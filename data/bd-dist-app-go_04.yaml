- en: 'Chapter 2: Setting Up API Endpoints'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：设置API端点
- en: In the previous chapter, we learned how to build our first Gin web application.
    In this one, we're going to build a complete RESTful API from scratch. Along the
    way, we will explore HTTP methods and advanced routing features. We'll also cover
    how to write the OpenAPI Specification and how to generate API documentation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何构建我们的第一个Gin网络应用程序。在这一章中，我们将从头开始构建一个完整的RESTful API。在这个过程中，我们将探索HTTP方法和高级路由功能。我们还将介绍如何编写OpenAPI规范以及如何生成API文档。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Exploring API functionality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索API功能
- en: Implementing HTTP routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现HTTP路由
- en: Writing the OpenAPI Specification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写OpenAPI规范
- en: By the end of this chapter, you'll be familiar with the routing mechanisms of
    Gin, HTTP methods, and data validation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉Gin的路由机制、HTTP方法和数据验证。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you''ll need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章内容，你需要以下内容：
- en: A laptop (Windows, Linux, or macOS) with Golang version 1.15.6 set up so that
    you can easily execute the commands provided
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台装有Golang版本1.15.6的笔记本电脑（Windows、Linux或macOS），以便您可以轻松执行提供的命令
- en: A general understanding of the RESTful API and the Go programming language
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对RESTful API和Go编程语言的一般理解
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包托管在GitHub上，网址为[https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter02)
- en: Exploring API functionality
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索API功能
- en: 'To illustrate how to build a RESTful API, we will build a cooking application.
    We will cover how to integrate, deploy, and test the app using the Gin framework.
    The application will do the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何构建RESTful API，我们将构建一个烹饪应用程序。我们将介绍如何使用Gin框架集成、部署和测试应用程序。该应用程序将执行以下操作：
- en: Display the recipes that are submitted by the users, along with their ingredients
    and instructions.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户提交的食谱，包括它们的成分和说明。
- en: Allow anyone to post a new recipe.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许任何人发布新的食谱。
- en: 'The application architecture and flow are shown in the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序架构和流程如下所示：
- en: '![Figure 2.1 – Recipes application architecture'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 食谱应用程序架构]'
- en: '](img/B17115_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_02_01.jpg]'
- en: Figure 2.1 – Recipes application architecture
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 食谱应用程序架构
- en: The architecture is composed of a microservice written with the Gin framework
    and a database for data persistency. The microservice exposes a RESTful API to
    manage the recipes through the HTTP protocol.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 架构由一个使用Gin框架编写的微服务和用于数据持久性的数据库组成。该微服务通过HTTP协议公开RESTful API来管理食谱。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Later in this book, we will cover how to build a frontend application with the
    React web framework so that we can consume the RESTful API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将介绍如何使用React网络框架构建前端应用程序，以便我们可以消费RESTful API。
- en: 'Before we get started, we need to create a GitHub repository where the code
    source will be stored. To structure the code within Git branches, we will use
    the GitFlow model. This approach consists of the following branches:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要创建一个GitHub仓库，代码源将存储在那里。为了在Git分支中组织代码，我们将使用GitFlow模型。这种方法包括以下分支：
- en: '**master**: This branch corresponds to the current production code. You can''t
    commit directly, except for hotfixes. Git tags can be used to tag all the commits
    in the master branch with a version number (for instance, for using the semantic
    versioning convention, [https://semver.org/](https://semver.org/), which has three
    parts: major, minor, and patch, so a tag with version 1.2.3 has 1 as its major
    version, 2 as its minor version, and 3 as its patch version).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**master**：这个分支对应于当前的生产代码。除了热修复之外，您不能直接提交。可以使用Git标签来标记master分支中的所有提交，并使用版本号（例如，为了使用语义版本控制约定[https://semver.org/](https://semver.org/)，它有三个部分：主要版本、次要版本和补丁版本，因此版本1.2.3的主要版本是1，次要版本是2，补丁版本是3）。'
- en: '**preprod**: This is a release branch and is a mirror of production. It can
    be used to test all the new features that are developed on the develop branch
    before they are merged to the master branch.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**preprod**：这是一个发布分支，是生产的镜像。在它们合并到master分支之前，可以用来测试在develop分支上开发的全部新功能。'
- en: '**develop**: This is the development integration branch, which contains the
    latest integrated development code.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**develop**：这是开发集成分支，包含最新的集成开发代码。'
- en: '**feature/X**: This is an individual feature branch that''s being developed.
    Each new feature resides in its own branch, and they''re generally created for
    the latest develop branch.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**feature/X**：这是一个正在开发的个人功能分支。每个新功能都位于自己的分支中，并且通常是为最新的开发分支创建的。'
- en: '**hotfix/X**: When you need to solve something in production code, you can
    use the hotfix branch and open a pull request for the master branch. This branch
    is based on the master branch.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hotfix/X**：当你需要在生产代码中解决问题时，你可以使用hotfix分支并为master分支打开一个拉取请求。这个分支基于master分支。'
- en: 'The following schema illustrates the GitFlow approach:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构说明了GitFlow方法：
- en: '![Figure 2.2 – GitFlow model – main branches'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – GitFlow模型 – 主要分支'
- en: '](img/B17115_02_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_02.jpg)'
- en: Figure 2.2 – GitFlow model – main branches
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – GitFlow模型 – 主要分支
- en: 'Once the GitHub repository has been created, clone it to your Go workspace
    and create three main branches called `develop`, `preprod`, and `master` . This
    will help you organize the project and isolate the code under development from
    the code running in production. This branching strategy is a slimmer version of
    the GitFlow workflow branching model (don''t forget to replace the GitHub URL
    with a link to your repository):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了GitHub仓库，克隆它到你的Go工作区，并创建三个主要分支，分别称为`develop`、`preprod`和`master`。这将帮助你组织项目并将开发中的代码与运行在生产中的代码隔离开。这种分支策略是GitFlow工作流程分支模型的简化版本（不要忘记将GitHub
    URL替换为你的仓库链接）：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create a new directory called `recipes-api`. Let''s make this directory
    the root of a module by executing the following command. This will enable us to
    manage project dependencies with the `go.mod` and `go.sum` files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`recipes-api`的新目录。让我们通过执行以下命令将此目录作为模块的根目录。这将使我们能够使用`go.mod`和`go.sum`文件来管理项目依赖项：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the project folder on VSCode and create a `main.go` file with the following
    code. The `main` function will initialize a new Gin router and run an HTTP server
    on port `8080` by invoking the `Run()` method of our Gin instance:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode上打开项目文件夹，创建一个包含以下代码的`main.go`文件。`main`函数将初始化一个新的Gin路由器，并通过调用我们的Gin实例的`Run()`方法在端口`8080`上运行一个HTTP服务器：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that you install the `gin` package with the `go get` command. Refer
    to the previous chapter for a step-by-step guide.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`go get`命令安装`gin`包。请参阅上一章以获取逐步指南。
- en: 'Push the changes to the Git remote repository. For now, we will push the changes
    directly to the `develop` branch. We will learn how to open pull requests in the
    next section:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到Git远程仓库。目前，我们将直接将更改推送到`develop`分支。我们将在下一节学习如何打开拉取请求：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The updated repository should look as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的仓库应如下所示：
- en: '![Figure 2.3 – GitHub branches'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – GitHub分支'
- en: '](img/B17115_02_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_03.jpg)'
- en: Figure 2.3 – GitHub branches
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – GitHub分支
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're working with a team of developers, you will need to issue the `go
    mod download` command to install the required dependencies after cloning the project
    from GitHub.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在与一组开发者合作，你需要在从GitHub克隆项目后，使用`go mod download`命令来安装所需的依赖项。
- en: In the next sub-section, we'll see how you can define the data model.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将看到如何定义数据模型。
- en: Defining the data model
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据模型
- en: 'Before digging into the routes definition, we need to define a model that will
    hold information about a recipe. We can create our model by defining a Go struct.
    This model will contain the properties/fields of a recipe. Declare the following
    struct in the `main.go` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究路由定义之前，我们需要定义一个将保存有关食谱信息的模型。我们可以通过定义一个Go结构体来创建我们的模型。此模型将包含食谱的属性/字段。在`main.go`文件中声明以下结构体：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `Recipe` model is self-explanatory. Each recipe should have a name, a list
    of ingredients, a list of instructions or steps, and a publication date. Moreover,
    each recipe belongs to a set of categories or tags (for example, vegan, Italian,
    pastry, salads, and so on), as well as an ID, which is a unique identifier to
    differentiate each recipe in the database. We will also specify the tags on each
    field using backtick annotation; for example, `` `json:"NAME"` ``. This allows
    us to map each field to a different name when we send them as responses, since
    JSON and Go have different naming conventions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Recipe`模型是自我解释的。每个食谱都应该有一个名称、一个配料清单、一个指令或步骤列表，以及一个发布日期。此外，每个食谱属于一组类别或标签（例如，纯素、意大利菜、糕点、沙拉等），以及一个ID，这是在数据库中区分每个食谱的唯一标识符。我们还将使用反引号注释指定每个字段的标签；例如，``
    `json:"NAME"` ``。这允许我们在将它们作为响应发送时将每个字段映射到不同的名称，因为JSON和Go有不同的命名约定。
- en: 'Once the struct has been defined, push the changes to a new branch based on
    the `develop` branch:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了结构体，就将更改推送到基于`develop`分支的新分支：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you''ve pushed these changes to your repository, the `feature/datamodel`
    with the `develop` branch:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将这些更改推送到您的仓库，`feature/datamodel`将与`develop`分支合并：
- en: '![Figure 2.4 – GitHub pull request'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – GitHub拉取请求]'
- en: '](img/B17115_02_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17115_02_04.jpg)'
- en: Figure 2.4 – GitHub pull request
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – GitHub拉取请求
- en: 'Merge the changes to the `develop` branch and delete the `feature/datamodel`
    branch:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改合并到`develop`分支并删除`feature/datamodel`分支：
- en: '![Figure 2.5 – Merging the pull request into the develop branch'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 将拉取请求合并到develop分支]'
- en: '](img/B17115_02_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17115_02_05.jpg)'
- en: Figure 2.5 – Merging the pull request into the develop branch
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 将拉取请求合并到develop分支
- en: With the data model defined, we can look at the route handler definitions. The
    API will expose various endpoints. Let's take a look at them now.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了数据模型之后，我们可以查看路由处理器的定义。API将公开各种端点。现在让我们看看它们。
- en: HTTP endpoints
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP端点
- en: 'The following table shows the list of HTTP endpoints that we can use:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们可以使用的HTTP端点列表：
- en: '![](img/011.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/011.jpg)'
- en: Now, we are going to establish the endpoints of our API. We will set this up
    by creating all our endpoints in the `main` function. Every endpoint needs a separate
    function to handle the request. We will define them in the `main.go` file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将建立我们API的端点。我们将通过在`main`函数中创建所有端点来设置这些端点。每个端点都需要一个单独的函数来处理请求。我们将在`main.go`文件中定义它们。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter, we will cover how to structure the Go project according
    to the standard Go layout.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何根据标准的Go布局来构建Go项目。
- en: Implementing HTTP routes
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP路由
- en: In this section, we will create function handlers to handle POST, GET, PUT,
    and DELETE HTTP requests. So, let's jump right into it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建处理POST、GET、PUT和DELETE HTTP请求的功能处理器。所以，让我们直接进入正题。
- en: POST /recipes
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST /recipes
- en: 'First, let''s implement the endpoint responsible for creating a new recipe.
    Create a POST method on the `/recipes` resource. Then, define a `NewRecipeHandler`
    method for that path. The `main.go` file should look something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们实现负责创建新食谱的端点。在`/recipes`资源上创建一个POST方法。然后，为该路径定义一个`NewRecipeHandler`方法。`main.go`文件可能看起来像这样：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before writing the code of the `NewRecipeHandler` method, we need to define
    a global variable called `recipes` to store the list of recipes. This variable
    will be used temporarily and will be replaced in the next chapter with a database
    for data persistency. To initialize the `recipes` variable, we can use the `init()`
    method, which will be executed during the startup of the application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`NewRecipeHandler`方法的代码之前，我们需要定义一个名为`recipes`的全局变量来存储食谱列表。这个变量将临时使用，并在下一章中用数据库替换。为了初始化`recipes`变量，我们可以使用`init()`方法，该方法将在应用程序启动时执行：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we will define the logic behind `NewRecipeHandler`. The `c.ShouldBindJSON`
    function marshals the incoming request body into a `Recipe` struct and then assigns
    a unique identifier with an external package called `xid`. Next, it assigns a
    publication date with the `time.Now()` function and appends the recipe to the
    list of recipes, which will keep it in memory. If the request body is invalid,
    then the handler will return an error (400 status code). Otherwise, the handler
    will return a 200 status code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义 `NewRecipeHandler` 背后的逻辑。`c.ShouldBindJSON` 函数将传入的请求体序列化到 `Recipe`
    结构体中，然后使用名为 `xid` 的外部包分配一个唯一的标识符。接下来，它使用 `time.Now()` 函数分配一个发布日期，并将食谱添加到食谱列表中，这将将其保留在内存中。如果请求体无效，则处理程序将返回一个错误（400
    状态码）。否则，处理程序将返回 200 状态码：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous code, we used a built-in status code constants such as `http.StatusOK`
    and `http.StatusBadRequest` instead of a hardcoded HTTP status code. We're also
    setting the response type to JSON.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了内置的状态码常量，如 `http.StatusOK` 和 `http.StatusBadRequest`，而不是硬编码的 HTTP
    状态码。我们还将响应类型设置为 JSON。
- en: 'Before running the application, we need to download the `xid` package, which
    is used to generate a unique ID:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，我们需要下载用于生成唯一 ID 的 `xid` 包：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The new dependency will be added automatically to the `go.sum` and `go.mod`
    files. Run the server, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 新的依赖项将自动添加到 `go.sum` 和 `go.mod` 文件中。按照以下方式运行服务器：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'An HTTP server will be deployed on port `8080`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将在端口 `8080` 上部署一个 HTTP 服务器：
- en: '![Figure 2.6 – Gin server logs'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – Gin 服务器日志'
- en: '](img/B17115_02_06.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_06.jpg](img/B17115_02_06.jpg)'
- en: Figure 2.6 – Gin server logs
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – Gin 服务器日志
- en: 'To test it out, issue a POST request with the Postman client at http://localhost:8080/recipes
    with the following JSON in the request body:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，使用 Postman 客户端在 http://localhost:8080/recipes 上发送 POST 请求，请求体中包含以下 JSON：
- en: '![Figure 2.7 – Issuing a POST request with the Postman client'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – 使用 Postman 客户端发送 POST 请求'
- en: '](img/B17115_02_07.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_07.jpg](img/B17115_02_07.jpg)'
- en: Figure 2.7 – Issuing a POST request with the Postman client
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 使用 Postman 客户端发送 POST 请求
- en: The preceding command will add the recipe to the array of recipes and return
    it with an assigned ID and publication date.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将食谱添加到食谱数组中，并返回带有分配的 ID 和发布日期的食谱。
- en: 'Another alternative to Postman is to use the `cURL` command. Use the following
    `cURL` command with the `POST` verb, followed by a JSON document:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 的另一个替代方案是使用 `cURL` 命令。使用以下 `cURL` 命令，后跟 JSON 文档，使用 `POST` 动词：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `jq` utility [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
    is used to format the response body in JSON format. It's a powerful command-line
    JSON processor.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq` 工具 [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/) 用于以
    JSON 格式格式化响应体。它是一个功能强大的命令行 JSON 处理器。'
- en: 'With the POST endpoint working as expected, we can push the code changes to
    a new feature branch:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 POST 端点按预期工作，我们可以将代码更改推送到一个新的功能分支：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once committed, raise a pull request to merge the `feature/new_recipe` branch
    with the `develop` branch:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交，请发起一个拉取请求，将 `feature/new_recipe` 分支与 `develop` 分支合并：
- en: '![Figure 2.8 – Merging a new recipe endpoint feature branch into the develop
    branch'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 将新食谱端点功能分支合并到 develop 分支'
- en: '](img/B17115_02_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_08.jpg](img/B17115_02_08.jpg)'
- en: Figure 2.8 – Merging a new recipe endpoint feature branch into the develop branch
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 将新食谱端点功能分支合并到 develop 分支'
- en: Make sure to delete the feature branch once the changes have been merged.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改已合并，请确保删除功能分支。
- en: Now that the `POST /recipes` endpoint has been created, we can implement a `GET
    /recipes` endpoint to list all the recipes we have added using the `POST/recipes`
    endpoint.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`POST /recipes` 端点已创建，我们可以实现一个 `GET /recipes` 端点，以列出使用 `POST/recipes` 端点添加的所有食谱。
- en: GET /recipes
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET /recipes
- en: 'Similar to the previous endpoint, register a `GET` method on the `/recipes`
    resource and attach `ListRecipesHandler`. The function will be invoked when an
    incoming GET request is received on the `/recipes` resource. The code is straightforward;
    it marshals the `recipes` array to JSON with the `c.JSON()` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的端点类似，在 `/recipes` 资源上注册一个 `GET` 方法并附加 `ListRecipesHandler`。当在 `/recipes`
    资源上接收到传入的 GET 请求时，将调用该函数。代码很简单；它使用 `c.JSON()` 方法将 `recipes` 数组序列化为 JSON：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Redeploy the app with the `go run main.go` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go run main.go` 命令重新部署应用程序：
- en: '![Figure 2.9 – Exposing a GET endpoint'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 暴露 GET 端点'
- en: '](img/B17115_02_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_09.jpg](img/B17115_02_09.jpg)'
- en: Figure 2.9 – Exposing a GET endpoint
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 暴露 GET 端点'
- en: 'To test the endpoint, issue a GET request on `http://localhost:8080/recipes`.
    Here, an empty array will be returned:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试端点，向 `http://localhost:8080/recipes` 发起 GET 请求。这里，将返回一个空数组：
- en: '![Figure 2.10 – Fetching a list of recipes'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.10 – 获取食谱列表'
- en: '](img/B17115_02_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_10.jpg)'
- en: Figure 2.10 – Fetching a list of recipes
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 获取食谱列表
- en: 'The corresponding `cURL` command is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的 `cURL` 命令如下：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The empty array is due to the fact the `recipes` variable is only available
    during the runtime of the application. In the next chapter, we will cover how
    to connect the RESTful API to a database such as MongoDB for data persistency.
    But for now, we can initialize the `recipes` array upon starting the application
    by placing the initialization code in the `init()` method.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 空数组是由于 `recipes` 变量仅在应用程序运行时可用。在下一章中，我们将介绍如何将 RESTful API 连接到数据库，如 MongoDB 以实现数据持久性。但到目前为止，我们可以在启动应用程序时通过在
    `init()` 方法中放置初始化代码来初始化 `recipes` 数组。
- en: 'The loading mechanism will be based on a JSON file that contains a list of
    recipes that I have created in advance. The complete list is available in this
    book''s GitHub repository:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 加载机制将基于一个包含我预先创建的食谱列表的 JSON 文件。完整的列表可在本书的 GitHub 仓库中找到：
- en: '![Figure 2.11 – List of recipes in JSON format'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.11 – 食谱列表的 JSON 格式'
- en: '](img/B17115_02_11.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_11.jpg)'
- en: Figure 2.11 – List of recipes in JSON format
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 食谱列表的 JSON 格式
- en: 'We will read the JSON file with the `ioutil.ReadFile()` method and then convert
    the content into an array of recipes with the following code snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `ioutil.ReadFile()` 方法读取 JSON 文件，然后使用以下代码片段将其内容转换为食谱数组：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Don''t forget to import `encoding/json` and `io/ioutil` before you rerun the
    application and issue a GET request on the `/recipes` endpoint. This time, a list
    of recipes will be returned in JSON format:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在重新运行应用程序并发出对 `/recipes` 端点的 GET 请求之前导入 `encoding/json` 和 `io/ioutil`。这次，将以
    JSON 格式返回食谱列表：
- en: '![Figure 2.12 – GET /recipes returning a list of recipes'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.12 – GET /recipes 返回食谱列表'
- en: '](img/B17115_02_12.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_12.jpg)'
- en: Figure 2.12 – GET /recipes returning a list of recipes
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – GET /recipes 返回食谱列表
- en: 'You can use the `curl` and `jq` commands to count the number of recipes that
    are returned by the request:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `curl` 和 `jq` 命令来计算请求返回的食谱数量：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `recipes.json` file contains 492 recipes; therefore, the HTTP request should
    return 492 recipes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipes.json` 文件包含 492 个食谱；因此，HTTP 请求应返回 492 个食谱：'
- en: '![Figure 2.13 – Using jq to count JSON items'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.13 – 使用 jq 计算JSON项'
- en: '](img/B17115_02_13.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_13.jpg)'
- en: Figure 2.13 – Using jq to count JSON items
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 使用 jq 计算JSON项
- en: 'Commit the new endpoint code to Git by creating a new feature branch with the
    following commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建以下命令创建一个新的功能分支并将新端点代码提交到 Git：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the changes have been pushed, create a pull request and merge the branch
    into `develop`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改已推送，创建一个拉取请求并将分支合并到 `develop`：
- en: '![Figure 2.14 – Merging the list of recipes endpoint feature branch into the
    develop branch'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.14 – 将食谱列表端点功能分支合并到 develop 分支'
- en: '](img/B17115_02_14.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_02_14.jpg)'
- en: Figure 2.14 – Merging the list of recipes endpoint feature branch into the develop
    branch
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 将食谱列表端点功能分支合并到 develop 分支
- en: PUT /recipes/{id}
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PUT /recipes/{id}
- en: 'To update an existing recipe, we will use the `PUT` verb with a path query
    parameter called ID, representing the identifier of the recipe to be updated.
    Register an endpoint on the `/recipes/:id` resource inside your main function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新现有食谱，我们将使用带有路径查询参数 ID 的 `PUT` 动词，该参数代表要更新的食谱的标识符。在主函数内部注册 `/recipes/:id`
    资源的端点：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `UpdateRecipeHandler` endpoint''s handler code is provided in the following
    snippet. It fetches the recipe ID from the request URL with the `c.Param()` method,
    converts the request body into a `Recipe` struct, and loops through the list of
    recipes, looking for the recipe to update. If it''s not found, an error message
    is sent with a 404 code error; otherwise, the recipe is updated with the new values
    from the request body:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateRecipeHandler` 端点的处理代码如下片段提供。它使用 `c.Param()` 方法从请求 URL 中获取食谱 ID，将请求体转换为
    `Recipe` 结构体，并遍历食谱列表，寻找要更新的食谱。如果没有找到，则发送带有 404 代码错误的错误消息；否则，使用请求体中的新值更新食谱：'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Relaunch the server, then issue a POST request to create a new recipe. To illustrate
    how the update endpoint is working, we will create a recipe for a margherita pizza
    with the following sample JSON:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器，然后发出 POST 请求以创建新食谱。为了说明更新端点的工作原理，我们将创建一个 margherita 食谱的以下示例 JSON：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To test it out, once again with the Postman client, issue a new POST request
    on `http://localhost:8080/recipes` with this JSON document:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，再次使用 Postman 客户端，在 `http://localhost:8080/recipes` 上发出一个新的 POST 请求，使用此
    JSON 文档：
- en: '![Figure 2.15 – Adding a new recipe'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.15 – 添加新食谱]'
- en: '](img/B17115_02_15.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_15.jpg]'
- en: Figure 2.15 – Adding a new recipe
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 添加新食谱
- en: 'The `Homemade Pizza` recipe will be created, and you will have received the
    ID of the new recipe (in our example, it is `c2inb6q3k1kc2p0uqetg`). Let''s say
    we want to update the recipe and change it to `Shrimp scampi pizza`. This time,
    we can use the `PUT` method and provide the ID of the recipe as a `path` parameter:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建 `Homemade Pizza` 食谱，并且您将收到新食谱的 ID（在我们的示例中，它是 `c2inb6q3k1kc2p0uqetg`）。假设我们想更新食谱并将其更改为
    `Shrimp scampi pizza`。这次，我们可以使用 `PUT` 方法并提供食谱的 ID 作为 `path` 参数：
- en: '![Figure 2.16 – Updating an existing recipe'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.16 – 更新现有食谱]'
- en: '](img/B17115_Figure_2.16.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_Figure_2.16.jpg]'
- en: Figure 2.16 – Updating an existing recipe
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 更新现有食谱
- en: 'The request will return a 200 status code. To verify that the changes have
    taken effect, we can use the `GET /recipes` endpoint:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将返回 200 状态码。为了验证更改是否生效，我们可以使用 `GET /recipes` 端点：
- en: '![Figure 2.17 – Verifying the changes are being applied to the recipe'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.17 – 验证更改是否应用于食谱]'
- en: '](img/B17115_Figure_2.17.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_Figure_2.17.jpg]'
- en: Figure 2.17 – Verifying the changes are being applied to the recipe
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 验证更改是否应用于食谱
- en: 'Push the new endpoint to a new feature branch and merge the branch into `develop`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将新端点推送到一个新的功能分支，并将分支合并到 `develop`：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: DELETE /recipes/{id}
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DELETE /recipes/{id}
- en: 'To delete a recipe, we need to register the `DELETE` HTTP route inside our
    main function, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除食谱，我们需要在我们的主函数中注册 `DELETE` HTTP 路由，如下所示：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `DeleteRecipeHandler` function''s code will get the target recipe ID from
    the request parameter and loop through the list of recipes. If no matching recipe
    is found, an error message of `"Recipe not found"` will be sent with a 404 status
    code. Otherwise, the recipe index on the array will be used and the recipe will
    be deleted based on the index:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteRecipeHandler` 函数的代码将从请求参数中获取目标食谱 ID 并遍历食谱列表。如果没有找到匹配的食谱，将使用 404 状态码发送
    `"Recipe not found"` 错误消息。否则，将使用数组上的食谱索引并基于索引删除食谱：'
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To test the delete endpoint, use the Postman client or issue a `cURL` command
    in the terminal session:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试删除端点，请使用 Postman 客户端或在终端会话中发出 `cURL` 命令：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the target recipe exists, then it will be deleted, and you will see that
    a success message is returned:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标食谱存在，则它将被删除，并且您将看到返回成功消息：
- en: '![Figure 2.18 – Deleting a recipe'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.18 – 删除食谱]'
- en: '](img/B17115_02_18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_18.jpg]'
- en: Figure 2.18 – Deleting a recipe
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 删除食谱
- en: 'Otherwise, an error message will be returned:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，将返回错误消息：
- en: '![Figure 2.19 – An error 404 message is returned if the recipe is not found'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.19 – 如果找不到食谱，将返回错误 404 信息]'
- en: '](img/B17115_02_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_19.jpg]'
- en: Figure 2.19 – An error 404 message is returned if the recipe is not found
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 如果找不到食谱，将返回错误 404 信息
- en: 'Once again, store the changes in a feature branch and merge the changes into
    `develop`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，将更改存储在功能分支中，并将其合并到 `develop`：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: GET /recipes/search
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET /recipes/search
- en: 'The final endpoint allows users to search for recipes based on tags or keywords:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个端点允许用户根据标签或关键词搜索食谱：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `SearchRecipesHandler` handler code snippet is as follows (don''t forget
    to import `strings`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchRecipesHandler` 处理器代码片段如下（不要忘记导入 `strings`）：'
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The HTTP handler fetches the tag value given in the query parameter with the
    `c.Query` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 处理器使用 `c.Query` 方法获取查询参数中给出的标签值。
- en: 'You can test the endpoint by looking for Italian recipes with a GET request
    at [http://localhost:8080/recipes/search?tag=italian](http://localhost:8080/recipes/search?tag=italian):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 [http://localhost:8080/recipes/search?tag=italian](http://localhost:8080/recipes/search?tag=italian)
    发出 GET 请求来测试端点，查找意大利食谱：
- en: '![Figure 2.20 – Searching for recipes with a query parameter'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.20 – 使用查询参数搜索食谱]'
- en: '](img/B17115_02_20.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_02_20.jpg]'
- en: Figure 2.20 – Searching for recipes with a query parameter
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 使用查询参数搜索食谱
- en: 'Finally, push the search endpoint code to the remote repository by creating
    a new feature branch:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过创建一个新的功能分支将搜索端点代码推送到远程仓库：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before each commit, make sure to run the `go mod tidy` command to ensure your
    `go.mod` and `go.sum` files are clean and accurate.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次提交之前，请确保运行 `go mod tidy` 命令以确保你的 `go.mod` 和 `go.sum` 文件干净且准确。
- en: So far, we have covered how to build a RESTful API in Golang with the Gin framework.
    However, without meaningful documentation of the API, users won't be able to use
    it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何使用 Gin 框架在 Golang 中构建 RESTful API。然而，如果没有有意义的 API 文档，用户将无法使用它。
- en: Documentation should be part of your development cycle, to help you maintain
    a scalable API. That's why, in the next section, we will explore how to use the
    **OpenAPI Specification** (**OAS**).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 文档应该成为你开发周期的一部分，以帮助你维护可扩展的 API。这就是为什么在下一节中，我们将探讨如何使用 **OpenAPI 规范**（**OAS**）。
- en: Writing the OpenAPI Specification
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 OpenAPI 规范
- en: 'The OpenAPI Specification (formerly known as the Swagger Specification) is
    an API description format or API definition language. It allows you to describe
    an API, including the following information:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范（以前称为 Swagger 规范）是一种 API 描述格式或 API 定义语言。它允许你描述一个 API，包括以下信息：
- en: General information about the API
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 API 的一般信息
- en: The available paths and operations (HTTP methods)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的路径和操作（HTTP 方法）
- en: The expected inputs (query or path parameters, request body, and so on) and
    responses (HTTP status code, response body, and so on) for each operation
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作的预期输入（查询或路径参数、请求体等）和响应（HTTP 状态码、响应体等）
- en: Finding an easy way to generate the OpenAPI definition from an existing API
    can be challenging. The good news is that Swagger tools can help you do this with
    ease.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有的 API 中找到一种简单的方法来生成 OpenAPI 定义可能具有挑战性。好消息是 Swagger 工具可以帮助你轻松完成这项任务。
- en: Installing Go Swagger
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Go Swagger
- en: 'To get started, install the `go-swagger` tool from the official guide at [https://goswagger.io/install.html](https://goswagger.io/install.html)
    or download the binary from GitHub at [https://github.com/go-swagger/go-swagger/releases](https://github.com/go-swagger/go-swagger/releases).
    At the time of writing this book, the latest stable version is v0.25.0:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请从官方指南 [https://goswagger.io/install.html](https://goswagger.io/install.html)
    安装 `go-swagger` 工具或从 GitHub [https://github.com/go-swagger/go-swagger/releases](https://github.com/go-swagger/go-swagger/releases)
    下载二进制文件。在撰写本书时，最新稳定版本是 v0.25.0：
- en: '![Figure 2.21 – Go Swagger binary – latest release'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.21 – Go Swagger binary – latest release]'
- en: '](img/B17115_02_21.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_02_21.jpg]'
- en: Figure 2.21 – Go Swagger binary – latest release
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.21 – Go Swagger binary – latest release]'
- en: 'Make sure to add it to the `PATH` environment variable. Then, issue the following
    command to verify the installation:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将其添加到 `PATH` 环境变量中。然后，运行以下命令以验证安装：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding command should display the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令应该显示以下输出：
- en: '![Figure 2.22 – Go Swagger version'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.22 – Go Swagger version]'
- en: '](img/B17115_02_22.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_02_22.jpg]'
- en: Figure 2.22 – Go Swagger version
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – Go Swagger 版本
- en: Now, it's time to write our OpenAPI Specification for the recipes API.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为食谱 API 编写我们的 OpenAPI 规范了。
- en: Note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative to `go-swagger` is `swag` ([https://github.com/swaggo/swag](https://github.com/swaggo/swag)).
    This tool can be used to convert Go annotations into Swagger documentation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-swagger` 的一个替代方案是 `swag` ([https://github.com/swaggo/swag](https://github.com/swaggo/swag)).
    这个工具可以将 Go 注释转换为 Swagger 文档。'
- en: Swagger metadata
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger 元数据
- en: 'We''ll start by providing some basic information about the API with the `swagger:meta`
    annotation. This annotation has the following properties:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 `swagger:meta` 注解提供一些关于 API 的基本信息。这个注解有以下属性：
- en: '![](img/02.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![img/02.jpg]'
- en: 'Add the following comments at the top of the `main` package:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 包的顶部添加以下注释：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These comments include things such as the API's description, version, base URL,
    and so on. There are more fields that you can include (a full list is available
    at [https://goswagger.io/use/spec/meta.html](https://goswagger.io/use/spec/meta.html)).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释包括 API 的描述、版本、基本 URL 等内容。还有更多字段可以包含（完整列表可在 [https://goswagger.io/use/spec/meta.html](https://goswagger.io/use/spec/meta.html)
    找到）。
- en: To generate the OpenAPI Specification, we will use the `swagger` command-line
    tool. The CLI will parse the `main.go` file. If the parser encounters a comment
    that matches the Swagger annotation or any supported tags, it will generate the
    corresponding block of the specification.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成OpenAPI规范，我们将使用`swagger`命令行工具。CLI将解析`main.go`文件。如果解析器遇到与Swagger注释或任何支持的标签匹配的注释，它将生成相应的规范块。
- en: 'On your Terminal, issue the following command to generate a `spec` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中，运行以下命令以生成`spec`文件：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command will generate the specification in JSON format. You can generate
    the spec in YAML format as well by just appending the output with the `.yml` or
    `.yaml` extension.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成JSON格式的规范。您也可以通过添加`.yml`或`.yaml`扩展名来生成YAML格式的规范。
- en: 'The content of the generated `swagger.json` file will look as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`swagger.json`文件内容如下：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another cool thing with the Swagger command line is its embedded UI. You can
    load the generated spec in the Swagger UI locally with the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger命令行的另一个酷炫功能是其内置的UI。您可以使用以下命令在本地加载生成的规范到Swagger UI中：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The UI will be exposed on port `http://localhost:49566`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: UI将在端口`http://localhost:49566`上公开：
- en: '![Figure 2.23 – Loading the Swagger specs in the UI'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.23 – 在UI中加载Swagger规范'
- en: '](img/B17115_02_23.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B17115_02_23.jpg](img/B17115_02_23.jpg)'
- en: Figure 2.23 – Loading the Swagger specs in the UI
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 在UI中加载Swagger规范
- en: 'If you point your browser to that URL, you should see the UI based on the Redoc
    template. The UI comes in two two flavors – Redoc and the Swagger UI:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将浏览器指向该URL，您应该会看到基于Redoc模板的UI。UI有两种风味 – Redoc和Swagger UI：
- en: '![Figure 2.24 – Swagger with a Redoc flavor'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24 – 带有Redoc风格的Swagger'
- en: '](img/B17115_02_24.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B17115_02_24.jpg](img/B17115_02_24.jpg)'
- en: Figure 2.24 – Swagger with a Redoc flavor
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 – 带有Redoc风格的Swagger
- en: 'If you''re a fan of the Swagger UI, you can set the flavor flag to `swagger`
    with the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Swagger UI的粉丝，可以使用以下命令将flavor标志设置为`swagger`：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This time, the API specification will be served from the Swagger UI:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，API规范将由Swagger UI提供：
- en: '![Figure 2.25 – Swagger UI mode'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.25 – Swagger UI模式'
- en: '](img/B17115_02_25.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B17115_02_25.jpg](img/B17115_02_25.jpg)'
- en: Figure 2.25 – Swagger UI mode
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 – Swagger UI模式
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also use the Swagger Online Editor ([https://editor.swagger.io/](https://editor.swagger.io/))
    to edit and load your OpenAPI Specification file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Swagger在线编辑器([https://editor.swagger.io/](https://editor.swagger.io/))来编辑和加载您的OpenAPI规范文件。
- en: 'Next, we will define a `swagger:operation` for listing recipe endpoints. The
    annotation has the following attributes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为列出配方端点定义一个`swagger:operation`。该注释具有以下属性：
- en: '![](img/03.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03.jpg)'
- en: You can find all the properties at [https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject)找到所有属性。
- en: 'Annotate the `ListRecipesHandler` function, as shown here. The annotation takes
    the HTTP method, path pattern, and operation ID as parameters:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，注释`ListRecipesHandler`函数。该注释接受HTTP方法、路径模式和操作ID作为参数：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For each operation, you can describe the HTTP response that matches an HTTP
    status code (200, 404, and so on) in the `responses` section. For this endpoint,
    we'll only return a 200 success code when responding to `GET` /`recipes`. The
    `description` field explains what this response means.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个操作，您可以在`responses`部分中描述与HTTP状态代码（200、404等）匹配的HTTP响应。对于此端点，当响应`GET /recipes`时，我们只会返回200成功代码。`description`字段解释了此响应的含义。
- en: 'Generate the specification with the Swagger CLI and reload `swagger.json`.
    This time, the `GET` /recipes operation will be added:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Swagger CLI生成规范并重新加载`swagger.json`。这次，将添加`GET /recipes`操作：
- en: '![Figure 2.26 – Adding a new Swagger operation'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.26 – 添加新的Swagger操作'
- en: '](img/B17115_02_26.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B17115_02_26.jpg](img/B17115_02_26.jpg)'
- en: Figure 2.26 – Adding a new Swagger operation
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 – 添加新的Swagger操作
- en: 'Define another Swagger operation for the `PUT /recipes/{id}` endpoint. Similar
    to the previous operation, we can define responses based on the handled response
    code. We can also define the ID as a `path` parameter in the `parameters` section.
    As well as provide an optional description, as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为`PUT /recipes/{id}`端点定义另一个Swagger操作。类似于之前的操作，我们可以根据处理响应代码定义响应。我们还可以在`parameters`部分中将ID定义为`path`参数。此外，还可以提供可选的描述，如下所示：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Regenerate the `swagger.json` file and reload the Swagger UI:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 重新生成 `swagger.json` 文件并重新加载 Swagger UI：
- en: '![Figure 2.27 – PUT operation in Swagger'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.27 – Swagger 中的 PUT 操作'
- en: '](img/B17115_02_27.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_02_27.jpg](img/B17115_02_27.jpg)'
- en: Figure 2.27 – PUT operation in Swagger
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – Swagger 中的 PUT 操作
- en: 'Define the rest of the operations. You should have something similar to the
    following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 定义剩下的操作。你应该有类似以下的内容：
- en: '![Figure 2.28 – Recipes API operations'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.28 – 食谱 API 操作'
- en: '](img/B17115_02_28.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_02_28.jpg](img/B17115_02_28.jpg)'
- en: Figure 2.28 – Recipes API operations
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – 食谱 API 操作
- en: With that, you have learned the basics of the OpenAPI Specification.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学到了 OpenAPI 规范的基础。
- en: 'Being a simple JSON file, the OpenAPI Specification file can be shared and
    managed within any SCM, just like the application source code. Commit the `spec`
    file to GitHub with the following commands:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 OpenAPI 规范文件是一个简单的 JSON 文件，它可以在任何源代码管理工具（SCM）中共享和管理，就像应用程序源代码一样。使用以下命令将 `spec`
    文件提交到 GitHub：
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The updated repository will look as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的存储库将如下所示：
- en: '![Figure 2.29 – Storing the OpenAPI Specification on GitHub'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.29 – 在 GitHub 上存储 OpenAPI 规范'
- en: '](img/B17115_02_29.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_02_29.jpg](img/B17115_02_29.jpg)'
- en: Figure 2.29 – Storing the OpenAPI Specification on GitHub
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – 在 GitHub 上存储 OpenAPI 规范
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to build a RESTful API from scratch with the
    Gin framework. We also covered how to validate incoming HTTP requests with Gin
    data binding and validation methods. Then, we provided an introduction to the
    OpenAPI Specification and learned how to generate it from an existing API. You
    should now be familiar with exposing HTTP methods (GET, POST, DELETE, PUT, and
    so on) to handle HTTP requests.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Gin 框架从头开始构建 RESTful API。我们还介绍了如何使用 Gin 数据绑定和验证方法验证传入的 HTTP 请求。然后，我们介绍了
    OpenAPI 规范，并学习了如何从现有的 API 中生成它。你现在应该熟悉暴露 HTTP 方法（GET、POST、DELETE、PUT 等）以处理 HTTP
    请求。
- en: In the next chapter, we will use MongoDB as a NoSQL database to manage data
    persistency for our API.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 MongoDB 作为 NoSQL 数据库来管理 API 的数据持久性。
- en: Questions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the GitFlow strategy?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 GitFlow 策略？
- en: How can we define a data model in Go?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Go 中定义数据模型？
- en: How can we validate a POST request body in Gin?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Gin 中验证 POST 请求的正文？
- en: Define an API endpoint that can get one recipe by ID.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个可以通过 ID 获取一个食谱的 API 端点。
- en: Define a body parameter of the new recipe endpoint with OpenAPI.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 OpenAPI 定义新食谱端点的正文参数。
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Hands-On RESTful API Design Patterns and Best Practices*, by Harihara Subramanian,
    Pethuru Raj, Packt Publishing'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实践 RESTful API 设计模式和最佳实践*，由 Harihara Subramanian，Pethuru Raj，Packt 出版'
- en: '*DevOps with GIT(Flow) Jenkins, Artifactory, Sonar, ELK, JIRA [Video]*, by
    Nand Venegalla, Packt Publishing'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 GIT(Flow) Jenkins, Artifactory, Sonar, ELK, JIRA [视频]*，由 Nand Venegalla，Packt
    出版'
