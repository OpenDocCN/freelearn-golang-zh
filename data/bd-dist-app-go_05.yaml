- en: 'Chapter 3: Managing Data Persistence with MongoDB'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：使用 MongoDB 管理数据持久性
- en: In the previous chapter, we learned how to build a RESTful API with the Gin
    web framework. In this one, we will integrate MongoDB into the backend for data
    storage, and we will also cover how to optimize database queries with Redis as
    a caching layer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 Gin 网络框架构建 RESTful API。在本章中，我们将集成 MongoDB 到后端进行数据存储，同时也会介绍如何使用
    Redis 作为缓存层来优化数据库查询。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up MongoDB with Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 设置 MongoDB
- en: Configuring Go MongoDB driver
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Go MongoDB 驱动
- en: Implementing MongoDB queries & and CRUD operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 MongoDB 查询和 CRUD 操作
- en: Standard Go project layout
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准的 Go 项目布局
- en: Deploying Redis with Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 部署 Redis
- en: Optimizing API response time with caching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存优化 API 响应时间
- en: Performance benchmark with Apache Benchmark
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apache Benchmark 进行性能基准测试
- en: By the end of this chapter, you will be able to perform CRUD operations on a
    MongoDB database using Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用 Go 在 MongoDB 数据库上执行 CRUD 操作。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the content in this chapter, you will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章的内容，您将需要以下内容：
- en: You must have a complete understanding of the previous chapter since this chapter
    is a follow-up of the previous one; it will use the same source code. Hence, some
    snippets won't be explained to avoid repetition.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于本章是前一章的后续，因此您必须对前一章有完整理解；它将使用相同的源代码。因此，为了避免重复，一些代码片段将不会进行解释。
- en: Some knowledge of NoSQL concepts and MongoDB basic queries.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 NoSQL 概念和 MongoDB 基本查询有一定的了解。
- en: The code bundle for this chapter is hosted on GitHub at [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/tree/main/chapter03)。
- en: Running a MongoDB Server
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 MongoDB 服务器
- en: The API we've built so far is not connected to a database. For a real-world
    application, we need to use a form of data storage; otherwise, data will be lost
    if the API crashes or the server hosting the API goes down. MongoDB is one of
    the most popular NoSQL databases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的 API 还未连接到数据库。对于实际应用，我们需要使用某种形式的数据存储；否则，如果 API 崩溃或托管 API 的服务器宕机，数据将会丢失。MongoDB
    是最受欢迎的 NoSQL 数据库之一。
- en: 'The following schema shows how MongoDB will be integrated into the API architecture:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构图显示了 MongoDB 将如何集成到 API 架构中：
- en: '![Figure 3.1 – API architecture'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – API 架构'
- en: '](img/B17115_03_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – API 架构'
- en: Figure 3.1 – API architecture
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – API 架构
- en: 'Before we get started, we need to deploy a MongoDB server. There are plenty
    of deployment options:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要部署一个 MongoDB 服务器。有大量的部署选项：
- en: 'You can download the MongoDB Community Edition binary from the following URL:
    [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).
    Select a package based on your OS:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从以下网址下载 MongoDB 社区版二进制文件：[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)。根据您的操作系统选择一个软件包：
- en: '![Figure 3.2 – MongoDB Community Server'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – MongoDB 社区服务器'
- en: '](img/B17115_03_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – MongoDB 社区服务器'
- en: Figure 3.2 – MongoDB Community Server
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – MongoDB 社区服务器
- en: You can use the MongoDB as a Service solution, known as MongoDB Atlas ([https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)),
    to run a free 500 MB database on the cloud. You can deploy a fully managed MongoDB
    server on AWS, Google Cloud Platform, or Microsoft Azure.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用名为 MongoDB Atlas 的 MongoDB 作为服务解决方案（[https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas)），在云上运行一个免费的
    500 MB 数据库。您可以在 AWS、Google Cloud Platform 或 Microsoft Azure 上部署一个完全管理的 MongoDB
    服务器。
- en: You can run MongoDB locally with a containerization solution such as Docker.
    Multiple Docker images are available on DockerHub with a MongoDB server configured
    and ready to use out of the box.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Docker 等容器化解决方案在本地运行 MongoDB。DockerHub 上有多个 MongoDB 服务器配置好的 Docker 镜像，可以直接使用。
- en: I opted to go with Docker due to its popularity and simplicity in running ephemeral
    environments.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用 Docker，因为它在运行临时环境方面既受欢迎又简单。
- en: Installing Docker CE
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker CE
- en: Docker ([https://www.docker.com/get-started](https://www.docker.com/get-started))
    is an open source project that allows you to run, build, and manage containers.
    A container is like a separate OS, but not virtualized; it only contains the dependencies
    needed for that one application, which makes the container portable and deployable
    on-premises or on the cloud.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker ([https://www.docker.com/get-started](https://www.docker.com/get-started))
    是一个开源项目，它允许您运行、构建和管理容器。容器就像一个独立的操作系统，但不是虚拟化；它只包含一个应用程序所需的依赖项，这使得容器可移植，可以在本地或云上部署。
- en: 'The following diagram shows the main difference between containers and virtual
    machines in their architecture approach:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了容器和虚拟机在架构方法上的主要区别：
- en: '![Figure 3.3 – Virtual machines versus containers'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – 虚拟机与容器对比'
- en: '](img/B17115_03_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_03.jpg)'
- en: Figure 3.3 – Virtual machines versus containers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 虚拟机与容器对比
- en: Virtualization happens at the hardware level for virtual machines, while for
    containers, it happens at the application layer. Therefore, containers can share
    the OS kernel and libraries, which makes them very lightweight and resource-efficient
    (CPU, RAM, disk, and so on).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机在硬件级别进行虚拟化，而容器在应用层进行虚拟化。因此，容器可以共享操作系统内核和库，这使得它们非常轻量级且资源高效（CPU、RAM、磁盘等）。
- en: 'To get started, you need to install Docker Engine on your machine. Navigate
    to [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    and install Docker for your platform:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要在您的机器上安装 Docker 引擎。导航到 [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
    并为您的平台安装 Docker：
- en: '![Figure 3.4 – Docker installation'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – Docker 安装'
- en: '](img/B17115_03_04.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_04.jpg)'
- en: Figure 3.4 – Docker installation
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Docker 安装
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Mac users can also use the Homebrew utility to install Docker with the `brew
    install docker` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Mac 用户也可以使用 Homebrew 工具通过 `brew install docker` 命令安装 Docker。
- en: 'Follow the installation wizard and, once completed, verify that everything
    works fine by executing the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照安装向导进行操作，完成后，通过执行以下命令验证一切是否正常：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the time of writing this book, I''m using Docker **Community Edition** (**CE**)
    version 20.10.2, as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，我正在使用 Docker **社区版** (**CE**) 20.10.2 版本，如下截图所示：
- en: '![Figure 3.5 – Docker Community Edition (CE) version'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – Docker 社区版 (CE) 版本'
- en: '](img/B17115_03_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_05.jpg)'
- en: Figure 3.5 – Docker Community Edition (CE) version
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – Docker 社区版 (CE) 版本
- en: 'With Docker installed, you can deploy your first container. Issue the following
    command in your terminal session:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 后，您可以在终端会话中运行以下命令来部署您的第一个容器：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command will deploy a container based on the `hello-world` image.
    When the container runs, it will print a *Hello from Docker*! message and exit:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将基于 `hello-world` 镜像部署容器。当容器运行时，它将打印一条 *Hello from Docker*! 消息并退出：
- en: '![Figure 3.6 – Docker hello-world container'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – Docker hello-world 容器'
- en: '](img/B17115_03_06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_06.jpg)'
- en: Figure 3.6 – Docker hello-world container
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – Docker hello-world 容器
- en: Congratulations! You are now successfully running Docker.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已成功运行 Docker。
- en: Running a MongoDB container
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 MongoDB 容器
- en: 'MongoDB''s official image can be found on DockerHub ([https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)).
    There are numerous images available, each representing different versions of MongoDB.
    You can use the `latest` tag to find them; however, it''s recommended to specify
    the target version. At the time of writing this book, MongoDB 4.4.3 is the latest
    stable version. Execute the following command to deploy a container based on that
    version:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的官方镜像可以在 DockerHub 上找到 ([https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo))。有大量的镜像可供选择，每个镜像代表
    MongoDB 的不同版本。您可以使用 `latest` 标签来查找它们；然而，建议指定目标版本。在撰写本书时，MongoDB 4.4.3 是最新的稳定版本。执行以下命令以基于该版本部署容器：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will run a MongoDB container in detached mode (the `-d` flag).
    We're also mapping the container port to the host port so that we can access the
    database from the host level. Finally, we must create a new user and set that
    user's password through the `MONGO_INITDB_ROOT_USERNAME` and `MONGO_INITDB_ROOT_PASSWORD`
    environment variables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将以分离模式（`-d` 标志）运行 MongoDB 容器。我们还映射了容器端口到主机端口，以便我们可以从主机级别访问数据库。最后，我们必须创建一个新用户，并通过
    `MONGO_INITDB_ROOT_USERNAME` 和 `MONGO_INITDB_ROOT_PASSWORD` 环境变量设置该用户的密码。
- en: 'For now, the MongoDB credentials are in plain text. Another way of passing
    sensitive information via environment variables is by using Docker Secrets. If
    you''re running in Swarm mode, you can execute the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，MongoDB 凭据以纯文本形式存在。另一种通过环境变量传递敏感信息的方法是使用 Docker Secrets。如果您在 Swarm 模式下运行，可以执行以下命令：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker Swarm mode is natively integrated in Docker engine. It's a container
    orchestration platform used to build, deploy, and scale containers across a cluster
    of nodes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 模式原生集成在 Docker 引擎中。它是一个用于在节点集群中构建、部署和扩展容器的容器编排平台。
- en: This command will generate a random password for a MongoDB user and set it as
    a Docker secret.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为 MongoDB 用户生成一个随机密码并将其设置为 Docker 机密。
- en: 'Next, update the `docker run` command so that it uses the Docker Secret instead
    of the password in plain text:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 `docker run` 命令，使其使用 Docker 机密而不是纯文本中的密码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `docker run` command''s output is as follows. It downloads the image from
    DockerHub and creates an instance (container) from it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令的输出如下。它从 DockerHub 下载镜像并从中创建一个实例（容器）：'
- en: '![Figure 3.7 – Pulling a MongoDB image from DockerHub'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 从 DockerHub 拉取 MongoDB 镜像'
- en: '](img/B17115_03_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_07.jpg)'
- en: Figure 3.7 – Pulling a MongoDB image from DockerHub
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 从 DockerHub 拉取 MongoDB 镜像
- en: 'It''s worth mentioning that if you''re already running the MongoDB container,
    make sure that you remove it before executing the previous command; otherwise,
    you''ll receive a "Container already exists" error. To remove an existing container,
    issue the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果您已经运行了 MongoDB 容器，在执行前面的命令之前请确保将其删除；否则，您将收到“容器已存在”错误。要删除现有容器，请发出以下命令：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the container has been created, check the logs by typing the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器创建后，通过键入以下内容来检查日志：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The logs should display the MongoDB server''s health check:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 日志应显示 MongoDB 服务器的健康检查：
- en: '![Figure 3.8 – MongoDB container runtime logs'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – MongoDB 容器运行日志'
- en: '](img/B17115_03_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_08.jpg)'
- en: Figure 3.8 – MongoDB container runtime logs
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – MongoDB 容器运行日志
- en: Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s recommended that you use Docker volumes to map the `/data/db` directory
    within the container with the underlying host system. That way, if the MongoDB
    server fails or your laptop restarts, the data won''t be lost (data persistency).
    Create a data directory on the host system and mount the directory to the `/data/db`
    directory with the following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用 Docker 卷将容器内的 `/data/db` 目录映射到底层主机系统。这样，如果 MongoDB 服务器失败或您的笔记本电脑重启，数据不会丢失（数据持久性）。在主机系统上创建一个数据目录，并使用以下命令将其挂载到
    `/data/db` 目录：
- en: '`mkdir /home/data`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir /home/data`'
- en: '`docker run -d --name mongodb –v /home/data:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin
    -e MONGO_INITDB_ROOT_PASSWORD=password -p 27017:27017 mongo:4.4.3`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run -d --name mongodb –v /home/data:/data/db -e MONGO_INITDB_ROOT_USERNAME=admin
    -e MONGO_INITDB_ROOT_PASSWORD=password -p 27017:27017 mongo:4.4.3`'
- en: 'To interact with the MongoDB server, you can use the MongoDB shell to issue
    queries and view data on the command line. However, there is a better alternative:
    MongoDB Compass.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 MongoDB 服务器交互，您可以使用 MongoDB 壳来在命令行中发出查询并查看数据。然而，有一个更好的选择：MongoDB Compass。
- en: Installing MongoDB Compass
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MongoDB Compass
- en: MongoDB Compass is a GUI tool that allows you to easily build queries, understand
    your database schema, and analyze your indexes, all without having to know MongoDB's
    query syntax.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB Compass 是一个图形用户界面工具，它允许你轻松构建查询、理解你的数据库模式，并分析你的索引，而无需了解 MongoDB 的查询语法。
- en: 'Download Compass from [https://www.mongodb.com/try/download/compass?tck=docs_compass](https://www.mongodb.com/try/download/compass?tck=docs_compass)
    based on your OS:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统从 [https://www.mongodb.com/try/download/compass?tck=docs_compass](https://www.mongodb.com/try/download/compass?tck=docs_compass)
    下载 Compass：
- en: '![Figure 3.9 – MongoDB Compass download page'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – MongoDB Compass 下载页面'
- en: '](img/B17115_03_09.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_09.jpg)'
- en: Figure 3.9 – MongoDB Compass download page
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – MongoDB Compass 下载页面
- en: Once you've downloaded the package relevant to your OS, run the installer and
    follow the steps that come after it. Once installed, open Compass, click on `mongodb://admin:password@localhost:27017/test`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下载与您的操作系统相关的包后，运行安装程序并按照其后的步骤操作。安装完成后，打开 Compass，点击 `mongodb://admin:password@localhost:27017/test`。
- en: 'MongoDB is running locally, so the hostname will be localhost and the port
    will be 27017:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 在本地运行，因此主机名将是 localhost，端口将是 27017：
- en: '![Figure 3.10 – MongoDB Compass – New Connection'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.10 – MongoDB Compass – 新连接'
- en: '](img/B17115_03_10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_10.jpg)'
- en: Figure 3.10 – MongoDB Compass – New Connection
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – MongoDB Compass – 新连接
- en: 'Click on the **CONNECT** button. Now, you are connected to your MongoDB server.
    You will see a list of databases that are available:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**连接**按钮。现在，您已连接到您的MongoDB服务器。您将看到可用的数据库列表：
- en: '![Figure 3.11 – MongoDB default databases'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – MongoDB默认数据库'
- en: '](img/B17115_03_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_11.jpg)'
- en: Figure 3.11 – MongoDB default databases
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – MongoDB默认数据库
- en: At this point, we have a functional MongoDB deployment. In the next section,
    we're going to interact with the database using the Recipes API we built in the
    previous chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个功能性的MongoDB部署。在下一节中，我们将使用上一章中构建的Recipes API与数据库进行交互。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To stop MongoDB server, run `docker ps` command to see the list of the running
    containers and `docker stop CONTAINER_ID` to stop the container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止MongoDB服务器，运行`docker ps`命令查看正在运行的容器列表，然后使用`docker stop CONTAINER_ID`停止容器。
- en: Configuring Go's MongoDB driver
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Go的MongoDB驱动程序
- en: The Recipes API we implemented in the previous chapter is written in Golang.
    Therefore, we need to install the official MongoDB Go driver ([https://github.com/mongodb/mongo-go-driver](https://github.com/mongodb/mongo-go-driver))
    to interact with the MongoDB server. The driver fully integrates with the MongoDB
    API and supports all the main queries and aggregation features of the API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中实现的Recipes API是用Golang编写的。因此，我们需要安装官方的MongoDB Go驱动程序（[https://github.com/mongodb/mongo-go-driver](https://github.com/mongodb/mongo-go-driver)）以与MongoDB服务器交互。该驱动程序完全集成到MongoDB
    API中，并支持API的所有主要查询和聚合功能。
- en: 'Issue the following command to install the package from GitHub:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令从GitHub安装包：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will add the package as a dependency in the `require` section, under the
    `go.mod` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`go.mod`文件下的`require`部分添加包作为依赖项：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To get started, import the following packages in the `main.go` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，请在`main.go`文件中导入以下包：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `init()` method, create a `mongo.Client` with the `Connect` function.
    This function takes a context as a parameter and the connection string, which
    is provided with an environment variable called `MONGO_URI`. Also, create the
    following global variables; they will be used across all the CRUD operation functions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`方法中，使用`Connect`函数创建一个`mongo.Client`。此函数接受一个上下文参数和连接字符串，该连接字符串由名为`MONGO_URI`的环境变量提供。同时创建以下全局变量；它们将在所有CRUD操作函数中使用：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have omitted some of the code to make the example readable and easy to follow.
    The full source code is available in this book's GitHub repository, under the
    `chapter03` folder.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例易于阅读和跟随，我已省略了一些代码。完整的源代码可在本书的GitHub仓库中找到，位于`chapter03`文件夹下。
- en: Once the `Connect` method returns the client object, we can use the `Ping` method
    to check whether the connection was successful or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Connect`方法返回客户端对象，我们可以使用`Ping`方法来检查连接是否成功。
- en: 'Pass the `MONGO_URI` environment variable to the `go run` command and check
    if the application can successfully connect to your MongoDB server:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MONGO_URI`环境变量传递给`go run`命令，并检查应用程序是否可以成功连接到您的MongoDB服务器：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If successful, a **Connected to MongoDB** message will be shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，将显示**已连接到MongoDB**的消息：
- en: '![Figure 3.12 – MongoDB connection with the Go driver'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – 使用Go驱动程序的MongoDB连接'
- en: '](img/B17115_03_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_12.jpg)'
- en: Figure 3.12 – MongoDB connection with the Go driver
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – 使用Go驱动程序的MongoDB连接
- en: Now, let's populate a fresh database with some data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用一些数据填充一个全新的数据库。
- en: Exploring MongoDB queries
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索MongoDB查询
- en: In this section, we will interact with the MongoDB server using CRUD operations,
    but first, let's create a database where the API data will be stored.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用CRUD操作与MongoDB服务器进行交互，但首先，让我们创建一个数据库，用于存储API数据。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can view the full documentation for the MongoDB Go driver on the GoDoc website
    ([https://godoc.org/go.mongodb.org/mongo-driver](https://godoc.org/go.mongodb.org/mongo-driver)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GoDoc网站上查看MongoDB Go驱动程序的完整文档（[https://godoc.org/go.mongodb.org/mongo-driver](https://godoc.org/go.mongodb.org/mongo-driver)）。
- en: The InsertMany operation
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入多个操作
- en: 'Let''s initialize the database with the `recipes.json` file we created in the
    previous chapter. First, retrieve a `Database` and then a `Collection` instance
    from `Client`. The `Collection` instance will be used to insert documents:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一章中创建的`recipes.json`文件初始化数据库。首先，从`Client`获取`Database`和`Collection`实例。`Collection`实例将用于插入文档：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code reads a JSON file ([https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json)),
    which contains a list of recipes, and encodes it into an array of the `Recipe`
    struct. Then, it establishes a connection with the MongoDB server and inserts
    the recipes into the `recipes` collection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码读取一个JSON文件([https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/recipes.json))，其中包含食谱列表，并将其编码为`Recipe`结构的数组。然后，它与MongoDB服务器建立连接并将食谱插入到`recipes`集合中。
- en: To insert multiple documents at a time, we can use the `InsertMany()` method.
    This method accepts an interface slice as a parameter. Therefore, we must map
    the `Recipes` struct slice to the interface slice.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性插入多个文档，我们可以使用`InsertMany()`方法。此方法接受一个接口切片作为参数。因此，我们必须将`Recipes`结构切片映射到接口切片。
- en: 'Rerun the application, but this time, set the `MONGO_URI and MONGO_DATABASE`
    variables as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序，但这次，将`MONGO_URI`和`MONGO_DATABASE`变量设置如下：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make sure to replace `USER` with your database user and `PASSWORD` with the
    user password we created while deploying the MongoDB container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`USER`替换为您的数据库用户，将`PASSWORD`替换为在部署MongoDB容器时创建的用户密码。
- en: 'The application will be launched; the `init()` method will be executed first
    and the recipes items will be inserted into the MongoDB collection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将被启动；首先执行`init()`方法，并将食谱项插入到MongoDB集合中：
- en: '![Figure 3.13 – Inserting recipes during startup'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – 启动时插入食谱'
- en: '](img/B17115_03_13.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_13.jpg](img/B17115_03_13.jpg)'
- en: Figure 3.13 – Inserting recipes during startup
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 启动时插入食谱
- en: 'To verify that the data has been loaded into the recipes collection, refresh
    MongoDB Compass. You should see the entries that you created:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证数据是否已加载到食谱集合中，请刷新MongoDB Compass。你应该看到你创建的条目：
- en: '![Figure 3.14 – Recipes collection'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 食谱集合'
- en: '](img/B17115_03_14.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_14.jpg](img/B17115_03_14.jpg)'
- en: Figure 3.14 – Recipes collection
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 食谱集合
- en: 'Now that the `recipes` collection has been prepared, we need to update each
    API endpoint''s code so that they use the collection instead of the hardcoded
    recipes list. But first, we need to update the `init()` method to remove the loading
    and encoding of the `recipes.json` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`recipes`集合已经准备好了，我们需要更新每个API端点的代码，使它们使用集合而不是硬编码的食谱列表。但首先，我们需要更新`init()`方法以删除`recipes.json`文件的加载和编码：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s worth mentioning that you can use the `mongoimport` utility to load the
    `recipe.json` file directly into the `recipes` collection without writing a single
    line of code in Golang. The command for this is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您可以使用`mongoimport`实用程序将`recipe.json`文件直接加载到`recipes`集合中，而无需在Golang中编写任何代码。此命令如下：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command will import the content from the JSON file into the `recipes`
    collection:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将JSON文件的内容导入到`recipes`集合中：
- en: '![Figure 3.15 – Importing data with mongoimport'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – 使用mongoimport导入数据'
- en: '](img/B17115_03_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_15.jpg](img/B17115_03_15.jpg)'
- en: Figure 3.15 – Importing data with mongoimport
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 使用mongoimport导入数据
- en: In the next section, we will update the existing function handlers to read and
    write from/to the `recipes` collection.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更新现有的函数处理程序，以便从`recipes`集合中读取和写入。
- en: The Find operation
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找操作
- en: 'To get started, we need to implement the function responsible for returning
    a list of recipes. Update `ListRecipesHandler` so that it uses the `Find()` method
    to fetch all the items from the `recipes` collection:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要实现一个返回食谱列表的函数。更新`ListRecipesHandler`，使其使用`Find()`方法从`recipes`集合中获取所有项目：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Find()` method returns a cursor, which is a stream of documents. We must
    go through the stream of documents and decode one at a time into the `Recipe`
    struct. Then, we must append the document to a list of recipes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find()`方法返回一个游标，它是一系列文档的流。我们必须遍历文档流，并将每个文档一次解码到`Recipe`结构中。然后，我们必须将文档追加到食谱列表中。'
- en: 'Run the application, then issue a GET request on the `/recipes` endpoint; a
    `find()` operation will be executed on the `recipes` collection. As a result,
    a list of recipes will be returned:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，然后在`/recipes`端点发出GET请求；将在`recipes`集合上执行`find()`操作。结果，将返回一个食谱列表：
- en: '![Figure 3.16 – Getting all the recipes'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 – 获取所有食谱'
- en: '](img/B17115_03_16.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_16.jpg](img/B17115_03_16.jpg)'
- en: Figure 3.16 – Getting all the recipes
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 获取所有食谱
- en: The endpoint is working and fetching the recipe's items from the collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 端点正在工作，并从集合中检索食谱项。
- en: The InsertOne operation
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: InsertOne 操作
- en: 'The second function to be implemented will be responsible for saving a new
    recipe. Update the `NewRecipeHandler` function so that it calls the `InsertOne()`
    method on the `recipes` collection:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实现的第二个函数将负责保存新食谱。更新 `NewRecipeHandler` 函数，使其在 `recipes` 集合上调用 `InsertOne()`
    方法：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we set a unique identifier using the `primitive.NewObjectID()` method
    ahead of saving the item in the collection. Therefore, we need to change the ID
    type of the `Recipe` struct. Also, note the usage of the `bson` tags to map a
    `struct` field to the `document` attribute in the MongoDB collection:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在将项目保存到集合之前使用 `primitive.NewObjectID()` 方法设置一个唯一标识符。因此，我们需要更改 `Recipe`
    结构体的 ID 类型。注意 `bson` 标签的使用，它将 `struct` 字段映射到 MongoDB 集合中的 `document` 属性：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, Go lowercases the struct field names when encoding struct values.
    If a different name is needed, you can override the default mechanism with `bson`
    tags.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 在编码结构体值时将结构体字段名转换为小写。如果需要不同的名称，可以使用 `bson` 标签覆盖默认机制。
- en: 'Insert a new recipe by calling the following POST request with the Postman
    client:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Postman 客户端调用以下 POST 请求来插入新食谱：
- en: '![Figure 3.17 – Creating a new recipe'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.17 – 创建新食谱'
- en: '](img/B17115_03_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_17.jpg)'
- en: Figure 3.17 – Creating a new recipe
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – 创建新食谱
- en: 'Verify that the recipe has been inserted into the MongoDB collection, as shown
    in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 验证食谱是否已插入到 MongoDB 集合中，如下截图所示：
- en: '![Figure 3.18 – Getting the last inserted recipe'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.18 – 获取最后插入的食谱'
- en: '](img/B17115_03_18.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_18.jpg)'
- en: Figure 3.18 – Getting the last inserted recipe
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – 获取最后插入的食谱
- en: To get the last inserted recipe, we use the `sort()` operation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最后插入的食谱，我们使用 `sort()` 操作。
- en: The UpdateOne operation
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UpdateOne 操作
- en: 'Finally, in order to update an item from the collection, update the `UpdateRecipeHandler`
    function so that it calls the `UpdateOne()` method. This method requires a filter
    document to match documents in the database and an updater document to describe
    the update operation. You can build a filter using `bson.D{}` – a **Binary-encoded
    JSON** (**BSON**) document:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了更新集合中的项目，更新 `UpdateRecipeHandler` 函数，使其调用 `UpdateOne()` 方法。此方法需要一个过滤器文档来匹配数据库中的文档，以及一个更新器文档来描述更新操作。您可以使用
    `bson.D{}` – 一个 **二进制编码的 JSON** （**BSON**）文档来构建过滤器：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method filters documents by their Object ID. We get the Object ID by applying
    `ObjectIDFromHex` to the route parameter ID. This updates the matched recipe's
    fields with the new values coming from the request body.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过其 Object ID 过滤文档。我们通过将 `ObjectIDFromHex` 应用到路由参数 ID 来获取 Object ID。这使用请求体中的新值更新匹配的食谱字段。
- en: 'Verify the endpoint is working by calling a PUT request on an existing recipe:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对现有食谱发出 PUT 请求来验证端点是否正常工作：
- en: '![Figure 3.19 – Updating a recipe'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.19 – 更新食谱'
- en: '](img/B17115_03_19.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_19.jpg)'
- en: Figure 3.19 – Updating a recipe
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – 更新食谱
- en: The request will match the recipe where `ID` is `600dcc85a65917cbd1f201b0` and
    will update its `name` from "`Homemade Pizza`" to "`Homemade Pepperoni Pizza`",
    and the `instructions` field with additional steps to make a "`Pepperoni Pizza`".
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将匹配 `ID` 为 `600dcc85a65917cbd1f201b0` 的食谱，并将其 `name` 从 "`Homemade Pizza`"
    更改为 "`Homemade Pepperoni Pizza`"，并将 `instructions` 字段更新为制作 "`Pepperoni Pizza`"
    的额外步骤。
- en: 'With that, the recipe has been successfully updated. You can confirm these
    changes with MongoDB Compass:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，食谱已成功更新。您可以使用 MongoDB Compass 确认这些更改：
- en: '![Figure 3.20 – UpdateOne operation results'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.20 – UpdateOne 操作结果'
- en: '](img/B17115_03_20.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_20.jpg)'
- en: Figure 3.20 – UpdateOne operation results
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – UpdateOne 操作结果
- en: You should now be familiar with the basic MongoDB queries. Go ahead and implement
    the remaining CRUD operations.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该熟悉基本的 MongoDB 查询。继续实施剩余的 CRUD 操作。
- en: 'Finally, make sure that you push the changes to the remote repository with
    the following commands:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保使用以下命令将更改推送到远程仓库：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, create a pull request to merge the `feature` branch into `develop`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个拉取请求以将 `feature` 分支合并到 `develop`：
- en: '![Figure 3.21 – New pull request'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.21 – 新的拉取请求'
- en: '](img/B17115_03_21.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_21.jpg)'
- en: Figure 3.21 – New pull request
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – 新的拉取请求
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A full implementation of the endpoints can be found in this book's GitHub repository
    ([https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的完整实现可以在本书的GitHub仓库中找到（[https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go](https://github.com/PacktPublishing/Building-Distributed-Applications-in-Gin/blob/main/chapter03/main.go)）。
- en: You just saw how to integrate MongoDB into the application architecture. In
    the next section, we will cover how to refactor the source code of our application
    so that it's maintainable, scalable, and extendable in the long run.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到了如何将MongoDB集成到应用程序架构中。在下一节中，我们将介绍如何重构应用程序的源代码，使其在长期内可维护、可扩展和可扩展。
- en: Designing the project's layout
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计项目的布局
- en: So far, all the code we've written is in the `main.go` file. While this works
    fine, it's important to make sure the code is well structured; otherwise, you'll
    end up with a lot of hidden dependencies and messy code (spaghetti code) when
    the project grows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的所有代码都在`main.go`文件中。虽然这样没问题，但确保代码结构良好很重要；否则，当项目增长时，你将会有很多隐藏的依赖和混乱的代码（意大利面代码）。
- en: 'We will start with the data model. Let''s create a `models` folder so that
    we can store all the models structs. For now, we have one model, which is the
    `Recipe` struct. Create a `recipe.go` file under the `models` folder and paste
    the following content:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从数据模型开始。让我们创建一个`models`文件夹，以便我们可以存储所有的模型结构体。目前，我们有一个模型，即`Recipe`结构体。在`models`文件夹下创建一个`recipe.go`文件，并粘贴以下内容：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, create a `handlers` folder with the `handler.go` file. This folder, as
    its name indicts, handles any incoming HTTP requests by exposing the right function
    to be called for each HTTP request:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个包含`handler.go`文件的`handlers`文件夹。这个文件夹，正如其名所示，通过暴露每个HTTP请求要调用的正确函数来处理任何传入的HTTP请求：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code creates a `RecipesHandler` struct with the MongoDB collection and
    context instances encapsulated. In our early simple implementations, we tended
    to keep these variables global within the main package. Here, we are keeping these
    variables in the struct. Next, we must define a `NewRecipesHandler` so that we
    can create an instance from the `RecipesHandler` struct.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个包含MongoDB集合和上下文实例的`RecipesHandler`结构体。在我们早期的简单实现中，我们倾向于在主包中全局保持这些变量。在这里，我们将这些变量保存在结构体中。接下来，我们必须定义一个`NewRecipesHandler`，这样我们就可以从`RecipesHandler`结构体创建一个实例。
- en: 'Now, we can define the endpoints handlers of the `RecipesHandler` type. The
    handlers can access all the variables of the struct such as the database connection
    because it is a method of the `RecipesHandler` type:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`RecipesHandler`类型的端点处理器。处理器可以访问结构体中的所有变量，例如数据库连接，因为它是`RecipesHandler`类型的一个方法：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From our `main.go` file, we''ll provide all the database credentials and connect
    to the MongoDB server:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`main.go`文件开始，我们将提供所有数据库凭据并连接到MongoDB服务器：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we must create a global variable to access the endpoints handlers. Update
    the `init()` method, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建一个全局变量来访问端点处理器。更新`init()`方法，如下所示：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, use the `recipesHandler` variable to access the handler for each HTTP
    endpoint:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`recipesHandler`变量来访问每个HTTP端点的处理器：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the application. This time, run all the `.go` files within the current
    directory:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。这次，运行当前目录下的所有`.go`文件：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The application will be working as expected. The server logs are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将按预期工作。服务器日志如下：
- en: '![Figure 3.22 – Gin debug logs'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.22 – Gin debug logs'
- en: '](img/B17115_03_22.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_03_22.jpg]'
- en: Figure 3.22 – Gin debug logs
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22 – Gin调试日志
- en: 'Now, your project structure should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的项目结构应该看起来像这样：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a basic layout for a Go application project. There are Go directories
    that we will cover in upcoming chapters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个Go应用程序项目的基本布局。我们将在接下来的章节中介绍Go目录。
- en: 'Push the changes to GitHub on a feature branch and merge the branch into `develop`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改推送到GitHub上的功能分支，并将其合并到`develop`分支：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When running a service that interacts with a database, its operations may become
    bottlenecks, thus degrading the user experience and impacting your business. That
    is why response time is one of the most important metrics to evaluate when developing
    a RESTful API.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行与数据库交互的服务时，其操作可能会成为瓶颈，从而降低用户体验并影响你的业务。这就是为什么响应时间是开发RESTful API时评估的最重要指标之一。
- en: Luckily, we can add a cache layer to store frequently accessed data in memory
    to speed things up, thus reducing the number of operations/queries on the database.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以添加一个缓存层来存储频繁访问的数据在内存中，从而加快速度，减少对数据库的操作/查询次数。
- en: Caching an API with Redis
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis缓存API
- en: In this section, we will cover how to add a caching mechanism to our API. Let's
    imagine that we have a tremendous number of recipes in our MongoDB database. Every
    time we try to query a list of recipes, we struggle with performance issues. What
    we can do instead is use an in-memory database, such as Redis, to reuse previously
    retrieved recipes and avoiding hitting the MongoDB database on each request.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何为我们的API添加缓存机制。让我们设想一下，我们MongoDB数据库中有大量的食谱。每次我们尝试查询食谱列表时，都会遇到性能问题。我们可以做的是使用内存数据库，例如Redis，来重用之前检索到的食谱，避免在每次请求中都击中MongoDB数据库。
- en: Redis is consistently faster at retrieving data because it is always in RAM
    – that's why it's an excellent choice for caching. On the other hand, MongoDB
    might have to retrieve data from disk for advancing queries.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Redis始终在RAM中，因此它在检索数据方面始终更快——这就是为什么它是缓存的一个优秀选择。另一方面，MongoDB可能需要从磁盘检索数据以进行查询。
- en: 'According to the official documentation ([https://redis.io/](https://redis.io/)),
    Redis is an open source, distributed, in-memory, key-value database, cache, and
    message broker. The following diagram illustrates how Redis fits in our API architecture:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档([https://redis.io/](https://redis.io/))，Redis是一个开源的、分布式的、内存中的键值数据库、缓存和消息代理。以下图表说明了Redis如何融入我们的API架构：
- en: '![Figure 3.23 – API new architecture'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.23 – API新架构'
- en: '](img/B17115_03_23.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_23.jpg)'
- en: Figure 3.23 – API new architecture
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23 – API新架构
- en: Let's say we want to get a list of recipes. First, the API will look around
    in Redis. If a list of recipes exists, it will be returned (this is called a `find({})`
    query will be issued, and the results will be returned and also saved in the cache
    for future requests.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取一个食谱列表。首先，API将在Redis中查找。如果存在食谱列表，它将被返回（这被称为`find({})`查询，并将结果返回并保存在缓存中，以供未来的请求使用。
- en: Running Redis in Docker
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Docker中运行Redis
- en: 'The easiest way to set up Redis is through Docker. We will use the Redis official
    image available at DockerHub for this ([https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)).
    At the time of writing this book, the latest stable version is 6.0\. Run a container
    based on that image:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Redis最简单的方法是通过Docker。我们将使用DockerHub上可用的Redis官方镜像来完成此操作([https://hub.docker.com/_/redis](https://hub.docker.com/_/redis))。在撰写本书时，最新稳定版本是6.0。基于该镜像运行容器：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This command does the following two main things:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令执行以下两个主要操作：
- en: The `–d` flag runs the Redis container as a daemon.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`标志以守护进程方式运行Redis容器。'
- en: The `–p` flag maps port 6379 of the container to port 6379 of the host. Port
    6379 is the port where the Redis server is exposed.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`标志将容器的6379端口映射到主机的6379端口。6379是Redis服务器暴露的端口。'
- en: 'The command''s output is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '![Figure 3.24 – Pulling a Redis image from DockerHub'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.24 – 从DockerHub拉取Redis镜像'
- en: '](img/B17115_03_24.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_24.jpg)'
- en: Figure 3.24 – Pulling a Redis image from DockerHub
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24 – 从DockerHub拉取Redis镜像
- en: 'Always check the Docker log to see the chain of events:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 总是检查Docker日志以查看事件链：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The logs provide a wealth of useful information, such as the default configuration
    and the exposed server port:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 日志提供了大量有用的信息，例如默认配置和暴露的服务器端口：
- en: '![Figure 3.25 – Redis server logs'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.25 – Redis服务器日志'
- en: '](img/B17115_03_25.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_25.jpg)'
- en: Figure 3.25 – Redis server logs
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25 – Redis服务器日志
- en: 'The Redis container uses the basic caching policy. For production usage, it''s
    recommended to configure an eviction policy. You can configure the policy with
    a `redis.conf` file:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Redis容器使用基本的缓存策略。对于生产使用，建议配置驱逐策略。您可以使用`redis.conf`文件配置策略：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This config allocates 512 MB of memory for Redis and sets the eviction policy
    to the **Least Recently Used** (**LRU**) algorithm, which deletes the cache items
    that were the least recently used. As a result, we only keep the items with the
    highest chances of getting read again.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置为Redis分配了512 MB的内存，并将驱逐策略设置为**最近最少使用**（**LRU**）算法，该算法删除最不常使用的缓存项。因此，我们只保留有最高再次读取概率的项。
- en: 'You can then pass the config at the runtime of the container with the following
    command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在容器的运行时传递配置：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, `$PWD/conf` is the folder containing the `redis.conf` file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`$PWD/conf` 是包含 `redis.conf` 文件的文件夹。
- en: 'Now that Redis is running, we can use it to cache API data. But first, let''s
    install the official Redis Go driver ([https://github.com/go-redis/redis](https://github.com/go-redis/redis))
    by executing the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Redis 已启动，我们可以使用它来缓存 API 数据。但首先，让我们通过执行以下命令来安装官方的 Redis Go 驱动程序 ([https://github.com/go-redis/redis](https://github.com/go-redis/redis))：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Import the following package in the `main.go` file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中导入以下包：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, on the `init()` method, initialize the Redis client with `redis.NewClient()`.
    This method takes the server address, password, and database as parameters. Next,
    we will call the `Ping()` method on the Redis client to check the connection status
    to the Redis server:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `init()` 方法中，使用 `redis.NewClient()` 初始化 Redis 客户端。此方法接受服务器地址、密码和数据库作为参数。接下来，我们将在
    Redis 客户端上调用 `Ping()` 方法以检查与 Redis 服务器的连接状态：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code will set up a connection with the Redis server after deployment:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将在部署后设置与 Redis 服务器的连接：
- en: '![Figure 3.26 – Checking the connection with the Redis server'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.26 – 检查与 Redis 服务器的连接'
- en: '](img/B17115_03_26.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_26.jpg)'
- en: Figure 3.26 – Checking the connection with the Redis server
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – 检查与 Redis 服务器的连接
- en: 'If the connection is successful, a `ping: PONG` message will be displayed,
    as shown in the preceding screenshot.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '如果连接成功，将显示 `ping: PONG` 消息，如前面的截图所示。'
- en: Optimizing MongoDB queries
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化 MongoDB 查询
- en: 'With a connection being established with the Redis server, we can update the
    `RecipesHandler` struct to store an instance of the Redis client so that the handlers
    can interact with Redis:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redis 服务器建立连接后，我们可以更新 `RecipesHandler` 结构体以存储 Redis 客户端的实例，以便处理程序可以与 Redis
    交互：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Make sure that you pass the Redis client instance to the `RecipesHandler` instance
    in the `init()` method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `init()` 方法中将 Redis 客户端实例传递给 `RecipesHandler` 实例：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we must update `ListRecipesHandler` to check if the recipes have been
    cached in Redis. If they are, we return a list. If not, we will retrieve the data
    from MongoDB and cache it in Redis. The new changes we must make to the code are
    as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须更新 `ListRecipesHandler` 以检查食谱是否已缓存在 Redis 中。如果是，我们返回一个列表。如果不是，我们将从 MongoDB
    获取数据并将其缓存在 Redis 中。我们必须对代码进行的新的更改如下：
- en: '[PRE39]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's worth mentioning that the Redis value has to be a string, so we had to
    encode the `recipes` slice into a string with the `json.Marshal()` method.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Redis 的值必须是一个字符串，因此我们必须使用 `json.Marshal()` 方法将 `recipes` 切片编码成字符串。
- en: 'To test out the new changes, run the application. Then, issue a GET request
    on the `/recipes` endpoint with Postman client or with a `cURL` command. Flip
    back to your Terminal and view the Gin logs. You should see a message in the console
    for the first request corresponding to getting data from MongoDB:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试新的更改，运行应用程序。然后，使用 Postman 客户端或 `cURL` 命令在 `/recipes` 端点发出 GET 请求。切换回你的终端并查看
    Gin 日志。你应该在控制台中看到一条消息，对应于从 MongoDB 获取数据的第一次请求：
- en: '![Figure 3.27 – Getting data from MongoDB'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.27 – 从 MongoDB 获取数据'
- en: '](img/B17115_03_27.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_27.jpg)'
- en: Figure 3.27 – Getting data from MongoDB
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – 从 MongoDB 获取数据
- en: Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a step-by-step guide on how to use the Postman client or `cURL` command,
    check out [*Chapter 1*](B17115_01_Final_JM_ePub.xhtml#_idTextAnchor015), *Getting
    Started with Gin*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用 Postman 客户端或 `cURL` 命令的逐步指南，请参阅[*第 1 章*](B17115_01_Final_JM_ePub.xhtml#_idTextAnchor015)，*使用
    Gin 入门*。
- en: 'If you hit a second HTTP request, this time, data will be returned from Redis
    because it was cached in the first request:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发出第二次 HTTP 请求，这次，数据将从 Redis 返回，因为它在第一次请求中被缓存：
- en: '![Figure 3.28 – Getting data from Redis'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.28 – 从 Redis 获取数据'
- en: '](img/B17115_03_28.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_28.jpg)'
- en: Figure 3.28 – Getting data from Redis
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 – 从 Redis 获取数据
- en: As we can see, retrieving data from memory (Redis) is wicked fast compared to
    retrieving data from disk (MongoDB).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，从内存（Redis）中检索数据比从磁盘（MongoDB）中检索数据快得多。
- en: 'We can verify that data is being cached in Redis by running the Redis CLI from
    the container. Run the following commands:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在容器中运行 Redis CLI 来验证数据是否被缓存在 Redis 中。运行以下命令：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These commands will connect to the Redis container using the interactive terminal
    and start the bash shell. You''ll notice that you''re now using your terminal
    as if you were inside your container, as shown in the following screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将通过交互式终端连接到 Redis 容器并启动 bash shell。你会注意到你现在正在使用你的终端，就像你身处容器内部一样，如下面的截图所示：
- en: '![Figure 3.29 – Running an interactive session inside a Redis container'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.29 – 在 Redis 容器内运行交互式会话'
- en: '](img/B17115_03_29.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_29.jpg]'
- en: Figure 3.29 – Running an interactive session inside a Redis container
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29 – 在 Redis 容器内运行交互式会话
- en: 'Now that we''re attached to the Redis container, we can use the Redis command
    line:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已连接到 Redis 容器，我们可以使用 Redis 命令行：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'From there, we can use the `EXISTS` command to check if the `recipes` key exists:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们可以使用 `EXISTS` 命令来检查 `recipes` 键是否存在：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This command will return `1` (if the key exists) or `0` (if the key doesn''t
    exist). In our case, the list of recipes has been cached in Redis:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将返回 `1`（如果键存在）或 `0`（如果键不存在）。在我们的例子中，配方列表已被缓存在 Redis 中：
- en: '![Figure 3.30 – Checking if a key exists in Redis'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.30 – 检查 Redis 中是否存在键'
- en: '](img/B17115_03_30.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_30.jpg]'
- en: Figure 3.30 – Checking if a key exists in Redis
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.30 – 检查 Redis 中是否存在键
- en: There is a lot that you can accomplish with the shell client, but you've got
    the general idea. Type `exit` to leave the MongoDB shell and then `exit` once
    again to leave the interactive shell.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 shell 客户端完成很多事情，但您已经了解了基本概念。输入 `exit` 退出 MongoDB shell，然后再次输入 `exit` 退出交互式
    shell。
- en: 'For GUI fans, you can use Redis Insights ([https://redislabs.com/fr/redis-enterprise/redis-insight/](https://redislabs.com/fr/redis-enterprise/redis-insight/)).
    It provides an intuitive interface to explore Redis and interact with its data.
    Similar to the Redis server, you can deploy Redis Insights with Docker:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 GUI 粉丝，您可以使用 Redis Insights ([https://redislabs.com/fr/redis-enterprise/redis-insight/](https://redislabs.com/fr/redis-enterprise/redis-insight/))。它提供了一个直观的界面来探索
    Redis 并与其数据交互。类似于 Redis 服务器，您可以使用 Docker 部署 Redis Insights：
- en: '[PRE43]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This command will run a container based on the Redis Insight official image
    and expose the interface on port 8001.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将基于 Redis Insight 官方镜像运行容器，并在端口 8001 上公开接口。
- en: 'Navigate with your browser to `http://localhost:8081`. The Redis Insights home
    page should appear. Click on **I already have a database** and then on the **Connect
    to Redis database** button:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器导航到 `http://localhost:8081`。Redis Insights 主页应该会出现。点击 **我已经有一个数据库** 然后点击
    **连接到 Redis 数据库** 按钮：
- en: '![Figure 3.31 – Configuring the Redis database'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.31 – 配置 Redis 数据库'
- en: '](img/B17115_03_31.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_31.jpg]'
- en: Figure 3.31 – Configuring the Redis database
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.31 – 配置 Redis 数据库
- en: 'Set the `redis`, `6379`, and name the database. The settings are as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `redis`、`6379` 并命名数据库。设置如下：
- en: '![Figure 3.32 – New Redis settings'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.32 – 新的 Redis 设置'
- en: '](img/B17115_03_32.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_32.jpg]'
- en: Figure 3.32 – New Redis settings
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.32 – 新的 Redis 设置
- en: 'Next, click on **ADD REDIS DATABASE**. The **local** database will be saved;
    click on it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击 **添加 Redis 数据库**。**本地**数据库将被保存；点击它：
- en: '![Figure 3.33 – Redis Insights databases'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.33 – Redis Insights 数据库'
- en: '](img/B17115_03_33.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_33.jpg]'
- en: Figure 3.33 – Redis Insights databases
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.33 – Redis Insights 数据库
- en: 'You will be redirected to the **Summary** page, which contains real metrics
    and stats about the Redis server:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被重定向到 **摘要** 页面，其中包含关于 Redis 服务器的真实指标和统计数据：
- en: '![Figure 3.34 – Redis server metrics'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.34 – Redis 服务器指标'
- en: '](img/B17115_03_34.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_34.jpg]'
- en: Figure 3.34 – Redis server metrics
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.34 – Redis 服务器指标
- en: 'If you click on **BROWSE**, you will see a list of all the keys that have been
    stored in Redis. As shown in the following screenshot, the recipes key has been
    cached:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击 **浏览**，您将看到存储在 Redis 中的所有键的列表。如图所示，recipes 键已被缓存：
- en: '![Figure 3.35 – Redis list of keys'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.35 – Redis 键列表'
- en: '](img/B17115_03_35.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_35.jpg]'
- en: Figure 3.35 – Redis list of keys
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.35 – Redis 键列表
- en: Now, you can use the interface to explore, manipulate, and visualize data within
    Redis.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用该界面在 Redis 中探索、操作和可视化数据。
- en: 'So far, the API we''ve built is working as a charm, right? Not really; imagine
    that you add a new recipe to the database:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建的 API 运行得很好，对吧？其实不然；想象一下，您向数据库中添加了一个新的配方：
- en: '![Figure 3.36 – Creating a new recipe'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.36 – 创建新配方'
- en: '](img/B17115_03_36.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_36.jpg]'
- en: Figure 3.36 – Creating a new recipe
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.36 – 创建新配方
- en: 'Now, if you issue a `GET /recipes` request, the new recipe won''t be found.
    This is because the data is being returned from the cache:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您发出 `GET /recipes` 请求，将找不到新的配方。这是因为数据是从缓存中返回的：
- en: '![Figure 3.37 – Recipe not found'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.37 – 没有找到配方'
- en: '](img/B17115_03_37.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17115_03_37.jpg]'
- en: Figure 3.37 – Recipe not found
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.37 – 没有找到配方
- en: 'One of the issues that caching introduces is that of keeping the cache up to
    date when data changes:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存引入的一个问题是，当数据发生变化时，如何保持缓存更新：
- en: '![Figure 3.38 – All future requests are hitting Redis'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.38 – 所有后续请求都命中Redis'
- en: '](img/B17115_03_38.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_03_38.jpg]'
- en: Figure 3.38 – All future requests are hitting Redis
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.38 – 所有后续请求都命中Redis
- en: There are two group rules in this case to fix inconsistencies. First, we can
    add a **Time to Live** (**TTL**) field for the recipes key in Redis. Second we
    can clear the **recipes** key in Redis each time a new recipe is inserted or updated.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有两个分组规则来修复不一致性。首先，我们可以在Redis中为菜谱键添加一个**生存时间**（**TTL**）字段。其次，每次插入或更新新的菜谱时，我们可以在Redis中清除**菜谱**键。
- en: Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The time to retain the cache's TTL depends on your application logic. You may
    need to save it for an hour or days, depending on how often the data gets updated.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的TTL保留时间取决于你的应用程序逻辑。你可能需要保存一个小时或几天，具体取决于数据更新的频率。
- en: 'We can implement the second solution by updating the `NewRecipeHandler` function
    so that it deletes the `recipes` key when a new recipe is being inserted. In this
    case, the implementation will be as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更新`NewRecipeHandler`函数来实现第二个解决方案，使其在插入新菜谱时删除`recipes`键。在这种情况下，实现方式如下：
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Redeploy the application. Now, if you hit a `GET /recipes` request, the data
    will be returned from MongoDB as expected; then, it will be cached in Redis. The
    second GET request will return data from Redis. However, now, if we issue a `POST
    /recipes` request to insert a new recipe, the `recipes` key in Redis will be cleared,
    as confirmed by the `Remove data from Redis` message. This means that the next
    `GET /recipes` request will fetch data from MongoDB:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 重新部署应用程序。现在，如果你发起一个`GET /recipes`请求，数据将按预期从MongoDB返回；然后，它将被缓存在Redis中。第二个GET请求将返回Redis中的数据。然而，现在，如果我们发起一个`POST
    /recipes`请求来插入一个新的菜谱，Redis中的`recipes`键将被清除，如`从Redis中删除数据`消息所确认的。这意味着下一个`GET /recipes`请求将从MongoDB获取数据：
- en: '![Figure 3.39 – Clearing the cache upon inserting a request'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.39 – 插入请求时清除缓存'
- en: '](img/B17115_03_39.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_03_39.jpg]'
- en: Figure 3.39 – Clearing the cache upon inserting a request
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.39 – 插入请求时清除缓存
- en: 'Now, the new recipe will be returned in the list of recipes:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，新的菜谱将出现在菜谱列表中：
- en: '![Figure 3.40 – New inserted recipe'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.40 – 新插入的菜谱'
- en: '](img/B17115_03_40.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_03_40.jpg]'
- en: Figure 3.40 – New inserted recipe
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.40 – 新插入的菜谱
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Update `UpdateRecipeHandler` to clear the cache when a PUT request is occurring
    on the `/recipes/{id}` endpoint.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`UpdateRecipeHandler`，以便在`/recipes/{id}`端点发生PUT请求时清除缓存。
- en: While caching offers great benefits for applications with heavy reads, it may
    not be as beneficial for applications that perform a lot of database updates and
    can slow down writes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然缓存为具有大量读取的应用程序提供了巨大的好处，但它可能对执行大量数据库更新的应用程序没有同样的好处，并且可能会减慢写入速度。
- en: Performance benchmark
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能基准测试
- en: We can take this further and see how the API will behave under a huge volume
    of requests. We can simulate multiple requests with Apache Benchmark ([https://httpd.apache.org/docs/2.4/programs/ab.html](https://httpd.apache.org/docs/2.4/programs/ab.html)).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，看看API在大量请求下的表现。我们可以使用Apache Benchmark（[https://httpd.apache.org/docs/2.4/programs/ab.html](https://httpd.apache.org/docs/2.4/programs/ab.html)）模拟多个请求。
- en: 'First, let''s test the API without the caching layer. You can run 2,000 GET
    requests in total on the `/recipes` endpoint with 100 concurrent requests with
    the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们测试没有缓存层的API。你可以使用以下命令在`/recipes`端点上运行总共2,000个GET请求，有100个并发请求：
- en: '[PRE45]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It should take a few minutes for all the requests to be completed. Once done,
    you should see the following results:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有请求可能需要几分钟。一旦完成，你应该看到以下结果：
- en: '![Figure 3.41 – API without a caching layer'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.41 – 没有缓存层的API'
- en: '](img/B17115_03_41.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_03_41.jpg]'
- en: Figure 3.41 – API without a caching layer
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.41 – 没有缓存层的API
- en: 'The important thing to take from this output is as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中可以得出的重要信息如下：
- en: '**Time taken for tests**: This means the total time to complete the 2,000 requests.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试所用时间**：这意味着完成2,000个请求的总时间。'
- en: '**Time per request**: This means how many milliseconds it takes to complete
    one request.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个请求的时间**：这意味着完成一个请求需要多少毫秒。'
- en: 'Next, we will issue the same requests but this time on the API with caching
    (Redis):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将发起相同的请求，但这次是在带有缓存的API（Redis）上：
- en: '[PRE46]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It should take a few seconds for the 2,000 requests to be completed:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 完成对2,000个请求的处理应该需要几秒钟：
- en: '![Figure 3.42 – API with a caching layer'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.42 – 带有缓存层的API'
- en: '](img/B17115_03_42.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17115_03_42.jpg]'
- en: Figure 3.42 – API with a caching layer
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.42 – 带有缓存层的API
- en: 'To compare both results, we can use the `gnuplot` utility to plot a chart based
    on the `without-cache.data` and `with-cache.data` files. But first, create an
    `apache-benchmark.p` file to render data into a graph:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较这两个结果，我们可以使用`gnuplot`实用程序根据`without-cache.data`和`with-cache.data`文件绘制图表。但首先，创建一个`apache-benchmark.p`文件以将数据渲染成图表：
- en: '[PRE47]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'These commands will draw two plots on the same graph based on the `.data` files
    and save the output as a PNG image. Next, run the `gnuplot` command to create
    the image:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将在同一图表上基于`.data`文件绘制两个图表，并将输出保存为PNG图像。接下来，运行`gnuplot`命令创建图像：
- en: '[PRE48]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A `benchmark.png` image will be created, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个`benchmark.png`图像，如下所示：
- en: '![Figure 3.43 – Benchmark of APIs with and without caches'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.43 – 带缓存和不带缓存的API基准测试'
- en: '](img/B17115_03_43.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_43.jpg)'
- en: Figure 3.43 – Benchmark of APIs with and without caches
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.43 – 带缓存和不带缓存的API基准测试
- en: The API's response time with the caching mechanism enabled is wicked fast compared
    to API's response time without caching.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 启用缓存机制的API响应时间与不带缓存的API响应时间相比非常快。
- en: 'Make sure that you push the changes to GitHub with a feature branch. Then,
    create a pull request to merge into `develop`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用功能分支将更改推送到GitHub。然后，创建一个拉取请求以合并到`develop`分支：
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'By the end of this chapter, your GitHub repository should look like this:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你的GitHub仓库应该看起来像这样：
- en: '![Figure 3.44 – Project''s GitHub repository'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.44 – 项目的GitHub仓库'
- en: '](img/B17115_03_44.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17115_03_44.jpg)'
- en: Figure 3.44 – Project's GitHub repository
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.44 – 项目的GitHub仓库
- en: Great! Now, you should be able to integrate a MongoDB database into your API
    architecture to manage data persistency.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，你应该能够将MongoDB数据库集成到你的API架构中，以管理数据持久性。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to build a RESTful API that leverages the Gin
    framework and Go driver for creating queries and querying in a NoSQL database
    such as MongoDB.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何构建一个利用Gin框架和Go驱动程序在NoSQL数据库（如MongoDB）中创建查询和查询的RESTful API。
- en: We also explored how to speed up the API by caching the data it accesses with
    Redis. It is definitely a great addition to your application if your data is mostly
    static and does not change constantly. Finally, we covered how to run performance
    benchmarks with Apache Benchmark.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何通过使用Redis缓存它访问的数据来加快API的速度。如果你的数据主要是静态的且不经常变化，这绝对是你应用程序的一个很好的补充。最后，我们介绍了如何使用Apache
    Benchmark进行性能基准测试。
- en: The RESTful API we have built so far works like a charm and is open to the public
    (if deployed on a remote server). If you leave the API unauthenticated, then anybody
    can hit any endpoint, which may very undesirable as your data could be damaged
    by users. Even worse, you might expose sensitive information from your database
    to the whole internet. That's why, in the next chapter, we will cover how to secure
    the API with authentication, such as JWT.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的RESTful API运行得非常顺畅，并且对公众开放（如果部署在远程服务器上）。如果你不验证API，那么任何人都可以访问任何端点，这可能会非常不理想，因为用户可能会损坏你的数据。更糟糕的是，你可能会将数据库中的敏感信息暴露给整个互联网。这就是为什么在下一章中，我们将介绍如何通过身份验证来保护API，例如使用JWT。
- en: Questions
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Implement a delete recipe operation when a `DELETE` request occurs.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生`DELETE`请求时，实现一个删除食谱操作。
- en: Implement a GET /`recipes/{id}` endpoint using the `FindOne` operation.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FindOne`操作实现一个GET /`recipes/{id}`端点。
- en: How are JSON documents stored in MongoDB?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSON文档在MongoDB中是如何存储的？
- en: How does the LRU eviction policy work in Redis?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis中的LRU驱逐策略是如何工作的？
- en: Further reading
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*MongoDB Fundamentals*, by Amit Phaltankar, Juned Ahsan, Michael Harrison,
    and Liviu Nedov, Packt Publishing'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《MongoDB基础》*，作者：Amit Phaltankar，Juned Ahsan，Michael Harrison和Liviu Nedov，Packt出版社'
- en: '*Learn MongoDB 4.x*, by Doug Bierer, Packt Publishing'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《学习MongoDB 4.x》*，作者：Doug Bierer，Packt出版社'
- en: '*Hands-On RESTful Web Services with Go – Second Edition*, by Naren Yellavula,
    Packt Publishing'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用Go的实战RESTful Web服务 – 第二版》*，作者：Naren Yellavula，Packt出版社'
