- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Calling External Processes and Handling Errors and Timeouts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用外部进程并处理错误和超时
- en: Many command-line applications interact with other external commands or API
    services. This chapter will guide you through how to call these external processes
    and how to handle timeouts and other errors when they occur. The chapter will
    start with a deep dive into the `os/exec` package, which contains everything you
    need to create commands that call external processes that give you multiple options
    for creating and running commands. You’ll learn how to retrieve data from the
    standard output and standard error pipes, as well as creating additional file
    descriptors for similar usage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行应用程序会与其他外部命令或API服务交互。本章将指导你如何调用这些外部进程，以及当它们发生时如何处理超时和其他错误。本章将从深入探讨`os/exec`包开始，该包包含了创建调用外部进程的命令所需的一切，它为你提供了创建和运行命令的多种选项。你将学习如何从标准输出和标准错误管道中检索数据，以及为类似用途创建额外的文件描述符。
- en: Another external process involves calling external API service endpoints. The
    `net/http` package is discussed and is where we start defining the client, then
    create the requests that it executes. We will discuss the different ways requests
    can be both created and executed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个外部进程涉及调用外部API服务端点。`net/http`包被讨论，这是我们开始定义客户端的地方，然后创建它执行的请求。我们将讨论请求可以创建和执行的不同方式。
- en: 'Timeouts and other errors can occur when calling either type of process. We
    will end the chapter by looking at how to capture when timeouts and errors occur
    in our code. It’s important to be mindful that these things can happen and so
    it’s important to write code that can handle them. The specific action taken upon
    error is dependent on the use case, so we’ll discuss the code to capture these
    cases only. To summarize, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用任何类型的进程时，都可能发生超时和其他错误。我们将以探讨如何在我们的代码中捕获超时和错误的发生结束本章。重要的是要意识到这些事情可能发生，因此编写能够处理它们的代码很重要。错误发生时采取的具体操作取决于用例，因此我们只将讨论捕获这些情况的代码。总结来说，我们将涵盖以下主题：
- en: Calling external processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用外部进程
- en: Interacting with REST APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与REST API交互
- en: Handling the expected – timeouts and errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理预期的 – 超时和其他错误
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll need a UNIX operating system to understand and run the examples shared
    in the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解并运行本章中分享的示例，你需要一个UNIX操作系统。
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter06](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter06).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到代码示例，链接为[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter06](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter06)。
- en: Calling external processes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用外部进程
- en: Within your command-line application, you may need to call some external processes.
    Sometimes, there are Golang libraries offered for third-party tools that function
    as a wrapper. For example, Go CV, [https://gocv.io/](https://gocv.io/), is a Golang
    wrapper offered for OpenCV, an open source computer vision library. Then, there’s
    GoFFmpeg, [https://github.com/xfrr/goffmpeg](https://github.com/xfrr/goffmpeg),
    which is a wrapper offered for FFmpeg, a library for recording, converting, and
    streaming audio and video files. Often, you need to install an underlying tool,
    such as OpenCV or FFmpeg, and then the library interacts with it. Calling these
    external processes then means importing the wrapper package and calling its methods
    within your code. Often, when you dive into the code, you’ll find that these libraries
    provide a wrapper for the C code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的命令行应用程序中，你可能需要调用一些外部进程。有时，第三方工具提供了作为包装器的Golang库。例如，Go CV，[https://gocv.io/](https://gocv.io/)，是针对OpenCV（一个开源计算机视觉库）提供的Golang包装器。然后是GoFFmpeg，[https://github.com/xfrr/goffmpeg](https://github.com/xfrr/goffmpeg)，它是针对FFmpeg（一个用于录制、转换和流式传输音频和视频文件的库）提供的包装器。通常，你需要安装底层工具，如OpenCV或FFmpeg，然后库与它交互。调用这些外部进程意味着导入包装器包，并在你的代码中调用其方法。通常，当你深入研究代码时，你会发现这些库为C代码提供了包装器。
- en: Besides importing a wrapper for an external tool, you may call external applications
    using the `os/exec` Golang library. This is the main purpose of the library and
    in this section, we will be digging into how to use it to call external applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了导入外部工具的包装器之外，你也可以使用`os/exec` Golang库来调用外部应用程序。这是库的主要目的，在本节中，我们将深入探讨如何使用它来调用外部应用程序。
- en: First, let’s review each of the variables, types, and functions that exist within
    the`os/exec` package with an example of each.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过每个示例来回顾一下 `os/exec` 包中存在的变量、类型和函数。
- en: The os/exec package
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: os/exec 包
- en: By digging deeper into the `exec` package, you will find that it is a wrapper
    for the `os.StartProcess` method, making it easier to handle the remapping of
    standard in and standard out, connecting the input and output with pipes, and
    handling other modifications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过深入研究 `exec` 包，你会发现它是对 `os.StartProcess` 方法的包装，这使得处理标准输入和标准输出的重映射、通过管道连接输入和输出以及处理其他修改变得更加容易。
- en: 'For clarity, it’s important to note that this package does not invoke the operating
    system’s shell and so doesn’t handle tasks handled typically by the shell: expanding
    glob patterns, pipelines, or redirections. If it is necessary to expand glob patterns,
    then you can call the shell directly and make sure to escape values to make it
    safe, or you can also use the path or file path’s `Glob` function. To expand any
    environment variables that exist in a string, use the `os` package’s `ExpandEnv`
    function.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，重要的是要注意，这个包不会调用操作系统的 shell，因此不处理通常由 shell 处理的任务：展开全局模式、管道或重定向。如果需要展开全局模式，可以直接调用
    shell 并确保转义值以使其安全，或者也可以使用路径或文件路径的 `Glob` 函数。要展开字符串中存在的任何环境变量，请使用 `os` 包的 `ExpandEnv`
    函数。
- en: In the following subsections, we’ll start to discuss the different variables,
    types, functions, and methods that exist within the `os/exec` package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将开始讨论 `os/exec` 包中存在的不同变量、类型、函数和方法。
- en: Variables
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: '`ErrNotFound` is the error variable returned when an executable file is not
    found in the application’s `$``PATH` variables.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrNotFound` 是当在应用程序的 `$``PATH` 变量中找不到可执行文件时返回的错误变量。'
- en: Types
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: '`Cmd` is a struct that represents an external command. Defining a variable
    of this type is just in preparation for the command to be run. Once this variable,
    of the `Cmd` type, is run via either the `Run`, `Output`, or `CombinedOutput`
    method, it cannot be reused. There are several fields on this `Cmd` struct that
    we can also elaborate upon:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmd` 是一个表示外部命令的结构体。定义这种类型的变量只是为了准备运行命令。一旦通过 `Run`、`Output` 或 `CombinedOutput`
    方法运行了 `Cmd` 类型的变量，它就不能再被重用。这个 `Cmd` 结构体上还有几个我们可以详细说明的字段：'
- en: '`Path string` This is the only required field. It is the path of the command
    to run; if the path is relative, then it will be relative to the value stored
    in the `Dir` field.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path string` 这是唯一必需的字段。它是要运行的命令的路径；如果路径是相对的，那么它将相对于存储在 `Dir` 字段中的值。'
- en: '`Args []string` This field holds the arguments for the command. `Args[0]` represents
    the command. `Path` and `Args` are set when the command is run, but if `Args`
    is `nil` or empty, then just `{Path}` is used during execution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Args []string` 这个字段包含命令的参数。`Args[0]` 表示命令。`Path` 和 `Args` 在运行命令时设置，但如果 `Args`
    是 `nil` 或空的，则在执行期间只使用 `{Path}`。'
- en: '`Env []string` The `Env` field represents the environment for the command to
    run. Each value in the slice must be in the following format: `"key=value"`. If
    the value is empty or `nil`, then the command uses the current environment. If
    the slice has duplicate key values, then the last value for the duplicate key
    is used.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Env []string` `Env` 字段表示要运行的命令的环境。切片中的每个值都必须以下列格式：`"key=value"`。如果值为空或 `nil`，则命令使用当前环境。如果切片有重复的键值，则使用重复键的最后一个值。'
- en: '`Dir string` The `Dir` field represents the working directory of the command.
    If it’s not set, then the current directory is used.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dir string` `Dir` 字段表示命令的工作目录。如果没有设置，则使用当前目录。'
- en: '`Stdin io.Reader` The `Stdin` field specifies the command process’ standard
    input. If the data is `nil`, then the process reads from `os.DevNull`, the null
    device. However, if the standard input is `*os.File`, then the contents are piped.
    During execution, a goroutine reads from standard input and then sends that data
    to the command. The `Wait` method will not complete until the goroutine starts
    copying. If it does not complete, then it could be because of an **end-of-file**
    (**EOF**), read, or write-to-pipe error.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stdin io.Reader` `Stdin` 字段指定了命令进程的标准输入。如果数据是 `nil`，则进程从 `os.DevNull`（空设备）读取。然而，如果标准输入是
    `*os.File`，则内容将通过管道传输。在执行过程中，一个 goroutine 从标准输入读取，然后将该数据发送到命令。`Wait` 方法将在 goroutine
    开始复制之前不会完成。如果它没有完成，那么可能是因为 **文件结束**（**EOF**）、读取或写入管道错误。'
- en: '`Stdout io.Writer` The `Stdout` field specifies the command process’ standard
    output. If the standard output is `nil`, then the process connects to the `os.DevNull`
    null device. If the standard output is `*os.File`, then output is sent to it instead.
    During execution, a goroutine reads from the command process and sends data to
    the writer.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stdout io.Writer` `Stdout` 字段指定了命令进程的标准输出。如果标准输出是 `nil`，则进程连接到 `os.DevNull`
    空设备。如果标准输出是 `*os.File`，则输出将发送到它。在执行过程中，一个goroutine从命令进程读取并发送数据到写入器。'
- en: '`Stderr io.Writer` The `Stderr` field specifies the command process’ standard
    error output. If the standard error is `nil`, then the process connects to the
    `os.DevNull` null device. If the standard error is `*os.File`, then error output
    is sent to it instead. During execution, a goroutine reads from the command process
    and sends data to the writer.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stderr io.Writer` `Stderr` 字段指定了命令进程的标准错误输出。如果标准错误是 `nil`，则进程连接到 `os.DevNull`
    空设备。如果标准错误是 `*os.File`，则错误输出将发送到它。在执行过程中，一个goroutine从命令进程读取并发送数据到写入器。'
- en: '`ExtraFiles []*os.File` The `ExtraFiles` field specifies additional files inherited
    by the command process. It doesn’t include standard input, standard output, or
    standard error, so if not empty, entry *x* becomes the *3+x* file descriptor.
    This field is not supported on Windows.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtraFiles []*os.File` `ExtraFiles` 字段指定了命令进程继承的附加文件。它不包括标准输入、标准输出或标准错误，因此如果非空，条目
    *x* 成为 *3+x* 文件描述符。此字段在 Windows 上不受支持。'
- en: '`SysProcAttr *syscall.SysProcAttr` `SysProcAttr` holds system-specific attributes
    that are passed down to `os.StartProcess` as an `os.ProcAttr`’s `Sys` field.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SysProcAttr *syscall.SysProcAttr` `SysProcAttr` 保留系统特定的属性，这些属性作为 `os.ProcAttr`
    的 `Sys` 字段传递给 `os.StartProcess`。'
- en: '`Process *os.Process` The `Process` field holds the underlying process once
    the command is run.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process *os.Process` `Process` 字段在命令运行后持有底层进程。'
- en: '`ProcessState *os.ProcessState` The `ProcessState` field contains information
    about the process. It becomes available after the wait or run method is called.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessState *os.ProcessState` `ProcessState` 字段包含有关进程的信息。在调用等待或运行方法后变得可用。'
- en: Methods
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'The following are the methods that exist on the `exec.Cmd` object:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `exec.Cmd` 对象上存在的方法：
- en: '`func (c *Cmd) CombinedOutput() ([]byte, error)` The `CombinedOutput` method
    returns both the standard output and standard error into 1-byte string output.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd) CombinedOutput() ([]byte, error)` `CombinedOutput` 方法将标准输出和标准错误都返回到1字节字符串输出中。'
- en: '`func (c *Cmd) Output ([]byte, error)` The `Output` method returns just the
    standard output. If an error occurs, it will usually be of the `*ExitError` type,
    and if the command’s standard error, `c.Stderr`, is `nil`, `Output` populates
    `ExitError.Stderr`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd) Output ([]byte, error)` `Output` 方法仅返回标准输出。如果发生错误，它通常将是 `*ExitError`
    类型，如果命令的标准错误 `c.Stderr` 是 `nil`，则 `Output` 将填充 `ExitError.Stderr`。'
- en: '`func (c *Cmd) Run() error` The `Run` method starts executing the command and
    then waits for it to complete. If there was no problem copying standard input,
    standard output, or standard error and the command exits with a zero status, then
    the error returned will be `nil`. If the command exits with an error, it will
    usually be of the `*ExitError` type, but could be other error types as well.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd) Run() error` `Run` 方法开始执行命令并等待其完成。如果没有问题复制标准输入、标准输出或标准错误，并且命令以零状态退出，则返回的错误将是
    `nil`。如果命令以错误退出，它通常将是 `*ExitError` 类型，但也可能是其他错误类型。'
- en: '`func (c *Cmd)` `Start() error`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd)` `Start() error`'
- en: The `Start` method will start executing the command and not wait for it to complete.
    If the `Start` method runs successfully, then the `c.Process` field will be set.
    The `c.Wait` field will then return the exit code and release resources once complete.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start` 方法将启动执行命令而不会等待其完成。如果 `Start` 方法运行成功，那么 `c.Process` 字段将被设置。然后 `c.Wait`
    字段将返回退出代码并在完成后释放资源。'
- en: f`unc (c* Cmd) StderrPipe() (io.ReadCloser, error)` `StderrPipe` returns a pipe
    that is connected to the command’s standard error. There won’t be a need to ever
    close the pipe because the `Wait` method will close the pipe once the command
    exits. Do not call the `Wait` method until all reads from the standard error pipe
    have completed. Do not use this command with the `Run` method for the same reason.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c* Cmd) StderrPipe() (io.ReadCloser, error)` `StderrPipe` 返回一个连接到命令标准错误的管道。不需要关闭管道，因为
    `Wait` 方法将在命令退出时关闭管道。不要在所有从标准错误管道读取完成之前调用 `Wait` 方法。不要与 `Run` 方法一起使用此命令，原因相同。'
- en: '`func (c* Cmd) StdinPipe() (io.WriteCloser, error`) `StdinPipe` returns a pipe
    that is connected to the command’s standard input. The pipe will be closed after
    `Wait`, and the command exits. However, sometimes the command will not run until
    the standard input pipe is closed, and thus you can call the `Close` method to
    close the pipe sooner.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c* Cmd) StdinPipe() (io.WriteCloser, error`) `StdinPipe`返回一个连接到命令标准输入的管道。在`Wait`之后，管道将被关闭，并且命令将退出。然而，有时命令将不会运行，直到标准输入管道被关闭，因此您可以调用`Close`方法来提前关闭管道。'
- en: '`func (c *Cmd) StdoutPipe() (io.ReadCloser, error`) The `StdoutPipe` method
    returns a pipe that is connected to the command’s standard output. There’s no
    need to close the pipe because `Wait` will close the pipe once the command exits.
    Again, do not call `Wait` until all reads from the standard output pipe have completed.
    Do not use this command with the `Run` method for the same reason.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd) StdoutPipe() (io.ReadCloser, error`) `StdoutPipe`方法返回一个连接到命令标准输出的管道。不需要关闭管道，因为`Wait`将在命令退出时关闭管道。同样，不要在所有从标准输出管道读取完成之前调用`Wait`。不要使用此命令与`Run`方法，原因相同。'
- en: '`func (c *Cmd) String() string` The `String` method returns a human-readable
    description of the command, `c`, for debugging purposes. The specific output may
    differ between Go version releases. Also, do not use this as input to a shell,
    as it’s not suitable for that purpose.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd) String() string` `String`方法返回一个人类可读的命令描述，`c`，用于调试目的。具体的输出可能在不同版本的Go发布之间有所不同。此外，不要将其用作shell的输入，因为它不适合这个目的。'
- en: '`func (c *Cmd) Wait() error` The `Wait` method waits for any copying to standard
    input, for standard output or standard error to complete, and for the command
    to exit. To utilize the `Wait` method, the command must have been started by the
    `Start` method and not the `Run` method. If there are no errors with copying from
    pipes and the process exits with a `0` exit status code, then the error returned
    will be `nil`. If the command’s `Stdin`, `Stdout`, or `Stderr` field is not set
    to `*os.File`, then `Wait` also ensures that the respective input-output loop
    process completes as well.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (c *Cmd) Wait() error` `Wait`方法等待任何复制到标准输入、标准输出或标准错误完成，以及命令退出。要使用`Wait`方法，命令必须是由`Start`方法而不是`Run`方法启动的。如果没有复制管道的错误，并且进程以`0`退出状态码退出，则返回的错误将是`nil`。如果命令的`Stdin`、`Stdout`或`Stderr`字段未设置为`*os.File`，则`Wait`还确保相应的输入-输出循环过程也完成。'
- en: '`Error` is a struct that represents an error returned from the `LookPath` function
    when it fails to recognize the file as an executable. There are a couple of fields
    and methods of this specific error type that we will define in detail.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`是一个结构体，表示当`LookPath`函数无法识别文件为可执行文件时返回的错误。我们将详细定义这个特定错误类型的几个字段和方法。'
- en: 'The following are the methods that exist on the `Error` type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Error`类型上存在的几种方法：
- en: '`func (e *Error) Unwrap() error` If the error returned is a chain of errors,
    then you can utilize the `Unwrap` method to *unwrap* it and determine what kind
    of error it is.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (e *Error) Unwrap() error` 如果返回的错误是错误链，则可以使用`Unwrap`方法来*展开*它并确定它是哪种错误。'
- en: '`ExitError` is a struct that represents an error when a command exits unsuccessfully.
    `*os.ProcessState` is embedded into this struct, so all values and fields will
    also be available to the `ExitError` type. Finally, there are a few fields of
    this type that we can define in more detail:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExitError`是一个结构体，表示命令未成功退出时的错误。`*os.ProcessState`被嵌入到这个结构体中，因此所有值和字段也将对`ExitError`类型可用。最后，我们可以更详细地定义这种类型的几个字段：'
- en: '`Stderr []byte` This field holds a set of the standard error output responses
    if not collected from the `Cmd.Output` method. `Stderr` may only contain the prefix
    and suffix of the error output if it’s sufficiently long. The middle will contain
    text about the number of omitted bytes. For debugging purposes, and if you want
    to include the entirety of the error messages, then redirect to `Cmd.Stderr`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stderr []byte` 此字段保存了如果没有从`Cmd.Output`方法收集的标准错误输出响应的集合。如果错误输出足够长，`Stderr`可能只包含前缀和后缀。中间将包含关于省略的字节数的文本。为了调试目的，如果您想包含整个错误消息，请重定向到`Cmd.Stderr`。'
- en: 'The following is the method that exists on the `ExitError` type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`ExitError`类型上存在的几种方法：
- en: '`func (e *ExitError) Error() string` The `Error` method returns the exit error
    represented as a string.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (e *ExitError) Error() string` `Error`方法返回表示退出错误的字符串。'
- en: Functions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'The following are functions that exist within the `os/exec` package:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`os/exec`包中存在的函数：
- en: '`func LookPath(file string) (string, error)` The `LookPath` function checks
    to see whether the file is an executable and can be found. If the file is a relative
    path, then it is relative to the current directory.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func LookPath(file string) (string, error)` `LookPath`函数检查文件是否是可执行的并且可以找到。如果文件是相对路径，则相对于当前目录。'
- en: '`func Command(name string, arg ...string) *Cmd` The `Command` function returns
    the `Cmd` struct with just the path and args set. If name has path separators,
    then the `LookPath` function is used to confirm the file is found and executable.
    Otherwise, `name` is used directly as the path. This function behaves slightly
    differently on Windows. For example, it will execute the whole command line as
    a single string, including quoted args, then handle its own parsing.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Command(name string, arg ...string) *Cmd` `Command`函数返回一个只设置了路径和参数的`Cmd`结构体。如果`name`有路径分隔符，则使用`LookPath`函数来确认文件已找到且可执行。否则，直接使用`name`作为路径。此函数在Windows上的行为略有不同。例如，它将整个命令行作为一个单独的字符串执行，包括引号内的参数，然后处理自己的解析。'
- en: '`func CommandContext(ctx context.Context, name string, arg ...string) *Cmd`
    Similar to the `Command` function, but receives context. If the context is executed
    before the command completes, then it will kill the process by calling `os.Process.Kill`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func CommandContext(ctx context.Context, name string, arg ...string) *Cmd`
    与`Command`函数类似，但接收上下文。如果上下文在命令完成之前执行，则将通过调用`os.Process.Kill`来杀死进程。'
- en: Now that we’ve really dived deep into the `os/exec` package and the structs,
    functions, and methods needed to execute functions, let’s actually use them in
    code to execute a function externally. Let’s create commands using the `Cmd` struct,
    but also with the `Command` and `CommandContext` functions. We can then take one
    example command and run it using either the `Run`, `Output`, or `CombinedOutput`
    method. Finally, we will handle some errors typically returned from these methods.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入研究了`os/exec`包以及执行函数所需的struct、函数和方法，让我们实际在代码中使用它们来执行外部函数。让我们使用`Cmd`结构体创建命令，同时使用`Command`和`CommandContext`函数。然后我们可以取一个示例命令，使用`Run`、`Output`或`CombinedOutput`方法之一来运行它。最后，我们将处理这些方法通常返回的一些错误。
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to follow along with the examples coming up, within the `Chapter-6`
    repository, install the necessary applications. In Windows, use the `.\build-windows.p1`
    PowerShell script. In Darwin, use the `make install` command. Once the applications
    are installed, run `go` `run main.go`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随即将出现的示例，在`Chapter-6`仓库中，安装必要的应用程序。在Windows上，使用`.\build-windows.p1` PowerShell脚本。在Darwin上，使用`make
    install`命令。一旦应用程序安装完毕，运行`go run main.go`。
- en: Creating commands using the Cmd struct
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Cmd结构体创建命令
- en: There are several different ways of creating commands. The first way is with
    the `Cmd` struct within the `exec` package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令有几种不同的方式。第一种方式是在`exec`包中的`Cmd`结构体。
- en: Using the Cmd struct
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Cmd结构体
- en: 'We first define the `cmd` variable with an unset `Cmd` structure. The following
    code resides in `/examples/command.go` within the `CreateCommandUsingStruct` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用未设置的`Cmd`结构体定义`cmd`变量。以下代码位于`/examples/command.go`中的`CreateCommandUsingStruct`函数：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each field is set separately. The path is set using `filepath.Join`, which
    is safe for use across different operating systems:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都是单独设置的。路径是通过`filepath.Join`设置的，这在不同的操作系统上都是安全的：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Each field is set separately. The `Args` field contains the command name in
    the `Args[0]` position, followed by the rest of the arguments to be passed in:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都是单独设置的。`Args`字段包含命令名，位于`Args[0]`位置，后面跟其余要传递的参数：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following three file descriptors are set – `Stdin`, `Stdout`, and `Stderr`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个文件描述符被设置 - `Stdin`、`Stdout`和`Stderr`：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, there’s a `writer`, file descriptor that’s passed into the `ExtraFiles`
    field. This specific field is inherited by the command process. It’s important
    to note that a pipe won’t work if you don’t pass the writer in `ExtraFiles`, because
    the child must get the writer to be able to write to it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个`writer`文件描述符被传递到`ExtraFiles`字段。这个特定的字段被命令进程继承。需要注意的是，如果不将writer传递到`ExtraFiles`，管道将无法工作，因为子进程必须获取writer才能写入它：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the actual uppercase command that’s called, there’s code in `cmd/uppercase/uppercase.go`
    that takes the first argument after the command name and changes the case to uppercase.
    The new uppercased text is then encoded into the pipe or extra file descriptor:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际调用的命令中，`cmd/uppercase/uppercase.go` 中有代码，它接受命令名之后的第一个参数并将其转换为大写。然后新的大写文本被编码到管道或额外的文件描述符中：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Back to the `CreateCommandUsingStruct` function, the value that’s encoded into
    the pipe can now be read via the `read` file descriptor of the pipe and then output
    with the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `CreateCommandUsingStruct` 函数，现在可以通过管道的 `read` 文件描述符读取编码到管道中的值，然后使用以下代码输出：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We now know one way of creating a command using the `Cmd` struct. Everything
    could have been defined at once at the same time as the command was initialized
    and depends on your preference.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了一种使用 `Cmd` 结构体创建命令的方法。所有内容都可以在初始化命令的同时一次性定义，这取决于您的偏好。
- en: Using the Command function
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Command 函数
- en: 'Another way to create a command is with the `exec.Command` function. The following
    code resides in `/examples/command.go` within `CreateCommandUsingCommandFunction`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令的另一种方式是使用 `exec.Command` 函数。以下代码位于 `/examples/command.go` 中的 `CreateCommandUsingCommandFunction`：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `exec.Command` function takes the file path to the command as the first
    argument. A slice of strings representing the arguments is optionally passed for
    the remaining parameters. The rest of the function is the same. Because `exec.Command`
    does not take any additional parameters, we similarly define the `ExtraFiles`
    field outside the original variable initialization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec.Command` 函数将命令的文件路径作为第一个参数。可选地传递一个表示参数的字符串切片作为剩余参数。函数的其余部分相同。因为 `exec.Command`
    不接受任何额外的参数，所以我们同样在原始变量初始化之外定义了 `ExtraFiles` 字段。'
- en: Running the command
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行命令
- en: Now that we know how to create commands, there are multiple different ways to
    run or start running a command. While each of these methods has already been described
    in detail earlier in this section, we’ll now share an example of using each.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何创建命令，有多种不同的方式来运行或开始运行一个命令。虽然这些方法在本节前面已经详细描述过，但我们现在将分享使用每个方法的示例。
- en: Using the Run method
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Run 方法
- en: 'The `Run` method, as mentioned earlier, starts the command process, and then
    waits for its completion. The code for this is called from the `main.go` file
    but can be found under `/examples/running.go`. In this example, we call a different
    command called `lettercount`, which counts the letters in a string and then prints
    out the result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Run` 方法启动命令进程，然后等待其完成。此代码从 `main.go` 文件中调用，但可以在 `/examples/running.go`
    中找到。在这个例子中，我们调用了一个名为 `lettercount` 的不同命令，该命令计算字符串中的字母数，然后打印出结果：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Again, we use the `ExtraFiles` field to pass in an additional file descriptor
    to write the result to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用 `ExtraFiles` 字段传递一个额外的文件描述符以写入结果：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result is finally printed with the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最终使用以下代码打印结果：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the Start command
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Start 命令
- en: 'The `Start` method is like the `Run` method; however, it doesn’t wait for the
    process to complete. You can find the code that uses the `Start` command in `examples/running.go`.
    For the most part, it’s identical, but you’ll be replacing the code block containing
    `cmd.Run` with the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start` 方法类似于 `Run` 方法；然而，它不会等待进程完成。您可以在 `examples/running.go` 中找到使用 `Start`
    命令的代码。大部分是相同的，但您将替换包含 `cmd.Run` 的代码块，如下所示：'
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s very important to call the `cmd.Wait` method because it releases resources
    taken by the command process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `cmd.Wait` 方法非常重要，因为它释放了命令进程占用的资源。
- en: Using the Output command
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Output 命令
- en: 'As the method name suggests, the `Output` method returns anything that’s been
    piped into the standard out pipe. The most common way to push from a command to
    the standard output pipe is through any of the print methods in the `fmt` package.
    An additional line is added to the end of the `main` function for the `lettercount`
    command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如方法名所示，`Output` 方法返回所有已通过标准输出管道传入的内容。将命令推送到标准输出管道的最常见方式是通过 `fmt` 包中的任何打印方法。为
    `lettercount` 命令在 `main` 函数的末尾添加了一行：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The only difference within the code that utilizes this `Output` method, which
    can be found in the `examples/running.go` file under the `OutputMethod` function,
    is this line of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此 `Output` 方法的代码中，唯一的区别可以在 `examples/running.go` 文件下的 `OutputMethod` 函数中找到，即这一行代码：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `out` variable is a byte slice that can later be cast to a string to be
    printed out. This variable captures the standard out and when the function is
    run, the output displayed is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`变量是一个字节切片，稍后可以将其转换为字符串以打印输出。这个变量捕获标准输出，当函数运行时，显示的输出如下：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the CombinedOutput command
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CombinedOutput命令
- en: 'As the method name suggests, the `CombinedOutput` method returns a combined
    output of the standard output and standard error piped data. Add a line toward
    the end of the `lettercount` command’s `main` function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如方法名所示，`CombinedOutput`方法返回标准输出和标准错误管道数据的组合输出。在`lettercount`命令的`main`函数末尾添加一行：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only big difference between the calls from the previous function and the
    current function, `CombinedOutputMethod`, is this line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个函数的调用和当前函数`CombinedOutputMethod`之间的唯一重大区别是这一行：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Similarly, it returns a byte slice, but now contains the combined output of
    standard error and standard output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，它返回一个字节切片，但现在包含标准错误和标准输出的组合输出。
- en: Executing commands on Windows
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows上执行命令
- en: 'Alongside the examples are similar files that end with `_windows.go`. The major
    thing to note, in the previous examples, is that `ExtraFiles` is not supported
    on Windows. These Windows-specific and simple examples execute an external `ping`
    command to `google.com`. Let’s take a look at one:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与示例并列的是以`_windows.go`结尾的类似文件。在先前的示例中，需要注意的主要事项是`ExtraFiles`在Windows上不受支持。这些针对Windows的特定和简单示例执行了一个指向`google.com`的外部`ping`命令。让我们看一下其中一个：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Like the commands we’ve written for Darwin, we can create commands using the
    `exec.Command` function or the struct and call `Run`, `Start`, `Wait`, `Output`,
    and `CombinedOutput` just the same.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为Darwin编写的命令一样，我们可以使用`exec.Command`函数或结构体来创建命令，并调用`Run`、`Start`、`Wait`、`Output`和`CombinedOutput`等操作。
- en: 'Also, for pagination, `less` is used on Linux and UNIX machines, but `more`
    is used on Windows. Let’s quickly show this code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于分页，Linux和UNIX机器上使用`less`，而Windows上使用`more`。让我们快速展示这段代码：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similarly, we can pass in the name and all arguments using the `exec.Command`
    method. We also pass the long text into the `moreCmd.Stdin` field.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`exec.Command`方法传递名称和所有参数。我们还把长文本传递到`moreCmd.Stdin`字段。
- en: So, the `os/exec` package offers different ways to create and run external commands.
    Whether you create a quick command using the `exec.Command` method or directly
    create one with the `exec.Cmd` struct and then run the `Start` command, you have
    options. Finally, you can either retrieve the standard output and error output
    separately or together. Knowing all about the `os/exec` package will make it easy
    to successfully run external commands from your Go command-line application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`os/exec`包提供了创建和运行外部命令的不同方式。无论您是使用`exec.Command`方法创建一个快速命令，还是直接使用`exec.Cmd`结构体创建一个命令然后运行`Start`命令，您都有选择。最后，您可以分别或一起检索标准输出和错误输出。了解`os/exec`包将使您能够轻松地从Go命令行应用程序成功运行外部命令。
- en: Interacting with REST APIs
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与REST API交互
- en: Often, if a company or user has already created an API, the command-line application
    will send requests to either the REST API or the gRPC endpoints. Let’s first talk
    about using REST API endpoints. It is important to understand the `net/http` package.
    It’s quite a large package with many types, methods, and functions, many of which
    are used for development on the server side. In this context, the command-line
    application will be the client of the API, so we won’t discuss each in detail.
    We’ll go into a few basic use cases from the client side though.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果公司或用户已经创建了一个API，命令行应用程序将向REST API或gRPC端点发送请求。让我们首先谈谈使用REST API端点。了解`net/http`包非常重要。这是一个相当大的包，包含许多类型、方法和函数，其中许多用于服务器端开发。在这种情况下，命令行应用程序将是API的客户端，因此我们不会详细讨论每个部分。不过，我们将从客户端的角度探讨一些基本用例。
- en: Get request
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GET请求
- en: 'Let’s revisit the code from [*Chapter 3*](B18883_03.xhtml#_idTextAnchor061),
    *Building an Audio Metadata CLI*. Within the `Run` command of the CLI command
    code, found in the `/cmd/cli/command/get.go` file, is a snippet of code that calls
    the corresponding API request endpoint using the `GET` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[*第3章*](B18883_03.xhtml#_idTextAnchor061)中的代码，*构建音频元数据CLI*。在`/cmd/cli/command/get.go`文件中CLI命令代码的`Run`命令中，有一个调用相应API请求端点的代码片段，使用的是`GET`方法：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that in the preceding code, we take the field value, `id`, which has
    been set on the `cmd` variable, and pass it into the HTTP request as a parameter.
    Consider the flags and arguments to be passed which are to be used as parameters
    for your HTTP request. The following code executes the request:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们取了字段值`id`，它已经在`cmd`变量上设置，并将其作为参数传递到HTTP请求中。考虑要传递的标志和参数，这些参数将用作HTTP请求的参数。以下代码执行请求：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the response is read into a byte string and printed. Prior to accessing
    the body of the response, check whether the response or body is `nil`. This can
    save you from some future headaches:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应被读取到一个字节字符串中并打印出来。在访问响应体之前，检查响应或体是否为`nil`。这可以让你避免一些未来的麻烦：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, in reality, there will be much more done with the response:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实中，会有更多的事情要做：
- en: '`200` `OK`, then we can return the output as it was a successful response.
    Otherwise, in the next section, *Handling the expected – timeouts and errors*,
    we’ll discuss how to handle other responses.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果返回`200` `OK`，则我们可以返回输出，因为它是一个成功的响应。否则，在下一节“处理预期的 – 超时和错误”中，我们将讨论如何处理其他响应。
- en: '**Log the response**: We may, ideally, log the response if it doesn’t contain
    any sensitive data. This detailed information can be written to a log file or
    output when in verbose mode.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录响应**：如果我们认为响应不包含任何敏感数据，理想情况下我们会记录响应。这些详细信息可以写入日志文件或在详细模式下输出。'
- en: '**Store the response**: Sometimes, the response may be stored in a local database
    or cache.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储响应**：有时，响应可能会存储在本地数据库或缓存中。'
- en: '`Content-Type` in the header is set to `application/json`, we would unmarshal
    the JSON response into the struct.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标头中的`Content-Type`设置为`application/json`，我们将JSON响应反序列化到结构体中。
- en: 'Currently, in the audiofile application, we transform the data into an `Audio`
    struct like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在audiofile应用程序中，我们将数据转换成如下`Audio`结构体：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But what if the response body isn’t in JSON format and the content type is
    something else? In a perfect world, we’d have API documentation that informs us
    of what to expect so we can handle it accordingly. Alternatively, you can check
    to confirm the type first using the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果响应体不是JSON格式，而是其他内容类型呢？在一个完美的世界里，我们会有一份API文档，它会告诉我们预期的内容，这样我们就可以相应地处理它。或者，你可以使用以下方法先检查确认类型：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A quick search on the internet for HTTP content types will return a large list.
    In the preceding example, the audio company might have decided to return a `Content-Type`
    value of `audio/wave`. In that case, we could either download or stream the result.
    There are also different HTTP method types defined as constants within the `net/http`
    package:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上快速搜索HTTP内容类型将返回一个长长的列表。在前面的示例中，音频公司可能已经决定返回一个`Content-Type`值为`audio/wave`。在这种情况下，我们既可以下载也可以流式传输结果。`net/http`包中定义了不同的HTTP方法类型作为常量：
- en: '`MethodGet`: Used when requesting data'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodGet`: 用于请求数据'
- en: '`MethodPost`: Used for inserting data'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodPost`: 用于插入数据'
- en: '`MethodPut`: Request is idempotent, used for inserting or updating an entire
    resource'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodPut`: 请求是幂等的，用于插入或更新整个资源'
- en: '`MethodPatch`: Similar to `MethodPut`, but sends only partial data to update
    without modifying the entire resource'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodPatch`: 与`MethodPut`类似，但只发送部分数据以更新，而不修改整个资源'
- en: '`MethodDelete`: Used for deleting or removing data'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodDelete`: 用于删除或移除数据'
- en: '`MethodConnect`: Used when talking to a proxy, when the URI begins with `https://`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodConnect`: 在与代理通信时使用，当URI以`https://`开头时'
- en: '`MethodOptions`: Used to describe the communication options, or allowed methods,
    with the target'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodOptions`: 用于描述与目标之间的通信选项或允许的方法'
- en: '`MethodTrace`: Used for debugging by providing a message loop-back along the
    path of the target'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MethodTrace`: 通过提供目标路径上的消息回环用于调试'
- en: 'There are many possibilities for the method types and content types of data
    returned. In the preceding `Get` example, we use a client’s `Do` method to call
    the method. Another option is to use the `http.Get` method. If we use that method,
    then we would use this code instead to execute the request:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数据返回的方法类型和内容类型有很多可能性。在前面的`Get`示例中，我们使用客户端的`Do`方法调用该方法。另一种选择是使用`http.Get`方法。如果我们使用该方法，那么我们将使用以下代码来执行请求：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similarly, rather than using the `client.Do` method for a post or to post a
    form, there are specific `http.Post` and `http.PostForm` methods that can be used
    instead. There are times when one method works better for what you are doing.
    At this point, it’s just important to understand your options.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，与其使用`client.Do`方法进行POST操作或提交表单，不如使用特定的`http.Post`和`http.PostForm`方法。有时，一个方法更适合你所做的事情。在这个时候，重要的是要了解你的选项。
- en: Pagination
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页
- en: 'Suppose there is a large amount of data being returned by the request. Rather
    than overloading the client by receiving the data all at once, often pagination
    is an option. There are two fields that can be passed in as parameters to the
    call:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设请求返回了大量的数据。与其一次性接收所有数据而使客户端过载，通常分页是一个选项。调用中可以传递两个作为参数的字段：
- en: '`Limit`: The number of objects to be returned'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Limit`：要返回的对象数量'
- en: '`Page`: The cursor for multiple pages of results returned'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Page`：返回多页结果的游标'
- en: 'We can define these internally and then formulate the path as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以内部定义这些，然后按照以下方式构建路径：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure, if you’re using an external API, to construct their documentation
    with the proper parameters for pagination and usage. This is just a general example.
    In fact, there are several other ways of doing pagination. You can send additional
    requests in a loop, incrementing the page until all data is retrieved.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用外部API，请确保使用适当的分页和用法参数构建它们的文档。这只是一个通用示例。实际上，还有几种其他实现分页的方法。你可以在循环中发送额外的请求，增加页面数，直到检索到所有数据。
- en: 'From the command side, however, you could return all the data after pagination,
    but you can also handle pagination on the CLI side. A way to handle it on the
    client side after a large amount of data is collected from an HTTP `Get` request
    is to pipe the data. This data can be piped into the operating system’s pager
    command. For UNIX, `less` is the pager command. We create the command and then
    pipe the string output to the `Stdin` pipe. This code can be found in the `examples/pagination.go`
    file. Similar to the other examples we’ve shared when creating a command, we create
    a pipe and pass in the writer as an extra file descriptor to the command so that
    data may be written out:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从命令行方面，你可以在分页后返回所有数据，也可以在CLI端处理分页。在从HTTP `Get`请求收集了大量数据后，在客户端处理分页的一种方法是将数据管道化。这些数据可以被管道化到操作系统的分页命令中。对于UNIX，`less`是分页命令。我们创建命令，然后将字符串输出管道化到`Stdin`管道。这段代码可以在`examples/pagination.go`文件中找到。类似于我们分享的其他示例，在创建命令时，我们创建一个管道并将写入器作为额外的文件描述符传递给命令，以便可以写出数据：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Again, the data from the reader is decoded into the `data` `string` variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从读取器中解码的数据被编码到`data` `string`变量中：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This string is then passed into the `Strings.NewReader` method and defined
    as the input for the `less` UNIX command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个字符串被传递到`Strings.NewReader`方法中，并定义为`less` UNIX命令的输入：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the command is run, the data is output as pages. The user then can press
    the spacebar to continue to the next page or use any of the command keys to navigate
    the data output.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令运行时，数据以页面的形式输出。然后用户可以按空格键继续到下一页，或者使用任何命令键来导航数据输出。
- en: Rate limiting
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率限制
- en: Often, when dealing with third-party APIs, there’s a limit to how many requests
    can be handled within a particular time. This is commonly known as **rate limiting**.
    For a single command, you might require multiple requests to an HTTP endpoint
    and so you might prefer to limit how often you’re sending these requests. Most
    public APIs will inform users of their rate limits, but there are times when you’ll
    hit the rate limit of an API unexpectedly. We’ll discuss how to limit your requests
    to stay within the limits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在处理第三方API时，特定时间内可以处理多少请求是有限制的。这通常被称为**速率限制**。对于单个命令，你可能需要向HTTP端点发送多个请求，因此你可能更喜欢限制发送这些请求的频率。大多数公共API都会通知用户他们的速率限制，但有时你会意外地达到API的速率限制。我们将讨论如何限制你的请求以保持在限制内。
- en: There is a useful library, `x/time/rate`, that can be used to define the limit,
    which is how often something should be executed, and limiters that control the
    process from executing within the limit. Let’s use some example code, supposing
    we want to execute something every five seconds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有用的库`x/time/rate`，可以用来定义限制，即某事应该执行的频率，以及限制器，它控制过程在限制内执行。让我们使用一些示例代码，假设我们想要每五秒执行一次。
- en: 'The code for this particular example is located in the `examples/limiting.go`
    file. To reiterate, this is just an example and there are different ways to use
    `runner`. We’re going to cover just a basic use case. We start by defining a struct
    that contains a function, `Run`, and the `limiter` field, which controls how often
    it will run. The `Limit()` function will use the `runner` struct to call a function
    within a rate limit:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定示例的代码位于`examples/limiting.go`文件中。再次强调，这只是一个示例，使用`runner`的方式有很多种。我们将只介绍基本用法。我们首先定义一个包含函数`Run`和`limiter`字段的`struct`，后者控制其运行频率。`Limit()`函数将使用`runner`结构体在速率限制内调用函数：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After defining `thing` as a `runner` instance, we get the start time and then
    define the function of `thing`. If the call is allowed within the time, because
    it does not exceed the limit, we print the current timestamp and return a `false`
    variable. We exit the function when at least 30 seconds have passed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`thing`定义为`runner`实例之后，我们获取开始时间，然后定义`thing`的功能。如果调用在规定时间内允许，因为不超过限制，我们打印当前时间戳并返回一个`false`变量。当至少过去30秒时，我们退出函数：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We define the limiter for `thing`. We’ve used a customer variable, which we’ll
    look at in more detail shortly. Simply, the `NewLimiter` method takes two variables.
    The first parameter is the limit, one event every five seconds, and the second
    parameter allows bursts for, at most, a single token:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`thing`定义了限制器。我们使用了一个自定义变量，我们将在稍后详细讨论。简单来说，`NewLimiter`方法接受两个变量。第一个参数是限制，每五秒一个事件，第二个参数允许最多一个令牌的突发：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For those not familiar with the difference between a limit and a burst, a burst
    defines the number of concurrent requests the API can handle. The rate limit is
    the number of requests allowed per the defined time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉限制和突发之间区别的人来说，突发定义了API可以处理的并发请求数量。速率限制是每单位时间内允许的请求数量。
- en: 'Next, inside a `for` loop, we call the `Run` function and only break when it
    returns `true`, which should be after 30 seconds have passed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`for`循环内部，我们调用`Run`函数，并且只有在它返回`true`时才退出循环，这通常是在30秒后：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As mentioned, the `forEvery` function, which returns a rate limit, is passed
    into the `NewLimiter` method. It simply calls the `rate.Every` method, which takes
    the minimum time interval between events and converts it into a limit:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，返回速率限制的`forEvery`函数被传递到`NewLimiter`方法中。它简单地调用`rate.Every`方法，该方法接受事件之间的最小时间间隔并将其转换为限制：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We run this code and the timestamps are output. Notice that they are output
    every five seconds:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行这段代码，时间戳每五秒输出一次。注意，它们每五秒输出一次：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are other ways of handling limiting requests, such as using a `time.Sleep(d
    Duration)` method after the code that is called inside a loop. I suggest using
    the `rate`package because it is great for not only limiting executions but also
    handling bursts. It has a lot more functionality that can be used for more complex
    situations when you are sending requests to an external API.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 处理限制请求还有其他方法，例如在循环内部调用的代码之后使用`time.Sleep(d Duration)`方法。我建议使用`rate`包，因为它不仅适用于限制执行，还适用于处理突发情况。它具有更多功能，可以在发送请求到外部API时用于更复杂的情况。
- en: You’ve now learned how to send requests to external APIs and how to handle the
    response, and when you receive a successful response, how to transform and paginate
    the results. Also, because rate limiting is commonly required for APIs, we’ve
    discussed how to do that. Since this section has only handled the case of success,
    let’s consider how to handle the case of failure in the following section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经学会了如何向外部API发送请求以及如何处理响应，当收到成功的响应时，如何转换和分页结果。此外，由于速率限制对于API来说是常见的，我们已经讨论了如何实现这一点。由于本节只处理了成功的情况，让我们在下一节中考虑如何处理失败的情况。
- en: Handling the expected – timeouts and errors
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理预期的 – 超时和错误
- en: When building a CLI that calls external commands or sends HTTP requests to an
    external API, with data that is passed in by the user, it’s a good idea to expect
    the unexpected. In a perfect world, you can guard against bad data. I’m sure you
    are familiar with the phrase *garbage in*, *garbage out.* You can create tests
    that also ensure that your code is covered for as many bad cases as you can think
    of. However, timeouts and errors happen. It’s the nature of software, and as you
    come across them within your development and also in production, you can modify
    your code to handle new cases.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个调用外部命令或向外部API发送HTTP请求的CLI时，使用用户传入的数据，预期意外情况是一个好主意。在理想的世界里，您可以防止不良数据。我相信您熟悉短语*垃圾输入，垃圾输出*。您可以创建测试，以确保您的代码覆盖了尽可能多的坏情况。然而，超时和错误是会发生的。这是软件的本质，当您在开发和生产中遇到它们时，您可以修改您的代码来处理新情况。
- en: Timeouts with external command processes
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部命令进程的超时
- en: 'Let’s first discuss how to handle timeouts when calling external commands.
    The timeout code exists within the `examples/timeout.go` file. The following is
    the entire method, which calls the `timeout` command. If you take a look at the
    `timeout` command code, located within `cmd/timeout/timeout.go`, you’ll see that
    it contains a basic infinite loop. This command will time out, but we need to
    handle the timeout with the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论在调用外部命令时如何处理超时。超时代码位于`examples/timeout.go`文件中。以下是一个完整的方法，它调用了`timeout`命令。如果您查看位于`cmd/timeout/timeout.go`中的`timeout`命令代码，您会看到它包含一个基本的无限循环。此命令将超时，但我们需要使用以下代码来处理超时：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We first define an error channel, `errChan`, which will receive any error returned
    from the `cmd.Wait()` method. The command, `cmd`, is then defined, and next `cmd`’s
    `Start` method is called to initiate the external process. Within a Go function,
    we wait for the command to return using the `cmd.Wait()` method. `errChan` will
    only receive the error value once the command has exited and the copying to standard
    input and standard error has completed. Within the following `select` block, we
    wait to receive from two different channels. The first case waits for the time
    returned after 10 seconds. The second case waits for the command to complete and
    receive the error value. This code allows us to gracefully handle any timeout
    issues.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个错误通道，`errChan`，它将接收来自`cmd.Wait()`方法的任何错误。然后定义命令`cmd`，接下来调用`cmd`的`Start`方法来启动外部进程。在Go函数中，我们使用`cmd.Wait()`方法等待命令返回。`errChan`仅在命令退出并且标准输入和标准错误复制完成后才会接收错误值。在下面的`select`块中，我们等待从两个不同的通道接收。第一种情况等待10秒后返回的时间。第二种情况等待命令完成并接收错误值。此代码使我们能够优雅地处理任何超时问题。
- en: Errors or panics with external command processes
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部命令进程的错误或恐慌
- en: First, let’s define the difference between errors and panics. Errors occur when
    the application can be recovered but is in an abnormal state. If a panic occurs,
    then something unexpected happened. For example, we try to access a field on a
    `nil` pointer or attempt to access an index that is out of bounds for an array.
    We can start by handling errors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义错误和恐慌之间的区别。错误发生在应用程序可以被恢复但处于异常状态时。如果发生恐慌，则表示发生了意外情况。例如，我们尝试访问`nil`指针上的字段或尝试访问超出数组索引范围的索引。我们可以从处理错误开始。
- en: 'There are a couple of errors that exist within the `os/exec` package:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`os/exec`包中存在一些错误：'
- en: '`exec.ErrDot`: Error when the file path of the command failed to resolve within
    the current directory, `"."`, hence the name `ErrDot`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec.ErrDot`：当命令的文件路径在当前目录`"."`中无法解析时发生的错误，因此命名为`ErrDot`'
- en: '`exec.ErrNotFound`: Error when the executable fails to resolve in the defined
    file path'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec.ErrNotFound`：当可执行文件在定义的文件路径中无法解析时发生的错误'
- en: You can check for the type to handle each error uniquely.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以检查类型以独特地处理每个错误。
- en: Handling errors when a command’s path cannot be found
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理命令路径找不到时的错误
- en: 'The following code exists within the `examples/error.go` file in the `HandlingDoesNotExistErrors`
    function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于`examples/error.go`文件中的`HandlingDoesNotExistErrors`函数中：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When checking the type of the command, use the `errors.Is` method, rather than
    checking whether `cmd.Err == exec.ErrDot` because the error is not returned directly.
    The `errors.Is` method checks the error chain for any occurrence of the specific
    error type.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查命令类型时，使用`errors.Is`方法，而不是检查`cmd.Err == exec.ErrDot`，因为错误不是直接返回的。`errors.Is`方法检查错误链中是否存在特定错误类型的任何发生。
- en: Handling other errors
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理其他错误
- en: 'Also, within the `examples/error.go` file is handling an error thrown by the
    command process itself. This second method, `HandlingOtherMethods`, sets the command’s
    standard error to a buffer that we can later use if an error is returned from
    the command. Let’s take a look at the code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`examples/error.go`文件中，还处理了命令进程本身抛出的错误。第二种方法`HandlingOtherMethods`将命令的标准错误设置为我们可以稍后使用的缓冲区。让我们看看代码：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When an error is encountered, we print not only the error, `exit status 1`,
    but also any data that has been piped into the standard error pipe, which should
    give the users more detail on why the error occurred.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到错误时，我们不仅打印错误，`退出状态 1`，还打印任何已通过标准错误管道管道的数据，这应该使用户能够获得更多关于错误发生原因的详细信息。
- en: 'To further understand how this code works, let’s take a look at the error command
    implementation that exists in the `cmd/error/error.go` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解这段代码的工作原理，让我们看看`cmd/error/error.go`文件中存在的错误命令实现：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since we are not passing any arguments into the command function, after we check
    the length of `os.Args`, we print to the standard error pipe the reason we are
    exiting with a non-zero exit code. This is a very simple way to handle errors
    in an effective manner. When calling this external process, we just return the
    errors, but as we’ve all probably experienced, error messages can be a bit cryptic.
    In later chapters, we will talk about how we can rewrite these to be more human-readable
    and provide a few examples.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有将任何参数传递给命令函数，在检查`os.Args`的长度后，我们将退出原因打印到标准错误管道。这是一种非常简单但有效处理错误的方法。在调用外部进程时，我们只是返回错误，但正如我们可能都经历过的一样，错误信息可能有点晦涩。在后面的章节中，我们将讨论如何将这些错误信息重写为更易读的格式，并提供一些示例。
- en: In [*Chapter 4*](B18883_04.xhtml#_idTextAnchor087), *Popular Frameworks for
    Building CLIs*, we discussed the use of the `RunE` function within the Cobra Command
    struct, which allows us to return an error value when the command is run. If you
    are calling an external process within the `RunE` method, then you can capture
    and return the error to the user, after rewriting it to a more human-readable
    format, of course!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18883_04.xhtml#_idTextAnchor087) *构建CLIs的流行框架*中，我们讨论了在Cobra命令结构中`RunE`函数的使用，这允许我们在命令运行时返回一个错误值。如果你在`RunE`方法中调用外部进程，那么你可以捕获并返回错误给用户，当然，在将其重写为更易读的格式之后！
- en: 'Panics are handled differently than errors, but it is a good practice to, within
    your own code, provide a way to recover from a panic gracefully. You can see this
    code initiated within the `examples/panic.go` file within the `Panic` method.
    This calls the `panic` command, located in `cmd/panic/panic.go`. This command
    simply panics and then recovers. It returns the panic message to the standard
    error pipe, prints the stack, and exits with a non-zero exit code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于恐慌（panic），处理方式与错误不同，但提供一个从恐慌中优雅恢复的方法是良好的编程实践。你可以在`examples/panic.go`文件中的`Panic`方法中看到这段代码的初始化。这个方法调用位于`cmd/panic/panic.go`中的`panic`命令。这个命令简单地引发恐慌然后恢复。它将恐慌信息返回到标准错误管道，打印堆栈，并以非零退出代码退出：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: On the side that runs this command, we handle it just like any other error by
    capturing the error and printing data piped into the standard error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此命令的一侧，我们像处理任何其他错误一样处理它，通过捕获错误并打印到标准错误管道中的数据。
- en: Timeouts and other errors with HTTP requests
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP请求中的超时和其他错误
- en: 'Similarly, you could also experience errors when sending requests to an external
    API server. To be clear, timeouts are considered errors as well. The code for
    this example is located within `examples/http.go`, which contains two functions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你发送请求到外部API服务器时也可能遇到错误。为了清楚起见，超时也被视为错误。此示例的代码位于`examples/http.go`中，其中包含两个函数：
- en: '`HTTPTimeout()`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPTimeout()`'
- en: '`HTTPError()`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPError()`'
- en: Before we dig into the previous methods, let’s talk about the code that needs
    to be running in order for these methods to execute properly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究之前的方法之前，让我们谈谈为了使这些方法正确执行，需要运行的代码。
- en: 'The `cmd/api/` folder contains the code for defining the handlers and starting
    an HTTP server locally. The `mux.HandleFunc` method defines the request pattern
    and matches it to the `handler` function. The server is defined by its address,
    which runs on localhost, port `8080`, and the `Handler`, `mux`. Finally, the `server.ListenAndServe()`
    method is called on the defined server:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd/api/`文件夹包含定义处理程序和本地启动HTTP服务器的代码。`mux.HandleFunc`方法定义请求模式并将其与`handler`函数匹配。服务器通过其地址定义，运行在localhost，端口`8080`，以及`Handler`，`mux`。最后，在定义的服务器上调用`server.ListenAndServe()`方法：'
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The timeout handler is defined simply. It waits two seconds before sending
    the response by using the `time.After(time.Second*2)` channel:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 超时处理程序被简单地定义。它等待两秒钟后通过使用`time.After(time.Second*2)`通道发送响应：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The error handler returns a status code of `http.StatusInternalServerError`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理程序返回状态码`http.StatusInternalServerError`：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In a separate terminal, run the `make install` command inside the root of the
    repository to start the API server. Now, let’s look at the code that calls each
    endpoint and show how we handle it. Let’s first discuss the first type of error
    – the timeout:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，在存储库的根目录下运行`make install`命令以启动API服务器。现在，让我们看看调用每个端点的代码，并展示我们如何处理它。让我们首先讨论第一种错误类型——超时：
- en: '`HTTPTimeout`: Inside the `examples/http.go` file resides the `HTTPTimeout`
    method. Let’s walk through the code together:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPTimeout`：在`examples/http.go`文件中存在`HTTPTimeout`方法。让我们一起走过这段代码：'
- en: 'First, we *define the client* using the `http.Client` struct, specifying the
    timeout as one second. Remember that as the timeout handler on the API returns
    a response after two seconds, the request is sure to timeout:'
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用`http.Client`结构体**定义客户端**，指定超时为一秒。记住，由于API上的超时处理程序在两秒后返回响应，因此请求肯定会超时：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we *define the request*: a `GET` method to the `/timeout` endpoint. We
    pass in an empty body:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们**定义请求**：一个对`/timeout`端点的`GET`方法。我们传递一个空的主体：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The client `Do` method is called with the request variable passed in as a parameter.
    We wait for the server to respond within a second and if not, an error is returned.
    Any errors returned by the client’s `Do` method will be of the `*url.Error` type.
    You can access the different fields to this error type, but in the following code,
    we check whether the error’s `Timeout` method returns `true`. In this statement,
    we can act however we’d like. We can return the error for now. We can back off
    and retry or we can exit. It depends on what your specific use case is:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端`Do`方法使用请求变量作为参数被调用。我们等待服务器在一秒内响应，如果没有，则返回错误。客户端`Do`方法返回的错误将是`*url.Error`类型。您可以访问此错误类型的不同字段，但在以下代码中，我们检查错误的`Timeout`方法是否返回`true`。在这个语句中，我们可以按自己的意愿行事。我们可以暂时返回错误，我们可以退避并重试，或者我们可以退出。这取决于您的具体用例：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When this method is executed, the output is printed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当此方法执行时，输出如下：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A timeout is just one error, but there are many others you might encounter.
    Since the client `Do` method returns a particular error type in the `net/url`
    package, let’s discuss that. Inside the `net/url` package exists the `url.Error`
    type definition:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 超时只是其中一种错误，但您可能会遇到许多其他错误。由于客户端`Do`方法在`net/url`包中返回特定的错误类型，让我们来讨论一下。在`net/url`包中存在`url.Error`类型定义：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The error contains the `Timeout()`method, which returns `true` when a request
    times out, and it is important to note that when the response status is anything
    other than `200 OK`, the error is not set. However, the status code indicates
    an error response. Error responses can be split into two different categories:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 错误包含`Timeout()`方法，当请求超时时返回`true`，并且需要注意的是，当响应状态不是`200 OK`时，错误不会被设置。然而，状态码指示错误响应。错误响应可以分为两个不同的类别：
- en: '`400` to `499`) indicate an error on the client’s side. A few examples of this
    include `Bad Request (400)`, `Unauthorized (401)`, and `Not` `Found (404)`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`400`到`499`)表示客户端发生错误。一些例子包括`Bad Request (400)`、`Unauthorized (401)`和`Not Found
    (404)`。
- en: '`500` to `599`) indicate an error on the server side. A few common examples
    of this include `Internal Server Error (500)`, `Bad Gateway (502)`, and `Service`
    `Unavailable (503)`.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (`500`到`599`)表示服务器端发生错误。一些常见的例子包括`Internal Server Error (500)`、`Bad Gateway
    (502)`和`Service Unavailable (503)`。
- en: '`HTTPErrors`: Some sample code of how this can be handled exists within the
    `examples/http.go` file within the `HTTPErrors` method. Again, it’s important
    to make sure that the API server is running before executing this code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPErrors`：如何在`examples/http.go`文件中的`HTTPErrors`方法中处理这种情况的示例代码存在。同样，在执行此代码之前确保API服务器正在运行非常重要：'
- en: 'The code within the method starts by calling a `GET` request to the `/``error`
    endpoint:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法中的代码首先通过调用对`/error`端点的`GET`请求开始：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the error is not `nil`, then we cast it to the `url.Error` type to access
    the fields and methods within it. For example, we check whether `urlError` is
    a timeout or a temporary network error. If it is neither, then we can output as
    much information as we know about the error to standard output. This additional
    information can help us to determine what steps to take next:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误不是`nil`，那么我们将它转换为`url.Error`类型以访问其中的字段和方法。例如，我们检查`urlError`是否是超时或临时网络错误。如果不是这两种情况，那么我们可以输出我们所知道的所有关于错误的信息到标准输出。这些附加信息可以帮助我们确定下一步要采取的措施：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since the status code error response isn’t considered a Golang error, the response
    body might have some useful information. If it’s not `nil`, then we can read the
    status code:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于状态码错误响应不被视为Go语言错误，响应体可能包含一些有用的信息。如果它不是`nil`，那么我们可以读取状态码：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We initially check that `StatusCode` doesn’t equal `http.StatusOK`. From there,
    we can check for particular error messages and take the appropriate action. In
    this example, we only check for three different types of error responses, but
    you can check for whichever ones make sense for what you’re doing:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最初检查`StatusCode`是否不等于`http.StatusOK`。从那里，我们可以检查特定的错误消息并采取适当的行动。在这个例子中，我们只检查了三种不同类型的错误响应，但你可以检查对你所做的事情有意义的任何类型：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, a client or server error status does not necessarily mean that the
    response body is `nil`. We can output the response body in case there’s any useful
    information we can further gather:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，客户端或服务器错误状态并不一定意味着响应体是`nil`。如果其中包含任何有用的信息，我们可以输出响应体：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This concludes the section for handling HTTP timeouts and other errors. Although
    the examples are simple, they give you the necessary information and guidance
    to handle timeouts, temporary networks, and other errors.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了处理HTTP超时和其他错误的章节。尽管示例很简单，但它们为你提供了处理超时、临时网络和其他错误所必需的信息和指导。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Over the course of this chapter, you’ve learned about the `os/exec` package
    in depth. This included learning about the different ways to create commands:
    using the `command` struct or the `Command` method. Not only have we created commands,
    but we’ve also passed file descriptors to them to receive information back. We
    learned about the different ways to run a command using the `Run` or `Start` method
    and the multiple ways of retrieving data from the standard output, standard error
    types, and other file descriptors.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你深入了解了`os/exec`包。这包括学习创建命令的不同方式：使用`command`结构体或`Command`方法。我们不仅创建了命令，还向它们传递文件描述符以接收信息。我们学习了使用`Run`或`Start`方法运行命令的不同方式，以及从标准输出、标准错误类型和其他文件描述符检索数据的多重方式。
- en: In this chapter, we also discussed the `net/http` and `net/url` packages, which
    are important to be comfortable with when creating HTTP requests to external API
    servers. Several examples taught us how to create requests with the methods on
    `http.Client`, including `Do`, `Get`, `Post`, and `PostForm`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还讨论了`net/http`和`net/url`包，当创建对外部API服务器的HTTP请求时，熟悉这些包非常重要。几个示例教会了我们如何使用`http.Client`上的方法创建请求，包括`Do`、`Get`、`Post`和`PostForm`。
- en: It’s important to learn how to build robust code, and handling errors gracefully
    is part of the process. We need to know how to capture errors first, so we discussed
    how to detect some common errors that can occur when running an external process
    or sending a request to an external API server. Capturing and handling other errors
    gives us confidence that our code is ready to take appropriate action when they
    occur. Finally, we now know how to check for different status codes when the response
    is not okay.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何构建健壮的代码非常重要，而优雅地处理错误是这个过程的一部分。我们需要知道如何首先捕获错误，因此我们讨论了在运行外部进程或向外部API服务器发送请求时可能发生的某些常见错误的检测方法。捕获和处理其他错误使我们确信我们的代码在它们发生时能够采取适当的行动。最后，我们现在知道如何在响应不正常时检查不同的状态码。
- en: With all the information learned in this chapter, we should now be more confident
    in building a CLI that interacts with external commands or sends requests to external
    APIs. In the next chapter, we’ll learn how to write code that can run on multiple
    different architectures and operating systems.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了本章的所有信息后，我们现在应该更有信心构建一个与外部命令交互或向外部API发送请求的CLI。在下一章，我们将学习如何编写可以在多个不同的架构和操作系统上运行的代码。
- en: Questions
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What method in the `time` package do we use to receive the time after a particular
    duration via a channel?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`time`包中，我们使用什么方法通过通道接收特定持续时间后的时间？
- en: What is the error type returned from `http.Client`’s `Do` method?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http.Client`的`Do`方法返回的错误类型是什么？'
- en: When an HTTP request receives a response with a status code other than `StatusOK`,
    is the error returned from the request populated?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当HTTP请求收到一个状态码不是`StatusOK`的响应时，请求返回的错误是否被填充？
- en: Answers
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`time.After(d Duration) <-``chan Time`'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`time.After(d Duration) <-chan Time`'
- en: '`*``url.Error`'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*url.Error`'
- en: 'No'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Further reading
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Visit the online documentation for `net/http` `at` `h`[ttps://pkg.go.dev/net/http](https://pkg.go.dev/net/http),
    and for net/url at h[ttps://pkg.go.dev/net/url](https://pkg.go.dev/net/url)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请访问`net/http`的在线文档[在此](https://pkg.go.dev/net/http)，以及`net/url`的文档[在此](https://pkg.go.dev/net/url)
