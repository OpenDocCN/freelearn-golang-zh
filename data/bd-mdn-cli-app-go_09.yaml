- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: The Empathic Side of Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发的同理心方面
- en: Empathy has been a hot topic lately, and its relation to software is no exception.
    This chapter will discuss how to use empathy to develop a better CLI. Empathy-driven
    CLI development is done with consideration of the output and errors that are written
    and the clarity and reassurance it may give the user. Written documentation that
    takes an empathetic approach also provides users with an effortless way to get
    started, while help and support are readily available for users when they need
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 同理心最近成为了一个热门话题，它与软件的关系也不例外。本章将讨论如何使用同理心来开发更好的CLI。以同理心驱动的CLI开发会考虑到所编写的输出和错误以及它们可能给用户带来的清晰度和信心。采用同理心方法的书面文档还为用户提供了一种轻松上手的方式，而当用户需要时，帮助和支持也随时可用。
- en: This chapter will give examples of how to rewrite errors in a way that users
    may easily understand, not just by being clearer that an error occurred but also
    how and where (with debug and traceback information), which can be provided with
    a `--verbose` flag and detailed logging. It is very important to provide logs
    for users, and this implementation will be described when discussing debug and
    traceback information. Users can also feel more reassured with the help of man
    pages, usage examples of each command, empathically written documentation, and
    a quick and easy way to submit bugs that are encountered within the application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将给出如何以用户易于理解的方式重写错误的示例，不仅使错误发生更加清晰，还包括如何以及在哪里（通过调试和回溯信息）提供，这些可以通过`--verbose`标志和详细的日志来实现。为用户提供日志非常重要，当讨论调试和回溯信息时，这种实现将被描述。用户还可以通过手册页、每个命令的使用示例、同理心编写的文档以及快速轻松提交在应用程序中遇到的bug的方式来感到更加放心。
- en: 'Taking an empathetic approach into many different areas of your application,
    as well as in your life, is a form of not only self-care but care for others as
    well. Hopefully, these tips will help to create a CLI that meets the user at their
    perspective and provides them with a feeling of reassurance. Specifically, this
    chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将同理心方法应用到应用程序的许多不同领域以及你的生活中，这不仅是一种自我关爱，也是一种对他人的关爱。希望这些建议能帮助你创建一个能够满足用户视角并给他们带来安心感的CLI。具体来说，本章将涵盖以下主题：
- en: Rewriting errors to be human-readable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误重写为人类可读格式
- en: Providing debug and traceback information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供调试和回溯信息
- en: Effortless bug submission
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无障碍的bug提交
- en: Help, documentation, and support
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助、文档和支持
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'These are the requirements for this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的要求：
- en: A Unix operating system to understand and run the examples shared in the chapter
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Unix操作系统，以便理解和运行本章中共享的示例
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter09](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter09)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到代码示例：[https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter09](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter09)
- en: Rewriting errors to be human-readable
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将错误重写为人类可读格式
- en: Errors can be a big point of frustration for users as they can set users off
    their original plans. Users will be grateful, though, if you can make the process
    as painless as possible. In this section, we will discuss some ways to ease users
    when an error occurs and provide some guidelines for creating better error messages
    and avoiding some common mistakes. Creating clear and helpful error messages is
    often overlooked, yet they are very impactful toward an optimal UX.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能会成为用户的一大挫折点，因为它们可能会打乱用户的原始计划。然而，如果你能尽可能地使这个过程不那么痛苦，用户会非常感激。在本节中，我们将讨论一些在发生错误时减轻用户痛苦的方法，并提供一些创建更好的错误信息和避免一些常见错误指南。创建清晰且有帮助的错误信息往往被忽视，但它们对最佳用户体验有着非常重大的影响。
- en: Think of some of your subjective experiences while working with CLIs and some
    of the errors you have encountered. This is an opportunity to think about how
    experiences can be improved for yourself when working with your own CLI, but also
    for others.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你在使用命令行界面（CLI）时的一些主观体验以及你遇到的一些错误。这是一个思考如何改进自己使用CLI时的体验的机会，同时也为他人考虑。
- en: Guidelines for writing error messages
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写错误信息的指南
- en: 'Here are some useful guidelines when writing error messages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写错误信息时，以下是一些有用的指南：
- en: '**Be specific**: Customize messages toward the actual task that has occurred.
    This error message is critical if the task required inputting credentials or a
    final command to complete a workflow. The best experience would include specifying
    the exact problem and then providing a way toward correcting the issue. Specific
    guidance helps the users stay engaged and willing to make corrections.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体化**：针对实际发生的任务定制信息。如果任务需要输入凭证或最终命令来完成工作流程，这个错误信息至关重要。最好的体验包括指定确切的问题并提供解决问题的方法。具体的指导有助于用户保持参与并愿意进行更正。'
- en: '**Remind the user that there’s a human on the other end**: A generic error
    message can sound very technical and intimidating to most users. By rewriting
    the error message, you can make them more useful and less intimidating. Empathize
    with your users and make sure that you don’t place blame on the user, which can
    be particularly discouraging. It’s important to encourage the user by being understanding,
    friendly, and speaking the same language, both literally and figuratively! How
    do the words you use sound in conversation?'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提醒用户另一端有真人**：一个通用的错误信息可能会让大多数用户听起来非常技术化和令人生畏。通过重新编写错误信息，你可以使它们更有用，不那么令人生畏。同情你的用户，并确保你不会责怪用户，这可能会特别令人沮丧。通过理解、友好地交流，并且字面和比喻上都使用相同的语言，鼓励用户是非常重要的！你用的词在对话中听起来怎么样？'
- en: '**Keep it light-hearted**: Keeping a light-hearted tone can help ease any tension
    when an error occurs, but be careful! In certain situations, it might make the
    situation a bit worse—especially if it’s a critical task. Users do not want to
    feel mocked. Regardless, with humor or not, the error message should still be
    informational, clear, and polite.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持轻松愉快**：保持轻松愉快的语气可以帮助在发生错误时缓解紧张情绪，但要注意！在某些情况下，这可能会使情况变得更糟——尤其是如果这是一个关键任务。用户不希望感到被嘲笑。无论如何，无论是否有幽默感，错误信息仍然应该是信息性的、清晰的和礼貌的。'
- en: '**Make it easy**: This will require you to do a bit more of the heavy lifting,
    but it will certainly be worth it in the end. Provide clear next steps, or commands
    to run, to resolve the issue and to help the user get back on track to what they
    had originally intended on doing. With helpful suggestions, the user will at least
    see the path through the trees and know what to do next.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让它变得简单**：这需要你做更多的工作，但最终绝对值得。提供清晰的下一步操作或要运行的命令，以解决问题并帮助用户回到他们最初想要做的事情上。有了有用的建议，用户至少可以看到穿过树林的道路，并知道下一步该做什么。'
- en: '**Consider the best placement**: When outputting error messages, it’s best
    to place them in an area where users will look first. In the case of the CLI,
    it’s most likely at the end of the output.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑最佳位置**：在输出错误信息时，最好将它们放置在用户首先会看的地方。在CLI的情况下，最可能是在输出的末尾。'
- en: '**Consolidate errors**: If there are multiple error messages, especially similar
    ones, group them together. It will look much better than repeating the same error
    message over and again.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合并错误**：如果有多个错误信息，尤其是相似的信息，将它们分组在一起。这样看起来会比反复重复相同的错误信息要好得多。'
- en: '**Optimize your error message with icons and text**: Usually, important information
    is placed at the end of the output, but if there’s any red text on the screen,
    that is often where the user’s eyes will be drawn to. Given the power of color,
    use it sparingly and with intention.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用图标和文本优化错误信息**：通常，重要信息被放置在输出的末尾，但如果屏幕上有任何红色文本，用户通常会注意到那里。鉴于颜色的力量，要谨慎使用，并有目的地使用。'
- en: '**Consider capitalization and punctuation**: Don’t write in all caps or with
    multiple exclamation points. Consider consistency as well—do your errors start
    with capitalization? If they are output to a log, errors may start all in lowercase
    letters.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑大小写和标点符号**：不要全部大写或使用多个感叹号。还要考虑一致性——你的错误信息是否以大写字母开头？如果它们被输出到日志中，错误可能全部以小写字母开头。'
- en: Decorating errors
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰错误
- en: Wrapping errors with additional information and context is a very important
    step. What is the specific task that failed and why? This helps the user understand
    what happened. Providing actions to take toward resolution will also help the
    user feel more supported and willing to move forward.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误信息中添加额外的信息和上下文是一个非常重要的步骤。具体任务失败的原因是什么？这有助于用户了解发生了什么。提供采取行动以解决问题的方法也将帮助用户感到更有支持感，并愿意继续前进。
- en: 'First, there are a few ways to decorate your errors with additional information.
    You can use the `fmt.Errorf` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有几种方法可以装饰你的错误信息以提供更多信息。你可以使用`fmt.Errorf`函数：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this function, you can print out the error as a string with any additional
    context. Here’s an example within the `errors/errors.go` file in the `Chapter-9`
    repo:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，你可以打印出带有任何附加上下文的错误字符串。以下是在`Chapter-9`仓库中的`errors/errors.go`文件中的一个示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next way to decorate your errors is by using the `errors.Wrap` method.
    This method is fully defined as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种装饰错误的方法是使用`errors.Wrap`方法。该方法完全定义如下：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It returns an error annotating `err` with a message and a stack trace at the
    point the method is called. If `err` is `nil`, then the `Wrap` function also returns
    `nil`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个错误，在方法调用点注释`err`的消息和堆栈跟踪。如果`err`是`nil`，则`Wrap`函数也返回`nil`。
- en: 'In the `wrapping()` function, we demonstrate this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wrapping()`函数中，我们展示了这一点：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that the previous error gets wrapped into the next error and so on until
    the final error is returned. The output of the error returned from the `wrapping()`
    function is shown here. I’ve removed the longer path for clarity:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的错误被包裹到下一个错误中，依此类推，直到返回最终错误。`wrapping()`函数返回的错误输出如下。为了清晰起见，我已经移除了较长的路径：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the errors from `operation1`, `operation2`, and `operation3` are
    wrapped under the original `error` instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`operation1`、`operation2`和`operation3`的错误都包裹在原始`error`实例之下。
- en: Because wrapping annotates the error with the stack trace and message, the line
    that calls the `wrapping()` function prints the error message followed by the
    stack trace at the call of the `New()` or `Wrap()` method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`wrapping()`函数将错误与堆栈跟踪和消息一起注释，所以调用`New()`或`Wrap()`方法时，调用`wrapping()`函数的行会打印出错误消息，随后是堆栈跟踪。
- en: Customizing errors
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义错误
- en: 'Creating custom errors allows you to store whatever information you think is
    valuable to your users with the error so that when it’s time to print out, all
    the information is available within a single struct. First, you need to think
    about the error structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义错误允许你将你认为对用户有价值的信息存储在错误中，以便在打印时，所有信息都可在单个结构体中找到。首先，你需要考虑错误结构：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Simply create any type that implements the `Error() string` method. Think about
    the data you’d want stored on the custom error structure that might be useful
    for your users, or even for yourself as the developer, for debugging purposes.
    This could include the method name where the error occurred, the severity of the
    error, or the kind of error. In the `Chapter-9` repo, in the `errors.go` file,
    I provide some examples. To keep things simple, only one additional field, `Task`,
    is added to the `customError` structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地创建任何实现`Error() string`方法的类型。考虑一下你想要存储在自定义错误结构体中的数据，这可能对用户有用，甚至对你作为开发者进行调试也有用。这可能包括错误发生的方法名称、错误的严重性或错误的类型。在`Chapter-9`仓库的`errors.go`文件中，我提供了一些示例。为了简化，只向`customError`结构体添加了一个额外的字段`Task`：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Error()` method that satisfies the previous interface is defined here.
    For fun, we use the `github.com/fatih/color` color page used in the previous chapter
    and an emoji (a red cross mark) alongside the error message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义了满足先前接口的`Error()`方法。为了好玩，我们使用了上一章中使用的`github.com/fatih/color`颜色页面以及一个表情符号（一个红色的十字标记）与错误消息一起：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we can demonstrate how this custom error can be used within the `eligibleToVote`
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以演示如何在`eligibleToVote`函数中使用这个自定义错误：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice there are multiple errors, and the error is initially defined at the
    top of the function, setting only the `Task` field. For each error that occurs,
    the `Err` field is then set and returned. Within the `Examples` method, we call
    the function with the following lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有多个错误，错误最初在函数顶部定义，只设置了`Task`字段。对于每个发生的错误，然后设置`Err`字段并返回。在`Examples`方法中，我们使用以下行调用函数：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following error is output when the preceding code runs:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码运行时，会输出以下错误：
- en: '![Figure 9.1 – Screenshot of voting error](img/Figure_9.1._B18883.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 投票错误截图](img/Figure_9.1._B18883.jpg)'
- en: Figure 9.1 – Screenshot of voting error
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 投票错误截图
- en: 'There are plenty of other ways to create custom errors, but here are a few
    things to consider adding to your custom errors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义错误有 plenty of 其他方法，但以下是一些可以考虑添加到自定义错误中的内容：
- en: The severity of the error for logging purposes
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于日志记录的错误严重性
- en: Any data that may be valuable for metrics
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可能对指标有价值的资料
- en: The kind of error so that you may easily filter out any unexpected errors when
    they occur
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误类型，这样你可以在错误发生时轻松过滤掉任何意外的错误
- en: Writing better error messages
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更好的错误消息
- en: Now that we know how to add more detail to error messages, let’s revisit the
    `audiofile` CLI and rewrite our error messages to be more human-friendly using
    the guidelines mentioned earlier in this section. In the repo, for this particular
    branch, I’ve decorated the errors with extra information so that the user or developer
    can better understand where the error occurred and why.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何添加更多细节到错误信息中，让我们回顾一下`audiofile` CLI，并使用本节前面提到的指南重写我们的错误信息，使其更加人性化。在仓库中，对于这个特定的分支，我已经添加了额外的错误信息，以便用户或开发者更好地理解错误发生的位置以及原因。
- en: 'Since the `audiofile` CLI interacts with the `audiofile` API, there are HTTP
    responses that can be handled and rewritten. A `CheckResponse` function exists
    in the `utils/http.go` file and does this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`audiofile` CLI与`audiofile` API交互，存在可以处理和重写的HTTP响应。在`utils/http.go`文件中存在一个`CheckResponse`函数，它执行以下操作：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Consider expanding on this within your own CLI, which might also interact with
    a REST API. You may check as many responses as you like and rewrite them as errors
    to be returned by the command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在您自己的CLI中扩展这一点，它可能也会与REST API交互。您可以检查您喜欢的任何响应并将它们重写为命令返回的错误。
- en: 'In previous versions of the `audiofile` CLI, if an `id` parameter was passed
    into the `get` or `delete` command, nothing would be returned if the ID was not
    found. However by passing back the `http.StatusNotFound` response and adding additional
    error decorations, the command that would previously error silently and return
    no data can now return some useful information:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`audiofile` CLI的先前版本中，如果将`id`参数传递给`get`或`delete`命令，如果ID未找到，则不会返回任何内容。然而，通过返回`http.StatusNotFound`响应并添加额外的错误装饰，之前会静默错误并返回无数据的命令现在可以返回一些有用的信息：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can even level up by additionally suggesting how to find an ID. Potentially,
    ask the user to run the `list` command to confirm the ID. Another thing that can
    be done, similarly to how we handled the status codes from an HTTP API request,
    is to check the errors coming back from a local command being called. Whether
    the command is not found or the command is missing executable permissions, you
    can similarly use a switch to handle potential errors that can occur when a command
    is started or run. These potential errors can be rewritten similarly using more
    user-friendly language.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过额外建议如何查找ID来提升等级。潜在的做法是要求用户运行`list`命令以确认ID。另一件事，类似于我们处理HTTP API请求的状态码的方式，是检查从本地命令返回的错误。无论是命令未找到还是命令缺少可执行权限，你都可以使用开关来处理在启动或运行命令时可能发生的潜在错误。这些潜在错误可以使用更用户友好的语言类似地重写。
- en: Providing debug and traceback information
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供调试和跟踪信息
- en: Debug and traceback information is mostly useful for you or other developers,
    but it can also help your end users share valuable information with you to help
    debug a potential issue found in your code. There are several diverse ways to
    provide this information. Debug and traceback information is primarily output
    to a log file, and often, the addition of a `verbose` flag will print this output,
    which is usually hidden.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和跟踪信息主要对您或其他开发者有用，但它也可以帮助您的最终用户与您分享有价值的信息，以帮助调试在您的代码中发现的潜在问题。有几种不同的方式可以提供这些信息。调试和跟踪信息主要输出到日志文件，通常，添加一个`verbose`标志将打印此输出，这通常是被隐藏的。
- en: Logging data
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志数据
- en: 'Since debug data is usually found in log files, let us discuss how to include
    logging in your command-line application and determine the levels associated with
    logging—`info`, `error`, and `debug` levels of severity. In this example, let
    us use a simple log package to demonstrate this example. There are several different
    popular structured log packages, including the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于调试数据通常位于日志文件中，让我们讨论如何在命令行应用程序中包含日志，并确定与日志相关的级别——`info`、`error`和`debug`级别的严重性。在这个例子中，让我们使用一个简单的日志包来演示这一点。有几个不同的流行结构化日志包，包括以下：
- en: Zap ([https://github.com/uber-go/zap](https://github.com/uber-go/zap))—Fast
    structured logger developed by Uber
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zap ([https://github.com/uber-go/zap](https://github.com/uber-go/zap))—由Uber开发的快速结构化日志记录器
- en: ZeroLog ([https://github.com/rs/zerolog](https://github.com/rs/zerolog))—Fast
    and simple logger dedicated to JSON format
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZeroLog ([https://github.com/rs/zerolog](https://github.com/rs/zerolog))—专注于JSON格式的快速简单日志记录器
- en: Logrus ([https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus))—Structured
    logger for Go with the option for JSON-formatted output (currently in maintenance
    mode)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logrus ([https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus))—一个为
    Go 提供结构化日志记录和 JSON 格式输出选项的日志记录器（目前处于维护模式）
- en: Although `logrus` is an extremely popular logger, it has not been updated in
    a while, so let us choose to use `zap` instead. In general, it’s a promising idea
    to choose an open source project that is actively maintained.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `logrus` 是一个非常受欢迎的日志记录器，但有一段时间没有更新了，所以我们选择使用 `zap`。一般来说，选择一个积极维护的开源项目是一个有希望的想法。
- en: Initiating a logger
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化一个日志记录器
- en: 'Back to the `audiofile` project, let us add logging for debugging purposes.
    The very first thing we run under our `audiofile` repo is this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `audiofile` 项目，让我们添加一些用于调试目的的日志记录。在我们 `audiofile` 仓库中运行的第一件事是：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It will get the updated Zap logger dependencies. After that, we can start referencing
    the import within the project’s Go files. Under the `utils` directory, we add
    a `utils/logger.go` file to define some code to initiate the Zap logger, which
    is called within the `main` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它将获取更新的 Zap 日志记录器依赖项。之后，我们可以在项目的 Go 文件中开始引用导入。在 `utils` 目录下，我们添加一个 `utils/logger.go`
    文件来定义一些初始化 Zap 日志记录器的代码，该代码在 `main` 函数中被调用：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It isn’t necessary, but we define two loggers here. One is a logger, `Logger`,
    which outputs to an output path defined within the config file, and the other
    is the verbose logger, `Verbose`, which outputs to standard output and the previously
    defined output path. Both use the `*zap.Logger` type, which is used when type
    safety and performance are critical. Zap also provides a sugared logger, which
    is used when performance is nice to have but not critical. `SugarLogger` also
    allows for structured logging, but in addition, supports `printf`-style APIs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但我们在这里定义了两个日志记录器。一个是 `Logger` 日志记录器，它将输出到配置文件中定义的输出路径，另一个是详细模式的 `Verbose`
    日志记录器，它将输出到标准输出和之前定义的输出路径。两者都使用 `*zap.Logger` 类型，这在类型安全和性能至关重要的场合使用。Zap 还提供了一个糖化日志记录器，当性能是可取的但不是关键时使用。`SugarLogger`
    也允许结构化日志记录，但除此之外，还支持 `printf` 风格的 API。
- en: Within the `Chapter-9` branch version of this repo, we replace some of the general
    `fmt.Println` or `fmt.Printf` output with the logs that can be shown in `verbose`
    mode. Also, we differentiate when printing out information with the `Info` level
    versus the `Error` level.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个仓库的 `Chapter-9` 分支版本中，我们将一些通用的 `fmt.Println` 或 `fmt.Printf` 输出替换为可以在 `verbose`
    模式下显示的日志。此外，我们在打印信息时区分了 `Info` 级别和 `Error` 级别。
- en: 'The following code uses Viper to read from the configuration file, which has
    been modified to hold a few extra configurations for the logger:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 Viper 从配置文件中读取，该文件已被修改以包含一些额外的日志记录器配置：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding configuration, we set the `level` and `encoding` fields. We
    choose the `debug` level so that debug and error statements are output to the
    log file. For the `encoding` value, we chose `json` because it provides a standard
    structure that can make it easier to understand the error message as each field
    is labeled. The encoder config is also defined within the same `utils/logger.go`
    file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们设置了 `level` 和 `encoding` 字段。我们选择 `debug` 级别，以便将调试和错误语句输出到日志文件。对于 `encoding`
    值，我们选择了 `json`，因为它提供了一个标准的结构，可以使得每个字段都有标签，从而更容易理解错误信息。编码器配置也在同一 `utils/logger.go`
    文件中定义：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the `InitCLILogger()` function is called within the `main` function, the
    two `Logger` and `Verbose` loggers will be available within any of the commands
    for use.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `InitCLILogger()` 函数在 `main` 函数中被调用，所以两个 `Logger` 和 `Verbose` 日志记录器将可用于任何命令中使用。
- en: Implementing a logger
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个日志记录器
- en: 'Let us look at how we can start using this logger in an effective way. First,
    we know that we are going to log all the data and output to the user when in verbose
    mode. We define the `verbose` flag as a persistent flag in the `cmd/root.go` file.
    This means that the `verbose` flag will be available not only at the root level
    but also for every subcommand added to it. In that file’s `init()` function, we
    add this line:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何有效地开始使用这个日志记录器。首先，我们知道在详细模式中，我们将记录所有数据并输出给用户。我们在 `cmd/root.go` 文件中将
    `verbose` 标志定义为持久标志。这意味着 `verbose` 标志不仅可在根级别使用，而且对于添加到其中的每个子命令也是可用的。在该文件的 `init()`
    函数中，我们添加了以下行：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, rather than checking for every error if the `verbose` flag is called and
    printing out the error before it is returned, we create a simple function that
    can be repeated for checking but also returning the error value. Within the `utils/errors.go`
    file, we define the following function for reuse:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，而不是在`verbose`标志被调用时检查每个错误并在返回之前打印出错误，我们创建了一个简单的函数，它可以重复用于检查，也可以返回错误值。在`utils/errors.go`文件中，我们定义以下函数以供重用：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s take one command as an example, the `delete` command, which shows how
    this function is called:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个命令为例，比如`delete`命令，它展示了如何调用此功能：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The bulk of the code for the command is usually found within the `Run` or `RunE`
    method, which receives the `cmd` variable, a `*cobra.Command` instance, and the
    `args` variable, which holds arguments within a slice of `strings`. Very early
    on, in each method, we create the client and extract any flags we might need—in
    this case, the `verbose`, `silence`, and `id` flags:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的大部分代码通常位于`Run`或`RunE`方法中，该方法接收`cmd`变量，一个`*cobra.Command`实例，以及`args`变量，它包含一个`strings`切片中的参数。在每种方法非常早期的时候，我们创建客户端并提取我们可能需要的任何标志——在这个例子中，是`verbose`、`silence`和`id`标志：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we construct the request we are sending to the `HTTP` client, which uses
    the `id` value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建我们发送给`HTTP`客户端的请求，它使用`id`值：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We check whether there’s any error when creating the request, which is most
    likely a result of a configuration error. Next, we log the request so that we
    are aware of any communication to external servers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查在创建请求时是否有任何错误，这很可能是配置错误的结果。接下来，我们记录请求，以便我们了解任何与外部服务器的通信：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ll execute the request through the client’s `Do` method and return an error
    if the request was unsuccessful:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过客户端的`Do`方法执行请求，如果请求未成功则返回错误：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following the request, we check the response and read the `resp.Body` , or
    the body of the response, if the response was successful. If not, an error message
    will be returned and logged:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求之后，我们检查响应并读取`resp.Body`，即响应体，如果响应成功。如果不成功，将返回并记录错误消息：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we check whether the response returns the `success` string, which
    shows a successful deletion. The result is then printed out to the user:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查响应是否返回`success`字符串，这表明删除成功。然后将结果打印给用户：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You’ll see that the `utils.Error` function is called every time an error is
    encountered. You’ll also see a few other logging functions: `utils.LogRequest`
    and `utils.LogHTTPResponse`. The first, `utils.LogRequest`, is defined to log
    the request to either standard output, the log file, or both:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到每当遇到错误时都会调用`utils.Error`函数。你还会看到几个其他的日志函数：`utils.LogRequest`和`utils.LogHTTPResponse`。第一个，`utils.LogRequest`，被定义为将请求记录到标准输出、日志文件或两者：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second, `utils.LogHTTPResponse`, similarly logs the response from the previous
    request to either standard output, the log file, or both:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`utils.LogHTTPResponse`，同样将前一个请求的响应记录到标准输出、日志文件或两者：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that this logger has been implemented for all the `audiofile` commands,
    let’s give it a try and see what the output looks like now that the command has
    a `verbose` flag to output debug data when necessary.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个记录器已经为所有的`audiofile`命令实现，让我们试一试，看看现在命令有了`verbose`标志输出调试数据时输出是什么样子：
- en: Trying out verbose mode to view stack traces
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试详细模式以查看堆栈跟踪
- en: 'After recompiling the project, we run the `delete` command with an invalid
    ID and pass the `verbose` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译项目后，我们使用无效的ID运行`delete`命令，并传递`verbose`命令：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using the `verbose` flag, the debug statements are printed out, and when an
    error occurs, the stack trace is also output. This is important data for the user
    to share with the developer to debug what went wrong. Now, let us learn how to
    give the option to the user to submit a bug.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`verbose`标志，打印出调试语句，当发生错误时，堆栈跟踪也会输出。这对于用户与开发者共享以调试出了什么问题的重要数据。现在，让我们学习如何给用户提交错误报告的选项：
- en: Effortless bug submission
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需努力的错误提交
- en: 'Let us create a `bug` command using the Cobra generator for users to submit
    issues to the developers of the `audiofile` CLI:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Cobra生成器创建一个`bug`命令，让用户可以向`audiofile` CLI的开发者提交问题：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have the `bug` command created, the `Run` field is changed to extract
    details of the application and launch a web browser with the data already added
    and ready for the user to just finish off the submission with some extra details:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`bug`命令，将`Run`字段更改为提取应用程序的详细信息并使用已添加和准备好的数据启动网络浏览器，以便用户只需添加一些额外细节即可完成提交：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The strings passed into the `buf.WriteString` method are defined outside the
    command within the same file, `cmd/bug.go`, but once the command is run, the complete
    template body is defined as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`buf.WriteString`方法的字符串定义在同一文件`cmd/bug.go`中的命令之外，但一旦命令运行，完整的模板体如下所示：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calling the `./bin/audiofile bug` command launches the browser to open a new
    issue on the GitHub repo:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`./bin/audiofile bug`命令会启动浏览器打开GitHub仓库中的新问题页面：
- en: "![Figure 9.2 – Screenshot of \uFEFFbrowser open to a new issue](img/Figure_9.2._B18883.jpg)"
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 浏览器打开到新问题的截图](img/Figure_9.2._B18883.jpg)'
- en: Figure 9.2 – Screenshot of browser open to a new issue
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 浏览器打开到新问题的截图
- en: From the browser window, open the new issue page; the version of the CLI is
    populated, and then the user can replace the default text for the description,
    reproduction steps, expected behavior, and other steps with their own.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从浏览器窗口中打开新问题页面；CLI的版本会被自动填充，然后用户可以用自己的文本替换描述、复现步骤、预期行为和其他步骤的默认文本。
- en: Help, documentation, and support
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帮助、文档和支持
- en: Part of creating a CLI that empathizes with its users is to supply sufficient
    help and documentation, as well as support users of all kinds. Luckily, the Cobra
    CLI framework supports the generation of help from the short and long fields of
    the Cobra command and the generation of man pages as well. However, bringing empathy
    into the extended documentation of your CLI may require several techniques.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个能够体谅用户的CLI的一部分是提供足够的帮助和文档，以及支持各种用户。幸运的是，Cobra CLI框架支持从Cobra命令的短字段和长字段生成帮助，以及生成man页面。然而，将同情心融入CLI的扩展文档可能需要几种技术。
- en: Generating help text
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成帮助文本
- en: 'By now, there have been many examples of creating commands, but just to reiterate,
    the command structure and the fields that show up in help are fields within the
    Cobra commands. Let’s go over a good example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经有很多创建命令的例子了，但为了重申，命令结构和在帮助中显示的字段是Cobra命令中的字段。让我们来看一个好例子：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Making sure you simply supply a short and long description of the command and
    one or several examples, you are supplying some help text that can at least get
    users started using the command. Running this will show the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你只提供命令的简短和长描述以及一个或几个示例，你就是在提供一些帮助文本，至少可以让用户开始使用该命令。运行此命令将显示以下输出：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A simple command doesn’t need a ton of explanation, so this is enough to help
    guide the user with usage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的命令不需要太多的解释，所以这些就足够帮助用户了解如何使用。
- en: Generating man pages
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成man页面
- en: 'In the `audiofile` repo, we’ve added some additional code to generate the man
    pages for the existing commands and commands in the `Makefile` to run to quickly
    run the code to do so. There exists a new program within the repo defined under
    `documentation/main.go`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`audiofile`仓库中，我们添加了一些额外的代码来为现有的命令和`Makefile`中的命令生成man页面，以便快速运行代码来完成这项工作。在仓库中存在一个新程序，定义在`documentation/main.go`下：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We pass in the `root` command and generate the pages in the `./pages` directory.
    The addition of the `make pages` command within the `Makefile` creates the man
    pages when called:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`root`命令并在`./pages`目录中生成页面。在`Makefile`中添加`make pages`命令会在调用时创建man页面：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Within the terminal, if you run `make manpages` and then check to see whether
    the new pages exist by running `man pages/audiofile.1`, you will see the generated
    man page for the `audiofile` CLI:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，如果你运行`make manpages`然后通过运行`man pages/audiofile.1`来检查新页面是否存在，你会看到为`audiofile`
    CLI生成的man页面：
- en: '![Figure 9.3 – Screenshot of audiofile man pages in the terminal](img/Figure_9.3_B18883.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 终端中audiofile man页面的截图](img/Figure_9.3_B18883.jpg)'
- en: Figure 9.3 – Screenshot of audiofile man pages in the terminal
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 终端中audiofile man页面的截图
- en: You can also see that within the `pages` directory, there’s an individual man
    page created for all the commands that have been added to the `root` command.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到在`pages`目录中，为添加到`root`命令的所有命令都创建了一个单独的man页面。
- en: Embedding empathy into your documentation
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将同情心融入你的文档
- en: By the time a user reaches your documentation, it is likely that they may already
    have encountered an issue and are frustrated or confused. It’s important that
    your documentation takes in that perspective and portrays an understanding of
    the user’s situation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户到达你的文档时，他们可能已经遇到了问题并且感到沮丧或困惑。你的文档需要考虑到这一点，并展现出对用户情况的了解。
- en: Although it may feel like documentation takes a lot of time and energy from
    other areas of development, it is essential for the future of your command-line
    application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能感觉文档编写会从其他开发领域消耗大量时间和精力，但它对你的命令行应用程序的未来至关重要。
- en: Within the last few years, there’s been a recent term, *empathy advocacy*, that
    has come up in regard to technical documentation. It was coined by Ryan Macklin,
    a technical and UX writer, as well as an empathy advocate. The term is used to
    describe a subfield of technical communication centered on empathy and realistic
    respect for human emotion. It can be considered a framework for the way you communicate
    with your users. Because many people come to your documentation, we know that
    there’s a varied assortment of brain chemistry, life experience, and recent events
    playing in mind. Empathy advocacy is one solution to this beautiful challenge.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，出现了一个新术语，*同理心倡导*，它与技术文档有关。这个术语是由技术及UX作家、同理心倡导者Ryan Macklin提出的。这个术语用来描述一个以同理心和现实中对人类情感的尊重为中心的技术传播子领域。它可以被视为与用户沟通方式的框架。因为很多人会阅读你的文档，我们知道其中包含了各种各样的脑化学、生活经验和最近的事件。同理心倡导是解决这个美好挑战的一种方法。
- en: 'Macklin has proposed seven philosophical documentation techniques rooted in
    empathy advocacy. These principles have been informed by disciplines such as UX,
    trauma psychotherapy, neurobiology, gameplay design, and cultural and language
    differences. Let’s discuss each of these tenets and why they work:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Macklin提出了基于同理心倡导的七个哲学文档技巧。这些原则受到了UX、创伤心理治疗、神经生物学、游戏设计以及文化和语言差异等学科的启发。让我们讨论这些原则及其为何有效：
- en: '**Employ visual storytelling**—The human brain easily grabs onto stories, and
    sighted users can benefit from visuals. However, this forces developers to think
    about different types of accessibility: visual, cognitive, motor, and so on. Telling
    a story forces the writer to think about structure. On the other hand, dense and
    long-winded text is **accessibility-hostile**. As a note, this idea doesn’t work
    for everyone.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运用视觉叙事**—人类大脑很容易抓住故事，视觉用户可以从视觉中受益。然而，这迫使开发者思考不同类型的可访问性：视觉、认知、运动等。讲述故事迫使作者思考结构。另一方面，密集且冗长的文本是**可访问性敌对的**。作为备注，这个想法并不适用于每个人。'
- en: '**Use synopses**—Using a **tl;dr** (short for **too long, don’t read**), a
    summary line, or a banner provides a shortened explanation for tired and stressed-out
    readers who benefit from a lower cognitive cost option. Cognitive glue is required
    for running a collection of cognitive tasks to complete a high level of intelligence.
    Cognitive glue requires energy, so providing a synopsis will provide a low-cost
    option for users who are already running on low.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用摘要**—使用**tl;dr**（代表**too long, don’t read**，即“太长，不读”）、总结行或横幅为疲惫和压力山大的读者提供一个简短的解释，这些读者从认知成本较低的选择中受益。完成高水平智力所需的认知任务需要认知粘合剂。认知粘合剂需要能量，因此提供摘要将为那些已经处于低能量状态的用户提供低成本选项。'
- en: '**Give time frames**—In general, uncertainty creates **vicious voids**, and
    dwelling within the unknown time frame can create heightened emotional responses.
    Providing time frames can help stabilize the void. Time frames can be given if
    there’s an outage on the server side, an upload to the server, or just a general
    time to complete a certain task.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供时间框架**—一般来说，不确定性会创造**恶性空白**，而在未知的时间框架中逗留会引发强烈的情绪反应。提供时间框架可以帮助稳定空白。如果服务器端出现故障、上传到服务器或完成特定任务的通用时间，都可以提供时间框架。'
- en: '**Include short videos**—This is a great alternative for some users who struggle
    with reading comprehension. Typically, younger audiences are used to video, and
    when you split videos up into a single topic at max, the shorter playtime can
    be reassuring. Reassurance is a powerful way to regulate emotion. However, there
    are some pitfalls to video—mainly, that video costs more time and energy to create.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含短视频**—这对于一些阅读理解有困难的用户来说是一个很好的替代方案。通常，年轻观众习惯于视频，当你将视频拆分成单个主题时，较短的播放时间可以提供安慰。安慰是一种强大的调节情绪的方式。然而，视频也有一些陷阱——主要是，视频需要更多的时间和能量来制作。'
- en: '**Reduce screenshots**—Providing screenshots can be helpful, but only when
    the UI can be confusing. Also, providing just enough for the user to figure some
    things out themselves helps to foster cognitive glue. Otherwise, being bombarded
    by visuals hurts everyone.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少截图**—提供截图可能会有帮助，但只有在用户界面可能令人困惑时。仅提供足够的信息让用户自己弄清楚一些事情，有助于培养认知粘性。否则，被视觉信息轰炸会伤害到每个人。'
- en: '**Rethink FAQs**—Instead of a traditional question and answer, break up documentation
    into single-scoped documents. Provide specific titles and avoid over-promising.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新思考FAQ**—与其传统的问答，不如将文档拆分为单范围文档。提供具体的标题，避免过度承诺。'
- en: '**Pick your battles**—It’s difficult to fight every fight; do the best you
    can, and choose your battles. Not everything you do will work for everyone—learn
    along the way. After all, advocating for empathy is another means of self-care.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择你的战斗**—不是每一场战斗都值得打；尽你所能，选择你的战斗。你做的事情并不一定适合每个人——在过程中学习。毕竟，倡导同理心是自我关怀的另一种方式。'
- en: Hopefully, these tenets that describe the philosophy of empathy advocacy help
    you to think twice about the words you use in your documentation. A few things
    to consider when you are writing your documentation include how your words may
    come across to someone who is in a panicked or frustrated state. Also, consider
    how you can help those about to give up or lacking the energy to complete their
    task to be successful.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些描述同理心倡导哲学的原理能帮助你重新思考你在文档中使用的词语。当你编写文档时，要考虑你的词语可能如何影响处于恐慌或挫败状态的人。还要考虑你如何帮助那些即将放弃或缺乏完成任务能量的用户取得成功。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned specific steps to make your command-line application
    more empathetic. From error handling, debug and traceback information, effortless
    bug submission, and empathic advocacy in technical communication, you have learned
    the technical and empathic skills to apply within your application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了具体步骤来使你的命令行应用程序更具同理心。从错误处理、调试和回溯信息、轻松的错误提交，到技术沟通中的同理心倡导，你学到了在应用程序中应用的技术和同理心技能。
- en: Errors can now be rewritten in color to jump out of the screen and decorated
    with additional information that provides the user information on exactly where
    an error has occurred and potentially what they may need to do to reach a resolution.
    When an error seems unresolvable, the user can then run the same command using
    the `--verbose` flag and view the detail logs, which might contain server requests
    and responses necessary to trace more specifically where an error may be happening,
    down to the line of code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在错误可以用颜色重写，从屏幕上跳出来，并装饰上提供用户关于错误发生的确切位置以及可能需要做什么来解决问题的额外信息。当错误看起来无法解决时，用户可以运行带有`--verbose`标志的相同命令，查看详细日志，这些日志可能包含追踪错误可能发生位置的必要的服务器请求和响应，直到代码的行。
- en: If a bug is encountered, the addition of a new `bug` command allows the user
    to spawn a new browser straight from their terminal, opening straight to a new
    template in GitHub’s new issue submission form.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到错误，新增的`bug`命令允许用户从终端直接启动一个新的浏览器，直接打开GitHub新问题提交表单中的新模板。
- en: Finally, bridging the gap between technical documentation and the user’s perspective
    is done by taking an empathetic approach. Several philosophical tenets when using
    an empathic framework when writing your documentation were discussed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过采取同理心方法来弥合技术文档和用户视角之间的差距。在编写文档时使用同理心框架的几个哲学原则已被讨论。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which two common methods can you use for decorating your errors?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用哪两种常见方法来装饰你的错误？
- en: Between Zap and Logrus loggers, why would you choose Zap?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Zap和Logrus日志记录器之间，你为什么选择Zap？
- en: What is empathy advocacy?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是同理心倡导？
- en: Further reading
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Empathy* *Advocacy*: [https://empathyadvocacy.org](https://empathyadvocacy.org)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同理心* *倡导*：[https://empathyadvocacy.org](https://empathyadvocacy.org)'
- en: '*Write the* *Docs*: [https://www.writethedocs.org](https://www.writethedocs.org)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写文档*：[https://www.writethedocs.org](https://www.writethedocs.org)'
- en: Answers
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '`fmt.Errorf(format string, a ...any) error or errors.Wrap(err error, message`
    `string) error`.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fmt.Errorf(format string, a ...any) error 或 errors.Wrap(err error, message
    string) error`。'
- en: Zap is faster and is actively maintained.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Zap更快，并且正在积极维护。
- en: Empathy advocacy is a sub-field of technical communication centered on empathy
    and realistic respect for human emotion. It can be considered a framework for
    the way you write your technical documentation and a solution for writing for
    many types of people with varied backgrounds and accessibilities.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同理心倡导是技术交流的一个子领域，它以同理心和现实中对人类情感的尊重为核心。它可以被视为一种编写技术文档的方式框架，以及为具有不同背景和可访问性的多种类型人群写作的解决方案。
