- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Publishing Your Go Binary as a Homebrew Formula with GoReleaser
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GoReleaser 将你的 Go 二进制文件作为 Homebrew 公式发布
- en: In this chapter, we’ll look at GoReleaser and GitHub Actions and how they can
    be used in tandem to automate the release of a Go binary as a Homebrew formula.
    First, we’ll look at **GoReleaser**, a popular open source tool that streamlines
    the creation, testing, and distribution of Go binaries. We’ll look at its various
    configurations and options as well as how it works with GitHub Actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 GoReleaser 和 GitHub Actions 以及它们如何协同使用来自动化将 Go 二进制文件作为 Homebrew 公式发布的过程。首先，我们将探讨
    **GoReleaser**，这是一个流行的开源工具，它简化了 Go 二进制文件的创建、测试和分发。我们将探讨其各种配置和选项，以及它是如何与 GitHub
    Actions 一起工作的。
- en: Following that, we’ll look at **GitHub Actions**, a CI/CD platform that lets
    you automate software development workflows and integrate with other tools such
    as GoReleaser. We’ll look at how to use it to ensure consistent and reliable builds,
    tests, and deployments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们将探讨 **GitHub Actions**，这是一个 CI/CD 平台，允许你自动化软件开发工作流程并与其他工具（如 GoReleaser）集成。我们将探讨如何使用它来确保构建、测试和部署的一致性和可靠性。
- en: After we’ve mastered both tools, we’ll concentrate on triggering releases, creating
    a Homebrew tap, and integrating with Homebrew for simple installation and testing.
    **Homebrew**, a popular package manager for macOS, can be used for easy installation
    and management of your CLI application. Releasing your software to Homebrew not
    only simplifies the installation process for macOS users, but also gives you access
    to a wider audience. You can reach a sizable community of macOS developers and
    consumers that prefer using a package manager for program installation, such as
    Homebrew. Users can quickly find and install your software with just one command,
    increasing its usability and accessibility. This can help you reach a larger audience
    than you otherwise would and boost the visibility, usage, and adoption of your
    program.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握这两个工具之后，我们将专注于触发发布、创建 Homebrew tap 以及与 Homebrew 集成以实现简单的安装和测试。**Homebrew**
    是一个流行的 macOS 包管理器，可以用于轻松安装和管理你的 CLI 应用程序。将你的软件发布到 Homebrew 不仅简化了 macOS 用户安装过程，还让你能够接触到更广泛的受众。你可以接触到一群喜欢使用包管理器安装程序的
    macOS 开发者和消费者，例如 Homebrew。用户只需一条命令就可以快速找到并安装你的软件，这提高了其可用性和可访问性。这可以帮助你接触到比以往更大的受众，并提高你程序的可见性、使用率和采用率。
- en: 'By the end of this chapter, you’ll have a firm grasp of how to combine GoReleaser
    and GitHub Actions to create an automated and efficient release process, and that
    includes publishing to Homebrew. With this knowledge, you will be able to tailor
    your own workflow to your specific requirements. The following topics will be
    covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固掌握如何结合 GoReleaser 和 GitHub Actions 来创建一个自动化和高效发布流程，包括发布到 Homebrew。有了这些知识，你将能够根据你的具体需求定制自己的工作流程。以下将涵盖以下主题：
- en: GoReleaser workflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoReleaser 工作流程
- en: Trigger release
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发发布
- en: Installing with Homebrew and Testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Homebrew 安装和测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要执行以下操作：
- en: You can also find the code examples on GitHub at [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在 GitHub 上找到代码示例，地址为 [https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile](https://github.com/PacktPublishing/Building-Modern-CLI-Applications-in-Go/tree/main/Chapter14/audiofile)
- en: A GitHub account
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 GitHub 账户
- en: Install the GoReleaser tool at [https://goreleaser.com/install/](https://goreleaser.com/install/)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [https://goreleaser.com/install/](https://goreleaser.com/install/) 安装 GoReleaser
    工具
- en: GoReleaser workflow
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoReleaser 工作流程
- en: Releasing software may be a lengthy and challenging process, particularly for
    projects with several dependencies and platforms. In addition to saving time,
    automating the release process lowers the possibility of human error and guarantees
    reliable and effective releases. GoReleaser is a popular choice for automating
    the release process for Go developers. However, there are also other choices,
    such as CircleCI, GitLab CI, and GitHub Actions, each of which has particular
    advantages and features. In this section, we’ll examine the advantages of automating
    the release procedure and look in more detail at a few of these choices, specifically
    GoReleaser and GitHub Actions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 发布软件可能是一个漫长且具有挑战性的过程，尤其是对于有多个依赖项和平台的工程项目。除了节省时间外，自动化发布过程可以降低人为错误的可能性，并确保发布可靠且有效。GoReleaser是Go开发者自动化发布过程的一个流行选择。然而，也有其他选择，如CircleCI、GitLab
    CI和GitHub Actions，每个都有其特定的优点和功能。在本节中，我们将探讨自动化发布流程的优点，并更详细地查看其中的一些选择，特别是GoReleaser和GitHub
    Actions。
- en: 'When compared to alternatives, GoReleaser stands out for the following reasons:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他替代方案相比，GoReleaser在以下方面脱颖而出：
- en: '**Easy to use**: Setup is simple and intuitive, making it easy for developers
    to get started with release automation. Their CLI quickly initializes a repository
    with a default configuration that can often work out of the box.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：设置简单直观，使开发者能够轻松开始使用发布自动化。他们的CLI可以快速初始化带有默认配置的仓库，通常可以即插即用。'
- en: '**Platform support**: A variety of operating systems, including the major OSs,
    and cloud services are supported.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台支持**：支持包括主要操作系统和云服务在内的各种操作系统。'
- en: '**Customization at each step**: Programmers have the ability to customize at
    every step of the release process including building, testing, and publishing
    to various platforms.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个步骤的定制**：程序员可以在发布过程的每个步骤中进行定制，包括构建、测试和发布到各种平台。'
- en: '**Release artifacts**: A wide range of release artifacts may be produced, including
    Debian packages, Docker images, and binary files.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布工件**：可以生成各种发布工件，包括Debian软件包、Docker镜像和二进制文件。'
- en: '**Versatile**: Combining with CI/CD pipelines, such as GitHub Actions, enables
    developers to fully automate their release procedure.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多功能性**：与CI/CD管道（如GitHub Actions）结合使用，使开发者能够完全自动化他们的发布流程。'
- en: '**Open source**: Programmers may access the source code of the GoReleaser project
    and alter it to suit their own needs.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：程序员可以访问GoReleaser项目的源代码，并根据他们的需求对其进行修改。'
- en: '**Community support**: GoReleaser offers a sizable and active user base, making
    it simple for developers to contribute to the project and find answers to their
    questions.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区支持**：GoReleaser拥有庞大且活跃的用户群，这使得开发者能够轻松地为项目做出贡献并找到他们问题的答案。'
- en: 'While there are many benefits to using GoReleaser, there are, however, a few
    reasons to not use GoReleaser for your project that you may need to consider:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用GoReleaser有许多好处，但也有一些原因可能需要考虑不使用GoReleaser进行您的项目：
- en: '**Reliance on Github**: This may not be ideal if you prefer to use different
    tools or workflows.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖GitHub**：如果您更喜欢使用不同的工具或工作流程，这可能不是最佳选择。'
- en: '**Specific platform requirements**: While GoReleaser supports many popular
    OSs or cloud providers, you may require a platform that is not supported.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定平台要求**：虽然GoReleaser支持许多流行的操作系统或云服务提供商，但您可能需要一个不受支持的平台。'
- en: '**Complex release requirements**: While there is customization allowed in every
    step, there’s a possibility GoReleaser may not be flexible enough to serve your
    specific level of complexity.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的发布需求**：虽然每个步骤都允许定制，但GoReleaser可能不足以灵活地满足您特定的复杂程度。'
- en: In conclusion, while there are other options out there, choose a tool that works
    for your specific use case. We do feel like GoReleaser is a great tool to use
    for the audiofile CLI use case, so let’s continue.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，虽然市场上还有其他选择，但请选择适合您特定用例的工具。我们确实认为GoReleaser是用于audiofile CLI用例的一个很好的工具，所以让我们继续。
- en: Defining the workflow
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义工作流程
- en: 'Having analyzed the pros and cons of using GoReleaser, let’s dive into its
    workflow by first sketching the overall process and then delving into each stage
    in greater detail:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分析了使用GoReleaser的优缺点后，让我们首先概述整体流程，然后更详细地探讨每个阶段：
- en: Configure your project to use GoReleaser.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置您的项目以使用GoReleaser。
- en: Configure GitHub Actions.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置GitHub Actions。
- en: Set up your GitHub repositories.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您的GitHub仓库。
- en: Set up your GitHub token for Actions.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为GitHub Actions设置您的GitHub令牌。
- en: Tag and push the code.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记并推送代码。
- en: 'It might make more sense to view this with a visual, so this is what we are
    trying to accomplish:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更直观的是通过视觉来查看，这就是我们试图实现的目标：
- en: '![Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser](img/Figure_14.1_B18883.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 使用GitHub Actions和GoReleaser的发布流程](img/Figure_14.1_B18883.jpg)'
- en: Figure 14.1 – Flow of the release process using GitHub Actions and GoReleaser
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 使用GitHub Actions和GoReleaser的发布流程
- en: Let’s dive deeper and gain a more thorough understanding of each step involved
    in the workflow now that we have a general idea of how it works; we will explore
    using GoReleaser with GitHub Actions and learn how to automate your own releases.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对工作流程有了大致的了解，让我们更深入地了解每个步骤，我们将探索如何使用GoReleaser与GitHub Actions结合，并学习如何自动化自己的发布。
- en: Configuring your project to use GoReleaser
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的项目以使用GoReleaser
- en: 'With the GoReleaser tool installed, you can now initialize your CLI repository.
    In this case, we’ll initialize the root of the audiofile CLI project repository
    by executing the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装GoReleaser工具后，你现在可以初始化你的CLI仓库。在这种情况下，我们将通过执行以下命令来初始化audiofile CLI项目仓库的根目录：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should notice that a new file has been generated: `goreleaser.yml`. Before
    even inspecting the file, we can run a local-only release to confirm that there
    are no issues with the configuration by executing the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到已经生成了一个新文件：`goreleaser.yml`。在检查文件之前，我们可以通过执行以下命令来运行一个仅限本地的发布，以确认配置没有问题：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output from the command gives you a clear idea of all the steps involved
    in the release. We will walk through these steps in the next section, *Trigger
    release*. At the very end of the output, you should see a message indicating a
    successful release, similar to this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出为你提供了一个关于发布过程中所有步骤的清晰概念。我们将在下一节“触发发布”中详细介绍这些步骤。在输出的最后，你应该看到一个表示发布成功的消息，类似于以下内容：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While the default configuration succeeded, we’ll need to look deeper into the
    configuration settings and modify and add appropriately to customize our release
    process. First, let’s look at the default `.goreleaser.yaml` file together and
    break it down.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认配置成功了，但我们需要更深入地查看配置设置，并相应地修改和添加以定制我们的发布过程。首先，让我们一起查看默认的`.goreleaser.yaml`文件，并对其进行分解。
- en: Global hooks
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局钩子
- en: 'At the very top of the file, we see some default global hooks. `before` field
    allows you to specify which custom scripts to run before the release process begins:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的最顶部，我们看到一些默认的全局钩子。`before`字段允许你在发布过程开始之前指定要运行的哪些自定义脚本：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we configured the automation to run the `go mod tidy`
    and `go generate ./...` commands prior to the release process. However, you might
    run scripts that perform tasks such as the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们配置了自动化在发布过程之前运行`go mod tidy`和`go generate ./...`命令。然而，你可能运行执行以下任务的脚本：
- en: Updating the version number in your project’s code
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新项目中代码的版本号
- en: Generating a changelog
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成变更日志
- en: Running automated tests to ensure that your code is working as expected
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行自动化测试以确保你的代码按预期工作
- en: Building your project and creating release artifacts
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的项目和创建发布工件
- en: Pushing changes to your version control system
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更改推送到你的版本控制系统
- en: The scripts you call from the `before` hooks section in GoReleaser can be written
    in any language, as long as they can be executed from the command line. For example,
    you might write scripts in Go, Python, Bash, or any other language that supports
    shell execution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从GoReleaser中的`before`钩子部分调用的脚本可以是用任何语言编写的，只要它们可以从命令行执行。例如，你可能用Go、Python、Bash或任何支持shell执行的其它语言编写脚本。
- en: Builds and environment variables
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建和环境变量
- en: 'Next, we see some default builds and some environment variables set. The `builds`
    field allows you to determine the combination of operating systems, defined by
    the `GOOS` field, architectures defined by the `GOARCH` field, and architecture
    mode, defined by the `GOARM` field. It also allows you to add additional fields,
    such as the `env` field, which allows you to set environment variables for the
    builds. Additional aspects that can be defined include the binary, flags, hook
    and more:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到一些默认构建和一些环境变量已设置。`builds`字段允许你确定由`GOOS`字段定义的操作系统组合、由`GOARCH`字段定义的架构以及由`GOARM`字段定义的架构模式。它还允许你添加额外的字段，例如`env`字段，该字段允许你为构建设置环境变量。还可以定义的其他方面包括二进制文件、标志、钩子和更多：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example that exists within the default configuration, we defined
    the environment variable, `CGO_ENABLED`, to be set to `0`, and then configure
    the build process to generate binaries for the Linux, Windows, and Darwin operating
    systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认配置中存在的先前的例子中，我们定义了环境变量 `CGO_ENABLED` 为 `0`，然后配置构建过程为 Linux、Windows 和 Darwin
    操作系统生成二进制文件。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `env` field can be set at a global level so that the environment variable
    is available at all stages of the release process, or it may be specified, such
    as in the previous case, within the build context alone.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 字段可以在全局级别设置，以便在发布过程的各个阶段都可以使用环境变量，或者它可以在构建上下文中指定，例如在先前的例子中。'
- en: 'The final configuration ends up having a few more modifications, such as specifying
    a few additional architectures, `amd64` and `arm64`, and removing `go generate
    ./...` before hook, which is unnecessary. Also, we’ve modified the `builds` field
    by setting build flags to use the `pro` and `dev` flags:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最终配置需要进行一些额外的修改，例如指定一些额外的架构，`amd64` 和 `arm64`，以及在钩子之前移除 `go generate ./...`，这是不必要的。此外，我们还通过设置构建标志为
    `pro` 和 `dev` 来修改了 `builds` 字段：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While there are many other options you can set under the `builds` field, we
    will not cover them in this section. We encourage you to view the full list of
    customizations available at [https://goreleaser.com/customization/builds/](https://goreleaser.com/customization/builds/).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在 `builds` 字段下设置许多其他选项，但我们将不会在本节中介绍它们。我们鼓励您查看 [https://goreleaser.com/customization/builds/](https://goreleaser.com/customization/builds/)
    上可用的完整自定义列表。
- en: Archives
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 归档
- en: 'Next, we view some default `archives` settings. In GoReleaser, an `README`,
    and `LICENSE` files. The objective is to package your application’s critical components
    into a single file, essentially making it easier to distribute and deploy. The
    default configuration sets the `archives` field to the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看一些默认的 `archives` 设置。在 GoReleaser 中，有一个 `README` 文件和一个 `LICENSE` 文件。目标是把应用程序的关键组件打包到一个文件中，从而使其更容易分发和部署。默认配置将
    `archives` 字段设置为以下内容：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Within the preceding defaults for the `archives` field, you can see that the
    default archive format is `tar.gz` for all operating systems except for when `GOOS`
    is set to Windows. In that case, the archive format is `zip`. The name of the
    file is defined by a template. To learn more about the GoReleaser naming template,
    visit [https://goreleaser.com/customization/templates/](https://goreleaser.com/customization/templates/)
    as there are many fields to customize the name of your archive. Let’s at least
    review the keys used in the `naming_template` field:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `archives` 字段的先前默认设置中，您可以看到默认的归档格式是 `tar.gz`，适用于所有操作系统，除非 `GOOS` 设置为 Windows。在这种情况下，归档格式是
    `zip`。文件的名称由一个模板定义。要了解更多关于 GoReleaser 命名模板的信息，请访问 [https://goreleaser.com/customization/templates/](https://goreleaser.com/customization/templates/)，因为有许多字段可以自定义归档的名称。让我们至少回顾一下
    `naming_template` 字段中使用的键：
- en: '`.ProjectName` – the project name. If not set, GoReleaser will use the name
    of the directory containing the Go project. In our case, it is `audiofile`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.ProjectName` – 项目名称。如果未设置，GoReleaser 将使用包含 Go 项目的目录名称。在我们的例子中，它是 `audiofile`。'
- en: '`.Os` – `GOOS` value.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Os` – `GOOS` 的值。'
- en: '`.Arch` – `GOARCH` value.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Arch` – `GOARCH` 的值。'
- en: '`.Arm` – `GOARM` value.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Arm` – `GOARM` 的值。'
- en: Now that we understand what these template keys refer to, let’s suppose that
    we generate an archive for our audiofile CLI project, for Linux, with an `amd64`
    architecture. The resulting name of the archive file would be `audiofile_Linux_x86x64.tar.gz`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些模板键的含义，让我们假设我们为我们的 audiofile CLI 项目生成一个归档，用于 Linux，架构为 `amd64`。归档文件的名称将是
    `audiofile_Linux_x86x64.tar.gz`。
- en: Checksum
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 校验和
- en: 'GoReleaser automatically creates and includes a file called `project 1.0.0
    checksums.txt` with the release package. `archives` field, you can use `naming_template`
    to generate the name of the `checksum` file. However, within our configuration,
    the default value for the `checksum` field is simply `checksums.txt`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GoReleaser 自动创建并包含一个名为 `project 1.0.0 checksums.txt` 的文件，其中包含发布包。您可以通过 `naming_template`
    生成 `checksum` 文件的名称。然而，在我们的配置中，`checksum` 字段的默认值仅仅是 `checksums.txt`：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Defining a `checksum` file is important since it helps ensure the integrity
    of the data being distributed. The `checksum` file contains a one-of-a-kind code
    that can be used to verify that the downloaded files are identical to the original
    files. If the `checksum` file is not provided, the released files may be modified
    or corrupted throughout the download process. This can result in unpredictable
    behavior in your application and problems for your users. To avoid this, always
    provide a `checksum` file with your releases so that everyone knows they’re getting
    the correct version of your product.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `checksum` 文件很重要，因为它有助于确保正在分发的数据的完整性。`checksum` 文件包含一个独一无二的代码，可用于验证下载的文件是否与原始文件相同。如果没有提供
    `checksum` 文件，发布文件在下载过程中可能会被修改或损坏。这可能导致您的应用程序出现不可预测的行为，并为您的用户带来问题。为了避免这种情况，始终在您的发布中提供
    `checksum` 文件，以便每个人都知道他们正在获取您产品的正确版本。
- en: Snapshot
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快照
- en: The `snapshot` field in the GoReleaser configuration file specifies whether
    a release is a “snapshot” or a stable release. A **snapshot** is a non-production
    version of a software project that is made available for testing and feedback.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: GoReleaser 配置文件中的 `snapshot` 字段指定发布是“快照”还是稳定发布。**快照**是软件项目的非生产版本，可供测试和反馈使用。
- en: 'The generated release artifacts will be marked as snapshots if the `snapshot`
    field is set to `true`. This means that the version number will be suffixed with
    `-SNAPSHOT`, and the release will not be published to any remote repository, such
    as GitHub Releases. If the `snapshot` field is set to `false` or is not supplied,
    the release is considered stable and is published normally. Like the previous
    two fields, `archives` and `checksum`, the `snapshot` field also has a `name_template`
    that can be used:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `snapshot` 字段设置为 `true`，则生成的发布工件将被标记为快照。这意味着版本号将附加 `-SNAPSHOT` 后缀，并且发布将不会发布到任何远程仓库，例如
    GitHub Releases。如果 `snapshot` 字段设置为 `false` 或未提供，则发布被视为稳定版本，并正常发布。与之前的两个字段 `archives`
    和 `checksum` 一样，`snapshot` 字段也有一个 `name_template` 可以使用：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If not set, the default version, `0.0.1`, is set. Based on the previous template,
    the name of the snapshot will be `0.0.1-next`. `incpatch`, according to the GoReleaser
    documentation, increments the patch of the given reversion, with a side note that
    it will panic if it’s not a semantic version. A `major.minor.patch` to convey
    the level of changes in a software release.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未设置，则默认版本为 `0.0.1`。基于之前的模板，快照的名称将是 `0.0.1-next`。`incpatch`，根据 GoReleaser 文档，它会增加给定版本的补丁，同时附带说明，如果它不是一个语义版本，则会引发恐慌。`major.minor.patch`
    用于传达软件发布中变化的级别。
- en: Changelog
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新日志
- en: The `changelog` field defines the path of your project’s changelog file. A **changelog**
    file contains a list of all the changes, improvements, and bug fixes made to a
    software project, typically organized by version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`changelog` 字段定义了您项目更新日志文件的路径。更新日志文件包含对软件项目所做的所有更改、改进和错误修复的列表，通常按版本组织。'
- en: 'The aim is to record these changes so that users and developers can easily
    discover what’s new in a specific release. The changelog also aids with debugging
    and support by documenting the development process. Let’s look at the default
    configuration for the `changelog` field:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是记录这些更改，以便用户和开发者可以轻松地发现特定版本中的新内容。更新日志还有助于调试和支持，因为它记录了开发过程。让我们看看 `changelog`
    字段的默认配置：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding block of the configuration, we defined the behavior of the
    changelog generation process. Using the `sort` field, we specify the order in
    which the entries of the changelog should be displayed, in this case, `asc`, for
    ascending. The `filters` field specifies, with the `exclude` subfield, a list
    of regular expressions matched against commits to be excluded. To view all the
    options available for the `changelog` field, visit `https://goreleaser.com/customization/changelog/`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置块中，我们定义了更新日志生成过程的行为。使用 `sort` 字段，我们指定了更新日志条目应显示的顺序，在这种情况下，为 `asc`，即升序。`filters`
    字段使用 `exclude` 子字段指定了与要排除的提交匹配的正则表达式列表。要查看 `changelog` 字段的所有可用选项，请访问 `https://goreleaser.com/customization/changelog/`。
- en: So, now that we’ve finished analyzing the default GoReleaser configuration,
    let’s determine what we’d want to consider adding.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经完成了对默认 GoReleaser 配置的分析，让我们确定我们想要考虑添加的内容。
- en: Release
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发布
- en: 'The following code block in the GoReleaser configuration dictates that if there
    are any changes present within a Git repository, it automatically generates a
    pre-release. The pre-released version will have a version number that includes
    a pre-release suffix, such as `1.0.0-beta.1`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: GoReleaser 配置中的以下代码块规定，如果 Git 仓库中存在任何更改，它将自动生成一个预发布版本。预发布版本将包含一个带有预发布后缀的版本号，例如
    `1.0.0-beta.1`：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This automated process provides a convenient way for developers to create early
    versions of their software for testing purposes. By utilizing pre-releases, they
    can quickly and effortlessly gather feedback on the latest changes and make any
    necessary modifications before releasing a final version to the public.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动化过程为开发者提供了一个方便的方式来创建用于测试目的的软件的早期版本。通过利用预发布版本，他们可以快速轻松地收集对最新更改的反馈，并在向公众发布最终版本之前进行任何必要的修改。
- en: Universal binaries
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用二进制
- en: 'Imagine having just one file that can work on multiple architectures of an
    operating system, such as an install that works on a macOS machine with either
    an M1 or Intel chip. That’s what a **universal binary** is, also known as **fat
    binaries**. Instead of having separate binaries for different architectures, you’d
    have just one universal binary that can work on both. This makes it a lot more
    convenient for developers to spread their software across different platforms,
    and for users to just download a single file and run it on their system without
    having to worry about compatibility issues:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下只有一个文件可以在操作系统的多个架构上工作，例如在配备 M1 或 Intel 芯片的 macOS 机器上安装的安装程序。这就是 **通用二进制**，也称为
    **胖二进制**。您不需要为不同的架构分别拥有单独的二进制文件，而只需一个可以在两者上工作的通用二进制文件。这使得开发者将软件推广到不同的平台变得更加方便，并且用户只需下载一个文件，就可以在他们的系统上运行它，而无需担心兼容性问题：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We tell GoReleaser to use universal binaries by adding the `universal_binaries`
    field and setting the `replace` value to `true`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加 `universal_binaries` 字段并将 `replace` 值设置为 `true` 来告诉 GoReleaser 使用通用二进制。
- en: Brews
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Brews
- en: 'The `brews` field allows developers to specify the details for creating and
    publishing Homebrew as part of their release process. Let’s take a look at the
    following addition to our configuration for the audiofile CLI project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`brews` 字段允许开发者指定创建和发布 Homebrew 作为其发布过程的一部分的详细信息。让我们看看我们对 audiofile CLI 项目的配置中以下添加的内容：'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s at least define what these fields are defining for the Homebrew creation
    and publishing process. A **tap repository** is a GitHub repository that contains
    one or more formula files, which define how to install a particular package on
    Homebrew. Note that the tap repository, although defined in the configuration,
    will be created in *Step 3*, *Setting up your* *GitHub repositories*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 至少让我们定义一下这些字段在 Homebrew 创建和发布过程中的定义。一个 **tap 仓库** 是一个包含一个或多个公式文件的 GitHub 仓库，这些文件定义了如何在
    Homebrew 上安装特定的软件包。请注意，虽然 tap 仓库在配置中定义，但将在 *步骤 3*，*设置您的* *GitHub 仓库* 中创建：
- en: '`name` – Defaults to the project name, audiofile.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` – 默认为项目名称，audiofile。'
- en: '`homepage` – Your CLI application’s homepage. This defaults to empty, but set
    it to your GitHub repository name.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`homepage` – 您的 CLI 应用程序的首页。默认为空，但将其设置为您的 GitHub 仓库名称。'
- en: '`tap` – Defines the GitHub/GitLab repository to publish the formula to. The
    `owner` field is the owner of the repository. The `name` field is the name of
    the repository.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tap` – 定义将公式发布到的 GitHub/GitLab 仓库。`owner` 字段是仓库的所有者。`name` 字段是仓库的名称。'
- en: '`commit_author` – This is the Git author that shows up when committing to the
    repository. It defaults to `goreleaserbot`, but in our case, we set it to our
    GitHub handle.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit_author` – 这是提交到仓库时显示的 Git 作者。默认为 `goreleaserbot`，但在我们的情况下，我们将其设置为我们的
    GitHub 昵称。'
- en: You can view all the available customizations available for the `brew` field
    at [https://goreleaser.com/customization/homebrew/](https://goreleaser.com/customization/homebrew/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://goreleaser.com/customization/homebrew/](https://goreleaser.com/customization/homebrew/)
    查看所有可用的 `brew` 字段自定义选项。
- en: Onto the next step!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是下一步！
- en: Configuring GitHub Actions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 GitHub Actions
- en: 'Within this section, we’ll learn about GitHub Actions and how they can be integrated
    with the GoReleaser tool. First, **Github Actions**, as you may recall, is a CI/CD
    tool, but get ready for this, it also has an incredible feature that allows you
    to set off an execution of whatever code you like on your repository when a certain
    event occurs! You may already know this actually, but for those who now know,
    new doors of opportunity are opening. Let’s discuss the main components of GitHub
    Actions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解GitHub Actions以及它们如何与GoReleaser工具集成。首先，**GitHub Actions**，如您所回忆的那样，是一个CI/CD工具，但准备好这个，它还有一个令人难以置信的功能，允许您在发生特定事件时在您的仓库中启动任何您喜欢的代码的执行！您可能已经知道了这一点，但对于那些现在才知道的人来说，新的机会之门正在打开。让我们讨论GitHub
    Actions的主要组件：
- en: '**Events**: Any GitHub event, such as pushing code, creating a new branch,
    opening a PR, a pull request, or commenting on an issue. Events trigger workflows.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**：任何GitHub事件，例如推送代码、创建新分支、打开PR（拉取请求）或评论问题。事件会触发工作流。'
- en: '**Runners**: A runner is a process that starts executing a workflow when triggered
    by an event. There is a one-to-one relationship between a runner and a job.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行者**：运行者是一个在由事件触发时开始执行工作流的进程。运行者与任务之间存在一对一的关系。'
- en: '`/.``github/workflows` directory.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/.github/workflows`目录。'
- en: '**Jobs**: A single job is a series of tasks. A task could be a script or another
    GitHub action.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乔布斯**：一份工作是一系列任务的集合。一个任务可能是一个脚本或另一个GitHub动作。'
- en: '**Actions**: An action is a task. Some tasks may perform complex tasks such
    as publishing a Go package to Homebrew, or simple tasks, such as setting an environment
    variable.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作**：一个动作就是一个任务。一些任务可能执行复杂任务，例如将Go包发布到Homebrew，或者简单的任务，例如设置环境变量。'
- en: 'The following diagram may help to indicate the relationship between the four
    major components of GitHub Actions:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表可能有助于说明GitHub Actions四个主要组件之间的关系：
- en: '![Figure 14.2 – Relationship between events, runners, workflows, jobs, and
    actions](img/Figure_14.2_B18883.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 事件、运行者、工作流、任务和动作之间的关系](img/Figure_14.2_B18883.jpg)'
- en: Figure 14.2 – Relationship between events, runners, workflows, jobs, and actions
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 事件、运行者、工作流、任务和动作之间的关系
- en: 'Now that we’ve grasped the concept of GitHub Actions, let’s see how we can
    take events, such as pushing tags, to trigger a GoReleaser job, which performs
    the complex task of publishing a Go package to Homebrew for us. First, we need
    to create the configuration file. From the root of the repository, do the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了GitHub Actions的概念，让我们看看我们如何将事件，例如推送标签，触发GoReleaser任务，它为我们执行将Go包发布到Homebrew的复杂任务。首先，我们需要创建配置文件。从仓库的根目录开始，执行以下操作：
- en: Create a folder called `.github`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`.github`的文件夹。
- en: Create a subfolder inside of the `.github` folder, called `workflows`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.github`文件夹内创建一个子文件夹，命名为`workflows`。
- en: Create a `release.yml` file.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`release.yml`文件。
- en: The GoReleaser website provides a default configuration for GitHub Actions on
    their website at [https://goreleaser.com/ci/actions/](https://goreleaser.com/ci/actions/).
    You may copy and paste this from their website to give you a good starting point.
    We’ll make a few modifications, but before we do, let’s walk through the default
    configuration together. Let’s begin by discussing the fields that exist within
    the GitHub Actions `release.yml` file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: GoReleaser网站在他们的网站上提供了GitHub Actions的默认配置，网址为[https://goreleaser.com/ci/actions/](https://goreleaser.com/ci/actions/)。您可以从他们的网站复制并粘贴以获得良好的起点。我们将进行一些修改，但在我们这样做之前，让我们一起浏览默认配置。让我们从讨论GitHub
    Actions `release.yml`文件中存在的字段开始。
- en: 'On'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在
- en: 'The `on` field within the Github Actions repository specifies the events that
    trigger the workflow. It could be a single event or multiple. Let’s go through
    some of the events:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Github Actions仓库中的`on`字段指定了触发工作流的事件。它可以是单个事件或多个事件。让我们浏览一些事件：
- en: '`Push`: The `push` field is used to tell the action to trigger a push. For
    example, this can be customized to specify pushing to a branch or tag. The syntax
    for this field is defined as follows:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Push`：`push`字段用于告诉动作触发推送。例如，这可以自定义以指定推送到分支或标签。此字段的语法定义如下：'
- en: '`on.push.<branches|tags|branches-ignore|tags-ignore>.<paths|paths-ignore>`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`on.push.<branches|tags|branches-ignore|tags-ignore>.<paths|paths-ignore>`'
- en: Use the `branches` filter to include specific branch names and the `branches-ignore`
    filter to exclude certain branch names. Remember, don’t use both `branches` and
    `branches-ignore` in the same workflow event.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`branches`过滤器包含特定的分支名称，使用`branches-ignore`过滤器排除某些分支名称。记住，不要在同一个工作流事件中使用`branches`和`branches-ignore`。
- en: Use the `tags` filter for including specific tag names and `tags-ignore` for
    excluding certain tag names. Again, be careful, don’t use both `tags` and `tags-ignore`
    in the same workflow! Apparently, the workflow won’t run if that’s the case.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `tags` 过滤器来包含特定的标签名称，使用 `tags-ignore` 来排除某些标签名称。再次提醒，不要在同一个工作流程中同时使用 `tags`
    和 `tags-ignore`！显然，如果那样做，工作流程将不会运行。
- en: The `paths` and `paths-ignore` fields can be used to specify if code has changed
    within a particular path. The value of those fields may be set to glob patterns
    that use the `*` and `**` wildcard characters. The `paths` and `paths-ignore`
    filters allow you to control what paths are included or excluded from path pattern
    matching.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths` 和 `paths-ignore` 字段可以用来指定特定路径内是否有代码变更。这些字段的值可以设置为使用 `*` 和 `**` 通配符字符的
    glob 模式。`paths` 和 `paths-ignore` 过滤器允许您控制哪些路径被包含或排除在路径模式匹配之外。'
- en: '`Pull request`: The `pull_request` field is used to tell the action to trigger
    a pull request. Like the previous field, we can specify the `branches` filter
    to include specific branch names or the `branches-ignore` filter to exclude branch
    names. Similarly, the `paths` and `paths-ignore` fields may also be set. The `branches`
    and `branches-ignore` fields also accept glob patterns.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pull request`：`pull_request` 字段用于告诉动作触发一个拉取请求。和前面的字段一样，我们可以指定 `branches` 过滤器来包含特定的分支名称或
    `branches-ignore` 过滤器来排除分支名称。同样，`paths` 和 `paths-ignore` 字段也可以设置。`branches` 和
    `branches-ignore` 字段也接受 glob 模式。'
- en: '`event_name`: The `event_name` field defines the type of activity that will
    trigger a workflow to be executed. Within GitHub, there are events that can be
    triggered from more than one activity. The syntax of the full defined event that
    includes this field is defined as follows:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_name`：`event_name` 字段定义了将触发工作流程执行的活动类型。在 GitHub 中，有可以从多个活动触发的事件。包含此字段的全定义事件的语法如下：'
- en: '`on.<event_name>.types`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`on.<事件名>.types`'
- en: There is quite a long list of available events that can be used, including the
    two that we covered earlier, `push` and `pull_request`, but also `check_run`,
    `label`, `release`, and many more.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的可用事件列表相当长，包括我们之前提到的两个事件，`push` 和 `pull_request`，还包括 `check_run`、`label`、`release`
    以及更多。
- en: There’s a lot more that can be done with GitHub Actions, so to see the full
    list of options to customize the `on` field, visit [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 可以做很多事情，所以为了查看自定义 `on` 字段的所有选项，请访问 [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)。
- en: 'Now that we have a good understanding of GitHub Actions, let’s look at the
    default configuration and see what it has set for the `on` field:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 GitHub Actions 有了一个很好的理解，让我们看看默认配置并看看它为 `on` 字段设置了什么：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Perfect! This is pretty much exactly what we need. The preceding block of code
    specifies running the workflow triggered by tags being pushed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！这正是我们所需要的。前面的代码块指定了由标签推送触发的工作流程运行。
- en: Permissions
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 权限
- en: 'The `permissions` field is used to define the level of access that the GitHub
    Actions workflow has to various resources within your GitHub repository. Essentially,
    it helps you control what your workflow can and can’t do within your repository.
    Let’s take a look at the default configuration for the `permissions` field:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`permissions` 字段用于定义 GitHub Actions 工作流程对您 GitHub 仓库内各种资源的访问级别。本质上，它帮助您控制工作流程在仓库内可以做什么和不能做什么。让我们看看
    `permissions` 字段的默认配置：'
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last two lines are commented out, but we can still discuss them. Within
    the preceding code, there are three permission types specified: `contents`, `packages`,
    and `issues`. Since these permissions are all set to `write`, but the latter two
    are commented out, then we limit the workflow permissions to `contents: write`
    to the repository. Based on the documentation on GoReleaser, the `contents:write`
    permission is required in order to upload archives as GitHub releases or to publish
    to Homebrew.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '最后两行被注释掉了，但我们仍然可以讨论它们。在前面的代码中，指定了三种权限类型：`contents`、`packages` 和 `issues`。由于这些权限都设置为
    `write`，但后两个被注释掉了，因此我们将工作流程权限限制为对仓库的 `contents: write`。根据 GoReleaser 的文档，`contents:write`
    权限是上传存档作为 GitHub 发布或发布到 Homebrew 所必需的。'
- en: 'If you want to push Docker images to GitHub, you’ll need to enable the `packages:
    write` permission. If you use milestone closing capacity, you’ll need the `issues:
    write` permission enabled.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您想将 Docker 镜像推送到 GitHub，您需要启用 `packages: write` 权限。如果您使用里程碑关闭容量，您需要启用 `issues:
    write` 权限。'
- en: Jobs
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作业
- en: 'The `jobs` field defines the individual tasks that make up your workflow. It
    is basically the blueprint of the workflow, defining each job and specifying in
    which order they will be executed. Let’s take a look at the default value set
    within our configuration file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobs` 字段定义了组成您工作流程的各个任务。它基本上是工作流程的蓝图，定义了每个作业以及它们将按何种顺序执行。让我们看看我们配置文件中设置的默认值：'
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let’s clarify the preceding code. There is only one job, named `goreleaser`,
    defined under the `jobs` field. The `goreleaser` job has the following steps defined
    in order:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们澄清前面的代码。在 `jobs` 字段下只定义了一个名为 `goreleaser` 的作业，该作业按照以下顺序定义了以下步骤：
- en: '`actions/checkout@v3` action to check out the code from your GitHub repository.
    The `fetch-depth` parameter is set to `0`, which ensures that all branches and
    tags are fetched from the repository.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`actions/checkout@v3` 动作用于从您的 GitHub 仓库检出代码。`fetch-depth` 参数设置为 `0`，这确保了从仓库中获取所有分支和标签。'
- en: '`git fetch --force --tags` command, which fetches all tags from the Git repository.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`git fetch --force --tags` 命令，该命令从 Git 仓库获取所有标签。'
- en: '`actions/setup-go@v3` action to set up a Go environment. The `go-version` parameter
    is set to `>=1.20.0`, which specifies the minimum version of Go required for this
    job. The `cache` parameter is set to `true`, which tells GitHub Actions to cache
    the Go environment, speeding up subsequent runs of this job.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`actions/setup-go@v3` 动作用于设置 Go 环境。`go-version` 参数设置为 `>=1.20.0`，指定此作业所需的 Go
    的最低版本。`cache` 参数设置为 `true`，告诉 GitHub Actions 缓存 Go 环境，加快此作业后续运行的执行速度。'
- en: '`goreleaser/goreleaser-action@v4` action to release the code with GoReleaser.
    The `distribution` parameter is set to `goreleaser`, which specifies the type
    of distribution to be used. The `version` parameter is set to `latest`, which
    specifies the latest version of GoReleaser to be used. The `args` parameter is
    set to `release --clean`, which specifies the command-line arguments to be passed
    to GoReleaser when the release is performed.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`goreleaser/goreleaser-action@v4` 动作用于使用 GoReleaser 发布代码。`distribution` 参数设置为
    `goreleaser`，指定要使用的分发类型。`version` 参数设置为 `latest`，指定要使用的 GoReleaser 的最新版本。`args`
    参数设置为 `release --clean`，指定在执行发布时传递给 GoReleaser 的命令行参数。'
- en: The only modification that we’ll need to do to the default configuration is
    to modify the `with.version` field for the `goreleaser/goreleaser-action` step.
    Currently, the default value is set to `latest`. Let’s replace it with `${{ env.GITHUB_REF_NAME
    }}`. The environment variable, `env.GITHUB_REF_NAME`, is automatically set by
    GitHub and represents the branch or tag name for the current Git reference.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改默认配置的唯一修改是修改 `goreleaser/goreleaser-action` 步骤的 `with.version` 字段。当前默认值设置为
    `latest`。让我们将其替换为 `${{ env.GITHUB_REF_NAME }}`。环境变量 `env.GITHUB_REF_NAME` 由 GitHub
    自动设置，代表当前 Git 引用的分支或标签名称。
- en: Final note, at the bottom of the configuration file, the environment variables
    are set to be used when `goreleaser` runs. `secrets.GITHUB_TOKEN` must be replaced
    with `secrets.PUBLISHER_TOKEN`. This token will be used when publishing to our
    other repository, the Homebrew tap repository. We’ve completed the configuration
    of our GitHub Actions, so now we can move on to the next step.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的注意事项，在配置文件的底部，设置了环境变量，以便在 `goreleaser` 运行时使用。必须将 `secrets.GITHUB_TOKEN` 替换为
    `secrets.PUBLISHER_TOKEN`。此令牌将在发布到我们的其他仓库，即 Homebrew tap 仓库时使用。我们已经完成了 GitHub
    Actions 的配置，因此现在我们可以继续下一步。
- en: Setting up your GitHub repositories
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置您的 GitHub 仓库
- en: If you’ve been following along with the audiofile CLI repository, then the repository
    already exists on GitHub. However, if you are creating your own CLI application
    in tandem, now is the time to make sure the repository exists on GitHub.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在跟随 audiofile CLI 仓库，那么该仓库已经在 GitHub 上存在。然而，如果您正在同时创建自己的 CLI 应用程序，现在就是确保该仓库存在于
    GitHub 上的时间。
- en: Besides pushing your CLI application’s repository to GitHub, we’ll also need
    to create the Homebrew tap repository that was defined earlier in the GoReleaser
    configuration file. A Homebrew `homebrew/core` repository, onto their computers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将您的 CLI 应用程序的仓库推送到 GitHub 之外，我们还需要创建在 GoReleaser 配置文件中先前定义的 Homebrew tap 仓库。将
    Homebrew `homebrew/core` 仓库推送到他们的计算机上。
- en: 'Let’s follow the steps to creating a new Homebrew tap repository:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照创建新的Homebrew tap仓库的步骤进行：
- en: Sign in to GitHub [https://github.com](https://github.com).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录GitHub [https://github.com](https://github.com)。
- en: Click the **New repository** button from your GitHub dashboard.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的GitHub仪表板点击**新建仓库**按钮。
- en: Enter the repository details. In our example, enter the name, homebrew-audiofile,
    that matches what we set within the GoReleaser configuration. Make sure that the
    repository is set to `Public` as well.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入仓库详细信息。在我们的例子中，输入名称，homebrew-audiofile，这与我们在GoReleaser配置中设置的名称相匹配。确保将仓库设置为`Public`。
- en: Create the repository by clicking on the **Create** **repository** button.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**创建** **仓库**按钮来创建仓库。
- en: Clone the repository to your local machine.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将仓库克隆到您的本地机器。
- en: There’s no reason to add any files at this point. The GoReleaser tool, once
    we run the release process, will push the formula to this repository, but first,
    we need to create a token to use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有理由添加任何文件。一旦我们运行发布过程，GoReleaser工具会将公式推送到这个仓库，但首先，我们需要创建一个令牌来使用。
- en: Setting up your GitHub Token for Actions
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置GitHub Token以用于操作
- en: In order to make the GoReleaser and GitHub Actions workflow work, we need to
    create a GitHub token and Actions secret.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使GoReleaser和GitHub Actions工作流程正常工作，我们需要创建一个GitHub令牌和操作秘密。
- en: 'To create a GitHub Token, click on your user menu and select the **Settings**
    option:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建GitHub令牌，点击您的用户菜单并选择**设置**选项：
- en: '![Figure 14.3 – User menu with the Settings option selected](img/Figure_14.3_B18883.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 选择设置选项的用户菜单](img/Figure_14.3_B18883.jpg)'
- en: Figure 14.3 – User menu with the Settings option selected
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 选择设置选项的用户菜单
- en: Once you are on the **Settings** page, scroll down the menu to see the last
    option, **Developer Settings**. When you select **Developer Settings**, you should
    now see the **Personal access tokens** option in the menu on the left side.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入**设置**页面，滚动菜单以查看最后一个选项，**开发者设置**。当您选择**开发者设置**时，您现在应该能在左侧菜单中看到**个人访问令牌**选项。
- en: '![Figure 14.4 – The Developer Settings page with Generate new token options](img/Figure_14.4_B18883.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 带有生成新令牌选项的开发者设置页面](img/Figure_14.4_B18883.jpg)'
- en: Figure 14.4 – The Developer Settings page with Generate new token options
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 带有生成新令牌选项的开发者设置页面
- en: 'Click on the **Generate new token** button. You might need to authenticate
    again if you have a two-factor authentication setup, but then you should be routed
    to the **New personal access token (classic)** page. From this page, take the
    following steps to create your GitHub token:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**生成新令牌**按钮。如果您设置了双因素认证，可能需要再次进行身份验证，但之后您应该会被路由到**新个人访问令牌（经典）**页面。从该页面，按照以下步骤创建您的GitHub令牌：
- en: Enter a value for the `audiofile` since this will be used for the audiofile
    CLI project.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`audiofile`输入一个值，因为这个值将被用于audiofile CLI项目。
- en: In the **Select scopes** section, select **repo**. This will give it permission
    to run actions against your repositories. Then, scroll to the bottom and click
    the **Generate** **token** button.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选择范围**部分，选择**repo**。这将赋予它运行针对您仓库的操作的权限。然后，滚动到页面底部并点击**生成** **令牌**按钮。
- en: '![Figure 14.5 – The Personal access tokens page once the token has been generated](img/Figure_14.5_B18883.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 生成令牌后个人访问令牌页面](img/Figure_14.5_B18883.jpg)'
- en: Figure 14.5 – The Personal access tokens page once the token has been generated
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 生成令牌后个人访问令牌页面
- en: Copy the generated token (which has been blocked out within the preceding screenshot).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制生成的令牌（在先前的屏幕截图中被遮挡）。
- en: Go back to your CLI repository; in our case, we went back to the [https://github.com/marianina8/audiofile](https://github.com/marianina8/audiofile).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的CLI仓库；在我们的例子中，我们返回到了[https://github.com/marianina8/audiofile](https://github.com/marianina8/audiofile)。
- en: Click on **Settings**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置**。
- en: From the menu on the left side, click on **Secrets and Variables**, which expands
    to show more options. Click on the **Actions** option.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中，点击**秘密和变量**，这将展开显示更多选项。点击**操作**选项。
- en: Click on **New repository secret**, which is in the top right corner of the
    screen.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕右上角的**新建仓库秘密**。
- en: '![Figure 14.6 – Actions secrets and variables page](img/Figure_14.6_B18883.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 操作秘密和变量页面](img/Figure_14.6_B18883.jpg)'
- en: Figure 14.6 – Actions secrets and variables page
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 操作秘密和变量页面
- en: From the `env.GITHUB_TOKEN` value in the template was set to `secrets.PUBLISHER_TOKEN`.
    Enter the `PUBLISHER_TOKEN` value into the **Name** field.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模板中的`env.GITHUB_TOKEN`值设置为`secrets.PUBLISHER_TOKEN`。将`PUBLISHER_TOKEN`值输入到**名称**字段。
- en: Paste the secret you copied in *step 3* into the **Secret** field.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你在*步骤 3*中复制的秘密粘贴到**秘密**字段中。
- en: Click the **Add** **secret** button.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加秘密**按钮。
- en: Confirm that the secret now exists in your **Actions secrets and** **variables**
    page.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认秘密现在存在于你的**动作秘密和变量**页面。
- en: '![Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN](img/Figure_14.7_B18883.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 显示新创建的 PUBLISHER_TOKEN 的存储库秘密](img/Figure_14.7_B18883.jpg)'
- en: Figure 14.7 – Repository secrets showing newly created PUBLISHER_TOKEN
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 显示新创建的 PUBLISHER_TOKEN 的存储库秘密
- en: Now that the publisher token is set, let’s move on to the final step.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发布者令牌已经设置好，让我们继续到最后一步。
- en: Trigger release
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发发布
- en: 'Now that the configuration files have been set up for GoReleaser and GitHub
    Actions, and the publisher tokens to give access to make changes to the repositories
    are also created and shared, we are ready to trigger a release with the next step
    of the workflow: tag and push the code. Before we do so, let’s take a step back
    and discuss what happens when you trigger the goReleaser job:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GoReleaser 和 GitHub Actions 的配置文件已经设置好，用于更改存储库的访问权限的发布者令牌也已创建并共享，我们准备通过工作流程的下一步来触发发布：标记并推送代码。在我们这样做之前，让我们回顾一下当你触发
    goReleaser 作业时会发生什么：
- en: '**Preparation**: GoReleaser checks the configuration files, validates the environment,
    and sets up the necessary environment variables'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：GoReleaser 检查配置文件，验证环境，并设置必要的环境变量'
- en: '**Building**: Builds the Go binary and compiles it for multiple platforms (such
    as Windows, Linux, and macOS)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：构建 Go 可执行文件，并为多个平台（如 Windows、Linux 和 macOS）编译'
- en: '**Versioning**: Generates a new version number based on the existing version
    and the user’s configuration'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：根据现有版本和用户的配置生成新的版本号'
- en: '**Creating the release artifacts**: Generates the release artifacts, such as
    tarballs, deb/rpm packages, and zip files for each platform'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建发布工件**：为每个平台生成发布工件，例如 tarball、deb/rpm 软件包和 zip 文件'
- en: '**Creating a Git tag**: Creates a new Git tag for the release, which is used
    to reference the release in the future'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建 Git 标签**：为发布创建一个新的 Git 标签，用于将来引用发布'
- en: '**Uploading the artifacts**: Uploads the generated release artifacts to the
    specified locations, such as a GitHub release, a file server, or a cloud storage
    service'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上传工件**：将生成的发布工件上传到指定的位置，例如 GitHub 发布、文件服务器或云存储服务'
- en: '**Updating Homebrew formulas**: If you are using Homebrew, it will update the
    Homebrew formulas to reflect the new release'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新 Homebrew 公式**：如果你使用 Homebrew，它将更新 Homebrew 公式以反映新发布'
- en: '**Notifying stakeholders**: If set up to do so, GoReleaser can notify stakeholders
    about the new release through various channels, such as email, Slack, or webhooks'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知利益相关者**：如果设置好，GoReleaser 可以通过电子邮件、Slack 或 webhook 等多种渠道通知利益相关者关于新发布的消息'
- en: Note that the previous steps may vary based on the specific configuration and
    plugins used with GoReleaser. Moving on, let’s trigger it with the push of a tag.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的步骤可能根据 GoReleaser 使用的特定配置和插件而有所不同。继续前进，让我们通过标记的推送来触发它。
- en: Tag and push the code
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记并推送代码
- en: 'At this point, make sure all the code changes you have been pushed to the remote
    repository for your CLI project:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，确保你已经将所有代码更改推送到你的 CLI 项目的远程存储库：
- en: 'Tag your CLI with the appropriate version. For our CLI project, within the
    audiofile repository, we run the following Git command:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的版本标记你的 CLI。对于我们的 CLI 项目，在 audiofile 存储库中，我们运行以下 Git 命令：
- en: '[PRE16]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now push the tag to the repository. This should trigger the GitHub Actions
    to take place:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将标签推送到存储库。这应该会触发 GitHub Actions 的执行：
- en: '[PRE17]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Visit the CLI repository, and you’ll now notice a yellow dot appear at the
    top of the file listing:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 CLI 存储库，你将注意到文件列表顶部出现一个黄色点：
- en: '![Figure 14.8 – Repository showing yellow dot](img/Figure_14.8_B18883.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.8 – 显示黄色点的存储库](img/Figure_14.8_B18883.jpg)'
- en: Figure 14.8 – Repository showing yellow dot
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – 显示黄色点的存储库
- en: 'Click on the yellow dot, and a popup will appear. To view the details of the
    GoReleaser process, click on the **Details** link:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击黄色点，将出现一个弹出窗口。要查看 GoReleaser 进程的详细信息，请点击**详细信息**链接：
- en: '![Figure 14.9 – Details popup of goReleaser process](img/Figure_14.9_B18883.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.9 – goReleaser 进程的详细信息弹出窗口](img/Figure_14.9_B18883.jpg)'
- en: Figure 14.9 – Details popup of goReleaser process
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – goReleaser 进程的详细信息弹出窗口
- en: 'Clicking on the **Details** link will take you to a page where you can watch
    the GoReleaser workflow progressing through each task:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **详情** 链接将带您到一个页面，您可以观看 GoReleaser 工作流程通过每个任务的进度：
- en: '![Figure 14.10 – List of tasks and their progress within the goreleaser job](img/Figure_14.10_B18883.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10 – goreleaser 作业中的任务及其进度列表](img/Figure_14.10_B18883.jpg)'
- en: Figure 14.10 – List of tasks and their progress within the goreleaser job
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – goreleaser 作业中的任务及其进度列表
- en: 'Once it successfully completes, from the CLI repository, click on the tag listed
    under the **Releases** section on the right-hand side of the page. From there,
    you’ll see the changelog and list of **Assets**:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功完成，从 CLI 存储库中，点击页面右侧 **发布** 部分下列出的标签。从那里，您将看到变更日志和 **资产** 列表：
- en: '![Figure 14.11 – List of assets generated from the goreleaser job](img/Figure_14.11_B18883.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 由 goreleaser 作业生成的资产列表](img/Figure_14.11_B18883.jpg)'
- en: Figure 14.11 – List of assets generated from the goreleaser job
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 由 goreleaser 作业生成的资产列表
- en: Looks like all the builds were successfully generated and archived and are available
    as assets on the **Releases** page. What if it can be installed successfully with
    Homebrew? For the final confirmation, let’s jump to the next section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来所有构建都已成功生成和归档，并且作为 **发布** 页面上的资产可用。如果它能成功通过 Homebrew 安装呢？为了最终确认，让我们跳到下一节。
- en: Installing with Homebrew and Testing
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Homebrew 安装和测试
- en: 'Since the GoReleaser job ran successfully, we should be able to install the
    CLI application with Homebrew. Let’s begin by telling Homebrew to tap the repository
    we’ve created for the formula:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GoReleaser 作业运行成功，我们应该能够使用 Homebrew 安装 CLI 应用程序。让我们首先告诉 Homebrew 使用我们为公式创建的存储库：
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should see the following output generated from the previous command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，这是来自上一个命令的：
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we know, tapping the repository adds to the list of Homebrew formulas to
    install. Next, let’s try installing the audiofile CLI:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，添加存储库会将 Homebrew 公式列表扩展。接下来，让我们尝试安装 audiofile CLI：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the following output generated for the installation of the application:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，这是为应用程序安装生成的：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, for the final test, let’s run the `audiofile` command and see the output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了最后的测试，让我们运行 `audiofile` 命令并查看输出：
- en: '![Figure 14.12 – Output of the audiofile command installed by Homebrew](img/Figure_14.12_B18883.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 由 Homebrew 安装的 audiofile 命令的输出](img/Figure_14.12_B18883.jpg)'
- en: Figure 14.12 – Output of the audiofile command installed by Homebrew
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 由 Homebrew 安装的 audiofile 命令的输出
- en: 'Let’s now try some of the commands; first, let’s start the API in one terminal
    window:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些命令；首先，让我们在一个终端窗口中启动 API：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In another terminal, let’s run the player by calling the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，让我们通过调用以下命令来运行播放器：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下内容：
- en: '![Figure 14.13 – The audiofile player](img/Figure_14.13_B18883.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13 – audiofile 播放器](img/Figure_14.13_B18883.jpg)'
- en: Figure 14.13 – The audiofile player
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 – audiofile 播放器
- en: We’ve been able to install with the Homebrew package manager and play around
    with the audiofile to know that it works well. This concludes our chapter on publishing
    your Go binary as a Homebrew formula with GoReleaser. While Homebrew is just one
    package manager, you can follow a similar process for **GoFish**, a cross-platform
    systems package manager that allows users to easily install applications on Linux
    and Windows. Combined, you’ll be able to expand your user base and make it easy
    for your users to install and update your CLI application.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够使用 Homebrew 软件包管理器安装并测试 audiofile，以确认其工作良好。这标志着我们关于使用 GoReleaser 将 Go
    二进制文件作为 Homebrew 公式发布的章节结束。虽然 Homebrew 只是一个软件包管理器，但您可以为 **GoFish**（一个跨平台系统软件包管理器，允许用户在
    Linux 和 Windows 上轻松安装应用程序）遵循类似的过程。结合使用，您将能够扩大您的用户群，并使您的用户能够轻松安装和更新您的 CLI 应用程序。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a closer look at how GoReleaser and GitHub Actions
    can work together to make releasing a CLI application a breeze. First, we got
    to know GoReleaser, a handy tool that makes building, testing, and deploying Go
    binary packages a snap. We went over the default configuration file and also talked
    about some simple tweaks you can make to fit your needs. Then, we explored GitHub
    Actions and how to integrate them with GoReleaser.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地探讨了 GoReleaser 和 GitHub Actions 如何协同工作，使发布 CLI 应用程序变得轻而易举。首先，我们了解了
    GoReleaser，这是一个方便的工具，可以轻松构建、测试和部署 Go 二进制包。我们讨论了默认配置文件，并介绍了一些你可以进行简单调整以适应你需求的修改。然后，我们探讨了
    GitHub Actions 以及如何将其与 GoReleaser 集成。
- en: By the end of this chapter, we had a good understanding of how to use these
    tools to create a seamless and efficient release process, complete with publishing
    on Homebrew. Releasing through Homebrew opens up the possibility of reaching more
    users who prefer to use package managers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们已很好地理解了如何使用这些工具创建一个无缝且高效的发布过程，包括在 Homebrew 上发布。通过 Homebrew 发布可以打开接触更多喜欢使用包管理器的用户的可能性。
- en: Questions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When are `before` hooks run? Are there `after` hooks?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`before`钩子在何时运行？有`after`钩子吗？'
- en: What is the `PUBLISHER_TOKEN` GitHub token used for?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub 中的 `PUBLISHER_TOKEN` 令牌用于什么？
- en: Can you trigger a GitHub Action workflow on a pull request?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在拉取请求上触发 GitHub Action 工作流程吗？
- en: Further reading
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: GoReleaser documentation can be found at [https://goreleaser.com/](https://goreleaser.com/)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoReleaser 文档可以在 [https://goreleaser.com/](https://goreleaser.com/) 找到
- en: GitHub Actions documentation can be found at [https://docs.github.com/en/actions](https://docs.github.com/en/actions)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Actions 文档可以在 [https://docs.github.com/en/actions](https://docs.github.com/en/actions)
    找到
- en: Homebrew documentation can be found at [https://docs.brew.sh/](https://docs.brew.sh/)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Homebrew 文档可以在 [https://docs.brew.sh/](https://docs.brew.sh/) 找到
- en: Answers
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `before` hooks field specifies scripts that are run before the release process.
    Yes, although not discussed in this chapter, there are `after` hooks, too!
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`before`钩子字段指定了在发布过程之前运行的脚本。是的，尽管本章没有讨论，但还有`after`钩子！'
- en: The `PUBLISHER_TOKEN` GitHub token is set as an environment variable on the
    goreleaser job in the `release.yml` file that defines the GitHub Actions release
    workflow. The token is configured within GitHub to give repository access to GitHub
    Actions, allowing the `goreleaser` job to publish the Homebrew formula to the
    `homebrew-audiofile` tap repository.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PUBLISHER_TOKEN` GitHub 令牌在 `release.yml` 文件中设置为环境变量，该文件定义了 GitHub Actions
    发布工作流程。该令牌在 GitHub 中配置，以允许 GitHub Actions 访问仓库，从而使 `goreleaser` 作业能够将 Homebrew
    公式发布到 `homebrew-audiofile` 仓库。'
- en: Yes, among many other triggers described in this chapter, pull requests can
    also trigger GitHub Action workflows.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，在本章描述的许多其他触发器中，拉取请求也可以触发 GitHub Action 工作流程。
