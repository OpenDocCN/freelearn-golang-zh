- en: Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security in microservices can feel like a minefield, and in some ways it is.
    This chapter is mainly intended to look at some of the things that you can do
    to improve the security of your Go code; however, I feel it is important to discuss
    some of the wider issues. In-depth discussion of topics such as firewall configuration
    is best left to specialist books; however, we will introduce some of the concepts
    and problems that are faced so that you can best prepare yourself for some further
    reading.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务中的安全性可能感觉像是一片雷区，在某些方面确实如此。本章主要旨在探讨一些你可以做的事情来提高你的Go代码的安全性；然而，我认为讨论一些更广泛的问题也很重要。对于像防火墙配置这样的主题，最好留给专业书籍来深入讨论；然而，我们将介绍一些你面临的概念和问题，以便你为更深入的阅读做好准备。
- en: Encryption and signing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和签名
- en: When we look at ways of securing data, either at rest or in transport, many
    of the methods we discuss will be cryptographically securing data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探讨保护数据的方法，无论是静态还是传输中的数据，我们讨论的许多方法都将涉及密码学保护数据。
- en: '"Cryptography is the science of using mathematics to encrypt and decrypt data.
    Cryptography enables you to store sensitive information or transmit it across
    insecure networks (line like the internet) so that it cannot be read by anyone
    except the intended recipient."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “密码学是使用数学来加密和解密数据的科学。密码学使你能够存储敏感信息或通过不安全的网络（如互联网）传输信息，这样除了预期的接收者外，任何人都无法读取。”
- en: '- An Introduction to Cryptography, Network Associates, Inc.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '- 《密码学简介》，网络合作伙伴公司'
- en: As a basis for the things we will discuss in this chapter, we must first understand
    how cryptography works, not in the way that we need a mathematics degree, but
    to the extent of the parts involved. Cryptography is only as good as the security
    of the keys involved and we need the knowledge of which of these keys can be distributed
    freely and which ones need to be guarded with our lives.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章我们将讨论的内容的基础，我们首先必须了解密码学是如何工作的，不是我们需要一个数学学位，而是要了解涉及的各个部分。密码学的安全性取决于所涉及的密钥的安全性，我们需要了解哪些密钥可以自由分发，哪些密钥需要我们用生命来保护。
- en: Symmetric-key encryption
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称密钥加密
- en: 'Symmetric-key encryption is also called secret-key or conventional cryptography:
    one key is used for both the encryption and decryption of the data. For a remote
    end to be able to decrypt this information, it must first have the key, and this
    key must be securely held as a single compromise of one server will lead to the
    compromise of all servers who share this key. It can also make key management
    more complicated, as when you need to change the key, and you should change it
    often, you will need to roll this change out across your entire estate.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密也称为密钥加密或传统密码学：一个密钥用于数据的加密和解密。为了远程端能够解密这些信息，它必须首先拥有这个密钥，并且这个密钥必须安全地保存，因为一个服务器的密钥泄露将导致所有共享这个密钥的服务器被泄露。它也可能使密钥管理更加复杂，因为当你需要更改密钥，而你应该经常更改它时，你需要将这个更改在整个环境中推广。
- en: Public-key cryptography
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公钥密码学
- en: Public-key cryptography was introduced by Whitfield Diffie and Martin Hellman
    in 1975 to get around the need for both sides requiring to know the secret. In
    fact, they were not the first to invent this; it was developed by the British
    Secret Service some years earlier but was kept a military secret.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学是由Whitfield Diffie和Martin Hellman于1975年引入的，以避免双方都需要知道秘密的需要。实际上，他们并不是第一个发明这种技术的；它是由英国情报机构多年前开发的，但被当作军事机密保密。
- en: Public-key cryptography uses a pair of keys for encryption; you will also hear
    it called asymmetric encryption. The public key is used for encrypting information
    while the private can only be used for decrypting. Because there is no way to
    determine the private key from the public, it is common that public keys will
    be published to the world.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学使用一对密钥进行加密；你也会听到它被称为非对称加密。公钥用于加密信息，而私钥只能用于解密。因为无法从公钥中确定私钥，所以通常公钥会被公之于众。
- en: Digital signatures
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字签名
- en: Public-key cryptography also gives us the capability of using digital signatures.
    A digital signature works by encrypting a message with a private key and then
    transferring the signed message. If the message can be decrypted with the public
    key, then the message must have originated from the holder of a private key. Due
    to the computation time of encrypting messages and the increase in the size of
    the payload, a standard approach is to create a one-way hash of the message and
    then use the private key to encrypt this. The recipient will decrypt the hash
    with the public key and generate the same hash from the message; then, the message
    can be deemed to be from a trustworthy source.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密也赋予我们使用数字签名的功能。数字签名通过使用私钥加密消息然后传输已签名的消息来实现。如果消息可以用公钥解密，那么消息一定是从私钥持有者那里发出的。由于加密消息的计算时间和有效载荷大小的增加，一个标准的方法是创建消息的单向哈希，然后使用私钥加密这个哈希。接收者将使用公钥解密哈希，并从消息中生成相同的哈希；然后，可以认为消息来自一个可信的来源。
- en: X.509 digital certificates
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: X.509数字证书
- en: One problem with public keys is that you must be careful that the key you think
    belongs to a recipient is owned by the recipient. If keys are transferred across
    public networks, there is always the possibility of a man-in-the-middle attack.
    An attacker could pose a fake public key as what you believe to be your trusted
    recipient; however, they could replace this with their keys. This would mean that
    the message you think has been transferred securely could, in fact, be decrypted
    and read by a malicious third party.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥的一个问题是您必须小心，您认为属于接收者的密钥确实属于接收者。如果密钥在公共网络上传输，总有可能发生中间人攻击。攻击者可以冒充一个假公钥，作为您认为的可信接收者；然而，他们可以用自己的密钥替换它。这意味着您认为已经安全传输的消息实际上可能被恶意第三方解密和读取。
- en: To avoid these issues, digital certificates exist, simplifying the task of establishing
    whether a public key belongs to the reported owner.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，存在数字证书，简化了确定公钥是否属于报告的所有者的任务。
- en: 'A digital certificate contains three things:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数字证书包含三样东西：
- en: A public key
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥
- en: Certificate information such as the owner's name or ID
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书信息，如所有者的名称或ID
- en: One or more digital signatures
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个数字签名
- en: The thing that makes a certificate trustworthy is the digital signatures. The
    certificate is signed by a trusted third party or certificate authority (CA) which
    vouches for your identity and that your public key belongs to you. Anyone can
    create a CA root certificate and sign their certs, and for non-public access to
    systems such as inter-microservice communication, this is quite a common practice.
    For public certificates, however, you pay a CA to sign your certificate. The purpose
    of the pricing is that the CA will ensure that you are who indeed you say you
    are; at present, the most popular CAs are Comodo, Symantec (previously Verisign
    before acquisition), and GoDaddy. The reason you see the padlock in your browser
    is not just because you are using secured communication but that your browser
    has validated the signature of the certificate against one of the 100 or so trusted
    third parties which come bundled with it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使证书可信的是数字签名。证书由一个受信任的第三方或证书授权机构（CA）签署，该机构证明您的身份以及您的公钥属于您。任何人都可以创建CA根证书并签署他们的证书，对于非公开访问系统，如微服务之间的通信，这是一种相当常见的做法。然而，对于公开证书，您需要支付CA来签署您的证书。定价的目的是让CA确保您确实是您所说的那个人；目前，最受欢迎的CA是Comodo、Symantec（在收购之前是Verisign）和GoDaddy。您在浏览器中看到的原因不仅仅是您正在使用安全通信，而是您的浏览器已经验证了证书的签名，这是与它捆绑在一起的100多个受信任的第三方之一。
- en: TLS/SSL
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS/SSL
- en: SSL, which is the common term for secure transmission of data between two systems,
    is a reference to a deprecated standard first developed by Mozilla back in 1995\.
    It has since been replaced by TLS 1.2, which was released in August 2008; while
    SSL 3.0 still technically works, it was deprecated in June 2015 after a vulnerability
    to the **POODLE** (**Paddling Oracle On Downgraded Legacy Encryption**) attack.
    The POODLE attack discovered by a team of Google security researchers in 2014
    works by the attackers making several requests to a server; this data is then
    analyzed and used, which enables them to decrypt the data in the transport. On
    average, only 256 SSL 3.0 calls need to be made to decrypt 1 byte of information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SSL，即两个系统之间安全传输数据的通用术语，是指由Mozilla在1995年首次开发的一个已弃用的标准。自那时起，它已被2008年8月发布的TLS 1.2所取代；尽管SSL
    3.0在技术上仍然可行，但在2015年6月由于**POODLE**（**在降级旧加密中摆动预言机**）攻击的漏洞而被弃用。2014年由一支谷歌安全研究人员团队发现的POODLE攻击是通过攻击者向服务器发送多个请求来工作的；然后分析这些数据并使用它们，这使得他们能够解密传输中的数据。平均而言，只需要进行256次SSL
    3.0调用，就可以解密1字节的信息。
- en: 'This means that the vulnerability existed for 18 years before being publicly
    disclosed; you might ask why people were still using SSL 3.0 15 years after the
    release of the stronger TLS 1.0? This came about due to a problem that some browsers
    and servers did not support TLS 1.0, so there was a fallback that which would
    allow fallback to a lower level of encryption. Even though, at the time of discovery,
    there was pretty much nobody still using SSL 3.0, the fallback was still in the
    protocol and was, therefore, exploitable by the hackers. The solution for this
    was quite straightforward: disable anything lower than TLS 1.0 in the configuration
    of your server. We have a little history of TLS and SSL but how does it keep your
    data secure?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这个漏洞在公开披露之前已经存在了18年；你可能会问，为什么在更强的TLS 1.0发布15年后，人们还在使用SSL 3.0？这起因于一些浏览器和服务器不支持TLS
    1.0的问题，因此存在一个回退机制，允许降级到较低级别的加密。尽管在发现时几乎没有人还在使用SSL 3.0，但回退机制仍然存在于协议中，因此可以被黑客利用。解决这个问题的方法相当简单：在服务器的配置中禁用低于TLS
    1.0的所有内容。我们有一些TLS和SSL的历史，但它是如何保护你的数据安全的呢？
- en: TLS works using symmetrical encryption, where the client and the server both
    have a key which is used for encryption and decryption. If you remember the previous
    section, we introduced symmetrical encryption and the problems of distributing
    keys. TLS gets around this problem by using asymmetrical encryption in the first
    part of the handshake. The client retrieves the certificate containing the public
    key from the server and generates a random number; it uses the public key to encrypt
    this random number and sends it back to the server. Now that both parties have
    the random number, they use this to generate symmetrical keys which are used for
    encrypting and decrypting the data over the transport.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TLS使用对称加密，客户端和服务器都拥有一个用于加密和解密的密钥。如果你还记得上一节，我们介绍了对称加密和密钥分发的问题。TLS通过在握手的第一部分使用非对称加密来解决这个问题。客户端从服务器检索包含公钥的证书并生成一个随机数；它使用公钥来加密这个随机数并将其发送回服务器。现在双方都有了随机数，他们使用这个随机数来生成对称密钥，这些密钥用于在传输过程中加密和解密数据。
- en: External security
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部安全
- en: This is your first line of defense to keep your systems safe, it is commonly
    comprised of layer 2 or 3 firewalls, DDoS protection, web application firewalls,
    and other software and hardware. Before an attacker can compromise your application,
    they must first pass through these layers of hardware and software which is not
    part of your application code but is a shared infrastructure layer that many components
    in the application may share. In this section, we will look at some of this external
    security as well as some attacks that could be used against you. Securing the
    perimeter of your services is often a task completed by operations however as
    developers we need to understand the processes and risks as it greatly enhances
    our ability to harden our application code. In this section, we will look at the
    common methods of external security and also some of the ways hackers can exploit
    your system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保护您系统安全的第一道防线，通常由第2层或第3层防火墙、DDoS保护、Web应用防火墙以及其他软件和硬件组成。在攻击者能够破坏您的应用程序之前，他们必须首先通过这些硬件和软件层，这些层不是应用程序代码的一部分，而是一个共享的基础设施层，应用程序中的许多组件可能都会共享。在本节中，我们将探讨一些外部安全措施以及可能针对您发起的攻击。通常，保护服务边界是由运维人员完成的任务，然而作为开发者，我们需要了解这些流程和风险，因为这极大地增强了我们加固应用程序代码的能力。在本节中，我们将探讨外部安全的一些常见方法，以及黑客可能利用系统的一些方式。
- en: Layer 2 or 3 firewalls
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2层或第3层防火墙
- en: 'Layer 2 is more commonly used for routing as it deals purely with MAC addresses
    and not IP addresses whereas layer 3 is IP address aware. Traditionally, layer
    2 was the only real way to go without adding latency as it would perform at roughly
    the same speed as the wire. With increases in processing power and memory, layer
    3 now performs at wire speeds and generally, when we are looking at edge firewalls,
    which are generally the first entry point into your system, they will be layer
    3 these days. So what does this give us? Firstly, it stops unwanted traffic at
    the edge: we limit the ports which are accessible to the outside world and traffic
    destined for something which is not allowed is stopped at the firewall and does
    not get the chance to execute an attack on the origin. In addition to this, it
    also allows us to restrict access to certain ports. For example, if you are running
    a server, you most likely will want some form of remote access such as SSH. The
    Heartbleed exploit which came out in 2015 took advantage of a vulnerability in
    OpenSSH, and SSH servers which were directly exposed to the Internet would be
    prone to this attack. Using a firewall effectively would mean that private ports
    such as SSH would be locked down to an IP address or IP range, which could be
    your VPN, office IP, or public IP. This dramatically reduces the attack vector
    so while you might be running a version of OpenSSH which is vulnerable to Heartbleed,
    for an attacker to take advantage of this, they would need to be inside of your
    protected zone.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第2层更常用于路由，因为它只处理MAC地址，而不处理IP地址，而第3层则是IP地址感知的。传统上，第2层是唯一真正的方式，因为它不会增加延迟，其速度与电缆大致相同。随着处理能力和内存的增加，第3层现在可以以电缆速度运行，通常，当我们查看边缘防火墙时，这些防火墙通常是进入您系统的第一个入口点，现在它们通常是第3层。这给我们带来了什么？首先，它阻止了边缘的不必要流量：我们限制了对外部世界的可访问端口，并阻止了流量到达不允许的目标，这些流量在防火墙处被阻止，没有机会对源头执行攻击。除此之外，它还允许我们限制对某些端口的访问。例如，如果您正在运行服务器，您很可能需要某种形式的远程访问，如SSH。2015年出现的Heartbleed漏洞利用了OpenSSH中的漏洞，直接暴露在互联网上的SSH服务器容易受到这种攻击。有效地使用防火墙意味着私有端口，如SSH，将被锁定到IP地址或IP地址范围，这可能是您的VPN、办公IP或公共IP。这大大减少了攻击向量，因此即使您正在运行一个容易受到Heartbleed影响的OpenSSH版本，攻击者要利用这一点，他们也需要在您的受保护区域内。
- en: 'The Heartbleed vulnerability exploited the ability to execute a buffer overrun
    attack. For example, you ask the server for a 4-letter word but specify the length
    of 500; what you get back is the 4-letter word, and the remaining 496 characters
    are the blocks of memory which follow the memory address of the initial allocation.
    In practice, this allowed a hacker to access chunks of memory in the server randomly;
    this may contain items, such as change password requests, which give them credentials
    to access the server. If you are running a globally available SSH server, then
    you may find you have a problem:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbleed漏洞利用了执行缓冲区溢出攻击的能力。例如，你要求服务器返回一个4个字母的单词，但指定长度为500；你得到的是4个字母的单词，剩下的496个字符是跟随初始分配内存地址的内存块。在实践中，这允许黑客随机访问服务器中的内存块；这可能包含诸如更改密码请求这样的项目，这些项目给了他们访问服务器的凭证。如果你运行的是一个全球可用的SSH服务器，那么你可能发现你有一个问题：
- en: '![](img/6c128381-747f-4ba7-8e96-be61fe250825.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c128381-747f-4ba7-8e96-be61fe250825.png)'
- en: Web application firewall
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络应用防火墙
- en: 'A web application firewall (**WAF)** is configured as your second or third
    line of defense in a system. To understand what a WAF is, let''s look at the definition
    from the Open Web Application Security Project (OWASP):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用防火墙（**WAF**）在系统中配置为第二或第三道防线。为了理解什么是WAF，让我们看看来自开放网络应用安全项目（OWASP）的定义：
- en: '"A web application firewall (WAF) is an application firewall for HTTP applications.
    It applies a set of rules to an HTTP conversation. These rules cover common attacks
    such as cross-site scripting (XSS) and SQL injection.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “网络应用防火墙（WAF）是针对HTTP应用的防火墙。它将一系列规则应用于HTTP会话。这些规则涵盖了常见的攻击，如跨站脚本（XSS）和SQL注入。
- en: While proxies protect clients, WAFs protect servers. A WAF is deployed to protect
    a specific web application or set of web applications. A WAF can be considered
    a reverse proxy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理保护客户端时，WAF保护服务器。WAF被部署以保护特定的网络应用或一组网络应用。WAF可以被视为反向代理。
- en: WAFs may come in the form of an appliance, server plugin, or filter, and may
    be customized to an application. The effort to perform this customization can
    be significant and needs to be maintained as the application is modified."
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WAF可能以设备、服务器插件或过滤器的形式出现，并且可以根据应用程序进行定制。进行这种定制的努力可能非常显著，并且需要随着应用程序的修改而维护。”
- en: OWASP is an incredibly useful resource and in fact has provided a core ruleset
    for ModSecurity, which protects against attacks such as SQL Injection XSS, Shellshock.
    As a bare minimum, setting up a WAF such as ModSecurity and the OWASP CRS should
    be your minimum requirement. Hosting this inside a Docker container should be
    relatively trivial, and this could form the second line of defense behind your
    layer 2 firewall.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP是一个非常有用的资源，实际上已经为ModSecurity提供了一套核心规则集，ModSecurity可以防止诸如SQL注入、XSS、Shellshock等攻击。作为最低要求，设置一个如ModSecurity和OWASP
    CRS的WAF应该是你的基本需求。在Docker容器内托管这应该相对简单，这可以形成在第二层防火墙之后的第二道防线。
- en: 'There is also another option: some CDN companies such as Cloudflare offer a
    hosted WAF. This is protection at the edge of your network and thanks to the expertise
    of businesses such as Cloudflare, you do not need to worry about configuration.
    In fact, Cloudflare supports the OWASP CRS ([https://www.modsecurity.org/crs/](https://www.modsecurity.org/crs/)).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有一个选择：一些CDN公司，如Cloudflare，提供托管WAF服务。这是在网络的边缘提供保护，得益于像Cloudflare这样的企业专业知识，你无需担心配置问题。实际上，Cloudflare支持OWASP
    CRS（[https://www.modsecurity.org/crs/](https://www.modsecurity.org/crs/)）。
- en: API Gateway
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关
- en: 'In addition to a WAF, an API Gateway can be a useful tool to have; this can
    serve a dual purpose of routing your public APIs to their backend services and
    some additional features such as token validation at the edge and input validation
    and transformation. When we talked about the confused deputy problem, where an
    attacker who is behind your firewall can execute commands which they are not privileged
    to do, we looked at the possibilities for encrypting web tokens; the problem with
    this is that private keys for decrypting these tokens would need to be distributed
    across multiple backend services. This makes managing keys far more challenging
    than it should be. An API Gateway can simplify this situation by being the only
    layer which can decrypt a message; the other services use the public key to verify
    a signature. API Gateways often implement many other first-line features such
    as but not limited to the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了WAF（Web应用防火墙）之外，API网关也是一个非常有用的工具；它可以同时起到将您的公共API路由到后端服务以及一些附加功能的作用，例如在边缘进行令牌验证和输入验证与转换。当我们讨论到困惑代理问题，即防火墙后面的攻击者可以执行他们无权执行的命令时，我们探讨了加密Web令牌的可能性；但问题是，用于解密这些令牌的私钥需要分布到多个后端服务中。这使得密钥管理比应有的要复杂得多。API网关可以通过成为唯一可以解密消息的层来简化这种情况；其他服务使用公钥来验证签名。API网关通常实现许多其他一线功能，例如但不限于以下内容：
- en: Request validation
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求验证
- en: Authorization
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: Rate limiting
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Logging
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Caching
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Request and response transformations
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和响应转换
- en: There is an element of crossover between a WAF and an API Gateway; however,
    the two should be treated as two distinctly separate parts of your infrastructure.
    Regarding providers of an API Gateway, this seems to be a developing area; AWS
    has an advanced API Gateway which can be used if you have bought into the AWS
    PaS environment. For standalone deployments, Kong ([https://getkong.org/](https://getkong.org/)),
    Tyk ([https://tyk.io/](https://tyk.io/)), Apigee ([https://apigee.com/api-management/#/homepage](https://apigee.com/api-management/#/homepage)),
    Mashery ([https://www.mashery.com/](https://www.mashery.com/)), and the Anypoint
    Platform from Mulesoft ([https://www.mulesoft.com/](https://www.mulesoft.com/))
    are among the leaders in this field. It is, of course, possible to build your
    own API Gateway backed with Nginx or HAProxy; however, I recommend, you first
    check out one of the specific platforms before going ahead and building your own.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: WAF和API网关之间存在一定的交叉；然而，这两个应该被视为您基础设施中两个截然不同的部分。关于API网关的提供商，这似乎是一个正在发展的领域；如果您已经购买了AWS
    PaS环境，可以使用AWS的高级API网关。对于独立部署，Kong（[https://getkong.org/](https://getkong.org/)）、Tyk（[https://tyk.io/](https://tyk.io/)）、Apigee（[https://apigee.com/api-management/#/homepage](https://apigee.com/api-management/#/homepage)）、Mashery（[https://www.mashery.com/](https://www.mashery.com/)）以及Mulesoft的Anypoint平台（[https://www.mulesoft.com/](https://www.mulesoft.com/)）是该领域的领导者。当然，您也可以使用Nginx或HAProxy构建自己的API网关；然而，我建议您在着手构建自己的之前先检查一下这些特定的平台。
- en: DDoS protection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDoS保护
- en: On October 21, 2016, a massive internet outage was caused by attackers targeting
    DYN's DNS servers using a Mirai botnet. The Mirai exploit takes advantage of vulnerabilities
    in IP cameras and DVRs made by the Chinese company called XionMai Technologies.
    Rather than attacking a target, the attackers decided to take down a major part
    of the internet's infrastructure, knocking out most of the east and west coast
    of America. The Mirai exploit takes advantage of just 60 usernames and passwords
    to attempt to update the firmware of the vulnerable devices. Once the malware
    had been installed, the device was then controllable by the botnet. All that was
    left to do was tell the bots to start a DNS attack against DYNs nameservers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年10月21日，一次大规模的互联网中断是由攻击者针对DYN的DNS服务器使用Mirai僵尸网络造成的。Mirai漏洞利用了由名为XionMai
    Technologies的中国公司制造的IP摄像头和DVR中的漏洞。攻击者没有攻击目标，而是决定摧毁互联网基础设施的主要部分，使美国东海岸和西海岸的大部分地区瘫痪。Mirai漏洞仅利用了60个用户名和密码来尝试更新易受攻击设备的固件。一旦恶意软件被安装，设备就被僵尸网络控制。剩下的只是告诉机器人对DYN的名称服务器发起DNS攻击。
- en: The code for Mirai has been published online; you can find it using Google without
    much effort. The thing I hope you find surprising looking at this code is just
    how simple it is. Now, I do not want to take anything away from the complexity
    of devising this attack; I am merely talking about the implementation. Quite a
    significant portion of the code is written in Go too, so is very readable. There
    is some excellent use of channels. If you do look at the code, try and identify
    the area which could be improved with a semaphore.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Mirai 的代码已经在网上公布；你只需稍加努力，用 Google 就可以找到。我希望你看到这段代码时感到惊讶的是它的简单性。现在，我不想从设计这种攻击的复杂性中减去任何东西；我只是在谈论实施。相当大的一部分代码是用
    Go 编写的，因此非常易于阅读。其中有一些对通道的出色使用。如果你查看代码，尝试找出可以用信号量改进的区域。
- en: A report published by Akamai stated that 98.34% of all attacks this year were
    infrastructure oriented, with only 1.66% aiming for the application layer. Of
    that 98.34%, many could be avoided with a little network hygiene. Let's look at
    the top threats and how they work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Akamai 发布的一份报告称，今年所有攻击中有 98.34% 是针对基础设施的，只有 1.66% 是针对应用层的。在这 98.34% 中，许多可以通过一点网络卫生来避免。让我们来看看主要的威胁以及它们是如何工作的。
- en: Types of DDoS attack
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDoS 攻击的类型
- en: 'The following are the types of DDos attack:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 DDoS 攻击的类型：
- en: UDP fragment
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP 分片
- en: DNS
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS
- en: NTP
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NTP
- en: Chargen
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chargen
- en: UDP
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP
- en: SYN
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYN
- en: SSDP
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSDP
- en: ACK
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACK
- en: UDP fragment attack
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP 分片攻击
- en: A UDP fragment attack is where the attacker exploits the way that datagram fragmentation
    works on networks. Every network has a limit called a maximum transmission unit
    (MTU). If a datagram sent to the network is greater than the MTU, it is fragmented
    to be transmitted successfully.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 分片攻击是攻击者利用网络中数据报分片的方式。每个网络都有一个称为最大传输单元（MTU）的限制。如果一个发送到网络的数据报大于 MTU，它将被分片以成功传输。
- en: The UDP fragment attack works by creating datagrams which contain fake packets;
    when the server attempts to reassemble these packets, it is unable to do so and
    the resources are quickly overwhelmed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 分片攻击通过创建包含伪造数据包的数据报来实现；当服务器尝试重新组装这些数据包时，它无法做到，资源很快就会被耗尽。
- en: UDP flood
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP 洪水
- en: A UDP flood attack works by sending a flood of UDP packets with a spoofed source
    address to an IP address. The server will respond to these requests, sending a
    reply to the spoofed addresses. Due to the high volume of the attack, a router
    will exceed its limit of UDP datagrams per second and stop sending to all addresses
    in the same security zone for a period.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 洪水攻击通过向一个 IP 地址发送大量带有伪造源地址的 UDP 数据包来实现。服务器将对这些请求做出响应，向伪造的地址发送回复。由于攻击的高强度，路由器将超过每秒
    UDP 数据报的限制，并在一段时间内停止向同一安全区域内的所有地址发送数据。
- en: This also often utilizes a technique called a reflected attack. When the IP
    address for the source is spoofed, the return packets are not sent back to the
    real source but the spoofed IP address. The reason this technique is used is that
    it allows the sender to amplify an attack by only expending resources on the outbound
    packets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常还会利用一种称为反射攻击的技术。当源 IP 地址被伪造时，返回的数据包不会发送回真实源地址，而是发送到伪造的 IP 地址。使用这种技术的理由是，它允许发送者通过仅消耗出站数据包的资源来放大攻击。
- en: DNS
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS
- en: A DNS attack utilizes a UDP flood to take out a DNS server; many requests are
    made to query a DNS server. The requests are designed to return a very large reply
    from a tiny request to maximize the efficiency of the attack since the response
    is often not received by the sender.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 攻击利用 UDP 洪水来攻击 DNS 服务器；会发出许多请求来查询 DNS 服务器。这些请求被设计成从一个小请求返回一个非常大的回复，以最大化攻击效率，因为通常发送者不会收到回复。
- en: The attack which we looked at earlier, which targeted Dyn's infrastructure,
    taking out many websites on the east and west coast of America in October 2016,
    was in the form of this attack. Unlike most DNS attacks, the Miraia net did not
    use Reflection, it allowed the responses to be returned to the sender, which was
    possible due to the enormous number of compromised devices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过的攻击，它针对的是 Dyn 的基础设施，在 2016 年 10 月导致美国东海岸和西海岸的许多网站瘫痪，这种攻击就是以这种方式进行的。与大多数
    DNS 攻击不同，Miraia 网络没有使用反射，它允许响应返回给发送者，这是由于大量被入侵的设备才成为可能。
- en: NTP
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NTP
- en: NTP is another amplification attack which takes advantage of a feature built
    into NTP servers, which returns up to the last 600 machines that have interacted
    with it. This attack takes advantage of open NTP servers which support the MONLIST
    command and have not been patched. The project [http://openntpproject.org/](http://openntpproject.org/)
    aims to identify unpatched servers to encourage the removal of this exploit. Unfortunately,
    research carried out in 2014 by NSFOCUS found that there were over 17,000 servers
    worldwide which were vulnerable to the exploit. Assuming all these servers could
    be used and using payload sizes from an NTP attack which hit CloudFlare in 2014,
    we have the capability of a DDoS attack of 1.4 Tbps. This traffic would be twice
    the biggest attack known today. NTP provides a platform for one of the most powerful
    application attacks and only exists due to poorly patched servers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NTP（网络时间协议）是另一种利用NTP服务器内置功能的放大攻击，该功能返回与它交互的最后600台机器。这种攻击利用了支持MONLIST命令且未打补丁的开放NTP服务器。该项目[http://openntpproject.org/](http://openntpproject.org/)旨在识别未打补丁的服务器，以鼓励移除这种漏洞。不幸的是，NSFOCUS在2014年进行的研究发现，全球有超过17,000台服务器容易受到这种漏洞的攻击。假设所有这些服务器都可以被利用，并使用2014年CloudFlare遭受的NTP攻击的负载大小，我们有能力进行1.4
    Tbps的DDoS攻击。这种流量将是今天已知最大攻击的两倍。NTP提供了一个强大的应用程序攻击平台，仅因服务器打补丁不当而存在。
- en: CHARGEN
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CHARGEN
- en: A **CHARGEN** (**Character Generation Protocol**) attack is another reflected
    amplification attack. The attack takes advantage of open CHARGEN servers which,
    running on port `19`, will return a random number of characters between 0 and
    512 in length every time it receives a datagram from the connecting host. CHARGEN
    is designed to be used as a source of byte-stream for debugging TCP network code
    and bandwidth measurement. CHARGEN attacks work by abusing CHARGEN servers which
    have been enabled on network-connected printers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**CHARGEN**（字符生成协议）攻击是另一种反射放大攻击。攻击利用了开放的CHARGEN服务器，这些服务器在端口`19`上运行，每次从连接的主机接收数据报时，都会返回0到512个字符长度的随机字符数。CHARGEN被设计为用于调试TCP网络代码和带宽测量的字节流源。CHARGEN攻击通过滥用已启用在网络连接打印机上的CHARGEN服务器来工作。'
- en: SYN flood
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SYN洪水
- en: A SYN flood is a classic DDoS attack that sends a lot of packets to a machine,
    attempting to keep connections from being closed. The connections eventually time
    out on the server side; however, the aim is to repeatedly hit the server, consuming
    all the available resources so genuine connections cannot get through.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SYN洪水是一种经典的DDoS攻击，向一台机器发送大量数据包，试图阻止连接被关闭。最终，服务器端的连接会超时；然而，目的是反复攻击服务器，消耗所有可用资源，以便真正的连接无法通过。
- en: SSDP
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSDP
- en: SSDP is the **Simple Service Discovery Protocol**, often used for the discovery
    of **Plug & Play** (**UPnP**) devices. This is exactly the protocol implemented
    by your home router, so next time you complain that your favorite gaming network
    is offline, why not first check that you are not inadvertently exposing SSDP to
    the internet?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SSDP（简单服务发现协议）通常用于发现**即插即用**（UPnP）设备。这正是您的家庭路由器实现的协议，所以下次您抱怨您最喜欢的游戏网络离线时，为什么不首先检查您是否无意中暴露了SSDP到互联网？
- en: ACK
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACK
- en: 'An ACK flood takes advantage of the three-way handshake that exists when a
    client connects to a server. The first step is the client sends an SYN packet
    to which an SYN-ACK packet is replied from the server. The client then finally
    replies with an ACK packet and then the connection is open for data. An ACK flood
    takes one of two forms:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ACK洪水利用了客户端连接到服务器时存在的三次握手。第一步是客户端发送一个SYN数据包，服务器回复一个SYN-ACK数据包。然后客户端最终回复一个ACK数据包，然后连接就为数据开放。ACK洪水有两种形式：
- en: The attacker sends a spoofed SYN packet to a server and then follows this with
    a spoofed SYN-ACK packet. The server then opens and holds open a connection. If
    enough connections are open, then the server will eventually run out of resources.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者向服务器发送一个伪造的SYN数据包，然后跟随一个伪造的SYN-ACK数据包。然后服务器打开并保持连接。如果打开的连接足够多，那么服务器最终会耗尽资源。
- en: The second method is only to send the ACK packet. Since the server does not
    have an open connection, this packet will be dropped; however, it still consumes
    resources having to process these packets.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法只是发送ACK数据包。由于服务器没有开放连接，这个数据包将被丢弃；然而，它仍然消耗资源来处理这些数据包。
- en: The attack is similar to a SYN attack; however, it can be more efficient due
    to the way it tricks DDoS filters to pass the packets to the server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种攻击类似于SYN攻击；然而，由于它通过欺骗DDoS过滤器将数据包传递到服务器的方式，它可能更加高效。
- en: 'Avoiding these attacks is not so simple: you need to detect and filter this
    activity at the edge of your network. You also require massive amounts of bandwidth
    to soak up the traffic inbound to your system, and this is not, in my opinion,
    something that can or should be tackled by an in-house solution.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些攻击并不简单：你需要检测和过滤你网络边缘的这种活动。你还需要大量的带宽来吸收系统进入的流量，在我看来，这不是一个可以或应该由内部解决方案解决的问题。
- en: The first line of defense to avoiding DDoS attacks is to make sure you are not
    enabling them. Configuring a firewall to ensure you are not exposing vulnerable
    services and patching your services will mean an attacker cannot use your network
    infrastructure to attack others. The second line is to leverage the power of Cloudflare,
    Akamai, Imperva, or the other experts who have the infrastructure and network
    scrubbing filters to ensure the traffic never gets to your server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 避免DDoS攻击的第一道防线是确保你没有启用它们。配置防火墙以确保你没有暴露易受攻击的服务，并修补你的服务意味着攻击者无法利用你的网络基础设施来攻击他人。第二道防线是利用Cloudflare、Akamai、Imperva或其他专家的力量，他们拥有基础设施和网络清洗过滤器，以确保流量永远不会到达你的服务器。
- en: Application security
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全
- en: We now, hopefully, understand some of the ways that encryption works and some
    of the ways that our infrastructure is vulnerable, but what about our application?
    It is entirely plausible that someone will want to break into your system. While
    a DDoS attack might cause you some inconvenience for a day or so, a hacker who
    gets past your firewall and into your application servers could cause serious
    financial or reputational damage. The first thing we need to do is to operate
    on a principle of no trust. David Strauss, in his talk, *Don't build "Death Star"
    security* (2016 O'Reilly software architecture conference) looked at the WikiLeaks
    website and concluded that it was not the first line of defense which fell, but
    the attackers were able to gain access to various backend systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望理解一些加密工作的方式以及我们基础设施的一些脆弱性，但我们的应用程序呢？完全有可能有人想闯入你的系统。虽然DDoS攻击可能会让你在一天或两天内感到不便，但一个绕过你的防火墙并进入你的应用程序服务器的黑客可能会造成严重的财务或声誉损害。我们首先需要做的是基于不信任的原则。David
    Strauss在他的演讲《不要构建“死亡之星”安全》（2016年O'Reilly软件架构会议）中，研究了维基解密网站，并得出结论，不是第一道防线失败了，而是攻击者能够访问各种后端系统。
- en: 'At the same conference, Sam Newman, who wrote the excellent *Microservices*
    book (which I encourage everyone to read if they have not yet), was also giving
    a talk on the *Application Security and Microservices*. Sam stated that *Microservices
    give us the capability for multiple perimeters*; while this can be a benefit,
    it can also cause problems. He suggested a model for microservices security which
    is used by ThoughtWorks; this advises that you follow the following four steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一场会议上，Sam Newman，他写了优秀的《微服务》一书（如果还没有读过，我鼓励大家阅读），也在谈论《应用安全和微服务》。Sam表示，*微服务为我们提供了多个边界的功能*；虽然这可能是一个好处，但也可能引起问题。他提出了一种ThoughtWorks使用的微服务安全模型；这建议你遵循以下四个步骤：
- en: Prevention
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预防
- en: Detection
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测
- en: Response
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应
- en: Recovery
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复
- en: Prevention
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预防
- en: Prevention is where you should spend the most of your effort, and the remainder
    of this chapter will concentrate on just that. This is implementing techniques
    for secure communication, authorization, and authentication.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 预防是你应该投入最多努力的地方，本章的剩余部分将专注于这一点。这是实施安全通信、授权和认证的技术。
- en: Detection
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测
- en: Detection relates to your application logs and ModSecurity logs if you are using
    it. We discussed in the previous chapter some methods for logging in your system,
    and I suggest you think about the type of logging you will need to detect malicious
    intent, not just for fault finding. This should form part of your non-functional
    requirements when you are planning a feature.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 检测与你的应用程序日志和ModSecurity日志（如果你使用它）有关。我们在上一章讨论了系统中的日志记录方法，我建议你考虑你需要检测恶意意图的日志类型，而不仅仅是用于故障排除。当你规划一个功能时，这应该成为你的非功能性要求的一部分。
- en: Response
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应
- en: 'The response is how you tackle the breach: if an incident occurs, you need
    to deal with it immediately. This not only involves closing the attackers out
    of the system but also identifying what has been taken and in the case of personal
    information or credit card loss, contacting your customers and being open about
    the problem. Think about what your company does about fire drills in case of fire.
    You practice so that, in the event there is a fire, everyone knows what to do
    and how to react quickly. Game days are standard practice for a few companies,
    where they will rehearse disaster recovery situations. If you intend to practice
    your response process, you need to ensure that the whole business is involved;
    while tech will be included in the diagnostic and rectification of the problem,
    there needs to be involvement on a business level, legal, PR, and communications
    for this to be truly useful.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应对措施是指你如何处理安全漏洞：如果发生事件，你需要立即处理。这不仅包括将攻击者排除在系统之外，还要确定被窃取的内容，在个人信息或信用卡丢失的情况下，联系你的客户并对问题保持透明。想想如果你的公司遇到火灾，你们会如何处理消防演习。你进行练习是为了确保在发生火灾的情况下，每个人都知道该做什么以及如何快速反应。对于一些公司来说，游戏日是标准实践，他们会演练灾难恢复情况。如果你打算练习你的应对流程，你需要确保整个业务都参与其中；虽然技术部门将包括在问题的诊断和修复中，但为了真正有用，还需要在业务层面、法律、公关和沟通方面的参与。
- en: Recovery
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复
- en: The recovery process should be the simplest step, assuming your infrastructure
    is well backed up and automated. Sam suggests not taking any chances and *burning
    it down*, rebuilding with new keys and passwords to avoid a further attack.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复过程应该是最简单的步骤，假设你的基础设施已经得到了良好的备份和自动化。山姆建议不要冒险，*彻底摧毁*它，使用新的密钥和密码重新构建，以避免进一步的攻击。
- en: Confused deputy
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆代理
- en: The confused deputy problem is where one system can abuse the trust another
    system has and will execute a command which it would not ordinarily be allowed
    to do. Consider a system which issues refunds inside of your system; you think
    that the system is safe as it is a private API sitting behind your firewall, but
    what if an attacker manages to compromise your firewall? If they can detect that
    sending a `POST` request with a payload to a server will refund money to a bank
    or PayPal account then they do not even need to attempt to attack further into
    your infrastructure to get their payday. This scenario is all too common; when
    building systems, we place too much trust on the external defenses and run a principle
    of trust for anything that sits behind the firewall. You also may be assuming
    that the attacker is actually outside your organization; what if they have access
    to the servers legitimately? In the USA, internal fraud accounts for XXX of financial
    losses; we need to build systems which make this situation difficult and we need
    to make sure that we have a full audit trail of access and operation. It does
    not need to be a difficult challenge to solve; we will see two very simple ways
    that we can counter this problem which when implemented will neither cause you
    additional development time or operational time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 混淆代理问题是指一个系统可以滥用另一个系统对其的信任，并执行它通常不允许执行的命令。考虑一个在你的系统中发放退款系统的例子；你认为这个系统是安全的，因为它是一个位于防火墙后的私有API，但如果你防火墙被攻击者攻破了呢？如果他们能够检测到向服务器发送带有有效负载的`POST`请求会导致银行或PayPal账户退款，那么他们甚至不需要进一步攻击你的基础设施来获得收益。这种情况非常普遍；在构建系统时，我们过度依赖外部防御，并对防火墙后的任何事物都实行信任原则。你也可能假设攻击者实际上在你的组织外部；如果他们合法地访问了服务器怎么办？在美国，内部欺诈占金融损失的XXX%；我们需要构建使这种情况变得困难的系统，并确保我们有完整的访问和操作审计记录。这并不需要是一个难以解决的问题；我们将看到两种非常简单的方法来解决这个问题，当实施时，既不会增加你的开发时间，也不会增加你的运营时间。
- en: How an attacker could bypass the firewall
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击者如何绕过防火墙
- en: You are probably a little confused as to why the internal security of services
    matters; after all, you have a great firewall, and all of the ports which should
    be are locked down.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: An attacker has multiple tools in their arsenal to bypass your security systems.
    We are not talking about people attempting to leverage existing exploits using
    tooling found on the internet. We are talking about sophisticated and intelligent
    hackers who, for whatever reason, are intent on causing harm to your company.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者拥有多种工具来绕过你的安全系统。我们不是在谈论试图利用互联网上找到的工具利用现有漏洞的人。我们谈论的是复杂且聪明的黑客，无论出于什么原因，都决心对你的公司造成伤害。
- en: Scenario
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景
- en: You are an e-commerce platform built utilizing the latest microservices architectural
    patterns. Your application code is running in Docker containers and you are hosting
    everything on AWS with Kubenetes. The front end of the system is a simple Node.js
    application which talks to a variety of private APIs to provide many of the transactional
    capabilities on the site. The application itself does not have a database and
    there are no secrets stored in the container.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一个利用最新的微服务架构模式构建的电子商务平台。你的应用程序代码正在 Docker 容器中运行，你使用 Kubernetes 在 AWS 上托管一切。系统的前端是一个简单的
    Node.js 应用程序，它与各种私有 API 通信，以提供网站上许多交易功能。应用程序本身没有数据库，容器中也没有存储任何机密。
- en: Attack
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击
- en: An attacker finds a remote code execution vulnerability in the templating engine
    used for the front end presentation. They discover that the system is running
    on Kubenettes and that the control API is available inside the compromised container.
    They use this API to be able to launch a rogue container on your network which,
    running in privileged mode, starts a reverse SSH tunnel to the attacker's remote
    server, which completely bypasses the firewall and gives them root access to the
    container. From here, they sniff the traffic on the network and determine that
    the payment gateway has `POST` endpoint v1/refunds; by sending a JSON payload
    to this endpoint, it is possible to refund huge amounts of money to an offshore
    bank account.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者发现了一个用于前端展示的模板引擎中的远程代码执行漏洞。他们发现系统运行在 Kubenettes 上，并且控制 API 在受损害的容器内部可用。他们使用这个
    API 来在你的网络上启动一个恶意容器，该容器以特权模式运行，启动一个反向 SSH 隧道到攻击者的远程服务器，完全绕过了防火墙，并使他们获得了容器的 root
    访问权限。从这里，他们嗅探网络流量，并确定支付网关有 `POST` 端点 v1/refunds；通过向此端点发送 JSON 负载数据，可以将大量资金退还到离岸银行账户。
- en: Even though the firewall was protecting inbound traffic and only ports `80`
    and `443` were allowed inbound, the attacker leveraged a vulnerability inside
    the application to be able to create a backdoor for themselves. The nonexistent
    security around launching applications inside the production environment and open
    non-encrypted communication between the services gave them all they needed to
    empty the company's bank account.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 即使防火墙正在保护入站流量，并且只允许端口 `80` 和 `443` 的入站，攻击者还是利用了应用程序内部的一个漏洞，为自己创建了一个后门。在生产环境中启动应用程序周围的不存在的安全性和服务之间开放的未加密通信，给了他们他们需要的一切，以清空公司的银行账户。
- en: This is a very real threat, but thankfully Go has many excellent tools to help
    us make it tough for an attacker.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常真实的威胁，但幸运的是，Go 语言有许多优秀的工具可以帮助我们使攻击者难以得逞。
- en: Input validation
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入验证
- en: In our scenario, the attacker used a remote code execution exploit to gain access
    to our environment. The first line of defense after the WAF is input validation.
    All data should be validated to set bounds; it does not take an enormous amount
    of time to implement and can help you protect against such an attack. There is
    an excellent library in Go which is part of the go-playground package ([https://github.com/go-playground/validator](https://github.com/go-playground/validator)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，攻击者使用远程代码执行漏洞来获取对我们环境的访问权限。WAF 之后的第一道防线是输入验证。所有数据都应该进行验证以设置边界；实现它并不需要花费大量时间，并且可以帮助你保护免受此类攻击。Go
    语言中有一个优秀的库，它是 go-playground 包的一部分（[https://github.com/go-playground/validator](https://github.com/go-playground/validator)）。
- en: 'Take a look at this simple code example to see just how easy it is to implement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个简单的代码示例，看看实现起来有多容易：
- en: '`validation/main.go`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`validation/main.go`'
- en: '[PRE0]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The nice thing about the validator package is that it works with field tags,
    which is an unobtrusive way of keeping your code clean. By adding the validate
    tag, we can specify one of many different validation functions for the field,
    including email, URL, IP addresses, minimum and maximum length, and event regular
    expressions. It is also possible to have multiple validators on the same field.
    For example, should I wish to validate that my input is an email and has a minimum
    length of three, I could add the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器包的好处是它与字段标签一起工作，这是一种保持代码整洁的无侵入方式。通过添加验证标签，我们可以为字段指定许多不同的验证函数，包括电子邮件、URL、IP地址、最小和最大长度以及正则表达式。同一字段上也可以有多个验证器。例如，如果我想验证我的输入是一个电子邮件并且长度至少为三个，我可以添加以下内容：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The validators process in the listed order, so the validation function to check
    whether the field contained an email would be validated before checking the length.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器按照列表中的顺序处理，所以检查字段是否包含电子邮件的验证函数会在检查长度之前进行验证。
- en: 'Using the package is also incredibly simple: if we take a look at the example
    from our tests, we can see that validation is actually only one method call:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个包也非常简单：如果我们看看测试中的示例，我们可以看到验证实际上只是一个方法调用：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In its simplest form, all we need to do to validate a request are two method
    calls. First, we create a new validator like in line 10 using the `New` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，我们只需要对请求进行验证的两个方法调用。首先，我们使用`New`函数创建一个新的验证器，就像第10行那样：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `New` function returns a new instance of `validate` with sane defaults.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`New`函数返回一个具有合理默认值的`validate`新实例。'
- en: 'Then we can call the `validate` method to check that our structure is valid:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用`validate`方法来检查我们的结构是否有效：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Struct` function validates a struct's exposed fields, and automatically
    validates nested structs, unless otherwise specified.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Struct`函数验证结构体的公开字段，并自动验证嵌套结构体，除非另有说明。'
- en: It returns `InvalidValidationError` for bad values passed in and nil or `ValidationErrors`
    as error otherwise. You will need to assert the error if it's not nil, for example,
    `err.(validator.ValidationErrors)` to access the array of errors.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传递的错误值，它返回`InvalidValidationError`，否则返回nil或`ValidationErrors`作为错误。如果您需要断言错误，它不为nil，例如，`err.(validator.ValidationErrors)`来访问错误数组。
- en: If the struct has validation errors, `Struct` will return an error; to get detailed
    messages for the error, we can cast the error to a `ValidationErrors` object,
    which is a collection of `FieldError`. To see all the available methods for the
    `FieldError` object, check out the godoc ([https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError](https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体有验证错误，`Struct`将返回一个错误；要获取错误详细消息，我们可以将错误转换为`ValidationErrors`对象，它是一个`FieldError`集合。要查看`FieldError`对象的全部可用方法，请查看godoc（[https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError](https://godoc.org/gopkg.in/go-playground/validator.v9#FieldError)）。
- en: Fuzzing
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试
- en: Of course, we should also beef up our testing techniques. One highly effective
    way of testing the bounds of input validation is to use a fuzzer inside our tests;
    this just broadens the scope of what we are testing to make sure we have all the
    edge cases covered. A potential attacker will most likely use this technique to
    test the boundary of your API so why not get the edge on them and make sure all
    of your input is correctly handled?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也应该加强我们的测试技术。一种非常有效的方法是在测试中使用模糊器来测试输入验证的边界；这仅仅扩大了我们测试的范围，以确保我们覆盖了所有边缘情况。潜在的攻击者很可能会使用这种技术来测试你API的边界，为什么不先发制人，确保所有输入都得到正确处理呢？
- en: One of the most popular implementations of a fuzzer in Go is the excellent package
    `github.com/dvyukov/go-fuzz/go-fuzz`. The `go-fuzz` is a coverage guided fuzzer,
    it uses an instrumented build of your application code exposing the code coverage
    which it uses to ensure that the maximum code paths are covered. The fuzzer generates
    random input the intent behind which is to either crash the application or to
    produce unexpected output. Fuzzing is an advanced topic however in the code samples
    for this chapter at `validation/fuzzer` you can find an example of how to fuzz
    the validation handler we have just covered.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中实现 fuzzer 的最流行实现之一是出色的包 `github.com/dvyukov/go-fuzz/go-fuzz`。`go-fuzz`
    是一个覆盖率引导的 fuzzer，它使用您的应用程序代码的仪器化构建，暴露出它使用的代码覆盖率，以确保最大化的代码路径被覆盖。fuzzer 生成随机输入，其目的是使应用程序崩溃或产生意外的输出。尽管
    fuzzing 是一个高级主题，但在本章的代码示例 `validation/fuzzer` 中，您可以找到一个如何对刚刚覆盖的验证处理程序进行 fuzz 的示例。
- en: TLS
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TLS
- en: The other exploit that our attacker took advantage of was that all of the traffic
    behind the firewall was not encrypted and by sniffing the traffic between services,
    they discovered a method to fake a call to the payments gateway to send a refund
    to a remote bank account. The other issue might be that you are passing sensitive
    information such as bank details or credit card numbers between your frontend
    service and your payment service. Even if you are not storing the credit card
    numbers on your system, if you are not careful, you could expose this traffic
    to an attacker by assuming that everything behind your firewall is safe. TLS or
    Transport Layer Security no longer adds any overhead due to the advances in processing
    power available to servers these days. In addition to this, services inside a
    firewall generally have a limited number of connections; so, to improve the time
    that is lost by the TLS handshake, you can use persistent reusable connections
    in your service to minimize this problem. Let's take a look at how we can implement
    TLS really quickly in Go.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的攻击者利用的另一个漏洞是，防火墙后面的所有流量都没有加密，通过嗅探服务之间的流量，他们发现了一种伪造对支付网关的调用以向远程银行账户发送退款的方法。另一个问题可能是，您正在将敏感信息，如银行详情或信用卡号码，在您的前端服务和支付服务之间传递。即使您没有在您的系统上存储信用卡号码，如果您不小心，您可能会通过假设防火墙后面的所有内容都是安全的，将此流量暴露给攻击者。由于现在服务器可用的处理能力不断提高，TLS
    或传输层安全性不再增加任何开销。除此之外，防火墙内部的服务通常只有有限数量的连接；因此，为了减少 TLS 握手的丢失时间，您可以在您的服务中使用持久可重用连接来最小化这个问题。让我们看看我们如何在
    Go 中快速实现 TLS。
- en: Generating private keys
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成私钥
- en: 'Before we do anything, we need to generate a key and a certificate. Go actually
    has a pretty awesome utility which can generate keys and certificates for us only
    in Go but before we look at that, let''s take a look at how we would traditionally
    generate a certificate using `openssl`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何操作之前，我们需要生成一个密钥和证书。Go 实际上有一个非常棒的实用工具，可以仅使用 Go 生成密钥和证书，但在我们查看这个之前，让我们看看我们如何传统地使用
    `openssl` 生成证书：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will generate us a key in PEM format, which uses the RSA algorithm with
    a 4096 bit size; the key will be encrypted using the aes256 format and will prompt
    you for a password. However, we also need an X.509 certificate which will be used
    with this key; to generate this, we can again use `openssl` and execute the following
    command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们生成一个 PEM 格式的密钥，它使用 4096 位大小的 RSA 算法；密钥将使用 aes256 格式加密，并提示您输入密码。然而，我们还需要一个
    X.509 证书，该证书将与这个密钥一起使用；为了生成这个证书，我们还可以再次使用 `openssl` 并执行以下命令：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command will use the key to generate the certificate again in PEM format
    with a validity of one year. In practice, we should not generate certificates
    which have such a long lifespan for our internal services. Since we control the
    deployment of the services, we should try to rotate keys as often as possible.
    The other thing to note about this certificate is that while it is valid and secure,
    it will not be trusted by clients automatically. This is because the root is auto-generated
    instead of coming from a trusted authority. This is fine for internal use; however,
    if we need the service to be public facing we would need to ask a trusted source
    to generate our certificate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用密钥再次以PEM格式生成证书，有效期为一年。在实践中，我们不应该为我们的内部服务生成寿命如此长的证书。因为我们控制服务的部署，我们应该尽可能频繁地轮换密钥。关于此证书的另一件事是，虽然它是有效且安全的，但客户端不会自动信任它。这是因为根是自动生成的，而不是来自受信任的权威机构。这对于内部使用来说是完全可以的；然而，如果我们需要服务面向公众，我们就需要请求一个受信任的来源为我们生成证书。
- en: Now we know how to do this with the `openssl` command-line tool, let's see how
    we could achieve the same thing using only the Go crypto libraries. The example
    application, which can be found at [https://golang.org/src/crypto/tls/generate_cert.go](https://golang.org/src/crypto/tls/generate_cert.go),
    gives us the details for this. Let's now take a look at the process step by step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用`openssl`命令行工具来完成这个操作，接下来让我们看看如何仅使用Go的crypto库实现相同的功能。示例应用程序可以在[https://golang.org/src/crypto/tls/generate_cert.go](https://golang.org/src/crypto/tls/generate_cert.go)找到，它为我们提供了这个操作的详细信息。现在让我们一步一步地查看这个过程。
- en: 'If we take a look at the example in `tls/generate_keys`, we can see that we
    are using the `GenerateKey` method from the `crypto/edcsa` package:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`tls/generate_keys`中的示例，我们可以看到我们正在使用来自`crypto/edcsa`包的`GenerateKey`方法：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The signature for the `GenerateKey` method on line **120** is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第**120**行的`GenerateKey`方法的签名如下：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first parameter is an I/O reader which will return random numbers; for
    this, we are using the `rand.Reader` method, which is a global shared instance
    of a cryptographically strong pseudo-random generator. On Linux, this will use
    `/dev/urandom` and on Windows, `CryptGenRandomAPI`. The second is the bit size
    to use: bigger is more secure but will result in slower encryption and decryption
    operations.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个I/O读取器，它将返回随机数；为此，我们使用`rand.Reader`方法，这是一个全局共享的加密强伪随机生成器的实例。在Linux上，这将使用`/dev/urandom`，在Windows上使用`CryptGenRandomAPI`。第二个参数是要使用的位数大小：位数越大越安全，但会导致加密和解密操作变慢。
- en: 'In order to serialize the key to a file, we need to run through a few different
    operations:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将密钥序列化到文件，我们需要执行几个不同的操作：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On line **192**, we are taking the `PrivateKey` reference that is returned
    from the `GenerateKey` function and we need to convert it into a slice of bytes
    so that we can serialize this to disk. The `crypto/x509` package has many useful
    functions to enable operations like this; the one that we need to use is `MarshalPKCS1PrivateKey`,
    which will marshal our RSA-based private key into ASN.1, DER format:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**192**行，我们正在获取从`GenerateKey`函数返回的`PrivateKey`引用，并需要将其转换为字节数组，以便将其序列化到磁盘。`crypto/x509`包有许多有用的函数，可以启用此类操作；我们需要使用的函数是`MarshalPKCS1PrivateKey`，它将我们的基于RSA的私钥序列化为ASN.1，DER格式：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have the key in byte format, we are ready to be able to write it to
    the file; however, just writing the bytes to a file is not enough; we need to
    be able to write it in PEM format, which looks like the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了字节的密钥格式，我们就可以准备将其写入文件；然而，仅仅将字节写入文件是不够的；我们需要能够以PEM格式写入，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The format for this file is as shown in the following code, and while we could
    manually create this file, the crypto library in Go has us covered:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的格式如下所示，虽然我们可以手动创建此文件，但Go的crypto库已经为我们提供了支持：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to keep our private keys safe, so if a password is specified,
    we are going to encrypt the key like we were doing with the command-line option.
    In line **196**, we are checking to see whether a password has been specified
    and, if so, we are calling the method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保我们的私钥安全，所以如果指定了密码，我们将像使用命令行选项一样加密密钥。在第**196**行，我们检查是否指定了密码，如果是的话，我们将调用该方法：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method returns a PEM block for the given DER encoded data which is encrypted
    with the given password. The algorithm we are using in our example is AES256;
    however, Go also supports the following ciphers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个用于给定DER编码数据的PEM块，该数据使用给定的密码加密。我们在示例中使用的是AES256算法；然而，Go也支持以下加密方式：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we do not want to encrypt the key with a password then we need to do something
    slightly different. In line **202**, we need to create the PEM block ourselves;
    the `pem` package provides this capability for us with the following struct:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想用密码加密密钥，我们需要做一些稍微不同的事情。在第202行，我们需要自己创建PEM块；`pem`包通过以下结构体为我们提供了这个功能：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Whether we are using an encrypted PEM block or unencrypted, we use this with
    the `Encode` function on the same package which will convert our data into the
    correct format:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用加密的PEM块还是未加密的，我们都使用同一包中的`Encode`函数，它将我们的数据转换为正确的格式：
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Generating X.509 certificates
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成X.509证书
- en: 'Now that we have a private key, we can go ahead and generate our certificate.
    We have already seen how easy this is to create with `openssl` and it is just
    as easy in Go:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了私钥，我们可以继续生成我们的证书。我们已经看到使用`openssl`创建它有多容易，在Go中也是如此：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are passing in a few parameters into this method. One of the first, which
    might be a little strange, is the template. Because we need to generate different
    kinds of certificate, such as those which can sign other certificates to create
    a chain of trust, we need to create a template to use which has some of the defaults
    populated. If we look at the `rootTemplate`, which is defined at line **22**,
    we can examine some of these options:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一些参数传递给这个方法。第一个参数可能有点奇怪，那就是模板。因为我们需要生成不同类型的证书，例如那些可以签署其他证书以创建信任链的证书，我们需要创建一个模板来使用，其中包含一些默认值。如果我们查看定义在第22行的`rootTemplate`，我们可以检查一些这些选项：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Subject, which is an instance of the `pkix.Name` struct, has the following
    fields:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 主题，是`pkix.Name`结构体的一个实例，具有以下字段：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These are the common elements of the X.509 distinguished name; most of these
    elements are straightforward and represent the details of the owner of the certificate.
    `SerialNumber` is one of the most important. The serial number must be unique
    for a certificate chain; however, it does not need to be sequential. If we look
    at our example in line **138**, we are generating a large random integer 128 bits
    in length but you can change this to be anything you like.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是X.509区分名称的常见元素；这些元素中的大多数都很直接，代表了证书所有者的详细信息。`SerialNumber`是最重要的之一。序列号对于证书链必须是唯一的；然而，它不需要是顺序的。如果我们查看第138行的示例，我们正在生成一个128位长的大随机整数，但你可以将它改为任何你喜欢的。
- en: 'The next interesting bit of our certificate generation is the `SubjectKey`;
    this is required for the chain of trust to work correctly. If a certificate is
    signed by another then the Authority Key Identifier will match the parent certificate''s
    Subject Key Identifier:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们证书生成的下一个有趣的部分是`SubjectKey`；这是为了使信任链正确工作所必需的。如果一个证书由另一个证书签署，那么权限密钥标识符将与父证书的主题密钥标识符匹配：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To generate the subject keys, we need to serialize the public version of the
    key into DER format, and then extract the bytes for just the key part:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成主题密钥，我们需要将密钥的公共版本序列化为DER格式，然后提取仅包含密钥部分的字节：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In line **174**, we are converting the public key into a byte array using the
    `MarshalPKIXPublicKey` function on the `x509` package:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在第174行，我们使用`x509`包中的`MarshalPKIXPublicKey`函数将公钥转换为字节数组：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This returns us a byte array which represents an ASN.1 data structure; to get
    access to the underlying data for the key, we need to unmarshal it into the struct
    format which is defined at line **169**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个表示ASN.1数据结构的字节数组；为了获取密钥的底层数据，我们需要将其解包到定义在第169行的结构体格式中：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To perform this conversion, we can use the `Unmarshal` function, which is on
    the package `encoding/asn1`. This method attempts to convert the ASN.1 data format:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此转换，我们可以使用`Unmarshal`函数，该函数位于`encoding/asn1`包中。此方法尝试将ASN.1数据格式转换为：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, in line **161**, we can create the certificate, using the `CreateCertificate`
    method on the `crypto/x509` package. This method accepts a parent certificate,
    which will be used to sign the child. For our root certificate, we want this to
    be self-signed so we set both the parent certificate and the private key to the
    root certificate''s private key and template. For the intermediate and leaf certificates,
    we would use the parent''s details for this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第**161**行，我们可以使用`crypto/x509`包上的`CreateCertificate`方法创建证书。此方法接受一个父证书，该证书将用于签名子证书。对于我们的根证书，我们希望它是自签名的，因此我们将父证书和私钥都设置为根证书的私钥和模板。对于中间和叶证书，我们会使用父证书的详细信息：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `CreateCertificate` function creates a new certificate based on a template.
    The following members of the template are used: `SerialNumber`, `Subject`, `NotBefore`,
    `NotAfter`, `KeyUsage`, `ExtKeyUsage`, `UnknownExtKeyUsage`, `BasicConstraintsValid`,
    `IsCA`, `MaxPathLen`, `SubjectKeyId`, `DNSNames`, `PermittedDNSDomainsCritical`,
    `PermittedDNSDomains`, and `SignatureAlgorithm`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateCertificate`函数基于模板创建一个新的证书。以下模板成员被使用：`SerialNumber`、`Subject`、`NotBefore`、`NotAfter`、`KeyUsage`、`ExtKeyUsage`、`UnknownExtKeyUsage`、`BasicConstraintsValid`、`IsCA`、`MaxPathLen`、`SubjectKeyId`、`DNSNames`、`PermittedDNSDomainsCritical`、`PermittedDNSDomains`和`SignatureAlgorithm`。'
- en: The certificate is signed by parent. If the parent is equal to template then
    the certificate is self-signed. The parameter `pub` is the public key of the signee
    and `priv` is the private key of the signer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 证书由父证书签名。如果父证书等于模板，则证书是自签名的。参数`pub`是签发者的公钥，`priv`是签发者的私钥。
- en: 'Now we have certificates, let''s see how we can secure a web server using TLS.
    Back in [Chapter 1](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml), *Introduction
    to Microservices*, you may remember being introduced to `http.ListenAndServe`
    from the standard HTTP package, which started an HTTP web server. Go, of course,
    has an equally amazing package for creating a web server which is secured with
    TLS. In fact, it is only two more parameters than the standard `ListenAndServe`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了证书，让我们看看如何使用TLS来保护一个网络服务器。在[第1章](ba3a8742-94e7-4e47-8a47-1324a277a7f9.xhtml)，“微服务简介”中，你可能还记得介绍了来自标准HTTP包的`http.ListenAndServe`，它启动了一个HTTP网络服务器。当然，Go有一个同样出色的包用于创建一个使用TLS加密的网络服务器。实际上，它只需要比标准的`ListenAndServe`多两个参数：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All we need to do is pass the paths to our certificate and the corresponding
    private key and the server when started will serve traffic using TLS. If we are
    using self-signed certificates, and in our example we are, then we need to write
    some additional code for our clients, otherwise when we try to make a connection
    to the server, we will get an error message like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是传递我们的证书和相应的私钥的路径以及服务器启动时将使用TLS来处理流量。如果我们使用自签名证书，在我们的例子中就是这样，那么我们需要为我们的客户端编写一些额外的代码，否则当我们尝试连接到服务器时，我们会收到如下错误信息：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To avoid this, we need to create a new cert pool and pass this to the client''s
    TLS settings. By default, Go will use the host''s root CA set, which will not
    include our self-signed certificates:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们需要创建一个新的证书池并将它传递给客户端的TLS设置。默认情况下，Go将使用主机的根CA集合，它将不包括我们的自签名证书：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In line **13**, we are creating a new certificate pool and then we read the
    certifcates, which are PEM encoded into a slice of bytes. In line **20**, we can
    then add these certificates to the new cert pool; for the certificate to be identified
    as valid, we need both the intermediate certificate and the root certificate.
    We can then create a new TLS config and add the certs; this is then added to the
    transport and ultimately, in line **38**, the client.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第**13**行，我们创建了一个新的证书池，然后读取证书，这些证书被PEM编码成字节数组。在第**20**行，我们可以将这些证书添加到新的证书池中；为了使证书被识别为有效，我们需要中间证书和根证书。然后我们可以创建一个新的TLS配置并添加证书；然后将其添加到传输中，最终在第**38**行添加到客户端。
- en: When we now run the client, it connects without any problem and we will see
    the `Hello World` response correctly returned from the server.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行客户端时，它没有任何问题地连接，我们将看到服务器正确返回的`Hello World`响应。
- en: Securing data at rest
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护静态数据
- en: Assuming our system had been attached to a database for storing things such
    as user accounts, the attacker would have been able to get access to the complete
    database of passwords. One of the things that we should think about when are storing
    data in a database is the encryption of our data. There is no doubt that encrypting
    data is more expensive than not encrypting it and that it can sometimes be difficult
    to figure out which fields or tables we should encrypt and which we should leave
    plain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的系统已经连接到数据库来存储诸如用户账户之类的信息，攻击者将能够访问完整的密码数据库。当我们把数据存储在数据库中时，我们应该考虑的一个问题是我们的数据加密。毫无疑问，加密数据比不加密数据更昂贵，有时很难确定我们应该加密哪些字段或表，哪些应该保持未加密状态。
- en: 'One of the many benefits microservices give us is that we separate function
    and data between our systems. This can make deciding what data to encrypt easier
    as rather than attempting to understand which data to encrypt within a datastore,
    you make a simpler decision: is there any data which needs to be encrypted inside
    this datastore? If so, then simply encrypt all of it. It may be beneficial to
    perform this encryption in the application layer rather than the datastore as
    applications tend to scale better than datastores and you must consider the edge
    cases that caching may introduce. If, to reduce the pressure on a datastore, you
    add an intermediary caching layer using Elasticache or another technology, you
    need to think about the security of your data. If the data is encrypted in the
    database then you need to ensure that the same level of encryption is applied
    to the cache.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务给我们带来的许多好处之一是我们可以在系统中分离功能和数据。这使得决定要加密哪些数据变得更加容易，因为与其试图理解数据存储中哪些数据需要加密，你只需做出一个更简单的决定：在这个数据存储中是否有任何需要加密的数据？如果有，那么只需简单地加密所有数据。在应用层而不是数据存储中执行此加密可能更有益，因为应用通常比数据存储扩展得更好，你必须考虑缓存可能引入的边缘情况。如果你为了减轻数据存储的压力，使用Elasticache或其他技术添加一个中间缓存层，你需要考虑你数据的安全性。如果数据在数据库中加密，那么你需要确保缓存也应用相同级别的加密。
- en: Physical machine access
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理机器访问
- en: 'When I say "physically", I mean access by humans; the code could be running
    on a VM. However, the problem is the same: all too often, I find that companies
    give developers access to databases and other sources of information running in
    a production environment. Even if they do not have access to the database password,
    they may have access to the config store or the ability to SSH into an application
    server and read the configuration from the application that way. There is a security
    principle called the **least privilege**; this recommends that accounts and services
    have the least amount of privilege to perform their business function. Even if
    you have ensured that the machine-to-machine communication is secured and there
    are appropriate safeguards with your firewall, there is always an opportunity
    for an attacker to access your systems by the back door. Consider the following
    scenario. A nontechnical employee in your company opens an email or downloads
    some software which installs some malware on their laptop. The attacker uses this
    to get access to their machine and, from there, manages to travel horizontally
    through the network and eventually ends up on your laptop. Now, since you are
    logged in and busy working and connected to the VPN into production, they manage
    to manage to install a key logger on your machine which gives them access to your
    passwords, they retrieve your SSH keys from your disk and because you have pretty
    much full access to production, now so do they. While this may seem like science
    fiction, it is very possible. You can, of course, secure your internal network
    but the best way to avoid such an attack is to restrict access to production environments
    and data severely. You should not ever need this level of access; with robust
    tests in my code, I often find that when a service misbehaves, it is not something
    that production access helps me with. I should be able to reproduce almost any
    error in a staging environment and the logging and metrics data that the service
    is emitting should be enough for me to diagnose any issues. I am not saying I
    have never debugged live on production but thankfully not in the last decade.
    Tooling and practice are such these days that we should never need to return to
    those acts.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说“物理上”时，我的意思是人类可以访问；代码可能运行在虚拟机上。然而，问题是一样的：我常常发现，公司给开发者访问在生产环境中运行的数据库和其他信息源。即使他们没有访问数据库密码，他们可能有权访问配置存储或能够通过SSH连接到应用程序服务器并从应用程序中读取配置。有一个名为**最小权限**的安全原则；这建议账户和服务应具有执行其业务功能所需的最小权限。即使你已经确保了机器到机器的通信是安全的，并且你的防火墙有适当的保护措施，攻击者总有通过后门访问你的系统的机会。考虑以下场景。你公司的一名非技术员工打开了一封电子邮件或下载了一些软件，这些软件在他们的笔记本电脑上安装了恶意软件。攻击者利用这一点来获取对他们的机器的访问权限，并从那里成功地在网络中横向移动，最终到达你的笔记本电脑。现在，由于你登录并忙于工作，并通过VPN连接到生产环境，他们设法在你的机器上安装了一个键盘记录器，这使他们能够访问你的密码，他们从你的磁盘中检索你的SSH密钥，因为你几乎可以完全访问生产环境，现在他们也一样。虽然这听起来像是科幻小说，但这是完全可能的。当然，你可以保护你的内部网络，但避免这种攻击的最佳方法是严格限制对生产环境和数据的访问。你永远不需要这种级别的访问权限；在我的代码中进行稳健的测试时，我常常发现，当一项服务表现不佳时，生产访问并不能帮助我解决问题。我应该能够在预演环境中重现几乎任何错误，并且该服务发出的日志和度量数据应该足以让我诊断任何问题。我并不是说我从未在生产环境中实时调试过，但幸运的是，在过去的十年中我没有这样做。工具和实践如此之先进，以至于我们永远不需要回到那些行为。
- en: OWASP
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OWASP
- en: Whenever you are looking for practical web security advice on security, OWASP
    should almost always be your first port of call.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在寻找关于安全的实际网络安全建议，OWASP几乎总是你的首选。
- en: 'For help with APIs, OWASP can also help: they have published the *REST Security
    Cheat Sheet* ([https://www.owasp.org/index.php/REST\_Security\_Cheat\_Sheet](https://www.owasp.org/index.php/REST/_Security/_Cheat/_Sheet)).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API的帮助，OWASP也可以提供帮助：他们已经发布了*REST安全速查表*([https://www.owasp.org/index.php/REST_Security_Cheat_Sheet](https://www.owasp.org/index.php/REST_Security_Cheat_Sheet))。
- en: Of course, as we have already discussed in this book, there are many different
    standards for building APIs and REST is but one of them; there are, however, some
    useful generic tips that we can leverage from this guide.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们在本书中已经讨论过的，构建API有许多不同的标准，REST只是其中之一；然而，我们可以从本指南中利用一些有用的通用技巧。
- en: Never storing session tokens in a URL
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远不要在URL中存储会话令牌
- en: JWT, which is probably the most common session token you will find used with
    APIs, encodes into a format which is URL-safe. Storing or passing the token in
    a URL, however, is not recommended, and it should always be stored in either a
    cookie or as a `POST` variable. The reason for this is that if you pass session
    tokens in a URL, these can leak into your server logs and, depending upon how
    you manage the duration of the token, if an attacker gets access to your log files,
    they may also be able to obtain full access to execute commands for your users.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: JWT（JSON Web Token），可能是您在API中最常见的会话令牌，编码成URL安全的格式。然而，将令牌存储或传递到URL中并不推荐，并且它始终应存储在cookie中或作为`POST`变量。这样做的原因是，如果您在URL中传递会话令牌，这些令牌可能会泄漏到您的服务器日志中，并且根据您如何管理令牌的持续时间，如果攻击者访问了您的日志文件，他们也可能能够获得完全访问权限来执行用户的命令。
- en: Cross-site scripting (XSS) and cross-site request forgery (CRSF)
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）和跨站请求伪造（CRSF）
- en: XSS and CRSF only apply when your API is going to be used from a web browser,
    such as in a single page app or a direct JavaScript call. However, to protect
    against an attacker injecting malicious JavaScript which can retrieve your session
    token, you should make sure that it is stored in a cookie which is marked as HTTP-only
    and that you only ever send them over HTTPS to stop them being captured in transit.
    In addition to this, we can add a layer of security which checks the HTTP referrer
    sent by the browser against the expected domain. While it is possible to fake
    the HTTP referrer using something like cURL, it is not possible or incredibly
    difficult to do this from JavaScript in the browser.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: XSS（跨站脚本）和CRSF（跨站请求伪造）仅在API将从网络浏览器中使用时适用，例如在单页应用或直接JavaScript调用中。然而，为了防止攻击者注入恶意JavaScript以检索您的会话令牌，您应确保它存储在标记为HTTP-only的cookie中，并且您始终通过HTTPS发送它们以防止它们在传输中被捕获。除此之外，我们还可以添加一层安全措施，该措施检查浏览器发送的HTTP引用与预期域名是否匹配。虽然使用类似cURL的工具可以伪造HTTP引用，但在浏览器中的JavaScript中这样做是不可能的或极其困难的。
- en: Insecure direct object references
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全直接对象引用
- en: When you are building an API, you need to ensure that you are checking the authenticated
    users can modify the object in the request. This would be performed server side;
    we do not want to give our attacker the capability to create a genuine login and
    then be able to manipulate the request to perform an action on behalf of another
    user.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建API时，您需要确保您正在检查认证用户是否可以修改请求中的对象。这将由服务器端执行；我们不希望给我们的攻击者创建一个真正的登录并能够操纵请求以代表其他用户执行操作的能力。
- en: The OWASP documents are regularly updated as new attacks and vulnerabilities
    are found; check the site often and keep yourself up to date.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP文档会定期更新，因为发现了新的攻击和漏洞；经常检查网站并保持自己最新。
- en: Authentication and authorization
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: 'Authentication is the process or action of checking something to be true, such
    as: does this username pair with this password? Authorization is the function
    of specifying access rights or policy regarding a user.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是检查某事是否为真的过程或行为，例如：此用户名是否与该密码匹配？授权是指定访问权限或关于用户的策略的功能。
- en: 'Authentication is a well-understood concept; however, there are a few concepts
    we need to understand to ensure that this action cannot be compromised, such as
    never storing passwords in plain text in a datastore and preventing the hijack
    of a login session by transferring an active token to a third party. Authorization,
    however, is equally important; we discussed earlier the confused deputy problem:
    even when a user is authenticated, we must still control the actions that they
    can perform on a system. Services which operate on a principle of trust between
    themselves and do not independently validate a user''s rights are wide open to
    abuse should an attacker compromise your firewall. In this section, we will look
    at just how easy it is to solve both of these problems, providing you with the
    patterns so that your services never need to be exposed.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是一个被广泛理解的概念；然而，我们需要理解一些概念以确保此操作不会被破坏，例如永远不要在数据存储中以纯文本形式存储密码，并防止通过将活动令牌转移到第三方来劫持登录会话。然而，授权同样重要；我们之前讨论了困惑代理问题：即使用户已通过认证，我们仍然必须控制他们在系统上可以执行的操作。在自身之间建立信任原则且不独立验证用户权利的服务，如果攻击者破坏了您的防火墙，就会很容易受到滥用。在本节中，我们将探讨解决这两个问题有多么容易，并提供模式，以确保您的服务永远不会暴露。
- en: Password hashing
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码散列
- en: 'A hash is one-way cryptography: you take a series of letters and numbers and
    by running them through the hashing algorithm, you get a sequence which while
    reproducible with the same original input cannot be reversed mathematically. So
    why would you use a hash instead of just encrypting the data? Firstly, hashes
    do not require any keys, and therefore they are not vulnerable to the loss of
    private keys, and they are perfect for storing data which does not need to be
    reversed. Consider passwords: your system never needs to know what the user''s
    password is, and it only needs to know that the value passed to you by the user
    matches the stored value. Hashing a password is the perfect approach to security:
    you hash the input from the user and compare this hash with the value you have
    in your data store. If the database is compromised then the attacker will not
    be able to decode the passwords. The attacker could, of course, attempt to brute
    force the password, but currently, there is not enough computing power on the
    planet to be able to decode a decent hash. Does that mean that hashes are invulnerable?
    No. In fact, many thought that MD5 hashes were irreversible; however, this algorithm
    had been compromised. It is possible to find collisions within a matter of seconds.
    There was a case back in 2011 where attackers used this vulnerability to create
    fake SSL certificates which allowed them to exploit users'' trust. Thankfully,
    we no longer use MD5 or SHA-1 for cryptographic purposes. You will still find
    it used for signatures such as in git commits where the possibilities of collision
    are offset by the speed of calculation but for security, we need to use a more
    modern algorithm.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种单向加密：你取一系列字母和数字，通过运行哈希算法，你得到一个序列，虽然可以通过相同的原始输入重新生成，但无法从数学上逆向。那么，为什么你会使用哈希而不是直接加密数据呢？首先，哈希不需要任何密钥，因此它们不会因为私钥的丢失而受到威胁，它们非常适合存储不需要逆向的数据。考虑密码：你的系统永远不需要知道用户的密码是什么，它只需要知道用户传递给你的值与存储的值匹配。哈希密码是完美的安全方法：你哈希用户的输入，并将这个哈希值与你的数据存储中的值进行比较。如果数据库被破坏，攻击者将无法解码密码。当然，攻击者可以尝试暴力破解密码，但截至目前，地球上没有足够的计算能力来解码一个合理的哈希值。这意味着哈希是不可攻破的吗？不。事实上，许多人认为MD5哈希是不可逆的；然而，这个算法已经被破坏。可以在几秒钟内找到碰撞。2011年有一个案例，攻击者利用这个漏洞创建了假的SSL证书，这允许他们利用用户的信任。幸运的是，我们不再使用MD5或SHA-1进行加密目的。你仍然可以在像git提交这样的签名中找到它，那里的碰撞可能性被计算速度所抵消，但对于安全性，我们需要使用更现代的算法。
- en: Adding a little seasoning
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一点调味料
- en: While a hash on its own provides a decent level of security, we can add a salt
    and a pepper. The salt is stored in the database along with the encrypted data.
    The intention behind this is to make brute forcing data more computationally expensive.
    It stops the attacker from using Rainbow tables to attack your data. Rainbow tables
    are precomputed tables of hashes, so instead of having to compute the hash with
    every attempt, you can simply look up the encrypted string in the table and return
    the original value. To counter this, we added a salt which is randomly generated
    for each value and appended to it before hashing. Even though we store this in
    the database along with the hashed value as we need to use it later to check the
    value, it stops the use of Rainbow tables as each table would have to be computed
    for every salt, and this is computationally very expensive. To further enhance
    security, we often also add a pepper, which is a precomputed value which is stored
    separately from the salt and hashed value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单独的哈希值可以提供相当的安全级别，但我们还可以添加盐和胡椒。盐与加密数据一起存储在数据库中。这样做背后的意图是使暴力破解数据变得更加计算密集。这阻止了攻击者使用彩虹表来攻击你的数据。彩虹表是预先计算好的哈希值表，因此，你不需要在每次尝试时都计算哈希值，只需在表中查找加密字符串并返回原始值即可。为了应对这种情况，我们添加了一个盐，这个盐是随机生成的，并在哈希之前附加到数据上。尽管我们需要将它与哈希值一起存储在数据库中以便稍后检查值，但它阻止了彩虹表的使用，因为每个表都必须为每个盐值重新计算，这非常计算密集。为了进一步增强安全性，我们通常还会添加一个胡椒，这是一个存储在盐和哈希值之外的预计算值。
- en: Common practice is to pre-generate a list of peppers and store them in a configuration
    store. When you are first hashing a password or other value, you would select
    one of the peppers at random and append it to the value in the same way as you
    do for the salt. Then when checking a supplied value matches the hash, you would
    loop through the list of peppers and generate a hash to compare with each one.
    This adds a little computation time to checking a password in your service; however,
    not nearly as much effort as it will add to the attacker who is attempting to
    brute force your values. Let's take a look at how we can hash a value in using
    a salt and a pepper.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 常规做法是预先生成一个胡椒列表并将其存储在配置存储中。当你第一次哈希密码或其他值时，你会随机选择一个胡椒并将其附加到值上，就像你为盐做的那样。然后，当你检查提供的值是否与哈希匹配时，你会遍历胡椒列表并为每个胡椒生成一个哈希值进行比较。这会在你的服务中检查密码时增加一点计算时间；然而，这远不如它会给试图暴力破解你的值的攻击者带来的工作量。让我们看看我们如何使用盐和胡椒来哈希一个值。
- en: 'If we take a look at the source code in `hashing/hash.go`, we can create a
    hash from an input string using the following `GenerateHash` method. The `GenerateHash`
    method has the following signature and given an input string, it returns a random
    salt and the hashed string using the sha512 algorithm:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`hashing/hash.go`中的源代码，我们可以使用以下`GenerateHash`方法从一个输入字符串创建一个哈希值。`GenerateHash`方法具有以下签名，并且给定一个输入字符串，它使用sha512算法返回一个随机盐和哈希字符串：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To use this, we can simply call the method with our string to hash and we would
    get some output as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，我们只需用我们的字符串来调用方法，然后我们会得到以下输出：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s look more in depth at what this function is doing:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看这个函数在做什么：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first thing we are doing, on line **25**, is retrieving a random pepper
    from the slice of peppers which is passed to the struct when we initialize it
    with `New(peppers)`. The pepper does not need to be stored in the database; this
    is purely to slow down a potential attacker by requiring them to increase their
    brute force attempts by a factor of five in our example. We can increase the number
    of peppers and as you can see from the benchmark below, even at 1,000 peppers,
    we are still able to compare a hash in 1 ms but for the additional security this
    will give you is probably not worth it. It takes 4,634 ns to generate one hash
    and due to the length of the string, we would need to generate a maximum of 6.2e19
    or 62 quintillion permutations. This is assuming 63 allowable characters and a
    password 11 characters in length. That is a pretty big number, and to generate
    that many hashes would take roughly 9 million years to brute force for a single
    CPU.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情，在第**25**行，是从传递给结构体的胡椒切片中随机获取一个胡椒。胡椒不需要存储在数据库中；这纯粹是为了通过要求攻击者将他们的暴力破解尝试次数增加五倍来减缓潜在的攻击者。在我们的例子中，我们可以增加胡椒的数量，正如你从下面的基准测试中可以看到，即使有1,000个胡椒，我们仍然能够在1毫秒内比较一个哈希值。但是，为了获得这种额外的安全性，可能并不值得。生成一个哈希值需要4,634纳秒，由于字符串的长度，我们需要生成最大为6.2e19或62千万亿种排列组合。这是假设有63个允许的字符和一个11个字符长度的密码。这是一个相当大的数字，要生成这么多的哈希值，对于一个单核CPU来说，大概需要9百万年的时间来暴力破解。
- en: Dictionary attacks
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典攻击
- en: However, not all passwords are complex and many are susceptible to an attack
    known as a dictionary attack. Instead of attempting all 62 quintillion permutations,
    the dictionary attack concentrates on those which are most likely to succeed.
    The dictionaries themselves are often derived from password databases which have
    previously been exploited and since humans are somewhat predictable, we often
    use the same passwords. Because our password `HelloWorld1` is already in the dictionary
    which contains 14 million other passwords, when I attempted to break the salted
    hash using `John the Ripper`, it only took 2.4 seconds to retrieve the password.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有密码都复杂，许多密码容易受到一种称为字典攻击的攻击。字典攻击不会尝试62千万亿种排列组合，而是集中在最有可能成功的那些上。这些字典本身通常是从之前被利用的密码数据库中派生出来的，由于人类的行为有一定的可预测性，我们经常使用相同的密码。因为我们的密码`HelloWorld1`已经在包含1400万个其他密码的字典中，当我尝试使用`John
    the Ripper`破解加盐的哈希时，只用了2.4秒就检索到了密码。
- en: Adding a pepper
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加胡椒
- en: 'There is a fine line as to what we can do to stop our users using simple passwords.
    We should always have a policy of what constitutes a good password--minimum length,
    the mixture of case, an addition of symbols, and so on--but usability can be compromised
    the more complex the password gets. Adding a pepper, however, can help to slow
    the attacker down: the pepper or peppers are known to the system but not stored
    with the password and salt. They can be hard coded into the application code,
    stored as launch configuration or stored in a secure vault which is accessed at
    runtime. In the same way, we appended the salt to the user''s password, we do
    the same thing with the pepper. Should the database tables become compromised
    due to a SQL injection attack then unless the attacker can retrieve the peppers,
    the database is useless. Of course, it is possible for the attacker to get hold
    of your peppers; however, almost everything in security is about making it difficult
    and slowing someone down.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在阻止用户使用简单密码方面，我们能够做的事情之间有一条很细的界限。我们应该始终有一个政策来定义什么是一个好的密码--最小长度、大小写混合、添加符号等等--但是随着密码的复杂度增加，可用性可能会受到影响。然而，添加pepper可以帮助减缓攻击者的速度：pepper或peppers为系统所知，但不会与密码和盐一起存储。它们可以硬编码到应用程序代码中，作为启动配置存储，或者在运行时从安全保险库中存储。同样，我们在用户的密码中附加了盐，我们也对pepper做同样的事情。如果数据库表因SQL注入攻击而受损，除非攻击者能够检索到peppers，否则数据库将毫无用处。当然，攻击者可能能够获取到你的peppers；然而，在安全领域，几乎一切都是关于使事情变得困难并减缓某人的速度。
- en: bcrypt
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bcrypt
- en: 'bcrypt is another popular method of hashing passwords, it uses a variable number
    of rounds to generate the hash which both slows down the ability to brute force
    the attack and the time it takes to generate the hash. Go has an implementation
    of bcrypt which is provided by the experimental packages at [https://godoc.org/golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt).
    To hash a password with bcrypt we use the `GenerateFromPassword` method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: bcrypt是另一种流行的密码散列方法，它使用可变次数的轮次来生成散列，这既减缓了暴力破解攻击的能力，也减缓了生成散列的时间。Go有一个bcrypt的实现，由实验性包提供，位于[https://godoc.org/golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt)。要使用bcrypt散列密码，我们使用`GenerateFromPassword`方法：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `GenerateFromPassword` method returns the bcrypt hash of the password at
    the given cost. The cost is a variable which allows you to increase the security
    of the returned hash at the expense of more processing time to generate it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateFromPassword`方法返回给定成本的密码的bcrypt散列。成本是一个变量，允许你在生成散列时增加处理时间以换取返回散列的安全性。'
- en: 'To check the equality of a bcrypt hash we can not call `GenerateFromPassword`
    again with the given password and compare the output to the hash we have stored
    as `GenerateFromPassword` will create a different hash every time it is run. To
    compare equality we need to use the `CompareHashAndPassword` method:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查bcrypt散列的相等性，我们不能再次使用给定的密码调用`GenerateFromPassword`并比较输出与存储的散列，因为`GenerateFromPassword`每次运行都会创建不同的散列。为了比较相等性，我们需要使用`CompareHashAndPassword`方法：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `CompareHashAndPassword` method compares a bcrypt hashed password with its
    possible plain text equivalent. bcrypt is a secure method of protecting passwords
    but it is slow, let's take a look in a little more depth at the cost of generating
    hashes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompareHashAndPassword`方法比较bcrypt散列密码与其可能的纯文本等效密码。bcrypt是保护密码的一种安全方法，但它很慢，让我们更深入地看看生成散列的成本。'
- en: Benchmarks
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: 'The following table illustrates the approximate time it takes to generate and
    compare a hashed string using the methods we have discussed so far. Even with
    1,000 peppers, we would be looking at a processing time of approximately 1.5 ms
    to run the comparison. This might not seem a huge amount of time; however, we
    need to take these benchmarks with a pinch of salt as they are running a single
    operation where your server will be dealing with multiple requests concurrently.
    What we do know is that comparing a hash with a list of 1,000 peppers takes 10x
    longer than comparing a list of 100 and this is 10x longer than a list of 10:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下表说明了使用我们迄今为止讨论的方法生成和比较散列字符串的大致时间。即使有1,000个peppers，我们也会看到大约1.5毫秒的处理时间来运行比较。这可能看起来不是很多时间；然而，我们需要带着一点盐来对待这些基准，因为它们正在运行单个操作，而你的服务器将同时处理多个请求。我们知道的是，与100个列表相比，比较1,000个peppers的列表需要10倍的时间，而这比10个列表的时间还要长10倍：
- en: 'Even with 1,000 peppers, we would be looking at a processing time of approximately
    1.5 ms to run the comparison. This might not seem a huge amount of time; however,
    we need to take these benchmarks with a pinch of salt as they are running a single
    operation where your server will be dealing with multiple requests concurrently.
    What we do know is that comparing a hash with a list of 1,000 peppers takes 10x
    longer than comparing a list of 100 and this is 10x longer than a list of 10:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有1,000个辣椒，我们运行比较的时间大约为1.5毫秒。这可能看起来不是很多时间；然而，我们需要带着一点盐来对待这些基准，因为它们正在运行一个单一操作，而你的服务器将同时处理多个请求。我们知道的是，与1,000个辣椒的哈希比较需要比100个的哈希比较长10倍，而这比10个的哈希比较长10倍：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Given this information, we can balance our service for speed against security;
    however, we should always lean on the more secure. To learn how Facebook manages
    hashing I recommend you take a look at Alec Muffett''s talk Facebook: *Password
    hashing and Authentication* ([https://www.youtube.com/watch?v=NQDo2e3gj1A](https://www.youtube.com/watch?v=NQDo2e3gj1A)).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，我们可以平衡我们的服务在速度和安全性之间的平衡；然而，我们应该始终倾向于更安全的选择。要了解Facebook如何管理哈希，我建议您观看Alec
    Muffett的演讲 Facebook：*密码哈希和身份验证*（[https://www.youtube.com/watch?v=NQDo2e3gj1A](https://www.youtube.com/watch?v=NQDo2e3gj1A)）。
- en: JWTs
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWTs
- en: A **JSON Web Token** (**JWT**) is a standard for safely passing claims or data
    attributed to a user within an environment. It is an incredibly popular standard
    and is available for just about every major language and framework, certainly
    for Go. There are two main strengths of JWT. One is a standard format for the
    claims, which makes the availability of reliable frameworks possible. The other
    is the use of asymmetric encryption, which means that because a token is signed,
    the receiver only needs the public key of the signer to validate that the token
    has indeed come from a trusted source and this allows us to lock down access to
    the private keys to an authorization server.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Token**（JWT）是一种在环境中安全传递与用户相关的声明或数据的标准。这是一个极其流行的标准，几乎适用于所有主要的语言和框架，当然也包括Go。JWT有两个主要优势。一是声明的一个标准格式，这使得可靠框架的可用性成为可能。另一个是使用非对称加密，这意味着因为令牌是经过签名的，所以接收者只需要签名人公钥来验证令牌确实来自可信源，这允许我们将对私钥的访问锁定到授权服务器。'
- en: Format of a JWT
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT的格式
- en: A JWT is broken into three different parts, which are encoded as Base64-URL.
    Like standard Base64, Base64-URL substitutes characters such as `+` and `/` for
    `-` and `\_` and removes all the padding. This allows the token to be safely transferred
    in a URL.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: JWT被分成三个不同的部分，这些部分被编码为Base64-URL。像标准Base64一样，Base64-URL用`-`和`_`替换了`+`和`/`，并移除了所有填充。这使得令牌可以在URL中安全地传输。
- en: 'The result is a token which looks like the following example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个看起来像以下示例的令牌：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The three distinct parts of the token are the header, the payload, and the
    signature. The header declares the type of the encoded object and the algorithm
    for the cryptographic signature:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的三个不同部分是头部、载荷和签名。头部声明了编码对象的类型和加密签名的算法：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second object payload which contains the details of the claims related
    to the token:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个对象载荷，包含与令牌相关的声明的详细信息：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And finally, the third part is the signature, which is an optional element
    shown as follows in the decoded state:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三部分是签名，这是一个可选元素，在解码状态下如下所示：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Every element in the JWT is base64URL encoded ([https://en.wikipedia.org/wiki/Base64#URL_applications](https://en.wikipedia.org/wiki/Base64#URL_applications));
    the signature represented in its binary form is the sha256 of the message in the
    following format:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: JWT中的每个元素都是base64URL编码的（[https://en.wikipedia.org/wiki/Base64#URL_applications](https://en.wikipedia.org/wiki/Base64#URL_applications)）；表示为其二进制形式的签名是以下格式的消息的sha256：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The format of the signature can either be symmetrical (HS256) using a shared
    secret or asymmetrical (RS256), which uses public and private keys. For JWTs,
    the best option is the asymmetrical option as for a service which needs to authenticate
    the JWT, it only requires the public part of the key.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 签名的格式可以是对称的（HS256），使用共享密钥，或者非对称的（RS256），使用公钥和私钥。对于JWT，最佳选项是非对称选项，因为对于需要验证JWT的服务，它只需要密钥的公钥部分。
- en: 'We can validate our JWT only using the command line. First, we need to convert
    our base64URL-encoded signature into standard base64 encoding by replacing `_`
    with `/` and `-` with `+`. We can then pipe that into the base64 command-line
    application and pass in the `-D` flag to decode the input; we then output this
    into a file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令行仅验证我们的 JWT。首先，我们需要将我们的 base64URL 编码的签名转换为标准 base64 编码，通过将 `_` 替换为 `/`
    和 `-` 替换为 `+`。然后，我们可以将此通过管道传递到 base64 命令行应用程序，并传递 `-D` 标志以解码输入；然后将其输出到一个文件中：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to validate that the signature has been signed by the correct
    key by validating it against a public key:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是验证签名是否由正确的密钥签名，通过将其与公钥进行验证：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Generating JWTs with Go is very straightforward thanks to some amazing community
    packages. The package we will be using in the example code is called **jose**
    and has been created by Eric Largergren ([https://github.com/SermoDigital/jose](https://github.com/SermoDigital/jose)).
    According to the listing on `jwt.io`, this package implements all the capabilities
    defined in the standard and was an obvious choice at the time of writing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 生成 JWT 非常简单，多亏了一些出色的社区包。在示例代码中我们将使用的包名为 **jose**，由 Eric Largergren 创建（[https://github.com/SermoDigital/jose](https://github.com/SermoDigital/jose)）。根据
    `jwt.io` 上的列表，此包实现了标准中定义的所有功能，并且在写作时是一个显而易见的选择。
- en: 'If we take a look at the file `chapter8/jwt/jwt.go` and look at the `GenerateJWT`
    method, we can see just how simple it is to create a JWT using jose:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看文件 `chapter8/jwt/jwt.go` 并查看 `GenerateJWT` 方法，我们可以看到使用 jose 创建 JWT 是多么简单：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first thing that we need to do is to generate a list of claims and to set
    an expiration; we are setting the expiration to two weeks. We can then set a list
    of claims using the `Set` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要生成一个声明列表并设置一个过期时间；我们将过期时间设置为两周。然后我们可以使用 `Set` 函数设置一个声明列表：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, in line **39**, we can create a new JWT passing the claims and the
    signing method to the `NewJWT` function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在行 **39** 中，我们可以通过将声明和签名方法传递给 `NewJWT` 函数来创建一个新的 JWT：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can then call the `Serialize` method, which has as a parameter the private
    key - in our case, an instance of `rsa.PrivateKey` - and returns us a slice of
    bytes in the encoded format:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用 `Serialize` 方法，该方法以私钥作为参数——在我们的例子中是一个 `rsa.PrivateKey` 的实例——并返回一个编码格式的字节数组：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Validating a JWT with jose is as easy as it was to create the JWT:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jose 验证 JWT 与创建 JWT 一样简单：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The first thing we need to do is to parse our JWT from a byte array into the
    `jwt` struct using the `ParseJWT` function:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是使用 `ParseJWT` 函数将我们的 JWT 从字节数组解析到 `jwt` 结构体中：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then we can call the `Validate` method, passing the public key corresponding
    to the private one which signed the message and the signing method. Optionally,
    we can provide a customer validator function; the default validation will only
    check the signature and that the token has not expired:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调用 `Validate` 方法，传递与私钥对应的公钥以及签名方法。可选地，我们可以提供一个自定义验证函数；默认验证将仅检查签名以及令牌是否未过期：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When the validation fails, an error will be returned; if the error is nil then
    the token is valid and the claims within can be trusted.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证失败时，将返回一个错误；如果错误为 nil，则令牌有效，其中的声明可以信赖。
- en: Secure messages
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全消息
- en: When we need to send an encrypted message, one of the best ways to do this is
    with asymmetric encryption, where we encrypt the message with publically known
    information which can be easily distributed and then decrypt it with the private
    key which is securely held by a single party.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要发送加密消息时，最好的方法之一是使用非对称加密，其中我们使用公开信息加密消息，这些信息可以轻松分发，然后使用由单个方安全持有的私钥解密它。
- en: 'The crypto packages in Go have all the features we need to secure our data.
    If we take a look at the example `chapter8/asymmetric/asymmetric.go`, the `EncryptDataWithPublicKey`
    method is a simple implementation of the `rsa` package''s public key encryption:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的加密包包含了我们保护数据所需的所有功能。如果我们查看示例文件 `chapter8/asymmetric/asymmetric.go`，`EncryptDataWithPublicKey`
    方法是 `rsa` 包公钥加密的一个简单实现：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The first parameter is a cryptographic hash which is used as the random oracle
    to process the message before encryption. This function must be the same for encryption
    and decryption and the documentation recommends using a sha256\. The next parameter
    is a random number generator; this is used as a source of entropy to ensure that
    if you encrypt the same message twice, you do not return the same cyphertext.
    `pub` is the `rsa.PublicKey` that we would like to use to encrypt the message;
    the message itself is passed as a slice of bytes. The final parameter is optional
    and is not encrypted in the resultant cyphertext; it can be used to help the receiver
    understand information such as which key has been used to encrypt the message,
    but extreme care must be taken not to add data to the label which could compromise
    the security of the encrypted message:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个加密哈希，用作加密前处理消息的随机预言机。这个函数在加密和解密时必须相同，文档建议使用 sha256。下一个参数是随机数生成器；它用作熵的来源，以确保如果你两次加密相同的消息，不会返回相同的密文。`pub`
    是我们想要用来加密消息的 `rsa.PublicKey`；消息本身作为字节数组切片传递。最后一个参数是可选的，并且在结果密文中不加密；它可以用来帮助接收者理解信息，例如使用了哪个密钥来加密消息，但必须极端小心，不要向标签中添加可能危及加密消息安全性的数据：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first thing we are doing in this method is to check whether the message
    is shorter than the maximum permitted length for this encryption method. The maximum
    length must be no longer than public modulus minus twice the hash length minus
    a further two. Due to the mathematics involved in public key cryptography, we
    can only allow for the encryption of small messages. We will look at how we can
    work around this issue a little later on. In line **53**, we are calling another
    internal function, which simply calls the `EncryptOAEP` function in the `rsa`
    package. We then encode the data to base64 and return the result.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们首先要检查消息是否短于这种加密方法允许的最大长度。最大长度必须不大于公模数减去两倍的哈希长度再减去两个。由于公钥密码学中涉及的数学，我们只能允许加密短消息。我们稍后会看看如何解决这个问题。在第
    **53** 行，我们调用另一个内部函数，该函数简单地调用 `rsa` 包中的 `EncryptOAEP` 函数。然后我们将数据编码为 base64 并返回结果。
- en: 'Decrypting the data is as straightforward:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 解密数据很简单：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Because our implementation of the encryption method returned a base64-encoded
    string, the first thing we do before decrypting the message is to decode it back
    into its binary form. We then call the internal method `DecryptDataWithPrivateKey`;
    this is a wrapper for the method `rsa.DecryptOAEP`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的加密方法实现返回了一个 base64 编码的字符串，我们在解密消息之前首先要做的是将其解码回二进制形式。然后我们调用内部方法 `DecryptDataWithPrivateKey`；这是一个
    `rsa.DecryptOAEP` 方法的包装器：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This method has the same parameters to the encrypt method except this time we
    are using the private key. If we recall how asymmetric encryption works, we can
    encrypt with a public key but you cannot decrypt a message with the public key.
    The private key must be used for this purpose.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与加密方法的参数相同，只是这次我们使用的是私钥。如果我们回顾非对称加密的工作原理，我们可以用公钥加密，但不能用公钥解密消息。必须使用私钥来完成这个目的。
- en: Shared secrets
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享密钥
- en: 'Symmetrical encryption also has its uses: for one, it is faster and the other
    is that it can handle a message of any size. Implementing symmetrical encryption
    in Go is, as you would expect, quite straightforward: we have the excellent `crypto/aes`
    package which manages all the heavy lifting for us. Let''s look at how we could
    encrypt a message with AES. Look at the example file `symmetric/symmetric.go`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密也有其用途：一方面，它更快，另一方面，它可以处理任何大小的消息。在 Go 中实现对称加密，正如你所期望的，相当简单：我们有优秀的 `crypto/aes`
    包，它为我们处理所有繁重的工作。让我们看看如何使用 AES 加密消息。查看示例文件 `symmetric/symmetric.go`：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first thing we need to do on line **13** is to validate the length of the
    key. The length of the key determines the strength of the encryption; a 16-byte
    key will encrypt with AES-128, 24 bytes AES-192, and 32 bytes AES-256\. We then
    create a new **GCM** (**Galois/Counter Mode**) cipher and pass it the reference
    to our AES cipher:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 **13** 行，我们首先需要做的是验证密钥的长度。密钥的长度决定了加密的强度；16 字节密钥将使用 AES-128 加密，24 字节 AES-192，32
    字节 AES-256。然后我们创建一个新的 **GCM**（**Galois/Counter Mode**）加密器，并将我们的 AES 加密器的引用传递给它：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We then need to create a nonce which is used to protect against replay attacks
    and finally we can call the `Seal` method which encrypts our data:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建一个用于防止重放攻击的nonce，最后我们可以调用`Seal`方法来加密我们的数据：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Unlike RSA public key encryption, the size of the message that AES can handle
    is pretty much unlimited; the problem, however, is that the secret must be shared
    by both the writer and the reader, which introduces the problem of distributing
    keys to both parties.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 与RSA公钥加密不同，AES可以处理的消息大小几乎是无限的；然而，问题在于密钥必须由作者和读者共享，这引入了向双方分配密钥的问题。
- en: 'Decryption works in the reverse of the encryption method, an example of which
    can be seen in the next code block:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 解密的工作方式与加密方法相反，一个例子可以在下一个代码块中看到：
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The main thing we need to note in this code block is in the `gcm.Open` method:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码块中，我们需要注意的主要是`gcm.Open`方法：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The nonce that we are going to use to decrypt the message needs to be the same
    one that was used to encrypt the message. When we called `Seal`, the slice of
    bytes returned from the method is the encrypted message and the nonce, so to retrieve
    it, we only need to calculate the size of the nonce and then split the bytes slice
    up into two parts.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要用来解密消息的nonce需要与加密消息时使用的相同。当我们调用`Seal`时，从方法返回的字节切片是加密消息和nonce，因此要检索它，我们只需要计算nonce的大小，然后将字节切片分成两部分。
- en: Asymmetric encryption with large messages
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大消息的非对称加密
- en: 'We have already discussed the problem with asymmetric encryption is that it
    can only be used for relatively small messages; however, the benefits of not having
    to deal with key distribution is hugely advantageous over symmetrical. There is
    a common solution to this problem; that solution is to create a random key and
    symmetrically encrypt a message then asymmetrically encrypt the key and distribute
    both parts to the receiver. Only the holder of the private key will be able to
    decrypt the symmetrical key and only once the symmetrical key has been decrypted
    can the receiver decrypt the main message:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了非对称加密的问题，即它只能用于相对较小的消息；然而，不需要处理密钥分配的好处相对于对称加密来说是非常有优势的。对此问题有一个常见的解决方案；该解决方案是创建一个随机密钥，然后对称加密一个消息，然后非对称加密密钥并将两部分都分发给接收者。只有私钥的持有者才能解密对称密钥，只有当对称密钥被解密后，接收者才能解密主消息：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Looking at the example in `asymmetric/asymmetric.go`, we can see that we are
    doing exactly this. This function mealy wraps the two methods for symmetrical
    and asymmetrical encryption that we looked at earlier in this chapter. Decryption
    is as simple:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`asymmetric/asymmetric.go`中的示例，我们可以看到我们正在做的是确切这样。这个函数简单地封装了我们在本章前面看到的对称和非对称加密的两种方法。解密很简单：
- en: '[PRE59]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Maintenance
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护
- en: One important element of keeping your system secure is making sure you keep
    it up to date with all the latest security patches. This approach needs to be
    applied to your application code and your server's operating system and applications,
    and if you are using Docker, you also need to ensure that your containers are
    up to date to ensure you are free from vulnerabilities.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的系统安全的一个重要元素是确保你使用所有最新的安全补丁来更新它。这种方法需要应用于你的应用程序代码和服务器操作系统以及应用程序，如果你使用Docker，你还需要确保你的容器是最新的，以确保你免受漏洞的侵害。
- en: Patching containers
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修补容器
- en: One of the simplest ways to keep your containers secure is to ensure that you
    build and deploy them regularly. Quite often, if a service is not under active
    development, then it may not be deployed to production for months on end. Because
    of this problem, you may be patching host-level application libraries such as
    OpenSSL but because of the application isolation that a container gives, you may
    have vulnerable binaries at a container level. The simplest way of keeping things
    up to date is to run a regular build and deploy even if the application code does
    not change. You also need to ensure that if you are using a base container in
    your Dockerfile, this is also built and updated.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的容器安全的最简单方法之一是定期构建和部署它们。很多时候，如果一个服务没有处于活跃开发状态，那么它可能连续数月都不会被部署到生产环境中。正因为这个问题，你可能需要修补主机级别的应用程序库，比如OpenSSL，但由于容器提供的应用隔离，你可能在容器级别有易受攻击的二进制文件。保持事物更新的最简单方法是定期运行构建和部署，即使应用程序代码没有变化。你还需要确保，如果你在Dockerfile中使用基础容器，这个容器也需要构建和更新。
- en: Docker hub, `quay.io`, and a couple of other software as a service registries
    have the capability to automatically rebuild a container when a linked container
    changes. If you are building an image which is based on `golang:latest`, you can
    automatically trigger a build when the upstream image is pushed to the registry.
    You can also run automated security scanning, which examines the layers in your
    image and scans for any CVE vulnerabilities. It will let you know in which layer
    the vulnerability exists and quite often you will find that this is in the base
    layer, such as Ubuntu or Debian.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub、`quay.io` 和其他几个软件即服务注册表具有在链接容器发生变化时自动重建容器的功能。如果你正在构建基于 `golang:latest`
    的镜像，你可以在上游镜像推送到注册表时自动触发构建。你还可以运行自动化的安全扫描，该扫描检查你的镜像层，并扫描任何 CVE 漏洞。它会告诉你漏洞存在于哪一层，通常你会发现这通常是在基础层，例如
    Ubuntu 或 Debian。
- en: Software updates
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件更新
- en: Patching the software on your host and in your Docker image can help keep you
    safe from vulnerabilities such as Heartbleed, which was found in OpenSSL. Patching
    software updates are relatively straightforward. You can configure your host to
    automatically update itself; the other option, which I prefer, is to ensure that
    your infrastructure is automated so that you can burn it down and rebuild it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的主机和 Docker 镜像上修补软件可以帮助你免受诸如 Heartbleed 这样的漏洞的侵害，该漏洞在 OpenSSL 中被发现。修补软件更新相对简单。你可以配置你的主机自动更新自己；另一个选项，我更喜欢，是确保你的基础设施是自动化的，这样你就可以将其烧毁并重建。
- en: Patching application code
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修补应用程序代码
- en: In the same way that the software on the host needs to be updated, you must
    also update your application code to ensure you always have the latest updates.
    Quite often, an approach of locking your application dependencies to a version
    is followed and with the vendoring support which was introduced in Go 1.5, this
    process has been growing in the community. One problem with this and one of the
    main reasons that vendoring was not present in releases prior to go 1.5 is to
    encourage you to build your application code against the latest packages and to
    fix any problems that occur with breaking API changes sooner rather than later.
    If you do use vendoring, and I am certainly not going to suggest you do not use
    it, then you should run a nightly build which updates all libraries to the latest
    version. You do not necessarily have to deploy this to production; however, if
    the tests pass then why not? If the tests fail then, even if it is a service which
    is not under active development, this should be a trigger to you to perform a
    little maintenance.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 就像主机上的软件需要更新一样，你也必须更新你的应用程序代码，以确保你总是拥有最新的更新。通常，人们会锁定应用程序依赖项到某个版本，并且随着Go 1.5中引入的
    vendoring 支持功能，这个过程在社区中越来越流行。这个问题的一个主要原因是，在 go 1.5 之前的版本中，vendoring 并未出现，这是为了鼓励你针对最新的包构建应用程序代码，并且尽早而不是晚些时候修复任何由于破坏性
    API 变化而产生的问题。如果你确实使用了 vendoring，我当然不会建议你不使用它，那么你应该运行一个夜间构建，将所有库更新到最新版本。你不必一定将此部署到生产环境中；然而，如果测试通过，为什么不呢？如果测试失败，那么，即使这是一个未处于积极开发状态的服务，这也应该成为你进行一些维护的触发器。
- en: Logging
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: If we have protected our passwords and implemented decent security, we still
    need to know when we are under threat. In the previous chapter, we introduced
    logging and logging can be a useful tool as part of your security policy. Consider
    someone attempting to brute force your application login; tracking high levels
    of authentication errors along with the source IP can be useful when you need
    to react to this threat. The IP address of the attacker can be blocked by the
    firewall.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们已经保护了密码并实施了良好的安全措施，我们仍然需要知道我们何时受到威胁。在前一章中，我们介绍了日志记录，日志记录可以作为你安全策略的一部分的有用工具。考虑有人试图暴力破解你的应用程序登录；当需要对此类威胁做出反应时，跟踪高水平的身份验证错误以及源
    IP 地址可能是有用的。攻击者的 IP 地址可以被防火墙阻止。
- en: 'The content of log files needs to consider the following attributes:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件的内容需要考虑以下属性：
- en: Who is performing the action
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁在执行操作
- en: What has failed or succeeded
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么失败了或成功了
- en: When is the action occurring
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动发生的时间
- en: Why this has failed or succeeded
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么会失败或成功
- en: How you can deal with the issue
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何处理这个问题
- en: 'The following example contains nowhere near enough information to be useful
    and, in fact, other than letting you know there may be a failure, you might as
    well not even consume the space taken by such logs:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例包含的信息远远不足以有用，实际上，除了让您知道可能存在故障外，您甚至可以不占用此类日志的空间：
- en: '[PRE60]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following example is far better; it shows the problem in much greater depth
    and describes in detail the events that a user is taking to access the system.
    Modern log evaluation tools such as Kibana allow filtering and grouping of such
    log files, which allows you to build up a dashboard or list of events:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例要好得多；它更深入地展示了问题，并详细描述了用户为访问系统所采取的事件。现代日志评估工具，如Kibana，允许过滤和分组此类日志文件，这使您能够构建仪表板或事件列表：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: For example, you could create a dashboard which is looking at failed attempts
    from a single IP address above a certain threshold, which could indicate a malicious
    attempt to brute force access to a system. It is often possible to set alerts
    on such events, allowing you to proactively identify a threat and block access.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以创建一个仪表板，查看来自单个IP地址的失败尝试，如果超过某个阈值，这可能表明恶意尝试暴力破解系统访问。通常可以在此类事件上设置警报，让您能够主动识别威胁并阻止访问。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned some of the attacks your service may face from
    an intruder. We, hopefully, should have an introduction on how encryption works
    and how we can leverage Go's standard package to implement these to keep our service
    safe. There is little you can do to completely protect yourself from a determined
    attacker; however, using the simple techniques described in this chapter should
    form your standard working practice. Implementing many of these techniques will
    not slow down your development cycle by any significant degree; it will, however,
    give you an edge to keep you safe.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了您的服务可能面临的来自入侵者的攻击。我们希望有一个关于加密工作原理以及如何利用Go的标准包来实现这些功能以保护我们的服务的介绍。您几乎无法完全保护自己免受决心攻击者的攻击；然而，使用本章中描述的简单技术应该形成您标准的工作实践。实施许多这些技术不会显著减慢您的开发周期；然而，这将为您提供一个保持安全的优势。
