- en: Handling Routing for Our REST Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理我们的REST服务的路由
- en: In this chapter, we will discuss routing of the application. For creating an
    API, the first step is to define routes. So, to define routes, we need to figure
    out available constructs in Go. We begin with the basic internal routing mechanism
    in Go. Then, we see how to create a custom Multiplexer. Since ServeMux's capabilities
    are very limited, we will explore a few other frameworks built to serve this purpose.
    This chapter also includes creating routes using third-party libraries such as `httprouter`
    and `Gorilla Mux`. We are going to build a URL-shortening API throughout this
    book. In this chapter, we define routes for the API. Then, we discuss topics like
    SQL injection of an URL. A web framework allows the developer to create a route
    as the first step and then attach handlers to it. Those handlers hold the business
    logic of the application. The crux of this chapter is teaching you how to create
    HTTP routers in Go using `Gorilla Mux`. We also discuss how URL-shortening service
    functions and try to design a logical implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论应用程序的路由。为了创建一个API，第一步是定义路由。因此，为了定义路由，我们需要找出Go中可用的构造。我们从Go中的基本内部路由机制开始。然后，我们看看如何创建一个自定义的多路复用器。由于ServeMux的功能非常有限，我们将探索一些其他用于此目的的框架。本章还包括使用第三方库（如`httprouter`和`Gorilla
    Mux`）创建路由。我们将在整本书中构建一个URL缩短的API。在本章中，我们为API定义路由。然后，我们讨论诸如URL的SQL注入之类的主题。Web框架允许开发人员首先创建一个路由，然后将处理程序附加到它上。这些处理程序包含应用程序的业务逻辑。本章的关键是教会您如何使用`Gorilla
    Mux`在Go中创建HTTP路由。我们还讨论URL缩短服务的功能，并尝试设计一个逻辑实现。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Building a basic web server in Go
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中构建一个基本的Web服务器
- en: Understanding the net/http package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解net/http包
- en: ServeMux, a basic router in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServeMux，在Go中的基本路由器
- en: Understanding httprouter, a router package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解httprouter，一个路由器包
- en: Introducing Gorilla Mux, a powerful HTTP router
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Gorilla Mux，一个强大的HTTP路由器
- en: Introducing URL shortening service design
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍URL缩短服务设计
- en: Getting the code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can download the code for this chapter from  [https://github.com/narenaryan/gorestful/tree/master/chapter2](https://github.com/narenaryan/gorestful/tree/master/chapter2).
    Feel free to add the comments and pull requests. Clone the code and use the code
    samples in the `chapter2` directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/narenaryan/gorestful/tree/master/chapter2](https://github.com/narenaryan/gorestful/tree/master/chapter2)下载本章的代码。欢迎添加评论和拉取请求。克隆代码并在`chapter2`目录中使用代码示例。
- en: Understanding Go's net/http package
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Go的net/http包
- en: 'Go''s `net/http` package deals with HTTP client and server implementations.
    Here, we are mainly interested in the server implementation. Let us create a small
    Go program called `basicHandler.go` that defines the route and a function handler:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`net/http`包处理HTTP客户端和服务器的实现。在这里，我们主要关注服务器的实现。让我们创建一个名为`basicHandler.go`的小型Go程序，定义路由和一个函数处理程序：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code does the following things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了以下几件事情：
- en: Create a route called  `/hello`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`/hello`的路由。
- en: Create a handler called `MyServer`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyServer`的处理程序。
- en: Whenever the request comes on the route (`/hello`), the handler function will
    be executed.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当请求到达路由（`/hello`）时，处理程序函数将被执行。
- en: Write `hello, world` to the response.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向响应中写入`hello, world`。
- en: Start the server on port `8000`. `ListenAndServe` returns **`error` **if something
    goes wrong. So log it using `log.Fatal`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口`8000`上启动服务器。如果出现问题，`ListenAndServe`将返回**`error`**。因此，使用`log.Fatal`记录它。
- en: The `http` package has a function called **`HandleFunc`,** using which we can
    map an URL to a function.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http`包有一个名为**`HandleFunc`**的函数，使用它可以将URL映射到一个函数。'
- en: Here, **`w`** is a response writer. A `ResponseWriter` interface is used by
    an HTTP handler to construct an HTTP response.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，**`w`**是一个响应写入器。`ResponseWriter`接口被HTTP处理程序用来构造HTTP响应。
- en: '`req` is a request object, which deals with all the properties and methods
    of an HTTP request.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`req`是一个请求对象，处理HTTP请求的所有属性和方法。'
- en: Use the log function to debug potential errors. The `ListenAndServe` function
    returns an error if there are any.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志功能来调试潜在的错误。如果有错误，`ListenAndServe`函数会返回一个错误。
- en: Running the code
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'We can run the preceding code as a standalone program. Name the preceding program `basicHandler.go`. Store
    it anywhere you wish to, then run it using the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将上述代码作为一个独立的程序运行。将上述程序命名为`basicHandler.go`。将其存储在任何您希望的位置，然后使用以下命令运行它：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now fire up a shell or browser to see the server in action. Here, I use the
    CURL request:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个shell或浏览器来查看服务器的运行情况。在这里，我使用CURL请求：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The response is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Go has a different concept for handling request and response. We used the `io`
    library to write to the response. For web development, we can use a template to
    automatically fill in the details. Go's internal URL handlers use a ServeMuxmultiplexer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个处理请求和响应的不同概念。我们使用`io`库来写入响应。对于Web开发，我们可以使用模板自动填充细节。Go的内部URL处理程序使用ServeMux多路复用器。
- en: ServeMux, a basic router in Go
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServeMux，在Go中的基本路由器
- en: ServeMux is an HTTP request multiplexer. The `HandleFunc` we used in the preceding
    section is actually a method of ServeMux. By creating a new ServeMux, we can handle
    multiple routes. Before that, we can also create our own multiplexer. A multiplexer
    just handles the logic of separating routes with a function called `ServeHTTP`.
    So if we create a new struct with the `ServeHTTP` method, it can do the job.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ServeMux是一个HTTP请求多路复用器。我们在前面的部分中使用的`HandleFunc`实际上是ServeMux的一个方法。通过创建一个新的ServeMux，我们可以处理多个路由。在此之前，我们还可以创建自己的多路复用器。多路复用器只是处理将路由与名为`ServeHTTP`的函数分离的逻辑。因此，如果我们创建一个具有`ServeHTTP`方法的新结构，它就可以完成这项工作。
- en: 'Consider a route as a key in a dictionary (map), then the handler as its value.
    The router finds the handler from the route and tries to execute the `ServeHTTP`
    function. Let us create a program called `customMux.go` and see this implementation
    in action:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由视为字典（映射）中的键，然后将处理程序视为其值。路由器从路由中找到处理程序，并尝试执行`ServeHTTP`函数。让我们创建一个名为`customMux.go`的程序，并看看这个实现的效果：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, we are creating a custom struct called **`CustomServeMux`, **which
    is going to take care of our routing. We implemented a function called **`ServeHTTP`**
    in order to capture the request and write a response back to it. The `fmt` package
    is usually used to create strings. **`Fprinf` **composes the string out of supplied
    parameters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个名为**`CustomServeMux`**的自定义结构，它将负责我们的路由。我们实现了一个名为**`ServeHTTP`**的函数，以便捕获请求并向其写入响应。通常使用`fmt`包来创建字符串。**`Fprinf`**将提供的参数组合成字符串。
- en: In the main function, we are creating an instance of our **`CustomServeMux` **and
    passing it to the `ListenAndServe` function on `http`.` "math/rand"` is the library
    that takes care of generating random numbers. This basic foundation is going to
    be helpful for us when we discuss adding authentication to our API server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们创建了一个**`CustomServeMux`**的实例，并将其传递给`http`的`ListenAndServe`函数。`"math/rand"`是负责生成随机数的库。当我们讨论向API服务器添加身份验证时，这个基本的基础将对我们有所帮助。
- en: Running the code
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'Let us fire a CURL request and see what the response is for various routes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们发出一个CURL请求并查看各种路由的响应：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, fire up a shell or browser to see the server in action. Here, I use the
    CURL request:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开一个shell或浏览器来查看服务器的运行情况。在这里，我使用CURL请求：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The response is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Use *Ctrl* + *C* or *Cmd* + *C* to stop your Go server. If you are running it
    as a background process, use **`pgrep go`** to find the `processID` and kill it
    using `kill pid`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *C*或*Cmd* + *C*来停止您的Go服务器。如果您将其作为后台进程运行，请使用**`pgrep go`**来查找`processID`，然后使用`kill
    pid`来杀死它。
- en: Adding multiple handlers using ServeMux
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ServeMux添加多个处理程序
- en: 'The preceding custom Mux that we created can be cumbersome when we have different
    endpoints with different functionalities. To add that logic, we need to add many
    `if/else` conditions to manually check the URL route. We can instantiate a new
    `ServeMux` and define many handlers like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的前面的自定义Mux在具有不同功能的不同端点时可能会很麻烦。为了添加该逻辑，我们需要添加许多`if/else`条件来手动检查URL路由。我们可以实例化一个新的`ServeMux`并像这样定义许多处理程序：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code snippet shows how to create a ServerMux and attach multiple handlers
    to it. `randomFloat` and `randomInt` are the two routes we created for returning
    a random `float` and random `int`, respectively. Now we can pass this to the `ListenAndServe`
    function. `Intn(100)` returns a random integer number from the range 0-100\. For
    more details on random functions, visit the Go random package page at [http://golang.org](http://golang.org).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了如何创建一个ServerMux并将多个处理程序附加到它上。`randomFloat`和`randomInt`是我们为返回一个随机`float`和随机`int`创建的两个路由。现在我们可以将这个传递给`ListenAndServe`函数。`Intn(100)`从0-100的范围内返回一个随机整数。有关随机函数的更多详细信息，请访问[http://golang.org](http://golang.org)上的Go随机包页面。
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The complete code looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码如下：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'We can run the program directly using the run command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接运行程序使用run命令：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let us fire two CURL commands and see the output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行两个CURL命令并查看输出：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The responses will be:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将是：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Your response may change due to the random number generator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机数生成器，您的响应可能会发生变化。
- en: We saw how we can create a URL router with basic Go constructs. Now we are going
    to look at a few popular URL routing frameworks that are widely used by the Go
    community for their API servers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用基本的Go构造创建URL路由器。现在我们将看一下一些广泛被Go社区用于其API服务器的流行URL路由框架。
- en: Introducing httprouter, a lightweight HTTP router
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍httprouter，一个轻量级的HTTP路由器
- en: '**httprouter,** as the name suggests, routes the HTTP requests to particular
    handlers. Compared to the basic router, it has the following features:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**httprouter**，顾名思义，将HTTP请求路由到特定的处理程序。与基本路由器相比，它具有以下特点：'
- en: Allows variables in the route paths
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在路由路径中使用变量
- en: It matches the REST methods (`GET`, `POST`, `PUT`, and so on)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它匹配REST方法（`GET`，`POST`，`PUT`等）
- en: No compromising on performance
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会影响性能
- en: 'We are going to discuss these qualities in more detail in the following section.
    Before that, there are a few noteworthy points that make httprouter an even better
    URL router:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地讨论这些特性。在那之前，有一些值得注意的点，使httprouter成为一个更好的URL路由器：
- en: httprouter plays well with the inbuilt `http.Handler`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httprouter与内置的`http.Handler`很好地配合
- en: httprouter explicitly says that a request can only match to one route or none
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: httprouter明确表示一个请求只能匹配一个路由或没有
- en: The router's design encourages building sensible, hierarchical RESTful APIs
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器的设计鼓励构建合理的、分层的RESTful API
- en: You can build efficient static file servers
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以构建高效的静态文件服务器
- en: Installation
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'To install httprouter, we just need to run the `get` command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装httprouter，我们只需要运行`get`命令：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, now we have `httprouter`. We can refer to the library in our source code
    as this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有了`httprouter`。我们可以在我们的源代码中引用这个库：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The basic usage of httprouter can be understood through an example. In this
    example, let us create a small API to get information about files and programs
    installed from the server. Before jumping straight into the program, you should
    know how to execute system commands on Go. There is a package called `os/exec`. It
    allows us to execute system commands and get the output back to the program.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子可以理解httprouter的基本用法。在这个例子中，让我们创建一个小型API，从服务器获取有关文件和程序安装的信息。在直接进入程序之前，您应该知道如何在Go上执行系统命令。有一个叫做`os/exec`的包。它允许我们执行系统命令并将输出返回给程序。
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then it can be accessed in the code as this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它可以在代码中被访问为这样：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**`exec.Command`** is the function that takes a command and an additional arguments
    array. Additional arguments are the options or input for the command. It can then
    be executed in two ways:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**`exec.Command`**是一个接受命令和额外参数数组的函数。额外的参数是命令的选项或输入。它可以通过两种方式执行：'
- en: Run the command instantly
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即运行命令
- en: Start and wait for it to finish
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动并等待其完成
- en: 'We can collect the output of the command by attaching `Stdout` to a custom
    string. Get that string and send it back to the client. The code makes more sense
    here. Let us write a Go program to create a REST service that does two things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`Stdout`附加到自定义字符串来收集命令的输出。获取该字符串并将其发送回客户端。代码在这里更有意义。让我们编写一个Go程序来创建一个REST服务，它可以做两件事：
- en: Gets the Go version
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取Go版本
- en: Gets the file contents of a given file
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定文件的文件内容
- en: 'This program uses `Hhttprouter` to create the service. Let us name it as `execService.go`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用`Hhttprouter`创建服务。让我们将其命名为`execService.go`：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Program explanation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序解释
- en: 'The preceding program is trying to implement a REST service using `httprouter`**.**
    We are defining two routes here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序试图使用`httprouter`**实现REST服务。**我们在这里定义了两个路由：
- en: '`/api/v1/go-version`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/v1/go-version`'
- en: '`/api/v1/show-file/:name`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/v1/show-file/:name`'
- en: The `:name` here is the path parameter. It indicates the API that shows the
    file named xyz. The basic Go router cannot handle these parameters, by using `httprouter`,
    we can also match the REST methods. In the program, we matched `GET` requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`:name`是路径参数。它表示显示名为xyz的文件的API。基本的Go路由器无法处理这些参数，通过使用`httprouter`，我们还可以匹配REST方法。在程序中，我们匹配了`GET`请求。
- en: 'In a step-by-step process, the preceding program:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个逐步的过程中，前面的程序：
- en: Imported the `httprouter` and other necessary Go packages
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入了`httprouter`和其他必要的Go包
- en: Created a new router using the `New()` method of `httprouter`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`httprouter`的`New()`方法创建了一个新的路由器
- en: The router has methods like `GET`, `POST`, `DELETE`, and so on
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器有`GET`，`POST`，`DELETE`等方法
- en: The `GET` method takes two arguments, `URL path expression` and `Handler function`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`方法接受两个参数，`URL路径表达式`和`处理程序函数`'
- en: This router can be passed to the `ListenAndServe` function of http
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个路由器可以传递给http的`ListenAndServe`函数
- en: Now, coming to the handlers, they look similar to the ones belonging to ServeMux,
    but a third argument called **`httprouter.Params`** holds information about all
    parameters that are supplied with a `GET` request
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，谈到处理程序，它们看起来与属于ServeMux的处理程序相似，但第三个参数称为**`httprouter.Params`**保存有关使用`GET`请求提供的所有参数的信息
- en: We defined the path parameter (a variable in the URL path) called `name` and
    used it in our program
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了路径参数（URL路径中的变量）称为`name`并在程序中使用它
- en: The `getCommandOutput` function takes commands and arguments and returns output
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCommandOutput`函数接受命令和参数并返回输出'
- en: The first API calls the Go version and returns the output to the client
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个API调用Go版本并将输出返回给客户端
- en: The second API performs a `cat` command of the file and returns it to the client
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个API执行了文件的`cat`命令并将其返回给客户端
- en: If you observe the code, I used `/usr/local/bin/go` as the Go executable location
    because it is the Go compiler location on my MacBook. While executing `exec.Command`,
    you should give the absolute path of the executable. So if you are working on
    an Ubuntu machine or Windows, use the path to your executable. On Linux machines,
    you can easily find that out by using the `$ which go` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察代码，我使用了`/usr/local/bin/go`作为Go可执行文件位置，因为这是我MacBook上的Go编译器位置。在执行`exec.Command`时，您应该给出可执行文件的绝对路径。因此，如果您在Ubuntu机器或Windows上工作，请使用可执行文件的路径。在Linux机器上，您可以通过使用`$
    which go`命令轻松找到。
- en: 'Now create two new files in the same directory. These files will be served
    by our file server program. You can create any custom files in this directory
    for testing:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在同一目录中创建两个新文件。这些文件将由我们的文件服务器程序提供。您可以在此目录中创建任何自定义文件进行测试：
- en: '`Latin.txt`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Latin.txt`：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Greek.txt`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greek.txt`：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now run the program with this command. This time, instead of firing a CURL
    command, let us use the browser as our output for `GET.` Windows users may not
    have CURL as the firsthand application. They can use API testing software like
    the postman client while developing the REST API. Take a look at the following
    command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用此命令运行程序。这一次，我们不使用CURL命令，而是使用浏览器作为我们的`GET`输出。Windows用户可能没有CURL作为首选应用程序。他们可以在开发REST
    API时使用像postman客户端这样的API测试软件。看一下以下命令：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for the first `GET` request looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`GET`请求的输出如下：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result will be this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是这样的：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second `GET` request requesting `Greek.txt` is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`GET`请求请求`Greek.txt`是：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we will see the file output in Greek as this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到希腊语的文件输出如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Building the simple static file server in minutes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在几分钟内构建简单的静态文件服务器
- en: 'Sometimes, as part of the API, we should serve static files. The other application
    of httprouter is building scalable file servers. It means that we can build a
    Content Delivery Platform of our own. Some of the clients need static files from
    the server. Traditionally, we use Apache2 or Nginx for that purpose. But, from
    within the Go server, in order to serve the static files, we need to route them
    through a universal route like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，作为API的一部分，我们应该提供静态文件。httprouter的另一个应用是构建可扩展的文件服务器。这意味着我们可以构建自己的内容传递平台。一些客户端需要从服务器获取静态文件。传统上，我们使用Apache2或Nginx来实现这一目的。但是，从Go服务器内部，为了提供静态文件，我们需要通过类似这样的通用路由进行路由：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'See the following code snippet for our implementation. The idea is to use the
    `http.Dir` method to load the filesystem, and then use the **`ServeFiles` **function
    of the `httprouter` instance. It should serve all the files in the given public
    directory. Usually, static files are kept in the folder **`/var/public/www` **on
    a Linux machine. Since I am using OS X, I create a folder called `static` in my
    home directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下代码片段以了解我们的实现。想法是使用`http.Dir`方法加载文件系统，然后使用`httprouter`实例的**`ServeFiles` **函数。它应该提供给定公共目录中的所有文件。通常，静态文件保存在Linux机器上的文件夹**`/var/public/www` **中。由于我使用的是OS
    X，我在我的主目录中创建了一个名为`static`的文件夹：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, I copy the `Latin.txt` and `Greek.txt` files,which we created for the
    previous example, to the preceding static directory. After doing this, let us
    write the program for the file server. You will be amazed at the simplicity of
    `httprouter`. Create a program called `fileserver.go`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我复制了我们为上一个示例创建的`Latin.txt`和`Greek.txt`文件到之前的静态目录。在这样做之后，让我们为文件服务器编写程序。您会对`httprouter`的简单性感到惊讶。创建一个名为`fileserver.go`的程序：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now run the server and see the output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行服务器并查看输出：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let us open another terminal and fire this CURL request:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开另一个终端并发送这个CURL请求：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the output will be a static file content server from our file server:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输出将是来自我们文件服务器的静态文件内容服务器：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Introducing Gorilla Mux, a powerful HTTP router
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Gorilla Mux，一个强大的HTTP路由器
- en: Mux stands for the multiplexer. Similarly, Gorilla Mux is a multiplexer designed
    to multiplex HTTP routes (URLs) to different handlers. Handlers are the functions
    which can handle the given requests. Gorilla Mux is a wonderful package for writing
    beautiful routes for our web applications and API servers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Mux代表多路复用器。同样，Gorilla Mux是一个设计用于将HTTP路由（URL）多路复用到不同处理程序的多路复用器。处理程序是可以处理给定请求的函数。Gorilla
    Mux是一个非常好的包，用于为我们的Web应用程序和API服务器编写美丽的路由。
- en: 'Gorilla Mux provides tons of options to control how routing is done to your
    web application. It allows a lot of features. Some of them are:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla Mux提供了大量选项来控制路由到您的Web应用程序的方式。它允许许多功能。其中一些是：
- en: Path-based matching
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路径的匹配
- en: Query-based matching
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于查询的匹配
- en: Domain-based matching
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于域的匹配
- en: Sub-domain based matching
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于子域的匹配
- en: Reverse URL generation
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向URL生成
- en: Installation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installing the Mux package is fairly simple. You need to run this command in
    the Terminal (Mac and Linux):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Mux包非常简单。您需要在终端（Mac和Linux）中运行此命令：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you get any errors saying `package github.com/gorilla/mux: cannot download,
    $GOPATH not set. For more details see--go help gopath`, set the `$GOPATH` environment
    variable using the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您收到任何错误，说`package github.com/gorilla/mux: cannot download, $GOPATH not set.
    For more details see--go help gopath`，请使用以下命令设置`$GOPATH`环境变量：'
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we discussed in the previous chapter, this says that all the packages and
    programs go into this directory. It has three folders: `bin`, **`pkg`,** and `src`.
    Now, add `GOPATH` to the `PATH` variable, to use the installed bin files as system
    utilities that have no `./executable` style. Refer to the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中讨论的，这意味着所有的包和程序都放在这个目录中。它有三个文件夹：`bin`，`pkg`和`src`。现在，将`GOPATH`添加到`PATH`变量中，以便使用已安装的bin文件作为没有`./executable`样式的系统实用程序。参考以下命令：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These settings stay until you turn off your machine. So, to make it a permanent
    change, add the preceding lines to your bash profile:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置会一直保留，直到您关闭计算机。因此，要使其成为永久更改，请将上述行添加到您的bash配置文件中：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we are ready to go. Assuming Gorilla Mux is installed, proceed to the basics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了。假设Gorilla Mux已安装，请继续进行基本操作。
- en: Fundamentals of Gorilla Mux
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gorilla Mux的基础知识
- en: Gorilla Mux allows us to create a new router, similar to httprouter. But the
    attachment of the handler function to a given URL route is different in both.
    If we observe, Mux's way of attaching a handler is similar to that of basic ServeMux.
    Unlike httprouter,it modifies the request object instead of using an additional
    argument to pass the URL parameters to the handler function. We can access parameters
    using the `Vars` method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla Mux允许我们创建一个新的路由器，类似于httprouter。但是在两者之间，将处理程序函数附加到给定的URL路由的方式是不同的。如果我们观察一下，Mux附加处理程序的方式类似于基本ServeMux。与httprouter不同，它修改请求对象而不是使用附加参数将URL参数传递给处理程序函数。我们可以使用`Vars`方法访问参数。
- en: 'I am going to take an example from the Gorilla Mux homepage to explain how
    useful it is. Create a file called `muxRouter.go` and add the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从Gorilla Mux主页上的一个示例来解释它有多有用。创建一个名为`muxRouter.go`的文件，并添加以下代码：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now run the file using the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令运行文件：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'By running the CURL command this way, we can get the output as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式运行CURL命令，我们可以得到以下输出：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Mux parses the variables in the path. All the variables that are parsed are
    available calling the `Vars` function. Don''t get caught up in the custom server
    details of the preceding program. Just observe the Mux code. We attached a handler
    to the URL. We have written the parsed variables back to the HTTP response. This
    line is crucial. Here, an `id` has a regular expression saying that `id` is a
    number (0–9) with one or more digits:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Mux解析路径中的变量。通过调用`Vars`函数，可以使用解析的所有变量。不要陷入上述程序的自定义服务器细节中。只需观察Mux代码。我们将处理程序附加到URL。我们将解析的变量写回HTTP响应。这一行很关键。在这里，`id`有一个正则表达式，表示`id`是一个数字（0-9），有一个或多个数字：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let us call it a route. With this flexibility of pattern matching, we can design
    the RESTful API very comfortably.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称之为路由。有了这种模式匹配的灵活性，我们可以非常舒适地设计RESTful API。
- en: Use `http.StatusOK` to write to the header of a response to announce that an
    API request is successful. Similarly, http has many status codes for various types
    of HTTP request. Use the appropriate one to convey the right message. For example,
    404 - Not found, 500 - Server error, and so on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`http.StatusOK`写入响应的标头，以宣布API请求成功。同样，http有许多状态代码，用于各种类型的HTTP请求。使用适当的状态代码传达正确的消息。例如，404
    - 未找到，500 - 服务器错误，等等。
- en: Reverse mapping URL
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向映射URL
- en: 'In simple words, a reverse-mapping URL is just getting the URL for an API resource.
    Reverse-mapping is quite useful when we need to share links to our web application
    or API. But in order to create a URL from the data, we should associate a `Name`
    with the Mux route:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，反向映射URL就是获取API资源的URL。当我们需要分享链接到我们的Web应用程序或API时，反向映射非常有用。但是为了从数据中创建URL，我们应该将`Name`与Mux路由关联起来：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, if we have data, we can form an URL:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有数据，我们可以形成一个URL：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Gorilla Mux provides a lot of flexibility in creating custom routes. It also
    allows method chaining to add properties to a created route.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla Mux在创建自定义路由方面提供了很大的灵活性。它还允许方法链接以向创建的路由添加属性。
- en: Custom paths
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义路径
- en: 'We can define the preceding route in two steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分两步定义前面的路由：
- en: 'First, define the path on the router:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在路由器上定义路径：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, define the handler on the router:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在路由器上定义处理程序：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Be aware that the method chained here is `HandlerFunc` and not `HandleFunc`,
    as shown in the preceding code. We can create a top-level path and add subpaths
    to different handlers easily in Mux using `Subrouter`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此处链接的方法是`HandlerFunc`而不是前面代码中显示的`HandleFunc`。我们可以使用`Subrouter`在Mux中轻松创建顶级路径并为不同的处理程序添加子路径：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So all the URLs of the form `http://localhost:8000/articles/123/settings` redirect
    to `settingsHandler` and URLs of the form `http://localhost:8000/articles/123/details` redirect
    to the **`detailsHandler`.** This might be useful when we create a namespace for
    grouping particular URL paths.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，形式为`http://localhost:8000/articles/123/settings`的所有URL将重定向到`settingsHandler`，形式为`http://localhost:8000/articles/123/details`的所有URL将重定向到**`detailsHandler`**。当我们为特定URL路径创建命名空间时，这可能非常有用。
- en: Path Prefix
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径前缀
- en: '**Path Prefix** is a wildcard for matching after a defined path. The general
    use case is when we serve files from our static folder and all URLs should be
    served as-is. From the official Mux documentation, we can use this for serving
    static files. This is the Mux version of the static file server that we created
    in the preceding program using `httprouter`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径前缀**是在定义路径之后进行匹配的通配符。一般用例是当我们从静态文件夹中提供文件并且所有URL都应该按原样提供时。从官方Mux文档中，我们可以用它来提供静态文件。这是使用`httprouter`在前面的程序中创建的静态文件服务器的Mux版本：'
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This can serve all kinds of files in the directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以提供目录中的所有类型的文件：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Strict Slash
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Strict Slash
- en: 'Strict Slash is a parameter on the Mux router by which we can order the router
    to redirect URL routes with trailing slashes to those without them. For example, **`/articles/`**
    can be the original path, but routes coming with `/path` will be redirected to
    the original path:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Strict Slash是Mux路由器上的一个参数，可以让路由器将带有尾随斜杠的URL路由重定向到没有尾随斜杠的路由。例如，**`/articles/`**可以是原始路径，但带有`/path`的路由将被重定向到原始路径：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This URL redirects to the preceding `ArticleHandler` if the `StrictSlash` parameter
    is set to `true`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`StrictSlash`参数设置为`true`，此URL将重定向到前面的`ArticleHandler`：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Encoded paths
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码路径
- en: 'We can have encoded paths from a few clients. To handle these encoded paths,
    Mux provides a method called **`UseEncodedPath`.** If we call this method on the
    router variable, we can even match the encoded URL route and forward it to the
    given handler:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一些客户端获取编码路径。为了处理这些编码路径，Mux提供了一个名为**`UseEncodedPath`**的方法。如果我们在路由器变量上调用此方法，甚至可以匹配编码的URL路由并将其转发给给定的处理程序：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This can match the URL:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以匹配URL：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`%2F` stands for `/` in the un-encoded form. If the method `UseEncodedPath`
    is not used, the router might understand it as `/v1/1/2`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`%2F`代表未编码形式中的`/`。如果不使用`UseEncodedPath`方法，路由器可能会将其理解为`/v1/1/2`。'
- en: Query-based matching
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于查询的匹配
- en: 'Query parameters are those that get passed along with the URL. This is what
    we commonly see in a REST `GET` request. Gorilla Mux can create a route for matching
    a URL with the given query parameters:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是与URL一起传递的参数。这是我们通常在REST `GET`请求中看到的。Gorilla Mux可以创建一个路由，用于匹配具有给定查询参数的URL：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let us add functionality to our program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的程序添加功能：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It limits the query with the preceding URL. The `id` and `category` match with
    the `Queries` list. Empty values are allowed for parameters. `QueryHandler` looks
    like this. You can use `request.URL.Query()` to obtain query parameters in your
    handler function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它限制了前面URL的查询。`id`和`category`与`Queries`列表匹配。参数允许为空值。`QueryHandler`如下所示。您可以使用`request.URL.Query()`在处理程序函数中获取查询参数：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Host-based matching
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主机的匹配
- en: Sometimes we need to allow requests from specific hosts. If the host is matched,
    then the request proceeds to the route handlers. This could be very helpful if
    we have multiple domains and subdomains and match them with the custom routes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要允许来自特定主机的请求。如果主机匹配，则请求将继续传递到路由处理程序。如果我们有多个域和子域并将它们与自定义路由匹配，这可能非常有用。
- en: 'Using the `Host` method on the router variable, we can regulate from which
    hosts routes can be directed:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由器变量上的`Host`方法，我们可以调节从哪些主机重定向路由：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we set this, all requests coming from the host `aaa.bbb.ccc` of the form 
    `http://aaa.bbb.ccc/111/222/333` will be matched. Similarly, we can regulate HTTP
    schemes (http, https) using `Schemes` and REST methods like (`GET`, `POST`) using
    `Methods` Mux functions. The program `queryParameters.go` explains how to use
    query parameters in the handler:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了这个，来自`aaa.bbb.ccc`主机的形式为`http://aaa.bbb.ccc/111/222/333`的所有请求将被匹配。类似地，我们可以使用`Schemes`来调节HTTP方案（http，https）和使用`Methods`
    Mux函数来调节REST方法（`GET`，`POST`）。程序`queryParameters.go`解释了如何在处理程序中使用查询参数：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let us fire a CURL request in this format in a terminal:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中以这种格式发送一个CURL请求：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We need to escape special characters in the shell. If it is in the browser,
    there is no problem escaping. The output is like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在shell中转义特殊字符。如果在浏览器中，转义就没有问题。输出如下：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The **`r.URL.Query()` **function returns a map with all the parameter and value
    pairs. They are basically strings, and in order to use them in our program logic
    we need to convert the number strings to integers. We can use Go's `strconv` package
    to convert a string to an integer, and vice versa.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**`r.URL.Query()` **函数返回一个带有所有参数和值对的映射。它们基本上是字符串，为了在我们的程序逻辑中使用它们，我们需要将数字字符串转换为整数。我们可以使用Go的`strconv`包将字符串转换为整数，反之亦然。'
- en: Its pattern matching features and simplicity push Gorilla Mux as a popular choice
    for an HTTP router in projects. Many successful projects worldwide are already
    using Mux for their routing needs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 其模式匹配功能和简单性使Gorilla Mux成为项目中HTTP路由器的热门选择。全球许多成功的项目已经在其路由需求中使用Mux。
- en: SQL injections in URLs and ways to avoid them
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL中的SQL注入及避免它们的方法
- en: 'SQL injection is the process of attacking a database with malicious scripts.
    If we are not careful while writing secure URL routes, there may be an opportunity
    for SQL injection. These attacks usually happen for the `POST`, `PUT`, and `DELETE`
    HTTP verbs. For example, if we are allowing the client to pass variables to the
    server, then there is a chance for an attacker to append a string to those variables.
    If we are inserting those users sending parameters directly into an SQL query,
    then it could be injectable. The right way to talk to DB is to allow driver functions
    to check the parameters before inserting the string and executing it in the database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是使用恶意脚本攻击数据库的过程。如果我们在编写安全的URL路由时不小心，可能会存在SQL注入的机会。这些攻击通常发生在`POST`，`PUT`和`DELETE`
    HTTP动词中。例如，如果我们允许客户端向服务器传递变量，那么攻击者有机会向这些变量附加一个字符串。如果我们直接将这些发送参数的用户插入到SQL查询中，那么它可能是可注入的。与数据库交谈的正确方式是允许驱动程序函数在插入字符串并在数据库中执行之前检查参数：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this snippet, we are trying to get information about an article by id and
    category. We are executing an SQL query. But since we are appending the values
    directly, we may include malicious SQL statements like (`--`) comments and (`ORDER
    BY n`) range clauses in the query:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们试图通过id和类别获取有关文章的信息。我们正在执行一个SQL查询。但由于我们直接附加值，我们可能在查询中包含恶意的SQL语句，如（`--`）注释和（`ORDER
    BY n`）范围子句：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This will leak information about columns the table has. We can change the number
    and see the breaking point where we get an error message from the database saying:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将泄漏表中的列信息。我们可以更改数字并查看我们从数据库收到错误消息的断点：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will see more about this in our upcoming chapters, where we build full-fledged
    REST services with other methods, like `POST`, `PUT`, and so on:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中了解更多信息，我们将在其中使用其他方法构建完整的REST服务，如`POST`，`PUT`等：
- en: 'Now, how to avoid these injections. There are a few ways:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何避免这些注入。有几种方法：
- en: Set the user level permissions to various tables
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户级别权限设置为各种表
- en: While using URL parameters, carefully observe the pattern
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用URL参数时，仔细观察模式
- en: Use the **`HTMLEscapeString` **function from Go's **`text/template` **package
    to escape special characters in the API parameters, like `body` and `path `
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go的`text/template`包中的**`HTMLEscapeString`**函数来转义API参数中的特殊字符，如`body`和`path`
- en: Use a driver program instead of executing raw SQL queries
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用驱动程序代替执行原始SQL查询
- en: Stop database debug messages getting relayed back to the client
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止数据库调试消息传回客户端
- en: Use security tools like `sqlmap` to find out vulnerabilities
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sqlmap`等安全工具查找漏洞
- en: Creating a basic API layout for URL shortening services
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为URL缩短服务创建基本的API布局
- en: Have you ever wondered how URL shortening services work? They take a very long
    URL and give a shortened, crisp, and memorable URL back to the user. At first
    sight, it looks like magic, but it is a simple math trick.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经想过URL缩短服务是如何工作的？它们将一个非常长的URL转换为一个缩短、简洁和易记的URL提供给用户。乍一看，它看起来像魔术，但实际上是一个简单的数学技巧。
- en: 'In a single statement, URL shortening services are built upon two things:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，URL缩短服务建立在两个基础上：
- en: A string mapping algorithm to map long strings to short strings ( Base 62)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种字符串映射算法，将长字符串映射到短字符串（Base 62）
- en: A simple web server that redirects a short URL to the original URL
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的Web服务器，将短URL重定向到原始URL
- en: 'There are a few obvious advantages of URL shortening:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: URL缩短有一些明显的优势：
- en: Users can remember the URL; easy to maintain
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以记住URL；易于维护
- en: Users can use the links where there are restrictions on text length; for example,
    Twitter
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在文本长度有限的链接上使用，例如Twitter
- en: Predictable shortened URL length
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测的缩短URL长度
- en: 'Take a look at the following diagram:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表：
- en: '![](img/cf0a2e5f-f392-415a-bbe6-e449a1baa9e2.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf0a2e5f-f392-415a-bbe6-e449a1baa9e2.jpg)'
- en: 'Under the hood, these things happen silently in a URL shortening service:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL缩短服务中，这些事情在幕后默默发生：
- en: Take the original URL.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取原始URL。
- en: Apply Base62 encoding on it. It generates a shortened URL.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其应用Base62编码。它会生成一个缩短的URL。
- en: 'Store that URL in the database. Map it to the original URl (`[shortened_url:
    orignial_url]`).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将该URL存储在数据库中。将其映射到原始URL（`[shortened_url: orignial_url]`）。'
- en: Whenever a request comes to the shortened URL, just do an HTTP redirect to the
    original URL.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当请求到达缩短的URL时，只需对原始URL进行HTTP重定向。
- en: 'We will implement the complete logic in upcoming chapters when we integrate
    databases to our API server, but before that, though, we should specify the API
    design documentation. Let us do that. Take a look at the following table:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中实现完整的逻辑，当我们将数据库集成到我们的API服务器时，但在那之前，我们应该指定API设计文档。让我们来做。看一下下表：
- en: '| **URL** | **REST Verb** | **Action** | **Success** | Failure |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **REST动词** | **动作** | **成功** | 失败 |'
- en: '| `/api/v1/new` | `POST` | Create a shortened URL | 200 | 500, 404 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `/api/v1/new` | `POST` | 创建缩短的URL | 200 | 500, 404 |'
- en: '| `/api/v1/:url` | `GET` | Redirect to original URL | 301 | 404 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `/api/v1/:url` | `GET` | 重定向到原始URL | 301 | 404 |'
- en: As an exercise, the reader is allowed to implement this from the fundamentals
    we have built thus far. You can use a dummy JSON file instead of a database like
    we did in the first chapter. We will implement this in upcoming chapters, anyway.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，读者可以根据我们迄今为止建立的基础来实现这一点。您可以使用一个虚拟的JSON文件，而不是像我们在第一章中所做的那样使用数据库。无论如何，我们将在接下来的章节中实现这一点。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first introduced the HTTP router. We tried to build a basic
    application using Go's http package. Then we briefly discussed ServeMux, with
    an example. We saw how to add multiple handlers to multiple routes. Then we introduced
    a lightweight router package called `httprouter`.`httprouter` allows developers
    to create scalable routes, with the option of parsing parameters passed in the
    URL path. We can also serve files over the HTTP using `httprouter`. We built a
    small service to get the Go version and file contents (read-only). That example
    can be extended to any system information.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了HTTP路由器。我们尝试使用Go的http包构建了一个基本的应用程序。然后我们简要讨论了ServeMux，并举例说明。我们看到了如何向多个路由添加多个处理程序。然后我们介绍了一个轻量级的路由器包，名为`httprouter`。`httprouter`允许开发人员创建可扩展的路由，还可以选择解析URL路径中传递的参数。我们还可以使用`httprouter`在HTTP上提供文件。我们构建了一个小型服务来获取Go版本和文件内容（只读）。该示例可以扩展到任何系统信息。
- en: Next, we introduced the popular Go routing library: `Gorilla Mux`. We discussed
    how it is different from `httprouter` and explored its functionality by implementing
    solid examples. We explained how `Vars` can be used to get path parameters and
    `r.URL.Query`to parse query parameters. Then we discussed SQL injection and how
    it can happen in our applications. We gave a few pointers on how to avoid it.
    We will see some of these measures in upcoming chapters when we build a complete
    REST service, which includes a database. Finally, we laid down the logic for URL
    shortening and created an API design document.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了流行的Go路由库：`Gorilla Mux`。我们讨论了它与`httprouter`的不同之处，并通过实现实例来探索其功能。我们解释了如何使用`Vars`来获取路径参数和使用`r.URL.Query`来解析查询参数。然后我们讨论了SQL注入以及它如何在我们的应用程序中发生。我们给出了一些建议，以避免它。当我们构建一个包含数据库的完整REST服务时，我们将在即将到来的章节中看到这些措施。最后，我们制定了URL缩短的逻辑，并创建了一个API设计文档。
- en: In the next chapter, we look at `Middleware` functions, which act as tamperers
    for HTTP requests and responses. That phenomenon will help us modify the API response
    on-the-fly. The next chapter also features `RPC` (Remote Procedure Call).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`中间件`函数，它们充当HTTP请求和响应的篡改者。这种现象将帮助我们即时修改API响应。下一章还涉及`RPC`（远程过程调用）。
