- en: Working with Middleware and RPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件和RPC进行工作
- en: In this chapter, we are going to look at middleware functionality. What is middleware,
    and how can we build it from scratch? Next, we will move to a better middleware
    solution written for us, called Gorilla Handlers. We will then try to understand
    a few use cases where middleware can be helpful. After that, we will start building
    our RPC services with Go's internal RPC and JSON RPC. Then we will move to an
    advanced RPC framework, such Gorilla HTTP RPC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究中间件功能。什么是中间件，我们如何从头开始构建它？接下来，我们将转向为我们编写的更好的中间件解决方案，称为Gorilla Handlers。然后，我们将尝试理解中间件可以帮助的一些用例。之后，我们将开始使用Go的内部RPC和JSON
    RPC构建我们的RPC服务。然后我们将转向一个高级的RPC框架，如Gorilla HTTP RPC。
- en: 'The topics we cover in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题有：
- en: What is middleware?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是中间件？
- en: What is an RPC (Remote Procedure Call)?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是RPC（远程过程调用）？
- en: How can we implement RPC and JSON RPC in Go?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何在Go中实现RPC和JSON RPC？
- en: Getting the code
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: All the code for this chapter is available at [https://github.com/narenaryan/gorestful/tree/master/chapter3](https://github.com/narenaryan/gorestful/tree/master/chapter3).
    Please refer to Chapter 1, *Getting Started with the REST API Development*, for
    setting up Go projects and running the programs. It is better to clone the entire
    `gorestful` repository from GitHub.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在[https://github.com/narenaryan/gorestful/tree/master/chapter3](https://github.com/narenaryan/gorestful/tree/master/chapter3)找到。请参考第1章，*开始REST
    API开发*，以设置Go项目并运行程序。最好从GitHub克隆整个`gorestful`存储库。
- en: What is middleware?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是中间件？
- en: 'Middleware is an entity that hooks into a server''s request/response processing.
    The middleware can be defined in many components. Each component has a specific
    function to perform. Whenever we define the handlers for our URL patterns (as
    in the last chapter), the request hits the handler and executes the business logic.
    So virtually all middleware should perform these functions in order:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一个钩入服务器请求/响应处理的实体。中间件可以在许多组件中定义。每个组件都有特定的功能要执行。每当我们为我们的URL模式定义处理程序（就像在上一章中那样），请求会命中处理程序并执行业务逻辑。因此，几乎所有中间件都应按顺序执行这些功能：
- en: Process the request before hitting the handler (function)
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命中处理程序（函数）之前处理请求
- en: Process the handler function
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理处理程序函数
- en: Process the response before giving it to the client
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将其提供给客户端之前处理响应
- en: 'We can see the previous points in the form of a visual illustration:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以可视化形式呈现的先前的要点：
- en: '![](img/50edf7ee-41ae-4e5e-8f94-558c488e93f9.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50edf7ee-41ae-4e5e-8f94-558c488e93f9.png)'
- en: 'If we observe the diagram carefully, the journey of the request starts with
    the client. In an application with no middleware, a request reaches the API server
    and will get handled by some function handler. The response is immediately sent
    back from the server and the client receives it. But in applications with middleware,
    it passes through a set of stages, like logging, authentication, session validation,
    and so on, and then proceeds to the business logic. This is to filter the wrong
    requests from interacting with the business logic. The most common use cases are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察图表，请求的旅程始于客户端。在没有中间件的应用程序中，请求到达API服务器，并将由某个函数处理程序处理。响应立即从服务器发送回来，客户端接收到它。但在具有中间件的应用程序中，它通过一系列阶段，如日志记录、身份验证、会话验证等，然后继续到业务逻辑。这是为了过滤错误的请求，防止其与业务逻辑交互。最常见的用例有：
- en: Use a logger to log each and every request hitting the REST API
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录器记录每个请求命中REST API
- en: Validate the session of the user and keep the communication alive
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户会话并保持通信活动
- en: Authenticate the user, if not identified
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户未经身份验证，则对用户进行身份验证
- en: Write custom logic to scrap the request data
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义逻辑以获取请求数据
- en: Attach properties to responses while serving the client
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为客户端提供服务时附加属性到响应
- en: With the help of middleware, we can keep the housekeeping work, like authentication,
    in its proper place. Let us create a basic middleware and tamper an HTTP request
    in Go.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 借助中间件，我们可以将诸如身份验证之类的杂务工作保持在适当的位置。让我们创建一个基本的中间件并在Go中篡改HTTP请求。
- en: Middleware functions should be defined when a piece of code needs to be executed
    for every request or subset of HTTP requests. Without them, we need to duplicate
    the logic in each and every handler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要为每个请求或HTTP请求子集执行一段代码时，应该定义中间件函数。如果没有它们，我们需要在每个处理程序中重复逻辑。
- en: Creating a basic middleware
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本中间件
- en: Building middleware is simple and straightforward. Let us build a program based
    on the knowledge gained from the second chapter. If you are not familiar with
    closure functions, a closure function returns another function. This principle
    helps us write middleware. The first thing we should do is implement a function
    that satisfies the http.Handler interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建中间件简单而直接。让我们根据第二章所学的知识构建一个程序。如果您对闭包函数不熟悉，闭包函数返回另一个函数。这个原则帮助我们编写中间件。我们应该做的第一件事是实现一个满足http.Handler接口的函数。
- en: 'A sample closure called `closure.go` looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`closure.go`的示例闭包如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run this code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Numbers will be generated and printed using tab spaces:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数字将使用制表符生成并打印：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are creating a closure function called generator and calling it to get a
    new number. A generator pattern generates a new item each time, based on given
    conditions. The inner function getting returned is an anonymous function with
    no arguments and one return type of integer. The variable `i` that is defined
    inside the outer function is available to the anonymous function, making it useful
    to compute logic in the future. The other good example application of closure
    is creating a counter. You can implement it by following the same logic applied
    in the preceding code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为generator的闭包函数，并调用它以获取一个新的数字。生成器模式根据给定条件每次生成一个新项。返回的内部函数是一个匿名函数，没有参数，一个整数类型的返回类型。在外部函数中定义的变量`i`可用于匿名函数，使其在将来计算逻辑时有用。闭包的另一个很好的示例应用是创建一个计数器。您可以通过遵循前面代码中应用的相同逻辑来实现它。
- en: In Go, the function signature of the outer function should exactly match the
    anonymous function's signature. In the previous example, `func() int` is the signature
    for both the outer and inner functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，外部函数的函数签名应该与匿名函数的函数签名完全匹配。在前面的例子中，`func() int`是外部和内部函数的签名。
- en: 'This example is given to understand how closure works in Go. Now, let us use
    this concept to compose our first middleware:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是为了理解闭包在Go中是如何工作的。现在，让我们使用这个概念来组合我们的第一个中间件：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let us run the code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行代码：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you do a CURL request or see `http://localhost:8000` in your browser, the
    console will receive this message:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用CURL请求或在浏览器中查看`http://localhost:8000`，控制台将收到此消息：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you observe the middleware illustration diagram provided before, the request
    phase is pointed to by the right arrow, and the response is the left one. This
    program is actually the one in the rightmost rectangle, that is, `CustomMiddleware`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察之前提供的中间件示意图，请求阶段由右箭头指向，响应是左箭头。这个程序实际上是最右边的矩形，也就是`CustomMiddleware`。
- en: 'In simple steps, the preceding program breaks down into this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，前面的程序可以分解为这样：
- en: Create a handler function by passing the main handler function (`mainLogic`)
    to `http.HandlerFunc()`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将主处理程序函数（`mainLogic`）传递给`http.HandlerFunc()`来创建一个处理程序函数。
- en: Create a middleware function that accepts a handler and returns a handler.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个接受处理程序并返回处理程序的中间件函数。
- en: The method `ServeHTTP` allows a handler to execute the handler logic that is mainLogic.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法`ServeHTTP`允许处理程序执行处理程序逻辑，即`mainLogic`。
- en: The `http.Handle` function expects an HTTP handler. By taking that into consideration,
    we wrapped up our logic in such a way that, finally, a handler gets returned,
    but the execution is modified.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Handle`函数期望一个HTTP处理程序。考虑到这一点，我们以这样一种方式包装我们的逻辑，最终返回一个处理程序，但执行被修改了。'
- en: We are passing the main handler into the middleware. Then middleware takes it
    and returns a function while embedding this main handler logic in it. This makes
    all the requests coming to the handler pass through the middleware logic.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将主处理程序传递给中间件。然后中间件接管并返回一个函数，同时将主处理程序逻辑嵌入其中。这样，所有发送到处理程序的请求都会通过中间件逻辑。
- en: The order of the print statement explains the request's journey.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印语句的顺序解释了请求的过程。
- en: Finally, we are serving the server on the `8000` port.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们在`8000`端口上提供服务器。
- en: Go web frameworks like Martini, Gin provide middleware by default. We will see
    more about them in upcoming chapters. It is good for a developer to understand
    the low-level details of middleware.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 像Martini、Gin这样的Go Web框架默认提供中间件。我们将在接下来的章节中了解更多关于它们的内容。对于开发人员来说，了解中间件的底层细节是很有益的。
- en: 'The following diagram can help you understand how the logic flow happens in
    the middleware:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的图表可以帮助您理解中间件中逻辑流程的发生：
- en: '![](img/a4a887a7-9856-4aef-8414-9841ccb57e58.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4a887a7-9856-4aef-8414-9841ccb57e58.png)'
- en: Multiple middleware and chaining
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个中间件和链接
- en: 'In the previous section, we built a single middleware to perform an action
    before or after the request hits the handler. It is also possible to chain a group
    of middleware. In order to do that, we should follow the same closure logic as
    the preceding section. Let us create a city API for saving city details. For simplicity''s
    sake, the API will have one POST method, and the body consists of two fields:
    city name and city area.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们构建了一个单个中间件，在请求到达处理程序之前或之后执行操作。也可以链接一组中间件。为了做到这一点，我们应该遵循与前一部分相同的闭包逻辑。让我们创建一个用于保存城市详细信息的城市API。为了简单起见，API将只有一个POST方法，主体包括两个字段：城市名称和城市面积。
- en: Let us think about a scenario where an API developer only allows the JSON media
    type from clients and also needs to send the server time in UTC back to the client
    for every request. Using middleware, we can do that.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，API开发人员只允许客户端使用JSON媒体类型，并且需要为每个请求将服务器时间以UTC格式发送回客户端。使用中间件，我们可以做到这一点。
- en: 'The functions of two middleware are:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 两个中间件的功能是：
- en: In the first middleware, check whether the content type is JSON. If not, don't
    allow the request to proceed
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个中间件中，检查内容类型是否为JSON。如果不是，则不允许请求继续进行。
- en: In the second middleware, add a timestamp called Server-Time (UTC) to the response
    cookie
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个中间件中，向响应cookie添加一个名为Server-Time（UTC）的时间戳
- en: 'First, let us create the `POST` API:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建`POST` API：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then give a CURL request:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后给一个CURL请求：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Go gives us the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go给了我们以下内容：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'CURL responses will be:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CURL的响应将是：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In order to chain, we need to pass the handler between multiple middlewares.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了链接，我们需要在多个中间件之间传递处理程序。
- en: 'Here is the program in simple steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是简单步骤中的程序：
- en: We created a REST API with a POST as the allowed method. It is not complete
    because we are not storing data to a database or file.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个允许POST方法的REST API。它还不完整，因为我们没有将数据存储到数据库或文件中。
- en: We imported the json package and used it to decode the POST body given by the
    client. Next, we created a structure that maps the JSON body.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入了`json`包，并用它解码了客户端提供的POST主体。接下来，我们创建了一个映射JSON主体的结构。
- en: Then, JSON got decoded and printed the information to the console.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，JSON被解码并将信息打印到控制台。
- en: 'Only one handler is involved in the preceding example. But now, for the upcoming
    task, the idea is to pass the main handler to multiple middleware handlers. The
    complete code looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中只涉及一个处理程序。但是，对于即将到来的任务，想法是将主处理程序传递给多个中间件处理程序。完整的代码看起来像这样：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if we run this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And run this for the CURL command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 并为CURL命令运行这个：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But if we try to remove `Content-Type:application/json` from the CURL command,
    the middleware blocks us from executing the main handler:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试从CURL命令中删除`Content-Type:application/json`，中间件会阻止我们执行主处理程序：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And the cookie will be set from the other middleware.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并且cookie将从另一个中间件设置。
- en: In the preceding program, we used log instead of the fmt package. Even though
    both do the same thing, log formats the output by attaching a timestamp of the
    log. It can also be easily directed to a file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们使用log而不是`fmt`包。尽管两者都是做同样的事情，但log通过附加日志的时间戳来格式化输出。它也可以很容易地定向到文件。
- en: 'There are a few interesting things in this program. The middleware functions
    we defined have quite common use cases. We can extend them to perform any action. The
    program is composed of many elements. If you read it function by function, the
    logic can be easily unwound. Take a look at the following points:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中有一些有趣的地方。我们定义的中间件函数具有相当常见的用例。我们可以扩展它们以执行任何操作。这个程序由许多元素组成。如果逐个函数地阅读它，逻辑可以很容易地展开。看一下以下几点：
- en: A struct called city was created to store city details, as in the last example.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个名为city的结构体来存储城市详情，就像上一个例子中一样。
- en: '`filterContentType` is the first middleware we added. It actually checks the
    content type of the request and allows or blocks the request from proceeding further.
    For checking, we are using `r.Header.GET` (content type). If it is application/json,
    we are allowing the request to call the `handler.ServeHTTP` function, which executes
    the `mainLogicHandler` code.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterContentType`是我们添加的第一个中间件。它实际上检查请求的内容类型，并允许或阻止请求继续进行。我们使用`r.Header.GET`（内容类型）进行检查。如果是application/json，我们允许请求调用`handler.ServeHTTP`函数，该函数执行`mainLogicHandler`代码。'
- en: '`setServerTimeCookie` is the second middleware that we designed to add a cookie
    to the response with a value of the server time. We are using Go''s time package
    to find the current UTC time in the Unix epoch.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setServerTimeCookie`是我们设计的第二个中间件，用于在响应中添加一个值为服务器时间的cookie。我们使用Go的`time`包来找到Unix纪元中的当前UTC时间。'
- en: For the cookie, we are setting `Name` and `Value`. The cookie also accepts another
    parameter called `Expire,` which tells the expiry time of the cookie.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于cookie，我们设置了`Name`和`Value`。cookie还接受另一个名为`Expire`的参数，用于告知cookie的过期时间。
- en: If the content type is not application/json, our application returns the 415-Media
    type not supported status code.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果内容类型不是application/json，我们的应用程序将返回415-不支持的媒体类型状态码。
- en: In the mainhandler, we are using `json.NewDecoder` to parse the JSON and fill
    them into the `city` struct.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在mainhandler中，我们使用`json.NewDecoder`来解析JSON并将其填充到`city`结构体中。
- en: '`strconv.FormatInt` allows us to convert an `int64` number to a string. If
    it is a normal `int`, then we use `strconv.Itoa`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strconv.FormatInt`允许我们将`int64`数字转换为字符串。如果是普通的`int`，那么我们使用`strconv.Itoa`。'
- en: 201 is the correct status code to be returned when the operation is successful.
    For all other methods, we are returning 405, that is, a method not allowed.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当操作成功时，返回的正确状态码是201。对于所有其他方法，我们返回405，即不允许的方法。
- en: 'The form of chaining we did here is readable for two to three middleware:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里进行的链式调用对于两到三个中间件是可读的：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If an API server wishes a request to go through many middlewares, then how can
    we make that chaining simple and readable? There is a very good library called
    Alice to solve this problem. It allows you to semantically order and attach your
    middleware to the main handler. We will see it briefly in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API服务器希望请求通过多个中间件，那么我们如何使这种链式调用简单且可读？有一个名为Alice的非常好的库可以解决这个问题。它允许您按语义顺序附加中间件到主处理程序。我们将在下一章中简要介绍它。
- en: Painless middleware chaining with Alice
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Alice轻松进行中间件链
- en: 'The Alice library reduces the complexity of chaining the middleware when the
    list of middleware is big. It provides us with a clean API to pass the handler
    to the middleware. In order to install it, use the go get command, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当中间件列表很大时，`Alice`库可以降低中间件链的复杂性。它为我们提供了一个清晰的API来将处理程序传递给中间件。为了安装它，使用`go get`命令，就像这样：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can import the Alice package in our program and use it straight away.
    We can modify the sections of the preceding program to bring the same functionality
    with improved chaining. In the import section, add `github.com/justinas/alice`,
    like the following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在程序中导入Alice包并立即使用它。我们可以修改前面程序的部分以带来改进的链式调用相同的功能。在导入部分，添加`github.com/justinas/alice`，就像以下代码片段：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, in the main function, we can modify the handler part like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在主函数中，我们可以修改处理程序部分，就像这样：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete code with these added changes is available as a file called `multipleMiddlewareWithAlice.go`
    in the `chapter 3` folder from the book's GitHub repository. With the knowledge
    of the preceding concepts, let us build a logging middleware with a library from
    the Gorilla toolkit called Handlers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些添加更改的完整代码可在书的GitHub存储库的`第3章`文件夹中的名为`multipleMiddlewareWithAlice.go`的文件中找到。在掌握了前面的概念之后，让我们使用Gorilla工具包中的Handlers库构建一个日志中间件。
- en: Using Gorilla's Handlers middleware for Logging
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gorilla的Handlers中间件进行日志记录
- en: 'The Gorilla Handlers package provides various kinds of middleware for common
    tasks. The most important ones in the list are:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla Handlers包提供了各种常见任务的中间件。列表中最重要的是：
- en: '`LoggingHandler`: For logging in Apache Common Log Format'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoggingHandler`：用于记录Apache通用日志格式'
- en: '`CompressionHandler`: For zipping the responses'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompressionHandler`：用于压缩响应'
- en: '`RecoveryHandler`: For recovering from unexpected panics'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecoveryHandler`：用于从意外的panic中恢复'
- en: 'Here, we use the `LoggingHandler` to perform API-wide logging. First, install
    this library using go get:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`LoggingHandler`来执行API范围的日志记录。首先，使用`go get`安装这个库：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This logging server enables us to create a server like a log with time and
    option. For example, when you see `apache.log`, you find something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日志服务器使我们能够创建一个带有时间和选项的日志服务器。例如，当你看到`apache.log`时，你会发现类似这样的内容：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The format is `IP-Date-Method:Endpoint-ResponseStatus`. Writing our own such
    middleware will take some effort. But Gorilla Handlers already implements it for
    us. Take a look at the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 格式是`IP-Date-Method:Endpoint-ResponseStatus`。编写我们自己的这样的中间件会需要一些工作。但是Gorilla Handlers已经为我们实现了它。看一下以下代码片段：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now run the server:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行服务器：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let us open `http://127.0.0.1:8000` in the browser, or do a CURL, and
    you will see the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在浏览器中打开`http://127.0.0.1:8000`，或者使用CURL，你将看到以下输出：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you observe, the last two logs are generated by the middleware. Gorilla `LoggingMiddleware`
    writes them at response time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察到，最后两个日志是由中间件生成的。Gorilla `LoggingMiddleware`在响应时写入它们。
- en: In the previous example, we always checked the API on localhost. In this example,
    we explicitly specified replacing localhost with `127.0.0.1` because the former
    will show as an empty IP in the logs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们总是在本地主机上检查API。在这个例子中，我们明确指定用`127.0.0.1`替换localhost，因为前者将显示为空IP在日志中。
- en: Coming to the program, we are importing the Gorilla Mux router and Gorilla handlers.
    Then we are attaching a handler called `mainLogic` to the router. Next, we are
    wrapping the router in the `handlers.LoggingHandler` middleware. It returns one
    more handler, which we can pass safely to http.ListenAndServe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 来到程序，我们正在导入Gorilla Mux路由器和Gorilla handlers。然后我们将一个名为`mainLogic`的处理程序附加到路由器上。接下来，我们将路由器包装在`handlers.LoggingHandler`中间件中。它返回一个更多的处理程序，我们可以安全地传递给http.ListenAndServe。
- en: You can try other middleware from handlers, too. This section's motto is to
    introduce you to Gorilla Handlers. There are many other external packages available
    for Go. There is one library worth mentioning for writing middleware directly
    on net/http. It is Negroni ([github.com/urfave/negroni](http://github.com/urfave/negroni)).
    It also provides the functionality of Alice, the Gorilla LoggingHandler. So please
    have a look at it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试其他中间件，比如handlers。这一节的座右铭是向你介绍Gorilla Handlers。Go还有许多其他外部包可用。有一个值得一提的库，用于直接在net/http上编写中间件。它是Negroni（[github.com/urfave/negroni](http://github.com/urfave/negroni)）。它还提供了Gorilla
    LoggingHandler的功能。所以请看一下。
- en: We can easily build cookie-based authentication middleware using a library called
    go.uuid ([github.com/satori/go.uuid](http://github.com/satori/go.uuid)) and cookies.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个叫做go.uuid的库（[github.com/satori/go.uuid](http://github.com/satori/go.uuid)）和cookies轻松构建基于cookie的身份验证中间件。
- en: What is RPC?
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是RPC？
- en: Remote Procedure Call (RPC) is an interprocess communication that exchanges
    information between various distributed systems. A computer called Alice can call
    functions (procedures) in another computer called Bob in protocol format and can
    get the computed result back. Without implementing the functionality locally,
    we can request things from a network that lies in another place or geographical
    region.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 远程过程调用（RPC）是在各种分布式系统之间交换信息的进程间通信。一台名为Alice的计算机可以以协议格式调用另一台名为Bob的计算机中的函数（过程），并获得计算结果。我们可以从另一个地方或地理区域的网络请求东西，而不需要在本地实现功能。
- en: 'The entire process can be broken down into the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以分解为以下步骤：
- en: Clients prepare function name and arguments to send
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端准备要发送的函数名和参数
- en: Clients send them to an RPC server by dialing the connection
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通过拨号连接将它们发送到RPC服务器
- en: The server receives the function name and arguments
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器接收函数名和参数
- en: The server executes the remote process
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器执行远程过程
- en: The message will be sent back to the client
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息将被发送回客户端
- en: The client collects the data from the request and uses it appropriately
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端收集请求的数据并适当使用它
- en: 'The server needs to expose its service for the client to connect and request
    a remote procedure. Take a look at the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器需要公开其服务，以便客户端连接并请求远程过程。看一下下面的图表：
- en: '![](img/7b0c08f9-936a-43f9-b7a1-f5b4addef8c5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b0c08f9-936a-43f9-b7a1-f5b4addef8c5.png)'
- en: Go provides a library to implement both the RPC server and RPC client. In the
    preceding diagram, the RPC client dials the connection with the details like the
    host and port. It sends two things along with the request. One is arguments and
    the reply pointer. Since it is a pointer, the server can modify it and send it
    back. Then the client can use the data filled into the pointer. Go has two libraries, net/rpc,
    and net/rpc/jsonrpc, for working with RPC. Let us write an RPC server that talks
    to the client and serves the server time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个库来实现RPC服务器和RPC客户端。在上图中，RPC客户端通过包含主机和端口等详细信息拨号连接。它发送两件事以及请求。一个是参数和回复指针。由于它是一个指针，服务器可以修改它并发送回来。然后客户端可以使用填入指针的数据。Go有两个库，net/rpc和net/rpc/jsonrpc，用于处理RPC。让我们编写一个RPC服务器，与客户端通信并提供服务器时间。
- en: Creating an RPC server
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个RPC服务器
- en: Let us create a simple RPC server that sends the UTC server time back to the
    RPC client. First, we start with the server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的RPC服务器，将UTC服务器时间发送回RPC客户端。首先，我们从服务器开始。
- en: 'The RPC server and RPC client should agree upon two things:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: RPC服务器和RPC客户端应该就两件事达成一致：
- en: Arguments passed
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递的参数
- en: Value returned
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回的值
- en: 'The types for the preceding two parameters should exactly match for both server
    and client:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数的类型应该完全匹配服务器和客户端：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We first create the Args struct. This holds information about arguments passed
    from the client (RPC) to the server. Then, we created a `TimeServer` number to
    register with the `rpc.Register`. Here, the server wishes to export an object
    of type `TimeServer(int64)`. `HandleHTTP` registers an HTTP handler for RPC messages
    to `DefaultServer`. Then we started a TCP server that listens on port 1234\. The
    `http.Serve` function is used to serve it as a running program. `GiveServerTime` is
    the function that will be called by the client, and the current server time is
    returned.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建Args结构。这个结构保存了从客户端（RPC）传递到服务器的参数信息。然后，我们创建了一个`TimeServer`数字来注册到`rpc.Register`。在这里，服务器希望导出一个类型为`TimeServer(int64)`的对象。`HandleHTTP`为RPC消息注册了一个HTTP处理程序到`DefaultServer`。然后我们启动了一个监听端口1234的TCP服务器。`http.Serve`函数用于将其作为一个运行程序提供。`GiveServerTime`是客户端将调用的函数，并返回当前服务器时间。
- en: 'There are a few points to note from the preceding example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中有几点需要注意：
- en: '`GiveServerTime` takes the `Args` object as the first argument and a reply
    pointer object'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GiveServerTime`以`Args`对象作为第一个参数和一个回复指针对象'
- en: It sets the reply pointer object but does not return anything except an error
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了回复指针对象，但除了错误之外没有返回任何东西
- en: The `Args` struct here has no fields because this server is not expecting the
    client to send any arguments
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的`Args`结构没有字段，因为此服务器不希望客户端发送任何参数
- en: Before running this program, let us write the RPC client, too. Both can be run
    simultaneously.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此程序之前，让我们也编写RPC客户端。两者可以同时运行。
- en: Creating an RPC client
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RPC客户端
- en: 'Now, the client also uses the same net/rpc package but uses different methods
    to dial to the server and get the remote function executed. The only way to get
    data back is to pass the reply pointer object along with the request, as shown
    in the following code snippet:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端也使用相同的net/rpc包，但使用不同的方法拨号到服务器并执行远程函数。获取数据的唯一方法是将回复指针对象与请求一起传递，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The client is performing the following things here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在这里执行以下操作：
- en: Do a `DialHTTP` to connect to the RPC server, which is running on the localhost
    on port `1234`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行`DialHTTP`连接到运行在本地主机端口`1234`上的RPC服务器。
- en: Call the `Remote` function with the `Name:Function`format with `args` and reply
    with the pointer object.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Name:Function`格式调用`Remote`函数，使用`args`并回复指针对象。
- en: Get the data collected into the `reply` object.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将收集的数据放入`reply`对象中。
- en: The **`Call` **function is sequential in nature.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Call` **函数是顺序性的。'
- en: 'Now we can run both the server and client to see them in action:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以同时运行服务器和客户端来看它们的运行情况：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This runs the server. Now open another shell tab and run this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务器。现在打开另一个shell选项卡并运行此命令：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now the server console will output the following UNIX time string:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器控制台将输出以下UNIX时间字符串：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See the magic? The client is running as an independent program. Here, both the
    programs can be on different machines and the computing can still be shared. This
    is the core concept of distributed systems. The tasks are divided and given to
    various RPC servers. Finally, the client collects the results and uses them for
    further actions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 看到魔术了吗？客户端作为独立程序运行。在这里，两个程序可以在不同的机器上运行，计算仍然可以共享。这是分布式系统的核心概念。任务被分割并分配给各种RPC服务器。最后，客户端收集结果并将其用于进一步的操作。
- en: Custom RPC code is only useful when the client and server are both written in
    Go. So in order to have the RPC server consumed by multiple services, we need
    to define the JSON RPC over HTTP. Then, any other programming language can send
    a JSON string and get JSON as a result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义RPC代码仅在客户端和服务器都是用Go编写时才有用。因此，为了让RPC服务器被多个服务使用，我们需要定义基于HTTP的JSON RPC。然后，任何其他编程语言都可以发送JSON字符串并获得JSON作为结果。
- en: RPC should be secured because it is executing the remote functions. Authorization
    is needed while collecting requests from the client.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: RPC应该是安全的，因为它正在执行远程函数。在从客户端收集请求时需要授权。
- en: JSON RPC using Gorilla RPC
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gorilla RPC进行JSON RPC
- en: We saw that the Gorilla toolkit helps us by providing many useful libraries.
    Then we explored Mux, Handlers, and now, the Gorilla RPC library. Using this,
    we can create RPC servers and clients that talk using a JSON instead of a custom
    reply pointer. Let us convert the preceding example into a much more useful one.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Gorilla工具包通过提供许多有用的库来帮助我们。然后，我们探索了Mux、Handlers，现在是Gorilla RPC库。使用这个，我们可以创建使用JSON而不是自定义回复指针进行通信的RPC服务器和客户端。让我们将前面的示例转换为一个更有用的示例。
- en: 'Consider this scenario. We have a JSON file on the server that has details
    of books (name, ID, author). The client requests book information by making an
    HTTP request. When the RPC server receives the request, it reads the file from
    the filesystem and parses it. If the given ID matches any book, then the server
    sends the information back to the client in the JSON format. We can install Gorilla
    RPC with the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况。服务器上有一个JSON文件，其中包含书籍的详细信息（名称、ID、作者）。客户端通过发出HTTP请求来请求书籍信息。当RPC服务器收到请求时，它从文件系统中读取并解析文件。如果给定的ID与任何书籍匹配，那么服务器将以JSON格式将信息发送回客户端。我们可以使用以下命令安装Gorilla
    RPC：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This package derives from the standard `net/rpc` package but uses a single
    HTTP request per call instead of persistent connections. Other differences compared
    to `net/rpc`: are explained in the following sections.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 该包源自标准的`net/rpc`包，但每次调用使用单个HTTP请求而不是持久连接。与`net/rpc`相比的其他差异：在以下部分中进行了解释。
- en: 'Multiple codecs can be registered in the same server. A codec is chosen based
    on the `Content-Type` header from the request. Service methods also receive the `http.Request`
    as a parameter. This package can be used on Google App Engine. Now, let us write
    an RPC JSON server. Here we are implementing the JSON1.0 specification. For 2.0,
    you should use Gorilla JSON2:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在同一个服务器中注册多个编解码器。编解码器是根据请求的`Content-Type`标头选择的。服务方法还接收`http.Request`作为参数。此包可用于Google
    App Engine。现在，让我们编写一个RPC JSON服务器。在这里，我们正在实现JSON1.0规范。对于2.0，您应该使用Gorilla JSON2：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This program might look different from the preceding RPC server implementation.
    It is because of the inclusion of the Gorilla **`Mux`, **Gorilla `rpc`, and `jsonrpc`
    packages. Let us run the preceding program before explaining what is happening.
    Run the server with the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可能与前面的RPC服务器实现不同。这是因为包含了Gorilla **`Mux`、**Gorilla `rpc`和`jsonrpc`包。在解释发生了什么之前，让我们运行前面的程序。使用以下命令运行服务器：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now where it the client? Here the client can be a CURL command since the RPC
    server is serving requests over HTTP. We need to post JSON with a book ID to get
    the details. So fire up another shell and execute this CURL request:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端在哪里？在这里，客户端可以是CURL命令，因为RPC服务器通过HTTP提供请求。我们需要发布JSON以获取详细信息。因此，打开另一个shell并执行此CURL请求：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output will be nice JSON, that served directly from the JSON RPC server:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一个漂亮的JSON，直接从JSON RPC服务器提供：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, coming to the program, we have a lot to understand. The documentation for
    creating RPC services is very limited. So the technique we used in the program
    can be applied to a wide variety of use cases. First, we are creating the `Args`
    and `Book`structs to hold the information about the JSON arguments passed and
    the book structure, respectively. We are defining a remote function called `GiveBookDetail`
    on a resource called `JSONServer`. This struct is a service created to register
    with the **`RegisterService` **function of the RPC server. If you notice, we are
    also registering the codec as JSON.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来到程序，我们有很多需要理解的地方。创建RPC服务的文档非常有限。因此，我们在程序中使用的技术可以应用于各种用例。首先，我们创建了`Args`和`Book`结构体，分别用于保存传递的JSON参数和书籍结构的信息。我们在名为`JSONServer`的资源上定义了一个名为`GiveBookDetail`的远程函数。这个结构体是一个服务，用于在RPC服务器的**`RegisterService`**函数中注册。如果您注意到，我们还注册了JSON编解码器。
- en: Whenever we get a request from the client, we load the JSON file called **`books.json` **into
    memory and then into the `Book` struct using JSON's **`Unmarshal` **method. `jsonparse`
    is the alias given for the Go package **`encoding/json` **because the JSON package
    from the Gorilla import has the same name. In order to remove conflict, we used
    an alias.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从客户端收到请求时，我们将名为**`books.json`**的JSON文件加载到内存中，然后使用JSON的**`Unmarshal`**方法加载到`Book`结构体中。`jsonparse`是给予Go包**`encoding/json`**的别名，因为Gorilla导入的JSON包具有相同的名称。为了消除冲突，我们使用了一个别名。
- en: The `reply` reference is passed to the remote function. In the remote function,
    we are setting the value of the reply with the matched book. If the ID sent by
    the client matches with any of the books in JSON, then the data is filled. If
    there is no match, then empty data will be sent back by the RPC server. In this
    way, one can create a JSON RPC to allow clients to be universal. Here, we didn't
    write a Go client. Any client can access data from the service.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`reply`引用被传递给远程函数。在远程函数中，我们使用匹配的书籍设置了回复的值。如果客户端发送的ID与JSON中的任何书籍匹配，那么数据就会被填充。如果没有匹配，那么RPC服务器将发送回空数据。通过这种方式，可以创建一个JSON
    RPC以允许客户端是通用的。在这里，我们没有编写Go客户端。任何客户端都可以从服务中访问数据。'
- en: Prefer JSON RPC when multiple client technologies need to connect to your RPC
    service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个客户端技术需要连接到您的RPC服务时，最好使用JSON RPC。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first looked into what middleware is, exactly, including
    how middleware processes a request and response. We then explored middleware code
    with a few practical examples. After that, we saw how to chain our middleware
    by passing one middleware to another. Then, we used a package called `Alice` for
    intuitive chaining. We also took a look at the Gorilla handlers middleware for
    logging. Next, we learned what an RPC is and how an RPC server and client can
    be built. After that, we explained what a JSON RPC is, and we saw how one can
    create a JSON RPC using Gorilla toolkit. We introduced many third-party packages
    for middleware and RPC, with examples.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先研究了中间件的确切含义，包括中间件如何处理请求和响应。然后，我们通过一些实际示例探讨了中间件代码。之后，我们看到了如何通过将一个中间件传递给另一个中间件来链接我们的中间件。然后，我们使用了一个名为`Alice`的包来进行直观的链接。我们还研究了Gorilla处理程序中间件用于日志记录。接下来，我们学习了RPC是什么，以及如何构建RPC服务器和客户端。之后，我们解释了什么是JSON
    RPC，并看到了如何使用Gorilla工具包创建JSON RPC。我们介绍了许多第三方中间件和RPC包，附有示例。
- en: In the next chapter, we are going to explore few famous web frameworks those
    further simplify the REST API creation. They have batteries included by possessing
    inbuilt middleware and HTTP routers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索一些著名的Web框架，这些框架进一步简化了REST API的创建。它们具有内置的中间件和HTTP路由器。
