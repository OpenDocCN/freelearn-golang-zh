- en: Working with PostgreSQL, JSON, and Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostgreSQL、JSON和Go进行工作
- en: In this chapter, we are going to look at SQL in the big picture. In previous
    chapters, we discussed SQLite3, which is a small database for quick prototyping.
    But when it comes to a production grade application, people prefer MySQL or PostgreSQL.
    Both are well proven in the web application space. First, we will discuss the
    internals of PostgreSQL and then move on to writing database models in Go. We
    will then try to realize the URL shortening service with a solid example.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从宏观角度看SQL。在之前的章节中，我们讨论了SQLite3，这是一个用于快速原型设计的小型数据库。但是，当涉及到生产级应用程序时，人们更喜欢MySQL或PostgreSQL。在Web应用程序领域，两者都经过了充分验证。首先，我们将讨论PostgreSQL的内部，然后转向在Go中编写数据库模型。然后，我们将尝试通过一个实例来实现URL缩短服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to the PostgreSQL database
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍PostgreSQL数据库
- en: Installing PostgreSQL and creating users and databases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PostgreSQL并创建用户和数据库
- en: Learning about `pq`, a database driver in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`pq`，Go中的数据库驱动程序
- en: Implementing a URL shortening service with PostgreSQL and a Base62 algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostgreSQL和Base62算法实现URL缩短服务
- en: Exploring the JSON store in PostgreSQL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索PostgreSQL中的JSON存储
- en: Introducing `gorm`, a powerful ORM for Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`gorm`，Go的强大ORM
- en: Implementation of an e-commerce REST API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施电子商务REST API
- en: Getting the code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7).
    In the previous chapter, we discussed protocol buffers and GRPC. But here, we
    come back to the REST API with JSON and see how PostgreSQL supplements JSON.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到本章的代码示例：[https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7)。在上一章中，我们讨论了协议缓冲区和GRPC。但是在这里，我们回到了使用JSON的REST
    API，并看看PostgreSQL如何补充JSON。
- en: Installing the PostgreSQL database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装PostgreSQL数据库
- en: 'PostgreSQL is an open-source database that can be installed on multiple platforms.
    On Ubuntu, it can be installed using the following commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL是一个可以安装在多个平台上的开源数据库。在Ubuntu上，可以使用以下命令进行安装：
- en: 'To add the repo to the package list:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储库添加到软件包列表中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To update the package list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新软件包列表：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This installs the database on an Ubuntu machine and starts a server on port
    `5432`.Now, in order to enter the database shell, use these commands. PostgreSQL
    creates a default user called `postgres` to log in. Take a look at the following
    command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Ubuntu机器上安装数据库并在端口`5432`上启动服务器。现在，为了进入数据库shell，使用以下命令。PostgreSQL创建一个名为`postgres`的默认用户以登录。看一下以下命令：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now the user has access to the database. Launch the PostgreSQL shell using
    the `psql` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以访问数据库。使用`psql`命令启动PostgreSQL shell：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This shows that PostgreSQL follows a different approach for entering into the
    shell compared to other similar databases such as MySQL or SQLite3\. On Windows,
    the installation is done by clicking the binary installer file. It is a GUI-based
    installation where the port and password for superuser should be supplied. Once
    the database is installed, we can check that using the **pgAdmin3** tool. The
    macOS X setup is similar to Ubuntu, except the installation is done through Homebrew.
    Take a look at the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明PostgreSQL与其他类似数据库（如MySQL或SQLite3）相比，采用了不同的进入shell的方法。在Windows上，通过单击二进制安装程序文件来进行安装。这是一个基于GUI的安装，应提供超级用户的端口和密码。安装数据库后，我们可以使用**pgAdmin3**工具进行检查。macOS
    X的设置与Ubuntu类似，只是安装是通过Homebrew完成的。看一下以下命令：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And then make the database server run even when the system is rebooted by using
    the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用以下命令使数据库服务器在系统重新启动时运行：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, the PostgreSQL server starts running and is available to store and retrieve
    data on macOS X.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，PostgreSQL服务器开始运行，并且可以在macOS X上存储和检索数据。
- en: Adding users and databases in PostgreSQL
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PostgreSQL中添加用户和数据库
- en: 'Now, we should know how to create a new user and database. For this, we are
    going to use Ubuntu/Mac as the general example. We do this in a shell called the `psql` shell.
    We can see all available commands in `psql` using the `\?`  command. In order
    to enter into `psql`, first change to the `postgres` user. On Ubuntu, you can
    do that using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该知道如何创建新用户和数据库。为此，我们将以Ubuntu/Mac为一般示例。我们在一个名为`psql`的shell中执行此操作。使用`\?`命令可以在`psql`中看到所有可用命令。为了进入`psql`，首先切换到`postgres`用户。在Ubuntu上，您可以使用以下命令来执行：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, it turns us into a user called `postgres`. Then, launch the `psql` shell
    using the `psql` command. If you type `\?` in there, you see the output of all
    available commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它将我们转换为一个名为`postgres`的用户。然后，使用`psql`命令启动`psql` shell。如果在其中输入`\?`，您将看到所有可用命令的输出：
- en: '![](img/a59458f4-5721-4fac-906b-ce4696b696f1.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a59458f4-5721-4fac-906b-ce4696b696f1.png)'
- en: 'To list all available users and their privileges, you will find a command in
    the `Informational` section of shell help, that is:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用用户及其权限，您将在shell帮助的`Informational`部分中找到一个命令，即：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A role is an access permission given to a user. The default role in that list
    is `postgres`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是授予用户的访问权限。列表中的默认角色是`postgres`：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command lists roles (users) with their attributes (what a role
    is allowed to do) and other options. For adding a new user, we just type this `psql` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令列出了角色（用户）及其属性（角色允许执行的操作）和其他选项。要添加新用户，我们只需输入此`psql`命令：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This creates a new user with the name `naren` and the password `passme123.`Now,
    give the permission to the user to create databases and further roles, using the
    following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`naren`的新用户和密码`passme123.`现在，使用以下命令为用户授予创建数据库和进一步角色的权限：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order to delete a user, just use the `DROP` command in the same context:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除用户，只需在相同上下文中使用`DROP`命令：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Don't try to change the password for the default `postgres` user.It is intended
    to be a sudo account, and should not be kept as a normal user. Instead, create
    a role and give require permissions for it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试更改默认`postgres`用户的密码。它旨在成为一个sudo帐户，不应该作为普通用户保留。相反，创建一个角色并为其分配所需的权限。
- en: 'Now we know how to create a role. Let us see a few more CRUD commands, which
    are really SQL commands that we see in other relational databases too. Take a
    look at the following table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建一个角色。让我们看看一些更多的CRUD命令，这些命令实际上是我们在其他关系数据库中看到的SQL命令。看一下下表：
- en: '| **Action** | **SQL command** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **SQL命令** |'
- en: '| Create database |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 创建数据库 |'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Create table |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 创建表 |'
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Insert into table |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 插入到表中 |'
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Update table |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 更新表 |'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Delete from table |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 从表中删除 |'
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Now, let us see from Go how we can talk to PostgreSQL and try to do the preceding
    operations using a simple example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从Go中看看如何与PostgreSQL交流，并尝试使用一个简单的例子来执行前面的操作。
- en: pq, a pure PostgreSQL database driver for Go
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pq，一个纯PostgreSQL数据库驱动程序
- en: 'In the previous chapters when we dealt with SQLite3, we used an external library
    called `go-sqlite3`.In the same way, a database driver library is available to
    bridge both Go and PostgreSQL. That library is called `pq`.We can install that
    library using the command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，当我们处理SQLite3时，我们使用了一个名为`go-sqlite3`的外部库。同样，有一个数据库驱动程序库可用于连接Go和PostgreSQL。该库称为`pq`。我们可以使用以下命令安装该库：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After getting this library, we need to use it in a similar way to SQLite3\.
    The API will be in line to the `database/sql`package of Go. In order to create
    a new table, we should initialize the DB. To create a new database, just type
    this command from the `psql` shell, as shown in the following command; it is a
    one-time thing:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 获得这个库之后，我们需要以与SQLite3相似的方式使用它。API将与Go的`database/sql`包一致。为了创建一个新表，我们应该初始化DB。要创建一个新数据库，只需在`psql`
    shell中输入以下命令，如下所示；这是一次性的事情：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we will write a small code illustration that explains the usage of the `pq`
    driver. Create a directory called `models` in your `$GOPATH`. Here, my `GOPATH`
    is `/home/naren/workspace/`.Similar to all the previous examples in the former
    chapters, we will create our packages and application sources in the `src/` directory:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个小的代码示例，解释了`pq`驱动程序的用法。在你的`$GOPATH`中创建一个名为`models`的目录。在这里，我的`GOPATH`是`/home/naren/workspace/`。与前几章中的所有示例一样，我们将在`src/`目录中创建我们的包和应用程序源代码：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, add a file called `web_urls.go`.This file is going to have the table creation
    logic:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`web_urls.go`的文件。这个文件将包含表创建逻辑：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are importing the `pq` library here. We are using the `sql.Open`function
    to start a new database connection pool. If you observe the connection string,
    it consists of multiple parts. Take a look at the following diagram:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里导入了`pq`库。我们使用`sql.Open`函数来启动一个新的数据库连接池。如果你观察连接字符串，它由多个部分组成。看一下下图：
- en: '![](img/c5cf7c9a-a38f-4642-a72b-54de1f5c7c41.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5cf7c9a-a38f-4642-a72b-54de1f5c7c41.png)'
- en: 'The connection string should consist of the database type, the `username:password`
    pair, the database server IP, and the sslmode settings. We are then creating a
    table called `web_url`. All the error handlers are there to specify if something
    goes wrong. The `InitDB` function returns the database connection object to whatever
    program imports the function. Let us write the main program to use this package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串应该包括数据库类型、`username:password`对、数据库服务器IP和sslmode设置。然后我们创建一个名为`web_url`的表。所有的错误处理程序都在那里，以指定如果出现问题。`InitDB`函数将数据库连接对象返回给导入该函数的任何程序。让我们编写主程序来使用这个包：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This program imports the `models` package and uses the `InitDB`function from
    it. We are just printing that database connection, which will be an address. If
    you run the program, you will see the address of the object got printed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序导入了`models`包，并使用了其中的`InitDB`函数。我们只是打印了数据库连接，这将是一个地址。如果你运行程序，你会看到对象的地址被打印出来：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This creates a `web_url` tablein the `mydb` database.We can crosscheck that
    by entering into the `psql` shell and typing:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`mydb`数据库中创建一个`web_url`表。我们可以通过进入`psql` shell并输入以下内容来交叉检查：
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It connects the user to `mydb` database and lists all available tables, as
    shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它将用户连接到`mydb`数据库并列出所有可用的表，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In PostgreSQL, the AUTO INCREMENT type needs to be replaced by SERIAL while
    providing a schema for a table creation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中，AUTO INCREMENT类型需要在为表创建提供模式时替换为SERIAL。
- en: Implementing a URL shortening service using Postgres and pq
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postgres和pq实现URL缩短服务
- en: 'Let us write the URL shortening service to explain all the concepts we discussed
    in the preceding section. Before that, let us design a package that implements
    the Base62 algorithm with encoding/decoding functions. The URL shortening technique
    needs the Base62 algorithm to convert a long URL to short, and vice versa. We
    then write a solid example to show how this encoding works. Create a directory
    called `base62`in the `GOPATH`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写URL缩短服务来解释我们在前一节讨论的所有概念。在那之前，让我们设计一个实现Base62算法的包，其中包括编码/解码函数。URL缩短技术需要Base62算法来将长URL转换为短URL，反之亦然。然后，我们编写一个实例来展示这种编码是如何工作的。在`GOPATH`中创建一个名为`base62`的目录：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, add a file called `encodeutils.go`, which houses our encode and decode
    functions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个名为`encodeutils.go`的文件，其中包含我们的编码和解码函数。
- en: Defining the Base62 algorithm
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Base62算法
- en: 'We saw how the Base62 algorithm works in the previous chapters. Here is the
    solid implementation of that algorithm. The logic is purely mathematical and can
    be found everywhere on the web. Take a look at the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中看到了Base62算法的工作原理。这是该算法的坚实实现。这个逻辑是纯数学的，可以在网上找到。看一下下面的代码：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding program, we defined two functions called `ToBase62` and `ToBase10`.The
    first one takes an integer and generates a `base62` string, and the latter one
    reverses the effect; that is, it takes a `base62` string and gives the original
    number. In order to illustrate this, let us create a simple program that uses
    both the functions to show encoding/decoding:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述程序中，我们定义了两个名为`ToBase62`和`ToBase10`的函数。第一个函数接受一个整数并生成一个`base62`字符串，而后一个函数则反转了这个效果；也就是说，它接受一个`base62`字符串并给出原始数字。为了说明这一点，让我们创建一个简单的程序，使用这两个函数来展示编码/解码：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following content to it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到其中：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we are using the functions from the `base62` packageand trying to see
    the output. If we run this program (from `$GOPATH/src/github.com/narenaryan`)
    using the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`base62`包中的函数，并尝试查看输出。如果我们使用以下命令运行这个程序（从`$GOPATH/src/github.com/narenaryan`）：
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It prints:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印出：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`base62` encoding of `100` is `1C`. This is because the index 100 shrunk to
    `1C` in our `base62` logic:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`100`的`base62`编码是`1C`。这是因为索引100在我们的`base62`逻辑中缩小为`1C`：'
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The original number will be used to map the character in this base string.
    Then, the number is divided by 62 to find out the next characters. The beauty
    of this algorithm is creating a unique, shorter string for every given number.
    We use this technique to pass a database ID into the `ToBase62` algorithm and
    get a shorter string out. Whenever a URL shortening request comes to our server,
    it should perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数字将用于映射此基本字符串中的字符。然后，将数字除以62以找出下一个字符。这种算法的美妙之处在于为每个给定的数字创建一个独特的、更短的字符串。我们使用这种技术将数据库ID传递到`ToBase62`算法中，并得到一个更短的字符串。每当URL缩短请求到达我们的服务器时，它应执行以下步骤：
- en: Store the URL in the database and get the ID of that record inserted.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将URL存储在数据库中，并获取插入记录的ID。
- en: Pass this ID to the client as the API response.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此ID作为API响应传递给客户端。
- en: Whenever a client loads the shortened URL, it hits our API server.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当客户端加载缩短的URL时，它会访问我们的API服务器。
- en: The API server then converts the short URL back to the database ID and fetches
    the record from the original URL.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后API服务器将短URL转换回数据库ID，并从原始URL中获取记录。
- en: Finally, the client can use this URL to redirect to the original site.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，客户端可以使用此URL重定向到原始站点。
- en: 'We are going to write a Go project here that implements the preceding steps.
    Let us compose the program. I am creating a directory structure for our project.
    We take files from the preceding illustrations for handling encoding/decoding
    `base62` and also for database logic. The directory structure looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写一个Go项目，实现上述步骤。让我们组成程序。我正在为我们的项目创建一个目录结构。我们从前面的示例中获取处理编码/解码`base62`和数据库逻辑的文件。目录结构如下：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Copy this directory to `$GOPATH/src/github.com/narenaryan`. Once again, a small
    caution. Replace `narenaryan` with your username. Copy `encodeutils.go`and `models.go`from
    the preceding examples. Then, start writing the main program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将此目录复制到`$GOPATH/src/github.com/narenaryan`。再次小心。用你的用户名替换`narenaryan`。从前面的示例中复制`encodeutils.go`和`models.go`。然后，开始编写主程序：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First, we imported the `postgres` library and other necessary libraries. We
    imported our database session from the models. Next, we imported our encode/decode
    base62 algorithms to implement our logic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了`postgres`库和其他必要的库。我们从模型中导入了数据库会话。接下来，我们导入了我们的编码/解码base62算法来实现我们的逻辑：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `DBClient` is needed in order to pass the database driver between various
    functions. The record is the structure that resembles the record that gets inserted
    into the database. We defined two functions in our code called  **`GenerateShortURL`**
    and `GetOriginalURL` for adding the URL to the database and then fetching it back
    from DB respectively. As we already explained the internal technique of URL shortening,
    the client that is using this service will get the necessary response back. Let
    us run the program and see the output before jumping into further details:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`DBClient`以便在各种函数之间传递数据库驱动程序。记录是类似于插入数据库的记录的结构。我们在我们的代码中定义了两个函数`GenerateShortURL`和`GetOriginalURL`，用于将URL添加到数据库，然后从数据库中获取它。正如我们已经解释了URL缩短的内部技术，使用此服务的客户端将得到必要的响应。让我们在跳入更多细节之前运行程序并查看输出：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If your `$GOPATH/bin` is already in the system `PATH` variable, we can first
    install the binary and run it like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`$GOPATH/bin`已经在系统的`PATH`变量中，我们可以首先安装二进制文件，然后像这样运行它：
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And then just the program name:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只是程序名称：
- en: '[PRE37]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It is a best practice to install the binary because it is available systemwide.
    But for smaller programs, we can run `main.go` by visiting the directory of the
    program.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是安装二进制文件，因为它可以在整个系统中使用。但对于较小的程序，我们可以通过访问程序的目录来运行`main.go`。
- en: 'Now it runs the HTTP server and starts collecting requests for the URL shortening
    service. Open the console and type these CURL commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它运行HTTP服务器并开始收集URL缩短服务的请求。打开控制台并输入以下CURL命令：
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It returns the shortened string:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回缩短的字符串：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The encoded string is just `"1"`. Base62 algorithms start allocating shorter
    strings starting from one to a combination of alphanumeric letters. Now, if we
    need to retrieve the original URL we can perform a `GET` request:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的字符串只是`"1"`。Base62算法从`1`开始分配更短的字符串，直到组合字母数字。现在，如果我们需要检索原始URL，我们可以执行`GET`请求：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It returns the following JSON:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下JSON：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, the service can use this result to redirect the user to the original URL
    (site). Here, the generated string doesn't depend on the length of the URL because
    only the database ID is the criteria for encoding.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务可以使用此结果将用户重定向到原始URL（站点）。在这里，生成的字符串不取决于URL的长度，因为只有数据库ID是编码的标准。
- en: The `RETURNING` keyword needs to be added to the `INSERT` SQL command in PostgreSQL
    to fetch the last inserted database ID. This is not the case with MySQL or SQLite3
    `INSERT INTO web_url( ) VALUES($1) RETURNING id, record.URL`. This DB query returns
    the last inserted record's ID. If we drop that `RETURNING` keyword, the query
    returns nothing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL中需要向`INSERT` SQL命令添加`RETURNING`关键字以获取最后插入的数据库ID。这在MySQL或SQLite3的`INSERT
    INTO web_url( ) VALUES($1) RETURNING id, record.URL`中并非如此。这个DB查询返回最后插入记录的ID。如果我们去掉`RETURNING`关键字，查询将返回空。
- en: Exploring the JSON store in PostgreSQL
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PostgreSQL中探索JSON存储
- en: '**PostgreSQL >9.2** has a prominent feature 9.2" dbid="254735" called the JSON
    store. PostgreSQL introduced a new data type for storing the JSON data. PostgreSQL
    allows users to insert a `jsonb` field type,which holds the JSON string. It is
    quite useful in modeling the real-world data that has to be more flexible with
    the structure. PostgreSQL draws the best of both worlds by allowing us to store
    JSON strings as well as relational types.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**PostgreSQL >9.2**有一个突出的功能9.2" dbid="254735"叫做JSON存储。PostgreSQL引入了一种新的数据类型来存储JSON数据。PostgreSQL允许用户插入一个`jsonb`字段类型，它保存JSON字符串。它在对结构更加灵活的真实世界数据进行建模时非常有用。PostgreSQL通过允许我们存储JSON字符串以及关系类型来发挥了最佳的作用。'
- en: In this section, we will try to realize a few of the JSON models that we defined
    for e-commerce websites in the previous chapters. But here, we will use the JSON
    field to store and retrieve items in PostgreSQL. For accessing PostgreSQL's JSON
    store, the normal `pq` library is very tedious. So, in order to handle that better,
    we can use an **Object Relational Mapper** (**ORM**) called **GORM**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试实现我们在前几章中为电子商务网站定义的一些JSON模型。但在这里，我们将使用JSON字段在PostgreSQL中存储和检索项目。对于访问PostgreSQL的JSON存储，普通的`pq`库非常繁琐。因此，为了更好地处理它，我们可以使用一个称为**GORM**的**对象关系映射器**（**ORM**）。
- en: GORM, a powerful ORM for Go
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GORM，Go的强大ORM
- en: 'This ORM has the API for all operations that can be done in the `database/sql`package.
    We can install GORM using this command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ORM具有`database/sql`包中可以执行的所有操作的API。我们可以使用这个命令安装GORM：
- en: '[PRE42]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For full documentation about this ORM, visit, [http://jinzhu.me/gorm/](http://jinzhu.me/gorm/).
    Let us write a program that implements user and order type JSON models. A user
    can place an order. We will use the models that we defined in the previous chapter.
    We can create a new directory called `jsonstore` in `$GOPATH/src/github.com/narenaryan` and
    create a new directory for our model in it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此ORM的完整文档，请访问[http://jinzhu.me/gorm/](http://jinzhu.me/gorm/)。让我们编写一个实现用户和订单类型JSON模型的程序。用户可以下订单。我们将使用我们在上一章中定义的模型。我们可以在`$GOPATH/src/github.com/narenaryan`中创建一个名为`jsonstore`的新目录，并在其中为我们的模型创建一个新目录：
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, edit the `models.go` file to this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`models.go`文件编辑为：
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This looks similar to the model we defined earlier in this chapter. Here, a
    lot of things are new for us. Every model (table) we create should be represented
    as a struct in GORM. That is the reason we created two structs, `User` and `Order`.
    The first line should be `gorm.Model`.The other fields are the fields of the table.
    By default, an incrementing ID will be created. In the previous model for the
    URL shortener, we manually checked the existence of table before operating on
    it. But here, there is a function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在本章前面定义的模型类似。在这里，对我们来说有很多新的东西。我们在GORM中创建的每个模型（表）都应该表示为一个结构。这就是我们创建了两个结构，`User`和`Order`的原因。第一行应该是`gorm.Model`。其他字段是表的字段。默认情况下，将创建一个递增的ID。在之前的URL缩短器模型中，我们在操作之前手动检查表的存在。但在这里，有一个函数：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function creates the tables for structs passed as parameters. It makes
    sure that if tables exist already, it skips creation. If you observe carefully,
    we added a function for those structs, `TableName`.By default, all the table names
    that GORM creates are plural names (`users`is created for `User`).In order to
    force it to create the given names, we need to override that function. One more
    interesting thing is, in the structs, we used a field called `Data`. That is of
    type:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数为作为参数传递的结构创建表。它确保如果表已经存在，它会跳过创建。如果你仔细观察，我们为这些结构添加了一个函数，`TableName`。默认情况下，GORM创建的所有表名都是复数名（`User`的`users`被创建）。为了强制它创建给定的名称，我们需要覆盖该函数。另一个有趣的事情是，在结构中，我们使用了一个叫做`Data`的字段。它的类型是：
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Yes, it is a `jsonb` type string. We, for now, add its type as `string.PostgreSQL`
    and GORM takes care of handling it. We are then returning the database connection
    to whoever imports the `models` package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '是的，它是一个`jsonb`类型的字符串。我们现在将其类型添加为`string.PostgreSQL`，GORM会处理它。然后我们将数据库连接返回给导入`models`包的人。 '
- en: Implementing the e-commerce REST API
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现电子商务REST API
- en: 'Before jumping in, let us design the API specification table, which shows the
    REST API signatures for various URL endpoints. Refer to the following table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们设计API规范表，其中显示了各种URL终端的REST API签名。请参考以下表：
- en: '| **Endpoint** | **Method** | **Description** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **终端** | **方法** | **描述** |'
- en: '| `/v1/user/id` | `GET` | Get a user using ID |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/user/id` | `GET` | 使用ID获取用户 |'
- en: '| `/v1/user` | `POST` | Create a new user |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/user` | `POST` | 创建新用户 |'
- en: '| `/v1/user?first_name=NAME` | `GET` | Get all users by the given first name
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/user?first_name=NAME` | `GET` | 通过给定的名字获取所有用户 |'
- en: '| `/v1/order/id` | `GET` | Get an order with the given ID |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/order/id` | `GET` | 获取具有给定ID的订单 |'
- en: '| `/v1/order` | `POST` | Create a new order |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `/v1/order` | `POST` | 创建新订单 |'
- en: 'Now we come to the main program; let us add one more file to our `jsonstore`project.
    In this program, we will try to implement the first three endpoints. We suggest
    the implementation of the remaining two endpoints as an assignment for the reader.
    Take a look at the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到主程序；让我们向我们的`jsonstore`项目添加一个文件。在这个程序中，我们将尝试实现前三个终端。我们建议读者将剩下的两个终端的实现作为一个作业。看一下以下命令：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The program structure follows the same style as all the programs we have seen
    until now. We use Gorilla Mux as our HTTP router and import the database driver
    into our program:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 程序结构遵循我们到目前为止看到的所有程序的相同风格。我们使用Gorilla Mux作为我们的HTTP路由器，并将数据库驱动程序导入到我们的程序中：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There are three important aspects here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个重要的方面：
- en: We replaced the traditional driver with the GORM driver
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用GORM驱动程序替换了传统的驱动程序
- en: Used GORM functions for CRUD operations
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GORM函数进行CRUD操作
- en: We inserted JSON into PostgreSQL and retrieved results in the JSON field
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将JSON插入到PostgreSQL中，并在JSON字段中检索结果
- en: 'Let us explain all the elements in detail. First, we imported all the necessary
    packages. The interesting ones are:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释所有的元素。首先，我们导入了所有必要的包。有趣的是：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'GORM internally uses the `database/sql`package to some extent. We imported
    models from the package we created in the preceding code. Next, we created three
    functions, implementing the first three API specifications. They are `GetUsersByFirstName`,60;`GetUser`,
    and `PostUser`. Each function is inheriting the database driver and passed as
    the handler functions for the URL endpoints in the `main` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: GORM在内部在某种程度上使用了`database/sql`包。我们从我们在前面的代码中创建的包中导入了模型。接下来，我们创建了三个函数，实现了前三个API规范。它们是`GetUsersByFirstName`，`GetUser`和`PostUser`。每个函数都继承了数据库驱动程序，并作为`main`函数中URL端点的处理程序函数传递：
- en: '[PRE50]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, if we enter the first function, which is simple, these statements will
    grab our attention:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们进入第一个函数，这很简单，这些语句会吸引我们的注意：
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The preceding statement tells the DB to fetch the first record from the database
    with the given second parameter `ID`. It fills the data returned to the `user`
    struct. We are using `UserResponse` instead of the `User` struct in `GetUser`because
    `User` consists of the data field, which is a string. But, in order to return
    complete and proper JSON to the client, we need to convert the data into a proper
    struct and then marshal it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句告诉数据库从具有给定第二参数`ID`的数据库中获取第一条记录。它将返回的数据填充到`user`结构中。我们在`GetUser`中使用`UserResponse`而不是`User`结构，因为`User`包含数据字段，它是一个字符串。但是，为了向客户端返回完整和正确的JSON，我们需要将数据转换为一个适当的结构，然后进行编组：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here, we are creating an empty interface that can hold any JSON data. When
    we call the firstfunction using the driver, the user struct has a data field,
    which is a string. We need to convert that string to a struct and then send it
    along with other details in `UserResponse`. Now let us see this in action. Run
    the program using the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个可以容纳任何JSON数据的空接口。当我们使用驱动程序调用第一个函数时，用户结构具有一个数据字段，它是一个字符串。我们需要将该字符串转换为一个结构，然后将其与`UserResponse`中的其他详细信息一起发送。现在让我们看看这个过程。使用以下命令运行程序：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And make a few CURL commands to see the API response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 并制作一些CURL命令来查看API响应：
- en: 'Create user:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It returns the inserted record in the DB:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回了在数据库中插入的记录：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, if we `GET` the details of the inserted record:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们`GET`插入记录的详细信息：
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It returns all the details about the user:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回有关用户的所有详细信息：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Insert one more record for checking the first name API:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 插入一条记录以检查名字API：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This inserts our second record. Let us test our third API, `GetUsersByFirstName`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这插入了我们的第二条记录。让我们测试我们的第三个API，`GetUsersByFirstName`：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This returns all the users with the given first name:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有具有给定名字的用户：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The core motto of this project is to show how JSON can be stored and retrieved
    out of PostgreSQL. The special thing here is that we queried on the JSON field
    instead of the normal fields in the `User` table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的核心宗旨是展示如何从PostgreSQL中存储和检索JSON。这里的特殊之处在于，我们查询了JSON字段，而不是`User`表中的普通字段。
- en: 'Remember, PostgreSQL stores its users in a table called user. If you want to
    create a new user table, create it using `"user"` (double quotes). Even while
    retrieving use double quotes. Otherwise, the DB will fetch internal user details:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，PostgreSQL将其用户存储在一个名为user的表中。如果要创建一个新的用户表，请使用`"user"`（双引号）。即使在检索时也要使用双引号。否则，数据库将获取内部用户详细信息。
- en: '`SELECT * FROM "user"; // Correct way`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT * FROM "user"; // 正确的方式`'
- en: '`SELECT * FROM user; // Wrong way. It fetches database users `'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT * FROM user; // 错误的方式。它获取数据库用户`'
- en: This concludes our journey through PostgreSQL. There is a lot more to explore
    in Postgres. It brings the best of both worlds by allowing us to store relational
    as well as JSON data in the same table.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对PostgreSQL的旅程。在Postgres中还有很多可以探索的地方。它通过允许我们在同一张表中存储关系型数据和JSON数据，将两者的优点发挥到了极致。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our journey by installing PostgreSQL. We introduced
    PostgreSQL formally and tried to see all possible SQL queries for CRUD operations.
    We then saw how to add users and databases in PostgreSQL. We then installed and
    explained `pq`, a Postgres driver for the Go language. We explained how the driver
    API performs raw SQL queries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过安装PostgreSQL开始了我们的旅程。我们正式介绍了PostgreSQL，并尝试看到所有可能的CRUD操作的SQL查询。然后我们看到了如何在PostgreSQL中添加用户和数据库。然后我们安装并解释了`pq`，这是Go语言的Postgres驱动程序。我们解释了驱动程序API如何执行原始的SQL查询。
- en: Then came the implementation part of the URL shortening service; that REST service
    takes the original URL and returns a shortened string. It also takes the shortened
    URL and returns the original URL. We wrote a sample program to illustrate the
    Base62 algorithm that powers our service. We leveraged this algorithm in our service
    next and created a REST API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是URL缩短服务的实现部分；该REST服务接受原始URL并返回缩短的字符串。它还接受缩短的URL并返回原始URL。我们编写了一个示例程序来说明支持我们服务的Base62算法。我们随后在我们的服务中利用了这个算法，并创建了一个REST
    API。
- en: GORM is a well-known object-relational mapper for Go. Using an ORM, one can
    easily manage the database operations. GORM provides a few useful functions, such
    as `AutoMigrate` (create a table if one doesn't exist), for writing intuitive
    Go code over the traditional `database/sql` driver.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: GORM是Go语言中众所周知的对象关系映射器。使用ORM，可以轻松管理数据库操作。GORM提供了一些有用的函数，比如`AutoMigrate`（如果不存在则创建表），用于在传统的`database/sql`驱动程序上编写直观的Go代码。
- en: PostgreSQL also allows JSON storage (called the JSON store) past version 9.2\.
    It allows developers to get the benefits of relational databases with the JSON
    format. We can create indexes on JSON fields, query on JSON fields, and so on.
    We implemented a REST API for the e-commerce model we defined in the previous
    chapters using GORM. PostgreSQL is a well established, open-source relational
    database that can suffice our enterprise needs. The driver support for Go is exceptional
    with `pq`and `gorm`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL还允许在9.2版本之后存储JSON（称为JSON存储）。它允许开发人员以JSON格式获得关系数据库的好处。我们可以在JSON字段上创建索引，对JSON字段进行查询等。我们使用GORM为我们在前几章中定义的电子商务模型实现了REST
    API。PostgreSQL是一个成熟的、开源的关系数据库，可以满足我们的企业需求。Go语言的驱动程序支持非常出色，包括`pq`和`gorm`。
