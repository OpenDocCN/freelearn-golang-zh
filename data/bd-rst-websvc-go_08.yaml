- en: Building a REST API Client in Go and Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go构建REST API客户端和单元测试
- en: In this chapter, we are going to discuss how Go client applications work in
    depth. We will explore `grequests`, a Python request-style library that allows
    us to make API calls from the Go code. Then, we will write a client software that
    uses the GitHub API. In the course of this, we will try to learn about two wonderful
    libraries called `cli` and `cobra`.After these fundamentals, we will try to use
    the knowledge to write an API testing tool on the command line. Then we will see
    about Redis, an in-memory database which we can use to cache the API responses
    to backup the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入讨论Go客户端应用程序的工作原理。我们将探索`grequests`，这是一个类似Python请求的库，允许我们从Go代码中进行API调用。然后，我们将编写一个使用GitHub
    API的客户端软件。在此过程中，我们将尝试了解两个名为`cli`和`cobra`的出色库。在掌握了这些基础知识后，我们将尝试使用这些知识在命令行上编写API测试工具。然后我们将了解Redis，这是一个内存数据库，我们可以用它来缓存API响应以备份数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a client software?</li>
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是客户端软件？
- en: Basics for writing a command-line tool in Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中编写命令行工具的基础知识
- en: Introducing `grequests`, a Python request-like library in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`grequests`，Go中类似Python请求的库
- en: Inspecting GitHub REST API from a Go client
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Go客户端检查GitHub REST API
- en: Creating an API client in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中创建API客户端
- en: Caching an API for later use
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存API以备后用
- en: Creating a unit testing tool for the API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API创建一个单元测试工具
- en: Getting the code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter at the GitHub repository link [https://github.com/narenaryan/gorestful/tree/master/chapter8](https://github.com/narenaryan/gorestful/tree/master/chapter8).
    This chapter has examples that are a combination of single programs, as well as
    projects. So, copy the respective directory to your `GOPATH` to run the code samples
    properly. For the last example of unit testing the URL shortening service, the
    tests are available at [https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库链接[https://github.com/narenaryan/gorestful/tree/master/chapter8](https://github.com/narenaryan/gorestful/tree/master/chapter8)中获取本章的代码示例。本章包含单个程序和项目的组合示例。因此，请将相应的目录复制到您的`GOPATH`中，以正确运行代码示例。对于URL缩短服务的单元测试的最后一个示例，测试可在[https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7)中找到。
- en: Plan for building a REST API client
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建REST API客户端的计划
- en: Till now, we mainly focused on writing server-side REST APIs. Basically, they
    are server programs. In a few cases, such as GRPC, we also needed the client.
    But a true client program takes input from the user and executes some logic. For
    working with a Go client, we should know the `flag` library in Go. Before that,
    we should know how to make requests for an API from a Go program. In previous
    chapters, we assumed the clients could be CURL, Browser, Postman, and so on. But
    how do we consume an API from Go?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注编写服务器端REST API。基本上，它们是服务器程序。在一些情况下，例如GRPC，我们还需要客户端。但是真正的客户端程序会从用户那里获取输入并执行一些逻辑。要使用Go客户端，我们应该了解Go中的`flag`库。在此之前，我们应该知道如何从Go程序中对API进行请求。在之前的章节中，我们假设客户端可以是CURL、浏览器、Postman等。但是我们如何从Go中消费API呢？
- en: Command-line tools are equally important as web user interfaces to perform system
    tasks. In **business-to-business** (**B2B**) companies, the software is packaged
    as a single binary instead of having multiple different pieces. As a Go developer,
    you should know how to achieve the goal of writing apps for the command line.
    Then, that knowledge can be leveraged to create REST API-related web clients very
    easily and elegantly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具与Web用户界面一样重要，用于执行系统任务。在**企业对企业**（**B2B**）公司中，软件打包为单个二进制文件，而不是多个不同的部分。作为Go开发人员，您应该知道如何实现为命令行编写应用程序的目标。然后，可以利用这些知识轻松而优雅地创建与REST
    API相关的Web客户端。
- en: Basics for writing a command-line tool in Go
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中编写命令行工具的基础知识
- en: 'Go provides a basic library called `flag`. It refers to the command-line flags.
    Since it is already packed with the Go distribution, there is no need to install
    anything externally. We can see the absolute basics of writing the command-line
    tool. The `flag`package has multiple functions, such as `Int` and `String`, to
    handle the input given as command-line flags. Suppose we need to take a name from
    the user and print it back to the console. We use the `flag.String`method, as
    shown in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个名为`flag`的基本库。它指的是命令行标志。由于它已经打包在Go发行版中，因此无需外部安装任何内容。我们可以看到编写命令行工具的绝对基础知识。`flag`包具有多个函数，例如`Int`和`String`，用于处理作为命令行标志给定的输入。假设我们需要从用户那里获取一个名称并将其打印回控制台。我们使用`flag.String`方法，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let us write a short program for clear details. Create a file called `flagExample.go`in
    your `$GOPATH/src/github.com/narenaryan` and add the following content:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简短的程序以获得清晰的细节。在您的`$GOPATH/src/github.com/narenaryan`中创建一个名为`flagExample.go`的文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this program, we are creating a flag called `name`. It is a string pointer.
    `flag.String`takes three arguments. The first one is the name of the argument.
    The second and third are the default values of that flag and the help text, respectively.
    We then ask the program to parse all flag pointers. When we run the program, it
    actually fills the values from the command line to the respective variables. To
    access the value of a pointer, we use `*`. First build and then run the program
    using the following commands:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了一个名为`name`的标志。它是一个字符串指针。`flag.String`接受三个参数。第一个是参数的名称。第二个和第三个是该标志的默认值和帮助文本。然后我们要求程序解析所有标志指针。当我们运行程序时，它实际上会将值从命令行填充到相应的变量中。要访问指针的值，我们使用`*`。首先构建，然后使用以下命令运行程序：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates a binary in the same directory. We can run it like a normal executable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在相同的目录中创建一个二进制文件。我们可以像运行普通可执行文件一样运行它：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It gives the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出以下输出：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we didn''t give any argument called `name`. But we have assigned the
    default value to that argument. Go''s flag takes the default value and proceeds
    further. Now, in order to see what options are available and to know about them,
    ask for help:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有给出名为`name`的参数。但是我们已经为该参数分配了默认值。Go的标志获取默认值并继续。现在，为了查看可用的选项并了解它们，可以请求帮助：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the reason we passed help text as the third argument for the flag command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将帮助文本作为标志命令的第三个参数的原因。
- en: In Windows, `flagExample.exe` will be generated when we build a `.go` file.
    After that, from the command line, we can run the program by calling the program
    name.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，当我们构建一个`.go`文件时，将生成`flagExample.exe`。之后，我们可以通过调用程序名称从命令行运行该程序。
- en: 'Now try to add the argument, and it prints the given name:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试添加参数，它会打印给定的名称：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Both work fine as arguments which give the output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数都可以正常工作，给出输出：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we need multiple parameters to collect, we need to modify the preceding
    program to this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要收集多个参数，我们需要修改前面的程序为：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This takes two parameters, just one more addition of a different type. If we
    run this, we see the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要两个参数，只是另一种类型的额外添加。如果我们运行这个，我们会看到输出：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is exactly what we expected. Instead of using the pointers, we can bind
    a variable to the parsed output. This binding is done through the `init()`function,
    which will run in a Go program irrespective of whether main exists or not:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的。我们可以将变量绑定到解析输出，而不是使用指针。这种绑定是通过`init()`函数完成的，无论主函数是否存在，它都会在Go程序中运行：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this way, the value will directly come and sit in the variable. The complete
    rewrite of the preceding program  using the `init()` function is shown in the
    following code snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，值将直接传递并存储在变量中。使用`init()`函数完全重写前面的程序如下所示：
- en: '`initFlag.go`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`initFlag.go`：'
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output is exactly the same as the preceding program. Here, instead of using
    pointers, we are able to load data directly into our variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与前面的程序完全相同。在这里，我们可以直接将数据加载到我们的变量中，而不是使用指针。
- en: In Go, execution starts from the main program. But a Go program can have any
    number of `init` functions. If a package has an `init` function in it, that will
    be executed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，执行从`main`程序开始。但是Go程序可以有任意数量的`init`函数。如果一个包中有`init`函数，它将被执行。
- en: This `flag`library is very basic to work. But in order to write advanced client
    applications, we need to take the help of the library. In the next section, we
    look at such a library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`flag`库非常基础。但是为了编写高级客户端应用程序，我们需要借助该库。在下一节中，我们将看看这样一个库。
- en: CLI – a library for building beautiful clients
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI - 用于构建美观客户端的库
- en: 'This is the next step for a Go developer after playing with the `flag`package.
    It provides an intuitive API for creating command-line applications with ease.
    It allows us to collect arguments and flags. It could be quite handy for designing
    complex applications. To install the package, use the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在玩`flag`包后Go开发人员的下一步。它提供了一个直观的API，可以轻松创建命令行应用程序。它允许我们收集参数和标志。对于设计复杂的应用程序来说，这可能非常方便。要安装该包，请使用以下命令：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, let us write a program that does exactly the same job as the preceding
    programs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们编写一个与前面程序完全相同的程序：
- en: '`cli/cliBasic.go`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`cli/cliBasic.go`：'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is lengthier than the one before, but it is more expressive. We created
    a new app using the `cli.NewApp` function. It creates a new struct. We need to
    attach a few parameters to this struct. They are the `Flags` struct and the `Action`
    function. The `Flags`struct is a list that defines all possible flags for this
    application. The structure of `Flag`from** GoDoc** ([https://godoc.org/github.com/urfave/cli#Flag](https://godoc.org/github.com/urfave/cli#Flag))is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前的程序更长，但更具表现力。我们使用`cli.NewApp`函数创建了一个新的应用程序。它创建了一个新的结构。我们需要将一些参数附加到这个结构。它们是`Flags`结构和`Action`函数。`Flags`结构是一个列表，定义了该应用程序的所有可能的标志。`Flag`的结构来自**GoDoc**
    ([https://godoc.org/github.com/urfave/cli#Flag](https://godoc.org/github.com/urfave/cli#Flag))：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The inbuilt structs, such as `StringFlag` and `IntFlag`, implement this `Flag`
    interface. `Name`, `Value`, and `Usage` are straightforward. They are similar
    to the ones used in the `flag` package. The `Action` function takes the argument
    `cli.Context`.That context object holds all of the information about flags and
    command-line arguments. We can use them and apply logic to them. The `c.String`,
    `c.Int`, and other functions are used to look up the flag variables. For example,
    in the preceding program, `c.String("name")` fetches a flag variable whose name
    is `name`. This program runs the same as the previous programs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的结构，如`StringFlag`和`IntFlag`，实现了`Flag`接口。`Name`，`Value`和`Usage`都很简单。它们类似于`flag`包中使用的那些。`Action`函数接受`cli.Context`参数。该上下文对象包含有关标志和命令行参数的所有信息。我们可以使用它们并对它们应用逻辑。`c.String`，`c.Int`和其他函数用于查找标志变量。例如，在前面的程序中，`c.String("name")`获取了一个名为`name`的标志变量。该程序与以前的程序运行相同：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Collecting command-line arguments in CLI
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CLI中收集命令行参数
- en: 'There is a difference between command-line arguments and flags. The following
    diagram clearly specifies the distinction between them:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数和标志之间存在区别。以下图表清楚地说明了它们之间的区别：
- en: '![](img/aaebeab6-0adf-407a-87a8-5c2b5e00dd03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaebeab6-0adf-407a-87a8-5c2b5e00dd03.jpg)'
- en: Suppose that we have a command-line app called storeMarks for saving the marks
    of a student. It has a flag (called `save`) to specify whether details should
    be pushed to DB or not. The arguments that are given are the name and actual marks
    of the student. We already saw how to collect the flag values in the program.
    In this section, we will see how to collect program arguments in an expressive
    way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为storeMarks的命令行应用程序，用于保存学生的成绩。它有一个标志（称为`save`）来指定是否应将详细信息推送到数据库。给定的参数是学生的姓名和实际成绩。我们已经看到如何在程序中收集标志值。在本节中，我们将看到如何以富有表现力的方式收集程序参数。
- en: 'For collecting arguments, we use the `c.Args`function, where `c` is the `cli`
    context of the `Action` function. Create a directory called `cli` and add a new
    program, `cli/storeMarks.go`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集参数，我们使用`c.Args`函数，其中`c`是`Action`函数的`cli`上下文。创建一个名为`cli`的目录，并添加一个新程序`cli/storeMarks.go`：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`c.Args`keeps all of the arguments we entered. Since we know the order of the
    arguments, we deduced that the first argument is the name and the remaining values
    are the marks. We are checking a flag called `save` to save those details in a
    database or not (we don''t have database logic here, for simplicity). `app.Version`
    sets the version of the tool. All other things remain the same as the last program.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`c.Args`保存了我们输入的所有参数。由于我们知道参数的顺序，我们推断第一个参数是名称，其余的值是分数。我们正在检查一个名为`save`的标志，以确定是否将这些详细信息保存在数据库中（这里我们没有数据库逻辑，为简单起见）。`app.Version`设置了工具的版本。其他所有内容与上一个程序相同。'
- en: 'Let us run this program and see the output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个程序，看看输出：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the program:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we don''t give any flag, the default is `save=no`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不给出任何标志，默认值是`save=no`：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Everything looks good till now. But how can the tool display help when a user
    needs it? The `cli`library already creates a nice help section for the given app.
    Type any of these commands and help text will be autogenerated:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切看起来都很好。但是当用户需要时，该工具如何显示帮助？`cli`库已经为给定的应用程序创建了一个很好的帮助部分。输入任何这些命令，帮助文本将被自动生成：
- en: '`./storeMarks -h` (or)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks -h`（或）'
- en: '`./storeMarks -help` (or)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks -help`（或）'
- en: '`./storeMarks --help`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks --help`'
- en: '`./storeMarks help`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks help`'
- en: 'A nice help section appears, like this one showing version details and available
    flags (global options), commands, and arguments:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的帮助部分出现了，像这样显示版本详细信息和可用标志（全局选项）、命令和参数：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This actually makes building client applications easier. It is way faster and
    more intuitive than the internal `flag`package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上使构建客户端应用程序变得更容易。它比内部的`flag`包更快、更直观。
- en: Command-line tools are binaries that are generated after building the program.
    They need to be run with the options. It is like any system program and not related
    to Go compiler anymore
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具是在构建程序后生成的二进制文件。它们需要以选项运行。这就像任何系统程序一样，不再与Go编译器相关
- en: grequests – a REST API package for Go
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: grequests - 用于Go的REST API包
- en: 'The developers who worked on Python know about the `Requests`library. It is
    a clean, short library that is not included in the standard library of Python.
    The Go package `grequests`is inspired by that library. It provides a simple set
    of functions, using which we can make API requests such as `GET`, `POST`, `PUT`,
    and `DELETE`from our Go code. Using `grequests` allows us to encapsulate the inbuilt
    HTTP request and response. To install the `grequests` package for your Go, run
    the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python的开发人员知道`Requests`库。这是一个干净、简短的库，不包括在Python的标准库中。Go包`grequests`受到该库的启发。它提供了一组简单的函数，使用这些函数我们可以从Go代码中进行API请求，如`GET`、`POST`、`PUT`和`DELETE`。使用`grequests`允许我们封装内置的HTTP请求和响应。要为Go安装`grequests`包，请运行以下命令：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, see this basic program illustrating the use of the `grequests` library
    to make a `GET` request to a REST API. Create a directory called `grequests` in
    your Go source directory and add a file called `basicRequest.go`, as shown in
    the following code snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下这个基本程序，演示了使用`grequests`库向REST API发出`GET`请求。在Go源目录中创建一个名为`grequests`的目录，并添加一个名为`basicRequest.go`的文件，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `grequests` package has methods for performing all REST actions. The preceding
    program uses the `Get`function from the package. It takes two function arguments.
    The first one is the URL of the API, and the second one is the request parameters
    object. Since we are not passing any request parameters, the second argument is
    `nil` here. `resp`is returned from the request, and it has a function called `String()`that
    returns the response body:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`grequests`包具有执行所有REST操作的方法。上面的程序使用了包中的`Get`函数。它接受两个函数参数。第一个是API的URL，第二个是请求参数对象。由于我们没有传递任何请求参数，这里的第二个参数是`nil`。`resp`是从请求返回的，它有一个名为`String()`的函数，返回响应体：'
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is the JSON response returned by the `httpbin`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`httpbin`返回的JSON响应：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: API overview of grequests
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: grequests的API概述
- en: 'The most important thing to explore in `grequests` is not the HTTP functions,
    but the `RequestOptions` struct. It is a very big struct that holds various kinds
    of information on the type of API method. If the REST method is `GET`, the `RequestOptions`
    holds the `Params`property. If the method is a `POST`, the struct will have a
    `Data` property. Whenever we make a request, we get a response back. Let us see
    the structure of the response. From the official documentation, the response looks
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grequests`中探索的最重要的事情不是HTTP函数，而是`RequestOptions`结构。这是一个非常大的结构，包含有关API方法类型的各种信息。如果REST方法是`GET`，`RequestOptions`将包含`Params`属性。如果方法是`POST`，该结构将具有`Data`属性。每当我们发出请求，我们都会得到一个响应。让我们看看响应的结构。根据官方文档，响应如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Ok`property of response holds the information about whether a request
    is successful or not. If something went wrong, an error will be filled into the `Error`
    property. `RawResponse` is the Go HTTP response that will be used by other functions
    of the `grequests` response. `StatusCode` and `Header` store the status codes
    of the response and header details, respectively. There are a few functions in
    `Response` that are useful:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的`Ok`属性保存了有关请求是否成功的信息。如果出现问题，错误将填入`Error`属性。`RawResponse`是Go HTTP响应，将被`grequests`响应的其他函数使用。`StatusCode`和`Header`分别存储响应的状态代码和头部详细信息。`Response`中有一些有用的函数：
- en: JSON
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: XML
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML
- en: String
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: String
- en: Bytes
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bytes
- en: 'These can be called on the obtained response by passing an empty interface
    to the functions—`grequests/jsonRequest.go`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将空接口传递给函数来调用获取的响应，如`grequests/jsonRequest.go`：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We declared an interface to hold the JSON values. We then populated the `returnData`
    (empty interface) using the `resp.JSON`function. This program prints the map instead
    of plain JSON.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个接口来保存JSON值。然后使用`resp.JSON`函数填充了`returnData`（空接口）。该程序打印地图而不是纯粹的JSON。
- en: Getting comfortable with the GitHub REST API
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉GitHub REST API
- en: 'GitHub provides a well-written REST API to consume from the users. It opens
    up the data about users, repositories, repository statistics, and so on, to the
    clients through the API. The current stable version is v3. The API documentation
    can be found at [https://developer.github.com/v3/](https://developer.github.com/v3/).
    The root endpoint of the API is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub提供了一个很好的REST API供用户使用。它通过API向客户端开放有关用户、存储库、存储库统计等数据。当前稳定版本为v3。API文档可以在[https://developer.github.com/v3/](https://developer.github.com/v3/)找到。API的根端点是：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The other API will be added to this base API. Now let us see how to make a few
    queries and get data related to various elements. For the unauthenticated user,
    the rate limit is 60/hour, whereas for clients who are passing `client_id` (which
    one can get from the GitHub account), it is 5,000/hour.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其他API将添加到此基本API中。现在让我们看看如何进行一些查询并获取与各种元素相关的数据。对于未经身份验证的用户，速率限制为60/小时，而对于传递`client_id`（可以从GitHub帐户获取）的客户端，速率限制为5,000/小时。
- en: If you have a GitHub account (if not, it is recommended you create one), you
    can find access tokens in the Your Profile | Personal Access Tokens area or by
    visiting [https://github.com/settings/tokens](https://github.com/settings/tokens).
    Create a new access token using the Generate new tokenbutton. It asks for various
    permissions for types for the resource. Tick all of them. A new string will be
    generated. Save it to some private place. The token we have generated can be used
    to access the GitHub API (for longer rate limits).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有GitHub帐户（如果没有，建议您创建一个），您可以在您的个人资料|个人访问令牌区域或通过访问[https://github.com/settings/tokens](https://github.com/settings/tokens)找到访问令牌。使用`Generate
    new token`按钮创建一个新的访问令牌。它要求各种权限和资源类型。全部选中。将生成一个新的字符串。将其保存到某个私人位置。我们生成的令牌可以用于访问GitHub
    API（以获得更长的速率限制）。
- en: 'The next step is to save that access token to an environment variable, **`GITHUB_TOKEN`. **To
    do that, open your  **`~/.profile`** or **`~/.bashrc` **file and add this as the
    last line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将访问令牌保存到环境变量**`GITHUB_TOKEN`**中。为此，请打开您的**`~/.profile`**或**`~/.bashrc`**文件，并将其添加为最后一行：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`YOUR_GITHUB_ACCESS_TOKEN` is what was generated and saved previously from
    the GitHub account. Let us create a program for fetching all the repos of the
    given user. Create a new directory called `githubAPI`and create a program file
    called `getRepos.go`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`YOUR_GITHUB_ACCESS_TOKEN`是之前从GitHub帐户生成并保存的。让我们创建一个程序来获取给定用户的所有存储库。创建一个名为`githubAPI`的新目录，并创建一个名为`getRepos.go`的程序文件：'
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the program, and you will see the following output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，您将看到以下输出：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The printed output is not JSON but a list of the Go Repo `struct`. The preceding
    program illustrates how we can query the GitHub API and load that data into our
    custom struct:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出不是JSON，而是Go `Repo` `struct`的列表。前面的程序说明了我们如何查询GitHub API并将数据加载到我们的自定义结构中：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the struct we used for saving the details of our repository. The JSON
    returned has many fields, but for simplicity''s sake, we are just plucking a few
    important fields out of them:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们用于保存存储库详细信息的结构。返回的JSON有许多字段，但为简单起见，我们只是从中摘取了一些重要字段：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the first line, we are fetching the environment variable called `GITHUB_TOKEN`.
    The `os.Getenv`function returns the value of an environment variable by the given
    name. For GitHub to assume the origin of the `GET` request, we should set the
    authentication. For that, pass an argument to the `RequestOptions` struct. That
    argument should be a list of the username and password.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们正在获取名为`GITHUB_TOKEN`的环境变量。`os.Getenv`函数通过给定的名称返回环境变量的值。为了使GitHub假定`GET`请求的来源，我们应该设置身份验证。为此，将参数传递给`RequestOptions`结构。该参数应该是用户名和密码的列表。
- en: Creating a CLI tool as an API client for the GitHub REST API
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个CLI工具作为GitHub REST API的API客户端
- en: 'After looking at this example, we are able to easily access the GitHub API
    from our Go client. We can combine both of the techniques we learned in this chapter
    so far to come up with a command-line tool that consumes the GitHub API. Let us
    create a new command-line application which:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了这个例子之后，我们能够轻松地从我们的Go客户端访问GitHub API。到目前为止，我们可以结合本章学到的两种技术，来设计一个使用GitHub
    API的命令行工具。让我们创建一个新的命令行应用程序，其中：
- en: Provides options to get repo details by username
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供按用户名获取存储库详细信息的选项
- en: Uploads any file to GitHub gists (text snippets) with a given description
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定描述将任何文件上传到GitHub gists（文本片段）
- en: Authenticates using a personal access token
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用个人访问令牌进行身份验证
- en: Gists are snippets provided by GitHub to store text content. For more details,
    visit [https://gist.github.com](https://gist.github.com).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Gists是GitHub提供的存储文本内容的片段。有关更多详细信息，请访问[https://gist.github.com](https://gist.github.com)。
- en: 'Create a program called **`gitTool.go` **in the `githubAPI` directory. This
    will be the logic for the preceding program specification:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`githubAPI`目录中创建一个名为**`gitTool.go`**的程序。这将是前面程序规范的逻辑：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let us run the program before jumping into the details of explanation. It makes
    clear how we implemented the program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入解释细节之前，让我们运行程序。这清楚地说明了我们如何实现该程序：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It creates a binary in the same directory. If you type `./gitTool -h`, it shows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它在相同的目录中创建一个二进制文件。如果您键入`./gitTool -h`，它会显示：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you see the help commands, there are two commands, `fetch` and `create`. `fetch`
    fetches the repositories of a given user and `create` creates a `gist` with the
    supplied files. Let us create two sample files in the same directory of the program
    to test the `create` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看帮助命令，有两个命令，`fetch`和`create`。`fetch`获取给定用户的存储库，`create`创建一个带有提供的文件的`gist`。让我们在程序的相同目录中创建两个示例文件，以测试`create`命令：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the tool with the first command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令运行该工具：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It returns all repositories belonging to the great Linus Torvalds.The log message
    prints the struct that filled:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回所有属于伟大的Linus Torvalds的存储库。日志消息打印填充的结构：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let us check the second command. It creates the `gist` with the given
    description and a set of files as arguments:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查第二个命令。它使用给定的描述和一组文件作为参数创建`gist`：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It returns the JSON details about the created `gist`. It is a very lengthy
    JSON, so the output is skipped here. Then, open your [gist.github.com](https://gist.github.com/)
    account, and you will see the created `gist`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回有关创建的`gist`的JSON详细信息。这是一个非常冗长的JSON，所以这里跳过输出。然后，打开您的[gist.github.com](https://gist.github.com/)帐户，您将看到创建的`gist`：
- en: '![](img/ff1620ca-8fee-48f9-8bec-ebc3d694ef84.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff1620ca-8fee-48f9-8bec-ebc3d694ef84.png)'
- en: 'Now, coming to the explanation, we first imported `grequests`for making API
    calls and `cli`for building the command-line tool. Other imports are necessary
    to read files, log to the console, and encode JSON. We then defined three structs: `Repo`,
    `File`, and `Gist`. The GitHub `gists` API expects a JSON data to create:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来解释一下，我们首先导入`grequests`以进行API调用和`cli`以构建命令行工具。其他导入是必要的，以便读取文件，记录到控制台和编码JSON。然后我们定义了三个结构：`Repo`，`File`和`Gist`。GitHub的`gists`
    API需要JSON数据来创建：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `grequests` `POST` request takes `requestOptions` that have `Data` as the
    field. But the signature of it is `Map[string]string]`,which is not enough to
    create the preceding structure. `grequests`allows us to pass a JSON string with
    any structure to the API. We created structs so that data can be filled and marshalled
    into proper JSON to `POST` request get succeeded.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`grequests`的`POST`请求使用具有`Data`作为字段的`requestOptions`。但它的签名是`Map[string]string]`，这不足以创建前面的结构。`grequests`允许我们传递任何结构的JSON字符串到API。我们创建了结构，以便数据可以填充并编组成适当的JSON以使`POST`请求成功。'
- en: Then, we created two functions: `getStats` (that returns all repo details of
    a given user) and `createGist` (that creates new `gist` files with the given description
    and filenames). The second function is more interesting. We are passing a URL
    for the `POST` request, description, and `file_names` in the form of an `args`array.
    Then, we are iterating on each and every file and getting the content. We are
    adjusting our structs so that the final JSON body for the `POST` request will
    be in the same structure. Finally, we are making a `POST` request with the **`requestOptions` **that
    have our JSON.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了两个函数：`getStats`（返回给定用户的所有存储库详细信息）和`createGist`（使用给定的描述和文件名创建新的`gist`文件）。第二个函数更有趣。我们正在传递一个URL进行`POST`请求，描述和`file_names`以`args`数组的形式。然后，我们正在迭代每个文件并获取内容。我们正在调整我们的结构，以便`POST`请求的最终JSON主体将具有相同的结构。最后，我们使用具有我们的JSON的**`requestOptions`**进行`POST`请求。
- en: In this way, we combined both of the libraries to build an API client which
    can do any task. The beauty of Go is that we can ship the final binary in which
    both the logic for the command-line tool and the REST API calling the logic were
    buried.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们结合了两个库来构建一个可以执行任何任务的API客户端。Go的美妙之处在于我们可以将最终的二进制文件中包含命令行工具的逻辑和调用逻辑的REST
    API。
- en: For any Go program to read and understand soon, follow the `main` function and
    then step into the other functions. In that way, we can come across imported packages
    and their APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Go程序来说，要很快读懂，首先要遵循`main`函数，然后进入其他函数。这样，我们可以遇到导入的包及其API。
- en: Using Redis for caching the API data
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis缓存API数据
- en: '**Redis** is an in-memory database that can store key/value pairs. It best
    suits the caching use cases where we need to store information temporarily but
    for huge traffic. For example, sites such as BBC and The Guardian show the latest
    articles on the dashboard. Their traffic is so high, if documents (articles) are
    fetched from the database, they need to maintain a huge cluster of databases all
    the time. Since the given set of articles does not change (at least for hours),
    the BBC can maintain a cache which saves the articles. When the first customer
    visits the page, a copy is pulled from the DB, sent to the browser, and placed
    in the Redis cache. The next time a customer appears, the BBC application server
    reads content from Redis instead of going to the DB. Since Redis runs in primary
    memory, latency is reduced. The customer sees his page loaded in a flash. The
    benchmarks on the web can tell more about how efficiently a site can optimize
    its contents.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**是一个可以存储键/值对的内存数据库。它最适合缓存使用案例，其中我们需要临时存储信息，但对于大量流量。例如，像BBC和The Guardian这样的网站在仪表板上显示最新文章。他们的流量很大，如果从数据库中获取文档（文章），他们需要一直维护一个庞大的数据库集群。由于给定的一组文章不会改变（至少几个小时），BBC可以维护一个保存文章的缓存。当第一个客户访问页面时，从数据库中获取副本，发送到浏览器，并放入Redis缓存中。下次客户出现时，BBC应用服务器从Redis中读取内容，而不是去数据库。由于Redis运行在主内存中，延迟得到减少。客户可以看到他的页面在一瞬间加载。网络上的基准测试可以更多地告诉我们网站如何有效地优化其内容。'
- en: What if data is no longer relevant in Redis? (For example, the BBC updated its
    top stories.) Redis provides a way to expire the `keys:values` stored in it. We
    can run a scheduler that updates the Redis whenever the expiration time has passed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Redis中的数据不再相关怎么办？（例如，BBC更新了其头条新闻。）Redis提供了一种在其中存储的`keys:values`过期的方法。我们可以运行一个调度程序，当过期时间过去时更新Redis。
- en: Similarly, we can cache the third-party API responses for the given request
    (`GET`). We need to do it, because third-party systems like GitHub are giving
    us a rate limit (telling us to be conservative). For a given `GET URL`, we can
    store the `URL` as key and the `Response` as value. Whenever the same request
    is given within the next time (before key expiration), just pull the response
    out of Redis instead of hitting the GitHub servers. This method is applicable
    to our REST API, too. The most frequent and unchanged REST API can be cached in
    order to reduce the load on the primary database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为给定请求（`GET`）缓存第三方API的响应。我们需要这样做，因为像GitHub这样的第三方系统给了我们一个速率限制（告诉我们要保守）。对于给定的`GET
    URL`，我们可以将`URL`作为键，`Response`作为值进行存储。在下次给出相同请求时（在键过期之前），只需从Redis中提取响应，而不是访问GitHub服务器。这种方法也适用于我们的REST
    API。最频繁和不变的REST API可以被缓存，以减少对主数据库的负载。
- en: 'There is a wonderful library available for Go to talk to Redis. It is [https://github.com/go-redis/redis](https://github.com/go-redis/redis).
    It is a well-known library which many developers suggest you use. The following
    diagram illustrates the concept very well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个很棒的库可以与Redis通信。它是[https://github.com/go-redis/redis](https://github.com/go-redis/redis)。这是一个众所周知的库，许多开发人员建议您使用。下图很好地说明了这个概念：
- en: '![](img/4ec5f6f5-dcf7-4cc9-b427-14e8ce28865e.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ec5f6f5-dcf7-4cc9-b427-14e8ce28865e.jpg)'
- en: One caveat to note here is the expiration of the API. A real-time API should
    not be cached because of its dynamic nature. Caching brings performance optimization
    to our plate, as well as a few headaches. Be careful while caching. There are
    many better practices available globally. Please go through them to get an understanding
    of various architectures.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个问题是API的过期。实时API不应该被缓存，因为它具有动态性。缓存为我们带来了性能优化，但也带来了一些麻烦。在进行缓存时要小心。全球有许多更好的实践方法。请仔细阅读它们，以了解各种架构。
- en: Creating a unit testing tool for our URL shortening service
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的URL缩短服务创建一个单元测试工具
- en: 'In the previous chapter, we created a URL shortening service. The structure
    of the URL shortener project we worked on previously looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个URL缩短服务。我们之前工作的URL缩短器项目的结构如下：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `main.go` file, we created two API handlers: one for `GET` and one for `POST`.
    We are going to write the unit tests for both of those handlers. Add a file called
    `main_test.go` in the root directory of the project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，我们创建了两个API处理程序：一个用于`GET`，一个用于`POST`。我们将为这两个处理程序编写单元测试。在项目的根目录中添加一个名为`main_test.go`的文件：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to test our API, we need to test our API handlers:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的API，我们需要测试我们的API处理程序：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There is a testing package in Go named `testing`. It allows us to create a few
    assertions and lets us make a pass or fail test. We are testing the API `TestGetOriginalURL`by
    making a simple HTTP request. Make sure you have at least one record inserted
    in the database. The advanced testing topics of database connections are out of
    the scope of this book. We can test this using Go test command inside the project
    directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Go中有一个名为`testing`的测试包。它允许我们创建一些断言，并让我们进行通过或失败的测试。我们正在通过进行简单的HTTP请求来测试API `TestGetOriginalURL`。确保数据库中至少插入了一条记录。数据库连接的高级测试主题超出了本书的范围。我们可以在项目目录中使用Go
    test命令进行测试。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We started our chapter with understanding client software: how a software client
    works and how we can create a few. We saw the basics of writing a command-line
    application. CLI is a third-party package that enables us to create beautiful
    command-line applications. After installing it, we saw how to collect command-line
    arguments through the tool. We also explored commands and flags in our CLI application.
    Next, we looked into `grequests`,a package similar to Python requests to make
    API requests from Go code. We saw how to make `GET`, `POST`, and so on, requests
    from the client programs.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解客户端软件开始我们的章节：软件客户端的工作原理以及我们如何创建一些。我们了解了编写命令行应用程序的基础知识。CLI是一个第三方包，可以让我们创建漂亮的命令行应用程序。安装后，我们看到了如何通过工具收集命令行参数。我们还探讨了CLI应用程序中的命令和标志。接下来，我们研究了`grequests`，这是一个类似于Python
    requests的包，用于从Go代码中进行API请求。我们看到了如何从客户端程序中进行`GET`、`POST`等请求。
- en: We next explored the GitHub API on how to fetch details like repositories. With
    the knowledge of both concepts, we developed a client that lists the repositories
    for a given user and also creates a `gist` (a text file on GitHub). We introduced
    Redis architecture on how caching could help handle rate-limited API. Finally,
    we wrote a unit test for the URL shortening service we created in the previous
    chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了GitHub API如何获取仓库等详细信息。有了这两个概念的知识，我们开发了一个客户端，列出了给定用户的仓库，并创建了一个`gist`（GitHub上的文本文件）。我们介绍了Redis架构，说明了缓存如何帮助处理速率限制的API。最后，我们为上一章中创建的URL缩短服务编写了一个单元测试。
