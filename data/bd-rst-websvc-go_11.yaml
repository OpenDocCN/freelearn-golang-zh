- en: Using an API Gateway to Monitor and Metricize REST API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API网关监视和度量REST API
- en: Once we have developed our API, we need to expose it to the outside world. In
    that journey, we deploy them. But is that sufficient? Don't we need to track our
    API? Which clients are connecting? What is the latency of requests, and so on
    and so forth? There are many other post-API development steps that one should
    follow to make their API production grade. They are authentication, logging, rate
    limiting, and so on. The best way to add those features is to use an API gateway.
    In this chapter, we will explore an open-source API gateway called **Kong**. Open-source
    software is preferable to cloud providers because of the reduced risk of vendor
    lock. All the API gateways differ in the implementation but perform the same task.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开发了API，我们需要将其暴露给外部世界。在这个过程中，我们部署它们。但这足够了吗？我们不需要跟踪我们的API吗？哪些客户端正在连接？请求的延迟是多少，等等？有许多其他的API开发后步骤，人们应该遵循，使其API达到生产级别。它们是身份验证、日志记录、速率限制等。添加这些功能的最佳方式是使用API网关。在本章中，我们将探索一个名为Kong的开源API网关。与云提供商相比，开源软件更可取，因为减少了供应商锁定的风险。所有API网关在实现上有所不同，但执行相同的任务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why is an API gateway needed?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要API网关？
- en: Introducing Kong, an open-source API gateway
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kong，一个开源的API网关
- en: Example illustration in Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker中的示例说明
- en: Adding developed API to Kong
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将开发的API添加到Kong
- en: Logging in Kong
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kong中登录
- en: Authentication and rate limiting in Kong
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kong中的身份验证和速率限制
- en: Important commands from Kong CLI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kong CLI中的重要命令
- en: Getting the code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取代码
- en: You can get the code samples for this chapter at [https://github.com/narenaryan/gorestful/tree/master/chapter11](https://github.com/narenaryan/gorestful/tree/master/chapter11).
    The usage of the files in the chapter is explained in the respective sections.
    You can also import the Postman client collection (JSON file) from the repository
    to test the API, which we will walk through in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到本章的代码示例：[https://github.com/narenaryan/gorestful/tree/master/chapter11](https://github.com/narenaryan/gorestful/tree/master/chapter11)。本章中文件的用法在各自的部分中有解释。您还可以从存储库中导入Postman客户端集合（JSON文件）来测试API，我们将在本章中介绍。
- en: Why is an API gateway required?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要API网关？
- en: 'Suppose a company named XYZ developed the API for its internal purpose. There
    are two ways in which it exposes that API for external use:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个名为XYZ的公司为其内部目的开发了API。它以两种方式将API暴露给外部使用：
- en: Exposes it using authentication from known clients
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知客户端的身份验证进行暴露
- en: Exposes it as an API as a service
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其作为API服务公开
- en: In the first case, this API is consumed by the other services inside the company.
    Since they are internal, we don't restrict the access. But in the second case,
    since API details are given to the outside world, we need a broker in between
    to check and validate the requests. This broker is the API gateway. An API gateway
    is a broker that sits in between the client and the server and forwards the request
    to the server on passing specific conditions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，此API由公司内部的其他服务使用。由于它们是内部的，我们不限制访问。但在第二种情况下，由于API细节提供给外部世界，我们需要一个中间人来检查和验证请求。这个中间人就是API网关。API网关是一个位于客户端和服务器之间的中间人，并在满足特定条件时将请求转发到服务器。
- en: 'Now, XYZ has an API written in Go and also in Java. There are a few common
    things that apply to any API:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，XYZ有一个用Go和Java编写的API。有一些通用的事情适用于任何API：
- en: Authentication
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证
- en: Logging of requests and responses
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求和响应的日志记录
- en: Without an API gateway, we need to write another server that tracks things such
    as requests and authentication of the API. It is hectic to implement and maintain
    when new APIs keep being added to the organization. To take care of these basic
    things, an API gateway is a fine piece of middleware.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 没有API网关，我们需要编写另一个跟踪请求和API身份验证等内容的服务器。当新的API不断添加到组织中时，实施和维护是繁琐的。为了处理这些基本事项，API网关是一个很好的中间件。
- en: 'Basically, an API getaway does these things:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，API网关会执行以下操作：
- en: Logging
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Security
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Traffic control
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量控制
- en: Transformations
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: Logging is the way to track the requests and responses. If we need an organization-level
    logging in contrast to application level-logging in Go kit, we should enable logging
    in an API gateway. Security is how authentication works. It can be basic auth,
    token-based authentication, OAuth2.0, and so on. It is essential to restrict access
    to the API for the valid customers/clients.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是跟踪请求和响应的方式。如果我们需要组织级别的日志记录，与Go kit中的应用级别日志记录相反，我们应该在API网关中启用日志记录。安全性是身份验证的工作方式。它可以是基本身份验证，基于令牌的身份验证，OAuth2.0等。限制对有效客户端的API访问是至关重要的。
- en: 'Traffic control comes into play when an API is a paid service. When an organization
    sells the data as an API, It needs to limit the operations per client. For example,
    a client can make 10,000 API requests per month. The rate can be set according
    to the plan the client has opted for. This is a very important feature. Transformations
    are like modifying the request before it hits the application server or modifying
    the response before it is sent back to the client. Take a look at the following
    diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当API是付费服务时，流量控制就会发挥作用。当组织将数据作为API出售时，需要限制每个客户端的操作。例如，客户端每月可以发出10,000个API请求。速率可以根据客户选择的计划进行设置。这是一个非常重要的功能。转换就像在命中应用程序服务器之前修改请求，或者在发送回客户端之前修改响应。看一下以下图表：
- en: '![](img/acf612e1-8b37-48f8-9243-52a71936c46d.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acf612e1-8b37-48f8-9243-52a71936c46d.png)'
- en: We can see how we are able to add the preceding features to our web services.
    From the diagram, the API gateway can redirect requests to any given internal
    servers. The client sees all the APIs are under a single entity of the organization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到如何将上述功能添加到我们的Web服务中。从图表中，API网关可以将请求重定向到任何给定的内部服务器。客户端看到所有API都在组织的单个实体下。
- en: Kong, an open-source API gateway
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kong，一个开源的API网关
- en: 'Kong is an open-source API gateway and a microservices management layer, delivering
    high performance and reliability. It is a combination of two libraries worth mentioning.
    One is **OpenResty** and another one is **Nginx**. Kong is a wrapper around these
    two main components. OpenResty is a fully-fledged web platform that integrates
    Nginx and Lua. Lua is another programming language similar to Go. Kong is written
    in Lua. We use Kong as a tool for deploying our Go REST services. The main topics
    we cover are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kong是一个开源的API网关和微服务管理层，提供高性能和可靠性。它是两个值得一提的库的组合。一个是**OpenResty**，另一个是**Nginx**。Kong是这两个主要组件的包装器。OpenResty是一个完整的Web平台，集成了Nginx和Lua。Lua是一种类似于Go的编程语言。Kong是用Lua编写的。我们使用Kong作为部署我们的Go
    REST服务的工具。我们要讨论的主要主题是：
- en: Installation of Kong and the Kong database
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Kong和Kong数据库
- en: Adding our API to Kong
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的API添加到Kong
- en: Using the plugins
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插件
- en: Logging in Kong
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录Kong
- en: Rate limiting in Kong
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kong中进行速率限制
- en: Kong needs a database to run. It could be either Cassandra or PostgreSQL. Since
    we are already familiar with PostgreSQL, we chose it. Where to install them? For
    illustration, we can install them on our local machine, but there is a drawback;
    it can screw up our machine. In order to test the setup, we are going to use Docker.
    Docker can create containerized applications and run them in a predictable, isolated
    environment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kong需要一个数据库才能运行。它可以是Cassandra或PostgreSQL。由于我们已经熟悉PostgreSQL，我们选择了它。在哪里安装它们？为了说明问题，我们可以在本地机器上安装它们，但有一个缺点；它可能会损坏我们的机器。为了测试设置，我们将使用Docker。Docker可以创建容器化应用程序并在可预测的隔离环境中运行它们。
- en: 'Using Kong, we can hide our API under a gateway. We can create consumers (clients)
    for our API. Kong does everything through a REST API. Kong has two kinds of API:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kong，我们可以将我们的API隐藏在一个网关下。我们可以为我们的API创建消费者（客户端）。Kong通过REST API执行所有操作。Kong有两种API：
- en: Application API (runs on port `8000`)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序API（运行在端口`8000`上）
- en: Admin API (runs on port `8001`)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理API（运行在端口`8001`上）
- en: Using an application API, we can access our web services. An admin API allows
    us to add/remove APIs under the gateway. We will see these things in more detail
    in upcoming sections. For more details about Kong, visit [https://getkong.org/](https://getkong.org/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序API，我们可以访问我们的Web服务。管理API允许我们在网关下添加/删除API。我们将在接下来的部分中更详细地了解这些内容。有关Kong的更多详细信息，请访问[https://getkong.org/](https://getkong.org/)。
- en: Introducing Docker
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker
- en: Docker is a virtualization tool that can create operating systems in the form
    of tiny containers. It is like multiple OS on a single host. Developers usually
    complain saying *working in my box* while facing deployment problems. Docker removes
    those situations by defining an OS environment in the form of images. A Docker
    image has all the information about a given OS at a given time. It allows us to
    replicate that environment any number of times.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个可以创建操作系统的虚拟化工具，以微小容器的形式。它就像在单个主机上有多个操作系统。开发人员通常抱怨说*在我的环境中工作*，同时面临部署问题。Docker通过定义镜像形式的OS环境来消除这些情况。Docker镜像包含了在特定时间给定OS的所有信息。它允许我们任意多次地复制该环境。
- en: 'It was available for Linux initially but is now available for macOS X and Windows.
    For downloading and installing Docker, visit [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).
    For Windows and Mac, the binaries are available on the Docker website and can
    be easily installed. After installing, verify the Docker installation with the
    following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最初只适用于Linux，但现在适用于macOS X和Windows。要下载和安装Docker，请访问[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)。对于Windows和Mac，二进制文件可在Docker网站上找到并且可以轻松安装。安装后，使用以下命令验证Docker安装：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It will give the version number; always choose the latest Docker. Now that Docker
    is ready, let us run a few commands to install Kong. The upcoming section requires
    some knowledge of Docker. Please go through the wonderful articles on the web
    explaining the fundamentals of Docker if not confident enough.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提供版本号；始终选择最新的Docker。现在Docker准备就绪，让我们运行一些命令来安装Kong。接下来的部分需要一些Docker知识。如果不够自信，请阅读网上关于Docker基础知识的精彩文章。
- en: 'Our final goal is to create three containers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终目标是创建三个容器：
- en: Kong database
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kong数据库
- en: Go container
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go容器
- en: Kong application
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kong应用
- en: When these three containers run, it sets the stage for setting up a web service
    behind an API gateway.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当这三个容器运行时，它为在API网关后面设置Web服务的舞台。
- en: Installing a Kong database and Kong
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Kong数据库和Kong
- en: 'First, install the PostgreSQL DB. One condition is that we need to expose the
    `5432` port. The user and database name should be `kong`, and that should be passed
    as environment variables to the container:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装PostgreSQL DB。一个条件是我们需要暴露`5432`端口。用户和数据库名称应为`kong`，并且应作为环境变量传递给容器：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This command works in this way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的工作方式是这样的：
- en: Get me an image from the Docker repository called `postgres:9.4`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker存储库获取名为`postgres:9.4`的镜像。
- en: Give a name to the image called `kong-database`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给镜像命名为`kong-database`。
- en: Set environment variables in the container called `POSTGRES_USER` and `POSTGRES_DB`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`POSTGRES_USER`和`POSTGRES_DB`的容器中设置环境变量。
- en: 'This creates a Docker container by pulling a PostgreSQL image, which is hosted
    on the **DockerHub** ([https://hub.docker.com/](https://hub.docker.com/)) repository.
    Now, apply the migrations required by Kong by running one more Docker command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过拉取托管在**DockerHub**（[https://hub.docker.com/](https://hub.docker.com/)）存储库上的PostgreSQL镜像来创建一个Docker容器。现在，通过运行另一个Docker命令来应用Kong所需的迁移：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It applies the migrations on the previously created PostgreSQL DB container.
    The command has an option called `--rm`, which says, *remove this container once
    migrations are done*. Before installing the Kong container, let us prepare our
    Go service. It will be a simple project with a health check `GET` API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它在先前创建的PostgreSQL DB容器上应用迁移。该命令有一个名为`--rm`的选项，表示*一旦迁移完成，删除此容器*。在安装Kong容器之前，让我们准备好我们的Go服务。这将是一个简单的项目，其中包含一个健康检查`GET`
    API。
- en: 'Now, go to any directory on the host machine and create a project called `kongExample`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到主机上的任何目录并创建一个名为`kongExample`的项目：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a program called `main.go` inside that directory, which fetches the
    health check (date and time) for a `GET` request:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录中创建一个名为`main.go`的程序，该程序获取`GET`请求的健康检查（日期和时间）：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This program returns the date and time when requested. Now, we need to Dockerize
    this application. Dockerizing means creating a running container. Add a Dockerfile
    to the current directory (in the same level `kongExample`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在请求时返回日期和时间。现在，我们需要将这个应用程序Docker化。Docker化意味着创建一个运行的容器。将Dockerfile添加到当前目录（在相同级别的`kongExample`中）：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We build a container with the help of this Dockerfile. It says to pull the
    `golang` container from DockerHub (installing the Go compiler and setting the `GOPATH`
    is automatically taken care of) and copy this `kongExample` project to the container.
    Install necessary packages for the project (in this case it is Gorilla Mux), then
    compile the binary and start the server. Run this command to create the container:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个Dockerfile构建一个容器。它告诉我们从DockerHub拉取`golang`容器（自动安装Go编译器并设置`GOPATH`），并将这个`kongExample`项目复制到容器中。安装项目所需的必要软件包（在本例中是Gorilla
    Mux），然后编译二进制文件并启动服务器。运行此命令创建容器：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice the `.` after the `docker build` command. The `-t` option is to tag
    the image with the name. It tells Docker to look at the Dockerfile in the current
    directory and create a Docker image with the given instructions. We need to actually
    run this image to create a container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`docker build`命令后的`.`。`-t`选项是为镜像打标签。它告诉Docker查看当前目录中的Dockerfile，并根据给定的指令创建一个Docker镜像。我们需要实际运行这个镜像来创建一个容器：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It creates a container called `go-server` and starts the Go web server on port
    `3000`.Now install Kong container, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个名为`go-server`的容器，并在端口`3000`上启动Go Web服务器。现在安装Kong容器，就像这样：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command is similar to the first one except we are exposing many other ports
    for Kong to function. We are also pulling the `kong:latest` image from DockerHub.
    Others are environment variables that are required by Kong. We are linking `kong-database`
    to a hostname called `kong-database` and `go-server` to `go-server`. A hostname
    is a helpful entity in a Docker environment to identify and reach to one container
    from another. Docker maintains an internal **Domain Name Space** (**DNS**) that
    keeps track of IP addresses of Docker containers to the linked names. This starts
    the Kong container and starts the Kong service with a default file called `kong.conf.default`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与第一个命令类似，只是我们暴露了许多其他端口供Kong使用。我们还从DockerHub拉取`kong:latest`镜像。其他的是Kong所需的环境变量。我们将`kong-database`链接到名为`kong-database`的主机名，将`go-server`链接到`go-server`。主机名是Docker环境中的一个有用的实体，用于从一个容器识别和访问另一个容器。Docker维护一个内部的**域名空间**（**DNS**），用于跟踪Docker容器的IP地址到链接名称的映射。这将启动Kong容器并使用名为`kong.conf.default`的默认文件启动Kong服务。
- en: 'Now, if we look at the running containers, it lists three container IDs:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看正在运行的容器，它列出了三个容器ID：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Docker containers are nothing but isolated environments for running applications.
    It is a best practice to run microservices in different containers as they are
    loosely coupled and one environment won't interfere with the other.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器只是用于运行应用程序的隔离环境。将微服务运行在不同的容器中是最佳实践，因为它们松散耦合，一个环境不会干扰另一个环境。
- en: 'It means we successfully set up the infrastructure for the Kong API gateway.
    Let''s see how to add the API from `go-server` in Kong. In order to check the
    status of Kong, just make a `GET` request to this URL:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们成功地为Kong API网关设置了基础设施。让我们看看如何在Kong中添加来自`go-server`的API。为了检查Kong的状态，只需向此URL发出`GET`请求：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It returns the status of the database and also the stats for Kong:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回数据库的状态以及Kong的统计信息：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding API to Kong
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Kong添加API
- en: Kong provides an intuitive REST API to add a custom API to the gateway. In order
    to add the aformentioned healthcheck API, we need to make a `POST` request to
    the Kong admin API, which runs on port `8001`. From now on we use the Postman
    REST client to show all API requests. These API requests are also available as
    a JSON file collection in the chapter's repository for readers to download and
    import in their Postman clients respectively. For more information on exporting
    and importing Postman collections, visit [https://www.getpostman.com/docs/postman/collections/data_formats](https://www.getpostman.com/docs/postman/collections/data_formats).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kong提供了一个直观的REST API来将自定义API添加到网关。为了添加上述的健康检查API，我们需要向运行在端口`8001`上的Kong管理API发出`POST`请求。从现在开始，我们使用Postman
    REST客户端来显示所有API请求。这些API请求也作为JSON文件集合在本章的存储库中提供，供读者下载并分别导入到他们的Postman客户端中。有关导出和导入Postman集合的更多信息，请访问[https://www.getpostman.com/docs/postman/collections/data_formats](https://www.getpostman.com/docs/postman/collections/data_formats)。
- en: 'Make a `POST` request from Postman to the Kong admin URL `http://localhost:8001/apis`
    with these fields in the JSON body:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从Postman向Kong管理URL`http://localhost:8001/apis`发出`POST`请求，并在JSON主体中使用这些字段：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It adds our health check API to Kong. The Postman screen looks like the following
    screenshot with all the changes. Postman is a wonderful tool that allows Windows,
    macOS X, and Linux users to make/test HTTP API requests. You can download it here [https://www.getpostman.com/](https://www.getpostman.com/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它将我们的健康检查API添加到Kong。Postman屏幕看起来像以下截图所示，显示了所有更改。Postman是一个很棒的工具，允许Windows、macOS
    X和Linux用户进行HTTP API请求的测试。您可以在这里下载它[https://www.getpostman.com/](https://www.getpostman.com/)。
- en: '![](img/432b02ac-7514-4427-8898-e1a466291ffb.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/432b02ac-7514-4427-8898-e1a466291ffb.png)'
- en: 'Once we make this, we get the response JSON with details of the API. This new
    `myapi` will be given an ID:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们就会得到包含API详细信息的响应JSON。这个新的`myapi`将被赋予一个ID：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A  `GET` request to this URL, `http://localhost:8001/apis/myapi` returns the
    metadata of newly added `myapi`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 向此URL发出`GET`请求，`http://localhost:8001/apis/myapi`返回新添加的`myapi`的元数据。
- en: Coming to the fields that we posted to the `POST` API, the `name` is the unique
    name of the API. We need to use this to identify an API on the gateway. `hosts`
    is the list of hosts from which the gateway can accept and forward requests. Upstream
    URL is the actual address to which Kong forward requests. Since we linked the `go-server`
    container, in the beginning, we can directly refer `http://go-server:3000` from
    the Kong. The `uris` field is intended to specify the path relative to the upstream
    proxy (Go server) to fetch resources.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们发布到`POST` API的字段，`name`是API的唯一名称。我们需要使用这个来在网关上标识API。`hosts`是网关可以接受和转发请求的主机列表。上游URL是Kong转发请求的实际地址。由于我们在开始时链接了`go-server`容器，我们可以直接从Kong中引用`http://go-server:3000`。`uris`字段用于指定相对于上游代理（Go服务器）的路径，以获取资源。
- en: 'For example, if the URI is `/api/v1` and the Go server''s API is `/healthcheck`,
    the resulting gateway API will be:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果URI是`/api/v1`，而Go服务器的API是`/healthcheck`，则生成的网关API将是：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`preserve_host` is the property that says whether Kong should change the request''s
    host field to the hostname of the upstream server. For more information, see [https://getkong.org/docs/0.10.x/proxy/#the-preserve_host-property](https://getkong.org/docs/0.10.x/proxy/#the-preserve_host-property). Other
    settings such as `upstream_connect_timeout` are straightforward.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`preserve_host`是一个属性，它表示Kong是否应该将请求的主机字段更改为上游服务器的主机名。有关更多信息，请参阅[https://getkong.org/docs/0.10.x/proxy/#the-preserve_host-property](https://getkong.org/docs/0.10.x/proxy/#the-preserve_host-property)。其他设置，如`upstream_connect_timeout`，都很简单。'
- en: 'We added our API to Kong. Let us verify if it is forwarding our health check
    request to the Go server or not. Don''t forget to add a header called `Host` with
    the value `server1` for all the API requests. This is very important. The API
    call looks like the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的API添加到Kong。让我们验证它是否将我们的健康检查请求转发到Go服务器。不要忘记为所有API请求添加一个名为`Host`值为`server1`的标头。这非常重要。API调用如下图所示：
- en: '>![](img/82c21b17-e5d8-48b2-b069-649abf0b7fb6.png)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/82c21b17-e5d8-48b2-b069-649abf0b7fb6.png)'
- en: We received the response successfully. This is the response returned by our
    `HealthcheckHandler` in our `main.go` program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功收到了响应。这是我们的`main.go`程序中的`HealthcheckHandler`返回的响应。
- en: If you receive a 404 error, please try the procedure from the beginning. The
    problem could be the containers not running or the upstream URL not being accessible
    from the Kong container. Another critical error may arise from not adding host
    in the request headers. This is the host given while adding the API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到404错误，请尝试从头开始执行该过程。问题可能是容器没有运行，或者Kong容器无法访问上游URL。另一个关键错误可能来自于未在请求标头中添加主机。这是在添加API时给出的主机。
- en: This health check API is actually running as a Go service. We made a request
    for the API gateway and it is forwarding that to the Go. It proves that we successfully
    linked our API with an API gateway.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个健康检查API实际上是作为Go服务运行的。我们向API网关发出了API请求，它正在将其转发到Go。这证明我们成功地将我们的API与API网关链接起来。
- en: This is the addition of the API, the tip of the iceberg. What about other things?
    We will be going through each and every feature of the API gateway and try to
    implement them for our API.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是API的添加，只是冰山一角。其他事情呢？我们将逐个研究API网关的每一个功能，并尝试为我们的API实现它们。
- en: In Kong, apart from this basic routing, additional things such as logging and
    rate limiting are available. We need to enable them to our API using plugins.
    A Kong plugin is an inbuilt component that allows us to plug any functionality
    easily. There are many types of plugins available. Out of them, we will discuss
    a few interesting ones in the next section. Let us start with the logging plugin.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kong中，除了基本路由之外，还提供了其他功能，如日志记录和速率限制。我们需要使用插件将它们启用到我们的API中。Kong插件是一个内置组件，可以让我们轻松地插入任何功能。有许多类型的插件可用。其中，我们将在下一节讨论一些有趣的插件。让我们从日志记录插件开始。
- en: API logging in Kong
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kong中的API日志记录
- en: 'Many plugins are available in Kong to log requests to multiple targets. A target
    is a system that collects the log and persists it somewhere. These are the important
    plugins available for logging:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kong中有许多插件可用于将请求记录到多个目标。目标是收集日志并将其持久化的系统。以下是可用于日志记录的重要插件：
- en: File log
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件日志
- en: Syslog
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Syslog
- en: HTTP log
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP日志
- en: 'The first one is file logging. If we need the Kong server to store the request
    and response logs in the form of JSON to a file, use this plugin. We should call
    on Kong''s admin REST API (`http://localhost:8001/apis/myapi/plugins`) to do that:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是文件日志记录。如果我们需要Kong服务器以JSON格式将请求和响应日志存储到文件中，使用此插件。我们应该调用Kong的管理REST API（`http://localhost:8001/apis/myapi/plugins`）来执行：
- en: '![](img/a51c3022-a3b1-4a32-8dd7-9f3ffd1241a0.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a51c3022-a3b1-4a32-8dd7-9f3ffd1241a0.png)'
- en: 'Hit the Send button and the gateway returns the response, like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击发送按钮，网关将返回响应，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It basically tells Kong that, for the given API called `myapi`, log every request
    to a file called `/tmp/file.log`. Now, make one more request for the health check (`http://localhost:8000/api/v1/healthcheck`)
    to the API gateway. The log for this request will be saved in the given file path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上告诉Kong，对于名为`myapi`的API，将每个请求记录到名为`/tmp/file.log`的文件中。现在，向API网关发出健康检查的另一个请求（`http://localhost:8000/api/v1/healthcheck`）。此请求的日志将保存在给定的文件路径中。
- en: 'How do we watch these logs? Those logs will be saved in the `/tmp` folder of
    the container. Open a new tab of a terminal and enter the Kong container using
    this command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何查看这些日志？这些日志将保存在容器的`/tmp`文件夹中。打开一个新的终端标签，并使用以下命令进入Kong容器：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This takes you into the container''s bash shell. Now, inspect the log file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您进入容器的bash shell。现在，检查日志文件：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And you will see a lengthy JSON written to the file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会看到一个长长的JSON写入文件：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: IP addresses logged here are the internal IP assigned by the Docker to the containers.
    This log also has a breakdown of latency information about the Kong proxy, Go
    server, and so on. You can learn more about the format of logged fields at [https://getkong.org/plugins/file-log/](https://getkong.org/plugins/file-log/).
    Kong admin API for enabling the other logging types is similar to the `file-log`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里记录的IP地址是Docker分配给容器的内部IP。这个日志还包含有关Kong代理、Go服务器等的延迟信息的详细信息。您可以在[https://getkong.org/plugins/file-log/](https://getkong.org/plugins/file-log/)了解有关记录字段格式的更多信息。Kong管理API用于启用其他日志记录类型与`file-log`类似。
- en: 'The `POST` requests we are making from Postman to the admin API has the header
    of `Content-Type: "application/json"`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '我们从Postman向管理API发出的`POST`请求具有`Content-Type: "application/json"`的标头。'
- en: API authentication in Kong
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kong中的API身份验证
- en: As we mentioned, an API gateway should take care of authentication for the multiple
    APIs running behind the gateway. Many plugins are available to provide authentication
    on the fly in Kong. In the next chapter, we will see the authentication concept
    in detail. For now, using these plugins, we can add authentication for a given
    API by calling the Kong admin API.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，API网关应该负责多个API在其后运行的身份验证。在Kong中有许多插件可用于提供即时身份验证。在下一章中，我们将详细了解身份验证概念。目前，使用这些插件，我们可以通过调用Kong管理API为特定API添加身份验证。
- en: 'An API key-based authentication is becoming famous these days. Kong provides
    the following authentication patterns:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 基于API密钥的身份验证如今变得很有名。Kong提供以下身份验证模式：
- en: API key-based authentication
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于API密钥的身份验证
- en: OAuth2 authentication
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth2身份验证
- en: JWT authentication
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT身份验证
- en: 'For the sake of simplicity, let us implement API key-based authentication.
    In simple words, key-based authentication allows an external client to consume
    the REST API with a unique token. For that in Kong, enable the key authentication
    plugin first. To enable the plugin, make a `POST` request to the `http://localhost:8001/apis/myapi/plugins`
    URL with two things in the JSON body:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们实现基于API密钥的身份验证。简而言之，基于密钥的身份验证允许外部客户端使用唯一令牌消耗REST API。为此，在Kong中，首先启用密钥身份验证插件。要启用插件，请向`http://localhost:8001/apis/myapi/plugins`
    URL发出`POST`请求，并在JSON主体中包含两个内容：
- en: The `name` is `key-auth`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`name`是`key-auth`。'
- en: '`config.hide_credentials` is `true`.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config.hide_credentials`是`true`。'
- en: 'The second option is to strip/hide the credential to get passed to the Go API
    server. Take a look at the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是剥离/隐藏凭据以传递给Go API服务器。看一下以下截图：
- en: '![](img/78461538-976d-4ab8-a7db-873035c6b39e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78461538-976d-4ab8-a7db-873035c6b39e.png)'
- en: 'It returns the JSON response with the created `api_id`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回JSON响应与创建的`api_id`：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if we try to make a health check API request, we receive a 401 Unauthorized
    error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试进行健康检查API请求，我们会收到401未经授权的错误：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then how can we consume an API? We need to create a consumer and give permissions
    for him to access the API. That permission is an API key. Let us see how to do
    that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何使用API？我们需要创建一个消费者并为他授予权限访问API。该权限是一个API密钥。让我们看看如何做到这一点。
- en: 'For creating a consumer, we need to create a consumer that represents a user
    consuming the API. Make an API call to the Kong admin API for consumers. The URL
    endpoint will be `http://localhost:8001/consumers`. Refer to the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个消费者，我们需要创建一个代表使用API的用户的消费者。向Kong管理API的消费者发出API调用。URL端点将是`http://localhost:8001/consumers`。参考以下截图：
- en: '![](img/48f55137-10a1-4148-9b2b-38d3cb7c77e8.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48f55137-10a1-4148-9b2b-38d3cb7c77e8.png)'
- en: 'The `POST` body should have the `username` field. The response will be JSON
    with the created consumer:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`主体应该有`username`字段。响应将是创建的消费者的JSON：'
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we need to grant the API permission to `johnd`, make a `POST` request
    to the `http://localhost:8001/consumers/johnd/key-auth admin` URL:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们需要授予API权限给`johnd`，请向`http://localhost:8001/consumers/johnd/key-auth admin`
    URL发出`POST`请求：
- en: '![](img/8a03b590-0d46-413c-b86d-c4a77d74e258.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a03b590-0d46-413c-b86d-c4a77d74e258.png)'
- en: 'This returns the API key:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回API密钥：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use this API key generated in the subsequent API calls. Now, remake
    the health check with `apikey` in header whose value is the key from the preceding
    response, and it successfully returns the date and time with a `200 OK`. Refer
    to the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在随后的API调用中使用此API密钥生成。现在，在标头中使用`apikey`重新进行健康检查，其值是前面响应中的密钥，它将成功返回日期和时间以及`200
    OK`。参考以下截图：
- en: '![](img/66502aeb-b4ac-4d19-ba66-eee9e0ae483e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66502aeb-b4ac-4d19-ba66-eee9e0ae483e.png)'
- en: API rate limiting in Kong
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kong中的API速率限制
- en: We can limit the rate of an API for a given consumer. For example, GitHub limits
    clients to make 5000 requests per hour. After that, it throws an API rate limit
    exceeded error. We can add similar rate limiting constraints for our API using
    Kong's `rate-limiting` plugin.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以限制特定消费者的API速率。例如，GitHub限制客户端每小时进行5000次请求。之后，它会抛出API速率限制错误。我们可以使用Kong的`rate-limiting`插件为我们的API添加类似的速率限制约束。
- en: 'We can enable it using this API: **`http://localhost:8001/apis/myapi/plugins`**,
    with `POST` `name`, `config.hour`, and `consumer_id` as body parameters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此API进行启用：**`http://localhost:8001/apis/myapi/plugins`**，使用`POST` `name`、`config.hour`和`consumer_id`作为body参数：
- en: '![](img/44aca43e-a1c6-4b9a-ad2b-11f48a2f078c.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44aca43e-a1c6-4b9a-ad2b-11f48a2f078c.png)'
- en: This API call is creating a rate limiting rule. The `consumer_id` is the id
    of the username `johnd`. This JSON response has an `ID`
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API调用正在创建速率限制规则。`consumer_id`是用户名`johnd`的ID。这个JSON响应有一个`ID`
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the consumer (`johnd`) has the rate limit on the API. He will only be
    allowed to make 5000 requests per hour to our health check API. If he exceeds
    it, he receives the following error:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消费者（`johnd`）在API上有速率限制。他每小时只能允许对我们的健康检查API进行5000次请求。如果超过，他将收到以下错误：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How should a client know how many requests are remaining as part of rate control?
    Kong sets a few headers on the response when a client makes a request to the API.
    Try to make 10 health check requests and check the response headers; you will
    find the following in the response headers, which proves that rate limiting is
    working:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该如何知道剩余的请求次数作为速率控制的一部分？当客户端向API发出请求时，Kong在响应中设置了一些标头。尝试进行10次健康检查请求并检查响应标头；您将在响应标头中找到以下内容，证明速率限制正在起作用：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this way, Kong provides many good features to take our API to the next level.
    It doesn't mean that an API gateway is absolutely necessary, but it can give you
    the pleasure of having many cool features without writing a single line of code.
    It is an open-source software developed to avoid rewriting the universally defined
    API gateway functionality within the web service business logic. For more features
    such as load balancing and request transformations, go through the documentation
    of Kong at [https://konghq.com/plugins/](https://konghq.com/plugins/).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，Kong提供了许多优秀的功能，可以将我们的API提升到更高的水平。这并不意味着API网关是绝对必要的，但它可以让您享受许多很酷的功能，而无需编写一行代码。它是一个开源软件，旨在避免在Web服务业务逻辑中重新编写通用定义的API网关功能。有关诸如负载平衡和请求转换之类的更多功能，请查看Kong的文档[https://konghq.com/plugins/](https://konghq.com/plugins/)。
- en: Kong CLI
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kong CLI
- en: 'Kong comes with a command-line tool for changing the behavior of Kong. It has
    a set of commands to start, stop, and modify Kong. Kong by default uses a configuration
    file. If we need to modify it, we need to restart Kong for those changes to be
    applied. So, all these housekeeping jobs are already wired into the Kong CLI tool.
    The basic functions are:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kong配备了一个命令行工具，用于更改Kong的行为。它有一组命令来启动、停止和修改Kong。Kong默认使用配置文件。如果我们需要修改它，我们需要重新启动Kong才能应用这些更改。因此，所有这些基本工作都已经编码到Kong
    CLI工具中。基本功能包括：
- en: '`kong start`: For starting the Kong server'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kong start`：用于启动Kong服务器'
- en: '`kong reload`: For reloading the Kong server'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kong reload`：用于重新加载Kong服务器'
- en: '`kong stop`: For stopping the Kong server'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kong stop`：用于停止Kong服务器'
- en: '`kong check`: For validating the given Kong configuration file'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kong check`：用于验证给定的Kong配置文件'
- en: '`kong health`: For checking necessary services, such as the database, are running'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kong health`：用于检查必要的服务，如数据库，是否正在运行'
- en: Please go through the documentation of Kong CLI for more commands at [https://getkong.org/docs/0.9.x/cli/](https://getkong.org/docs/0.9.x/cli/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看Kong CLI的文档以获取更多命令[https://getkong.org/docs/0.9.x/cli/](https://getkong.org/docs/0.9.x/cli/)。
- en: Other API gateways
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他API网关
- en: There are many other API gateway providers available in the market. As we mentioned
    earlier, all gateways perform the same kinds of functions. Enterprise gateway
    service providers such as Amazon API Gateway plays nice with EC2 and Lambdas.
    Apigee is another well-known API gateway technology that is a part of Google Cloud.
    The problem with cloud providers is that they can cause vendor lock (cannot easily
    migrate to another platform). Because of that reason, open-source alternatives
    are always good for startup companies.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多其他API网关提供商。正如我们之前提到的，所有网关都执行相同类型的功能。像亚马逊API网关这样的企业网关服务提供商与EC2和Lambdas兼容。Apigee是另一个知名的API网关技术，是Google
    Cloud的一部分。云服务提供商的问题在于它们可能导致供应商锁定（无法轻松迁移到另一个平台）。因此，对于初创公司来说，开源替代方案总是不错的选择。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started with the basics of an API gateway. An API gateway
    tries to do a few things; it acts as a proxy for our API. By being a proxy, it
    forwards requests to the multiple APIs from different domains. In that process
    of forwarding, a gateway can block requests, rate limit them, and also transform
    requests/responses.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从API网关的基础知识开始。API网关尝试做一些事情；它充当我们的API的代理。通过充当代理，它将请求转发到不同域的多个API。在转发的过程中，网关可以阻止请求，对其进行速率限制，还可以转换请求/响应。
- en: Kong is a good open-source API gateway available for the Linux platform. It
    has many features such as authentication, logging, and rate limiting. We saw how
    to install Kong, a Kong database, and our REST service inside the Docker containers.
    We used Docker instead of host machine because containers can be destroyed and
    created at will. It gives less chance for screwing up our host system. After learning
    about the installation, we learned that Kong has two types of REST API. One is
    the admin API, and the other is the app API. The admin API is the one we use to
    add our API to the gateway. The app API is our application's API. We saw how to
    add an API to Kong. Then, we came to know about Kong plugins. Kong plugins are
    the functional pieces that can plug into a Kong. Logging plugins are available.
    Authentication plugins and rate limiting plugins are also available in Kong.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Kong是一个适用于Linux平台的优秀的开源API网关。它具有许多功能，如身份验证、日志记录和速率限制。我们看到了如何在Docker容器中安装Kong、Kong数据库和我们的REST服务。我们使用Docker而不是主机机器，因为容器可以随意销毁和创建。这减少了损坏主机系统的机会。在了解安装后，我们了解到Kong有两种类型的REST
    API。一种是管理API，另一种是应用程序API。管理API是我们用来将API添加到网关的API。应用程序API是我们应用程序的API。我们看到了如何将API添加到Kong。然后，我们了解了Kong插件。Kong插件是可以插入Kong的功能模块。日志记录插件可用。Kong还提供身份验证插件和速率限制插件。
- en: We made requests with the Postman client and saw the sample JSON returned. For
    authentication, we used the `apikey` based consumer. We then simulated GitHub's
    5000 requests per hour with a `key-auth` plugin of Kong.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Postman客户端进行了请求，并看到了返回的示例JSON。对于身份验证，我们使用了基于`apikey`的消费者。然后，我们使用Kong的`key-auth`插件模拟了GitHub每小时5000次请求。
- en: Finally, we introduced the Kong CLI and also inspected other enterprise API
    gateways such as Apigee and Amazon API Gateway.  In the next chapter, we will
    see in more detail how authentication works and try to secure our API when there
    is no API gateway present.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了Kong CLI，并检查了其他企业API网关，如Apigee和亚马逊API网关。在下一章中，我们将更详细地了解身份验证的工作原理，并在没有API网关的情况下尝试保护我们的API。
