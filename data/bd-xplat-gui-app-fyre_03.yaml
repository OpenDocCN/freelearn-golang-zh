- en: '*Chapter 2*: The Future According to Fyne'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：根据 Fyne 的未来'
- en: The Fyne toolkit design is based on the premise that the best way to resolve
    many of the challenges raised in [*Chapter 1*](B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015),
    *A Brief History of GUI Toolkits and Cross-Platform Development*, is to take a
    fresh approach to GUI toolkit design. It aims to combine the benefits of a modern
    programming language, the Material Design look, and a simple API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 工具包的设计基于这样一个前提，即解决[*第一章*](B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015)中提出的许多挑战的最好方法是对
    GUI 工具包设计采取全新的方法。它旨在结合现代编程语言、Material Design 风格和简单的 API 的优点。
- en: 'In this chapter, we explore the background and ambition of the Fyne project,
    including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Fyne 项目的背景和目标，包括以下内容：
- en: The vision for Fyne and its team
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fyne 及其团队的目标愿景
- en: How does a modern programming language enable a fresh approach?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代编程语言如何实现全新的方法？
- en: How does it address the complexities of cross-platform, native app development?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它如何解决跨平台、原生应用开发的复杂性？
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be using examples of Go code, so you will need to install
    the Go compiler – refer to the instructions at [https://golang.org/doc/install](https://golang.org/doc/install).
    We will also explore bridging to C APIs, so you will need to install a C compiler
    as well. The installation of C varies from system to system. You can find details
    in [*Appendix A*](B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253), *Developer
    Tool Installation.*
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Go 代码的示例，因此您需要安装 Go 编译器——请参阅[https://golang.org/doc/install](https://golang.org/doc/install)中的说明。我们还将探讨如何将
    C API 进行桥接，因此您还需要安装一个 C 编译器。C 的安装因系统而异。您可以在[*附录 A*](B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253)中找到详细信息，*开发者工具安装*。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter02)找到。
- en: Starting with a clean slate
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一张白纸开始
- en: Through the history of GUI development, we see that the majority of the most
    popular toolkits are based on C or C++ language code. These projects have a substantial
    history, large communities, and innumerable hours of development to make them
    what they are today. Despite being the yardstick against which all other toolkits
    are measured, they have drawbacks, mostly due to the legacy of the old design
    decisions they are built on. In this section, we reflect on why starting from
    scratch creates a better experience for building cross-platform apps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 GUI 开发的历史，我们看到大多数最受欢迎的工具包都是基于 C 或 C++ 语言代码。这些项目有着悠久的历史、庞大的社区和无数的开发小时数，使它们成为今天的模样。尽管它们是衡量所有其他工具包的标准，但它们存在缺点，这主要是因为它们建立在旧的设计决策之上。在本节中，我们反思为什么从头开始创建跨平台应用程序的更好体验。
- en: Designing for modern devices
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为现代设备设计
- en: The types of devices we use today are both vastly different and much more varied
    compared with the 1980s and 1990s, when the most common toolkits were being designed
    and built. Today, a graphical application could be running on a desktop computer,
    laptop or netbook, a mobile device or tablet, smart phone or watch form factor,
    or even a set-top box or a smart TV. These device categories all have different
    user interface paradigms—APIs designed for a desktop computer using a mouse and
    keyboard don’t always adapt well to touchscreen-based input, multiple touch hand
    gestures, or a remote control as the primary input device. An input API designed
    for modern devices will be able to provide a suitable abstraction over the low-level
    details to focus on the user’s intent. By using this approach, applications can
    better adapt to the variety of devices in consumers’ hands.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天使用的设备类型与 1980 年代和 1990 年代相比，既大不相同又更加多样化，当时最常用的工具包正在设计和构建中。今天，图形应用程序可以在台式计算机、笔记本电脑或上网本、移动设备或平板电脑、智能手机或手表形态、甚至机顶盒或智能电视上运行。这些设备类别都有不同的用户界面范式——为使用鼠标和键盘的台式计算机设计的
    API 并不一定很好地适应基于触摸屏的输入、多指手势或作为主要输入设备的遥控器。为现代设备设计的输入 API 将能够提供对底层细节的适当抽象，从而关注用户的意图。通过采用这种方法，应用程序可以更好地适应消费者手中的各种设备。
- en: Along with the variety of device sizes come a wide spectrum of screen sizes
    and types. Mobile phones now have larger screens than ever, but they are still
    relatively small. However, the number of pixels they contain is huge, creating
    a smooth look when held close to our faces. TVs, on the other hand, are very large,
    but the resolution is low due to the distance they are usually observed at. Even
    desktop screens have changed—the average size has increased and the screens have
    become wider, but the biggest change is that pixel density has gone up astronomically,
    with high-end displays containing ten times as many pixels as those of cheap devices.
    Handling this variety of output devices requires resolution-independent rendering,
    which is a big shift from the origins of graphical toolkits, where pixels could
    be assumed to be a certain size. To work around these issues, some toolkits simply
    use a multiplier for each output pixel. This approach manages to avoid an app
    becoming too difficult to read by using more pixels to display the same original
    resolution—but will require application updates to avoid badly pixelated rendering.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着设备尺寸的多样性，屏幕尺寸和类型也呈现出广泛的变化。现在的手机屏幕比以往任何时候都要大，但它们仍然相对较小。然而，它们包含的像素数量巨大，当我们将它们贴近脸部时，会呈现出平滑的外观。另一方面，电视屏幕非常大，但由于通常观察的距离较远，分辨率较低。即使是台式机的屏幕也发生了变化——平均尺寸增大，屏幕变得更宽，但最大的变化是像素密度呈天文数字般增长，高端显示器的像素数量是廉价设备的十倍。处理这种多样化的输出设备需要分辨率无关的渲染，这与图形工具包的起源有很大的不同，在图形工具包中，像素的大小是可以假设的。为了解决这些问题，一些工具包简单地为每个输出像素使用一个乘数。这种方法通过使用更多的像素来显示相同的原始分辨率，从而避免了应用程序变得难以阅读，但为了避免渲染出现严重像素化，需要更新应用程序。
- en: With the ever-increasing complexity of smart phones, consumers now expect that
    applications will adapt to their location, preferences, and behaviors. Much of
    this is possible due to the inclusion of many sensors, each of which have platform-specific
    APIs. An easy-to-use abstraction over the platform specifics is part of a good
    modern toolkit and significantly reduces the time spent by developers in preparing
    their software for the different platforms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着智能手机的复杂性不断增长，消费者现在期望应用程序能够适应他们的位置、偏好和行为。这很大程度上得益于许多传感器的加入，每个传感器都有平台特定的API。在良好的现代工具包中，对平台特定性的简单抽象可以显著减少开发者准备软件以适应不同平台所需的时间。
- en: Parallelism and web services
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行处理和Web服务
- en: Computing technology has come a long way in 50 years, not just in machine rooms
    and server racks, but on our desks and in our pockets. It is often said that we
    now have more power in our pockets than we had when man first landed on the moon.
    In fact, it’s more like 10,000 times the amount of power if you factor in a smart
    phone’s capabilities. To be able to accommodate this much power requires modern
    programming techniques—it’s not as simple as running the same code much faster.
    One major factor is that a modern operating system and any application on it will
    be able to calculate many things at the same time – but to do so effectively requires
    code that understands **parallel processing.** To make this adjustment is straightforward;
    code must be split into components that are independent enough to be able to run
    simultaneously. Introducing this ability can mean that memory is no longer controlled
    by a single part of code and so unexpected outcomes can occur (often called **race
    conditions**). Working around these complications with older tools can be very
    complicated and error prone.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算技术在过去的50年里取得了长足的进步，不仅是在机房和服务器机架中，也在我们的桌面上和口袋里。人们常说，我们现在口袋里的计算能力比人类首次登月时还要强大。实际上，如果考虑到智能手机的功能，这个数字可能高达1万倍。要容纳这么大的计算能力需要现代编程技术——这不仅仅是运行相同的代码速度更快。一个主要因素是，现代操作系统和其上的任何应用程序都能够同时计算许多事情——但要有效地做到这一点，需要理解**并行处理**的代码。进行这种调整很简单；代码必须分成足够独立的组件，以便能够同时运行。引入这种能力意味着内存不再由代码的单一部分控制，因此可能会出现意外的结果（通常称为**竞态条件**）。使用旧工具解决这些复杂问题可能非常复杂且容易出错。
- en: Almost all GUI toolkits to date (including the latest releases by Apple and
    Microsoft) require that changes to the user interface or output graphics are handled
    by the *main thread*, a single portion of the capability of any application. This
    constraint requires careful coordination from an application developer and potentially
    limits the computing power available for the graphical components of an app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，几乎所有GUI工具包（包括苹果和微软的最新版本）都要求用户界面或输出图形的更改由*主线程*处理，这是任何应用程序能力的一个单一部分。这个限制要求应用程序开发者进行仔细的协调，并可能限制应用程序图形组件可用的计算能力。
- en: One of the most common uses for background threads in an application will be
    communicating with remote resources. Web services or network resources are not
    accessible as fast as data on the local computer or bundled with an application,
    and so an app must manage user input and graphical updates while handling these
    slower requests. The core of most graphical toolkits and APIs is focused solely
    on the widgets—the presentation of the interface to the user. The design of many
    toolkits pre-dates cloud services and web-based APIs as we know them today. Powerful
    web services and standardized protocols for communication vastly improve the speed
    of development for web-based applications. Conversely, they can make it harder
    for native graphical applications on the desktop, where support is lacking from
    the core language or standard libraries. Inclusion of these features in modern
    programming languages is changing this and a modern graphical toolkit should provide
    similar benefits to developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中背景线程最常见的一个用途将是与远程资源通信。网络服务或网络资源不像本地计算机上的数据或与应用程序捆绑的数据那样快速访问，因此应用程序必须在处理这些较慢请求的同时管理用户输入和图形更新。大多数图形工具包和API的核心都专注于小部件——向用户展示界面的方式。许多工具包的设计早于我们今天所知道的云服务和基于Web的API。强大的网络服务和用于通信的标准协议大大提高了基于Web应用程序的开发速度。相反，它们可能会使桌面上的本地图形应用程序更难，因为核心语言或标准库缺乏支持。将这些功能纳入现代编程语言正在改变这一点，现代图形工具包应该为开发者提供类似的好处。
- en: Building for any device
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为任何设备构建
- en: While considering the hardware characteristics and connected nature of devices,
    we need to consider how software is deployed to them. Each operating system expects
    applications to be packaged and installed in a different format and often have
    different ways of discovering and downloading software as well. Although the C
    and C++ languages do work across most platforms, it can be very complicated to
    compile for a computer that is different to the one that you are working on. This
    restriction has not been a problem for desktop and laptop apps, as companies simply
    buy the different types of computers to run the compilation and packaging. It
    is, however, more complex for mobile and embedded devices, where they cannot compile
    their own apps from the source code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑设备的硬件特性和连接性质时，我们需要考虑软件如何部署到这些设备上。每个操作系统都期望应用程序以不同的格式打包和安装，并且通常有不同方式来发现和下载软件。尽管C和C++语言在大多数平台上都能工作，但要为与你正在工作的不同计算机编译可能会非常复杂。对于桌面和笔记本电脑应用程序来说，这种限制并不是问题，因为公司只需购买不同类型的计算机来运行编译和打包。然而，对于移动和嵌入式设备来说，情况就复杂得多，因为它们无法从源代码编译自己的应用程序。
- en: Programming languages designed more recently include the ability to build for
    different systems from a single development computer. Although this is something
    that interpreted languages had done forever, it is now possible for your compiled
    applications (faster with no need for pre-installed runtime environments) to be
    **cross-compiled** for any device. In addition to this capability, the GUI toolkit
    must support preparation of different formats of application bundles that can
    package up the binary assets, resources, and other metadata for distribution.
    It is possible to perform these tasks manually, but a well-thought-out developer
    experience should ensure that this is practically automatic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最近设计的编程语言包括从单一开发计算机构建不同系统的能力。尽管解释型语言一直都在做这件事，但现在你的编译应用程序（更快，无需预安装运行时环境）可以为任何设备进行**交叉编译**。除了这个功能之外，GUI工具包必须支持准备不同格式的应用程序包，这些包可以打包二进制资产、资源和其他元数据以进行分发。虽然可以手动执行这些任务，但一个经过深思熟虑的开发者体验应该确保这实际上是自动的。
- en: Additionally, many distribution platforms such as app stores and software marketplaces
    require a certification process that ensures authenticity of the apps it will
    make available. The cryptographic steps required to set this up are often lengthy
    and can be a hurdle to new app developers looking to make their work available.
    Rethinking a toolkit and the utilities it provides would allow this problem to
    be addressed alongside the compilation and packaging challenges.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多分发平台，如应用商店和软件市场，要求一个认证过程，以确保其提供的应用程序的真实性。设置这些加密步骤通常很耗时，可能会成为希望将其作品提供给公众的新应用程序开发者的障碍。重新思考工具包及其提供的实用工具将允许在编译和打包挑战的同时解决此问题。
- en: Best practices have moved on
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践已经发展
- en: A final factor that can be observed when evaluating a toolkit for developing
    your app might be how up to date its best practices are. It has long been thought
    that automated testing of graphical applications is next to impossible, an opinion
    that is in no small way due to the fact that **Test-Driven Development** (**TDD**)
    and **Continuous Integration** (**CI**) were not common practices when the legacy
    toolkits, or the programming languages they use, were designed. A developer looking
    to learn, or one that is in a team of professional software engineers, would probably
    expect such practices to be supported or even encouraged in modern tools.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估用于开发应用程序的工具包时，可以观察到的最后一个因素可能是其最佳实践是否最新。长期以来，人们认为图形应用程序的自动化测试几乎是不可能的，这种观点在很大程度上是由于**测试驱动开发**（**TDD**）和**持续集成**（**CI**）在遗留工具包或它们使用的编程语言设计时并不常见。一个希望学习或在一个专业软件工程师团队中的开发者可能会期望现代工具支持或甚至鼓励这些实践。
- en: The C language (and many derivatives thereof) have often been criticized for
    the weak handling of string types. In fact, it is this very deficiency that has
    led to many highly visible software vulnerabilities and public data breaches.
    Although not all older programming languages suffer from this issue, they almost
    all have the restriction of only supporting simple strings using the *Latin alphabet*
    (although some have add-on libraries that attempt to work around this). With such
    a restriction, it is difficult to write an application that will easily adapt
    to the variety of commonplace languages that software should support in this international
    world. The **Unicode** standard is the universal approach to handling internationalized
    text, but this *multi-byte* (using more than a single byte to represent a letter
    or symbol) format can cause problems when introduced to software that was not
    designed to understand it. Users and developers alike now expect these complex
    encodings to be supported, and so the drawbacks of older toolkits continue to
    grow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C语言（及其许多衍生语言）常因对字符串类型的处理能力弱而受到批评。事实上，正是这种缺陷导致了众多高度可见的软件漏洞和公开数据泄露。尽管并非所有较老的编程语言都存在这个问题，但它们几乎都只支持使用*拉丁字母*的简单字符串（尽管一些有附加库尝试解决这个问题）。在这种限制下，编写一个能够轻松适应软件应支持的国际世界中各种常见语言的程序是困难的。**Unicode**标准是处理国际化文本的通用方法，但这种*多字节*（使用多个字节来表示一个字母或符号）格式在引入到未设计为理解它的软件时可能会引起问题。用户和开发者现在都期望支持这些复杂的编码，因此较老工具包的缺点继续增加。
- en: As you can see, there are a number of challenges in developing, or working with,
    a graphical toolkit that could be overcome if we start from scratch. And so, the
    Fyne toolkit decided to do just that, but to do so required a choice as to which
    programming language to use. As we know, Go was picked for Fyne—in the next section,
    we look at why it was seen to be a good fit to overcome the challenges faced.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在开发或使用图形工具包时存在许多挑战，如果我们从头开始，这些问题是可以克服的。因此，Fyne工具包决定这样做，但这样做需要选择使用哪种编程语言。正如我们所知，Go被选为Fyne——在下一节中，我们将探讨为什么它被认为是一个克服所面临挑战的好选择。
- en: How Go is a great fit for this challenge
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言非常适合这个挑战
- en: In the previous section, we saw that there are many reasons why graphical toolkits
    are rooted in dated foundations and that even the languages they are built with
    could be limiting their chances of adapting. A number of manufacturers are recognizing
    this problem and reaching to new languages to find solutions or even avoid the
    challenges of the past completely. Apple is moving all development to the Swift
    language, although Apple-supported software is designed to run on their devices
    only. Other companies, such as Facebook, are finding ways to adapt more modern
    web-based tools to create native apps for phones and desktop.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了许多原因说明图形工具包根植于过时的基础，以及它们所使用的语言可能限制了它们适应的机会。许多制造商正在认识到这个问题，并转向新的语言以寻找解决方案，甚至完全避免过去的挑战。苹果公司正在将所有开发迁移到
    Swift 语言，尽管苹果支持的软件仅设计在他们的设备上运行。其他公司，如 Facebook，正在寻找方法将更现代的基于网络的工具适应，以创建适用于手机和桌面的原生应用程序。
- en: Neither the approach of a platform-specific technology nor languages derived
    from the interpreted internet technologies are going to be able to truly create
    a delightful development experience. We are looking for a development platform
    that results in performant and robust, cross-platform applications—the panacea
    of modern application development. I, the author of this book and indeed the Fyne
    project, believe that Go may be the language to underpin such a revolution in
    building cross-platform graphical applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是特定平台的技术方法还是源自解释型互联网技术的语言，都无法真正创造出令人愉悦的开发体验。我们正在寻找一个能够产生性能优异且健壮的跨平台应用程序的开发平台——这是现代应用程序开发的万能药。作为本书的作者，以及
    Fyne 项目的开发者，我相信 Go 可能是支撑这种跨平台图形应用程序革命的语言。
- en: To quote the Go frequently asked questions on this topic, refer to [https://golang.org/doc/faq](https://golang.org/doc/faq).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 Go 经常被问及的关于这个话题的问题，请参阅 [https://golang.org/doc/faq](https://golang.org/doc/faq)。
- en: Go addressed these issues by attempting to combine the ease of programming of
    an interpreted, dynamically typed language with the efficiency and safety of a
    statically typed, compiled language. It also aimed to be modern, with support
    for networked and multicore computing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go 通过尝试将解释型、动态类型语言的编程便捷性与静态类型、编译型语言的效率和安全性相结合来解决这些问题。它还旨在成为现代语言，支持网络和多核计算。
- en: In this section, we will look at the various reasons why the Go programming
    language is well placed to support a new era of GUI programming.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨为什么 Go 编程语言非常适合支持新一代的图形用户界面编程。
- en: Simple cross-platform code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的跨平台代码
- en: Go is a language that (like C, C++, Swift, and many others) compiles to a native
    binary on every platform it supports. This is important for graphical applications
    as it’s the best way to create the most responsive and smoothest user interfaces
    on mainstream computer hardware. What stands out about Go compared to other languages
    that are popular with GUI developers is that it manages to support a long list
    of operating systems while compiling, without any alterations or special adaptation,
    to native code on every platform. This means that a Go-based project can be built
    on any computer for any other computer, using the standard tools, with no need
    for complex build configurations or extra developer packages to be installed.
    At the time of writing, the platforms that Go runs on includes Windows, macOS,
    Linux, Solaris, and other popular Unix-based operating systems (which is essentially
    all desktop personal computers) along with iOS, Android, and other Linux-based
    mobile devices (and even tiny embedded computers via TinyGo).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种语言（类似于 C、C++、Swift 以及许多其他语言），它可以在每个它支持的平台上编译成原生二进制文件。这对于图形应用程序来说非常重要，因为这是在主流计算机硬件上创建最响应和最流畅的用户界面的最佳方式。与其他流行的
    GUI 开发者语言相比，Go 的突出之处在于它能够在编译时支持大量操作系统，而无需任何修改或特殊适应，就可以在每个平台上生成原生代码。这意味着基于 Go 的项目可以在任何计算机上构建，用于其他任何计算机，使用标准工具，无需复杂的构建配置或额外安装的开发者包。在撰写本文时，Go
    运行的平台包括 Windows、macOS、Linux、Solaris 以及其他流行的基于 Unix 的操作系统（这基本上是所有桌面个人计算机），以及 iOS、Android
    和其他基于 Linux 的移动设备（甚至通过 TinyGo 在微型嵌入式计算机上）。
- en: Go is a *typed* language, which means that every variable, constant, function
    parameter, and return type must have a single, defined type—leading to robust
    code by default. Unlike some older typed languages, Go is often able to infer
    a type, which helps avoid the duplication of information in the source code (in
    fact, one of Go’s design principles is to avoid duplication). These features help
    to create a language that’s fast and fun to develop with, while creating software
    that is as solid as the languages traditionally used for native graphical apps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种*类型化*语言，这意味着每个变量、常量、函数参数和返回类型都必须有一个单一、已定义的类型——这导致默认情况下代码更加健壮。与一些较老的类型化语言不同，Go通常能够推断类型，这有助于避免源代码中的信息重复（实际上，Go的设计原则之一就是避免重复）。这些特性帮助创建了一个既快速又易于开发的语言，同时创建的软件与传统用于原生图形应用的编程语言一样稳固。
- en: In addition to being easy to learn and simple to read, the Go language comes
    with well communicated standards for code style, documentation, and testing. Standardization
    such as this makes it easy for developers to understand different projects and
    reduces the time required to integrate libraries and learn new APIs. As well as
    documenting these standards, the Go development tools include utilities that can
    check whether your code meets these guidelines. In many cases, they can even update
    your source code files to comply automatically. Quite naturally, the development
    environments that support Go also encourage following the guidelines, making it
    even easier to reduce the learning curve for anyone joining your project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了易于学习和易于阅读之外，Go语言还提供了关于代码风格、文档和测试的良好沟通标准。这种标准化使得开发者更容易理解不同的项目，并减少了集成库和学习新API所需的时间。除了记录这些标准之外，Go开发工具包括可以检查你的代码是否符合这些指南的实用工具。在许多情况下，它们甚至可以自动更新你的源代码文件以符合这些指南。很自然地，支持Go的开发环境也鼓励遵循这些指南，这使得任何加入你项目的人的学习曲线更加平缓。
- en: As well as standard formats for source code and documentation for all APIs,
    the Go language and community support and encourage unit testing in apps and libraries.
    The compiler has built-in test functionality normally associated with *dynamic*
    languages that need this sort of check to ensure correctness. The inclusion of
    effective testing alongside an already robust language provides validation of
    code behavior and makes it easier for code to be changed by individuals other
    than those that created it. In fact, in a collection of popular Go libraries,
    one of the requirements for being listed is that your code meets an 80% unit test
    code coverage metric (see [https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)
    and their contribution guidelines).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有API的源代码和文档的标准格式外，Go语言及其社区支持和鼓励在应用程序和库中进行单元测试。编译器内置了通常与*动态*语言相关联的测试功能，这些语言需要此类检查以确保正确性。在已经强大的语言中加入有效的测试功能，可以验证代码行为，并使得其他人更容易修改代码。实际上，在流行的Go语言库集合中，被列入的要求之一是你的代码满足80%的单元测试代码覆盖率指标（参见[https://github.com/avelino/awesome-go](https://github.com/avelino/awesome-go)及其贡献指南）。
- en: Standard library
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库
- en: The standard library of a programming language is the set of APIs and features
    that are provided by the language runtime. C, for example, has a very small standard
    library—as a low-level language designed for many different types of devices,
    the number of features that it can support for every operating system is limited.
    Java, on the other hand, historically known for being heavy on memory and start
    up time, provides a massive standard library—including the Swing GUI described
    in [*Chapter 1*](B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015), *A Brief History
    of GUI Toolkits and Cross-Platform Development*. This is a trade-off that all
    languages need to make when deciding in favor of smaller memory or lots of built-in
    features.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的标准库是指由语言运行时提供的API集合和功能。例如，C语言有一个非常小的标准库——作为一种为多种不同设备设计的底层语言，它能够支持的每个操作系统的功能数量是有限的。另一方面，Java语言因其内存和启动时间较重而闻名，提供了一个庞大的标准库——包括在[*第一章*](B16820_01_Final_JM_ePub.xhtml#_idTextAnchor015)中描述的Swing
    GUI，*GUI工具包和跨平台开发简史*。这是所有语言在决定是优先考虑较小的内存还是大量内置功能时都需要做出的权衡。
- en: Thankfully, the Go language makes a clever balance, allowing it to comprise
    a large library of APIs that fully support every one of its target operating systems.
    To do this, it makes use of **build tags** that allow inclusion of only the code
    needed for the current (or target) operating system. This is a huge advantage
    for developers who want to write an efficient application for multiple operating
    systems without maintaining slightly different versions for each platform, or
    suffering slow load times or large memory requirements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Go语言做出了聪明的平衡，使其能够包含一个庞大的API库，完全支持其目标操作系统中的每一个。为此，它使用了**构建标签**，允许只包含当前（或目标）操作系统所需的代码。这对于想要为多个操作系统编写高效应用程序的开发者来说是一个巨大的优势，他们不需要为每个平台维护略有不同的版本，也不需要忍受缓慢的加载时间或大量的内存需求。
- en: The standard library included with Go includes powerful features across many
    areas, including cryptography, image manipulation, text handling (including Unicode),
    networking, concurrency, and web service integration (we will cover this in the
    sections to come). You can read the full documentation at [https://golang.org/pkg/#stdlib](https://golang.org/pkg/#stdlib).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Go的标准库包含了涵盖许多领域的强大功能，包括密码学、图像处理、文本处理（包括Unicode）、网络、并发和网络服务集成（我们将在后续章节中介绍）。您可以在[https://golang.org/pkg/#stdlib](https://golang.org/pkg/#stdlib)上阅读完整的文档。
- en: Concurrency
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发
- en: As illustrated in the *Parallelism and web services* section earlier, a modern
    programming language needs to handle concurrency. Unfortunately, working with
    the APIs to manage multithreading can add complexity and make code harder to read.
    The designers of Go decided that concurrency should be incorporated from the beginning,
    making it easy to manage many threads of execution while still avoiding the difficulty
    of shared memory management. GUI toolkits built on languages without this built-in
    awareness of concurrency have propagated the idea that graphical routines must
    happen on a particular thread. By starting from scratch with a better suited language,
    we can avoid such constraints.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文在 *并行性和网络服务* 部分所述，现代编程语言需要处理并发问题。不幸的是，使用API来管理多线程可能会增加复杂性，并使代码更难以阅读。Go的设计者决定从一开始就将并发性纳入其中，使得管理许多执行线程变得容易，同时避免了共享内存管理的困难。基于没有这种内置并发意识的语言的GUI工具包已经传播了这样的观点：图形例程必须在特定的线程上执行。通过从更好的语言开始，我们可以避免这样的限制。
- en: Go does not expose traditional threads, but instead introduces the concept of
    **goroutines**—these are akin to lightweight threads, but that are enhanced to
    support several thousand at the same time. It is common for applications to communicate
    between background processes by sharing memory, but this introduces issues known
    as *race conditions*, requiring more code to manage access. To avoid this, Go
    provides **channels**—a mechanism for communicating between threads of execution
    without causing the same problems. With this model, the language manages the safe
    transfer of information from one goroutine to another, keeping multithread code
    neat and easy to understand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go不暴露传统的线程，而是引入了**goroutines**的概念——这些类似于轻量级线程，但增强了以支持同时运行数千个。应用程序之间通过共享内存进行通信是很常见的，但这引入了称为*竞争条件*的问题，需要更多的代码来管理访问。为了避免这种情况，Go提供了**通道**——一种在执行线程之间通信而不引起相同问题的机制。在这个模型中，语言管理从goroutine到另一个goroutine的安全信息传输，使多线程代码整洁且易于理解。
- en: Web services
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络服务
- en: As a modern programming language, Go comes with extensive support for HTTP clients,
    servers, and standard encoding handlers, including JSON and XML. For GUI developers
    coming from a background in C programming, this is a significant improvement—web
    services, and indeed remote resources, were not commonplace when the language
    or its toolkits were created.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种现代编程语言，Go提供了对HTTP客户端、服务器和标准编码处理器的广泛支持，包括JSON和XML。对于来自C编程背景的GUI开发者来说，这是一个重大的改进——当语言或其工具包被创建时，网络服务和远程资源并不常见。
- en: Thanks to language-level support for text encoding used in web communications,
    it is possible to load data structures directly from an HTTP request. Such convenience
    may be standard for web-based languages such as JavaScript and PHP, but to function
    in a strictly typed language without using third-party code is a rare bonus.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言级别对网络通信中使用的文本编码的支持，可以直接从HTTP请求中加载数据结构。这种便利性对于基于Web的语言（如JavaScript和PHP）来说可能是标准的，但在严格类型化的语言中不使用第三方代码就能实现这一点是罕见的额外优势。
- en: Despite these features that make Go an excellent language for building complex
    applications that can be described at a high level and thoroughly tested, it is
    also possible to perform platform-specific requests to the operating system if
    required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些特性使Go成为构建可以以高级别描述并彻底测试的复杂应用程序的优秀语言，但在需要时，也可以对操作系统执行特定平台请求。
- en: High level with system access
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级系统访问
- en: Even with a fully featured programming language, it can be occasionally necessary
    to access low-level components or platform-specific APIs. Whether it is to send
    a notification, read data from a custom device, or simply to call a function specific
    to the current operating system, it will occasionally be necessary to access functionality
    that is not included in a programming language or its standard library. To solve
    this challenge, Go provides three avenues to handle the platform-specific aspects
    of a program—syscall, CGo, and build tags.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使拥有功能齐全的编程语言，有时也可能会需要访问低级组件或特定平台的API。无论是为了发送通知、从自定义设备读取数据，还是简单地调用当前操作系统的特定函数，有时可能需要访问编程语言或其标准库中未包含的功能。为了解决这一挑战，Go提供了三条途径来处理程序的特定平台方面——syscall、CGo和构建标签。
- en: Build tags
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建标签
- en: In Go, it is possible to include part of your code for specific operating systems
    at a per-file level based on some conditional parameters called **build tags**.
    This can be helpful to adjust behavior when your app will run on certain systems,
    but is more beneficial in controlling the inclusion of the platform-specific use
    of syscall or CGo code illustrated in the next sections.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你可以根据一些称为**构建标签**的条件参数，在文件级别为特定操作系统包含部分代码。这有助于在应用程序将在某些系统上运行时调整行为，但在控制下一节中展示的特定平台syscall或CGo代码的使用方面更有益。
- en: Even if your app is not making specific use of operating system-specific calls,
    it can be helpful to make use of the conditional compilation. In simple cases,
    Go code can check what system an app is running on to execute slightly different
    code (by checking the value of `os.GOOS`, for example, a function could return
    different values). However, for more behavioral changes, it can be useful to put
    the platform-specific code into separate files that are named in a certain convention
    (for example, `*_windows.go` will be included when building for Microsoft Windows)
    or through the use of the special comment at the top of a file (such as `// +build
    linux,darwin` including the file when Linux or macOS is the target platform).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的应用程序没有使用特定于操作系统的调用，利用条件编译也可能很有帮助。在简单情况下，Go代码可以检查应用程序正在运行的系统以执行略微不同的代码（例如，通过检查`os.GOOS`的值，一个函数可以返回不同的值）。然而，对于更复杂的行为变化，将特定平台代码放入以特定约定命名的单独文件中（例如，`*_windows.go`在为Microsoft
    Windows构建时将被包含）或通过在文件顶部使用特殊注释（例如，`// +build linux,darwin`在Linux或macOS是目标平台时包含文件）可能很有用。
- en: Syscall
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Syscall
- en: One of the packages provided by Go’s standard library is `os` and `net`, to
    provide higher-level abstractions, so double-check that the functionality you
    desire is not provided by another package before using syscall.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供的包之一是`os`和`net`，以提供高级抽象，因此在使用syscall之前，请务必检查你所需的功能是否由其他包提供。
- en: A typical call into this package might be to request details of a Windows registry
    key, or to load a DLL (a system library on a Windows computer) to access functionality
    not provided by Go. On a Linux computer, you may use this functionality to read
    or write to specific memory areas such as connected devices, where permitted.
    A system call is a very complicated procedure and, where possible, it will normally
    be easier to call a C function instead – we see how to do that with CGo next.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个包的典型调用可能是请求Windows注册表键的详细信息，或者加载DLL（Windows计算机上的系统库）以访问Go未提供的功能。在Linux计算机上，如果允许，你可以使用此功能读取或写入特定的内存区域，例如连接的设备。系统调用是一个非常复杂的程序，在可能的情况下，通常调用C函数会更简单——我们将在下一节中看到如何使用CGo来实现这一点。
- en: CGo
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CGo
- en: If your application, or one of the libraries that you rely upon, was written
    with the C language (or one of its derivatives, such as C++ or Objective-C) for
    specific reasons and you’re not able to move it to Go, then CGo is an invaluable
    feature. Using this functionality, it is possible to include C code directly,
    or call out to other C-based functionality. It is important to use this carefully—there
    are some performance impacts in making the jump from one language to another—but
    more significantly you need to remember about memory management and threading
    in a way that Go would normally manage for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序或您依赖的一个库出于特定原因是用C语言（或其衍生语言，如C++或Objective-C）编写的，并且您无法将其迁移到Go，那么CGo是一个无价的功能。使用此功能，可以直接包含C代码或调用其他基于C的功能。重要的是要小心使用此功能——从一种语言跳转到另一种语言会有一些性能影响——但更重要的是，您需要记住关于内存管理和线程的方式，这是Go通常会为您管理的。
- en: 'The following source code shows C and Go code in the same file where we convert
    a Go string into a C string (or, more strictly, a `[]byte`) and pass it into a
    C function. As you can see, we also need to free the memory we passed into the
    C code once it is no longer required:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码展示了在同一文件中C和Go代码的示例，其中我们将Go字符串转换为C字符串（或者更严格地说，转换为`[]byte`）并将其传递给C函数。正如您所看到的，一旦不再需要，我们还需要释放传递给C代码的内存：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code can be run just like any other Go program, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以像任何其他Go程序一样运行，如下所示：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the code snippet, you can see that the C code is included in a comment above
    the `import "C"` line. This code could be in a separate `.c` file or even within
    a library on the build computer (and the Go compiler will use `pkgconfig` to find
    the required headers). When used in combination with conditional building such
    as build tags in the previous code, you can see that it is possible to access
    platform-specific functionality or legacy code where required.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，您可以看到C代码包含在`import "C"`行上面的注释中。此代码可以位于单独的`.c`文件中，甚至可以在构建计算机上的库中（并且Go编译器将使用`pkgconfig`来查找所需的头文件）。当与之前的代码中的条件构建（如构建标签）结合使用时，您可以看到，在需要时可以访问特定平台的功能或遗留代码。
- en: This section considered the Go language and how its design is well suited to
    building a modern GUI toolkit. Next, we will look at how Material Design provides
    a great aesthetic for Fyne applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节考虑了Go语言及其设计如何非常适合构建现代GUI工具包。接下来，我们将探讨Material Design如何为Fyne应用程序提供出色的美学。
- en: Looking good with Material Design
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Material Design看起来很棒
- en: A key part of any GUI toolkit that can impact the developer’s selection and
    also the user appeal of the applications built is the overall design language.
    This choice of aesthetic can be seen in the colors, fonts, layouts, and even icon
    design. Some of these choices are obvious and others more subtle, but, when combined,
    result in a recognizable application look and feel.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 任何GUI工具包的关键部分都可能影响开发者的选择，以及构建的应用程序的用户吸引力，那就是整体设计语言。这种审美选择体现在颜色、字体、布局甚至图标设计中。其中一些选择很明显，而另一些则更为微妙，但结合在一起，就能产生一个可识别的应用程序外观和感觉。
- en: New cross-platform toolkits commonly create their own design, such as Java’s
    Swing or the GTK+ and Qt toolkits. These are often designed to look contemporary
    with the software of the time—you can recognize a 1990s desktop application design
    in those toolkits. In the current landscape, usability and design principles of
    mobile apps are being adapted and deployed to other areas, bringing a new age
    of software design to traditional applications. Because of its work in this space,
    the Material Design project makes a good match for application design aiming at
    universal cross-platform appeal.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新的跨平台工具包通常创建自己的设计，例如Java的Swing或GTK+和Qt工具包。这些通常设计得与当时软件的外观相匹配——您可以在这些工具包中识别出20世纪90年代的桌面应用程序设计。在当前的环境下，移动应用程序的可用性和设计原则正在被适应和部署到其他领域，为传统应用程序带来了软件设计的新时代。由于在这个领域的工作，Material
    Design项目非常适合旨在具有通用跨平台吸引力的应用程序设计。
- en: 'The official website for Material Design (`https://material.io`) describes
    material as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计的官方网站（`https://material.io`）对材料的描述如下：
- en: Material is an adaptable system of guidelines, components, and tools that support
    the best practices of user interface design. Backed by open source code, Material
    streamlines collaboration between designers and developers, and helps teams quickly
    build beautiful products.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 材料是一个灵活的系统，包括指南、组件和工具，支持用户界面设计的最佳实践。由开源代码支持，Material简化了设计师和开发者之间的协作，并帮助团队快速构建美观的产品。
- en: Google first published the Material Design guidelines in 2014 based on their
    earlier work on a new design language for their websites. It has since been applied
    to their different web properties and has also become the visual design for the
    Android operating system. This adaptation meant that the component designs have
    identified areas that work across all platforms and also where slight adaptation
    may be required for desktop computers, reducing the work required by Fyne or other
    cross-platform toolkits that use its design language.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Google首次于2014年发布了基于他们之前为网站开发的新设计语言的Material Design指南。此后，它已被应用于其不同的网络属性，并已成为Android操作系统的视觉设计。这种适应性意味着组件设计已经确定了适用于所有平台的工作区域，同时也确定了可能需要为桌面计算机进行轻微调整的区域，从而减少了Fyne或其他使用其设计语言的跨平台工具包所需的工作。
- en: The layout and functionality of the standard components varies by platform,
    and implementation though clear recommendations is documented at the main website,
    [https://material.io](https://material.io). What can be more universally recognized
    is the color palette and iconography used in material-based apps.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 标准组件的布局和功能因平台而异，尽管在主网站上提供了明确的推荐，但实现方式在[https://material.io](https://material.io)上有文档记录。更普遍的是，材料应用中使用的调色板和图标图形。
- en: Color palette
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调色板
- en: 'Material Design colors are oriented around a standard color palette. A primary
    color is used to raise the importance of certain elements, such as default buttons
    or focused input. A complementary secondary color is (optionally) reserved for
    accenting important items, such as floating buttons or selected text. The Material
    Design project provides a baseline color theme that can be used with any app.
    Developers may also choose their own primary and secondary colors to match their
    brand identity or preferred aesthetic. Here is the baseline color palette:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计颜色围绕标准调色板进行设计。主色用于提高某些元素的重要性，例如默认按钮或焦点输入。辅助的次级颜色（可选）保留用于强调重要项目，例如浮动按钮或选中文本。Material
    Design项目提供了一个基线颜色主题，可用于任何应用程序。开发者也可以选择自己的主色和次级颜色，以匹配其品牌身份或首选的美学。以下是基线调色板：
- en: '![Figure 2.1 – The material design ”baseline” color palette'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 材料设计“基准”调色板'
- en: '](img/B16820_02_01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B16820_02_01.jpg]'
- en: Figure 2.1 – The material design ''baseline'' color palette
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 材料设计“基准”调色板
- en: The striking colors of a material theme help an application to have a clean
    design while conveying meaning and importance. Similarly, the material design
    offers a set of clean, crisp icons that should be used where possible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 材料主题的醒目颜色有助于应用程序拥有干净的设计，同时传达意义和重要性。同样，材料设计提供了一套干净、清晰的图标，应在可能的情况下使用。
- en: Standard icons
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准图标
- en: 'The material icons are designed to be *delightful and beautifully crafted*
    and cover the common interactions and standard items for most modern software.
    They cover topics such as standard hardware, file types, content operations, and
    user actions. As well as the standard icon set, there are repositories of community
    submitted add-ons that can be useful for applications that employ fewer standard
    operations. In the following screenshot, we can see some material design icons:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 材料图标设计得既令人愉悦又精美，涵盖了大多数现代软件的常见交互和标准项目。它们包括标准硬件、文件类型、内容操作和用户动作等主题。除了标准图标集外，还有社区提交的附加组件库，对于采用较少标准操作的应用程序可能很有用。在下面的屏幕截图中，我们可以看到一些材料设计图标：
- en: '![Figure 2.2 – A small selection of material design icons'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 材料设计图标的小选集'
- en: '](img/B16820_02_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B16820_02_02.jpg]'
- en: Figure 2.2 – A small selection of material design icons
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 材料设计图标的小选集
- en: By following the material design specification, any apps built using the Fyne
    toolkit will be clean and easy to use from the outset, while supporting an element
    of brand identity and customization.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循材料设计规范，使用Fyne工具包构建的任何应用程序都将从一开始就干净、易于使用，同时支持品牌身份和定制。
- en: We have seen how Fyne-based apps look to the end user, but for a developer,
    the API design is just as important. Let’s look at how the team aim to keep that
    just as clean and well crafted.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了基于Fyne的应用程序对最终用户的外观，但对于开发者来说，API设计同样重要。让我们看看团队如何旨在保持这种简洁和精心制作的设计。
- en: Designing APIs for simplicity and maintainability
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为简洁性和可维护性设计API
- en: A delightful user experience is an important ambition for any application toolkit,
    but Fyne aims to make the experience of development a pleasure as well. To do
    this, the API must be planned carefully to be simple and easy to learn, but also
    extensible to support more complex applications. The project’s modular approach
    aims to support this while also being testable every step of the way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 令人愉悦的用户体验是任何应用程序工具包的重要目标，但Fyne旨在使开发体验也变得愉快。为此，API必须精心设计，既简单易学，又可扩展以支持更复杂的应用程序。项目的模块化方法旨在支持这一点，同时每一步都易于测试。
- en: Semantic API
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义API
- en: An **API** (or **Application Programming Interface**) is typically defined as
    a set of functions and procedures that controls access to features and data. At
    a high level, however, the Fyne toolkit aims to deliver a *semantic API*, a set
    of functions that defines intent rather than features or functionality. By taking
    this approach, the toolkit is able to separate meaning from presentation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**API**（或**应用程序编程接口**）通常被定义为控制对特性和数据访问的一组函数和过程。然而，在较高层次上，Fyne工具包旨在提供一种*语义API*，一组定义意图而不是特性和功能的函数。通过采取这种方法，工具包能够将意义与表现分离。'
- en: 'For example, we can consider a simple button—when there are many on a screen,
    you may wish for one to stand out against the other as more important. In an API
    that is focused on presentation or styles, you might set the button color; with
    the Flutter GUI toolkit, this would appear as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以考虑一个简单的按钮——当屏幕上有许多按钮时，你可能希望其中一个能够突出显示，显得更重要。在一个专注于表现或样式的API中，你可能设置按钮颜色；在Flutter
    GUI工具包中，这会显示如下：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In comparison, an API that takes a semantic approach would allow developers
    to indicate the expected difference through a button type or intent field, as
    the following Fyne snippet does:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，采用语义方法的API将允许开发者通过按钮类型或意图字段来指示预期的差异，如下面的Fyne片段所示：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Following this approach allows for a consistent API that describes the expected
    outcomes instead of features that could hint at those outcomes. It also allows
    the current theme to ensure a consistent visual style and avoids developer-defined
    code creating unreadable or unattractive graphical choices.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法可以提供一个一致的API，它描述了预期的结果而不是可能暗示这些结果的特性。它还允许当前主题确保一致的视觉风格，并避免开发者定义的代码创建难以阅读或不吸引人的图形选择。
- en: Modular
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: When building a robust toolkit designed to work seamlessly across many different
    operating systems and computers, it is important to take a modular approach. Doing
    so ensures that no element of the library will be able to make false assumptions
    about other areas of the code. To accidentally expose all the inner details of
    a key area, such as a graphics driver, might restrict a widget to function correctly
    on a single operating system or in a particular graphics mode. This technique
    is known in software engineering as **Separation of Concerns**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个旨在跨多个不同的操作系统和计算机无缝工作的强大工具包时，采用模块化方法非常重要。这样做可以确保库的任何元素都不会对代码的其他区域做出错误的假设。不小心暴露关键区域（如图形驱动程序）的所有内部细节，可能会限制小部件只能在单个操作系统或特定图形模式下正确运行。这种技术在软件工程中被称为**关注点分离**。
- en: In the Go language, modules are known as **packages** and they are structured
    hierarchically under the project root. To allow different parts of the system
    to communicate, a project typically defines a collection of **interface** types
    that describe the functionality, and dependencies that some code may choose to
    conform to. By loading code that implements these interfaces, an application or
    library can compose separate elements of code to create the complete solution.
    Each area is only aware of the declared capability that each interface publicizes
    and can hide all of the inner details. This allows complex software to be built
    and tested in smaller pieces, which is far easier to test and even to debug if
    something goes wrong.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，模块被称为**包**，并且它们在项目根目录下以层次结构组织。为了允许系统的不同部分进行通信，项目通常定义一组**接口**类型，这些类型描述了功能，以及某些代码可能选择遵守的依赖关系。通过加载实现这些接口的代码，应用程序或库可以将代码的独立元素组合在一起以创建完整的解决方案。每个区域只知道每个接口公开声明的功能，可以隐藏所有内部细节。这允许通过更小的部分构建和测试复杂的软件，如果出现问题，这要容易得多。
- en: In Fyne, the use of packages can be seen in many areas, with the most notable
    being implementations of the `Driver` and `Widget` interface definitions. The
    use of drivers in the Fyne toolkit makes it possible for applications to run on
    many different types of computers without needing to know, or accidentally taking
    advantage of, specific details of a single device. When an application starts,
    the correct driver will be loaded to handle specific details of running on the
    current computer. As you will see in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*, the various widgets inside Fyne (and indeed custom
    ones that can be added by app developers) all implement the `Widget` interface.
    The behavior that all widgets must implement provides information to the driver
    and graphics code about how it should appear, meaning that the graphics code does
    not need to know any inner details of a widget to be able to draw it in an application
    window. This makes it possible for widget developers to avoid impacting graphics
    code, and indeed for other developers to add custom widgets outside the toolkit
    code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fyne中，包的使用可以在许多地方看到，最显著的是`Driver`和`Widget`接口定义的实现。Fyne工具包中使用驱动程序使得应用程序能够在许多不同类型的计算机上运行，而无需了解或意外利用单个设备的特定细节。当应用程序启动时，正确的驱动程序将被加载来处理当前计算机运行的特定细节。正如您将在[*第5章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)“小部件库和主题”中看到的那样，Fyne内部的各种小部件（以及确实可以由应用程序开发者添加的自定义小部件）都实现了`Widget`接口。所有小部件必须实现的行为为驱动程序和图形代码提供了有关其外观的信息，这意味着图形代码不需要了解小部件的任何内部细节就能在应用程序窗口中绘制它。这使得小部件开发者能够避免影响图形代码，并且确实允许其他开发者在工具包代码之外添加自定义小部件。
- en: One other benefit of a modular approach is that code can be executed without
    launching in a standard application or showing any windows. This may not be a
    common requirement for user-facing code, but it is very important to support the
    efficient testing of applications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化方法的一个其他好处是代码可以在不启动标准应用程序或显示任何窗口的情况下执行。这可能不是面向用户的代码的常见要求，但对于支持应用程序的高效测试来说非常重要。
- en: Testable
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试
- en: Automated testing of graphical user interface code has long been considered
    one of the hardest steps of a full test suite, and this becomes even more difficult
    if you add smart phones or mobile devices to your supported platforms. Each operating
    system may require a different methodology and probably also specific code to
    be written and maintained in order to run the test suite. As mentioned in the
    previous section, the modular approach taken by the Fyne toolkit promises easier
    testing by not requiring applications to be displayed for the test scripts to
    execute.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 自动测试图形用户界面代码长期以来一直被认为是完整测试套件中最困难的一步，如果你将智能手机或移动设备添加到你的支持平台中，这会变得更加困难。每个操作系统可能需要不同的方法，可能还需要编写和维护特定的代码来运行测试套件。正如前文所述，Fyne工具包采用的模块化方法通过不需要显示应用程序来执行测试脚本，从而承诺更容易地进行测试。
- en: 'Because of its modular design, the drawing components of a Fyne-based application
    are a minor detail. The main logic and behavior of widgets are defined completely
    separately to the graphical output. This approach allows all elements to be tested
    through automated interactions faster and more reliably than alternative tools
    that load applications and then tap buttons using test runners that control the
    mouse and keyboard (or touchscreen) hardware. The following code snippet shows
    how a `Button` and `Entry` widget could be tested in a simple unit test:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其模块化设计，基于Fyne的应用程序的绘图组件是一个小细节。小部件的主要逻辑和行为与图形输出完全分开定义。这种方法允许所有元素通过自动化交互更快、更可靠地进行测试，比加载应用程序然后使用控制鼠标和键盘（或触摸屏）硬件的测试运行器点击按钮的替代工具更快、更可靠。以下代码片段显示了如何在简单的单元测试中测试`Button`和`Entry`小部件：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, these two simple unit tests (using the standard Go test structure)
    are able to test that the `Button` and `Entry` widgets behave as expected when
    standard user interactions occur. The test helpers `Tap` and `Type` are provided
    to perform these actions, along with various other utilities in the `test` package.
    By building up a test suite in this manner, you can execute thousands of GUI tests
    per second, without ever having to load a window or connect to a specific device.
    In fact, this very functionality supports true TDD for graphical applications.
    This approach means that application code can be designed and understood before
    it is implemented, leading to more robust software and better decoupling of modules,
    thereby allowing more developers to work on a project concurrently.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这两个简单的单元测试（使用标准的Go测试结构）能够测试在标准用户交互发生时`Button`和`Entry`小部件的行为是否符合预期。测试辅助函数`Tap`和`Type`被提供以执行这些操作，以及`test`包中的各种其他实用工具。通过这种方式构建测试套件，你可以每秒执行数千个GUI测试，而无需加载窗口或连接到特定的设备。实际上，这个功能支持图形应用程序的真正TDD（测试驱动开发）。这种方法意味着在实现之前，可以设计和理解应用程序代码，从而产生更健壮的软件和更好的模块解耦，使得更多的开发者可以并行工作在一个项目上。
- en: 'The Fyne toolkit will ensure that all elements will be presented correctly
    on any device that your app will be distributed to. Its drivers and widgets all
    undergo the same testing rigor described earlier in this section. Sometimes, however,
    it is necessary to test the actual rendered output of a widget or screen. In this
    situation, the `test` package has more utilities that can aid your development.
    Although not visible on your screen, the Fyne test code will calculate how the
    output would look and can save this to an image through a `Capture()` function.
    The test helper `AssertImageMatches` is then able to compare this to a specific
    output either saved earlier or created by a designer:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包将确保所有元素都将正确地显示在应用程序将分发的任何设备上。其驱动程序和小部件都经过与本章前面所述相同的测试严格性。然而，有时有必要测试小部件或屏幕的实际渲染输出。在这种情况下，`test`包提供了更多可以帮助你开发的实用工具。尽管这些工具在屏幕上不可见，但Fyne测试代码将计算输出将如何显示，并通过`Capture()`函数将其保存到图像中。然后，测试辅助函数`AssertImageMatches`能够将此与之前保存或由设计师创建的特定输出进行比较：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code sample does include some details about `Window` and `Canvas` that
    we will cover in [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*, but you can see the overall simplicity. The code
    defines a widget (in this case a `Button` widget), and then adds it to a test
    window that is then captured and compared to a pre-existing image file. The test
    window is not shown on screen or even communicated to the operating system—it
    is loaded purely in memory to simulate the drawing process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例确实包含了一些关于`Window`和`Canvas`的细节，这些内容我们将在[*第3章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)“窗口、画布和绘图”中进行讲解，但你可以看到其整体上的简洁性。代码定义了一个小部件（在这种情况下是一个`Button`小部件），然后将其添加到一个测试窗口中，该窗口随后被捕获并与一个预先存在的图像文件进行比较。测试窗口不会显示在屏幕上，甚至不会与操作系统通信——它完全加载到内存中，以模拟绘图过程。
- en: We have seen how good modularity and testing can result in more robust applications,
    but this has described the toolkit design—is it possible for developers to extend
    the functionality for their own purposes?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到良好的模块化和测试如何导致更健壮的应用程序，但这里描述的是工具包设计——开发者是否可以为自己的目的扩展功能？
- en: Extensible
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性
- en: The core widgets of the Fyne toolkit are designed to be robust, easy to use,
    and well tested, but a toolkit cannot include every possible type of widget. For
    this reason, a toolkit also needs to be extensible, supporting the inclusion of
    widgets that were not defined by the core project—either as add-on libraries or
    by allowing applications to add their own custom user interface elements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包的核心小部件被设计成健壮、易于使用且经过良好测试，但工具包不能包含所有可能类型的小部件。因此，工具包也需要是可扩展的，支持包含核心项目未定义的小部件——无论是作为附加库还是允许应用程序添加它们自己的自定义用户界面元素。
- en: The Fyne project allows widgets to be included in two different ways—developers
    can extend existing widgets (keeping the main rendering consistent, but adding
    new functionality) or by adding their own widgets. As described in the *Modular*
    section earlier, any code that implements the `Widget` interface will be interpreted
    as an interface component and can be used throughout any Fyne application. Later
    in this book, we will also see how existing widgets can be extended to add new
    functionality or tweak behavior to suit a particular application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne项目允许以两种不同的方式包含小部件——开发者可以扩展现有的小部件（保持主要渲染的一致性，但添加新功能）或者添加他们自己的小部件。如前文在*模块化*部分所述，任何实现`Widget`接口的代码都将被解释为接口组件，并可以在任何Fyne应用程序中使用。在本书的后续部分，我们还将看到如何扩展现有的小部件以添加新功能或调整行为以适应特定应用程序。
- en: Due to the interface-based design of the modular code base, there are many other
    ways in which a Fyne application can be extended. By implementing the `Layout`
    interface, an app can define its component position and sizing, or, using the
    URI interface, it could connect to different types of data resources (for more
    information, see [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模块化代码库基于界面设计，Fyne应用程序可以以许多其他方式扩展。通过实现`Layout`接口，应用程序可以定义其组件的位置和大小，或者，使用URI接口，它可以连接到不同类型的数据资源（更多信息，请参阅[*第4章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)，*布局和文件处理*)。
- en: As you can see, the design of a toolkit and its API is just as important as
    the functionality it contains. To complete this chapter, let’s review the overall
    vision of the Fyne project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，工具包及其API的设计与它所包含的功能一样重要。为了完成本章，让我们回顾一下Fyne项目的整体愿景。
- en: A vision of the future
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对未来的展望
- en: The Fyne project was created in response to growing criticism of the complexity
    in existing graphical toolkits and application APIs and their inability to adapt
    to modern devices and best practices. It was designed with the aim of being easy
    to use, and the Go language was chosen for its powerful simplicity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne项目是在对现有图形工具包和应用API的复杂性日益增长的批评以及它们无法适应现代设备和最佳实践的背景下创建的。该项目旨在易于使用，并选择了Go语言，因为它具有强大的简洁性。
- en: 'The vision statement on the Fyne project wiki ([https://github.com/fyne-io/fyne/wiki/Vision](https://github.com/fyne-io/fyne/wiki/Vision))
    states the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne项目维基上的愿景声明([https://github.com/fyne-io/fyne/wiki/Vision](https://github.com/fyne-io/fyne/wiki/Vision))如下所述：
- en: Fyne’s APIs aim to be the best for developing beautiful, usable, and lightweight
    applications for desktop and beyond.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne的API旨在为开发美观、易用且轻量级的桌面和更多平台上的应用程序提供最佳方案。
- en: With more device types and platform-specific toolkits than we have seen in recent
    times, it is more difficult, and more expensive than ever, to deliver a great
    native app experience across all platforms. The Fyne toolkit is positioned as
    a solution to these challenges, while bringing the design and user experience
    learning from modern mobile apps to all devices.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备类型和平台特定工具包的数量比我们最近看到的要多，要在所有平台上提供出色的原生应用程序体验变得更加困难，成本也更高。Fyne工具包定位为解决这些挑战的解决方案，同时将现代移动应用程序的设计和用户体验学习带到所有设备上。
- en: Beautiful apps
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 美观的应用程序
- en: Fyne aims to support the building of graphical applications that look consistent
    across all platforms, rather than adopting the look and feel of the operating
    system. Its APIs ensure that all apps provide a polished user experience and render
    a beautiful application GUI. Using the Material Design guidelines, a Fyne-based
    app will look familiar to Android users and match the aesthetic of the flat user
    interface in Windows 10\. For operating systems where the user interface is typically
    in a different style, users will still be delighted by the crisp visual design,
    bundled icons, and clean typography.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne旨在支持构建在所有平台上看起来一致的图形应用程序，而不是采用操作系统的外观和感觉。其API确保所有应用程序都提供精致的用户体验并渲染美观的应用程序GUI。遵循Material
    Design指南，基于Fyne的应用程序将让Android用户感到熟悉，并与Windows 10的扁平用户界面美学相匹配。对于用户界面通常采用不同风格的操作系统，用户仍会为清晰的视觉设计、捆绑的图标和干净的字体感到高兴。
- en: 'As many operating systems now offer a choice of light and dark modes, toolkits
    need to adapt appropriately to meet user expectations. All Fyne apps include a
    light and dark theme and, unless the developer overrides the setting, it will
    match the current system configuration. When end users change their system theme,
    any running Fyne apps will update to reflect configuration changes. This is shown
    in the following image, we see what the light and dark Fyne themes look like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多操作系统现在提供浅色和深色模式的选择，工具包需要相应地适应以满足用户期望。所有Fyne应用程序都包括浅色和深色主题，除非开发者覆盖设置，否则它将匹配当前的系统配置。当最终用户更改系统主题时，任何正在运行的Fyne应用程序都将更新以反映配置更改。这将在以下图像中显示，我们看到浅色和深色Fyne主题的外观：
- en: '![](img/B16820_02_03_-__Combine.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16820_02_03_-__Combine.jpg)'
- en: Simple to learn
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容易学习
- en: As well as maintaining a clean, simple design, the Fyne team wants to ensure
    that everyone can learn to build graphical applications. To do this, the barrier
    to entry needs to be low—through simple installation and setup with documentation
    and tutorials readily available to support even the most inexperienced developer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保持简洁、简单的设计外，Fyne团队还希望确保每个人都能学会构建图形应用程序。为此，入门门槛需要低——通过简单的安装和设置，以及文档和教程的 readily
    可用，以支持甚至是最没有经验的开发者。
- en: Developers who have not used the Go language before can start with the online
    tour ([https://tour.golang.org/](https://tour.golang.org/)), and from there move
    to the Fyne tour, which introduces developers to the concepts of GUI development
    and how to get started with the project ([https://tour.fyne.io/](https://tour.fyne.io/)).
    Lots more documentation is available at the main developer website, containing
    tips on getting started, code tutorials, and a full API reference ([https://developer.fyne.io/](https://developer.fyne.io/)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前没有使用Go语言的开发者来说，可以从在线导游([https://tour.golang.org/](https://tour.golang.org/))开始，然后转到Fyne导游，它向开发者介绍了GUI开发的概念以及如何开始这个项目([https://tour.fyne.io/](https://tour.fyne.io/))。更多文档可以在主要开发者网站上找到，包括入门提示、代码教程和完整的API参考([https://developer.fyne.io/](https://developer.fyne.io/))。
- en: Platform-agnostic
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台无关性
- en: Cross-platform toolkits have various levels of complexity when building for
    different platforms. Some require different build processes and others will load
    different user interfaces, depending on the type of device. Fyne aims to be easier
    to use across these disparate targets and aims for **platform-agnostic**, meaning
    that the code doesn’t need to know anything about the device it is running on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台工具包在为不同平台构建时具有不同的复杂程度。有些需要不同的构建过程，而另一些则会根据设备类型加载不同的用户界面。Fyne旨在使这些不同的目标更容易使用，并追求**平台无关性**，这意味着代码不需要了解它正在运行的设备。
- en: For many start-ups, the term platform agnostic represents a kind of unattainable
    utopia in the world of mobile apps.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多初创公司来说，平台无关性在移动应用的世界中代表了一种难以达到的乌托邦。
- en: This quote is from [http://alleywatch.com.](http://alleywatch.com.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话来自[http://alleywatch.com.](http://alleywatch.com.)
- en: The code of a Fyne-based app does not need to adapt to system specifics and
    can compile for any devices using the same set of tools. As we will see later
    in the book, it is sometimes necessary to adjust for a specific operating system
    or device. In these situations, there are Go and Fyne APIs available to help.
    For many applications, it will be possible to avoid any customization per-system
    and the only element of the process that varies will be the application distribution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Fyne 的应用程序代码不需要适应系统特定性，并且可以使用相同的工具集编译到任何设备上。正如我们将在本书后面看到的那样，有时需要调整以适应特定的操作系统或设备。在这些情况下，有Go和Fyne
    API可用以帮助。对于许多应用程序，将有可能避免任何系统特定的定制，并且过程中唯一变化的是应用程序的发行。
- en: Distribution to all platforms
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布到所有平台
- en: When your app is ready for release, it needs to be packaged and uploaded to
    a central place where users can find it. Unfortunately, every operating system
    uses different packaging formats, and every vendor has a different store or marketplace
    for apps. The `fyne` command-line tool that we will use many times throughout
    this book is able to create application bundles in all of the required formats.
    With the app bundled, it can be installed locally, shared with friends, or uploaded
    to a website for distribution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用准备发布时，需要打包并上传到一个中央位置，让用户能够找到它。不幸的是，每个操作系统都使用不同的打包格式，每个供应商都有自己的应用商店或市场。我们将在本书中多次使用的`fyne`命令行工具能够创建所有必需格式的应用程序包。应用打包后，可以在本地安装，与朋友分享，或者上传到网站进行分发。
- en: Most systems are now moving to an app store or marketplace model where apps
    are available in a manufacturer provided location with screenshots, free advertising,
    and a managed installation. One of the challenges here is that every store is
    different and the process of certifying and uploading apps is different for each
    platform. The Fyne tool helps with the release process as well—streamlining as
    much as possible and ensuring a consistent developer experience for all stores.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统现在都在转向应用商店或市场模式，其中应用在制造商提供的位置可用，包括截图、免费广告和管理的安装。这里的挑战之一是每个商店都不同，每个平台的应用认证和上传过程也不同。Fyne工具在发布过程中也提供帮助——尽可能简化流程，并确保所有商店的开发者体验一致。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how designing a new graphical toolkit could overcome
    many of the challenges still faced by existing approaches. We explored the background
    and vision for Fyne, how it aims to solve these difficulties, and how it supports
    creating beautiful and performant apps across all popular desktop and mobile devices.
    We introduced Material Design and saw how it brings modern usability principles
    and design learnings to desktop and beyond. By using the `fyne` build tools, we
    saw that an app can be built and distributed for any devices or app stores without
    any platform-specific code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何设计一个新的图形工具包可以克服现有方法面临的许多挑战。我们探讨了Fyne的背景和愿景，它旨在解决这些困难，以及它如何支持在所有流行的桌面和移动设备上创建美观且性能良好的应用。我们介绍了材料设计，并看到了它如何将现代可用性原则和设计经验带到桌面以及更远的地方。通过使用`fyne`构建工具，我们看到了应用可以构建和分发到任何设备或应用商店，而无需任何平台特定的代码。
- en: In the next chapter, we will explore the fundamentals of a Fyne application
    and see how its drawing capabilities allow us to build a simple game.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Fyne应用程序的基础知识，并看到其绘图能力如何使我们能够构建一个简单的游戏。
- en: Further reading
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about some of the topics introduced in this chapter, you can
    visit the following websites:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章介绍的一些主题，你可以访问以下网站：
- en: 'Test-driven development: [https://www.agilealliance.org/glossary/tdd/](https://www.agilealliance.org/glossary/tdd/)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发：[https://www.agilealliance.org/glossary/tdd/](https://www.agilealliance.org/glossary/tdd/)
- en: 'The Go programming language: [https://golang.org/](https://golang.org/)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编程语言：[https://golang.org/](https://golang.org/)
- en: 'C bindings from Go: [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言中的C绑定：[https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)
- en: 'The Material Design system: [https://material.io](https://material.io)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料设计系统：[https://material.io](https://material.io)
- en: 'Fyne toolkit developer documentation: [https://developer.fyne.io/](https://developer.fyne.io/)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fyne工具包开发者文档：[https://developer.fyne.io/](https://developer.fyne.io/)
