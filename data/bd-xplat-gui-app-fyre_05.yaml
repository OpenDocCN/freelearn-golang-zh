- en: '*Chapter 3*: Window, Canvas, and Drawing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：窗口、画布和绘图'
- en: We have explored the basics of graphical application development and seen how
    starting with a new design in a modern language can lead to easier development.
    From this point on, we will be looking in more detail at how the Fyne toolkit
    aims to provide an easy-to-use API for building cross-platform applications for
    all developers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了图形应用程序开发的基础，并看到了从现代语言中的新设计开始如何导致更简单的开发。从现在开始，我们将更详细地探讨 Fyne 工具包旨在为所有开发者提供易于使用的
    API 来构建跨平台应用程序。
- en: In this chapter, we will investigate the structure of a Fyne application, how
    it draws objects, and how they can be scaled and manipulated—as well as animated—in
    a container.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究 Fyne 应用程序的结构，它如何绘制对象，以及它们如何在容器中进行缩放和操作——以及动画。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How Fyne applications are structured and how to start making your first app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建 Fyne 应用程序及其结构以及如何开始制作您的第一个应用程序
- en: Exploring the canvas package and the types of objects that can be drawn
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索画布包和可以绘制的对象类型
- en: How scalable elements create a clean user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展元素如何创建一个干净的用户界面
- en: Working with bitmaps and pixel rendering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与位图和像素渲染一起工作
- en: Animation of elements and properties
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素和属性的动画
- en: By the end of this chapter, you will know how these features combine to create
    a graphical application, which will be demonstrated with a simple game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解这些功能如何组合在一起创建一个图形应用程序，这将通过一个简单的游戏进行演示。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will be writing our first Fyne code, including building
    a complete application. To do this, you will need to have the **Go** compiler
    installed, as well as a code editor application. You can download Go from the
    home page at [https://golang.org/dl/](https://golang.org/dl/). The choice of code
    editor is normally a matter of user preference, but Microsoft's *Visual Studio
    Code* and JetBrain's *GoLand* applications are both highly recommended.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写我们的第一个 Fyne 代码，包括构建一个完整的应用程序。为此，您需要安装 **Go** 编译器以及一个代码编辑器应用程序。您可以从
    [https://golang.org/dl/](https://golang.org/dl/) 的主页下载 Go。代码编辑器的选择通常是用户偏好的问题，但微软的
    *Visual Studio Code* 和 JetBrain 的 *GoLand* 应用程序都强烈推荐。
- en: As Fyne uses some operating system APIs internally, you will also need to have
    a **C** compiler installed. Developers on Linux will probably already have one;
    macOS users can simply install *Xcode* from the Mac App Store. Windows-based developers
    will need to install a compiler, such as *MSYS2*, *TDM-GCC*, or *Cygwin*—more
    details can be found in [*Appendix A*](B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253)
    *– Developer Tool Installation*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Fyne 在内部使用一些操作系统 API，因此您还需要安装一个 **C** 编译器。Linux 上的开发者可能已经安装了一个；macOS 用户可以从
    Mac App Store 简单地安装 *Xcode*。基于 Windows 的开发者需要安装一个编译器，例如 *MSYS2*、*TDM-GCC* 或 *Cygwin*——更多详细信息可以在
    [*附录 A*](B16820_11_Final_JM_ePub.xhtml#_idTextAnchor253) *– 开发者工具安装* 中找到。
- en: The full source code for this chapter can be found in the book's GitHub repository
    at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在本书的 GitHub 仓库中找到，网址为 [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03)。
- en: Anatomy of a Fyne application
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fyne 应用程序的解剖结构
- en: As we saw in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036),
    *The Future According to Fyne*, the toolkit took the opportunity to start from
    scratch, throwing away the old and sometimes confusing constraints of previous
    toolkits. As a result, the APIs need to define everything involved in building
    a graphical application. In this section, we will explore the main concepts in
    running a Fyne-based application and producing visible components on screen, starting
    with the application itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 2 章*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036) *《根据 Fyne 的未来》*
    中所看到的，工具包抓住了从头开始的机会，摒弃了旧工具包中的一些有时令人困惑的限制。因此，API 需要定义构建图形应用程序所涉及的所有内容。在本节中，我们将探讨运行基于
    Fyne 的应用程序和产生屏幕上可见组件的主要概念，从应用程序本身开始。
- en: Application
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: The application, defined in the `fyne.App` interface, models the capabilities
    of a Fyne-based application. Each app using Fyne will typically create and run
    a single `fyne.App` instance from within their `main()` function. Because of the
    way that graphical applications work, they must be started from the main function
    and not through a goroutine or other background thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fyne.App`接口中定义的应用程序，模拟了基于Fyne的应用程序的功能。每个使用Fyne的应用程序通常会在其`main()`函数内部创建并运行一个单独的`fyne.App`实例。由于图形应用程序的工作方式，它们必须从主函数启动，而不是通过goroutine或其他后台线程。
- en: To create an app instance, we make use of the `app` package within Fyne, which
    can be imported using `fyne.io/fyne/app`. This package contains all of the logic
    and driver setup code that allows an app to understand the platform it is running
    on and configure itself appropriately. The function that we call is named `New()`
    and it will return the app instance that we will use throughout our code. To run
    the application, we would then call `Run()` and the application will start.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建应用程序实例，我们利用Fyne中的`app`包，可以使用`fyne.io/fyne/app`导入它。这个包包含了所有逻辑和驱动设置代码，允许应用程序了解其运行的平台并适当地配置自己。我们调用的函数名为`New()`，它将返回我们将在整个代码中使用的应用程序实例。要运行应用程序，我们随后调用`Run()`，应用程序将启动。
- en: With this knowledge, we could run our first Fyne app; however, it would be difficult
    to know if it was working without asking it to display something first! And so,
    we shall now learn how to display a window before running the first example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们可以运行我们的第一个Fyne应用程序；然而，如果不先要求它显示某些内容，很难知道它是否在正常工作！因此，我们现在将学习如何在运行第一个示例之前显示一个窗口。
- en: Window
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 窗口
- en: A **window** defines the area on the screen that your application controls.
    In a desktop environment, this will typically be shown inside a window border
    that matches the rest of the applications installed. You will normally be able
    to move and resize the window and close it when you are done.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口**定义了屏幕上应用程序控制区域。在桌面环境中，这通常会在与已安装的其他应用程序匹配的窗口边框内显示。你通常可以移动和调整窗口大小，并在完成后关闭它。'
- en: On mobile and other devices, this concept can be a little less well defined.
    For example, on Android and iOS smart phones, the application window will take
    up the whole screen and will not show window borders. To switch applications,
    you would use a gesture defined by the operating system or press a standard button,
    and other applications will appear, allowing you to move around. In addition to
    this, tablet computers—iPadOS, Android, or Windows, for example—will allow applications
    to be displayed in a portion of the screen, probably separated by a divider that
    allows the user to change how much space is used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动和其他设备上，这个概念可能定义得不太明确。例如，在Android和iOS智能手机上，应用程序窗口将占据整个屏幕，并且不会显示窗口边框。要切换应用程序，你会使用操作系统定义的手势或按下一个标准按钮，其他应用程序将出现，允许你移动。此外，平板电脑——例如iPadOS、Android或Windows——将允许应用程序在屏幕的一部分显示，可能通过一个分隔符来分隔，允许用户改变使用的空间量。
- en: In all of these different presentation modes the content that is displayed is
    still modeled by the `fyne.Window` interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些不同的展示模式中，显示的内容仍然由`fyne.Window`接口来模拟。
- en: To show content on the screen, we will need to create a new window and show
    it. Once a window is defined, we can run an application to see the results. Let's
    work through the code for our first application!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示内容，我们需要创建一个新的窗口并显示它。一旦定义了窗口，我们就可以运行应用程序来查看结果。让我们逐步分析我们的第一个应用程序的代码！
- en: 'We open a new file, `main.go`, and define it to be in the package `main`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开一个新的文件，`main.go`，并将其定义为`main`包：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then need to add any imports—in this case, we are just using the `app` package,
    so the following will be sufficient:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要添加任何导入——在这个例子中，我们只是使用`app`包，所以以下就足够了：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To define a runnable program, we create a `main()` method. Into this function,
    we will create a new application instance using the `New()` function we saw earlier:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要定义一个可运行的程序，我们创建一个`main()`方法。在这个函数中，我们将使用之前看到的`New()`函数创建一个新的应用程序实例：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, in this method, we call `NewWindow(string)` (defined on `fyne.App`),
    which allows us to create the window to display. We pass it a single string parameter
    that sets a title (which is used if the operating system shows titles in the window
    border or app switcher, for example). Place the following code where `...` appeared
    in the previous snippet:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在这个方法中，我们调用`NewWindow(string)`（在`fyne.App`中定义），这允许我们创建用于显示的窗口。我们传递一个字符串参数来设置标题（例如，如果操作系统在窗口边框或应用程序切换器中显示标题，则使用它）。将以下代码放置在前面代码片段中的`...`出现的位置：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have created a window, we can show it using the `Show()` function.
    After showing the window, we also need to call the `Run()` function on the application.
    As it is common to do both at the same time, there is a helper function `ShowAndRun()`,
    which we can use when showing the first window in an application:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个窗口，我们可以使用`Show()`函数来显示它。在显示窗口之后，我们还需要在应用程序上调用`Run()`函数。由于通常同时进行这两项操作，有一个辅助函数`ShowAndRun()`，我们可以在显示应用程序的第一个窗口时使用它：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this code in place, we can save the file and run its contents like any
    other Go application:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此代码到位后，我们可以保存文件并像其他Go应用程序一样运行其内容：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see a window appear on screen. Depending on your operating system,
    this may be a very small window, as we have not added any content. The following
    screenshot was taken on a macOS computer after resizing the empty window:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在屏幕上看到一个窗口出现。根据你的操作系统，这可能会是一个非常小的窗口，因为我们没有添加任何内容。下面的截图是在macOS计算机上调整空窗口大小后拍摄的：
- en: '![Figure 3.1 – Our first window'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 我们的第一个窗口'
- en: '](img/Figure_3.1_B16820.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16820.jpg)'
- en: Figure 3.1 – Our first window
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 我们的第一个窗口
- en: As you can see from the window in *Figure 3.1*, there is no content to the window,
    as we did not set any. The background of the window is not just black (or random
    colors from old graphics memory)—how can this be? The reason is that the window
    contains a `Canvas`, which is what manages the content we draw.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从*图3.1*中的窗口中看到的，窗口中没有内容，因为我们没有设置任何内容。窗口的背景不仅仅是黑色（或旧图形内存中的随机颜色）——这怎么可能呢？原因是窗口包含一个`Canvas`，这就是管理我们绘制的内容的东西。
- en: Canvas
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布
- en: The content of every `fyne.Window` is a `fyne.Canvas`. Although the way that
    the canvas works internally is dependent upon the current system and some complex
    code within Fyne's internal driver packages, it will look exactly the same to
    developers and our application's end users. This platform-independent rendering
    canvas is responsible for all of the draw operations that come together to create
    a graphical output and eventually complete application interfaces.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`fyne.Window`的内容都是一个`fyne.Canvas`。尽管画布内部的工作方式取决于当前系统和Fyne内部驱动程序包中的某些复杂代码，但它对开发者和我们的应用程序最终用户来说看起来完全一样。这个平台无关的渲染画布负责所有组合在一起创建图形输出并最终完成应用程序界面的绘制操作。
- en: Inside every canvas is at least one `fyne.CanvasObject`. These objects, as we
    will see in the *Understanding CanvasObject and the canvas package* section, define
    the types of operations that can be drawn to the canvas. To set the content of
    our window we can use `Window.SetContent(fyne.CanvasObject)`. This function passes
    the content down to the canvas, telling it to draw this object, and also resizes
    the window to be large enough to display it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个画布中至少包含一个`fyne.CanvasObject`。这些对象，正如我们在*理解CanvasObject和画布包*部分将看到的，定义了可以绘制到画布上的操作类型。为了设置窗口的内容，我们可以使用`Window.SetContent(fyne.CanvasObject)`。这个函数将内容传递到画布，告诉它绘制这个对象，并且调整窗口大小以足够大以显示它。
- en: Of course, this only sets the content to be a single element; we will normally
    want to include many, and this is what the `Container` type provides.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这仅设置内容为单个元素；我们通常希望包含许多元素，这正是`Container`类型提供的。
- en: Container
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: 'The `fyne.Container` extends the simple `fyne.CanvasObject` type to include
    managing multiple child objects. A container is responsible for controlling the
    size and position of each element it contains. *Figure 3.2* shows how the **Canvas**
    contains one container that positions three **CanvasObject** elements in a stack
    on the left and an additional **Container** to the right. This second container
    is responsible for three further elements, which it lays out in a row:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`fyne.Container`扩展了简单的`fyne.CanvasObject`类型，包括管理多个子对象。容器负责控制它包含的每个元素的大小和位置。*图3.2*显示了**画布**包含一个容器，该容器将三个**CanvasObject**元素堆叠在左侧，并在右侧还有一个额外的**Container**。这个第二个容器负责三个进一步元素，它将它们排列成一行：'
- en: '![Figure 3.2 – A Canvas with various Container and CanvasObject elements'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 – 包含各种容器和CanvasObject元素的画布'
- en: '](img/Figure_3.3_B16820.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.3_B16820.jpg]'
- en: Figure 3.2 – A Canvas with various Container and CanvasObject elements
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 包含各种容器和CanvasObject元素的画布
- en: Containers typically delegate the work of positioning child objects to a `fyne.Layout`.
    These layout algorithms will be explored further in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)*,
    Layout and File Handling*. In the current chapter, we will use containers without
    layouts—these are called *manual layouts* and are invoked using `container.NewWithoutLayout(elements)`,
    where the `elements` parameter is a list of `fyne.CanvasObject` types that the
    container will present. We will explore manual layouts further in the *Combining
    elements* section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通常将定位子对象的工作委托给`fyne.Layout`。这些布局算法将在[*第4章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)*，布局和文件处理*中进一步探讨。在当前章节中，我们将使用不带布局的容器——这些被称为*手动布局*，并使用`container.NewWithoutLayout(elements)`调用，其中`elements`参数是容器将要展示的`fyne.CanvasObject`类型列表。我们将在*组合元素*部分进一步探讨手动布局。
- en: Now that we have seen how the application is defined and how it handles the
    presentation of graphical elements, we should see what drawing capabilities Fyne
    supports, and how to use them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了应用程序的定义以及它如何处理图形元素的表现，我们应该看看Fyne支持哪些绘图功能，以及如何使用它们。
- en: Understanding CanvasObject and the canvas package
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CanvasObject和画布包
- en: The `CanvasObject` definition is just a Go interface that describes an element
    that can be positioned, sized, and added to a Fyne canvas. The type does not contain
    any information about how to draw—this information is provided by *concrete types*
    within the `canvas` package. These types define well-understood graphical primitives,
    such as `Text` and `Line`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CanvasObject`定义只是一个Go接口，它描述了一个可以定位、调整大小并添加到Fyne画布中的元素。该类型不包含任何关于如何绘制的相关信息——这些信息由`canvas`包内的*具体类型*提供。这些类型定义了易于理解的图形原语，例如`Text`和`Line`。'
- en: Before learning how to use these elements, we shall see how they look in the
    Fyne demo app.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用这些元素之前，我们应该看看它们在Fyne演示应用程序中的样子。
- en: Canvas demo
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布演示
- en: 'Before we look at how to write code that will display shapes in our window,
    we should look at a demo of these features in action. Using the built-in Fyne
    demo application, we can see what the `canvas` package supports. If you have not
    already done so, you can install and run the demo application using the following
    commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何在窗口中显示形状的代码之前，我们应该看看这些功能的实际演示。使用内置的Fyne演示应用程序，我们可以看到`canvas`包支持什么。如果您还没有这样做，可以使用以下命令安装并运行演示应用程序：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While running the demo, tap on the **Canvas** item on the left navigation panel.
    You should see the following screen:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行演示时，点击左侧导航面板上的**画布**项。你应该看到以下屏幕：
- en: '![Figure 3.3 - The fyne_demo application showing various canvas primitives'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - fyne_demo应用程序展示各种画布原语'
- en: '](img/Figure_3.7_B16820.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.7_B16820.jpg]'
- en: Figure 3.3 - The fyne_demo application showing various canvas primitives
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - fyne_demo应用程序展示各种画布原语
- en: 'The window shown in *Figure 3.3* demonstrates some of the canvas types known
    to Fyne. Those drawn here are named in the following list in order (left to right,
    from the top row and then the bottom):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.3*所示，该窗口展示了Fyne所知的几种画布类型。这里绘制的类型按以下列表顺序命名（从左到右，从上到下）：
- en: Image
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片
- en: Rectangle
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Line
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线
- en: Circle
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形
- en: Text
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Raster
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光栅
- en: Linear Gradient
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性渐变
- en: Radial Gradient
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 径向渐变
- en: Each of these elements can be included in our application, as we will explore
    next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素都可以包含在我们的应用程序中，正如我们接下来将要探索的。
- en: Adding objects to our window
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的窗口添加对象
- en: Each element in the previous demo figure, as well as any new items that are
    subsequently added to the `canvas` package, can be created directly using their
    `NewXxx()` constructor function. The object returned from this can then be passed
    directly to the window or a container of objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上一演示图中的每个元素，以及随后添加到`canvas`包中的任何新项目，都可以直接使用它们的`NewXxx()`构造函数创建。从这个构造函数返回的对象可以直接传递到窗口或对象容器中。
- en: 'To demonstrate this, let''s add some text content to the empty window. After
    adding `image/color` and `fyne.io/fyne/canvas` to the previously used `import`
    statements, we can change the main function to the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们向空窗口添加一些文本内容。在之前使用的`import`语句中添加`image/color`和`fyne.io/fyne/canvas`之后，我们可以将主函数更改为以下内容：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, this change adds just one line—the `canvas.NewText` that is
    passed to `w.SetContent`. The text constructor function takes two parameters,
    the text to display and the color to use. If you run this code, you will see that
    the window now contains the text **This works!**, and is sized just right for
    this to be displayed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次更改仅添加了一行——传递给 `w.SetContent` 的 `canvas.NewText`。文本构造函数接受两个参数，要显示的文本和要使用的颜色。如果您运行此代码，您将看到窗口现在包含文本
    **This works!**，并且大小正好适合显示：
- en: '![Figure 3.4 – Displaying text content'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.4 – 显示文本内容'
- en: '](img/Figure_3.9_B16820.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B16820.jpg)'
- en: Figure 3.4 – Displaying text content
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 显示文本内容
- en: As you can see here, showing a canvas element is as simple as knowing which
    content you would like to display. Let's look at a slightly more complicated example
    using multiple canvas elements in a container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，显示画布元素就像知道您想显示哪些内容一样简单。让我们看看一个稍微复杂一点的例子，使用容器中的多个画布元素。
- en: Combining elements
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素组合
- en: 'To show how we can use a container to display multiple items and create a more
    appealing output, we shall replicate a road sign using a `canvas.Circle` and `canvas.Rectangle`
    element inside a `fyne.Container`. Let''s see how to go about this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们如何使用容器来显示多个项目并创建更吸引人的输出，我们将使用 `canvas.Circle` 和 `canvas.Rectangle` 元素在
    `fyne.Container` 内复制一个道路标志。让我们看看如何进行：
- en: 'Firstly, we will create a new function for this code, named `makeSign()`. It
    should return `a fyne.CanvasObject` (which all graphical elements implement).
    The rest of our code will go into this function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为这段代码创建一个新函数，命名为 `makeSign()`。它应该返回 `a fyne.CanvasObject`（所有图形元素都实现此接口）。我们代码的其余部分将放入此函数中：
- en: '[PRE8]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we will create the background for a sign using `canvas.NewCircle()`, saving
    a reference to it so that we can use it later. The color that we pass is bright
    red—`255` (the maximum) for red channel. Green and blue values are `0`, and the
    alpha channel (how opaque the color appears) is also set at maximum, so it is
    fully visible:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `canvas.NewCircle()` 创建一个标志的背景，并保存对其的引用，以便我们稍后可以使用它。我们传递的颜色是鲜艳的红色——红色通道的
    `255`（最大值）。绿色和蓝色值是 `0`，alpha 通道（颜色看起来有多不透明）也设置为最大值，因此它是完全可见的：
- en: '[PRE9]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we add a white border to this circle. The `StrokeWidth` property controls
    how wide the border is (defaults to `0` or hidden) and we set `StrokeColor` to
    white for an outer circle of white:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们给这个圆添加一个白色边框。`StrokeWidth` 属性控制边框有多宽（默认为 `0` 或隐藏），我们将 `StrokeColor` 设置为白色以形成一个外圈白色：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we will draw the bar across the center; this is simply a white rectangle:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将绘制横跨中心的条形；这只是一个白色矩形：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To combine these two elements, we define a container. It is important to pass
    the parameters with the circle (`bg`) first and rectangle (`bar`) second, as they
    will be drawn in this order:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要组合这两个元素，我们定义一个容器。重要的是要首先传递带有圆圈（`bg`）的参数，然后是矩形（`bar`），因为它们将按此顺序绘制：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we must position these elements. We will specify that the sign is `100`
    x `100`. Because it has a border, we will inset it from the sides by `10` x `10`
    so that it is centered within a window sized 120 x 120:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定位这些元素。我们将指定标志是 `100` x `100`。因为它有边框，我们将从两侧向内缩进 `10` x `10`，以便它在 120
    x 120 大小的窗口中居中：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To position the `bar`, we will make it `80` x `20`. To position it over the
    60, 60 central spot, we move it to `20`, `50`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了定位 `bar`，我们将它设置为 `80` x `20`。为了将其定位在 60, 60 的中心点，我们将它移动到 `20`，`50`：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this code in place, we end the function by returning the container we
    have made:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码到位后，我们通过返回我们制作的容器来结束函数：
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This completes the definition of our sign. To display it, we call the `makeSign()`
    function and pass it to `SetContent()`. We can also turn off the default padding
    on the window, as our content is not reaching the edge of our container. Because
    we are using a manual layout, we also need to resize the window to show the items
    we have positioned:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们标志的定义。要显示它，我们调用 `makeSign()` 函数并将其传递给 `SetContent()`。我们还可以关闭窗口上的默认填充，因为我们的内容没有达到容器的边缘。因为我们正在使用手动布局，所以我们也需要调整窗口大小以显示我们定位的项目：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this code in place, you can run the application in the usual way, but
    this time we shall force the dark theme so that our white border stands out (we
    will look at themes in more detail in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，您可以用通常的方式运行应用程序，但这次我们将强制使用深色主题，以便我们的白色边框更加突出（我们将在 [*第 5 章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)，*小部件库和主题*）中更详细地了解主题）：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see the following window with the sign crisp against a darker-colored
    background:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个带有清晰标志的窗口，背景颜色较深：
- en: '![Figure 3.5 – Our road sign, created from a circle and rectangle'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – 由圆形和矩形创建的我们的路标]'
- en: '](img/Figure_3.5_B16820.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B16820.jpg)'
- en: Figure 3.5 – Our road sign, created from a circle and rectangle
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 由圆形和矩形创建的我们的路标
- en: 'Note: manual layouts do not automatically resize'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：手动布局不会自动调整大小
- en: When using a manual layout, as explored in this example, it will not resize
    when the window changes size. This functionality is provided by using a layout
    algorithm, which we will explore in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用手动布局，如本例中所述，当窗口大小改变时，它不会进行缩放。这种功能是通过使用布局算法实现的，我们将在[*第4章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)，*布局和文件处理*中探讨。
- en: In this section, we explored the canvas elements and how to draw them. They
    created crisp, clean output, but we did not explore how that works. In the next
    section, we look at what scalable rendering is and how it creates such high-quality
    output.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了画布元素及其绘制方法。它们创建出清晰、干净的输出，但我们没有探讨它是如何工作的。在下一节中，我们将探讨可缩放渲染是什么以及它是如何创建如此高质量的输出的。
- en: Scalable drawing primitives
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可缩放绘图原语
- en: As you probably realized from the previous example, all the items that we have
    rendered so far are vector graphics. This means that they are described by lines,
    curves, and high-level parameters instead of a collection of pixels. Because of
    this, these components are called **scalable** (like in **scalable vector graphics**
    (**SVG**) files), meaning that they can be drawn at any scale. The Fyne toolkit
    is a scalable toolkit, which means that a Fyne application can be drawn at any
    scale and render at a high quality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上一个示例中可能已经意识到的，我们迄今为止渲染的所有项目都是矢量图形。这意味着它们是由线条、曲线和高层次参数描述的，而不是像素集合。正因为如此，这些组件被称为**可缩放的**（就像在**可缩放矢量图形**（**SVG**）文件中一样），这意味着它们可以在任何比例下绘制。Fyne工具包是一个可缩放的工具包，这意味着Fyne应用程序可以在任何比例下绘制并以高质量渲染。
- en: 'Let''s look at the text component in more detail, for example. We define a
    simple text component as before:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看文本组件，例如。我们像以前一样定义一个简单的文本组件：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then place that line of code into the standard `main()` function that
    we wrote in the first section of this chapter, *Anatomy of a Fyne application*,
    and then run it. The output will be as expected—drawing text at the normal size—but
    if we override the preferred scale using `FYNE_SCALE`, we can see how the application
    would look if the user wanted much larger text:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这一行代码放入我们在本章第一部分“Fyne应用程序结构”中编写的标准`main()`函数中，然后运行它。输出将如预期的那样——以正常大小绘制文本——但如果使用`FYNE_SCALE`覆盖首选比例，我们可以看到如果用户想要更大的文本，应用程序将看起来如何：
- en: '![Figure 3.6 – canvas.Text rendered with FYNE_SCALE=1 (left) and 3.5 (right)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – 使用FYNE_SCALE=1（左）和3.5（右）渲染的canvas.Text]'
- en: '](img/Figure_3.13_B16820.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B16820.jpg)'
- en: Figure 3.6 – canvas.Text rendered with FYNE_SCALE=1 (left) and 3.5 (right)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 使用FYNE_SCALE=1（左）和3.5（右）渲染的canvas.Text
- en: 'Scaling a Fyne application in this way will not just change the font size,
    but will scale up every element of the user interface. This includes all standard
    graphics, widgets, and layouts. The standard themes also provide a set of icons
    (which we will explore more in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119),
    *Widget Library and Themes*), which are also scalable. We can see this by using
    a theme resource and the icon widget type:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式缩放Fyne应用程序不仅会改变字体大小，还会缩放用户界面的每个元素。这包括所有标准图形、小部件和布局。标准主题还提供了一套图标（我们将在[*第5章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)，*小部件库和主题*中进一步探讨），这些图标也是可缩放的。我们可以通过使用主题资源和图标小部件类型来看到这一点：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By adding the preceding line to the same `main` function, we can see how icons
    will scale to match the text demonstrated in the previous figure:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将前面的行添加到同一个`main`函数中，我们可以看到图标将如何缩放以匹配前一个图中展示的文本：
- en: '![Figure 3.7 – widget.Icon rendered with FYNE_SCALE=1 (left) and 3.5 (right)](img/Figure_3.15_B16820.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 使用FYNE_SCALE=1（左）和3.5（右）渲染的widget.Icon](img/Figure_3.15_B16820.jpg)'
- en: Figure 3.7 – widget.Icon rendered with FYNE_SCALE=1 (left) and 3.5 (right)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 使用FYNE_SCALE=1（左）和3.5（右）渲染的widget.Icon
- en: The size and position of elements will be scaled according to the canvas scale.
    We can now see how this coordinate system works.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的大小和位置将根据画布比例进行缩放。我们现在可以看看这个坐标系是如何工作的。
- en: Coordinate system
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 坐标系
- en: As you saw in the *Combining elements* section earlier, it is sometimes necessary
    to position or resize elements within a user interface. Doing so for a scalable
    output can be a little complicated, as we are not measuring content using pixels.
    And so, Fyne uses a device-independent coordinate system that Android developers
    may be familiar with.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在之前的*组合元素*部分中看到的，有时需要在用户界面内定位或调整元素的大小。对于可伸缩的输出，这样做可能会有些复杂，因为我们不是用像素来衡量内容的。因此，Fyne使用一个与设备无关的坐标系，这可能是Android开发者所熟悉的。
- en: A 1 x 1 size in Fyne (written as `fyne.NewSize(1, 1)`) may represent more than
    (or fewer than) 1 output pixel. If the scale was 3 (as it is for many modern smart
    phones), then the 1 x 1 square will likely use nine output pixels. As the toolkit
    is designed for scalable output, the result will not be a *pixelated* output,
    like it could be with older graphical toolkits that simply multiply the size of
    each pixel. The rendered output will continue to look crisp, as we saw in *Figure
    3.6* and *Figure 3.7*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fyne中，1 x 1的大小（写作`fyne.NewSize(1, 1)`）可能代表多于（或少于）1个输出像素。如果缩放比例是3（如许多现代智能手机那样），那么1
    x 1的正方形可能会使用九个输出像素。由于工具包是为可伸缩输出设计的，所以结果不会是*像素化*的输出，就像它可能使用简单的将每个像素大小乘以的老式图形工具包那样。渲染的输出将继续看起来清晰，就像我们在*图3.6*和*图3.7*中看到的那样。
- en: A fully scalable user interface has huge benefits when working with display
    devices of varying pixel densities, and it allows users to choose a preferred
    zoom level for all application components. However, sometimes we need to work
    with nonscalable elements, such as bitmap (pixel based) images, or our application
    may need to use every pixel available for high-definition graphical output. We
    will explore this in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当与不同像素密度的显示设备一起工作时，完全可伸缩的用户界面具有巨大的好处，它允许用户为所有应用程序组件选择首选的缩放级别。然而，有时我们需要与非可伸缩的元素一起工作，例如基于像素的位图图像，或者我们的应用程序可能需要使用所有可用的像素进行高清图形输出。我们将在下一节中探讨这个问题。
- en: Pixel output – rendering images
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素输出 – 渲染图像
- en: For the reasons outlined in the previous section, it is recommended that you
    use scalable graphics (normally SVG files) for icons and other image-based components
    of user interfaces. It will sometimes be necessary to work with bitmap graphics
    (those defined by a collection of pixels rather than graphical features). If you
    are loading and managing images, or if you want to display detailed graphical
    elements using every pixel available, then this section contains important information
    about how to proceed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一部分中概述的原因，建议您使用可伸缩的图形（通常是SVG文件）来制作图标和其他基于图像的用户界面组件。有时需要与位图图形（由像素集合定义而不是图形特征）一起工作。如果您正在加载和管理图像，或者您想使用所有可用的像素显示详细的图形元素，那么本节包含有关如何进行的重要信息。
- en: Images
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像
- en: Image content in Fyne defines graphical content that will normally stretch or
    shrink to the space that is allocated to it. Loading a bitmap image (which has
    dimensions that are defined by the number of pixels) into a scalable output may
    not provide the expected outcome. The rendered output of a size defined in pixels
    will vary depending on the scale of the output device or user preferences. For
    this reason, Fyne does not normally set a minimum size for images that are being
    loaded.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne中的图像内容定义了通常会根据分配给它的空间拉伸或缩小的图形内容。将具有像素尺寸定义的位图图像加载到可伸缩的输出中可能不会提供预期的结果。以像素定义的大小渲染的输出将取决于输出设备的缩放比例或用户的首选项。因此，Fyne通常不会为正在加载的图像设置最小尺寸。
- en: 'Images can be loaded from files, resources, data streams, and more. Each file
    should have a unique name (or path), which makes it possible for performance improvements
    through caching. Loading an image from the filesystem should be done through the
    Fyne `storage` API to avoid any platform-specific code or assumptions (this is
    explored in detail in [*Chapter 4*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089),
    *Layout and File Handling*). You can use `storage.NewFileURI` to get the reference
    to a file path if that is needed. For example, to load an image from a file path,
    you would call the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以从文件、资源、数据流等加载。每个文件都应该有一个唯一的名称（或路径），这使得通过缓存进行性能改进成为可能。从文件系统加载图像应通过Fyne的`storage`
    API进行，以避免任何特定平台的代码或假设（这在[*第4章*](B16820_04_Final_JM_ePub.xhtml#_idTextAnchor089)，*布局和文件处理*中详细探讨）。如果需要，您可以使用`storage.NewFileURI`来获取文件路径的引用。例如，要从文件路径加载图像，您将调用以下代码：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To define how a loaded image should be displayed in your app, you can set the
    `ImageFill` field in your `canvas.Image` object. It will be one of the following
    values:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义加载的图像在您的应用程序中的显示方式，您可以在`canvas.Image`对象中设置`ImageFill`字段。它将是以下值之一：
- en: '`canvas.ImageFillStretch`: The default value. This will adjust the image dimensions
    up or down to match the image object size, adjusting the **aspect ratio** (the
    ratio of width to height values), which can cause images to look squashed or stretched.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas.ImageFillStretch`: 默认值。这将调整图像尺寸以匹配图像对象大小，调整**宽高比**（宽度和高度值的比率），这可能导致图像看起来被压扁或拉伸。'
- en: '`canvas.ImageFillContain`: This fill option will retain the aspect ratio so
    that the image is not distorted and draws it as the largest size possible that
    can fit within the image size. This will usually leave a space on two of the edges
    so that the image is centered in the available space.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas.ImageFillContain`: 此填充选项将保留图像的宽高比，以确保图像不会被扭曲，并以尽可能大的尺寸绘制，使其适合图像大小。这通常会在两个边缘上留下空间，以便图像在可用空间中居中。'
- en: '`canvas.ImageFillOriginal`: In original fill mode, the image will display using
    one output pixel for each pixel in the image. Although this seems desirable, it
    is important to note that it''s visible size will vary based on the device because
    of the variation of pixel density. Using this value will also ensure that sufficient
    space will be reserved to draw the required number of pixels. If it is likely
    that the image will be larger than the space available, be sure to wrap it in
    a scroll container (discussed in [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)*,
    Widget Library and Themes*).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas.ImageFillOriginal`: 在原始填充模式下，图像将使用图像中的每个像素显示一个输出像素。尽管这似乎是理想的，但重要的是要注意，由于像素密度的变化，其可见大小将根据设备而变化。使用此值还将确保为绘制所需数量的像素保留足够的空间。如果图像可能比可用空间大，请确保将其包裹在滚动容器中（在第[*第5章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)*，小部件库和主题*）中讨论）。'
- en: As mentioned in the fill modes, the output size of an image cannot be known
    by looking at the image file, and so your application will probably need to specify
    how large the image should be. Normally, this will be controlled by a layout—images
    would be expanded according to the type of layout. Another way to do this is to
    call `SetMinSize()` to ensure that the image never gets smaller than a specified
    (pixel independent) value. If you have used `ImageFillOriginal`, then this step
    will have been completed automatically.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如填充模式中所述，图像的输出大小不能通过查看图像文件来确定，因此您的应用程序可能需要指定图像的大小。通常，这将由布局控制——图像将根据布局类型扩展。另一种方法是调用`SetMinSize()`以确保图像永远不会小于指定的（与像素无关）值。如果您已使用`ImageFillOriginal`，则此步骤将已自动完成。
- en: 'If small images are used, but they occupy a large space, they may appear *pixelated*,
    depending on how far they have been scaled. It is recommended that you use images
    that contain sufficient pixels/detail so that they will be scaled down (shown
    smaller) when displayed instead of scaling them up; however, if you want the output
    to look pixelated (or retro), you can specify that a pixel-based scaling should
    be used to enhance this look:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的是小图像，但它们占据了很大的空间，它们可能看起来*像素化*，这取决于它们被缩放的程度。建议您使用包含足够像素/细节的图像，这样在显示时它们会被缩小（显示得更小），而不是放大；然而，如果您想让输出看起来像素化（或复古），可以指定使用基于像素的缩放来增强这种外观：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the pixelated output described here does not apply if the image file
    was `.svg`. When a scalable image file is loaded, it will always be redrawn to
    the size requested, ensuring a high-quality output each time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里描述的像素化输出不适用于图像文件为`.svg`的情况。当加载可缩放图像文件时，它将始终被重新绘制到请求的大小，确保每次输出都是高质量的。
- en: Images are not the only way to draw bitmap content; we can also include more
    dynamically created pixel content using the `Raster` type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图像不是绘制位图内容的唯一方式；我们还可以使用`Raster`类型包含更多动态创建的像素内容。
- en: Raster
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光栅
- en: In some cases, an application may wish to display content using every available
    pixel so that high detail can be displayed, such as when showing wave forms or
    a 3D render. In these situations, we use the `Raster` widget. This is designed
    to show pixel-based output that is calculated dynamically instead of being loaded
    from a file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用程序可能希望使用所有可用的像素来显示内容，以便显示高细节，例如在显示波形或3D渲染时。在这些情况下，我们使用`Raster`小部件。这是设计用来显示基于像素的动态计算输出，而不是从文件中加载。
- en: A raster output will dynamically determine the content to display based on the
    number of pixels available in the space it occupies. Each time the space resizes,
    the widget will be asked to redraw itself. These requests for content are handled
    by generator functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅输出将根据其在占据空间中可用的像素数量动态确定要显示的内容。每次空间调整大小时，都会要求小部件重新绘制自己。这些内容请求由生成器函数处理。
- en: 'In this example, we will explore how to display a checkerboard pattern:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将探讨如何显示棋盘图案：
- en: 'Firstly, we declare a generator function—this will take the `x`, `y` parameter
    of the pixel requested and the width and height parameter of the overall area
    (in pixels), and return a color value, as shown here:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们声明一个生成器函数——这将接受请求的像素的 `x`、`y` 参数以及整个区域的宽度和高度参数（以像素为单位），并返回一个颜色值，如图所示：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then want to determine which color our pixel is. The following calculation
    will return white if the `x`, `y` coordinate is in a 20 x 20 pixel square at the
    top left or any odd-numbered square along the row, and then the opposite squares
    on the following row. For these pixels, we specify a white color:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来想确定我们的像素的颜色。以下计算将在 `x`、`y` 坐标位于左上角的 20 x 20 像素方块或任何奇数行的方块，以及下一行的相反方块时返回白色。对于这些像素，我们指定白色颜色：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And for any other pixel, we will return black instead:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于任何其他像素，我们将返回黑色：
- en: '[PRE24]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the generator function defined, we can create a new `raster` widget that
    will use it to color the output pixels:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器函数定义后，我们可以创建一个新的 `raster` 小部件，该小部件将使用它来着色输出像素：
- en: '[PRE25]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By reusing the same application launch code in the previous examples, we can
    load the app and display its window:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在先前的示例中重用相同的应用程序启动代码，我们可以加载应用程序并显示其窗口：
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will display the result shown in the following figures:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示以下图中的结果：
- en: '![Figure 3.8 - canvas.Raster rendered with FYNE_SCALE=1 (left) and 3.5 (right)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 - 使用 FYNE_SCALE=1（左侧）和 3.5（右侧）渲染的 canvas.Raster'
- en: '](img/Figure_3.17_B16820.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.17_B16820.jpg)'
- en: Figure 3.8 - canvas.Raster rendered with `FYNE_SCALE=1` (left) and `3.5` (right)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 - 使用 `FYNE_SCALE=1`（左侧）和 `3.5`（右侧）渲染的 canvas.Raster
- en: Whether you change the scale or resize the window, you will see that the pattern
    repeats at the same size, always using squares that are 20 pixels wide and high.
    Before we complete this section, we should also look at how gradients are handled
    on the canvas.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你改变比例还是调整窗口大小，你都会看到图案以相同的大小重复，始终使用宽度和高度为 20 像素的正方形。在我们完成本节之前，我们还应该看看如何在画布上处理渐变。
- en: Gradient
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐变
- en: As we saw in *Figure 3.3*, the Fyne canvas is also capable of displaying gradients.
    Much like the raster in the previous section, a gradient will display using all
    the available pixels for the best output possible for each device. Adding a gradient,
    however, is much simpler than managing raster content.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *图 3.3* 中所看到的，Fyne 画布也能够显示渐变。与上一节中的光栅类似，渐变将使用所有可用的像素来显示，以实现每个设备可能的最佳输出。然而，添加渐变比管理光栅内容要简单得多。
- en: 'There are two types of gradient: linear and radial.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的渐变：线性渐变和径向渐变。
- en: Linear gradient
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性渐变
- en: A `LinearGradient` displays an even transition from one color to another and
    is normally presented as horizontal or vertical. A vertical gradient changes color
    from the start at the top of the area and the end color at the bottom; each row
    of pixels will have the same color, creating a gradient area that transitions
    from top to bottom. A horizontal gradient performs the same operation, but with
    the start color at the left of the area and the end at the right, which means
    that each column of pixels will have the same color.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearGradient` 显示从一种颜色到另一种颜色的均匀过渡，通常以水平或垂直方式呈现。垂直渐变从区域顶部的起始颜色到底部的结束颜色改变颜色；每一行的像素将具有相同的颜色，从而创建一个从顶部到底部过渡的渐变区域。水平渐变执行相同的操作，但起始颜色在区域的左侧，结束颜色在右侧，这意味着每一列的像素将具有相同的颜色。'
- en: 'For example, the following lines would create a horizontal vertical gradient
    respectively from white to black using the provided convenience constructors:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下行将分别使用提供的便利构造函数创建从白色到黑色的水平垂直渐变：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By passing each of these to `Window.SetContent`, as we have done with other
    examples, you can see the following result, with a horizontal gradient on the
    left and a vertical gradient on the right:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些传递给 `Window.SetContent`，就像我们在其他示例中所做的那样，你可以看到以下结果，左侧有一个水平渐变，右侧有一个垂直渐变：
- en: '![Figure 3.9 – Horizontal and vertical gradients'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – 水平和垂直渐变'
- en: '](img/Figure_3.19_B16820.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.19_B16820.jpg)'
- en: Figure 3.9 – Horizontal and vertical gradients
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 水平和垂直渐变
- en: 'It is also possible to specify the exact angle of a linear gradient. The `NewLinearGradient`
    constructor takes a third parameter, the angle in degrees to orient. The vertical
    gradient is at `0` degrees and the horizontal is `270` degrees (equivalent to
    a `90`-degree counter-clockwise rotation). So, the usage of the horizontal gradient
    helper could also have been written as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以指定线性渐变的精确角度。`NewLinearGradient` 构造函数接受第三个参数，即用于定位的角度（以度为单位）。垂直渐变在 `0` 度，水平渐变在
    `270` 度（相当于逆时针旋转 `90` 度）。因此，水平渐变辅助函数的使用也可以写成如下所示：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Sometimes, however, a gradient that forms a curve is required; for this, we
    use a radial gradient.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，然而，需要形成一个曲线的渐变；为此，我们使用径向渐变。
- en: Radial gradient
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 径向渐变
- en: 'A radial gradient is one where the start color is at the center of the area
    (although this can be offset using `CenterOffsetX` and `CenterOffsetY`) and progresses
    to the end color at the edge of the area. The gradient is drawn such that the
    end color fully appears within the bounds on the horizontal and vertical lines
    from the center of the gradient. This means that the corners of the area this
    gradient occupies will be outside of the gradient calculation; for this reason,
    it can be useful for the end color to be `color.Transparent`. We set up a gradient
    similar to the `LinearGradient` example from white to black, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 径向渐变是指起始颜色位于区域的中心（尽管可以使用 `CenterOffsetX` 和 `CenterOffsetY` 来偏移），并逐渐过渡到区域的边缘的结束颜色。渐变绘制的方式是，结束颜色在从渐变中心出发的水平线和垂直线范围内完全显示。这意味着此渐变占据的区域角落将位于渐变计算之外；因此，将结束颜色设置为
    `color.Transparent` 可能很有用。我们设置了一个类似于 `LinearGradient` 示例的从白色到黑色的渐变，如下所示：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code will result in the following image when placed in the contents of
    a window:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此代码放置在窗口的内容中时，将生成以下图像：
- en: '![Figure 3.10 – A radial gradient transitioning from white to black'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 从白色到黑色的径向渐变'
- en: '](img/Figure_3.21_B16820.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.21_B16820.jpg)'
- en: Figure 3.10 – A radial gradient transitioning from white to black
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 从白色到黑色的径向渐变
- en: We have seen the various ways that we can output content, but it is also possible
    to animate it so that your application appears more interactive. We will see how
    to do this in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们可以输出的各种方式，但也可以使内容动起来，从而使你的应用程序看起来更具交互性。我们将在下一节中了解如何做到这一点。
- en: Animation of the draw properties
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制属性的动画
- en: The Fyne `canvas` package also includes the facility to handle the animation
    of objects and properties. Using these APIs will help you to manage smooth transitions
    for a better user experience.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 的 `canvas` 包还包括处理对象和属性动画的功能。使用这些 API 将有助于你管理平滑的过渡，以获得更好的用户体验。
- en: Animating a transition
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画过渡
- en: 'An animation in Fyne, at its very basic level, is a function that will be called
    for every graphical frame that it runs. Once it is started, it will run as long
    as the `Duration` field specifies. A basic animation can be created using the
    following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fyne 中，最基本的动画是一个将在每个图形帧上被调用的函数。一旦启动，它将根据 `Duration` 字段指定的时长运行。可以使用以下方式创建基本动画：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The animation that is returned from this constructor function can be started
    by calling `anim.Start()`. When the animation is started, its end time will be
    calculated based on the duration of time that passes. The callback that is passed
    in will be executed each time the graphics are updated. The `float32` parameter
    to this function will be `0.0` when it starts and `1.0` immediately before it
    ends; each intermediate call will have a value between these two.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个构造函数返回的动画可以通过调用 `anim.Start()` 来启动。当动画启动时，其结束时间将基于经过的时间长度来计算。传入的回调函数将在每次图形更新时执行。此函数的
    `float32` 参数在开始时为 `0.0`，在结束前立即为 `1.0`；每次中间调用都将在这两个值之间。
- en: 'To provide a more concrete illustration, we can set up a position animation.
    This is one of the helpful animations provided by the `canvas` package. It, like
    many others, takes two additional parameters: the `start` and `end` value of the
    animation. In this case, it expects a `start` and `end` `fyne.Position`. Note
    that that the `callback` function will provide the current position value instead
    of a `float32` *offset* parameter. We create a new position animation that will
    run for one second:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更具体的说明，我们可以设置一个位置动画。这是 `canvas` 包提供的有用动画之一。它，像许多其他动画一样，需要两个额外的参数：动画的 `start`
    和 `end` 值。在这种情况下，它期望一个 `start` 和 `end` `fyne.Position`。请注意，`callback` 函数将提供当前的位置值，而不是
    `float32` *偏移* 参数。我们创建一个新的位置动画，它将持续一秒钟：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `callback` function is responsible for applying the position value to a
    graphical object. In this case, we will create a text object that will move across
    the window:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback` 函数负责将位置值应用于图形对象。在这种情况下，我们将创建一个将在窗口中移动的文本对象：'
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then simply start this animation using the `Start()` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需使用 `Start()` 方法启动此动画即可：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These animations will run just once, but they can also be asked to loop.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动画将只运行一次，但也可以要求它们循环。
- en: Looping animations
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环动画
- en: 'Any animation can be set to repeat—this means that after the time duration
    lapses, it will start again at the beginning. To request this behavior, set the
    `RepeatCount` field on the `Animation` struct to `fyne.AnimationRepeatForever`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 任何动画都可以设置为重复——这意味着在时间持续时间过后，它将从开始处再次开始。要请求此行为，将 `Animation` 结构体上的 `RepeatCount`
    字段设置为 `fyne.AnimationRepeatForever`：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Setting `RepeatCount` to any number above `0` will specify how many times this
    animation should repeat.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `RepeatCount` 设置为大于 `0` 的任何数字将指定此动画应重复的次数。
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After a repeating animation is started, it will run until it is manually stopped
    (using `Animation.Stop()`) or the number of repeats specified in `RepeatCount`
    is reached.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在重复动画开始后，它将一直运行，直到手动停止（使用 `Animation.Stop()`）或达到 `RepeatCount` 中指定的重复次数。
- en: There are many more animation APIs that can be used to control graphics and
    transitions. You can find more by looking for `NewXxxAnimation()` constructor
    functions in the `canvas` package.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多的动画 API 可以用来控制图形和过渡。您可以在 `canvas` 包中查找 `NewXxxAnimation()` 构造函数来找到更多。
- en: Now that we have explored the graphical capabilities of the Fyne toolkit, we
    will put it together in a small game application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了 Fyne 工具包的图形功能，我们将将其组合在一个小型游戏应用程序中。
- en: Implementing a simple game
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个简单的游戏
- en: In the first example application of this book, we will see how the canvas elements
    come together by building the graphical elements of a *snake game* (for a history
    of this game, see the Wikipedia entry at [https://en.wikipedia.org/wiki/Snake_(video_game_genre)](https://en.wikipedia.org/wiki/Snake_(video_game_genre)).
    The main element of this game is a snake character that the user will control
    as it moves around the screen. We will build the snake from a row of rectangles
    and add animation elements to bring it to life. Let's start by drawing the initial
    screen.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一个示例应用程序中，我们将通过构建 *蛇游戏* 的图形元素来了解画布元素是如何结合在一起的（关于这款游戏的历史，请参阅维基百科条目[https://en.wikipedia.org/wiki/Snake_(video_game_genre)](https://en.wikipedia.org/wiki/Snake_(video_game_genre))）。这个游戏的主要元素是蛇角色，用户将控制它在屏幕上移动。我们将从一排矩形开始构建蛇，并添加动画元素使其生动起来。让我们先绘制初始屏幕。
- en: Drawing a snake on screen
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制蛇
- en: 'To start the work of displaying the game canvas, we will see create a simple
    snake that consists of a row of 10 green squares. Let''s begin:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始显示游戏画布的工作，我们将创建一个由 10 个绿色方块组成的简单蛇。让我们开始：
- en: 'Firstly, we will create a setup function that will build the game screen. We
    will call this function `setupGame` and create an empty list that we will populate.
    The return from this method is a container with no layout so that we can later
    use a manual layout for the visual elements:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个设置函数，该函数将构建游戏屏幕。我们将调用此函数 `setupGame` 并创建一个空列表，我们将填充它。此方法返回的容器没有布局，这样我们就可以稍后为视觉元素手动布局：
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To set up the graphical elements, we will iterate through a loop of 10 elements
    (`i` from `0` to `9`) and make a new `Rectangle` for each position. The elements
    are all created 10 x 10 in size and placed one above the other using the `Move`
    function. We will add them all to the segment slice created previously. This completes
    our setup code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了设置图形元素，我们将遍历一个包含 10 个元素的循环（`i` 从 `0` 到 `9`），并为每个位置创建一个新的 `Rectangle`。这些元素都是
    10 x 10 的大小，并使用 `Move` 函数一个接一个地放置。我们将它们全部添加到之前创建的段切片中。这完成了我们的设置代码：
- en: '[PRE37]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding color specification is using a hexadecimal format, where `0xff`
    is the maximum for a channel and a missing channel (like red and blue in this
    code) defaults to `0`. The result is a green of medium brightness.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前提到的颜色规范使用的是十六进制格式，其中 `0xff` 是通道的最大值，缺失的通道（如本代码中的红色和蓝色）默认为 `0`。结果是中等亮度的绿色。
- en: 'With the graphical setup code, we can wrap this in the usual application load
    code, this time passing the result of `setupGame()` to the `SetContent` function.
    As this game will not have dynamic sizing, we will call `SetFixedSize(true)` so
    that the window cannot be resized:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图形设置代码，我们可以将其包裹在通常的应用程序加载代码中，这次将 `setupGame()` 的结果传递给 `SetContent` 函数。由于这个游戏没有动态大小，我们将调用
    `SetFixedSize(true)` 以确保窗口不能调整大小：
- en: '[PRE38]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we can build and run the code in the usual way:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像往常一样构建和运行代码：
- en: '[PRE39]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will see the following result:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下结果：
- en: '![Figure 3.11 – A simple snake drawn in the window'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.11 – 窗口中绘制的一个简单蛇'
- en: '](img/Figure_3.23_B16820.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_3.23_B16820.jpg](img/Figure_3.23_B16820.jpg)'
- en: Figure 3.11 – A simple snake drawn in the window
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 窗口中绘制的一个简单蛇
- en: Next, we will bring the snake to life with some simple movement code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一些简单的移动代码使蛇活跃起来。
- en: Adding a timer to move the snake
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加计时器来移动蛇
- en: 'The next step is to add some motion to the game. We will start with a simple
    timer that repositions the snake on screen:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加一些游戏动作。我们将从一个简单的计时器开始，它将蛇重新定位在屏幕上：
- en: 'To help manage the game state, we will define a new type to store the `x`,
    `y` value of each snake segment, named `snakePart`. We then make a slice that
    contains all of the elements, and this is what we will update as the snake moves
    around the screen. We will also define the game variable that we will use to refresh
    the screen when needed:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助管理游戏状态，我们将定义一个新的类型来存储每个蛇段 `x`、`y` 值，命名为 `snakePart`。然后我们创建一个包含所有元素的切片，这就是我们在蛇在屏幕上移动时将更新的内容。我们还将定义一个游戏变量，当需要刷新屏幕时我们将使用它：
- en: '[PRE40]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside `setupGame`, we need to create the representation of snake segments,
    one for each of the rectangles we created before. Adding the following lines to
    the loop will set up the state:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `setupGame` 内部，我们需要创建蛇段表示，每个矩形一个。将以下行添加到循环中将设置状态：
- en: '[PRE41]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make sure that the game refreshes each time we move the snake, we need to
    move the rectangles and call `Refresh()`. We create a new function that will update
    the rectangles that we created earlier based on updated snake section information.
    We call this `refreshGame()`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保每次移动蛇时游戏都会刷新，我们需要移动矩形并调用 `Refresh()`。我们创建一个新的函数，该函数将根据更新的蛇段信息更新我们之前创建的矩形。我们称这个函数为
    `refreshGame()`：
- en: '[PRE42]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To run the main game loop, we need one more function that will use a timer
    to move the snake. We call this function `runGame`. This code waits 250 milliseconds
    and then moves the snake forward. To move it, we copy the position of each element
    from that of the element that is one segment further forward, working from the
    tail to the head. Lastly, the code moves the head to a new position, in this case
    further up the screen (by using `snakeParts[0].y--`). Refer to the following function:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行主游戏循环，我们需要一个额外的函数来使用计时器移动蛇。我们称这个函数为 `runGame`。此代码等待 250 毫秒，然后移动蛇。为了移动它，我们复制每个元素的位置，从比它前进一步的那个元素的位置开始，从尾部到头部工作。最后，代码将头部移动到新的位置，在这种情况下是屏幕的上方（通过使用
    `snakeParts[0].y--`）。请参考以下函数：
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To start the game timer, we need to update the `main()` function. It must assign
    the `game` variable so that we can refresh it later, and it will start a new goroutine
    executing the `runGame` code. We do this by changing the `SetContent` and `ShowAndRun`
    calls to read as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启动游戏计时器，我们需要更新 `main()` 函数。它必须分配 `game` 变量，以便我们稍后可以刷新它，并且它将启动一个新的 goroutine
    执行 `runGame` 代码。我们通过更改 `SetContent` 和 `ShowAndRun` 调用来这样做：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running the updated code will initially show the same screen, but the green
    shape will then move up the screen until it leaves the window:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行更新后的代码最初将显示相同的屏幕，但绿色形状随后将向上移动屏幕，直到它离开窗口：
- en: '[PRE45]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the draw and basic movement code in place, we want to be able to control
    the game, which we will look at next.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了绘制和基本运动代码之后，我们希望能够控制游戏，我们将在下一节中探讨这一点。
- en: Using keys to control direction
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用按键控制方向
- en: 'To control the snake''s direction, we will need to handle some keyboard events.
    Unfortunately, this will be specific to desktop or mobile devices with a hardware
    keyboard; to add touchscreen controls would require using widgets (such as a button)
    that we will not explore until [*Chapter 5*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)*,
    Widget Library and Themes*:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制蛇的方向，我们需要处理一些键盘事件。不幸的是，这将是针对具有硬件键盘的桌面或移动设备；要添加触摸屏控制，需要使用小部件（如按钮），我们将在[*第5章*](B16820_05_Final_JM_ePub.xhtml#_idTextAnchor119)*，小部件库和主题*中不探讨这些内容：
- en: 'To start with, we define a new type (`moveType`) that will be used to describe
    the next direction in which to move. We use the Go built-in instruction `iota`,
    which is similar to `enum` in other languages. The `move` variable is then defined
    to hold the next move direction:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个新的类型（`moveType`），它将用于描述下一个移动方向。我们使用Go内置指令`iota`，它在其他语言中类似于`enum`。然后定义`move`变量来保存下一个移动方向：
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will translate from key events to the movement type that we just defined.
    Create a new `keyTyped` function as follows that will perform the keyboard mapping:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从按键事件转换为我们刚刚定义的运动类型。创建一个新的`keyTyped`函数，如下所示，该函数将执行键盘映射：
- en: '[PRE47]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For the key events to be triggered, we must specify that this key handler should
    be used for the current window. We do this using the `SetOnKeyTyped()` function
    on the window''s canvas:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了触发按键事件，我们必须指定这个键处理程序应该用于当前窗口。我们通过在窗口的画布上使用`SetOnKeyTyped()`函数来完成此操作：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make the snake move according to these events, we need to update the `runGame()`
    function to apply the correct movement. In place of the line `snakeParts[0].y--`
    (just before `refreshGame()`), we add the following code that will position the
    head for each new move:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使蛇根据这些事件移动，我们需要更新`runGame()`函数以应用正确的移动。在`snakeParts[0].y--`（在`refreshGame()`之前）的行替换以下代码，该代码将为每次新移动定位头部：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now run the updated code sample to test the keyboard handling:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行更新的代码示例来测试键盘处理：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After the app loads and you press the left and then down keys, you should see
    something like the following:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序加载后，您按下左键然后按下下键，您应该看到以下内容：
- en: '![Figure 3.12 – The snake can move around the screen'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.12 – 蛇可以在屏幕上移动'
- en: '](img/Figure_3.25_B16820.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 3.25 – B16820.jpg](img/Figure_3.25_B16820.jpg)'
- en: Figure 3.12 – The snake can move around the screen
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 3.12 – 蛇可以在屏幕上移动
- en: Although this is now technically an animated game, we can make it smoother.
    Using the animation API will allow us to draw smoother movements.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管现在从技术上讲这是一个动画游戏，但我们仍然可以使它更加流畅。使用动画API将允许我们绘制更平滑的运动。
- en: Animating the movement
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画运动
- en: 'The motion created by our run loop in the previous section provides the motion
    that the game is based on, but it is not very smooth. In this last section, we
    will improve the motion by using the animation API. We will create a new rectangle
    for the head segment that will move ahead of the snake animation and also move
    the tail to its new position smoothly. The rest of the elements can remain fixed.
    Let''s see how this is done:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中我们的运行循环创建的运动为游戏提供了基础运动，但它并不非常平滑。在本节的最后，我们将通过使用动画API来改进运动。我们将为头部段创建一个新的矩形，该矩形将移动到蛇动画的前面，并将尾巴平滑地移动到新位置。其余元素可以保持固定。让我们看看这是如何实现的：
- en: 'We first define a new rectangle that represents the moving head segment:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的矩形，代表移动的头部段：
- en: '[PRE51]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We set this up by adding the following code to the `setupGame` function:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在`setupGame`函数中添加以下代码来设置此功能：
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To start drawing the head in front of the current body position, we add the
    following code to the top of the `runGame` function so that the next segment is
    calculated in the movement before the snake reaches that position:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在蛇当前身体位置之前开始绘制头部，我们需要在`runGame`函数的顶部添加以下代码，以便在蛇到达该位置之前计算下一个运动段：
- en: '[PRE53]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We set up our animations inside the `for` loop in the `runGame` function, before
    the timer pause. Firstly, we calculate where the head is and then its new position
    and set up a new animation to make that transition:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`runGame`函数中的`for`循环内设置动画，在计时器暂停之前。首先，我们计算头部位置及其新位置，然后设置一个新的动画来实现这个过渡：
- en: '[PRE54]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also create another animation to transition the tail to its new position,
    as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建另一个动画，将尾巴过渡到新的位置，如下所示：
- en: '[PRE55]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After the `time.Sleep` in our game loop, we need to use the new `nextPart`
    variable to set up the new head position, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的游戏循环中的`time.Sleep`之后，我们需要使用新的`nextPart`变量来设置新的头部位置，如下所示：
- en: '[PRE56]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After the refresh line, we need to update the movement calculations to set
    up `nextPart` ready for the next movement:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在刷新行之后，我们需要更新运动计算来设置`nextPart`以便为下一次移动做准备：
- en: '[PRE57]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the updated code and you will see this behavior, but with a smooth transition
    along the path:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行更新后的代码，你会看到这种行为，但沿着路径有一个平滑的过渡：
- en: '[PRE58]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For the complete code for this example, you can use the book's GitHub repository
    at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例的完整代码，你可以使用本书的GitHub仓库：[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter03/example)。
- en: Although many more features could be added to this example, we have explored
    all the application and canvas operations required to build a full game.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以给这个示例添加更多功能，但我们已经探索了构建完整游戏所需的所有应用程序和画布操作。
- en: Summary
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our journey with the Fyne toolkit, exploring how
    it is organized and how a Fyne application operates. We saw how it uses vector
    graphics to create a high-quality output at any resolution, allowing it to scale
    well over desktop computers, smart phones, and more.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了使用Fyne工具包的旅程，探索了它是如何组织的以及一个Fyne应用程序是如何运行的。我们看到了它是如何使用矢量图形在任何分辨率下创建高质量输出的，这使得它能够在桌面电脑、智能手机等设备上很好地缩放。
- en: We explored the features of the canvas package and saw how it can be used to
    draw individual elements to the screen. By combining these graphical primitives
    using `fyne.Container`, we were able to draw more complex output to our window.
    We also saw how the animation APIs can be used to display transitions of an object's
    size, position, and other properties.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了canvas包的功能，并看到了它是如何被用来将单个元素绘制到屏幕上的。通过使用`fyne.Container`结合这些图形原语，我们能够绘制更复杂的输出到我们的窗口中。我们还看到了动画API是如何被用来显示对象大小、位置和其他属性的过渡效果。
- en: To bring this knowledge together, we built a small snake game that displayed
    elements to the screen and animated them based on user input. Although we could
    add many more features and graphical polish to this game, we will move on to other
    topics.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些知识结合起来，我们构建了一个小型的蛇游戏，该游戏将元素显示到屏幕上并根据用户输入进行动画处理。尽管我们可以给这个游戏添加更多功能和图形润色，但我们将继续探讨其他主题。
- en: In the next chapter, we will explore how layout algorithms can manage the contents
    of a window and the best practices of file handling that are needed to build an
    image browser application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨布局算法如何管理窗口的内容以及构建图像浏览器应用程序所需的最佳文件处理实践。
