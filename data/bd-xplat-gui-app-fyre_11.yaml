- en: '*Chapter 8*: Project Structure and Best Practices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：项目结构和最佳实践'
- en: The Go language comes with a well-understood set of best practices such as style,
    documentation, and code structure. Often, when applications start adding **graphical
    user interface** (**GUI**) elements, these best practices can be lost. Testing
    individual components and keeping a clean separation of types helps us maintain
    clean code that is easier to maintain over time. These concepts can be followed
    within GUI code as well, with support from a toolkit such as Fyne.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言附带了一套被广泛理解的最佳实践，如风格、文档和代码结构。通常，当应用程序开始添加**图形用户界面（GUI**）元素时，这些最佳实践可能会丢失。测试单个组件并保持类型之间的清晰分离有助于我们保持代码的整洁，使其随着时间的推移更容易维护。这些概念也可以在GUI代码中遵循，并得到像Fyne这样的工具包的支持。
- en: 'In this chapter, we''ll explore how these concepts apply to graphical application
    development and how we can learn from them to make our GUIs easier to manage over
    time. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这些概念如何应用于图形应用程序开发，以及我们如何从中学习，使我们的GUI随着时间的推移更容易管理。我们将涵盖以下主题：
- en: Organizing a well-structured project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织一个结构良好的项目
- en: Understanding the separation of concerns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关注点的分离
- en: Using test-driven development and writing tests for the whole application GUI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试驱动开发并编写整个应用程序GUI的测试
- en: Managing platform-specific code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理特定平台的代码
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has the same requirements as [*Chapter 3*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066),
    *Windows, Canvas, and Drawing*; that is, you must have the Fyne toolkit installed
    and a Go and C compiler working. For more information, please refer to that chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与[*第3章*](B16820_03_Final_JM_ePub.xhtml#_idTextAnchor066)、“Windows、Canvas和绘图”相同；也就是说，你必须安装Fyne工具包，并且Go和C编译器正在运行。更多信息，请参阅该章节。
- en: The full source code for this chapter can be found at [https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08](https://github.com/PacktPublishing/Building-Cross-Platform-GUI-Applications-with-Fyne/tree/master/Chapter08)找到。
- en: Some parts of this chapter refer to managing platform-specific code, so it may
    be beneficial if you have two different operating systems available to work with.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些部分涉及管理特定平台的代码，因此如果你有两个不同的操作系统可供使用，可能会很有帮助。
- en: Organizing your project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织你的项目
- en: One of the design principles of the Go language is that you can start simple
    and build more structure into your project as it grows. Following this mantra,
    you can simply start a GUI project with a single `main.go` file inside a directory
    that's been created for the project. This will initially contain your entire application,
    starting from its `main()` function.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的设计原则之一是你可以从简单开始，随着项目的增长，逐步构建更多的结构。遵循这个原则，你可以在为项目创建的目录中简单地启动一个GUI项目，其中包含一个`main.go`文件。这最初将包含你的整个应用程序，从其`main()`函数开始。
- en: Starting simple
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从简单开始
- en: Once your user interface has grown from the very basics, it is a good idea to
    split it into a new file, perhaps named `ui.go`. Splitting the code in this way
    makes it clearer which code is simply booting an application (the `main()` function
    and helpers) compared to what is actually building the user interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的用户界面从最基本的形式发展起来，将其拆分到一个新文件中是一个好主意，例如命名为`ui.go`。以这种方式拆分代码可以使代码更清晰，区分哪些代码仅仅是启动应用程序（`main()`函数和辅助函数）与实际构建用户界面的代码。
- en: 'By this time, you should be thinking about adding unit tests (if you have not
    already added them!). These tests will live in a file, alongside your code, that
    ends in `_test.go` – for example, `ui_test.go`. It is good practice to test all
    of your code, and for each new function or type you add, there will be new tests
    to ensure the code is working correctly over time. It is normal for there to not
    be a test file for the main function since its purpose is simply to wire up the
    application''s components and launch it. A project that has passed the very basic
    stage might contain the following files:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该开始考虑添加单元测试（如果你还没有添加的话！）。这些测试将存在于一个文件中，与你的代码一起，以`_test.go`结尾——例如，`ui_test.go`。测试所有代码是一个好习惯，并且对于你添加的每个新函数或类型，都会有新的测试来确保代码随着时间的推移正确运行。对于主函数没有测试文件是正常的，因为它的目的只是连接应用程序的组件并启动它。一个已经通过非常基础的阶段的项目可能包含以下文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This structure works well until an application needs to add some custom types.
    We will explore this next.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构在应用程序需要添加一些自定义类型时效果很好。我们将在下一节中探讨这个问题。
- en: Adding new types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新类型
- en: 'Since Fyne application user interface code focuses mainly on behavior, it is
    common to break up different areas of an application into separate areas, each
    defining its own type. Each type will define the data (or data access) that it
    represents, as well as the various methods that can operate on that information.
    These sections of the application code could be simple type definitions, where
    there will likely be a UI creation function, named `makeUI()` or something similar.
    Here''s an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Fyne应用程序的用户界面代码主要关注行为，因此通常会将应用程序的不同区域拆分为单独的区域，每个区域定义自己的类型。每个类型将定义它所代表的数据（或数据访问），以及可以操作这些信息的各种方法。这些应用程序代码的部分可能是简单的类型定义，其中可能有一个名为`makeUI()`或类似名称的UI创建函数。以下是一个示例：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, they may be custom widgets, in which case the type extends `CanvasObject`,
    so it can be passed into the wider GUI structure. In either situation, these types
    deserve a new file, such as `mytype.go`, and their own tests, in `mytype_test.go`.
    For example, an application that is growing may have the following structure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可能是自定义小部件，在这种情况下，类型扩展`CanvasObject`，因此可以将其传递到更广泛的GUI结构中。在任一情况下，这些类型都值得有一个新的文件，例如`mytype.go`，以及它们自己的测试，在`mytype_test.go`中。例如，一个不断增长的应用程序可能具有以下结构：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a good structure for a simple application, but once the code base grows,
    especially if it contains libraries or supporting functionality that are not part
    of the GUI, you will likely want to consider using multiple packages. So, what
    happens then? Let's take a look.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单应用程序的好结构，但一旦代码库增长，特别是如果它包含不是GUI部分的库或支持功能，你可能会考虑使用多个包。那么会发生什么呢？让我们看看。
- en: Splitting code into packages
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码拆分为包
- en: Packages are useful when you want to separate some complex code that manages,
    for example, data access or complex calculations from the user interface code
    that will display it. In these situations, a separate package allows you to maintain
    the clean divide and test these elements independently (see the *Understanding
    the separation of concerns* section later in this chapter). If you would like
    this subpackage API to be publicly available, then you can just create a new folder
    for it (for example, `project/mylib`). Alternatively, you could choose to group
    many subpackages under a standard `pkg` directory (that is, `project/pkg/mylib`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将一些复杂的代码，例如数据访问或复杂计算的管理代码，与将要显示它的用户界面代码分离时，包就非常有用。在这些情况下，一个单独的包允许你保持清晰的分离并独立测试这些元素（参见本章后面的*理解关注点分离*部分）。如果你希望这个子包API对公众可用，那么你可以只为它创建一个新的文件夹（例如，`project/mylib`）。或者，你也可以选择将许多子包分组在标准的`pkg`目录下（即，`project/pkg/mylib`）。
- en: However, if you would like to keep its API as an internal detail for this project,
    you can use the special `internal` package as its parent (that is, `project/internal/pkg/mylib`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你希望将其API作为此项目的内部细节，你可以使用特殊的`internal`包作为其父包（即，`project/internal/pkg/mylib`）。
- en: 'It can also be helpful to keep your code tidy if the GUI code makes use of
    the internal structure as well, so that the top of the project contains fewer
    files. It is common to use `project/internal/app/` for this purpose. So, an application
    that contains the `storage` and `cache` internal libraries might begin to look
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果GUI代码也使用了内部结构，那么保持代码整洁也是有帮助的，这样项目的顶部就会包含更少的文件。通常，人们会使用`project/internal/app/`来实现这一点。因此，一个包含`storage`和`cache`内部库的应用程序可能看起来像这样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using this model, the library packages are all self-contained and the app package
    can depend on them to operate. The `main.go` file may depend on all of these packages
    to prepare the application and launch its GUI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模型，库包都是自包含的，应用程序包可以依赖它们来运行。`main.go`文件可能依赖于所有这些包来准备应用程序并启动其GUI。
- en: 'The preceding structure works well for a single application repository. The
    following command will install it directly (note that this should not include
    a scheme prefix such as `http://`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构对于单个应用程序存储库来说效果很好。以下命令将直接安装它（请注意，这个命令不应该包含方案前缀，如`http://`）：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, in some situations, you will require more than one executable in a
    project. We'll look at this in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你需要在项目中使用多个可执行文件。我们将在下一节中探讨这个问题。
- en: Multiple executables
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 多个可执行文件
- en: Regardless of whether the project is primarily a library or an application that
    contains multiple executables, there is a standard directory named `cmd` that
    can contain multiple subdirectories, one for each executable. Each package within
    `cmd` will contain the name of the application it should compile to, though the
    `Go` package will always be `main` so that it can be executed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论项目主要是库还是包含多个可执行文件的应用程序，都有一个名为`cmd`的标准目录，可以包含多个子目录，每个子目录对应一个可执行文件。`cmd`中的每个包都将包含它应该编译到的应用程序的名称，尽管`Go`包始终是`main`，这样它就可以被执行。
- en: 'So, if your project was mainly a library but contained the `mylib_gui` and
    `mylib_config` executables, then you would have a structure like the following
    (omitting any internal code):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你的项目主要是库，但包含了`mylib_gui`和`mylib_config`可执行文件，那么你的结构将如下所示（省略任何内部代码）：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By using this format, someone could depend on your library by using the following
    command (without `http://` being used):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用此格式，某人可以通过以下命令（不使用`http://`）来依赖你的库：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'They could also choose to install the GUI binary using the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 他们也可以选择使用以下命令安装GUI二进制文件：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This flexibility allows repositories to have multiple purposes while maintaining
    a clean structure. Of course, there would probably be a lot of common code in
    `internal/pkg/` or `internal/app/` to allow this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性允许仓库在保持整洁结构的同时拥有多个用途。当然，`internal/pkg/`或`internal/app/`中可能会有很多通用代码，以实现这一点。
- en: The preceding illustrations are just examples – each application will have different
    requirements and may wish to diverge from these common layouts. To help developers
    understand an application, its `main()` function should be at the root of a project
    or in a `cmd/appname/` subdirectory. Similarly, a library's main API should be
    importable from the root of a project or the `pkg/libname/` subdirectory. Following
    these hints will make your app or library easier to pick up for new developers
    who are familiar with the recommended Go project layouts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例只是例子——每个应用程序都会有不同的需求，可能希望偏离这些常见的布局。为了帮助开发者理解一个应用程序，其`main()`函数应该位于项目的根目录或`cmd/appname/`子目录中。同样，库的主要API应该可以从项目的根目录或`pkg/libname/`子目录导入。遵循这些提示将使你的应用程序或库对新熟悉推荐Go项目布局的开发者更容易上手。
- en: In this section, we learned how an application can be split into multiple pieces.
    It may not have been clear why this is important, though. In the next section,
    we'll look at the separation of concerns, which shows how this approach helps
    keep our code clean and maintainable for the future.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将应用程序拆分为多个部分。尽管如此，这为什么很重要可能并不清楚。在下一节中，我们将探讨关注点分离，这将展示这种方法如何帮助我们保持代码的整洁和未来可维护性。
- en: Understanding the separation of concerns
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解关注点分离
- en: As we mentioned earlier in this chapter, as well as when we discussed the Fyne
    toolkit API principles in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036),
    *The Future According to Fyne*, in the *Designing APIs for simplicity and maintainability*
    section, the concept of **separation of concerns** is important if we wish to
    maintain a clean code base. It enables us keep related code together without the
    fear of breaking other areas when we make a change.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面所提到的，以及我们在[*第2章*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036)中讨论Fyne工具包API原则时，在*设计简洁且易于维护的API*部分，**关注点分离**的概念如果我们要保持代码库的整洁性是非常重要的。它使我们能够将相关的代码放在一起，而不用担心在做出更改时破坏其他区域。
- en: 'This concept is closely related to the single responsibility principle, as
    introduced by Robert C. Martin in his *Principles of Object-Oriented Design* ([http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))
    article. Here, he stated the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念与罗伯特·C·马丁在其*面向对象设计原则*([http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://www.butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))文章中引入的单一职责原则密切相关。在这里，他提出了以下观点：
- en: '"A class should have one, and only one, reason to change."'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该只有一个，并且只有一个，改变的理由。”
- en: –Robert C. Martin
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: –罗伯特·C·马丁
- en: In this respect, *concerns* have a wider scope than responsibilities in that
    they typically influence your application's design and architecture rather than
    individual classes or interfaces. Separation of concerns is essential in a graphical
    application if you wish to correctly detach your easily tested logic from the
    presentation code, which manages user interaction. By separating the concerns
    of an application, it is easier to test subcomponents and check the validity of
    our software without even needing to run the application. In doing so, we create
    more robust applications that can adapt to changes in requirements or technology
    over time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在这方面，*关注点*比责任有更广泛的范围，因为它们通常影响您应用程序的设计和架构，而不是单个类或接口。在图形应用程序中，如果您希望正确地将易于测试的逻辑与处理用户交互的表示代码分离，关注点的分离是必不可少的。通过分离应用程序的关注点，我们更容易测试子组件并验证我们软件的有效性，甚至不需要运行应用程序。这样做，我们创建了更健壮的应用程序，可以适应随时间变化的需求或技术。 '
- en: For example, the Fyne widgets and APIs should not be incorporated into, or impact
    the design of, your business logic. Even a graphical API focused on behavior,
    such as the Fyne toolkit, should only be referenced by the presentation layer
    of your application (items in the project root or `internal/app` packages). It
    is for this reason that a robust application is split into multiple areas. Each
    of the supporting libraries will operate without any reference to the presentation
    layer or toolkit's capabilities. In this way, we keep the software open to change
    without it having a huge impact on unrelated areas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Fyne小部件和API不应纳入或影响您的业务逻辑设计。即使是专注于行为的图形API，如Fyne工具包，也只应由应用程序的表示层（项目根目录或`internal/app`包中的项目）引用。正因为如此，一个健壮的应用程序才被分割成多个区域。每个支持库都将独立于表示层或工具包的功能运行。这样，我们保持软件的开放性，使其在不影响相关区域的情况下易于更改。
- en: In the next section, we'll learn how the provided test utilities help ease the
    creation of unit tests. We can do this by keeping our code separated into smaller
    components. This is useful for validating the behavior of the presentation code
    of our apps.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习提供的测试实用工具如何帮助简化单元测试的创建。我们可以通过将代码分割成更小的组件来实现这一点。这对于验证我们应用程序表示代码的行为非常有用。
- en: Test driving your development
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: The effort required to automatically test user interfaces or frontend software
    is often considered too expensive for the value it returns when it comes to avoiding
    future bugs. However, this is largely rooted in the toolkits being utilized or
    even the presentation technologies that have been chosen. Without full support
    for testing in the development tools or graphical APIs, it can be difficult to
    create simple unit tests without a huge amount of effort being needed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自动测试用户界面或前端软件所需的工作量通常被认为对于避免未来错误的价值太低。然而，这很大程度上取决于所使用的工具包或甚至选择的表现技术。如果没有开发工具或图形API对测试的全面支持，在没有投入大量努力的情况下创建简单的单元测试可能会很困难。
- en: One of the design principles of the Fyne toolkit is that the application GUI
    should be as easy to test as the rest of its code. This is partly made possible
    by the API's design, but this is further reinforced by the test utilities that
    we can provision. We will explore this later in this section. Using the following
    approaches, we will learn how a Fyne application can follow **test-driven development**
    (**TDD**), even for the user interface components.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包的设计原则之一是应用程序的GUI应该像其余代码一样易于测试。这部分得益于API的设计，但这一点通过我们可以提供的测试实用工具得到了进一步加强。我们将在本节稍后探讨这一点。通过以下方法，我们将学习Fyne应用程序如何遵循**测试驱动开发**（**TDD**），即使是对于用户界面组件。
- en: Designed to be tested
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计用于测试
- en: The modular design of the Fyne toolkit allows different drivers to be loaded
    for different systems or purposes. This approach primarily supports Fyne applications
    working on any operating system, without developers needing to modify their applications.
    An additional benefit of this approach is that an app can be loaded into a test
    runtime to execute various checks, without ever needing to display to the screen.
    This vastly improves the speed of test runs and also makes your tests more reliable
    (as user interaction cannot interfere with the test process).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包的模块化设计允许为不同的系统或目的加载不同的驱动程序。这种方法主要支持在任何操作系统上工作的Fyne应用程序，无需开发者修改他们的应用程序。这种方法的一个额外好处是，可以将应用程序加载到测试运行时中执行各种检查，而无需在屏幕上显示。这大大提高了测试运行的速度，同时也使你的测试更加可靠（因为用户交互不能干扰测试过程）。
- en: By importing the `fyne.io/fyne/test` package, we automatically create an in-memory
    application that is capable of creating virtual windows that contain actual application
    GUIs. These windows support the same APIs as regular windows so that your code
    can run the same as it ran previously. Each graphical element can be programmatically
    interacted with and tested to confirm its behavior and state, and even to verify
    its rendering output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`fyne.io/fyne/test`包，我们自动创建了一个内存中的应用程序，该应用程序能够创建包含实际应用程序GUI的虚拟窗口。这些窗口支持与常规窗口相同的API，因此你的代码可以像之前一样运行。每个图形元素都可以通过编程方式与之交互和测试，以确认其行为和状态，甚至验证其渲染输出。
- en: In the next two examples, we'll learn how to test the behavior of a user interface
    component and then how to verify that it rendered correctly, all without needing
    to display the GUI on a screen.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个例子中，我们将学习如何测试用户界面组件的行为，然后如何验证它是否正确渲染，所有这些都不需要将GUI显示在屏幕上。
- en: Testing our GUI logic
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的GUI逻辑
- en: 'To test the functionality of an application, we must define a very simple GUI.
    It will have a `Hello World!` label, followed by an entry widget that we can use
    to specify our name. The final component – a simple button – will be triggered,
    updating the greeting based on the input. Here is how it works:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试应用程序的功能，我们必须定义一个非常简单的GUI。它将有一个`Hello World!`标签，后面跟着一个我们可以用来指定我们名字的输入小部件。最后的组件——一个简单的按钮——将被触发，根据输入更新问候语。以下是它是如何工作的：
- en: 'First, we define a simple `struct` called `greeter` that will hold references
    to these objects. For this example, we will write the following code to `ui.go`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个简单的`struct`，称为`greeter`，它将包含对这些对象的引用。在这个例子中，我们将编写以下代码到`ui.go`中：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since we are not creating a custom widget in this example, we will define a
    small method named `makeUI` that will construct the widgets that represent this
    application. In this case, this is a simple vertical box container that combines
    all the widgets that we created following the preceding description. We create
    each of the widgets, assign them to variables of the `greeter` type, and then
    return a vertical box that packs them together:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在这个例子中没有创建自定义小部件，我们将定义一个名为`makeUI`的小方法，该方法将构建代表此应用程序的小部件。在这种情况下，这是一个简单的垂直框容器，它结合了我们根据前面的描述创建的所有小部件。我们创建每个小部件，将它们分配给`greeter`类型的变量，然后返回一个将它们打包在一起的垂直框：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To perform the update, when the button is tapped, we need an additional function,
    `setGreeting`, that will format a replacement string using `fmt.Sprintf`. It passes
    in the current content of the `name` entry widget to make the greeting personal.
    This looks as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行更新，当按钮被点击时，我们需要一个额外的函数`setGreeting`，该函数将使用`fmt.Sprintf`格式化一个替换字符串。它将当前`name`输入小部件的内容传递进去，以使问候语个性化。这看起来如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Lastly, we create a simple `main` function that will load the greeter, display
    it in a window, and run the application:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个简单的`main`函数，该函数将加载问候语，在窗口中显示它，并运行应用程序：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can verify that the application works correctly by simply running it, as
    follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单地运行它来验证应用程序是否正确工作，如下所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this section, we''re focusing on the tests we must employ, so let''s write
    a unit test that validates the behavior we defined earlier:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注我们必须执行的测试，因此让我们编写一个单元测试来验证我们之前定义的行为：
- en: 'First, create the test file that will be provided along with this code; that
    is, `ui_test.go`. Here, we define a test with the standard signature. It must
    start with `Test` and accept a single parameter; that is, a `testing.T` pointer:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个测试文件，该文件将与代码一起提供；即`ui_test.go`。在这里，我们定义了一个具有标准签名的测试。它必须以`Test`开头，并接受一个参数；即一个`testing.T`指针：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this function, we will create a new instance of our greeter and request that
    the interface components are created. Once this has been run, we assert that the
    initial state is correct. Here, we use the `assert` package from the testify project
    by `stretchr` (more information can be found at [https://github.com/stretchr/testify](https://github.com/stretchr/testify)).
    This will use the `github.com/stretchr/testify/assert` import path, which should
    be added to the top of the file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将创建我们问候器的全新实例并请求创建界面组件。一旦运行完成，我们断言初始状态是正确的。在这里，我们使用由`stretchr`提供的testify项目的`assert`包（更多信息可以在[https://github.com/stretchr/testify](https://github.com/stretchr/testify)找到）。这将使用`github.com/stretchr/testify/assert`导入路径，应该添加到文件顶部。
- en: 'By adding the following code, you can set up the user interface so that it
    can be tested and perform its first assertions:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加以下代码，您可以设置用户界面以便进行测试并执行其第一次断言：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final step of writing this test is to execute the user steps and check
    the resulting changes. We''re using Fyne''s `test` package to simulate a user
    typing into the entry widget and then tapping the button to confirm this. After
    that, we confirm that the greeting text has been updated:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写此测试的最后一步是执行用户步骤并检查结果变化。我们使用Fyne的`test`包来模拟用户在输入小部件中输入并点击按钮以确认。之后，我们确认问候文本已被更新：
- en: '[PRE15]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With this test code, we can be sure that the user interface is working correctly.
    It can be simply executed like any other go test:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段测试代码，我们可以确保用户界面运行正确。它可以像其他任何go测试一样简单地执行：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With that, we know that the app works correctly. However, it can be helpful
    to verify that the output is being rendered as expected. Let's write a new test
    to do that.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们知道应用运行正确。然而，验证输出是否按预期渲染可能会有所帮助。让我们编写一个新的测试来做到这一点。
- en: Verifying that the output is being rendered
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输出是否被渲染
- en: In most situations, an application can be tested for correctness through behavior
    testing, as we saw previously. However, it is sometimes useful to actually see
    what will be rendered to check the result. If your application contains custom
    drawing code or complex layouts, this may be appropriate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，应用程序可以通过行为测试来测试其正确性，就像我们之前看到的那样。然而，有时实际看到将要渲染的内容以检查结果是有用的。如果您的应用程序包含自定义绘图代码或复杂的布局，这可能很合适。
- en: 'In this section, we will create a new test, similar to the one we created in
    the preceding section, but in this case, we will test the rendered output using
    another `test` utility. Let''s see how this works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个新的测试，类似于我们在上一节中创建的测试，但在这个情况下，我们将使用另一个`test`实用工具来测试渲染输出。让我们看看这是如何工作的：
- en: 'Create a new method, as shown in the following code. Once you''ve set up the
    `greeter` type, pass `g.makeUI()` into `test.NewWindow()`. This will create an
    in-memory window that we can use to capture the output, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的方法，如下面的代码所示。一旦设置了`greeter`类型，将`g.makeUI()`传递给`test.NewWindow()`。这将创建一个内存中的窗口，我们可以用它来捕获输出，如下所示：
- en: '[PRE17]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With a test window created, we can get its content using `w.Canvas().Capture()`.
    This function will return an image with the interface rendered as if it were running
    in a real window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建测试窗口后，我们可以使用`w.Canvas().Capture()`来获取其内容。这个函数将返回一个图像，界面渲染得就像它在真实窗口中运行一样。
- en: 'Now, we can use the `AssertImageMatches` test utility, which requires that
    the test compares this image to the named file, as follows:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`AssertImageMatches`测试实用工具，它要求测试比较此图像与命名文件，如下所示：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will compare the default look. Now, we can simulate user actions
    again and compare the new state to another image file with an appropriate name:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码将比较默认的外观。现在，我们可以再次模拟用户操作，并将新状态与另一个具有适当名称的图像文件进行比较：
- en: '[PRE19]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can run these tests just like the behavior tests before, though this time,
    the tests will fail because the images it is being compared to don't exist. You
    will find two new files inside the `testdata/failed/` directory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像之前的行测试一样运行这些测试，尽管这次测试将失败，因为与之比较的图像不存在。您将在`testdata/failed/`目录内找到两个新文件。
- en: 'You should look at these files to see what is being drawn. If you agree that
    the output is correct, then these files can be moved to the `testdata/` directory.
    On a second run of these tests, you will see that they all pass as expected. The
    following screenshot shows what the `typed_joe.png` file looks like:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该查看这些文件以了解正在绘制的内容。如果您认为输出是正确的，那么这些文件可以被移动到`testdata/`目录。在第二次运行这些测试时，您将看到它们都按预期通过。以下截图显示了`typed_joe.png`文件的外观：
- en: '![Figure 8.1 – The generated image from testing our user interface code'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1 – The generated image from testing our user interface code](img/Figure_8.1_B16820.jpg)'
- en: '](img/Figure_8.1_B16820.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.1 – The generated image from testing our user interface code](img/Figure_8.1_B16820.jpg)'
- en: Figure 8.1 – The generated image from testing our user interface code
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 测试我们的用户界面代码生成的图像
- en: Such tests can be brittle since making a change to the design of the toolkit
    will cause them to fail. However, they can be helpful to highlight when a code
    change causes a graphical change that was unexpected. Therefore, when used appropriately
    in your test code, this approach can be a valuable addition to your validation
    process.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对工具包设计进行更改会导致它们失败，因此此类测试可能很脆弱。然而，它们可以帮助突出显示代码更改导致意外图形变化的情况。因此，当在测试代码中适当使用时，这种方法可以成为验证过程的有价值补充。
- en: The tests we have explored in this section help verify that your application
    code is correct, and they should be run regularly. The best way to ensure this
    is to have a server run tests automatically. We will look at this next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们探讨的测试有助于验证应用程序代码的正确性，并且应该定期运行。确保这一点的最佳方法是让服务器自动运行测试。我们将在下一节探讨这一点。
- en: Continuous integration for GUIs
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUI的持续集成
- en: '**Continuous integration** (**CI** – the regular way to merge a team''s work-in-progress
    code so that it can be automatically tested) has become commonplace in software
    development teams. Adding this process to your team workflow is shown to highlight
    issues earlier in the development process, which leads to issues being fixed faster
    and, ultimately, better-quality software.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI** – 以常规方式合并团队的工作进度代码，以便自动测试）已成为软件开发团队的常态。将此流程添加到团队工作流程中已被证明可以更早地突出显示开发过程中的问题，从而更快地修复问题，并最终产生高质量的软件。'
- en: A critical part of this is automating the tests that exercise the entire source
    code – including the GUI. It is highly recommended to include not only a regular
    compilation of your entire application code, but also a full run of the unit tests
    upon each commit. Doing so will help you quickly identify breakages or unexpected
    changes in behavior. Various CI tools are available for this purpose, though looking
    at them is outside the scope of this book. These are helpful when you're configuring
    your automated processes as they ensure that tests such as the ones explored in
    this section are part of your regular testing and acceptance checks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键部分包括自动化测试整个源代码，包括GUI。强烈建议不仅包括整个应用程序代码的常规编译，而且在每次提交时都要运行单元测试。这样做可以帮助你快速识别损坏或行为上的意外变化。为此目的，有各种CI工具可用，尽管查看它们超出了本书的范围。当你配置自动化流程时，这些工具很有帮助，因为它们确保本节中探索的测试等成为你常规测试和验收检查的一部分。
- en: We have already seen that testing, and doing so regularly, is important, but
    how does this change if we want to have slightly different code for different
    platforms? At some point, most applications are likely to need system calls that
    vary based on the operating system. Next, we will look at how to do this while
    maintaining good code structure that is easy to understand.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，定期进行测试很重要，但如果我们希望为不同的平台编写略有不同的代码，情况会有所改变。在某个时候，大多数应用程序可能需要基于操作系统的系统调用。接下来，我们将探讨如何在保持易于理解的良好代码结构的同时完成这项工作。
- en: Managing platform-specific code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理特定平台的代码
- en: Back in [*Chapter 2*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036), *The
    Future According to Fyne*, we saw that the Go compiler has built-in support for
    the conditional inclusion of source files based on a system of environment variables
    and build tags. As an application adds more functionality, especially from a platform
    integration perspective, it is possible that the toolkit will not provide all
    of the functionality you are looking for. When this happens, the code will need
    to be updated to handle platform-specific functionality. To do so, we will use
    a variation of the conditional build – using well-named files instead of build
    tags. This is easier to read at the project level and should clearly indicate
    which files will be compiled for which platform.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16820_02_Final_JM_ePub.xhtml#_idTextAnchor036)“根据Fyne的未来”中，我们了解到Go编译器支持基于环境变量和构建标签的源文件条件包含。随着应用程序添加更多功能，尤其是在平台集成方面，工具包可能无法提供你所需的所有功能。当这种情况发生时，代码需要更新以处理特定平台的功能。为此，我们将使用条件构建的变体——使用命名良好的文件而不是构建标签。这在项目级别上更容易阅读，并且应该清楚地表明哪些文件将编译为哪个平台。
- en: 'Let''s create a simple example: we want to read text out loud, but our code
    only has the ability to do so on macOS (Darwin). We will set up a simple `say()`
    function that does what we want in the `say_darwin.go` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的示例：我们想要大声朗读文本，但我们的代码只能在 macOS (Darwin) 上这样做。我们将在 `say_darwin.go` 文件中设置一个简单的
    `say()` 函数，来完成我们想要的功能：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This simple function calls out to the built-in *say* tool, a command-line application
    bundled with macOS that allows text to be read out loud. Since this file ends
    with `_darwin.go`, it will only be compiled when we are building for macOS. To
    compile correctly when building on other platforms, we need to create another
    file that will be loaded instead. We will call this file `say_other.go`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数调用了内置的 *say* 工具，这是一个与 macOS 打包的命令行应用程序，允许文本被大声朗读。由于这个文件以 `_darwin.go`
    结尾，它只会在我们为 macOS 构建时编译。为了在其他平台上正确编译，我们需要创建另一个将被加载的文件。我们将把这个文件命名为 `say_other.go`：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this file, we must specify the build condition since there is no special
    filename format for all other platforms. Here, `// +build !darwin` means that
    the file will be included on any platform other than macOS. The method we''ll
    be providing in this file simply logs that the feature is not supported. Finally,
    we must create a simple application launcher named `main.go` that will call the
    `say()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们必须指定构建条件，因为没有为所有其他平台指定特殊的文件名格式。在这里，`// +build !darwin` 表示该文件将包含在任何非
    macOS 平台上。我们将在此文件中提供的简单方法只是记录该功能不受支持。最后，我们必须创建一个简单的应用程序启动器，命名为 `main.go`，它将调用
    `say()` 函数：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running this code (using `go run .`) will read `Hello world!` out loud when
    it''s run on a macOS computer. On other operating systems, it will print an error
    stating that the feature is not available:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码（使用 `go run .`）将在 macOS 计算机上运行时大声朗读 `Hello world!`。在其他操作系统上，它将打印一个错误，表明该功能不可用：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can handle platform-specific code in such a way that it's clear to anyone
    learning the project at hand and reading its code for the first time. Another
    developer could decide to add a `say_windows.go` file to add support for reading
    text on Windows. As long as they also update the build rules in `say_other.go`,
    the application will continue to work as expected but with the addition of Windows-based
    text reading. The benefit of this approach is that it does not require us to modify
    any of the existing code to simply add this new functionality.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以这种方式处理特定平台的代码，使得任何学习当前项目并首次阅读其代码的人都能清楚地理解。另一位开发者可以决定添加一个 `say_windows.go`
    文件来支持在 Windows 上读取文本。只要他们也更新 `say_other.go` 中的构建规则，应用程序将继续按预期工作，但增加了基于 Windows
    的文本读取功能。这种方法的优点是，它不需要我们修改任何现有代码来简单地添加这个新功能。
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored some of the tips and techniques for managing a
    GUI-based application written with Go. By carefully planning the modules of an
    application and how they interact, we saw that we can make any application easier
    to test and maintain. Since higher test coverage is a factor when it comes to
    increasing the quality of software applications, we looked at how we can use these
    techniques to test our graphical code, which is a notoriously difficult topic.
    We stepped through an example of writing test code for a simple GUI application
    that could be run automatically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Go 编写的基于 GUI 的应用程序的一些管理和技巧。通过仔细规划应用程序的模块及其交互方式，我们看到了我们可以使任何应用程序更容易测试和维护。由于更高的测试覆盖率是提高软件应用程序质量的一个因素，我们研究了如何使用这些技术来测试我们的图形代码，这是一个众所周知难以处理的话题。我们通过一个示例来编写一个简单的
    GUI 应用程序的测试代码，该代码可以自动运行。
- en: When it becomes necessary to adapt to a specific operating system, we need to
    learn how our code can adapt. With appropriate abstractions or by writing platform-specific
    code that is switched out by generic fallbacks, we can keep our applications easy
    to maintain, despite operating system differences.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要适应特定的操作系统时，我们需要了解我们的代码如何适应。通过适当的抽象或编写特定平台的代码，并通过通用回退来切换，我们可以使我们的应用程序易于维护，尽管存在操作系统差异。
- en: Throughout this book, we have been running examples from the command line, next
    to their source code. This means that we have been able to incorporate files that
    exist in the current directory – but this is not going to be possible as we start
    to distribute our applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在命令行旁边运行示例代码，与它们的源代码并列。这意味着我们能够包含当前目录中存在的文件——但是当我们开始分发我们的应用程序时，这将不再可能。
- en: In the next chapter, we will look at how to include these extra assets (such
    as images and data files) in our application in preparation for their release.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将这些额外资源（例如图片和数据文件）包含到我们的应用程序中，为它们的发布做准备。
