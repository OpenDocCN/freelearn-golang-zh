- en: Securing Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护微服务
- en: Welcome to the third chapter in our journey to learn modern Go cloud programming.
    In this chapter, we will secure the restful API service that was authored in the
    preceding chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们学习现代Go云编程的第三章。在本章中，我们将保护前一章中编写的RESTful API服务。
- en: Before we start diving into the code we need to write, there are some key concepts
    that we have to cover in order to provide a decent knowledge foundation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入编写代码之前，我们需要涵盖一些关键概念，以便提供一个良好的知识基础。
- en: As we covered in the preceding chapter, web applications need to make use of
    HTTP (which is an application-level protocol) in order to communicate. HTTP by
    itself is not secure, which means that it sends data over plain text. Obviously,
    if we are trying to send credit card information or sensitive personal data, we
    would never want to send it as a clear text. Fortunately, HTTP communications
    can be secured via a protocol known as **TLS** (**Transport Layer Security**).
    The combination of HTTP and TLS is known as HTTPS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中所介绍的，Web应用程序需要使用HTTP（这是一个应用级协议）进行通信。HTTP本身不安全，这意味着它会以明文发送数据。显然，如果我们试图发送信用卡信息或敏感个人数据，我们绝对不希望以明文发送。幸运的是，HTTP通信可以通过一种称为**TLS**（**传输层安全**）的协议来保护。HTTP和TLS的组合被称为HTTPS。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The internal workings of HTTPS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS的内部工作原理
- en: Securing microservices in Go
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中保护微服务
- en: HTTPS
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS
- en: To practically understand HTTPS, we will need to first talk about the TLS protocol.
    TLS is a protocol that can be utilized to encrypt data communicated over a computer
    network. TLS relies on two types of cryptography algorithms to achieve its goals—**symmetric
    cryptography** and **public-key cryptography**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际理解HTTPS，我们首先需要讨论TLS协议。TLS是一种可用于加密计算机网络上通信数据的协议。TLS依赖于两种类型的加密算法来实现其目标——**对称加密**和**公钥加密**。
- en: Public-key cryptography is also known as asymmetrical cryptography. We will
    cover where the name came from shortly. On the other hand, symmetric cryptography
    can also be called symmetric-key algorithms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密也被称为非对称加密。我们很快会介绍这个名字的由来。另一方面，对称加密也可以称为对称密钥算法。
- en: Symmetric cryptography
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密
- en: The core idea of data encryption is the use of complex mathematical equations
    to encode (or cipher) data, which in effect will make this data unreadable to
    humans. In the world of secure software communication, the encrypted data can
    then be sent to the intended receiver, which will be expected to decrypt the data
    back to its original human-readable form.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加密的核心思想是使用复杂的数学方程对数据进行编码（或加密），从而使这些数据对人类来说变得不可读。在安全软件通信领域，加密数据可以被发送到预期的接收者，预期的接收者将对数据进行解密，使其恢复到原始的可读形式。
- en: In almost all cases, to encrypt a piece of data, you will need an **encryption
    key**. Encryption keys are simply a piece of the complex mathematical equations
    used to encode the data. In some encryption algorithms, you can use the same encryption
    key to decrypt your data back to its original form. In others, a **decryption
    key** that is different than the encryption key is needed to perform the decryption.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，要加密一段数据，你需要一个**加密密钥**。加密密钥只是用于对数据进行编码的复杂数学方程的一部分。在一些加密算法中，你可以使用相同的加密密钥将数据解密回其原始形式。在其他情况下，需要一个与加密密钥不同的**解密密钥**来执行解密。
- en: Symmetric cryptography or symmetric-key algorithms are the algorithms that make
    use of the same key to encrypt and decrypt the data, which is why they are called
    **symmetric**. The following diagram shows where an encryption key is utilized
    to encrypt the word **Hello** into an encoded form, then the same key is used
    with the encoded data to decrypt it back to the word **Hello**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密或对称密钥算法是使用相同密钥来加密和解密数据的算法，这就是为什么它们被称为**对称**。下图显示了加密密钥用于将单词**Hello**加密成编码形式，然后使用相同的密钥与编码数据一起将其解密回单词**Hello**。
- en: '![](img/64412289-eba5-4bf4-a5a4-6229a4aecf23.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64412289-eba5-4bf4-a5a4-6229a4aecf23.png)'
- en: Symmetric cryptography
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密
- en: Symmetric-key algorithms in HTTPS
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS中的对称密钥算法
- en: Now, let's return to the world of web applications and HTTP. In general, web
    applications are just different pieces of software that communicate using the
    HTTP protocol. As mentioned earlier in the chapter, to secure HTTP and transform
    it to HTTPS, we will combine it with another protocol called TLS. The TLS protocol
    makes use of symmetric-key algorithms to encrypt HTTP data between a client and
    a server. In other words, the web client and the web server start their communication
    by agreeing on a shared encryption key (some call it a shared secret), which is
    then used to protect the data going back and forth between them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到Web应用程序和HTTP的世界。一般来说，Web应用程序只是使用HTTP协议进行通信的不同软件片段。正如本章前面提到的，为了保护HTTP并将其转换为HTTPS，我们将其与另一个称为TLS的协议结合起来。TLS协议利用对称密钥算法来加密客户端和服务器之间的HTTP数据。换句话说，Web客户端和Web服务器通过协商一个共享的加密密钥（有些人称之为共享秘钥），然后使用它来保护它们之间来回传输的数据。
- en: The sender application uses the key to encrypt the data before sending it to
    the recipient application, which in turn utilizes a copy of the same key to decrypt
    this data. This process is the symmetric-key algorithm part of the TLS protocol.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 发送方应用程序使用密钥对数据进行加密，然后将其发送给接收方应用程序，接收方应用程序使用相同的密钥副本对数据进行解密。这个过程是TLS协议的对称密钥算法部分。
- en: '![](img/a41dc9a4-96d8-4b53-b608-2d6a864725ec.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a41dc9a4-96d8-4b53-b608-2d6a864725ec.png)'
- en: Symmetric-key algorithms in HTTPS
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS中的对称密钥算法
- en: This sounds all good and well, but how exactly would a web client and web server
    securely agree on the same encryption key before starting to use it to send encrypted
    data? Obviously, the web client can't just send the key in plain text to the web
    server and not expect the key to being captured by an unauthorized third party
    that can then simply decrypt any secure communication via the stolen key. The
    answer to that question as we mentioned earlier is that the TLS protocol relies
    on not one, but two types of cryptography algorithms to secure HTTP. The symmetric-key
    algorithms, which we have covered so far, are utilized to secure most of the communication;
    however, the public-key algorithms are used for the initial handshake. This is
    where the client and the server say hi and identify each other, then agree on
    an encryption key to use thereafter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来都很好，但是Web客户端和Web服务器如何确保在开始使用加密密钥发送加密数据之前，安全地达成对同一个加密密钥的共识呢？显然，Web客户端不能只是以明文形式将密钥发送给Web服务器，然后期望这个密钥不会被未经授权的第三方捕获，然后简单地解密通过被窃取的密钥进行的任何安全通信。我们之前提到的答案是TLS协议依赖于不只一个，而是两种类型的加密算法来保护HTTP。迄今为止，我们已经介绍了对称密钥算法，它们用于保护大部分通信；然而，公钥算法用于初始握手。这是客户端和服务器打招呼并相互识别，然后达成之后使用的加密密钥的地方。
- en: Asymmetric cryptography
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Unlike symmetric-key algorithms, asymmetric cryptography or public-key algorithms
    that utilize two keys for protection of data. One key to encrypt the data is known
    as the public key, and it can be shared safely with other parties. Another key
    to decrypt the data is known as the private key, and it must not be shared.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称密钥算法不同，非对称加密或公钥算法利用两个密钥来保护数据。用于加密数据的一个密钥称为公钥，可以安全地与其他方分享。用于解密数据的另一个密钥称为私钥，不得分享。
- en: The public key can be used by any person to encrypt data. However, only the
    person with the private key that corresponds to the public key can decrypt the
    data back to its original human-readable form. The public and private keys are
    generated using complex computational algorithms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥可以被任何人用来加密数据。然而，只有拥有与公钥对应的私钥的人才能将数据解密回其原始的可读形式。公钥和私钥是使用复杂的计算算法生成的。
- en: In a typical scenario, a person who owns a pair of public and private keys would
    share the public key with other people that they want to communicate with. The
    other people would then use the public key to encrypt the data being sent to the
    key owner. The key owner, in turn, can use their private key to decrypt this data
    back to its original content.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的情况下，拥有一对公私钥的人会与他们想要通信的其他人分享公钥。其他人随后会使用公钥来加密发送给密钥所有者的数据。密钥所有者反过来可以使用他们的私钥来将这些数据解密回其原始内容。
- en: Consider a good example—courtesy of Wikipedia—that showcases the idea. Let's
    say Alice want to communicate with her friends securely over the internet. For
    that, she uses an application that generates a pair of public-private keys.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个很好的例子——维基百科提供的——展示了这个想法。假设Alice想要通过互联网与她的朋友安全地进行通信。为此，她使用一个生成一对公私钥的应用程序。
- en: '![](img/222b0883-4987-4d8f-b015-c5528b6fa682.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/222b0883-4987-4d8f-b015-c5528b6fa682.png)'
- en: Alice's public-private key
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Alice的公私钥
- en: Now, a friend of Alice called Bob would like to send her a secure message over
    the internet. The message is simply **Hello Alice!** Alice first needs to send
    Bob a copy of her public key so that Bob can use it to encrypt his message before
    sending it to Alice. Then, when Alice receives the message, she can use her private
    key, which is not shared with anyone, to decrypt the message back to the human-readable
    text and see that Bob said hello.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Alice的一个名叫Bob的朋友想要通过互联网给她发送一条安全消息。消息只是**你好，Alice！** Alice首先需要向Bob发送她的公钥的副本，以便Bob可以使用它来加密他的消息然后发送给Alice。然后，当Alice收到消息时，她可以使用她的私钥（不与任何人分享）来将消息解密回可读的文本，看到Bob说了你好。
- en: '![](img/aaed743e-4890-4438-b629-2f12c677c270.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaed743e-4890-4438-b629-2f12c677c270.png)'
- en: Asymmetric cryptography between Alice and Bob
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Alice和Bob之间的非对称加密
- en: With this, you should have enough practical understanding of public-key algorithms.
    However, how is this utilized in the HTTPS protocol?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你应该对公钥算法有足够的实际理解了。然而，这在HTTPS协议中是如何利用的呢？
- en: Asymmetrical cryptography in HTTPS
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS中的非对称加密
- en: As mentioned earlier in this chapter, asymmetrical cryptography is utilized
    between a web client and web server to agree on a shared encryption key (also
    known as shared secret or session key) that is then used in symmetrical cryptography.
    In other words, the key is used by both the web client and web server to encrypt
    mutual HTTP communications. We have already covered the symmetrical cryptography
    part of this interaction, so now let's dive a bit deeper into how the asymmetrical
    cryptography part is carried out.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，Web客户端和Web服务器之间使用非对称加密来协商一个共享的加密密钥（也称为共享秘密或会话密钥），然后在对称加密中使用。换句话说，密钥被Web客户端和Web服务器同时使用来加密相互的HTTP通信。我们已经介绍了这种互动的对称加密部分，现在让我们深入一点了解非对称加密是如何进行的。
- en: A **handshake** occurs between the web client and web server, where the client
    indicates its intention to start a secure communication session to the server.
    Typically, this entails agreeing on some mathematical details on how the encryption
    occurs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Web客户端和Web服务器之间发生了一个**握手**，在这个握手中，客户端表示其意图向服务器开始一个安全的通信会话。通常，这涉及同意一些关于加密如何发生的数学细节。
- en: The server then replies with a **digital certificate**. If you are not familiar
    with the concept of digital certificates, then now is the time to shed some light
    on what it is. A digital certificate (or a public-key certificate) is an electronic
    document that proves the ownership of a public key. To understand the importance
    of digital certificates, let's take a couple of steps back to remember what a
    public key is.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器随后回复一个**数字证书**。如果您对数字证书的概念不熟悉，那么现在是时候阐明一下它是什么了。数字证书（或公钥证书）是一种证明公钥所有权的电子文档。为了理解数字证书的重要性，让我们退后几步，回想一下公钥是什么。
- en: As covered earlier, a public key is an encryption key used in asymmetric cryptography
    (or public-key algorithms); the key can only encrypt data but can never decrypt
    it back, and it can be shared with anyone who we wish to communicate with. The
    issuer of the public key always holds a corresponding key called the private key,
    which can decrypt the data encrypted by the public key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，公钥是用于非对称加密（或公钥算法）的加密密钥；该密钥只能加密数据，但永远无法解密数据，并且可以与我们希望进行通信的任何人共享。公钥的颁发者始终持有一个称为私钥的对应密钥，该私钥可以解密由公钥加密的数据。
- en: This sounds great, but what happens if a client requests a public key to communicate
    with a server, then a bad agent intercepts this request and replies with its own
    public key (this is known as a man-in-the-middle attack)? The client will then
    keep communicating with this bad agent thinking that it is the legitimate server;
    the client may then send sensitive information, such as credit card numbers or
    personal data, to the bad agent. Obviously, if we seek true protection and security,
    we want to avoid this scenario at all costs, hence comes the need for certificates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很棒，但是如果客户端请求与服务器通信的公钥，然后一个坏的代理拦截了这个请求，并回复了自己的公钥（这被称为中间人攻击）会发生什么？客户端将继续与这个坏的代理进行通信，认为它是合法的服务器；然后客户端可能会向坏的代理发送敏感信息，例如信用卡号或个人数据。显然，如果我们寻求真正的保护和安全，我们希望尽一切可能避免这种情况，因此需要证书。
- en: A digital certificate is a digital document that gets issued by a trusted third-party
    entity. The document contains a public encryption key, the server name that the
    key belongs to, and the name of the trusted third-party entity who verifies that
    the information is correct and that the public key belongs to the expected key
    owner (also called the issuer of the certificate). The trusted third-party entity
    who issues the certificate is known as a **CA** (**certificate authority**). There
    are multiple known CA who issue a certificate and verify identities for businesses
    and organizations. They typically charge a fee for their service. For larger organizations
    or government bodies, they issue their own certificates; this process is known
    as **self-signing**, and hence, their certificates are known as self-signed certificates.
    Certificates can have expiry dates by which the certificates will need to be renewed;
    this is for extra protection to protect in case the entity that owned the certificate
    in the past had changed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书是由受信任的第三方实体颁发的数字文档。该文档包含一个公共加密密钥，该密钥所属的服务器名称，以及验证信息正确性的受信任第三方实体的名称，以及公钥属于预期密钥所有者（也称为证书颁发者）的名称。颁发证书的受信任第三方实体被称为**CA**（**证书颁发机构**）。有多个已知的CA颁发证书并验证企业和组织的身份。他们通常会收取一定的费用。对于较大的组织或政府机构，他们会颁发自己的证书；这个过程被称为**自签名**，因此他们的证书被称为自签名证书。证书可以有到期日期，到期后需要进行更新；这是为了在过去拥有证书的实体发生变化时提供额外的保护。
- en: A web client typically contains a list of certificate authorities that it knows
    of. So, when the client attempts to connect to a web server, the web server responds
    with a digital certificate. The web client looks for the issuer of the certificate
    and compares the issuer with the list of certificate authorities that it knows.
    If the web client knows and trusts the certificate issuer, then it will continue
    with the connection to that server and make use of the public key in the certificate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Web客户端通常包含其所知的证书颁发机构列表。因此，当客户端尝试连接到Web服务器时，Web服务器会回复一个数字证书。Web客户端查找证书的颁发者，并将颁发者与其所知的证书颁发机构列表进行比较。如果Web客户端知道并信任证书颁发者，那么它将继续连接到该服务器，并使用证书中的公钥。
- en: The public key obtained from the server will then be used to encrypt communications
    in order to securely negotiate a shared encryption key (or session key or shared
    secret) to then be used in symmetrical cryptography communications between the
    web client and web server. There is a number of algorithms that can be used to
    generate this session key, but they are beyond the scope of this chapter. What
    we need to know is that once a session key is agreed on, the initial handshake
    between the web client and web server will conclude, allowing the actual communication
    session to proceed securely under the protection of the shared session key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器获取的公钥将用于加密通信，以安全地协商共享加密密钥（或会话密钥或共享密钥），然后在Web客户端和Web服务器之间的对称加密通信中使用。有许多算法可以用来生成会话密钥，但这超出了本章的范围。我们需要知道的是，一旦会话密钥达成一致，Web客户端和Web服务器之间的初始握手将结束，允许实际的通信会话在共享会话密钥的保护下安全进行。
- en: With this, we now have sufficient practical understanding of how web communications
    are secured. This is used for secure Restful web APIs and secure web page loads.
    One more important remark to add is that the URL utilized for secure web communications
    starts with `https://` instead of `http://`. This is obvious because secure web
    communications utilize HTTPS instead of just HTTP.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在对Web通信如何得到保护有了足够的实际理解。这用于安全的Restful Web API和安全的Web页面加载。要补充的另一个重要说明是，用于安全Web通信的URL以`https://`开头，而不是`http://`。这是显而易见的，因为安全的Web通信使用HTTPS，而不仅仅是HTTP。
- en: Secure web services in Go
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的安全Web服务
- en: Now it's time to find out how to write secure web services in the Go language.
    Fortunately, Go was built from the grounds up with modern software architectures
    in mind, which includes secure web applications. Go comes with a powerful standard
    library that allows a smooth transition from HTTP servers to HTTPS servers. Before
    we start looking into the code, let's answer the simple question of how to obtain
    a digital certificate to use in our web server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候找出如何在Go语言中编写安全的Web服务了。幸运的是，Go是从头开始构建的，考虑到了现代软件架构，包括安全的Web应用程序。Go配备了一个强大的标准库，允许从HTTP服务器平稳过渡到HTTPS服务器。在我们开始查看代码之前，让我们先回答一个简单的问题，即如何获取数字证书以在我们的Web服务器中使用。
- en: Obtaining a certificate
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取证书
- en: The default method to obtain a digital certificate for your organization, start-up,
    or website is to buy the service of verifying your identity and issuing a certificate
    from a certificate authority provider. As we mentioned earlier, there are multiple
    certificate authority providers. A list of the most popular providers can be found
    in Wikipedia at: [https://en.wikipedia.org/wiki/Certificate_authority#Providers](https://en.wikipedia.org/wiki/Certificate_authority#Providers)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数字证书的默认方法是购买验证您的身份并从证书颁发机构提供者那里颁发证书的服务。正如我们之前提到的，有多个证书颁发机构提供者。可以在维基百科上找到最受欢迎的提供者列表：[https://en.wikipedia.org/wiki/Certificate_authority#Providers](https://en.wikipedia.org/wiki/Certificate_authority#Providers)
- en: There are also certificate authorities who provide the service for free. For
    example, in 2016, the **Mozilla Foundation** along with the **Electronic Frontier
    Foundation** and the **University of Michigan** collaborated to found a certificate
    authority called *Let's Encrypt*, which can be found at: [https://letsencrypt.org/](https://letsencrypt.org/).
    *Let's Encrypt* is a free service that performs the validation, signing, and issuing
    of certificates in an automated fashion.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些提供免费服务的证书颁发机构。例如，在2016年，**Mozilla基金会**与**电子前沿基金会**和**密歇根大学**合作成立了一个名为*Let's
    Encrypt*的证书颁发机构，网址为：[https://letsencrypt.org/](https://letsencrypt.org/)。*Let's
    Encrypt*是一个免费服务，以自动化方式执行验证、签名和颁发证书。
- en: That sounds great. However, what if we just want to test some local web application
    such as the event's microservice we built in the preceding chapter? In this case,
    we will need a more straightforward way to generate certificates that we can work
    and test with. Then, after that, when we deploy to production, we can use a trusted
    certificate authority to issue certificates for us that will be respected by web
    browsers and clients connected to the internet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很不错。但是，如果我们只想测试一些本地Web应用程序，比如我们在前一章中构建的事件微服务，该怎么办？在这种情况下，我们需要一种更直接的方法来生成我们可以使用和测试的证书。然后，在部署到生产环境后，我们可以使用受信任的证书颁发机构为我们颁发证书，这些证书将受到Web浏览器和连接到互联网的客户端的尊重。
- en: The straightforward approach to generating certificates for our testing, in
    this case, would be to manually create our own certificates and self-sign them.
    The advantage of this is that we can generate numerous certificates to use in
    our internal testing without getting through a verification process. The disadvantage,
    however, is the fact that any third-party web clients, such as web browsers, that
    would try to connect to our web applications via our self-signed certificates
    would not identify the issuer of those certificates and hence will generate a
    lot of warnings before allowing us to proceed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 生成我们测试的证书的直接方法是手动创建我们自己的证书并进行自签名。这样做的优点是我们可以生成大量证书用于内部测试，而无需经过验证过程。然而，缺点是任何第三方网络客户端，如Web浏览器，尝试通过我们的自签名证书连接到我们的Web应用程序时，将无法识别这些证书的发行者，因此在允许我们继续之前会产生大量警告。
- en: 'To generate our newly minted self-signed digital certificates, we will need
    to use specialized tools that understand the algorithms enough to create the necessary
    outputs. Remember that in order to initiate an HTTPS session, we need the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们新鲜出炉的自签名数字证书，我们需要使用了解算法足够的专门工具来创建必要的输出。请记住，为了启动HTTPS会话，我们需要以下内容：
- en: 'A digital certificate which will contain the following:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含以下内容的数字证书：
- en: A public key that can be shared with other parties.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以与其他方共享的公钥。
- en: The server name or domain name who owns the certificate.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有证书的服务器名称或域名。
- en: The issuer of the certificate. In case of a self-signed certificate, the issuer
    would just be us. In case of a certificate issued by a trusted certificate authority,
    the issuer will be the CA.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的发行者。在自签名证书的情况下，发行者只是我们自己。在由受信任的证书颁发机构颁发的证书的情况下，发行者将是CA。
- en: A private key that we need to keep a secret and not share with anyone
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要保密并不与任何人分享的私钥
- en: OpenSSL
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSL
- en: 'One of such specialized tools that can generate a TLS digital certificate and
    is very popular is called **OpenSSL**. OpenSSL can be found at: [https://www.openssl.org/](https://www.openssl.org/).
    OpenSSL is an open source commercial grade TLS toolkit that can be used to perform
    a variety of tasks; among them is to generate self-signed digital certificates.
    The OpenSSL organization by itself does not provide prebuilt binaries for the
    tool. However, there is a wiki page that lists third-party places where a binary
    can be downloaded for the tool. The wiki page can be found at: [https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries).
    Once you have the tool downloaded, here is an example of how to make use of it
    to generate a digital certificate in addition to its private key:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以生成TLS数字证书的一种专门工具是非常流行的**OpenSSL**。OpenSSL可以在以下网址找到：[https://www.openssl.org/](https://www.openssl.org/)。OpenSSL是一个开源商业级TLS工具包，可用于执行各种任务；其中之一就是生成自签名数字证书。OpenSSL组织本身并不提供该工具的预构建二进制文件。但是，有一个维基页面列出了可以下载该工具的第三方位置。维基页面可以在以下网址找到：[https://wiki.openssl.org/index.php/Binaries](https://wiki.openssl.org/index.php/Binaries)。一旦您下载了该工具，以下是如何使用它生成数字证书及其私钥的示例：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first word in the preceding code is obviously the name of the binary. Let''s
    cover the arguments one by one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个单词显然是二进制文件的名称。让我们逐个讨论这些参数：
- en: '`req`: Stands for the request; it indicates that we request a certificate.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`req`：表示请求；它表示我们请求一个证书。'
- en: '`-x509`: This will indicate that we want to output a self-signed certificate.
    In the world of cryptography, the notion `X.509` is a standard that defines the
    format of public key certificates. Digital certificates used in many internet
    protocols utilize this standard.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -x509：这将表明我们要输出一个自签名证书。在密码学世界中，“X.509”是一个定义公钥证书格式的标准。许多互联网协议中使用的数字证书都使用了这个标准。
- en: '`-newkey`: This option indicates that we would like a new certificate with
    a paired private key. As mentioned before, a certificate is nothing but a public
    key combined with a bunch of identifiers. So, to perform asymmetric cryptography,
    we will need a private key paired with this public key.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-newkey`：此选项表示我们希望一个新的带有配对私钥的证书。如前所述，证书只是一个公钥与一堆标识符的组合。因此，为了执行非对称加密，我们需要一个与这个公钥配对的私钥。'
- en: '`rsa:2048`: This is an argument to the `-newkey` option, indicating the type
    of encryption algorithm that we would like to use for generating the key.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rsa:2048`：这是`-newkey`选项的参数，表示我们希望使用的加密算法类型来生成密钥。'
- en: '`-keyout`: This option provides the filename to write the newly created private
    key to.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-keyout`：此选项提供要将新创建的私钥写入的文件名。'
- en: '`key.pem`: This is the argument to the `-keyout` option. It indicates that
    we would like the private key to be stored in a file called `key.pem`. This key
    needs to be kept private and not shared with anyone, as mentioned earlier.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key.pem`：这是`-keyout`选项的参数。它表示我们希望将私钥存储在一个名为`key.pem`的文件中。正如前面提到的，这个密钥需要保持私密，不与任何人分享。'
- en: '`-out`: This option provides the filename to write the newly created self-signed
    certificate to.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-out`：此选项提供要将新创建的自签名证书写入的文件名。'
- en: '`cert.pem`: This is the argument to the `-out` option; it indicates that we
    would like to save the certificate in a file called `cert.pem`. This certificate
    can then be shared with web clients attempting to communicate securely with our
    web server in order to invoke HTTPS.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cert.pem`：这是`-out`选项的参数；它表示我们希望将证书保存在一个名为`cert.pem`的文件中。然后，这个证书可以与试图通过HTTPS与我们的网站安全通信的Web客户端共享。'
- en: '`-days`: The number of days that the certificate should be valid for.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-days`：证书有效期的天数。'
- en: '`365`: This is the argument for the `-days` option. It is simply us saying
    that we would like the certificate to be valid for 365 days, or simply one year.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 365：这是“-days”选项的参数。这只是我们说我们希望证书有效期为365天，或者简单地说是一年。
- en: generate_cert.go
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: generate_cert.go
- en: 'In the world of the Go language, there is another approach besides OpenSSL
    to generate self-signed certificates to utilize in our testing. If you go to the
    `GOROOT` folder, which is where the Go language is installed and then head to
    the `/src/crypto/tls` folder, you will find a file called `generate_cert.go`.
    This file is nothing but a simple tool that can easily and efficiently generate
    certificates for our testing pleasure. In my computer, the `GOROOT` folder is
    located at `C:\Go`. The following is a screenshot of the `generate_cert.go` file
    on my machine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言的世界中，除了OpenSSL之外，还有另一种方法可以生成用于测试的自签名证书。如果您转到`GOROOT`文件夹，这是Go语言安装的位置，然后转到`/src/crypto/tls`文件夹，您会发现一个名为`generate_cert.go`的文件。这个文件只是一个简单的工具，可以轻松高效地为我们生成证书。在我的计算机上，`GOROOT`文件夹位于`C:\Go`。以下是我机器上`generate_cert.go`文件的截图：
- en: '![](img/e9aa3dd4-46e3-46c9-88f7-28e13a51d22d.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9aa3dd4-46e3-46c9-88f7-28e13a51d22d.png)'
- en: generate_cert.go file
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: generate_cert.go文件
- en: 'The `generate_cert.go` is a self-contained Go program that can run simply via
    the `go run` command. Once you run it, it will create a certificate and private
    key files for you and place them in your current folder. The tool supports a number
    of arguments, but typically the most commonly used argument is `--host`, which
    indicates the name of the web server that we would like to generate the certificate
    and the key for. The following is how we would run the tool via the `go run` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_cert.go`是一个独立的Go程序，可以通过`go run`命令简单运行。运行后，它将为您创建证书和私钥文件，并将它们放在当前文件夹中。该工具支持许多参数，但通常最常用的参数是`--host`，它表示我们要为哪个网站生成证书和密钥。以下是我们如何通过`go
    run`命令运行该工具的方式：'
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command was executed on the Windows operating system, which is
    why it represents the `GOROOT` environmental path variable as `%GOROOT%`. How
    the environmental variable is represented differs from one operating system to
    another. In the case of Linux, for example, the environmental variable would be
    represented as `$GOROOT`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令是在Windows操作系统上执行的，这就是为什么它将`GOROOT`环境路径变量表示为`%GOROOT%`。环境变量的表示方式因操作系统而异。例如，在Linux的情况下，环境变量将表示为`$GOROOT`。
- en: 'We will now instruct the command to build a certificate and a private key for
    a server called `localhost`. The command will generate the certificate and the
    key for us, then place them in the current folder, as mentioned earlier. Here
    is a screenshot showing a successful execution of the command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将指示命令为名为`localhost`的服务器构建证书和私钥。该命令将为我们生成证书和密钥，然后将它们放在当前文件夹中，如前所述。以下是显示命令成功执行的屏幕截图：
- en: '![](img/3d8b88d7-f667-43bf-85e7-f1fac5b17ad6.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d8b88d7-f667-43bf-85e7-f1fac5b17ad6.png)'
- en: generate_cert.go command
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: generate_cert.go命令
- en: 'The `generate_cert` tool supports other options besides `--host`. It is worth
    it to cover some of them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_cert`工具支持`--host`之外的其他选项。值得覆盖其中一些：'
- en: '`--start-date`: This option indicates the start validation date of the certificate.
    The argument to this option needs to be formatted as Jan 1 15:04:05 2011, for
    example.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --start-date：此选项表示证书的开始验证日期。此选项的参数需要格式化为2011年1月1日15:04:05，例如。
- en: '`--duration`: This option indicates the duration that the certificate is valid
    for in hours. The default value is a year.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--duration`：此选项表示证书有效期限，以小时为单位。默认值为一年。'
- en: '`--rsa-bits`: This option indicates the number of bits to be utilized in the
    rsa encryption of the keys. The default value is 2,048.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rsa-bits`：此选项表示在密钥的RSA加密中要使用的位数。默认值为2,048。'
- en: '`--help`: This provides a list of supported options with their descriptions.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--help`：这提供了支持的选项列表及其描述。'
- en: Once the certificate and key files are generated, we can obtain and use them
    in our web server application in order to support HTTPS. We'll see how to do just
    that in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成证书和密钥文件后，我们可以在我们的Web服务器应用程序中获取并使用它们，以支持HTTPS。我们将在下一节中看到如何做到这一点。
- en: Building an HTTPS server in Go
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中构建HTTPS服务器
- en: 'It''s finally time to dig into some code. Since Go is very well-suited for
    building modern web software, writing an HTTPS web server is easy. Let''s begin
    by reviewing the piece of code we wrote in the preceding chapter to establish
    an HTTP web server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在终于是时候深入一些代码了。由于Go非常适合构建现代Web软件，编写HTTPS Web服务器非常容易。让我们从回顾我们在上一章中编写的代码片段开始，以建立一个HTTP
    Web服务器：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It was a single line of code, a function called `ListenAndServe()`, which belongs
    to the HTTP Go package in the standard library. The first argument to `ListenAndServe()`
    was the endpoint to which we would like our web server to listen to. So, for example,
    if we would like our web server to listen to local port 8181, the endpoint would
    be `:8181` or `localhost:8181`. The second argument is the object that describes
    the HTTP routes and their handlers—this object was created by the Gorilla `mux`
    package. The code to create it from the preceding chapter is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行代码，一个名为`ListenAndServe()`的函数，它属于标准库中的HTTP Go包。`ListenAndServe()`的第一个参数是我们希望我们的Web服务器监听的端点。因此，例如，如果我们希望我们的Web服务器监听本地端口8181，端点将是`:8181`或`localhost:8181`。第二个参数是描述HTTP路由及其处理程序的对象——这个对象是由Gorilla
    `mux`包创建的。从上一章中创建它的代码如下：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To convert the web server from the preceding chapter from HTTP to HTTPS, we
    will need to perform one simple change—instead of calling the `http.ListenAndServer()`
    function, we''ll utilize instead another function called `http.ListenAndServeTLS()`.
    The code will look as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将上一章的Web服务器从HTTP转换为HTTPS，我们只需要进行一个简单的更改——而不是调用`http.ListenAndServer()`函数，我们将使用另一个名为`http.ListenAndServeTLS()`的函数。代码将如下所示：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As shown in the preceding code, the `http.ListenAndServeTLS()` function takes
    more arguments than the `original http.ListenAndServe()` function. The extra arguments
    are the second and third arguments. They are simply the digital certificate filename
    and the private key filename. The first argument is still the web server listening
    endpoint, whereas the last argument is still the handler object (which, in our
    case, is a Gorilla `*Router` object). We have already generated the certificate
    and private key files from the preceding step, so all we need to do here is to
    ensure that the second and third arguments point to the correct files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述代码所示，`http.ListenAndServeTLS()`函数比`原始http.ListenAndServe()`函数接受更多的参数。额外的参数是第二个和第三个参数。它们只是数字证书文件名和私钥文件名。第一个参数仍然是Web服务器监听端点，而最后一个参数仍然是处理程序对象（在我们的情况下是Gorilla
    `*Router`对象）。我们已经从上一步生成了证书和私钥文件，所以我们在这里需要做的就是确保第二个和第三个参数指向正确的文件。
- en: That's it. This is all what we need to do in order to create an HTTPS web server
    in Go; the Go HTTP standard package will then take the certificate and private
    key and utilize them as required by the TLS protocol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这就是我们需要做的一切，以便在Go中创建一个HTTPS Web服务器；Go HTTP标准包将接收证书和私钥，并根据TLS协议的要求使用它们。
- en: 'However, what if we would like to support both HTTP and HTTPS in our microservice?
    For this, we will need to get a little creative. The first logical step would
    be to run both the `http.ListenAndServe()` and the `http.ListenAndServeTLS()`
    functions in our code, but then we come across an obvious challenge: how would
    both functions listen on the same local port? We simply solve this by picking
    a listening port for HTTPS that is different than the listening port of HTTP.
    In the preceding chapter, we used a variable called **endpoint** to hold the value
    of the local HTTP server listening address. For HTTPS, let''s assume that the
    local listening address is stored in a variable called `tlsendpoint`. With this,
    the code will look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要在我们的微服务中同时支持HTTP和HTTPS怎么办？为此，我们需要有点创意。第一个逻辑步骤将是在我们的代码中运行`http.ListenAndServe()`和`http.ListenAndServeTLS()`函数，但是我们遇到了一个明显的挑战：这两个函数如何在同一个本地端口上监听？我们可以通过选择一个与HTTP监听端口不同的端口来解决这个问题。在前面的章节中，我们使用了一个名为**endpoint**的变量来保存本地HTTP服务器的监听地址。对于HTTPS，让我们假设本地监听地址存储在一个名为`tlsendpoint`的变量中。有了这个，代码将如下所示：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That sounds great, but now we are faced with another hurdle, both of `http.ListenAndServeTLS()` and
    the `http.ListenAndServe()` are blocking functions. This means that whenever we
    call them, they block the current goroutine indefinitely until an error occurs.
    This means that we can't call both functions on the same goroutine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很棒，但现在我们面临另一个障碍，`http.ListenAndServeTLS()`和`http.ListenAndServe()`都是阻塞函数。这意味着每当我们调用它们时，它们会无限期地阻塞当前的goroutine，直到发生错误。这意味着我们不能在同一个goroutine上调用这两个函数。
- en: A goroutine is a vital language component in Go. It can be considered as a lightweight
    thread. Go developers make use of goroutines everywhere to achieve efficient concurrency.
    To communicate information between multiple goroutines, we use another Go language
    components called Go channels.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: goroutine是Go语言中的一个重要语言组件。它可以被视为轻量级线程。Go开发人员在各处都使用goroutines来实现高效的并发。为了在多个goroutines之间传递信息，我们使用另一个Go语言组件，称为Go通道。
- en: 'So, the solution for this is simple. We call one of the functions in a different
    goroutine. This can be simply achieved by placing the word go before the function
    name. Let''s run the `http.ListenAndServe()` function in a different goroutine.
    Here is what the code would look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个问题的解决方案很简单。我们在不同的goroutine中调用其中一个函数。这可以通过在函数名之前加上go这个词来简单实现。让我们在一个不同的goroutine中运行`http.ListenAndServe()`函数。代码将如下所示：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Perfect! With this, our web server can function as an HTTP server for clients
    who would like to use HTTP or an HTTPS server for clients who prefer to use HTTPS.
    Now, let''s address another question: both of the `http.ListenAndServe()` and
    the `http.ListenAndServeTLS()` functions return error objects to report any issues
    in case of failure; so, can we capture errors produced from either function in
    case of failure, even though they run on different goroutines? For this, we''ll
    need to make use of Go channels, which is the Go idiomatic way to communicate
    between two goroutines. Here is how the code will look like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！有了这个，我们的Web服务器可以作为HTTP服务器为希望使用HTTP的客户端，或者作为HTTPS服务器为希望使用HTTPS的客户端。现在，让我们解决另一个问题：`http.ListenAndServe()`和`http.ListenAndServeTLS()`函数都会返回错误对象来报告任何失败的问题；那么，即使它们在不同的goroutines上运行，我们是否可以捕获任一函数产生的错误？为此，我们需要使用Go通道，这是Go语言中两个goroutines之间通信的惯用方式。代码将如下所示：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we create two Go channels, one called `httpErrChan` and
    the other one called `httptlsErrChan`. The channels will hold an object of type
    error. One of the channels will report errors observed from the `http.ListenAndServe()`
    function, whereas the other will report errors returned from the `http.ListenAndServeTLS()`
    function. We then use two goroutines with anonymous functions in order to run
    the two `ListenAndServe` functions and push their results into the corresponding
    channels. We use anonymous functions here because our code entails more than just
    calling the `http.ListenAndServe()` or the `http.ListenAndServeTLS()` functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了两个Go通道，一个叫做`httpErrChan`，另一个叫做`httptlsErrChan`。这些通道将保存一个错误类型的对象。其中一个通道将报告`http.ListenAndServe()`函数观察到的错误，而另一个将报告`http.ListenAndServeTLS()`函数返回的错误。然后，我们使用两个带有匿名函数的goroutines来运行这两个`ListenAndServe`函数，并将它们的结果推送到相应的通道中。我们在这里使用匿名函数，因为我们的代码不仅仅涉及调用`http.ListenAndServe()`或`http.ListenAndServeTLS()`函数。
- en: You may note that we now run both of the `ListenAndServe` functions in goroutines
    instead of just one. The reason we do that is to prevent either of them from blocking
    the code, which will allow us to return both of the `httpErrChan` and the `httptlsErrChan`
    channels to the caller code. The caller code, which is the main function in our
    case, can then handle the errors as it pleases if any errors occur.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们现在在两个`ListenAndServe`函数中都使用了goroutines，而不仅仅是一个。我们这样做的原因是为了防止它们中的任何一个阻塞代码，这将允许我们将`httpErrChan`和`httptlsErrChan`通道都返回给调用者代码。调用者代码，也就是我们的主函数，在任何错误发生时可以自行处理这些错误。
- en: 'In the preceding chapter, we placed this code in a function called `ServeAPI()`;
    let''s now look at the completed code of this function after our changes:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们将这段代码放在一个名为`ServeAPI()`的函数中；现在让我们来看一下在我们的更改之后这个函数的完整代码：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function now takes a new string argument called `tlsendpoint`, which will
    hold the HTTPS server listening address. The function will also return two error
    channels. The function code then proceeds to define the HTTP routes that our REST
    API supports. From there, it will create the error channels we discussed, call
    the HTTP package `ListenAndServe` functions in two separate goroutines, and return
    the error channels. The next logical step for us is to cover the code that will
    call the `ServeAPI()` function and see how it handles the error channels.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数现在接受一个名为`tlsendpoint`的新字符串参数，它将保存HTTPS服务器的监听地址。该函数还将返回两个错误通道。然后，函数代码继续定义我们的REST
    API支持的HTTP路由。然后，它将创建我们讨论过的错误通道，调用两个单独的goroutine中的HTTP包`ListenAndServe`函数，并返回错误通道。我们下一个逻辑步骤是覆盖调用`ServeAPI（）`函数的代码，并查看它如何处理错误通道。
- en: 'As discussed earlier, our main function is what calls the `ServeAPI()` function,
    so this will put the burden of handling the returned error channels on the main
    function as well. Here is what the code in the main function will look like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，我们的主函数是调用`ServeAPI（）`函数的，因此这也将使主函数承担处理返回的错误通道的负担。主函数中的代码将如下所示：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code will call the `ServeAPI()` function, which will then capture the two
    returned error channels into two variables. We will then use the power of the
    Go's `select` statement to handle those channels. A `select` statement in Go can
    block the current goroutine to wait for multiple channels; whatever channel returns
    first will invoke the `select` case that corresponds to it. In other words, if
    `httpErrChan` returns, the first case will be invoked, which will print a statement
    in the standard output reporting that an HTTP error occurred with the error found.
    Otherwise, the second case will be invoked. Blocking the main goroutine is important,
    because if we don't block it then the program will just exit, which is something
    we don't want happening if there are no failures. In the past, the `http.ListenAndServe()`
    function used to block our main goroutine and prevent our program from exiting
    if no errors occurred. However, since we now have run both of the `ListenAndServe`
    functions on separate goroutines, we needed another mechanism to ensure that our
    program does not exit unless we want it to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将调用`ServeAPI（）`函数，然后将两个返回的错误通道捕获到两个变量中。然后我们将使用Go的`select`语句的功能来处理这些通道。在Go中，`select`语句可以阻塞当前goroutine以等待多个通道；无论哪个通道首先返回，都将调用与之对应的`select`
    case。换句话说，如果`httpErrChan`返回，将调用第一个case，它将在标准输出中打印一条报告发生HTTP错误的语句，并显示错误。否则，将调用第二个case。阻塞主goroutine很重要，因为如果我们不阻塞它，程序将会退出，这是我们不希望发生的事情，如果没有失败的话。过去，`http.ListenAndServe（）`函数通常会阻塞我们的主goroutine，并防止我们的程序在没有错误发生时退出。但是，由于我们现在已经在两个单独的goroutine上运行了`ListenAndServe`函数，我们需要另一种机制来确保我们的程序不会退出，除非我们希望它退出。
- en: In general, whenever you try to receive a value from a channel or send a value
    to a channel, the goroutine will be blocked till a value is passed. This means
    that if no errors are returned from the `ListenAndServe` functions, then no value
    will pass through the channels, which will block the main goroutine till an error
    happens.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每当您尝试从通道接收值或向通道发送值时，goroutine都会被阻塞，直到传递一个值。这意味着如果`ListenAndServe`函数没有返回任何错误，那么值将不会通过通道传递，这将阻塞主goroutine直到发生错误。
- en: There is another type of channels in Go beside regular channels called buffered
    channels, which can allow you to pass values without blocking your current goroutine.
    However, in our case here, we use regular channels.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规通道之外，Go还有一种称为缓冲通道的通道类型，它可以允许您在不阻塞当前goroutine的情况下传递值。但是，在我们的情况下，我们使用常规通道。
- en: 'The last piece of code we need to cover here is to update the configuration.
    Remember—in the previous chapter—that we used a configuration object in order
    to process configuration information for our microservice. The configuration information
    entailed database addresses, HTTP endpoints, and so on. Since we now also need
    an HTTPS endpoint, we need to add it to the configuration. The configuration code
    existed in the `./lib/configuration.go` file. Here is what it should now look
    like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里覆盖的最后一段代码是更新配置。请记住，在上一章中，我们使用配置对象来处理微服务的配置信息。配置信息包括数据库地址、HTTP端点等。由于我们现在还需要一个HTTPS端点，因此我们需要将其添加到配置中。配置代码存在于`./lib/configuration.go`文件中。现在它应该是这样的：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, we did three main things from the last chapter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们从上一章做了三件主要的事情：
- en: We added a constant called `RestfulTLSEPDefault`, which will default to `localhost:9191`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`RestfulTLSEPDefault`的常量，它将默认为`localhost:9191`。
- en: We added a new field to the `ServiceConfig` struct. The field is called `RestfulTLSEndPint`;
    it will be expected to correspond to a JSON field called `restfulapi-tlsendpoint`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向`ServiceConfig`结构添加了一个新字段。该字段称为`RestfulTLSEndPint`；它将期望对应于名为`restfulapi-tlsendpoint`的JSON字段。
- en: In the `ExtractConfiguration()` function, we set the default value of the `RestfulTLSEndPint`
    field of the initialized `ServiceConfig` struct object to `RestfulTLSEPDefault`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ExtractConfiguration（）`函数中，我们将初始化的`ServiceConfig`结构对象的`RestfulTLSEndPint`字段的默认值设置为`RestfulTLSEPDefault`。
- en: With those three changes, our configuration layer will be able to read the HTTPS
    endpoint value from a configuration JSON file if a configuration override exists.
    If either no configuration file exists, or no `restfulapi-tlsendpoint` JSON field
    is set in the configuration file, then we will take the default value, which is
    `localhost:9191`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个更改，我们的配置层将能够从配置JSON文件中读取HTTPS端点值，如果存在配置覆盖。如果不存在配置文件，或者配置文件中没有设置`restfulapi-tlsendpoint`
    JSON字段，则我们将采用默认值，即`localhost:9191`。
- en: Any code that will call the `ExtractConfiguration()` function will get access
    to this functionality and be able to obtain either a default or a configured value
    for the HTTPS endpoint. In our code, the main function will call the `ExtractConfiguration()`
    function and will obtain the necessary information to call the `ServeAPI()` function,
    which will run our RESTful API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 任何调用`ExtractConfiguration()`函数的代码都将获得对这个功能的访问权限，并能够获取HTTPS端点的默认值或配置值。在我们的代码中，主函数将调用`ExtractConfiguration()`函数，并获取调用`ServeAPI()`函数所需的信息，该函数将运行我们的RESTful
    API。
- en: Perfect! With this last piece, we conclude our chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！有了这最后一部分，我们结束了本章。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a deep dive into the world of secure web software and
    how it works internally. We explored HTTPS, symmetric and asymmetric cryptography,
    and how to secure web services in the Go language.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了安全的Web软件世界以及其内部工作原理。我们探讨了HTTPS、对称和非对称加密，以及如何在Go语言中保护Web服务。
- en: 'In the next chapter, we will cover a key topic in the world of distributed
    microservices architectures: message queues.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖分布式微服务架构世界中的一个关键主题：消息队列。
