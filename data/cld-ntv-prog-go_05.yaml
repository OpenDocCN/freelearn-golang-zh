- en: Building a Frontend with React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React构建前端
- en: In the previous chapters, you have built multiple microservices with Go and
    integrated them using both REST web services and asynchronous message queues.
    However, even the most scalable cloud application is only half as useful without
    an interface that your users can easily interact with (unless, of course, offering
    a REST API to your users is your actual product). In order to make the APIs built
    in the previous chapters more tangible, we will now add a web-based frontend to
    our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您已经使用Go构建了多个微服务，并使用REST Web服务和异步消息队列进行了集成。然而，即使是最可扩展的云应用程序，如果没有用户可以轻松交互的界面，也只有一半的用处（除非，当然，向用户提供REST
    API是您的实际产品）。为了使前几章中构建的API更具体，我们现在将为我们的应用程序添加一个基于Web的前端。
- en: For this, we will leave the world of Go programming for a while and take a short
    side trip to the JavaScript programming world. More precisely, we will take a
    look at the React framework and will use it to build a frontend application for
    the (now almost complete) MyEvents backend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将离开Go编程世界一段时间，并短暂地转向JavaScript编程世界。更确切地说，我们将看一下React框架，并将其用于为（现在几乎完成的）MyEvents后端构建前端应用程序。
- en: While building the frontend application, we will also get in touch with many
    components of the incredibly diverse JavaScript ecosystem. For example, we will
    work with the TypeScript compiler in order to be able to program in a type-safe
    way. Also, we will use the Webpack module bundler to easily deploy our JavaScript
    application for easy consumption in all modern web browsers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建前端应用程序时，我们还将接触到JavaScript生态系统中许多组件。例如，我们将使用TypeScript编译器以便以类型安全的方式进行编程。此外，我们将使用Webpack模块打包程序，以便轻松部署我们的JavaScript应用程序，以便在所有现代Web浏览器中轻松使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up a Node.js/TypeScript/React development environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Node.js/TypeScript/React开发环境
- en: Bootstrapping a new project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个新项目
- en: React components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React组件
- en: The Webpack module bundler
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack模块打包程序
- en: Building a React application with a RESTful backend
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RESTful后端构建React应用程序
- en: Getting started with React
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用React
- en: For this chapter, we will take a short step outside of the Go ecosystem. For
    working with React, you will need a development environment offering Node.js,
    npm, and a TypeScript compiler, which we will set up in the following section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将暂时离开Go生态系统。要使用React，您需要一个开发环境，其中包括Node.js、npm和TypeScript编译器，我们将在下一节中设置。
- en: Setting up Node.js and TypeScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Node.js和TypeScript
- en: JavaScript is a dynamically typed language. Although (like Go) it does have
    a notion of data types, a JavaScript variable can (unlike Go) basically have any
    type at any time. Since we do not want you to start missing the Go compiler and
    Go's type safety during our brief excursion into the JavaScript world, we will
    use TypeScript in this example. TypeScript is a type-safe superset of JavaScript
    that adds static typing and class-based OOP to JavaScript. You can compile TypeScript
    to JavaScript using the TypeScript compiler (or short, *tsc*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态类型语言。尽管（像Go一样）它确实有数据类型的概念，但JavaScript变量基本上可以在任何时候具有任何类型（与Go不同）。由于我们不希望您在我们短暂进入JavaScript世界的过程中开始错过Go编译器和Go的类型安全性，因此我们将在此示例中使用TypeScript。TypeScript是JavaScript的类型安全超集，它添加了静态类型和基于类的面向对象编程。您可以使用TypeScript编译器（或简称为*tsc*）将TypeScript编译为JavaScript。
- en: First of all, in addition to your Go runtime, you will need a working Node.js
    runtime set up on your development machine. Take a look at [https://nodejs.org/en/download](https://nodejs.org/en/download)
    to learn how to set up Node.js on your machine. If you are running Linux (or macOS
    using a package manager such as Homebrew), take a look at [https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了Go运行时，您还需要在开发机器上设置一个可用的Node.js运行时。查看[https://nodejs.org/en/download](https://nodejs.org/en/download)了解如何在您的机器上设置Node.js。如果您使用Linux（或macOS使用Homebrew等软件包管理器），请查看[https://nodejs.org/en/download/package-manager](https://nodejs.org/en/download/package-manager)。
- en: 'After having installed Node.js, continue by installing the TypeScript compiler
    using the **Node Package Manager** (**npm**):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Node.js后，继续使用Node包管理器（npm）安装TypeScript编译器：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will download and install the TypeScript compiler into your system's `PATH`.
    After running the preceding command, you should be able to call tsc on your command
    line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载并安装TypeScript编译器到您系统的`PATH`中。运行上述命令后，您应该能够在命令行上调用tsc。
- en: 'In this project, we will also use the Webpack module bundler. A module bundler
    takes Node.js modules and generates static JavaScript files that can be used in
    a browser environment. You can install Webpack just as you did for the TypeScript
    compiler via npm:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们还将使用Webpack模块打包程序。模块打包程序获取Node.js模块并生成静态JavaScript文件，可在浏览器环境中使用。您可以通过npm安装Webpack，就像您为TypeScript编译器所做的那样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initializing the React project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化React项目
- en: 'Start by creating a new directory for your React frontend application. Next,
    initialize the directory as a new `npm` package:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先为您的React前端应用程序创建一个新目录。接下来，将该目录初始化为一个新的`npm`包：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `npm init` command will prompt you for a few (more or less), important
    information about your project. In the end, it should generate a `package.json`
    file, which should look roughly like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm init`命令将提示您输入有关您的项目的一些（多多少少）重要信息。最后，它应该会生成一个`package.json`文件，大致如下：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In general, our application will have the following directory structure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们的应用程序将具有以下目录结构：
- en: Our TypeScript source files will be placed in the `src/` directory.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的TypeScript源文件将放在`src/`目录中。
- en: The compiled JavaScript files will be placed in the `dist/` directory. Since
    we will be using Webpack as a module bundler, our `dist/` directory will most
    likely contain just one file containing the entire compiled source code.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的JavaScript文件将放在`dist/`目录中。由于我们将使用Webpack作为模块打包程序，我们的`dist/`目录很可能只包含一个文件，其中包含整个编译后的源代码。
- en: The libraries that we will be installing as dependencies via npm will be installed
    into the `node_modules/` directory.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过npm安装的库作为依赖项安装到`node_modules/`目录中。
- en: 'We can now use npm to add dependencies to our project. Let''s start by installing
    the React and ReactDOM packages:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用npm向我们的项目添加依赖项。让我们从安装React和ReactDOM包开始：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@types` packages are needed for the TypeScript compiler. Since React is
    a JavaScript (not TypeScript) library, the TypeScript compiler will need additional
    information about the classes defined by the react library and their method signatures.
    For example, these **typings** might contain information on which parameter types
    are needed for certain functions provided by React and their return types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器需要`@types`包。由于React是一个JavaScript（而不是TypeScript）库，TypeScript编译器将需要有关由react库定义的类和它们的方法签名的额外信息。例如，这些**typings**可能包含有关React提供的某些函数所需的参数类型和它们的返回类型的信息。
- en: 'We will also need a few development dependencies:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些开发依赖项：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These libraries will be needed by the Webpack module bundler to compile our
    source files to JavaScript files. However, we will need these dependencies only
    for *building* the application, not for actually *running* it. For this reason,
    we declared them as development dependencies using the `--save-dev` flag.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库将被Webpack模块捆绑器需要将我们的源文件编译为JavaScript文件。但是，我们只需要这些依赖项来*构建*应用程序，而不是实际*运行*它。因此，我们使用`--save-dev`标志将它们声明为开发依赖项。
- en: 'Next, we will need to configure the TypeScript compiler. For this, create a
    new `tsconfig.json` file in the project directory:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置TypeScript编译器。为此，在项目目录中创建一个新的`tsconfig.json`文件：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note how we are configuring the TypeScript compiler to load its source files
    from the `src/` directory using the `include` attribute and to save the compiled
    output files to `dist/` using the `outDir` attribute.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在配置TypeScript编译器，使用`include`属性从`src/`目录加载其源文件，并使用`outDir`属性将编译后的输出文件保存到`dist/`。
- en: 'Lastly, we will also need to configure the Webpack module bundler by creating
    a `webpack.config.js` file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要通过创建一个`webpack.config.js`文件来配置Webpack模块捆绑器：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This file configures Webpack to use the TypeScript loader on all `.ts` and `.tsx`
    files, compile them, and bundle all modules into the `dist/bundle.js` file. Before
    you can actually do that, though, you will need to add some source files to compile.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件配置Webpack在所有`.ts`和`.tsx`文件上使用TypeScript加载器，编译它们，并将所有模块捆绑到`dist/bundle.js`文件中。但在实际执行之前，您需要添加一些要编译的源文件。
- en: Before doing that, let's take a look at how React actually works.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之前，让我们看看React实际上是如何工作的。
- en: Basic React principles
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的React原则
- en: A React application is built from **Components**. A component is a JavaScript
    class that accepts a set of values (called properties, or in short, *props*) and
    returns a tree of DOM elements that can be rendered by the browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: React应用程序是由**组件**构建的。组件是一个JavaScript类，它接受一组值（称为属性，或简称为*props*），并返回可以由浏览器呈现的DOM元素树。
- en: 'Consider the following easy example. We will start with the plain JavaScript
    implementation and show you how to add static typing using TypeScript later:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的例子。我们将从纯JavaScript实现开始，然后向您展示如何使用TypeScript添加静态类型：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Even if you are used to JavaScript, the syntax will probably seem new to you.
    Technically, the preceding code example is not plain JavaScript (any browser would
    refuse to actually run this code), but **JSX**. JSX is a special syntax extension
    to JavaScript that allows you to directly define DOM elements using their respective
    HTML representation. This makes defining React components much easier. Without
    using JSX, the preceding code example will need to be written as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您习惯于JavaScript，该语法对您来说可能会很新。从技术上讲，前面的代码示例不是纯JavaScript（任何浏览器都会拒绝实际运行此代码），而是**JSX**。JSX是JavaScript的一种特殊语法扩展，允许您直接使用它们的HTML表示来定义DOM元素。这使得定义React组件变得更加容易。如果不使用JSX，前面的代码示例将需要按照以下方式编写：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Of course, for actually running the JSX source code in the browser, it needs
    to be transformed to plain old JavaScript first. This will be done by the Webpack
    module bundler when actually building the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当实际在浏览器中运行JSX源代码时，它需要首先转换为普通的JavaScript。这将在实际构建应用程序时由Webpack模块捆绑器完成。
- en: There's also a TypeScript variant of JSX, called **TSX**. It works exactly the
    same way, but with static typing. When building a React component with TypeScript,
    you also have the possibility to define an interface for the component props.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还有JSX的TypeScript变体，称为**TSX**。它的工作方式完全相同，但具有静态类型。使用TypeScript构建React组件时，您还可以为组件props定义接口。
- en: Since this is actually a Go book, it is important to note that TypeScript interfaces
    are a very different thing compared to Go interfaces. While a Go interface describes
    a set of methods that a struct needs to implement, a TypeScript interface defines
    properties and/or methods that an object needs to have.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这实际上是一本Go书，很重要的一点是要注意TypeScript接口与Go接口相比是非常不同的。虽然Go接口描述了一个结构体需要实现的一组方法，但TypeScript接口定义了对象需要具有的属性和/或方法。
- en: 'To associate a React component with a props interface, the `React.Component`
    class has a type parameter that you can specify when extending the class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要将React组件与props接口关联起来，`React.Component`类具有一个类型参数，您可以在扩展类时指定：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Components can be nested into each other. For example, you can now reuse the
    `HelloWorld` component from earlier in another component:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以嵌套在彼此中。例如，您现在可以在另一个组件中重用之前的`HelloWorld`组件：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One advantage of using TypeScript is that when you are using a component whose
    props are defined via an interface, the TypeScript compiler checks whether you
    are actually providing the component with the correct props. For example, omitting
    the `name` prop in the preceding example (or passing it another value than a string)
    will trigger a compile error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript的一个优点是，当您使用通过接口定义props的组件时，TypeScript编译器会检查您是否实际上提供了正确的props给组件。例如，在前面的例子中省略`name`
    prop（或将其传递给另一个值而不是字符串）将触发编译错误。
- en: 'The props passed to a React component are treated as immutable. This means
    that the component will not re-render when one of the prop''s values is changed.
    However, each React component may have an internal state, which can be updated.
    Every time a component''s state is changed, it will be re-rendered. Consider the
    following example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给React组件的props被视为不可变的。这意味着当prop的值之一更改时，组件不会重新渲染。但是，每个React组件可能有一个内部状态，可以进行更新。每当组件的状态更改时，它将被重新渲染。考虑以下例子：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now update this state whenever we want using the component''s `setState()`
    method. For example, we can have a timer increment the counter every second:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用组件的`setState()`方法随时更新此状态。例如，我们可以使用计时器每秒增加计数器：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Changing the component's state will cause it to be re-rendered. In the preceding
    example, this would cause the counter to visibly increment by 1 every second.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 改变组件的状态将导致重新渲染。在前面的例子中，这将导致计数器每秒可见地增加1。
- en: 'Of course, we can also combine props and state. One common use case is to use
    the props that are passed into a component to initialize that component''s state:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以组合props和state。一个常见的用例是使用传递给组件的props来初始化该组件的状态：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Armed with the knowledge about React components, we can now start building the
    frontend for our MyEvents platform.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了React组件的知识后，我们现在可以开始构建MyEvents平台的前端。
- en: Kick-starting the MyEvents frontend
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动MyEvents前端
- en: We will start by building a simple React application that gets the list of available
    events from the server and displays it as a simple list.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建一个简单的React应用程序，从服务器获取可用事件列表并将其显示为简单列表。
- en: 'Before getting started, we will need to bootstrap our React application. For
    this, we will need to build an `index.html` file that can serve as the entry point
    of our application. Typically, this file will not be long, since most of its logic
    will be living in the form of React components:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要引导我们的React应用程序。为此，我们需要构建一个可以作为应用程序入口点的`index.html`文件。通常，这个文件不会很长，因为它的大部分逻辑将以React组件的形式存在：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's take a more detailed look at this HTML file. The `DIV` with the `myevents-app`
    ID will later be the location at which our React application will be rendered.
    Most of the file then consists of loading the React libraries from the respective
    npm packages and loading our actual application bundle (which will be built by
    Webpack).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下这个HTML文件。具有`myevents-app` ID的`DIV`将成为我们的React应用程序将呈现的位置。然后，大部分文件由从相应的npm包加载React库和加载我们的实际应用程序包（将由Webpack构建）组成。
- en: 'To make our application a bit nicer to look at, we will also add the Twitter
    Bootstrap framework to our frontend. As usual, you can use `npm` to install Bootstrap:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序看起来更好一些，我们还将在前端添加Twitter Bootstrap框架。像往常一样，您可以使用`npm`来安装Bootstrap：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After installing Bootstrap, you can include the respective CSS file in the header
    section of your `index.html` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Bootstrap后，您可以在`index.html`文件的头部部分包含相应的CSS文件：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To get started, let''s now add a new React component. For this, create the `src/components/hello.tsx`
    file in your project directory:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请现在添加一个新的React组件。为此，在项目目录中创建`src/components/hello.tsx`文件：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The actual entry point of our React application will be placed in the `src/index.tsx` file.
    You may remember that this was also the file that we have specified as the entry
    point for the Webpack module bundler in the `webpack.config.js` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的React应用程序的实际入口点将放在`src/index.tsx`文件中。您可能还记得，这也是我们在`webpack.config.js`文件中指定为Webpack模块打包程序的入口点的文件：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Take a look at the `className` attribute in the preceding code example. When
    working with plain HTML elements in JSX or TSX, you will need to use `className`
    instead of `class`. This is because `class` is a reserved keyword in both JavaScript
    and TypeScript, so using just `class` would seriously confuse the compiler.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面代码示例中的`className`属性。在JSX或TSX中使用纯HTML元素时，您需要使用`className`而不是`class`。这是因为`class`是JavaScript和TypeScript中的保留关键字，因此仅使用`class`会严重混淆编译器。
- en: 'After having created all these files, you can now run the Webpack bundler to
    create your `bundle.js` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了所有这些文件后，现在可以运行Webpack打包程序来创建您的`bundle.js`文件：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'While in development, you can also have the Webpack bundler running continuously,
    updating your `bundle.js` file whenever one of the source files changes. Just
    leave the started process running in a shell window in the background:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您还可以让Webpack打包程序持续运行，每当源文件之一更改时更新您的`bundle.js`文件。只需在后台的shell窗口中保持启动的进程运行：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can now open the `index.html` file in your browser. However, directly opening
    local files in your browser will cause issues later when making HTTP requests
    to our backend services. You can use the `http-server` npm''s package to quickly
    set up an HTTP server that can serve these local files. Simply install it via
    `npm` and then run it in your project directory:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在浏览器中打开`index.html`文件。但是，直接在浏览器中打开本地文件将在以后向后端服务发出HTTP请求时引起问题。您可以使用`http-server`
    npm包快速设置一个可以提供这些本地文件的HTTP服务器。只需通过`npm`安装它，然后在项目目录中运行它：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Node.js HTTP server will listen at the TCP port `8080` by default, so you
    can access it by navigating to `http://localhost:8080` in your browser:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node.js HTTP服务器将在TCP端口`8080`上监听，因此您可以通过在浏览器中导航到`http://localhost:8080`来访问它：
- en: '![](img/66fc2cd7-4f3f-41fe-9c4e-9b06844fbc75.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66fc2cd7-4f3f-41fe-9c4e-9b06844fbc75.png)'
- en: output (http://localhost:8080)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（http://localhost:8080）
- en: Congratulations! You have just built your first React application. Of course,
    for the MyEvents platform, we will need a bit more than Hello World! One of our
    first tasks will be loading the available events from the backend service and
    displaying them in an aesthetically pleasing manner.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚构建了您的第一个React应用程序。当然，对于MyEvents平台，我们将需要比Hello World!更多。我们的第一个任务之一将是从后端服务加载可用事件并以美观的方式显示它们。
- en: Implementing the event list
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现事件列表
- en: To display a list of available events, we will need a solution for loading these
    events from the backend service, more precisely, the event service's REST API
    that you have built in [Chapter 2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml),
    *Building Microservices Using Rest APIs*, and [Chapter 3](9c1db13f-619b-43a7-96a1-c6fc65e13b67.xhtml),
    *Securing Microservices*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示可用事件的列表，我们将需要一个解决方案来从后端服务加载这些事件，更准确地说，是您在[第2章](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml)中构建的事件服务的REST
    API，*使用Rest API构建微服务*，以及[第3章](9c1db13f-619b-43a7-96a1-c6fc65e13b67.xhtml)，*保护微服务*。
- en: Bringing your own client
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自己带来客户端
- en: 'React is a modular Framework. Unlike other JavaScript frontend frameworks such
    as Angular, React does not ship its own library for REST calls, but instead expects
    you to bring your own. To load data from the server, we will use the fetch API.
    The fetch API is a newer JavaScript API for doing AJAX calls to backend services
    that are implemented in many modern browsers (primarily, Firefox and Chrome).
    For older browsers that do not yet implement the fetch API, there is a `polyfill`
    library that you can add to your application via `npm`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: React是一个模块化的框架。与其他JavaScript前端框架（如Angular）不同，React不提供自己的REST调用库，而是期望您自己带来。为了从服务器加载数据，我们将使用fetch
    API。fetch API是一个较新的JavaScript API，用于向许多现代浏览器（主要是Firefox和Chrome）中实现的后端服务进行AJAX调用。对于尚未实现fetch
    API的旧版浏览器，有一个`polyfill`库，您可以通过`npm`添加到您的应用程序中：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will need to include these two `polyfill` libraries in your `index.html`
    file alongside the other JavaScript libraries:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在`index.html`文件中将这两个`polyfill`库与其他JavaScript库一起包含：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The fetch `polyfill` library will use the browser's fetch API when it is available,
    and provide its own implementation when it's not available. In a few years, when
    more browsers support the fetch API, you will be safely able to remove the `polyfill`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器的fetch API可用时，fetch `polyfill`库将使用浏览器的fetch API，并在不可用时提供自己的实现。几年后，当更多的浏览器支持fetch
    API时，您将能够安全地删除`polyfill`。
- en: Building the event list components
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建事件列表组件
- en: 'Let''s now think about which React components we will need for our event list.
    The following diagram shows an overview of the components that we will be building:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下我们将需要哪些React组件来构建我们的事件列表。以下图表显示了我们将要构建的组件的概述：
- en: '![](img/0f475ad6-376b-4108-8f95-131ae2ba5c34.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f475ad6-376b-4108-8f95-131ae2ba5c34.png)'
- en: An overview of the components that the event list will be built of
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 事件列表将构建的组件概述
- en: 'These components will have the following responsibilities:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将有以下职责：
- en: The `EventListContainer` component will be responsible for loading the event
    list from the backend service and managing the event list in its own state. It
    will then pass the current set of events down to the props of the `EventList`
    component.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventListContainer`组件将负责从后端服务加载事件列表并在其自己的状态中管理事件列表。然后，它将当前的事件集传递给`EventList`组件的props。'
- en: The `EventList` component will be responsible for rendering the container in
    which the event list will be presented. For starters, we will choose a simple
    table view. This table will then be filled with a set of `EventListItem`, one
    for each event.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventList`组件将负责呈现事件列表将呈现的容器。首先，我们将选择一个简单的表格视图。然后，这个表格将被填充一个`EventListItem`集合，每个事件一个。'
- en: The `EventListItem` component will render a single Event item in the event list.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventListItem`组件将在事件列表中呈现单个事件项。'
- en: Technically, we could make the `EventList` component do both—load the events
    from the backend service and manage the event list presentation. However, this
    would violate the **single-responsibility principle**; that's why we have two
    components—one that loads events and passes them to another, and one that presents
    them to the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`EventList`组件可以同时加载来自后端服务的事件并管理事件列表呈现。然而，这将违反**单一责任原则**；这就是为什么我们有两个组件的原因——一个加载事件并将其传递给另一个，另一个向用户呈现它们。
- en: 'Let''s start by telling the TypeScript compiler how an Event actually looks
    like. To do this, we will define a TypeScript interface that describes the JSON
    responses that are delivered by the backend service when `GET` is used for getting
    the URL `/events`. Create a new `./src/models/event.ts` file with the following
    contents:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先告诉TypeScript编译器事件实际上是什么样子。为此，我们将定义一个TypeScript接口，描述后端服务在使用`GET`获取URL`/events`时传递的JSON响应。创建一个新的`./src/models/event.ts`文件，内容如下：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note how closely this interface definition corresponds with the `persistence.Event`
    struct that was defined in the event service's code. In order for frontend and
    backend to work well together, these two definitions will need to be kept in sync
    when they change.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个接口定义与事件服务代码中定义的`persistence.Event`结构是多么相似。为了使前端和后端能够良好协作，这两个定义在发生更改时需要保持同步。
- en: 'You can now continue to build the React components. We will start bottom-up
    by implementing the `EventListItem`. For this, create a new `src/components/event_list_item.tsx` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以继续构建React组件。我们将从底部开始实现`EventListItem`。为此，请创建一个新的`src/components/event_list_item.tsx`文件：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, define the `EventList` component in the `src/components/event_list.tsx` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`src/components/event_list.tsx`文件中定义`EventList`组件：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note how the `EventList` component uses JavaScript's native `map` function to
    convert an array of Event objects to a list of `EventListItem` (with that event
    passed as a prop) very easily. The list of `EventListItem` is then inserted into
    the body of the table created by the `EventList` component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`EventList`组件如何使用JavaScript的原生`map`函数将事件对象数组转换为`EventListItem`列表（传递事件作为prop）非常容易。`EventListItem`列表然后插入到`EventList`组件创建的表的主体中。
- en: 'Last but not least, we can build the `EventListContainer` component. Within
    this component, we will use the fetch API to load the events from the server.
    First, let''s implement the definitions for the `EventListContainer` props and
    state in the `src/components/event_list_container.tsx` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以构建`EventListContainer`组件。在这个组件中，我们将使用fetch API从服务器加载事件。首先，让我们在`src/components/event_list_container.tsx`文件中实现`EventListContainer`的props和state的定义：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we can implement the actual component:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现实际的组件：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the constructor, we will first initialize the component's state. Here, it
    is important to remember that HTTP operations in JavaScript are usually asynchronous.
    Although we are calling the `fetch` function in the constructor, the JavaScript
    runtime will execute this HTTP request asynchronously and the component will be
    created even when no data has been loaded (yet). For this reason, our component
    state includes a boolean property named `loading` that indicates whether the data
    is still loading. Later, the component can adjust its presentation based on this
    state attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将首先初始化组件的状态。在这里，重要的是要记住JavaScript中的HTTP操作通常是异步的。尽管我们在构造函数中调用`fetch`函数，但JavaScript运行时将异步执行此HTTP请求，并且即使没有加载数据（尚未），组件也将被创建。因此，我们的组件状态包括一个名为`loading`的布尔属性，指示数据是否仍在加载。稍后，组件可以根据这个状态属性调整其呈现。
- en: The `fetch` method returns a promise. A promise is a placeholder for a value
    that is not yet available. You can use the `then(...)` function on a promise instance
    to run code as soon as the promised value becomes available. You can also chain
    promise; in this case, the `fetch` function returns a promise for an HTTP response
    (that is, an instance of the `Response` class). This class in itself has a `json()`
    function that itself returns another promise for the JSON-decoded value. When
    a function passed to a `then(...)` call returns another promise, the returned
    promise will replace the original promise. This means that we can add another
    `then()` call to the chain that will be called when the HTTP response is available
    and was successfully JSON-decoded. When that happens, we will update the component's
    state, indicating that the component is no longer loading, and the `events` property
    containing the actual event list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`方法返回一个promise。promise是一个尚未可用的值的占位符。您可以在promise实例上使用`then(...)`函数，以便在承诺的值变为可用时立即运行代码。您还可以链接promise；在这种情况下，`fetch`函数返回一个HTTP响应的promise（即`Response`类的实例）。这个类本身有一个`json()`函数，它本身返回另一个解码后的JSON值的promise。当传递给`then(...)`调用的函数返回另一个promise时，返回的promise将替换原始promise。这意味着我们可以在链中添加另一个`then()`调用，当HTTP响应可用并且成功解码为JSON时将调用该调用。当发生这种情况时，我们将更新组件的状态，指示组件不再处于加载状态，并且包含实际事件列表的`events`属性。'
- en: 'Finally, finish the `EventListContainer` component by adding a `render()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过添加一个`render()`方法来完成`EventListContainer`组件：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In order to actually display the event list on our page, you can now use the
    `EventListContainer` in the `index.tsx` file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际在我们的页面上显示事件列表，现在可以在`index.tsx`文件中使用`EventListContainer`：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In general, it is also considered a good practice to build a root component
    that can serve as a single point of entry into the application. We can extract
    the DOM elements from the `ReactDOM.render` call into its own component and then
    use that in the `ReactDOM.render` call:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，构建一个可以作为应用程序的单一入口点的根组件也被认为是一种良好的做法。我们可以将`ReactDOM.render`调用中的DOM元素提取到自己的组件中，然后在`ReactDOM.render`调用中使用它：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Enabling CORS in the backend services
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在后端服务中启用CORS
- en: Before testing the frontend application, you will need to make sure that the
    backend services (more precisely, both the event service and the booking service)
    support **Cross-Origin Resource Sharing** (**CORS**). Otherwise, your browser
    will not execute HTTP requests to any of your backend services, when the frontend
    is served on `http://localhost:8080` and the backend services run on other TCP
    ports.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试前端应用程序之前，您需要确保后端服务（更准确地说，事件服务和预订服务）支持**跨源资源共享**（**CORS**）。否则，当前端在`http://localhost:8080`上提供，后端服务在其他TCP端口上运行时，浏览器将不会执行对任何后端服务的HTTP请求。
- en: 'In principle, CORS consists of nothing more than a few additional headers that
    need to be present in the HTTP response. For example, to allow AJAX requests from
    another domain, the HTTP response needs to contain an `Access-Control-Allow-Origin`
    header. An HTTP response with such a header might look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，CORS只是需要在HTTP响应中存在的一些额外标头。例如，为了允许来自另一个域的AJAX请求，HTTP响应需要包含一个`Access-Control-Allow-Origin`标头。具有这样一个标头的HTTP响应可能如下所示：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since we are using the Gorilla toolkit in both the event and booking service,
    adding the CORS functionality is easy. First, we will need to go get the `github.com/gorilla/handlers`
    package:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在事件和预订服务中都使用Gorilla工具包，因此添加CORS功能很容易。首先，我们需要获取`github.com/gorilla/handlers`包：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After that, we can use the `handlers.CORS` function to add the CORS functionality
    to an existing HTTP server. This allows us to adjust the event service''s `rest.go`
    file as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用`handlers.CORS`函数将CORS功能添加到现有的HTTP服务器中。这允许我们调整事件服务的`rest.go`文件如下：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Adjust the booking service the same way. After that, you will be able to talk
    to both services from the frontend application without any issues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式调整预订服务。之后，您将能够从前端应用程序无问题地与两个服务进行通信。
- en: Testing the event list
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试事件列表
- en: 'In order to test your application, make sure that you have an instance of the
    event service running locally and listening on TCP port `8181`. Also, ensure that
    you have already created one or two events using the event service''s REST API.
    Then, start the Node.js `http-server` in your frontend application directory and
    navigate to `http://localhost:8080` in your browser:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的应用程序，请确保你的事件服务实例在本地运行，并监听TCP端口`8181`。还要确保你已经使用事件服务的REST API创建了一个或两个事件。然后，在你的前端应用目录中启动Node.js
    `http-server`，并在浏览器中导航到`http://localhost:8080`：
- en: '![](img/df05a321-6a76-4287-a1a8-57f641e80d96.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df05a321-6a76-4287-a1a8-57f641e80d96.png)'
- en: output (http://localhost:8080)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（http://localhost:8080）
- en: Adding routing and navigation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由和导航
- en: Before we add more functionalities to our frontend application, let's take the
    time to add a robust navigation and routing layer. This will allow our application
    to stay easily maintainable when more features are added.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为前端应用添加更多功能之前，让我们花时间添加一个强大的导航和路由层。这将使我们的应用在添加更多功能时保持易于维护。
- en: 'In order for our application to support multiple application views, we will
    first add the `react-router-dom` package to our application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个应用视图，我们首先将`react-router-dom`包添加到我们的应用中：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `react-router-dom` package adds a few new components to our application.
    We can use these in our root component to easily implement routing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-router-dom`包为我们的应用添加了一些新组件。我们可以在根组件中使用这些组件来轻松实现路由：'
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how the `<Route>` component is used within the container; at this point,
    we can later add multiple `Route` components and the React router will render
    these components depending on the current URL. This allows our application to
    lead the user from one view to another using plain, old links.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意容器中如何使用`<Route>`组件；在这一点上，我们可以稍后添加多个`Route`组件，React路由将根据当前URL呈现这些组件。这允许我们的应用使用普通的旧链接将用户从一个视图引导到另一个视图。
- en: Note the `eventList` constant that is being declared in the preceding `render()`
    method. This is because the `Route` component accepts a `component` prop, which
    refers to a component or a function that will be called whenever this `Route`
    is matched. However, we cannot specify props that should be passed to the respective
    component. This is why we are declaring a function that initializes the `EventListContainer`
    component with default props, allowing it to be used in the `Route` component.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的`render()`方法中声明的`eventList`常量。这是因为`Route`组件接受一个`component`属性，它引用一个组件或一个函数，每当匹配到这个`Route`时都会调用它。然而，我们无法指定应该传递给相应组件的props。这就是为什么我们声明一个函数，用默认props初始化`EventListContainer`组件，允许它在`Route`组件中使用。
- en: 'Now that we have a working routing layer; let''s make sure that our users will
    always find their way back to the event list. For this, we will add a new navigation
    bar component that we can use in our root component. Create a new `src/components/navigation.tsx`
    file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个工作的路由层；让我们确保我们的用户始终能找到回到事件列表的方法。为此，我们将添加一个新的导航栏组件，我们可以在根组件中使用。创建一个新的`src/components/navigation.tsx`文件：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, add a `render()` method to the new component:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在新组件中添加一个`render()`方法：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note how our `Navigation` component uses the `Link` component to create links
    to other React routes, which is admittedly not that complicated yet, given that
    we only have the `/` route for now.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的`Navigation`组件如何使用`Link`组件来创建到其他React路由的链接，鉴于我们现在只有`/`路由，这并不复杂。
- en: 'To actually use our new navigation component, add it to the root component''s
    `render` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用我们的新导航组件，请将其添加到根组件的`render`方法中：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing the booking process
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现预订流程
- en: Now that we have a working routing and navigation in place, we can implement
    the next piece of functionality—the booking process. For the purpose of this book,
    we will keep the booking process simple. Each line in the events list that we
    implemented earlier should get a button that takes the user to the booking form.
    In this form, they will be prompted for the number of tickets they want to book
    and can then submit the form. On submitting, the frontend application will perform
    an HTTP request to the booking service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个工作的路由和导航，我们可以实现下一个功能——预订流程。为了本书的目的，我们将保持预订流程简单。我们之前实现的事件列表中的每一行都应该有一个按钮，可以将用户带到预订表单。在这个表单中，他们将被要求输入他们想要预订的票数，然后可以提交表单。提交后，前端应用将执行一个HTTP请求到预订服务。
- en: 'Of course, we will implement the booking form as a React component. Just as
    before, we will keep responsibilities separated and build separate components
    to handle the backend communication and frontend presentation. The `EventBookingFormContainer`
    will be responsible for loading the event record from the event service and saving
    the actual booking back to the booking service. The `EventBookingForm` will then
    be responsible for the actual frontend presentation of the form. In order to make
    the form presentation easier, we will also introduce a `FormRow` component. The
    following diagram gives an overview of these components and how they relate to
    each other:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将把预订表单实现为一个React组件。与之前一样，我们将分开职责并构建单独的组件来处理后端通信和前端呈现。`EventBookingFormContainer`将负责从事件服务加载事件记录，并将实际预订保存到预订服务。然后`EventBookingForm`将负责表单的实际前端呈现。为了使表单呈现更容易，我们还将引入一个`FormRow`组件。以下图表概述了这些组件及它们之间的关系：
- en: '![](img/da695a1f-2970-4f7b-99de-cf52a8f9de57.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da695a1f-2970-4f7b-99de-cf52a8f9de57.png)'
- en: Relation between components
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间的关系
- en: 'The `FormRow` component will be a purely presentational component to make the
    Bootstrap framework''s form CSS classes easier to use. As before, we will implement
    these components bottom-up, starting with the innermost component. For this, create
    the `src/components/form_row.tsx` file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormRow`组件将是一个纯粹的呈现组件，以便更容易使用Bootstrap框架的表单CSS类。与之前一样，我们将自下而上实现这些组件，从最内部的组件开始。为此，创建`src/components/form_row.tsx`文件：'
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this case, we are using the special prop `children`. Although we did not
    explicitly define this prop in the `FormRowProps` interface, we can use the `children`
    prop in any React component. It will contain any DOM elements that were passed
    as child elements into the current component. This will allow you to use the `FormRow`
    component as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了特殊的prop`children`。虽然我们没有在`FormRowProps`接口中明确定义这个prop，但我们可以在任何React组件中使用`children`prop。它将包含传递给当前组件的任何DOM元素的子元素。这将允许您像下面这样使用`FormRow`组件：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we can use the `FormRow` component to build the `EventBookingForm` component.
    For this, create a new file, called `src/components/event_booking_form.tsx`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用`FormRow`组件来构建`EventBookingForm`组件。为此，创建一个名为`src/components/event_booking_form.tsx`的新文件：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `EventBookingForm` component has both input props and an internal state.
    The input properties contain the actual event, for which the booking form should
    be rendered, and a callback method. We will later configure the booking form to
    call this callback method whenever the form is submitted. The form's internal
    state contains a variable for the number of tickets that should be booked.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventBookingForm`组件既有输入props，也有内部状态。输入属性包含实际的事件，为其应该呈现预订表单，并且一个回调方法。我们稍后将配置预订表单，在表单提交时调用这个回调方法。表单的内部状态包含应该预订的门票数量的变量。'
- en: 'Now, add a `render()` method to the `EventBookingForm` component:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为`EventBookingForm`组件添加一个`render()`方法：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will generate a small form in which the user will be able to review which
    event they are booking tickets for, select the desired amount of tickets, and
    then submit the order. Note how the `onSubmit` prop is called on the button's
    `onClick` event.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个小表单，用户将能够查看他们预订门票的事件，选择所需数量的门票，然后提交订单。请注意，`onSubmit`属性在按钮的`onClick`事件上被调用。
- en: 'Also, note that the select field''s `onChange` event calls a `this.handleNewAmount` method,
    which we have not defined yet. Let''s do this now:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意选择字段的`onChange`事件调用了一个`this.handleNewAmount`方法，我们还没有定义。现在让我们来做这个：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Last but not least, we can now implement the `EventBookingFormContainer` component.
    This component will be responsible for handling the AJAX communication to the
    respective backend services (since we are working with event bookings, we will
    also have to communicate with the booking service that we built in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们现在可以实现`EventBookingFormContainer`组件。这个组件将负责处理与相应后端服务的AJAX通信（因为我们正在处理事件预订，我们还必须与我们在[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中构建的预订服务进行通信，*使用消息队列的异步微服务架构*）。
- en: 'Let''s start by defining the component''s props and state. For this, create
    a new `src/components/event_booking_form_container.tsx` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义组件的props和state。为此，创建一个新的`src/components/event_booking_form_container.tsx`文件：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `EventBookingFormContainer` will need to make AJAX calls to both the event
    service and the booking service. When a new instance of this component is created,
    it will be passed an event ID via its properties, and then use that ID to load
    the respective event's data from the event service into the component's state.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventBookingFormContainer`将需要对事件服务和预订服务进行AJAX调用。当创建这个组件的新实例时，它将通过其属性传递一个事件ID，然后使用该ID从事件服务加载相应的事件数据到组件的状态中。'
- en: 'Loading the event data is something that we can do in the component''s constructor
    function that we will define next:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 加载事件数据是我们可以在接下来定义的组件构造函数中做的事情：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can add a `render` method to this component that presents the actual
    booking form as soon as the event has been loaded:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为这个组件添加一个`render`方法，一旦事件被加载，就会呈现实际的预订表单：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This `render()` method basically covers all possible variants of the component's
    state and then prints the respective status messages. When an event has successfully
    been loaded, the actual `EventBookingForm` is presented.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`render()`方法基本上涵盖了组件状态的所有可能变体，然后打印相应的状态消息。当事件成功加载时，实际的`EventBookingForm`就会被呈现出来。
- en: 'Finally, we will need to implement the `handleSubmit` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现`handleSubmit`方法：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This concludes our work on the booking form. Up until now, we have missed just
    one little thing—there is no way to access this form yet. Let's now amend this
    oversight.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对预订表单的工作。到目前为止，我们只错过了一件小事——还没有办法访问这个表单。让我们现在修正这个疏忽。
- en: 'Start by adding a new route to the `index.tsx` file, more precisely, in the
    `App` component''s `render` method:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`index.tsx`文件中添加一个新的路由，更确切地说，在`App`组件的`render`方法中：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this code example, you can see multiple things. First, we are declaring a
    new local component `eventBooking`, which basically returns an `EventBookingFormContainer`
    component with some default parameters. This component will be passed a prop object
    with a `match` attribute (the curly brackets in the parameter declaration are
    a so-called **destructuring assignment**). This match object contains the route
    parameters from the `/events/:id/book` route that was declared in the previous
    example. This allows us to include an event ID as a route parameter (so, for example,
    `localhost:8080/#/events/58d543209cdd4128c06e59db/book`).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，你可以看到多个内容。首先，我们声明了一个新的本地组件`eventBooking`，它基本上返回一个带有一些默认参数的`EventBookingFormContainer`组件。这个组件将被传递一个带有`match`属性的prop对象（参数声明中的花括号是所谓的**解构赋值**）。这个match对象包含了前面示例中声明的`/events/:id/book`路由的路由参数。这允许我们将事件ID作为路由参数包含进去（例如，`localhost:8080/#/events/58d543209cdd4128c06e59db/book`）。
- en: Also, for this code to work, we are assuming that you have an instance of the
    booking service from [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*, running and listening
    on localhost TCP port `8282`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使这段代码工作，我们假设您已经从[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中获得了一个运行并监听在本地TCP端口`8282`上的预订服务的实例，*使用消息队列的异步微服务架构*。
- en: 'Lastly, we need to add a button that allows the user to actually reach this
    route. For this, we will modify the `EventListItem` component in the `src/component/event_list_item.tsx`
    file that you have created in an earlier section of this chapter. We will use
    the `Link` component from the `react-router-dom` package that you have worked
    with before:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个按钮，允许用户实际到达这个路由。为此，我们将修改本章前面部分中创建的`src/component/event_list_item.tsx`文件中的`EventListItem`组件。我们将使用您之前使用过的`react-router-dom`包中的`Link`组件：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In your frontend application, you will now see an additional button labeled
    Book now!:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的前端应用程序中，您现在将看到一个名为“立即预订！”的额外按钮：
- en: '![](img/4be3b4b9-3be5-412e-a5c8-484e30221a82.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4be3b4b9-3be5-412e-a5c8-484e30221a82.png)'
- en: Book now! button
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 立即预订！按钮
- en: 'The `EventistItem` components in the event list now contain a link to each
    event''s booking form. Upon clicking one of these buttons, the application will
    link you to the respective event''s actual booking form:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 活动列表中的`EventistItem`组件现在包含每个活动预订表单的链接。点击其中一个按钮后，应用程序将链接到相应活动的实际预订表单：
- en: '![](img/bd606b09-37e8-4d93-958e-f6eb9d91e2a1.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd606b09-37e8-4d93-958e-f6eb9d91e2a1.png)'
- en: The EventBookingForm in action
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 活动预订表单的实际操作
- en: Note the URL containing the event ID. Since we have built `EventBookingFormContainer`
    to load the event data from the event service when it is constructed, we can now
    even use this URL and open it directly in a browser. The React router will open
    the booking form immediately and then load the event's data from the event service.
    This allows you to open subroutes in React applications directly and even share
    or bookmark these URLs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意包含活动ID的URL。由于我们已经构建了`EventBookingFormContainer`，它在构建时从活动服务加载活动数据，现在甚至可以使用这个URL直接在浏览器中打开。React路由将立即打开预订表单，然后从活动服务加载活动数据。这使您可以直接在React应用程序中打开子路由，甚至共享或收藏这些URL。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have given you a glimpse into frontend development with
    React. Of course, we have only scratched the surface of what is possible with
    the React framework. In an actual real-world application, we would still need
    to add quite a lot of features for the frontend application to be actually complete
    (for example, we would need to add some trivial things, such as a user sign-up
    and a more sophisticated checkout process).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为您展示了使用React进行前端开发的一瞥。当然，我们只是触及了React框架可能性的冰山一角。在实际的现实世界应用中，我们仍然需要为前端应用程序添加相当多的功能，才能真正完成（例如，我们需要添加一些琐碎的东西，比如用户注册和更复杂的结账流程）。
- en: Up until now, we have spent most of our time doing actual programming, both
    in the backend with Go and in the frontend with TypeScript. However, there is
    more to do with software development than just programming. Over the next few
    chapters, we will concern ourselves with the deployment of our application. This
    will include both the backend services (such as the Event and booking services
    built in previous chapters), but also persistence and messaging services (such
    as databases or message queues). For this, we will take a look at modern container
    technologies and how to deploy these to the cloud. Stay tuned.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大部分时间都在做实际的编程，既在后端使用Go语言，又在前端使用TypeScript。然而，软件开发不仅仅是编程。在接下来的几章中，我们将关注应用程序的部署。这将包括后端服务（例如在之前章节中构建的活动和预订服务），还有持久性和消息服务（例如数据库或消息队列）。为此，我们将研究现代容器技术以及如何将其部署到云端。敬请关注。
