- en: Migration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: Welcome to chapter 11 of our journey to learn the world of cloud native programming
    and the Go language. In this chapter, we'll cover some practical techniques to
    migrate applications from monolithic architectures to microservice architectures.
    We have already covered monolithic and microservice architectures in [Chapter
    2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml), *Building Microservices Using
    Rest APIs. *However, we will start this chapter by covering the practical definitions
    of monolithic and microservice architectures, in case you are reading this chapter
    separately.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们学习云原生编程和Go语言世界的第11章。在本章中，我们将涵盖一些实用的技术，以将应用程序从单片架构迁移到微服务架构。我们已经在[第2章](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml)中涵盖了单片和微服务架构，*使用Rest
    API构建微服务。*但是，我们将从实际定义单片和微服务架构开始本章，以防您单独阅读本章。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: A review on monolithic applications and microservices architectures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片应用程序和微服务架构的回顾
- en: Techniques for migrating from monolithic applications to microservices applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单片应用程序迁移到微服务应用程序的技术
- en: Advanced microservices design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级微服务设计模式
- en: Data consistency in microservices architectures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构中的数据一致性
- en: What is a monolithic application?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单片应用程序？
- en: A **monolithic application** is simply a single piece of software that undertakes
    several independent tasks at once. Let's take an online store application as an
    example. In a monolithic architecture, we'd have a single piece of software that
    would handle the customers, their orders, the database connections, the website,
    the inventory, and any other tasks needed for the online store to be successful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**单片应用程序**只是一个软件，可以同时执行多个独立的任务。让我们以在线商店应用程序为例。在单片架构中，我们将有一个单一的软件来处理客户、他们的订单、数据库连接、网站、库存以及在线商店成功所需的任何其他任务。'
- en: A single piece of software doing everything might seem like an inefficient approach
    for software design, which is the case in some scenarios. However, it is important
    to mention that monolithic applications are not always bad. There are some scenarios
    where a single software service doing all the work is an acceptable idea. This
    includes minimum viable products or MVPs where we try to build something fast
    to get it out for test users to try. It also includes use cases where not a lot
    of data load or traffic is expected, such as an online store for legacy board
    game hobbyists.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软件执行所有任务似乎是软件设计的一种低效方法，在某些情况下确实如此。然而，重要的是要提到，单片应用程序并不总是不好的。在一些情况下，一个单一的软件服务执行所有工作是可以接受的。这包括最小可行产品或MVP，我们试图快速构建一些东西供测试用户尝试。这还包括预期没有太多数据负载或流量的使用情况，比如面向传统棋盘游戏爱好者的在线商店。
- en: What are microservices?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: A **microservice architecture** takes a different approach to building software
    as compared to monolithic applications. In a microservice architecture, the tasks
    are distributed among multiple smaller software services, which are known as microservices.
    In a well-designed microservice architecture, each microservice should be self-contained,
    deployable, and scalable. Well-designed microservices also enjoy clean APIs that
    allow other microservices to communicate with them. The concept of independent
    software services working together to reach a common goal is not new; it existed
    in the past as **service-oriented architectures** (**SOA**). However, modern microservices
    architectures take the idea a bit further by insisting on the software services
    being relatively small,  independent, and fully self-contained.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**与单片应用程序相比，构建软件采用了不同的方法。在微服务架构中，任务分布在多个较小的软件服务中，这些服务被称为微服务。在设计良好的微服务架构中，每个微服务应该是自包含的、可部署的和可扩展的。设计良好的微服务还享有干净的API，允许其他微服务与它们通信。独立的软件服务共同努力实现共同目标的概念并不新鲜；它在过去作为**面向服务的架构**（**SOA**）存在。然而，现代微服务架构通过坚持软件服务相对较小、独立和完全自包含的概念，将这个想法推向了更远。'
- en: Let's go back to the online store example. In the case of a microservice architecture,
    we would have a microservice for customer handling, a microservice for inventory
    handling, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到在线商店的例子。在微服务架构的情况下，我们会有一个用于处理客户的微服务，一个用于处理库存的微服务，依此类推。
- en: 'A typical microservice contains multiple essential layers in the inside to
    handle logging, configuration, APIs to communicate with other microservices, and
    persistence. There is also the core code of the microservice, which covers the
    main task the service is supposed to do. The following is what a microservice
    should internally look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的微服务内部包含多个必要的层，用于处理日志记录、配置、与其他微服务通信的API以及持久性。还有微服务的核心代码，涵盖了服务应该执行的主要任务。以下是微服务内部应该看起来的样子：
- en: '![](img/0b75db61-3b04-471c-a000-60aa8f4b3a33.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b75db61-3b04-471c-a000-60aa8f4b3a33.png)'
- en: Internal look of microservice
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的内部外观
- en: Microservice architectures have major advantages over monolithic applications
    when it comes to scalability and flexibility. Microservices allow you to scale
    indefinitely, utilize the power of more than one programming language, and gracefully
    tolerate failures.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及可伸缩性和灵活性时，微服务架构比单片应用程序具有重大优势。微服务允许您无限扩展，利用多种编程语言的功能，并优雅地容忍故障。
- en: Migrating from monolithic applications to microservices
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单片应用程序迁移到微服务
- en: So, now, let's say that you have a monolithic application, your business is
    growing, your customers are demanding more features, and you need to migrate to
    an architecture that is both flexible and scalable. It's time to use microservices.
    The first key rule of thumb to have in mind when migrating is that there is no
    golden set of steps we need to follow to perform a successful migration from monolithic
    applications to microservices. The steps we need to follow differ from one situation
    to another and from one organization to another. Having said that, there are some
    very helpful concepts and ideas that we can cover in this chapter, which will
    help you make informed decisions on how to go about the migration.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你有一个单片应用，你的业务正在增长，你的客户要求更多功能，你需要迁移到既灵活又可扩展的架构。是时候使用微服务了。迁移时需要牢记的第一个关键原则是，没有一套黄金步骤可以确保从单片应用成功迁移到微服务。我们需要遵循的步骤因情况而异，因组织而异。话虽如此，本章中有一些非常有用的概念和想法，可以帮助您做出明智的决策。
- en: Humans and technology
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人与技术
- en: One of the most overlooked aspects when transitioning from monolithic applications
    to microservices is the **people factor**. We typically think of technology and
    architecture, but what about teams who write the code, manage the projects, and
    redesign the application? Moving from a monolithic application to a microservice
    is a paradigm shift that needs to be properly planned for in an organization.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从单片应用转向微服务时最容易被忽视的因素之一是**人员因素**。我们通常考虑技术和架构，但是谁来编写代码、管理项目和重新设计应用的团队呢？从单片应用转向微服务是一个需要在组织中进行适当规划的范式转变。
- en: 'The first thing we need to consider right after making the decision to move
    to microservices is the structures of teams involved with the development process.
    Typically, the following comprises the team that works on monolithic applications:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定转向微服务后，我们需要考虑的第一件事是参与开发过程的团队结构。通常，以下是负责单片应用的团队：
- en: Developers who are used to working in very specific pieces of the application
    in a single programming language and nothing else
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员习惯于在单一编程语言中工作的特定部分的应用中工作
- en: IT infrastructure teams who are used to deployments being nothing more than
    updating a few number of servers hosting the monolithic application and its databases
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IT基础设施团队通常只需更新托管单片应用及其数据库的少数服务器，部署就完成了。
- en: Team leads who own a piece of an application as opposed to an entire software
    service from A to Z
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队负责人拥有应用的一部分，而不是从A到Z的整个软件服务
- en: 'As mentioned before, microservices migration represents a paradigm shift. This
    means that when transitioning to a microservice architecture, a new way of thinking
    needs to get engaged in the organization. Consider the following :'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，微服务迁移代表了一种范式转变。这意味着在转向微服务架构时，组织需要采用一种新的思维方式。考虑以下内容：
- en: Developers will need to be divided into smaller teams, where each team should
    be in charge of one or more microservices. Developers will need to be comfortable
    being in charge of an entire software service as opposed to a bunch of software
    modules or classes. Of course, if the organization is large enough, you can still
    have developers being responsible for specific modules within the microservice.
    However, it pays off if the developers are trained to think of their product as
    the entire microservice, as this will produce a better-designed microservice.
    Developers will also need to be comfortable with using the right programming language
    for the job. For example, Java is important for data processing and pipelining,
    Go is very good for building fast reliable microservices, C# is good for Windows
    services, and so on.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员需要分成较小的团队，每个团队应负责一个或多个微服务。开发人员需要习惯于负责整个软件服务，而不是一堆软件模块或类。当然，如果组织足够大，你仍然可以让开发人员负责微服务中的特定模块。然而，如果开发人员接受培训，将产品视为整个微服务，这将产生更好设计的微服务。开发人员还需要习惯于使用适合工作的编程语言。例如，Java对于数据处理和流水线很重要，Go非常适合构建快速可靠的微服务，C#适用于Windows服务，等等。
- en: IT infrastructure teams will need to learn about horizontal scaling, redundancy,
    expandable cloud platforms, and the planning process involved with deploying a
    massive number of services distributed among numerous servers.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IT基础设施团队需要了解水平扩展、冗余、可扩展的云平台以及部署大量服务所涉及的规划过程。
- en: Team leads will carry the responsibility of an entire software service from
    A to Z. They will need to consider implementation details such as how to scale
    the service, whether to share a database with other services or have its own database,
    and how the service would communicate with other service.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队负责人将承担从A到Z的整个软件服务的责任。他们需要考虑实施细节，比如如何扩展服务、是否与其他服务共享数据库或拥有自己的数据库，以及服务如何与其他服务通信。
- en: Cutting a monolithic application to pieces
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单片应用切割成片
- en: Now that we discussed the people aspect of the migration, let's take a dive
    into the technical details. One golden rule that virtually everyone agrees on
    is that writing everything from scratch and ignoring all the code in the existing
    monolithic application (also known as the big bang rewrite) is not a good idea.
    Instead, the best approach to migrate from a monolithic application to microservices
    is to cut the monolithic application piece by piece over time. Each detached piece
    becomes a microservice. For every new microservice, we will need to ensure that
    it can still communicate with the monlithic application, as well as other new
    microservices. If this approach goes well, the monolithic application will keep
    shrinking overtime till it becomes a microservice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了迁移的人员方面，让我们深入了解技术细节。几乎每个人都同意的一个黄金法则是，从头开始编写所有内容，忽略现有单片应用中的所有代码（也称为大爆炸重写）并不是一个好主意。相反，从单片应用迁移到微服务的最佳方法是随着时间的推移逐步削减单片应用。每个分离的部分都成为一个微服务。对于每个新的微服务，我们需要确保它仍然可以与单片应用以及其他新的微服务进行通信。如果这种方法进行顺利，单片应用将随着时间的推移不断缩小，直到成为一个微服务。
- en: '![](img/78cdb5a4-136f-4f38-991d-f5659b14fdc3.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78cdb5a4-136f-4f38-991d-f5659b14fdc3.png)'
- en: Monolithic application shrinking overtime
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单片应用随时间缩小
- en: This sounds simple; however, in real life, it is typically not that straightforward.
    Let's cover some planning strategies to make the piece-by-piece approach more
    executable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很简单；然而，在现实生活中，通常并不是那么直截了当。让我们讨论一些规划策略，使逐步逐步的方法更具可执行性。
- en: How do we break the code?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何分解代码？
- en: 'One key technical question we will need to ask is how exactly should we break
    the monolithic application''s code? Here are some important points to keep in
    mind:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要问的一个关键技术问题是，我们应该如何精确地分解单片应用的代码？以下是一些重要的要点：
- en: If an application is well-written, there will be clean and obvious separations
    between the different classes or software modules.  This makes cutting up the
    code an easier task.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个应用程序编写得很好，不同类或软件模块之间会有清晰明显的分离。这使得切割代码变得更容易。
- en: On the other hand, if there are no clean separations in the code, we'll need
    to do some refactoring to the existing code before we can start moving pieces
    of code to new microservices.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果代码中没有清晰的分离，我们需要在开始将代码片段移动到新的微服务之前对现有代码进行一些重构。
- en: It is typically preferred not to add new code or features to the monolithic
    application without trying to separate the new feature into a new microservice.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常最好的做法是，不要在单片应用中添加新的代码或功能，而是尝试将新功能分离成一个新的微服务。
- en: Glue code
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粘合代码
- en: 'In order for the new microservice to fit into the original application without
    breaking its functionality, the microservice needs to be capable of exchanging
    information with the original application. To make this happen, we may need to
    write some glue code that will link the new with the old. The glue code typically
    includes some API interfaces that would act as the communication channel between
    the original application and the microservice. The glue code will also include
    any code necessary to make the new microservice work with the existing application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使新的微服务适应原始应用而不破坏其功能，微服务需要能够与原始应用交换信息。为了实现这一点，我们可能需要编写一些粘合代码，将新代码与旧代码链接起来。粘合代码通常包括一些API接口，作为原始应用和微服务之间的通信渠道。粘合代码还将包括使新的微服务与现有应用程序配合工作所需的任何代码：
- en: '![](img/d6662e58-ee72-4ea8-92ed-ae2c223656de.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6662e58-ee72-4ea8-92ed-ae2c223656de.png)'
- en: Glue code
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 粘合代码
- en: The glue code might be temporary or permanent, depending on our application.
    Sometimes, the glue code might need to do some data modeling translation or communicate
    with an old database to make things work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 粘合代码可能是临时的，也可能是永久的，这取决于我们的应用程序。有时，粘合代码可能需要进行一些数据建模转换或与旧数据库进行通信以使事情正常运行。
- en: If your application is a web application, the glue code may include a temporary
    web HTTP API that can connect your newly separated microservice with your viewing
    layer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序是一个Web应用程序，粘合代码可能包括一个临时的Web HTTP API，可以将您新分离的微服务与您的视图层连接起来。
- en: Microservices design patterns
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计模式
- en: In this section, we will discuss some important design patterns and architectural
    approaches that can help us build robust and effective cloud-ready microservices.
    Let's get started.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些重要的设计模式和架构方法，这些方法可以帮助我们构建强大而有效的云就绪微服务。让我们开始吧。
- en: Sacrificial architecture
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牺牲性架构
- en: '**Sacrificial architecture** is an important design approach that doesn''t
    typically get the attention it deserves. It was mentioned by Martin Folwer in
    2014 and can be found at [https://martinfowler.com/bliki/SacrificialArchitecture.html](https://martinfowler.com/bliki/SacrificialArchitecture.html).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**牺牲性架构**是一个重要的设计方法，通常没有得到应有的关注。Martin Folwer在2014年提到了这一点，可以在[https://martinfowler.com/bliki/SacrificialArchitecture.html](https://martinfowler.com/bliki/SacrificialArchitecture.html)找到。'
- en: The core idea of sacrificial architecture is that we should write our software
    in a way where it is easily replaceable in the future. To understand the previous
    statement better, let's consider an example scenario. Let's say that a couple
    of years ago, we had built a computer networking application that utilizes custom
    data serialization formats designed by our developers. Today, we need to rewrite
    the application in a more modern programming language that can handle a lot more
    data load and user requests. This task will not be fun or easy by any measure
    because our application relies on custom serialization and communications protocols
    that can only be understood by the original developers of the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 牺牲架构的核心思想是，我们应该以一种易于在未来替换的方式编写我们的软件。为了更好地理解前面的陈述，让我们考虑一个例子情景。假设几年前，我们构建了一个计算机网络应用程序，该应用程序利用我们的开发人员设计的自定义数据序列化格式。今天，我们需要用更现代的编程语言重写该应用程序，以处理更多的数据负载和用户请求。这个任务无论如何都不会有趣或容易，因为我们的应用程序依赖于只有应用程序的原始开发人员才能理解的自定义序列化和通信协议。
- en: Now, what if we had used a more standardized serialization format such as protocol
    buffers? The task of rewriting or updating the application will be much easier
    and more efficient because protocol buffers are supported by a wide range of programming
    languages and frameworks. Building our application with a standard serialization
    format instead of a custom one is what sacrificial architecture is about.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用了更标准化的序列化格式，比如协议缓冲区，那会怎么样？重写或更新应用程序的任务将变得更加容易和高效，因为协议缓冲区受到广泛的编程语言和框架支持。使用标准序列化格式构建我们的应用程序，而不是自定义的格式，这就是牺牲架构的意义所在。
- en: When we design our software with sacrificial architecture in mind, the tasks
    of upgrading, refactoring, and/or evolving our application become much more straightforward.
    If our monolithic application gets designed with sacrificial architecture in mind,
    separating pieces of the application into microservices becomes easy.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计我们的软件时考虑到牺牲架构，升级、重构和/或演变我们的应用程序的任务变得更加简单。如果我们的单片应用程序设计时考虑到了牺牲架构，将应用程序的部分分离成微服务就变得容易了。
- en: If we write our glue code with sacrificial architecture in mind, evolving the
    glue code in the future or getting rid of it altogether and replacing it with
    something else becomes much easier. If we build our new microservices with sacrificial
    architecture in mind, we give ourselves the capability to grow and evolve our
    microservices quickly, painlessly, and efficiently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在编写我们的粘合代码时考虑到了牺牲架构，那么在未来演变粘合代码或完全摆脱它并用其他东西替换它将变得更加容易。如果我们在构建新的微服务时考虑到了牺牲架构，我们就给自己快速、无痛和高效地增长和演变微服务的能力。
- en: A four-tier engagement platform
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个四层的参与平台
- en: A **four-tier engagement platform** is an architectural approach that targets
    the application as a whole. It was described by Forrester research at ;[https://go.forrester.com/blogs/13-11-20-mobile_needs_a_four_tier_engagement_platform/](https://go.forrester.com/blogs/13-11-20-mobile_needs_a_four_tier_engagement_platform/).
    This architecture is very suited for modern applications targeting the mobile
    and web age. The architecture allows scalability, flexibility, and performance.
    It also makes integrating cloud services and internal microservices quite easy
    and efficient.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**四层参与平台**是一种以整个应用程序为目标的架构方法。它在Forrester研究中被描述为[https://go.forrester.com/blogs/13-11-20-mobile_needs_a_four_tier_engagement_platform/](https://go.forrester.com/blogs/13-11-20-mobile_needs_a_four_tier_engagement_platform/)。这种架构非常适合面向移动和网络时代的现代应用程序。该架构允许可伸缩性、灵活性和性能。它还使得集成云服务和内部微服务变得非常容易和高效。'
- en: '![](img/3ac4697f-dd63-4e40-b05a-573ca35e2f76.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ac4697f-dd63-4e40-b05a-573ca35e2f76.png)'
- en: Four-tier engagement architecture
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 四层参与架构
- en: 'The main idea behind this architecture is that the overall application should
    be divided into four main layers or tiers:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构背后的主要思想是，整个应用程序应该分为四个主要层或层：
- en: '**The client layer**:This layer is responsible for the user experience; it
    tailors the user experience based on the user''s context environment. A context
    environment includes the user device type, the user''s location, the time of day,
    among other things. For example, if the user of your product is using a smart
    watch, then the client layer should render content suitable for a smart watch.
    If they are using a tablet, a user interface that is perfect for a tablet greets
    the user. If the user is viewing data from China, the client layer needs to show
    the information in Chinese. If the user is viewing the data from Canada, the information
    needs to be shown in English.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户层**：这一层负责用户体验；它根据用户的上下文环境定制用户体验。上下文环境包括用户设备类型、用户位置、时间等。例如，如果您的产品用户使用智能手表，那么客户层应该呈现适合智能手表的内容。如果他们使用平板电脑，那么适合平板电脑的用户界面将迎接用户。如果用户正在查看来自中国的数据，客户层需要以中文显示信息。如果用户正在查看来自加拿大的数据，信息需要以英文显示。'
- en: '**The delivery layer**: The delivery layer is responsible for delivering optimized
    data to the users as requested by the client layer. This is achieved by doing
    on-the-fly optimizations, such as image compression or bandwidth reduction. The
    layer can make use of monitoring tools to track user activity, then utilize algorithms
    to use this information to deliver better customer experience. This layer is also
    where we would using caching algorithms and techniques to ensure better performance
    for our customers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交付层**：交付层负责按照客户层的要求向用户交付优化的数据。这是通过进行即时优化来实现的，例如图像压缩或带宽减少。该层可以利用监控工具来跟踪用户活动，然后利用算法利用这些信息来提供更好的客户体验。这一层也是我们使用缓存算法和技术来确保为我们的客户提供更好性能的地方。'
- en: '**The aggregation layer**: This layer is where data from different sources
    is aggregated to form stable and uniform data models, which can then be handed
    over to the preceding layers. Tasks undertaken by this layer include the following:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合层：**这一层是将来自不同来源的数据聚合成稳定和统一的数据模型的地方，然后将其交给前面的层。这一层的任务包括以下内容：'
- en: Acting as an API hub between layer, providing service discoverability, and data
    access to the preceding layers.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在层之间充当API中心，提供服务可发现性和数据访问给前面的层。
- en: Integrating outputs from internal services such as in-house microservices and
    external services such as AWS cloud services.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成来自内部服务（例如内部微服务）和外部服务（例如AWS云服务）的输出。
- en: Merging data from different source types—for example, reading a base64-encoded
    message from one source and a JSON-encoded message from another source and then
    linking them together to form a unified data model.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同来源类型合并数据，例如，从一个来源读取base64编码的消息，从另一个来源读取JSON编码的消息，然后将它们链接在一起形成统一的数据模型。
- en: Encoding data to formats suitable for delivery to the users.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据编码为适合交付给用户的格式。
- en: Specifying role-based access to the data.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定基于角色的数据访问。
- en: '**The services layer:** This layer is composed of our external and internal
    services. It provides the raw data and functionality to the layers. These layers
    are composed of a set of deployable internal and external services. The services
    layer is where we would communicate with databases such as MySQL or DynamoDB;
    it''s where we would use third-party services such as AWS S3 or Twilio. This layer
    should be designed to be pluggable, meaning that we could easily add or remove
    services to it as we please.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务层：**这一层由我们的外部和内部服务组成。它为各层提供原始数据和功能。这些层由一组可部署的内部和外部服务组成。服务层是我们与数据库（如MySQL或DynamoDB）通信的地方；我们会在这里使用第三方服务，如AWS
    S3或Twilio。这一层应该被设计为可插拔的，这意味着我们可以随意地向其中添加或移除服务。'
- en: If we design our modern applications with the preceding architectural pattern,
    we will gain endless flexibility and scalability. For example, we can target new
    user device types in the client layer without needing to change much code in other
    layers. We can add or remove microservices or cloud services in the services layer
    without needing to change much code in the layers above it. We can support new
    encoding formats in the aggregation layer such as Thrift or protocol buffers without
    needing to change much code on the other layers. The four-tier engagement platform
    is currently being utilized by companies such as Netflix and Uber.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用上述的架构模式设计我们的现代应用程序，我们将获得无限的灵活性和可扩展性。例如，我们可以在客户端层针对新的用户设备类型，而无需在其他层中改变太多代码。我们可以在服务层中添加或移除微服务或云服务，而无需在其上层改变太多代码。我们可以在聚合层中支持新的编码格式，如Thrift或协议缓冲区，而无需在其他层上改变太多代码。四层参与平台目前正在被Netflix和Uber等公司使用。
- en: Bounded contexts in domain-driven designs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计中的有界上下文
- en: '**Domain-driven** **design **(**DDD**) is a popular design pattern that we
    can use to internally design microservices. Domain-driven design typically targets
    complex applications that are likely to grow exponentially over time. If your
    monolithic application was already designed via DDD, migrating to microservices
    architecture will be straightforward. Otherwise, if you are expecting the new
    microservices to grow in scope and complexity, then considering DDD may be a good
    idea.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）是一种流行的设计模式，我们可以用它来内部设计微服务。领域驱动设计通常针对可能会随着时间呈指数增长的复杂应用程序。如果您的单片应用程序已经通过DDD设计，那么迁移到微服务架构将是直接的。否则，如果您期望新的微服务在范围和复杂性上增长，那么考虑DDD可能是一个好主意。'
- en: Domain-driven design is a massive topic. The wikipedia article can be found
    at [https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design).
    However, for the purpose of this section, we will cover some brief concepts that
    can help us obtain practical understanding of DDD. Then, from there, you'll learn
    why this design approach is good for complex microservices architectures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计是一个庞大的主题。维基百科文章可以在[https://en.wikipedia.org/wiki/Domain-driven_design](https://en.wikipedia.org/wiki/Domain-driven_design)找到。然而，为了本节的目的，我们将介绍一些简要的概念，这些概念可以帮助我们获得对DDD的实际理解。然后，从那里，您将了解为什么这种设计方法对于复杂的微服务架构是有益的。
- en: The idea of domain-driven design is that a complex application should be considered
    to be functioning within a *domain*. A domain is simply defined as a sphere of
    knowledge or activity. The domain of our software application can be described
    as everything related to the purpose of the software. So, for example, if our
    software application's main goal is to facilitate planning social events, then
    planning social events becomes our domain.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 领域驱动设计的理念是，一个复杂的应用程序应该被视为在一个*领域*内运行。领域简单地定义为知识或活动的范围。我们软件应用程序的领域可以被描述为与软件目的相关的一切。因此，例如，如果我们软件应用程序的主要目标是促进社交活动的规划，那么规划社交活动就成为我们的领域。
- en: A domain contains *contexts*; each context would represent a logical piece of
    the domain, where people talk the same language. Language used within a context
    can only be understood based on the context from which it belongs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个域包含*上下文*；每个上下文代表域的一个逻辑部分，人们在其中使用相同的语言。在上下文中使用的语言只能根据它所属的上下文来理解。
- en: 'From my experience, it is difficult to understand what a context is without
    an example. So, let''s take a simple example. Assume that the organization that
    is behind the social events application is a large organization, with a sales
    department, a marketing department, and a support department. This means that
    the domain-driven design of this organization may need to include the following
    three main contexts: a sales context, a marketing context, and a support context.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，没有例子很难理解上下文是什么。所以，让我们举一个简单的例子。假设社交活动应用背后的组织是一个大型组织，拥有销售部门、营销部门和支持部门。这意味着这个组织的领域驱动设计可能需要包括以下三个主要上下文：销售上下文、营销上下文和支持上下文。
- en: Some of the language used by the sales people will only be relevant to the sales
    people. For example, the concepts of sales funnel, sales opportunity, or sales
    pipeline are very important to sales, but may not be relevant to the support department.
    That is why, a sales context can include the concept of a sales funnel, but you
    won't find that language or  concept in the support context much.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 销售人员使用的一些语言只对销售人员相关。例如，销售漏斗、销售机会或销售管道的概念对销售非常重要，但对支持部门可能并不相关。这就是为什么销售上下文可以包括销售漏斗的概念，但在支持上下文中你不会经常找到这种语言或概念。
- en: '![](img/9124a64c-1f1b-404b-829f-138e696490c4.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9124a64c-1f1b-404b-829f-138e696490c4.png)'
- en: The Domain
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 领域
- en: 'Domains also contain models. Each model is an abstraction that describes an
    independent concept in the domain. Models are what end up getting transformed
    into software modules or objects. Models typically live inside contexts. For example,
    in a sales context, we will need models to represent a sales contract, a sales
    funnel, a sales opportunity, the sales pipeline, and the customers among others,
    whereas in the support context, we need models to show tickets, customers, and
    defects. The following is a simple diagram showing some models inside the sales
    context and the support context:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 领域还包含模型。每个模型都是描述领域中独立概念的抽象。模型最终会被转化为软件模块或对象。模型通常存在于上下文中。例如，在销售上下文中，我们需要模型来表示销售合同、销售漏斗、销售机会、销售管道和客户等，而在支持上下文中，我们需要模型来显示工单、客户和缺陷。以下是一个简单的图表，显示了销售上下文和支持上下文中的一些模型：
- en: '![](img/44d6aaf1-7ead-42a0-8734-56590e1576e1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44d6aaf1-7ead-42a0-8734-56590e1576e1.png)'
- en: Sales and support contact
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 销售和支持上下文
- en: Different contexts can share the same language or concept, but focus on a different
    aspect of it. In our huge organization example, a word used by the sales people
    might not always mean the same word for the support people. For example, the word
    *customer* for sales represents a customer who is likely to buy a product from
    the organization, but hasn't done so just, yet. On the other hand, a customer
    for the support department is probably a customer who already bought the product,
    bought a support contract, and is suffering from some kind of issue with the product.
    So, both contexts share the concept of a customer; however, they care about different
    things when it comes to that concept.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的上下文可以共享相同的语言或概念，但关注不同的方面。在我们的大型组织示例中，销售人员使用的一个词可能并不总是对支持人员来说意味着相同的词。例如，对于销售部门来说，*客户*代表着一个可能从组织购买产品但尚未购买的客户。另一方面，对于支持部门来说，客户可能是已经购买产品、购买了支持合同并且正在遇到产品问题的客户。因此，这两个上下文共享客户的概念；然而，当涉及到这个概念时，它们关心的是不同的事情。
- en: 'The fact that the same language might mean different things in different contexts
    introduces one of the key ideas in the world of DDD, which is bounded contexts.
    Bounded contexts are contexts that share a concept, but then they implement their
    own models of that concept. For example, the concept of *customers* is represented
    by a model in the sales context, which reflects the version of customer that the
    sales department cares about. The concept of customers is also modeled in the
    support context according to their version of it. Although they are two models,
    they are still linked. That is because, at the end of the day, they both represent
    a customer for the social events planning company. The following is a simple diagram
    that shows what this would look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 同一种语言在不同环境中可能意味着不同的事情，这引入了领域驱动设计世界中的一个关键概念，即有界上下文。有界上下文是共享概念的上下文，但它们实现了自己的概念模型。例如，*客户*的概念在销售上下文中由一个模型表示，反映了销售部门关心的客户版本。客户的概念也根据支持上下文中的版本进行建模。虽然它们是两个模型，但它们仍然是相互关联的。这是因为，归根结底，它们都代表了社交活动策划公司的客户。以下是一个简单的图表，显示了这种情况：
- en: '![](img/39d9dcb0-771c-417f-8376-5d520ae9d179.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39d9dcb0-771c-417f-8376-5d520ae9d179.png)'
- en: Bounded sales and support contact
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 销售和支持上下文
- en: Contexts and Bounded contexts is where the worlds of domain-driver design and
    microservices start to meet. It is a key design factor when it comes to complex
    modern microservices, because contexts can map easily to microservices. If you
    try to define bounded contexts, you will find yourself not only defining what
    a microservice should be in practice, but also what information should be shared
    between microservices to form the overall application. A simple definition for
    a bounded context is that it's a self-contained logical block that is part of
    a bigger application. This same definition can be applied with no additions to
    describe a well-designed microservice. Sometimes, a bounded context can be divided
    into more than one  service, but that typically depends on the level of complexity
    of the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文和有界上下文是领域驱动设计和微服务相遇的地方。这是复杂现代微服务的关键设计因素，因为上下文可以很容易地映射到微服务。如果你试图定义有界上下文，你会发现自己不仅在实践中定义了微服务应该是什么，还在定义应该在微服务之间共享什么信息来构建整个应用程序。有界上下文的简单定义是它是一个作为更大应用程序一部分的自包含逻辑块。这个定义也可以毫无添加地应用于描述一个设计良好的微服务。有时，一个有界上下文可以被划分为多个服务，但这通常取决于应用程序的复杂程度。
- en: In our example here, we would then end up with a microservice that handles sales
    operations and a microservice that handles support operations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们最终会有一个处理销售操作的微服务和一个处理支持操作的微服务。
- en: If your monolithic application has been already designed with the DDD principles
    in mind, migrating to a microservices architecture gets easier. That is because
    transitioning from code that form the bounded contexts to self-containing microservices
    would make sense.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的单体应用程序已经根据DDD原则进行了设计，那么迁移到微服务架构会变得更容易。这是因为从形成界限上下文的代码过渡到自包含的微服务会是有意义的。
- en: If, on the other hand, your monolithic application is not designed this way,
    but the application is complex and growing, then DDD principles can be utilized
    to build future microservices.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您的单体应用程序没有以这种方式设计，但应用程序复杂且不断增长，那么可以利用DDD原则来构建未来的微服务。
- en: Data consistency
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据一致性
- en: 'The database that powers an application is a vital block that must be handled
    with extreme care and respect when migrating to a microservice architecture. In
    the world of monolithic applications, you would likely deal with a small number
    of databases (one or maybe two) that connects to your monolithic application through
    a fat data handling layer, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 支撑应用程序的数据库是一个至关重要的组成部分，在迁移到微服务架构时必须极其小心谨慎地处理和尊重。在单体应用程序的世界中，您可能会处理连接到单体应用程序的少量数据库（一个或两个）通过一个庞大的数据处理层，如下所示：
- en: '![](img/3866d74d-1919-4e48-bd36-f0ec9e61446c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3866d74d-1919-4e48-bd36-f0ec9e61446c.png)'
- en: Monolithic application with database
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序与数据库
- en: However, in the case of microservices and distributed cloud architectures, things
    can get wildly different. That is because the architecture will likely include
    a wider range of data models and database engines to serve the needs of the distributed
    microservices. Microservices can have their own databases, share databases with
    other applications, or make use of multiple databases at once. Data consistency
    and modeling in a modern microservices architecture are a nontrivial challenge
    that we need to tackle with good applications design before it gets out of control.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在微服务和分布式云架构的情况下，情况可能大不相同。这是因为架构可能包括更广泛的数据模型和数据库引擎，以满足分布式微服务的需求。微服务可以拥有自己的数据库，与其他应用程序共享数据库，或同时使用多个数据库。在现代微服务架构中，数据一致性和建模是一个非常棘手的挑战，我们需要在失控之前通过良好的应用程序设计来解决。
- en: '![](img/26f79828-f779-40ec-8730-d7f9d3ed3c27.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f79828-f779-40ec-8730-d7f9d3ed3c27.png)'
- en: In the following section, we'll discuss some strategies to keep in mind when
    breaking the data models from a monolithic application paradigm to microservices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将讨论一些策略，以便在从单体应用程序范式到微服务中打破数据模型时牢记。
- en: Event-driven architecture for data consistency
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据一致性的事件驱动架构
- en: A key design patterns that we can utilize to protect data consistency in a microservices
    architecture is an event-driven design. The reason why data consistency is difficult
    to maintain with microservices is that each microservice is typically responsible
    for a piece of data from the overall application. The sum of the data stores handled
    by the application's microservices represent the total state of the application.
    So, that means when a microservice updates its database, other microservices that
    are affected by this data change need to know about it so that they can take appropriate
    actions and update their own states.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用的关键设计模式之一，用于保护微服务架构中的数据一致性的是事件驱动设计。微服务中数据一致性难以维护的原因是，每个微服务通常负责整个应用程序的一部分数据。应用程序微服务处理的数据存储的总和代表了应用程序的总状态。因此，这意味着当一个微服务更新其数据库时，受此数据更改影响的其他微服务需要知道这一点，以便它们可以采取适当的行动并更新自己的状态。
- en: Let's take the sales and support microservices example from the bounded context
    section of this chapter. In the event that a new customer buys a product, the
    sales microservice will need to update its own database to reflect the new customer
    status as an actual paying customer instead of just a potential customer. This
    event will also need to be communicated to the support microservice so that it
    can update its own database to reflect the fact that there is a new paying customer
    who deserves customer or technical support whenever needed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以本章的界限上下文部分中的销售和支持微服务示例为例。如果一个新客户购买了产品，销售微服务将需要更新自己的数据库，以反映新客户的状态，即实际付费客户，而不仅仅是潜在客户。这个事件还需要通知支持微服务，以便它可以更新自己的数据库，以反映有一个新的付费客户，无论何时需要都应该得到客户或技术支持。
- en: This kind of event communication between microservices is what event-driven
    design is about in the world of microservices. A message queue or a message broker
    between the microservices can be utilized to communicate event messages between
    microservices. Message brokers were discussed in detail in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*. Microservices
    that need to be notified whenever a certain event happens will have to subscribe
    to those events.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种微服务之间的事件通信就是微服务世界中的事件驱动设计。微服务之间的消息队列或消息代理可以用来在微服务之间通信事件消息。消息代理在[第4章](0a806398-0654-46f9-8e6f-02af9334821b.xhtml)中详细讨论，*使用消息队列的异步微服务架构*。需要在某个事件发生时通知的微服务将必须订阅这些事件。
- en: '![](img/e3f1de3a-32a3-41a1-a6a4-84b5641089af.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3f1de3a-32a3-41a1-a6a4-84b5641089af.png)'
- en: For example, the support service will need to subscribe to the event topic on
    the message queue that represents a customer buying the product. The sales microservice
    then triggers this event whenever a customer buys the product. Since the support
    service is subscribed to that event, it will receive the notification of the event
    shortly after, which will include the new customer's information. From there,
    the support service will be able to carry out its own logic to ensure that the
    support organization is ready for that customer whenever help is needed or even
    maybe trigger a welcome email for the new customer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，支持服务将需要订阅消息队列上代表客户购买产品的事件主题。销售微服务在客户购买产品时触发此事件。由于支持服务订阅了该事件，它将在不久后收到事件的通知，其中将包括新客户的信息。从那里，支持服务将能够执行自己的逻辑，以确保支持组织随时为客户提供帮助，甚至可能为新客户触发欢迎邮件。
- en: Now, this all sounds good, but what if the support microservice fails before
    it can receive the new customer event? This means that the support service will
    end up not knowing about the new customer, and hence it will not apply any logic
    to add the relevant information about the new customer into the support database.
    Does that mean when the customer calls later for help, the support team won't
    help because they don't see the customer in their system? Obviously, we don't
    want that to happen. One approach would be to have a central database that stores
    customer data, which would be shared between different microservices, but what
    if we seek a flexible design where each  microservice is fully responsible for
    it's entire state. This is where the concepts of event sourcing and CQRS come
    into the picture.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这听起来都很好，但如果支持微服务在接收新客户事件之前失败了怎么办？这意味着支持服务最终将不知道新客户的情况，因此不会对新客户的相关信息进行任何逻辑处理，也不会将其添加到支持数据库中。这是否意味着当客户以后寻求帮助时，支持团队不会帮助，因为他们在系统中看不到客户？显然，我们不希望发生这种情况。一种方法是拥有一个存储客户数据的中央数据库，该数据库将在不同的微服务之间共享，但如果我们寻求一种灵活的设计，每个微服务都完全负责自己的整个状态，该怎么办。这就是事件溯源和CQRS概念出现的地方。
- en: Events sourcing
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源
- en: The basic idea behind event sourcing is that instead of fully relying on a local
    database to read the state, we need to make use of a recorded stream of events
    to form the state. To make that work, we will need to store all current and past
    events so that we can retrieve them at a later time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的基本思想是，我们需要利用记录的事件流来形成状态，而不是完全依赖于本地数据库来读取状态。为了使其工作，我们需要存储所有当前和过去的事件，以便以后可以检索它们。
- en: We need an example to solidify this theoretical definition. Let's say that the
    support service had failed and crashed before it could receive the new customer
    event. If the support service doesn't use event sourcing, then when it restarts,
    it will not find the customer information in its own database and will never know
    about the customer. However, if it uses event sourcing, then instead of only looking
    at its local database, it will look at an event store which is shared with all
    the other microservices. The event store will record any event that was ever triggered
    between our microservices. In that event store, the support service will be able
    to replay the new customer event that got triggered recently and will see that
    this customer doesn't currently exist in the local support microservice database.
    The support service can then take this information and process it as normal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个例子来巩固这个理论定义。假设支持服务在接收新客户事件之前失败并崩溃了。如果支持服务不使用事件溯源，那么当它重新启动时，它将在自己的数据库中找不到客户信息，也永远不会知道这个客户。然而，如果它使用事件溯源，那么它不仅会查看本地数据库，还会查看与所有其他微服务共享的事件存储。事件存储将记录我们的微服务之间触发的任何事件。在事件存储中，支持服务将能够重放最近触发的新客户事件，并且会发现这个客户目前不存在于本地支持微服务数据库中。支持服务可以将这些信息处理为正常情况。
- en: 'Again, a key trick for this design to work is to never discard any events,
    past or new. This is achieved by saving them in an event store; here is what this
    would look like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种设计能够成功的关键技巧是永远不要丢弃任何事件，无论是过去的还是新的。这是通过将它们保存在事件存储中来实现的；以下是它的样子：
- en: '![](img/2b39e000-6ae9-46f8-abcb-9d68c15174f3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b39e000-6ae9-46f8-abcb-9d68c15174f3.png)'
- en: There are multiple ways to implement an event store; it can be a SQL database,
    a NoSQL database, or even a message queue that supports having events saved forever.
    Kafka is an example of a message queue that claims to also be a good engine for
    event sourcing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事件存储有多种方法；它可以是SQL数据库、NoSQL数据库，甚至是支持永久保存事件的消息队列。Kafka就是一个消息队列的例子，它声称也是事件溯源的良好引擎。
- en: There are multiple approaches to tackling event sourcing; the scenario that
    we covered in this section represented an approach where we use event stores with
    snapshots. A snapshot in this case was the support microservice local database,
    which also tried to keep a snapshot state. However, the ultimate state was still
    expected to be in the event store.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件溯源有多种方法；我们在本节中涵盖的场景代表了一种使用事件存储和快照的方法。在这种情况下，快照是支持微服务本地数据库，它也试图保持快照状态。然而，最终状态仍然预期在事件存储中。
- en: There are other approaches to implementing event sourcing, where no snapshots
    are used and the entire state always has to be derived from the event store.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他实现事件溯源的方法，其中不使用快照，整个状态始终必须从事件存储中派生。
- en: The disadvantage of event sourcing is that it can grow exponentially in complexity.
    That is because in some environments, we may need to replay tons of events in
    order to build the current state of the system, which requires a lot of processing
    and complexity. The queries we need to run in order to form data models that join
    data from different replay events can easily become painful.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源的缺点是它可能在复杂性上呈指数级增长。这是因为在某些环境中，我们可能需要重放大量事件，以构建系统的当前状态，这需要大量的处理和复杂性。我们需要运行的查询以形成从不同重放事件中联接数据的数据模型可能会变得非常痛苦。
- en: A popular approach to control the complexity of event sourcing is CQRS.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 控制事件溯源复杂性的一种流行方法是CQRS。
- en: CQRS
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS
- en: The basic idea behind **Command Query Responsibility Segregation** (**CQRS**) is
    that commands—which means any operations related to changing data such as add,
    updates, or deletes—should be separated from queries—which are any operations
    related to reading data. In a microservices architecture, that may mean that some
    services should be responsible for commands, whereas others are responsible for
    querying.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令查询责任分离**（**CQRS**）的基本理念是，命令（指与更改数据相关的任何操作，如添加、更新或删除）应该与查询（指与读取数据相关的任何操作）分开。在微服务架构中，这意味着一些服务应该负责命令，而其他服务应该负责查询。'
- en: A key advantage of CQRS is separation of concerns. That is because we separate
    write concerns from read concerns and allow them to scale independently. For example,
    let's say that we work with a complex application where we need different view
    models of our data to be available. We would like to store all customer data in
    an elastic search cluster in order to be able to efficiently search for them and
    retrieve their information. At the same time, we would like to store all the customer
    data in a graph database because we would like a graph view of the data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS的一个关键优势是关注点的分离。这是因为我们将写入关注点与读取关注点分开，并允许它们独立扩展。例如，假设我们使用一个复杂的应用程序，我们需要不同的数据视图可用。我们希望将所有客户数据存储在弹性搜索集群中，以便能够高效地搜索并检索它们的信息。与此同时，我们希望将所有客户数据存储在图数据库中，因为我们希望以图形方式查看数据。
- en: In this case, we will create micrservices that are responsible for querying
    the customer events from the events stream (message queue) and then updating elastic
    search and the graph database whenever a new customer event is received via event
    sourcing. Those services will be the querying part of CQRS. On the other hand,
    we'll have other microservices that are responsible for triggering new events
    whenever needed. Those services will end up being the command part of CQRS.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将创建微服务，负责从事件流（消息队列）中查询客户事件，然后通过事件溯源在接收到新的客户事件时更新弹性搜索和图数据库。这些服务将成为CQRS的查询部分。另一方面，我们将有其他微服务负责在需要时触发新事件。这些服务最终将成为CQRS的命令部分。
- en: '![](img/3211dba1-7403-49a0-b56a-c008bd94cfd5.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3211dba1-7403-49a0-b56a-c008bd94cfd5.png)'
- en: Those read and write microservices can then work with the rest of our services
    to form our application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些读写微服务然后可以与我们的其他服务一起工作，形成我们的应用程序。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dove deeper into the practical aspects of migrating from
    monolithic applications to microservices applications. We had a close look at
    some advanced design patterns and architectures that we can utilize to our benefit
    in order to switch from monolithic applications to microservices applications.
    This chapter concludes our learning journey for this book.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了从单体应用程序迁移到微服务应用程序的实际方面。我们仔细研究了一些高级设计模式和架构，可以利用它们来从单体应用程序切换到微服务应用程序。本章结束了我们对本书的学习之旅。
- en: In the next chapter, we'll discuss some technologies and topics that you can
    start exploring after acquiring the knowledge contained within this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些技术和主题，您可以在掌握本书中的知识后开始探索。
