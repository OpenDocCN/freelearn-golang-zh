- en: Where to Go from Here?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来该去哪里？
- en: Welcome to the last chapter in our journey to learning cloud native programming
    in the Go language. By now, you should have enough knowledge to build production
    grade microservices, design complex distributed architectures, utilize the power
    of key Amazon web services, empower your software with containers, among other
    things.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们学习Go语言云原生编程的最后一章。到目前为止，你应该已经掌握了足够的知识来构建生产级别的微服务，设计复杂的分布式架构，利用亚马逊云服务的强大功能，为你的软件赋予容器的力量，等等。
- en: However, the subject of cloud native programming is a very deep and massive
    one. This means that there are topics that you can still learn to enrich your
    knowledge and skills in that area. The purpose of this chapter is to light a path
    for you from where this book leaves off, by providing some practical overviews
    of topics not covered in this book that are strong avenues to pursue after you
    absorb the knowledge contained in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，云原生编程的主题非常深入和广泛。这意味着你仍然可以学习一些主题，丰富你在这个领域的知识和技能。本章的目的是为你提供一些实用的概述，让你在吸收了本书中的知识之后，能够继续探索一些本书未涵盖的强大主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Additional microservice communication patterns and protocols, such as Protocol
    Buffers and GRPC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他微服务通信模式和协议，比如协议缓冲区和GRPC
- en: More useful features offered by cloud providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云提供商提供的更多有用功能
- en: Other cloud providers (Azure, GCP, and OpenStack)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他云提供商（Azure、GCP和OpenStack）
- en: Serverless Computing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器计算
- en: Microservices communications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务通信
- en: 'In this book, we covered two approaches for microservices to communicate with
    each other:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们涵盖了微服务相互通信的两种方法：
- en: The first approach was via RESTful APIs, where a web HTTP layer would be built
    into a microservice, effectively allowing the microservice to communicate with
    any web client, whether the web client is another microservice or a web browser.
    One advantage to this approach is that it empowers microservices to communicate
    with the outside world when needed, since HTTP is now a universal protocol that
    is supported by all software stacks out there. The disadvantage of this approach,
    however, is the fact that HTTP can be a heavy protocol with multiple layers, which
    may not be the best choice when the requirement is fast efficient communications
    between internal microservices.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是通过RESTful API，其中一个Web HTTP层将被构建到一个微服务中，有效地允许微服务与任何Web客户端进行通信，无论这个Web客户端是另一个微服务还是一个Web浏览器。这种方法的一个优点是它赋予了微服务在需要时与外部世界通信的能力，因为HTTP现在是一个被所有软件堆栈支持的通用协议。然而，这种方法的缺点是HTTP可能是一个具有多层的重型协议，在内部微服务之间需要快速高效的通信时可能不是最佳选择。
- en: The second approach is via message queues, where a message broker software such
    as RabbitMQ or Kafka will facilitate the exchange of messages between microservices.
    Message brokers receive messages from sending microservices, queue the messages,
    and then deliver them to microservices that previously indicated their interests
    in those messages. One major advantage of this approach is the fact that it can
    solidify data consistency in large-scale distributed microservices architectures,
    as explained in [Chapter 11](1b9e8bd9-c7a6-46ce-87f7-d45631865e07.xhtml), *Migration*.
    This approach enables event-driven distributed architectures, such as event sourcing
    and CQRS. However, if our scaling requirements are relatively simple in scope,
    this approach may be too complex for our needs. This is because it requires us
    to maintain a message broker software with all its configurations and backends.
    In those cases, direct microservice to microservice communication may be all what
    we need.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是通过消息队列，其中消息代理软件（如RabbitMQ或Kafka）将促进微服务之间的消息交换。消息代理接收来自发送微服务的消息，将消息排队，然后将其传递给之前表明对这些消息感兴趣的微服务。这种方法的一个主要优势是它可以巩固大规模分布式微服务架构中的数据一致性，如[第11章](1b9e8bd9-c7a6-46ce-87f7-d45631865e07.xhtml)
    *迁移*中所解释的那样。这种方法使得事件驱动的分布式架构成为可能，比如事件溯源和CQRS。然而，如果我们的扩展需求相对简单，这种方法可能对我们的需求来说过于复杂。这是因为它要求我们维护一个带有所有配置和后端的消息代理软件。在这些情况下，直接的微服务之间的通信可能就是我们所需要的一切。
- en: 'If you haven''t noted already, one obvious disadvantage for either of those
    approaches is the fact that they don''t offer direct efficient microservice to
    microservice communications. There are two popular choices for technologies that
    we can employ for direct microservices communications: Protocol buffers and GRPC.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注意到，这两种方法的一个明显的缺点是它们都不能提供直接高效的微服务之间的通信。我们可以采用两种流行的技术来实现直接的微服务通信：协议缓冲区和GRPC。
- en: Protocol buffers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲区
- en: In their official documentations, protocol buffers are defined as a language-neutral,
    platform-neutral mechanism for serializing structured data. Let's take a look
    at an example to help build a clear picture of what protocol buffers are.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们的官方文档中，协议缓冲区被定义为一种语言中立、平台中立的序列化结构化数据的机制。让我们看一个例子，帮助建立协议缓冲区是什么的清晰图景。
- en: Assume that you have two microservices in your application; the first microservice
    (service 1) has collected information about a new customer and would like to send
    it to the second microservice (service 2). This data is considered structured
    data because it contains structured information such as the customer name, age,
    job, and phone numbers. One way to send this data is to send it as a JSON document
    (our data format) over HTTP from service 1 to service 2\. However, what if we
    want to send this data faster and in a smaller form? This is where protocol buffers
    come into the picture. Inside service 1, protocol buffers will take the customer
    object, then serialize it into a compact form. From there, we can take this encoded
    compact piece of data and send it to service 2 via an efficient communications
    protocol such as TCP or UDP.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序中有两个微服务；第一个微服务（服务1）已经收集了有关新客户的信息，并希望将其发送给第二个微服务（服务2）。这些数据被视为结构化数据，因为它包含结构化信息，如客户姓名、年龄、工作和电话号码。发送这些数据的一种方式是将其作为JSON文档（我们的数据格式）通过HTTP从服务1发送到服务2。然而，如果我们想更快地以更小的形式发送这些数据呢？这就是协议缓冲区的作用。在服务1内部，协议缓冲区将获取客户对象，然后将其序列化为紧凑形式。然后，我们可以将这个编码后的紧凑数据发送到服务2，通过高效的通信协议，如TCP或UDP。
- en: Note that we described protocol buffers as inside the service in the preceding
    example. This is true because protocol buffers come as software libraries that
    we can import and include in our code. There are protocol buffer packages for
    a wide selection of programming languages (Go, Java, C#, C++, Ruby, Python, and
    more).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的例子中，我们将协议缓冲区描述为服务内部。这是因为协议缓冲区是作为软件库提供的，我们可以导入并包含在我们的代码中。有许多编程语言的协议缓冲区包（Go、Java、C#、C++、Ruby、Python等）。
- en: 'The way how protocol buffers work is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区的工作方式如下：
- en: You define your data in a special file, known as the `proto` file.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在一个特殊的文件中定义您的数据，称为`proto`文件。
- en: You use a piece of software known as the protocol buffer compiler to compile
    the proto file into code files written in the programming language of your choice.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用一个名为协议缓冲区编译器的软件来将proto文件编译成您选择的编程语言的代码文件。
- en: You use the generated code files combined with the protocol buffer software
    package in your language of choice to build your software.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用生成的代码文件与您选择的编程语言的协议缓冲区软件包结合起来构建您的软件。
- en: This is protocol buffers in a nutshell. In order to obtain more deep understanding
    of protocol buffers, go to [https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/),
    where you will find good documentation to get you started with the technology.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是协议缓冲区的要点。要更深入地了解协议缓冲区，请访问[https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/)，那里有很好的文档可以帮助您开始使用这项技术。
- en: 'There are currently two commonly used versions for protocol buffers: protocol
    buffers 2 and protocol buffers 3\. A lot of the current training resources available
    online cover the newest version, Protocol Buffers 3\. If you are looking for a
    resource to help with protocol buffers version 2, you can check this article in
    my website at [http://www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/](http://www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有两个常用的协议缓冲区版本：协议缓冲区2和协议缓冲区3。当前在线可用的大部分培训资源都覆盖了最新版本，协议缓冲区3。如果您正在寻找协议缓冲区版本2的资源，您可以在我的网站上查看这篇文章[http://www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/](http://www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/)。
- en: GRPC
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GRPC
- en: One key feature missing from the protocol buffers technology is the communications
    part. Protocol buffers excel at encoding and serializing data into compact forms
    that we can share with other microservices. However, when the concept of Protocol
    buffers was initially conceived, only serialization was considered, but not the
    part where we actually send the data elsewhere. For that, developers used to roll
    their sleeves and implement their own TCP or UDP application layer to exchange
    the encoded data between services. However, what if we can't spare the time and
    effort to worry about an efficient communication layer? This is where GRPC comes
    into picture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区技术缺少的一个关键特性是通信部分。协议缓冲区擅长将数据编码和序列化为紧凑形式，以便与其他微服务共享。然而，当协议缓冲区的概念最初被构想时，只考虑了序列化，而没有考虑实际将数据发送到其他地方的部分。因此，开发人员过去常常需要自己动手实现TCP或UDP应用层来在服务之间交换编码数据。然而，如果我们没有时间和精力来担心一个高效的通信层呢？这就是GRPC的作用。
- en: GRPC can simply be described as protocol buffers combined with an RPC layer
    on top. A **Remote Procedure Call** (**RPC**) layer is a software layer that allows
    different piece of software such as microservices to interact via an efficient
    communications protocol such as TCP. With GRPC, your microservice can serialize
    your structured data via protocol buffers version 3 and then will be able to communicate
    this data with other microservices without you having to worry about implementing
    a communications layer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC可以简单地描述为在协议缓冲区之上加上一个RPC层。**远程过程调用**（**RPC**）层是一种软件层，允许不同的软件部分，如微服务，通过高效的通信协议（如TCP）进行交互。使用GRPC，您的微服务可以通过协议缓冲区版本3序列化您的结构化数据，然后能够与其他微服务通信，而无需担心实现通信层。
- en: If your application architecture needs efficient and fast interactions between
    your microservices, and at the same time you can't use message queues or Web APIs,
    then consider GRPC for your next application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序架构需要微服务之间的高效快速交互，同时又不能使用消息队列或Web API，那么请考虑在下一个应用程序中使用GRPC。
- en: To get started with GRPC, visit [https://grpc.io/](https://grpc.io/). Similar
    to protocol buffers, GRPC is supported by a wide range of programming languages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用GRPC，请访问[https://grpc.io/](https://grpc.io/)。与协议缓冲区类似，GRPC支持多种编程语言。
- en: More on AWS
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于AWS
- en: In this book, we dedicated two chapters to providing a practical dive into AWS
    fundamentals, with a focus on how to write Go microservices that would site comfortably
    on Amazon's cloud. However, AWS is a very deep topic that deserves an entire book
    to cover it as opposed to just a few chapters. In this section, we will provide
    brief overviews on some useful AWS technologies that we didn't get a chance to
    cover in this book. You can use the following section as an introduction for your
    next steps in learning AWS.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们专门介绍了AWS基础知识的两章内容，重点介绍了如何编写能够轻松适应亚马逊云的Go微服务。然而，AWS是一个非常深入的话题，值得一整本书来覆盖，而不仅仅是几章。在本节中，我们将简要介绍一些有用的AWS技术，这些技术我们在本书中没有涉及到。您可以将以下部分作为学习AWS的下一步的介绍。
- en: DynamoDB streams
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DynamoDB流
- en: In [Chapter 8](25f18fd2-4d08-41fb-a8b2-acc927bd0876.xhtml), *AWS II - S3, SQS,
    API Gateway, and DynamoDB,* we covered the popular AWS DynamoDB service. We learned
    what DynamoDB is, how it models data, and how to write Go applications that can
    harness DynamoDB's power.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](25f18fd2-4d08-41fb-a8b2-acc927bd0876.xhtml)中，*AWS II - S3、SQS、API Gateway和DynamoDB*，我们介绍了流行的AWS
    DynamoDB服务。我们了解了DynamoDB是什么，它如何对数据进行建模，以及如何编写能够利用DynamoDB功能的Go应用程序。
- en: There is one powerful feature of DynamoDB that we didn't get a chance to cover
    in this book, which is known as DynamoDB streams. DynamoDB streams allow us to
    capture changes that happen to items in a DynamoDB table, at the same time the
    change occurs. In practice, this means that we can react to data changes that
    happen to the database in real time. As usual, let's take an example to solidify
    the meaning.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，有一个强大的DynamoDB功能我们没有机会介绍，那就是DynamoDB流。DynamoDB流允许我们捕获DynamoDB表中项目发生的更改，同时发生更改。实际上，这意味着我们可以实时地对数据库中发生的数据更改做出反应。和往常一样，让我们举个例子来巩固其含义。
- en: Assume that we are building the cloud native distributed microservices application
    that powers a large multiplayer game. Let's say that we use DynamoDB as the database
    backend for our application and that one of our microservices added a new player
    to the database. If we are utilizing DynamoDB streams in our application, other
    interested microservices will be able to capture the new player information shortly
    after it gets added. This allows the other microservices to act accordingly with
    this new information. For instance, if one of the other microservices is responsible
    for locating players in the game map, it will then attach the new player to a
    start location on the game map.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建云原生分布式微服务应用程序，为大型多人游戏提供支持。假设我们使用DynamoDB作为应用程序的数据库后端，并且我们的某个微服务向数据库添加了新玩家。如果我们在应用程序中使用DynamoDB流，其他感兴趣的微服务将能够在新玩家添加后不久捕获新玩家的信息。这使得其他微服务可以根据这些新信息采取相应的行动。例如，如果其中一个其他微服务负责在游戏地图中定位玩家，它将把新玩家附加到游戏地图上的起始位置。
- en: The way DynamoDB streams work is simple. They capture changes that happen to
    a DynamoDB table item in order. The information gets stored in a log that goes
    up to 24 hours. Other applications written by us can then access this log and
    capture the data changes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB流的工作方式很简单。它们按顺序捕获发生在DynamoDB表项上的更改。信息被存储在一个长达24小时的日志中。我们编写的其他应用程序可以访问此日志并捕获数据更改。
- en: In other words, if an item gets created, deleted, or updated, DynamoDB streams
    would store the item primary key and the data modification that occurred.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果一个项目被创建、删除或更新，DynamoDB流将存储项目的主键和发生的数据修改。
- en: DynamoDB streams need to be enabled on tables that need monitoring. We can also
    disable DynamoDB streams on existing tables, if, for any reason, the tables don't
    need any more monitoring. DynamoDB streams operate in parallel to the DynamoDB
    tables, which basically means that there are no performance impact to using them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在需要监控的表上启用DynamoDB流。如果由于任何原因，表不再需要监控，我们也可以在现有表上禁用DynamoDB流。DynamoDB流与DynamoDB表并行操作，这基本上意味着使用它们不会对性能产生影响。
- en: To get started with DynamoDB streams, check out [http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用DynamoDB流，请查看[http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html)。
- en: To get started with DynamoDB streams support in the Go programming language,
    check out [https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodbstreams/](https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodbstreams/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Go编程语言中的DynamoDB流支持，请查看[https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodbstreams/](https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodbstreams/)。
- en: Autoscaling on AWS
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS上的自动扩展
- en: Due to the fact that AWS is designed from the grounds up to be utilized with
    massively distributed microservices applications, AWS comes with built-in features
    to allow developers of these huge applications to autoscale their applications
    in the cloud with the least manual intervention possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于AWS从一开始就设计用于与大规模分布式微服务应用程序一起使用，AWS具有内置功能，允许这些大型应用程序的开发人员在云中自动扩展其应用程序，尽可能少地进行手动干预。
- en: 'In the world of AWS, the word autoscaling means three main things:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS的世界中，自动扩展这个词有三个主要含义：
- en: The ability to automatically replace unhealthy applications or bad EC2 instances
    without your intervention.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够自动替换不健康的应用程序或不良的EC2实例，无需您的干预。
- en: The ability to automatically create new EC2 instances to handle increased loads
    on your microservices application without your intervention. Then, the ability
    to shut down EC2 instances when the application loads decrease.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够自动创建新的EC2实例来处理微服务应用程序的增加负载，无需您的干预。然后，能够在应用程序负载减少时关闭EC2实例。
- en: The ability to automatically increase cloud service resources available for
    your application, when the application loads increase. AWS cloud resources here
    go beyond just EC2\. An example of a cloud service resource that can go automatically
    up or down according to your need is DynamoDB read and write throughput.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序负载增加时，自动增加可用于应用程序的云服务资源的能力。AWS云资源不仅限于EC2。根据您的需求，可以自动增加或减少的云服务资源的一个示例是DynamoDB读取和写入吞吐量。
- en: 'To serve this broad definition of autoscaling, the AWS autoscaling service
    offers three main features:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足自动缩放的广泛定义，AWS自动缩放服务提供了三个主要功能：
- en: '**Fleet management for EC2 instances**: This feature allows you to monitor
    the health of running EC2 instances, automatically replaces bad instances without
    manual intervention, and balances Ec2 instances across multiple zones when multiple
    zones are configured.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2实例的车队管理：此功能允许您监视运行中的EC2实例的健康状况，自动替换不良实例而无需手动干预，并在配置了多个区域时在多个区域之间平衡Ec2实例。
- en: '**Dynamic Scaling**: This feature allows you to first configure tracking policies
    to engage the amount of load on your applications. For example, monitor CPU utilization
    or capture the number of incoming requests. Then, the dynamic scaling feature
    can automatically add or remove EC2 instances based on your configured target
    limits.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态缩放：此功能允许您首先配置跟踪策略，以调整应用程序的负载量。例如，监视CPU利用率或捕获传入请求的数量。然后，动态缩放功能可以根据您配置的目标限制自动添加或删除EC2实例。
- en: '**Application Auto Scaling**: This feature allows you to dynamically scale
    resources on AWS services that go beyond EC2, based on your application''s needs.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序自动缩放：此功能允许您根据应用程序的需求动态扩展超出EC2的AWS服务资源。
- en: To get started with the AWS autoscaling services, visit [https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/.).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用AWS自动缩放服务，请访问[https://aws.amazon.com/autoscaling/](https://aws.amazon.com/autoscaling/)。
- en: Amazon Relational Database Service
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊关系数据库服务
- en: 'In [Chapter 8](25f18fd2-4d08-41fb-a8b2-acc927bd0876.xhtml), *AWS II - S3, SQS,
    API Gateway, and DynamoDB*, when we covered the database service in the AWS world,
    we covered DynamoDB exclusively. DynamoDB is a managed NoSQL database service
    that is offered by Amazon on AWS. If you have enough technical expertise with
    database engines, you would probably ask the obvious question: what about relational
    databases? Shouldn''t there be a managed AWS service for that as well?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](25f18fd2-4d08-41fb-a8b2-acc927bd0876.xhtml)中，*AWS II - S3、SQS、API Gateway和DynamoDB*，当我们涵盖AWS世界中的数据库服务时，我们专门涵盖了DynamoDB。
    DynamoDB是亚马逊在AWS上提供的托管NoSQL数据库服务。如果您对数据库引擎有足够的技术专长，您可能会问一个显而易见的问题：关系数据库呢？难道也不应该有一个托管的AWS服务吗？
- en: The answer for the previous two questions is yes, there is, and it's called
    **Amazon Relational Database Service** (**RDS**). AWS RDS allows developers to
    easily configure, operate, scale, and deploy a relational database engine on the
    cloud.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个问题的答案是肯定的，它被称为Amazon关系数据库服务（RDS）。 AWS RDS允许开发人员轻松在云上配置、操作、扩展和部署关系数据库引擎。
- en: Amazon RDS supports a collection of well-known relational database engines that
    a lot of developers use and love. This includes PostgreSQL, MySQL, MariaDB, Oracle,
    and Microsoft SQL server. In addition to RDS, Amazon offers a service known as
    Database Migration service that allows you to easily migrate or replicate your
    existing database to Amazon RDS.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon RDS支持许多开发人员使用和喜爱的知名关系数据库引擎。这包括PostgreSQL、MySQL、MariaDB、Oracle和Microsoft
    SQL Server。除了RDS，亚马逊还提供一个名为数据库迁移服务的服务，允许您轻松地将现有数据库迁移到Amazon RDS或复制到Amazon RDS。
- en: To get started on AWS RDS, visit [https://aws.amazon.com/rds/](https://aws.amazon.com/rds/).
    To build Go applications capable of interacting with RDS, visit [https://docs.aws.amazon.com/sdk-for-go/api/service/rds/](https://docs.aws.amazon.com/sdk-for-go/api/service/rds/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用AWS RDS，请访问[https://aws.amazon.com/rds/](https://aws.amazon.com/rds/)。要构建能够与RDS交互的Go应用程序，请访问[https://docs.aws.amazon.com/sdk-for-go/api/service/rds/](https://docs.aws.amazon.com/sdk-for-go/api/service/rds/)。
- en: Other cloud providers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他云提供商
- en: Up until now, we have focused on AWS as a cloud provider. Of course, there are
    other providers that offer similar services, the two biggest being the Microsoft
    Azure Cloud and the Google Cloud Platform. Besides these, there are many other
    providers that also offer IaaS solutions, more often than not based on the open
    source platform OpenStack.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于AWS作为云提供商。当然，还有其他提供商提供类似的服务，其中最大的两个是微软Azure云和谷歌云平台。除此之外，还有许多其他提供商也提供基于开源平台OpenStack的IaaS解决方案。
- en: All cloud providers employ similar concepts, so if you have experience with
    one of them, you will probably find your way around others. For this reason, we
    decided not to cover each of them in depth within this book, but instead focus
    on AWS and give you a short outlook on other providers and how they are different.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有云提供商都采用类似的概念，因此如果您对其中一个有经验，您可能会在其他云提供商中找到自己的路。出于这个原因，我们决定不在本书中深入涵盖它们中的每一个，而是专注于AWS，并简要展望其他提供商以及它们的不同之处。
- en: Microsoft Azure
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微软Azure
- en: 'You can sign up for the Azure cloud on [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
    Like AWS, Azure offers multiple regions and availability zones in which you can
    run your services. Also, most of the Azure core services work similar to AWS,
    although they often are named differently:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)上注册Azure云。与AWS一样，Azure提供多个区域和可用性区域，您可以在其中运行您的服务。此外，大多数Azure核心服务的工作方式类似于AWS，尽管它们通常被命名为不同的名称：
- en: The service managing virtual machines (EC2 in AWS terms) is called just that, **virtual
    machines**. When creating a virtual machine, you will need to select an image
    (both Linux and Windows images are supported), provide an SSH public key, and
    choose a machine size. Other core concepts are named similarly. You can configure
    network access rules using **Network Security Groups**, loadbalance traffic using **Azure
    Load Balancers** (named Elastic Load Balancer in AWS), and manage automatic scaling
    using **VM Scale Sets**.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理虚拟机的服务（在AWS术语中为EC2）就是**虚拟机**。创建虚拟机时，您需要选择一个镜像（支持Linux和Windows镜像），提供一个SSH公钥，并选择一个机器大小。其他核心概念的命名方式类似。您可以使用**网络安全组**配置网络访问规则，使用**Azure负载均衡器**（在AWS中称为弹性负载均衡器）负载平衡流量，并使用**VM规模集**管理自动扩展。
- en: Relational databases (managed by the Relational Database Service in AWS) are
    managed by **Azure SQL Databases**. However, at the time of writing this book,
    only Microsoft SQL databases are supported. Support for MySQL and PostgreSQL databases
    is available as a preview service only.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库（由AWS的关系数据库服务管理）由**Azure SQL数据库**管理。但是，在撰写本书时，仅支持Microsoft SQL数据库。对MySQL和PostgreSQL数据库的支持仅作为预览服务提供。
- en: NoSQL databases, similar to DynamoDB, are available in the form of the **Azure
    Cosmos DB**.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于DynamoDB的NoSQL数据库以**Azure Cosmos DB**的形式提供。
- en: Message Queues similar to the Simple Queue Service are provided by the **Queue
    Storage** service.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供类似于简单队列服务的消息队列服务的是**队列存储**服务。
- en: Access to APIs provided by your services is possible using the **Application
    Gateway**.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用**应用程序网关**访问您的服务提供的API。
- en: 'To consume Azure services from within your Go application, you can use the **Azure
    SDK for Go**, which is available at [https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go).
    You can install it using the usual `go get` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Go应用程序中使用Azure服务，可以使用**Azure SDK for Go**，可在[https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go)上获得。您可以使用通常的`go
    get`命令进行安装：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Azure SDK for Go is currently still under heavy development and should be
    used with caution. To not be surprised by any breaking changes in the SDK, ensure
    that you use a dependency management tool such as *Glide* to put a version of
    this library into your vendor/directory (as you learned in [Chapter 9](465ef76f-a2b2-42f7-b9c4-3c60ac552f77.xhtml),
    *Continuous Delivery*).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SDK for Go目前仍在积极开发中，应谨慎使用。为了不受SDK中的任何重大更改的影响，请确保使用依赖管理工具（如*Glide*）将此库的一个版本放入您的*vendor/directory*中（正如您在[第9章](465ef76f-a2b2-42f7-b9c4-3c60ac552f77.xhtml)中学到的，*持续交付*）。
- en: Google Cloud Platform
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: 'The **Google Cloud Platform** (**GCP**) is the IaaS offering by Google. You
    can sign up at [https://console.cloud.google.com/freetrial](https://console.cloud.google.com/freetrial).
    Just as with the Azure cloud, you will recognize many core features, although
    differently named:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Platform**（**GCP**）是Google提供的IaaS。您可以在[https://console.cloud.google.com/freetrial](https://console.cloud.google.com/freetrial)上注册。与Azure云一样，您会发现许多核心功能，尽管名称不同：'
- en: You can manage virtual instances using the **Google Compute Engine**. As usual,
    each instance is created from an image, a selected machine type, and an SSH public
    key. Instead of Security Groups, you have **Firewall Rules**, and autoscaling
    groups are called **Managed Instance Groups**.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用**Google计算引擎**管理虚拟实例。与往常一样，每个实例都是从一个镜像、一个选择的机器类型和一个SSH公钥创建的。您可以使用**防火墙规则**而不是安全组，并且自动缩放组称为**托管实例组**。
- en: Relational databases are provided by the **Cloud SQL** service. GCP supports
    both MySQL and PostgreSQL instances.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud SQL**服务提供关系型数据库。GCP支持MySQL和PostgreSQL实例。'
- en: For NoSQL databases, you can use the **Cloud Datastore** service.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于NoSQL数据库，您可以使用**Cloud Datastore**服务。
- en: The **Cloud Pub/Sub** service offers the possibility to implement complex publish/subscribe
    architectures (in fact, superceding the possibilities that AWS offers with SQS).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cloud Pub/Sub**服务提供了实现复杂的发布/订阅架构的可能性（事实上，超越了AWS提供的SQS的可能性）。'
- en: 'Since both come from Google, it goes without saying that GCP and Go go hand
    in hand (pun intended). You can install the Go SDK via the usual `go get` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两者都来自Google，可以毫不夸张地说GCP和Go是密不可分的（双关语）。您可以通过通常的`go get`命令安装Go SDK：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: OpenStack
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenStack
- en: 'There are also many cloud providers that build their products on the open source
    cloud management software, OpenStack ([https://www.openstack.org](https://www.openstack.org)).
    OpenStack is a highly modular software, and clouds built on it may vary significantly
    in their setup, so it''s difficult to make any universally valid statements about
    them. Typical OpenStack installations might consist of the following services:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多云提供商在开源云管理软件OpenStack（[https://www.openstack.org](https://www.openstack.org)）上构建其产品。OpenStack是一个高度模块化的软件，基于它构建的云可能在设置上有很大差异，因此很难对它们做出普遍有效的陈述。典型的OpenStack安装可能包括以下服务：
- en: '**Nova** manages virtual machine instances and Neutron to manage networking.
    In the management console, you will find this under the Instances and Networks labels.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nova管理虚拟机实例，Neutron管理网络。在管理控制台中，您会在“实例”和“网络”标签下找到这些功能。
- en: '**Zun** and **Kuryr** manage containers. Since these are relatively young components,
    it will probably be more common to find managed Kubernetes clusters in OpenStack
    clouds, though.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zun**和**Kuryr**管理容器。由于这些组件相对较新，可能更常见的是在OpenStack云中找到托管的Kubernetes集群。'
- en: '**Trove** provides database services for both relational and nonrelational
    databases, such as MySQL or MongoDB.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trove**为关系型和非关系型数据库（如MySQL或MongoDB）提供数据库服务。'
- en: '**Zaqar** provides messaging services similar to SQS.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zaqar**提供类似于SQS的消息服务。'
- en: If you want to access OpenStack features from a Go application, there are multiple
    libraries that you can choose from. First of all, there is the official client
    library—[github.com/openstack/golang-client](http://github.com/openstack/golang-client)—which,
    however, is not yet recommended for production use. At the time of writing this
    book, the most mature Go client library for OpenStack is the [github.com/gophercloud/gophercloud](http://github.com/openstack/golang-client) library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从Go应用程序访问OpenStack功能，则有多个库可供选择。首先，有官方客户端库 - [github.com/openstack/golang-client](http://github.com/openstack/golang-client)
    - 但目前尚不建议用于生产。在撰写本书时，OpenStack的最成熟的Go客户端库是[github.com/gophercloud/gophercloud](http://github.com/openstack/golang-client)库。
- en: Running containers in the cloud
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中运行容器
- en: In [Chapter 6](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml), *Deploying Your
    Application in Containers*, we got a thorough look at how to deploy a Go application
    using modern container technologies. When it comes to deploying these containers
    into a cloud environment, you have a variety of different ways to do that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](af835c34-a409-4898-9a55-74fc9d05b46b.xhtml)中，*在容器中部署您的应用程序*，我们深入了解了如何使用现代容器技术部署Go应用程序。当涉及将这些容器部署到云环境时，您有多种不同的方法可以做到这一点。
- en: One possibility to deploy containerized applications is using an orchestration
    engine such as **Kubernetes**. This is especially easy when you are using the
    Microsoft Azure cloud or the Google Cloud Platform. Both providers offer Kubernetes
    as a managed service, although not under that name; look for the **Azure Container
    Service** (**AKS**) or **Google Container Engine** (**GKE**).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 部署容器化应用程序的一种可能性是使用诸如**Kubernetes**之类的编排引擎。当您使用Microsoft Azure云或Google Cloud
    Platform时，这尤其容易。这两个提供商都提供Kubernetes作为托管服务，尽管不是以这个名称; 寻找**Azure容器服务**（**AKS**）或**Google容器引擎**（**GKE**）。
- en: Although AWS does not offer a managed Kubernetes service, they have a similar
    offering called **EC2 Container Service** (**ECS**). Since ECS is a service available
    exclusively on AWS, it is very tightly integrated with other AWS core services,
    which can be both an advantage and disadvantage. Of course, you can set up your
    own Kubernetes cluster on AWS using the building blocks provided in the form of
    VMs, networking, and storage. Doing this is incredibly complex work, but do not
    despair. You can use third-party tools to set up a Kubernetes cluster on AWS automatically.
    One of these tools is **kops**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管AWS不提供托管的Kubernetes服务，但他们有一个类似的服务称为**EC2容器服务**（**ECS**）。由于ECS是AWS独家提供的服务，它与其他AWS核心服务紧密集成，这既是优势也是劣势。当然，您可以使用在VM、网络和存储形式提供的构建块在AWS上设置自己的Kubernetes集群。这是非常复杂的工作，但不要绝望。您可以使用第三方工具自动在AWS上设置Kubernetes集群。其中一个工具是**kops**。
- en: You can download kops at [https://github.com/kubernetes/kops](https://github.com/kubernetes/kops).
    After that, follow the setup instructions for AWS that you can find in the project
    documentation at [https://github.com/kubernetes/kops/blob/master/docs/aws.md](https://github.com/kubernetes/kops/blob/master/docs/aws.md).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/kubernetes/kops](https://github.com/kubernetes/kops)下载kops。之后，请按照AWS的设置说明进行设置，您可以在项目文档中找到[https://github.com/kubernetes/kops/blob/master/docs/aws.md](https://github.com/kubernetes/kops/blob/master/docs/aws.md)。
- en: Kops itself is also written in Go and uses the very same AWS SDK that you have
    already come across in [Chapters 7](f11f12b7-32c8-4ee8-ad1a-b9e1882b57f6.xhtml), *AWS
    I–Fundamentals, AWS SDK for Go, and EC2*, and [Chapter 8](25f18fd2-4d08-41fb-a8b2-acc927bd0876.xhtml),
    *AWS II - S3, SQS, API Gateway, and DynamoDB*. Take a look at the source code
    to see a real-life example of some very sophisticated usage of the AWS client
    library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Kops本身也是用Go编写的，并使用了您在[第7章](f11f12b7-32c8-4ee8-ad1a-b9e1882b57f6.xhtml)中已经遇到的AWS
    SDK。看一下源代码，看看AWS客户端库的一些非常复杂的用法的真实例子。
- en: Serverless architectures
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器架构
- en: When consuming a traditional Infrastructure-as-a-Service offering, you are provided
    a number of virtual machines along with the respective infrastructure (such as
    storage and networking). You typically need to operate everything running within
    these virtual machines yourself. This usually means not only your compiled application,
    but also the entire operating system, including the kernel of each and every system
    service of a full-blown Linux (or Windows) system. You are also responsible for
    the capacity planning of your infrastructure (which means estimating your application's
    resource requirements and defining sensible boundaries for your autoscaling groups).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用传统的基础设施即服务时，您将获得一些虚拟机以及相应的基础设施（如存储和网络）。通常需要自己操作在这些虚拟机中运行的所有内容。这通常意味着不仅是您编译的应用程序，还包括整个操作系统，包括每个完整的Linux（或Windows）系统的内核和系统服务。您还需要负责基础设施的容量规划（这意味着估算应用程序的资源需求并为自动扩展组定义合理的边界）。
- en: All of this means **Operational Overhead** that keeps you from your actual job,
    that is, building and deploying software that drives your business. To reduce
    this overhead, you can instead use a Platform-as-a-Service offering instead of
    an IaaS one. One common form of PaaS hosting is using container technologies,
    where the developer simply provides a container image, and the provider takes
    care of running (and optionally, scaling) the application and managing the underlying
    infrastructure. Typical container-based PaaS offerings include the EC2 Container
    Service by AWS or any Kubernetes cluster, such as the Azure Container Service
    or the Google Container Engine. Noncontainer-based PaaS offerings might include
    AWS Elastic Beanstalk or Google App Engine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着**操作开销**会让您无法专注于实际工作，也就是构建和部署推动业务的软件。为了减少这种开销，您可以使用平台即服务（PaaS）而不是基础设施即服务（IaaS）。一种常见的PaaS托管形式是使用容器技术，开发人员只需提供一个容器镜像，提供商负责运行（和可选地扩展）应用程序，并管理底层基础设施。典型的基于容器的PaaS提供包括AWS的EC2容器服务或任何Kubernetes集群，例如Azure容器服务或Google容器引擎。非基于容器的PaaS提供可能包括AWS
    Elastic Beanstalk或Google App Engine。
- en: 'Recently, another approach has arisen that strives to eliminate even more operational
    overhead than PaaS offerings: **Serverless Computing**. Of course, that name is
    wildly misleading, as applications being run on a serverless architecture obviously
    still require servers. The key difference is that the existence of these servers
    is completely hidden from the developer. The developer only provides the application
    to be executed, and the provider takes care of provisioning infrastructure for
    this application and deploying and running it. This approach works well with Microservice
    Architectures, as it becomes incredibly easy to deploy small pieces of code that
    communicate with each other using web services, message queues, or other means.
    Taken to the extreme, this often results in single functions being deployed as
    services, resulting in the alternate term for serverless computing: **Functions-as-a-Service**
    (**FaaS**).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，又出现了另一种方法，旨在消除PaaS提供的操作开销：**无服务器计算**。当然，这个名字是非常误导的，因为在无服务器架构上运行的应用程序显然仍然需要服务器。关键的区别在于这些服务器的存在完全对开发人员隐藏。开发人员只提供要执行的应用程序，提供商负责为该应用程序提供基础设施，并部署和运行它。这种方法与微服务架构很搭配，因为部署使用web服务、消息队列或其他方式相互通信的小代码片段变得非常容易。在极端情况下，这经常导致单个函数被部署为服务，从而产生无服务器计算的替代术语：**函数即服务**（**FaaS**）。
- en: Many cloud providers offer FaaS functionalities as part of their services, the
    most prominent example being **AWS Lambda**. At the time of writing this book,
    AWS Lambda does not officially support Go as a programming language (supported
    languages are JavaScript, Python, Java, and C#), and running Go functions is only
    possible using third-party wrappers such as [https://github.com/eawsy/aws-lambda-go](https://github.com/eawsy/aws-lambda-go).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 许多云服务提供商作为其服务的一部分提供FaaS功能，其中最突出的例子是**AWS Lambda**。在撰写本书时，AWS Lambda并不正式支持Go作为编程语言（支持的语言包括JavaScript、Python、Java和C#），而运行Go函数只能使用第三方包装器，例如[https://github.com/eawsy/aws-lambda-go](https://github.com/eawsy/aws-lambda-go)。
- en: Other cloud providers offer similar services. Azure offers **Azure Functions** (supporting
    JavaScript, C#, F#, PHP, Bash, Batch, and PowerShell) and GCP offers **Cloud Functions** as
    a Beta product (supporting only JavaScript). If you are running a Kubernetes cluster,
    you can use the Fission framework ([https://github.com/fission/fission](https://github.com/fission/fission))
    to run your own FaaS platform (which even supports Go). However, Fission is a
    product in an early alpha development stage and not yet recommended for production
    use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其他云服务提供商提供类似的服务。Azure提供**Azure Functions**（支持JavaScript、C#、F#、PHP、Bash、Batch和PowerShell），GCP提供**Cloud
    Functions**作为Beta产品（仅支持JavaScript）。如果您正在运行Kubernetes集群，可以使用Fission框架（[https://github.com/fission/fission](https://github.com/fission/fission)）来运行自己的FaaS平台（甚至支持Go）。然而，Fission是一个处于早期alpha开发阶段的产品，目前还不建议用于生产环境。
- en: As you may have noticed, support for the Go language is not yet far spread among
    the popular FaaS offerings. However, given the popularity of both Go as a programming
    language and Serverless Architecture, not all hope is lost.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，流行的FaaS提供中对Go语言的支持还不够广泛。然而，鉴于Go作为一种编程语言和无服务器架构的流行，还不是所有的希望都已经失去。
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With this, we reach the end of our book. By now, you should have enough knowledge
    to build sophisticated microservices cloud native applications that are resilient,
    distributed, and scalable. With this chapter, you should also develop ideas of
    where to go next to take your newly acquired knowledge to the next level. We thank
    you for giving us the chance to guide you through this learning journey and look
    forward to being part of your future journeys.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们的书就要结束了。到目前为止，您应该已经掌握了足够的知识，可以构建复杂的云原生微服务应用程序，这些应用程序具有弹性、分布式和可扩展性。通过本章，您还应该有了下一步如何将您新获得的知识提升到更高水平的想法。我们感谢您给我们提供机会，引导您完成这次学习之旅，并期待成为您未来旅程的一部分。
