- en: '*Chapter 1*: Getting Started with TinyGo'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：TinyGo入门'
- en: In my opinion, Go is easy to learn, easy to read, and easy to write. The language
    is not overloaded with fancy features but rather focuses on being concise. The
    built-in concurrency, fast compile times, high execution performance, and rich
    standard libraries make a great mix for an awesome language. This is why I want
    to take you on a journey from very basic high-level Go programs to the depths
    of microcontrollers utilizing the full power of TinyGo.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Go语言易于学习、易于阅读、易于编写。该语言没有过多的花哨特性，而是注重简洁。内置的并发性、快速的编译时间、高执行性能和丰富的标准库使它成为一款出色的语言。这就是为什么我想带您从非常基础的高级Go程序开始，深入到利用TinyGo全部功能的微控制器。
- en: In this chapter, we are going to set up TinyGo and learn how to get code completion
    to work in VS Code and different editors. After this is done, we will have a look
    at the Arduino UNO and its technical specifications. We are going to compare TinyGo
    with Go and talk about what makes TinyGo special compared to other languages on
    microcontrollers. At the end of this chapter, we will write, compile, deploy,
    and run our first TinyGo program on a real microcontroller. Having all these topics
    covered, you will have learned how to write, build, and run programs on microcontrollers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置TinyGo，并学习如何在VS Code和其他编辑器中实现代码补全。完成这些后，我们将查看Arduino UNO及其技术规格。我们将比较TinyGo与Go，并讨论TinyGo相较于其他微控制器语言的特殊之处。在本章结束时，我们将编写、编译、部署和运行我们的第一个TinyGo程序在真实的微控制器上。涵盖所有这些主题后，您将学会如何在微控制器上编写、构建和运行程序。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding what TinyGo is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解TinyGo是什么
- en: Setting up TinyGo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置TinyGo
- en: Understanding the IDE integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解IDE集成
- en: The Arduino UNO
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino UNO
- en: Checking out the Hello World of things
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看事物的Hello World
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to continue, you need to have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续，您需要具备以下条件：
- en: Go must be installed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须安装Go
- en: GOPATH must be set up
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须设置GOPATH
- en: Git must be installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须安装Git
- en: An Arduino Uno, preferably the Rev3 Edition but you can also use other Arduino
    Uno boards
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Uno，最好是Rev3版本，但您也可以使用其他Arduino Uno板
- en: 'You can find all code examples from this chapter in the following GitHub repository:
    [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此GitHub仓库中找到本章的所有代码示例：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter01)
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3mLFCCJ](https://bit.ly/3mLFCCJ)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在此处找到：[https://bit.ly/3mLFCCJ](https://bit.ly/3mLFCCJ)
- en: Understanding what TinyGo is
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TinyGo是什么
- en: TinyGo is an independently written *compiler*, with its *own runtime implementation*.
    It is intended to be used for microcontroller programming, **WebAssembly** (**WASM**),
    and CLI tools. TinyGo heavily makes use of the LLVM infrastructure to optimize
    and compile code to binaries that a microcontroller can understand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo是一个独立编写的*编译器*，拥有其*自己的运行时实现*。它旨在用于微控制器编程、**WebAssembly**（**WASM**）和CLI工具。TinyGo大量使用LLVM基础设施来优化和编译代码，使其成为微控制器可以理解的二进制文件。
- en: The first release of TinyGo (v0.1) was published on February 1, 2019 on GitHub.
    Since then, the project has quickly implemented lots of features and never stopped
    adding support for more microcontrollers, sensors, displays, and other devices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo的第一个版本（v0.1）于2019年2月1日在GitHub上发布。从那时起，该项目迅速实现了许多功能，并且从未停止为更多微控制器、传感器、显示屏和其他设备添加支持。
- en: On February 2, 2020, TinyGo announced that it is now officially a Google-sponsored
    project. This was a big step for the complete project.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2020年2月2日，TinyGo宣布它现在正式成为谷歌赞助的项目。这对整个项目来说是一个巨大的进步。
- en: How TinyGo works
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TinyGo的工作原理
- en: 'The TinyGo compiler uses a different set of steps than other languages to transform
    Go source code to machine code. We will not be going into the details though,
    but let''s take a look at an overview of the compiler pipeline:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo编译器与其他语言相比，在将Go源代码转换为机器代码时使用不同的步骤。虽然我们不会深入细节，但让我们看一下编译器管道的概述：
- en: We write the Go source code.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写Go源代码。
- en: This source code gets translated to Go **SSA** (**Static Single Assignment**).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此源代码被转换为 Go **SSA**（**静态单赋值**）。
- en: The Go SSA is transformed to LLVM IR by the TinyGo compiler package.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TinyGo 编译器包将 Go SSA 转换为 LLVM IR。
- en: The initialization code in the LLVRM IR is interpreted by the TinyGo `interp`
    packages. This step optimizes globals, constants, and more.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVRM IR 中的初始化代码由 TinyGo 的 `interp` 包解释。这一步优化了全局变量、常量等。
- en: The result is then optimized by some LLVM optimization passes (such as `string`
    to `[]byte` optimization).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果随后通过一些 LLVM 优化过程（如 `string` 到 `[]byte` 优化）进行优化。
- en: The result is then again optimized by the LLVM optimizer.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果随后再次由 LLVM 优化器优化。
- en: Next, some fixes are done by the compiler package.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编译器包进行了一些修正。
- en: And as the last step, LLVM creates the machine code.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，LLVM 创建机器代码。
- en: If this sounds complicated right now, don't worry – we don't have to take care
    of this process. TinyGo does all this for us. Now let's have a look at what makes
    TinyGo special compared to Go.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在听起来很复杂，请不要担心——我们不需要关心这个过程。TinyGo 会为我们完成所有这些。现在让我们看看与 Go 相比，TinyGo 有哪些特殊之处。
- en: Comparing TinyGo to Go
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 TinyGo 与 Go 比较
- en: 'TinyGo can compile some, but not all Go programs. Let''s have a look at an
    example that can be compiled by both. Let''s write a small Hello World program
    in Go—build it and check its size:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo 可以编译一些 Go 程序，但不是全部。让我们看看一个可以被两者编译的例子。让我们用 Go 编写一个简单的 Hello World 程序——构建它并检查其大小：
- en: 'This is the most minimal Hello World program I can currently think of:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我目前能想到的最简单的 Hello World 程序：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It does not need an external package such as `fmt` to print the line.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它不需要像 `fmt` 这样的外部包来打印行。
- en: 'I will be using Go 1.15.2 on an Ubuntu 20.01 operating system. To check your
    currently installed Go version, use the `go version` command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将在 Ubuntu 20.01 操作系统上使用 Go 1.15.2。要检查您当前安装的 Go 版本，请使用 `go version` 命令：
- en: '[PRE1]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We build the program using the `go build` command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `go build` 命令构建程序：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we check the size using the `ls –l` command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用 `ls –l` 命令来检查大小：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the program has 1,231,780 bytes, which is 1.23178 megabytes. That is pretty
    big for a program that consists of just 4 lines of code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，程序有 1,231,780 字节，即 1.23178 兆字节。对于一个只有 4 行代码的程序来说，这相当大。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ls` command is not available on all operating systems. If you want to check
    the sizes for yourself, you need to use tools that are available on your operating
    system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 命令并非在所有操作系统上都有。如果您想自己检查大小，您需要使用您操作系统上可用的工具。'
- en: The size of the binary file may differ when you try it out, as the Go team continues
    to optimize the compiler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件的大小在您尝试时可能会有所不同，因为 Go 团队继续优化编译器。
- en: Furthermore, the size of the binary file could differ when building for other
    operating systems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为其他操作系统构建时，二进制文件的大小也可能不同。
- en: 'Now let''s check what the size of the same program is, but this time compiled
    using TinyGo. As TinyGo does not support building binaries for Windows, I take
    care of the compiling, so we can just compare the sizes here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查相同程序的大小，但这次使用 TinyGo 编译。由于 TinyGo 不支持为 Windows 构建二进制文件，我负责编译，所以我们只需比较大小即可：
- en: 'I used the following command to build the binary:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我使用以下命令构建二进制文件：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then I checked the size using the `ls –l` command, as we did before:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我使用 `ls –l` 命令检查了大小，就像我们之前做的那样：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We see that the TinyGo version of our Hello World program is only a fraction
    of the size that the Go compiler emitted. The TinyGo version is only 21,152 bytes,
    which is about 0.021152 megabytes. The TinyGo program is 58 times smaller as compared
    to the Go program. This is a huge difference. If you still want to test it out
    yourself, you can do this after setting up TinyGo.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，我们的 Hello World 程序的 TinyGo 版本大小仅为 Go 编译器生成的尺寸的一小部分。TinyGo 版本仅为 21,152 字节，大约是
    0.021152 兆字节。与 Go 程序相比，TinyGo 程序小了 58 倍。这是一个巨大的差异。如果您仍然想亲自测试，您可以在设置 TinyGo 后进行。
- en: We have now learned that TinyGo can compile some, but not all Go programs. Also,
    we learned that programs that are compiled with TinyGo are very small. In the
    next sections, we'll get to know why TinyGo cannot compile all Go programs and
    what features TinyGo offers that Go does not offer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解到 TinyGo 可以编译一些 Go 程序，但不能编译所有。我们还了解到，用 TinyGo 编译的程序非常小。在下一节中，我们将了解为什么
    TinyGo 不能编译所有 Go 程序，以及 TinyGo 提供了哪些 Go 没有的特性。
- en: Supported language features
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持的语言特性
- en: TinyGo supports a part of the Go language features, but not everything is supported
    right now. Goroutines and channels work on most microcontrollers. Reflection is
    supported for most types. While slices are supported, you may encounter some problems
    when working with maps. Only certain types of strings, integers, pointers, and
    structs or arrays that contain the previous types are supported. So, all in all,
    a good portion of Go is supported in TinyGo.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo支持Go语言的一部分特性，但并不是所有特性都支持。Goroutines和channels在大多数微控制器上工作。对于大多数类型，反射是支持的。虽然切片是支持的，但在处理映射时可能会遇到一些问题。只有某些类型的字符串、整数、指针以及包含前述类型的结构体或数组是支持的。所以，总的来说，TinyGo支持了Go语言的大部分特性。
- en: Supported standard packages
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持的标准包
- en: The biggest part of the standard library is also supported in TinyGo. As of
    the time of writing, however, most of the `net` and `crypto` packages still do
    not compile. That means, if you import them, you will get compile errors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的大部分内容也在TinyGo中得到支持。然而，截至编写本文时，`net`和`crypto`包的大部分内容仍然无法编译。这意味着，如果你导入它们，你会得到编译错误。
- en: 'You can look up a list of currently supported standard packages here: [https://tinygo.org/lang-support/stdlib/](https://tinygo.org/lang-support/stdlib/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查找当前支持的标准化包列表：[https://tinygo.org/lang-support/stdlib/](https://tinygo.org/lang-support/stdlib/)。
- en: Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A *yes* in the support table does not mean that every function in a package
    is actually usable in TinyGo. Some functions still could cause compile errors.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 支持表中的一项“是”并不意味着一个包中的每个函数在TinyGo中实际上都是可用的。一些函数仍然可能引起编译错误。
- en: Volatile operations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 易失性操作
- en: Volatile operations can be used to read to and write from memory-mapped registers.
    The values inside these registers can change between several reads without the
    knowledge of the compiler. The compiler has no knowledge about the effects of
    these operations, hence they are called volatile.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 易失性操作可以用来读写内存映射寄存器。这些寄存器中的值在多次读取之间可能会改变，而编译器并不知道这一点。编译器对这些操作的效果一无所知，因此它们被称为易失性。
- en: Go does not have a volatile operator, which is why TinyGo provides a **volatile
    package**. For most cases, we will not need volatile operations, as these are
    abstracted away by the machine package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有易失性运算符，这就是为什么TinyGo提供了一个**易失性包**。在大多数情况下，我们不需要易失性操作，因为这些操作被机器包抽象掉了。
- en: Inline assembly
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联汇编
- en: '**Assembly Language** (**ASM**) is a language that is specifically designed
    for a certain processor architecture. This happens because assembly depends on
    the machine code instruction set. The device-specific packages of TinyGo provide
    assembly packages.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编语言**（**ASM**）是一种专门为特定处理器架构设计的语言。这是因为汇编依赖于机器代码指令集。TinyGo的设备特定包提供了汇编包。'
- en: This enables us to use inline assembly code in our Go programs, which is not
    possible in standard Go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们能够在Go程序中使用内联汇编代码，这在标准Go中是不可能的。
- en: Heap allocations
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆内存分配
- en: The **Heap** is the part of the memory where dynamic allocations and deallocations
    take place during runtime. So, when our application wants to reserve a part of
    the memory, it talks with the Heap to reserve the memory. That part of the memory
    will then be marked as being in use. As this space is rather limited on microcontrollers
    and garbage collection is expensive and slow, TinyGo tries to optimize away Heap
    allocations. The result is that, often, objects can be statically allocated instead
    of dynamically.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆**是内存中动态分配和释放发生的地方。因此，当我们的应用程序想要保留内存的一部分时，它会与堆进行通信以保留内存。这部分内存将被标记为正在使用。由于微控制器上的空间相当有限，垃圾回收既昂贵又慢，TinyGo试图优化堆内存分配。结果是，通常，对象可以被静态分配而不是动态分配。'
- en: Garbage collection
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Garbage collection is the process of freeing memory. So, when your application
    no longer needs a part of the memory it earlier requested, this memory is marked
    as unused (free) again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是释放内存的过程。因此，当你的应用程序不再需要之前请求的内存部分时，这部分内存会被标记为未使用（空闲）。
- en: 'For that purpose, TinyGo has implemented its own variant of garbage collection.
    TinyGo uses a conservative mark/sweep garbage collection, where conservative means
    that the **Garbage Collector** (**GC**) has no knowledge of what is a pointer
    and what it is not. The GC process is split into two parts:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，TinyGo实现了自己的垃圾回收变体。TinyGo使用保守的标记/清除垃圾回收，这里的保守意味着垃圾回收器（**GC**）不知道什么是指针，什么不是指针。GC过程分为两个部分：
- en: '**Mark**: In the marking phase, the gc marks objects as reachable.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mark**：在标记阶段，gc将对象标记为可达。'
- en: '**Sweep**: In the sweeping phase, the gc frees memory by marking the areas
    of unreachable objects as free. These freed areas can then be reused to allocate
    new objects.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sweep**：在清扫阶段，gc通过将不可达对象的区域标记为空闲来释放内存。这些释放的区域可以随后被重新用于分配新对象。'
- en: We do now know what TinyGo is and what differences exist between TinyGo and
    Go. We have also learned what the Heap, the GC, and volatile packages are. The
    next logical step is to go on and set up TinyGo, which we will be doing in the
    next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经知道了TinyGo是什么，以及TinyGo和Go之间存在的差异。我们还学习了Heap、GC和volatile包是什么。下一步的逻辑步骤是继续设置TinyGo，我们将在下一节中完成。
- en: Setting up TinyGo
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置TinyGo
- en: 'The easiest way to install TinyGo and all its dependencies is to follow the
    Quick Start Guides for Linux, macOS, Windows, and Docker at the following link:
    [https://tinygo.org/getting-started/](https://tinygo.org/getting-started/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中，您可以按照Linux、macOS、Windows和Docker的快速入门指南安装TinyGo及其所有依赖项：[https://tinygo.org/getting-started/](https://tinygo.org/getting-started/)。
- en: As these guides cover important parts, I will only cover the Quick Start part
    for x64-based architectures and only for Debian-based operating systems such as
    Ubuntu for Linux.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些指南涵盖了重要部分，我将仅涵盖基于x64架构的快速入门部分，并且仅针对基于Debian的操作系统的Linux，如Ubuntu。
- en: The first thing to do before we start the setup is to check the latest version
    of TinyGo. To do so, go to [https://github.com/tinygo-org/tinygo/releases](https://github.com/tinygo-org/tinygo/releases)
    and check for the newest release. Now, keep this information written down somewhere
    or memorize it as we'll be using it later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始设置之前，我们首先要检查TinyGo的最新版本。为此，请访问[https://github.com/tinygo-org/tinygo/releases](https://github.com/tinygo-org/tinygo/releases)并检查最新发布版本。现在，请将此信息记录下来或记住它，因为我们稍后会用到。
- en: Installing on Linux
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: 'The following steps cover installing TinyGo on a Linux derivate, which is based
    on Debian:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤涵盖了在基于Debian的Linux发行版上安装TinyGo：
- en: 'We use the following command to download the `deb` package from GitHub and
    install it using `dpkg`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令从GitHub下载`deb`包，并使用`dpkg`进行安装：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can exchange the version in the path and filename with the newest release
    version you found before.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将路径和文件名中的版本与您之前找到的最新发布版本进行交换。
- en: 'Now we must add TinyGo to `GOPATH`. You can use the following command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须将TinyGo添加到`GOPATH`中。您可以使用以下命令：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next step is to verify the installation. Use the `tinygo version` command
    to verify that TinyGo has been successfully installed:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是验证安装。使用`tinygo version`命令验证TinyGo是否已成功安装：
- en: '[PRE8]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'AVR dependencies: As we are going to work with an Arduino UNO in the first
    chapters, we need to install some additional dependencies. We do so by using the
    following commands:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVR依赖项：由于我们将在前几章中使用Arduino UNO，我们需要安装一些额外的依赖项。我们通过以下命令来完成：
- en: '[PRE9]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After installing these dependencies, we can now compile on AVR-based boards
    such as the Arduino UNO.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些依赖项后，我们现在可以在基于AVR的板卡上编译，例如Arduino UNO。
- en: 'If you are using Fedora, Arch Linux, or other distributions, please follow
    the installation guide: [https://tinygo.org/getting-started/linux/](https://tinygo.org/getting-started/linux/).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Fedora、Arch Linux或其他发行版，请遵循以下安装指南：[https://tinygo.org/getting-started/linux/](https://tinygo.org/getting-started/linux/)。
- en: Installing on Windows
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: In this section, we are going to learn how to install TinyGo on Windows. After
    this section, we will have also learned how to install dependencies, which are
    needed to flash the Arduino UNO.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在Windows上安装TinyGo。在本节之后，我们还将学习如何安装依赖项，这些依赖项是烧录Arduino UNO所必需的。
- en: Very important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的注意事项
- en: You cannot create Windows binary programs using TinyGo. You can still compile
    and flash programs for microcontroller and WebAssembly targets.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法使用TinyGo创建Windows二进制程序。您仍然可以编译和烧录针对微控制器和WebAssembly目标的程序。
- en: You may want to directly install and use TinyGo inside the **Windows Subsystem
    for Linux** (**WSL**). The WSL is the way I recommend for Windows users.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望直接在**Windows Subsystem for Linux**（**WSL**）中安装并使用TinyGo。WSL是我推荐给Windows用户的方案。
- en: 'To install TinyGo on Windows without using the WSL, I recommend using Scoop,
    a command-line installer for Windows. Make sure that you have PowerShell 5 (or
    later) and .NET Framework 4.5 (or later) installed. To do so, please follow these
    steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不使用WSL的情况下在Windows上安装TinyGo，我推荐使用Scoop，这是一个Windows的命令行安装程序。请确保您已安装PowerShell
    5（或更高版本）和.NET Framework 4.5（或更高版本）。为此，请按照以下步骤操作：
- en: 'Enable PowerShell for your current user account using the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令为您的当前用户账户启用 PowerShell：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now run the following command to download Scoop:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行以下命令以下载 Scoop：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can install TinyGo by using the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装 TinyGo：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now to verify the installation was successful, use the following command:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要验证安装是否成功，请使用以下命令：
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output should look like the following:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '[PRE14]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The actual TinyGo and Go version might differ.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际的 TinyGo 和 Go 版本可能不同。
- en: 'AVR dependencies: In order to be able to compile and flash programs for the
    Arduino UNO, we need to have an AVR 8-bit toolchain installed. You can find a
    download here: [https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers](https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers).'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AVR 依赖项：为了能够编译和刷写 Arduino UNO 等基于 AVR 的微控制器的程序，我们需要安装一个 AVR 8 位工具链。您可以在以下位置找到下载链接：[https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers](https://www.microchip.com/mplab/avr-support/avr-and-arm-toolchains-c-compilers)。
- en: 'Extend your `%PATH%` and make sure that the `bin` folder is included:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展您的 `%PATH%` 并确保 `bin` 文件夹被包含在内：
- en: 'Next, download and install GNU Make for Windows. You can find GNU Make here:
    [http://gnuwin32.sourceforge.net/packages/make.htm](http://gnuwin32.sourceforge.net/packages/make.htm).'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载并安装 Windows 的 GNU Make。您可以在以下位置找到 GNU Make：[http://gnuwin32.sourceforge.net/packages/make.htm](http://gnuwin32.sourceforge.net/packages/make.htm)。
- en: 'As the last step, you need to download and install `avrdude`. The `avrdude`
    EXE also must be inside your `%PATH%`. You can download AVR Dude here: [http://download.savannah.gnu.org/releases/avrdude/](http://download.savannah.gnu.org/releases/avrdude/).
    The file you are looking for is called `avrdude-6.3-mingw32.zip`.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，您需要下载并安装 `avrdude`。`avrdude` EXE 也必须位于您的 `%PATH%` 中。您可以在以下位置下载 AVR Dude：[http://download.savannah.gnu.org/releases/avrdude/](http://download.savannah.gnu.org/releases/avrdude/)。您要找的文件名为
    `avrdude-6.3-mingw32.zip`。
- en: 'If you encounter any problems regarding the `avr` setup or don''t know how
    to configure environment variables, you may want to check out the following guide:
    [https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html](https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到有关 `avr` 设置的问题或不知道如何配置环境变量，您可能想查看以下指南：[https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html](https://fab.cba.mit.edu/classes/863.16/doc/projects/ftsmin/windows_avr.html)。
- en: WSL installation
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: WSL 安装
- en: It is also possible to install TinyGo directly on the **Windows Subsystem for
    Linux** (**WSL**). Just follow the Linux section to do that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接在 **Windows Subsystem for Linux**（**WSL**）上安装 TinyGo。只需遵循 Linux 部分，即可完成此操作。
- en: Installing on macOS
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: macOS 安装
- en: 'Installation on macOS is straightforward. Let''s take a quick look at the steps:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 安装
- en: 'We are going to use Homebrew to `install tinygo`. Just use the following two
    commands:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Homebrew 来 `安装 tinygo`。只需使用以下两个命令：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Simply run the `tinygo version` command to verify the installation:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地运行 `tinygo version` 命令以验证安装：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following commands to install the additional requirements needed to
    compile programs for AVR-based microcontrollers such as the Arduino UNO, which
    we are going to use in the first few chapters of the book:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们快速查看以下步骤，以安装编译 AVR 基于微控制器程序（如我们在本书的前几章中将使用的 Arduino UNO）所需的附加要求：
- en: '[PRE17]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Installing on Docker
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 安装
- en: It is possible to directly use a Docker image to compile our programs. However,
    it is not possible to flash the programs using the Docker image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接使用 Docker 镜像来编译我们的程序。然而，使用 Docker 镜像无法刷写程序。
- en: 'Simply download the image using the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地使用以下命令下载镜像：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The actual TinyGo version might differ. Use the newest TinyGo version from the
    check we did when we started the section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 TinyGo 版本可能不同。使用我们在开始本节时进行的检查中获取的最新 TinyGo 版本。
- en: 'Here is an example call to build a program:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个构建程序的示例调用：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have now successfully set up TinyGo and installed all additional requirements
    to compile and flash programs to the Arduino UNO microcontroller. Also, everything
    we need for WebAssembly is now set up. The next step is to set up IDE integration
    before we start writing our first program for a microcontroller.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功设置了 TinyGo，并安装了所有编译和刷写到 Arduino UNO 微控制器所需的附加要求。此外，我们需要的所有 WebAssembly
    东西也已设置好。下一步是在我们开始编写微控制器的第一个程序之前设置 IDE 集成。
- en: Understanding IDE integration
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 IDE 集成
- en: Having a properly set up IDE is truly a blessing as we benefit from its features
    of code completion, functional linting, and so on. This way, we do not have to
    investigate the source code or documentation for every function we want to call.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个设置得当的 IDE 真是件好事，因为我们能从中受益于代码补全、功能性代码审查等功能。这样，我们就不必调查每个想要调用的函数的源代码或文档。
- en: In this section, we will look at the process of integrating TinyGo into VS Code,
    Goland, and other editors. This enables us to choose whatever editor we prefer
    to use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨将 TinyGo 集成到 VS Code、Goland 和其他编辑器中的过程。这使得我们可以选择我们偏好的任何编辑器来使用。
- en: VS Code integration
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code 集成
- en: VS Code offers an extension system, which makes it easy to integrate the Go
    and TinyGo toolset into the IDE. We are going to install the Go Extension, which
    offers support for the Go programming language. Afterward, we are going to install
    the TinyGo extension, which brings TinyGo support.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 提供了一个扩展系统，这使得将 Go 和 TinyGo 工具集集成到 IDE 中变得容易。我们将安装提供 Go 编程语言支持的 Go 扩展。之后，我们将安装提供
    TinyGo 支持的 TinyGo 扩展。
- en: The Go extension
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go 扩展
- en: 'We install the Go extension using the **Extensions** view using the following
    steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下步骤通过 **扩展** 视图安装 Go 扩展：
- en: Open the **Extensions** view either by clicking on the **Extensions** icon or
    pressing *Ctrl* + *Shift* + *X*.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **扩展** 图标或按 *Ctrl* + *Shift* + *X* 来打开 **扩展** 视图。
- en: Search for **Go**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 **Go**。
- en: Select the first entry in the list, which is called **Go** and is from the Go
    team at Google.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择列表中的第一个条目，它被称为 **Go**，由 Google 的 Go 团队提供。
- en: Click on the **Install** button, as seen in the following screenshot:![Figure
    1.1 – Installation from the Extensions view
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击以下截图中的 **安装** 按钮：![图 1.1 – 从扩展视图安装
- en: '](img/Figure_1.1_B16555.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B16555.jpg)'
- en: Figure 1.1 – Installation from the Extensions view
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.1 – 从扩展视图安装
- en: 'After installing the extension for the first time, you might get prompted to
    install more dependencies. Do so by clicking on the **Install** button. If you
    do not get prompt, you can also install all dependencies by hitting *Ctrl* + *Shift*
    + *P* and entering the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首次安装扩展后，可能会提示您安装更多依赖项。通过点击 **安装** 按钮进行安装。如果没有提示，您也可以通过按 *Ctrl* + *Shift* + *P*
    并输入以下命令来安装所有依赖项：
- en: '[PRE20]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Select the **Go: Install/Update Tools** command and hit *Enter*:![Figure 1.2
    – Go: Install/Update Tools command to execute'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择 **Go: 安装/更新工具** 命令，然后按 *Enter*：![图 1.2 – 执行安装/更新工具命令'
- en: '](img/Figure_1.2_B16555.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_1.2_B16555.jpg)'
- en: 'Figure 1.2 – Go: Install/Update Tools command to execute'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.2 – 执行安装/更新工具命令
- en: Now select all dependencies by checking the box on the left side and click **OK**:![Figure
    1.3 – Selection of all dependencies
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过在左侧勾选复选框来选择所有依赖项，然后点击 **确定**：![图 1.3 – 选择所有依赖项
- en: '](img/Figure_1.3_B16555.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_1.3_B16555.jpg)'
- en: Figure 1.3 – Selection of all dependencies
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.3 – 选择所有依赖项
- en: 'VS Code will now install all dependencies, and it should print the following
    message when done:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VS Code 现在将安装所有依赖项，完成后应会打印以下消息：
- en: '[PRE21]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we'll see the TinyGo integration in VS Code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到 VS Code 中的 TinyGo 集成。
- en: The TinyGo extension
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TinyGo 扩展
- en: 'TinyGo integration in VS Code is straightforward as there is a TinyGo extension
    that we simply need to install. Let''s quickly go through the steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo 在 VS Code 中的集成非常简单，因为有一个 TinyGo 扩展，我们只需要安装它。让我们快速浏览以下步骤：
- en: Open the **Extensions** view either by clicking on the **Extensions** icon or
    pressing *Ctrl* + *Shift* + *X*.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **扩展** 图标或按 *Ctrl* + *Shift* + *X* 来打开 **扩展** 视图。
- en: Search for **TinyGo**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 **TinyGo**。
- en: Select the first entry in the list, which is called **TinyGo** and is from the
    TinyGo team.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择列表中的第一个条目，它被称为 **TinyGo**，由 TinyGo 团队提供。
- en: Click on the **Install** button, as seen in the following screenshot:![Figure
    1.4 – Extensions view showing the TinyGo extension
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击以下截图中的 **安装** 按钮：![图 1.4 – 显示 TinyGo 扩展的扩展视图
- en: '](img/Figure_1.4_B16555.jpg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_1.4_B16555.jpg)'
- en: Figure 1.4 – Extensions view showing the TinyGo extension
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.4 – 显示 TinyGo 扩展的扩展视图
- en: We are not done with installing the extension. We need to use another command
    to configure the target we want to build for. Hit *Ctrl* + *Shift* + *P*, type
    `TinyGo target`, and hit *Enter*.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有完成扩展的安装。我们需要使用另一个命令来配置我们想要构建的目标。按 *Ctrl* + *Shift* + *P*，输入 `TinyGo target`，然后按
    *Enter*。
- en: Now search for `arduino` and hit *Enter*, as we see in the following screenshot:![Figure
    1.5 – The target selection popup
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，搜索`arduino`并按*Enter*键，正如我们在以下截图中所见：![图1.5 – 目标选择弹出窗口
- en: '](img/Figure_1.5_B16555.jpg)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_1.5_B16555.jpg)'
- en: Figure 1.5 – The target selection popup
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.5 – 目标选择弹出窗口
- en: 'VS Code will open a popup telling you that it needs to reload the window. Do
    so by clicking on **Reload**:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: VS Code将打开一个弹出窗口，告诉您它需要重新加载窗口。通过点击**重新加载**来完成此操作：
- en: '![Figure 1.6 – Popup asking to reload the window'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – 弹出窗口请求重新加载窗口'
- en: '](img/Figure_1.6_B16555.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.6_B16555.jpg)'
- en: Figure 1.6 – Popup asking to reload the window
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 弹出窗口请求重新加载窗口
- en: Okay, we now have the extension installed and have selected a target. But what
    does it do internally? The only function of this extension is to set the `go.toolsEnvVars`
    variable in `vs code settings.json` of your current project.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在已经安装了扩展，并选择了一个目标。但是，它内部是如何工作的？这个扩展的唯一功能是在当前项目的`vs code settings.json`中设置`go.toolsEnvVars`变量。
- en: 'This could look like the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像以下示例：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sometimes a popup similar to the one in the following screenshot will appear.
    Do not click on **Update tools**; just close it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会出现类似于以下截图的弹出窗口。不要点击**更新工具**；只需关闭它。
- en: '![Figure 1.7 – Popup asking to update tools'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 – 弹出窗口请求更新工具'
- en: '](img/Figure_1.7_B16555.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.7_B16555.jpg)'
- en: Figure 1.7 – Popup asking to update tools
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 弹出窗口请求更新工具
- en: If you are using VS Code, congratulations, you are done with the setup and are
    ready to go! The next sections are going to explain how to set up the IDE integration
    in other editors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用VS Code，恭喜您，您已完成设置，准备开始使用！接下来的几节将解释如何在其他编辑器中设置IDE集成。
- en: General IDE integration
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用IDE集成
- en: You may wonder, how does IDE integration work with TinyGo? Well, we simply have
    to configure the standard Go tooling, especially the **gopls language** server.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，IDE集成是如何与TinyGo一起工作的？嗯，我们只需要配置标准的Go工具，特别是**gopls语言**服务器。
- en: TinyGo has its own implementation of the standard libraries and also provides
    additional libraries, such as the machine package. The gopls language server needs
    to know where to look for these packages. That is why we need to set a `GOROOT`
    for this project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo有自己的标准库实现，并提供额外的库，例如机器包。gopls语言服务器需要知道在哪里查找这些包。这就是为什么我们需要为这个项目设置一个`GOROOT`。
- en: 'TinyGo makes heavy use of compiler flags. These flags are used during compile
    time to determine which files must be included in the build, as we see in the
    following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo大量使用编译器标志。这些标志在编译时用于确定哪些文件必须包含在构建中，正如我们在以下截图中所见：
- en: '![Figure 1.8 – The board_arduino.go file from the TinyGo source code showing
    a build flag'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – 来自TinyGo源代码的board_arduino.go文件显示构建标志'
- en: '](img/Figure_1.8_B16555.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.8_B16555.jpg)'
- en: Figure 1.8 – The board_arduino.go file from the TinyGo source code showing a
    build flag
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 来自TinyGo源代码的board_arduino.go文件显示构建标志
- en: So basically, we integrate TinyGo into an IDE by locally setting these environment
    variables.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们通过在本地设置这些环境变量将TinyGo集成到IDE中。
- en: 'We do not have to guess the correct values for `GOROOT` and `GOFLAGS`. TinyGo
    provides a command for that purpose. Let''s say we want to set the correct flags
    for an Arduino, we can find out by using the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必猜测`GOROOT`和`GOFLAGS`的正确值。TinyGo提供了一个用于此目的的命令。假设我们想要为Arduino设置正确的标志，我们可以通过以下命令来查找：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will print the following result:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下结果：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The important parts of the output are `build tags` and `cached GOROOT`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的重要部分是`build`标签和`缓存的GOROOT`。
- en: As we now know where to find the needed information, we can go ahead and configure
    any IDE we want to use.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了所需信息的来源，我们就可以配置我们想要使用的任何IDE。
- en: Setting up Goland
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Goland
- en: As we have now learned that we must set a `GOROOT` and `build` tags, we can
    also configure the integration in Goland.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解到我们必须设置`GOROOT`和`build`标签，我们也可以在Goland中配置集成。
- en: 'Set `GOROOT` from the `tinygo info` command, as seen in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下截图中的`tinygo info`命令设置`GOROOT`：
- en: '![Figure 1.9 – GOROOT configuration in Goland'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 – Goland中的GOROOT配置'
- en: '](img/Figure_1.9_B16555.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.9_B16555.jpg)'
- en: Figure 1.9 – GOROOT configuration in Goland
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – Goland中的GOROOT配置
- en: 'The next step is to set the `build` tags. You can find them under **Build Tags
    & Vendoring**.Add the tags into the **Custom tags** field:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置`build`标签。您可以在**构建标签和供应商**下找到它们。将这些标签添加到**自定义标签**字段中：
- en: '![ Figure 1.10 – Custom tags configuration in Goland'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – Goland 中的自定义标签配置'
- en: '](img/Figure_1.10_B16555.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.10_B16555.jpg)'
- en: Figure 1.10 – Custom tags configuration in Goland
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – Goland 中的自定义标签配置
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You must manually change **Custom tags** each time you want to program for another
    microcontroller.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您想要为另一个微控制器编程时，都必须手动更改**自定义标签**。
- en: Integrating any editor
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成任何编辑器
- en: If you have the standard Go tolling installed, you can use any other editor
    such as Vim or Nano so you can get IDE support. As other editors might lack configuration
    files, we can work around this fact by passing them the environment variables
    at the moment we start them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装标准 Go 工具，您可以使用任何其他编辑器，例如 Vim 或 Nano，以便您获得 IDE 支持。由于其他编辑器可能缺少配置文件，我们可以通过在启动时传递它们环境变量来解决这个问题。
- en: 'In the following example, we start a VS Code instance by first setting environment
    variables and then starting VS Code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们首先设置环境变量，然后启动 VS Code 实例：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can exchange the code call to any other program such as `vim` or `nano`.
    On Windows systems, the call might look a little bit different.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将代码调用更改为任何其他程序，例如 `vim` 或 `nano`。在 Windows 系统上，调用可能略有不同。
- en: As we now know how to configure any IDE for the use of TinyGo, we will move
    on to learn about the Arduino UNO.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道如何为 TinyGo 配置任何 IDE，我们将继续学习关于 Arduino UNO 的内容。
- en: The Arduino UNO
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino UNO
- en: The Arduino UNO is one of the most popular boards out there. It is powered by
    an 8-bit ATmega328P microcontroller, and as of the writing of this book, there
    are lots of derivates from the original Arduino UNO boards. Let's get to know
    it better in the following subsections.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino UNO 是最受欢迎的板之一。它由一个 8 位 ATmega328P 微控制器供电，截至本书编写时，有大量源自原始 Arduino UNO
    板的衍生产品。让我们在以下小节中更好地了解它。
- en: Getting to know the technical specifications
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解技术规格
- en: As you can see in the following table, the ATmega328P has only 16 MHz and 32
    KB Flash memory. Standard Go produces a Hello World program of about 1.2 MB, which
    would not even fit on this microcontroller. So, we are working with very limited
    hardware here, but you will see that this is sufficient to build amazing projects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下表中看到的，ATmega328P 只有 16 MHz 和 32 KB 闪存。标准 Go 生成大约 1.2 MB 的 Hello World 程序，甚至无法适应这个微控制器。因此，我们在非常有限的硬件上工作，但您将看到这足以构建惊人的项目。
- en: 'Here is a brief look at the technical specs of the Arduino UNO:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里简要地看看 Arduino UNO 的技术规格：
- en: '![Table 1.1 – Technical specifications'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.1 – 技术规格'
- en: '](img/Table_1.1_B16555.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_1.1_B16555.jpg)'
- en: Table 1.1 – Technical specifications
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 技术规格
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Consider the DC current per I/O pin of 20 mA as an upper limit. You should not
    exceed this limit to prevent damaging your microcontroller.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑每个 I/O 引脚的直流电流上限为 20 mA。您不应超过此限制，以防止损坏您的微控制器。
- en: Let's have a look at the pinout next.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看引脚图。
- en: Exploring pinout
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索引脚图
- en: A **Pinout** is basically a map of the pins. We are going to use the descriptions
    of these pins in all projects that we build with the Arduino UNO. We will need
    it to correctly wire our components.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**引脚图**基本上是引脚的映射。我们将使用我们在 Arduino UNO 上构建的所有项目的这些引脚的描述。我们需要它来正确布线我们的组件。'
- en: '![Figure 1.11 – Arduino UNO REV3 pinout'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – Arduino UNO REV3 引脚图'
- en: '](img/Figure_1.11_B16555.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.11_B16555.jpg)'
- en: Figure 1.11 – Arduino UNO REV3 pinout
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – Arduino UNO REV3 引脚图
- en: As we now have learned some basic information about the Arduino UNO, let's go
    on and write our first program.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了一些关于 Arduino UNO 的基本信息，让我们继续编写我们的第一个程序。
- en: Checking out the Hello World of Things
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查事物的 Hello World
- en: A Hello World program is the typical way to start the journey in a new programming
    language. A Hello World program on a microcontroller looks a bit different compared
    to a normal Hello World program. We are going to write a Hello World program to
    let the built-in LED blink. Let's get started!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Hello World 程序是开始学习一门新编程语言的典型方式。与普通 Hello World 程序相比，微控制器上的 Hello World 程序看起来略有不同。我们将编写一个
    Hello World 程序来使内置 LED 闪烁。让我们开始吧！
- en: Getting the requirements ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备要求
- en: 'To get started with our program, we need the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用我们的程序，我们需要以下内容：
- en: An Arduino UNO
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino UNO
- en: One USB cable to connect it to your computer
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根 USB 线连接到您的电脑
- en: Preparing the project
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备项目
- en: 'Follow these steps closely for your project:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 严格按照以下步骤进行您的项目：
- en: Create a new folder named `ch1` in the root of your project.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目根目录下创建一个名为 `ch1` 的新文件夹。
- en: Inside the folder, we need to create a folder named `hello-world-of-things`
    and inside it, we are going to create a new `main.go` file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹内，我们需要创建一个名为 `hello-world-of-things` 的文件夹，并在其中创建一个新的 `main.go` 文件。
- en: 'Your structure should now look like the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的结构现在应该如下所示：
- en: '![Figure 1.12 – The project structure'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 项目结构'
- en: '](img/Figure_1.12_B16555.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.12_B16555.jpg)'
- en: Figure 1.12 – The project structure
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 项目结构
- en: As we have now prepared our project, we can go on and write our first program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的项目，我们可以继续编写我们的第一个程序。
- en: Programming the microcontroller
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程微控制器
- en: 'We are going to let the onboard LED blink. It is the easiest possible start
    for us. The example we are using is inspired by the *Blinky example* from the
    TinyGo source code, which is also used as a Hello World of Things showcase. Let''s
    go through each step carefully:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让板载 LED 闪烁。这是我们最容易开始的例子。我们使用的例子是受 TinyGo 源代码中的 *Blinky 示例* 启发，该示例也被用作事物世界问候的展示。让我们仔细地过一遍每个步骤：
- en: 'Declare the `main` package:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `main` 包：
- en: '[PRE26]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Import the packages `machine` and `time`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `machine` 和 `time` 包：
- en: '[PRE27]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add a `main` function:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `main` 函数：
- en: '[PRE28]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Initialize a variable named `led` with the value `machine.LED`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个名为 `led` 的变量，其值为 `machine.LED`：
- en: '[PRE29]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Configure the `led` pin as the output pin:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `led` 引脚配置为输出引脚：
- en: '[PRE30]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare an endless loop:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个无限循环：
- en: '[PRE31]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Set the `led` to `Low` so that no voltage is given on the LED:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `led` 设置为 `Low` 以确保不向 LED 提供电压：
- en: '[PRE32]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Set `sleep` for `300` milliseconds, that is the time the LED is off:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sleep` 设置为 `300` 毫秒，即 LED 关闭的时间：
- en: '[PRE33]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set the `led` to `High` so a voltage is given to the LED to make it shine:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `led` 设置为 `High` 以给 LED 提供电压，使其发光：
- en: '[PRE34]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set `Sleep` for `300` milliseconds, which is the amount of time the LED is
    on for:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sleep` 设置为 `300` 毫秒，这是 LED 亮的时间：
- en: '[PRE35]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Close the `for` loop:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `for` 循环：
- en: '[PRE36]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Closing braces for the `main` function:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 函数的闭合花括号：'
- en: '[PRE37]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `machine` package provides constants for the pin mapping and provides some
    more functions that are directly related to the used microcontroller.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`machine` 包提供了引脚映射的常量，并提供了一些与所使用的微控制器直接相关的函数。'
- en: We must wait for a certain amount of time between giving voltage to the LED
    and taking it off again, so we can see the blinking.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在给 LED 提供电压和再次断电之间等待一定的时间，这样我们才能看到闪烁。
- en: Configuring a pin as output means that we tell the microcontroller that we are
    only going to send signals using this pin. We can also configure a pin as input,
    which enables us to read the state from the pin.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将引脚配置为输出意味着我们告诉微控制器我们只将通过此引脚发送信号。我们也可以将引脚配置为输入，这样我们就可以从引脚读取状态。
- en: Flashing the program
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪存程序
- en: Flashing the program is a simple command, if you are on Linux, macOS, or are
    using Windows WSL.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Linux、macOS 或使用 Windows WSL，闪存程序是一个简单的命令。
- en: 'Simply connect your Arduino UNO to any USB port and execute the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将你的 Arduino UNO 连接到任何 USB 端口并执行以下命令：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `tinygo flash` command needs at least the following parameters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`tinygo flash` 命令至少需要以下参数：'
- en: '`--target`, which sets the microcontroller to flash'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--target`，该命令将微控制器设置为闪存：'
- en: The path to the `main.go` file
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.go` 文件的路径'
- en: 'Your output should look like the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该如下所示：
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, in my example, the code flashed onto the Arduino UNO is only
    using 558 bytes of memory.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在我的例子中，闪存到 Arduino UNO 的代码只使用了 558 字节的内存。
- en: Congratulations, you have successfully written, built, and flashed your first
    program onto an Arduino UNO using TinyGo.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经成功使用 TinyGo 在 Arduino UNO 上编写、构建和闪存了你的第一个程序。
- en: Using TinyGo Playground
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TinyGo Playground
- en: You don't have an Arduino UNO right now? You can test the code using **TinyGo
    Playground**. TinyGo Playground makes use of WebAssembly to emulate the behavior
    of a small number of boards such as the Arduino Nano IoT 33 and the Arduino UNO.
    It can also compile programs for the Arduino Nano IoT 33\. But please keep in
    mind that the behavior in the TinyGo Playground might differ from real hardware.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在没有 Arduino UNO？你可以使用 **TinyGo Playground** 测试代码。TinyGo Playground 利用 WebAssembly
    模拟少量板的行为，例如 Arduino Nano IoT 33 和 Arduino UNO。它还可以为 Arduino Nano IoT 33 编译程序。但请记住，TinyGo
    Playground 中的行为可能与真实硬件不同。
- en: You can find the TinyGo Playground at [https://play.tinygo.org/](https://play.tinygo.org/).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://play.tinygo.org/](https://play.tinygo.org/) 找到 TinyGo Playground。
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned what TinyGo actually is, how it differs from standard Go, we
    have acquired basic knowledge about the Arduino UNO itself, how to set up TinyGo,
    how to set up IDE integration, and finally, wrote and flashed our first program
    onto real hardware and made an LED blink with our code. Isn't that an interesting
    start?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了TinyGo实际上是什么，它与标准Go有何不同，我们获得了关于Arduino UNO本身的基本知识，如何设置TinyGo，如何设置IDE集成，最后，我们将我们的第一个程序写入并烧录到真实硬件上，并用我们的代码使LED闪烁。这不是一个有趣的开始吗？
- en: We are going to build a traffic light controller system in the next chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章构建一个交通灯控制器系统。
- en: Questions
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which command can be used to find out the needed environment variable values
    for the IDE integration?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令可以用来找出用于IDE集成的所需环境变量值？
- en: Which command can be used to flash a program onto a microcontroller?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令可以用来将程序烧录到微控制器上？
- en: Why do we have to sleep a certain amount of time when giving voltage or taking
    voltage away from the LED?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在给LED供电或从LED取电时，我们必须让电路休眠一段时间？
- en: How would you let the LED blink S-O-S in morse code?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何让LED以摩尔斯电码闪烁S-O-S？
