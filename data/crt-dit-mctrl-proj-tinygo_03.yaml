- en: '*Chapter 3*: Building a Safety Lock Using a Keypad'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：使用键盘构建安全锁'
- en: We gained basic knowledge of using LEDs, GPIO ports, and resistors in the last
    chapter. We also learned how to handle input and output. In this chapter, we are
    going to build a safety lock using a keypad. We will be able to input a passcode
    in the keypad that triggers a servomotor to unlock a lock. This will be achieved
    by splitting up the project into individual steps and putting it all together
    at the end of the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用LED、GPIO端口和电阻，以及如何处理输入和输出。在本章中，我们将使用键盘构建一个安全锁。我们可以在键盘上输入一个密码，触发伺服电机解锁锁。这将通过将项目分解成单独的步骤并在本章末尾将其全部组合来实现。
- en: After working through this chapter, we will know how to write information to
    the serial port and how to monitor this information. This is a great way to easily
    debug an application. Then, we are going to write our own driver for a 4x4 keypad,
    which can be used as passcode input in our case. This 4x4 keypad can also be used
    as controller input, or as input to start different parts of a program. With that
    covered, we are going to write the logic to control a servomotor. Servomotors
    can be used as a lock mechanism and are also often used in remote-controlled planes.
    In the end, we will have a project where we can set up a passcode, enter the passcode,
    and trigger the servomotor if the input was correct.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，我们将了解如何将信息写入串行端口以及如何监控这些信息。这是一种轻松调试应用程序的好方法。然后，我们将编写自己的4x4键盘驱动程序，在我们的情况下，它可以作为密码输入使用。这个4x4键盘也可以用作控制器输入，或者作为启动程序不同部分的输入。在完成这些后，我们将编写控制伺服电机的逻辑。伺服电机可以用作锁机制，也常用于遥控飞机。最后，我们将有一个项目，可以设置密码，输入密码，如果输入正确，则触发伺服电机。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Writing to the serial port
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向串行端口写入
- en: Monitoring the serial port
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控串行端口
- en: Monitoring input from a keypad
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控键盘输入
- en: Writing the driver
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写驱动程序
- en: Finding drivers for TinyGo
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找TinyGo的驱动程序
- en: Controlling a servomotor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制伺服电机
- en: Building a safety lock using a keypad
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘构建安全锁
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We are going to need the following components for this project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在微控制器上调试程序，我们需要以下组件：
- en: One Arduino Uno
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno
- en: One 4x4 membrane keypad
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个4x4膜式键盘
- en: One SG90 servomotor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个SG90伺服电机
- en: One red LED
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个红色LED
- en: One green LED
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绿色LED
- en: 14 jumper wires
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 14根跳线
- en: Two 220 Ohm resistors
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个220欧姆电阻
- en: A breadboard
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块面包板
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter03)
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3uN9OAf](https://bit.ly/3uN9OAf)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在以下链接找到：[https://bit.ly/3uN9OAf](https://bit.ly/3uN9OAf)
- en: Writing to the serial port
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向串行端口写入
- en: An easy way to debug your programs on a microcontroller is to write messages
    to the serial port. You can later use this technique to debug your program, by
    printing the current step or sensor values, for example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在微控制器上调试程序的一个简单方法是向串行端口写入消息。您可以使用此技术来调试程序，例如打印当前步骤或传感器值。
- en: 'Let''s write a small program to see how writing to a serial port is done. We
    start by creating a new folder named `Chapter03` in the project directory, and
    inside this new directory, we create another directory named `writing-to-serial`.
    Now we have to create a new `main.go` file and insert an empty `main()` function.
    The folder structure should now look like the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个小程序来看看如何向串行端口写入。我们首先在项目目录中创建一个名为`Chapter03`的新文件夹，然后在这个新目录内创建另一个名为`writing-to-serial`的新目录。现在我们需要创建一个新的`main.go`文件并插入一个空的`main()`函数。文件夹结构现在应该如下所示：
- en: '![Figure 3.1 – The folder structure for writing to serial port'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 向串行端口写入的文件夹结构'
- en: '](img/Figure_3.1_B16555.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1_B16555.jpg)'
- en: Figure 3.1 – The folder structure for writing to serial port
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 向串行端口写入的文件夹结构
- en: 'Now, follow these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请按照以下步骤操作：
- en: 'We print the word `starting` followed by a space and print the word `program`
    followed by an `\n`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印单词`starting`后跟一个空格，然后打印单词`program`后跟一个`\n`：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We endlessly loop, print `Hello World`, and sleep for a second:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们无限循环，打印`Hello World`并暂停一秒钟：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, flash the program to your microcontroller by using the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令将程序烧录到您的微控制器中：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, we now have a program on our controller that prints text to the serial
    port. We have learned about a very convenient way to insert debug logging into
    our programs. In the next section, we are going to learn how to read data from
    the serial port on the computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在在控制器上有一个程序，它会将文本打印到串行端口。我们已经了解了一种非常方便的方法，可以将调试日志插入到我们的程序中。在下一节中，我们将学习如何从计算机上的串行端口读取数据。
- en: Monitoring the serial port
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控串行端口
- en: As we are writing debug logs or other messages to the serial port, we need a
    convenient way to monitor these logs. An easy way to monitor the serial port on
    all operating systems is to use PuTTy.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向串行端口写入调试日志或其他消息时，我们需要一种方便的方式来监控这些日志。在所有操作系统上监控串行端口的一个简单方法是使用PuTTY。
- en: 'Let''s first look at how to install PuTTy on various platforms:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何在各种平台上安装PuTTy：
- en: '`apt`. We can install it using the following command:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt`。我们可以使用以下命令来安装它：'
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`brew`. We can install it using the following command:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brew`。我们可以使用以下命令来安装它：'
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`.msi` file.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.msi`文件。'
- en: 'As we have now installed PuTty, it is time to monitor our serial port:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经安装了PuTTY，现在是时候监控我们的串行端口了：
- en: Make sure the program from the previous section is flashed on your microcontroller
    and the USB cable is plugged in.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保上一节中的程序已经烧录到您的微控制器中，并且USB线已经插入。
- en: The next step is starting PuTTy. As soon as PuTTy is started, click on **Session**
    and select **Serial** for **Connection type**. This should look as in the following
    screenshot:![Figure 3.2 – PuTTy Configuration
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是启动PuTTY。一旦PuTTY启动，点击**会话**并选择**串行**作为**连接类型**。这应该看起来像以下截图：![图3.2 – PuTTy配置
- en: '](img/Figure_3.2_B16555.jpg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B16555.jpg)'
- en: Figure 3.2 – PuTTy Configuration
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2 – PuTTy配置
- en: Now we have to choose the serial line. On Windows, this will typically be `/dev/ttyACM0`
    or `/dev/ttyUSB0`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须选择串行线路。在Windows上，这通常是`/dev/ttyACM0`或`/dev/ttyUSB0`。
- en: As we have now successfully configured the session, we can save this configuration.
    To do so, add `Microcontroller` as the name and click on **Save**. This should
    look as in the following screenshot:![Figure 3.3 – PuTTy saving the configuration
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在已经成功配置了会话，我们可以保存此配置。为此，将`Microcontroller`作为名称并点击**保存**。这应该看起来像以下截图：![图3.3
    – PuTTy保存配置
- en: '](img/Figure_3.3_B16555.jpg)'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.3_B16555.jpg)'
- en: Figure 3.3 – PuTTy saving the configuration
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.3 – PuTTy保存配置
- en: As we have now saved the configuration, we can reuse it each time we want to
    monitor the serial port. Now select **Microcontroller** from the list and click
    on the **Open** button:![Figure 3.4 – PuTTy Microcontroller session selected
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在已经保存了配置，我们可以在每次想要监控串行端口时重用它。现在从列表中选择**微控制器**并点击**打开**按钮：![图3.4 – PuTTy微控制器会话已选择
- en: '](img/Figure_3.4_B16555.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4_B16555.jpg)'
- en: Figure 3.4 – PuTTy Microcontroller session selected
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.4 – PuTTy微控制器会话已选择
- en: 'After clicking on the **Open** button, a new window opens, which shows the
    output from our program. It should look similar to the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**打开**按钮后，将打开一个新窗口，显示我们程序的输出。它应该看起来类似于以下截图：
- en: '![Figure 3.5 – PuTTy program output'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – PuTTy程序输出'
- en: '](img/Figure_3.5_B16555.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.5_B16555.jpg)'
- en: Figure 3.5 – PuTTy program output
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – PuTTy程序输出
- en: We have now learned how to monitor the output of our programs. Next, we are
    going to learn how to use a 4x4 keypad and monitor button presses.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何监控我们程序的输出。接下来，我们将学习如何使用4x4键盘并监控按键。
- en: Monitoring input from a keypad
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控键盘输入
- en: In this section, we are going to read input from a 4x4 keypad and print the
    pressed button to the serial port. Since TinyGo does not have a driver for this
    keypad, we will look at how to create a driver. This will help you understand
    the process and you can use this knowledge when you need to use other unsupported
    hardware.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从4x4键盘读取输入并将按下的按钮打印到串行端口。由于TinyGo没有为此键盘提供驱动程序，我们将看看如何创建一个驱动程序。这将帮助您理解这个过程，并且当您需要使用其他不受支持的硬件时，您可以使用这些知识。
- en: As part of this exercise, I have also followed the process of adding this to
    the TinyGo codebase and it should be supported in the future. We are going to
    start by learning how to connect the keypad. Then we will move on to writing a
    driver, and then we are going to have a brief look at how new drivers are added
    to TinyGo.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个练习的一部分，我还遵循了将其添加到 TinyGo 代码库的过程，并且它应该在未来得到支持。我们将从学习如何连接键盘开始。然后我们将继续编写驱动程序，然后我们将简要地看看如何将新驱动程序添加到
    TinyGo。
- en: Building the circuit
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'We start off by assembling the circuit. We are going to need a 4x4 keypad and
    eight jumper wires. Although we could use jumper cables to directly wire the keypad
    to the Arduino ports, we are going to wire it through a breadboard. We are going
    to add more components to this in the upcoming sections. Follow these steps to
    correctly wire the keypad:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先组装电路。我们需要一个 4x4 键盘和八根跳线。虽然我们可以使用跳线直接将键盘连接到 Arduino 端口，但我们将通过面包板进行连接。我们将在接下来的章节中添加更多组件。按照以下步骤正确连接键盘：
- en: Connect pin *D3* to *A32*.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D3* 连接到 *A32*。
- en: Connect pin *D4* to *A31*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D4* 连接到 *A31*。
- en: Connect pin *D5* to *A30*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D5* 连接到 *A30*。
- en: Connect pin *D6* to *A29*.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D6* 连接到 *A29*。
- en: Connect pin *D7* to *A28*.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D7* 连接到 *A28*。
- en: Connect pin *D8* to *A27*.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D8* 连接到 *A27*。
- en: Connect pin *D9* to *A26*.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D9* 连接到 *A26*。
- en: Connect pin *D10* to *A25*.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚 *D10* 连接到 *A25*。
- en: Connect *E32* with pin *0* on the keypad.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E32* 与键盘上的 *0* 号引脚连接。
- en: Connect *E31* with pin *1* on the keypad.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E31* 与键盘上的 *1* 号引脚连接。
- en: Connect *E30* with pin *2* on the keypad.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E30* 与键盘上的 *2* 号引脚连接。
- en: Connect *E29* with pin *3* on the keypad.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E29* 与键盘上的 *3* 号引脚连接。
- en: Connect *E28* with pin *4* on the keypad.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E28* 与键盘上的 *4* 号引脚连接。
- en: Connect *E27* with pin *5* on the keypad.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E27* 与键盘上的 *5* 号引脚连接。
- en: Connect *E26* with pin *6* on the keypad.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E26* 与键盘上的 *6* 号引脚连接。
- en: Connect *E25* with P pin in *7* on the keypad.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *E25* 与键盘上的 *7* 号 P 引脚连接。
- en: 'Having done this, your circuit should look similar to the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，您的电路应类似于以下截图：
- en: '![Figure 3.6 – Keypad circuit – image is taken from Fritzing'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – 键盘电路 – 图片来自 Fritzing'
- en: '](img/Figure_3.6_B16555.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.6_B16555.jpg)'
- en: Figure 3.6 – Keypad circuit – image is taken from Fritzing
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 键盘电路 – 图片来自 Fritzing
- en: We have now correctly wired the keypad. Before we can go on with implementing
    the code, we need to understand how a 4x4 keypad works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经正确地连接了键盘。在我们继续编写代码之前，我们需要了解 4x4 键盘是如何工作的。
- en: Understanding the workings of a 4x4 keypad
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 4x4 键盘的工作原理
- en: Having a look at the keypad, we realize that it basically consists of **four
    rows** with **four columns** per row. The keypad comes with eight pins. The first
    four pins are used for the rows, and the remaining four are used for the columns.
    To determine which key is being pressed, we just need to find the position of
    the pressed key in this 4x4 coordinate system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 观察键盘，我们发现它基本上由 **四行** 组成，每行有 **四列**。键盘共有八个引脚。前四个引脚用于行，剩下的四个用于列。为了确定哪个键被按下，我们只需找到按下键在
    4x4 坐标系统中的位置。
- en: Button **1**, for example, has the coordinates 0,0 (row 0, column 0), while
    button **D** has the coordinates 3,3 (row 3, column 3).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，按钮 **1** 的坐标是 0,0（行 0，列 0），而按钮 **D** 的坐标是 3,3（行 3，列 3）。
- en: In the internal circuit of the keypad, the rows are connected to the columns.
    When a button is being pressed, the circuit is closed. When the circuit is closed,
    current flows, which is the signal we can read on a pin. As the keypad is not
    directly connected to GND and VCC, we need to provide the keypad with power. That
    is why four pins will be used as input and four will be used as output pins.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在键盘的内部电路中，行与列相连。当按钮被按下时，电路闭合。当电路闭合时，电流流动，这就是我们可以在引脚上读取的信号。由于键盘没有直接连接到 GND 和
    VCC，我们需要为键盘提供电源。这就是为什么将使用四个引脚作为输入，四个作为输出引脚。
- en: 'I have dissembled such a 4x4 keypad, to provide a visual of the internal circuit:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经拆解了这样一个 4x4 键盘，以提供内部电路的视觉：
- en: '![Figure 3.7 – Keypad internal circuit'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – 键盘内部电路'
- en: '](img/Figure_3.7_B16555.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.7_B16555.jpg)'
- en: Figure 3.7 – Keypad internal circuit
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 键盘内部电路
- en: As we now know that we basically just have to check each coordinate in this
    4x4 coordinate system for the correct state, we can go on and write the code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们基本上只需要检查这个 4x4 坐标系统中的每个坐标是否处于正确状态，然后我们可以继续编写代码。
- en: Writing the driver
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写驱动程序
- en: As we want to have reusable code, we are going to write a driver package for
    the keypad. The driver will provide an easy-to-use interface while hiding the
    more complicated implementation logic. Doing it this way, we can simply reuse
    the package in later projects even beyond the book. The official TinyGo drivers
    typically provide a constructor-like function that creates a new instance of the
    driver and a `Configure` function that takes care of initialization. We are also
    going to provide a similar API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望有可重用的代码，我们将为键盘编写一个驱动程序包。驱动程序将提供一个易于使用的接口，同时隐藏更复杂的实现逻辑。这样做，我们可以在以后的工程中简单地重用这个包，甚至超出本书的范围。官方
    TinyGo 驱动程序通常提供一个类似于构造函数的函数来创建驱动程序的新实例，以及一个 `Configure` 函数来处理初始化。我们也将提供类似的 API。
- en: 'Just like in our previous projects, we are going to start by creating a new
    folder named `controlling-keypad` inside the `Chapter03` folder. Then, we are
    going to create a `main.go` file with an empty `main` function. Also, we need
    to create a new folder named `keypad` and create a new file named `driver.go`,
    and then name the package `keypad`. Your project structure should now look like
    the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的工程一样，我们将在 `Chapter03` 文件夹内创建一个名为 `controlling-keypad` 的新文件夹。然后，我们将在 `main.go`
    文件中创建一个空的 `main` 函数。此外，我们还需要创建一个名为 `keypad` 的新文件夹，并创建一个名为 `driver.go` 的新文件，然后命名包为
    `keypad`。现在，您的项目结构应该如下所示：
- en: '![Figure 3.8 – Project structure for writing the driver'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 编写驱动程序的工程结构](img/Figure_3.8_B16555.jpg)'
- en: '](img/Figure_3.8_B16555.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 编写驱动程序的工程结构](img/Figure_3.8_B16555.jpg)'
- en: Figure 3.8 – Project structure for writing the driver
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 编写驱动程序的工程结构
- en: 'We are going to split the logic into the following five parts:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逻辑分为以下五个部分：
- en: '`Driver` variables'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver` 变量'
- en: '`Configure`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Configure`'
- en: '`GetIndices`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetIndices`'
- en: '`GetKey`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetKey`'
- en: '`main`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`'
- en: Let's understand each of them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解每个部分。
- en: Driver variables
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动变量
- en: 'We are going to need some variables inside our `Driver` struct. Follow these
    steps to set it up:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Driver` 结构体内部，我们需要一些变量。按照以下步骤设置它：
- en: 'Define a new struct named `Driver`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的名为 `Driver` 的结构体：
- en: '[PRE5]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need an `inputEnabled` variable to debounce the keypresses:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个 `inputEnabled` 变量来去抖动按键：
- en: '[PRE6]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`lastColumn` and `lastRow` are used to save the position of the last keypress:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lastColumn` 和 `lastRow` 用于保存上次按键的位置：'
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need an array of `machine.Pin` to store the column pins:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个 `machine.Pin` 数组来存储列引脚：
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need an array of `machine.Pin` to store the row pins:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个 `machine.Pin` 数组来存储行引脚：
- en: '[PRE9]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use mapping to map the key values to indices (positions):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用映射将键值映射到索引（位置）：
- en: '[PRE10]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we are going to initialize the pins and the `Driver` variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将初始化引脚和 `Driver` 变量。
- en: Configure
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Configure
- en: 'Start off by creating an empty function named `Configure` that takes eight
    `machine.Pin` function as an argument and is a pointer receiver to `Driver`. This
    should look like the following snippet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为 `Configure` 的空函数，该函数接受八个 `machine.Pin` 函数作为参数，并且是 `Driver` 的指针接收器。这应该看起来像以下代码片段：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next step is to put the initialization logic into this function. To do
    so, follow these steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将初始化逻辑放入此函数中。为此，请按照以下步骤操作：
- en: 'Initialize the column pins using a PinInputPullup config. The internal pullup
    resistor is going to hold the column to 5 V until a button is being pressed, which
    we then can read as input:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PinInputPullup 配置初始化列引脚。内部上拉电阻将使列保持在 5 V，直到按键被按下，然后我们可以将其作为输入读取：
- en: '[PRE12]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the column pins to the `columns` array. By doing so, we can later just
    use a loop to iterate over all columns:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列引脚添加到 `columns` 数组中。这样做之后，我们就可以通过循环遍历所有列：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Initialize the row pins using the `PinOutput` config:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PinOutput` 配置初始化行引脚：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add all the row pins to the rows array. This enables us to iterate over all
    the rows using a loop:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有行引脚添加到行数组中。这样我们就可以通过循环遍历所有行：
- en: '[PRE15]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initialize the mapping with the key values. We will be mapping the pressed
    column and row index to get the correct key value:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键值初始化映射。我们将映射按下的列和行索引以获取正确的键值：
- en: '[PRE16]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initialize `inputEnabled`, `lastColumn`, and `lastRow`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `inputEnabled`、`lastColumn` 和 `lastRow`：
- en: '[PRE17]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is everything we need to initialize our program to talk to the keypad.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们初始化程序与键盘通信所需的一切。
- en: GetIndices
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetIndices
- en: 'Now we just need to loop over the arrays and columns and find the pressed key.
    We start by creating a new function named `GetIndices` that returns two integers
    and is a pointer receiver to `Driver`. This should look like the following snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要遍历数组和列，找到按下的键。我们首先创建一个名为 `GetIndices` 的新函数，该函数返回两个整数，并且是一个指向 `Driver`
    的指针接收器。这应该看起来像以下代码片段：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, follow these steps to implement the function logic:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤实现函数逻辑：
- en: 'Iterate over all rows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有行：
- en: '[PRE19]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Set the current `rowPin` to `Low`. We need to do this as we are using internal
    `rowPin` to `High` instead:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前的 `rowPin` 设置为 `Low`。我们需要这样做，因为我们正在使用内部的 `rowPin` 设置为 `High`：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Iterate over all columns:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有列：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Get the current `columnPin`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前的 `columnPin`：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Check whether the current `columnPin` is pressed and execute the logic if we
    accept input. Disable accepting input and save the current column and row, and
    then return the indices:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前的 `columnPin` 是否被按下，并在接受输入时执行逻辑。禁用接受输入并保存当前列和行，然后返回索引：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Accept the input again, if the previous key is not pressed anymore:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果之前的键不再被按下，请再次接受输入：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Set `rowPin` to `High` again and close the outer loop:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `rowPin` 再次设置为 `High` 并关闭外部循环：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Return `–1, -1` if no key was pressed and close the function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有按键被按下，则返回 `–1, -1` 并关闭函数：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Calling this function will now tell us the position of the pressed key in the
    coordinate system. If you want to understand pullup and pulldown resistors in
    more detail, have a look at the following link: [https://www.electronics-tutorials.ws/logic/pull-up-resistor.html](https://www.electronics-tutorials.ws/logic/pull-up-resistor.html).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数将告诉我们按下的键在坐标系中的位置。如果您想更详细地了解上拉和下拉电阻，请查看以下链接：[https://www.electronics-tutorials.ws/logic/pull-up-resistor.html](https://www.electronics-tutorials.ws/logic/pull-up-resistor.html)。
- en: GetKey
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GetKey
- en: 'Next, we are going to create a function that checks the indices of the pressed
    key and maps the indices to the key value. To do so, we start with an empty function
    named `GetKey` that returns a string and is a pointer receiver to `Driver`. This
    should look like the following snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个函数来检查按下的键的索引并将索引映射到键值。为此，我们从一个名为 `GetKey` 的空函数开始，该函数返回一个字符串，并且是一个指向
    `Driver` 的指针接收器。这应该看起来像以下代码片段：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Inside this function, we just call the `GetIndices` method, check whether a
    button was pressed, and if a button was pressed, we return the key value as a
    string. This looks like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数内部，我们只是调用 `GetIndices` 方法，检查是否按下了按钮，如果按下了按钮，我们就以字符串的形式返回键值。这看起来像以下代码：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, only the `main` logic is missing. Let's look at that next!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只缺少 `main` 逻辑。让我们看看下一个！
- en: main
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: main
- en: 'We call our initialization logic and loop endlessly to check the pressed key.
    The following steps show how:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用初始化逻辑并无限循环以检查按下的键。以下步骤展示了如何操作：
- en: 'Initialize `keypadDevice`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `keypadDevice`：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, loop endlessly, check for a keypress, and print the value if a key was
    pressed:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，无限循环，检查按键，如果按下了键就打印值：
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Great! That''s it. Now we can flash the program and monitor the outputs. Flash
    the program using the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这就完成了。现在我们可以烧录程序并监控输出。使用以下命令烧录程序：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, open PuTTy and monitor the serial output while pressing keys on the keypad.
    The output should look similar to the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 PuTTy 并在按键盘上的键时监控串行输出。输出应该类似于以下截图：
- en: '![Figure 3.9 – Keypad output in PuTTy'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.9 – PuTTy 中的按键输出'
- en: '](img/Figure_3.9_B16555.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.9_B16555.jpg)'
- en: Figure 3.9 – Keypad output in PuTTy
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – PuTTy 中的按键输出
- en: Great, we have successfully written our own driver to monitor button presses
    on a keypad!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们已经成功编写了自己的驱动程序来监控键盘上的按钮按下！
- en: In the next section, we are going to learn where to find TinyGo drivers for
    peripheral hardware. We are also going to look at the process of contributing
    to the TinyGo drivers repository.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习在哪里找到用于外围硬件的 TinyGo 驱动程序。我们还将查看向 TinyGo 驱动程序存储库贡献的过程。
- en: Finding drivers for TinyGo
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找 TinyGo 的驱动程序
- en: 'As of the time of writing, there are 53 devices supported by TinyGo. The driver
    we just wrote, which I am going to contribute to TinyGo, will support 54 devices.
    But where can we find drivers for devices that we want to use? The answer is simple:
    there is a repository for this purpose. You can find it at [https://github.com/tinygo-org/drivers](https://github.com/tinygo-org/drivers).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 截至写作时，TinyGo支持53种设备。我们刚刚编写的，我将要贡献给TinyGo的驱动程序将支持54种设备。但我们如何找到我们想要使用的设备的驱动程序呢？答案是简单的：有一个用于此目的的仓库。您可以在[https://github.com/tinygo-org/drivers](https://github.com/tinygo-org/drivers)找到它。
- en: In the next chapter, we will learn how to use such drivers when using different
    types of displays.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在使用不同类型的显示器时使用此类驱动程序。
- en: Contributing drivers to TinyGo
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为TinyGo贡献驱动程序
- en: 'The TinyGo community happily appreciates all contributions. If you develop
    a driver for a device and want to contribute it to TinyGo, you can follow these
    simple steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo社区非常欢迎所有贡献。如果您为设备开发了一个驱动程序并希望将其贡献给TinyGo，您可以遵循以下简单步骤：
- en: Open an issue and explain what you want to add and how you plan to implement
    it.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出一个问题并解释您想添加的内容以及您计划如何实现它。
- en: Fork the repository.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分叉仓库。
- en: Create a new branch based on the dev branch.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于dev分支创建一个新的分支。
- en: Create a pull request.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交一个pull request。
- en: 'You can find the contribution guidelines at the following link: [https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md](https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到贡献指南：[https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md](https://github.com/tinygo-org/drivers/blob/release/CONTRIBUTING.md)。
- en: All in all, my personal experience with the TinyGo community has been extremely
    positive. They are very polite and will help you out with any kind of problem.
    I have not encountered a single problem where the community could not give me
    a helpful answer. Don't be afraid to ask a question in an issue or on the TinyGo
    channel in the Gophers slack.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我对TinyGo社区的个人经历极为积极。他们非常礼貌，并且会帮助您解决任何问题。我没有遇到过社区无法给我提供有用答案的问题。不要害怕在问题中或在Gophers
    slack的TinyGo频道中提问。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please do not ask any questions that are directly related to this book in any
    of the official TinyGo channels, such as Slack or GitHub. If you have any questions
    regarding this book, you can raise an issue on the accompanying GitHub repository
    or send an email to me.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要在任何官方TinyGo渠道（如Slack或GitHub）中提出与此书直接相关的问题。如果您对此书有任何问题，可以在配套的GitHub仓库中提出问题或给我发送电子邮件。
- en: As we now know how keypads work and where to find drivers, we can go on with
    the next part of our safety lock.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，如何使用键盘和在哪里找到驱动程序，我们可以继续我们的安全锁的下一部分。
- en: Controlling a servomotor
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制伺服电机
- en: As we are now able to read the input to the keypad, the thing that is missing
    to build a safety lock is some kind of motor. For that case, we are going to use
    an SG90 servomotor. As of the time of writing, the timings on the Arduino Uno
    are not accurate enough to completely control the SG90 servomotor, but that is
    not a problem for our use case. We are just going to move the servo in one direction,
    which is clockwise. Also, there is currently no official driver for the SG90 servomotor,
    so we are going to write our own!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在能够读取键盘的输入，要构建一个安全锁所缺少的是某种类型的电机。为此，我们将使用SG90伺服电机。截至写作时，Arduino Uno上的定时不够准确，无法完全控制SG90伺服电机，但这对我们用例来说不是问题。我们只是将伺服器向一个方向移动，即顺时针方向。此外，目前还没有SG90伺服电机的官方驱动程序，因此我们将编写自己的驱动程序！
- en: Understanding SG90 servomotors
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解SG90伺服电机
- en: SG90 servomotors are controlled by **Pulse Width Moduluation** (**PWM**). Basically,
    the SG90 reads inputs in a 50 Hz period. During this period, we can tell the servomotor
    to adjust itself to a certain angle by setting a signal for a certain amount of
    time. The signal length is called the *duty cycle*. After the duty cycle, we wait
    for the rest of the period. Depending on the duty cycle (the **pulse width**),
    the SG90 will adjust its angle.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: SG90伺服电机由**脉冲宽度调制**（**PWM**）控制。基本上，SG90在一个50赫兹的周期内读取输入。在这个周期内，我们可以通过设置一定时间的信号来告诉伺服电机调整到一定的角度。这个信号的长度被称为*占空比*。在占空比之后，我们等待剩余的周期。根据占空比（**脉冲宽度**），SG90将调整其角度。
- en: 'The SG90 can be adjusted to the following three positions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: SG90可以调整到以下三个位置：
- en: 0 degrees (center) using a 1.5 ms pulse
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用1.5毫秒脉冲旋转0度（中心）。
- en: + 90 degrees (right) using a 2 ms pulse
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用2毫秒脉冲旋转+90度（右侧）。
- en: '- 90 degrees (left) using a 1 ms pulse'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用1毫秒脉冲旋转-90度（左侧）。
- en: It is also possible to adjust the servomotor to all angles in between this by
    doing some math on the pulse width sizes, but we do not need to do that for our
    example.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对脉冲宽度大小进行一些数学运算，也可以将伺服电机调整到这个范围内的所有角度，但我们的示例中不需要这样做。
- en: 'The SG90 typically has three wires:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: SG90通常有三根线：
- en: Black/brown for ground
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑色/棕色用于地线
- en: Red for VCC
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色用于VCC
- en: Orange/yellow for the PWM signal
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙色/黄色用于PWM信号
- en: Building the circuit
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'We will build on top of our last example. We just have to add the servomotor
    by following these steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在上一个示例的基础上进行构建。我们只需按照以下步骤添加伺服电机：
- en: Connect the 5 V port from the Arduino Uno to the positive lane on the power
    bus.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino Uno的5V端口连接到电源总线上的正线。
- en: Connect a GND port from the Arduino Uno to the ground lane on the power bus.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino Uno的GND端口连接到电源总线上的地线。
- en: Connect the GND wire from the SG90 to the ground lane on the power bus.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SG90的GND线连接到电源总线上的地线。
- en: Connect the VCC wire from the SG90 to the positive lane on the power bus.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SG90的VCC线连接到电源总线上的正线。
- en: Connect the PWM wire from the SG90 to pin *D11* on the Arduino Uno.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SG90的PWM线连接到Arduino Uno的*D11*引脚。
- en: 'Our circuit should now look as in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的电路应该看起来像下面的截图：
- en: '![Figure 3.10 – Keypad and servomotor'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 伺服电机和键盘](img/Figure_3.10_B16555.jpg)'
- en: '](img/Figure_3.10_B16555.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – 伺服电机和键盘](img/Figure_3.10_B16555.jpg)'
- en: Figure 3.10 – Keypad and servomotor
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – 键盘和伺服电机
- en: Excellent. Before we can start programming, we should learn something about
    PWM pins on the Arduino Uno. Only six pins of the GPIO ports are capable of PWM.
    The pins are marked with a **~** symbol.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。在我们开始编程之前，我们应该了解一些关于Arduino Uno上的PWM引脚的知识。只有GPIO端口中的六个引脚能够进行PWM。这些引脚被标记为**~**符号。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On the Arduino Uno, you can use pins *D3*, *D5*, *D6*, *D9*, *D10*, and *D11*
    for PWM.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino Uno上，你可以使用*D3*、*D5*、*D6*、*D9*、*D10*和*D11*引脚进行PWM。
- en: Writing the servo control logic
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写伺服控制逻辑
- en: 'We need to create a new folder named `controlling-servo` inside the `Chapter03`
    folder. Next, we create a new `main.go` file inside the new folder and insert
    an empty `main` function. Also, we need to create a new folder named `servo` with
    a new `driver.go` file inside the `servo` package. Our project structure should
    now look like the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Chapter03`文件夹内创建一个名为`controlling-servo`的新文件夹。接下来，在新的文件夹内创建一个名为`main.go`的新文件，并插入一个空的`main`函数。此外，我们还需要在`servo`包内创建一个名为`servo`的新文件夹，并包含一个名为`driver.go`的新文件。我们的项目结构现在应该看起来如下：
- en: '![Figure 3.11 – Project structure for servo control logic'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 伺服控制逻辑的项目结构](img/Figure_3.11_B16555.jpg)'
- en: '](img/Figure_3.11_B16555.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 – 伺服控制逻辑的项目结构](img/Figure_3.11_B16555.jpg)'
- en: Figure 3.11 – Project structure for servo control logic
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – 伺服控制逻辑的项目结构
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'PWM is currently being reworked. In the future handling, PWM devices will be
    much simpler. It is also being handled by hardware PWM instead of emulating the
    PWM behavior. You can check the progress at the following pull request: [https://github.com/tinygo-org/tinygo/pull/1121](https://github.com/tinygo-org/tinygo/pull/1121).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: PWM目前正在重做。在未来的处理中，PWM设备将更加简单。它现在也由硬件PWM而不是模拟PWM行为来处理。你可以在以下pull request中查看进度：[https://github.com/tinygo-org/tinygo/pull/1121](https://github.com/tinygo-org/tinygo/pull/1121)。
- en: The driver that we are now building has the main purpose of teaching us how
    PWM actually works and is going to work better on all microcontrollers that are
    not based on the 8-bit AVR architecture, such as the ATmega328P, which is onboard
    the Arduino Uno. This is due to the fact that the AVR support is still experimental,
    although it is being improved with nearly every release of TinyGo. As soon as
    the PR mentioned previously is merged, I recommend using a driver that is based
    on that hardware PWM support for controlling servos.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在构建的驱动器的主要目的是教我们PWM实际上是如何工作的，并且将在所有不是基于8位AVR架构的微控制器上运行得更好，例如Arduino Uno上的ATmega328P。这是因为尽管TinyGo的AVR支持正在随着每个版本的发布而不断改进，但它仍然是实验性的。一旦之前提到的PR被合并，我建议使用基于该硬件PWM支持的驱动器来控制伺服电机。
- en: Also be aware that as of the time of writing, you manually need to reset the
    servo when it reaches the rightmost position.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 也请注意，截至写作之时，当伺服电机到达最右侧位置时，你需要手动将其重置。
- en: 'Inside the `driver.go` file, we need to use the following steps to let our
    servo rotate a bit:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`driver.go`文件中，我们需要按照以下步骤来让我们的伺服电机旋转一点：
- en: 'Declare package-level constants for the duty cycles and `rightRemainingPeriod`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明包级别的常量用于占空比和`rightRemainingPeriod`：
- en: '[PRE32]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a new struct named `Driver` that has `machine.Pin` as a member:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Driver`的新结构体，它有一个`machine.Pin`成员：
- en: '[PRE33]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define a new, empty function named `Configure` that takes `machine.Pin` as
    a parameter and is a pointer receiver to `Driver`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Configure` 的新空函数，它接受 `machine.Pin` 作为参数，并且是 `Driver` 的指针接收器：
- en: '[PRE34]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Configure pin as output:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将引脚配置为输出：
- en: '[PRE35]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Loop four times to rotate the motor only about 30 degrees:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环四次，仅将电机旋转约30度：
- en: '[PRE36]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set a signal for the duty cycle, pull it down, and sleep for the rest of the
    period:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置占空比的信号，将其拉低，然后睡眠剩余的周期：
- en: '[PRE37]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we can try out our library, we need to write a small example program.
    To do so, put the following snippet inside the `main.go` file inside the controlling
    `servo` folder:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够尝试我们的库之前，我们需要编写一个小型的示例程序。为此，将以下片段放入控制 `servo` 文件夹内的 `main.go` 文件中：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we just need to try that program by flashing it using the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要通过以下命令闪烁程序来尝试该程序：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Congratulations, this was the first time that we moved something using code.
    As we have now learned how to rotate the servo a bit and how to read inputs from
    a keypad, the next step is to put everything together.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，这是我们第一次使用代码移动某个东西。既然我们已经学会了如何稍微旋转伺服电机以及如何从键盘读取输入，下一步就是将所有这些整合在一起。
- en: 'As soon as the refactoring of the PWM is merged to upstream and released in
    a TinyGo version, you do not want to use the previous driver anymore. For that
    case, we create a new driver that makes use of hardware PWM instead of emulating
    the behavior. So go on and create a new folder named `servo-pwm` and create a
    new `driver.go` file inside. Then follow these steps to implement the better driver:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PWM的重构合并到上游并发布在TinyGo版本中，你就不想再使用之前的驱动程序了。为此，我们创建了一个新的驱动程序，它使用硬件PWM而不是模拟行为。所以继续创建一个名为
    `servo-pwm` 的新文件夹，并在其中创建一个新的 `driver.go` 文件。然后按照以下步骤实现更好的驱动程序：
- en: 'We define the period, which is 20.000 microsecond and create a new `Device`
    struct, shown as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了周期，为20.000微秒，并创建了一个新的 `Device` 结构体，如下所示：
- en: '[PRE40]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next step is to add a constructor function as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一个构造函数，如下所示：
- en: '[PRE41]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we configure the PWM interface. We need to set the period and get the channel
    for our output pin:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们配置PWM接口。我们需要设置周期并获取输出引脚的通道：
- en: '[PRE42]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we add functions that lets us set the position of the servomotor. We pass
    in the microseconds for the duty cycles as parameter, as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们添加一些函数，让我们能够设置伺服电机的位置。我们以参数的形式传入占空比的微秒数，如下所示：
- en: '[PRE43]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As a last step, we control the duty cycle of the channel:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们控制通道的占空比：
- en: '[PRE44]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let us try how the `Set` function works. For this, we take a look at the documentation
    as it the function is very well explained there:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下 `Set` 函数的工作原理。为此，我们查看文档，因为该函数在那里解释得非常清楚：
- en: '![Figure 3.12 – The pwm.Set() documentation'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 – pwm.Set()文档](img/Figure_3.12_B16555.jpg)'
- en: '](img/Figure_3.12_B16555.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_3.12_B16555.jpg)'
- en: Figure 3.12 – The pwm.Set() documentation
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 – pwm.Set()文档
- en: 'Now let us also create an alternative example program that uses the new driver.
    To do so, create a new folder named `controlling-servo-pwm` inside the `Chapter03`
    folder and place the following code into the `main` function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也创建一个使用新驱动程序的替代示例程序。为此，在 `Chapter03` 文件夹内创建一个名为 `controlling-servo-pwm`
    的新文件夹，并将以下代码放入 `main` 函数中：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We are using the `machine.Timer1` in the preceding example, as the `Timer1`
    is a 16-bit timer, which is usable in combination with the `machine.D9` pin. `Timer0`
    and `Timer2` are 8-bit timers used by the other PWM pins.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了 `machine.Timer1`，因为 `Timer1` 是一个16位定时器，可以与 `machine.D9` 引脚一起使用。`Timer0`
    和 `Timer2` 是用于其他PWM引脚的8位定时器。
- en: Excellent! I have also added alternative implementations that use hardware PWM
    based driver instead of the software emulated driver we have in the preceding
    code, for all following projects in this chapter. You can find them in the GitHub
    repository in the `Chapter03` folder. I strongly advice to use this implementation
    of the servomotor driver instead of the one we created first, as this implementation
    works way better on the Arduino UNO compared to the software emulated PWM driver
    that we wrote first. Implementing a software emulation of the PWM interface is
    still a good way to understand how PWM works internally. I have also implemented
    an alternative program for the final project of this chapter that uses the hardware
    PWM servo driver. If you cannot build the projects that use the new driver, then
    the PWM refactoring has not yet made its way onto the TinyGo release branch. But
    I am very sure, that this feature is going to be released this year (2021).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀！我还添加了使用基于硬件PWM的驱动器而不是我们在前面代码中使用的软件模拟驱动器的替代实现，用于本章所有后续项目。您可以在GitHub仓库的`Chapter03`文件夹中找到它们。我强烈建议使用这个伺服电机驱动器的实现，而不是我们最初创建的那个，因为这个实现与我们在第一个项目中编写的软件模拟PWM驱动器相比，在Arduino
    UNO上工作得更好。实现PWM接口的软件模拟仍然是理解PWM内部工作原理的好方法。我还为本章的最终项目实现了一个替代程序，该程序使用硬件PWM伺服电机驱动器。如果您无法构建使用新驱动器的项目，那么PWM重构尚未进入TinyGo发布分支。但我非常确信，这个特性将在今年（2021年）发布。
- en: Building a safety lock using a keypad
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘构建安全锁
- en: We now know how to read input from a keypad and how to control a servomotor.
    We are going to use this knowledge to build a safety lock that opens when the
    correct passcode has been entered through the keypad. As we wrote libraries to
    control the servo and read data from the keypad, we only need to write the logic
    to check a passcode and light up LEDs. We are going to let the red LED blink each
    time a key is being pressed. When we enter a wrong passcode, we light up the red
    LED for 3 seconds. When we enter the correct passcode, we light up the green LED
    for 3 seconds and trigger the servomotor.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何从键盘读取输入以及如何控制伺服电机。我们将使用这些知识来构建一个安全锁，当通过键盘输入正确的密码时，该锁会打开。因为我们编写了控制伺服电机和从键盘读取数据的库，所以我们只需要编写检查密码并点亮LED的逻辑。我们将让红色LED在每次按键时闪烁。当我们输入错误的密码时，我们将红色LED点亮3秒。当我们输入正确的密码时，我们将绿色LED点亮3秒并触发伺服电机。
- en: Building the circuit
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: We are going to reuse the circuits we built in the previous sections of this
    chapter. As we already have a servo and the keypad wired, we just have to add
    the LEDs and the resistors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用本章前几节中构建的电路。因为我们已经有了连接好的伺服电机和键盘，我们只需要添加LED和电阻。
- en: 'To build the final circuit, follow these steps:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建最终电路，请按照以下步骤操作：
- en: Connect a GND port from the Arduino Uno with the GND lane on the power bus.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino Uno的GND端口与电源总线上的GND通道连接。
- en: Place a red LED with the cathode in *G7* and the anode in *G8*.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将红色LED的阴极放置在*G7*，阳极放置在*G8*。
- en: Place a green LED with the cathode in *G11* and the anode in *G12*.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绿色LED的阴极放置在*G11*，阳极放置在*G12*。
- en: Connect *F7* with ground on the power bus using a jumper wire.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将*F7*与电源总线上的地连接。
- en: Connect *F11* with ground on the power bus using a jumper wire.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将*F11*与电源总线上的地连接。
- en: Use a 220 Ohm resistor to connect *D8* with *F8*.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用220欧姆电阻将*D8*与*F8*连接。
- en: Use a 220 Ohm resistor to connect *D12* with *F12*.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用220欧姆电阻将*D12*与*F12*连接。
- en: Connect pin *D12* from the Arduino Uno with *A12* using a jumper wire.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将Arduino Uno的*D12*引脚与*A12*连接。
- en: Connect pin *D13* from the Arduino Uno with *A8* using a jumper wire.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将Arduino Uno的*D13*引脚与*A8*连接。
- en: 'Our circuit should now look like the circuit in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的电路应该看起来像以下屏幕截图中的电路：
- en: '![Figure 3.13 – Keypad, servomotor, and LED circuit'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 – 键盘、伺服电机和LED电路'
- en: '](img/Figure_3.13_B16555.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.13_B16555.jpg)'
- en: Figure 3.13 – Keypad, servomotor, and LED circuit
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 – 键盘、伺服电机和LED电路
- en: Writing the logic
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写逻辑
- en: 'As we have successfully wired our circuit, we can now start to write the logic
    for our program. We start by creating a new folder named `safety-lock-keypad`
    inside the `Chapter03` folder and create a new `main.go` file with an empty `main`
    function inside the new folder. Our project structure should now look like the
    following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经成功连接了电路，我们现在可以开始编写程序的逻辑。我们首先在`Chapter03`文件夹内创建一个名为`safety-lock-keypad`的新文件夹，并在新文件夹内创建一个包含空`main`函数的新`main.go`文件。我们的项目结构现在应该如下所示：
- en: '![Figure 3.14 – Project structure for safety lock program'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 – 安全锁程序的项目结构'
- en: '](img/Figure_3.14_B16555.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.14_B16555.jpg)'
- en: Figure 3.14 – Project structure for safety lock program
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 – 安全锁程序的项目结构
- en: 'As we can reuse our libraries, we just have to concern ourselves with the actual
    passcode logic. To implement the logic, use the following steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以重用我们的库，我们只需关注实际的密码逻辑。要实现逻辑，请使用以下步骤：
- en: 'Import `keypad` and the `servo` driver. Then, you need to adjust the paths
    to match the paths to the packages in your `Gopath`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`keypad`和`servo`驱动程序。然后，您需要调整路径以匹配您的`Gopath`中的包路径：
- en: '[PRE46]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Inside the `main` function, we start by initializing `keypadDriver`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们首先初始化`keypadDriver`：
- en: '[PRE47]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we initialize `servoDriver`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们初始化`servoDriver`：
- en: '[PRE48]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Initialize a new `outPutConfig`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的`outPutConfig`：
- en: '[PRE49]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Initialize both LEDs:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化两个LED：
- en: '[PRE50]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Initialize the passcode with the value `133742`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用值`133742`初始化密码：
- en: '[PRE51]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Initialize a new variable named `enteredPasscode` with an empty string as the
    value:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用空字符串作为值初始化一个名为`enteredPasscode`的新变量：
- en: '[PRE52]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Read the keypad input:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取键盘输入：
- en: '[PRE53]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check whether a key was pressed and print the pressed key to the serial port,
    while appending the pressed key to `enteredPasscode`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否按下了键，并将按下的键打印到串行端口，同时将按下的键追加到`enteredPasscode`变量中：
- en: '[PRE54]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Light up the red LED to provide visual feedback and close the `if` statement:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点亮红色LED以提供视觉反馈并关闭`if`语句：
- en: '[PRE55]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Check whether `enteredPasscode` has same length as `passcode`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`enteredPasscode`的长度是否与`passcode`相同：
- en: '[PRE56]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If `enteredPasscode` matches the `passcode` value, print `Success` to the serial
    port , reset the `enteredPasscode` and trigger the servomotor:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`enteredPasscode`与`passcode`值匹配，将`Success`打印到串行端口，重置`enteredPasscode`并触发伺服电机：
- en: '[PRE57]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Light up the green LED to give visual feedback for the success and handle the
    incorrect passcode case with `else`:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点亮绿色LED以提供成功的视觉反馈，并使用`else`处理错误的密码情况：
- en: '[PRE58]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Print `Fail` and the entered passcode to the serial port , that helps us, when
    debugging the program and also reset the `enteredPasscode`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Fail`和输入的密码打印到串行端口，这有助于我们在调试程序时，并重置`enteredPasscode`：
- en: '[PRE59]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Light up the red LED to give visual feedback for the failure and close the
    `else` and `if` cases:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点亮红色LED以提供失败的视觉反馈，并关闭`else`和`if`情况：
- en: '[PRE60]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Sleep for `50` milliseconds and close the `for` loop. This helps to debounce
    the keypresses:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 睡眠`50`毫秒并关闭`for`循环。这有助于消除按键抖动：
- en: '[PRE61]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Great, we have now written the complete logic for our final project in this
    chapter. Now flash the program using the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们现在已经在本章中编写了最终项目的完整逻辑。现在使用以下命令烧录程序：
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we have now successfully flashed the program, open PuTTy and open the **Microcontroller**
    serial session by loading your saved profile. Now enter a random passcode to let
    the program fail. The red LED should light up for 3 seconds and the output in
    PuTTy should look as in the following screenshot:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经成功烧录了程序，打开PuTTy并打开通过加载您的保存配置文件的**微控制器**串行会话。现在输入一个随机密码以让程序失败。红色LED应该亮起3秒，PuTTy中的输出应该如下截图所示：
- en: '![Figure 3.15 – Incorrect input'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.15 – 错误输入'
- en: '](img/Figure_3.15_B16555.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.15_B16555.jpg)'
- en: Figure 3.15 – Incorrect input
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 错误输入
- en: 'Now, let''s try the correct passcode, so enter `133742` as the passcode. The
    output should now look similar to the following screenshot:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试正确的密码，所以输入`133742`作为密码。输出现在应该类似于以下截图：
- en: '![Figure 3.16 – Correct input'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.16 – 正确输入'
- en: '](img/Figure_3.16_B16555.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.16_B16555.jpg)'
- en: Figure 3.16 – Correct input
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – 正确输入
- en: Excellent, we have successfully built a circuit that accepts a passcode and
    triggers a servomotor when the correct passcode has been entered.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀，我们已经成功构建了一个接受密码并在输入正确密码时触发伺服电机的电路。
- en: 'You can find a alternative implementation that uses the new refactored PWM
    jere: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以找到一个使用新重构的PWM的替代实现：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/blob/master/Chapter03/safety-lock-keypad-pwm/main.go)
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to write messages to the serial port and
    how to configure PuTTy to monitor messages on the serial port. We have then used
    this knowledge to output keypresses on a keypad that we controlled using a driver
    that we wrote. During that procedure, we learned how to write drivers for devices
    that currently have no official drivers and also learned about the contribution
    process of the driver's repository from TinyGo.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何向串行端口发送消息以及如何配置PuTTy来监控串行端口上的消息。然后，我们利用这些知识通过我们编写的驱动程序在键盘上输出按键操作。在这个过程中，我们学习了如何为目前没有官方驱动程序的设备编写驱动程序，并且了解了TinyGo的驱动程序仓库的贡献过程。
- en: Then we learned how to control a servomotor and wrote a library to do so. As
    the last step, we combined everything we learned in this chapter to build a safety
    lock that accepts a passcode to open up the lock. This knowledge can be very useful
    if you ever want to build a door lock or a flight control system, where you need
    to control servomotors. The keypad can also be used as a gamepad, where you use
    the keys as input. As a bonus, we also wrote two drivers that we can reuse in
    all upcoming projects after finishing the book.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何控制伺服电机，并编写了一个库来实现这一功能。作为最后一步，我们将本章学到的所有知识结合起来，构建了一个接受密码来打开锁的安全锁。如果你想要构建一个门锁或飞行控制系统，其中需要控制伺服电机，这些知识将非常有用。键盘也可以用作游戏手柄，其中你使用按键作为输入。作为额外奖励，我们还编写了两个可以在完成本书后重用于所有未来项目的驱动程序。
- en: In the next chapter, we are going to learn how to read sensor values using ADC
    pins, how to find thresholds in values, how to control a pump, and how to use
    relays and buzzers.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用ADC引脚读取传感器值，如何在值中找到阈值，如何控制泵，以及如何使用继电器和蜂鸣器。
- en: Questions
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Having learned about the coordinate system we used for the keypad, what are
    the coordinates for key 3?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在了解了我们用于键盘的坐标系之后，3号键的坐标是什么？
- en: In our final project, we checked whether the input is correct when the correct
    passcode length has been reached. How would you change the code to get it to check
    whether the passcode is correct when the key number has been pressed?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的最终项目中，我们检查了当达到正确的密码长度时输入是否正确。你将如何修改代码，使其在按下按键编号时检查密码是否正确？
