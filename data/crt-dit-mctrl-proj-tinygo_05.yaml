- en: '*Chapter 5*: Building a Touchless Handwash Timer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：构建非接触式洗手计时器'
- en: In [*Chapter 4*](B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082), *Building
    a Plant Watering System*, we learned how the ADC interface works, and we used
    that knowledge to write libraries for a capacitive soil moisture sensor and a
    water level sensor. We also wrote a small library to control a buzzer and learned
    how relays work and used that knowledge to control a pump using our code. Then
    we used all this knowledge to build an automated plant watering system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082)“构建植物浇水系统”中，我们学习了ADC接口的工作原理，并利用这一知识编写了电容式土壤湿度传感器和水位传感器的库。我们还编写了一个小型库来控制蜂鸣器，并学习了继电器的工作原理，利用这些知识使用我们的代码控制水泵。然后，我们利用所有这些知识构建了一个自动植物浇水系统。
- en: In this chapter, we are going to build a touchless handwash timer. After working
    through this chapter, you will know how ultrasonic sound sensors work and how
    to measure distance with them. We are going to utilize this knowledge to create
    a sensor that recognizes a hand that is between 20 and 30 centimeters away from
    the sensor to start a timer. The timer will then be displayed on a 7-segment display.
    While implementing this, we will also learn about the MAX7219 chip and how to
    use it to control different display types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个非接触式洗手计时器。完成本章学习后，您将了解超声波传感器的工作原理以及如何使用它们来测量距离。我们将利用这些知识来创建一个传感器，当手在传感器20至30厘米之间时，可以启动计时器。计时器随后将在7段显示器上显示。在实现这一功能的同时，我们还将了解MAX7219芯片及其如何用于控制不同类型的显示器。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Introducing the Arduino Nano 33 IoT
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Arduino Nano 33 IoT
- en: Measuring distance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量距离
- en: Using a 7-segment display
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用7段显示器
- en: Putting it all together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We are going to need the following components for this project:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下组件来完成这个项目：
- en: An Arduino Nano 33 IoT
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Arduino Nano 33 IoT
- en: An HC-SR04 sensor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HC-SR04传感器
- en: An external power supply module
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个外部电源模块
- en: HS420561K 4-Digit 7-segment display common cathode
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HS420561K 4位7段显示器共阴极
- en: A MAX7219 or MAX7221 serial input/output common-cathode display driver
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个MAX7219或MAX7221串行输入/输出共阴极显示驱动器
- en: One 10,000 Ohm resistor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个10,000欧姆电阻
- en: One 1,000 Ohm resistor
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个1,000欧姆电阻
- en: One 2,000 Ohm resistor
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个2,000欧姆电阻
- en: 2 breadboards
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2块面包板
- en: Jumper wire cables
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线电缆
- en: Most of the components are part of the so-called Arduino Starter Kit. If you
    do not have such a set, they can be acquired at any electronics supply store.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件都是所谓的Arduino入门套件的一部分。如果您没有这样的套件，它们可以在任何电子产品商店购买。
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter05)
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3e2IYgG](https://bit.ly/3e2IYgG)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在此处找到：[https://bit.ly/3e2IYgG](https://bit.ly/3e2IYgG)
- en: Introducing the Arduino Nano 33 IoT
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Arduino Nano 33 IoT
- en: 'We have reached a point where the TinyGo support for the Arduino UNO has reached
    its limit. At the time of writing, it is not possible to resolve this shortcoming
    for the current and following chapters using an Arduino UNO. The cause of this
    is a missing `Pull` request for that opened by me. Additionally, the **Alf and
    Vegard''s RISC** (**AVR**) backend in the TinyGo compiler toolchain has some problems
    in the versions used by the current TinyGo version, and the code won''t compile.
    So, let''s take a look at another board, which is fully supported by TinyGo—the
    Arduino Nano 33 IoT. Compared to UNO, the Nano 33 IoT is a powerhouse. Here are
    its technical specifications:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经达到一个阶段，TinyGo对Arduino UNO的支持已经达到极限。在撰写本文时，无法使用Arduino UNO解决当前和后续章节的这个问题。原因是缺少我发起的相应“Pull”请求。此外，TinyGo编译器工具链中的Alf和Vegard的RISC（**AVR**）后端在当前TinyGo版本中存在一些问题，代码无法编译。因此，让我们看看另一个完全由TinyGo支持的板——Arduino
    Nano 33 IoT。与UNO相比，Nano 33 IoT是一款性能强大的板。以下是它的技术规格：
- en: '**Microcontroller**: AMD21 Cortex®-M0+ 32bit low power ARM MCU'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微控制器**：AMD21 Cortex®-M0+ 32位低功耗ARM MCU'
- en: '**Radio module**: U-blox NINA-W102'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无线模块**：U-blox NINA-W102'
- en: '**Operating voltage**: 3.3V'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作电压**：3.3V'
- en: '**Input Voltage (limit)**: 2V'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入电压（限制）**: 2V'
- en: '**DC Current per I/O Pin**: 7 mA'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个I/O引脚的直流电流**: 7 mA'
- en: '**Clock speed**: 48 MHz'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟速度**: 48 MHz'
- en: '**CPU Flash Memory**: 256 KB'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU闪存**: 256 KB'
- en: '**SRAM**: 32 KB'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SRAM**: 32 KB'
- en: '**GPIO Pins**: 14'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO引脚**: 14'
- en: '**Analog input pins**: 8 (8/10/12 bit)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟输入引脚**: 8 (8/10/12位)'
- en: '**Analog output pins**: 1 (10 bit)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟输出引脚**: 1 (10位)'
- en: So, the Arduino Nano 33 IoT has a much higher clock speed, more RAM, and more
    flash memory while operating on 3.3V instead of 5V. Additionally, on top of that,
    the Nano 33 IoT is capable of Wi-Fi communication.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Arduino Nano 33 IoT在3.3V而不是5V供电时具有更高的时钟速度、更多的RAM和更多的闪存。此外，Nano 33 IoT还具备Wi-Fi通信功能。
- en: Now, let's take a brief look at the 5V output capabilities of the Arduino Nano
    33 IoT.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要地了解一下Arduino Nano 33 IoT的5V输出能力。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although the Arduino Nano 33 IoT has a 5V output pin, this pin is deactivated
    by default. To activate that pin, some soldering needs to be done.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Arduino Nano 33 IoT有一个5V输出引脚，但该引脚默认是禁用的。要激活该引脚，需要进行一些焊接。
- en: When powering the Arduino Nano 33 IoT through USB, we also have a 5V current
    available on the `Vin` pin, but that pin is intended to power the Arduino. We
    will be handling devices that require 5V input, but that is not a problem; we
    are just going to use an external power supply to power these devices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过USB为Arduino Nano 33 IoT供电时，我们也在`Vin`引脚上有一个5V电流，但该引脚的目的是为Arduino供电。我们将处理需要5V输入的设备，但这不是问题；我们只是将使用外部电源为这些设备供电。
- en: 'Now that we have a brief understanding, let''s take a look at the pinout. The
    following diagram shows the pinout of the Arduino Nano 33 IoT:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对它有了基本的了解，让我们来看看引脚图。以下图表显示了Arduino Nano 33 IoT的引脚图：
- en: '![Figure 5.1 – The Arduino Nano 33 IoT pinout'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – Arduino Nano 33 IoT引脚图'
- en: '](img/Figure_5.1_B16555.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B16555.jpg)'
- en: Figure 5.1 – The Arduino Nano 33 IoT pinout
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – Arduino Nano 33 IoT引脚图
- en: The source of the pinout diagram can be found at [https://store.arduino.cc/arduino-nano-33-iot](https://store.arduino.cc/arduino-nano-33-iot).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚图来源可以在[https://store.arduino.cc/arduino-nano-33-iot](https://store.arduino.cc/arduino-nano-33-iot)找到。
- en: In this section, we took a brief look at the technical specs of the Arduino
    Nano 33 IoT. However, before we can use it in our project, we need to install
    some dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要地了解了Arduino Nano 33 IoT的技术规格。然而，在我们能够在项目中使用它之前，我们需要安装一些依赖项。
- en: Installing Bossa
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Bossa
- en: Bossa is needed in order to flash programs onto the Arduino Nano 33 IoT.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将程序烧录到Arduino Nano 33 IoT上，需要Bossa。
- en: 'First, let''s take a look at the installing process on a Mac system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在Mac系统上的安装过程：
- en: 'You can simply install the dependencies using the following command:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用以下命令简单地安装依赖项：
- en: '[PRE0]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: https://github.com/shumatech/BOSSA/releases/download/1.9.1/bossa-x64-1.9.1.msi
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/shumatech/BOSSA/releases/download/1.9.1/bossa-x64-1.9.1.msi](https://github.com/shumatech/BOSSA/releases/download/1.9.1/bossa-x64-1.9.1.msi)'
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When executing the `msi`, choose the following installation path:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当执行`msi`时，请选择以下安装路径：
- en: '[PRE2]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: set PATH=%PATH%;"c:\Program Files\BOSSA";
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set PATH=%PATH%;"c:\Program Files\BOSSA";
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to install `bossa` on a Linux system, execute the following commands:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在Linux系统上安装`bossa`，请执行以下命令：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify the installation success, use the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证安装成功，请使用以下命令：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Up-to-date information on how to install the needed dependencies can be found
    at [https://tinygo.org/microcontrollers/arduino-nano33-iot/](https://tinygo.org/microcontrollers/arduino-nano33-iot/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装所需依赖项的最新信息可以在[https://tinygo.org/microcontrollers/arduino-nano33-iot/](https://tinygo.org/microcontrollers/arduino-nano33-iot/)找到。
- en: We have now set up the dependencies required to flash programs on the Arduino
    Nano 33 IoT. Let's move on to the first project of this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了在Arduino Nano 33 IoT上烧录程序的所需依赖项。让我们继续本章的第一个项目。
- en: Learning to measure distances
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习测量距离
- en: If you have ever wondered how touchless soap dispensers or touchless blow dryers
    register that there is a hand beneath them, there is a good chance that they are
    using the HC-SR04 ultrasonic sensor. We are going to use this sensor to measure
    the distance between an object and the sensor. Let's begin with the HC-SR04 sensor.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经好奇无接触式肥皂分配器或无接触式吹风机是如何检测到它们下面有手的，那么它们很可能正在使用HC-SR04超声波传感器。我们将使用这个传感器来测量物体与传感器之间的距离。让我们从HC-SR04传感器开始。
- en: Understanding the HC-SR04 sensor
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解HC-SR04传感器
- en: 'The HC-SR04 sensor emits an ultrasound at 40k Hz, which travels through the
    air and bounces back if the emitted pulse collides with any object in its path.
    The sensor cannot be used as a detector for other ultrasound pulses, as it only
    registers echoes from the exact same pulse that it itself emitted. Typically,
    these sensors look similar to the one in the following photograph:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR04传感器以40k Hz的频率发射超声波，这些超声波穿过空气，如果发射的脉冲与路径上的任何物体碰撞，就会反弹。该传感器不能用作其他超声波脉冲的检测器，因为它只能注册它自己发出的确切脉冲的回声。通常，这些传感器看起来与以下照片中的类似：
- en: '![Figure 5.2 – The HC-SR04 sensor'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – HC-SR04传感器'
- en: '](img/Figure_5.2_B16555.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B16555.jpg)'
- en: Figure 5.2 – The HC-SR04 sensor
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – HC-SR04传感器
- en: 'This sensor has the following technical specifications:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个传感器有以下技术规格：
- en: It has a detection range from 2 to 400 centimeters.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的检测范围从2到400厘米。
- en: It draws less than 2 mA current.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的电流小于2 mA。
- en: It has a working voltage of 5V.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的工作电压为5V。
- en: It has a resolution of 0.3 centimeters.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的分辨率为0.3厘米。
- en: It has an angle of fewer than 15 degrees.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的角度小于15度。
- en: 'The sensor has the following three ports:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器有以下三个端口：
- en: '*VCC*: This is used to power the sensor.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VCC*：这个用于给传感器供电。'
- en: '*TRIG*: This triggers the pulse.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TRIG*：这个触发脉冲。'
- en: '*ECHO*: This receives the echo of the pulse.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ECHO*：这个接收脉冲的回声。'
- en: 'Now, let''s take a look at how exactly an ultrasonic pulse can be used to measure
    the distance between the sender and an object. The sensor emits eight pulses that
    travel through the air. If they hit an object, they get reflected and travel back
    as an echo, as shown in the following diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看超声波脉冲是如何精确地用来测量发送器和物体之间的距离的。传感器发射八个脉冲，这些脉冲穿过空气。如果它们击中一个物体，它们会被反射并作为回声返回，如下面的图所示：
- en: '![Figure 5.3 – Eight pulses and one echo'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 八个脉冲和一个回声'
- en: '](img/Figure_5.3_B16555.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B16555.jpg)'
- en: Figure 5.3 – Eight pulses and one echo
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 八个脉冲和一个回声
- en: When recognizing the echo, the **echo** pin will be set to high from the sensor
    for the exact same time frame that the pulse needed to leave and return to the
    sensor. Now, we only need some math to calculate the distance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当识别到回声时，传感器的**回声**引脚将被设置为高电平，持续的时间与脉冲离开并返回传感器所需的时间完全相同。现在，我们只需要进行一些数学计算来计算距离。
- en: The pulse travels at 340 m/s, which is the speed of sound in the air. This can
    also be expressed as 0.034 m/μs (microseconds). If the object is about 30 centimeters
    away from the sensor, the pulse needs to travel for about 882 microseconds. The
    **echo** pin will be set to high for exactly as long as the pulse needs to travel
    the entire path; that is why we need to divide the result by 2\. And as the last
    step, we are going to divide the travel time by 0.034 to get the traveled distance
    in centimeters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 脉冲以340 m/s的速度传播，这是空气中的声速。这也可以表示为0.034 m/μs（微秒）。如果物体距离传感器大约30厘米，脉冲需要传播大约882微秒。**回声**引脚将被设置为高电平，正好与脉冲需要传播整个路径的时间一样长；这就是为什么我们需要将结果除以2。最后一步，我们将旅行时间除以0.034，以得到以厘米为单位的旅行距离。
- en: 'Here is how this example works out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何实现这个例子的：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s rearrange that formula to get `distance`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新排列这个公式来得到`距离`：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we have learned how to use an ultrasonic sound sensor, theoretically, we
    can now go on to prove this theory by trying it out in real time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用超声波传感器，从理论上讲，我们现在可以通过实时尝试来验证这个理论。
- en: Assembling the circuit
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装电路
- en: Before we start to assemble the circuit, we need to make sure that the echo
    pin from the sensor, which will be connected to an input pin on the Arduino, does
    send 3.3V signals instead of 5V signals. For this, we can make use of a **voltage
    divider**. The echo pin of the sensor outputs 5V, but the Arduino Nano 33 IoT
    should not be connected to 5V, as this could cause permanent damage to the Arduino.
    That is why we make use of the voltage divider.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始组装电路之前，我们需要确保传感器的回声引脚，它将被连接到Arduino的输入引脚，确实发送3.3V信号而不是5V信号。为此，我们可以使用**分压器**。传感器的回声引脚输出5V，但Arduino
    Nano 33 IoT不应该连接到5V，因为这可能会永久损坏Arduino。这就是为什么我们使用分压器的理由。
- en: 'The formula to calculate the **output voltage** (**Vout**) is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 计算**输出电压**（**Vout**）的公式如下：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `Vs` is the source voltage, `R2` is the resistor that is connected to
    the source voltage, and `R1` is the resistor that is connected to the ground.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Vs`是源电压，`R2`是连接到源电压的电阻，`R1`是连接到地线的电阻。
- en: 'So, we are going to need a 2,000-Ohm resistor for R2 and a 1,000-Ohm resistor
    for R1\. This is going to result in the following equation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个2,000欧姆的电阻作为R2，以及一个1,000欧姆的电阻作为R1。这将导致以下方程：
- en: '*3.333V = 5 * 2,000 / (1,000 + 2,000)*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*3.333V = 5 * 2,000 / (1,000 + 2,000)*'
- en: 'Now that we have learned how to build a voltage divider, we can go ahead and
    assemble the circuit using the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构建分压器，我们可以继续按照以下步骤组装电路：
- en: Place the HC-SR04 sensor on the breadboard with the *VCC* pin in the *J* row
    on the breadboard.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HC-SR04传感器放置在面包板上，将*VCC*引脚放在面包板的*J*行上。
- en: Connect the *VCC* lane on the power bus with *VCC* of the sensor using a jumper
    wire.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将电源总线上的*VCC*通道与传感器的*VCC*连接起来。
- en: Connect the *GND* lane on the power bus with *GND* of the sensor using a jumper
    wire. Connect *D2* from the Arduino with *Trig* of the sensor using a jumper wire.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将电源总线上的*GND*通道与传感器的*GND*连接起来。使用跳线将Arduino的*D2*与传感器的*Trig*连接起来。
- en: Use a 2,000-Ohm resistor to connect `GND` with *C53* on the breadboard using
    a jumper wire.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用2,000欧姆电阻通过跳线将`GND`与面包板上的*C53*连接起来。
- en: Use a 1,000-Ohm resistor to connect *Echo* with *A53* on the breadboard jumper
    wire.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用1,000欧姆电阻通过面包板跳线将*Echo*与*A53*连接起来。
- en: Now, connect *D3* from the Arduino with *B53* on the breadboard using a jumper
    wire. We can read the 3.3V *Echo* signal here.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用跳线将Arduino的*D3*与面包板上的*B53*连接起来。我们可以在这里读取3.3V的*Echo*信号。
- en: Place an external power supply on the breadboard. Take care to **set the jumpers
    to 5V**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面包板上放置一个外部电源。注意将跳线设置为**5V**。
- en: 'This is everything we need to write and test a library. Your circuit should
    now look similar to the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们编写和测试库所需的一切。您的电路现在应该类似于以下图示：
- en: '![Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)'
- en: '](img/Figure_5.4_B16555.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.4_B16555.jpg]'
- en: Figure 5.4 – The HC-SR04 circuit (image taken from Fritzing)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – HC-SR04电路（图片来自Fritzing）
- en: We have now learned how an ultrasonic sound sensor works and have assembled
    a circuit. As has been the case with the previous chapters, here, we also start
    by creating a library to control the sensor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了超声波传感器的工作原理，并组装了电路。正如前几章所做的那样，这里我们也首先创建一个库来控制传感器。
- en: Writing a library
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写库
- en: 'We are going to write a library that has a function that returns the current
    distance from the sensor to an object, or `0` if the object is out of range. We
    start by creating a new folder, called `Chapter05`, inside our project. Inside
    the new `Chapter05` folder, create a new folder, called `ultrasonic-distance-sensor`,
    and create a new `driver.go` file. Name the package `hcsr04`. Your folder structure
    should look like the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个库，该库有一个函数，返回传感器到物体的当前距离，或者如果物体超出范围，则返回`0`。我们首先在项目内部创建一个名为`Chapter05`的新文件夹。在新的`Chapter05`文件夹内，创建一个名为`ultrasonic-distance-sensor`的新文件夹，并创建一个名为`driver.go`的新文件。将包命名为`hcsr04`。您的文件夹结构应如下所示：
- en: '![Figure 5.5 – The project structure for writing a library'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.5 – The project structure for writing a library'
- en: '](img/Figure_5.5_B16555.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.5_B16555.jpg]'
- en: Figure 5.5 – The project structure for writing a library
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 编写库的项目结构
- en: 'Now that we have set up our project structure, we can start to write the actual
    logic. To do this, perform these steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了项目结构，我们可以开始编写实际的逻辑。为此，执行以下步骤：
- en: 'Define a new constant at the package level, name it `speedOfSound`, and set
    its value to `0.0343`, which is the speed of sound in centimeters per microsecond:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包级别定义一个新的常量，命名为`speedOfSound`，并将其值设置为`0.0343`，这是每微秒厘米的声速：
- en: '[PRE9]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, define a new interface and call it HCSR04, as shown in the following
    code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个新的接口，命名为HCSR04，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we define a new `struct`, called `hcsr04`, which holds the `trigger`
    and `echo` `pins` as well as a `timeout` in microseconds, as shown in the following
    code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个新的`struct`，称为`hcsr04`，它包含`trigger`和`echo``pins`以及微秒级的`timeout`，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we add a function named `NewHCSR04`, which takes a `trigger` and `echo`
    pin along with the `maxDistance` in centimeters and returns `HCSR04`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个名为`NewHCSR04`的函数，它接受一个`trigger`和`echo`引脚以及厘米单位的`maxDistance`，并返回`HCSR04`：
- en: '[PRE12]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Calculate the `timeout` in microseconds. We multiply the `maxDistance` by `2`
    because the pulse needs to travel to an object and back again. We then divide
    the result by `speedOfSound`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算微秒级的`timeout`。我们将`maxDistance`乘以`2`，因为脉冲需要到达物体并返回。然后将结果除以`speedOfSound`：
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new instance of `hcsr04`, set `trigger`, `echo`, and `timeout`, and
    return a pointer to the new instance:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`hcsr04`实例，设置`trigger`、`echo`和`timeout`，并返回新实例的指针：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the `Configure` function, which is a pointer receiver that configures `trigger`
    as output and the `echo` pin as input:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Configure`的函数，它是一个指针接收器，将`trigger`配置为输出，将`echo`引脚配置为输入：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the `sendPulse` function, which pulls the `trigger` high for `10` microseconds
    and then sets the `trigger` to low again. This will trigger eight ultrasonic pulses
    in the HC-SR04 sensor:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`sendPulse`函数，该函数将`trigger`拉高`10`微秒，然后再次将`trigger`设置为低。这将触发HC-SR04传感器中的八个超声波脉冲：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a new function named `GetDistance`, which returns `uint16` and is a pointer
    receiver. First, the function sends out a pulse and then listens for the echo.
    We receive an incoming echo when the echo pin reads a high value:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GetDistance`的新函数，它返回`uint16`并且是一个指针接收器。首先，该函数发送脉冲并监听回声。当echo引脚读取高值时，我们收到回声：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check whether `i` is greater than `15`. We do this to save some time, as comparing
    an integer is a very fast operation in comparison to getting a current timestamp.
    If the time since our timer started is greater than our configured `timeout`,
    then return `0`, which we can use as the `timeout` value:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`i`是否大于`15`。我们这样做是为了节省一些时间，因为与获取当前时间戳相比，比较一个整数是一个非常快的操作。如果自我们的计时器开始以来经过的时间大于我们配置的`timeout`，则返回`0`，我们可以将其用作`timeout`值：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we have to measure the time when the `echo` pin is set to high:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们必须测量`echo`引脚被设置为高时的时间：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a function named `GetDistanceFromPulseLength`, which takes `pulseLength`
    as a parameter, returns the distance in centimeters, and is a pointer receiver:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`GetDistanceFromPulseLength`的函数，它接受`pulseLength`作为参数，返回厘米距离，并且是一个指针接收器：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the `pulseLength` parameter is the time that the signal needs to travel
    to the target and back, we need to divide it by `2`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`pulseLength`参数是信号到达目标并返回所需的时间，我们需要将其除以`2`：
- en: '[PRE21]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To get the result in centimeters, we need to multiply `pulseLength` with `speedOfSound`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了得到厘米的结果，我们需要将`pulseLength`乘以`speedOfSound`：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Return `result` as `uint16`, as we don''t care about decimal places:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`result`作为`uint16`返回，因为我们不关心小数位：
- en: '[PRE23]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is all the code we need for the library. From now on, we can use this library
    to measure distances using an HCSR-04 sensor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要为库的所有代码。从现在起，我们可以使用这个库通过HCSR-04传感器来测量距离。
- en: Before we move on to test the library in a real-world example, let's use the
    `GetDistanceFromPulseLength` function to take a brief look at how unit testing
    can be done in TinyGo.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续在真实世界的示例中测试库之前，让我们使用`GetDistanceFromPulseLength`函数简要地看看如何在TinyGo中进行单元测试。
- en: Unit testing in TinyGo
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TinyGo中的单元测试
- en: 'TinyGo does support unit testing, which comes in handy when you have complicated
    logic and do not want to flash every single change onto your microcontroller when
    you are trying to find a bug. Let''s take a look at what is currently is supported
    in a practical way. To do this, create a new file, called `driver_test.go`, inside
    the `ultrasonic-distance-sensor` folder and name the package `hcsr04_test`. The
    project structure should look similar to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo支持单元测试，这在您有复杂的逻辑且不想在尝试查找错误时将每个更改都闪存到微控制器上时非常有用。让我们看看目前以实用方式支持的内容。为此，在`ultrasonic-distance-sensor`文件夹内创建一个名为`driver_test.go`的新文件，并将包命名为`hcsr04_test`。项目结构应类似于以下内容：
- en: '![Figure 5.6 – The project structure for the first unit test'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 第一个单元测试的项目结构'
- en: '](img/Figure_5.6_B16555.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B16555.jpg)'
- en: Figure 5.6 – The project structure for the first unit test
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 第一个单元测试的项目结构
- en: 'Now, let''s add our first unit test in TinyGo. To do so, perform these steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在TinyGo中添加我们的第一个单元测试。为此，执行以下步骤：
- en: 'Add a new function named `TestGetDistanceFromPulseLength_30cm`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`TestGetDistanceFromPulseLength_30cm`的新函数：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a new `HCSR04` instance. We do not really need a parameter for this
    test, as these parameters will not be used; however, we can add some correct ones
    anyway:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`HCSR04`实例。我们实际上不需要为这个测试添加参数，因为这些参数将不会使用；然而，我们仍然可以添加一些正确的参数：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Calculate the `distance` for the given `pulseLength` parameter, which is exactly
    the length of a pulse for a distance of 30 centimeters:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据给定的`pulseLength`参数计算`distance`，这正好是30厘米距离的脉冲长度：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Check whether the `distance` equals `30`. If it does not, we fail the test
    and log some information, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`distance`是否等于`30`。如果不等于，我们则失败测试并记录一些信息，如下所示：
- en: '[PRE27]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This was our first unit test in TinyGo. Do not forget to import the `testing`
    package. Just like in the normal program code, we can make use of the standard
    Golang package. You can run the test by using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们 TinyGo 中的第一个单元测试。不要忘记导入 `testing` 包。就像在正常的程序代码中一样，我们可以使用标准的 Golang 包。你可以使用以下命令运行测试：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: TinyGo internally makes heavy use of `arduino_nano33`, are used to decide which
    packages and files are needed to build the current code. The test will not compile
    if we omit the `–tags` parameter, as the `machine` package would then be missing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo 内部大量使用 `arduino_nano33`，用于决定构建当前代码所需的哪些包和文件。如果我们省略 `–tags` 参数，测试将无法编译，因为那时将缺少
    `machine` 包。
- en: 'The output of the test should look like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出应该看起来像以下内容：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we know that we can make use of very simple tests to test our logic in
    TinyGo. Let''s go one step further and do a **table-driven test**. Perform these
    steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以利用非常简单的测试来测试 TinyGo 中的逻辑。让我们更进一步，进行**基于表的测试**。执行以下步骤：
- en: 'The next step is to add a new function, called `TestGetDistanceFromPulseLength_TableDriven`,
    right underneath the other test. The code snippet looks like the following:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在其他测试下方添加一个新函数，称为 `TestGetDistanceFromPulseLength_TableDriven`。代码片段如下：
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add four test cases, each of them with a `Name`, the expected `Result`, and
    the `PulseLength`, which we use as input, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加四个测试用例，每个测试用例都有一个 `Name`、预期的 `Result` 和我们用作输入的 `PulseLength`，如下所示：
- en: '[PRE31]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a new instance of the `HCSR04` `Device` instance. It should look like
    the following snippet:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `HCSR04` `Device` 实例的新实例。它应该看起来像以下代码片段：
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we can run a test for each `testCase` in the array. This looks like the
    following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为数组中的每个 `testCase` 运行一个测试。这看起来像以下代码：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Calculate the `distance`. And check whether we get a result that differs from
    the predefined test cases:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 `distance`。并检查我们得到的结果是否与预定义的测试用例不同：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This was everything for the tests. Now, let''s run the tests again using the
    following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是测试的全部内容。现在，让我们使用以下命令再次运行测试：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should now look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在应该看起来像以下内容：
- en: '![Figure 5.7 – The tinygo test output'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – tinygo 测试输出'
- en: '](img/Figure_5.7_B16555.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.7_B16555.jpg)'
- en: Figure 5.7 – The tinygo test output
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – tinygo 测试输出
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since building binaries for Windows is currently not supported, the preceding
    `tinygo test` command is going to fail on a Windows systems. One option for Windows
    users is to use the WSL for unit tests. Another possibility is to set a build
    target by using the `–target` parameter. Windows does support building the **wasm**
    or **wasi** targets, but as our code depends on the machine package, that will
    not work for this specific test. This is because the machine package is not available
    for the wasm and wasi targets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前不支持为 Windows 构建二进制文件，前面的 `tinygo test` 命令将在 Windows 系统上失败。Windows 用户的一个选择是使用
    WSL 进行单元测试。另一个可能性是使用 `–target` 参数设置构建目标。Windows 支持构建 **wasm** 或 **wasi** 目标，但由于我们的代码依赖于
    `machine` 包，这在这个特定测试中不会工作。这是因为 `machine` 包对 wasm 和 wasi 目标不可用。
- en: Now we know that we can also use table-driven tests in TinyGo. At the time of
    writing, the majority of the testing package seems to be implemented. Currently,
    only the `Helper()` function seems to not be implemented. However, there could
    be one or two small things that I have not found yet, which might not work. Additionally,
    we have checked that our logic to calculate the distance seems to be working as
    expected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们也可以在 TinyGo 中使用基于表的测试。在撰写本文时，测试包的大部分功能似乎已经实现。目前，似乎只有 `Helper()` 函数尚未实现。然而，可能还有一两个小问题我没有发现，它们可能不会正常工作。此外，我们已经检查过我们计算距离的逻辑似乎按预期工作。
- en: With that covered, we can go on and write a small example program to test the
    rest of our code on real hardware.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们可以继续编写一个小型示例程序来测试我们代码在真实硬件上的其余部分。
- en: Writing an example program for the library
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为库编写示例程序
- en: 'We have now checked that our formula to calculate the distance from a pulse
    length input seems to be correct. So, we can move ahead and create an example
    that outputs the measured distance to serial. To do that, first, we need to create
    a new folder, called `ultrasonic-distance-sensor-example`, inside the `Chapter05`
    folder. Additionally, we need to create a new `main.go` file with an empty `main`
    function. The project structure should look similar to the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经验证了从脉冲长度输入计算距离的公式似乎是正确的。因此，我们可以继续前进，创建一个将测量距离输出到串行的示例。为此，首先，我们需要在`Chapter05`文件夹内创建一个新的文件夹，命名为`ultrasonic-distance-sensor-example`。此外，我们还需要创建一个新的`main.go`文件，并包含一个空的`main`函数。项目结构应类似于以下内容：
- en: '![Figure 5.8 – The project structure for the example program'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 示例程序的工程结构'
- en: '](img/Figure_5.8_B16555.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.8_B16555.jpg)'
- en: Figure 5.8 – The project structure for the example program
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 示例程序的工程结构
- en: 'The example logic consists of initializing the sensor and then printing the
    distance each second. All of this is done inside the `main` function. It looks
    like the following snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例逻辑包括初始化传感器，然后每秒打印一次距离。所有这些都在`main`函数内部完成。它看起来像以下代码片段：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the complete code for the example. The library was imported with an
    alias named `hcsr04`. Now, let''s flash the program onto the Arduino Nano 33 IoT
    using the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例的完整代码。库被导入并命名为`hcsr04`别名。现在，让我们使用以下命令将程序烧录到Arduino Nano 33 IoT上：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To check the output, we can use the same `PuTTY` profile that we created in
    [*Chapter 3*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058), *Building a Safety
    Lock Using a Keypad*. Open up PuTTY and select the **Microcontroller** profile.
    Make sure that you have the USB cable plugged into the same port as the Arduino
    UNO beforehand. Depending on the current distance from the sensor to any object,
    the output should look similar to the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查输出，我们可以使用在[*第3章*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058)“使用键盘构建安全锁”中创建的相同的`PuTTY`配置文件。打开PuTTY并选择**微控制器**配置文件。确保在之前已经将USB线插入与Arduino
    UNO相同的端口。根据传感器与任何物体之间的当前距离，输出应类似于以下屏幕截图：
- en: '![Figure 5.9 – Sensor readings in PuTTy'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – PuTTy中的传感器读数'
- en: '](img/Figure_5.9_B16555.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.9_B16555.jpg)'
- en: Figure 5.9 – Sensor readings in PuTTy
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – PuTTy中的传感器读数
- en: In this section, we wrote a library for the HC-SR04 sensor, learned that unit
    testing also works in TinyGo, and then wrote an example project to test the library.
    So, we are now able to measure distance, which is the first half of our project.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们编写了一个HC-SR04传感器的库，学习了TinyGo中也同样可以进行单元测试，然后编写了一个示例项目来测试这个库。因此，我们现在能够测量距离，这是项目的前半部分。
- en: In the next section, we will look at 7-segment displays, as we need 7-segment
    displays to display a timer in our final project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨7段显示器，因为我们需要7段显示器在我们的最终项目中显示计时器。
- en: Using 4-digit 7-segment displays
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用4位7段显示器
- en: A 7-segment display can be used for multiple purposes. One of them is to display
    times, which is exactly what we want to do in our final project. But how can we
    control them?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 7段显示器可以用于多种用途。其中之一是显示时间，这正是我们最终项目想要做的。但我们如何控制它们呢？
- en: 'The 4-digit display has 12 pins: one pin for each digit (from 0 to 9), one
    pin for each segment, and a pin for the dot. So, to display anything, we have
    to send a high signal to the digit we want to set and then just set all pins to
    high, which we need to represent the character we want to display.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 4位显示器有12个引脚：每个数字（从0到9）一个引脚，每个段一个引脚，还有一个点引脚。因此，要显示任何内容，我们必须向要设置的数字发送高电平信号，然后只需将所有引脚设置为高电平，这是我们用来表示要显示的字符的方式。
- en: For instance, if we want to display the character of "1" in the fourth digit,
    we would set pin 4 and pins B and C to high.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在第四位显示字符“1”，我们会将引脚4以及B和C引脚设置为高电平。
- en: 'To get a better understanding of this, take a look at the following diagram:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，请查看以下图表：
- en: '![Figure 5.10 – A 7-segment display pinout'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10 – 7段显示器引脚图'
- en: '](img/Figure_5.10_B16555.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.10_B16555.jpg)'
- en: Figure 5.10 – A 7-segment display pinout
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 7段显示器引脚图
- en: From the preceding diagram, you can see that pins 1 to 4 are being used to select
    the digit.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，你可以看到引脚1到4被用来选择数字。
- en: The 7-segment A-G pins are being used to control the segments and the **dot**
    pin is being used to set the dot.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 7段A-G引脚被用来控制段，而**点**引脚被用来设置点。
- en: 'So, having to control 12 pins is kind of hard, as then we would only have 2
    digital pins left when controlling the display. That is why we use another device
    to control the display: a MAX7219\. The next section explains how this is done.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要控制 12 个引脚有点困难，因为那样的话，在控制显示器时我们只剩下 2 个数字引脚。这就是为什么我们使用另一个设备来控制显示器：一个 MAX7219。下一节将解释如何做到这一点。
- en: Using a MAX7219
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 MAX7219
- en: The MAX7219 (and Max7221) is a *serially interfaced*, 8-digit LED *display driver*.
    In short, we can control this chip using only four wires, which controls up to
    eight 7-segment digits.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: MAX7219（和 Max7221）是一个 *串行接口*，8 位 LED *显示驱动器*。简而言之，我们可以使用仅四根线来控制这个芯片，它可以控制多达八个
    7 段数字。
- en: 'To send data to that chip, we simply need to drive the load pin low, send 1
    byte of data containing the register to set and 1 byte of data to set the segments
    and the dot. Then, we drive the load pin high and the 16 bits that have been written
    are processed. The chip will then decode the data and set all of the output pins.
    The following diagram is a pinout of the chip for reference:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要向该芯片发送数据，我们只需将负载引脚拉低，发送包含要设置的寄存器的 1 字节数据和设置段和点的 1 字节数据。然后，我们将负载引脚拉高，并处理已写入的
    16 位。然后，芯片将解码数据并设置所有输出引脚。以下图是芯片的引脚图，仅供参考：
- en: '![Figure 5.11 – The MAX7219 and MAX7221 pinout'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11 – MAX7219 和 MAX7221 引脚图'
- en: '](img/Figure_5.11_B16555.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.11_B16555.jpg)'
- en: Figure 5.11 – The MAX7219 and MAX7221 pinout
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – MAX7219 和 MAX7221 引脚图
- en: 'These chips are commonly used in 8x8 LED matrices. So ,if you have such a device,
    you could carefully remove the chip using a tweezer. *Removing the chip could
    cause permanent damage to the chip!* These chips are also freely available in
    most shops for microcontroller components. Before we start to write a library
    for this chip, let''s first assemble our circuit. To do this, perform the following
    steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些芯片通常用于 8x8 LED 矩阵。所以，如果你有这样的设备，你可以小心地使用镊子移除芯片。*移除芯片可能会永久损坏芯片!* 这些芯片在大多数微控制器组件商店也都可以自由购买。在我们开始为这个芯片编写库之前，让我们首先组装我们的电路。为此，执行以下步骤：
- en: Take a second breadboard; a half-size one is sufficient.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取另一个面包板；一个半尺寸的就足够了。
- en: Place the MAX7219 on to the breadboard. The *CLK* pin should sit in *E1*, and
    the *LOAD* pin should sit in *G1*.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 放置在面包板上。*CLK* 引脚应位于 *E1*，而 *LOAD* 引脚应位于 *G1*。
- en: Place the 7-segment display on to the breadboard. The `E` pin should sit in
    `D25`, and the `1` pin should sit in *F25* or *G25* (depending on which fits better).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 7 段显示器放置在面包板上。`E` 引脚应位于 `D25`，而 `1` 引脚应位于 *F25* 或 *G25*（取决于哪个更适合）。
- en: Connect *DIG0* from the MAX7219 with *Digit1* from the display.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *DIG0* 连接到显示器的 *Digit1*。
- en: Connect *DIG1* from the MAX7219 with *Digit2* from the display.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *DIG1* 连接到显示器的 *Digit2*。
- en: Connect *DIG2* from the MAX7219 with *Digit3* from the display.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *DIG2* 连接到显示器的 *Digit3*。
- en: Connect *DIG3* from the MAX7219 with *Digit4* from the display.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *DIG3* 连接到显示器的 *Digit4*。
- en: Connect *SEGA* from the MAX7219 with *A* from the display.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGA* 连接到显示器的 *A*。
- en: Connect *SEGB* from the MAX7219 with *B* from the display.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGB* 连接到显示器的 *B*。
- en: Connect *SEGC* from the MAX7219 with *C* from the display.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGC* 连接到显示器的 *C*。
- en: Connect *SEGD* from the MAX7219 with *D* from the display.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGD* 连接到显示器的 *D*。
- en: Connect *SEGE* from the MAX7219 with *E* from the display.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGE* 连接到显示器的 *E*。
- en: Connect *SEGF* from the MAX7219 with *F* from the display.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGF* 连接到显示器的 *F*。
- en: Connect *SEGG* from the MAX7219 with *G* from the display.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGG* 连接到显示器的 *G*。
- en: Connect *SEGDP* from the MAX7219 with *DOT* from the display.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 MAX7219 的 *SEGDP* 连接到显示器的 *DOT*。
- en: Connect the *GND* lane from the power bus of both breadboards.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个面包板电源总线上的 *GND* 通道连接起来。
- en: Connect the *VCC* lane from the power bus of both breadboards using a jumper
    wire.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将两个面包板电源总线上的 *VCC* 通道连接起来。
- en: Connect *ISET* with VCC from the MAX7219 using a **10,000-Ohm resistor**. This
    is a hardware solution that controls the brightness of the display.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个 **10,000-Ohm** 电阻将 *ISET* 连接到 MAX7219 的 VCC。这是一个控制显示器亮度的硬件解决方案。
- en: Connect *D13* from the Arduino with *CLK* from the MAX7219.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Arduino 的 *D13* 连接到 MAX7219 的 *CLK*。
- en: Connect *D6* from the Arduino with *LOAD* from the MAX7219.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Arduino 的 *D6* 连接到 MAX7219 的 *LOAD*。
- en: Connect *D11* from the Arduino with *DIN* from the MAX7219.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Arduino 的 *D11* 连接到 MAX7219 的 *DIN*。
- en: Connect *D5* from the Arduino with *VCC* from the buzzer.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Arduino 的 *D5* 连接到蜂鸣器的 *VCC*。
- en: Connect *GND* from the buzzer with *GND* on the power bus.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蜂鸣器的 *GND* 与电源总线上的 *GND* 连接。
- en: 'When all of this is done, the result should now look similar to the following
    diagram:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当所有这些步骤都完成后，结果现在应该看起来类似于以下图示：
- en: '![Figure 5.12 – The final circuit'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12 – 最终电路图'
- en: '](img/Figure_5.12_B16555.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.12_B16555.jpg)'
- en: Figure 5.12 – The final circuit
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 最终电路图
- en: Now, let's better understand how the MAX7219 works by writing a small library
    that communicates with this chip.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过编写一个小型库来与这个芯片通信，更好地理解 MAX7219 的工作原理。
- en: Writing a library to control the MAX7219
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写控制 MAX7219 的库
- en: We do not only want to learn how to use a MAX7219 in a single project, but we
    also want to create a library that we can use in all future projects, even beyond
    the book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅想学习如何在单个项目中使用 MAX7219，还想创建一个库，我们可以在所有未来的项目中使用，甚至超出本书的范围。
- en: 'To begin with, we need to create a new folder, called `max7219spi`, inside
    the `Chapter05` folder. Create two files named `registers.go` and `device.go`
    inside the newly created folder, and use `MAX7219spi` as the package name. The
    project structure should look like the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `Chapter05` 文件夹中创建一个新的文件夹，命名为 `max7219spi`。在新建的文件夹中创建两个名为 `registers.go`
    和 `device.go` 的文件，并使用 `MAX7219spi` 作为包名。项目结构应如下所示：
- en: '![Figure 5.13 – The project structure to control the MAX7219'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13 – 控制MAX7219的项目结构'
- en: '](img/Figure_5.13_B16555.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.13_B16555.jpg)'
- en: Figure 5.13 – The project structure to control the MAX7219
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 控制MAX7219的项目结构
- en: We are now ready to move ahead and write some code. We will start by implementing
    the needed registers in the next section.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好继续前进并编写一些代码。我们将在下一节中实现所需的寄存器。
- en: Registers.go
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Registers.go
- en: 'Inside the `registers.go` file, we place a bunch of constants that represent
    register addresses. We will explain the constants as soon as we use them in the
    code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `registers.go` 文件中，我们放置了一些代表寄存器地址的常量。我们将在使用代码中的常量时解释这些常量：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is it for this file. Further explanations regarding these constants can
    also be found in the datasheet at [https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf](https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf).
    Now, we are going to implement the driver.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个文件的全部内容。有关这些常量的进一步解释也可以在数据手册[https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf](https://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf)中找到。现在，我们将实现驱动程序。
- en: Device.go
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Device.go
- en: 'In this file, we can define an interface to implement its methods. The interface
    will provide a function to write data to the MAX7219, along with some convenience
    functions to start a display test for our example. To implement it, follow these
    steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们可以定义一个接口来实现其方法。该接口将提供一个向 MAX7219 写入数据的函数，以及一些方便的函数来为我们的示例启动显示测试。要实现它，请按照以下步骤：
- en: 'Define the `Device` interface with all of its functions, as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式定义包含所有功能的 `Device` 接口：
- en: '[PRE39]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, define a `device` struct that contains an `load`. We will explain these
    pins in more detail as soon as we use them:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个包含 `load` 的 `device` 结构体。我们将在使用这些引脚时详细解释它们：
- en: '[PRE40]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, define a function, called `NewDevice`, that creates a new instance of
    `device` and sets the `load` pin along with the SPI `bus`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个名为 `NewDevice` 的函数，它创建一个新的 `device` 实例，并设置 `load` 引脚以及 SPI `总线`：
- en: '[PRE41]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define a function, called `WriteCommand`, that takes 2 bytes as its parameter.
    The first byte is `register` and the second one is the `data` to set. For the
    register, we use the constants of the `registers.go` file. We write data to the
    MAX7219 by pulling the `load` pin to low. Next, we write the `register` byte,
    then the `payload`, and then we pull the load `pin` to `high`. Pulling the `load`
    pin to `high` triggers the MAX7219 to load and process the data:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `WriteCommand` 的函数，它接受 2 个字节作为其参数。第一个字节是 `register`，第二个字节是设置的数据。对于寄存器，我们使用
    `registers.go` 文件中的常量。我们通过将 `load` 引脚拉低来向 MAX7219 写入数据。接下来，我们写入 `register` 字节，然后是
    `payload`，然后我们将 `load` 引脚拉高。将 `load` 引脚拉高会触发 MAX7219 加载并处理数据：
- en: '[PRE42]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define a function, called `Configure`, that sets the `load` pin as the output:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Configure` 的函数，将 `load` 引脚设置为输出：
- en: '[PRE43]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define a function, called `SetScanLimit`, that tells the MAX7219 how many digits
    we are going to use in our program. Digits in the MAX7219 start from 0, so we
    subtract 1 from our digit number, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `SetScanLimit` 的函数，告诉 MAX7219 我们将在程序中使用多少位。MAX7219 中的数字从 0 开始，因此我们需要从我们的数字数量中减去
    1，如下所示：
- en: '[PRE44]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, define a function, called `SetDecodeMode`, that tells the MAX7219 how
    many digits should be decoded. The decode mode is going to help us later, as it
    translates our input into the matching output for the 7-segment display in order
    to display a character. The MAX7219 has a predefined set of characters for this
    purpose:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个名为`SetDecodeMode`的函数，该函数告诉MAX7219应该解码多少位。解码模式将有助于我们以后，因为它将我们的输入转换为匹配7段显示屏的输出以显示字符。MAX7219为此目的有一个预定义的字符集：
- en: '[PRE45]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Switch over to the `digitNumber` input; if we only use one digit, we tell the
    MAX7219 to only *decode the first digit*:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`digitNumber`输入；如果我们只使用一个数字，我们告诉MAX7219只*解码第一个数字*：
- en: '[PRE46]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we use two, three, or four digits, we tell the MAX7219 to *decode the first
    four digits*:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们使用两个、三个或四个数字，我们告诉MAX7219*解码前四个数字*：
- en: '[PRE47]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Decode all of the digits:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码所有数字：
- en: '[PRE48]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the input is 0, or greater than 8, we tell the MAX7219 to *decode nothing*:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入为0或大于8，我们告诉MAX7219*不进行解码*：
- en: '[PRE49]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: func (driver *device) StartShutdownMode() {
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: func (driver *device) StartShutdownMode() {
- en: driver.WriteCommand(REG_SHUTDOWN, 0x00)
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: driver.WriteCommand(REG_SHUTDOWN, 0x00)
- en: '}'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: func (driver *device) StopShutdownMode() {
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: func (driver *device) StopShutdownMode() {
- en: driver.WriteCommand(REG_SHUTDOWN, 0x01)
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: driver.WriteCommand(REG_SHUTDOWN, 0x01)
- en: '}'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE50]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we want to be able to start and stop the display test mode. The *display
    test activates all of the connected LEDs*. This looks like the following:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们希望能够启动和停止显示测试模式。*显示测试激活所有连接的LED*。这看起来如下所示：
- en: '[PRE51]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define a function, called `writeByte`, that takes a byte and writes it to the
    MAX7219\. Here, we make use of the SPI interface. First, the SPI implementation
    internally pulls down the clock pin, then it takes each bit of the byte, and sets
    the data pin to low for a 0 and to high for a 1\. After the data line bit has
    been set, it pulls up the clock pin:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`writeByte`的函数，该函数接收一个字节并将其写入MAX7219。在这里，我们使用SPI接口。首先，SPI实现内部拉低时钟引脚，然后它取字节中的每个位，并将数据引脚设为低电平以表示0，设为高电平以表示1。在数据线位被设置后，它拉高时钟引脚：
- en: '[PRE52]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is everything we need for the MAX7219.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要的MAX7219的所有内容。
- en: In the next section, we will create a small abstraction layer above this device.
    Our abstraction layer will implement the specifics of 7-segment displays. We have
    implemented the MAX7219 package in a very generic way, and that was done on purpose
    so that we can build abstraction layers for 7-segment displays and 8x8 LED matrices
    based on this package.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个位于此设备之上的小型抽象层。我们的抽象层将实现7段显示屏的具体细节。我们已经以非常通用的方式实现了MAX7219包，这是故意的，以便我们可以根据这个包构建7段显示屏和8x8
    LED矩阵的抽象层。
- en: Writing a library to control the hs42561k display
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写控制hs42561k显示屏的库
- en: 'This library makes use of the MAX7219 library to set it up for 7-segment display
    use and provides a convenience function to set a character to a specific digit.
    We start by creating a new folder, called `hs42561k`, inside the `Chapter05` folder
    and create two files named `constants.go` and `device.go`. Then, name the package
    `hs42561k`. The project structure should look similar to the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库使用MAX7219库来设置它用于7段显示屏的使用，并提供一个便利函数来设置特定数字的字符。我们首先在`Chapter05`文件夹内创建一个名为`hs42561k`的新文件夹，并创建两个名为`constants.go`和`device.go`的文件。然后，将包命名为`hs42561k`。项目结构应类似于以下内容：
- en: '![Figure 5.14 – The project structure to control the hs42561k display'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14 – 控制hs42561k显示屏的项目结构'
- en: '](img/Figure_5.14_B16555.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.14_B16555.jpg)'
- en: Figure 5.14 – The project structure to control the hs42561k display
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 控制hs42561k显示屏的项目结构
- en: 'We start with the `constants.go` file. This file is going to hold some constants
    and a convenience function that returns a string for a character. To do this,
    perform the following steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`constants.go`文件开始。这个文件将包含一些常量和返回字符字符串的便利函数。为此，执行以下步骤：
- en: 'Add constants for all of the characters. The values are taken from the MAX7219
    datasheet. If we use these values, the MAX7219 is going to set the correct pins
    on the display, thanks to the integrated decoder:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有字符添加常量。这些值取自MAX7219数据表。如果我们使用这些值，MAX7219将设置显示屏上的正确引脚，这要归功于集成的解码器：
- en: '[PRE53]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let''s add the `Character` struct, which implements the `String` function.
    The `String` function will come in handy when debugging. We have truncated the
    list in the example; of course, you might also want to add cases `One` to `Eight`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加`Character`结构体，它实现了`String`函数。`String`函数在调试时非常有用。我们在示例中截断了列表；当然，你也可能想添加`One`到`Eight`的情况：
- en: '[PRE54]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is everything we need in the `constants.go` file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `constants.go` 文件中我们需要的所有内容。
- en: 'Now, let''s implement the `device.go` file by following these steps:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤实现 `device.go` 文件：
- en: 'Add an interface named `Device` with a `Configure` function and a `SetDigit`
    function:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Device` 的接口，其中包含 `Configure` 函数和 `SetDigit` 函数：
- en: '[PRE55]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a `struct`, called `device`, which holds the number of digits we want to
    control and a reference to the MAX7219 device:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `device` 的 `struct`，它包含我们想要控制的数字数量以及 MAX7219 设备的引用：
- en: '[PRE56]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add a function, called `NewDevice`, that returns a `Device` instance:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `NewDevice` 的函数，该函数返回一个 `Device` 实例：
- en: '[PRE57]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add a function named `Configure`. The `Configure` function is used to initialize
    the display driver. It does this by setting the correct `decode mode` and `scan
    limit` functions and stopping the shutdown mode to bring the display into operational
    mode, which is implemented in the following snippet:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Configure` 的函数。`Configure` 函数用于初始化显示驱动器。它通过设置正确的 `decode mode` 和 `scan
    limit` 函数以及停止关闭模式以将显示屏带入操作模式来实现，如下面的代码片段所示：
- en: '[PRE58]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Write `blank` next to each digit, so we can start off with a clean display,
    just like the following code:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个数字旁边写 `blank`，这样我们就可以从一个干净的显示屏开始，就像以下代码所示：
- en: '[PRE59]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we can define an *error* for an invalid digit selection:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个用于无效数字选择的 *错误*：
- en: '[PRE60]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The next step is to define a function, called `SetDigit`, that sets the given
    character to the given digit:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是定义一个名为 `SetDigit` 的函数，该函数将给定的字符设置为给定的数字：
- en: '[PRE61]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we have an invalid digit number, we need to validate the `digit` input and
    return an error. This is because we cannot display values on digits that do not
    exist:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们有一个无效的数字编号，我们需要验证 `digit` 输入并返回一个错误。这是因为我们无法在不存在数字上显示值：
- en: '[PRE62]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The last step is to write the `character` to the given `digit`, as shown in
    the following snippet:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将 `character` 写入给定的 `digit`，如下面的代码片段所示：
- en: '[PRE63]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This is the complete logic for the display driver.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显示驱动器的完整逻辑。
- en: 'Now, let''s add a small example project to validate that our code is working
    as expected. For that purpose, we create a new folder, called `hs42561k-spi-example`,
    inside the `Chapter05` folder and create a new `main.go` file with an empty `main`
    function in it. The project structure should look like the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个小型示例项目来验证我们的代码是否按预期工作。为此，我们在 `Chapter05` 文件夹内创建一个名为 `hs42561k-spi-example`
    的新文件夹，并创建一个包含空 `main` 函数的新 `main.go` 文件。项目结构应如下所示：
- en: '![Figure 5.15 – The project structure to validate the code for the hs42561k-spi-example'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.15 – 验证 hs42561k-spi-example 代码的项目结构'
- en: '](img/Figure_5.15_B16555.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.15_B16555.jpg](img/Figure_5.15_B16555.jpg)'
- en: Figure 5.15 – The project structure to validate the code for the hs42561k-spi-example
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 验证 hs42561k-spi-example 代码的项目结构
- en: 'Now, we can add logic to the new `main.go` file. Follow these steps to set
    up our example program:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在新的 `main.go` 文件中添加逻辑。按照以下步骤设置我们的示例程序：
- en: 'First, we add an array of `Character`, which contains all possible characters.
    Here are the characters that we want to display:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个包含所有可能字符的 `Character` 数组。以下是我们想要显示的字符：
- en: '[PRE64]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Configure the `SPI0` interface. `SDO` is our output pin, and `SCK` is our clock
    pin. We send data with the most *significant bit first* at a `frequency` of 10
    MHz. 10 MHz is the maximum frequency that the MAX7219 can handle according to
    the datasheet:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `SPI0` 接口。`SDO` 是我们的输出引脚，而 `SCK` 是我们的时钟引脚。我们以 10 MHz 的 `frequency` 发送数据，最
    **重要** 的位首先发送。根据数据表，10 MHz 是 MAX7219 可以处理的最大频率：
- en: '[PRE65]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We check whether there was an error and print the error if there was one. This
    information helps us when debugging:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查是否有错误，如果有错误，则打印错误信息。这些信息有助于我们在调试时使用：
- en: '[PRE66]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Initialize the MAX7219 display driver with `D6` as the load pin and `machine.SPI0`
    as the SPI bus:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `D6` 作为加载引脚和 `machine.SPI0` 作为 SPI 总线初始化 MAX7219 显示驱动器：
- en: '[PRE67]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we need to initialize the `display` with 4 digits. After this step, the
    display is ready to be used:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要用 4 个数字初始化 `display`。完成此步骤后，显示屏就准备好使用了：
- en: '[PRE68]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For each `character` in `characters`, set the `character` to all digits and
    sleep for half a second. That way, we can test whether we are able to display
    every possible character on every digit:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `characters` 中的每个 `character`，将 `character` 设置为所有数字，并暂停半秒钟。这样，我们可以测试我们是否能够在每个数字上显示每个可能的字符：
- en: '[PRE69]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is the complete example program. We can go ahead and flash the program
    using the following command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的示例程序。我们可以继续使用以下命令来烧录程序：
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If everything went as expected, the display should now start to print each possible
    character.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切如预期进行，显示器现在应该开始打印每个可能的字符。
- en: We have now learned how to control a 7-segment display, learned about the MAX7219
    display driver, wrote a library for the display driver and the display, and also
    wrote an example program. In the next section, we are going to use these libraries
    and the ultrasonic distance sensor to build our final project of this chapter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何控制7段显示器，了解了MAX7219显示器驱动器，编写了显示器驱动器和显示器的库，还编写了一个示例程序。在下一节中，我们将使用这些库和超声波距离传感器来构建本章的最终项目。
- en: Putting it all together
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些组合起来
- en: In our final project of this chapter, we are going to make use of everything
    we have learned in the preceding sections. We are going to use the ultrasonic
    distance sensor to recognize a hand movement in close proximity to the sensor.
    We are using the 7-segment display to count down from 20 to 0 and we are going
    to use a buzzer, to provide an additional signal, for the timer start and the
    timer end. In Germany, it is officially recommended that we wash our hands for
    at least 20 seconds, which is why we will also add a timer for 20 seconds. Putting
    all of this together, we will create a touchless handwash timer.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最终项目中，我们将利用前面章节所学的所有知识。我们将使用超声波距离传感器来识别传感器附近的手部动作。我们使用7段显示器从20倒数到0，并且我们将使用蜂鸣器，为计时器的开始和结束提供额外的信号。在德国，官方建议我们洗手至少20秒，这就是为什么我们也会添加一个20秒的计时器。将这些全部组合起来，我们将创建一个非接触式洗手计时器。
- en: 'Before we start to write the code to control the hand wash timer, we need to
    add a buzzer. We can add this by following these steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写控制洗手计时器的代码之前，我们需要添加一个蜂鸣器。我们可以通过以下步骤来添加它：
- en: Put the *GND* pin of the buzzer in *D53* and the *VCC* pin of the buzzer into
    `D54`. If that is too close together for your buzzer's pins, just put the buzzer
    in and wire the following two wires accordingly.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蜂鸣器的*GND*引脚连接到*D53*，并将蜂鸣器的*VCC*引脚连接到`D54`。如果蜂鸣器的引脚太靠近，只需将蜂鸣器插入并相应地连接以下两根线。
- en: Connect the *GND* pin of the Arduino with *A53* on the breadboard using a jumper
    wire.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将Arduino的*GND*引脚与面包板上的*A53*连接。
- en: Connect the *D5* pin of the Arduino with *A54* on the breadboard using a jumper
    wire.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将Arduino的*D5*引脚与面包板上的*A54*连接。
- en: 'The circuit should look similar to the following diagram:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 电路应该看起来类似于以下图示：
- en: .
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '![Figure 5.16 – The touchless handwash timer circuit'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.16 – The touchless handwash timer circuit](img/Figure_5.16_B16555.jpg)'
- en: '](img/Figure_5.16_B16555.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.16 – The touchless handwash timer circuit](img/Figure_5.16_B16555.jpg)'
- en: Figure 5.16 – The touchless handwash timer circuit
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.16 – The touchless handwash timer circuit
- en: 'Now that we have set up the circuit, we can go ahead and write the logic. We
    start by creating a new folder, called `touchless-handwash-timer`, inside the
    `Chapter05` folder. Then, we create a new `main.go` file with an empty `main`
    function. The project structure should look like the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了电路，我们可以继续编写逻辑。我们首先在`Chapter05`文件夹中创建一个名为`touchless-handwash-timer`的新文件夹。然后，我们创建一个名为`main.go`的新文件，其中包含一个空的`main`函数。项目结构应该如下所示：
- en: '![Figure 5.17 – The project structure for the handwash timer'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.17 – The project structure for the handwash timer](img/Figure_5.17_B16555.jpg)'
- en: '](img/Figure_5.17_B16555.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.17 – The project structure for the handwash timer](img/Figure_5.17_B16555.jpg)'
- en: Figure 5.17 – The project structure for the handwash timer
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 5.17 – The project structure for the handwash timer
- en: 'Now, follow these steps inside the `main` function to implement the logic for
    the touchless handwash timer:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`main`函数内部按照以下步骤实现非接触式洗手计时器的逻辑：
- en: 'The first step is to initialize the `SPI0` interface, as follows:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是初始化`SPI0`接口，如下所示：
- en: '[PRE71]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If an error occurs, we print it. Doing so enables us to debug the program by
    monitoring the output of the serial port:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生错误，我们将打印出来。这样做使我们能够通过监控串行端口输出来调试程序：
- en: '[PRE72]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now we want to initialize the `display`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想要初始化`display`：
- en: '[PRE73]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After that is done, we can go on and initialize the `distanceSensor`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以继续初始化`distanceSensor`：
- en: '[PRE74]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we initialize the `buzzer`. If you skipped [*Chapter 4*](B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082),
    *Building a Plant Watering System*, simply import the buzzer package from [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer):'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们初始化`buzzer`。如果你跳过了[*第4章*](B16555_04_Final_VK_ePub.xhtml#_idTextAnchor082)，*构建植物浇水系统*，只需从[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter04/buzzer)导入buzzer包：
- en: '[PRE75]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, we get and print the `currentDistance`. Printing the distance helps us
    to debug the program if any problems occur later on. This looks like the following:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们获取并打印`currentDistance`。打印距离有助于我们在以后出现问题时调试程序。如下所示：
- en: '[PRE76]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If the `currentDistance` is between `12` and `25` centimeters, activate the
    timer. This is shown with the following snippet:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`currentDistance`在`12`到`25`厘米之间，激活计时器。这在上面的代码片段中显示：
- en: '[PRE77]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now we have to sleep for `100` milliseconds. We do this to prevent the echoes
    from overlapping:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须暂停`100`毫秒。我们这样做是为了防止回声重叠：
- en: '[PRE78]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The last function is the `handleTimer` function, which takes `display`, `displayDriver`,
    and `buzzer` as parameters:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数是`handleTimer`函数，它接受`display`、`displayDriver`和`buzzer`作为参数：
- en: '[PRE79]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'First, we make sure that `display` is in operational mode:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们确保`display`处于操作模式：
- en: '[PRE80]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now we let the `buzzer` beep two times to indicate that the timer has started:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们让`buzzer`鸣响两次以指示计时器已启动：
- en: '[PRE81]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we count from `20` to `0`. This represents the 20 seconds that our timer
    is running, as follows:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从`20`计数到`0`。这代表我们的计时器正在运行的20秒，如下所示：
- en: '[PRE82]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If we have more than 10 seconds left, we need to set the third `digit`. Because
    we need to set more than one digit, we are going to set digit `3` and `4`, which
    looks like the following:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们还有超过10秒的时间，我们需要设置第三个`digit`。因为我们需要设置多个数字，我们将设置数字`3`和`4`，如下所示：
- en: '[PRE83]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Additionally, we need to handle all numbers that have a trailing 0\. And this
    looks similar to the following snippet:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们还需要处理所有带有尾随0的数字。这看起来与以下代码片段类似：
- en: '[PRE84]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we need to handle all numbers that are smaller than 10\. This is implemented
    in the following snippet:'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要处理所有小于10的数字。这在上面的代码片段中实现：
- en: '[PRE85]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'After the timer runs out, we reset both used digits by setting them to `blank`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计时器运行结束后，我们将两个使用的数字重置为`blank`：
- en: '[PRE86]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let the `buzzer` beep for half a second to indicate that the timer has finished:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让`buzzer`鸣响半秒钟以指示计时器已完成：
- en: '[PRE87]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Put the display driver into shutdown mode:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示驱动器置于关机模式：
- en: '[PRE88]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is all the code we need. Now, try the code by flashing it onto the Arduino
    using the following command:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有代码。现在，通过以下命令将代码烧录到Arduino上尝试一下：
- en: '[PRE89]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We have successfully built and flashed the program. Now it is time to try it
    out.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功构建并烧录了程序。现在，是时候尝试一下了。
- en: So, we combined all the components that we built throughout this chapter into
    this final project, and we used the components to recognize the movement from
    a certain distance in front of the sensor to start a timer. This was the final
    project of this chapter.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将本章构建的所有组件组合成这个最终项目，并使用这些组件来识别传感器前方一定距离内的运动以启动计时器。这是本章的最终项目。
- en: Summary
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the technical specifications of the Arduino
    Nano 33 IoT and how to calculate the distance between an object and an ultrasonic
    distance sensor. Additionally, we learned how the sensor works internally and
    wrote a library for it. We also learned that unit testing is supported in TinyGo
    and wrote some tests for the ultrasonic distance sensor library. Then, we learned
    how to use a MAX7219 serial interfaced display driver to control a 7-segment display,
    and we wrote a library for the MAX7219 and the 7-segment display. At the end of
    this chapter, we put all of the drivers into a single project and only had to
    add a small amount of control logic to build a touchless handwash timer.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Arduino Nano 33 IoT的技术规格以及如何计算物体与超声波距离传感器之间的距离。此外，我们还学习了传感器内部的工作原理，并为它编写了库。我们还了解到TinyGo支持单元测试，并为超声波距离传感器库编写了一些测试。然后，我们学习了如何使用MAX7219串行接口显示驱动器来控制7段显示器，并为MAX7219和7段显示器编写了库。在本章的最后，我们将所有驱动器组合成一个单一的项目，并且只需要添加少量控制逻辑来构建一个非接触式洗手计时器。
- en: In the next chapter, we are going to learn how to use 16x02 LCD and ST7735 TFT
    displays.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用16x02 LCD和ST7735 TFT显示屏。
- en: Questions
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is it possible to draw 5V output from the Arduino Nano 33 IoT?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以从Arduino Nano 33 IoT上绘制出5V输出？
- en: Why do we divide `pulseLength` by 2 when calculating the distance to an object?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在计算到物体的距离时，要将`pulseLength`除以2？
- en: Change the code so that the handwash timer counts from 120 to 0\. Use three
    digits to display the remaining seconds.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码修改为从120开始倒数至0。使用三位数字来显示剩余的秒数。
