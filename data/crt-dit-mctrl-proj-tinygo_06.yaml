- en: '*Chapter 6*: Building Displays for Communication using I2C and SPI Interfaces'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用I2C和SPI接口构建用于通信的显示屏'
- en: In the previous chapter, we learned how to display data using a 7-segment display,
    how a MAX7219 chip works, how ultrasonic distance sensors work, and how to write
    a library for all this. We used the SPI interface to do so.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用7段显示屏显示数据，MAX7219芯片的工作原理，超声波距离传感器的工作原理，以及如何编写所有这些的库。我们使用SPI接口来完成这些操作。
- en: After working through this chapter, we will know how to use different types
    of displays and which displays use different interfaces for communication. We
    are going to learn how the I2C interface works by using a display that we can
    connect using an I2C bus. With that covered, we are going to learn how to read
    and interpret user input. After that, we are going to learn how to draw shapes
    and texts on displays. Finally, we are going to learn how to build a game that
    can run on a microcontroller. With this knowledge, we will be able to understand
    the overall concept of using various displays for communication.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，我们将了解如何使用不同类型的显示屏以及哪些显示屏使用不同的接口进行通信。我们将通过使用可以通过I2C总线连接的显示屏来学习I2C接口的工作原理。了解这一点后，我们将学习如何读取和解释用户输入。之后，我们将学习如何在显示屏上绘制形状和文本。最后，我们将学习如何构建一个可以在微控制器上运行的游戏。有了这些知识，我们将能够理解使用各种显示屏进行通信的整体概念。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Exploring the TinyGo drivers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索TinyGo驱动程序
- en: Displaying text on a 16x2 LCD display
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在16x2 LCD显示屏上显示文本
- en: Displaying user input on the display
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示屏上显示用户输入
- en: Building a CLI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建命令行界面
- en: Displaying a simple game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示简单游戏
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We are going to need the following components for this project:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下组件来完成此项目：
- en: An Arduino Nano 33 IoT
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Nano 33 IoT
- en: HD44780 1602 LCD display bundled with an I2C interface
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备I2C接口的HD44780 1602 LCD显示屏
- en: ST7735 display
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ST7735显示屏
- en: 1 x breadboard
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个面包板
- en: 1 x 10k Ohm resistor
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个10k欧姆电阻
- en: 1 x 4-pinned button
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个4针按钮
- en: Jumper wires
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter06)
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/2Qo8Jji](https://bit.ly/2Qo8Jji)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在以下链接找到：[https://bit.ly/2Qo8Jji](https://bit.ly/2Qo8Jji)
- en: Exploring the TinyGo drivers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索TinyGo驱动程序
- en: In [*Chapter 3*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058), *Building
    a Safety Lock Using a Keypad*, we learned about the TinyGo drivers repository.
    Let's have a brief look at how to find drivers and examples in this repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16555_03_Final_VK_ePub.xhtml#_idTextAnchor058)“使用键盘构建安全锁”，我们学习了TinyGo驱动程序存储库。让我们简要了解一下如何在存储库中查找驱动程序和示例。
- en: When you're planning a new project, it is always good to check if the drivers
    repository has drivers for the devices you plan to use. It will speed up your
    project and make it easier to implement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你计划一个新的项目时，检查驱动程序存储库是否为你计划使用的设备提供了驱动程序总是好的。这将加快你的项目进度，并使其更容易实现。
- en: 'The drivers repository is split into two parts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序存储库分为两部分：
- en: The drivers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序
- en: Examples
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例
- en: The drivers directly reside in the root of the repository. All the examples
    are inside an example folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序直接位于存储库的根目录下。所有示例都位于一个示例文件夹中。
- en: 'We want to use an hd44780 LCD display with an I2C interface in our example,
    so let''s check if we can find it inside the drivers repository. Refer to the
    following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在示例中使用具有I2C接口的hd44780 LCD显示屏，因此让我们检查是否可以在驱动程序存储库中找到它。参考以下截图：
- en: '![Figure 6.1 – An hd44780i2c driver'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – hd44780i2c驱动程序](img/Figure_6.1_B16555.jpg)'
- en: '](img/Figure_6.1_B16555.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – hd44780i2c驱动程序](img/Figure_6.1_B16555.jpg)'
- en: Figure 6.1 – An hd44780i2c driver
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – hd44780i2c驱动程序
- en: As we can see, the package is named after the device and the interface (**I2C**)
    it uses. Sometimes, a driver package provides more than one interface to use in
    one package. Most of the drivers omit the additional interface in the name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该软件包以它所使用的设备和接口（**I2C**）命名。有时，一个驱动程序包在一个包中提供多个接口供使用。大多数驱动程序在名称中省略了额外的接口。
- en: 'To find example code that shows how to use a package, navigate to the `examples`
    folder and look for a folder that has exactly the same name as the driver package.
    The following screenshot shows the example code for the **hd47780i2c** driver:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到显示如何使用包的示例代码，请导航到`examples`文件夹，并查找与驱动程序包名称完全相同的文件夹。以下屏幕截图显示了**hd47780i2c**驱动程序的示例代码：
- en: '![Figure 6.2 – hd44780i2c driver example'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – hd44780i2c驱动器示例'
- en: '](img/Figure_6.2_B16555.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.2_B16555.jpg)'
- en: Figure 6.2 – hd44780i2c driver example
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – hd44780i2c驱动器示例
- en: Now that we now know that there is a driver for the display we want to use and
    where to find example code for that driver, let's move on and use that driver.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道有一个用于我们想要使用的显示屏的驱动程序，并且知道在哪里可以找到该驱动程序的示例代码，让我们继续并使用该驱动程序。
- en: Displaying text on an HD44780 16x2 LCD display
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HD44780 16x2 LCD显示屏上显示文字
- en: The HD44780 16x2 LCD is cheap and easy to use. If we only want to display text,
    this type of display can do just that and is the device of choice. It has 16 pins,
    which is too many, if we want to combine it with more devices in a project. That
    is why it is a pretty common practice to use an I2C display driver to control
    the display. This is a concept similar to using a MAX7219 to drive a 7-segment
    display, as we did in the previous chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: HD44780 16x2 LCD显示屏便宜且易于使用。如果我们只想显示文字，这种类型的显示屏可以做到这一点，并且是首选设备。它有16个引脚，如果我们想在项目中结合更多设备，这会太多。这就是为什么使用I2C显示屏驱动器来控制显示屏是一种相当常见的做法。这与我们在上一章中使用MAX7219驱动7段显示屏的概念类似。
- en: 'The HD44780 16x2 display can be obtained in a bundle with an I2C driver soldered
    to it, or it can come without an I2C driver. The display can come in different
    color configurations, pertaining to background and text color. They typically
    look similar to the one shown in the following image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: HD44780 16x2显示屏可以与焊接在其上的I2C驱动器一起购买，或者它可以不带有I2C驱动器。显示屏可能有不同的颜色配置，涉及背景和文字颜色。它们通常看起来与以下图像中的类似：
- en: '![Figure 6.3 – HD44780 front'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – HD44780正面'
- en: '](img/Figure_6.3_B16555.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.3_B16555.jpg)'
- en: Figure 6.3 – HD44780 front
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – HD44780正面
- en: 'When the display comes with an I2C driver, it is usually an LCM1602 IIC, which
    provides four ports:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示屏带有I2C驱动器时，通常是一个LCM1602 IIC，它提供四个端口：
- en: GND
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GND
- en: VCC
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VCC
- en: SDA
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SDA
- en: SCL
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SCL
- en: 'So, when using the LCM1602, we only need to connect *GND* and *VCC* to the
    power bus; the remaining two wires are used for *SDA* and *SCL*. The LCM1602 IIC
    has a potentiometer on the board, which can be used to adjust the contrast of
    the display. The following image shows such an LCM1602 IIC, which has been soldered
    to the back of an HD44780:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用LCM1602时，我们只需要将*GND*和*VCC*连接到电源总线；其余的两根线用于*SDA*和*SCL*。LCM1602 IIC板上有一个电位器，可以用来调整显示屏的对比度。以下图像显示了这样一个LCM1602
    IIC，它已经被焊接在HD44780的背面：
- en: '![Figure 6.4 – LCM1602 IIC soldered to the back of an HD44780'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – LCM1602 IIC焊接在HD44780的背面'
- en: '](img/Figure_6.4_B16555.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.4_B16555.jpg)'
- en: Figure 6.4 – LCM1602 IIC soldered to the back of an HD44780
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – LCM1602 IIC焊接在HD44780的背面
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Most HD47780 displays operate at 5V, but some only need 3.3V. So, check the
    datasheet of your display carefully to prevent possible damage!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数HD47780显示屏在5V下运行，但有些只需要3.3V。因此，仔细检查你显示屏的数据表，以防止可能的损坏！
- en: We now have a brief understanding of the HD44780 and that we can utilize an
    LCM1602 IIC to save some pins. Now, let's move on and build the circuit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对HD44780有了初步的了解，并且可以利用LCM1602 IIC来节省一些引脚。现在，让我们继续并构建电路。
- en: Building the circuit
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'Before we can show anything on the display, we need to build the circuit. Just
    follow these steps to do so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在显示屏上显示任何内容之前，我们需要构建电路。只需按照以下步骤操作即可：
- en: Make sure that the jumper of the power supply sits on 5V. Double-check if you
    might have a 3.3V display and if so, set the jumper to 3.3V.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保电源跳线位于5V。如果可能你有3.3V的显示屏，那么将跳线设置为3.3V。
- en: Connect the *GND* pin of the display to the *GND* lane on the power bus.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示屏的*GND*引脚连接到电源总线上的*GND*线路。
- en: Connect the *VCC* pin of the display to the *VCC* lane on the power bus.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示屏的*VCC*引脚连接到电源总线上的*VCC*线路。
- en: Connect *A14* to the breadboard (*GND*) with the *GND* lane on the power bus.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*A14*连接到面包板（*GND*）与电源总线上的*GND*线路。
- en: Connect *A9* to the breadboard (*SCL*) with the *SCL* pin of the display.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*A9*连接到面包板（*SCL*）与显示屏的*SCL*引脚。
- en: Connect *A8* to the breadboard (*SDA*) with the *SDA* pin of the display.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*A8*连接到面包板（*SDA*）与显示屏的*SDA*引脚。
- en: 'The circuit should now look similar to the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 电路现在应该看起来类似于以下图像：
- en: '![Figure 6.5 – 16x02 I2C display circuit (image taken from Fritzing)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 16x02 I2C显示电路（图片来自Fritzing）'
- en: '](img/Figure_6.5_B16555.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.5_B16555.jpg)'
- en: Figure 6.5 – 16x02 I2C display circuit (image taken from Fritzing)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 16x02 I2C显示电路（图片来自Fritzing）
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '16x02 I2C LCD Fritzing parts have been taken from the following link:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 16x02 I2C LCD Fritzing组件已从以下链接获取：
- en: '[https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-](https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-](https://github.com/e-radionicacom/e-radionica.com-Fritzing-Library-parts-)。'
- en: That was everything we needed to set up regarding our hardware devices. However,
    before we start writing the code, we need to understand I2C.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们设置硬件设备所需的所有内容。然而，在我们开始编写代码之前，我们需要了解I2C。
- en: Understanding I2C
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解I2C
- en: I2C is a synchronous two-wired serial bus, where the data wire being used is
    bidirectional. Sometimes, **I2C** is also called a **Two-Wire Interface** (**TWI**).
    One wire is used to provide a **clock**, while the other wire is used to **transmit
    data**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: I2C是一种同步双线串行总线，其中所用的数据线是双向的。有时，**I2C**也被称为**双线接口**（**TWI**）。一根线用于提供**时钟**，而另一根线用于**传输数据**。
- en: The I2C bus allows multiple devices to communicate on the same bus. Unlike the
    **Peripheral Interface** (**SPI**)) bus, the I2C bus does not need a **chip select**
    (**CS**) pin; instead, it just includes the address of the receiving device in
    the message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: I2C总线允许多个设备在同一总线上进行通信。与**外围接口**（**SPI**）总线不同，I2C总线不需要**芯片选择**（**CS**）引脚；相反，它只需在消息中包含接收设备的地址。
- en: 'An I2C message contains the following parts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个I2C消息包含以下部分：
- en: '**Start condition**: The start condition signals that a new message is being
    sent.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动条件**：启动条件表示正在发送一条新消息。'
- en: '**Address frame**: The address frame contains the address of the device that
    should receive the message.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址帧**：地址帧包含应接收消息的设备的地址。'
- en: '**Read/Write bit**: This bit is used to signal whether data is being sent from
    the controller to the device, or if data is being requested from the device.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读/写位**：此位用于指示数据是否从控制器发送到设备，或者是否从设备请求数据。'
- en: '**ACK/NACK bit**: The receiving device tells the sender if the previous frame
    has been received successfully.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACK/NACK位**：接收设备会通知发送方之前的数据帧是否已成功接收。'
- en: '**Data frame**: A single message can contain *1* to *n* DataFrames of 8 bits
    each.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据帧**：一个消息可以包含1到n个8位的数据帧。'
- en: '**Stop condition**: The stop condition signals that the message has been completely
    sent.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止条件**：停止条件表示消息已完全发送。'
- en: 'The following image visualizes a message with 16 bits of data:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像可视化了一个包含16位数据的消息：
- en: '![Figure 6.6 – I2C message'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – I2C消息'
- en: '](img/Figure_6.6_B16555.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.6_B16555.jpg)'
- en: Figure 6.6 – I2C message
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – I2C消息
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you do not know the address of the device you want to use, you can make use
    of the ACK bit by iterating all possible addresses and checking if the device
    sends an ACK on an address. If that is the case, you've found the address.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道要使用的设备的地址，您可以通过迭代所有可能的地址并检查设备是否在地址上发送ACK来使用ACK位。如果是这样，您就找到了地址。
- en: Now that we have a brief understanding of what I2C is and how it works, we can
    write our first program using I2C to control the display.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对I2C是什么以及它是如何工作的有了初步的了解，我们可以编写第一个使用I2C控制显示的程序。
- en: Writing the code
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写代码
- en: 'We will start by creating a new folder named `Chapter06` inside our project.
    Inside the `Chapter06` folder, create a new folder named `hd44780-text-display`
    and create a new `main.go` file with an empty `main` function inside it. The project
    structure should now look as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的项目中创建一个名为`Chapter06`的新文件夹。在`Chapter06`文件夹内，创建一个名为`hd44780-text-display`的新文件夹，并在其中创建一个包含空`main`函数的新`main.go`文件。现在，项目结构应如下所示：
- en: '![Figure 6.7 – Project structure'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – 项目结构'
- en: '](img/Figure_6.7_B16555.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_6.7_B16555.jpg)'
- en: Figure 6.7 – Project structure
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 项目结构
- en: 'Now, follow these steps to display the first piece of text:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤显示第一段文本：
- en: 'Import the driver:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入驱动程序：
- en: '[PRE0]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `main` function, configure the I2C interface and set the clock''s
    `frequency` to `400KHz`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，配置I2C接口并将时钟的`频率`设置为`400KHz`：
- en: '[PRE1]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a new instance of `hd44780i2c` and pass the `I2C` interface, as well
    as `address`, as a parameter. Most LCM1602 IICs should listen on the `0x27` address,
    but some modules listen on `0x3F`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `hd44780i2c` 实例，并将 `I2C` 接口以及 `address` 作为参数传递。大多数 LCM1602 IIC 应该监听在
    `0x27` 地址，但有些模块监听在 `0x3F`：
- en: '[PRE2]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Configure the display by setting columns `(Width)`and rows (`Height`). We need
    to do this as this driver also supports 20x4 and other types of displays:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置列（宽度）和行（高度）来配置显示屏。我们需要这样做，因为这个驱动器也支持 20x4 和其他类型的显示屏：
- en: '[PRE3]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Print the text. `\n` is being interpreted by the driver, and all characters
    followed by `\n` are being written to the next row. We can do this with the following
    code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印文本。`\n` 被驱动器解释，所有跟在 `\n` 后面的字符都被写入下一行。我们可以用以下代码做到这一点：
- en: '[PRE4]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s test the code by flashing it. Use the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过闪烁代码来测试它。使用以下命令：
- en: '[PRE5]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should now see the text being printed on the screen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到屏幕上打印的文本。
- en: 'Let''s look at what happens when we try to print more than 16x2 characters
    onto the screen. To do so, just add the following snippet to the end of our `main`
    function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们尝试在屏幕上打印超过 16x2 个字符时会发生什么。要做到这一点，只需将以下片段添加到我们的 `main` 函数的末尾：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, flash the program again and look at the result. What we can observe is
    that after reaching the 32nd character, the cursor jumps to position x = 0 and
    y = 0 again and continues to print from there. However, we want to print more
    than 32 characters on the display, and we want to be able to read all of them.
    To do so, we must create a small animation. Perform the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次闪烁程序并查看结果。我们可以观察到，在达到第32个字符后，光标跳回到位置 x = 0 和 y = 0，并从这里继续打印。然而，我们希望在显示屏上打印超过32个字符，并且我们希望能够阅读所有这些字符。为了做到这一点，我们必须创建一个小动画。执行以下步骤：
- en: 'At the end of the `main` function, sleep for `5` seconds and call the `animation`
    function and pass `lcd` as a parameter, as shown in the following code snippet:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数的末尾，暂停 `5` 秒并调用 `animation` 函数，并将 `lcd` 作为参数传递，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We need to define the `animation` function, which takes `lcd` as a parameter:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要定义一个名为 `animation` 的函数，它接受 `lcd` 作为参数：
- en: '[PRE8]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to define the text we want to print:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要定义我们想要打印的文本：
- en: '[PRE9]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We must clear the display to remove everything we printed previously. This
    also resets the cursor to the first position (0,0):'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须清除显示屏以移除之前打印的所有内容。这也将光标重置到第一个位置（0,0）：
- en: '[PRE10]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s print a single character. We need to do some type conversions here
    as the display driver only accepts `[]byte` as a parameter. For this, refer to
    the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打印一个单个字符。在这里我们需要进行一些类型转换，因为显示驱动器只接受 `[]byte` 作为参数。为此，请参考以下代码：
- en: '[PRE11]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the message has been completely written onto the display, we sleep for
    `2` seconds and clear the display again. This enables a clean start for the next
    iteration:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当消息完全写入显示屏后，我们暂停 `2` 秒并再次清除显示屏。这为下一次迭代提供了一个干净的开始：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, flash the updated program again. The characters should now nicely appear
    one after the other.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次闪烁更新后的程序。字符应该会依次出现。
- en: Now that we understand how to use the display driver to print hardcoded texts
    and how to create a simple animation, let's display some dynamically received
    texts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用显示驱动器打印硬编码的文本以及如何创建简单的动画，让我们显示一些动态接收到的文本。
- en: Displaying user input on the display
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在显示屏上显示用户输入
- en: In this section, we are going to print the input of a user onto the display.
    The input is being sent from the computer to the microcontroller using **serial
    (UART)**, which will then print it onto the display.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将打印用户的输入到显示屏上。输入是通过计算机发送到微控制器的 **串行（UART**），然后将其打印到显示屏上。
- en: In [*Chapter 2*](B16555_02_Final_VK_ePub.xhtml#_idTextAnchor041), *Building
    a Traffic Lights Control System*, we learned how to use UART to send messages
    to the computer, and observed them using PuTTY. Now, we are going to use this
    interface bidirectionally. For this project, we are using the same hardware setup
    that we used in the previous section, which means we can directly dive into the
    code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第2章*](B16555_02_Final_VK_ePub.xhtml#_idTextAnchor041) 中，*构建交通灯控制系统*，我们学习了如何使用
    UART 向计算机发送消息，并使用 PuTTY 观察它们。现在，我们将使用这个接口进行双向通信。对于这个项目，我们使用与上一节相同的硬件设置，这意味着我们可以直接进入代码。
- en: 'Start by creating a new folder named `hd44780-user-input` inside the `Chapter06`
    folder. Then, inside this newly created folder, add a new `main.go` file with
    an empty `main()` function inside it. The project''s structure should now look
    similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `Chapter06` 文件夹内创建一个名为 `hd44780-user-input` 的新文件夹。然后，在这个新创建的文件夹内，添加一个包含空
    `main()` 函数的 `main.go` 文件。现在，项目的结构应该类似于以下内容：
- en: '![Figure 6.8 – Project structure'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – 项目结构'
- en: '](img/Figure_6.8_B16555.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.8_B16555.jpg)'
- en: Figure 6.8 – Project structure
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 项目结构
- en: 'Follow these steps to implement the program:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现程序：
- en: 'Save the hex value for `carriageReturn` as a constant. Later, we will be checking
    if a received byte equals this `carriageReturn` value:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `carriageReturn` 的十六进制值保存为一个常量。稍后，我们将检查接收到的字节是否等于这个 `carriageReturn` 值：
- en: '[PRE13]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save the `uart` interface in a variable so that we don''t have to type `machine.UART0`
    every time:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `uart` 接口保存在一个变量中，这样我们就不必每次都输入 `machine.UART0`：
- en: '[PRE14]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the `main` function, start by initializing the display driver:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，首先初始化显示屏驱动程序：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let the user know that we can type something and then print it on the display:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让用户知道我们可以输入一些内容，然后将其打印到显示屏上：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We want to clear the display as soon as the first input has been received.
    That is why we save this state:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在接收到第一个输入后立即清除显示屏。这就是为什么我们保存这个状态：
- en: '[PRE17]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If no data resides in the buffer, we don''t want to do anything. Incoming data
    isinternally buffered by TinyGo using a ring buffer:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果缓冲区中没有数据，我们不想做任何事情。TinyGo 使用环形缓冲区内部缓冲传入的数据：
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we encounter the very first input, we must clear the display and save the
    state that we had input previously:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到第一个输入，我们必须清除显示屏并保存我们之前输入的状态：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we read one byte from the buffer and log any possible errors:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从缓冲区读取一个字节，并记录任何可能的错误：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If a `carriageReturn` is being received, such as because the user pressed the
    *Enter* key, we also want to print in a new line. We print that character on the
    display, as well as to `uart`, so that the output in PuTTY and the output on the
    display behave similarly:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接收到 `carriageReturn`，例如用户按下了 *Enter* 键，我们还想在新的一行打印。我们将该字符打印到显示屏以及 `uart`，以便
    PuTTY 的输出和显示屏上的输出行为相似：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last step is to simply print the data onto both outputs:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将数据简单地打印到两个输出上：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can receive data from a computer that is connected to the microcontroller
    and print it onto the display. Try it out by flashing the program to the microcontroller
    by using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从连接到微控制器的计算机接收数据并将其打印到显示屏上。通过以下命令将程序烧录到微控制器来尝试它：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, start PuTTy, connect to the `microcontroller` profile, and start typing
    to check if the program runs correctly. If everything works correctly, PuTTY should
    also print what you have written, similar to what''s shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动 PuTTy，连接到 `microcontroller` 配置文件，并开始输入以检查程序是否运行正确。如果一切正常，PuTTY 应该也会打印出你所写的内容，类似于以下截图所示：
- en: '![Figure 6.9 – PuTTY output'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9 – PuTTY 输出'
- en: '](img/Figure_6.9_B16555.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.9_B16555.jpg)'
- en: Figure 6.9 – PuTTY output
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – PuTTY 输出
- en: The UART interface is a serial interface, which means it can be also used to
    send and receive data between two microcontrollers. On the Arduino Nano 33 IoT,
    the **transmit** (**TX**) pin is being used to send the data and the **receive**
    (**RX**) pin is being used to receive data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: UART 接口是一个串行接口，这意味着它也可以用于在两个微控制器之间发送和接收数据。在 Arduino Nano 33 IoT 上，**发送**（**TX**）引脚用于发送数据，而**接收**（**RX**）引脚用于接收数据。
- en: In this section, we learned how to read and interpret single bytes from the
    UART interface, as well as how to manually send data back to the UART interface,
    without using the `print()` or `println()` functions. We'll use this knowledge
    in the next section to learn how to interpret longer strings of data.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何从 UART 接口读取和解释单个字节，以及如何在不使用 `print()` 或 `println()` 函数的情况下手动将数据发送回
    UART 接口。我们将在下一节中使用这些知识来学习如何解释更长的数据字符串。
- en: Building a CLI
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个 CLI
- en: In this section, we are going to parse the input from a user and compare the
    input with predefined commands. These commands will then be executed by the microcontroller.
    For this project, we are going to use the same hardware setup that we used in
    the previous one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解析用户的输入，并将输入与预定义的命令进行比较。然后，这些命令将由微控制器执行。对于这个项目，我们将使用与上一个项目相同的硬件设置。
- en: 'We will start by creating a new folder named `hd44780-cli` inside the `Chapter06`
    folder. Then, we must create a `main.go` file with an empty `main` function inside
    it. The project''s structure should now look similar to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 `Chapter06` 文件夹内创建一个名为 `hd44780-cli` 的新文件夹。然后，我们必须创建一个包含空 `main` 函数的
    `main.go` 文件。现在，项目的结构应该类似于以下内容：
- en: '![Figure 6.10 – Project structure'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – 项目结构'
- en: '](img/Figure_6.10_B16555.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.10_B16555.jpg)'
- en: Figure 6.10 – Project structure
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 项目结构
- en: 'Now that the project structure has been set up, we can implement the logic.
    To do so, follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目结构已经设置好，我们可以实现逻辑。要做到这一点，请按照以下步骤操作：
- en: 'Above the `main` function, start by defining some constants. `commandConstant`
    represents the command that needs to be sent to the microcontroller. We will use
    these constants ahead in this code and compare them with the user input to determine
    whether a CLI command has been entered:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数上方，首先定义一些常量。`commandConstant` 代表需要发送到微控制器的命令。我们将在代码中使用这些常量，并将它们与用户输入进行比较，以确定是否输入了
    CLI 命令：
- en: '[PRE24]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Save the UART interface in a variable. We could also always write `machine.UART0`
    instead, but by doing it this way, we improve the readability:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 UART 接口保存在一个变量中。我们也可以始终使用 `machine.UART0` 来写，但通过这种方式，我们可以提高可读性：
- en: '[PRE25]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Inside the `main` function, we initialize the display, as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，我们初始化显示屏，如下所示：
- en: '[PRE26]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s call the `homeScreen` function (we are going to explain what this
    function does when we implement it later):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `homeScreen` 函数（我们将在实现它之后解释这个函数的功能）：
- en: '[PRE27]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, define a `commandBuffer`. That is a simple string where we store the
    parts of a command:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个 `commandBuffer`。这是一个简单的字符串，我们用它来存储命令的部分：
- en: '[PRE28]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`commandIndex` is being used to count the characters inside `commandBuffer`.
    If the index is greater than the length of the longest command, then we know that
    we can reset the buffer:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`commandIndex` 正在被用来计算 `commandBuffer` 内部的字符数。如果索引大于最长命令的长度，那么我们知道我们可以重置缓冲区：'
- en: '[PRE29]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will be using the `commandStart` boolean as a signal, so we need to append
    any subsequent characters to `commandBuffer`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `commandStart` 布尔值作为信号，因此我们需要将后续的任何字符追加到 `commandBuffer` 中：
- en: '[PRE30]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Just like in the previous project, we are going to use the `hadInput` flag
    to clear the screen when the first input is received:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在先前的项目中一样，我们将使用 `hadInput` 标志在接收到第一个输入时清除屏幕：
- en: '[PRE31]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We don''t need to do anything if there are no characters in the internal receive
    buffer:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内部接收缓冲区中没有字符，我们不需要做任何事情：
- en: '[PRE32]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Upon receiving the first input, clear the display. We will explain the `clearDisplay`
    function when we implement it ahead, after a few steps:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到第一个输入后，清除显示屏。我们将在实现它之前，在接下来的几步中解释 `clearDisplay` 函数：
- en: '[PRE33]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we read a byte from the buffer, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从缓冲区中读取一个字节，如下所示：
- en: '[PRE34]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Check if we received a **pound sign (#)**. This is the indicator that a command
    is going to follow:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否收到了 **井号 (#)**。这是表示将跟随一个命令的指示器：
- en: '[PRE35]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we receive the start of the command, we append all subsequent characters
    to `commandBuffer`. This is done as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们收到命令的开始时，我们将所有后续字符追加到 `commandBuffer` 中。这是按照以下方式完成的：
- en: '[PRE36]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To check if we may have a complete command inside `commandBuffer`, we must
    switch over our `commandBuffer`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查 `commandBuffer` 中是否可能有一个完整的命令，我们必须切换我们的 `commandBuffer`：
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If the content of `commandBuffer` equals `homeCommand`, we execute the `homeScreen`
    function and reset the command. We must also write the input data back inside
    the UART interface:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `commandBuffer` 的内容等于 `homeCommand`，我们执行 `homeScreen` 函数并重置命令。我们还必须在 UART
    接口中写回输入数据：
- en: '[PRE38]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If the content of `commandBuffer` equals `clearCommand`, we must execute the
    `clearDisplay` function and reset the command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `commandBuffer` 的内容等于 `clearCommand`，我们必须执行 `clearDisplay` 函数并重置命令：
- en: '[PRE39]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If `commandIndex` is greater than the length of our longest command, we must
    reset the command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `commandIndex` 大于我们最长命令的长度，我们必须重置命令：
- en: '[PRE40]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we receive a `carriageReturn`, we must print a new line:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们收到一个 `carriageReturn`，我们必须打印一个新行：
- en: '[PRE41]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we print the received data, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印接收到的数据，如下所示：
- en: '[PRE42]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, define the `homeScreen` function, which is called when the input matches
    the `homeScreen` command. We must clear the display and print the first input
    again:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 `homeScreen` 函数，当输入匹配 `homeScreen` 命令时会被调用。我们必须清除显示屏并再次打印第一个输入：
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, define the `clearDisplay` function, which is called when the input matches
    the `clearDisplay` command. We just make use of the `ClearDisplay` function of
    the display here:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 `clearDisplay` 函数，当输入匹配 `clearDisplay` 命令时调用该函数。我们在这里只是使用了显示器的 `ClearDisplay`
    函数：
- en: '[PRE44]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, flash the program using the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令烧录程序：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now, let's try out our program.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试我们的程序。
- en: 'Start putty and select the microcontroller profile. Type something and use
    the `#home` and `#clear` commands that we defined in the code. PuTTY''s output
    should now look similar to the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 PuTTY 并选择微控制器配置文件。输入一些内容并使用我们在代码中定义的 `#home` 和 `#clear` 命令。现在 PuTTY 的输出应该类似于以下内容：
- en: '![Figure 6.11 – CLI output in PuTTY'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – PuTTY 中的 CLI 输出'
- en: '](img/Figure_6.11_B16555.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.11_B16555.jpg)'
- en: Figure 6.11 – CLI output in PuTTY
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – PuTTY 中的 CLI 输出
- en: With that, we have verified that the program works as intended. Such a system
    could be used to control a microcontroller using another microcontroller, not
    just to display something – it could also be used to request sensor readings or
    trigger other things.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经验证了程序按预期工作。这样的系统可以用来用另一个微控制器控制微控制器，而不仅仅是显示某些内容——它还可以用来请求传感器读数或触发其他事情。
- en: In this section, we learned how to interpret more than a single character of
    input data at a time, as well as how to set up a simple CLI in order to execute
    commands that are being sent through UART. In the next section, we are going to
    gain a deeper understanding of SPI, since we will be using an SPI-driven display
    in the final project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何一次解释多个输入字符，以及如何设置简单的 CLI 以执行通过 UART 发送的命令。在下一节中，我们将更深入地了解 SPI，因为我们将在最终项目中使用
    SPI 驱动的显示屏。
- en: Understanding SPI
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 SPI
- en: SPI is a bus system that has a controller and one or many devices. The controller
    selects a device that should send data to the controller, or that is going to
    receive data from the controller.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 是一个具有控制器和一个或多个设备的总线系统。控制器选择一个设备，该设备应向控制器发送数据，或者将从控制器接收数据。
- en: Devices on an SPI bus can also be daisy chained together. A **daisy chain**
    is a wiring scheme in which you put multiple devices together in a row.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SPI 总线上的设备也可以级联在一起。**级联**是一种将多个设备排成一行的布线方案。
- en: 'SPI communication between two devices uses the following four pins:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 两个设备之间的 SPI 通信使用以下四个引脚：
- en: '**CS**: **ChipSelect** selects which device on the bus should receive or send
    data.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CS**: **芯片选择**选择总线上应接收或发送数据的设备。'
- en: '**CLK**: **Clock** sets the frequency of the transfer (DO) and receive (DI)
    wires.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CLK**: **时钟**设置传输（DO）和接收（DI）线的频率。'
- en: '**DO**: **DataOut** or **DigitalOut** transmits data to the receiving device.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DO**: **数据输出**或**数字输出**将数据传输到接收设备。'
- en: '**DI**: **DataIn** or **DigitalIn** receives data from the controller.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**DI**: **数据输入**或**数字输入**从控制器接收数据。'
- en: 'The following diagram shows the one-to-one connection of an SPI controller
    and an SPI device:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 SPI 控制器和 SPI 设备的一对一连接：
- en: '![Figure 6.12 – SPI communication'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – SPI 通信'
- en: '](img/Figure_6.12_B16555.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.12_B16555.jpg)'
- en: Figure 6.12 – SPI communication
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – SPI 通信
- en: 'The following diagram shows the SPI connection of one controller and two devices.
    Here, we are using two CS pins to signal the receiving device. This is the device
    the controller is talking to:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了控制器和两个设备之间的 SPI 连接。在这里，我们使用两个 CS 引脚来向接收设备发送信号。这是控制器正在与之通信的设备：
- en: '![Figure 6.13 – SPI communication between a controller and two devices'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – 控制器和两个设备之间的 SPI 通信'
- en: '](img/Figure_6.13_B16555.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.13_B16555.jpg)'
- en: Figure 6.13 – SPI communication between a controller and two devices
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 控制器和两个设备之间的 SPI 通信
- en: 'The following diagram shows how devices can be daisy chained together. The
    *DO* pin of the first device is connected to the *DI* pin of the next device,
    while they share the *CLK* and *CS* wires:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了设备如何级联在一起。第一个设备的 *DO* 引脚连接到下一个设备的 *DI* 引脚，同时它们共享 *CLK* 和 *CS* 线：
- en: '![Figure 6.14 – SPI communication with daisy chained devices'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14 – 与级联设备的 SPI 通信'
- en: '](img/Figure_6.14_B16555.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.14_B16555.jpg)'
- en: Figure 6.14 – SPI communication with daisy chained devices
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 与级联设备的 SPI 通信
- en: Now that we have a better understanding of SPI, let's build a circuit using
    the ST7735 display.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 SPI 有更好的理解，让我们使用 ST7735 显示屏构建一个电路。
- en: Displaying a simple game
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示简单游戏
- en: In this section, we are going to learn how to use another display type using
    the SPI interface. We need a new type of display since we want to display more
    than plain text. We will also discover two more TinyGo repositories that provide
    handy functions for when we're working with displays. The display we are going
    to use in this section is a 1.8" TFT ST7735 display with a resolution of 160x128
    pixels. So, let's have a brief look at the technical specifications of the display.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 SPI 接口来使用另一种显示类型。由于我们想要显示不仅仅是纯文本，我们需要一种新的显示类型。我们还将发现两个额外的 TinyGo
    仓库，它们提供了在处理显示时方便的功能。在本节中我们将使用的显示设备是一款 1.8 英寸的 TFT ST7735 显示器，分辨率为 160x128 像素。因此，让我们简要了解一下该显示器的技术规格。
- en: The ST7735 display provides an SD card slot, which is optional. The display
    has a color depth of 262K colors on a TFT-LCD module. The SPI interface is being
    used with the display. To draw something on the display, we need eight pins. We
    have already used SPI, but we did not have a deeper look at it, since the devices
    can be arranged on an SPI bus in different ways. So, let's gain a better understanding
    of how SPI works before we use the display in an example project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ST7735 显示器提供了一个可选的 SD 卡槽。该显示器在 TFT-LCD 模块上具有 262K 色彩深度。正在使用 SPI 接口。要在显示器上绘制内容，我们需要八个引脚。我们已经使用了
    SPI，但因为我们没有深入探讨它，因为设备可以以不同的方式排列在 SPI 总线上。所以，在我们使用示例项目中的显示器之前，让我们更好地了解 SPI 的工作原理。
- en: Building the circuit
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'As in the previous projects, we are going to use an external power supply.
    We also need a ST7735 display, the Arduino Nano 33 IoT, and some jumper wires.
    To set everything up correctly, follow these steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，我们将使用外部电源。我们还需要一个 ST7735 显示器、Arduino Nano 33 IoT 和一些跳线。为了正确设置一切，请按照以下步骤操作：
- en: Connect the *GND* lane from the power bus to pin *J50 (GND)* on the breadboard.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源总线上的 *GND* 通道连接到面包板上的 *J50 (GND)* 引脚。
- en: Connect pin *E31 (LED)* on the breadboard to pin *A53 (D2)* on the breadboard.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板上的 *E31 (LED)* 引脚连接到面包板上的 *A53 (D2)* 引脚。
- en: Connect pin *E32 (SCK)* on the breadboard to pin *J63 (D13)* on the breadboard.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板上的 *E32 (SCK)* 引脚连接到面包板上的 *J63 (D13)* 引脚。
- en: Connect pin *E33 (SDA)* on the breadboard to pin *A62 (D11)* on the breadboard.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板上的 *E33 (SDA)* 引脚连接到面包板上的 *A62 (D11)* 引脚。
- en: Connect pin *E34 (AO)* on the breadboard to pin *A56 (D5)* on the breadboard.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板上的 *E34 (AO)* 引脚连接到面包板上的 *A56 (D5)* 引脚。
- en: Connect pin *E35 (RESET)* on the breadboard to pin *A57 (D6)* on the breadboard.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板上的 *E35 (RESET)* 引脚连接到面包板上的 *A57 (D6)* 引脚。
- en: Connect pin *E36 (CS)* on the breadboard to pin *A58 (D7)* on the breadboard.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将面包板上的 *E36 (CS)* 引脚连接到面包板上的 *A58 (D7)* 引脚。
- en: Connect the *GND* lane from the power bus to pin *E37 (GND)* on the breadboard.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源总线上的 *GND* 通道连接到面包板上的 *E37 (GND)* 引脚。
- en: Connect the *VCC* lane from the power bus to pin *E38 (VCC)* on the breadboard.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源总线上的 *VCC* 通道连接到面包板上的 *E38 (VCC)* 引脚。
- en: Place the ST7735 display so that the *LED* pin sits in *A31* and the *VCC* pin
    sits in *A37*.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ST7735 显示器放置，使 *LED* 引脚位于 *A31*，*VCC* 引脚位于 *A37*。
- en: 'This is everything we need to connect to the display. The setup should now
    look as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要连接到显示器的所有内容。现在设置应该看起来如下：
- en: '![Figure 6.15 – ST7735 circuit'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – ST7735 电路'
- en: '](img/Figure_6.15_B16555.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.15_B16555.jpg)'
- en: Figure 6.15 – ST7735 circuit
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – ST7735 电路
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The 1.8" TFT display Fritzing part is made by vanepp: [https://forum.fritzing.org/u/vanepp](https://forum.fritzing.org/u/vanepp).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 1.8 英寸 TFT 显示器 Fritzing 部分由 vanepp 制作：[https://forum.fritzing.org/u/vanepp](https://forum.fritzing.org/u/vanepp)。
- en: Now that we've set up the hardware, let's implement some logic.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了硬件，让我们实现一些逻辑。
- en: Using an ST7735 display
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ST7735 显示器
- en: TinyGo provides a driver for ST7735 displays. This means we can use the existing
    driver. Also, TinyGo provides two additional packages named `TinyFont` and `TinyDraw`,
    both of which we are going to use. First, let's check out the `TinyDraw` package.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo 为 ST7735 显示器提供了驱动程序。这意味着我们可以使用现有的驱动程序。此外，TinyGo 还提供了两个额外的包，名为 `TinyFont`
    和 `TinyDraw`，我们都会使用。首先，让我们看看 `TinyDraw` 包。
- en: '`TinyDraw` is a repository inside the TinyGo organization on GitHub. You can
    find it at [https://github.com/tinygo-org/tinydraw](https://github.com/tinygo-org/tinydraw).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`TinyDraw` 是位于 GitHub 上 TinyGo 组织内部的一个仓库。您可以在 [https://github.com/tinygo-org/tinydraw](https://github.com/tinygo-org/tinydraw)
    找到它。'
- en: '`TinyDraw` is still in an early state, which means that it has not been optimized
    for performance or memory usage. However, it provides useful functionality, such
    as for drawing rectangles, circles, filled rectangles and filled circles, and
    more. It works with most interface drivers since the APIs of display drivers are
    nearly (or exactly) the same. Now, let''s have a look at the `TinyFont` package
    before we see it in action.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`TinyDraw`仍然处于早期阶段，这意味着它尚未针对性能或内存使用进行优化。然而，它提供了有用的功能，例如绘制矩形、圆形、填充矩形和填充圆形等。由于显示驱动程序的API几乎（或完全）相同，它与大多数接口驱动程序兼容。现在，在我们看到它的实际应用之前，让我们先看看`TinyFont`包。'
- en: Just like `TinyDraw`, `TinyFont` is a repository inside the TinyGo organization
    on GitHub. You can find it at [https://github.com/tinygo-org/tinyfont](https://github.com/tinygo-org/tinyfont).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`TinyDraw`一样，`TinyFont`是GitHub上TinyGo组织内部的一个仓库。您可以在[https://github.com/tinygo-org/tinyfont](https://github.com/tinygo-org/tinyfont)找到它。
- en: '`TinyFont` provides an API to let you draw text onto displays using fonts that
    come with the `TinyFont` package. It also allows you to create your own custom
    font. `TinyFont` also makes use of the fact that most TinyGo display drivers share
    the same interface.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`TinyFont`提供了一个API，允许您使用`TinyFont`包中包含的字体在显示上绘制文本。它还允许您创建自己的自定义字体。`TinyFont`还利用了大多数TinyGo显示驱动程序共享相同接口的事实。'
- en: 'Now, let''s set up a project that uses the ST7735, TinyDraw, and TinyFont.
    To do so, create a new folder named `st7735` inside the `Chapter06` folder and
    create a new `main.go` file with an empty `main()` function inside it. The project''s
    structure should now look similar to the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一个使用ST7735、TinyDraw和TinyFont的项目。为此，在`Chapter06`文件夹内创建一个名为`st7735`的新文件夹，并在其中创建一个包含空`main()`函数的新`main.go`文件。现在，项目的结构应该类似于以下内容：
- en: '![Figure 6.16 – Project structure'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.16 – Project structure'
- en: '](img/Figure_6.16_B16555.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.16 – Project structure'
- en: Figure 6.16 – Project structure
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 项目结构
- en: 'Now, let''s dive into the code. We will need to import the following packages
    for this project:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入代码。我们需要导入以下包来完成此项目：
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To write our first test program for this display, follow these steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这个显示编写第一个测试程序，请按照以下步骤操作：
- en: 'Above the `main` function, define a set of colors that we are going to use
    later in the program:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数上方，定义我们将要在程序中使用的颜色集：
- en: '[PRE47]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Configure the `SPI0` interface with a frequency of 12 MHz. We do not need to
    pass the pins for SCK and DO as the `Configure` function will use the default
    SPI pins for this board when no pins are passed:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`SPI0`接口，频率为12 MHz。我们不需要传递SCK和DO引脚，因为当没有传递引脚时，`Configure`函数将使用该板默认的SPI引脚：
- en: '[PRE48]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Set the required pins for the display:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置显示所需的引脚：
- en: '[PRE49]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Get a new instance of the `st7735` display:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`st7735`显示的新实例：
- en: '[PRE50]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Call the `Configure` function. This function transmits the bootup sequence
    to the display. After this call, the display is ready to use:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Configure`函数。此函数将启动序列传输到显示。在此调用之后，显示即可使用：
- en: '[PRE51]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Get the `width` and `height` attributes from the display:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从显示中获取`width`和`height`属性：
- en: '[PRE52]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Draw four rectangles. Each of them should take up a quarter of the screen and
    be a different color. The function takes a position on the x-axis, a position
    on the y-axis, the width and height of the rectangle to draw, as well as the color
    of the rectangle. We will use this as a test for our display. This is a good test
    for the display:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制四个矩形。每个矩形应占据屏幕的四分之一，并具有不同的颜色。该函数接受x轴上的位置、y轴上的位置、要绘制的矩形的宽度和高度，以及矩形的颜色。我们将使用此作为显示的测试。这是一个很好的显示测试：
- en: '[PRE53]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before we move on and draw some more advanced graphics, let''s test the program
    by flashing it using the following command:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续绘制更高级的图形之前，让我们通过以下命令闪烁程序来测试程序：
- en: '[PRE54]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once the program has been successfully flashed onto the microcontroller, you
    should see four rectangles. This looks similar to the following:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦程序成功烧录到微控制器上，你应该会看到四个矩形。这看起来类似于以下内容：
- en: '![Figure 6.17 – ST7735 displaying four rectangles'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.17 – ST7735显示四个矩形'
- en: '](img/Figure_6.17_B16555.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.17 – ST7735显示四个矩形'
- en: Figure 6.17 – ST7735 displaying four rectangles
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – ST7735显示四个矩形
- en: 'Now, let''s draw some more complicated forms using `TinyDraw` and some text
    using `TinyFont`. To do so, follow these steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`TinyDraw`绘制一些更复杂的形状，并使用`TinyFont`绘制一些文本。为此，请按照以下步骤操作：
- en: 'At the end of the `main` function, add a sleep for 3 seconds so that we have
    a chance to actually see the display test:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数的末尾，添加一个3秒的睡眠，这样我们就有机会真正看到显示测试：
- en: '[PRE55]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Initialize a counter that will be used to display a count of how many times
    we have drawn an animation:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个计数器，它将用于显示我们绘制动画的次数：
- en: '[PRE56]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Fill the screen with `black` to clean the display:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`black`填充屏幕以清除显示：
- en: '[PRE57]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Draw a white rectangle at the lower end of the screen. It should have a height
    of `32` pixels, which should leave us with 128x128 pixels:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕的底部绘制一个白色矩形。它应该有`32`像素的高度，这将给我们留下128x128像素：
- en: '[PRE58]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Since we have assembled our display upside down, we are going to write text
    rotated:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经将显示屏倒置安装，我们将写入旋转的文本：
- en: '[PRE59]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At the center of the black square, draw three circles of different sizes and
    colors on top of each other:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在黑色方形的中心，绘制三个大小和颜色不同的同心圆：
- en: '[PRE60]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, draw the `TinyFont` text in `green` beneath the circles:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在圆圈下方用绿色绘制`TinyFont`文本：
- en: '[PRE61]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Draw the count of how many times the animation will run on the white rectangle:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在白色矩形上绘制动画将运行多少次的计数：
- en: '[PRE62]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We need to sleep for a moment because otherwise, we won''t be able to see the
    result. This is because it will be overridden in the next iteration:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要稍作等待，否则我们无法看到结果。这是因为它将在下一次迭代中被覆盖：
- en: '[PRE63]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, flash the program again. After the test screen, you should see a result
    similar to the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次闪烁程序。在测试屏幕后，你应该看到以下类似的结果：
- en: '![Figure 6.18 – Result of the test program'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18 – 测试程序的输出结果'
- en: '](img/Figure_6.18_B16555.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.18_B16555.jpg)'
- en: Figure 6.18 – Result of the test program
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 测试程序的输出结果
- en: In this section, we learned how to draw basic shapes and write text on our display.
    The next logical step is to write a game that runs on a microcontroller.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在显示屏上绘制基本形状和写入文本。下一步合乎逻辑的是编写一个在微控制器上运行的程序。
- en: Developing a game
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发一个游戏
- en: 'In this section, we are going to develop a very simple game that consists of
    an enemy, represented by a red block, that tries to reach the end of the screen.
    A green line will represent our home zone, which the red block should not cross.
    We''ll also have a green block that represents the player, as well as a smaller
    green block that represents a bullet that we can shoot to stop the red block from
    invading our home zone. We will be adding a button that will act as a trigger
    and shoot the small green blocks. So, the logical first step is to add the button
    to our breadboard. To do so, follow these steps:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个非常简单的游戏，该游戏由一个代表敌人的红色方块组成，它试图到达屏幕的末端。一条绿色线将代表我们的家园区域，红色方块不应该穿越。我们还将有一个代表玩家的绿色方块，以及一个代表我们可以射击以阻止红色方块入侵我们家园区域的子弹的较小的绿色方块。我们将添加一个按钮，它将充当触发器并射击小绿色方块。因此，合乎逻辑的第一步是将按钮添加到我们的面包板上。为此，请按照以下步骤操作：
- en: Place the button on the breadboard so that one pin sits in *E23* and the other
    pins sit in *E25* on one side and *F25* and *F23* on the other side.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮放置在面包板上，使一个引脚位于*E23*，其他引脚位于一边的*E25*和另一边的*F25*和*F23*。
- en: Connect the *+3V3* output from the Arduino to *J23* on the breadboard.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Arduino的*+3V3*输出连接到面包板上的*J23*。
- en: Use a **10K Ohm resistor** to connect the *GND* lane from the power bus to *J25*.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个**10K欧姆电阻**将电源总线上的*GND*线路连接到*J25*。
- en: Connect *D25* to *A60 (D9)* on the breadboard.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*D25*连接到面包板上的*A60 (D9)*。
- en: 'This was everything we needed to add to the circuit. It should now look as
    follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要添加到电路中的所有内容。现在它应该看起来如下所示：
- en: '![Figure 6.19 – The final circuit with the button'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19 – 带按钮的最终电路'
- en: '](img/Figure_6.19_B16555.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.19_B16555.jpg)'
- en: Figure 6.19 – The final circuit with the button
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 带按钮的最终电路
- en: 'Now, let''s create a new folder for the last project in this chapter. Name
    the folder `tinygame` and put it inside the `Chapter06` folder. Then, create a
    new `main.go` file with an empty `main()` function inside it. The project''s structure
    should now look as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为本章的最后一个项目创建一个新的文件夹。将文件夹命名为`tinygame`，并将其放入`Chapter06`文件夹中。然后，创建一个包含空`main()`函数的新`main.go`文件。现在，项目的结构应该如下所示：
- en: '![Figure 6.20 – Project structure'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.20 – 项目结构'
- en: '](img/Figure_6.20_B16555.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.20_B16555.jpg)'
- en: Figure 6.20 – Project structure
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 项目结构
- en: 'To implement the logic, follow these steps:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现逻辑，请按照以下步骤操作：
- en: 'Add a `bool` that holds the `buttonPressed` state. We will define this globally,
    so we do not need to use channels or something else to pass the state between
    the goroutines that we are going to use. This is just an easy and convenient way
    to do this:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`bool`变量来保存`buttonPressed`状态。我们将全局定义它，因此我们不需要使用通道或其他方式在将要使用的goroutines之间传递状态。这只是一个简单方便的方法：
- en: '[PRE64]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Define `enemySize`, `bulletSize`, and the `width` and `height` properties of
    the game field in pixels:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`enemySize`、`bulletSize`以及游戏区域的像素宽度和高度属性：
- en: '[PRE65]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add two variables to store our `currentScore` and `highscore`, respectively:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个变量来存储我们的`currentScore`和`highscore`：
- en: '[PRE66]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Define a set of colors that we will use later:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们将要使用的颜色集：
- en: '[PRE67]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we need to move inside the `main` function. Here, assign `buttonPin` and
    configure it as input:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将代码移动到`main`函数内部。在这里，分配`buttonPin`并将其配置为输入：
- en: '[PRE68]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Update `highscore` since we are in the startup phase. Here, `highscore` is
    `0`:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动阶段更新`highscore`。在这里，`highscore`是`0`：
- en: '[PRE69]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Initialize the display, as follows:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化显示，如下所示：
- en: '[PRE70]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the `checkButton` function inside a new goroutine so that it is non-blocking.
    This enables us to update the game loop in the `main` goroutine:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的goroutine中运行`checkButton`函数，使其非阻塞。这使我们能够在`main` goroutine中更新游戏循环：
- en: '[PRE71]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Loop forever and fill the screen with black to erase everything from the screen
    after each round of the game:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限循环并在每轮游戏结束后用黑色填充屏幕以擦除屏幕上的所有内容：
- en: '[PRE72]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Loop forever and check the button''s state. If the button has been pressed,
    we update the `buttonPressed` state. After each check, we sleep for `20` milliseconds,
    since we need a blocking call so that the scheduler can work on other goroutines
    again:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限循环并检查按钮的状态。如果按钮被按下，我们更新`buttonPressed`状态。每次检查后，我们休眠`20`毫秒，因为我们需要一个阻塞调用，以便调度器可以再次处理其他goroutines：
- en: '[PRE73]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `updateHighscore` function takes a `score`, checks if this new `score`
    is greater than `highscore`, and if so, it updates `highscore` and prints `highscore`
    to the serial:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`updateHighscore`函数接受一个`score`，检查这个新的`score`是否大于`highscore`，如果是，则更新`highscore`并将`highscore`打印到串行端口：'
- en: '[PRE74]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'With that, we have implemented a check for button presses, a function to update
    `highscore`, and also have a main goroutine that starts a new round of the game
    as soon as it ends. Now, let''s implement the actual game logic. To do so, follow
    these steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就实现了按钮按下的检查，一个更新`highscore`的函数，以及一个在游戏结束后立即开始新一轮游戏的`main` goroutine。现在，让我们实现实际的游戏逻辑。为此，请遵循以下步骤：
- en: 'Normally, it would be best to split the update for the game''s physics, such
    as the player''s movement, bullets, and the enemy and put it in one part of the
    logic, and then put the animation in another part of the logic. When developing
    games for other platforms, these two parts would update independently of each
    other so that they don''t rely on the same framerate. However, to keep things
    simple, we will have a single game loop that updates the positions as well as
    drawing to the screen. The `updateGame` function represents the main logic of
    the game:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，最好将游戏物理的更新（如玩家的移动、子弹和敌人）与动画分开，分别放在逻辑的不同部分。当为其他平台开发游戏时，这两部分将独立更新，这样它们就不依赖于相同的帧率。然而，为了简化，我们将有一个单独的游戏循环，它不仅更新位置，还将绘制到屏幕上。`updateGame`函数代表游戏的主要逻辑：
- en: '[PRE75]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define some variables that will store the position of the enemy:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些将存储敌人位置的变量：
- en: '[PRE76]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To prevent the enemy from starting above the game field, we must subtract its
    size:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止敌人从游戏区域上方开始，我们必须减去其大小：
- en: '[PRE77]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we need to store the position of the bullet inside a variable:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在变量中存储子弹的位置：
- en: '[PRE78]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We store the state if a shot has been fired in a bool variable:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在一个布尔变量中存储是否发射了射击的状态：
- en: '[PRE79]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We store the state if a new shot can be fired in a bool variable. We initialize
    it to `true` as we want the player to be able to fire a shot when the game starts:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在一个布尔变量中存储是否可以发射新射击的状态。我们将其初始化为`true`，因为我们希望在游戏开始时玩家能够发射射击：
- en: '[PRE80]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The game has just started, so `currentScore` is `0`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏刚刚开始，所以`currentScore`是`0`：
- en: '[PRE81]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If the button has been pressed, we reset the `buttonPressed` state as we will
    be handling it. As long as the bullet is still flying inside the game field, we
    cannot fire again:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按钮被按下，我们将重置`buttonPressed`状态，因为我们将会处理它。只要子弹仍在游戏区域内飞行，我们就不能再次射击：
- en: '[PRE82]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If a shot has been fired, we update the bullet:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经发射了射击，我们更新子弹：
- en: '[PRE83]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, we update the position and draw it:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们更新位置并绘制它：
- en: '[PRE84]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If the bullet leaves the game field, we reset the position and reset the `shotFired`
    and `canFire` states. This enables the player to shoot again:'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果子弹离开游戏区域，我们将重置其位置并重置`shotFired`和`canFire`状态。这允许玩家再次射击：
- en: '[PRE85]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Next, we check that the bullet has collided with the enemy on the horizontal
    axis. For this, we use a hitbox that is slightly larger than the bullet itself:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查子弹是否在水平轴上与敌人相撞。为此，我们使用一个比子弹本身稍大的碰撞盒：
- en: '[PRE86]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, we check for a collision on the vertical axis. This time, the hitbox is
    the same size as `bulletSize`. These hitboxes have proven to work pretty well
    in my tests:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们检查垂直轴上的碰撞。这次，碰撞盒的大小与`bulletSize`相同。这些碰撞盒在我的测试中证明效果相当不错：
- en: '[PRE87]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If we hit the enemy, we increment the score:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们击中敌人，我们增加分数：
- en: '[PRE88]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we must draw a black box over the enemy to let it disappear:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在敌人上方画一个黑色盒子，让它消失：
- en: '[PRE89]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Reset the enemy''s position. This respawns the enemy at its spawn position:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置敌人的位置。这将使敌人在其出生位置重生：
- en: '[PRE90]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Update `highscore`, like so:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`highscore`，如下所示：
- en: '[PRE91]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Update and draw the enemy''s position:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并绘制敌人的位置：
- en: '[PRE92]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If the enemy passes our home zone, we lose the game. If this happens, we return,
    as this lets the loop outside the function run again and start a new game:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果敌人通过了我们的主区域，我们就输了。如果发生这种情况，我们就返回，这样函数外部的循环就可以再次运行并开始新的一局：
- en: '[PRE93]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Draw the home zone:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制主区域：
- en: '[PRE94]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Draw the player:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制玩家：
- en: '[PRE95]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Sleep for `12` milliseconds. If we do not sleep here, the enemy and the bullet
    will move too quickly over the screen and will appear to be flickering, which
    does not look nice. So, we use this little trick to slow it down and reduce the
    flickering:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 睡眠`12`毫秒。如果我们不在这里睡眠，敌人和子弹会在屏幕上移动得太快，看起来会闪烁，这看起来不太好。所以，我们使用这个小技巧来减慢速度并减少闪烁：
- en: '[PRE96]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now that we have implemented the main game logic, we only have to create the
    logic that updates the bullet and the enemy before we can play the game.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经实现了主要游戏逻辑，我们只需要在玩游戏之前创建更新子弹和敌人的逻辑。
- en: 'Update the bullet by incrementing its position on the y-axis by 2\. Draw a
    black box behind it so that it does not leave a trail on the display:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在y轴上增加2来更新子弹的位置。在其后面画一个黑色盒子，这样它就不会在显示屏上留下痕迹：
- en: '[PRE97]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The last thing we need to do is update the enemy. To do so, follow these last
    few steps:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的就是更新敌人。为此，遵循以下最后几个步骤：
- en: 'First, we must define the positions and width of the rectangle we will use
    to clear out the previous position of the enemy:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义我们将用来清除敌人之前位置的矩形的坐标和宽度：
- en: '[PRE98]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, we must calculate the position where we need to clear out the enemy:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须计算我们需要清除敌人的位置：
- en: '[PRE99]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If the enemy reaches the left-hand side, we need to completely remove its rectangle
    as the enemy will spawn on the other side of the screen again:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果敌人到达左侧，我们需要完全移除其矩形，因为敌人将在屏幕的另一侧再次重生：
- en: '[PRE100]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we must clear out the enemy and draw the enemy in its new position. We
    must do this to prevent the enemy from leaving trails on the display:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须清除敌人并绘制敌人到其新的位置。我们必须这样做以防止敌人在显示屏上留下痕迹：
- en: '[PRE101]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Update the position of the enemy on the x-axis:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新敌人在x轴上的位置：
- en: '[PRE102]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If the enemy reaches the border of the screen on the x-axis, they also move
    on the y-axis:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果敌人在x轴上到达屏幕边缘，它们也会在y轴上移动：
- en: '[PRE103]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Return the new position:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回新的位置：
- en: '[PRE104]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This is all the logic we need for that game. Now, let''s play it. Flash the
    program using the following command:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个游戏所需的所有逻辑。现在，让我们来玩一玩。使用以下命令闪存程序：
- en: '[PRE105]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We do not need to specify a scheduler here because the scheduler is not deactivated
    by default for `atsamd21`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在这里指定一个调度器，因为默认情况下`atsamd21`不会禁用调度器。
- en: 'Once you''ve played the game for a few rounds, you can start thinking about
    how to extend the game:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你玩了几轮游戏，你就可以开始考虑如何扩展游戏：
- en: We could add two more buttons so that we can move the player left and right.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以再添加两个按钮，以便我们可以左右移动玩家。
- en: We could make it possible for the player to shoot more than one bullet at a
    time.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以让玩家一次射击多个子弹。
- en: The enemy's movement could be randomized so that they don't always move from
    right to left.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人的移动可以是随机的，这样它们就不总是从右向左移动。
- en: We could add a joystick to control the player's position.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加一个摇杆来控制玩家的位置。
- en: Multiple enemies could be spawned.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以生成多个敌人。
- en: The enemies could drop different kinds of powerups, which the player could then
    pick up.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人可以掉落不同类型的道具，玩家可以捡起这些道具。
- en: We could add a buzzer in order to add sounds to the game.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加一个蜂鸣器来为游戏添加声音。
- en: We could display the high score at the end of each round.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在每一轮结束时显示最高分。
- en: This was the last chapter before we start diving into the world of `#tinygame`,
    `#tinygo`, and `#packtbookgame`, and also don't forget to tag me using `@Nooby_Games`.
    Of course, you can also share your games on all other social media channels, blogs,
    and so on. You can also open an issue in this book's GitHub repository to show
    off your results. That way, I can also playtest your games.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开始深入探索`#tinygame`、`#tinygo`和`#packtbookgame`世界之前的最后一章，也请别忘了使用`@Nooby_Games`标签提及我。当然，你还可以在其他所有社交媒体渠道、博客等上分享你的游戏。你还可以在本书的GitHub仓库中打开一个issue来展示你的成果。这样，我也可以测试你的游戏。
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what the I2C interface is and how to use it. We
    also learned how to use a 16x02 LCD display, how to display static text, how to
    display animations, and how to build a little CLI that can receive commands through
    UART and control the display.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了I2C接口是什么以及如何使用它。我们还学习了如何使用16x02 LCD显示屏，如何显示静态文本，如何显示动画，以及如何构建一个小型CLI（命令行界面），该CLI可以通过UART接收命令并控制显示屏。
- en: Then, we gained a deeper understanding of the SPI interface and used it to control
    a 1.8" TFT display. We drew some basic shapes and then used `TinyDraw` to draw
    circles and rectangles and `TinyFont` to draw text. At this point, we have used
    all the important interfaces of a microcontroller, so we now have the skills to
    connect and control any device we need in future projects.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对SPI接口有了更深入的了解，并使用它来控制1.8英寸TFT显示屏。我们绘制了一些基本形状，然后使用`TinyDraw`绘制圆形和矩形，使用`TinyFont`绘制文本。到此为止，我们已经使用了微控制器的重要接口，因此我们现在有了在未来的项目中连接和控制任何所需设备的技能。
- en: At the end of this chapter, we used the knowledge we'd gained in this chapter
    to build a simple game that is controlled by one button and is displayed on the
    1.8" TFT display.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们利用本章学到的知识构建了一个简单的游戏，该游戏由一个按钮控制，并在1.8英寸TFT显示屏上显示。
- en: In the next chapter, we are going to learn how build a **WebAssembly** page
    using TinyGo, as well as how to use the **Wi-Fi chip** that is built into the
    Arduino Nano 33 IoT.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用TinyGo构建**WebAssembly**页面，以及如何使用集成在Arduino Nano 33 IoT板上的**Wi-Fi芯片**。
- en: Questions
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does a device that listens on an I2C bus know that a message is dedicated
    to that device?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听I2C总线的设备是如何知道消息是针对该设备的？
- en: How does a device that listens on an SPI bus know that a message is dedicated
    to that device?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听SPI总线的设备是如何知道消息是针对该设备的？
