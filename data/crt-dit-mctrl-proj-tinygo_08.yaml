- en: '*Chapter 8*: Automating and Monitoring Your Home through the TinyGo Wasm Dashboard'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：通过TinyGo Wasm仪表板自动化和监控您的家'
- en: In the previous chapter, we learned how to use the Wi-Fi chip on the Arduino
    Nano 33 IoT board in order to send **Message Queuing Telemetry** (**MQTT**) messages.
    We then consumed these messages containing weather data and weather alerts, to
    display them on a **WebAssembly** (**Wasm**) dashboard, but we were not able to
    control anything from inside the dashboard. We are now going to change this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用Arduino Nano 33 IoT板上的Wi-Fi芯片来发送**消息队列遥测协议**（**MQTT**）消息。然后我们消费了包含天气数据和天气警报的消息，并在**WebAssembly**（**Wasm**）仪表板上显示它们，但我们无法从仪表板内部控制任何东西。现在我们将改变这一点。
- en: After working through this chapter, we will know how to secure our Wasm apps
    by adding a login page. We're also going to learn about security aspects when
    validating credentials on a client application. After building the login view,
    we are going to learn how to send and receive data inside a dashboard that we
    are going to build. By doing so, we are also going to learn some new techniques
    that will help us by dynamically adding and removing content. By manipulating
    the **Document Object Model** (**DOM**), we will know how to use bidirectional
    communication through MQTT. Lastly, we are going to learn about possibilities
    to control devices that operate at 130V (where **V** stands for **volts**) or
    230V.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章学习后，我们将知道如何通过添加登录页面来保护我们的Wasm应用。我们还将了解在客户端应用程序验证凭据时的安全方面。在构建登录视图后，我们将学习如何在我们要构建的仪表板内部发送和接收数据。通过这样做，我们还将学习一些新技术，这些技术将帮助我们通过动态添加和删除内容来帮助我们。通过操作**文档对象模型**（**DOM**），我们将知道如何通过MQTT进行双向通信。最后，我们将了解控制130V（其中**V**代表**伏特**）或230V设备的可能性。
- en: 'Knowing all this will enable us to build all sorts of home automation projects
    you can think of, beyond this book. In this chapter, we''re going to cover the
    following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有这些将使我们能够构建各种智能家居项目，而不仅仅是这本书中的项目。在本章中，我们将涵盖以下主要主题：
- en: Building a home automation dashboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建智能家居仪表板
- en: Building the home automation client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建智能家居客户端
- en: Requesting data from the microcontroller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从微控制器请求数据
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We are going to need the following components for this project:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下组件来完成此项目：
- en: An Arduino Nano 33 IoT board
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arduino Nano 33 IoT板
- en: A breadboard
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: A **light-emitting diode** (**LED**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**发光二极管**（**LED**）
- en: A 68 Ohm resistor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个68欧姆电阻
- en: Jumper wires
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 'You can find the code for this chapter on GitHub at the following link: [https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08](https://github.com/PacktPublishing/Creative-DIY-Microcontroller-Projects-with-TinyGo-and-WebAssembly/tree/master/Chapter08)
- en: 'The Code in Action video for the chapter can be found here: [https://bit.ly/3uPLI7X](https://bit.ly/3uPLI7X)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在以下链接找到：[https://bit.ly/3uPLI7X](https://bit.ly/3uPLI7X)
- en: Building a home automation dashboard
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建智能家居仪表板
- en: After you have finished this book, you might want to build lots of cool projects
    that could include LED stripes or a motion-sensor-controlled light, or you might
    add a motor to your curtains to open or close them based on the light intensity
    or the time. These would be really cool projects, but now imagine that you're
    sitting on the couch and want to watch a movie, but the sun is too bright and
    did not exceed the threshold to start the motor that controls the curtains. What
    can we do in such a situation? Do we stand up and close the curtains manually,
    or do we open a Wasm app on our smartphone or tablet in order to control the motor
    for the curtains by just pressing a button on an app? You might also want to check
    if the LED stripe in the living room is still turned on, but you do not want to
    get out of bed to check. In that case, it would be great to have a dashboard that
    informs you about its status. In this section, we are going to build a Wasm app
    that provides a login page where the user is able to enter a username and a password
    before they can log in. The page should then be transitioned to a dashboard that
    provides functionality to enable or disable the lights in a specific room.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这本书后，你可能想要构建许多酷炫的项目，这些项目可能包括LED灯带或由运动传感器控制的灯光，或者你可能给窗帘添加一个电机，根据光强度或时间打开或关闭它们。这些将是非常酷的项目，但现在想象一下，你正坐在沙发上想看电影，但太阳太亮了，没有超过启动控制窗帘的电机阈值。在这种情况下我们能做什么呢？我们是站起来手动关闭窗帘，还是在我们智能手机或平板电脑上打开一个Wasm应用，只需按一下应用上的按钮就能控制窗帘的电机？你也可能想检查客厅里的LED灯带是否仍然开启，但你不想起床去检查。在这种情况下，有一个提供其状态的仪表板会很好。在本节中，我们将构建一个Wasm应用，它提供一个登录页面，用户在登录之前可以输入用户名和密码。然后页面应过渡到一个仪表板，提供启用或禁用特定房间灯光的功能。
- en: We will start with a reusable MQTT JavaScript component that can be used until
    a TinyGo-compatible MQTT library has been created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个可重用的MQTT JavaScript组件开始，直到创建一个与TinyGo兼容的MQTT库。
- en: Creating a reusable MQTT component
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用的MQTT组件
- en: In [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135), *Displaying
    Weather Alerts on the TinyGo Wasm Dashboard*, we embedded the MQTT client into
    a `wasm.js` file. This worked well for the project but is not reusable. Therefore,
    we are now going to create a reusable component.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135)，“在TinyGo Wasm仪表板上显示天气警报”，我们将MQTT客户端嵌入到`wasm.js`文件中。这对于项目来说效果很好，但不可重用。因此，我们现在将创建一个可重用的组件。
- en: To do so, start off by creating a new folder named `Chapter08` for this project.
    Inside the newly created folder, create a new folder called `light-control`. This
    new folder is going to contain all the files that are needed for the Wasm app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，首先为这个项目创建一个名为`Chapter08`的新文件夹。在新建的文件夹内，创建一个名为`light-control`的新文件夹。这个新文件夹将包含Wasm应用所需的所有文件。
- en: 'Now, create a new file inside the `light-control` folder and name the file
    `mqtt.js`. The project structure should now look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`light-control`文件夹内创建一个新文件，并将其命名为`mqtt.js`。项目结构现在应该看起来像这样：
- en: '![Figure 8.1 – Project structure'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 项目结构'
- en: '](img/Figure_8.1_B16555.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B16555.jpg)'
- en: Figure 8.1 – Project structure
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 项目结构
- en: 'Inside the `mqtt.js` file, follow these steps to implement it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mqtt.js`文件中，按照以下步骤实现它：
- en: 'First, we define a variable that holds the MQTT client and constants for the
    MQTT broker. We also use `strict` mode again, to prevent us from using undefined
    variables. Strict mode also eliminates some silent errors and exchanges them to
    throw errors instead, and enables JavaScript engines to perform optimizations
    that were otherwise not possible. Using `strict` mode could lead to faster execution.
    The `host` and `port` values *need to be set to your own MQTT broker* host and
    port if the broker is not running locally. The code is shown in the following
    snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个变量来保存MQTT客户端和MQTT代理的常量。我们再次使用`strict`模式，以防止我们使用未定义的变量。`strict`模式还可以消除一些静默错误，并将它们转换为抛出错误，并使JavaScript引擎能够执行在其他情况下不可能的优化。使用`strict`模式可能会导致执行速度更快。如果代理不在本地运行，`host`和`port`值*必须设置为您的MQTT代理*的主机和端口。以下代码片段显示了代码：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then add a function that simply logs to the console when the connection
    to the MQTT broker has been successfully established, as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个函数，当连接到MQTT代理成功建立时，它简单地记录到控制台，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As the Wasm app is being executed on the client, it is possible that we will
    lose the connection to the MQTT broker. This could be caused by an unstable Wi-Fi
    connection. If that happens, we want to attempt to create a new connection. We
    can do this by running the following code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Wasm应用程序正在客户端执行，我们可能会失去与MQTT代理的连接。这可能是由于不稳定的Wi-Fi连接造成的。如果发生这种情况，我们希望尝试创建一个新的连接。我们可以通过运行以下代码来完成此操作：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now need to add a callback for the `messageArrived` event. When a new message
    arrives, we want to call a message handler that is exported by the Go code. This
    works as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要为`messageArrived`事件添加一个回调。当收到新消息时，我们希望调用由Go代码导出的消息处理程序。它的工作方式如下：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We next want to be able to publish messages. In this case, we set the `1` as
    we want to make sure that a message is definitely received by consumers. Furthermore,
    we do not need to retain messages. In later projects, you could also parameterize
    the QOS level and the `retain` flag. The code is shown in the following snippet:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们希望能够发布消息。在这种情况下，我们设置`1`，以确保消息确实被消费者接收。此外，我们不需要保留消息。在未来的项目中，您还可以参数化QOS级别和`retain`标志。代码如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Establish the connection to the MQTT broker, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立与MQTT代理的连接，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is everything we need for our reusable MQTT component. All we need to
    do when integrating it into projects is this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要用于我们的可重用MQTT组件的所有内容。当将其集成到项目中时，我们只需要做以下操作：
- en: Expose a `handleMessage()` function in the Go code.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go代码中公开一个`handleMessage()`函数。
- en: Set the `hostname, port, and cname` values to the MQTT broker in the JavaScript
    file.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript文件中将`hostname`、`port`和`cname`值设置为MQTT代理。
- en: The next step is to set up the so-called glue code that connects the JavaScript
    code with the Go code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置所谓的粘合代码，它将JavaScript代码与Go代码连接起来。
- en: Setting up the Wasm instantiation code
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Wasm实例化代码
- en: 'The Wasm instantiation code is nearly the same every time. It only changes
    if we want to add some project-specific code in it. So, let''s quickly create
    a new file named `wasm.js` inside the `light-control` folder. Now, run the following
    standard code to initialize a Wasm app inside the new file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm实例化代码每次几乎都是相同的。只有当我们想在其中添加一些特定于项目的代码时，它才会改变。因此，让我们快速在`light-control`文件夹内创建一个名为`wasm.js`的新文件。现在，运行以下标准代码以在新的文件中初始化一个Wasm应用程序：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is nearly the same code as in [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135),
    *Displaying Weather Alerts on the TinyGo Wasm Dashboard*, in the *Implementing
    the weather app* section, but this time we did not include the MQTT client code
    inside the file. You can use this file for every project beyond this book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与[*第7章*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135)，“在TinyGo Wasm仪表板上显示天气警报”部分中的代码相同，但这次我们没有在文件中包含MQTT客户端代码。您可以使用此文件在本书之外的所有项目中。
- en: 'The next step is to add the `wasm_exec.js` file. We can either download it
    from the TinyGo GitHub repository or copy it from our local installation. On Unix-based
    systems, you can use the following command to copy the file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加`wasm_exec.js`文件。我们可以从TinyGo GitHub仓库下载它，或者从我们的本地安装中复制它。在基于Unix的系统上，您可以使用以下命令来复制文件：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The path to the `wasm_exec.js` file is different on Windows. When using the
    preceding command, you need to insert your own path to the TinyGo installation.
    The path basically follows this pattern:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm_exec.js`文件的路径在Windows上不同。当使用前面的命令时，您需要插入自己的TinyGo安装路径。路径基本上遵循以下模式：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's everything we need in terms of JavaScript code. We can now go on to create
    our **HyperText Markup Language** (**HTML**) template file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有JavaScript代码。我们现在可以继续创建我们的**超文本标记语言**（**HTML**）模板文件。
- en: Creating the HTML template
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建HTML模板
- en: In [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135), *Displaying
    Weather Alerts on the TinyGo Wasm Dashboard*, in the *Implementing the weather
    app* section, we defined our base structure inside the HTML file, but this time
    our HTML template is going to be much shorter. We are only going to include the
    needed header and define an empty body element as we are going to create all HTML
    elements dynamically using DOM manipulation from inside the Go code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135)，“在TinyGo Wasm仪表板上显示天气警报”部分中，在*实现天气应用程序*部分，我们在HTML文件中定义了我们的基本结构，但这次我们的HTML模板将会更短。我们只包括所需的标题并定义一个空的身体元素，因为我们将在Go代码内部使用DOM操作动态创建所有HTML元素。
- en: 'To do so, create a new file named `index.html` inside the `light-control` folder.
    The body element needs to get an `id` value as we are going to identify the element
    using the ID. We also import all needed JavaScript files in the header. This is
    what it will look like:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，在`light-control`文件夹内创建一个名为`index.html`的新文件。主体元素需要获取一个`id`值，因为我们将通过ID来识别该元素。我们还在标题中导入了所有需要的JavaScript文件。它看起来是这样的：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's everything we need for the HTML template. The next step is writing the
    login view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是HTML模板所需的所有内容。下一步是编写登录视图。
- en: Implementing the login view logic
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现登录视图逻辑
- en: The login component needs to add the login view to the HTML document and also
    implement logic to handle the user input. Let's create a new folder named `login`
    inside the `light-control` folder and create a new file named `userinfo.go` inside
    the newly created folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 登录组件需要将登录视图添加到HTML文档中，并实现处理用户输入的逻辑。让我们在`light-control`文件夹内创建一个名为`login`的新文件夹，并在新创建的文件夹内创建一个名为`userinfo.go`的新文件。
- en: 'The `userinfo.go` file simply holds the `UserInfo` element, which looks like
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`userinfo.go`文件简单地持有`UserInfo`元素，其外观如下：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we create a new `login.go` file inside the `login` folder and implement
    the view by following these steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`login`文件夹内创建一个新的`login.go`文件，并按照以下步骤实现视图：
- en: 'We need username and password values for the login, so we define them as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要登录的用户名和密码值，因此我们定义如下：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We only need to fetch the document a single time, so we just store it inside
    a package-level variable, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要获取文档一次，所以我们只需将其存储在包级变量中，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we define a service that only needs to hold a channel. The channel is
    later being used to propagate the logged-in username to the other components.
    The code is shown in the following snippet:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个只需要持有通道的服务。该通道随后被用来将登录的用户名传播到其他组件。代码如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We define a constructor function that accepts a channel and returns a new instance
    of `Service`, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个构造函数，它接受一个通道并返回一个新的`Service`实例，如下所示：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to implement the logic to create the view. We want to simulate
    having a multipage app by telling the browser to change the **Uniform Resource
    Locator** (**URL**) by pushing a new state. The code to do this is shown in the
    following snippet:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现创建视图的逻辑。我们希望通过告诉浏览器通过推送新的状态来改变**统一资源定位符**（**URL**），来模拟一个多页应用。实现此功能的代码如下所示：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now create a new `div` tag that is going to hold all subsequent elements,
    as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的`div`标签，它将包含所有后续元素，如下所示：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then set an `h1` that also tells the user the name of the component, as
    follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先设置一个`h1`，同时告诉用户组件的名称，如下所示：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we create a form that holds the input fields. So, we simply create a new
    instance of `form` and also create a new `userName` input field with the corresponding
    label, which works as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个包含输入字段的表单。因此，我们简单地创建一个新的`form`实例，并创建一个新的`userName`输入字段以及相应的标签，其工作原理如下：
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now want to add an input field of type `password` that obscures the input.
    To do this, run the following code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要添加一个类型为`password`的输入字段，它会隐藏输入。为此，运行以下代码：
- en: '[PRE19]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we now have both input fields, we need a button that emits `click` and `keyPress`
    events that we can use to trigger the `login` logic. Here is the code we run to
    do this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在有了两个输入字段，我们需要一个按钮来触发`click`和`keyPress`事件，我们可以使用这些事件来触发`login`逻辑。以下是实现此功能的代码：
- en: '[PRE20]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have now created all components that we need inside our `loginForm`, so
    we can go on and append them to `loginForm`, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经在`loginForm`内部创建了所有需要的组件，因此我们可以继续将它们附加到`loginForm`中，如下所示：
- en: '[PRE21]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last thing to do is to append the previous element to the `div`. We append
    everything inside a `div` so that we can easily delete the elements again. In
    order to display the newly created elements, we just append the `div` in the body,
    as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是将前面的元素添加到`div`中。我们将在`div`中添加所有内容，这样我们就可以轻松地再次删除这些元素。为了显示新创建的元素，我们只需将`div`添加到主体中，如下所示：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now create the view itself. The only thing missing here is the logic
    to handle `EventListener` from the `login` button, as well as the login logic
    itself. To do so, follow these last few steps for this component:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建视图本身。这里唯一缺少的是处理`login`按钮的`EventListener`逻辑以及登录逻辑本身。为此，请按照以下最后几个步骤为此组件执行：
- en: 'When the user clicks on the `login` button, we simply want to attempt a login.
    The following code snippet illustrates this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击 `login` 按钮时，我们只想尝试登录。以下代码片段说明了这一点：
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the input button is focused and the user hits the *Enter* button, we also
    want to attempt a login. We wrap the event `args` into a `tinydom` event that
    provides us with convenience functions, as illustrated in the following code snippet:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入按钮获得焦点并且用户按下 *Enter* 按钮时，我们还想尝试登录。我们将在以下代码片段中展示如何将事件 `args` 包装成一个提供便利函数的
    `tinydom` 事件：
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `login` function fetches the input from the `username` and `password` input
    fields and compares them to our defined credentials. When invalid credentials
    are found, we trigger an alert. The most important bit in this function is the
    need to wrap the call that writes into the channel inside a goroutine. If we did
    not wrap a goroutine around it, the code could not compile. Refer to the following
    code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`login` 函数从 `username` 和 `password` 输入字段获取输入，并将它们与我们的定义凭证进行比较。当发现无效凭证时，我们触发一个警报。这个函数中最重要的部分是需要将写入通道的调用包裹在一个
    goroutine 中。如果我们没有围绕它包裹一个 goroutine，代码将无法编译。请参考以下代码：'
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Excellent! We have completed the login component. But what would this view
    look like in a browser? Let''s check the following screenshot to find out:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了登录组件。但这个视图在浏览器中会是什么样子呢？让我们查看以下截图来找出答案：
- en: '![Figure 8.2 – Login view rendered by a browser'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 浏览器渲染的登录视图'
- en: '](img/Figure_8.2_B16555.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – B16555.jpg](img/Figure_8.2_B16555.jpg)'
- en: Figure 8.2 – Login view rendered by a browser
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 浏览器渲染的登录视图'
- en: 'Before we implement the dashboard component, we have to talk about some security
    aspects of this login component. We have defined the credentials that are needed
    to log in inside the code. This code is going to be downloaded by the browser
    in the form of a Wasm binary file. As we provide the code that includes the credentials
    to the client, this procedure is considered unsecure. Let''s have a look at the
    following screenshot that shows a part of the Wasm binary:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现仪表板组件之前，我们必须讨论一下这个登录组件的一些安全方面。我们在代码中定义了登录所需的凭证。这段代码将以 Wasm 二进制文件的形式被浏览器下载。由于我们向客户端提供了包含凭证的代码，这个过程被认为是不安全的。让我们看看以下截图，它显示了
    Wasm 二进制文件的一部分：
- en: '![Figure 8.3 – Credentials leaked in binary file'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 二进制文件中泄露的凭证'
- en: '](img/Figure_8.3_B16555.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – B16555.jpg](img/Figure_8.3_B16555.jpg)'
- en: Figure 8.3 – Credentials leaked in binary file
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 二进制文件中泄露的凭证'
- en: 'To find the credentials inside the Wasm binary, I simply opened the binary
    in a text editor and searched for the password. So, what other possibilities do
    we have to keep credentials safe? Here are a couple of options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Wasm 二进制文件中找到凭证，我只需在文本编辑器中打开二进制文件并搜索密码。那么，我们还有哪些其他可能性来确保凭证的安全？以下是一些选项：
- en: Make an HTTP call to a **REpresentational State Transfer** (**REST**) **application
    programming interface** (**API**) that validates credentials.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向一个 **REpresentational State Transfer** (**REST**) **应用程序编程接口** (**API**) 发起
    HTTP 调用，以验证凭证。
- en: Use any JavaScript library that is able to talk to an **Open Authorization 2**
    (**OAuth 2**) service.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任何能够与 **Open Authorization 2** (**OAuth 2**) 服务通信的 JavaScript 库。
- en: There might be plenty of other possibilities, but they all boil down to moving
    the actual credential validation logic to any kind of external API. But for our
    scope, this solution is good enough to validate the credentials inside the client.
    The next step is to implement the dashboard component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有很多其他可能性，但它们都归结为将实际的凭证验证逻辑移动到任何类型的外部 API。但就我们的范围而言，这个解决方案足够好，可以在客户端内部验证凭证。下一步是实现仪表板组件。
- en: Implementing the dashboard component
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现仪表板组件
- en: 'We are now going to implement our home automation dashboard. The dashboard
    is going to hold a list of components with associated actions that are represented
    by buttons. We also want to log out the user after a 5-minute period of inactivity.
    Before we dive into the code, we need to create a new folder named `dashboard`
    inside the `light-control` folder and create a new `dashboard.go` file inside.
    Now, follow these steps to implement the logic:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现我们的智能家居仪表板。仪表板将包含一系列组件及其关联的动作，这些动作由按钮表示。我们还希望在用户5分钟不活动后注销用户。在我们深入代码之前，我们需要在
    `light-control` 文件夹内创建一个名为 `dashboard` 的新文件夹，并在其中创建一个名为 `dashboard.go` 的新文件。现在，按照以下步骤实现逻辑：
- en: 'We save a reference to the current document, as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们保存了对当前文档的引用，如下所示：
- en: '[PRE26]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The service object holds a channel that we use to signal a logout. The `UserInfo`
    object will later be used to check `loginTime`, which will be used as an inactivity
    timer. We also get `UserName` from `UserInfo`. The code is shown in the following
    snippet:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务对象持有一个我们用来发出注销信号的通道。`UserInfo`对象将稍后用于检查`loginTime`，它将被用作不活动计时器。我们还从`UserInfo`中获取`UserName`。代码如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The constructor function needs to get the channel injected as we react to logout
    events that are being sent to the channel from the `wasm.go` file. The code is
    shown in the following snippet:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构造函数需要获取从`wasm.go`文件发送到通道的注销事件注入的通道。代码如下所示：
- en: '[PRE28]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We want to be able to trigger a connection attempt to the MQTT broker from
    inside the Go code, so we call the `js` function that resides inside the `mqtt.js`
    file, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能够在Go代码内部触发对MQTT代理的连接尝试，因此我们调用位于`mqtt.js`文件中的`js`函数，如下所示：
- en: '[PRE29]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we define a function that can be used as a callback to an eventListener.
    As this function is being called from within JavaScript, we need to fulfill a
    function signature that takes `js.Value` and a `[]js.Value` parameters and returns
    `interface{}`, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个可以作为事件监听器回调使用的函数。由于此函数是在JavaScript内部被调用的，我们需要满足一个接受`js.Value`和`[]js.Value`参数并返回`interface{}`的函数签名，如下所示：
- en: '[PRE30]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `bedroomOn` function is being used as callback for the JavaScript code
    and will be called when the user clicks the `On` button. The code is shown in
    the following snippet:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bedroomOn`函数被用作JavaScript代码的回调，当用户点击`On`按钮时将被调用。代码如下所示：'
- en: '[PRE31]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the user performs any action, we need to check if the activity timer timed
    out. We do so by checking the `loggedInAt` timestamp. If the user is inactive
    for more than 5 minutes we perform a logout, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户执行任何操作时，我们需要检查活动计时器是否超时。我们通过检查`loggedInAt`时间戳来完成此操作。如果用户超过5分钟未活动，我们将执行注销，如下所示：
- en: '[PRE32]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we simply need to invoke the `publish` function in the JavaScript code
    and reset the `loggedInAt` timer, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需在JavaScript代码中调用`publish`函数并重置`loggedInAt`计时器，如下所示：
- en: '[PRE33]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Turning the lights off works in a similar way to turning them on. The only
    difference is the payload of the message. We send `off` instead of `on` here,
    which looks like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭灯光的方式与打开灯光的方式类似。唯一的区别是消息的有效负载。我们在这里发送`off`而不是`on`，如下所示：
- en: '[PRE34]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have successfully implemented the complete control logic. Now, we need to
    implement the logic that creates the view. These are the necessary steps to do
    this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功实现了完整控制逻辑。现在，我们需要实现创建视图的逻辑。以下是完成此操作的必要步骤：
- en: 'When we create the dashboard view, we have information about which user just
    logged in, so we store this as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建仪表板视图时，我们了解哪个用户刚刚登录，因此我们如下存储此信息：
- en: '[PRE35]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Just as in the login view, we tell the browser to display another URL by pushing
    a new state, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在登录视图中一样，我们告诉浏览器通过推送新的状态显示另一个URL，如下所示：
- en: '[PRE36]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We create a new `div` element and set an `Id` value so that we can identify
    the element later on, to remove it when logging out. The code is shown in the
    following snippet:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的`div`元素并设置一个`Id`值，以便我们可以在稍后识别该元素，在注销时将其删除。代码如下所示：
- en: '[PRE37]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now greet the user by their name, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过以下方式向用户问候他们的名字：
- en: '[PRE38]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As we want to have a way to easily add new components to the dashboard, we
    use a table to control the components. That way, we can simply add new table rows
    later on. Of course, we could also create new custom components or use any other
    kind of structure, but adding rows to a table is easy to understand. The whole
    process looks like this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望有一种简单的方法向仪表板添加新组件，我们使用表格来控制组件。这样，我们就可以简单地稍后添加新的表格行。当然，我们也可以创建新的自定义组件或使用任何其他类型的结构，但向表格中添加行更容易理解。整个过程如下所示：
- en: '[PRE39]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Besides a logout based on inactivity, we want the user to have the possibility
    to log out manually. Here''s how to set this up:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了基于不活动的注销外，我们还想让用户有手动注销的可能性。以下是设置此功能的方法：
- en: '[PRE40]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last steps append all child elements to the `div` and append the `div`
    to the body, as illustrated in the following code snippet:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将所有子元素附加到`div`，然后将`div`附加到主体中，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Great! We have now fully implemented the logic that is needed to create the
    view. When rendered by a browser, the view looks similar to this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经完全实现了创建视图所需的逻辑。当由浏览器渲染时，视图看起来类似于以下这样：
- en: '![Figure 8.4 – Dashboard view'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 仪表板视图'
- en: '](img/Figure_8.4_B16555.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B16555.jpg)'
- en: Figure 8.4 – Dashboard view
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 仪表板视图
- en: Now, we only need to implement the main logic before the app itself is complete.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在应用本身完成之前实现主要逻辑。
- en: Implementing the main logic
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现主要逻辑
- en: We are going to split the logic for the different components (login, dashboard)
    into separate files. The `wasm.go` file, which we now create inside the `light-control`
    folder, is going to hold the `main()` function and is used to control the flow
    through the app.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把不同组件（登录、仪表板）的逻辑拆分到单独的文件中。我们现在在`light-control`文件夹中创建的`wasm.go`文件将包含`main()`函数，并用于控制应用中的流程。
- en: 'We are now going to introduce a new library called `tinydom`. The `tinydom`
    library wraps the `syscall/js` API and also provides additional data types such
    as `Video`, `Form`, or `Label`. Using this library, we can save lots of `tinydom`
    works on `js.Value` types internally, it is fully interoperable with the `syscall/js`
    API. You can install `tinydom` using the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍一个新的库，称为`tinydom`。`tinydom`库封装了`syscall/js` API，并提供了一些额外的数据类型，如`Video`、`Form`或`Label`。使用这个库，我们可以节省大量的`tinydom`在`js.Value`类型上的工作，它与`syscall/js`
    API完全兼容。您可以使用以下命令安装`tinydom`：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As this is now set up, let''s go on to implement the logic by following these
    steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经设置好了，让我们继续按照以下步骤实现逻辑：
- en: 'Above the `main` function, we define some variables. We define them outside
    of the `main` function as we are going to need them inside the functions. The
    code is shown in the following snippet:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数上方，我们定义了一些变量。我们将在`main`函数外部定义它们，因为我们将在函数内部使用它们。代码如下所示：
- en: '[PRE43]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We use the `main` function to render the login screen, as well as setting up
    the login and logout event handler. This is done as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`main`函数来渲染登录屏幕，并设置登录和注销事件处理器。这是通过以下方式完成的：
- en: '[PRE44]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When receiving a login event from the channel, we initialize `loginState`,
    connect to MQTT, and render the dashboard view, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从通道接收到登录事件时，我们初始化`loginState`，连接到MQTT，并渲染仪表板视图，如下所示：
- en: '[PRE45]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In order to remove an object from the view, we simply remove it from the DOM.
    We do so by fetching the body element and removing the child with the `login-component`
    ID, as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从视图中移除一个对象，我们只需从DOM中移除它。我们通过获取body元素并移除具有`login-component` ID的子元素来实现，如下所示：
- en: '[PRE46]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also want to be able to remove the dashboard view to be able to go back
    to the login view. We do this by running the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望能够移除仪表板视图，以便能够返回到登录视图。我们通过运行以下代码来实现：
- en: '[PRE47]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When we receive a logout event from the channel, we remove the dashboard view,
    reset the login state, and render the login view again, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从通道接收到注销事件时，我们移除仪表板视图，重置登录状态，并再次渲染登录视图，如下所示：
- en: '[PRE48]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That's everything we need for our main logic. The next step is to implement
    a server that serves the app to clients.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的主要逻辑所需的所有内容。下一步是实现一个为客户端提供应用的服务器。
- en: Serving the app
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供应用服务
- en: Serving the app works in a similar way to serving the app in [*Chapter 7*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135),
    *Displaying Weather Alerts on the TinyGo Wasm Dashboard*, but we add an extra
    trick in here. When the user refreshes the page or tries to visit one of the URLs
    that we set by pushing a state, the server would normally be unaware of these
    URLs. That's why we redirect the client to the correct URL. We handle that case
    by simply redirecting the user to the root URL.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 提供应用服务与在[*第7章*](B16555_07_Final_VK_ePub.xhtml#_idTextAnchor135)中提供应用服务的方式类似，*在TinyGo
    Wasm仪表板上显示天气警报*，但我们在这里添加了一个额外的技巧。当用户刷新页面或尝试访问我们通过推送状态设置的URL之一时，服务器通常不会意识到这些URL。这就是为什么我们将客户端重定向到正确的URL。我们通过简单地重定向用户到根URL来处理这种情况。
- en: 'Now, add the following code into a `main.go` file that resides in a newly created
    folder named `wasm-server`, which is inside the `Chapter08` folder:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到位于新创建的`wasm-server`文件夹中的`main.go`文件中，该文件夹位于`Chapter08`文件夹内：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We have completed the app and the server that serves the app. Let''s now build
    and run everything. We will be using a **Makefile** for this example, but you
    could also use a Docker container, a shell script, or something similar. We need
    to build the Wasm app, copy all dependencies, and start the server. The Makefile
    approach looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了应用及其提供应用的服务器。现在让我们构建并运行一切。我们将使用**Makefile**来完成此示例，但您也可以使用Docker容器、shell脚本或类似的东西。我们需要构建Wasm应用，复制所有依赖项，并启动服务器。Makefile方法如下所示：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In order to run the server, we use the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行服务器，我们使用以下命令：
- en: '[PRE51]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When this is successful, go on and try out our app by visiting the following
    URL in a browser:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当这成功后，继续通过在浏览器中访问以下URL来尝试我们的应用：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When using the Mosquitto Docker container, don''t forget to check that the
    container has been started and that the container does not run. Simply start it
    by using the following command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Mosquitto Docker容器时，别忘了检查容器是否已启动，并且容器没有运行。只需使用以下命令启动它：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we have now successfully built a Wasm app that is able to publish messages
    to an MQTT broker, we can now go on and create a client that consumes these messages,
    and this is exactly what we are going to do in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经成功构建了一个能够向MQTT代理发布消息的Wasm应用，我们现在可以继续创建一个消费这些消息的客户端，这正是我们将在下一节中要做的。
- en: Building the home automation client
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建智能家居客户端
- en: Home automation basically consists of *activating and deactivating things* based
    on a *precondition*. For example, we might want to turn on a light when someone
    enters a room at night. Throughout this book, we have activated and deactivated
    many things based on preconditions, but most of them were not connected to a network.
    We are now going to learn how we can send signals over a network. These signals
    are going to be used as preconditions. After completing this section, we will
    be fully prepared for building our own home automation clients that can be triggered
    over a network.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 智能家居基本上是基于*前提条件*来*激活和停用*事物。例如，我们可能想在夜间有人进入房间时打开灯光。在这本书的整个过程中，我们已经根据前提条件激活和停用了许多事物，但它们大多数都没有连接到网络。现在我们将学习如何通过网络发送信号。这些信号将被用作前提条件。完成本节后，我们将为构建自己的智能家居客户端做好准备，这些客户端可以通过网络触发。
- en: The client that is going to run on the Arduino Nano 33 IoT is simply going to
    connect to an MQTT broker and then subscribe to a topic. When a message comes
    in for the topic, we need to deserialize the message and perform the action that
    is defined in the message.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将在Arduino Nano 33 IoT上运行的客户端将简单地连接到MQTT代理，并订阅一个主题。当有消息进入该主题时，我们需要反序列化消息并执行消息中定义的操作。
- en: For our example project, we are going to turn an LED on and off. Of course,
    a single LED might not be enough to light up a complete bedroom, so we will talk
    about other real-world solutions at the end of this section. Let's start by setting
    up the circuit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例项目，我们将要实现LED的开关。当然，单个LED可能不足以照亮整个卧室，所以我们将在本节末尾讨论其他实际解决方案。让我们先设置电路。
- en: Setting up the circuit
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置电路
- en: 'The circuit for this project is fairly simple. Just follow these steps to set
    everything up:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的电路相当简单。只需按照以下步骤设置一切：
- en: Place an LED with the cathode in *E40* on the breadboard.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个阴极在*E40*上的LED放置在面包板上。
- en: Connect A41 (*GND*) with the *GND* lane on the power bus.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将A41（*GND*）与电源总线上的*GND*通道连接。
- en: Connect the anode of the LED with pin D4 and place a 68 Ohm resistor in between.
    If you don't have a 68 Ohm resistor, you can also use a 100 Ohm one. Connect *B52*
    with the *GND* lane on the power bus.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LED的阳极与D4引脚连接，并在之间放置一个68欧姆的电阻。如果你没有68欧姆的电阻，你也可以使用一个100欧姆的。将*B52*与电源总线上的*GND*通道连接。
- en: 'The result should look similar to this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '![Figure 8.5 – Light control circuit (image is taken from Fritzing)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.5 – 灯光控制电路（图片来自Fritzing）'
- en: '](img/Figure_8.5_B16555.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B16555.jpg)'
- en: Figure 8.5 – Light control circuit (image is taken from Fritzing)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 灯光控制电路（图片来自Fritzing）
- en: 'If you are unsure which technical specs your LEDs have because you simply do
    not have a datasheet, have a look at the following URL. This provides a resistor
    calculator, as well as good voltages for different LED colors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定你的LED有哪些技术规格，因为你根本就没有数据表，请查看以下URL。这里提供了一个电阻计算器，以及不同LED颜色的良好电压：
- en: '[https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor](https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor](https://www.digikey.de/en/resources/conversion-calculators/conversion-calculator-led-series-resistor)'
- en: Great! We are now all set up and ready to implement the logic.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经设置完毕，准备实现逻辑。
- en: Implementing the logic
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现逻辑
- en: 'For our final project, we need to create a new folder named `light-control-client`
    inside the `Chapter08` folder and create a new `main.go` file inside. The logic
    of the `main` function is just used to initialize everything, while the actual
    logic is going to reside in separate functions. To implement it, follow these
    steps:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终项目，我们需要在`Chapter08`文件夹内创建一个名为`light-control-client`的新文件夹，并在其中创建一个名为`main.go`的新文件。`main`函数的逻辑仅用于初始化一切，而实际的逻辑将位于单独的函数中。要实现它，请按照以下步骤操作：
- en: 'Above the main function, we add constants for the Wi-Fi credentials and the
    LED pin. We simply need to replace the SSID and password with our own data, which
    looks like this:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数上方，我们添加了Wi-Fi凭证和LED引脚的常量。我们只需将SSID和密码替换为我们自己的数据，如下所示：
- en: '[PRE54]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, inside the main function, we want to control the LED. To do so, we need
    to configure the pin as output, as shown in the following code snippet:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主函数内部，我们想要控制LED。为此，我们需要将引脚配置为输出，如下面的代码片段所示：
- en: '[PRE55]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The next step is to establish the Wi-Fi connection, as seen in the following
    code snippet:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是建立Wi-Fi连接，如下面的代码片段所示：
- en: '[PRE56]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we need to connect to the MQTT broker. You need to replace the IP address
    with the IP address of your MQTT broker, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要连接到MQTT代理。你需要将IP地址替换为你的MQTT代理的IP地址，如下所示：
- en: '[PRE57]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In order to subscribe to a topic, we need to hand in the QOS level and a function
    that is called when a message on that topic arrives, which looks like this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了订阅一个主题，我们需要提供QOS级别和一个当该主题上的消息到达时被调用的函数，如下所示：
- en: '[PRE58]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The last step is to add in a blocking function so that the program does not
    terminate, which can be seen in the following code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是添加一个阻塞函数，以便程序不会终止，如下面的代码片段所示：
- en: '[PRE59]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'That''s all we need to initialize everything. We now only need to implement
    the logic that handles the incoming messages. To do so, follow these steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们初始化所需的一切。我们现在只需要实现处理传入消息的逻辑。为此，请按照以下步骤操作：
- en: 'First, we need to deserialize the incoming message by splitting the string,
    and then call functions depending on the room that is being delivered. If we receive
    an invalid message or finish handling the message, we `Ack` the message, as follows:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过分割字符串来反序列化传入的消息，然后根据接收到的房间调用相应的函数。如果我们收到无效的消息或完成消息的处理，我们将消息`Ack`，如下所示：
- en: '[PRE60]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the next step, we simply execute the correct functions based on the module
    and action provided. The complete function is implemented in the following snippet:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，我们只需根据提供的模块和动作执行正确的函数。完整的函数在以下代码片段中实现：
- en: '[PRE61]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we just need to activate or deactivate the LED, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需激活或关闭LED，如下所示：
- en: '[PRE62]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We want to stop the execution and print the error repeated, while initializing
    everything. For that case, we use the following helper function:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在初始化一切的同时停止执行并重复打印错误。为此，我们使用以下辅助函数：
- en: '[PRE63]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That''s everything we need to implement the client. We can now go on and flash
    the program, using the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们实现客户端所需的一切。我们现在可以继续使用以下命令闪存程序：
- en: '[PRE64]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: While the program is running, we are now able to turn the LED on and off using
    the Wasm app. So, now go on and try that.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们现在可以使用Wasm应用来打开和关闭LED。所以，现在就试试吧。
- en: Okay—you tried that; everything is working as expected and now you want to know
    what's next. What if something went wrong and the LED never activates or deactivates?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——你尝试了；一切按预期工作，现在你想知道下一步是什么。如果出了问题，LED从未激活或关闭怎么办？
- en: In such a case, I highly recommend watching the output of the serial port in
    PuTTY. If everything looks fine there, the next thing you can try is to send MQTT
    messages to the broker by using MQTT Explorer. If you still have no luck, you
    should double-check your wiring; and if nothing else helps, you might want to
    try to directly flash the code from the GitHub repository.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我强烈建议在PuTTY中查看串行端口的输出。如果那里看起来一切正常，你可以尝试通过MQTT Explorer向代理发送MQTT消息。如果你仍然没有运气，你应该检查你的接线；如果其他方法都不起作用，你可能想尝试直接从GitHub仓库闪存代码。
- en: Now that everything is working as intended, you might think that *only* being
    able to activate and deactivate the light is nice, but what about displaying the
    current status of the light on the dashboard? Let's do this as a next step.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切按预期工作，你可能会认为只能激活和关闭灯光是件好事，但关于在仪表板上显示灯光的当前状态怎么办？让我们作为下一步来做这件事。
- en: Requesting data from the microcontroller
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从微控制器请求数据
- en: We might want to know if the light is currently turned on or off inside the
    living room, without having to walk all the way into the room. So, it would be
    great if the Wasm app *could request the status of the light* and display it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想知道客厅里的灯是开着还是关着，而不必走到房间里去。所以，如果 Wasm 应用程序能够请求灯的状态并显示它，那就太好了。
- en: Now, let's imagine we have one or multiple microcontrollers in different rooms,
    listening to messages. For this example, we do not want the microcontroller to
    continuously report the state of the light as this would cause unnecessary network
    traffic. So, we go on and send a message to request the data. The microcontrollers
    are subscribed to the status topic and get the message delivered. After receiving
    the status request, they answer it by each sending a status message.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们有一个或多个微控制器在不同的房间里监听消息。对于这个例子，我们不希望微控制器持续报告灯的状态，因为这会导致不必要的网络流量。所以，我们继续发送一个请求数据的消息。微控制器订阅了状态主题，并接收到了消息。在收到状态请求后，它们通过各自发送状态消息来回答。
- en: 'This process is represented in the following diagram:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在以下图中表示：
- en: '![Figure 8.6 – Architecture diagram'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 架构图'
- en: '](img/Figure_8.6_B16555.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B16555.jpg)'
- en: Figure 8.6 – Architecture diagram
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 架构图
- en: 'In order to implement that behavior, one microcontroller is sufficient. So,
    let''s go on and update our code accordingly. To do so, follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种行为，一个微控制器就足够了。所以，让我们继续并相应地更新我们的代码。为此，请按照以下步骤操作：
- en: 'Inside the `wasm.js` file, we subscribe to the `home/status` topic. This is
    the topic in which the microcontrollers are going to publish status messages.
    We also want to call a `go` function when the connection has been established.
    Refer to the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `wasm.js` 文件中，我们订阅了 `home/status` 主题。这是微控制器将要发布状态消息的主题。我们还想在连接建立时调用一个 `go`
    函数。请参考以下代码：
- en: '[PRE65]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Inside the `dashboard.go` file, we add a `Boolean` to save the status of the
    bedroom lights inside the `Service` struct, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `dashboard.go` 文件中，我们在 `Service` 结构体中添加了一个 `Boolean` 来保存卧室灯的状态，如下所示：
- en: '[PRE66]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We need to expose the `handleMessage` function to the JavaScript code so that
    it can be called when a new message arrives. We also expose a `handleConnect`
    function to the JavaScript code, which is called when the connection to the broker
    has been established. The code is shown in the following snippet:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将 `handleMessage` 函数暴露给 JavaScript 代码，以便在收到新消息时调用它。我们还向 JavaScript 代码暴露了一个
    `handleConnect` 函数，该函数在连接到代理时被调用。代码如下所示：
- en: '[PRE67]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As we want to add a new column to the table, we need to add a new column header.
    We can do this with the following code:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想在表格中添加一个新列，我们需要添加一个新的列标题。我们可以使用以下代码来完成此操作：
- en: '[PRE68]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We now want to add a new `Status` column inside the table, so we need to add
    some lines of code inside the `RenderDashboard` function. Right below `controlElement`,
    we add a new `statusElement`, as follows:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想在表格中添加一个新的“状态”列，因此我们需要在 `RenderDashboard` 函数中添加一些代码行。在 `controlElement`
    下方，我们添加一个新的 `statusElement`，如下所示：
- en: '[PRE69]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As we have added a column, we need to add it to the table row. We can do this
    by running the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们添加了一个列，我们需要将其添加到表格行中。我们可以通过运行以下代码来完成此操作：
- en: '[PRE70]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we add a new function that lets us request the status. We use the `home/status-request`
    topic for that purpose. This is illustrated in the following code snippet:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们添加了一个新的函数，它允许我们请求状态。我们使用 `home/status-request` 主题来达到这个目的。这在上面的代码片段中有说明：
- en: '[PRE71]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As we now have the ability to request the status, we just need to invoke it
    to get the status updates. We do it right after the MQTT connection has been established,
    as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在有了请求状态的能力，我们只需要调用它来获取状态更新。我们在 MQTT 连接建立后立即这样做，如下所示：
- en: '[PRE72]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The last thing that we need to add is handling the message. So, let''s split
    the message into room, component, and action and call the correct function depending
    on room and component, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加的最后一件事情是处理消息。所以，让我们将消息拆分为房间、组件和动作，并根据房间和组件调用正确的函数，如下所示：
- en: '[PRE73]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We have successfully added all we need to the Wasm app. Let''s now extend the
    logic of the `light-control-client` program. To do so, follow these steps:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将所有需要添加的内容添加到了 Wasm 应用程序中。现在，让我们扩展 `light-control-client` 程序的逻辑。为此，请按照以下步骤操作：
- en: 'We need to save the current status of the lights, so we add a new variable
    at the package level, as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要保存灯的当前状态，因此我们在包级别添加了一个新变量，如下所示：
- en: '[PRE74]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the `main` function, we subscribe to the `home/status-request` topic, as
    illustrated in the following code snippet:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们订阅了`home/status-request`主题，如下面的代码片段所示：
- en: '[PRE75]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We now need to implement the handler for the status request. We simply report
    the status and `Ack` the message afterward, as illustrated in the following code
    snippet:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要实现状态请求的处理程序。我们简单地报告状态，并在之后`Ack`消息，如下面的代码片段所示：
- en: '[PRE76]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `reportStatus` function just needs to check and report the status. This
    can be done by running the following code:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reportStatus`函数只需要检查并报告状态。这可以通过运行以下代码来完成：'
- en: '[PRE77]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Inside the `HandleActionMessage` function, we need to pass `mqtt.Client` as
    an additional parameter to the `controlBedroom` function. We can do this by running
    the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HandleActionMessage`函数中，我们需要将`mqtt.Client`作为附加参数传递给`controlBedroom`函数。我们可以通过运行以下代码来实现：
- en: '[PRE78]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We now also need to add `mqtt.Client` to the `controlBedroom` parameter list.
    We can do this by running the following code:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还需要将`mqtt.Client`添加到`controlBedroom`参数列表中。我们可以通过运行以下代码来实现：
- en: '[PRE79]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We then pass the client in to the `controlBedroomlights` function, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后将客户端传递给`controlBedroomlights`函数，如下所示：
- en: '[PRE80]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The last step is to update and report the status in the `controlBedroomLights`
    function. We also update the status here so that we get feedback in the Wasm app
    after clicking on the **on**/**off** buttons. The code for this is shown in the
    following snippet:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在`controlBedroomLights`函数中更新和报告状态。我们也在这里更新状态，以便在点击**开**/**关**按钮后，在Wasm应用中获取反馈。下面的代码片段显示了这一代码：
- en: '[PRE81]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Excellent! The client can now check the status of the lights inside the Wasm
    app.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在客户端可以在Wasm应用中检查灯光的状态。
- en: Well, congratulations! You have finished all of the projects in this book. Let's
    now have a look at possible alternative solutions to our current implementation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，恭喜！你已经完成了这本书中的所有项目。现在让我们来看看可能的替代解决方案，以替代我们当前的实现。
- en: Checking other implementation ideas
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查其他实现想法
- en: Lighting up a small LED by pressing a button on a Wasm app is exciting but does
    not really help in terms of home automation. An LED can be considered as a placeholder
    for literally anything you can think of. We have implemented the logic to trigger
    any kind of action. What possibilities do we have to control real lights or other
    components?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Wasm应用中按下一个按钮来点亮一个小型LED灯很令人兴奋，但就家庭自动化而言，这实际上并没有太大的帮助。LED可以被看作是你能想到的任何东西的占位符。我们已经实现了触发任何类型动作的逻辑。我们有哪些可能性来控制真正的灯光或其他组件？
- en: Using smart sockets
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用智能插座
- en: One option is to use smart sockets, which are controllable using Wi-Fi or Bluetooth.
    Most of them do not provide an open API and require you to reverse-engineer the
    signals to control them, but there are also some manufacturers that provide API
    references for their products.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用智能插座，这些插座可以通过Wi-Fi或蓝牙进行控制。大多数它们不提供公开API，需要你逆向工程信号来控制它们，但也有一些制造商为他们的产品提供了API参考。
- en: An example of this is the NETIO PowerBOX 3Px, which is a socket that supports
    lots of APIs such as MQTT, HTTP, **JavaScript Object Notation** (**JSON**), and
    **Transmission Control Protocol** (**TCP**), among others. Another example is
    WIFIPLUG—they also produce smart sockets that have open APIs available.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是NETIO PowerBOX 3Px，这是一个支持许多API的插座，如MQTT、HTTP、**JavaScript对象表示法**（**JSON**）、**传输控制协议**（**TCP**）等。另一个例子是WIFIPLUG——他们也生产具有公开API的智能插座。
- en: Using a relais
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用继电器
- en: We have learned how to control a relais when building our automatic plant-watering
    system. Some relais and boards support voltages up to 230V and 10 **amps** (**A**),
    which is sufficient to power nearly any electrical device. Although the relais
    might be able to handle currencies of 230V or 130V, you should never work mains-voltage.
    Lots of nice projects can be built with currents up to 12V.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的自动植物浇水系统时，我们已经学会了如何控制继电器。一些继电器和板子支持高达230V和10 **安培**（**A**）的电压，这足以供电几乎任何电气设备。尽管继电器可能能够处理230V或130V的电压，但你永远不应该操作主电压。使用高达12V的电流可以构建许多优秀的项目。
- en: Using TLS
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用TLS
- en: When developing **Internet of Things** (**IoT**) applications, it's important
    to consider security. At the time of writing, the Wi-Fi driver implementation
    of the Arduino Nano 33 IoT does not support TLS. This is a topic that is actively
    being worked on and will definitely be implemented soon. So, when implementing
    functionalities that operate outside of your local network, you should definitely
    aim to use TLS. Also, as mentioned, when implementing the login view, we learned
    that embedding credentials into Wasm is not as secure as embedding credentials
    into the binary file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 **物联网**（**IoT**）应用程序时，考虑安全性非常重要。在撰写本文时，Arduino Nano 33 IoT 的 Wi-Fi 驱动程序实现不支持
    TLS。这是一个正在积极工作的主题，并肯定会很快实现。因此，在实现操作超出您本地网络的功能时，您应该确保使用 TLS。此外，如前所述，在实现登录视图时，我们了解到将凭据嵌入到
    Wasm 中不如将凭据嵌入到二进制文件中安全。
- en: We have now learned that there are several manufacturers for smart sockets that
    have an open API, which makes it easy to integrate them into our projects **safely**.
    We have also learned that we can make use of a relais to control LED stripes or
    other devices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解到，有多个智能插座制造商提供了开放 API，这使得它们很容易被集成到我们的项目中**安全地**。我们还了解到，我们可以利用继电器来控制
    LED 灯带或其他设备。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to build a Wasm app that creates its views
    fully and dynamically. We have learned this by manipulating the DOM. We have also
    learned how to handle user input in Wasm and how to create reusable JavaScript
    components for use in future Wasm projects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何构建一个完全且动态创建视图的 Wasm 应用程序。我们通过操作 DOM 来学习这一点。我们还学习了如何在 Wasm 中处理用户输入以及如何创建可重复使用的
    JavaScript 组件，以便在未来的 Wasm 项目中使用。
- en: We then learned how to publish MQTT messages from inside a Wasm app, by implementing
    a dashboard able to toggle lights that were represented by an LED.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何通过实现一个能够切换由 LED 表示的灯光的仪表板，从 Wasm 应用程序内部发布 MQTT 消息。
- en: This book's task was to bring you closer to programming microcontrollers and
    Wasm and to teach you how to implement small projects with little code and—hopefully—a
    lot of fun. You have now learned everything you need to go on and realize your
    own project ideas.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的任务是让您更接近编程微控制器和 Wasm，并教您如何用很少的代码实现小型项目——希望您会玩得很开心。您现在已经学到了实现您自己的项目想法所需的一切。
- en: Questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is validating credentials inside Wasm code not secure?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在 Wasm 代码内部验证凭据不安全？
- en: What are the alternatives to validating credentials inside Wasm code?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Wasm 代码内部验证凭据有哪些替代方案？
