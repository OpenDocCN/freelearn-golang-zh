- en: Appendix – "Go"ing Ahead
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 – “Go”前进
- en: In this appendix section, we are going to have a look at some concepts of the
    Go programming language that have not been explained in the previous chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录部分，我们将探讨一些在前面章节中没有解释的Go编程语言的概念。
- en: 'The following topics are covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题被涵盖：
- en: Blocking a goroutine
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞goroutine
- en: Finding heap allocations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找堆分配
- en: Blocking a goroutine
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞goroutine
- en: Blocking a goroutine can be important. The easiest example of this is the `main`
    function. If we have no blocking call or loop inside the `main` function, the
    program terminates and restarts. In most cases, we do not want a program to terminate,
    as we might want to wait for a signal on any input that could trigger any further
    action in the code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞goroutine可能很重要。最简单的例子是`main`函数。如果我们没有在`main`函数内部使用阻塞调用或循环，程序将终止并重新启动。在大多数情况下，我们不希望程序终止，因为我们可能希望等待任何可能触发代码中进一步操作的输入信号。
- en: Let's now look at some possibilities for blocking a goroutine. Blocking a goroutine
    is sometimes necessary in order to gain time to let a scheduler work on other
    goroutines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下阻塞goroutine的一些可能性。在某些情况下，阻塞goroutine是必要的，以便获得时间让调度器在其他goroutine上工作。
- en: Reading from a channel
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从通道读取
- en: 'A very common way to block a goroutine is to read from a channel. Reading from
    a channel blocks the goroutine until a value can be read. This is illustrated
    in the following code example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞goroutine的一种非常常见的方式是从通道读取。从通道读取将阻塞goroutine，直到可以读取值。以下代码示例说明了这一点：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A select statement
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个select语句
- en: 'A `select` statement lets a goroutine wait on multiple operations. The syntax
    is similar to the syntax of a `switch` statement. The following code example implements
    a `select` statement that blocks until one of two cases can run:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`select`语句让goroutine等待多个操作。其语法与`switch`语句的语法类似。以下代码示例实现了一个阻塞直到两个情况之一可以运行的`select`语句：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If both cases happen to be ready at the same time, the `select` statement chooses
    a random case.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个情况恰好同时准备好，`select`语句将随机选择一个情况。
- en: 'We sometimes have cases where our `main` function should do nothing while other
    goroutines are waiting for incoming messages to handle them. In such cases, we
    can make use of an empty `select` statement that blocks indefinitely. An example
    of this can be seen in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会遇到这样的情况，即我们的`main`函数在其他goroutine等待处理传入消息时应该什么也不做。在这种情况下，我们可以使用一个空的`select`语句来无限期地阻塞。以下代码片段是一个这样的例子：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Sleeping is a blocking call
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 休眠是一个阻塞调用
- en: 'In some cases, we only want to gain some time for a scheduler to work on another
    goroutine. In such cases, we can use `time.Sleep()` in order to sleep for a brief
    amount of time and then continue to work on our current goroutine. This could
    look like the following code example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们只想为调度器工作在另一个goroutine上争取一些时间。在这种情况下，我们可以使用`time.Sleep()`来短暂休眠，然后继续在当前的goroutine上工作。这可以像以下代码示例那样：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have learned some different ways to block a goroutine, so let's now learn
    a bit about allocations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了不同的方法来阻塞goroutine，现在让我们学习一点关于分配的内容。
- en: Finding heap allocations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找堆分配
- en: The TinyGo compiler toolchain tries to optimize code in such a way that no heap
    allocations are left in the result, but some allocations cannot be optimized.
    Is there a way to know which those allocations are? Yes! We can deactivate the
    `build` and `flash` commands.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: TinyGo编译器工具链试图以这种方式优化代码，即结果中不留下任何堆分配，但有些分配无法优化。是否有办法知道哪些分配？是的！我们可以禁用`build`和`flash`命令。
- en: 'When the GC is deactivated, the compilation process is going to fail and throws
    an error, which points to the line of code that caused a heap allocation. Let''s
    check out the following code example, which causes a heap allocation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当GC被禁用时，编译过程将失败并抛出一个错误，该错误指向导致堆分配的代码行。让我们看看以下导致堆分配的代码示例：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When building this program, we will have the GC deactivated with the following
    command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建此程序时，我们将使用以下命令禁用GC：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is going to throw the following error:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发以下错误：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Storing a pointer to a value in a global object results in a heap allocation.
    How could we improve the program to not allocate heap memory? We could simply
    omit using a pointer here. Check out the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将值的指针存储在全局对象中会导致堆分配。我们如何改进程序以不分配堆内存？我们可以简单地在这里省略使用指针。查看以下示例：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now try to build the program again, using the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试再次构建程序，使用以下命令：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command is going to create the output file and will not throw any errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建输出文件，并且不会抛出任何错误。
- en: 'If you want to check out which operations cause **heap allocations** and which
    do not, check out the following link:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查哪些操作会导致**堆分配**，哪些不会，请查看以下链接：
- en: '[https://tinygo.org/compiler-internals/heap-allocation/](https://tinygo.org/compiler-internals/heap-allocation/)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://tinygo.org/compiler-internals/heap-allocation/](https://tinygo.org/compiler-internals/heap-allocation/)'
- en: 'If you want to gain a better understanding of the **heap**, check out the following
    link:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更好地理解**堆**，请查看以下链接：
- en: '[https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d](https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d](https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d)'
