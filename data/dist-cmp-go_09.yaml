- en: Foundations of Web Scale Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web规模架构的基础
- en: '[Chapter 5](../Text/Ch05.xhtml), *Introducing Goophr*, [Chapter 6](../Text/Ch06.xhtml),
    *Goophr Concierge*, and [Chapter 7](../Text/Ch07.xhtml), *Goophr Librarian* were
    about the design and implementation of a distributed search index system, starting
    from basic concepts to running individual components and verifying that they work
    as expected. In [Chapter 8](../Text/Ch08.xhtml), *Deploying Goophr*, we connected
    the various components with the help of **docker-compose** so that we could launch
    and connect all the components in an easy and reliable manner. We have achieved
    quite a lot in the past four chapters, but you may have noticed that we ran everything
    on a single machine, most likely our laptop or desktop.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](../Text/Ch05.xhtml)，*介绍Goophr*，[第6章](../Text/Ch06.xhtml)，*Goophr Concierge*，和[第7章](../Text/Ch07.xhtml)，*Goophr
    Librarian*，是关于从基本概念到运行各个组件并验证它们按预期工作的分布式搜索索引系统的设计和实现。在[第8章](../Text/Ch08.xhtml)，*部署Goophr*，我们使用**docker-compose**将各个组件连接起来，以便我们可以以简单可靠的方式启动和连接所有组件。在过去的四章中，我们取得了相当大的进展，但你可能已经注意到我们在单台机器上运行了所有东西，很可能是我们的笔记本电脑或台式机。'
- en: Ideally, we should next try to prepare our distributed system to work reliably
    under a heavy user load and expose it over the web for general use. However, the
    reality is that we will have to make a lot of upgrades to our current system to
    make it reliable and resilient enough to be able to work under real-world traffic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们应该尝试准备我们的分布式系统在大量用户负载下可靠工作，并将其暴露在Web上供一般使用。然而，现实情况是，我们将不得不对我们当前的系统进行大量升级，以使其足够可靠和有弹性，能够在真实世界的流量下工作。
- en: 'In this chapter, we are going to look at various factors we should keep in
    mind while we try to design for the web. We will be looking at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在尝试为Web设计时应该牢记的各种因素。我们将关注以下内容：
- en: Scaling a web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展Web应用程序
- en: Monolith app versus microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体应用程序与微服务
- en: Deployment options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署选项
- en: Scaling a web application
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展Web应用程序
- en: In this chapter, we will not be discussing Goophr but instead a simple web application
    for blogging so that we can concentrate on scaling it for the web. Such an application
    may consist of a single server instance running the database and the blog server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不讨论Goophr，而是一个简单的用于博客的Web应用程序，以便我们可以专注于为Web扩展它。这样的应用程序可能包括运行数据库和博客服务器的单个服务器实例。
- en: 'Scaling a web application is an intricate topic, and we will devote a lot of
    time to this very subject. As we shall see throughout this section, there are
    multiple ways to scale a system:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Web应用程序是一个复杂的主题，我们将花费大量时间来讨论这个主题。正如我们将在本节中看到的，有多种方式可以扩展系统：
- en: Scaling the system as a whole
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整体扩展系统
- en: Splitting up the system and scaling individual components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分系统并扩展各个组件
- en: Choosing specific solutions to better scale the system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择特定的解决方案以更好地扩展系统
- en: Let's start with the most basic setup, a single server instance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的设置开始，即单个服务器实例。
- en: The single server instance
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个服务器实例
- en: 'A single server setup will generally consist of:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单服务器设置通常包括：
- en: A web server to serve web pages and handle server-side logic
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于提供网页并处理服务器端逻辑的Web服务器
- en: A database to save all user data (blog posts, user login details, and so on)
    related to the blog
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于保存与博客相关的所有用户数据（博客文章、用户登录详细信息等）的数据库
- en: 'The following figure shows what such a server would look like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了这样一个服务器的外观：
- en: '![](img/74eb2b09-6ebf-4c93-9a5b-9db3bd3e2f4b.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74eb2b09-6ebf-4c93-9a5b-9db3bd3e2f4b.png)'
- en: The figure shows a simple setup where the user interacts with the blog server,
    which will be interacting with a database internally. This setup of a database
    and blog server on the same instance will be efficient and responsive only up
    to a certain number of users.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了一个简单的设置，用户与博客服务器进行交互，博客服务器将在内部与数据库进行交互。这种在同一实例上设置数据库和博客服务器将仅在一定数量的用户上是高效和响应的。
- en: As the system starts to slow down or storage starts to fill up, we can redeploy
    our application (database and blog server) on to a different server instance with
    more storage, RAM, and CPU power; this is known as **vertical scaling**. As you
    may suspect, this can be time consuming and an inconvenient way of upgrading your
    server. Wouldn't it be better if we could stave off this upgrade for as long as
    possible?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统开始变慢或存储空间开始填满时，我们可以将我们的应用程序（数据库和博客服务器）重新部署到具有更多存储空间、RAM和CPU功率的不同服务器实例上；这被称为**垂直扩展**。正如你可能怀疑的那样，这可能是耗时和不便的升级服务器的方式。如果我们能尽可能地推迟这次升级，那不是更好吗？
- en: 'An important point to think about is that the issue might be due to any combination
    of the following factors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要问题是，问题可能是由以下任何组合因素导致的：
- en: Out of memory due to the database or blog server
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据库或博客服务器而导致内存不足
- en: Performance degradation due to the web server or database requiring more CPU
    cycles
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Web服务器或数据库需要更多CPU周期而导致性能下降
- en: Out of storage space due to the database
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据库的存储空间不足
- en: Scaling the complete application for any of the preceding factors isn't an optimal
    way to deal with the issue because we are spending a lot of money where we could
    have solved the issue with far fewer resources! So how should we fashion our system
    so that we can solve the right problem in the right manner?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决上述任何因素，扩展完整应用程序并不是处理问题的最佳方式，因为我们在本可以用更少的资源解决问题的地方花费了很多钱！那么我们应该如何设计我们的系统，以便以正确的方式解决正确的问题呢？
- en: Separate layers for the web and database
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Web和数据库分层
- en: 'If we take the three issues stated earlier, we can solve each of them in one
    or two ways. Let''s look at them first:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑前面提到的三个问题，我们可以通过一两种方式解决每个问题。让我们首先看看它们：
- en: '**Issue #1**: Out of memory'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题＃1**：内存不足'
- en: '**Solution**:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: '**Due to the database**: Increase RAM for the database'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于数据库**：为数据库增加RAM'
- en: '**Due to the blog server**: Increase RAM for the blog server'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于博客服务器**：为博客服务器增加RAM'
- en: '**Issue #2**: Performance degradation'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题＃2**：性能下降'
- en: '**Solution**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: '**Due to the database***:* Increase the CPU power for the database'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于数据库**：增加数据库的CPU功率'
- en: '**Due to the blog server**: Increase the CPU power for the blog server'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于博客服务器**：增加博客服务器的CPU功率'
- en: '**Issue #3**: Out of storage space'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题＃3**：存储空间不足'
- en: '**Solution**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: '**Due to the database**: Increase the storage space for the database'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由于数据库**：增加数据库的存储空间'
- en: 'Using this listing, we can upgrade our system as and when required for a particular
    problem we are facing. However, we first need to correctly identify the component
    that is causing the issue. For this reason, even before we start scaling our application
    vertically, we should separate our database from our web server as shown in this
    figure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此列表，我们可以根据我们面临的特定问题随时升级我们的系统。然而，我们首先需要正确识别导致问题的组件。因此，即使在我们开始垂直扩展我们的应用程序之前，我们也应该像图中所示将我们的数据库与Web服务器分开。
- en: '![](img/cf3987e3-753d-44d1-844f-a0a4ac2ee2fc.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf3987e3-753d-44d1-844f-a0a4ac2ee2fc.png)'
- en: This new setup with the database and the blog server on separate server instances
    would enable us to monitor which component is having an issue and vertically scale
    only that particular component. We should be able to serve a larger user traffic
    with this new setup.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 具有数据库和博客服务器在单独的服务器实例上的新设置将使我们能够监视哪个组件存在问题，并且仅垂直扩展该特定组件。我们应该能够使用这种新设置为更大的用户流量提供服务。
- en: However, as the load on the server increases, we might have other issues on
    our hands. For example, what would happen if our blog server were to become unresponsive?
    We would no longer be able to serve blog posts and no one would be able to post
    comments on said blog posts. This is a situation no one wants to face. Wouldn't
    it be nice if we could keep serving traffic even if the blog server were down?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着服务器负载的增加，我们可能会遇到其他问题。例如，如果我们的博客服务器变得无响应会发生什么？我们将无法继续提供博客文章，也没有人能够在博客文章上发表评论。这是没有人愿意面对的情况。如果我们能够在博客服务器宕机时继续提供流量，那不是很好吗？
- en: Multiple server instances
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个服务器实例
- en: 'Serving a large traffic of users with a single server instance for our blog
    server or any application (business logic) server is dangerous because we are
    essentially creating a single point of failure. The most logical and simplest
    way to avoid such a situation is to have duplicate instances of our blog server
    to handle incoming user traffic. This approach of scaling a single server to multiple
    instances is known as **horizontal scaling**. However, this raises the question:
    how can we reliably distribute the traffic between the various instances of our
    blog server? For this we use a **load balancer**.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个服务器实例为我们的博客服务器或任何应用程序（业务逻辑）服务器提供大量用户流量是危险的，因为我们实质上正在创建一个单点故障。避免这种情况的最合乎逻辑和最简单的方法是复制我们的博客服务器实例以处理传入的用户流量。将单个服务器扩展到多个实例的这种方法称为**横向扩展**。然而，这带来了一个问题：我们如何可靠地在博客服务器的各个实例之间分发流量？为此，我们使用**负载均衡器**。
- en: The load balancer
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: 'A load balancer is a type of HTTP server responsible for distributing traffic
    (routing) to various web servers based on the rules defined by the developer.
    A load balancer, in general, is a very fast and specialized application. Trying
    to implement similar logic in a web server might not be optimal because the resources
    available to your web server have to be split between handling requests for your
    business logic and requests that need to be routed. Also, a load balancer provides
    us with a lot of features out of the box such as these:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器是一种HTTP服务器，负责根据开发人员定义的规则将流量（路由）分发到各种Web服务器。总的来说，负载均衡器是一个非常快速和专业的应用程序。在Web服务器中尝试实现类似的逻辑可能不是最佳选择，因为您的Web服务器可用资源必须在处理业务逻辑的请求和需要路由的请求之间进行分配。此外，负载均衡器为我们提供了许多开箱即用的功能，例如：
- en: '**Load balancing algorithms**: The following are some algorithms for load balancing:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡算法**：以下是一些负载均衡的算法。'
- en: '**Random**: Distribute randomly across the servers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机**：在服务器之间随机分发。'
- en: '**Round robin**: Distribute equally and sequentially across servers.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询**：在服务器之间均匀顺序地分发。'
- en: '**Asymmetric load**: Distribute between servers in certain proportions. For
    example, for 100 requests, send 80 to Server A and 20 to Server B.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不对称负载**：以一定比例在服务器之间分发。例如，对于100个请求，将80个发送到A服务器，20个发送到B服务器。'
- en: '**Least connections**: Send a new request to the server with the least number
    of active connections (an asymmetric load can also be integrated with least connections).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最少连接**：将新请求发送到具有最少活动连接数的服务器（不对称负载也可以与最少连接集成）。'
- en: '**Session persistence**: Imagine an e-commerce site where a user has added
    items to his shopping cart and the information about items in the cart is stored
    on, Server A. However, when the user wants to complete the purchase, the request
    is sent to a different server, Server B! This would be an issue for the user because
    all details related to his shopping cart is on Server A. Load balancers have the
    provision to ensure that such requests are redirected to the relevant server.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话持久性**：想象一个电子商务网站，用户已将商品添加到购物车中，购物车中的商品信息存储在A服务器上。然而，当用户想要完成购买时，请求被发送到另一台服务器B！这对用户来说是一个问题，因为与他的购物车相关的所有详细信息都在A服务器上。负载均衡器可以确保将这些请求重定向到相关的服务器。'
- en: '**HTTP compression**: Load balancers also have the provision to compress the
    outgoing response using `gzip` so that it has less data to send to the user. This
    tends to greatly improve the user experience.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP压缩**：负载均衡器还可以使用`gzip`压缩传出响应，以便向用户发送更少的数据。这往往会极大地改善用户体验。'
- en: '**HTTP caching**: For sites that serve more than REST API content, a lot of
    files can be cached because they do not change as often and cached content can
    be delivered much faster.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP缓存**：对于提供REST API内容的站点，许多文件可以被缓存，因为它们不经常更改，并且缓存的内容可以更快地传递。'
- en: Depending on which load balancer is being used, they can provide a lot more
    features than the ones stated above. This should give an idea about the capability
    of a load balancer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的负载均衡器，它们可以提供比上述列出的更多功能。这应该让人了解负载均衡器的能力。
- en: 'The following figure shows how a load balancer and multiple servers might work
    together:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了负载均衡器和多个服务器如何一起工作：
- en: '![](img/0a855d3a-5d7c-4b76-9f86-d8b145ad2f71.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a855d3a-5d7c-4b76-9f86-d8b145ad2f71.png)'
- en: The user's requests reach the load balancer, which then routes the request to
    one of the many instances of the blog server. However, note that even now we are
    using the same database for read and write operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的请求到达负载均衡器，然后将请求路由到博客服务器的多个实例之一。然而，请注意，即使现在我们仍然在使用相同的数据库进行读写操作。
- en: Multi-availability zones
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多可用区域
- en: In the previous section, we talked about the single point of failure and why
    having multiple instances of the application server is a good thing. We can extend
    this concept further; what if we have all of our servers in one location and due
    to some major malfunction or outage, all of our servers go down? We will not be
    able to serve any user traffic.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们谈到了单点故障以及为什么有多个应用服务器实例是一件好事。我们可以进一步扩展这个概念；如果我们所有的服务器都在一个位置，由于某种重大故障或故障，所有的服务器都宕机了怎么办？我们将无法为任何用户流量提供服务。
- en: 'We can see that having our servers in one location also creates a single point
    of failure. The solution for this would be to have application server instances
    available in multiple locations. Then the next question would be: how do we decide
    on the locations to deploy our servers? Should we deploy the servers to multiple
    locations within a single country or should we deploy them to multiple countries?
    We can rephrase the question using cloud computing terminology as follows.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，将我们的服务器放在一个位置也会造成单点故障。解决这个问题的方法是在多个位置提供应用服务器实例。然后下一个问题是：我们如何决定部署服务器的位置？我们应该将服务器部署到单个国家内的多个位置，还是应该将它们部署到多个国家？我们可以使用云计算术语重新表达问题如下。
- en: We need to decide whether we want to deploy our servers to **multiple regions**
    or **multiple zones**, or perhaps a combination of both.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定是否要将我们的服务器部署到**多个区域**或**多个区域**，或者两者兼而有之。
- en: 'One important point to note is that deploying to multiple zones may lead to
    network delay and we may want to deploy to multiple regions first. However, before
    we deploy to multiple regions and zones, we need to make sure of two facts:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点要注意的是，部署到多个区域可能会导致网络延迟，我们可能希望先部署到多个地区。然而，在我们部署到多个地区和区域之前，我们需要确保两个事实：
- en: Our website has heavy traffic that our single server setup is no longer able
    to handle
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的网站有大量流量，我们的单服务器设置已经无法处理
- en: We have a significant chunk of users from another country, and it might be a
    good idea to deploy servers in a zone near them
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有相当多的用户来自另一个国家，将服务器部署在他们附近的区域可能是一个好主意
- en: 'Once we have given consideration to these factors and decided to deploy to
    additional zones and regions, our blogging system as a whole might look something
    like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们考虑了这些因素并决定部署到额外的区域和区域，我们的博客系统整体可能看起来像这样：
- en: '![](img/c8356325-b9ee-4215-9fbc-9bca596afbfa.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8356325-b9ee-4215-9fbc-9bca596afbfa.png)'
- en: The database
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库
- en: We have been scaling the application/blog server and seen how to scale the server
    vertically and horizontally, and how to factor multiple zones and regions for
    high availability and performance of the overall system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在扩展应用程序/博客服务器，并看到了如何垂直和水平扩展服务器，以及如何为整个系统的高可用性和性能因素化多个区域和区域。
- en: You may have noticed in all of the previous designs that we still relied on
    a single database instance. By now, you may have realized that having a single
    instance of any service/server can become a single point of failure and may bring
    the system to a complete standstill.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在所有先前的设计中，我们仍然依赖单个数据库实例。到现在为止，您可能已经意识到，任何服务/服务器的单个实例都可能成为单点故障，并可能使系统完全停滞。
- en: The tricky part is that we cannot use the straightforward strategy of running
    multiple database instances as we did for the application server. We were able
    to use this strategy for application server because the application server is
    responsible for business logic and what little state it maintains within itself
    is temporary, while all vital and important information is being pushed to the
    database which forms the single source of truth, and, ironically, the single source
    of failure. Before we dig deeper into the complexity of scaling a database and
    the challenges that come along with it, let us first look at an important topic
    that needs to be addressed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是，我们不能像为应用服务器那样简单地运行多个数据库实例的策略。我们之所以能够为应用服务器使用这种策略，是因为应用服务器负责业务逻辑，它自身维护的状态很少是临时的，而所有重要的信息都被推送到数据库中，这构成了真相的唯一来源，也是讽刺的是，单点故障的唯一来源。在我们深入探讨数据库扩展的复杂性和随之而来的挑战之前，让我们首先看一下需要解决的一个重要主题。
- en: SQL versus NoSQL
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL与NoSQL
- en: 'For the uninitiated, databases come in two varieties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，数据库有两种类型：
- en: '**Relational databases**: These use SQL (with minor variations) for querying
    the database'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系型数据库**：这些使用SQL（略有变化）来查询数据库'
- en: '**NoSQL databases**: These can store unstructured data and use the database
    specific query language'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NoSQL数据库**：这些可以存储非结构化数据并使用特定的数据库查询语言'
- en: Relational databases have been around for a long time now, and a lot of effort
    has been put into optimizing their performance and making them as robust as possible.
    However, the reliability and performance requires us to plan and organize our
    data into well-defined tables and relationships. Our data is bound to the schema
    of the database tables. Anytime we need to add more fields/columns to our table,
    we will have to migrate the table to a new schema, and this would require us to
    create migration scripts that take care of adding the new fields, and also to
    provide conditions and data to fill the newly created fields for the already existing
    rows in your table.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库已经存在很长时间了，人们已经付出了大量的努力来优化它们的性能，并使它们尽可能健壮。然而，可靠性和性能要求我们计划和组织我们的数据到定义良好的表和关系中。我们的数据受限于数据库表的模式。每当我们需要向我们的表中添加更多字段/列时，我们将不得不将表迁移到新的模式，并且这将要求我们创建迁移脚本来处理添加新字段，并且还要提供条件和数据来填充已存在的表中的新创建字段。
- en: NoSQL databases tend to have a more free-form structure. We need not define
    schemas for our tables since data is stored as a single row/document. We can insert
    data of any schema into a single table and then query it. Given that the data
    is not confined to schema rules, we might end up inserting wrong or ill-formed
    data into our database. This means that we will have to deal with ensuring that
    we retrieve the correct data and also have to take precautions to ensure that
    data of different schemas do not crash the program.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库往往具有更自由的结构。我们不需要为我们的表定义模式，因为数据存储为单行/文档。我们可以将任何模式的数据插入单个表中，然后对其进行查询。鉴于数据不受模式规则的限制，我们可能会将错误或格式不正确的数据插入到我们的数据库中。这意味着我们将不得不确保我们检索到正确的数据，并且还必须采取预防措施，以确保不同模式的数据不会使程序崩溃。
- en: Which type of database should we use?
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们应该使用哪种类型的数据库？
- en: At first, one might be tempted to go with NoSQL because then we don't need to
    worry about structuring our data and join queries. However, it is important to
    realize that, instead of writing these queries in SQL form, we will instead be
    retrieving all the data into the user space, that is, the program, and then write
    the manual join queries within the program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，人们可能会倾向于选择NoSQL，因为这样我们就不需要担心构造我们的数据和连接查询。然而，重要的是要意识到，我们将不再以SQL形式编写这些查询，而是将所有数据检索到用户空间，即程序中，然后在程序中编写手动连接查询。
- en: Instead, if we rely upon relational databases, we can be assured of smaller
    storage space, more efficient join queries, and data with well-defined schemas.
    All relational databases and some of the NoSQL databases provide indexing, which
    also helps in optimizing for faster search queries. However, one major drawback
    of relational databases with using tables and joins is that, as the data grows
    bigger, it is possible that the joins will start getting slower. By this point,
    you will have a clear idea of which parts of your data can take advantage of NoSQL
    solutions, and you will start maintaining your data in a combination of SQL and
    NoSQL system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们依赖关系数据库，我们可以确保更小的存储空间，更高效的连接查询，以及具有定义良好模式的数据。所有关系数据库和一些NoSQL数据库都提供索引，这也有助于优化更快的搜索查询。然而，使用表和连接的关系数据库的一个主要缺点是，随着数据的增长，连接可能会变得更慢。到这个时候，您将清楚地知道您的数据的哪些部分可以利用NoSQL解决方案，并且您将开始在SQL和NoSQL系统的组合中维护您的数据。
- en: In a nutshell, start with relational databases and, once you have a significant
    amount of data in your tables and no further database tuning can be done, then
    consider moving tables that really need the high performance of NoSQL datastores.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，从关系数据库开始，一旦表中有大量数据且无法进行进一步的数据库调优，那么考虑将确实需要NoSQL数据存储的表移动过去。
- en: Database replication
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据库复制
- en: 'Now that we have established why we are opting to use a relational database,
    let us move onto the next question: how can we ensure that our database doesn''t
    become a single point of failure?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了为什么选择使用关系数据库，让我们转向下一个问题：我们如何确保我们的数据库不会成为单点故障？
- en: 'Let us first consider what are the consequences if a database fails:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑如果数据库失败会有什么后果：
- en: We cannot write new data to the database
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法向数据库中写入新数据
- en: We cannot read from the database
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法从数据库中读取
- en: Of the two consequences, the latter is more critical. Consider our blogging
    application, while being able to write new blog posts is important, the vast majority
    of the users on our site will be readers. This is the norm for most everyday user-facing
    applications. Hence, we should try to ensure that we are always able to read data
    from the database even if we are no longer able to write new data to it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种后果中，后者更为关键。考虑我们的博客应用，虽然能够写新的博客文章很重要，但我们网站上绝大多数的用户将是读者。这是大多数日常用户界面应用的常态。因此，我们应该尽量确保我们总是能够从数据库中读取数据，即使我们不再能够向其中写入新数据。
- en: 'Database replication and redundancy try to address these issues and, generally,
    the solutions are included as part of the database or a plugin. In this section,
    we shall discuss three strategies used for database replication:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库复制和冗余性试图解决这些问题，通常解决方案作为数据库或插件的一部分包含在其中。在本节中，我们将讨论用于数据库复制的三种策略：
- en: Master-replica replication
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主-副本复制
- en: Master-master replication
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主-主复制
- en: Failover cluster replication
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障转移集群复制
- en: Master-replica replication
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主-副本复制
- en: 'This is the most straightforward method of replication. It can be explained
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最直接的复制方法。可以解释如下：
- en: 'We take a cluster of databases:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们采用数据库集群：
- en: '![](img/05818c20-497a-4808-b4cb-a9f2945a25cc.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05818c20-497a-4808-b4cb-a9f2945a25cc.png)'
- en: Cluster of databases
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库集群
- en: 'Designate one of them as the master, and the remaining databases as replicas:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中一个指定为主数据库，其余数据库为副本：
- en: '![](img/b380eeef-f090-425c-a3d2-7ed6a47bc54c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b380eeef-f090-425c-a3d2-7ed6a47bc54c.png)'
- en: DB-3 is designated as the master
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: DB-3被指定为主数据库
- en: 'All writes are performed to the master:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有写入都是在主数据库上执行的：
- en: '![](img/bd4944ec-aba0-413f-a338-a05e46b08a9b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4944ec-aba0-413f-a338-a05e46b08a9b.png)'
- en: Three writes are performed on the master
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库上执行三次写入
- en: 'All reads are performed from the replicas:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有读取都是从副本执行的：
- en: '>![](img/542a9156-003e-4c02-a8be-59d1ebd0b1de.png)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/542a9156-003e-4c02-a8be-59d1ebd0b1de.png)'
- en: Reads performed from the replicas
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从副本执行的读取
- en: 'The master ensures that all the replicas have the latest state which is the
    state of the master database:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主数据库确保所有副本都具有最新状态，即主数据库的状态：
- en: '![](img/4b07728c-7236-4a5f-a59d-89839bd3fbb6.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b07728c-7236-4a5f-a59d-89839bd3fbb6.png)'
- en: The master updates all the replicas with the latest update
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库将所有副本更新为最新更新
- en: 'Failure in master database still allows reads from replicant databases but
    writes are not possible:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主数据库故障仍允许从副本数据库读取，但不允许写入：
- en: '![](img/fd0bb311-32cb-47da-9bc6-ada8f6e5b8d9.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0bb311-32cb-47da-9bc6-ada8f6e5b8d9.png)'
- en: Master failure; no writes, only reads
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 主数据库故障；只读取，不写入
- en: Master-master replication
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主-主复制
- en: 'You may have noticed two issues with the master-replica setup:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到主-副本设置存在两个问题：
- en: The master is used extensively for database writes, and hence is under constant
    duress
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主数据库被广泛用于数据库写入，因此处于持续压力之下
- en: The issue of reads has been solved with replicas but the single point of failure
    for writes is still present
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本解决了读取的问题，但写入的单点故障仍然存在
- en: 'Master-master replication tries to solve these issues by making every database
    a master. It can be explained as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 主-主复制尝试通过使每个数据库成为主数据库来解决这些问题。可以解释如下：
- en: 'We take a cluster of databases:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们采用数据库集群：
- en: '![](img/adc01142-21d5-48a6-8e21-7b4b31c39aab.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adc01142-21d5-48a6-8e21-7b4b31c39aab.png)'
- en: Cluster of databases
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库集群
- en: 'We designate every database as a master:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个数据库指定为主数据库：
- en: '![](img/f97237e8-3f47-4085-8663-16ca50668ab0.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f97237e8-3f47-4085-8663-16ca50668ab0.png)'
- en: All databases are designated as a master
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据库都被指定为主数据库
- en: 'Reads can be performed from any of the masters:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以从任何主数据库执行读取：
- en: '![](img/04b29bf9-962f-48f5-86ed-d89509748c73.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04b29bf9-962f-48f5-86ed-d89509748c73.png)'
- en: Reads performed on masters
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在主数据库上执行读取
- en: 'Writes can be performed to any of the masters:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在任何主数据库上执行写入：
- en: '![](img/5509f284-1103-4d8b-a789-3aea941a01f1.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5509f284-1103-4d8b-a789-3aea941a01f1.png)'
- en: Writes made to DB-1 and DB-3
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 写入DB-1和DB-3
- en: 'Every master updates every other master with the writes:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个主数据库都使用写入更新其他主数据库：
- en: '![](img/6dfbc383-b6d5-4444-9e53-e19d58552f2c.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dfbc383-b6d5-4444-9e53-e19d58552f2c.png)'
- en: Database state synchronized across the masters
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库状态在主数据库之间同步
- en: 'Hence, the state is maintained across all the databases:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，状态在所有数据库中保持一致：
- en: '![](img/c78429cb-281f-4406-8e5d-2197b54b4e98.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c78429cb-281f-4406-8e5d-2197b54b4e98.png)'
- en: DB-1 failure, successful reads and writes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DB-1故障，成功读取和写入
- en: It may seem like this strategy works fine, but it has its own limitations and
    challenges; the major one being conflict resolution between writes. Here's a simple
    example.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略似乎运行良好，但它有自己的局限性和挑战；主要的问题是解决写入之间的冲突。这里有一个简单的例子。
- en: 'We have two master-master databases **DB-1** and**DB-2**,and both have the
    latest state of the database system:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个主-主数据库**DB-1**和**DB-2**，并且两者都具有数据库系统的最新状态：
- en: '![](img/ec564223-6449-4fd9-b4e3-ce86ad1af8bb.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec564223-6449-4fd9-b4e3-ce86ad1af8bb.png)'
- en: Latest state of DB-1 and DB-2
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: DB-1和DB-2的最新状态
- en: We have two simultaneous write operations to perform, so we send "Bob" to **DB-1**
    and "Alice" to **DB-2***.*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个同时进行的写操作，因此我们将“Bob”发送到**DB-1**，将“Alice”发送到**DB-2***.*
- en: '![](img/39c2dd82-bfa7-4a4b-a150-22b179f055fb.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39c2dd82-bfa7-4a4b-a150-22b179f055fb.png)'
- en: Write "Bob" to DB-1 and Write "Alice" to DB-2
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将“Bob”写入DB-1，将“Alice”写入DB-2
- en: 'Now that both databases have written the data to their tables, they need to
    update the other master with its own latest state:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个数据库都已将数据写入其表，它们需要使用自己的最新状态更新另一个主数据库：
- en: '![](img/cda8ddb8-8758-407a-bf96-0e99ed0d29c0.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda8ddb8-8758-407a-bf96-0e99ed0d29c0.png)'
- en: States before DB synchronization
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: DB同步之前的状态
- en: 'This will lead to conflict because in both tables, **ID# 3** is populated with **Bob** for
    **DB-1** and **Alice** for **DB-2**:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致冲突，因为在两个表中，**ID# 3**分别填充了**DB-1**的**Bob**和**DB-2**的**Alice**：
- en: '![](img/cd911985-d51b-40a7-be08-2cb8302b61b8.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd911985-d51b-40a7-be08-2cb8302b61b8.png)'
- en: Conflict while updating DB-1 and DB-2 states because ID# 3 is already populated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新DB-1和DB-2状态时发生冲突，因为ID# 3已经被填充。
- en: In reality, the master-master strategy would have in-built mechanisms to deal
    with these kinds of issues, but they may induce a performance penalty or other
    challenges. This is a complex subject and we have to decide on what trade-offs
    are worth making if we want to use master-master replication.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，主-主策略将具有内置机制来处理这类问题，但它们可能会导致性能损失或其他挑战。这是一个复杂的主题，我们必须决定在使用主-主复制时值得做出哪些权衡。
- en: Failover cluster replication
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故障转移集群复制
- en: Master-replica replication allows us to have a simple setup for reads and writes
    at the potential risk of being unable to write to the master database. Master-master
    replication allows us to be able to read and write to the database even if one
    of the masters fail. However, the complexity of maintaining a consistent state
    across all the masters and the possible performance penalty can mean that it is
    not the ideal choice in all circumstances.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 主-副本复制允许我们在潜在风险的情况下对读取和写入进行简单设置，无法写入主数据库。主-主复制允许我们在其中一个主数据库故障时能够读取和写入数据库。然而，要在所有主数据库之间保持一致状态的复杂性和可能的性能损失可能意味着它并不是在所有情况下的理想选择。
- en: 'The failover cluster replication tries to take the middle ground by providing
    features of both replication strategies. It can be explained as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 故障转移集群复制试图采取中间立场，提供两种复制策略的功能。可以解释如下：
- en: We take a cluster of databases.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们采用数据库集群。
- en: A database is assigned as the master depending on the master selection strategy
    used, which can vary from database to database.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据使用的主选择策略，将数据库分配为主数据库，这可能因数据库而异。
- en: The remaining databases are assigned as the replicas.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余数据库被分配为副本。
- en: The master is responsible for updating the replicas with the latest state of
    the database.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主服务器负责将副本更新为数据库的最新状态。
- en: If the master fails for some reason, a selection is made to assign one of the
    remaining databases as the new master.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果主服务器因某种原因失败，将选择将剩余的数据库之一指定为新的主数据库。
- en: 'So which replication strategy should we use? It would be best to start with
    the simplest one, that is, the master-replica strategy because this will cover
    most of initial needs with great ease. Let us now see what our application would
    look like if we used the master-replica strategy for database replication:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该使用哪种复制策略？最好从最简单的开始，也就是主-副本策略，因为这将非常轻松地满足大部分最初的需求。现在让我们看看如果我们使用主-副本策略进行数据库复制，我们的应用程序会是什么样子：
- en: '![](img/ffbc1129-0b4a-4b21-b1ec-d3ccb95e4879.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffbc1129-0b4a-4b21-b1ec-d3ccb95e4879.png)'
- en: An application with the master-replica database setup
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 具有主-副本数据库设置的应用程序
- en: Monolith versus microservices
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体架构与微服务
- en: 'Most of the new projects start out as a single codebase where all the components
    interact with one another via direct function calls. However, as the user traffic
    and codebase increases, we will start facing issues with the codebase. Here are
    a few possible reasons for this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新项目最初都是单一的代码库，所有组件通过直接函数调用相互交互。然而，随着用户流量和代码库的增加，我们将开始面临代码库的问题。以下是可能的原因：
- en: Your codebase is growing in size and this means that it will take longer for
    any new developer to understand the complete system.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码库正在不断增长，这意味着任何新开发人员理解完整系统将需要更长的时间。
- en: Adding a new feature will take longer because we have to make sure that the
    change doesn't break any of the other components.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新功能将需要更长时间，因为我们必须确保更改不会破坏任何其他组件。
- en: 'Redeploying code for every new feature might become cumbersome because of the
    following:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于以下原因，为每个新功能重新部署代码可能会变得繁琐：
- en: Deployment failed and/or
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署失败和/或
- en: One of the redeployed components had an unexpected bug which crashed the program
    and/or
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新部署的组件出现了意外的错误，导致程序崩溃和/或
- en: The build process may take longer because of a large number of tests
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于测试数量较多，构建过程可能需要更长时间
- en: Scaling the complete application to support a CPU intensive component
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将完整应用程序扩展以支持CPU密集型组件
- en: 'Microservices provide a solution to this by splitting up the major components
    of the application into separate smaller applications/services. Does this mean
    we should split our application from the start into microservices so that we don''t
    face this issue? That is one possible way of approaching this subject. However,
    there are certain drawbacks to this approach as well:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过将应用程序的主要组件拆分为单独的较小的应用程序/服务来解决这个问题。这是否意味着我们应该从一开始就将我们的应用程序拆分成微服务，以便我们不会面临这个问题？这是一种可能的处理方式。然而，这种方法也有一定的缺点：
- en: '**Too many moving parts**: Dividing each component into its own service means
    that we will have to monitor and maintain servers for each of them.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动部件过多**：将每个组件分成自己的服务意味着我们必须监视和维护每个组件的服务器。'
- en: '**Increased complexity**: Microservices increase the number of possible reasons
    for failure. Failures in a monolith may be limited to the server(s) going down
    or issues with code execution. However, with a microservice we have to:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的复杂性**：微服务增加了失败的可能原因。单体架构中的故障可能仅限于服务器宕机或代码执行问题。然而，对于微服务，我们必须：'
- en: Identify which component's server(s) went down or
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别哪个组件的服务器宕机或
- en: 'If a component fails, identify the failing component and then further investigate
    whether the failure was due to:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个组件失败，识别失败的组件，然后进一步调查失败是否是由于：
- en: Faulty code or
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障代码或
- en: Due to failure in one of the dependant components
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于一个依赖组件的失败
- en: '**Harder to debug the whole system**: The increased complexity described in
    the preceding points makes it harder to debug the complete system.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个系统更难调试：前面描述的增加的复杂性使得调试完整系统变得更加困难。
- en: 'Now that we have seen some of the pros and cons of microservices and monolith
    architecture, which one is better? The answer should be fairly obvious by now:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了微服务和单体架构的一些优缺点，哪一个更好呢？答案现在应该是相当明显的：
- en: Small to medium-sized codebases benefit from the simplicity offered by a monolith
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小到中等规模的代码库受益于单体架构提供的简单性
- en: Large codebases benefit from the granular control offered by the microservices
    architecture
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型代码库受益于微服务架构提供的细粒度控制
- en: This means that we should design our monolith codebase with the expectation
    that it might eventually grow to a very large size, and then we will have to refactor
    it into microservices. In order to make the task of refactoring the codebase into
    microservices as effortless as possible, we should identify the possible components
    as early as possible, and implement the interaction between them and the rest
    of the code using the **Mediator design pattern**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该设计我们的单体代码库，预期它最终可能会增长到非常庞大的规模，然后我们将不得不将其重构为微服务。为了尽可能轻松地将代码库重构为微服务，我们应该尽早确定可能的组件，并使用**中介者设计模式**实现它们与代码的其他部分之间的交互。
- en: Mediator design pattern
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中介者设计模式
- en: Mediator acts as an intermediary between components in the code, and this leads
    to very loose coupling between various components. This allows us to make minimal
    changes to the code, as we only need to change the interaction between the mediator
    and the component which is being extracted into its own microservice.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者充当代码中各个组件之间的中间人，这导致各个组件之间的耦合非常松散。这使我们可以对代码进行最小的更改，因为我们只需要更改中介者与被提取为自己的微服务的组件之间的交互。
- en: Let's look at an example. We have a monolith, which is defined by **Codebase
    A**. It consists of five components—**Component 1** through **Component 5**. We
    realize that **Component 1** and **Component 2** rely on interacting with **Component
    5**, while **Component 2** and **Component 3** rely on **Component 4**. If **Component
    1** and **Component 2** were to directly call **Component 5**, and similarly **Component
    2** and **Component 4** were to directly call **Component 4**, then we would create
    tightly coupled components.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子。我们有一个由 **Codebase A** 定义的单体应用。它由五个组件组成——**Component 1** 到 **Component
    5**。我们意识到 **Component 1** 和 **Component 2** 依赖于与 **Component 5** 交互，而 **Component
    2** 和 **Component 3** 依赖于 **Component 4**。如果 **Component 1** 和 **Component 2**
    直接调用 **Component 5**，同样 **Component 2** 和 **Component 4** 直接调用 **Component 4**，那么我们将创建紧密耦合的组件。
- en: 'If we were to introduce a function that takes input from the calling components
    and calls the necessary component as a proxy, and if all data were passed using
    well-defined structs, then we would have introduced the mediator design pattern.
    This can be seen in the following figure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们引入一个函数，该函数从调用组件接收输入并调用必要的组件作为代理，并且所有数据都使用明确定义的结构传递，那么我们就引入了中介者设计模式。这可以在下图中看到：
- en: '![](img/805a38af-f4cb-437e-95c5-0aaad75e2466.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/805a38af-f4cb-437e-95c5-0aaad75e2466.png)'
- en: Components within a codebase connected via the mediator
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过中介者连接的代码库中的组件
- en: 'Now if a situation arises where we might need to separate one of the components
    into its own separate microservices, we only need to change the implementation
    of the proxy function. In our example, `Component 5` is segregated into its own
    separate microservice, and we have changed the implementation of the proxy function
    **mediator 1** to communicate with **Component 5** using HTTP and JSON instead
    of communicating via function calls and structs. This is illustrated in the following
    figure:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果出现需要将其中一个组件分离成自己独立的微服务的情况，我们只需要改变代理函数的实现。在我们的例子中，`Component 5` 被分离成了自己独立的微服务，并且我们已经改变了代理函数
    **mediator 1** 的实现，以使用 HTTP 和 JSON 与 **Component 5** 进行通信，而不是通过函数调用和结构体进行通信。如下图所示：
- en: '![](img/3aeaa9a3-9b0c-4c7a-8831-29fc0e08ad24.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aeaa9a3-9b0c-4c7a-8831-29fc0e08ad24.png)'
- en: Component separated into a microservice and the change in the mediator implementation
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 组件分离成微服务和中介者实现的更改
- en: Deployment options
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署选项
- en: We have looked at various strategies for scaling our application, different
    types of databases, how to structure our code, and finally how to use the mediator
    pattern to make the transition from monolith to microservices. However, we haven't
    discussed where we would be deploying said web application and databases. Let's
    take a brief look at the deployment landscape.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了各种扩展应用程序的策略、不同类型的数据库、如何构建我们的代码，最后是如何使用中介者模式来实现从单体应用到微服务的过渡。然而，我们还没有讨论我们将在哪里部署所述的
    Web 应用程序和数据库。让我们简要地看一下部署的情况。
- en: Till the early 2000s, most servers were deployed on hardware owned by the companies
    writing the software. There would be dedicated infrastructure and a team to deal
    with this critical part of software engineering. This was mostly the subject of
    data centers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 2000 年代初，大多数服务器都部署在由编写软件的公司拥有的硬件上。会有专门的基础设施和团队来处理这个软件工程的关键部分。这在很大程度上是数据中心的主题。
- en: However, in the 2000s, companies began to realize that data centers could be
    abstracted away because most of the developers weren't interested in handling
    these problems. This allowed for cheaper and faster development and deployment
    of software, especially for web applications. Now, instead of buying hardware
    and space at a data center, the developers would be provided with server instances
    they could access via SSH. One of the most prominent companies in this field from
    the start was Amazon.com, Inc. This allowed them to expand their business beyond
    e-commerce.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 2000 年代，公司开始意识到数据中心可以被抽象化，因为大多数开发人员对处理这些问题并不感兴趣。这使得软件的开发和部署变得更加便宜和快速，特别是对于
    Web 应用程序。现在，开发人员不再购买数据中心的硬件和空间，而是可以通过 SSH 访问服务器实例。在这方面最著名的公司之一是亚马逊公司。这使他们的业务扩展到了电子商务之外。
- en: 'These services also gave rise to the question: do developers need to install
    and maintain generic applications such as databases, load balancers, or other
    such services? The reality was that not all developers or companies wanted to
    be involved with maintaining these services. This created demand for ready-to-use
    application instances that would be maintained by the company selling these applications
    as a service.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务也引发了一个问题：开发人员是否需要安装和维护诸如数据库、负载均衡器或其他类似服务的通用应用程序？事实是，并非所有开发人员或公司都希望参与维护这些服务。这导致了对现成应用实例的需求，这些实例将由销售这些应用作为服务的公司进行维护。
- en: There are many companies which initially started out as software companies that
    maintained their own data centers—Amazon, Google, and Microsoft to name a few
    examples—and they now boast a great set of such services for general consumption.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多最初作为软件公司开始并维护自己数据中心的公司——例如亚马逊、谷歌和微软等等——他们现在为一般消费者提供了一系列这样的服务。
- en: Maintainability of multiple instances
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个实例的可维护性
- en: 'The availability of the mentioned services improve our life significantly yet
    there is a lot of complexity involved with maintaining a plethora of applications
    running across multiple server instances. For example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的服务的可用性显著改善了我们的生活，但在维护跨多个服务器实例运行的大量应用程序时涉及了许多复杂性。例如：
- en: How can we update the server instances without bringing down the whole service?
    Can this be done with less effort?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更新服务器实例而不使整个服务停机？这可以用更少的工作量完成吗？
- en: Is there a reliable way to scale our application (vertically and horizontally)
    with ease?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有没有一种可靠的方法可以轻松地扩展我们的应用程序（纵向和横向）？
- en: Given that all modern deployments make use of containers, we can make use of
    container orchestration software that helps with the maintainability issues. Kubernetes
    ([https://kubernetes.io/](https://kubernetes.io/)) and Mesos ([http://mesos.apache.org/](http://mesos.apache.org/))
    are examples of two such solutions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有现代部署都使用容器，我们可以利用容器编排软件来帮助解决可维护性问题。Kubernetes（[https://kubernetes.io/](https://kubernetes.io/)）和Mesos（[http://mesos.apache.org/](http://mesos.apache.org/)）是两种解决方案的例子。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took the example of a simple blogging application and showed
    how we can scale it to meet the demands of growing user traffic. We also looked
    at the complexity and strategies involved with scaling databases.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以一个简单的博客应用为例，展示了如何扩展以满足不断增长的用户流量的需求。我们还研究了扩展数据库涉及的复杂性和策略。
- en: We then took a brief look at how to architect our codebase and what the trade-offs
    are that we might need to consider. Finally, we looked at one approach to easily
    refactor our codebase from a monolith into microservices.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要介绍了如何设计我们的代码库以及我们可能需要考虑的权衡。最后，我们看了一种将代码库从单体架构轻松重构为微服务的方法。
