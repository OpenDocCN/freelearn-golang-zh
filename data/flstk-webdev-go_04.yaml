- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Serving and Embedding HTML Content
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务和嵌入 HTML 内容
- en: As we build on our foundations, it is important that we look at another aspect
    of processing HTTP user requests, routing. Routing is useful as it allows us to
    structure our application to handle different functionality for certain HTTP methods,
    such as a `GET` that can retrieve and a `POST` on the same route that can replace
    the data. This concept is the fundamental principle of designing a REST-based
    application. We’ll end the chapter by looking at how we can use the new `embed`
    directive introduced in Go version 1.16 to bundle our web app as a single self-contained
    executable. This chapter will provide us with the tools to handle user data and
    create the interface for the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们基础的构建，我们查看处理 HTTP 用户请求的另一个方面——路由。路由很有用，因为它允许我们根据不同的 HTTP 方法（如可以检索的 `GET`
    和可以在同一路由上替换数据的 `POST`）来组织我们的应用程序。这个概念是设计基于 REST 的应用程序的基本原则。我们将通过查看如何使用 Go 版本 1.16
    中引入的新 `embed` 指令将我们的 Web 应用程序打包为单个自包含的可执行文件来结束本章。本章将为我们提供处理用户数据和创建用户界面的工具。
- en: 'By the end of this chapter, you will have learned how static and dynamic content
    is served by the application. You will also have learned how to embed all the
    different assets (icons, `.xhtml`, `.css`, etc.) that will be served by the web
    application in the application using a single binary. In this chapter, we’ll cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会应用程序如何服务静态和动态内容。你还将学会如何使用单个二进制文件将所有不同的资产（图标、`.xhtml`、`.css` 等）嵌入到应用程序中，这些资产将由
    Web 应用程序提供。在本章中，我们将涵盖以下主题：
- en: Handling HTTP functions and Gorilla Mux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTTP 函数和 Gorilla Mux
- en: Rendering static and dynamic content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染静态和动态内容
- en: Using Go embed to bundle your content
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go embed 打包你的内容
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code for this chapter can be accessed at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码都可以在 [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04)
    上访问。
- en: Handling HTTP functions and Gorilla Mux
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 HTTP 函数和 Gorilla Mux
- en: 'When we look at the **Go standard library**, we can see that a lot of thought
    has gone into the **HTTP library**. You can check out the documentation for the
    Go standard library here: [https://pkg.go.dev/net/http](https://pkg.go.dev/net/http).
    However, we’ll cover the foundations and look at how we can build upon them. It’s
    interesting to Note that the Go standard library covers both client- and server-side
    implementations. We will only be focusing on the parts we require to serve content.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 **Go 标准库** 时，我们可以看到在 **HTTP 库** 上投入了大量的思考。你可以在这里查看 Go 标准库的文档：[https://pkg.go.dev/net/http](https://pkg.go.dev/net/http)。然而，我们将涵盖基础并探讨如何在此基础上构建。值得注意的是，Go
    标准库涵盖了客户端和服务器端的实现。我们只将关注我们需要的用于服务内容的部分。
- en: We will create a simple app that replies with `Hello, World`, as well as look
    at returning `POST` data once we have expanded our routes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，它将回复 `Hello, World`，同时在我们扩展了路由后，我们还将查看返回 `POST` 数据。
- en: Hello, World with defaults
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值下的 Hello, World
- en: 'The basic concepts of creating a server in **Golang** are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 **Golang** 服务器的基本概念如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see this code in the Git repository under the `library-mux` sub-folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Git 仓库的 `library-mux` 子目录下看到这段代码。
- en: 'How this works is we define a `handlerGetHelloWorld` handler function (row
    11) that is passed as a parameter to the `router.HandleFunc` function. The `HandleFunc`
    parameter requires a function parameter that has the following signature: `func(ResponseWriter`,
    `*Request`).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的：我们定义了一个 `handlerGetHelloWorld` 处理函数（第 11 行），并将其作为参数传递给 `router.HandleFunc`
    函数。`HandleFunc` 参数需要一个具有以下签名的函数参数：`func(ResponseWriter, *Request)`。
- en: The handler’s job is to take in a request type and a `ResponseWriter` and make
    a decision based on the request; that is, what to write to `ResponseWriter`. In
    our case, the `handlerGetHelloWorld` handler will send the `Hello, World` string
    as a response, using the `fmt.Fprintf(...)` function. The reason why it is possible
    for the response to be sent back is that the `http.ResponseWriter` implements
    the `Write()` function, which is used inside the `fmt.Fprintf(...)` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的任务是接收一个请求类型和一个`ResponseWriter`，并根据请求做出决定；也就是说，决定向`ResponseWriter`写入什么。在我们的例子中，`handlerGetHelloWorld`处理器将通过`fmt.Fprintf(...)`函数发送`Hello,
    World`字符串作为响应。之所以能够将响应发送回去，是因为`http.ResponseWriter`实现了`Write()`函数，该函数在`fmt.Fprintf(...)`函数内部使用。
- en: 'We now define the following steps for the main function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为主函数定义以下步骤：
- en: 'First, we create a router: this is what our handlers will connect to. We create
    our own router with `NewServeMux` (line 43). We could use the `DefaultServeMux`
    found in the default library, but as you will see at [https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334](https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334),
    it contains a few additional debugging endpoints that we may not want to expose
    publicly. By registering our own, we gain more control and can add the same endpoints
    ourselves if we want them.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个路由器：这是我们处理器将要连接的。我们通过`NewServeMux`（第43行）创建我们自己的路由器。我们也可以使用默认库中找到的`DefaultServeMux`，但正如你将在[https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334](https://github.com/golang/go/blob/5ec87ba554c2a83cdc188724f815e53fede91b66/src/expvar/expvar.go#L334)中看到的那样，它包含了一些我们可能不想公开的额外调试端点。通过注册我们自己的，我们可以获得更多的控制权，并且如果我们想要的话，可以自己添加相同的端点。
- en: Second, we create an instance of our server and bind it to an available port.
    The `Addr` field on the server specifies the address and port to bind to. In our
    example, we are using `9002`. Different operating systems have different restrictions
    on what port can be used. For example, Linux systems only allow the admin or root
    user to run applications that use ports between `1` and `1023`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们创建我们的服务器实例并将其绑定到一个可用的端口。服务器上的`Addr`字段指定了要绑定的地址和端口。在我们的例子中，我们使用的是`9002`。不同的操作系统对可用的端口有不同的限制。例如，Linux系统只允许管理员或root用户运行使用`1`到`1023`之间端口的程序。
- en: The final step is to attach our router, start the server, and get it to begin
    listening. This is accomplished in line 57\. What we’re doing here is telling
    the router that when it gets any HTTP request for `"/"`, known as the document
    root, it should handle the request by passing it to our handler.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将我们的路由器附加到服务器上，启动服务器，并让它开始监听。这是在第57行完成的。我们在这里告诉路由器，当它收到对`"/"`的任何HTTP请求，即文档根时，应该通过传递给我们的处理器来处理这个请求。
- en: 'The final function, `srv.ListenAndServe()` (line 59), is a blocking function
    that starts our server up and starts listening for incoming requests on the server’s
    defined port. When a valid HTTP request is found, it is passed to the `"/"`, then
    our handler is invoked. We can run our app and visit `http://localhost:9002/`;
    we should be met with the following response from the server:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数，`srv.ListenAndServe()`（第59行），是一个阻塞函数，它启动我们的服务器并开始在服务器定义的端口上监听传入的请求。当找到有效的HTTP请求时，它会被传递到`"/"`，然后我们的处理器被调用。我们可以运行我们的应用程序并访问`http://localhost:9002/`；我们应该收到服务器以下响应：
- en: '![Figure 4.1 – Hello, World from Go!](img/Figure_4.1_B18295.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – Go的“Hello, World!”](img/Figure_4.1_B18295.jpg)'
- en: Figure 4.1 – Hello, World from Go!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – Go的“Hello, World!”
- en: It’s good to note here that each request is given its own goroutine to execute
    concurrently, and each request’s life cycle is managed by the server so we don’t
    need to do anything explicitly to leverage this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里值得注意的一点是，每个请求都会被分配一个自己的goroutine来并发执行，并且每个请求的生命周期由服务器管理，因此我们不需要做任何显式操作来利用这一点。
- en: In the next section, we will explore building different functionalities using
    `GET` and `POST`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨使用`GET`和`POST`构建不同的功能。
- en: Building on the basics with Gorilla Mux
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Gorilla Mux的基础上构建基础知识
- en: Gorilla Mux, accessible at [https://github.com/gorilla/mux](https://github.com/gorilla/mux),
    is a subproject of the **Gorilla project**. Gorilla Mux is an *HTTP request multiplexer*
    that makes it easy to match different handlers with matching incoming requests.
    Developers gain a lot of benefits from using the library, as it makes writing
    lots of boilerplate code unnecessary. The library provides advanced capabilities
    to match requests based on different criteria, such as schemes and dynamic URLs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可在 [https://github.com/gorilla/mux](https://github.com/gorilla/mux) 访问的 Gorilla
    Mux 是 **Gorilla 项目** 的一个子项目。Gorilla Mux 是一个 *HTTP 请求多路复用器*，它使得匹配不同的处理器与匹配的传入请求变得容易。开发者通过使用这个库可以获得很多好处，因为它使得编写大量的样板代码变得不再必要。该库提供了基于不同标准（如方案和动态
    URL）匹配请求的高级功能。
- en: The server and router provided as part of Go’s standard library are incredibly
    powerful for “freebies”, but we’re going to look at adding Gorilla Mux to our
    project and some of the benefits it provides.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供的服务器和路由器对于“免费”来说非常强大，但我们将看看如何将 Gorilla Mux 添加到我们的项目中，以及它提供的一些好处。
- en: Uses of the web consist of more than just returning *Hello World*, and generally,
    most web apps accept data provided by users, update the data, and even delete
    the data, and this is possible because the browser accepts a variety of content
    such as images, video, data fields, and plain text. The previous exercise focused
    on what is known as a `GET` method, which is the default sent when you load a
    page in your web browser, but there are many more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的使用不仅仅局限于返回 *Hello World*，通常，大多数网页应用接受用户提供的数据，更新数据，甚至删除数据，这是可能的，因为浏览器接受各种内容，如图片、视频、数据字段和纯文本。之前的练习专注于所谓的
    `GET` 方法，这是在您的网页浏览器中加载页面时默认发送的方法，但还有更多。
- en: 'The standard library implementation makes it easy to explicitly handle other
    types of methods, such as `GET`, `POST`, `PUT`, `DELETE`, and more, which are
    defined in the HTTP standard. This is typically done in the handler function as
    we can see below:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库实现使得显式处理其他类型的方法变得容易，例如 `GET`、`POST`、`PUT`、`DELETE` 等，这些方法在 HTTP 标准中定义。这通常在处理器函数中完成，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s look at an example of how we can separate two handlers, `GET` and `POST`,
    and some of the helpers provided by Gorilla Mux:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，说明我们如何将两个处理器，`GET` 和 `POST`，以及 Gorilla Mux 提供的一些辅助工具分开：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ve imported the Gorilla Mux library as `mux` and set up two different handlers:
    `handlerGetHelloWorld` (line 24) and `handlerPostEcho` (line 32). `handlerGetHelloWorld`
    is the same handler we defined in the previous example that responds with *Hello,
    World*. Here, thanks to the extended functionality of the router, we’ve specified
    explicitly that the handler can only resolve if the user performs a `GET` method
    on the `"/"` endpoint (line 74).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将 Gorilla Mux 库导入为 `mux` 并设置了两个不同的处理器：`handlerGetHelloWorld`（第 24 行）和 `handlerPostEcho`（第
    32 行）。`handlerGetHelloWorld` 是我们在上一个例子中定义的相同处理器，它响应 *Hello, World*。在这里，多亏了路由器的扩展功能，我们明确指定了处理器只能在用户对
    `"/"` 端点执行 `GET` 方法时解析（第 74 行）。
- en: 'Let’s start the sample by first changing to the `chapter4/gorilla-mux` directory
    and running the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从首先切换到 `chapter4/gorilla-mux` 目录并运行以下命令开始样本：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use cURL, which is a standard utility available on Windows (use cmd
    instead of PowerShell) and installed by default on Linux (depending on your Linux
    distribution) and macOS. The tool allows users to make HTTP requests from a terminal
    without using a browser. Use the `curl localhost:9002` command in a separate terminal
    to test whether the server is up and running:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 cURL，这是一个在 Windows 上可用的标准实用工具（使用 cmd 而不是 PowerShell），在 Linux（取决于您的 Linux
    发行版）和 macOS 上默认安装。这个工具允许用户在终端中发出 HTTP 请求，而无需使用浏览器。在单独的终端中使用 `curl localhost:9002`
    命令来测试服务器是否正在运行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that `GET` works as expected but using `-X DELETE` to tell cURL to
    use the `HTTP DELETE` method results in no content being returned. Under the hood,
    the endpoint is responding with a `405 Method Not Allowed` error message. The
    405 error message reported to the user comes from the library by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `GET` 正常工作，但使用 `-X DELETE` 来告诉 cURL 使用 `HTTP DELETE` 方法会导致没有内容返回。在底层，端点正在响应一个
    `405 Method Not Allowed` 错误消息。默认情况下，报告给用户的 405 错误消息来自库。
- en: We’ve added a second handler (line 75) to take data from a `POST` request. The
    handler for the `POST` method, `handlerPostEcho` (line 32), performs in a similar
    manner to the `GET` request, but we’ve added some additional code to read the
    user-provided data, store it, print it, and then return it unaltered.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了第二个处理器（第75行），用于从`POST`请求中获取数据。`POST`方法的处理器`handlerPostEcho`（第32行）的行为与`GET`请求类似，但我们添加了一些额外的代码来读取用户提供的输入数据，存储它，打印它，然后返回未修改的数据。
- en: 'We can see how this works using cURL as before:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用cURL来查看这是如何工作的，就像之前一样：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’re skipping a lot of validation and explicitly checking/handling data formats,
    such as JSON, at this point, but we’ll build towards this in later sections.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们跳过了很多验证，并且明确地检查/处理数据格式，例如JSON，但我们将在后面的章节中逐步实现这一点。
- en: 'Another benefit of using Gorilla Mux is how easy it makes pattern matching
    in paths. These path variables, or `slugs`, are defined using the `{name}` format
    or `{name:pattern}`. The following table shows different `slugs` with examples:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux的另一个好处是它使得路径模式匹配变得非常容易。这些路径变量或`slugs`使用`{name}`格式或`{name:pattern}`定义。以下表格展示了不同的`slugs`及其示例：
- en: '| `/``books/{pagetitle}/page/{pageno}` | `/``books/mytitle/page/1, /books/anothertitle/page/100`
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `/books/{pagetitle}/page/{pageno}` | `/books/mytitle/page/1, /books/anothertitle/page/100`
    |'
- en: '| `/``posts/{slug}` | /posts/titlepage/posts/anothertitle |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `/posts/{slug}` | /posts/titlepage/posts/anothertitle |'
- en: 'Pattern can be a type of regular expression. For example, in our sample code
    we added a `handlerSlug` handler (line 15) to perform a simple capture. We can
    use cURL to test this, as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可以是正则表达式的一种类型。例如，在我们的示例代码中，我们添加了一个`handlerSlug`处理器（第15行）来执行简单的捕获。我们可以使用cURL来测试这一点，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this section, we have learned how to write handlers and use them with Gorilla
    Mux. We have also looked at configuring Gorilla Mux to handle dynamic paths that
    will be processed by handlers. In the next section, we will look at serving content
    to users from our application. The served content will contain static and dynamic
    content.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何编写处理器并使用Gorilla Mux。我们还探讨了如何配置Gorilla Mux来处理由处理器处理的动态路径。在下一节中，我们将探讨如何从我们的应用程序向用户提供内容。提供的内容将包含静态和动态内容。
- en: Rendering static content
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染静态内容
- en: In this section, we will learn how to serve the web pages we have created as
    static content. We will use the standard Go `net/http` package to serve up the
    web pages. All the code and HTML files can be found inside the `static/web` directory
    ([https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将我们创建的网页作为静态内容提供。我们将使用标准的Go `net/http`包来提供网页服务。所有代码和HTML文件都可以在`static/web`目录内找到（[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/static/web)）。
- en: 'Execute the server using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令执行服务器：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will see the following message on the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在屏幕上看到以下消息：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open your browser and enter `http://localhost:3333` as the URL. You will see
    the login page, as shown in *Figure 4**.2*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的浏览器，输入`http://localhost:3333`作为URL。您将看到如图*图4.2*所示的登录页面：
- en: '![Figure 4.2 – The login page](img/Figure_4.2_B18295.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 登录页面](img/Figure_4.2_B18295.jpg)'
- en: Figure 4.2 – The login page
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 登录页面
- en: 'To access the dashboard page, you can use the URL `http://localhost:3333/dashboard.xhtml`.
    You will see like the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问仪表盘页面，您可以使用URL `http://localhost:3333/dashboard.xhtml`。您将看到如下截图：
- en: '![ Figure 4.3 – The dashboard page](img/Figure_4.3_B18295.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 仪表盘页面](img/Figure_4.3_B18295.jpg)'
- en: Figure 4.3 – The dashboard page
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 仪表盘页面
- en: 'Let’s take a quick look at the code that serves up the static pages:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下提供静态页面的代码：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As can be seen, this is a simple HTTP server that uses the `http.FileServer(..)`
    Go standard library function (shown in line 9). The function is called by passing
    in the `(./static)` parameter to the directory that we want to serve (line 9).
    The example code can be found inside the `chapter4/static/web/static` folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，这是一个简单的HTTP服务器，它使用了Go标准库中的`http.FileServer(..)`函数（在第9行显示）。该函数通过传递`(./static)`参数到我们想要提供服务的目录（第9行）来调用。示例代码可以在`chapter4/static/web/static`文件夹内找到。
- en: Rendering dynamic content
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染动态内容
- en: 'Now that we understand how to serve static content using the `net/http` package,
    let’s take a look at adding some dynamic content using Gorilla Mux found here:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic).
    Execute the server using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用 `net/http` 包提供静态内容，让我们看看如何添加一些动态内容，使用的是在这里找到的 Gorilla Mux：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter04/dynamic)。使用以下命令执行服务器：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Launch your browser and enter `http://localhost:3333` as the address; you will
    see a login screen similar to the static content. Perform the following steps
    on the login screen:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 启动浏览器并输入 `http://localhost:3333` 作为地址；你将看到一个与静态内容相似的登录界面。在登录界面上执行以下步骤：
- en: Enter any combination of username and password on the login screen.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录界面上输入任意用户名和密码组合。
- en: Click the `Login` button.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `登录` 按钮。
- en: You will get a **Login unsuccessful** message, as shown in *Figure 4**.4*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到一个 **登录失败** 的消息，如图 *4**.4* 所示。
- en: '![ Figure 4.4 – Message screen after login](img/Figure_4.4_B18295.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 登录后的消息屏幕](img/Figure_4.4_B18295.jpg)'
- en: Figure 4.4 – Message screen after login
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 登录后的消息屏幕
- en: We have introduced dynamic content for our login operation, which means the
    application will serve pages based on certain conditions, in this case, the successful
    validation of the username/password combination. To achieve a successful validation,
    enter `admin/admin` as the username/password combination, as this exists in the
    database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为登录操作引入了动态内容，这意味着应用程序将根据某些条件提供页面，在这种情况下，是用户名/密码组合的成功验证。为了成功验证，请输入 `admin/admin`
    作为用户名/密码组合，因为这在数据库中存在。
- en: 'Let’s explore the code a bit further to understand how it works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探索代码，以了解它是如何工作的：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ServeHTTP` function (line 19) serves the content specified by the directory
    defined in the `staticHandler` struct (line 65), which points to the `static`
    directory with the index page showing as `index.xhtml`. The handler configuration
    is registered using the Gorilla Mux attached to the `/` path prefix (line 66).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServeHTTP` 函数（第19行）负责根据在 `staticHandler` 结构体（第65行）中定义的目录指定的内容提供服务，该结构体指向包含索引页面
    `index.xhtml` 的 `static` 目录。处理器的配置是通过附加到 `/` 路径前缀的 Gorilla Mux 注册的（第66行）。'
- en: The next part is the code that takes care of the registration of the `/login`
    endpoint (line 63). The `postHandler` function (line 34) extracts and validates
    the username and password information passed from the request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是处理 `/login` 端点注册的代码（第63行）。`postHandler` 函数（第34行）从请求中提取并验证用户名和密码信息。
- en: The web page contains two input elements, the username and password, which are
    sent by the browser when the user clicks on the `ParseForm()` function (line 36)
    and then extracts the value passed by referencing the field names `username` and
    `password` (line 38), which corresponds to the name of the HTML element specified
    inside the file in `chapter04/dynamic/static/index.xhtml`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 网页包含两个输入元素，即用户名和密码，当用户点击 `ParseForm()` 函数（第36行）时，浏览器会发送这些元素，然后通过引用字段名 `username`
    和 `password`（第38行）提取传递的值，这些字段名对应于 `chapter04/dynamic/static/index.xhtml` 文件内指定的
    HTML 元素名称。
- en: On completing the validation process, the app then uses the Go `html/template`
    package (line 44) to parse another HTML file (`static/tmpl/msg.xhtml`). The app
    will parse the HTML file and will insert all the relevant information to be included
    as part of the HTML page using the `template.Must` function (line 51).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 完成验证过程后，应用程序随后使用 Go 的 `html/template` 包（第44行）解析另一个 HTML 文件（`static/tmpl/msg.xhtml`）。应用程序将解析
    HTML 文件，并使用 `template.Must` 函数（第51行）将所有相关信息插入到 HTML 页面中。
- en: 'This `msg.xhtml` file contains a `{{.}}` placeholder string that is understood
    by the `html/template` package (line 18):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `msg.xhtml` 文件包含一个 `{{.}}` 占位符字符串，该字符串被 `html/template` 包（第18行）理解：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this section, we have learned how to render dynamic content. In the next
    section, we will look at bundling both our static and dynamic content to allow
    us to run the application as a single file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何渲染动态内容。在下一节中，我们将查看如何捆绑我们的静态和动态内容，以便我们可以作为一个单独的文件运行应用程序。
- en: Using Go embed to bundle your content
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go embed 打包你的内容
- en: 'In this section, we will look at how to package applications into a single
    binary. Packaging everything the application needs into a single binary makes
    it easier to deploy the application anywhere in the cloud. We are going to use
    the `embed` package that is provided by the *Go standard library*. The following
    link provides further detail on the different functions available inside the embed
    package: [https://pkg.go.dev/embed](https://pkg.go.dev/embed).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何将应用程序打包成一个单独的二进制文件。将应用程序所需的所有内容打包成一个二进制文件，使其更容易在云中的任何地方部署。我们将使用由
    *Go 标准库* 提供的 `embed` 包。以下链接提供了关于 embed 包内不同函数的更多详细信息：[https://pkg.go.dev/embed](https://pkg.go.dev/embed)。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The embed package is only available in Go version 1.16 and upwards.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: embed 包仅在 Go 版本 1.16 及以上版本中可用。
- en: 'The following code provides a simple example of using the embed package in
    three different ways – to embed a specific file, embed the full contents of a
    folder, and embed a specific file type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码提供了一个使用 embed 包的简单示例，以三种不同的方式——嵌入特定文件、嵌入文件夹的全部内容以及嵌入特定文件类型：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The source code resides inside the `chapter4/embed` folder. The code uses the
    `//go:embed` directive (lines 19, 22, and 25). This tells the compiler that the
    `version string` (line 20) will get the content from `version/version.txt`, which
    contains the version information that we want to display to the user.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码位于 `chapter4/embed` 文件夹中。代码使用 `//go:embed` 指令（第 19、22 和 25 行）。这告诉编译器 `version
    string`（第 20 行）将从 `version/version.txt` 获取内容，其中包含我们想要向用户显示的版本信息。
- en: We also declare the `//go:embed` directive telling the compiler that we want
    to include everything inside the `static/` (line 22) and `tmpl/` (line 25) folders.
    During the compilation process, the compiler detects the preceding directives
    and automatically includes all the different files into the binary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了 `//go:embed` 指令，告诉编译器我们想要包含 `static/`（第 22 行）和 `tmpl/`（第 25 行）文件夹中的所有内容。在编译过程中，编译器检测到前面的指令，并自动将所有不同的文件包含到二进制文件中。
- en: The `tmpl` directory contains the template that will render dynamic content,
    and since we have embedded it into the binary, we need to use a different way
    to render it (line 56). The new `renderFiles` function uses the `template.ParseFS`
    function (line 57), which renders the template declared in the `tmplEmbed` variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpl` 目录包含将渲染动态内容的模板，由于我们已经将其嵌入到二进制文件中，我们需要使用不同的方式来渲染它（第 56 行）。新的 `renderFiles`
    函数使用 `template.ParseFS` 函数（第 57 行），它渲染 `tmplEmbed` 变量中声明的模板。'
- en: The `renderFiles` function is called from the `postHandler` function (line 77),
    passing in the template name and other parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderFiles` 函数是从 `postHandler` 函数（第 77 行）调用的，传递模板名称和其他参数。'
- en: 'Now, this time when building our application, the final executable file contains
    the different files (HTML, CSS, etc.) in a single file. We can now compile the
    application, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建应用程序时，最终的可执行文件包含不同的文件（HTML、CSS 等）在一个文件中。我们现在可以编译应用程序，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will generate an executable file – for example, in Linux, it will be called
    `embed` and in Windows, it will be called `embed.exe`. Next, run the application
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个可执行文件——例如，在 Linux 中，它将被称为 `embed`，在 Windows 中，它将被称为 `embed.exe`。接下来，按照以下方式运行应用程序：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open your browser and go to `http://localhost:3333/`. It should look the same
    as before, except that everything is being retrieved via `embed.FS`. You now have
    a fully embedded application that can be deployed as a single binary in the cloud.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并访问 `http://localhost:3333/`。它应该看起来和之前一样，只是所有内容都是通过 `embed.FS` 获取的。现在你拥有了一个完全嵌入的应用程序，它可以作为一个单独的二进制文件在云端部署。
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This pretty big chapter served as our first look at interacting with user-provided
    data and handling web requests. We’ve seen how we can add RESTful endpoints using
    the Go standard library and have learned how we can use the utility functions
    of Gorilla Mux to quickly add more power and functionality to our application.
    We’ve also explored the different ways we can handle requests. In one method,
    we can now utilize Go’s `html/template` library to dynamically create content
    and package it as a directory read from disk. Alternatively, we can use the new
    Go `e``mbed` directive to give us a single binary that packages up all our assets
    and makes for simple deployments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容相当丰富，它作为我们首次了解与用户提供的数据进行交互和处理Web请求的起点。我们看到了如何使用Go标准库添加RESTful端点，并学习了如何利用Gorilla
    Mux的实用函数快速为我们的应用程序添加更多功能和强大功能。我们还探索了处理请求的不同方法。在一种方法中，我们现在可以利用Go的`html/template`库动态创建内容并将其打包为从磁盘读取的目录。或者，我们可以使用新的Go
    `embed`指令来获得一个包含所有资源的单个二进制文件，从而实现简单的部署。
- en: In the next chapter, we will look at adding middleware to help process the request
    pipeline and introduce security to ensure that content can be accessed securely.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何添加中间件以帮助处理请求管道，并引入安全机制以确保内容可以安全访问。
