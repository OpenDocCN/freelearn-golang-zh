- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Securing the Backend and Middleware
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护后端和中间件
- en: In previous chapters, we learned how to build our database, run our web application
    as a server, and serve dynamic content. In this chapter, we will discuss security
    – in particular, we will look at securing the web app. Security is a vast topic
    so for this chapter, we will just look at the security aspects that are relevant
    to our application. Another topic that we will look at is middleware and using
    it as part of our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何构建我们的数据库，以服务器形式运行我们的Web应用程序，并服务动态内容。在本章中，我们将讨论安全性——特别是，我们将查看如何保护Web应用程序。安全性是一个广泛的话题，所以对于本章，我们只会查看与我们的应用程序相关的安全方面。我们还将探讨的另一个主题是中间件以及将其作为我们应用程序的一部分使用。
- en: Middleware is software that is introduced into an application to provide generic
    functionality that is used for incoming and outgoing traffic in our application.
    Middleware makes it easy to centralize features that are used across different
    parts of our applications, and this will be discussed more in upcoming sections
    of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一种软件，它被引入到应用程序中以提供通用的功能，这些功能用于我们应用程序的入站和出站流量。中间件使得在不同部分的应用程序中集中使用功能变得容易，这将在本章的后续部分中进一步讨论。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: Adding middleware
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加中间件
- en: Adding cookies and sessions with Redis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis添加cookies和会话
- en: Upon completing this chapter, you will have learned how to set up a user database
    and add authentication to the app. We will also learn about middleware and how
    to add it to an existing app. Lastly, you will learn about cookies, storing information
    in sessions, and using Redis as persistence storage for these sessions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将学习如何设置用户数据库并为应用添加身份验证。我们还将了解中间件以及如何将其添加到现有应用中。最后，您将学习关于cookies、在会话中存储信息以及使用Redis作为这些会话的持久化存储。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code explained in this chapter can be checked out at [https://github.com/PacktPublishing/Becoming-a-Full-Stack-Go-Developer/tree/main/Chapter05](https://github.com/PacktPublishing/Becoming-a-Full-Stack-Go-Developer/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有源代码都可以在[https://github.com/PacktPublishing/Becoming-a-Full-Stack-Go-Developer/tree/main/Chapter05](https://github.com/PacktPublishing/Becoming-a-Full-Stack-Go-Developer/tree/main/Chapter05)中找到。
- en: Adding authentication
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加身份验证
- en: Building the application requires some consideration in terms of designing the
    application, and one of the key pieces that needs to be thought of ahead of time
    is security. There are many facets of security but in this section of our application,
    we will look at authentication.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序需要在设计应用程序时进行一些考虑，并且需要提前考虑的关键部分之一是安全性。安全性有许多方面，但在这个应用程序的部分，我们将查看身份验证。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Authentication is the process of validating that a user is who they claim to
    be.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是验证用户是否是他们所声称的过程。
- en: 'To add authentication to our app, we will need to store the user information
    in the database first. The user information will be used to authenticate the user
    before using the application. The database user table can be found inside the
    `db/schema.sql` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的应用添加身份验证，我们首先需要在数据库中存储用户信息。用户信息将用于在使用应用程序之前验证用户。数据库用户表可以在`db/schema.sql`文件中找到：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following table outlines the data types that are used for the user table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下表概述了用于用户表的数据类型：
- en: '| `BIGSERIAL` | An auto-incrementing data type that is normally used as a primary
    key. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `BIGSERIAL` | 一种自动递增的数据类型，通常用作主键。|'
- en: '| `TEXT` | A variable-length character string. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `TEXT` | 可变长度的字符字符串。|'
- en: '| `JSONB` | The JSON binary data type is suitable for JSON data. The database
    provides this data type to make it easier to index, parse, and query JSON data
    directly. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `JSONB` | JSON二进制数据类型适合JSON数据。数据库提供此数据类型以使其更容易索引、解析和直接查询JSON数据。|'
- en: '| `TIMESTAMP` | A date and time data type. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `TIMESTAMP` | 日期和时间数据类型。|'
- en: '| `BOOLEAN` | A logical data type that contains true or false. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `BOOLEAN` | 包含真或假的逻辑数据类型。|'
- en: The authentication will be performed by checking the `User_Name` and `Pass_Word_Hash`
    fields. One thing to note – the `Pass_Word_Hash` field contains an encrypted password,
    and we will look further into encrypting the password a bit later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证将通过检查`User_Name`和`Pass_Word_Hash`字段来执行。有一点需要注意——`Pass_Word_Hash`字段包含一个加密密码，我们将在稍后进一步探讨加密密码。
- en: 'As discussed in [*Chapter 1*](B18295_01.xhtml#_idTextAnchor016), *Building
    the Database and Model*, we are using sqlc to generate the Go code that will talk
    to the database. To generate the Go code, execute the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 [*第1章*](B18295_01.xhtml#_idTextAnchor016) 中讨论的，*构建数据库和模型*，我们正在使用 sqlc 生成与数据库通信的
    Go 代码。要生成 Go 代码，请执行以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code that will read the user information will be stored under the `gen/query.sql_gen.go`
    file as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将读取用户信息的代码将存储在 `gen/query.sql_gen.go` 文件中，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `GetUserByName` function queries the database by calling the `QueryRowContext()`
    function, passing in the query that we want to use, which is defined as shown
    here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUserByName` 函数通过调用 `QueryRowContext()` 函数查询数据库，传递我们想要使用的查询，该查询定义如下：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The query uses the `WHERE` clause and expects one parameter, which is the `user_name`
    field. This is populated by passing the `userName` parameter into the `QueryRowContext()`
    function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 查询使用了 `WHERE` 子句，并期望一个参数，即 `user_name` 字段。这是通过将 `userName` 参数传递给 `QueryRowContext()`
    函数来填充的。
- en: We will look at how to create a dummy user when we start the application in
    the next section. A dummy user is a user that is normally used for testing purposes
    – in our case, we want to create a dummy user to test the authentication process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨在启动应用程序时如何创建虚拟用户。虚拟用户通常用于测试目的的用户 - 在我们的案例中，我们想要创建一个虚拟用户来测试身份验证过程。
- en: Creating our dummy user
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的虚拟用户
- en: 'Our database is empty so we will need to populate it with a dummy user and
    in this section, we will look at how to create one. We will add code to create
    a dummy user when the application starts up. The following function inside `main.go`
    creates the dummy user, and this user will be used to log in to the application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库是空的，因此我们需要用虚拟用户来填充它。在本节中，我们将探讨如何创建一个虚拟用户。当应用程序启动时，我们将添加代码来创建虚拟用户。`main.go`
    中的以下函数创建虚拟用户，该用户将用于登录应用程序：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the application starts up it will first check whether an existing test
    user exists and if none exists, it will automatically create one. This is put
    inside the application to make it easier for us to test the application. The `createUserDb()`
    function uses the `CreateUsers()` generated sqlc function to create the user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，它将首先检查是否存在现有的测试用户，如果不存在，它将自动创建一个。这是放在应用程序中，以便我们更容易测试应用程序。`createUserDb()`
    函数使用生成的 sqlc 函数 `CreateUsers()` 来创建用户。
- en: 'One of the things you will notice is the password is created by the following
    code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到密码是通过以下代码片段创建的：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The password is passed to a `HashPassword` function that will return a hashed
    version of the clear text password.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 密码被传递给 `HashPassword` 函数，该函数将返回明文密码的哈希版本。
- en: 'The `HashPassword` function uses the Go `crypto` or `bcrypt` standard libraries
    that provide a function to return a hash of a plain string as shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashPassword` 函数使用了 Go 的 `crypto` 或 `bcrypt` 标准库，这些库提供了一个函数来返回一个普通字符串的哈希值，如下所示：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The hash generated from the string password will be different whenever the `bcrypt.GenerateFromPassword`
    function is called. The `GenerateFromPassword()` function uses the standard cryptography
    library to generate the hash value of the password.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串密码生成的哈希值，每次调用 `bcrypt.GenerateFromPassword` 函数时都会不同。`GenerateFromPassword()`
    函数使用标准密码学库来生成密码的哈希值。
- en: Cryptography is the practice of ensuring text messages are converted into a
    form that is not easy to read or deconstruct. This provides data security to make
    it hard to deconstruct what the data is all about. Go provides a standard library
    that provides cryptography functions, which is available in the `golang.org/x/crypto`
    package. The `crypto` library provides a number of cryptography functions that
    you can choose from – it all depends on what you need for your application. In
    our example, we use `bcrypt`, which is a password-hashing function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是将文本消息转换为不易阅读或分解的形式的实践。这提供了数据安全，使得很难分解数据的内容。Go 提供了一个标准库，该库提供了密码学函数，这些函数可在
    `golang.org/x/crypto` 包中使用。`crypto` 库提供了一系列密码学函数，您可以根据应用程序的需求进行选择。在我们的示例中，我们使用了
    `bcrypt`，这是一个密码哈希函数。
- en: Now that we have added a function to create a dummy user in the database, in
    the next section, we will look at how to authenticate with the database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个在数据库中创建虚拟用户的功能，在下一节中，我们将探讨如何与数据库进行身份验证。
- en: Authenticating a user
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户身份验证
- en: 'User authentication is simple, as the application will use the function generated
    by sqlc, as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证很简单，因为应用程序将使用 sqlc 生成的函数，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `GetUserByName` function is used, with the username passed as a parameter
    to obtain the user information. Once that has been retrieved successfully, it
    will check whether the password is correct by calling `CheckPasswordHash`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUserByName` 函数用于通过将用户名作为参数传递来获取用户信息。一旦成功检索到信息，它将通过调用 `CheckPasswordHash`
    来检查密码是否正确。'
- en: The `CheckPasswordHash` function uses the same `crypto` or `bcrypt` package
    and it calls the `CompareHashAndPassword` function, which will compare the hashed
    password with the password sent by the client. The function returns `true` if
    the password matches.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckPasswordHash` 函数使用相同的 `crypto` 或 `bcrypt` 包，并调用 `CompareHashAndPassword`
    函数，该函数将哈希密码与客户端发送的密码进行比较。如果密码匹配，函数返回 `true`。'
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `validateUser` function will return `true` if the username and password
    combination exists in the database and is correct.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateUser` 函数将在用户名和密码组合存在于数据库且正确时返回 `true`。'
- en: Start your application and navigate your web browser to `http://127.0.0.1:3333/`
    and you should see a login prompt. Try logging in with incorrect credentials before
    entering `user@user / password` – you should now be sent to the successful login
    screen! Congratulations – you successfully authenticated!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的应用程序，并在 Web 浏览器中导航到 `http://127.0.0.1:3333/`，您应该会看到一个登录提示。在输入 `user@user
    / password` 之前，尝试使用错误的凭据登录 – 您现在应该被发送到成功的登录屏幕！恭喜 – 您成功认证了！
- en: In the next section, we will look at middleware, what it is, and how to add
    it to our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨中间件，它是什么，以及如何将其添加到我们的应用程序中。
- en: Adding middleware
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加中间件
- en: Middleware is a piece of code that is configured as an HTTP handler. The middleware
    will pre-process and post-process the request, and it sits between the main Go
    server and the actual HTTP handlers that have been declared.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一段配置为 HTTP 处理器的代码。中间件将预处理和后处理请求，并位于主 Go 服务器和已声明的实际 HTTP 处理器之间。
- en: Adding middleware as part of our application helps take care of tasks that are
    outside of the main application features. Middleware can take care of authentication,
    logging, and rate limiting, among other things. In the next section, we will look
    at adding a simple logging middleware.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将中间件作为我们应用程序的一部分添加有助于处理主要应用程序功能之外的任务。中间件可以处理身份验证、日志记录和速率限制等任务。在下一节中，我们将探讨添加简单的日志中间件。
- en: Basic middleware
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本中间件
- en: 'In this section, we are going to add a simple basic middleware to our application.
    The basic middleware is shown in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的应用程序添加一个简单的基本中间件。基本中间件的代码片段如下：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Gorilla Mux makes it incredibly easy to use our middleware. This is done by
    exposing a function on the router called `Use()`, which is implemented with a
    variadic number of parameters that can be used to stack multiple pieces of middleware
    to be executed in order:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla Mux 使得使用我们的中间件变得非常容易。这是通过在路由器上公开一个名为 `Use()` 的函数来完成的，该函数通过可变数量的参数实现，可以用来堆叠多个中间件以按顺序执行：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code snippet shows how we implement the `Use()` function to register
    the middleware:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何实现 `Use()` 函数以注册中间件：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`mux.MiddwareFunc` is simply a type alias for `func(http.Handler) http.Handler`
    so that anything that meets that interface can work.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`mux.MiddlewareFunc` 简单地是 `func(http.Handler) http.Handler` 的类型别名，这样任何满足该接口的东西都可以工作。'
- en: 'To see our function in action, we simply call `router.Use()`, pass in our middleware,
    navigate to our web app, and there we can see that it is called:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的函数如何工作，我们只需调用 `router.Use()`，传入我们的中间件，导航到我们的 Web 应用程序，在那里我们可以看到它被调用：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You may be wondering why you can see it being called multiple times with different
    paths – the reason is that when requesting our app, it’s performing a number of
    `GET` requests for the numerous hosted resources. Each of these is passing through
    our middleware as shown in *Figure 5**.1*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么您可以看到它被多次以不同的路径调用 – 原因是当请求我们的应用程序时，它正在执行针对大量托管资源的多个 `GET` 请求。这些请求中的每一个都像
    *图 5**.1* 中所示的那样通过我们的中间件：
- en: '![Figure 5.1 – Request passing through middleware](img/Figure_5.01_B18295.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 请求通过中间件传递](img/Figure_5.01_B18295.jpg)'
- en: Figure 5.1 – Request passing through middleware
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 请求通过中间件传递
- en: The `handlers` library – available at [https://github.com/gorilla/handlers](https://github.com/gorilla/handlers)
    – contains many other useful middleware methods and we’ll be using some of them
    later, including the `handlers.CORS()` middleware to allow us to handle **Cross-Origin
    Resource Sharing** (**CORS**). We will look at CORS and using this middleware
    in more detail in [*Chapter 9*](B18295_09.xhtml#_idTextAnchor184), *Tailwind,
    Middleware,* *and CORS.*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`handlers` 库（可在 [https://github.com/gorilla/handlers](https://github.com/gorilla/handlers)
    找到）包含许多其他有用的中间件方法，我们将在稍后使用其中一些，包括 `handlers.CORS()` 中间件，允许我们处理**跨源资源共享**（**CORS**）。我们将在第
    9 章[*Tailwind, Middleware,* 和 CORS.*](B18295_09.xhtml#_idTextAnchor184)中更详细地探讨
    CORS 和使用此中间件。'
- en: In this section, we learned about middleware, the different functionality that
    it can provide, and how to add it to an app. In the next section, we will look
    at session handling and using cookies to track user information as they use the
    application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了中间件，它可以提供的不同功能，以及如何将其添加到应用程序中。在下一节中，我们将探讨会话处理和使用 cookies 跟踪用户信息，当他们使用应用程序时。
- en: Adding cookies and sessions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 cookies 和会话
- en: In this section, we are going to take a look at how we are going to keep track
    of the users when using our application. We are going to take a look at session
    management and how it can help our application understand whether a user is allowed
    to access our application. We are also going to take a look at cookies, which
    are a session management tool that we are going to use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在使用我们的应用程序时如何跟踪用户。我们将探讨会话管理以及它如何帮助我们的应用程序理解用户是否有权访问我们的应用程序。我们还将探讨
    cookies，这是我们将要使用的会话管理工具。
- en: The session management discussed in this chapter is part of the Gorilla project,
    which can be found at [https://github.com/gorilla/sessions](https://github.com/gorilla/sessions).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的会话管理是 Gorilla 项目的组成部分，该项目可在 [https://github.com/gorilla/sessions](https://github.com/gorilla/sessions)
    找到。
- en: Cookies and session handling
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cookies 和会话处理
- en: In this section, we are going to look at session handling and how to use it
    to store information relevant to a particular user. The web as we know is stateless
    in nature, which means that requests are not actually tied to any other previous
    requests. This makes it hard to know which requests belong to which user. Hence,
    the need arises to keep track of this and store information about the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨会话处理以及如何使用它来存储与特定用户相关的信息。我们所知的网络在本质上是无状态的，这意味着请求实际上并没有与任何其他之前的请求绑定。这使得很难知道哪些请求属于哪个用户。因此，需要跟踪这一点并存储有关用户的信息。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A web session is used to facilitate interaction between users and the different
    services that are used in the sequence of requests and responses. The session
    is unique to a particular user.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 网络会话用于促进用户与在请求和响应序列中使用的不同服务之间的交互。会话对特定用户是唯一的。
- en: Sessions are stored in memory, with each session belonging to a particular user.
    Session information will be lost if the application stops running or when the
    application decides to remove the session information. There are different ways
    to store session information permanently in storage to be used at a future time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 会话存储在内存中，每个会话属于特定用户。如果应用程序停止运行或应用程序决定删除会话信息，会话信息将会丢失。有不同方法可以将会话信息永久存储在存储中，以便在未来使用。
- en: '*Figure 5**.2* shows the high-level flow of how a session is created and used
    for each incoming request. New sessions are created when one does not exist and
    once one is made available, the application can use it to store relevant user
    information.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5**.2* 展示了会话创建和使用的高级流程，用于每个传入的请求。当不存在会话时，将创建新的会话，一旦会话可用，应用程序就可以使用它来存储相关的用户信息。'
- en: '![Figure 5.2 – Session check flow](img/Figure_5.02_B18295.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 会话检查流程](img/Figure_5.02_B18295.jpg)'
- en: Figure 5.2 – Session check flow
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 会话检查流程
- en: We know that a session is used to store user-specific information – the question
    is how the application knows which session to use for which user. The answer is
    a key that is sent back and forth between the application and the browser. This
    key is called a session key, which is added to the cookie header as shown in *Figure
    5**.3*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道会话用于存储特定用户的信息——问题是应用程序如何知道为哪个用户使用哪个会话。答案是应用程序和浏览器之间来回发送的一个密钥。这个密钥被称为会话密钥，如
    *图 5**.3* 所示，它被添加到 cookie 标头中。
- en: '![Figure 5.3 – Cookie containing a session token](img/Figure_5.03_B18295.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 包含会话令牌的 cookie](img/Figure_5.03_B18295.jpg)'
- en: Figure 5.3 – Cookie containing a session token
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 包含会话令牌的cookie
- en: As seen in *Figure 5**.3*, the cookie with the `session_token` label contains
    the key that will be sent back to the server to identify the user stored in the
    session. *Figure 5**.3* shows the developer console of the browser. For Firefox,
    you can open it using the **Tools** > **Web Developer** > **Web Developer Tool**
    menu, and if you are using Chrome, you can access it using *Ctrl* + *Shift* +
    *J*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5**.3*所示，带有`session_token`标签的cookie包含将发送回服务器以识别存储在会话中的用户的键。*图5**.3*显示了浏览器的开发者控制台。对于Firefox，您可以通过**工具**
    > **Web开发者** > **Web开发者工具**菜单打开它，如果您使用的是Chrome，您可以通过*Ctrl* + *Shift* + *J*访问它。
- en: 'The following snippet shows the `sessionValid` function, which checks whether
    the incoming request contains a valid `session_token` key. The `store.Get` function
    will automatically create a new one if an existing session is not available for
    the current user:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`sessionValid`函数，该函数检查传入的请求是否包含有效的`session_token`键。如果当前用户没有可用的现有会话，`store.Get`函数将自动创建一个新的会话：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once the application finds a session for the user, it will check the authentication
    status of the user as shown here. The session information is stored as a map,
    and the map type stores information as key and value, so in our case, we are checking
    whether the session contains the `authenticated` key:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序找到用户的会话，它将检查用户的认证状态，如下所示。会话信息存储为映射，映射类型以键值对的形式存储信息，因此在我们的情况下，我们正在检查会话是否包含`authenticated`键：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If there is a failure to obtain the `authenticated` key, the application will
    automatically redirect the request to display the login page as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在获取`authenticated`键时出现失败，应用程序将自动将请求重定向到显示登录页面，如下所示：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have learned about sessions and how we can use them to check whether a user
    has been authenticated. We will explore this further.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了会话以及如何使用它们来检查用户是否已认证。我们将进一步探讨这个问题。
- en: Storing session information
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储会话信息
- en: In the previous section, we learned about sessions and cookie handling. In this
    section, we will look at how to store session information pertaining to the user.
    The information stored inside the session is stored in the server memory, which
    means that this data will be temporarily available as long as the server is still
    running. Once the server stops running, all the data stored in memory will not
    available anymore. This is why we will look at persisting the data in a separate
    storage system in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了会话和cookie处理。在本节中，我们将探讨如何存储与用户相关的会话信息。存储在会话中的信息存储在服务器内存中，这意味着只要服务器仍在运行，这些数据将临时可用。一旦服务器停止运行，存储在内存中的所有数据将不再可用。这就是为什么我们将在下一节中探讨如何在单独的存储系统中持久化数据。
- en: In our sample application, we are storing information on whether the user has
    been authenticated successfully. Users are allowed to access other parts of the
    application only when they have been successfully authenticated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用程序中，我们存储有关用户是否成功认证的信息。只有当用户成功认证后，他们才能访问应用程序的其他部分。
- en: 'Run the sample application and open your browser in private mode (Firefox)
    or incognito mode (Chrome) and type `http://localhost:3333/dashboard.xhtml` as
    the address. The application will redirect you to the login page because the session
    does not exist. The operation to check for the existence of the `authenticated`
    key is performed inside the `storeAuthenticated` function shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例应用程序，并在私密模式（Firefox）或隐身模式（Chrome）下打开您的浏览器，将`http://localhost:3333/dashboard.xhtml`作为地址输入。由于会话不存在，应用程序将重定向您到登录页面。检查`authenticated`键存在性的操作是在以下所示的`storeAuthenticated`函数中执行的：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `session.Save` function saves the session into memory after creating the
    `authenticated` key with a new value pass as part of the function call.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`session.Save`函数在创建带有新值作为函数调用一部分的`authenticated`键后，将会话保存到内存中。'
- en: Using Redis for a session
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Redis进行会话
- en: As discussed in the previous section, the sessions are stored in memory. In
    this section, we will look at storing the session information permanently using
    Redis. The code samples for this section can be found at [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter05-redis](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter05-redis).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，会话存储在内存中。在本节中，我们将探讨使用Redis永久存储会话信息。本节的代码示例可以在[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter05-redis](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter05-redis)找到。
- en: 'The reason why we want to use Redis is because of its simplicity in terms of
    data storage, only containing key values. It also can be configured for both in-memory
    and permanent external storage. For our application, we will need to configure
    `redis` to store information on the disk to make it permanent. Execute the following
    `make` command to run `redis`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用Redis的原因是因为它在数据存储方面的简单性，只包含键值。它还可以配置为内存和永久外部存储。对于我们的应用程序，我们需要配置`redis`以将信息存储在磁盘上，使其永久化。执行以下`make`命令以运行`redis`：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the full Docker command used to run `redis`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行`redis`时使用的完整Docker命令：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The command runs `redis` using Docker and specifies the `redisdata` local directory
    as the location of the permanent file storage for the data. To run the sample
    application, make sure you also run `postgres` using this command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用Docker运行`redis`，并将`redisdata`本地目录指定为数据永久文件存储的位置。要运行示例应用程序，请确保您还使用以下命令运行`postgres`：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once both `redis` and `postgres` are up and running, you can now run the sample
    app and use the web application. The following code snippet shows the `initRedis()`
    function, which takes care of initializing Redis. The function uses two different
    packages, which you can find at [https://github.com/redis/go-redis](https://github.com/redis/go-redis)
    and [https://github.com/rbcervilla/redisstore](https://github.com/rbcervilla/redisstore).
    The `go-redis/redis` package contains the driver and API to communicate with Redis
    while `rbcervilla/redisstore` contains a simple API to read, write, and delete
    data from Redis:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`redis`和`postgres`都启动并运行，现在您可以运行示例应用程序并使用Web应用程序。以下代码片段显示了`initRedis()`函数，该函数负责初始化Redis。该函数使用两个不同的包，您可以在[https://github.com/redis/go-redis](https://github.com/redis/go-redis)和[https://github.com/rbcervilla/redisstore](https://github.com/rbcervilla/redisstore)找到。`go-redis/redis`包包含与Redis通信的驱动程序和API，而`rbcervilla/redisstore`包含一个简单的API，用于从Redis读取、写入和删除数据：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the initialization has been completed, the `store` variable will be used
    to write data to and read it from Redis. Inside the `gorilla` library, the `sessions`
    package automatically uses the configured `client` object to handle all writing
    and reading of information to and from `redis`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，`store`变量将用于向Redis写入数据并从中读取。在`gorilla`库中，`sessions`包自动使用配置的`client`对象来处理所有向Redis写入和读取信息。
- en: 'A new additional handler is added to allow the user to log out from the application
    as shown in the handler snippet here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的处理程序，允许用户从应用程序中注销，如处理程序片段所示：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The logout operation is done by setting the `Options.MaxAge` field for a session.
    This indicates to the library that the next time the same `session_token` is passed
    to the server, it is considered an invalid/expired session and it will redirect
    to the login page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注销操作是通过设置会话的`Options.MaxAge`字段来完成的。这表示当相同的`session_token`下次传递给服务器时，它被视为无效/过期的会话，并将重定向到登录页面。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about a few new things that can help our application
    better. We learned how to add an authentication layer to our application to secure
    it, which helps protect our application from being accessed anonymously. We also
    looked at adding middleware to our application and showed how easy it was to add
    different middleware to our application without changing much code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了一些可以帮助我们应用程序更好地新事物。我们学习了如何向应用程序添加认证层以保护它，这有助于保护我们的应用程序免受匿名访问。我们还探讨了向应用程序添加中间件，并展示了如何轻松地向应用程序添加不同的中间件而无需更改太多代码。
- en: Lastly, we looked at session handling and learned how to use it to track user
    information and a user’s journey with our application. Since session handling
    is not stored permanently, we looked at using the `redis` data store to store
    the user session information, which allows the application to remember user information
    anytime the application is restarted.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了会话处理，并学习了如何使用它来跟踪用户信息和用户与我们的应用程序的旅程。由于会话处理不会永久存储，我们研究了使用`redis`数据存储来存储用户会话信息，这使得应用程序能够在应用程序重启时随时记住用户信息。
- en: In the next chapter, we will look at writing code that will process information
    back and forth between the browser and our application. We will look at building
    a REST API that will be used to perform different operations on our data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨编写代码以在浏览器和我们的应用程序之间来回处理信息。我们将研究构建一个REST API，该API将用于对我们的数据进行不同的操作。
