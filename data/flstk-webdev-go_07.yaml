- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Frontend Frameworks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端框架
- en: In this chapter, we will take a high-level look at the current JavaScript frameworks
    available to modern web developers. We will compare some of the popular ones,
    Svelte, React, and Vue, before creating a simple app in Vue and ending by adding
    navigation using the popular Vue Router. This will lay the foundations needed
    to later talk to our API server from [*Chapter 6*](B18295_06.xhtml#_idTextAnchor093),
    *Moving* *to API-First*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从高层次的角度审视现代网络开发者可用的当前JavaScript框架。我们将比较一些流行的框架，如Svelte、React和Vue，然后在Vue中创建一个简单的应用，并以使用流行的Vue
    Router添加导航结束。这将为我们后来从[*第6章*](B18295_06.xhtml#_idTextAnchor093)，*转向API-First*时与API服务器通信奠定基础。
- en: 'Upon completion of this chapter, we will have covered the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成后，我们将涵盖以下内容：
- en: Understanding the difference between server-side rendering and single-page applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务器端渲染与单页应用之间的区别
- en: Looking at different frontend frameworks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看不同的前端框架
- en: Creating applications using the Vue framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Vue框架创建应用
- en: Understanding routing inside the Vue framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Vue框架中的路由
- en: This chapter paves the way to the land of the frontend. We will learn about
    the different parts of frontend development in this and the next chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为前端领域铺平了道路。在本章和下一章中，我们将学习前端开发的不同部分。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the source code used in this chapter can be checked out from [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有源代码都可以从[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Go/tree/main/Chapter07)中检出。
- en: Make sure you have all the necessary tools installed on your local machine by
    following the instructions from the Node.js documentation:[https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您已按照Node.js文档中的说明在本地机器上安装了所有必要的工具：[https://docs.npmjs.com/downloading-and-installing-node-js-and-npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)。
- en: Server-side rendering versus single-page apps
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染与单页应用
- en: In [*Chapter 4*](B18295_04.xhtml#_idTextAnchor053), *Serving and Embedding HTML
    Content*, we created our app as a server-side rendered app. What this means is
    that all of the content and assets, including the HTML, are generated on the backend
    and sent on each page request. There’s nothing wrong with this; our publisher,
    Packt, uses **server-side rendering** (**SSR**) for its own site at [https://www.packtpub.com/](https://www.packtpub.com/).
    SSR as a technique is used by technologies such as WordPress and many other sites
    that host content that changes less frequently and may have less interactivity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18295_04.xhtml#_idTextAnchor053)，*服务和嵌入HTML内容*中，我们将应用作为服务器端渲染应用创建。这意味着所有内容、资产，包括HTML，都是在后端生成的，并在每个页面请求时发送。这并没有什么问题；我们的出版商Packt在其[https://www.packtpub.com/](https://www.packtpub.com/)网站上使用**服务器端渲染**（**SSR**）。作为一项技术，SSR被WordPress和其他许多内容变化较少且可能交互性较低的网站所使用。
- en: The alternative to SSR we’re going to use for our app is **client-side rendering**
    (**CSR**). CSR works by having the client fetch the app as a *bundle* of JavaScript
    and other assets, executing the JavaScript and the app dynamically, and binding
    to an element that takes over the page rendering. The app creates and renders
    each route dynamically in the browser. This is all done without requiring any
    reloading of the bundle or content.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的应用使用的SSR（服务器端渲染）的替代方案是**客户端渲染**（**CSR**）。CSR通过客户端以JavaScript和其他资源的*包*的形式获取应用，动态执行JavaScript和应用，并将绑定到一个接管页面渲染的元素上。应用在浏览器中动态创建和渲染每个路由。这一切都是在不需要重新加载包或内容的情况下完成的。
- en: By moving to client-side rendering, it improves the app's interactivity and
    responsiveness by allowing it to manipulate the document model, fetch additional
    content and data via the API, and generally perform closer to what a user might
    expect from a desktop app without constant page reloads.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转向客户端渲染，它通过允许应用操作文档模型、通过API获取额外的内容和数据以及通常在不需要不断重新加载页面的情况下更接近用户可能从桌面应用中期望的性能来提高应用的用户交互性和响应性。
- en: When we talk about reactivity, we’re describing the situation in which changes
    in the application state are automatically reflected in the **document object
    model** (**DOM**). This is a key attribute of all of the frameworks we’ll be exploring
    in this chapter, including React, Vue, and Svelte.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论响应性时，我们描述的是应用程序状态变化自动反映在**文档对象模型**（**DOM**）中的情况。这是我们将要探索的所有框架的关键属性，包括 React、Vue
    和 Svelte。
- en: Introducing React, Vue, and more
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 React、Vue 以及更多
- en: If there’s one thing that the JavaScript community enjoys doing, it’s creating
    new frameworks!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JavaScript 社区喜欢做的事情有一件，那就是创建新的框架！
- en: We’re going to explore and contrast a few of the most popular ones and look
    at the common parts they all share and the main points of difference.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索和对比一些最受欢迎的框架，并查看它们共有的部分以及主要的不同点。
- en: React
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React
- en: React is one of the most popular JavaScript libraries available. It was created,
    and is still maintained, by Meta (formerly Facebook) and was inspired heavily
    by a predecessor used internally within Facebook for creating PHP components.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React 是可用的最受欢迎的 JavaScript 库之一。它由 Meta（前身为 Facebook）创建并维护，并且受到了 Facebook 内部用于创建
    PHP 组件的前任的极大启发。
- en: React uses the `.jsx` and `.vue` files, and build them into a final bundle that
    can be deployed as a static file. We’ll look at this in a later chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用 `.jsx` 和 `.vue` 文件，并将它们构建成一个最终包，可以部署为静态文件。我们将在后面的章节中探讨这一点。
- en: '![Figure 7.1: Modern JavaScript SPA build process](img/Figure_7.01_B18295.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：现代 JavaScript SPA 构建过程](img/Figure_7.01_B18295.jpg)'
- en: 'Figure 7.1: Modern JavaScript SPA build process'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：现代 JavaScript SPA 构建过程
- en: React is a very popular option for creating apps and one of its strengths is
    the fact that there are a number of different options to choose from when building
    your app, such as Redux, Flux, BrowserRouter, or React Router. This flexibility
    is great but can cause conflict and strong opinions on the “one true way.” The
    React team avoids this issue by continually calling out that React is a library,
    not a framework, so choosing the components of your app is down to the individual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: React 是创建应用程序的一个非常受欢迎的选择，其一个优势是在构建应用程序时有许多不同的选项可供选择，例如 Redux、Flux、BrowserRouter
    或 React Router。这种灵活性很好，但可能会导致冲突和关于“唯一正确的方法”的强烈观点。React 团队通过不断强调 React 是一个库而不是框架来避免这个问题，因此选择应用程序的组件取决于个人。
- en: React is similar to other frameworks in that it has a full life cycle model
    that can be “hooked” at runtime to override defaults (for example, `render` and
    `shouldComponentUpdate`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: React 与其他框架类似，它有一个完整的生命周期模型，可以在运行时“挂钩”以覆盖默认值（例如，`render` 和 `shouldComponentUpdate`）。
- en: Svelte
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Svelte
- en: Svelte straddles an interesting middle ground and is included as an alternative
    to the two heavy hitters of React and Vue. Svelte takes the approach of pushing
    more into the compilation step, removing the need for techniques such as diffing
    the virtual DOM to transpile the code into vanilla JavaScript. This approach means
    less work is done by the browser but it still has a similar build process to both
    React and Vue for building bundles. Svelte provides its own preferred router,
    called SvelteKit, but alternatives exist and Svelte can represent a nice, lightweight
    alternative to the others. Svelte is quite a new project when looking at the more
    established players and doesn’t have as many resources behind it, but it is still
    viable for smaller projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 处于一个有趣的中间位置，被包括作为 React 和 Vue 这两个重量级选手的替代品。Svelte 采用将更多内容推入编译步骤的方法，消除了需要像比较虚拟
    DOM 来将代码转换为纯 JavaScript 这样的技术。这种方法意味着浏览器需要做的工作更少，但它仍然具有与 React 和 Vue 类似的构建过程来构建包。Svelte
    提供了自己的首选路由器，称为 SvelteKit，但存在替代方案，Svelte 可以成为其他产品的轻量级替代品。从更成熟的参与者来看，Svelte 是一个相当新的项目，并且背后没有那么多资源，但它对于小型项目来说仍然是可行的。
- en: Vue
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue
- en: The final framework we’re going to introduce is Vue, which is what we use as
    our preferred framework for building our frontend application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一个框架是 Vue，这是我们用于构建前端应用程序的首选框架。
- en: The big appeal initially for me was the fact that the previous version of Vue
    (version 2) could be loaded and run directly via a **content domain network**
    (**CDN**), which made experimentation and prototyping incredibly easy back in
    2016 when it was first released.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，最初的最大吸引力是 Vue 的上一个版本（版本 2）可以通过**内容分发网络**（**CDN**）直接加载和运行，这使得在 2016 年首次发布时进行实验和原型设计变得极其容易。
- en: Vue offers a very familiar syntax that makes it easy to learn – it separates
    out the presentation from the logic and the styling, it’s very lightweight, and
    it uses the concept of **single-file** **components** (**SFCs**).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 提供了一种非常熟悉的语法，这使得它很容易学习——它将表示与逻辑和样式分离，非常轻量级，并且它使用了**单文件**组件（**SFCs**）的概念。
- en: The concept of SFC makes it incredibly easy to build simple, scoped components
    that can be reused from project to project without the addition of learning the
    “not-quite-JavaScript” JSX used by React.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: SFC 的概念使得构建简单、范围有限的组件变得极其容易，这些组件可以在项目之间重复使用，而无需学习 React 使用的“不太像 JavaScript”的
    JSX。
- en: 'The following code is a simple component that displays a greeting using the
    Options API. When Vue was first released, it used the Options API by default,
    but in later iterations, it has moved to include a newer Composition API, which
    we’ll explore later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的组件，它使用 Options API 显示问候语。当 Vue 首次发布时，它默认使用 Options API，但在后续版本中，它已经转向包括一个更新的
    Composition API，我们将在后面探讨：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Example of a** **SFC Greeter.vue**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**SFC Greeter.vue 的示例**'
- en: 'As you can see in the preceding code block, the approach of Vue’s SFC design
    has three parts: the HTML, the JavaScript, and the style (usually CSS, often “scoped”).
    This means you can combine the HTML`-esque` style of the `<template>` with small
    Vue-specific additions, such as `@click="functionName"`, to easily create our
    components. The `@click` annotation featured here, which looks close to HTML,
    is the syntax used by Vue to extend and bind HTML events to our objects – in this
    case, replacing the native `onClick` attribute.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码块所示，Vue 的 SFC 设计方法有三个部分：HTML、JavaScript 和样式（通常是 CSS，通常是“scoped”）。这意味着你可以将
    `<template>` 的 HTML 风格与小的 Vue 特定添加（如 `@click="functionName"`）结合起来，轻松创建我们的组件。这里使用的
    `@click` 注解，看起来接近 HTML，是 Vue 用于扩展并将 HTML 事件绑定到我们的对象的语法——在这种情况下，替换了原生的 `onClick`
    属性。
- en: The `<script>` contained instance includes a name; props, used to provide properties
    to the component from parents; `mounted()`, a function called when the component
    is first added to the DOM; components, that is, the components being imported
    for use by the component; assorted other methods; and finally, the `data()` object,
    which can hold our components' state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>` 中包含的实例包括一个名称；props，用于从父组件提供属性给组件；`mounted()`，当组件首次添加到 DOM 时调用的函数；components，即被导入供组件使用的组件；其他各种方法；最后是
    `data()` 对象，它可以保存我们组件的状态。'
- en: The final part of the SFC is the `<style>` part – we can specify non-CSS languages
    here. For example, we could use `lang="scss"` if we wanted to use SCSS rather
    than CSS. We can also add the `scoped` keyword, which means that Vue will use
    name mangling to ensure that our CSS styles are scoped only to this component
    instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SFC 的最后一部分是 `<style>` 部分——我们在这里可以指定非 CSS 语言。例如，如果我们想使用 SCSS 而不是 CSS，我们可以使用 `lang="scss"`。我们还可以添加
    `scoped` 关键字，这意味着 Vue 将使用名称混淆来确保我们的 CSS 样式仅限于这个组件实例。
- en: A final benefit of using Vue is the opinionated approach taken to build tools
    (preferring to create Vite, which leverages the incredibly fast esbuild to reduce
    bundle build times to milliseconds compared to the slower React), component layout,
    and routers (Vue Router), which we’ll explore in later chapters. The opinionated
    nature of Vue works nicely with the opinionated nature of Golang itself, which
    helps remove a lot of debate on which approach and components to choose to build
    your app, ensuring that when you bring in more team members and hand over your
    successful full stack app, you can be safe in the knowledge that another Vue developer
    wouldn’t argue with you on how you did it, nor on the technology chosen – mainly
    as they would’ve chosen the same!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue 的另一个好处是它对构建工具采取的具有意见的方法（更倾向于创建 Vite，它利用速度极快的 esbuild 来将包构建时间缩短到毫秒级，与较慢的
    React 相比），组件布局，以及路由器（Vue Router），我们将在后面的章节中探讨。Vue 的具有意见的性质与 Golang 本身的具有意见的性质很好地结合在一起，这有助于消除很多关于选择哪种方法和组件来构建你的应用的争论，确保当你引入更多团队成员并将你的成功的全栈应用交付出去时，你可以放心地知道另一个
    Vue 开发者不会与你争论你是如何做到的，也不会争论选择的技术——主要是因为他们也会选择同样的技术！
- en: So far in this section, we have looked at what the Vue framework is all about.
    In the next section, we will learn by creating some simple apps using the Vue
    framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们已经了解了 Vue 框架是什么。在下一节中，我们将通过创建一些简单的应用来学习 Vue 框架。
- en: Creating a Vue app
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Vue 应用
- en: In the previous section, we discussed different frontend frameworks, so for
    this section, we are going to try to use Vue to build our frontend. In this section,
    we will look at writing our UI in Vue and discuss how we migrate the login page
    to Vue. This section will not teach you how to use Vue but rather will look at
    the way we use Vue to write the frontend components for our sample application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了不同的前端框架，因此在本节中，我们将尝试使用Vue构建我们的前端。在本节中，我们将查看如何在Vue中编写我们的UI，并讨论如何将登录页面迁移到Vue。本节不会教你如何使用Vue，而是将查看我们使用Vue编写示例应用程序前端组件的方式。
- en: Application and components
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序和组件
- en: When writing software using Vue, the application will start up by creating an
    application instance. This instance is the main object in our Vue-based application.
    Once we have an instance, then we can start using components. Components are reusable
    UI pieces that contain three parts – a template (which is like HTML), styles,
    and JavaScript. Normally, when designing a frontend, we think about HTML elements
    – div, href, and so on – but now we need to think about components that contain
    all the different parts. *Figure 7**.2* shows an example of the login page that
    we rewrite using Vue.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Vue编写软件时，应用程序将通过创建应用程序实例来启动。这个实例是我们基于Vue的应用程序中的主要对象。一旦我们有一个实例，我们就可以开始使用组件。组件是可重用的UI部件，包含三个部分——模板（类似于HTML）、样式和JavaScript。通常，在设计前端时，我们会考虑HTML元素——div、href等——但现在我们需要考虑包含所有不同部分的组件。*图7.2*显示了使用Vue重写的登录页面示例。
- en: '![Figure 7.2: Vue-based login](img/Figure_7.02_B18295.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：基于Vue的登录](img/Figure_7.02_B18295.jpg)'
- en: 'Figure 7.2: Vue-based login'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：基于Vue的登录
- en: The concept of an application inside Vue can be thought of as a self-isolated
    container containing different components that can share data. Any web page can
    contain a number of applications displaying different kinds of data, and even
    if they are isolated, they can also share data if and when required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Vue内部应用程序的概念可以被视为一个包含不同组件的自隔离容器，这些组件可以共享数据。任何网页都可以包含多个应用程序，显示不同类型的数据，即使它们是隔离的，在需要时也可以共享数据。
- en: Login page using Vue
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vue的登录页面
- en: 'In this section, we will look at how we use the login page as is without converting
    it into a component and use it as a Vue application rendered by the browser. We
    need to install the dependencies first by running the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看如何直接使用登录页面，而不将其转换为组件，并作为浏览器渲染的Vue应用程序使用。我们首先需要通过运行以下命令安装依赖项：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will install all the different dependencies, including the `http-server`
    module, which we will be using to serve the login page. Start the server by running
    the following command, making sure you are inside the `chapter7/login` directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装所有不同的依赖项，包括我们将用于提供登录页面的`http-server`模块。通过运行以下命令启动服务器，确保你位于`chapter7/login`目录中：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You will see the output shown in *Figure 7**.3*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到*图7.3*中所示的输出：
- en: '![Figure 7.3: Serving using http-server](img/Figure_7.03_B18295.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：使用http-server提供服务](img/Figure_7.03_B18295.jpg)'
- en: 'Figure 7.3: Serving using http-server'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：使用http-server提供服务
- en: Open your browser and type http://127.0.0.1:3000/login.xhtml into the address
    bar, and you will see the login page.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器，在地址栏中输入http://127.0.0.1:3000/login.xhtml，你将看到登录页面。
- en: 'Let’s dig through the code and see how it works together. The following snippet
    inside `login.xhtml` shows the application initialization code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入代码，看看它是如何协同工作的。以下`login.xhtml`内部的代码片段显示了应用程序初始化代码：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code imports `createApp` from the Vue library and uses it to create an application
    that contains `data()` and `methods` used inside the page. The `data()` block
    declares the variables that will be used inside the page while `methods` contains
    functions used. The application is mounted into the element with the ID “app”
    app, in this case, the `<div>` with `id=app`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从Vue库中导入`createApp`，并使用它创建一个包含页面内使用的`data()`和`methods`的应用程序。`data()`块声明了页面内将使用的变量，而`methods`包含函数。应用程序被挂载到具有ID“app”的元素上，在这种情况下，是具有`id=app`的`<div>`。
- en: 'The following code snippet shows the part of the page that uses the data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了使用数据的页面部分：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The variable inside the curly brackets (`{{}}`) will be populated with the data
    defined previously when we initialize the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号内的变量（`{{}}`）将在初始化应用程序时填充之前定义的数据。
- en: 'The following code snippet shows the part of the page that uses the `handleSubmit`
    function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了使用`handleSubmit`函数的部分页面：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`@click` on the button element will trigger the function that was defined when
    creating the Vue application object, which will write to the console log the data
    in the username field.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮元素上点击`@click`将触发在创建Vue应用程序对象时定义的函数，该函数将把用户名字段中的数据写入控制台日志。
- en: Using Vite
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vite
- en: Referring back to *Figure 7**.1*, one of the parts of the build process is that
    of the bundler. In this section, we will look at Vite, which is a bundler for
    Vue. What is a bundler? It is a build tool that combines all your different assets
    (HTML, CSS, and so on) into one file, making it easy for distribution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*图7.1*，构建过程的一部分是打包器。在本节中，我们将查看Vite，它是Vue的打包器。什么是打包器？它是一个构建工具，将你所有的不同资产（HTML、CSS等）合并到一个文件中，使其易于分发。
- en: In the previous section, we linked to a CDN-hosted version of the Vue runtime.
    In this section, we’ll be using Vite to build our application and generate our
    bundled code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们链接到了一个由CDN托管的Vue运行时版本。在本节中，我们将使用Vite来构建我们的应用程序并生成我们的打包代码。
- en: Vite – French for “quick” – was built by the same team behind Vue itself and
    was designed to provide a faster development experience with extremely fast hot
    reload and combine it with a powerful build stage that transpiles, minifies, and
    bundles your code into optimized static assets ready for deployment. Refer back
    to *Figure 7**.1* to see all the stages used to build SPAs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Vite - 法语中意为“快速”，是由Vue本身的团队构建的，旨在提供更快的开发体验，具有极快的热重载，并将其与一个强大的构建阶段相结合，该阶段将转换、压缩和打包你的代码到优化的静态资产，以便部署。参考*图7.1*以查看构建SPAs所使用的所有阶段。
- en: In this section, we will look at writing our login page as a component and using
    it as a Vue application rendered by the browser. The code can be seen inside the
    `chapter7/npmvue` folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看如何将登录页面编写为组件，并使用它作为由浏览器渲染的Vue应用程序。代码可以在`chapter7/npmvue`文件夹中查看。
- en: 'Open your terminal and run the following commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的终端并运行以下命令：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the server is up and running, you will get the output shown in *Figure
    7**.4*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动并运行，你将看到*图7.4*所示的输出。
- en: '![Figure 7.4: Vite server output](img/Figure_7.04_B18295.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：Vite服务器输出](img/Figure_7.04_B18295.jpg)'
- en: 'Figure 7.4: Vite server output'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：Vite服务器输出
- en: 'Open the browser and access the login page by entering `http://localhost:3000`
    into the address bar. Let’s investigate further and look at how the code is structured.
    We will start by looking at the `index.xhtml` page, as shown in the following
    snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，在地址栏中输入`http://localhost:3000`以访问登录页面。让我们进一步调查并查看代码的结构。我们将从以下片段中查看`index.xhtml`页面：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding `index.xhtml` references the `main.js` script, which is how we
    inject the Vue initialization code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`index.xhtml`引用了`main.js`脚本，这是我们注入Vue初始化代码的方式。
- en: The `<div..>` declaration is where the application will be mounted when rendered
    in the browser, and the page also includes a script found in `src/main.js`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div..>`声明是当在浏览器中渲染时应用程序将被挂载的位置，页面还包括在`src/main.js`中找到的脚本。'
- en: '`main.js` contains the Vue application initialization code, as shown:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.js`包含Vue应用程序初始化代码，如下所示：'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`createApp` will create an application using the `App` object imported from
    `App.vue`, which will be the starting component for our application. Vue-related
    code is normally stored inside a file with the `.vue` extension. The `App.vue`
    file acts as an app container that hosts the components that it will use. In this
    case, it will use the `Login` component, as shown in the following snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`createApp`将使用从`App.vue`导入的`App`对象创建一个应用程序，这将是我们的应用程序的起始组件。与Vue相关的代码通常存储在具有`.vue`扩展名的文件中。`App.vue`文件充当应用程序容器，它承载它将使用的组件。在这种情况下，它将使用`Login`组件，如下面的片段所示：'
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<script setup>` tag is known as the Composition API, which is a set of
    APIs that allows Vue components to be imported. In our case, we are importing
    the components from the `Login.vue` file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script setup>`标签被称为组合式API，它是一组允许Vue组件被导入的API。在我们的例子中，我们是从`Login.vue`文件中导入组件。'
- en: The code imports the `Login.Vue` file as a component and uses it inside the
    `<template>` block. Looking at the `Login.vue` file, you will see that it contains
    the HTML elements to create the login page.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将`Login.Vue`文件作为组件导入，并在`<template>`块中使用它。查看`Login.vue`文件，你会看到它包含创建登录页面所需的HTML元素。
- en: 'The `Login.vue` snippet can be seen in the following code block:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login.vue`片段可以在以下代码块中看到：'
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The class used for the button in the preceding example is declared inside a
    `minified.css` file inside the `assets` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中按钮所用的类是在`assets`文件夹内的`minified.css`文件中声明的。
- en: We have learned how to create apps using the Vue framework and wired all the
    different components together. We also looked at how to use the Vite tool to write
    a Vue-based application. In the next section, we will look at routing requests
    to different Vue components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用Vue框架创建应用程序，并将所有不同的组件连接在一起。我们还探讨了如何使用Vite工具编写基于Vue的应用程序。在下一节中，我们将探讨如何将请求路由到不同的Vue组件。
- en: Using Vue Router to move around
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue Router进行导航
- en: In this section, we will look at Vue Router and learn how to use it. Vue Router
    helps in structuring the frontend code when designing a **single-page application**
    (**SPA**). An SPA is a web application that is presented to the user as a single
    HTML page, which makes it more responsive as the content inside the HTML page
    is updated without refreshing the page. The SPA requires the use of a router that
    will route to the different endpoints when updating data from the backend.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Vue Router并学习如何使用它。Vue Router有助于在设计和**单页应用程序**（SPA）时构建前端代码。SPA是一种将用户呈现为单个HTML页面的Web应用程序，由于HTML页面内的内容更新而不需要刷新页面，因此它更加响应。SPA需要使用路由器，当从后端更新数据时，路由器将路由到不同的端点。
- en: Using a router allows easier mapping between the URL path and components simulating
    page navigation. There are two types of routes that can be configured using Vue
    Router – dynamic and static routes. Dynamic routes are used when the URL path
    is dynamic based on some kind of data. For example, in `/users/:id`, `id` in the
    path will be populated with a value, which will be something such as `/users/johnny`
    or `users/acme`. Static routes are routes that do not contain any dynamic data,
    for example, `/users` or `/orders`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由器允许更容易地在URL路径和组件之间进行映射，从而模拟页面导航。可以使用Vue Router配置两种类型的路由——动态路由和静态路由。当URL路径基于某种数据动态时，使用动态路由。例如，在`/users/:id`中，路径中的`id`将被填充为一个值，例如`/users/johnny`或`/users/acme`。静态路由是不包含任何动态数据的路由，例如`/users`或`/orders`。
- en: 'In this section, we will look at static routes. The examples for this section
    can be found in the `chapter7/router` folder. Run the following command from the
    `router` folder to run the sample application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨静态路由。本节的示例可以在`chapter7/router`文件夹中找到。从`router`文件夹运行以下命令以运行示例应用程序：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The command will run a server listening on port `8080`. Open your browser and
    enter `http://localhost:8080` in the address bar. You will see the output shown
    in *Figure 7**.5*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将在端口`8080`上运行一个服务器。打开您的浏览器，在地址栏中输入`http://localhost:8080`。您将看到*图7**.5*所示的输出：
- en: '![Figure 7.5: Router sample application](img/Figure_7.05_B18295.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：路由示例应用程序](img/Figure_7.05_B18295.jpg)'
- en: 'Figure 7.5: Router sample application'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：路由示例应用程序
- en: 'The `App.vue` file contains the Vue Router information, which can be seen as
    follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.vue`文件包含Vue Router信息，如下所示：'
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding `router-link` route is defined inside `router/index.js`, as shown:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的`router-link`路由位于`router/index.js`中，如下所示：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `<router-link/>` tag defines the router configuration that the application
    has, and in our case, this is pointing to the `Home` and `Login` components declared
    inside the `index.js` file under the `router` folder, as shown:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`<router-link/>`标签定义了应用程序的路由配置，在我们的例子中，它指向位于`router`文件夹下的`index.js`文件内声明的`Home`和`Login`组件，如下所示：'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Each of the defined routes is mapped to its respective components, which are
    the `Home` and `Login` components, which can be found inside the `views` folder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个定义的路由都映射到其相应的组件，这些组件是`Home`和`Login`组件，它们位于`views`文件夹内。
- en: Routing the login page
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录页面的路由
- en: 'We know that the `/login` path is mapped to the `Login` component, which is
    the same component that we looked at in the previous section, *Login page using
    Vue*. The difference in the router example is in the way the script is defined,
    as shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`/login`路径映射到`Login`组件，这与我们在上一节中查看的相同组件，即*使用Vue的登录页面*。在路由示例中的区别在于脚本的定义方式，如下所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Unlike in the previous section, the Vue initialization code has been moved
    into `main.js`, as shown:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节不同，Vue初始化代码已移动到`main.js`中，如下所示：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this section, we looked at how to restructure the application to work as
    a SPA by using Vue Router.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何通过使用Vue Router重构应用程序以作为SPA运行。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Vue and how to structure our frontend to make
    it easy to transition into components and applications. We looked at the different
    frontend frameworks and discussed what each of them provides.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Vue以及如何构建我们的前端结构，使其易于过渡到组件和应用。我们探讨了不同的前端框架，并讨论了它们各自提供的内容。
- en: We looked at how components and applications work together when writing a Vue-based
    web page. We tested what we learned by migrating the login page that we created
    as a simple HTML page to a Vue-based application. Lastly, we learned about Vue
    Router and how to use it to make it easier to route to different parts of a SPA.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写基于Vue的网页时，研究了组件和应用是如何协同工作的。我们通过将我们创建的简单HTML页面迁移到基于Vue的应用程序来测试我们所学的知识。最后，我们学习了Vue
    Router以及如何使用它来简化SPA中不同部分的导航。
- en: Taking on board all this learning, in the next chapter, we will look at writing
    our application as a Vue- based application that will communicate with the REST
    API that we have built.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在吸收了所有这些知识之后，在下一章中，我们将探讨如何将我们的应用编写成一个基于Vue的应用程序，该程序将与我们所构建的REST API进行通信。
