- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing Functional Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍函数式编程
- en: In this first chapter, we are going to take a bird’s eye view of the *what*
    and *why* behind **functional programming** (**FP**). Before we dive into the
    nitty gritty of FP, we first have to understand what benefit we get from applying
    these techniques to our code. To start off, we will provide a brief look into
    the history and contemporary state of FP methodologies. Next, we will take a look
    at how FP compares to more traditional **object-oriented programming** (**OOP**).
    Finally, we will also discuss the “Go programming paradigm.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们将从宏观的角度了解**函数式编程**（**FP**）背后的**是什么**和**为什么**。在我们深入FP的细节之前，我们首先需要了解从应用这些技术到我们的代码中我们能获得什么好处。首先，我们将简要回顾FP的历史和当代状态。接下来，我们将探讨FP与传统**面向对象编程**（**OOP**）的比较。最后，我们还将讨论“Go编程范式”。
- en: 'The main things we will cover in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主要内容如下：
- en: What is FP?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是FP？
- en: A brief history of FP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP的简要历史
- en: A look at the current state of FP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FP的当前状态一览
- en: A comparison of traditional object-oriented and functional methodologies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统面向对象和函数式方法的比较
- en: A discussion on Go programming paradigms and how FP fits into this
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Go编程范式及其如何融入FP的讨论
- en: What is functional programming?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: As you might have guessed, FP is a programming paradigm where functions play
    the main role. Functions will be the bread and butter of the functional programmer’s
    toolbox. Our programs will be composed of functions, chained together in various
    ways to perform ever more complex tasks. These functions tend to be small and
    modular.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，FP是一种以函数为主角的编程范式。函数将是函数式程序员工具箱中的主食。我们的程序将由函数组成，以各种方式链接在一起以执行更复杂的任务。这些函数通常很小且模块化。
- en: This is in contrast with OOP, where objects play the main role. Functions are
    also used in OOP, but their use is usually to change the state of an object. They
    are typically tied to an object as well. This gives the familiar call pattern
    of *someObject.doSomething()*. Functions in these languages are treated as secondary
    citizens; they are used to serve an object’s functionality rather than being used
    for the function itself.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这与OOP形成对比，在OOP中，对象是主角。函数在OOP中也被使用，但它们的使用通常是为了改变对象的状态。它们通常与一个对象绑定在一起。这导致了熟悉的调用模式*someObject.doSomething()*。在这些语言中，函数被视为二等公民；它们被用来服务于对象的功能，而不是用于函数本身。
- en: Introducing first-class functions
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍一等函数
- en: In FP, functions are considered **first-class citizens**. This means they are
    treated in a similar way to how objects are treated in a traditional object-oriented
    language. Functions can be bound to variable names, they can be passed to other
    functions, or even served as the return value of a function. In essence, functions
    are treated as any other “type” would be. This equivalence between types and functions
    is where the power of FP stems from. As we will see in later chapters, treating
    functions as first-class citizens opens a wide door of possibilities for how to
    structure programs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，函数被视为**一等公民**。这意味着它们被以类似于在传统面向对象语言中处理对象的方式对待。函数可以被绑定到变量名上，它们可以被传递给其他函数，甚至可以作为函数的返回值。本质上，函数被当作任何其他“类型”一样对待。这种类型与函数之间的等价性是FP力量的源泉。正如我们将在后面的章节中看到的，将函数视为一等公民为如何构建程序打开了一扇广泛的大门。
- en: 'Let’s take a look at an example of treating functions as first-class citizens.
    Don’t worry if what’s happening here is not entirely clear yet; we’ll have a full
    chapter dedicated to this later in the book:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将函数视为一等公民的一个例子。如果你觉得这里发生的事情还不完全清楚，不要担心；我们将在本书稍后的章节中对此进行详细介绍：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break what’s happening here down a bit. First, we are using a “type alias”
    to define a new type. The new type is actually a “function” and not a primitive
    or a struct:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分析一下这里发生的事情。首先，我们使用“类型别名”来定义一个新的类型。这个新类型实际上是一个“函数”，而不是原始类型或结构体：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This tells us that everywhere in our code base where we find the `predicate`
    type, it expects to see a function that takes an `int` and returns a `bool`. In
    our `filter` function, we are using this to say we expect a slice of integers
    as input, as well as a function that matches the `predicate` type:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，在我们代码库的任何地方，当我们找到`predicate`类型时，它期望看到一个接受`int`并返回`bool`的函数。在我们的`filter`函数中，我们使用这个来表示我们期望一个整数切片作为输入，以及一个匹配`predicate`类型的函数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These are two examples of how functions are treated differently in functional
    languages from in object-oriented languages. First, types can be defined as functions
    instead of just classes or primitives. Second, we can pass any function that satisfies
    our type signature to the `filter` function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是函数在函数式语言和面向对象语言中处理方式不同的两个示例。首先，类型可以定义为函数，而不仅仅是类或原语。其次，我们可以将满足我们的类型签名的任何函数传递给`filter`函数。
- en: 'In the `main` function, we are showing an example of passing the `isLargerThan5`
    function to the `filter` function, similar to how you’d pass around objects in
    an object-oriented language:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们展示了将`isLargerThan5`函数传递给`filter`函数的示例，类似于在面向对象语言中传递对象的方式：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is a small example of what we can do with FP. This basic idea, of treating
    functions as just another type in our system that can be used in the same way
    as a struct, will lead to the powerful techniques that we explore in this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以用FP做到的一小部分示例。这个基本思想，即把函数视为我们系统中的一种类型，可以像结构体一样使用，将引导我们在这本书中探索的强大技术。
- en: What are pure functions?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是纯函数？
- en: FP is often thought of as a purely academic paradigm, with little to no application
    in industry. This, I think, stems from an idea that FP is somehow more complicated
    and less mature for the industry than OOP. While the roots of FP are academic,
    the concepts that are central to these languages can be applied to many problems
    that we solve in industry.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: FP通常被认为是一种纯粹学术范式，在工业界应用很少或没有。我认为这源于一种观念，即FP在某种程度上比OOP更复杂、不够成熟。虽然FP的根源在学术领域，但这些语言的核心概念可以应用于我们在工业界解决的许多问题。
- en: Often, FP is thought of as more complex than traditional OOP. I believe this
    is a misconception. Often, when people say FP, what they really mean to say is
    *pure FP*. A pure functional program is a subset of FP, where each function has
    to be pure – it cannot mutate the state of a system or produce any side effects.
    Hence, a pure function is completely predictable. Given the same set of inputs,
    it will always produce the same set of outputs. Our program becomes entirely deterministic.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，FP被认为比传统的OOP更复杂。我认为这是一个误解。当人们提到FP时，他们真正想说的是*纯FP*。一个纯函数程序是FP的一个子集，其中每个函数都必须是纯的——它不能改变系统的状态或产生任何副作用。因此，纯函数是完全可预测的。给定相同的输入集，它总是产生相同的输出集。我们的程序变得完全确定。
- en: This book will focus on FP without treating it as the stricter subset of “pure”
    FP. That is not to say that purity brings us no value. In a purely functional
    language, functions are entirely deterministic and the state of a system is unchanged
    by calling them. This makes code easier to debug and comprehend and improves testability.
    [*Chapter 6*](B18771_06.xhtml#_idTextAnchor101) is dedicated to function purity,
    as it can bring immense value to our programs. However, eradicating all side effects
    from our code base is often more trouble than it’s worth. The goal of this book
    is to help you write code in a way that improves readability, and as such, we’ll
    often have to make a trade-off between the (pure) functional style and a more
    forgiving style of FP.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将专注于FP，而不将其视为“纯”FP的更严格子集。这并不是说纯度没有给我们带来价值。在纯函数语言中，函数是完全确定的，系统的状态在调用它们时不会改变。这使得代码更容易调试和理解，并提高了可测试性。[第6章](B18771_06.xhtml#_idTextAnchor101)专门讨论函数纯度，因为它可以为我们的程序带来巨大的价值。然而，从我们的代码库中根除所有副作用通常弊大于利。本书的目标是帮助您以改进可读性的方式编写代码，因此我们经常需要在（纯）函数式风格和更宽容的FP风格之间做出权衡。
- en: 'To briefly and rather abstractly show what function purity is, consider the
    following example. Say we have a struct of the `Person` type, with a `Name` field.
    We can create a function to change the name of the person, such as `changeName`.
    There are two ways to implement this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简要而抽象地展示函数纯度是什么，考虑以下示例。假设我们有一个`Person`类型的结构体，其中有一个`Name`字段。我们可以创建一个函数来更改人的姓名，例如`changeName`。有两种实现方式：
- en: We can create a function that takes in the object, changes the content of the
    `name` field to the new name, and returns nothing.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数，它接受一个对象，将`name`字段的内文更改为新名称，然后不返回任何内容。
- en: We can create a function that takes in an object and returns a new object with
    the changes applied. The original object is not changed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数，它接受一个对象，并返回一个应用了更改的新对象。原始对象不会被更改。
- en: 'The first way does not create a pure function, as it has changed the state
    of our system. If we want to avoid this, we can instead create a `changeName`
    function that returns a new `Person` object that has identical field values for
    each field as the original `Person` object does, but instead has a new name in
    the `name` field. The diagram here shows this a bit more abstractly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法并没有创建一个纯函数，因为它已经改变了我们系统的状态。如果我们想避免这种情况，我们可以创建一个`changeName`函数，该函数返回一个新的`Person`对象，该对象每个字段与原始`Person`对象具有相同的字段值，但在`name`字段中有一个新名字。这里的图更抽象地展示了这一点：
- en: '![Figure 1.1: Pure function (top) compared to impure function (bottom)](img/Figure_1.1_B18771.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：纯函数（顶部）与不纯函数（底部）的比较](img/Figure_1.1_B18771.jpg)'
- en: 'Figure 1.1: Pure function (top) compared to impure function (bottom)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：纯函数（顶部）与不纯函数（底部）的比较
- en: In the top diagram, we have a function (denoted with the Lambda symbol) that
    takes a certain object, **A**, as input. It performs an operation on this object,
    but instead of changing the object, it returns a new object, **B**, which has
    the transformation applied to it. The bottom diagram shows what was explained
    in the earlier paragraph. The function takes object **A**, makes a change “in-place”
    on the object’s values, and returns nothing. It has only changed the state of
    the system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部的图中，我们有一个函数（用Lambda符号表示），它接受一个特定的对象**A**作为输入。它对这个对象执行一个操作，但不是改变这个对象，而是返回一个新的对象**B**，这个新对象应用了变换。底部的图显示了前面段落中解释的内容。该函数接受对象**A**，在对象值上“就地”进行更改，并返回空值。它只改变了系统的状态。
- en: 'Let’s take a look at what this would look like in code. We start off by defining
    our struct, `Person`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这将在代码中是什么样子。我们首先定义我们的结构体，`Person`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To implement the function that mutates the `Person` object and places a new
    value in the `Name` field, we can write the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个会修改`Person`对象并在`Name`字段中放置新值的函数，我们可以编写以下代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is equivalent to the bottom of the diagram; the `Person` object that was
    passed to the function is mutated. The state of our system is now different from
    before the function was called. Every place that refers to that `Person` object
    will now see the new name instead of the old name.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这与图的下部相当；传递给函数的`Person`对象被修改了。现在我们系统的状态与函数调用之前不同。现在所有引用该`Person`对象的地方都将看到新名字而不是旧名字。
- en: 'If we were to write this in a pure function, we’d get the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用纯函数的方式来写这个，我们会得到以下结果：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this second function, we copy over the `Age` value from the original `Person`
    object (`p`) and place the `newName` value in the `Name` field. The result of
    this is returned as a new object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个函数中，我们复制了原始`Person`对象（`p`）的`Age`值，并将`newName`值放置在`Name`字段中。这个结果作为新对象返回。
- en: While it’s true that the former, impure way of writing code seems easier superficially
    and takes less effort, the implications for maintaining a system where functions
    can change the state of the system are vast. In larger applications, maintaining
    a clear understanding of the state of your system will help you debug and replicate
    errors more easily.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从表面上看，前一种不纯的写法似乎更容易且更省力，但对于维护一个函数可以改变系统状态的系统来说，其影响是巨大的。在更大的应用程序中，保持对你系统状态的清晰理解将帮助你更容易地调试和复制错误。
- en: This example looks at pure functions in the context of immutable data structures.
    A pure function will not mutate the state of our system and always return the
    same output given the same input.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子考察了在不可变数据结构上下文中的纯函数。纯函数不会改变我们系统的状态，并且对于相同的输入总是返回相同的输出。
- en: In this book, we will focus on the essence of FP and how we can apply the techniques
    in Go to create more readable, maintainable, and testable code. We will look at
    the core building blocks, such as higher-order functions, function currying, recursion,
    and declarative programming. As mentioned previously, FP is not equivalent to
    “pure” FP, but we will discuss the purity aspect as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将关注函数式编程（FP）的精髓以及我们如何将技术应用于Go语言以创建更易读、可维护和可测试的代码。我们将探讨核心构建块，如高阶函数、函数柯里化、递归和声明式编程。如前所述，FP不等同于“纯”FP，但我们将讨论纯度方面。
- en: Say what you want, not how you want it
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随意说出你想要的内容，而不是你想要的方式
- en: One commonality that is shared between FP languages is that functions are declarative
    rather than imperative. In a functional language, you, as the programmer, say
    *what* you want to achieve rather than *how* to achieve it. Compare these two
    snippets of the Go code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言之间有一个共同点，那就是函数是声明性的，而不是命令性的。在函数式语言中，作为程序员，你可以说出你想要实现的目标，而不是实现它的方法。比较这两个
    Go 代码片段。
- en: 'The first snippet here is an example of valid Go code where the result is obtained
    declaratively:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第一个片段是一个有效的 Go 代码示例，其中结果是通过声明性获得的：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice how, in this code, we say the following things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，我们说了以下内容：
- en: Give us a range of integers, between -10 and 10
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给我们一个介于 -10 和 10 之间的整数范围
- en: Turn these numbers into their absolute value
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些数字转换为它们的绝对值
- en: Filter for all the even numbers
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 筛选出所有的偶数
- en: Give us the sum of these even numbers
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给我们这些偶数的总和
- en: 'Nowhere did we say how to achieve these things. In an imperative style, the
    code would look like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有说如何实现这些事情。在命令式风格中，代码看起来如下：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While, in this example, both snippets are easy to read for anyone with some
    Go experience, we can imagine how this would stop being the case for larger examples.
    In the imperative example, we have to spell out literally how the computer is
    supposed to give us a result.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，在这个例子中，对于有 Go 经验的人来说，这两个片段都很容易阅读，但我们可以想象，对于更大的例子，这种情况将不再成立。在命令式示例中，我们必须明确地说明计算机应该如何给我们一个结果。
- en: A brief history of functional programming
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程的简要历史
- en: If you take a look at the mainstream languages of the past decade, you will
    notice how the prevailing programming paradigm is **OOP**. This might lead you
    to believe that FP is an upstart paradigm, one that is in a young state compared
    to the well-established object-oriented approach. Yet, when we look at the history
    of FP, we can trace its roots all the way back to the 1930s, quite some time before
    we talked about programming in the modern-day sense.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看过去十年的主流语言，你会注意到主流的编程范式是**面向对象编程**（OOP）。这可能会让你认为函数式编程是一种新兴的范式，与成熟的面向对象方法相比，它处于一个年轻的状态。然而，当我们看看函数式编程的历史，我们可以追溯到
    1930 年代，这比我们谈论现代意义上的编程要早得多。
- en: The roots of FP can be traced back to the Lambda calculus, which was developed
    in the 1930s by Alonzo Church. This was developed as a formal system based on
    function abstraction and application, using variable binding. There are two variants
    of this calculus; it can either be **typed** or **untyped**. This is directly
    parallel to how programming languages today are either **statically typed**, such
    as Java and Go, or **dynamically typed** such as Python. The Lambda calculus was
    proven to be Turing-complete in 1937 – again, similar to how all mainstream programming
    languages today are Turing-complete.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的根源可以追溯到 1930 年代由 Alonzo Church 开发的 Lambda 演算。这是一个基于函数抽象和应用的正式系统，使用变量绑定。这个演算有两种变体；它可以是**类型化**的，也可以是**无类型**的。这与今天的编程语言直接平行，例如
    Java 和 Go 是**静态类型**的，而 Python 是**动态类型**的。Lambda 演算在 1937 年被证明是图灵完备的——再次，这与今天所有主流编程语言都是图灵完备的相似。
- en: The Lambda calculus predates modern programming by a few decades. To get to
    the first actual code that could be thought of as FP, in the way that we understand
    programming today, we have to move forward a few decades. The **LISt Processor**
    (**LISP**) was originally created in the 1950s as a practical application of mathematical
    notation. This was influenced by the Lambda calculus laid out in the 1930s by
    Church.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 演算比现代编程早了几十年。要到达第一个可以被认为是函数式编程的代码，就像我们今天理解的编程一样，我们必须向前推进几十年。**LISt Processor**（**LISP**）最初在
    1950 年代被创建，作为一种数学符号的实际应用。这受到了 1930 年代 Church 提出的 Lambda 演算的影响。
- en: LISP can be thought of as the first FP language that reached some sense of popularity.
    It was especially popular in the field of artificial intelligence research, but
    through the decades, made its way to industry. Derivatives of LISP continued to
    be popular for a long time, with notable achievements such as the Crash Bandicoot
    game, and Hacker News being written in derivatives of this language.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: LISP 可以被认为是第一个达到一定知名度的函数式编程语言。它在人工智能研究领域尤其受欢迎，但经过几十年，它逐渐进入了工业领域。LISP 的衍生语言在很长时间内一直很受欢迎，
    notable achievements such as the Crash Bandicoot game, and Hacker News being written
    in derivatives of this language.
- en: LISP was developed in the late 1950s by John McCarthy. To define LISP functions,
    he took inspiration from the Lambda calculus developed by Church. It was extended
    beyond the mathematical system by introducing recursion, a fundamental concept
    for how functional languages work. Beyond recursion, LISP also treated functions
    as first-class citizens and pushed innovation in programming language design by
    including things such as garbage collection and conditional statements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: LISP是在20世纪50年代末由约翰·麦卡锡开发的。为了定义LISP函数，他从丘奇开发的Lambda演算中汲取了灵感。通过引入递归，一个对于函数式语言工作方式的基本概念，它将LISP扩展到了数学系统之外。除了递归之外，LISP还将函数视为一等公民，并通过包括垃圾回收和条件语句等特性推动了编程语言设计的创新。
- en: 'In the early 1960s, Kenneth E. Iverson developed **A Programming Language**
    (**APL**). APL is, again, a functional language that is perhaps most known for
    its use of symbols and terse code.  For example, the following is an image of
    the code snippet that would generate Conway’s Game Of Life:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代初，肯尼思·E·伊夫森开发了**A编程语言**（**APL**）。APL再次是一种函数式语言，它最著名的可能是其符号的使用和简洁的代码。例如，以下是一个生成康威生命游戏的代码片段的图像：
- en: '![Figure 1.2: Conway’s Game of Life in APL](img/Figure_1.2_B18771.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：APL中的康威生命游戏](img/Figure_1.2_B18771.jpg)'
- en: 'Figure 1.2: Conway’s Game of Life in APL'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：APL中的康威生命游戏
- en: 'Jumping ahead another decade, in 1973, we get a language called **Meta Language**
    (**ML**). This language introduced the *polymorphic Hindley-Milner type system*
    – that is to say, a type system in which types are assigned automatically without
    requiring explicit type annotations. In addition, it supported features such as
    **function currying**, which we will apply to our functional Go code later in
    this book. It also supports pattern matching on the arguments of a function, as
    we can see in the following snippet of a function to compute the factorial of
    a number:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过十年，到了1973年，我们得到了一种名为**元语言**（**ML**）的语言。这种语言引入了*多态的Hindley-Milner类型系统*——也就是说，一个类型系统，其中类型是自动分配的，无需显式类型注解。此外，它还支持诸如**函数柯里化**等特性，我们将在本书后面的功能Go代码中应用这些特性。它还支持对函数参数进行模式匹配，正如我们可以在以下计算数字阶乘的函数片段中看到的那样：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The pattern matcher in this example will take a look at what the input value
    is to the `fac` function, and then either continue with the first line if the
    input value is `0`, or the second line in all other cases. Notice that this is
    also a recursive function expressed quite beautifully. Sadly, pattern matching
    will not be explored further in this book, as Go currently offers no way of doing
    this. We will see a way of doing a similar type of function dispatching using
    maps and higher-order functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，模式匹配器将查看输入值是`fac`函数的什么，然后如果输入值是`0`，则继续第一行，在其他所有情况下则继续第二行。请注意，这也是一个表达得相当优美的递归函数。遗憾的是，本书将不会进一步探讨模式匹配，因为Go目前没有提供执行此操作的方法。我们将看到一种使用映射和高阶函数执行类似类型函数分派的方法。
- en: In 1977, the language called FP was created. It was developed by John Backus
    specifically to support the FP paradigm. While the language itself did not get
    much traction outside of academia, the paper in which it was introduced (*Can
    programming be liberated from the von Neumann style?*) did spark a renewed interest
    in FP.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 1977年，创建了一种名为FP的语言。约翰·巴克特开发这种语言是为了专门支持FP范式。虽然这种语言本身在学术界之外并没有得到太多关注，但它介绍该语言的论文（*能否从冯·诺伊曼风格中解放编程？*）确实重新激起了对FP的兴趣。
- en: In the same decade as ML and FP, another language called **Scheme** was developed.
    This is the first dialect of LISP that used lexical scoping and tail-call optimization.
    Tail-call optimization led to the practical implementation of recursive algorithms.
    While the details of tail-call optimization will be discussed in [*Chapter 7*](B18771_07.xhtml#_idTextAnchor113)
    of this book, briefly stated, it allows recursive algorithms to be implemented
    in an efficient way and without using more memory than a traditional loop would,
    thus eliminating the “stack overflow exceptions” that otherwise would happen during
    deep recursion.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在ML和FP相同的十年中，还开发了一种名为**Scheme**的语言。这是LISP的第一个使用词法作用域和尾调用优化的方言。尾调用优化导致了递归算法的实际实现。虽然本书第7章（[B18771_07.xhtml#_idTextAnchor113]）将讨论尾调用优化的细节，但简要地说，它允许递归算法以有效的方式实现，并且不需要比传统循环更多的内存，从而消除了在深度递归过程中可能发生的“栈溢出异常”。
- en: Scheme is one of the most influential LISP dialects to have been created, and
    continues to this day to have some popularity. Although it was created in 1975,
    the last standard was defined as recently as 2013 (R7RS-Small). Scheme, in turn,
    influenced other LISP dialects, the most notable of which is perhaps Common Lisp.
    Interestingly, although having roots in FP, Common Lisp introduced the **Common
    Lisp Object System** (**CLOS**). The CLOS facilitated OOP in LISP. With this,
    we can perhaps consider LISP a truly multi-paradigm language, not unlike Go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme是影响最大的LISP方言之一，至今仍有一定的人气。尽管它是在1975年创建的，但最新的标准是在2013年定义的（R7RS-Small）。Scheme反过来又影响了其他LISP方言，其中最著名的是Common
    Lisp。有趣的是，尽管起源于FP，Common Lisp引入了**Common Lisp对象系统**（**CLOS**）。CLOS促进了LISP中的面向对象编程。因此，我们可以将LISP视为一个真正的多范式语言，就像Go一样。
- en: 'The final language to look at before we jump to contemporary functional languages
    is Miranda. Miranda is a lazy, purely FP language. The key concept that was introduced
    here is lazy evaluation. When a language is said to support lazy evaluation, this
    means that an expression is not resolved until the value is actually needed. It
    can be used, for example, to implement infinite data structures. You could define
    a function that generates all Fibonacci numbers, a sequence that never ends –
    but, rather than creating the entire list (which is not possible), it will only
    generate a subset of that list that is relevant to the problem you are solving.
    For example, the following snippet of Miranda code computes all square numbers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向当代函数式语言之前，最后要讨论的语言是Miranda。Miranda是一种懒加载的纯函数式语言。这里引入的关键概念是懒加载。当一个语言声称支持懒加载时，这意味着表达式只有在实际需要值时才会被解析。它可以用来实现无限数据结构。例如，你可以定义一个生成所有斐波那契数的函数，这是一个永不结束的序列——但是，而不是创建整个列表（这是不可能的），它只会生成与你要解决的问题相关的列表子集。例如，以下Miranda代码片段计算所有平方数：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With that, we have arrived at the next language to discuss briefly, namely Haskell.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就到达了下一个要简要讨论的语言，即Haskell。
- en: Modern functional programming
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代函数式编程
- en: After our brief look at the history of FP, it’s time to dive into modern functional
    languages. One of the languages that is popular today within the strict FP languages
    is Haskell. When people study FP or become exposed to it, it is often through
    this language. Haskell is a statically typed FP language. It has goodies such
    as type inference (like ML) and lazy evaluation (like Miranda).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要回顾了函数式编程的历史之后，是时候深入现代函数式语言了。在严格的函数式编程语言中，Haskell是今天流行的一种语言。当人们学习FP或接触到它时，通常是通过这种语言。Haskell是一种静态类型函数式语言。它有诸如类型推断（类似于ML）和懒加载（类似于Miranda）等好处。
- en: When people want to learn more about pure FP, my recommendation is always to
    start with Haskell. It has a great community and plenty of resources and teaches
    you all there is to know about the FP domain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们想要了解更多关于纯FP的知识时，我的建议总是从Haskell开始。它有一个优秀的社区和丰富的资源，并教你所有关于FP领域的内容。
- en: It might very well be the most popular pure FP language around, yet it accounts
    for less than 1% of the active users on GitHub ([https://www.benfrederickson.com/ranking-programming-languages-by-github-users/](https://www.benfrederickson.com/ranking-programming-languages-by-github-users/)).
    For fun, if we take a look at Go, it currently sits at about approximately 4%
    of active users. Not bad for a language that’s just about a decade old at this
    point!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能是最受欢迎的纯函数式语言，但在GitHub上的活跃用户不到1%([https://www.benfrederickson.com/ranking-programming-languages-by-github-users/](https://www.benfrederickson.com/ranking-programming-languages-by-github-users/))。有趣的是，如果我们看看Go，它目前大约有大约4%的活跃用户。对于一个大约十年前才出现的语言来说，这已经很不错了！
- en: In the .NET world, another language that is relatively popular is F#. While
    this is not a purely functional language such as Haskell, it is a *functional-first*
    language. It prefers the functional paradigm over others but does not enforce
    it. Similarly to Haskell, it has less than 1% of active users on GitHub. C# seems
    to get all the popular features of F# though, so at least the functional concepts
    that F# spearheaded for .NET will find popularity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET的世界中，另一种相对流行的语言是F#。虽然这并不是像Haskell那样的纯函数式语言，但它是一种*以函数优先*的语言。它更倾向于函数范式，但并不强制执行。与Haskell类似，它在GitHub上的活跃用户不到1%。然而，C#似乎获得了F#的所有流行特性，因此至少F#为.NET带来的函数概念将会受到欢迎。
- en: So does that mean functional programming is dead on arrival? Well, not quite.
    The book you are reading now is all about Go, and Go is not a purely FP language.
    My take on it is that the concepts from FP are generally useful and can create
    better code, even in object-oriented languages – and I’d like to think I’m not
    alone in thinking this. Many of the languages that we think of as object-oriented
    languages have become more and more functional.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那这意味着函数式编程在到来时就死了？嗯，并不完全是这样。你现在正在阅读的这本书是关于 Go 的，而 Go 并不是一种纯粹的函数式编程语言。我的看法是，函数式编程的概念通常是有用的，并且可以在面向对象的语言中创建更好的代码——而且我希望我不是唯一这样想的人。我们认为是面向对象的语言中的许多语言已经变得越来越函数式。
- en: We can see this shift happening even in the most popular mainstream object-oriented
    languages. Java is introducing FP concepts with each iteration, offering such
    things as pattern matching, higher-order functions, and declarative programming
    through Lambda functions. C# is looking more and more like F# (Microsoft’s functional
    programming counterpart of C#) with each release. They have implemented pattern
    matching, immutability, built-in tuple support, and more.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在最流行的主流面向对象语言中看到这种转变的发生。Java 在每次迭代中都引入了函数式编程的概念，提供了诸如模式匹配、高阶函数和通过 Lambda
    函数的声明式编程等功能。C# 在每次发布中都越来越像 F#（C# 的微软函数式编程对应物）。它们实现了模式匹配、不可变性、内置元组支持等更多功能。
- en: This shift is happening because, although purely functional languages might
    not always suit the industry, the concepts from functional languages allow us
    to write our object-oriented code with more confidence. They lead to code that
    is easier to test, easier to read, and faster to debug.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转变正在发生，因为尽管纯粹的函数式编程语言可能并不总是适合工业界，但函数式编程语言的概念使我们能够更有信心地编写面向对象的代码。它们导致代码更容易测试、更容易阅读，并且更容易调试。
- en: 'The most popular programming language used today is JavaScript. While this
    would perhaps not pop into people’s minds when talking about FP, it does meet
    a subset of the “requirements” we have for a functional language. It has the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最受欢迎的编程语言是 JavaScript。虽然当谈到函数式编程时，这或许不会立刻出现在人们的脑海中，但它确实满足了我们对于函数式语言的一部分“要求”。它具有以下特点：
- en: First-class functions
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首等函数
- en: Anonymous (Lambda) functions
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名（Lambda）函数
- en: Closures
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: When combining these features, we can create many constructs that allow us to
    leverage code in an FP style.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当结合这些特性时，我们可以创建许多结构，使我们能够以函数式编程风格利用代码。
- en: For those of us who want to have a purely functional language in the browser,
    there are languages that transpile to JavaScript, such as Elm and PureScript.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望在浏览器中拥有纯粹函数式语言的人来说，有一些语言可以转换为 JavaScript，例如 Elm 和 PureScript。
- en: Let’s now take a look at the star of this book, Go, and how this fits into the
    picture.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看这本书的明星，Go 语言，以及它是如何融入这幅图画的。
- en: The Go programming paradigm
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 编程范式
- en: Unless this is your first introduction to Go, you probably know that Go is a
    statically typed programming language. You also know that it has structs and that
    we can instantiate objects out of these. You likely also know that Go optionally
    binds functions to a struct, but that is not required. It would be possible to
    write an entire Go program without creating an object, something that the stricter
    object-oriented languages rarely allow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除非这是你第一次接触 Go 语言，否则你可能知道 Go 是一种静态类型编程语言。你也知道它有 struct，我们可以从这些 struct 中实例化对象。你很可能也知道
    Go 语言可以选择性地将函数绑定到 struct 上，但这不是必需的。完全有可能编写一个不创建对象的整个 Go 程序，这在更严格的面向对象语言中很少允许。
- en: 'In fact, the simplest `Hello World` program in Go has no sense of structs or
    objects:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Go 语言中最简单的 `Hello World` 程序并没有 struct 或对象的意识：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the introductory Go program that many of us wrote when starting
    to learn Go has no notion of structs or objects to do something useful. `Println`
    is a function defined in the `fmt` package, but it’s not bound to an object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们开始学习 Go 语言时，许多人编写的入门级 Go 程序没有 struct 或对象的意识来执行有用的操作。`Println` 是在 `fmt`
    包中定义的函数，但它并没有绑定到对象上。
- en: The term for a language such as Go is multi-paradigm. Go does not force us to
    write code in the object-oriented paradigm or in the functional paradigm. We,
    the programmers, have complete freedom to use the language however we want. This
    is why the book you are reading right now exists.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 Go 这样的语言，术语是多范式的。Go 语言并不强迫我们用面向对象范式或函数式范式来编写代码。我们，程序员，有完全的自由来按自己的意愿使用这种语言。这就是你现在正在阅读的这本书存在的原因。
- en: 'Go offers several features that enable us to write functional Go code with
    (relative) ease:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了几个特性，使我们能够相对轻松地编写功能性的 Go 代码：
- en: Functions as first-class citizens
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: Higher-order functions
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Immutability guarantees
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性保证
- en: Generics (not needed per se, but make life easier)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型（虽然不是必需的，但可以使生活更轻松）
- en: Recursion
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: 'These are explored in more detail later in the book. I also want to point out
    some features that Go lacks (as of 1.18) that would improve our quality of life:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容将在本书的后续部分进行更详细的探讨。我还想指出一些 Go（截至 1.18 版本）缺乏的特性，这些特性将提高我们的生活质量：
- en: Tail-call optimization
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: Lazy evaluation
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Purity guarantee
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯净性保证
- en: These are not deal-breakers. The focus of this book is leveraging FP in Go to
    write better code. Even if we don’t have a purely statically typed system to work
    with, we can work with what we do have.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是决定性的因素。本书的重点是利用 FP 在 Go 中编写更好的代码。即使我们没有纯静态类型系统可供工作，我们也可以利用我们所拥有的。
- en: By no means do I want to posit FP as the superior way to write Go code. Nor
    do I want to frame it as the “right” paradigm to choose. Go is multi-paradigm,
    and just as programmers choose the right language for any problem, we also have
    to choose the right paradigm for each problem. We can even opt to stick to functional
    concepts 90% of the time and still end up with cleaner code than if we had stuck
    to it 100%. For example, writing purely functional code would prevent the use
    of any side effects. Yet, many side effects do serve a purpose. Any time we want
    to show a user output or get input from a user, we are technically dealing with
    a side effect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我绝不想将 FP 定位为编写 Go 代码的优越方式。我也不想将其定位为“正确”的范式选择。Go 是多范式的，就像程序员为任何问题选择正确的语言一样，我们也要为每个问题选择正确的范式。我们甚至可以选择在
    90% 的时间里坚持函数式概念，最终得到的代码比完全坚持它时更干净。例如，编写纯函数式代码将防止使用任何副作用。然而，许多副作用确实有其作用。任何我们想要向用户展示输出或从用户那里获取输入的时候，我们实际上都在处理副作用。
- en: Why functional programming?
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择函数式编程？
- en: 'All this does not yet tell us why we want to invest time in learning about
    FP. The main benefits we hope to get from functional programming are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些还不足以告诉我们为什么我们要投入时间学习函数式编程。我们希望通过函数式编程获得的主要好处如下：
- en: More readable code
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更易于阅读的代码
- en: Easier to understand and debug code
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易理解和调试代码
- en: Easier testing
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的测试
- en: Fewer bugs
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少的错误
- en: Easier concurrency
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的并发
- en: These can be achieved by a relatively small set of FP features. To achieve more
    readable code, this can be done by writing code in a declarative way. Declarative
    programming will show us what is happening rather than how it is happening. Declarative
    code is often more concise than the imperative counterpart. Conciseness is not
    necessarily a benefit to code readability (remember the APL example previously?)
    but when applied correctly, it can be.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过一组相对较小的 FP 特性来实现。为了编写更易于阅读的代码，可以通过声明式编程来实现。声明式编程将向我们展示正在发生的事情，而不是如何发生。声明式代码通常比命令式代码更简洁。简洁性并不一定是代码可读性的好处（记得之前提到的
    APL 例子吗？），但正确应用时，它可以成为好处。
- en: FP makes code easier to understand, debug, and test by preferring purity over
    impurity. When each function always creates a deterministic outcome, we can trust
    a function does only what it says. When you encounter a function called `square(n
    int)`, we can be convinced that all the function does is square the input.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: FP 通过优先考虑纯净性而非杂质，使代码更容易理解、调试和测试。当每个函数总是产生一个确定的输出时，我们可以相信函数只做它所说的。当你遇到一个名为 `square(n
    int)` 的函数时，我们可以确信该函数所做的只是对输入进行平方。
- en: In addition, the state of the system is not changed. If we are working with
    structs and objects, it helps us guarantee that the values our object holds are
    not changed by functions that are operating on it. This reduces the cognitive
    overhead when reasoning about our programs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，系统状态不会改变。如果我们正在处理结构和对象，这有助于我们保证对象持有的值不会被操作它的函数所改变。这减少了推理程序时的认知负担。
- en: 'Pure, immutable code makes code easier to test for the following reasons:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 纯净、不可变的代码使代码更容易测试，以下是一些原因：
- en: The state of the system has no impact on our function – so we don’t have to
    mock the state when testing.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的状态不会影响我们的函数——因此我们在测试时不需要模拟状态。
- en: A given function always returns the same output for a given input. This means
    we get predictable, deterministic functions.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的输入，一个给定的函数总是返回相同的输出。这意味着我们得到了可预测的、确定的函数。
- en: I won’t be advocating for test-driven development or any such thing here, but
    I do believe testing is critical to writing good code. Or at least, to avoid being
    paged at 3 A.M. because a function started throwing unintelligible error codes
    at a user.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里提倡测试驱动开发或任何类似的东西，但我确实认为测试对于编写好代码至关重要。至少，可以避免在凌晨3点被叫醒，因为一个函数开始向用户抛出无法理解的错误代码。
- en: Hand in hand with more testable code, FP helps us write fewer bugs. This is
    perhaps hard to quantify, but the idea here is that without mutable states and
    with only predictable functions in our code, we’ll have fewer edge cases to think
    about. If the state is important to your program, you have to know, at each point
    in time, what the state of the system can be and how it influences the function
    you are writing. This gets complex fast.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与可测试的代码相结合，函数式编程帮助我们编写更少的错误。这可能很难量化，但这里的想法是，没有可变状态，并且代码中只有可预测的函数，我们将有更少的边缘情况需要考虑。如果状态对程序很重要，你必须知道，在每一个时间点，系统的状态可能是什么以及它如何影响你正在编写的函数。这会很快变得复杂。
- en: Finally, FP will make writing concurrent code easier. Go is a pretty well-known
    language for its built-in concurrency features. Concurrency was part of Go from
    its inception and was not tacked on later as with some other mainstream languages.
    As a result, Go has pretty solid concurrent coding tools.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数式编程将使编写并发代码变得更加容易。Go以其内置的并发特性而闻名。并发性是Go从诞生之初就具备的特性，而不是像一些其他主流语言那样后来才添加的。因此，Go拥有相当坚实的并发编程工具。
- en: The way in which functional programming helps is that functions are deterministic
    and immutable. Thus, running the same function concurrently can never impact the
    result of another running function. If functions never depend on the state of
    the system, thread A can not invalidate the system’s state for thread B.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程帮助的方式在于函数是确定性和不可变的。因此，并发运行相同的函数永远不会影响另一个正在运行函数的结果。如果函数从不依赖于系统的状态，线程A不能使线程B的系统状态无效。
- en: One thing I want to highlight again, as it is important, is that I don’t advocate
    sticking to pure FP in Go. Doing so will probably make your life, and that of
    your coworkers, harder than it has to be. Choose the right tool for the job –
    sometimes that will be objects, and sometimes that will be functions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我想再次强调的一点，因为它很重要，就是我不会提倡在Go中坚持纯函数式编程。这样做可能会让你的生活，以及你同事的生活，比本应更艰难。选择适合工作的正确工具——有时那将是对象，有时那将是函数。
- en: Why not functional programming in Go?
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不在Go中使用函数式编程？
- en: To provide a holistic view of how FP can help us, as Go programmers, we should
    also consider when not to use FP. I view FP as a tool in my toolbox and when a
    problem lends itself to it, I will gladly use it – but just as importantly, we
    have to recognize when this does not work.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个全面的视角，了解函数式编程如何帮助我们，作为Go程序员，我们还应该考虑何时不使用函数式编程。我认为函数式编程是我的工具箱中的一个工具，当一个问题适合使用它时，我会乐意使用它——但同样重要的是，我们必须认识到何时这行不通。
- en: One of the concerns around FP is performance – while there is a lot to say on
    this topic, as we’ll see in later chapters, performance concerns could mean we
    throw out some functional concepts such as immutability in favor of executing
    with speed. This is more complex than it might sound at first, as Go pointers
    are not guaranteed to be faster than Go’s pass-by-value functions. We’ll expand
    more on the performance concerns in later chapters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数式编程（FP）的一个担忧是性能——虽然关于这个话题有很多可以说的，正如我们将在后面的章节中看到的，性能担忧可能意味着我们会为了追求速度而放弃一些函数式概念，比如不可变性。这比一开始听起来要复杂得多，因为Go的指针并不保证比Go的按值传递函数更快。我们将在后面的章节中进一步探讨性能担忧。
- en: Another reason not to choose FP is Go’s lack of tail-call optimization. In theory,
    every loop you write in your program could be replaced by a recursive call, but
    as of Go 1.18, Go does not have the necessary tools to do this efficiently and
    you’d risk running into stack overflows. There are ways around this, as we will
    see, but if it starts sacrificing performance or readability significantly, my
    advice would be to just write a loop. This is not to say recursion is never the
    right approach. If you’ve worked with trees or graphs extensively, you’ve probably
    written some recursive algorithms and found them to work just fine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不选择函数式编程的另一个原因是 Go 缺乏尾调用优化。理论上，你程序中写的每个循环都可以被递归调用所替代，但截至 Go 1.18，Go 没有必要的工具来有效地执行此操作，你可能会遇到栈溢出。我们将会看到有绕过这个问题的方法，但如果它开始显著牺牲性能或可读性，我的建议是直接写一个循环。这并不是说递归永远不会是正确的方法。如果你广泛地使用过树或图，你可能已经编写了一些递归算法，并发现它们工作得很好。
- en: Finally, if you are working on an existing code base with many other contributors,
    the best thing to do is follow the style of the code base. While some concepts
    of FP can be introduced quite easily, it is harder to enforce them in a team that’s
    not on board with the whole idea. Luckily, many programmers today see benefits
    in key concepts of FP. Even in Java or C#, the idea of immutable code is embraced.
    Side effects similarly are more and more seen as unwanted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你正在处理一个有许多其他贡献者的现有代码库，最好的做法是遵循代码库的风格。虽然函数式编程的一些概念可以相当容易地引入，但在一个不支持整个想法的团队中强制执行它们会更难。幸运的是，今天许多程序员都看到了函数式编程关键概念的益处。即使在
    Java 或 C# 中，不可变代码的想法也被接受。同样，副作用也越来越被视为不受欢迎的。
- en: Let’s embrace Go as a fully multi-paradigm language and leverage each paradigm
    where it makes sense.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拥抱 Go 作为一种完全的多范式语言，并在合理的地方利用每个范式。
- en: Comparing FP and OOP
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较函数式编程（FP）和面向对象编程（OOP）
- en: As we have seen in the preceding pages, FP is not exactly a new thing. It, in
    fact, predates the object-oriented paradigm by a few decades. While Go is multi-paradigm
    and we can embrace both styles of programming, let’s take a quick look at a concrete
    comparison between the two.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的页面所看到的，函数式编程并不完全是新事物。实际上，它比面向对象范式早了几十年。虽然 Go 是多范式的，我们可以接受两种编程风格，但让我们快速看一下两者之间的具体比较。
- en: '| **Functional programming** | **Object-oriented programming** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **函数式编程** | **面向对象编程** |'
- en: '| Functions are the bread and butter | Classes and objects are the bread and
    butter |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 函数是基础 | 类和对象是基础 |'
- en: '| Declarative code | Imperative code |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 声明式代码 | 命令式代码 |'
- en: '| Immutability preferred | Mutable state |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 优先考虑不可变性 | 可变状态 |'
- en: '| Can enforce purity | Often no focus on purity |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 可以强制纯净性 | 通常不关注纯净性 |'
- en: '| Recursion | Loops |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 递归 | 循环 |'
- en: 'Table 1.1: Table comparing FP (left) and OOP (right)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1：比较函数式编程（左）和面向对象编程（右）
- en: This comparison is a tad superficial. Many object-oriented languages also have
    a notion of recursion, but it’s not always central to the language’s design. Similarly,
    object-oriented code can encapsulate the mutable state and try to get immutability
    as much as possible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较有点肤浅。许多面向对象的语言也有递归的概念，但并不总是语言设计的核心。同样，面向对象的代码可以封装可变状态，并尽可能多地尝试实现不可变性。
- en: In today’s world, even languages that we consider traditionally object-oriented,
    such as Java, are, in fact, becoming more and more multi-paradigm.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今世界，即使是传统上被认为是面向对象的编程语言，如 Java，实际上也在变得越来越多范式。
- en: 'As a side note, this comparison might make it seem like there are only three
    possible paradigms: functional, object-oriented, or multi-paradigm. While these
    are certainly the most common, there are other paradigms, such as literate programming,
    logic programming, and reactive programming. As OOP is the main player in this
    space, and thus what most readers are familiar with, that will be a focus of comparison
    throughout this book.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，这种比较可能会让人感觉只有三种可能的范式：函数式、面向对象或多范式。虽然这些确实是最常见的，但还有其他范式，如文献编程、逻辑编程和响应式编程。由于面向对象编程在这个领域是主要参与者，因此大多数读者都熟悉，这本书将重点关注比较。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we have seen in this first chapter, FP is not exactly the “new kid on the
    block.” It is a paradigm that stems from the work of Alonzo Church in the 1930s.
    It has seen continuous and steady investment since the 1950s with various languages
    pushing the paradigm further and further.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中看到的，FP范式并不是“新来的孩子”。它是一种起源于20世纪30年代Alonzo Church工作的范式。自20世纪50年代以来，它一直持续稳定地受到投资，各种语言推动了这一范式不断向前发展。
- en: As we have also seen, FP and OOP are being combined more and more in modern
    languages, with Java and C# integrating ideas from the functional paradigm into
    their object-oriented paradigm. Go, the star of this book, takes this a step further
    and is a multi-paradigm language. Go gives us complete freedom to write code in
    whichever domain suits us best.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们看到的，FP和OOP在现代语言中越来越多地被结合在一起，Java和C#将函数式范式的思想整合到它们的面向对象范式中。本书的明星语言Go更进一步，是一种多范式语言。Go赋予我们完全的自由，以最适合我们的领域编写代码。
- en: The core idea to remember from this chapter is that the FP paradigm will help
    us write code that is easier to test, read, and maintain. It reduces cognitive
    overhead by limiting side effects, not mutating the state of our system, and favoring
    small composable functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章中需要记住的核心思想是，FP范式将帮助我们编写更容易测试、阅读和维护的代码。它通过限制副作用、不改变我们系统的状态以及偏好小型可组合函数来减少认知负担。
- en: Finally, it is also important to remember that, although we advocate for the
    FP paradigm in this book, Go is multi-paradigm, and we have to choose the right
    paradigm for the problem we are solving.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要记住，尽管在这本书中我们提倡FP范式，但Go语言是多范式的，我们必须为解决我们正在解决的问题选择正确的范式。
