- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Treating Functions as First-Class Citizens
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数视为一等公民
- en: As we established in the previous chapter, the core part of our functional programs
    will be functions. In this chapter, we are going to cover exactly why functions
    are powerful in languages that treat them as **first-class citizens**. Go has
    functions as first-class citizens out of the box, meaning we get this functionality
    by default. More and more languages are choosing this approach. In this chapter,
    we are going to see how this will allow us to create interesting constructs, which
    will improve the readability and test ability of our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中确立的，我们函数式程序的核心部分将是函数。在本章中，我们将详细探讨为什么在将函数视为**一等公民**的语言中函数如此强大。Go默认将函数作为一等公民，这意味着我们默认获得这种功能。越来越多的语言正在选择这种方法。在本章中，我们将看到这将如何允许我们创建有趣的构造，这将提高我们代码的可读性和可测试性。
- en: 'Concretely, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Benefits of first-class functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首类函数的优点
- en: Defining types for functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数定义类型
- en: Using functions like objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数当作对象使用
- en: Anonymous functions versus named functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数与命名函数的比较
- en: Storing functions in data types or structs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据类型或结构体中存储函数
- en: Creating a function dispatcher using all the previous
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用所有前面的内容创建一个函数分发器
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the examples for this chapter can be found at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2).
    For this example, any Go version will work
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有示例都可以在[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2)找到。对于这个示例，任何Go版本都可以使用
- en: Benefits of first-class functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首类函数的优点
- en: Before we talk about “first-class functions,” let’s first define what it means
    for anything to be called “first-class” in programming language design. When we
    talk about a “first-class citizen,” we mean an entity (object, primitive, or function)
    for which all the common language operations are available. These are operations
    such as assignment, passing it to a function, returning from a function, or storing
    it in another data type such as a map.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论“一等函数”之前，让我们首先定义在编程语言设计中称任何事物为“一等”的含义。当我们谈论“一等公民”时，我们指的是一个实体（对象、原始数据类型或函数），对于该实体，所有常见的语言操作都是可用的。这些操作包括赋值、将其传递给函数、从函数返回或将其存储在另一种数据类型（如映射）中。
- en: Looking at this list, we can see how all of those operations typically apply
    to the structs that we are defining in our language. Objects and primitives can
    be passed around between functions. They are often returned as the results of
    a function and we definitely assign them to variables. When we say that functions
    are first-class citizens, you can simply think of this as treating functions like
    objects. Their equivalence will help us create all future constructs in this book.
    They will lead to improved *testability*, such as by allowing us to mock functions
    of a struct, and improved *readability*, such as by removing large switch cases
    for a single function dispatcher.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个列表，我们可以看到所有这些操作通常都适用于我们在语言中定义的结构体。对象和原始数据类型可以在函数之间传递。它们通常作为函数的结果返回，并且我们确实将它们分配给变量。当我们说函数是一等公民时，你可以简单地将其视为将函数当作对象来对待。它们的等价性将帮助我们创建本书中的所有未来构造。这将提高*可测试性*，例如，通过允许我们模拟结构体的函数，以及提高*可读性*，例如，通过移除单个函数分发器的庞大switch语句。
- en: Defining types for functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为函数定义类型
- en: Go is a statically typed language. Although, we don’t have to spell out the
    type for each assignment – the types are there under the hood. It is effectively
    the compiler taking care of this for us. When we work with functions in Go, they
    are also implicitly assigned a type. While defining a type for a function in the
    way a compiler does it is a difficult task, we can use the concept of function
    aliases to add type safety to our code base.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种静态类型语言。尽管如此，我们不必为每个赋值指定类型——类型在底层已经存在。实际上，编译器会为我们处理这一点。当我们用Go处理函数时，它们也会隐式地被分配一个类型。虽然以编译器的方式为函数定义类型是一项困难的任务，但我们可以使用函数别名概念来为我们的代码库增加类型安全性。
- en: When working with functions throughout the rest of this book, we will often
    use **type aliases**. This will help the compiler provide more readable error
    messages, and also makes our code more readable in general. Type aliases are,
    however, not just useful in the context of functions. They are a great feature
    of Go that is not too often used. It’s also a feature that you won’t easily find
    in other mainstream languages. So let’s take a dive into what type aliases are.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分处理函数时，我们经常会使用**类型别名**。这将帮助编译器提供更易读的错误信息，并且通常使我们的代码更易读。然而，类型别名不仅适用于函数的上下文。它是Go的一个很棒的功能，但并不常用。这也是你在其他主流语言中不太容易找到的功能。所以，让我们深入了解类型别名是什么。
- en: In essence, a type alias does just what it says on the tin; it creates an alias
    for a type. It's similar to how in Unix systems you would create an alias for
    a command. It helps us create a new type that has all the same properties as the
    original type. One reason why we might want to do this is for readability, as
    we will see when creating aliases for functions. Another reason is to communicate
    our intent more clearly when we write code. For example, we could use our type
    system to define `CountryID` and `CityID` as an alias for `String`. Although both
    types are a string under the hood, they cannot be used interchangeably in code.
    Thus they communicate to the reader what the actual expected value is.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，类型别名正是它所说的那样；它为类型创建了一个别名。这类似于在Unix系统中为命令创建别名的方式。它帮助我们创建一个具有与原始类型相同属性的新类型。我们可能想要这样做的一个原因是为了可读性，正如我们在创建函数别名时将看到的。另一个原因是当我们编写代码时，更清晰地传达我们的意图。例如，我们可以使用我们的类型系统将`CountryID`和`CityID`定义为`String`的别名。尽管这两种类型在底层都是字符串，但在代码中它们不能互换使用。因此，它们向读者传达了实际期望的值。
- en: Type aliases for primitives
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型别名
- en: 'A common pattern to see in object-oriented languages is that the OO languages
    turn into `Person` struct, and we want to set a phone number on this struct:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，一个常见的模式是OO语言变成了`Person`结构体，而我们想要在这个结构体上设置一个电话号码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, which is heavily influenced by Java, we are creating a “setter-like”
    function that takes `phonenumber` as a string input and updates our object accordingly.
    If you are using an IDE that provides type hints for functions you are calling,
    it will just tell you that the `setPhoneNumberfunction` expects a string, which
    means any string is valid. Now, if we had a type alias, we could make that hint
    more useful.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，它受到了Java的很大影响，我们正在创建一个类似于“setter”的函数，该函数接受`phonenumber`作为字符串输入并相应地更新我们的对象。如果你使用的是提供函数类型提示的IDE，它将告诉你`setPhoneNumberfunction`期望一个字符串，这意味着任何字符串都是有效的。现在，如果我们有一个类型别名，我们可以使这个提示更有用。
- en: 'So, let’s make some changes and use a type alias for `phoneNumber`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们做一些修改，并使用类型别名`phoneNumber`：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By making this change, our type is now communicating more clearly with what
    our intent is, and with none of the overhead of creating a new struct just to
    model a phone number. We can do this, as a phone number can be thought of as essentially
    a string.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，我们的类型现在更清楚地传达了我们的意图，并且没有创建一个新结构体来模拟电话号码的开销。我们可以这样做，因为电话号码本质上可以看作是一个字符串。
- en: 'Using this, because a type alias is equivalent to the underlying type, is as
    easy as using a real string:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，因为类型别名等同于底层类型，就像使用一个真正的字符串一样简单：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, great. So we have a name, which is just a string, and `phonenumber`,
    which is a `phoneNumber` type, which is equal to a string. So where does the benefit
    come from? Well, part of it is gained in communicating intent. Code is read by
    many more people than the original author, so we want to be as clear as possible
    in our code. The other part is in the error messages. Using type aliases, error
    messages will tell us explicitly what was expected rather than just saying a string
    was expected. Let’s create a function that can update both `name` and `phonenumber`,
    and let’s first use `string` for both:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太棒了。所以，我们有一个名字，它只是一个字符串，还有一个`phonenumber`，它是一个`phoneNumber`类型，它等于一个字符串。那么，好处从哪里来呢？嗯，一部分是在传达意图中获得的。代码被比原作者更多的人阅读，所以我们的代码要尽可能清晰。另一部分是在错误信息中。使用类型别名，错误信息将明确告诉我们期望什么，而不仅仅是说期望一个字符串。让我们创建一个可以更新`name`和`phonenumber`的函数，并且首先使用`string`为两者：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What happens when we try to compile our code? Well, we will get the following
    error:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译我们的代码时会发生什么？嗯，我们将得到以下错误：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this simple example, it doesn’t do much. But as your code base expands, this
    ensures that all developers are thinking about the type that should be passed
    into a function. This lowers the risk of errors by passing invalid data to a function.
    An additional benefit, depending on the IDE, is that your IDE will also show you
    the signature. If you had a large function that takes five different types of
    string, your IDE might just show you *function expects input (string, string,
    string, string, string)*, with no clear order in which arguments need to be passed.
    If each string is a distinct type, this might become *name, phonenumber, email,
    street, country*. Especially in a language such as Go, where single-letter variable
    names are often used, this can create readability benefits.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，它并没有做什么。但随着你的代码库的扩展，这确保了所有开发者都在思考应该传递给函数的类型。这通过向函数传递无效数据来降低错误的风险。根据IDE的不同，还有一个额外的优点，即你的IDE也会显示签名。如果你有一个接受五种不同类型字符串的大函数，你的IDE可能只会显示*函数期望输入（string,
    string, string, string, string）*，没有任何明确的参数传递顺序。如果每个字符串都是不同的类型，这可能会变成*name, phonenumber,
    email, street, country*。特别是在像Go这样的语言中，单字母变量名经常被使用，这可以带来可读性的好处。
- en: 'To make our code work, we just have to make a small change to the function
    signature:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的代码工作，我们只需要对函数签名进行一个小改动：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is an easy fix and amounts to just a small change, but doing it consistently
    makes your code convey more meaning just with the type system. In the end, types
    are there to convey meaning to other readers as well as the compiler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复，仅仅是一个小的改动，但持续这样做可以让你的代码仅通过类型系统传达更多的意义。最终，类型的存在是为了向其他读者以及编译器传达意义。
- en: 'Let’s take a look at another benefit of type aliases. Let’s add an `age` field
    to our struct with its own type alias:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看类型别名的一个额外好处。让我们给我们的结构体添加一个带有其自己的类型别名的`age`字段：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One thing that we cannot do with primitive types in Go such as `uint` is to
    attach functions to them. When we assign a type alias, however, that restriction
    is gone. Hence, now we can attach functions to the `age` type, which really is
    just attaching a function to `uint`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们不能像对`uint`这样的原始类型那样，将函数附加到它们上。然而，当我们分配一个类型别名时，这种限制就消失了。因此，现在我们可以将函数附加到`age`类型上，这实际上就是将函数附加到`uint`上：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are creating a `valid` function, which is bound to
    the `age` type. In other functions, we can now call the `valid()` function on
    this type with the familiar dot notation. This example is a bit trivial, but it’s
    something that would not work on a primitive type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在创建一个`valid`函数，它绑定到`age`类型。现在，在其他函数中，我们可以使用熟悉的点符号在类型上调用`valid()`函数。这个例子可能有点微不足道，但它是一些在原始类型上无法工作的事情。
- en: 'If we tried to attach a function to a primitive, we would not be able to compile
    our program:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将一个函数附加到一个原始类型上，我们将无法编译我们的程序：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This throws the following error:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这会抛出以下错误：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This alone makes type aliases quite powerful. It also means you can now extend
    types that are not created by you in your code base. You might be working with
    an external library that exposes a struct, but you want to add your own functionality
    to it. One way of doing that is by creating a type alias and extending it with
    your own functionality. While diving into this example is too in-depth for what
    we’re exploring in this chapter, suffice it to say that type aliases are a powerful
    construct.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此一项就让类型别名变得非常强大。这也意味着你现在可以扩展你代码库中不是由你创建的类型。你可能正在使用一个公开结构的第三方库，但你想要向它添加自己的功能。实现这一点的其中一种方法是通过创建类型别名并使用你自己的功能来扩展它。虽然深入这个例子超出了我们本章要探讨的范围，但可以简单地说，类型别名是一个强大的结构。
- en: Type aliases for functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的类型别名
- en: As a function is a *first-class citizen* in Go, we can work with them like we
    would with any other data type. Thus, just as we can create a type alias for a
    variable or a struct, we can also create a type alias for a function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Go中函数是一个*一等公民*，我们可以像处理任何其他数据类型一样处理它们。因此，就像我们可以为变量或结构体创建类型别名一样，我们也可以为函数创建类型别名。
- en: 'Why might we want to do this? The main benefit for the reader of our code will
    be the clarity and readability it creates. Look at the following piece of code
    for a `filter` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做呢？我们代码的读者获得的主要好处将是它带来的清晰度和可读性。看看以下`filter`函数的代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function is a good example of using functions as first-class citizens.
    Here, the `predicate` function is a function that is passed to the `filter` function.
    It is passed around in the same way in which we would typically pass around objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是使用函数作为一等公民的一个很好的例子。在这里，`predicate`函数是一个传递给`filter`函数的函数。它以我们通常传递对象的方式传递。
- en: 'If we want to clean up this function signature, we can introduce a type alias
    and rewrite the filter function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要清理这个函数签名，我们可以引入一个类型别名并重写过滤器函数：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you can see that the second argument now takes the `predicate` type. The
    compiler will translate this type to `func(int) bool`, but we can just write `predicate`
    throughout our code base.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到第二个参数现在接受`predicate`类型。编译器将把这个类型转换为`func(int) bool`，但我们可以只在代码库中写`predicate`。
- en: 'Another benefit of introducing a type alias is that our error messages become
    more readable. Let’s imagine we pass a function to `filter` that does not adhere
    to the `predicate` type declaration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 引入类型别名的好处之一是，我们的错误消息变得更加易读。让我们想象一下，我们向`filter`传递了一个不遵循`predicate`类型声明的函数：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Without a type alias, the error message reads as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类型别名，错误消息的读法如下：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That’s an error message that, while being quite explicit, is quite verbose
    to read. With the type alias, the message will tell us what type of function we
    expected:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误消息，虽然非常明确，但读起来相当冗长。有了类型别名，消息将告诉我们期望的是哪种类型的函数：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using functions as objects
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为对象使用
- en: In the preceding section, we saw how to create type aliases to make our code
    more readable when dealing with functions. In this section, let’s take a brief
    look at how functions can be used in the same way as objects. This is the essence
    of what it means to be *first-class*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何创建类型别名来使我们的代码在处理函数时更加易读。在本节中，让我们简要地看看函数如何像对象一样使用。这就是*一等*的含义。
- en: Passing functions to functions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数传递给函数
- en: 'We can pass functions to functions as in the preceding filter function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将函数传递给函数，就像前面的过滤器函数那样：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we have created the `largerThanTwo` function, which adheres
    to the `predicate` type alias. Note that we don’t have to specify anywhere that
    this function adheres to our `predicate` type; the compiler will figure this out
    during compile time, just like it does for regular variables. Next, we have created
    a `filter` function, which expects both a slice of `ints` as well as a `predicate`
    function. In our `main` function, we create a slice of `ints` and call the `filter`
    function with the `largerThanTwo` function as the second parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`largerThanTwo`函数，它遵循`predicate`类型别名。请注意，我们不必在任何地方指定这个函数遵循我们的`predicate`类型；编译器将在编译时解决这个问题，就像它对常规变量所做的那样。接下来，我们创建了一个`filter`函数，它期望一个`ints`切片以及一个`predicate`函数。在我们的`main`函数中，我们创建了一个`ints`切片，并使用`largerThanTwo`函数作为第二个参数调用`filter`函数。
- en: In-line function definitions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联函数定义
- en: 'We don’t have to create functions such as `largerThanTwo` in the package scope.
    We can create functions inline, in the same way in which we can create structs
    inline:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在包作用域中创建像`largerThanTwo`这样的函数。我们可以像创建内联结构体一样创建内联函数：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `inlinePersonStruct` is shown in this code as an example of how the inline
    function compares to the inline struct definition. The code won’t actually compile
    with this struct present as it’s not used in the rest of our `main` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`inlinePersonStruct`在这个代码中作为内联函数与内联结构体定义比较的例子。实际上，由于这个结构体在`main`函数的其余部分没有使用，所以代码不会编译。'
- en: Anonymous functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'We can also create functions on the fly where they are needed. These are called
    *anonymous* functions as they don’t have a name assigned to them. Continuing with
    our `filter` function, the anonymous function version of a `largerThanTwo` predicate
    would look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在需要的地方动态创建函数。这些被称为*匿名函数*，因为它们没有分配给它们的名字。继续使用我们的`filter`函数，一个`largerThanTwo`谓词的匿名函数版本看起来是这样的：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we are both creating a slice of integers as well as
    the predicate function inline. Neither of them is named. The slice cannot be referenced
    anywhere else in that `main` function and neither can the function. While function
    definitions like these tend to make our code more verbose and can hinder readability,
    we will see applications of them in [*Chapter 3*](B18771_03.xhtml#_idTextAnchor047)
    and [*Chapter 4*](B18771_04.xhtml#_idTextAnchor060).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们既创建了一个整数切片，也创建了内联的谓词函数。它们都没有命名。切片不能在该`main`函数的任何其他地方引用，函数也是如此。虽然这类函数定义会使我们的代码更加冗长，并可能阻碍可读性，但我们将看到它们在[*第3章*](B18771_03.xhtml#_idTextAnchor047)和[*第4章*](B18771_04.xhtml#_idTextAnchor060)中的应用。
- en: Returning functions from functions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数中返回函数
- en: A core concept of any programming language is returning a value from a function.
    As a function is treated just like a regular object, we can return a function
    from a function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的核心概念之一是从函数中返回一个值。由于函数被当作一个普通对象来处理，我们可以从一个函数中返回一个函数。
- en: 'In the earlier examples, our predicate `largerThanTwo` function always checked
    whether or not an integer was larger than two. Now, let’s create a function that
    can generate such predicate functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们的`largerThanTwo`谓词函数始终检查一个整数是否大于两个。现在，让我们创建一个可以生成此类谓词函数的函数：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we have created a `createLargerThanPredicate` function, which
    returns a `predicate`. Remember that the type `predicate` is just a type alias
    for a function that takes an integer as input and returns a bool as output. Next,
    we define the function that we are returning in the function body.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`createLargerThanPredicate`函数，它返回一个`predicate`。记住，类型`predicate`只是一个类型别名，代表一个接受整数作为输入并返回bool作为输出的函数。接下来，我们在函数体中定义我们返回的函数。
- en: 'The function we are returning follows the type signature of `predicate`, and
    it returns true if `i` is larger than `threshold`. Notice that the `i` function
    is not passed to the `createLargerThanPredicate` function itself. We have defined
    that inline. When we call the `createLargerThanPredicate` function, we don’t get
    the outcome of the predicate function, but rather we get a new function that follows
    the inner signature:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的函数遵循`predicate`的类型签名，如果`i`大于`threshold`则返回true。请注意，`i`函数并没有传递给`createLargerThanPredicate`函数本身。我们是在内联定义的。当我们调用`createLargerThanPredicate`函数时，我们得到的不是谓词函数的结果，而是一个遵循内部签名的新的函数：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, in the `main` function, we first call the `createLargerThanPredicate(2)`
    function. This returns a new `func(i int) bool` function. The `2` here refers
    to the `threshold` parameter, not the `i` parameter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`main`函数中，我们首先调用`createLargerThanPredicate(2)`函数。这返回一个新的`func(i int) bool`函数。这里的`2`指的是`threshold`参数，而不是`i`参数。
- en: On the next line, we can once again call the `filter` function with the newly
    created `largerThanTwo` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们再次可以使用新创建的`largerThanTwo`函数调用`filter`函数。
- en: 'Returning functions from functions will be a core concept when we dive into
    more advanced topics such as *continuation-passing style* programming and function
    currying. For now, the main takeaway is that this allows us to create customizable
    functions on the fly. For example, we could create a series of “larger than” predicates
    each with its own threshold:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究更高级的主题，如*传递风格*编程和函数柯里化时，从函数中返回函数将是一个核心概念。目前，主要的收获是这允许我们即时创建可定制的函数。例如，我们可以创建一系列具有各自阈值的“大于”谓词：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that this example won’t compile, as we’re not using the functions anywhere
    in the remainder of the `main` block. But this shows us how we can essentially
    “spawn” functions with one parameter fixed. Instead of creating these functions
    inside function blocks, we can move them up to the package-specific `var` block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子无法编译，因为我们没有在`main`块的其余部分使用这些函数。但这展示了我们如何基本上“生成”具有一个固定参数的函数。我们不必在函数块内创建这些函数，而是可以将它们移动到包特定的`var`块。
- en: Functions in var
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数在var中
- en: 'Continuing the preceding example, we can create a series of functions that
    can be used throughout our package:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的例子，我们可以创建一系列可以在整个包中使用的函数：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These “function factories” allow us to create some customized functions throughout
    our code. One thing to note here is that this will work inside `var` blocks, but
    will not compile if we move these to a `const` block:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“函数工厂”使我们能够在整个代码中创建一些自定义函数。这里需要注意的是，这将在`var`块内部工作，但如果我们将这些移动到`const`块，则无法编译：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will generate the following errors:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下错误：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our functions are not considered “constants” from a package perspective.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数从包的角度来看不被认为是“常量”。
- en: Functions inside data structures
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构内部的函数
- en: So far, we have been creating a bunch of functions that were either defined
    at the top-level `var` block or inline inside a function. What if we want to store
    our function somewhere in the runtime memory of our application?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建了一大堆函数，这些函数要么是在顶层 `var` 块中定义的，要么是在函数内联定义的。如果我们想在应用程序的运行时内存中某个地方存储我们的函数怎么办？
- en: Well, just like we can store primitives and structs inside our runtime memory,
    we can store functions there as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，就像我们可以在运行时内存中存储原始类型和结构体一样，我们也可以在那里存储函数。
- en: 'Let’s start off by storing our `largerThan` predicates in an array. We’ll move
    the predicate declarations back to the `var` block and pass them to a `filter`
    function in our `main` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将我们的 `largerThan` 谓词存储在数组中开始。我们将谓词声明移回 `var` 块，并在 `main` 函数中传递给 `filter`
    函数：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding example, we have created a “slice of predicates.” The type
    would be `[]predicate`, and as part of the declaration, we have also pushed the
    three predicates we created earlier to this slice. After this line, the slice
    contains a reference to the three functions: `largerThanTwo`, `largerThanFive`,
    and `largerThanHundred`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个“谓词切片”。类型将是 `[]predicate`，作为声明的一部分，我们还将我们之前创建的三个谓词推送到这个切片中。在这行代码之后，切片包含对三个函数的引用：`largerThanTwo`、`largerThanFive`
    和 `largerThanHundred`。
- en: 'Once we have created this slice, we can iterate over it just like any regular
    slice. When we write `for _, predicate := range predicates`, the value of `predicate`
    takes on the value of each function we stored in the slice, sequentially. Thus,
    when we print the output of our filter function for each subsequent iteration,
    we get the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了切片，我们就可以像任何常规切片一样迭代它。当我们写 `for _, predicate := range predicates` 时，`predicate`
    的值将依次取我们存储在切片中的每个函数的值。因此，当我们为每个后续迭代打印过滤函数的输出时，我们得到以下内容：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the first iteration, `predicate` refers to the `largerThanTwofunction`; in
    the second iteration, it becomes `largerThanFive`, and finally becomes `largerThanHundred`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，`predicate` 指的是 `largerThanTwofunction`；在第二次迭代中，它变为 `largerThanFive`，最后变为
    `largerThanHundred`。
- en: 'Similarly, we can store functions inside a map:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在映射中存储函数：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this example, we create a map that stores predicates and associates the
    predicate function with a string as the key. We can then call the `filter` function
    and ask the map to return the function associated with the `"2"` key. This returns
    the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个存储谓词并关联谓词函数与字符串作为键的映射。然后我们可以调用 `filter` 函数并要求映射返回与 `"2"` 键关联的函数。这返回以下内容：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This pattern is quite powerful, which we’ll explore later in this chapter, in
    *Example 1*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常强大，我们将在本章后面的 *示例 1* 中探讨。
- en: Before we dive into that example, let’s take a look at storing functions inside
    structs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入那个例子之前，让我们看看如何在结构体内部存储函数。
- en: Functions inside structs
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体内部的函数
- en: By now, it should come as no surprise that wherever we can use a data type,
    a function can play that role. Let’s see how this plays out for structs. Let’s
    create a struct called `ConstraintChecker`, which checks whether or not a value
    is in between two values.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们可以在任何可以使用数据类型的地方使用函数，让我们看看这在结构体中是如何体现的。让我们创建一个名为 `ConstraintChecker`
    的结构体，该结构体用于检查一个值是否介于两个值之间。
- en: 'Let’s start off by defining our struct. The `ConstraintChecker` struct has
    two fields. Each field is a function of type `predicate`. The first function is
    `largerThan` and the second is `smallerThan`. These are the boundaries between
    which the input number should lie:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们的结构体开始。`ConstraintChecker` 结构体有两个字段。每个字段都是类型为 `predicate` 的函数。第一个函数是
    `largerThan`，第二个是 `smallerThan`。这些是输入数字应该位于其间的边界：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create a method for this struct. The `check` method takes an integer
    input and passes this on to the `largerThan` and `smallerThan` functions, respectively.
    As both predicate functions return a bool, we simply check that the input returns
    true for both these functions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为这个结构体创建一个方法。`check` 方法接受一个整数输入，并将其分别传递给 `largerThan` 和 `smallerThan`
    函数。由于这两个谓词函数都返回一个布尔值，我们只需检查输入在这两个函数中返回的值是否为真：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have our struct and our method created, let’s take a look at how
    we would use this struct:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了结构体和我们的方法，让我们看看我们如何使用这个结构体：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our main function, we first instantiate the functions. Note that we can create
    the `ConstraintChecker` struct both by providing an existing function, as we have
    done for `largerThan`, as well as by using an anonymous function as is the case
    for the `smallerThan` field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们首先实例化函数。请注意，我们可以通过提供现有函数（如我们为`largerThan`所做的那样）以及使用匿名函数（如`smallerThan`字段的情况）来创建`ConstraintChecker`结构体。
- en: This shows how a struct can store functions, and how these functions can be
    treated just like any other field in the struct. In essence, we could treat each
    function that is **bound** to a struct as a function that is a **field** of the
    struct. There are advantages to passing functions as a field versus binding it,
    which we will explore in more detail later, in *Example 2* in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了结构体可以存储函数，以及这些函数如何被当作结构体中的任何其他字段来对待。本质上，我们可以将绑定到结构体的每个函数视为结构体的一个**字段**函数。将函数作为字段传递与绑定相比有一些优势，我们将在本章的*示例
    2*中更详细地探讨。
- en: The main difference is that a function that is bound is essentially constant
    – the implementation does not change. Whereas a function passed to a field is
    entirely flexible. The actual implementation is unknown to our struct. We’ll explore
    in more detail how this allows us to mock functions for testing in *Example 2*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，绑定到函数的函数本质上是不变的——实现不会改变。而传递给字段的函数则完全灵活。实际的实现对我们这个结构体来说是未知的。我们将在*示例 2*中更详细地探讨这是如何允许我们为测试模拟函数的。
- en: Example 1 – map dispatcher
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – 映射调度器
- en: One pattern that is enabled by these types of first-class functions is the “map
    dispatcher pattern.” This is a pattern where we use a map of “key to function.”
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些一等函数类型使得“映射调度器模式”成为可能。这是一种模式，其中我们使用“键到函数”的映射。
- en: Creating a simple calculator
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的计算器
- en: For this first example, let’s build a really simple calculator. This is just
    to demonstrate the idea of dispatching functions based on a certain input value.
    In this case, we are going to build a calculator that takes two integers as input,
    an operation, and returns the result of this operation to the user. For this first
    example, we are only supporting the addition, subtraction, multiplication, and
    division operations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个例子，让我们构建一个真正简单的计算器。这只是为了演示基于特定输入值调度函数的想法。在这种情况下，我们将构建一个计算器，它接受两个整数作为输入，一个操作，并将这个操作的结果返回给用户。对于这个第一个例子，我们只支持加法、减法、乘法和除法操作。
- en: 'First, let’s define the basic functions that are supported:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义支持的基本函数：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So far, this is all pretty standard stuff. We have a few functions that our
    calculator supports. In most cases, the result is returned instantly, but for
    the division function, we’ll do a quick check to make sure we’re not dividing
    by zero and panic otherwise. In a real application, we’d avoid the `panic` operation
    as much as possible, but for this example, it doesn’t really have any impact.
    No users were harmed by having a panic in this example!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些都是相当标准的东西。我们的计算器支持一些函数。在大多数情况下，结果会立即返回，但对于除法函数，我们会快速检查以确保我们不是除以零，否则会恐慌。在实际应用中，我们会尽量避免使用`panic`操作，但在这个例子中，它实际上没有任何影响。在这个例子中，没有用户因为恐慌而受到伤害！
- en: 'Next, let’s take a look at how we’d implement the `calculate` function, which
    takes two numbers and the desired operation. We’ll implement this first without
    considering functions as first-class citizens and use a `switch` statement instead
    to decide which operation to dispatch:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何实现`calculate`函数，它接受两个数字和所需的操作。我们将首先不考虑函数作为一等公民，而是使用`switch`语句来决定调度哪个操作：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each branch of the `switch` statement performs the desired operation on our
    numbers and returns the result. If the options are exhausted and nothing matched
    the input, we panic. Each time we added a new function to our calculator, we would
    have to extend this function with another branch. Over time, this might not be
    the most readable option. So let’s look at an alternative using what we’ve learned
    so far in this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句的每个分支都会对我们的数字执行所需的操作并返回结果。如果选项耗尽且没有匹配输入，我们会恐慌。每次我们向计算器添加一个新函数时，我们都需要通过另一个分支扩展这个函数。随着时间的推移，这可能不是最可读的选项。所以，让我们看看本章到目前为止学到的替代方案。'
- en: 'First, let’s introduce a type for these kinds of functions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍这类函数的类型：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, let’s create a map where we can bind the string input of a user to a
    calculator function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个映射，我们可以将用户的字符串输入绑定到计算器函数：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This map is called `operations`. The key of the map is the input the user will
    provide, which is the operations we support in our calculator. We have bound each
    input to a specific function call.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个映射被称为 `operations`。映射的键是用户将提供的输入，即我们在计算器中支持的运算。我们将每个输入绑定到特定的函数调用。
- en: 'Now, if we want to implement the actual `calculate` function, we just have
    to look up the key in our map and call the corresponding function. If the requested
    operation does not match a key in our map, we’ll panic. This is similar to the
    default branch in the switch-based approach:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想实现实际的 `calculate` 函数，我们只需在我们的映射中查找键并调用相应的函数。如果请求的操作与我们的映射中的键不匹配，我们会陷入恐慌。这与基于
    switch 的方法的默认分支类似：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This way, we can replace `Switch` statements with a map dispatcher. Also remember
    also that a map lookup is typically done in constant time, so this implementation
    of a function dispatcher is fairly efficient. It does require us to use a bit
    more memory to bind keys to functions, but this is negligible. With this approach,
    adding a new operation is a matter of adding a new entry to our map rather than
    extending the `switch` statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以用映射调度器替换 `Switch` 语句。同时记住，映射查找通常是常数时间完成的，所以这种函数调度器的实现相当高效。它确实需要我们使用更多内存来绑定键到函数，但这可以忽略不计。使用这种方法，添加新操作只需在我们的映射中添加一个新条目，而不是扩展
    `switch` 语句。
- en: 'With the use of anonymous functions, we could also define the dispatched function
    inline. For example, this is how we would extend the map with bitshift functions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名函数，我们还可以在行内定义调度函数。例如，这是我们将如何扩展映射以包含位移函数的方式：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this way, we can create a map dispatcher for anonymous functions. This could
    become rather verbose to read though, so use your best judgment when applying
    this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以为匿名函数创建一个映射调度器。但这可能会变得难以阅读，所以在应用时请使用最佳判断。
- en: Example 2 – mocking functions for testing
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 2 – 测试时模拟函数
- en: In the following example, we will take a look at mocking functions using what
    we have learned so far in this chapter. The application we will be building and
    testing is a simple to-do application. The to-do application simply allows a user
    to add text to a to-do, to overwrite all content.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将通过使用本章学到的内容来模拟函数。我们将构建和测试的应用程序是一个简单的待办事项应用程序。这个待办事项应用程序简单地允许用户向待办事项添加文本，或覆盖所有内容。
- en: We won’t be using an actual database, so we’ll imagine that this one exists
    and use the filesystem and program arguments instead. Our goal will be to create
    tests for this application where we can mock the database interactions. To achieve
    this, we will use functions as first-class citizens and type aliases for code
    readability.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会使用实际的数据库，所以我们将想象这个数据库存在，并使用文件系统和程序参数。我们的目标将是创建测试此应用程序，其中我们可以模拟数据库交互。为了实现这一点，我们将使用函数作为一等公民和类型别名以提高代码可读性。
- en: 'The complete example can be found on GitHub: [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2/Examples/TestingExample](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2/Examples/TestingExample)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在 GitHub 上找到：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2/Examples/TestingExample](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter2/Examples/TestingExample)
- en: 'Let’s start by setting up our main structs. The two structs we will need are
    `Todo` and `Db`. The `Todo` struct represents the to-do item, which will contain
    a piece of text. The struct also contains a reference to a `Db` struct:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置我们的主要结构体开始。我们需要两个结构体：`Todo` 和 `Db`。`Todo` 结构体表示待办事项，它将包含一段文本。该结构体还包含对
    `Db` 结构体的引用：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we also created a “constructor” function, to ensure that users
    get a correctly initialized object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还创建了一个“构造函数”，以确保用户得到一个正确初始化的对象。
- en: 'We will add two functions bound to this struct: `Write` and `Append`. The `Write`
    function will override the content of the `Text` field, while the `Append` function
    will add content to the existing field’s content. Let’s also assume that any call
    to these functions can only be done by authorized users. As such, we’ll first
    make a database call to figure out whether the user is authorized to perform this
    action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个结构体添加两个绑定函数：`Write` 和 `Append`。`Write` 函数将覆盖 `Text` 字段的内容，而 `Append` 函数将内容添加到现有字段的现有内容中。让我们还假设对这些函数的调用只能由授权用户进行。因此，我们首先进行数据库调用，以确定用户是否有权执行此操作：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With this in place, let’s take a look at the fake database. As we want to be
    able to mock our database’s functions in the tests that we will write later, we
    will leverage the concept of first-class functions. First, we’ll create a `Db`
    struct. As we are only pretending that we are connecting to a real database, we
    won’t bother with setting up the connection and having an actual database running
    somewhere:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们看看模拟数据库。因为我们希望在稍后编写的测试中能够模拟数据库的函数，我们将利用一等函数的概念。首先，我们将创建一个`Db`结构体。因为我们只是在假装连接到一个真实的数据库，所以我们不会麻烦地设置连接并让一个实际的数据库在某处运行：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is the struct definition of `Db`. Remember that functions can be stored
    as fields in a struct. And that’s what’s happening here, our `Db` struct contains
    a single field called `AuthorizationFn`. This is a reference to a function of
    type `authorizationFunc`. Remember that this is just a type alias. The compiler
    will actually expect a function with the `func() bool` signature. Thus, we are
    expecting a function that takes no arguments as input and returns a bool.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Db`的结构体定义。记住，函数可以作为结构体的字段存储。这正是这里发生的事情，我们的`Db`结构体包含一个名为`AuthorizationFn`的单个字段。这是一个指向类型`authorizationFunc`的函数的引用。记住，这只是一个类型别名。编译器实际上会期望一个具有`func()
    bool`签名的函数。因此，我们期望一个不接受任何输入参数并返回bool值的函数。
- en: 'Now, let’s create such an authorization function. As this example is self-contained,
    we’re not interested in the overhead of having an actual database in use. For
    this example, assume that a user is authorized if the program arguments contain
    the `admin` string as the first argument to our program:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建这样一个授权函数。由于这个示例是自包含的，我们不对使用实际数据库的开销感兴趣。对于这个例子，假设如果程序参数包含作为程序第一个参数的`admin`字符串，则用户被授权：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice that this function matches the function signature for the type `authorizationFunc`.
    As such, this can be stored inside the `authorizationFn` field of our `Db` struct.
    Next, let’s create a constructor type function for our `Db` so we can give users
    a correctly initialized struct:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个函数与类型`authorizationFunc`的函数签名相匹配。因此，它可以存储在我们的`Db`结构体的`authorizationFn`字段中。接下来，让我们为我们的`Db`创建一个构造函数类型函数，这样我们就可以为用户提供一个正确初始化的结构体：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice how we are passing the `argsAuthorization` function to the `AuthorizationFn`
    field. Whenever we are creating a database, we can thus change the implementation
    of `AuthorizationFn` to match our use case. We’ll leverage this for unit testing
    later, but you could also leverage this to provide different authorization implementations,
    thus improving the reusability of our struct.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何将`argsAuthorization`函数传递给`AuthorizationFn`字段的。因此，每次我们创建数据库时，我们都可以更改`AuthorizationFn`的实现以匹配我们的用例。我们将利用这一点来进行单元测试，但你也可以利用这一点来提供不同的授权实现，从而提高我们结构体的可重用性。
- en: 'A handy construct to introduce here is to also create a function bound to the
    `Db` object, which will call the inner authorization function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里引入一个方便的结构是创建一个绑定到`Db`对象的函数，该函数将调用内部授权函数：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a simple quality-of-life improvement. In this way, we could add code
    to `IsAuthorized`, which runs regardless of which implementation is chosen for
    the authorization function. We could add logs here for debugging, collecting metrics,
    handling potential exceptions, and so forth. In our case, we’ll keep it as a simple
    function call to `AuthorizationFn`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的质量改进。这样，我们可以在`IsAuthorized`中添加代码，无论选择哪种实现方式，它都会运行。我们可以在那里添加日志进行调试、收集指标、处理潜在的异常等等。在我们的情况下，我们将保持它为一个简单的对`AuthorizationFn`的函数调用。
- en: With this in place, let’s now think about testing our code. Without mocking
    the `IsAuthorized` function, our tests would fail the `Write` and `Append` tests,
    as only authorized users can call those functions. Our test runs should not depend
    on the “outside world” to succeed. Unit tests should run in isolation without
    caring about real underlying systems (in this case, program arguments, but in
    a real scenario, the actual database).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们现在考虑测试我们的代码。如果不模拟`IsAuthorized`函数，我们的测试将无法通过`Write`和`Append`测试，因为只有授权用户才能调用这些函数。我们的测试运行不应该依赖于“外部世界”来成功。单元测试应该在隔离状态下运行，而不关心真实的底层系统（在这种情况下，程序参数，但在实际场景中，实际的数据库）。
- en: 'So, how do we get around this? We will mock the `authorizationFn` implementation
    by creating a `Db` struct with our own `AuthorizationFn` in its place:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这个问题呢？我们将通过创建一个包含我们自己的`AuthorizationFn`的`Db`结构体来模拟`authorizationFn`的实现：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice how in the setup of this test, we are manually constructing a `Todo`
    struct rather than calling the constructor-type `newTodo()` function. We’re also
    manually constructing `Db`. This is to avoid the default implementation from running
    in our unit tests. Instead of using the existing function found in the code, we’re
    providing a custom authorization function. Our custom function simply returns
    true for every call to `IsAuthorized`. This is the desired behavior in our test
    case, as we want to test the functionality of the `Todo` struct rather than that
    of `Db`. Using this pattern, we can mock core parts of our implementation. We
    also get the additional benefit that our structs themselves have become more flexible,
    as implementations can now be swapped out even at runtime.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个测试的设置中，我们手动构建了一个`Todo`结构体，而不是调用构造函数类型的`newTodo()`函数。我们还在手动构建`Db`。这是为了避免在单元测试中运行默认实现。我们不是使用代码中找到的现有函数，而是提供了一个自定义的授权函数。我们的自定义函数简单地对每次调用`IsAuthorized`返回true。这是我们测试用例中期望的行为，因为我们想测试`Todo`结构体的功能，而不是`Db`的功能。使用这种模式，我们可以模拟实现的核心部分。我们还得到了额外的好处，即我们的结构体本身变得更加灵活，因为实现现在可以在运行时进行替换。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have taken a look at what first-class functions are and
    what type of use cases they open up to us as Go developers. We have taken a look
    at the equivalence between functions and objects, such as how they can be instantiated,
    passed around as parameters, stored inside other data structures, and returned
    from other functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了作为Go开发者，一等函数是什么以及它们为我们打开了哪些类型的用例。我们探讨了函数与对象之间的等价性，例如它们如何被实例化、作为参数传递、存储在其他数据结构中，以及从其他函数返回。
- en: We have also learned how type aliases can be used to create more readable code
    and to provide clearer error messages. We’ve seen how these can be applied to
    both functions as well as regular data types for structs and primitives.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用类型别名来创建更易读的代码，并提供更清晰的错误消息。我们看到了这些如何应用于函数以及结构体和原始数据类型的常规数据类型。
- en: In the examples, we have seen how we can create a readable function dispatcher,
    as well as how we can leverage first-class functions to create mocks of functions.
    In the next chapter, we will use what we have learned in this chapter to build
    higher-order functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们看到了如何创建一个可读的函数分发器，以及如何利用一等函数创建函数的模拟。在下一章中，我们将使用本章学到的知识来构建高阶函数。
