- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Writing Testable Code with Pure Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纯函数编写可测试的代码
- en: When you read about functional programming, quite often, what is meant is “pure”
    functional programming. As we touched on in the first chapter, this is not a strict
    requirement of functional programming or functional languages. If you decide to
    pick up a functional programming language, the chances are pretty high that you’ll
    pick up a language such as Haskell or Elm. If so, you would have chosen two purely
    functional languages and might have coupled your understanding of *pure functional*
    with *functional*. On the other hand, if you had picked up a language such as
    Lisp, Clojure, or Erlang, you would have picked a functional language that is
    impure yet still functional.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读有关函数式编程的内容时，相当常见的是指的是“纯”函数式编程。正如我们在第一章中提到的，这并不是函数式编程或函数式语言的严格要求。如果你决定学习函数式编程语言，你很可能选择像Haskell或Elm这样的语言。如果是这样，你就选择了两种纯函数式语言，并且可能会将你对*纯函数式*的理解与*函数式*相结合。另一方面，如果你选择了像Lisp、Clojure或Erlang这样的语言，你就选择了一种不纯但仍然是函数式的语言。
- en: 'In this chapter, we will address the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: What exactly is purity?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯度究竟是什么？
- en: Why should purity matter?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么纯度很重要？
- en: How do we create pure functions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何创建纯函数？
- en: Learning how unit testing is impacted by writing pure functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何通过编写纯函数来影响单元测试
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, any version of Go after Go 1.12 can be used. You can find
    the complete examples at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，可以使用Go 1.12之后的任何版本。你可以在[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4)找到完整的示例。
- en: What is purity?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是纯度？
- en: 'When talking about a purely functional programming language, we are talking
    about a language in which each function adheres to these properties:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论纯函数式编程语言时，我们指的是一种每个函数都遵循以下特性的语言：
- en: Does not generate any side effects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不产生任何副作用
- en: Returns the same output when providing the same input (idempotence)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供相同的输入时返回相同的输出（幂等性）
- en: This means that our functions are completely deterministic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的函数是完全确定性的。
- en: The best way forward might be to demonstrate what we are talking about by showing
    some examples. So, in this section, we’ll take a look at two functions, a pure
    one and another which is impure. Then, we’ll talk a bit more about the properties
    of such functions and their importance to the programs that we are writing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的前进方式可能是通过展示一些例子来演示我们正在讨论的内容。因此，在本节中，我们将查看两个函数，一个是纯函数，另一个是不纯函数。然后，我们将更多地讨论这类函数的特性及其对我们所编写的程序的重要性。
- en: Demonstrating pure versus impure function calls
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示纯函数与不纯函数调用的区别
- en: 'A simple example of this would be an addition function. This is a function
    that takes two integers as input and returns the sum as the output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个简单例子就是一个加法函数。这是一个接收两个整数作为输入并返回和作为输出的函数：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we call this function with the same inputs, we will get consistent output.
    Thus, no matter how many times I call the `add(10,5)` function, the code will
    always return the same output: 15\. This is pretty much as simple as it gets when
    creating a pure function. We did not use any state outside of our function to
    determine the answer, nor did we update anything outside of our function.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用相同的输入调用这个函数时，我们将得到一致的结果。因此，无论我调用`add(10,5)`函数多少次，代码总是会返回相同的输出：15。在创建纯函数时，这一点非常简单。我们没有在函数外部使用任何状态来确定答案，也没有在函数外部更新任何内容。
- en: 'Next, let’s look at an example of an impure function, whose output is always
    random:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一个不纯函数的例子，其输出总是随机的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When calling the `rollDice` function, the output is not consistent. If it were
    consistently outputting the same number, it would be a pretty bad randomization
    function. If we were to call the `rollDice` function five times, we’d get five
    different outputs:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`rollDice`函数时，输出并不一致。如果它总是输出相同的数字，那将是一个非常糟糕的随机化函数。如果我们调用`rollDice`函数五次，我们会得到五个不同的输出：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This would result in the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Referential transparency
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指称透明性
- en: 'One property that helps us think about pure functions is the property of *referential
    transparency*. Both in mathematics and computer science, a function is said to
    be referentially transparent if you can replace the function call with its output,
    without changing the result of the program. In mathematics, it’s easy to see why
    that is true. If we work out any formula, we can essentially substitute part of
    an equation for its result, without changing the result. For example, take the
    following equation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特性帮助我们思考纯函数，那就是引用透明性的特性。在数学和计算机科学中，如果一个函数可以被其输出所替换，而不改变程序的结果，那么这个函数就被认为是引用透明的。在数学中，这一点很容易理解。如果我们解出任何公式，我们实际上可以用其结果替换方程的一部分，而不会改变结果。例如，考虑以下方程：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result is 5\. We could have gotten the same result had we replaced the
    multiplication with its result, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是5。如果我们用其结果替换乘法，我们同样可以得到相同的结果，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This property is what we mean by referential transparency. All mathematical
    operations have this property, and many of us have leveraged this property when
    working out equations in our algebra, calculus, or other mathematics classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性就是我们所说的引用透明性。所有数学运算都具有这个特性，我们中的许多人都在代数、微积分或其他数学课程中利用了这个特性来解决问题。
- en: 'Let’s jump back to the realm of software engineering to explore this further.
    In a programming language, referential transparency means that a function call
    can be replaced with its result. If we apply this same test to our `add` function,
    which we wrote earlier, we can see how this is true. Let’s demonstrate this with
    a small piece of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到软件工程的领域，进一步探讨这个问题。在编程语言中，引用透明性意味着函数调用可以被其结果所替换。如果我们将这个相同的测试应用到我们之前编写的`add`函数上，我们可以看到这是如何成立的。让我们用一小段代码来演示这一点：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we have replaced one of the `add` functions with its result.
    And sure enough, the output of our program remained identical and functionally
    correct. You might think this is obvious, but there are plenty of functions that
    we rely on for which this is not true. Let’s introduce another function that breaks
    this property. We’ll keep it simple and create a program that tells us the current
    time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们用其结果替换了其中一个`add`函数。果然，我们程序的输出保持一致，并且功能正确。你可能认为这是显而易见的，但有许多我们依赖的函数并不具备这个特性。让我们引入另一个打破这个特性的函数。我们将保持简单，创建一个告诉我们当前时间的程序：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this snippet, we are using the `time.Now` function. There’s not a single
    value that you can replace this function call with while guaranteeing your program
    is functionally equivalent and correct. If we were to hardcode the current time,
    it would be wrong by the time your program has compiled and when it’s run.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用了`time.Now`函数。没有哪个值可以替换这个函数调用，同时保证你的程序在功能上等效且正确。如果我们硬编码当前时间，那么在程序编译和运行时，这个时间就会是错误的。
- en: 'To expand on this, let’s take a look at a larger example than just the `time.Now`
    function. In the following piece of code, let’s imagine we are writing a function
    to select the starting player of a game. We’ll use a simple type alias from `Player`
    to `string` instead of making a complete struct. As this is a game, we want our
    starting player to be randomly selected on each run of our program:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们看一个比`time.Now`函数更大的例子。在下面的代码片段中，让我们假设我们正在编写一个函数来选择游戏的起始玩家。我们将使用从`Player`到`string`的简单类型别名，而不是创建一个完整的结构体。由于这是一个游戏，我们希望我们的起始玩家在每次程序运行时都是随机选择的：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we are breaking the referential transparency requirement
    of our code since there is no way to replace this function call with a single
    value while maintaining an equivalent outcome of our program. The preceding code
    is also not testable. Think about this for a second – how would you write a unit
    test for this function? This would prove impossible to do in the code’s current
    state and would require some refactoring. We will show you how we could refactor
    this code and make it testable later in this chapter, but you can find it on GitHub
    at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们违反了代码的引用透明性要求，因为没有办法用一个单一值替换这个函数调用，同时保持程序等价的结果。前面的代码也不可测试。思考一下——你将如何为这个函数编写单元测试？这将证明在代码当前状态下是无法做到的，并且需要一些重构。我们将在本章后面展示如何重构此代码并使其可测试，你可以在GitHub上找到它：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/TestableCode)。
- en: Idempotence
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂等性
- en: Another property of pure functions is that they are idempotent. This means that
    no matter how many times the function is executed, it will always return the same
    output, assuming that the input arguments have remained the same. In the preceding
    example, the `add` function is always returning the same sum of two numbers provided
    the same input. On the other hand, the `time.Now` function is not (nor would that
    have been the desired behavior).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的另一个特性是它们是幂等的。这意味着无论函数执行多少次，只要输入参数保持不变，它总是会返回相同的输出。在前面的例子中，`add`函数总是返回相同的两个数的和，前提是输入相同。另一方面，`time.Now`函数不是（这也不是预期的行为）。
- en: You might be familiar with idempotence as it also shows up when you are implementing
    a `REST` service or dealing with HTTP calls in general. When implemented correctly,
    the `GET, HEAD, PUT, and DELETE` methods should be idempotent. A notable exception
    is the `POST` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能对幂等性很熟悉，因为它在实现`REST`服务或处理HTTP调用时也会出现。当正确实现时，`GET, HEAD, PUT, 和 DELETE`方法应该是幂等的。一个值得注意的例外是`POST`方法。
- en: Statelessness
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态
- en: A pure function should not depend on any state of the system. This means that
    neither the input nor the output should change the state. Web requests are often
    said to be stateless; each request can run independently of the other and still
    generate the same result. In Go terms, this also means that our function should
    not depend on things such as global variables, files on our filesystem, or general
    I/O operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数不应依赖于系统的任何状态。这意味着输入和输出都不应改变状态。通常说Web请求是无状态的；每个请求可以独立于其他请求运行，并且仍然产生相同的结果。在Go的术语中，这也意味着我们的函数不应依赖于诸如全局变量、文件系统上的文件或一般的I/O操作等事物。
- en: Side effects
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副作用
- en: The properties mentioned previously tie together in creating functions that
    are free of side effects. A side effect is any operation that your function does
    that changes the state of your system. In the next chapter, we’ll dive deeper
    into what it means for the state to be immutable at the `struct` level. In this
    chapter, we’ll consider the state to mean the system within which your program
    is operating.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的属性结合在一起，创建出没有副作用的功能。副作用是指你的函数所做的任何改变系统状态的操作。在下一章中，我们将更深入地探讨在`struct`级别上状态不可变的意义。在这一章中，我们将考虑状态为程序运行的系统。
- en: Why does purity improve our code?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么纯度能提高我们的代码？
- en: So far, we have looked into some properties of purely functional code. We’ve
    also seen some examples of both pure and impure functions. Now, let’s look at
    what benefits we can expect from writing pure functional code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了纯函数代码的一些特性。我们也看到了纯函数和不纯函数的例子。现在，让我们看看编写纯函数代码可以期待哪些好处。
- en: Increases the testability of our code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高了我们代码的可测试性
- en: 'When writing pure functions, your functions will be easier to test. This is
    a consequence of them being both idempotent and stateless:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写纯函数时，你的函数将更容易测试。这是它们既是幂等的又是无状态的后果：
- en: '**Idempotent**: Run functions any number of times and get the same result'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：运行函数任意次数都会得到相同的结果'
- en: '**Stateless**: Each function will run independently of the state of the system'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：每个函数将独立于系统的状态运行'
- en: For idempotence, it’s easy to see how this would be true. In our test suite,
    if functions were to return different outputs for the same inputs, it would be
    hard to write tests for that function. After all, if you can’t predict the output
    of a certain function, you can only guess what value you should be testing for.
    The benefit of it being stateless might not be immediately obvious. This comes
    down to our test suite not being able to run in the same environment as our production
    system. Thus, if we were relying on the state of the system in some way, we would
    have to guarantee that our test state replicates the production state at the moment
    in which the function is called. Let’s demonstrate this with an example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于幂等性，很容易看出这一点是正确的。在我们的测试套件中，如果函数对于相同的输入返回不同的输出，那么为该函数编写测试将会很困难。毕竟，如果你无法预测某个函数的输出，你只能猜测应该测试的值。它无状态的好处可能并不立即明显。这归结于我们的测试套件无法在我们的生产系统环境中运行。因此，如果我们以某种方式依赖于系统状态，我们必须保证我们的测试状态在函数被调用的那一刻复制了生产状态。让我们用一个例子来演示这一点。
- en: 'Recall from earlier in this chapter, when we created a function to select a
    random player for a game? Let’s refactor this code into something more testable.
    There are two changes we need to make – first, we need to make the function deterministic.
    It sounds like this breaks the randomization, and it does, but we’ll show how
    we can work around that soon. The second change we will make is to remove any
    side effects. In our first example, we had a `panic` function in case the randomization
    function returned an integer above 1\. We’ll replace that panic by returning a
    tuple from our function containing `(Player, error)`, following the common error
    handling idiom in Go. With these changes, our new function looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下本章前面提到的，当我们创建一个函数来为游戏选择一个随机玩家时？让我们将这段代码重构为更易于测试的形式。我们需要做两个改动——首先，我们需要使函数具有确定性。这听起来好像打破了随机性，确实如此，但我们将很快展示如何解决这个问题。我们将做的第二个改动是移除任何副作用。在我们的第一个例子中，如果随机化函数返回大于1的整数，我们有一个`panic`函数。我们将用从我们的函数返回一个包含`(Player,
    error)`元组的做法来替换这个`panic`，这遵循了Go语言中常见的错误处理惯例。有了这些改动，我们新的函数看起来是这样的：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With these changes in place, our function is now deterministic. For each input,
    we always generate the same output, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些改动到位后，我们的函数现在是确定的。对于每个输入，我们总是生成相同的输出，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how in the last case, whereby `n` is larger than one, we are not simply
    returning `nil` and an error. This bears some explanation. The gist of it is that
    we’ll try to avoid using pointers in our code as much as possible. And, in Go,
    if you’re not working with pointers, you cannot represent `nil`. Exactly why we
    avoid this and what the implications are will be explained in detail in the following
    chapter, [*Chapter 5*](B18771_05.xhtml#_idTextAnchor085).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在最后一种情况下，当`n`大于一时，我们并没有简单地返回`nil`和错误。这需要一些解释。其核心思想是我们将尽可能避免在我们的代码中使用指针。在Go语言中，如果你不使用指针，你就无法表示`nil`。我们为什么要避免使用它以及它的含义将在下一章中详细解释，[*第五章*](B18771_05.xhtml#_idTextAnchor085)。
- en: 'Now that we have seen what the expected output is for each case, and that we
    agree on this function being pure, we can write a test case to confirm that the
    output matches what we expect:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了每种情况下的预期输出，并且我们同意这个函数是纯的，我们可以编写一个测试用例来确认输出是否符合我们的预期：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Everything that is happening in the preceding code is pretty straightforward.
    For each valid input (0 and 1), we confirm that the first or second player is
    returned, respectively. For an input higher than 1, we confirm that an error is
    thrown. Technically, you could extend this unit test to exhaustively test all
    possible integer inputs and confirm that an error is thrown for each of them.
    That might be a tad too exhaustive for this simple function, though.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中发生的一切都很简单明了。对于每个有效输入（0和1），我们确认分别返回第一个或第二个玩家。对于大于1的输入，我们确认抛出了一个错误。技术上，你可以扩展这个单元测试，以穷举测试所有可能的整数输入，并确认每个输入都会抛出错误。不过，对于这个简单的函数来说，这可能有点过于详尽。
- en: 'With this, only one thing remains to be addressed: our code is no longer selecting
    a random player, but rather it is expecting an integer input and returning a deterministic
    value. You might notice that we have merely shifted the problem, as the random
    selection function still needs to be present somewhere. This is correct. If we
    were to look at how we would be using this code in an actual game, we might find
    code like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一需要解决的事情就是：我们的代码不再选择一个随机玩家，而是期望一个整数输入并返回一个确定性的值。你可能注意到，我们只是将问题转移了，因为随机选择函数仍然需要存在于某个地方。这是正确的。如果我们看看在实际游戏中如何使用这段代码，我们可能会发现这样的代码：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see a recurring pattern as we aim to improve the purity of our
    code. The strategy will be to limit the places where side effects and non-determinism
    can occur. When you shift the way you think about structuring your code to preferring
    function purity and isolating the locations where you break it, you might end
    up with 90% of pure code and 10% impure code. Sure, you’re not 100% purely functional,
    but we’re programming in Go and we can forgive ourselves for the 10% impure code.
    As we’ve explored in quite some detail, purely functional programming is a subset
    of functional programming. Also, there’s no pure functional programming police
    that will hunt you down if you write an impure function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一种重复出现的模式，因为我们旨在提高代码的纯净度。策略将是限制副作用和非确定性可能发生的地方。当你改变思考代码结构的方式，更倾向于函数纯净并隔离破坏它的位置时，你可能会得到90%的纯代码和10%的不纯代码。当然，你并不是100%的纯函数式，但我们在
    Go 中编程，我们可以原谅自己10%的不纯代码。正如我们详细探讨的那样，纯函数式编程是函数式编程的一个子集。此外，没有纯函数式编程警察会因为你写了一个不纯的函数而追捕你。
- en: Does this mean it’s impossible to be entirely pure? Well, not quite. After all,
    there are purely functional programming languages such as Haskell that can be
    used in real-world production environments. The way they deal with these impure
    functions is by using a form of encapsulation, known as **monads**. While it is
    possible to create monads in Go, it might cause more friction than necessary,
    hence why I advocate for embracing the idea of functional rather than pure functional
    code. For fun and to be extensive in our exploration of purely functional code,
    we will take a look at monads in the next chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着完全纯净是不可能的？好吧，并不完全是这样。毕竟，有一些纯函数式编程语言，如 Haskell，可以在现实世界的生产环境中使用。它们处理这些不纯函数的方式是通过一种称为**单子**的封装形式。虽然可以在
    Go 中创建单子，但这可能会引起不必要的摩擦，这就是我为什么主张拥抱函数式而非纯函数式代码的理念。为了娱乐和扩展我们对纯函数式代码的探索，我们将在下一章中探讨单子。
- en: Increases the confidence in our code
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高我们代码的信心
- en: While this goes hand in hand with improved testability, the improved confidence
    in your code goes beyond that. When dealing with impure functions and states,
    your program is harder to comprehend. If you work in a sufficiently complex system
    that has impure functions, and state mutations such as through global variables,
    it becomes harder to reason about. Imagine you are working in such a complex system,
    and a user reports a bug. If the system is mutable, you’d need to get a full understanding
    of what the entire system looked like at the moment the bug appeared just to begin
    to debug it. This can lead to many painful and wasted hours of debugging. There’s
    a popular notion, called the **Heisenbug**, which is a consequence of this. In
    this case, if the function that caused the bug depended on the state of the system,
    you might need to repeat the exact steps the user did just to replicate the bug.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与提高可测试性密切相关，但你对代码的信心提升远不止于此。当处理不纯函数和状态时，你的程序更难以理解。如果你在一个足够复杂的系统中工作，该系统包含不纯函数和状态突变，如通过全局变量，推理起来会更困难。想象一下，你在一个这样的复杂系统中工作，一个用户报告了一个错误。如果系统是可变的，你需要完全理解错误出现时整个系统的样子，才能开始调试。这可能导致许多痛苦且浪费时间的调试。有一个流行的概念，称为**海森堡虫**，这是其后果之一。在这种情况下，如果导致错误的函数依赖于系统的状态，你可能需要重复用户所做的确切步骤才能重现错误。
- en: An additional benefit is that our code becomes easier to debug. When debugging
    a program, any sufficiently advanced debugger will also show the state of your
    system during debugging. It will tell you what values were held in memory by the
    various parts of your program. That’s a great tool and can help you find bugs
    and eliminate them. But what if your program just doesn’t depend on such a state?
    This would eliminate the need for a crux such as the advanced debugger.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是，我们的代码更容易调试。在调试程序时，任何足够先进的调试器也会显示调试期间你的系统状态。它会告诉你程序各个部分在内存中持有的值。这是一个伟大的工具，可以帮助你找到错误并消除它们。但如果你程序根本不依赖于这种状态呢？这将消除对像高级调试器这样的关键的需求。
- en: You could look at a single function, and reason about what it’s doing without
    having to also keep in mind what the rest of the system would look like at the
    moment of execution. Humans are bad at keeping things in our “working memory;”
    we can juggle about 7 +- 2 things at any given moment. If we optimize and try
    to make our program understandable by most humans, we’d have to limit the state
    variables to just 5\. This is ignoring the fact that our function probably has
    some variables as well. As such, we quickly exceed the upper bound of our human
    memory limits.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看一个单独的函数，并对其所做的事情进行推理，而无需同时记住执行时刻整个系统的样子。人类在保持“工作记忆”方面很糟糕；我们可以在任何给定时刻处理大约7
    ± 2件事情。如果我们优化并尝试让我们的程序对大多数人类来说是可理解的，我们就必须将状态变量限制为只有5个。这是忽略我们函数可能有一些变量的事实。因此，我们很快就会超过人类记忆的上限。
- en: Improved confidence in function names and signatures
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高对函数名称和签名的信心
- en: 'Another great benefit of improving the readability and understandability of
    your code is that you can suddenly gain extra confidence in your functions. Imagine
    you are reading a code base, and you encounter the following piece of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提高你代码的可读性和可理解性的另一个巨大好处是，你突然会对你的函数有额外的信心。想象一下，你正在阅读一个代码库，你遇到了以下这段代码：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What would the output be? You may naturally assume that `add1` is a pure function,
    and the output would be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会是什么样子？你可能自然会假设`add1`是一个纯函数，输出如下：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But, you would be wrong. The actual output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你会错的。实际输出如下：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To understand why, let’s take a look at the `add1` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么，让我们看看`add1`函数：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding function, we can see that the `add1` function is impure. It
    is not deterministic, as the outcome of each run depends on a random number being
    generated. Plus, it also creates a side effect. Each time a function has a `panic`
    statement in it, that statement produces a side effect outside of the normal outcome
    of your function. This was a bit of a contrived example, but it shows that when
    working in an environment where functions can contain side effects and are not
    idempotent, you lose some trust in the function signature itself.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们可以看到`add1`函数是不纯的。它不是确定的，因为每次运行的输出取决于生成的随机数。此外，它还产生了副作用。每次一个函数中有一个`panic`语句时，该语句会产生一个超出你函数正常输出的副作用。这是一个有点人为的例子，但它表明，当在一个函数可以包含副作用且不是幂等的环境中工作时，你对函数签名本身的信任度会降低。
- en: Safer concurrency
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更安全的并发
- en: One of the selling points of Go, and a feature that sets it apart from many
    mainstream languages, is how easily it handles concurrency. With Go, it is incredibly
    easy to spin up multiple threads and have them work in parallel. This happens
    through the **channels** and **goroutines** concepts. There is much to be said
    about how concurrency works in Go, enough to deserve its entire book. What we
    will focus on here briefly is the correctness aspect of concurrency. Is it true
    that spinning up goroutines and processing in parallel is much easier in Go compared
    to, say, Java? What is not true is that it’s easier to write correct concurrent
    code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Go的一个卖点，以及它区别于许多主流语言的特点之一，是它处理并发的容易程度。使用Go，启动多个线程并使它们并行工作非常简单。这是通过**通道**和**goroutines**概念实现的。关于Go中并发的工作方式有很多可以说的，足以写一本书。在这里，我们将简要关注并发的正确性方面。在Go中启动goroutines和并行处理是否比Java等语言更容易？不正确的是，编写正确的并发代码更容易。
- en: 'Let’s take a look at some concurrent code. In this example, we will create
    a slice of integers and append to it in the `addToSlice` function. In our `main`
    function, we will push an integer to the slice:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些并发代码。在这个例子中，我们将创建一个整数切片，并在`addToSlice`函数中向其中追加。在我们的`main`函数中，我们将一个整数推送到切片中：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Think about this program for a second and try to guess what the output would
    be. The correct answer is that this program's output is non-deterministic. We
    are running multiple threads in which we append to our slice, and at the end,
    we call `wg.Done()`. When working with these waitgroups, we pass along several
    threads to wait for. This is done in `wg.Add(numbersToAdd)`. Each time `wg.Done()`
    is called, the number of threads to wait for decrements by one. As we are working
    on a shared slice of integers in this example, it is impossible to predict exactly
    what that slice looked like when it was performing the `add` operation in the
    final thread. This means that our output could be all numbers randomly ordered
    such as `[9 0 1 2 3 4 5 6 7 8]`, but it’s equally possible that the output would
    just be `[4 9 0 1 2]`. Having mutable data sources in concurrent functions is
    a recipe for disaster, and leads to some pretty hard-to-trace bugs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个程序，并尝试猜测输出结果会是什么。正确答案是这个程序的输出是非确定性的。我们在多个线程中运行，向我们的切片中追加内容，最后调用`wg.Done()`。当与这些等待组一起工作时，我们传递几个线程去等待。这是在`wg.Add(numbersToAdd)`中完成的。每次调用`wg.Done()`时，等待的线程数减一。在这个例子中，我们正在处理一个共享的整数切片，因此无法准确预测在最后一个线程执行`add`操作时切片看起来是什么样子。这意味着我们的输出可能是所有数字随机排序的，例如`[9
    0 1 2 3 4 5 6 7 8]`，但同样可能的结果是`[4 9 0 1 2]`。在并发函数中有可变的数据源是灾难性的，会导致一些难以追踪的bug。
- en: So, as you can see from this small snippet, it was incredibly simple to spin
    up multiple threads, but not quite so simple to avoid bugs in our code. Pure functions
    can help with this. Remember that when a function is pure, the same input always
    generates the same output without causing any side effects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你可以从这个小片段中看到的，启动多个线程非常简单，但避免代码中的bug并不那么简单。纯函数可以帮助解决这个问题。记住，当一个函数是纯的，相同的输入总是生成相同的输出，而不会引起任何副作用。
- en: In this example, our side effect was mutating the slice, which is not thread-safe
    in Go. The program won’t crash but the result will be random. If we push pure
    functional programming to the extreme, we will eliminate all such impure functions,
    and in doing so, we could run all our functions infinitely in parallel without
    causing any trouble.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的副作用是修改了切片，这在Go中不是线程安全的。程序不会崩溃，但结果将是随机的。如果我们将纯函数编程推向极端，我们将消除所有这样的不纯函数，并且在这个过程中，我们可以无限并行地运行所有函数而不会引起任何麻烦。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In practice, there are ways to avoid this from happening using a mutex. Some
    libraries take care of parallelism and thus abstract away some of the complexity.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，有使用互斥锁来避免这种情况发生的方法。一些库会处理并行性，从而抽象掉一些复杂性。
- en: When not to write pure functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不应该编写纯函数的情况
- en: 'So far, we have seen what pure functions are and what kind of advantages pure
    functions can provide. But we should at least spend a bit of time thinking about
    occasions where we might want to sacrifice function purity. Now, if you ask this
    question to “purists,” the answer to this question is probably along the lines
    of: “Never, nunca, jamais.” This is fine, and some languages make it pretty easy
    to write functional code without ever having to sacrifice function purity. But,
    let’s take a look at a few examples where it makes sense to sacrifice some function
    purity. Now, before we dive into these examples, let me be the first to acknowledge
    that all of these supposed problems are circumventable. And yes, a language such
    as Haskell handles this mostly gracefully.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了纯函数是什么以及纯函数可以提供什么样的优势。但我们应该至少花一点时间思考一下我们可能想要牺牲函数纯度的场合。现在，如果你向“纯粹主义者”提出这个问题，这个问题的答案可能大致是这样的：“永远不，决不，绝不。”这是可以的，有些语言使得编写不牺牲函数纯度的函数代码变得相当简单。但是，让我们看看一些牺牲一些函数纯度是有意义的例子。现在，在我们深入这些例子之前，让我首先承认，所有这些所谓的都是可以规避的。是的，像Haskell这样的语言处理这些问题大多数情况下都很优雅。
- en: But we are not programming in Haskell; we are programming in Go. And while Go
    allows us to write purely functional code if we wish to do so, some things are
    just easier to implement by temporarily forgiving ourselves for our sin of writing
    impure code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不是在用Haskell编程；我们是在用Go编程。虽然Go允许我们编写纯函数代码，如果我们愿意的话，但有些事情通过暂时原谅自己编写不纯代码的“罪行”更容易实现。
- en: Input/output operations
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入/输出操作
- en: Think about the implications of totally eradicating side effects from your code.
    If we say that we are writing purely functional code and have eliminated all side
    effects, we have also eliminated part of what generates value for our users. Any
    time we are getting input from a user or displaying input to a user in some way,
    it is technically a side effect. Any time we are storing data in local storage,
    or uploading to a server somewhere, we are producing a side effect. Many applications
    will take some type of input, and many will also generate some kind of output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑从代码中完全消除副作用的影响。如果我们说我们在编写纯函数代码并消除了所有副作用，那么我们也消除了为我们的用户提供价值的一部分。每次我们从用户那里获取输入或以某种方式向用户显示输入时，在技术上都是副作用。每次我们在本地存储中存储数据或上传到服务器时，我们都在产生副作用。许多应用程序会接收某种类型的输入，许多也会生成某种类型的输出。
- en: Non-determinism can be desired
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非确定性可能是期望的
- en: Another reason why we might not want to create pure functions is when the non-deterministic
    nature fits within the domain of what we are building. If we are building a game
    of Monopoly, it is the desired effect to have a `rollDice` function return a non-deterministic
    result. The game of Monopoly example was no accident. Randomness is inherent in
    many of the games we see around us, and thus a domain where pure determinism is
    not the desired outcome of each function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不希望创建纯函数的另一个原因是，非确定性特性适合于我们构建的领域。如果我们正在构建《大富翁》游戏，那么期望`rollDice`函数返回一个非确定性结果是合乎愿望的。《大富翁》的例子并非偶然。随机性是我们周围许多游戏固有的特性，因此，纯确定性不是每个函数期望的结果。
- en: When we really have to panic!
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当我们真的不得不`panic`时！
- en: When your program is in a state whereby it is impossible to continue operating
    normally, the typical way of handling that is by using a `panic`. While panics
    should be used sparingly, they are instances of the side effects that you are
    generating. Earlier in this chapter, we saw an example where a function would
    unpredictably panic during its execution. That example was artificial and a pretty
    bad use case for the `panic` function. But that does not mean that there are never
    any valid reasons to use `panic`. For example, if you are trying to reserve memory
    beyond the memory that is available on the system, that could be a cause for `panic`.
    In general, `panic` should be used to signal that the normal operation can’t proceed
    and there’s no way to gracefully continue running the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序处于无法正常继续运行的状态时，处理这种情况的典型方式是使用`panic`。虽然`panic`应该谨慎使用，但它们是你产生副作用的一个实例。在本章的早期，我们看到了一个函数在执行过程中可能会不可预测地引发`panic`的例子。那个例子是人为的，对于`panic`函数来说是一个相当糟糕的使用案例。但这并不意味着永远没有使用`panic`的有效理由。例如，如果你试图预留超出系统可用内存的内存，那可能就是引发`panic`的原因。一般来说，`panic`应该用来表示正常操作无法继续进行，且没有优雅地继续运行应用程序的方法。
- en: Two things are worth pointing out. The first one is that using the `panic` keyword
    should be the exception rather than the role. The second is that there is a common
    error handling paradigm in Go, namely returning a tuple containing a potential
    error value. Returning an error from a function is a distinct operation from using
    `panic` and serves a different use case.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点值得指出。第一点是使用`panic`关键字应该是例外而不是常规操作。第二点是Go语言中有一个常见的错误处理模式，即返回一个包含潜在错误值的元组。从函数中返回错误与使用`panic`是不同的操作，它们服务于不同的用例。
- en: How do we create pure functions?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何创建纯函数？
- en: So far in this chapter, we have taken a look at some properties of pure functions.
    We have also touched on some of the advantages we can gain by writing all our
    functions as pure functions. Now, let’s look at some things we can do to make
    it easier to write pure functions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们查看了一些纯函数的性质。我们还简要提到了通过将所有函数编写为纯函数所能获得的一些优势。现在，让我们看看我们可以做些什么来使编写纯函数更容易。
- en: Avoid global state
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免全局状态
- en: 'One of the ways we can facilitate writing pure functional code is by avoiding
    the global state in our programs. In Go, this comes down to avoiding the use of
    `const` and `var` blocks at the package level as much as possible. When you see
    these blocks, there’s a good chance that the program state is relied upon by some
    functions, thus generating either side effects or having non-deterministic program
    execution. While it’s not always possible to completely avoid such state variables,
    we should try to limit their use as much as possible. The way to prevent a function
    from relying on this state is by having the state pass to the function through
    a normal function argument. This is rather straightforward. The following is a
    small example, once using state from a `var` block and once without:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以促进编写纯净函数式代码的一种方法是在我们的程序中避免全局状态。在Go语言中，这相当于尽可能避免在包级别使用`const`和`var`块。当你看到这些块时，有很大可能性是某些函数依赖于程序状态，从而产生副作用或具有非确定性的程序执行。虽然我们不可能完全避免这样的状态变量，但我们应尽可能限制它们的使用。防止函数依赖这种状态的方法是通过正常函数参数将状态传递给函数。这相当直接。以下是一个小例子，一次使用`var`块中的状态，一次不使用：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could get the same functionality as the preceding block without the `var`
    block by simply passing the `name` parameter as input to our function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`name`参数作为输入传递给我们的函数，而不使用`var`块来获得与前面块相同的功能：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s the gist of it. Next, let’s look at a general way of dealing with code
    that contains impure elements.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是重点。接下来，让我们看看处理包含杂质代码的一般方法。
- en: Separate pure and impure functionality
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分纯净和杂质功能
- en: As mentioned earlier, it’s hard to be completely pure. We should not aim to
    eradicate I/O operations, API calls, and so on as by eliminating these, we’d likely
    be throwing out most of what makes our programs valuable. The main exercise will
    be in trying to create as many small, pure functions as possible and composing
    these into a larger program. There will still be side effects, but we’ll limit
    their occurrence.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要完全纯净是很难的。我们不应试图消除I/O操作、API调用等，因为消除这些操作，我们可能会丢弃使我们的程序有价值的大部分内容。主要的练习将是尝试创建尽可能多的小型、纯净函数，并将这些组合成更大的程序。仍然会有副作用，但我们将限制它们的发生。
- en: Bubbling up errors
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误冒泡
- en: A somewhat common side effect is generated by errors. Our programs end up in
    a state where they do not continue gracefully and there’s no real way to circumvent
    this. One way to isolate the pure and impure aspects here is by using the Go error-handling
    idiom and essentially “bubbling up” errors to a common layer where they can be
    handled. We saw this earlier in our example of selecting random players. Since
    Go 1.13, there are additional built-in tools available for bubbling up errors.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一种相对常见的副作用是由错误产生的。我们的程序最终处于无法优雅继续的状态，而且没有真正的方法可以绕过这个问题。在这里隔离纯净和杂质方面的一种方法是通过使用Go的错误处理习惯用法，并将错误“冒泡”到可以处理的公共层。我们在选择随机玩家的例子中已经看到了这一点。自Go
    1.13以来，还有额外的内置工具可用于错误冒泡。
- en: Each function does exactly one thing
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 每个函数只做一件事
- en: 'This is good advice in general. Generally speaking, a function should only
    do one thing, which significantly reduces the odds of our function creating a
    side effect. You find this same principle in traditional object-oriented languages
    as well. The industry more or less agrees that this is the way, but it’s surprisingly
    easy to break this good intention. Take a look at the following code of a simple
    addition function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一般性的好建议。一般来说，一个函数应该只做一件事，这显著降低了我们的函数产生副作用的可能性。你同样可以在传统的面向对象语言中找到这个原则。业界或多或少都同意这是正确的方法，但打破这个良好意图却出奇地容易。看看以下简单加法函数的代码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is not a pure function. The side effect of this snippet is that we are
    printing the `sum` value to the standard output. Sure enough, this is pretty harmless,
    but if our users rely on this functionality, how do we ensure this function works
    properly? In other words, how would you go about testing that this function prints
    the correct output to the screen?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个纯净函数。这个片段的副作用是我们将`sum`值打印到标准输出。确实，这并不太有害，但如果我们的用户依赖于这个功能，我们如何确保这个函数正常工作？换句话说，你将如何测试这个函数是否将正确的输出打印到屏幕上？
- en: 'A variant of this could be writing to the filesystem or a database call as
    part of a function where that should not be the case. Let’s take a look at a function
    for signing up new users to a service. We expect the input to be a username and
    a password, and there’s some logic defined on the `User` struct to ensure the
    password is compliant with password rules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变体可能是将写入文件系统或数据库调用作为函数的一部分，而这种情况本不应该发生。让我们看看一个用于注册新用户到服务的函数。我们期望输入是一个用户名和一个密码，`User`结构体上定义了一些逻辑来确保密码符合密码规则：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The issue with this function is that it tries to do two things. First, it creates
    a new user struct and confirms that the password is compliant. Next, it stores
    the `User` struct in a database, assuming that the password is valid; otherwise,
    it panics. We could have split this into multiple functions, one for validating
    the password, one for storing the user, and a third function for orchestrating
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的问题在于它试图做两件事。首先，它创建一个新的用户结构体并确认密码是否符合要求。接下来，它将`User`结构体存储在数据库中，假设密码有效；否则，它将引发恐慌。我们可以将这个操作拆分成多个函数，一个用于验证密码，一个用于存储用户，第三个函数用于协调这些操作：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we have separated the concerns, but we’re still left
    with two impure functions. However, the problems are now more contained tough
    within a single function. This code is not perfect yet, and there’s still room
    for improvement, as we will see in the next chapter. Before we go there, though,
    let’s take a look at a more extensive example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经分离了关注点，但我们仍然留下了两个不纯的函数。然而，问题现在被更严格地限制在单个函数内部。这段代码还不够完美，还有改进的空间，我们将在下一章中看到。不过，在去那里之前，让我们看看一个更广泛的例子。
- en: Example 1 – hotdog shop
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 1 – 热狗店
- en: For our first example, we are going to take a look at some code that has been
    written in an impure way, and which is pretty much violating all good sense for
    writing pure functions. We’ll refactor this code as we go along to create more
    testable code, along with improving the readability and understandability of the
    code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们将查看一些以不纯方式编写的代码，这些代码几乎违反了编写纯函数的所有良好原则。我们将随着代码的进行进行重构，以创建更可测试的代码，同时提高代码的可读性和可理解性。
- en: Bad hotdog shop
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不好的热狗店
- en: 'First, let’s take a look at how not to create this hotdog shop system. We’ll
    start by defining a constant, a global variable that dictates the price of our
    hotdog:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何不创建这个热狗店系统。我们将从一个常量开始定义，这是一个全局变量，它决定了我们热狗的价格：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we’ll create some structs. We will need a struct to represent a hotdog,
    as well as a struct to hold our credit card information. To keep things simple,
    the hotdog does not hold any state variables at the moment, while the credit card
    only stores the credit that is available on the card. Credit in this example is
    an integer value. It’s not something that accurately represents a monetary value
    in real life, but it’s good enough for this example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些结构体。我们需要一个结构体来表示热狗，还需要一个结构体来存储我们的信用卡信息。为了简化，目前热狗不包含任何状态变量，而信用卡只存储卡上可用的信用额度。在这个例子中，信用额度是一个整数值。它并不准确地代表现实生活中的货币价值，但对于这个例子来说已经足够了：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With these defined, we can get to the first piece of functionality that we
    care about. We need a way to charge our credit card for a certain value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 定义好这些之后，我们可以着手实现我们关心的第一个功能。我们需要一种方式来为我们的信用卡充值一定金额：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding `charge` method, we are charging the credit card for a certain
    amount by decreasing the credit available on the card. If there isn’t enough credit
    available to make the charge, we are using `panic` to halt the program. For now,
    the main issue with this function is the use of side effects. There are two of
    them. First, we are using `panic` if a certain branch is hit. The next side effect
    is that we are changing the state of `CreditCard`. Struct immutability is a topic
    we’ll cover in detail in the next chapter, so let’s close our eyes to this issue
    for now and continue writing the rest of our hotdog shop. The most important function
    for a user is to order a hotdog. So, let’s take a look at an implementation for
    doing so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`charge`方法中，我们通过减少卡上的可用信用额度来为信用卡收取一定金额。如果没有足够的信用额度来执行扣款，我们使用`panic`来停止程序。目前，这个函数的主要问题是使用了副作用。有两个副作用。首先，如果遇到某个分支，我们会使用`panic`。下一个副作用是我们改变了`CreditCard`的状态。结构体的不可变性是我们将在下一章详细讨论的主题，所以现在让我们忽略这个问题，继续编写我们的热狗店代码。对于用户来说最重要的功能是订购热狗。所以，让我们看看如何实现这个功能的实现：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code is, again, impure code. The credit card of the user is being
    charged by a price defined outside of the function, using the global state. This
    function is doing more than one thing – it is both creating a hotdog to return
    to the user as well as charging their credit card.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码，再次，是不纯的代码。用户的信用卡正被一个在函数外部定义的价格所扣除，使用了全局状态。这个函数做了不止一件事——它既为用户创建了一个要返回的热狗，同时也扣除了他们的信用卡。
- en: Think about how you would test this for a second. It is possible to test this
    – but not convenient. You need to test or mock the credit card to also ensure
    a hotdog is being returned from this function. Furthermore, you have to capture
    a potential panic, which is not happening in the `orderHotdog` function but rather
    a call deeper. In addition, because `charge` is also impure, a reader of `orderHotdog`
    has no idea that `charge` *might* panic unless they take a look at that specific
    function as well. As we learned earlier, pure functional code gives us more confidence
    when reading code. We trust that a function does what it says it will – nothing
    more, nothing less. With that in mind, let’s take a look at how we can refactor
    this code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你是如何测试这个功能的。测试这个功能是可能的——但并不方便。你需要测试或模拟信用卡，以确保这个函数确实返回了一个热狗。此外，你还得捕捉一个潜在的恐慌，这并不是在`orderHotdog`函数中发生的，而是在更深层次的调用中。另外，因为`charge`也是不纯的，`orderHotdog`的读者如果没有查看那个特定的函数，就没有意识到`charge`*可能*会引发恐慌。正如我们之前学到的，纯函数式代码在阅读代码时给我们带来了更多的信心。我们相信一个函数会做它所说的——不多，也不少。带着这个想法，让我们看看我们如何可以重构这段代码。
- en: Better hotdog shop
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的热狗店
- en: In this version of the hotdog shop, we will try to address some of the issues
    we found in the previous example. The full code can be found at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个热狗店的版本中，我们将尝试解决我们在上一个例子中发现的一些问题。完整的代码可以在[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter4/Examples/HotdogShop/PureHotdogShop)找到。
- en: 'Let’s start by defining our types:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们的类型开始：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we have defined all the types we need to represent data in this small
    application. Our `CreditCard` struct contains an integer amount of credit, and
    our `hotdog` costs an integer amount as well. We have defined a `error` called
    `CreditError`, as well as a type alias for a payment function. Let’s also set
    up some constructor-like functions for our `CreditCard` and `Hotdog`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了所有我们需要表示这个小型应用程序数据的类型。我们的`CreditCard`结构体包含一个整数金额的信用额度，而热狗的价格也是一个整数。我们定义了一个名为`CreditError`的错误，以及一个支付函数的类型别名。让我们也为`CreditCard`和`Hotdog`设置一些类似构造函数的函数：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These are pretty straightforward. We will add a global variable to represent
    an error whereby a user does not have enough credit to perform an operation on
    the credit card:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相当直接。我们将添加一个全局变量来表示一个错误，即用户没有足够的信用额度来对信用卡执行操作：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you may recall, earlier, I advocated against using these types of package-level
    declarations. That’s still true and I’d advocate avoiding using them as much as
    possible. For error declarations, however, this is pretty much the accepted, idiomatic
    way of writing Go code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能记得的，之前我曾反对使用这类包级别的声明。这一点依然成立，我建议尽可能避免使用它们。然而，对于错误声明来说，这几乎是编写Go代码的公认、惯用的方式。
- en: We could avoid it here and instantiate the error in-line wherever it is applicable,
    but that will slightly hurt the testing code, which we’ll write later. In general,
    keep in mind that I advocate *functional programming* in Go, not *pure* *functional
    programming*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里避免它，并在适用的地方直接实例化错误，但这会稍微损害我们稍后要编写的测试代码。一般来说，请记住，我提倡在Go中使用*函数式编程*，而不是*纯*函数式编程。
- en: 'Either way, let’s write our first non-trivial function. We will rewrite the
    initial `charge` function in a pure way. The goal here is to eliminate the initial
    side effect that we had not by using `panic` but rather by returning a tuple containing
    a potential error:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，让我们编写我们的第一个非平凡函数。我们将以纯净的方式重写最初的`charge`函数。这里的目的是通过返回一个包含潜在错误的元组来消除我们之前没有通过`panic`而是通过返回副作用的方式。
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can tell in the preceding snippet, we are not only returning an error
    value, but we are also returning a value of the `CreditCard` type. This is not
    the same `CreditCard` that is passed to the function by a caller. As we are not
    using a pointer to `CreditCard`, when a function calls `Charge`, `CreditCard`
    will be used inside the `Charge` function. As we are working on a copy, the `c.credit
    -= amount` statement only impacts the copy and not the original `CreditCard`.
    This is a common pitfall for newer Go programmers. In the next chapter, we will
    dive into immutability in greater detail and discuss the trade-off between this
    approach and the pointer-based function calls. But suffice it to say that this
    current function is *pure enough*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中可以看到，我们不仅返回了一个错误值，还返回了一个`CreditCard`类型的值。这并不是由调用者传递给函数的同一个`CreditCard`。因为我们没有使用`CreditCard`的指针，当函数调用`Charge`时，`CreditCard`将在`Charge`函数内部使用。由于我们正在操作一个副本，`c.credit
    -= amount`这一语句只会影响副本，而不会影响原始的`CreditCard`。这是新晋Go程序员常见的陷阱。在下一章中，我们将更深入地探讨不可变性，并讨论这种方法和基于指针的函数调用之间的权衡。但可以肯定的是，当前这个函数是*足够纯净的*。
- en: 'This `Charge` function is also easily testable. Let’s write a unit test to
    make sure the behavior is as we expect. First, we will define our test cases.
    The following structure is the setup for a *table-driven test*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Charge`函数也易于测试。让我们编写一个单元测试来确保行为符合我们的预期。首先，我们将定义我们的测试用例。以下结构是*表格驱动测试*的设置：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding snippet, we are testing a few paths that our code can take.
    We can try to charge the credit card when we have more credit available than the
    cost, when we have the exact amount available, or when we don’t have enough credit
    available. With this table structure, adding more test cases is trivial. Now,
    let’s write the unit test itself, which will just run a test for each of the test
    cases defined previously:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们正在测试我们的代码可以采取的几个路径。我们可以尝试在信用额度超过成本时扣款，当有恰好足够的金额时扣款，或者当信用额度不足时扣款。有了这种表格结构，添加更多测试用例变得非常简单。现在，让我们编写实际的单元测试，它将为之前定义的每个测试用例运行测试：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Et voilà! A complete unit test for the charge function. Something that would
    have been nigh impossible in the impure example. Now, let’s also refactor the
    `OrderHotdog` function that we had earlier. As with anything, there are multiple
    ways to tackle this problem. The solution that we are implementing here is using
    a higher-order function to delay computation to a later stage. This will move
    the side effect of actually charging the credit card up the call chain:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这是对`charge`函数的完整单元测试。这在非纯净示例中几乎是不可能的。现在，让我们也重构一下我们之前提到的`OrderHotdog`函数。就像任何事物一样，解决这个问题有多个方法。我们在这里实施的方法是使用高阶函数将计算延迟到更晚的阶段。这将把实际扣款的副作用向上移动到调用链中：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let’s unpack what’s happening here. First, there’s our function signature. The
    `OrderHotdog` function still accepts `CreditCard` as input, but also a `PaymentFunc`.
    Recall that we defined `PaymentFunc` as a function that takes a `CreditCard` and
    an `int`, and returns a `CreditCard` and a `CreditError`. The `OrderHotdog` function
    returns the `Hotdog` itself, as well as a function that will return a `CreditCard`
    and an `error`. This might be a bit confusing at first but will become clearer
    in the function body.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里发生的事情。首先，是我们的函数签名。`OrderHotdog`函数仍然接受`CreditCard`作为输入，但还接受一个`PaymentFunc`。回想一下，我们定义`PaymentFunc`为一个接受`CreditCard`和一个`int`作为参数，并返回`CreditCard`和`CreditError`的函数。`OrderHotdog`函数返回热狗本身，以及一个将返回`CreditCard`和`error`的函数。这可能会一开始有些令人困惑，但在函数体中会变得清晰。
- en: The first step is creating a new hotdog. After this, we must create a new function
    in-line. Recall that this is possible because Go supports functions as first-class
    citizens. Inside this function, we are calling `pay`, with the provided credit
    card, for the price of a hotdog. This is a `OrderHotdog` function then returns
    the hotdog and the newly created function. It’s important to note that `chargeFunc`
    is not executed when the `OrderHotdog` function is called. No side effect is occurring
    in this function; the side effect is deferred to a later stage. Once again, we
    are going to try to isolate our side effects as much as possible. Higher up the
    call chain is a better place for side effects as our code is typically read from
    higher to lower levels of abstraction. This avoids surprises somewhere hidden
    in the implementation details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的热狗。之后，我们必须在行内创建一个新的函数。回想一下，这是可能的，因为Go支持将函数作为一等公民。在这个函数内部，我们使用提供的信用卡，为热狗的价格调用`pay`。这是一个`OrderHotdog`函数，它返回热狗和刚刚创建的函数。需要注意的是，当调用`OrderHotdog`函数时，`chargeFunc`并不会被执行。这个函数中没有发生副作用；副作用被延迟到了后续的阶段。再次强调，我们将尽可能地将副作用隔离。在调用链的更高层次进行副作用处理是一个更好的选择，因为我们的代码通常是从抽象层次较高的地方开始阅读的。这可以避免在实现细节中隐藏的意外。
- en: 'With this, we have recreated the functionality of the original hotdog shop.
    Before we take a look at testing `OrderHotdog`, we will first look at an example
    of how we would use this function. In the following `main` function, we are going
    to order a hotdog and subsequently call the `pay` function to charge our credit
    card:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经重新创建了原始热狗店的功能。在我们查看测试`OrderHotdog`之前，我们将首先看看如何使用这个函数的例子。在下面的`main`函数中，我们将订购一个热狗，随后调用`pay`函数来对信用卡进行扣费：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There we go – a usable example of ordering a hotdog. Let’s look at how we are
    calling `OrderHotdog`. We are passing both the credit card, as well as the `Charge`
    function we wrote earlier. You can run this example in the GitHub example repository
    and play around with it. Let’s also confirm that this code is testable by writing
    a unit test function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这是一个可用的订购热狗的例子。让我们看看我们是如何调用`OrderHotdog`的。我们传递了信用卡以及我们之前编写的`Charge`函数。你可以在GitHub的示例仓库中运行这个例子，并对其进行实验。让我们也通过编写单元测试函数来确认这段代码是可测试的。
- en: 'We don’t need a table-driven test for this. The `OrderHotdog` function needs
    to be tested to ensure that it does the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们不需要一个表格驱动的测试。`OrderHotdog`函数需要被测试以确保它执行以下操作：
- en: Creates a new hotdog
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的热狗
- en: Creates a function that calls the payment function
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个调用支付函数的函数
- en: Returns both the hotdog and the function
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回热狗和函数
- en: 'Our test function will confirm that a new hotdog has been created and that
    a payment function is called. As this is a unit test, we don’t care about the
    payment function itself. We will mock a payment function to ensure that it is
    called from the returned function. The actual `charge` function is tested separately,
    as we saw earlier:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试函数将确认是否创建了一个新的热狗，并且支付函数被调用。由于这是一个单元测试，我们并不关心支付函数本身。我们将模拟一个支付函数以确保它被从返回的函数中调用。实际的`charge`函数如之前所见，将被单独测试：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we are strictly testing that our function is creating
    the correct values for the hotdog and the closure. A correct closure function
    in this case implies that the function that is returned calls the payment function
    that is passed to it. Notice how we could mock away the original behavior and
    create a `bool` to ensure that the function is called. Once again, this is the
    power of having first-class functions in Go.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们严格测试我们的函数是否为热狗和闭包创建了正确的值。在这种情况下，正确的闭包函数意味着返回的函数调用了传递给它的支付函数。注意我们如何可以模拟原始行为并创建一个`bool`来确保函数被调用。再次证明，这是在Go中拥有一等函数的力量。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at pure functional programming. First, we looked
    at what exactly it means for a programming language to be pure and functional
    as opposed to impure and functional. Next, we took a more detailed look at how
    pure code can help improve testability by eliminating side effects. We also learned
    that pure code gives readers more confidence in the code that they are reading
    since functions are more predictable and won’t change the state of the system.
    We also discussed when we should not use pure functions, such as when dealing
    with functions that should generate random behavior for games or functions that
    deal with I/O.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了纯函数式编程。首先，我们探讨了编程语言为何被称为纯函数式，而不是不纯函数式，以及函数式编程的含义。接下来，我们更详细地探讨了纯代码如何通过消除副作用来提高可测试性。我们还了解到，纯代码让读者对所阅读的代码更有信心，因为函数更可预测，不会改变系统的状态。我们还讨论了何时不应使用纯函数，例如处理应生成随机行为的游戏函数或处理I/O的函数。
- en: Although we have only briefly touched on it, we have seen how immutability plays
    a core part in writing pure functions by not changing the values of structs. In
    the next chapter, we will take a deep dive into immutability, how it does (or
    doesn’t) impact performance, and how we can leverage this in combination with
    pure functions to write more maintainable code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们只是简要地提到了它，但我们已经看到了通过不改变结构体的值，不可变性如何在编写纯函数中扮演核心角色。在下一章中，我们将深入探讨不可变性，它如何（或不如何）影响性能，以及我们如何利用它与纯函数结合来编写更易于维护的代码。
