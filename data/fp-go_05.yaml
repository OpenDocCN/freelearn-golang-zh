- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Immutability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: In this chapter, we will look at immutability. We are going to cover what exactly
    it means to be immutable, and how the Go language helps preserve immutability
    at the struct-level. To understand how this works, we will take a look at how
    Go handles pointers and references to objects, what the performance implications
    are, and how to decide between the pointer-reference trade-offs. We will also
    dive into the implications of garbage collection, unit testing, and *pure* functional
    programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不可变性。我们将讨论什么是不可变性，以及 Go 语言如何帮助在结构体级别上保持不可变性。为了理解这是如何工作的，我们将查看 Go 如何处理对象的指针和引用，性能影响是什么，以及如何在指针-引用权衡之间做出决定。我们还将深入研究垃圾回收、单元测试和*纯*函数式编程的影响。
- en: 'These are the main topics that we will cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本章中涵盖的主要主题：
- en: What is immutability?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是不可变性？
- en: How to write immutable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写不可变代码
- en: How do pointers and references work in Go?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的指针和引用是如何工作的？
- en: Analyzing the performance of mutable and immutable code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析可变和不可变代码的性能
- en: Examples of concurrency and testing with immutable code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变代码进行并发和测试的示例
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you can use any Go version at or above Go 1.18 as we will
    be using generics in some of the later examples. You can find all the code on
    GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter5](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter5).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你可以使用 Go 1.18 或更高版本的任何版本，因为我们将使用泛型来编写一些后续示例。你可以在 GitHub 上找到所有代码：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter5](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter5)。
- en: What is immutability?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是不可变性？
- en: 'When we talk about immutability in this chapter, we are talking about structs
    that have a state that does not change over time. In other words, when a struct
    is created, that is how that specific struct will be represented during its lifetime.
    We can still create new structs and delete old ones. So, the state at the system
    level will effectively change by new structs being created and old structs being
    deleted. This has several advantages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这章中谈论不可变性时，我们是在谈论那些状态随时间不变的结构体。换句话说，当结构体被创建时，这就是它在整个生命周期中将如何表示的。我们仍然可以创建新的结构体和删除旧的结构体。因此，系统级别的状态将通过创建新的结构体和删除旧的结构体而有效地改变。这有几个优点：
- en: First, because our structs are not changing, we can safely pass data to a function
    and know that, whatever happens, the copy that we passed to the function will
    remain intact.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，因为我们的结构体不会改变，我们可以安全地将数据传递给一个函数，并且知道无论发生什么，传递给函数的副本都将保持完整。
- en: Secondly, immutable structs make it easier to write correct, concurrent code.
    As the state of the struct cannot be changed by any function calling it, we can
    safely parallelize execution and call multiple functions using the same struct
    as input data.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，不可变结构体使得编写正确、并发的代码更加容易。由于结构体的状态不能被任何调用它的函数改变，我们可以安全地进行并行执行，并使用相同的结构体作为输入数据调用多个函数。
- en: And third, this makes our code easier to reason about. At each step of the way,
    the state of our struct is more predictable.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，这使得我们的代码更容易推理。在每一步中，我们的结构体的状态都更加可预测。
- en: Immutability is not just something that we strive for when writing functional
    code. In many object-oriented programming languages, it is preferred to write
    immutable code. The reason it deserves mention in this book is that it ties in
    nicely with pure functions, which we saw in the previous chapter. If you want
    to write true *pure* functional code, you need immutable structs. If you make
    a change to a struct in a function, that would count as having a side effect.
    Recall from the previous chapter that we will try to eliminate side effects as
    much as possible. That said, almost everything in this chapter can still be applied
    to traditional object-oriented languages as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性不仅仅是我们在编写函数式代码时追求的东西。在许多面向对象的编程语言中，编写不可变代码是首选。这本书中提到它的原因是因为它与纯函数紧密相关，我们在上一章中看到了纯函数。如果你想编写真正的*纯*函数式代码，你需要不可变结构体。如果你在函数中更改结构体，这将被视为副作用。回想一下上一章，我们将尽可能消除副作用。话虽如此，本章中的几乎所有内容都可以应用到传统的面向对象语言中。
- en: Immutability at the data layer
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据层上的不可变性
- en: Immutability is a powerful concept that we can apply to the programs we write.
    But it also appears as a concept for the data that we store. If we are writing
    software that deals with extremely sensitive data, such as an **Electronic Health
    Record** (**EHR**), we likely want the data to be immutable. That is to say, whenever
    some information in our EHR changes, we want this change to be completely traceable.
    That way, the entire history of your EHR is visible at any time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性是一个强大的概念，我们可以将其应用于我们编写的程序。但它也表现为我们存储的数据的概念。如果我们正在编写处理极其敏感数据的软件，例如**电子健康记录**（**EHR**），我们可能希望数据是不可变的。也就是说，每当我们的EHR中的某些信息发生变化时，我们希望这种变化是完全可追踪的。这样，您的EHR的整个历史在任何时候都是可见的。
- en: By having the medical data immutable, you can always look at what the file looked
    like in the past. For example, you can look at any blood test the patient has
    done or any notes that were previously taken. It also helps to serve as an auditable
    log – each change to the record is traceable. Imagine that a doctor accidentally
    deletes the result of a blood test. If your data storage is immutable, the blood
    test will not be deleted at the data layer (but rather marked as “deleted” so
    that the application layer can choose not to display it to a user). It also protects
    against ill intent – if a bad actor gained access to the application and decided
    to start changing the text of the doctors’ notes, this would show up as *new*
    notes. The original notes would still be there, at least in the data layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使医疗数据不可变，您可以始终查看文件过去的样子。例如，您可以查看患者所做的任何血液检查或之前记录的任何笔记。这也有助于作为可审计的日志——记录的每次更改都是可追踪的。想象一下，如果一位医生不小心删除了血液检查的结果。如果您的数据存储是不可变的，血液检查将不会在数据层被删除（而是被标记为“已删除”，以便应用层可以选择不将其显示给用户）。它还可以防止恶意行为——如果恶意行为者获得了对应用程序的访问权限并决定开始更改医生的笔记文本，这将显示为*新*笔记。原始笔记仍然存在，至少在数据层中。
- en: Imagine what would happen if we did not have immutability, and the actual information
    updated each time new data became available. This would be less than ideal. Imagine
    that each blood test overrides the past results – this would obfuscate any trends
    in your medical history, erasing valuable information to medical practitioners.
    Or worse, once a medical image is deleted, it would stay deleted, and the patient
    would have to undergo the same series of tests. Not only is this bad for the patient’s
    experience, but in some countries it is also costly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们没有不可变性，每次新数据可用时实际信息都会更新会发生什么。这将远非理想。想象一下，每次血液检查都会覆盖过去的结果——这将模糊您医疗历史中的任何趋势，删除对医疗从业者有价值的信息。或者更糟，一旦删除了医疗图像，它就会一直被删除，患者将不得不进行相同的测试系列。这不仅对患者的体验不利，而且在一些国家，这还可能很昂贵。
- en: This idea of traceability and immutability at the data layer, in some ways,
    culminated in what is now called **the blockchain**. While I don’t know of any
    mainstream EHR systems implemented on top of blockchain databases, there are at
    least some efforts being made by companies around the world to make this a reality.
    And it would make some sense to do so.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在数据层实现的可追溯性和不可变性的想法，在某种程度上，最终导致了现在被称为**区块链**的东西。虽然我不知道有任何主流的基于区块链数据库的电子健康记录（EHR）系统，但至少全球有公司正在努力使这一现实成为可能。这样做是有意义的。
- en: Blockchain databases are immutable by default. Apart from being suitable for
    the EHR examples mentioned previously, it is currently being used for trading
    currency. In a blockchain database, the entire history of the block is visible.
    When an update is made to a block, a new block is added to the chain with the
    updated information, rather than it overriding the existing block. This is how
    cryptocurrencies can model financial transactions. There is more depth to it than
    what I’ve explained here, as I’ve omitted a concrete explanation of how a blockchain
    can guarantee immutability and provide tamper mechanisms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 区块链数据库默认是不可变的。除了适合之前提到的电子健康记录（EHR）示例外，它目前还被用于货币交易。在区块链数据库中，整个区块的历史都是可见的。当对区块进行更新时，会向链中添加一个新的区块，其中包含更新的信息，而不是覆盖现有的区块。这就是加密货币可以模拟金融交易的方式。这里所解释的只是冰山一角，因为我省略了区块链如何保证不可变性和提供篡改机制的具体解释。
- en: A deep dive into immutability at the data layer is beyond the scope of this
    book, but hopefully, this short overview served as a good starting point to explore
    these ideas further.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据层对不可变性的深入研究超出了本书的范围，但希望这个简短的概述为您进一步探索这些想法提供了一个良好的起点。
- en: How to write immutable code in Go
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Go中编写不可变代码
- en: When we talk about immutability in Go, we are specifically focusing on how to
    have immutable structs in our code. At the core of this, we have to take a look
    at how Go uses pointers and the difference between pass-by-value and pass-by-reference.
    This is something that trips up new Go programmers, and there is a sufficient
    amount of edge cases where even more seasoned Go programmers will occasionally
    shoot themselves in the foot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Go中的不可变性时，我们特别关注如何在代码中拥有不可变的结构体。在这个核心，我们必须看看Go如何使用指针以及按值传递和按引用传递之间的区别。这是让新Go程序员感到困惑的事情，而且有足够多的边缘情况，即使是经验丰富的Go程序员偶尔也会自己绊倒。
- en: In essence, it comes down to whether or not we are using pointers in our code
    when passing around structs to functions. If our code is entirely free of pointers,
    then we would also be writing immutable code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这取决于我们在传递结构体到函数时是否使用指针。如果我们的代码完全不含指针，那么我们也会编写不可变代码。
- en: 'To demonstrate this, take a look at the following piece of code. We have a
    struct to define a person, and a function to change the name of this person:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们看一下以下代码片段。我们有一个结构体来定义一个人，以及一个用来更改这个人名字的函数：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The outcome of this function, perhaps contrary to expectation, is `Benny`.
    The `setName` function has not changed the name of the `Person` object. Eventually,
    we all get used to the idea that to update structs in a function, we need to use
    a pointer instead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的结果，可能出乎意料，是`Benny`。`setName`函数并没有改变`Person`对象的名字。最终，我们都习惯了这样一个想法：要在函数中更新结构体，我们需要使用指针：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, when we run this code, the output is `Bjorn`, as we expected. The difference
    between these two examples is that in the first example, we are using pass-by-value,
    while in the second, we are using pass-by-reference.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这段代码时，输出是`Bjorn`，正如我们所预期的。这两个例子之间的区别在于，在第一个例子中，我们使用的是按值传递，而在第二个例子中，我们使用的是按引用传递。
- en: If we look at what is happening in the first function, we will see that our
    `Person` object is being copied and that this copy is then passed to the `setName`
    function. Thus, every operation that we do on this struct is happening on the
    copy itself, and not on the actual object. However, in the second example, by
    using a pointer, we have access to the actual `Person` object and not just a copy.
    Under the hood, the second example passes an address (pointer) to the struct.
    The syntax of Go obfuscates some of the pointer referencing and dereferencing
    for us, which makes it seem like a rather small change.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看第一个函数中发生的事情，我们会看到我们的`Person`对象正在被复制，而这个副本随后被传递给`setName`函数。因此，我们对这个结构体进行的每一个操作都是在副本本身上进行的，而不是在真正的对象上。然而，在第二个例子中，通过使用指针，我们能够访问实际的`Person`对象，而不仅仅是副本。在底层，第二个例子传递了结构体的地址（指针）。Go的语法为我们模糊了一些指针引用和取消引用的操作，这使得它看起来像是一个相当小的变化。
- en: 'In general, we want to keep our code immutable. Hence, we want to avoid using
    pointers in our code. How, then, do we update our structs? The `setName` function
    provides useful functionality to our system. Recall that although we cannot change
    the state of the objects we are using, we are still free to create and destroy
    them. The solution is to create a new object that has all the properties of our
    original object, with some changes applied. To continue our previous example,
    let’s refactor the `setName` function to achieve the desired functionality:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望保持代码的不可变性。因此，我们希望避免在代码中使用指针。那么，我们如何更新我们的结构体呢？`setName`函数为我们提供了有用的功能。回想一下，尽管我们不能改变我们使用的对象的状态，但我们仍然可以自由地创建和销毁它们。解决方案是创建一个新的对象，它具有我们原始对象的所有属性，并应用了一些更改。为了继续我们的上一个例子，让我们重构`setName`函数以实现所需的功能：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, you can see the core change in which we need to update
    structs without breaking our immutability concern. We achieve this by having functions
    accept copies (pass-by-value) as input and return a new struct with the changes
    applied. In our calling function, we now have the choice of whether or not to
    keep both objects or discard the original and keep only the newly returned object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以看到我们需要在不破坏不可变性的前提下更新结构体的核心变化。我们通过让函数接受副本（按值传递）作为输入并返回一个应用了更改的新结构体来实现这一点。在我们的调用函数中，我们现在可以选择是否保留两个对象或者丢弃原始对象，只保留新返回的对象。
- en: 'This syntax should be quite familiar to Go programmers, as this is similar
    to what we do when working with slices. For example, if we wanted to add a value
    to a slice, we would write code like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法对Go程序员来说应该相当熟悉，因为这与我们处理切片时的做法类似。例如，如果我们想向切片中添加一个值，我们会编写如下代码：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code would return `[Miranda Paula Yvonne]`. When working with immutable
    structs, our syntax will look similar to this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会返回`[Miranda Paula Yvonne]`。当与不可变结构体一起工作时，我们的语法将看起来类似于这样。
- en: Writing immutable code for collection data types
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为集合数据类型编写不可变代码
- en: 'Earlier, we saw how easy it is to change functions from immutable to mutable.
    We simply replace a function that takes a pointer with a function that accepts
    a value and returns a new value. The story changes a bit when working with the
    collection `Map` data type, as becomes apparent in the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何轻松地将函数从不可变转换为可变。我们只需用一个接受值并返回新值的函数替换掉接受指针的函数。当与集合`Map`数据类型一起工作时，情况会有所不同，以下示例中可以看出：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output of this code is `[red 10]`. Although we are not using a pointer in
    the `addValue` function, the function is not operating on a copy of the map but
    is operating on the map itself. **Maps always act like pass-by-reference** **in
    Go**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出是`[red 10]`。尽管我们在`addValue`函数中没有使用指针，但该函数并不是在映射的副本上操作，而是在映射本身上操作。**在Go中，映射总是以引用传递的方式操作**。
- en: 'If we try a similar setup with slices, another collection data type, it works
    as expected:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用类似设置与切片（另一种集合数据类型）一起使用，它将按预期工作：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output here is `Miranda`. Using pointers, we can once again make the function
    mutable:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出是`Miranda`。使用指针，我们再次可以使函数可变：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we run the preceding code, the output will be `[Miranda Yvonne]`. It is common
    enough in Go that seasoned programmers are used to this, but it can trip up the
    more novice Go programmer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出将是`[Miranda Yvonne]`。这在Go中很常见，经验丰富的程序员已经习惯了这一点，但这也可能让初学者感到困惑。
- en: Measuring performance in mutable and immutable code
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变和不可变代码的性能测量
- en: A common complaint about immutable code is that it is less performant than its
    mutable counterpart. Even without doing a deep dive into the performance characteristics
    of the Go runtime, this seems like a reasonable statement. After all, in the immutable
    variant, a new copy of an object is spawned for each function call. In practice,
    however, these differences in performance are often negligible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不可变代码的常见抱怨是，它的性能不如其可变版本。即使没有深入研究Go运行时的性能特征，这似乎是一个合理的说法。毕竟，在不可变版本中，每次函数调用都会生成一个对象的新副本。然而，在实践中，这些性能差异通常是可以忽略不计的。
- en: Still, even if there would be a significant performance impact, you need to
    question if the performance sacrifices make sense in your context. In return for
    some performance, you are getting thread-safe, easy-to-maintain, understand, and
    test code. As engineers, it is often extremely tempting to go for the most optimal
    solution, using as little memory and CPU time as possible. However, for many real-world
    applications, the performance impact is small enough that this is not something
    the end user would notice. And for other engineers maintaining your code, they’d
    often want something more understandable rather than something faster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，即使会有显著的性能影响，你也需要质疑这些性能牺牲在你的环境中是否合理。作为交换，你得到了线程安全、易于维护、理解和测试的代码。作为工程师，我们常常非常渴望寻求最优化解决方案，尽可能少地使用内存和CPU时间。然而，对于许多实际应用来说，性能影响足够小，以至于这并不是用户会注意到的。而且对于维护你代码的其他工程师来说，他们通常更希望得到的是更易于理解的东西，而不是更快的东西。
- en: Unlike other languages, Go will take somewhat of a performance hit due to being
    garbage collected. If you want to squeeze every ounce of performance out of your
    system, perhaps Go is not the right tool for the job either. With this out of
    the way, we should take a look at actual benchmarks and dive a bit deeper into
    the performance implications of immutable code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言不同，Go由于垃圾回收而可能会遭受一定的性能损失。如果你想从系统中榨取每一分性能，也许Go也不是完成这项工作的正确工具。现在我们已经排除了这一点，我们应该看看实际的基准测试，并深入探讨不可变代码的性能影响。
- en: Benchmarking functions
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试函数
- en: While we can reason about the performance of a function in abstract terms, such
    as space-time complexity, to get a real sense of performance, we should do performance
    testing. After all, the runtime complexity of mutable and immutable functions
    can be quasi-identical. Caring about the implementation of pointers is too low-level
    to be considered. So, for that reason, we will set up a test to determine which
    performance is worse. As a reminder, the assumption here is that the mutable code,
    using pointers, will be faster than our immutable variant. The underlying reason
    for that assumption is that copying structs is a more costly operation than passing
    pointers to a function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以从抽象的角度推理函数的性能，例如空间-时间复杂度，但要真正了解性能，我们应该进行性能测试。毕竟，可变和不可变函数的运行时复杂度可以近似相同。关心指针的实现过于底层，不值得考虑。因此，我们将设置一个测试来确定哪种性能更差。作为提醒，这里的假设是，使用指针的可变代码将比我们的不可变版本更快。这种假设的潜在原因是，复制结构体比将指针传递给函数更耗费资源。
- en: 'Let’s set up two constructor-like functions, one for an immutable version and
    the other for a mutable version. The first function creates a `Person` object,
    and then passes that function to a function to set a name for the person, and
    subsequently to another function that sets an age for the person:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置两个类似于构造函数的函数，一个用于不可变版本，另一个用于可变版本。第一个函数创建一个 `Person` 对象，然后将该函数传递给一个设置人名的函数，然后传递给另一个设置人年龄的函数：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we can see that the `Person` object first gets copied to `immutableSetName`
    and afterward is copied again to `immutableSetAge`. Finally, we return this `Person`
    to the calling function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `Person` 对象首先被复制到 `immutableSetName`，然后又被复制到 `immutableSetAge`。最后，我们将这个
    `Person` 返回给调用函数。
- en: 'Now, let’s also set up a mutable version of this code. In the mutable version,
    we are creating a `Person` object. But, when passing it to the mutable functions
    to set a name and an age, we are going to pass a pointer to our object instead:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也设置一个可变版本的代码。在可变版本中，我们创建一个 `Person` 对象。但是，当将其传递给设置姓名和年龄的可变函数时，我们将传递一个指向我们对象的指针：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we can see that pointers are used to avoid copying the `Person` object
    between functions. One thing to point out in these examples is that these two
    functions are identical in Go:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到指针被用来在函数之间避免复制 `Person` 对象。在这些示例中，有一点需要指出的是，这两个函数在 Go 中是相同的：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And with the function bound to an object instead:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 而当函数绑定到一个对象上时：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are some practical differences in how we call these functions and implications
    for function name collisions. That said, their performance characteristics are
    identical for both the mutable and immutable examples.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用这些函数的方式以及函数名冲突的后果方面，有一些实际的区别。尽管如此，对于可变和不可变示例，它们的性能特征是相同的。
- en: 'With that out of the way, let’s write our benchmark. Go has built-in benchmarking
    support, just like it has built-in testing support. That makes our job of writing
    benchmarks rather easy since the entire code to benchmark fits on a single page:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，让我们编写我们的基准测试。Go 有内置的基准测试支持，就像它有内置的测试支持一样。这使得编写基准测试变得相当容易，因为要基准测试的整个代码可以放在一页上：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this built-in benchmarking support, we can run our benchmark with the
    following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个内置的基准测试支持，我们可以使用以下命令运行我们的基准测试：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Averaged out over a couple of runs, on my **Amazon Web Service** (**AWS**)
    EC2 instance, I get the following result:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 **Amazon Web Service** (**AWS**) EC2 实例上，经过几次运行的平均结果如下：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The concrete values for these `ns/op` properties are going to be different on
    your machine, so don’t focus too much on the concrete values. What should be surprising
    here is that our immutable code outperforms our mutable code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `ns/op` 属性的具体值在您的机器上可能会有所不同，所以不要过于关注具体值。这里应该令人惊讶的是，我们的不可变代码比我们的可变代码表现更好。
- en: To understand what’s going on, we need to take a look at garbage collection,
    and stack versus heap allocation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解发生了什么，我们需要看看垃圾回收以及栈与堆分配。
- en: Understanding stacks, heaps, and garbage collection
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解栈、堆和垃圾回收
- en: Garbage collection is a topic that is complex enough that it probably deserves
    a full chapter in its entirety. We will take some shortcuts here and look at a
    sufficiently deep understanding of this process but will simplify some steps.
    Go itself is open source and has good documentation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是一个足够复杂的话题，可能值得整章讨论。在这里，我们将采取一些捷径，并深入了解这一过程，但会简化一些步骤。Go 本身是开源的，并且有良好的文档。
- en: Reclaiming memory through garbage collection
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过垃圾回收回收内存
- en: Go is a garbage-collected language, which means that memory management is taken
    care of by the Go runtime. This reduces the effort required on the programmer’s
    side as it takes away from the need to manually manage memory. This can eliminate
    or reduce the odds of having certain types of bugs in your code, such as memory
    leaks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种垃圾回收语言，这意味着内存管理由 Go 运行时负责。这减少了程序员方面的努力，因为它消除了手动管理内存的需要。这可以消除或减少代码中某些类型错误的可能性，例如内存泄漏。
- en: With automatic garbage collection, we, the programmers, don’t have to think
    about managing the memory of our application. Memory will be reserved for us,
    and later given back to the system, without our intervention. To make this work,
    the Go runtime needs to do some behind-the-scenes work. Essentially, the runtime
    will trigger a “garbage collection” process to free up memory. It does so by temporarily
    freezing our application, checking which objects are no longer required, and removing
    them from the working memory of our application. There are different ways of figuring
    out which objects are no longer required, and some mechanisms to delete them throughout
    our program’s lifetime. Typically, a garbage collector will try to figure out
    if there are still any references to a piece of data. If there’s a reference to
    the data, it is still accessible by your program and thus should not be deleted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动垃圾回收，我们，程序员，不需要考虑管理我们应用程序的内存。内存会为我们保留，并在之后无我们的干预下归还给系统。为了使这一过程工作，Go 运行时需要在幕后做一些工作。本质上，运行时会触发一个“垃圾回收”过程来释放内存。它通过暂时冻结我们的应用程序，检查哪些对象不再需要，并将它们从我们应用程序的工作内存中移除来实现。有不同方法来确定哪些对象不再需要，以及在我们程序的生命周期中删除它们的机制。通常，垃圾回收器会尝试确定是否还有对数据的引用。如果有对数据的引用，它仍然可以通过你的程序访问，因此不应该被删除。
- en: To understand how this process impacts performance, it helps to think of garbage
    collection as a *stop-the-world* process. This means it completely stops all execution,
    identifies garbage, and removes it to free up memory. In practice, Go uses multiple
    threads to identify the garbage objects. This approach is called the *concurrent
    mark-and-sweep garbage collector*. Regardless of this being concurrent, there
    is still performance overhead. When people are deciding on which language to use
    for their application, the garbage collection overhead pops up surprisingly often
    in conversation. This is most apparent when the decision has to be made between
    Go, C/C++, or Rust.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个过程如何影响性能，将垃圾回收视为一个“停止世界”的过程是有帮助的。这意味着它完全停止所有执行，识别垃圾，并将其移除以释放内存。在实践中，Go
    使用多个线程来识别垃圾对象。这种方法被称为“并发标记-清除垃圾回收器”。尽管这是并发的，但仍然存在性能开销。当人们在决定为他们的应用程序使用哪种语言时，垃圾回收的开销在谈话中经常意外地出现。这在与
    Go、C/C++ 或 Rust 之间的选择中尤为明显。
- en: While the performance impact of garbage collection has been reduced in the more
    recent Go version, the impact cannot be completely erased. There are ways of tweaking
    the garbage collector’s behavior in Go, but in general, that would not be a recommended
    approach. Often, a suboptimal implementation of an algorithm would outweigh the
    negative impact felt by garbage collection.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在最新的 Go 版本中垃圾回收的性能影响已经减少，但影响不能完全消除。有方法可以调整 Go 中垃圾回收器的行为，但通常这不是一个推荐的方法。通常，算法的低效实现会超过垃圾回收带来的负面影响。
- en: Stacks and heaps
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈和堆
- en: Our next topics to discuss are stacks and heaps. There are two types of memory
    available at runtime, namely a stack and a heap. A stack is a **Last-In, First-Out**
    (**LIFO**) data structure. This means that when data is removed from the stack,
    the last item to have been inserted will be deleted. Go uses a stack to store
    data in a chain of function calls, this includes local variables, the function’s
    input parameters, and more.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题是栈和堆。在运行时，有两种类型的内存可用，即栈和堆。栈是一种**后进先出**（**LIFO**）的数据结构。这意味着当数据从栈中移除时，最后插入的项目将被删除。Go使用栈来存储函数调用链中的数据，这包括局部变量、函数的输入参数等等。
- en: When a function is called, the data of this function is pushed to the top of
    the stack. When the function is done executing, this data is removed from the
    stack. Thus, the stack is continuously growing and shrinking while functions are
    being called in your application. There is a limited amount of space available
    for the stack; exceeding this leads to an error well known as a *stack overflow*.
    The elements on the stack can be thought of as having a limited lifetime as they
    are removed from memory quickly (at the end of a function).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被调用时，该函数的数据将被推送到栈顶。当函数执行完毕后，这些数据将从栈中移除。因此，当你的应用程序中调用函数时，栈会持续地增长和缩小。栈可用的空间是有限的；超出这个限制会导致一个众所周知的问题，即*栈溢出*。栈上的元素可以被认为是具有有限生命周期的，因为它们在函数结束时迅速从内存中移除。
- en: The heap, on the other hand, is shared memory for the lifetime of your application.
    The data that is stored here is not limited to the lifetime of a function. This
    means that this data can be referenced (pointed to) from multiple places in your
    application. To avoid the heap from continuously expanding, the heap memory is
    managed by the garbage collector. The garbage collector will scan the memory in
    the heap to figure out if it’s still needed or not. If the data is no longer needed,
    it is deleted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，堆是应用程序生命周期内的共享内存。存储在这里的数据不仅限于函数的生命周期。这意味着这些数据可以从应用程序的多个地方被引用（指向）。为了避免堆不断扩展，堆内存由垃圾回收器管理。垃圾回收器会扫描堆中的内存，以确定是否还需要这些数据。如果数据不再需要，它将被删除。
- en: In the stack and heap implementation, it is cheaper to reclaim memory from a
    stack than it is from a heap. The stack does not need a garbage collector that
    “stops the world” to scan for objects to delete. Thus, if we could allocate as
    much as possible on the stack instead of the heap, our programs would run faster.
    This is not always possible as there is data that we want to keep alive outside
    of the context of a single function. In addition to this, heap allocations tend
    to be slower than stack allocations, as the memory required for a heap allocation
    needs to be reclaimed from a memory pool – a set of memory that Go has claimed
    from the operating system. This is a potentially slow operation as your program
    waits for the memory to become available.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈和堆的实现中，从堆中回收内存比从栈中回收内存更便宜。栈不需要垃圾回收器“停止世界”来扫描要删除的对象。因此，如果我们尽可能在栈上而不是在堆上分配内存，我们的程序将运行得更快。但这并不总是可能的，因为有些数据我们希望在单个函数之外的环境中保持活跃。此外，堆分配通常比栈分配慢，因为堆分配所需的内存需要从内存池中回收——这是Go从操作系统申请的一组内存。这是一个可能很慢的操作，因为程序需要等待内存变得可用。
- en: To understand how this impacts the performance of the immutable and mutable
    example we looked at previously, we need to understand how Go chooses where to
    store a variable. In theory, this sounds simple – if data is needed only in a
    single function it is a stack variable; otherwise, we have to store it on the
    heap. In practice, though, there are a few more things to consider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这如何影响之前我们查看的不变和可变示例的性能，我们需要了解Go如何选择存储变量的位置。在理论上，这听起来很简单——如果数据只需要在单个函数中使用，它就是一个栈变量；否则，我们必须将其存储在堆上。然而，在实践中，还有更多的事情需要考虑。
- en: First, the compiler will try to prove that a variable is local to a single function.
    The compiler does this through a process called *escape analysis*, where it looks
    for variables that escape the context of a single function. If a variable is not
    local to a single function, it stores it on the heap. Another piece of information
    the Go runtime will look at is the size of the data. It makes more sense to store
    large data on the heap rather than on the stack, as the stack is typically more
    limited in space. Stack space is a real issue that we will explore in some more
    depth when we discuss recursion in the next chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器将尝试证明一个变量仅属于单个函数。编译器通过一个称为 *逃逸分析* 的过程来完成这项工作，在这个过程中，它会寻找那些逃离单个函数上下文的变量。如果一个变量不属于单个函数，它就会将其存储在堆上。Go
    运行时还会查看数据的大小。将大型数据存储在堆上而不是栈上更有意义，因为栈的空间通常更有限。栈空间是一个真实的问题，我们将在下一章讨论递归时对其进行更深入的探讨。
- en: How does this tie into our conversations of mutability with pointers? In the
    example code, which we used to benchmark the two functions, the immutable code
    can allocate all memory on the stack. The mutable example is not so lucky and
    will allocate data on the heap since we are using pointers, which is the context
    that escapes a single function. Thus, the impact we are seeing in performance
    is caused by the garbage collector reclaiming memory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何与我们的指针可变性的讨论联系起来？在示例代码中，我们用它来基准测试两个函数，不可变代码可以在栈上分配所有内存。可变示例不太幸运，因为它使用了指针，这会导致数据分配在堆上，这是逃离单个函数的上下文。因此，我们在性能上看到的影响是由垃圾收集器回收内存所造成的。
- en: It’s important to note that the concrete implementation of the garbage collector,
    and even the algorithms for escape analysis, can and do change over time. To understand
    how garbage collection works in the latest version of Go, it’s best to read the
    documentation of that version.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，垃圾收集器的具体实现，甚至逃逸分析的算法，随着时间的推移可能会改变。要了解 Go 最新版本中的垃圾收集器是如何工作的，最好阅读该版本的文档。
- en: Seeing escape analysis in action
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 观察逃逸分析的实际操作
- en: 'Let’s explore the behavior of escape analysis in Go to show that our reasoning
    makes sense. First, we will change our code slightly by adding a pragma to avoid
    the compiler from in-lining our function. A pragma is a special comment in Go
    that gives some instructions to the compiler. We will add this to each function
    so that they will all have the comment present, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过探索 Go 中的逃逸分析行为来展示我们的推理是有道理的。首先，我们将稍微修改我们的代码，通过添加一个pragma来防止编译器内联我们的函数。在
    Go 中，pragma 是一种特殊的注释，它向编译器提供一些指令。我们将为每个函数添加这个pragma，这样它们都会包含这个注释，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means the functions are not erased by the compiler. Function inlining is
    a compiler optimization process that occurs behind the scenes to speed up the
    execution of our programs. Once again, this deserves a chapter on its own but
    is outside the scope of this book.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着函数不会被编译器删除。函数内联是编译器的一种优化过程，它在幕后发生，以加快我们程序的执行速度。再次强调，这值得单独一章来讨论，但超出了本书的范围。
- en: 'Once we have added the pragma to each function, we can build our application
    with the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为每个函数添加了pragma，我们就可以使用以下命令构建我们的应用程序：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This tells the Go compiler to explain to us where escape analysis decisions
    are being made, and what the outcome of these decisions is. When we look at the
    output, we get this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Go 编译器向我们解释逃逸分析决策在哪里被做出，以及这些决策的结果是什么。当我们查看输出时，我们得到以下内容：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What this shows us is that, on line 30, our `Person` is escaping to the heap.
    And when an object escapes to the heap, this eventually has to be picked up by
    the garbage collector so that our memory space can be reclaimed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，在第 30 行，我们的 `Person` 正逃逸到堆上。当一个对象逃逸到堆上时，最终必须由垃圾收集器来处理，以便我们的内存空间可以被回收。
- en: Many things are happening behind the scenes, and we simplified some of how garbage
    collection works in Go. But overall, this should serve as an example of why the
    assumption that pointers and mutable code are faster than immutable code without
    pointers is invalid.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后发生了很多事情，我们简化了 Go 中垃圾收集工作的一些方式。但总体来说，这应该作为一个例子，说明指针和可变代码比没有指针的不可变代码更快这一假设是不成立的。
- en: When to write mutable functions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时编写可变函数
- en: So far, this chapter has indexed heavily on why we prefer to write immutable
    functions. But there are some instances in which it makes sense to write mutable
    functions either way. The only real reason is performance. As we saw earlier,
    the performance implications can often be ignored, but not always. If you are
    using structs that contain a lot of data, copying that over to each function can
    negatively impact the performance sufficiently to cripple your application. The
    only real way of knowing whether this is the case is by adding performance metrics
    to your application. Even so, a trade-off must be made between more performant
    code and more maintainable code. Oftentimes, trying to squeeze more performance
    out of your application hinders long-term maintainability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章主要讨论了为什么我们更喜欢编写不可变函数。但有些情况下，无论是编写可变函数都有意义。唯一真正的理由是性能。正如我们之前看到的，性能影响通常可以忽略，但并非总是如此。如果你使用包含大量数据的结构体，将它们复制到每个函数中可能会对性能产生负面影响，足以削弱你的应用程序。唯一真正知道这是否是这种情况的方法是向你的应用程序添加性能指标。即便如此，也必须在更高效的代码和更易于维护的代码之间做出权衡。通常，试图从你的应用程序中挤出更多性能会阻碍长期的可维护性。
- en: Another possible reason to write mutable code using pointers is for resources
    that need to be singularly unique within your application. If you’re implementing
    traditional object-oriented patterns in your code, you might have implemented
    the singleton pattern. If you want to have a true singleton, you should be using
    a pointer rather than copying over the singleton. Otherwise, you will have multiple
    copies of your singleton available in different functions, potentially each with
    a different state. Whether or not having singletons in your code is a good idea
    is a discussion for a different book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针编写可变代码的另一个可能原因是需要在你应用程序中具有唯一性的资源。如果你在代码中实现传统的面向对象模式，你可能已经实现了单例模式。如果你想有一个真正的单例，你应该使用指针而不是复制单例。否则，你将在不同的函数中有多个单例副本，每个可能都有不同的状态。在你的代码中是否使用单例是一个不同书籍中的讨论话题。
- en: What are functors and monads?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子和单子是什么？
- en: In the previous chapter, we discussed the concept of function purity. A function
    should not produce any side effects and should be idempotent. In this chapter,
    we have seen how structs can be made immutable, and how this ties into function
    purity. As mentioned earlier, even in a purely functional language, in which side
    effects are eliminated as much as possible, you still have desirable side effect
    behavior. For example, getting input from a user, or writing data to a database,
    are both side effects that add value to a program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了函数纯度的概念。一个函数不应该产生任何副作用，并且应该是幂等的。在本章中，我们看到了如何使结构体不可变，以及这与函数纯度的联系。正如之前提到的，即使在纯函数式语言中，尽可能消除副作用，你仍然有期望的副作用行为。例如，从用户那里获取输入，或将数据写入数据库，都是增加程序价值的副作用。
- en: In this section, we will try to build an understanding of how pure functional
    languages can achieve this. We’ll also look at an implementation in Go to achieve
    the same results, building on top of our knowledge about immutable structs and
    pure functions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试理解纯函数式语言如何实现这一点。我们还将查看Go语言中的实现，以实现相同的结果，基于我们对不可变结构和纯函数的知识。
- en: To preface this section, it is commonly said that there are too many monad explanations
    already and all of them are wrong or lacking in some manner. There are many books
    about functional programming, or blog posts and videos, that try to offer a good
    explanation. The fact that new explanations are being offered so frequently should
    give you an idea as to the complexity of the topic. I don’t have the lofty goal
    of offering the “final monad explanation that is ever needed.” Rather, I will
    try to cut it down to the core idea and keep it as close to what’s practical as
    possible. As such, we will stay away from the deeper theoretical layers of category
    theory. What follows is, hopefully, a *good enough* explanation of the idea rather
    than a perfectly holistic explanation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍本节之前，通常说已经有太多的单子解释，而且它们都是错误的或者在某些方面有所欠缺。关于函数式编程有很多书籍，或者博客文章和视频，试图提供好的解释。新解释频繁提出的事实应该让你对这一主题的复杂性有所了解。我没有提供“最终需要的单子解释”的宏伟目标。相反，我将尝试将其简化为核心思想，并尽可能接近实际应用。因此，我们将避免深入到范畴论的理论层面。以下是一个希望是“足够好”的解释，而不是一个完美整体性的解释。
- en: What’s a functor?
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是函子？
- en: 'Before we can demonstrate what a monad is, we need to understand what a functor
    is. A functor, simply put, is a function that can apply an operation to each element
    contained in a data structure. In Haskell, the implementation of this function
    is called `fmap`. In Go, this function might look something like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们演示什么是单子之前，我们需要了解什么是函子。简单来说，函子是一个可以对数据结构中包含的每个元素应用操作的函数。在 Haskell 中，这个函数的实现称为
    `fmap`。在 Go 中，这个函数可能看起来像这样：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding type signature, we are using slices. A slice is a data type
    that contains other data elements. The `fmap` implementation does not have to
    operate on slices – any data structure that holds data elements will do, such
    as pointers (they optionally hold a data element), functions themselves, trees,
    or as we will see in the next few pages, a monad.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类型签名中，我们使用了切片。切片是一种包含其他数据元素的数据类型。`fmap` 实现不必在切片上操作——任何包含数据元素的数据结构都可以，例如指针（它们可以可选地包含一个数据元素）、函数本身、树，或者正如我们将在下一页看到的那样，一个单子。
- en: 'If we were to write an implementation of `fmap` in Go to operate on slices,
    as shown in the function signature previously, we would simply call the provided
    `mapFunc` for each element in `sliceA`. The result of this would be stored in
    the new slice, `sliceB`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在 Go 中编写一个操作切片的 `fmap` 实现如之前所示的功能签名，我们只需为 `sliceA` 中的每个元素调用提供的 `mapFunc`。这个结果将存储在新的切片
    `sliceB` 中：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the use of generics in the preceding example, which we can use to map
    between two `any` types. But the input is `A` and the output is `B`. The map function
    thus **changes the type** of our data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面示例中泛型的使用，我们可以用它来在两个 `any` 类型之间进行映射。但输入是 `A`，输出是 `B`。因此，映射函数**改变了**我们数据的数据类型。
- en: 'Let’s take a look at how we would use this function. Imagine that we have a
    slice of integers, and we want to transform this into a slice of strings. We could
    use our `fmap` function to do exactly this. All we need to do is provide `fmap`
    with a function that takes an integer and returns a string:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个函数。想象一下，我们有一个整数切片，我们想将其转换成字符串切片。我们可以使用我们的 `fmap` 函数来完成这个任务。我们只需要向
    `fmap` 提供一个函数，该函数接受一个整数并返回一个字符串：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we run the preceding function, we get the following output (recall that
    `%T` prints the type of the variable):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的函数时，我们得到以下输出（回想一下，`%T` 打印变量的类型）：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This tells us that our int, `slice`, was transformed into a string slice, and
    the values contained are, to no surprise, `[1,` `2, 3]`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们的 `int`、`slice` 被转换成了字符串切片，并且不出所料，包含的值是 `[1, 2, 3]`。
- en: This is pretty much what a functor is. It’s a function that transforms all data
    in a given data structure into data of a different type. The `fmap` implementation
    is a pure, higher-order function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是一个函子的定义。它是一个将给定数据结构中的所有数据转换为不同类型数据的函数。`fmap` 实现是一个纯的、高阶函数。
- en: From functor to monad
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函子到单子
- en: The next step is getting from a functor to a monad. So, what exactly is a monad?
    When we aim for a somewhat theoretical description of the monad, we might get
    something such as the following.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从函子到单子的转换。那么，单子究竟是什么呢？当我们试图对单子进行某种理论描述时，我们可能会得到以下内容。
- en: 'A monad is a software design pattern. It is a data type that can combine functions
    of similar types and wrap the results of a non-monad type into a new monadic type
    offering additional functions. For a type to be a monad, it needs to have two
    functions defined:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单子是一种软件设计模式。它是一种可以将类似类型的函数组合起来，并将非单子类型的结果包装成一个新的单子类型，提供额外函数的数据类型。为了使一个类型成为单子，它需要定义两个函数：
- en: '**A function to wrap a value of the T type** **into Monad[T]**'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个将 T 类型的值包装到 Monad[T] 中的函数**'
- en: '**A function to combine the function of the** **Monad[T] type**'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个组合 Monad[T] 类型函数的函数**'
- en: We will demonstrate the monad with a practical example. A `String`). A popular
    monad is the `Maybe` monad, also known as `Optional` in some programming languages.
    The `Maybe` monad is a type that *potentially* contains a concrete value, but
    also might be empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个实际示例来演示单子。一个流行的单子是 `Maybe` 单子，在一些编程语言中也称为 `Optional`。`Maybe` 单子是一种可能包含具体值的类型，但也可能为空。
- en: 'To model the `Maybe` monad in Go, we will use an interface that defines the
    operations on our struct. Next, we will also create two implementations, one for
    when a value is present, and one for when the value is absent:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中模拟 `Maybe` 单子，我们将使用一个定义我们结构体操作的接口。接下来，我们还将创建两个实现，一个用于值存在的情况，另一个用于值不存在的情况：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding interface implementation, we have defined two functions: `Get`
    and `GetOrElse`. More can be defined; the concrete functions don’t matter as much.
    What’s important is that we have a way to model values that might or might not
    be present.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的接口实现中，我们定义了两个函数：`Get`和`GetOrElse`。可以定义更多；具体的函数并不那么重要。重要的是，我们有一种方式来模拟可能存在或可能不存在的值。
- en: Notice that we are not using pointers here, we’re only using concrete types.
    The `Maybe` monad is often introduced to avoid pointers. By avoiding pointers,
    we can eliminate a class of errors that happen at runtime when functions are called
    on *null pointers*. The `null`, or `nil` in Go, also does not make real sense
    from a type taxonomy perspective. The `nil` pointer belongs to every type, meaning
    there’s no real useful information in there, and we want our type system to be
    as declarative as possible. (Go does have a `typed nil`, on which functions can
    be called safely. Still, exercise caution whenever using this. It’s not common
    behavior in programming languages and can trip up even seasoned Go programmers.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里没有使用指针，我们只使用了具体类型。`Maybe`单子通常被引入以避免使用指针。通过避免使用指针，我们可以消除在运行时调用*空指针*时发生的一类错误。在Go中，“null”或“nil”从类型分类的角度来看也没有真正的意义。“nil”指针属于每个类型，这意味着其中没有真正有用的信息，我们希望我们的类型系统尽可能声明式。
    （Go确实有“类型nil”，函数可以在其上安全地调用。然而，在使用时仍需谨慎。这并不是编程语言的常见行为，甚至可能会让经验丰富的Go程序员感到困惑。）
- en: George Hoar, who first introduced the null pointer concept, called this his
    “*billion-dollar mistake*.”
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 乔治·霍尔，他首次引入了空指针概念，称这是他的“*十亿美元的错误*”。
- en: 'The two implementations that we will use for modeling the presence and absence
    of a value are `Just` and `Nothing`, respectively. These names have been borrowed
    from Haskell; you’ll find different names for these values in different programming
    languages. `Just` signals a concrete value is present, while `Nothing` signals
    the absence thereof. We will start by implementing the value present use case,
    with the `JustMaybe` type:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于模拟值的存在和不存在的情况的两个实现分别是`Just`和`Nothing`。这些名称是从Haskell借用的；你会在不同的编程语言中找到这些值的不同的名称。“Just”表示存在一个具体值，而“Nothing”表示不存在。我们将首先实现值存在的情况，使用`JustMaybe`类型：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code adheres to the `Maybe` interface. As such, we can use a
    `JustMaybe` as an instance of `Maybe`. To implement the absence of a value, we’ll
    implement the analogous `NothingMaybe`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码遵循`Maybe`接口。因此，我们可以将`JustMaybe`用作`Maybe`的一个实例。为了实现值的缺失，我们将实现类似的`NothingMaybe`：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The implementations are rather straightforward for each function. Perhaps the
    most surprising thing is the `return` statement in `Get` for a `NothingMonad`,
    where we wrote:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的实现相当直接。也许最令人惊讶的是`Get`函数中对于`NothingMonad`的`return`语句，我们写的是：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This statement returns a new instance of `A`, but `A` is an unknown value at
    compile time. By using `new`, we can instance it, but it’ll return a pointer value,
    which we will dereference to return a concrete value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句返回`A`的新实例，但`A`在编译时是一个未知值。通过使用`new`，我们可以实例化它，但它将返回一个指针值，我们将解引用它以返回一个具体值。
- en: 'Next, let’s also create constructor-like functions for these two implementations,
    which are functions that can wrap a value of a given type into the monadic representation.
    Recall that this is a requirement for our monad pattern:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们也创建这两个实现的构造函数，这些是可以将给定类型的值包装到单子表示中的函数。回想一下，这是我们单子模式的要求：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These two implementations will let us implement both the presence and absence
    of a given value. For example, we could now use these in a function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实现将使我们能够实现给定值的“存在”和“不存在”。例如，我们现在可以在一个函数中使用这些实现：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding function, we are getting a value from a map by looking up a
    given key. If a value is present, we return the `JustMaybe` implementation of
    our monad; otherwise, we return the `NothingMaybe` implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们通过查找给定的键从映射中获取一个值。如果存在值，我们返回我们的单子`JustMaybe`实现；否则，我们返回`NothingMaybe`实现。
- en: Convenience functions can be written, such as `fromNullable(*value)`, which
    would return either a `JustMaybe` or a `NothingMaybe` by checking if the value
    passed to the function is present.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写一些便利函数，例如`fromNullable(*value)`，它将根据传递给函数的值是否存在返回`JustMaybe`或`NothingMaybe`。
- en: 'Remember that our monad type is a data structure that holds underlying elements.
    As such, we can implement the `fmap` function on this type as well. In this implementation,
    we will turn a `Maybe` of type `A` into a `Maybe` of type `B`. We need to provide
    a function to map from the underlying type `A` to the underlying type `B` to accomplish
    this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的单子类型是一个包含底层元素的数据结构。因此，我们也可以在这个类型上实现`fmap`函数。在这个实现中，我们将一个类型为`A`的`Maybe`转换为类型为`B`的`Maybe`。我们需要提供一个函数来从底层类型`A`映射到底层类型`B`以完成此操作：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we are using a type switch to determine what type our
    `Maybe` monad is to figure out if it represents the `JustMaybe` or `NothingMaybe`
    implementation. If the type matches `JustMaybe`, we will map the underlying value
    from type `A` to type `B`, and return this wrapped in a new monad.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用类型切换来确定我们的`Maybe`单子的类型，以确定它是否代表`JustMaybe`或`NothingMaybe`实现。如果类型匹配`JustMaybe`，我们将从类型`A`映射到类型`B`的底层值，并返回这个新封装的单子。
- en: This is an incomplete definition of a monad, but a practical implementation
    of one such instance. This concept can be pushed further, but Go does not provide
    a convenient way of exploring this further, so it would not often be used in the
    real world.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单子的不完整定义，但是一个实际实现的实例。这个概念可以进一步扩展，但Go没有提供方便的方式来进一步探索，所以它不太可能在现实世界中经常使用。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched upon immutability in Go. We took a small refresher
    on how immutability works in Go, by either pass-by-value or pass-by-reference.
    We learned that pointers do not guarantee that your code will be more performant
    than if you avoid them. We also discussed some of the benefits of immutable code,
    such as improving the readability and understandability of the code base. We also
    touched on how this makes concurrency easier to implement correctly, as the state
    is not mutated between functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要回顾了Go中的不可变性。我们通过值传递或引用传递来回顾了Go中不可变性的工作方式。我们了解到指针并不能保证你的代码比避免它们时更高效。我们还讨论了不可变代码的一些好处，例如提高代码库的可读性和可理解性。我们还简要介绍了这使得并发更容易正确实现，因为状态在函数之间不会被修改。
- en: Finally, we wrapped up the discussion of pure functions that we started in the
    previous chapter by looking at monads and a practical implementation thereof with
    the `Maybe` monad.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看单子以及使用`Maybe`单子的实际实现来结束了对上一章开始讨论的纯函数的讨论。
- en: In the next chapter, we will explore some must-have functions for writing code
    functionally.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨编写函数式代码时必须拥有的函数。
- en: 'Part 2: Using Functional Programming Techniques'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：使用函数式编程技术
- en: After we have established the basic ideas of functional programming and see
    how they relate to the object-oriented paradigm, we will move on to this part.
    Here, we will look at how functional programming can be leveraged to compose larger
    programs while still at the class level. We’ll learn about solving problems iteratively
    versus recursively, the three important categories of function types, and how
    to chain functions together for more readable code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们建立了函数式编程的基本思想并看到它们如何与面向对象范式相关联之后，我们将继续这部分内容。在这里，我们将探讨如何在类级别上利用函数式编程来组合更大的程序。我们将学习如何迭代地解决问题与递归地解决问题，函数类型的三种重要类别，以及如何将函数链接起来以编写更易读的代码。
- en: 'This part has the following chapters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含以下章节：
- en: '[*Chapter 6*](B18771_06.xhtml#_idTextAnchor101)*, Three Common Categories of
    Functions*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18771_06.xhtml#_idTextAnchor101)*，函数的三个常见类别*'
- en: '[*Chapter 7*](B18771_07.xhtml#_idTextAnchor113)*, Recursion*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18771_07.xhtml#_idTextAnchor113)*，递归*'
- en: '[*Chapter 8*](B18771_08.xhtml#_idTextAnchor126)*, Readable Function Composition
    with Fluent Programming*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18771_08.xhtml#_idTextAnchor126)*，使用流畅编程进行可读的函数组合*'
