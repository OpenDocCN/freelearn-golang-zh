- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Three Common Categories of Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的三个常见类别
- en: In the preceding chapters, we have looked at some of the core components of
    functional programming. We have discussed how to write functions that adhere to
    both functional programming and pure functional programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经探讨了函数式编程的一些核心组件。我们讨论了如何编写既符合函数式编程又符合纯函数式编程的函数。
- en: 'In this chapter, we are going to look at some practical implementations of
    functions that leverage these concepts. These are the categories and topics we
    will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些利用这些概念的实际函数实现。我们将涵盖以下类别和主题：
- en: The first category we will look at is predicate-based functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个类别是基于谓词的函数
- en: Then, we will take a look at data transformation functions, which maintain the
    structure of our data (more on that later)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将查看数据转换函数，这些函数保持我们数据结构（更多内容将在后面介绍）
- en: Finally, we will take a look at functions, which transform the data and reduce
    the information into a single value
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将探讨函数，这些函数将数据转换并减少信息到一个单一值
- en: This is not meant to be an exhaustive list, but with these three categories,
    we can build a large portion of our day-to-day applications.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个详尽的列表，但有了这三个类别，我们可以构建我们日常应用的大部分内容。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you can use any Go version at or above Go 1.18, as we will
    be using generics in some of the later examples. You can find all the code on
    GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter6](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter6).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你可以使用任何 Go 1.18 或更高版本的 Go，因为我们将在一些后续示例中使用泛型。你可以在 GitHub 上找到所有代码，链接为 [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter6](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter6)。
- en: Predicate-based functions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于谓词的函数
- en: The first type of functions that we will explore is predicate-based functions.
    A `if` statements inside the body of a function. A common use case is to filter
    a set of data into a subset that matches a specific condition – for example, given
    a list of people, return all of those who are older than 18 years old.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一种函数类型是基于谓词的函数。函数体内的 `if` 语句。一个常见的用例是将一组数据过滤成符合特定条件的子集 - 例如，给定一个人员列表，返回所有年龄大于
    18 岁的人。
- en: 'To start, we can introduce a type alias for a function that defines the type
    signature of a predicate:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以引入一个函数类型别名，它定义了谓词的类型签名：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This type alias tells us that the function takes an input with a type of `A`,
    which can represent `the any` type in our program, but needs to return a `bool`
    value. This type uses generics, which were introduced in Go 1.18\. We can now
    use this type in every place at which a predicate is expected. The first function
    that works using predicates is the simple `Filter` function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型别名告诉我们，该函数接受一个类型为 `A` 的输入，它可以代表程序中的 `any` 类型，但需要返回一个 `bool` 值。这个类型使用了泛型，它是在
    Go 1.18 中引入的。我们现在可以在任何期望谓词的地方使用这个类型。第一个使用谓词工作的函数是简单的 `Filter` 函数。
- en: Implementing a Filter function
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现一个 Filter 函数
- en: 'The `Filter` function is a staple within the functional programmer’s toolbox.
    Let’s imagine that we don’t have higher-order functions available, and we want
    to write a `Filter`-like function. For this, let’s assume that we have a slice
    of numbers, and we want to filter all the numbers that are larger than 10\. We
    could write something such as this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter` 函数是函数式程序员工具箱中的基本工具。让我们假设我们没有可用的高阶函数，并且我们想要编写一个类似 `Filter` 的函数。为此，让我们假设我们有一组数字，并且我们想要过滤出所有大于
    10 的数字。我们可以编写如下内容：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This works well enough, but it’s not flexible. In this case, this function
    will always just filter for numbers larger than 10\. We could make it a bit more
    flexible by adjusting the threshold value using an input parameter for our function.
    With a trivial change, we get the following function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足够好了，但它不够灵活。在这种情况下，这个函数将始终只过滤出大于 10 的数字。我们可以通过调整函数的输入参数中的阈值值来使其更加灵活。通过微小的改动，我们得到以下函数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives us a more flexible `Filter` function. However, as we all know, requirements
    change often, and users need new functionalities on an existing system almost
    ad infinitum. The next requirement for our function is to optionally filter for
    either *larger than*, or, in some cases, *smaller than*. Thinking about this for
    some time, you might realize that this could be implemented as two functions (the
    function body is omitted in snippets, as it’s a trivial change):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们有了更灵活的`Filter`函数。然而，正如我们所知，需求经常变化，用户几乎无限期地需要现有系统的新功能。我们函数的下一个需求是可选地过滤出“大于”或在某些情况下“小于”。思考一段时间后，你可能会意识到这可以作为一个函数实现（函数体在代码片段中被省略，因为它是一个微不足道的更改）：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sure enough, this would work – but the work never stops. Next, you have to implement
    a function that can filter for numbers larger than a given value but smaller than
    another. Then, our users become really into odd numbers, so there needs to be
    a filter for finding all odd numbers as well. Later on, the user asks you to count
    the exact amount of times a certain value appears, so you also need a filter for
    a certain value *exactly* in your list of numbers. You get the point; we can create
    a bunch of functions that suit all these use cases, but that approach does not
    sound like the best option.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会起作用——但工作永远不会停止。接下来，你必须实现一个可以过滤出大于给定值但小于另一个值的数字的函数。然后，我们的用户对奇数特别感兴趣，因此需要有一个可以找到所有奇数的过滤器。后来，用户要求你计算某个值出现的确切次数，因此你还需要一个过滤器来确保你的数字列表中恰好有一个特定的值。你明白我的意思了；我们可以创建一系列适合所有这些用例的函数，但这种方法听起来并不是最佳选择。
- en: One of the benefits of having a language with support for higher-order functions
    is that we can reduce repetitive implementations and abstract our algorithm. All
    of the aforementioned use cases fit within a function often called `Filter` in
    functional programming languages. The implementation of the `Filter` function
    is rather straightforward. The basic operation it supports is to iterate over
    a container, such as a *slice*, and apply a predicate function to every data element
    contained within the container. If the predicate function returns `true`, we will
    append this data element to our output. If not, we simply discard elements that
    did not match.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个支持高阶函数的语言的好处之一是我们可以减少重复的实现并抽象我们的算法。所有上述用例都适合在函数式编程语言中经常被称为`Filter`的函数。`Filter`函数的实现相当直接。它支持的基本操作是遍历一个容器，如切片，并对容器中包含的每个数据元素应用谓词函数。如果谓词函数返回`true`，我们将此数据元素追加到我们的输出中。如果不匹配，我们简单地丢弃不匹配的元素。
- en: 'As we want to follow the best practices for implementing these functions, these
    functions will be pure and immutable. The original slice will never be modified
    within our filter functions, and neither will the elements contained therein:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望遵循实现这些函数的最佳实践，因此这些函数将是纯函数且不可变的。在我们的过滤器函数内部，原始切片永远不会被修改，其中的元素也不会被修改：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `Filter` implementation is a pretty typical implementation that you will
    find in many functional (and multi-paradigm) programming languages. Using higher-order
    functions in this way, we can essentially make part of an algorithm configurable.
    In other words, we abstract our algorithm. With the `Filter` function, the actual
    predicate part of an `if` statement is customizable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Filter`实现是一个相当典型的实现，你会在许多函数式（和多范式）编程语言中找到。通过这种方式使用高阶函数，我们实际上可以使算法的一部分可配置。换句话说，我们抽象了我们的算法。使用`Filter`函数，`if`语句的实际谓词部分是可定制的。
- en: 'Notice that we have implemented this using *generics*. `Filter` does not care
    what data types it is working with. Anything that can be stored in a slice can
    be passed to the `Filter` function. Let’s look at how we would use this in practice
    by creating some of the functions we discussed earlier. We will start off by implementing
    `LargerThan` and `SmallerThan` filters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是泛型。`Filter`不关心它正在处理的数据类型。任何可以存储在切片中的东西都可以传递给`Filter`函数。让我们通过创建我们之前讨论的一些函数来查看我们如何在实践中使用它。我们将从实现`LargerThan`和`SmallerThan`过滤器开始：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The functions that we are passing to `Filter` as input are a tad verbose, as
    at the time of writing, Go does not have syntactic sugar for creating anonymous
    functions. Notice how we did not have to duplicate the body of our `Filter` function
    for this implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`Filter`作为输入的函数有点冗长，因为在编写本文时，Go还没有创建匿名函数的语法糖。注意，我们不需要为这个实现重复`Filter`函数的主体。
- en: 'Implementing other filters, such as *larger than X but smaller than Y* or *filter
    even numbers*, are equally easy to implement. Remember that we only have to pass
    the `if` statement logic each time and the iteration of the list is taken care
    of by the `Filter` function itself:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实现其他过滤器，如`大于X但小于Y`或`过滤偶数`，同样容易实现。记住，我们每次只需要传递`if`语句的逻辑，列表的迭代由`Filter`函数本身处理：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By implementing this with generics, our `Filter` function can work with any
    data type. Let’s see how this function would work with the `Dog` struct that we
    have used in earlier chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用泛型实现，我们的`Filter`函数可以与任何数据类型一起工作。让我们看看这个函数如何与我们在前面章节中使用过的`Dog`结构体一起工作。
- en: 'Recall that our struct for `Dog` had three fields: `Name`, `Breed`, and `Gender`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的`Dog`结构体有三个字段：`Name`、`Breed`和`Gender`：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This snippet omits the `const` declarations for `Breed` and `Gender`, as well
    as the type aliases. These are the same as those in [*Chapter 3*](B18771_03.xhtml#_idTextAnchor047),
    and the full implementation can be found on GitHub: [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段省略了`Breed`和`Gender`的`const`声明以及类型别名。这些与[*第3章*](B18771_03.xhtml#_idTextAnchor047)中的相同，完整的实现可以在GitHub上找到：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter3)。
- en: 'Because we have used generics in the implementation of our `Filter` function,
    this will work on any data type, including custom structs. As such, we can use
    the function as is without any changes. Let’s implement a filter for all dogs
    that are of the `Havanese` breed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Filter`函数的实现中使用了泛型，这将适用于任何数据类型，包括自定义结构体。因此，我们可以直接使用该函数，无需任何修改。让我们实现一个对所有哈瓦那犬品种的狗进行过滤的过滤器：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s all there is to it. Next, let’s look at some other functions that use
    predicates.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。接下来，让我们看看一些使用谓词的其他函数。
- en: Any or all
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何或所有
- en: It is common to have to make sure that either *some* elements or *all* elements
    match a certain condition. The use case for abstracting this into a higher-order
    function is the same as for the `Filter` function. If we do not abstract this,
    a separate `All` and `Any` function would have to be implemented for each use
    case. While these are not found as often in multi-paradigm languages or object-oriented
    languages, they are still found in purely functional languages and come in handy.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 确保某些元素或所有元素符合特定条件是很常见的。将这种需求抽象成高阶函数的使用场景与`Filter`函数相同。如果我们不进行抽象，就必须为每个使用场景实现单独的`All`和`Any`函数。虽然这些在多范式语言或面向对象语言中并不常见，但在纯函数式语言中仍然存在，并且非常有用。
- en: Looking for a match
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找匹配项
- en: The first function to look at is the `Any` function. At times, you may be interested
    in knowing whether or not a certain value is present in a list without being interested
    in exactly how often it is present or actually using the values afterward. If
    this is the case, the `Any` function is exactly what you are looking for.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要查看的函数是`Any`函数。有时，你可能想知道某个值是否存在于列表中，而不关心它出现的次数或实际上使用这些值。如果是这种情况，`Any`函数正是你所需要的。
- en: 'Without the `Any` function, the same result could be achieved somewhat ad hoc
    with the `Filter` function. You would probably end up writing something such as
    the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`Any`函数，同样的结果可以通过`Filter`函数以某种临时方式实现。你可能会写出如下内容：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Do note that I am splitting this into multiple lines for clarity, but in less
    verbose languages such as Python and Haskell, this kind of filter would still
    be a good one-liner. In Go, I’d be a bit cautious about the line length in case
    you decide to do so.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我将其分成多行是为了清晰起见，但在像Python和Haskell这样的非冗长语言中，这种过滤器仍然是一个很好的单行代码。在Go中，如果你决定这样做，我会对行长度稍微谨慎一些。
- en: This implementation has one major flaw. What if you have a really large list
    of 10 million elements? The `Filter` function will iterate through every element
    in the list. It is always running in linear time, `O(n)`. Our `Any` function can
    do better, although we’ll still be running in `O(n)` – worst-case time. In practice,
    it can be more performant, however.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现有一个主要缺陷。如果你有一个包含1000万个元素的非常大的列表怎么办？`Filter`函数将遍历列表中的每个元素。它始终以线性时间，`O(n)`运行。我们的`Any`函数可以做得更好，尽管我们仍然会以`O(n)`
    – 最坏情况时间运行。然而，在实践中，它可能更高效。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we knew that we only needed to look for integers, there are better algorithms
    than our `Any` implementation here. However, we want to write it generically for
    any type of data, so those other algorithms would fail for data types such as
    strings or custom structs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道我们只需要查找整数，那么比我们的 `Any` 实现更好的算法。然而，我们希望为任何类型的数据编写它，所以那些其他算法对于字符串或自定义结构体等数据类型将失败。
- en: 'The easiest way to gain some performance, despite having a theoretical worst-case
    complexity of linear time, is by iterating through a slice until the first element
    matches our search. If the match is found, we return `true`. Otherwise, we return
    `false` at the end of our function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管理论上的最坏情况复杂度为线性时间，但获取一些性能的最简单方法是通过遍历切片直到第一个元素匹配我们的搜索。如果找到匹配项，我们返回 `true`。否则，我们在函数结束时返回
    `false`：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking for all matches
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找所有匹配项
- en: 'The implementation for `All` matches is similar to the `Any` match, with the
    same benefit of abstracting the implementation of `if` statements. The implementation
    for `All` has a similar practical benefit as the `Any` implementation. As soon
    as an element does `false`. Otherwise, we return `true` at the end of our function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`All` 匹配的实现与 `Any` 匹配类似，具有相同的抽象 `if` 语句实现的优点。`All` 的实现具有与 `Any` 实现类似的实际优点。一旦一个元素返回
    `false`。否则，我们在函数结束时返回 `true`：'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing DropWhile and TakeWhile
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 DropWhile 和 TakeWhile
- en: The next two implementations are still predicate-based, but rather than returning
    a single `true` or `false` as output, these are used to manipulate the slice.
    In that sense, they are closer to the original `Filter` implementation, but the
    difference is that they truncate either the start of a list or the tail of a list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个实现仍然是基于谓词的，但它们不是返回单个 `true` 或 `false` 作为输出，而是用来操作切片。从这个意义上说，它们更接近原始的 `Filter`
    实现，但不同之处在于它们截断列表的开始或尾部。
- en: TakeWhile implementation
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TakeWhile 实现
- en: '`TakeWhile` is a function that will take elements from the input slice as long
    as a condition is met. As soon as the condition fails, the result containing the
    start of the list up until the failing predicate is returned:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`TakeWhile` 是一个函数，只要满足条件，就会从输入切片中取元素。一旦条件失败，就会返回包含列表开始直到失败谓词的结果：'
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this function, this is exactly what is happening. As long as our predicate
    is met for each subsequent element, this element is stored in our output value.
    Once the predicate fails a single time, the output is returned. Let’s demonstrate
    this with a simple slice containing consecutive numbers. Our predicate will look
    for odd numbers. Hence, as long as the numbers are odd, they will be appended
    to the output slice, but as soon as we encounter an even number, what we have
    collected thus far will be returned:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，这正是所发生的事情。只要我们的谓词对每个后续元素都成立，这个元素就会被存储在我们的输出值中。一旦谓词失败一次，输出就会被返回。让我们用一个简单的包含连续数字的切片来演示这一点。我们的谓词将寻找奇数。因此，只要数字是奇数，它们就会被追加到输出切片中，但一旦我们遇到偶数，我们迄今为止收集到的内容就会被返回：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the output is `[1 1]`. Notice how this is different from the
    plain `Filter` function – if this same predicate was given to the `Filter` function,
    our output would be `[1 1 3` `5 13]`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，输出结果是 `[1 1]`。注意这与普通的 `Filter` 函数不同——如果将这个相同的谓词给 `Filter` 函数，我们的输出将是
    `[1 1 3 5 13]`。
- en: Implementing DropWhile
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 DropWhile
- en: 'Implementing `DropWhile` is the counterpart to `TakeWhile`. This function will
    drop elements as long as a condition is met. Thus, elements are returned from
    the first failed predicate test until the end of the list:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `DropWhile` 是 `TakeWhile` 的对应函数。这个函数会在满足条件的情况下丢弃元素。因此，从第一个失败的谓词测试开始直到列表的末尾返回元素：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s test this out against the same input data as our `TakeWhile` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用与我们的 `TakeWhile` 函数相同的输入数据来测试这个实现：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output of this function is `[2 3 5 8 13]`. The only elements that are dropped
    are therefore `[1 1]`. If you combine the output of `TakeWhile` and `DropWhile`,
    given the same predicate, you would recreate the input slice.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的输出结果是 `[2 3 5 8 13]`。因此，被丢弃的唯一元素是 `[1 1]`。如果你将 `TakeWhile` 和 `DropWhile`
    的输出结合起来，给定相同的谓词，你将重新创建输入切片。
- en: Map/transformation functions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map/转换函数
- en: The next category of functions which we will look at is `Map` functions. These
    are functions that apply a transformation function to each element in a container,
    changing the element and possibly even the data type. This is one of the most
    powerful functions in a functional programmer’s toolbox, as this allows you to
    transform your data according to a given rule.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的下一类函数是`Map`函数。这些函数将转换函数应用于容器中的每个元素，改变元素甚至可能改变数据类型。这是函数式程序员工具箱中最强大的函数之一，因为它允许你根据给定的规则转换你的数据。
- en: There are two main implementations that we will look at. The first implementation
    is the simple `Map` function, whereby an operation is performed on each element,
    but the data type remains the same before and after the transformation – for example,
    multiplying each element in a slice. This will change the content of the values,
    but not the type of the values. The other implementation of `Map` is one whereby
    the data types can change as well. This will be implemented as `FMap`, and this
    is what we introduced in the previous chapter when looking into Monads.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨两种主要的实现。第一种实现是简单的`Map`函数，其中对每个元素执行操作，但转换前后数据类型保持不变——例如，乘以切片中的每个元素。这将改变值的内
    容，但不会改变值的类型。`Map`的另一种实现是数据类型也可以改变。这将被实现为`FMap`，这是我们上一章在探讨Monads时引入的。
- en: Transformations while maintaining the data type
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持数据类型不变的转换
- en: The first transformation function that we will look at is one whereby the data
    types remain the same. Whenever a programmer encounters this function, they can
    be assured that the data type after calling the function is the same as the data
    type that was passed to the function. In other words, if the function is called
    for a list of elements with a data type of `Dog`, the output of this function
    is still a list of `Dog` elements. What can be different though is the actual
    content of the fields within those structs (e.g., the name property can be updated).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的第一个转换函数是数据类型保持不变的那种。每当程序员遇到这个函数时，他们可以确信函数调用后的数据类型与传递给函数的数据类型相同。换句话说，如果函数被用于一个包含`Dog`类型元素的列表，那么这个函数的输出仍然是一个包含`Dog`元素的列表。不过，这些结构体（structs）字段的实际内容可能会有所不同（例如，名称属性可能会被更新）。
- en: Just like with the `Filter` implementation, these will be implemented in a purely
    functional way. Calling the `Map` function should **never** make changes in place
    to the objects that we provide as an input to the function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Filter`实现一样，这些将纯函数式地实现。调用`Map`函数**永远**不应该对我们提供给函数作为输入的对象进行就地更改。
- en: 'Overall, implementing the `Map` function is straightforward. We will iterate
    over our slice of values and call a transformation function for each value. Essentially,
    what we are doing with the `Map` function is abstracting the actual transformation
    logic. The core algorithm is the iteration over our slice, not the concrete transformations.
    This means we are once again building a higher-order function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，实现`Map`函数很简单。我们将遍历我们的值切片并对每个值调用转换函数。本质上，我们使用`Map`函数所做的就是抽象实际的转换逻辑。核心算法是我们对切片的迭代，而不是具体的转换。这意味着我们再次构建了一个高阶函数：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, our generic type signature tells us that the data type is
    preserved when calling `MapFunc`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的泛型类型签名告诉我们，在调用`MapFunc`时数据类型是保留的：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Given `A`, we will get `A` back. Notice that the type can be any type as per
    the generic contract. There are no type constraints necessary for our `Map` implementation.
    Let’s look at a demo of multiplying each element in our slice by `2`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`A`，我们将得到`A`。请注意，类型可以是任何类型，根据泛型合约。我们的`Map`实现不需要类型约束。让我们看看将切片中的每个元素乘以`2`的示例：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function can work with any data type as well. Let’s look at a demo in
    which we apply a transformation to the name of each dog in a list. If the gender
    of the dog is male, we’ll prefix the name with `Mr.`, and if the gender is female,
    we’ll prefix it with `Mrs.`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也可以与任何数据类型一起工作。让我们看看一个示例，我们将对列表中每只狗的名称进行转换。如果狗的性别是男性，我们将名称前缀设置为`Mr.`；如果性别是女性，我们将前缀设置为`Mrs.`：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running this code would result in the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It’s important to stress that these changes are made to copies of the data,
    and not to the original `Dog` objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，这些更改是对数据副本进行的，而不是对原始`Dog`对象进行的。
- en: Transforming from one to many
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一到多的转换
- en: An adaptation of the `Map` function is the `Flatmap` function. This function
    will map a `Flatmap`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 函数的一个变体是 `Flatmap` 函数。这个函数将映射一个 `Flatmap`。'
- en: 'The implementation of the function we will use is not as efficient but works
    well enough for most purposes. For each element in our slice, we are going to
    call the transformation function, which will transform our single element into
    a slice of elements. Rather than storing this intermediately as a slice of slices,
    we will immediately collapse each slice and store the individual elements consecutively
    in memory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的函数实现并不那么高效，但对于大多数目的来说足够好了。对于切片中的每个元素，我们将调用转换函数，该函数将我们的单个元素转换为一个元素切片。我们不会将这个中间结果作为切片的切片存储，而是立即将每个切片折叠并连续存储在内存中的单个元素：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s demonstrate this by implementing an example. For each integer, `N`, in
    a slice, we are going to turn this into a slice of all integers from 0 up to `N`.
    Finally, we are going to return this result as a consecutive slice:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个示例来演示这一点。对于切片中的每个整数 `N`，我们将将其转换为从 0 到 `N` 的所有整数的切片。最后，我们将这个结果作为连续切片返回：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of running this code is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出如下：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is what we have shown in the image. Every single element is turned into
    a slice, and the slices are then combined. For each element in our input slice,
    this is what the intermediate output would look like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们展示在图像中的内容。每个单独的元素都被转换为一个切片，然后这些切片被组合。对于输入切片中的每个元素，中间输出将如下所示：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This intermediate output then gets combined into a single slice. Next, let’s
    take a look at the final category of functions that play a crucial role in functional
    programming languages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间输出随后被组合成一个单一的切片。接下来，让我们看看在函数式编程语言中起着关键作用的函数的最后一类。
- en: Data reducing functions
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据减少函数
- en: The final group we are going to take a look at is *reducer* functions. These
    are functions that apply an operation to a container of elements and derive a
    single value from them. Combined with the functions we have seen earlier in this
    chapter, we can compose the majority of our applications. At least, as far as
    data manipulation goes. There are a few different names for functions such as
    this in functional programming. In Haskell, you’ll find functions named `Fold`
    or `Fold` + a suffix, such as `Foldr`, while in some languages they are called
    `Reduce`. We will use the `Reduce` terminology for the remainder of this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一组函数是 *reducer* 函数。这些函数将操作应用于元素容器，并从中导出一个单一值。结合本章前面看到的函数，我们可以组合我们的大多数应用程序。至少，就数据操作而言。在函数式编程中，这类函数有几个不同的名称。在
    Haskell 中，你会找到名为 `Fold` 或 `Fold` 加后缀的函数，例如 `Foldr`，而在某些语言中它们被称为 `Reduce`。本书余下部分我们将使用
    `Reduce` 术语。
- en: The first function we will look at is simply `Reduce`. This higher-order function
    abstracts operations to two data elements of the list. It then repeats this operation,
    accumulating the result, until a single answer is retrieved. Just as with the
    `Filter` and `Map` functions, these functions are pure, so the actual input data
    is never changed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个函数就是简单的 `Reduce`。这个高阶函数将操作抽象为列表中的两个数据元素。然后它重复这个操作，累加结果，直到得到一个单一答案。就像
    `Filter` 和 `Map` 函数一样，这些函数是纯函数，所以实际输入数据永远不会改变。
- en: 'The abstracted function in this algorithm is a function that takes two values
    of an identical data type and returns a single value of that data. The result
    is achieved by performing some operation on them that the caller of the function
    can provide:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法中的抽象函数是一个接受相同数据类型两个值的函数，并返回该数据类型的一个单一值。结果是通过对它们执行一些操作来实现的，这些操作是由函数的调用者提供的：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function will ultimately be called iteratively for each element in the
    slice, storing the intermediate results and feeding those back into the function:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数最终将迭代地调用切片中的每个元素，存储中间结果，并将这些结果反馈回函数：
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This sounds like recursion but it is not recursive in the implementation in
    this chapter. We will look at a recursive approach in the next chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是递归，但在这个章节的实现中它不是递归的。我们将在下一章查看递归方法。
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we are also handling our edge cases. If we get an empty slice,
    we return the `default-nil` value of whatever type was passed to our function.
    If there is only one item in the slice, no operation can be performed, and, instead,
    we just return that value (by not executing the loop and thus instantly returning
    the result based on `input[0]`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们也在处理我们的边缘情况。如果我们得到一个空切片，我们返回传递给我们的函数的类型的`default-nil`值。如果切片中只有一个项目，则无法执行任何操作，我们只需返回该值（通过不执行循环，因此基于`input[0]`立即返回结果）。
- en: 'These higher-order function abstracts are how you can combine two elements
    into a single answer. One possible reducer would be `sum reducer`, which adds
    two numbers and returns the result. The following anonymous function is an example
    of this function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高阶函数抽象是如何将两个元素组合成一个答案的。一个可能的归约器是`sum reducer`，它将两个数字相加并返回结果。以下匿名函数是这个函数的一个示例：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is an anonymous function that we would pass to `Reduce` to perform a summation
    of all elements – but there’s one problem with this approach as it is written
    now. The `Reduce` function is generic and can take `+` operator is not defined
    for every data type. To work around this, we can create a `Sum` function that
    calls the reducer internally but tightens the type signature to only allow numbers
    to be provided as input.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匿名函数，我们将将其传递给`Reduce`以执行所有元素的求和——但就目前的写法而言，这种方法有一个问题。`Reduce`函数是泛型的，可以接受`+`运算符，但并非为每个数据类型定义。为了解决这个问题，我们可以创建一个`Sum`函数，它内部调用归约器，但将类型签名收紧，只允许提供数字作为输入。
- en: 'Remember that as there are multiple number data types in Go, we want to be
    able to use the `Sum` function for all of these. This can be achieved by creating
    a custom type constraint for our generic functions. We’ll also consider a `type`
    alias of `Number` as valid – this can be achieved by adding the `~` prefix to
    each type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于Go中有多种数字数据类型，我们希望能够为所有这些使用`Sum`函数。这可以通过为我们的泛型函数创建一个自定义类型约束来实现。我们还将考虑将`Number`的类型别名视为有效——这可以通过在每个类型前添加`~`前缀来实现：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we can use this type as a type constraint in a generic function such
    as the `Sum` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将此类型用作泛型函数（如`Sum`函数）的类型约束：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There we go – now, we can use this function to return a summation of a slice
    of numbers, whereby a number is any currently supported number-like data type
    in Go that we have defined in our constraint:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——现在，我们可以使用这个函数来返回数字切片的求和，其中数字是Go中我们定义在约束中的任何当前支持的类似数字的数据类型：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of this function is `10`. Effectively, our reducer has performed
    a sum of `1 + 2 + 3 + 4`. With the reducer in place, we can therefore abstract
    these operations to lists. Adding a similar function to perform the multiplication
    of each element is equally easy to write as the summation function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的输出是`10`。实际上，我们的归约器执行了`1 + 2 + 3 + 4`的求和。有了归约器，我们因此可以将这些操作抽象为列表。添加一个执行每个元素乘法的类似函数与编写求和函数一样容易：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This implementation works the same way as the `Sum` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的工作方式与`Sum`函数相同。
- en: 'In Haskell and other functional languages, there are a few different reducer
    implementations provided out of the box, each changing the core algorithm slightly.
    You will find the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell和其他函数式语言中，提供了一些不同的归约器实现，每个实现都略微改变了核心算法。你将找到以下内容：
- en: Reducers that iterate from the start to the end of a list
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表的开始到结束迭代的归约器
- en: Reducers that iterate from the end to the start of a list
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表的末尾到开始迭代的归约器
- en: Reducers that start with a default value instead of the first element of a list
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表的第一个元素而不是默认值开始的归约器
- en: Reducers that start with a default value and then iterate from the end to the
    start of the list
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从具有默认值开始并从列表的末尾到开始迭代的归约器
- en: 'The reverse reducers (iterating from the end to the start of a list) are left
    as an exercise for the reader to explore independently, but the full code for
    them can be found on GitHub: [https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/pkg/reducers.go](https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/pkg/reducers.go).
    However, we will take a look at the reducers that have a starting value.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 反向归约器（从列表的末尾迭代到开始）留作读者独立探索的练习，但它们的完整代码可以在GitHub上找到：[https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/pkg/reducers.go](https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/pkg/reducers.go)。然而，我们将探讨具有起始值的归约器。
- en: 'Providing a different starting value would allow us to write a function such
    as `multiple all numbers together, and then finally multiply by two`. We could
    achieve this with some minor modifications to our `Reducer` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 提供不同的起始值将允许我们编写一个函数，例如“将所有数字相乘，然后最终乘以二”。我们可以通过修改我们的`Reducer`函数来实现这一点：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We’re handling similar edge cases as with the original `Reduce` function, but
    one key difference is that we always have a default value to return. We can either
    return it when the slice is empty or return the combination of the starting value
    with the first element in the slice when the slice contains exactly one element.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理与原始`Reduce`函数类似的边缘情况，但一个关键的区别是我们始终有一个默认值返回。我们可以在切片为空时返回它，或者在切片恰好包含一个元素时返回起始值与切片中第一个元素的组合。
- en: 'In the next example code, we are going to concatenate strings with a comma
    in between each word, but to show off our new `ReduceWithStart` function, we will
    provide a starting value of `first`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例代码中，我们将使用逗号将字符串连接起来，但为了展示我们新的`ReduceWithStart`函数，我们将提供一个起始值`first`：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we run this code, we will get the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将得到以下输出：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With these functions in place, let’s take a look at an example in which we combine
    the use of all three categories of functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些函数到位后，让我们看看一个示例，其中我们将结合使用所有三类函数。
- en: Example – working with airport data
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – 处理机场数据
- en: In this example, we are going to tie together the functions from this chapter
    to analyze airport data. We need to do some work before we can play around with
    the functions that we have created. First, we need to get the data. On GitHub,
    you can find a `.json` extract under [https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/resources/airlines.json](https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/resources/airlines.json).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将结合本章中的函数来分析机场数据。在我们能够使用我们创建的函数之前，我们需要做一些工作。在GitHub上，你可以在[https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/resources/airlines.json](https://github.com/PacktPublishing/Functional-Programming-in-Go./blob/main/Chapter6/resources/airlines.json)找到`.json`提取文件。
- en: 'The following snippet is the template for the dataset:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是数据集的模板：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To work with this data, we will recreate the `.json` structure as structs in
    Go. We can use the built-in `.json` tags and deserializers to read this data in
    memory. Our Go struct to work with this data looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这些数据，我们将重新创建`.json`结构作为Go中的结构体。我们可以使用内置的`.json`标签和反序列化器来在内存中读取这些数据。我们用于处理这些数据的Go结构体如下所示：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is a bit verbose, but it’s just a copy of what we could find in the first
    entry of the file. After this, we need to write some code to read this file into
    memory as entries:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文字稍微有些冗长，但它只是文件第一项内容的复制。在此之后，我们需要编写一些代码来将文件内容作为条目读入内存：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As in previous chapters, we are using `panic` in this code. It is discouraged,
    but for demonstration purposes, this is fine. This code will read our resource
    file, parse it as `json` based on the struct we have created, and return it as
    a slice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，我们在代码中使用`panic`。这是不被鼓励的，但出于演示目的，这是可以的。此代码将读取我们的资源文件，根据我们创建的结构体将其解析为`json`，并作为切片返回。
- en: 'Now, to demo the functions that we have created, this is what our problem statement
    looks like: **write a function that returns the total hours of delays for the
    Seattle airport (airport** **code: SEA)**.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了演示我们创建的函数，这是我们的问题陈述：**编写一个返回西雅图机场（机场** **代码：SEA**）总延误小时的函数。
- en: 'Based on this problem statement, we can see that there are three actions to
    take:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个问题陈述，我们可以看到有三个动作需要执行：
- en: Filter the data by the airport code SEA.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过机场代码SEA过滤数据。
- en: Transform the `MinutesDelayed` field into hours.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MinutesDelayed`字段转换为小时。
- en: Sum all the hours.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 汇总所有小时数。
- en: 'The order of *steps 2 and 3* could be reversed, but this way, it follows the
    structure in which we have introduced those functions in this chapter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2和步骤3的顺序可以颠倒，但这样，它遵循我们在本章中介绍这些函数的结构：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And there we go. We have implemented our use case using three of the functions
    that we have seen in this chapter. As you can tell, whenever we call a function,
    we store the result in a new slice. The original data is therefore never lost,
    and we could still use it for other parts of our function should we choose to
    do so.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就这样开始了。我们使用本章中看到的三种函数实现了我们的用例。正如你所见，每次我们调用一个函数时，我们都会将结果存储在一个新的切片中。因此，原始数据永远不会丢失，如果我们选择这样做，我们仍然可以使用它来处理函数的其他部分。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw three categories of functions that will help us functionally
    build our programs. First, we saw predicate-based functions, which can either
    filter our data into a subset meeting a requirement or tell us whether or not
    the data in our dataset entirely or partially matches a condition. Next, we saw
    how data can be changed functionally, ways of transforming data whereby our data
    type is guaranteed to remain the same, and functions in which we are also changing
    the type itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了三种类型的函数，这些函数将帮助我们以函数式的方式构建程序。首先，我们看到了基于谓词的函数，这些函数可以将我们的数据过滤成满足特定要求的子集，或者告诉我们数据集是否完全或部分符合某个条件。接下来，我们看到了数据如何以函数式的方式改变，以及数据类型保证保持不变的数据转换方式，以及那些也在改变类型本身的函数。
- en: Finally, we looked at reducer functions, which take a list of elements and reduce
    them into a single value. We have demonstrated how these three types of functions
    can be combined in the airport data example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了reducer函数，这些函数将一系列元素减少到一个单一值。我们在机场数据示例中展示了这三种类型函数的组合方式。
- en: In the next chapter, we will dive into recursion and see how this plays a role
    in functional programming, as well as what the performance implications are for
    writing recursive functions in Go.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨递归，看看它在函数式编程中的作用，以及编写递归函数在Go中的性能影响。
