- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Functional Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: In this chapter, we will move to a higher level of abstraction. Rather than
    talking about individual functions and operations, let’s take a look at some design
    patterns. While we will not extensively explain each design pattern, we will take
    a look at how the object-oriented pattern translates to the functional world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章中，我们将提升到一个更高的抽象层次。而不是讨论单个函数和操作，让我们来看看一些设计模式。虽然我们不会详细解释每个设计模式，但我们会看看面向对象模式如何转化为函数式世界。 '
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: 'Classical design patterns in a functional paradigm:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数范式中的经典设计模式：
- en: The strategy pattern
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: The decorator pattern
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The Hollywood principle
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好莱坞原则
- en: Functional design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, any version at or above Go 1.18 will work for all Go-related
    code. Some snippets are written in Java; those will work with any version of Java
    above 1.5.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，任何1.18版或更高版本的Go都将适用于所有Go相关代码。一些代码片段是用Java编写的；这些代码片段将适用于1.5版以上的任何Java版本。
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到：[https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9](https://github.com/PacktPublishing/Functional-Programming-in-Go./tree/main/Chapter9)。
- en: Classical design patterns in a functional paradigm
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数范式中的经典设计模式
- en: Anyone who has programmed in an object-oriented language will encounter design
    patterns at some point. Design patterns are a type of cookie-cutter solution to
    common engineering problems. One key point is that the solution they provide should
    be thought of as a starting point, a way to tackle a problem that has proven itself
    to be useful. Often, the solution is not readily usable out of the box and needs
    to be adapted to your concrete environment and situation. A given design pattern
    might provide 90% of a solution to a problem, and the remaining 10% is filled
    in with custom, non-pattern code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在面向对象语言中编程的人都会在某个时刻遇到设计模式。设计模式是一种针对常见工程问题的通用解决方案。一个关键点是，他们提供的解决方案应被视为一个起点，一种解决问题的方法，这种方法已被证明是有用的。通常，解决方案不能直接使用，需要根据你的具体环境和情况进行调整。一个给定的设计模式可能为问题提供90%的解决方案，其余的10%则需要用自定义的非模式代码来填补。
- en: 'This chapter does not aim to exhaustively cover design patterns. In fact, entire
    books have been written about design patterns, such as the well-known *Gang of
    Four* book, *Design Patterns: Elements of Reusable Object-Oriented Software*.
    What this chapter does aim to do is to showcase how certain object-oriented design
    patterns translate to the functional paradigm, and how they are often simpler
    to express in this paradigm. For each design pattern, we will take a look at the
    object-oriented implementation, the general problem and benefit of the pattern,
    and finally, what the functional implementation looks like. We’ll start off with
    the strategy pattern and continue with the decorator pattern and the **Inversion
    of Control** (**IoC**) principle.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是全面覆盖设计模式。实际上，关于设计模式已经写出了整本书，例如著名的《设计模式：可复用面向对象软件元素》（Gang of Four）一书。本章的目标是展示某些面向对象设计模式如何转化为函数范式，以及它们在这个范式下通常如何更简单地进行表达。对于每个设计模式，我们将查看面向对象实现、模式的一般问题和好处，以及最终，函数实现的样子。我们将从策略模式开始，然后继续装饰模式，最后是**控制反转**（**IoC**）原则。
- en: These are three patterns that are common to object-oriented code. The strategy
    pattern is a way to change the behavior of our program at runtime and decouple
    a class with a concrete implementation. The decorator pattern allows us to dynamically
    extend functions without breaking the open-closed principle, and the IoC principle
    is a staple of many object-oriented frameworks, whereby the order of control is
    delegated to the highest level in the call tree.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种模式在面向对象代码中很常见。策略模式是一种在运行时改变程序行为并解耦具有具体实现类的方法。装饰者模式允许我们动态地扩展函数而不破坏开闭原则，而IoC原则是许多面向对象框架的基石，其中控制顺序被委派给调用树的最高层。
- en: The strategy pattern
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The first pattern that we will take a look at is the strategy pattern. The strategy
    pattern is a design pattern that allows us to dynamically change the algorithm
    of a method or function at runtime. By doing this, we can modify the behavior
    of our program throughout its runtime. In the example that we will work out, we
    will have an `EncryptionService`, which supports various ciphers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个模式是策略模式。策略模式是一种设计模式，它允许我们在运行时动态地更改方法或函数的算法。通过这样做，我们可以修改程序在整个运行期间的行为。在我们将要解决的例子中，我们将有一个
    `EncryptionService`，它支持各种密码。
- en: 'We’ll keep it simple and work with substitution ciphers that change the letters
    in the output. We will implement three different cipher mechanisms:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持简单，并使用改变输出中字母的替换密码。我们将实现三种不同的密码机制：
- en: The Caesar cipher
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凯撒密码
- en: The Atbash cipher
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atbash 密码
- en: A custom cipher
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义密码
- en: 'Each cipher needs to support the encryption and decryption of a given string
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个密码都需要支持给定字符串的加密和解密，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In other words, we should be able to reconstruct the input from a ciphered output.
    For our implementations, we will also limit ourselves to changing the letters
    of the alphabet a-z, and ignore casing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们应该能够从加密输出中重建输入。对于我们的实现，我们还将限制自己只改变字母表中的字母 a-z，并忽略大小写。
- en: Ciphers and security
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 密码和安全
- en: It bears calling out that these ciphers should never be used for actual encryption.
    They are incredibly weak and offer no real protection against a malicious actor
    in this day and age. They are interesting to study for their historical context
    and are fun to implement while being easy to understand.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些密码绝对不应该用于实际的加密。它们非常脆弱，在当今这个时代无法提供真正的保护来抵御恶意行为者。它们对于研究历史背景很有趣，实现起来既有趣又容易理解。
- en: Object-oriented strategy pattern
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象策略模式
- en: 'First, we will solve this problem in an object-oriented way. Remember that
    Go is a multi-paradigm language, so we can easily apply object-oriented design
    patterns in Go. *Figure 9**.1* shows the architecture for this solution:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将以面向对象的方式解决这个问题。记住，Go 是一种多范式语言，因此我们可以在 Go 中轻松应用面向对象的设计模式。*图9**.1 显示了这个解决方案的架构：
- en: '![Figure 9.1: Strategy pattern for cipher implementation](img/Figure_9.1_B18771.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：密码实现的策略模式](img/Figure_9.1_B18771.jpg)'
- en: 'Figure 9.1: Strategy pattern for cipher implementation'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：密码实现的策略模式
- en: 'In the object-oriented implementation, we start with a `CipherService`. This
    is any class that wants to use a cipher. Rather than having a concrete implementation,
    `CipherService` instead contains a `CipherStrategy` through object composition.
    This `CipherStrategy` is an interface that specifies the `Cipher` and `Decipher`
    methods. Both methods take a string as input and return either a ciphered or deciphered
    string. In *Figure 9**.1*, we have three concrete implementations for the cipher:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的实现中，我们从 `CipherService` 开始。这是任何想要使用密码的类。而不是有一个具体的实现，`CipherService` 通过对象组合包含一个
    `CipherStrategy`。这个 `CipherStrategy` 是一个接口，它指定了 `Cipher` 和 `Decipher` 方法。这两个方法都接受一个字符串作为输入，并返回加密或解密后的字符串。在
    *图9**.1 中，我们有三种具体的密码实现：
- en: Caesar
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凯撒
- en: Atbash
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atbash
- en: A custom cipher
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义密码
- en: Each of these is a class (struct) that implements the required methods (`Cipher`
    and `Decipher`). We can also include a useful state in these classes, as we will
    see in the upcoming code examples, whereby we maintain a `Rotation` variable as
    part of the Caesar cipher. Both the Caesar cipher and the Atbash cipher are so-called
    substitution ciphers. They exchange one letter of the alphabet with another letter.
    In the case of the Caesar cipher, the replacement letter is situated a certain
    amount of positions further in the alphabet. For the Atbash cipher, this is a
    simple substitution of each letter with the letter of the same position in the
    reverse alphabet (z-a).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是实现所需方法（`Cipher` 和 `Decipher`）的类（结构体）。我们还可以在这些类中包含一个有用的状态，正如我们将在接下来的代码示例中所看到的，其中我们将
    `Rotation` 变量作为凯撒密码的一部分来维护。凯撒密码和Atbash密码都是所谓的替换密码。它们用一个字母替换另一个字母。在凯撒密码的情况下，替换字母位于字母表中一定数量的位置之后。对于Atbash密码，这是将每个字母简单地替换为反向字母表中相同位置的字母（z-a）。
- en: Caesar
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 凯撒
- en: 'Let’s start implementing this in Go. First, we’ll set up the `CipherService`,
    as well as a slice containing all letters of the alphabet that we’ll support.
    We will also need to figure out the index of a given rune in this slice of letters,
    which we will do by implementing an `indexOf` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Go中开始实现这个。首先，我们将设置`CipherService`，以及一个包含我们将支持的所有字母表的切片。我们还需要确定给定rune在这个字母表切片中的索引，我们将通过实现一个`indexOf`函数来完成：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To follow a more traditional object-oriented language pattern, we can attach
    a `Cipher` and `Decipher` method to `CipherService` as well. This will just delegate
    the call to the chosen implementation (`Strategy`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循更传统的面向对象语言模式，我们还可以将`Cipher`和`Decipher`方法附加到`CipherService`上。这只会将调用委托给选择的实现（`Strategy`）：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After this is set up, we will also define an interface, `CipherStrategy`, which
    will enforce any implementation to have the `Cipher` and `Decipher` methods:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好之后，我们还将定义一个接口，`CipherStrategy`，它将强制任何实现都必须有`Cipher`和`Decipher`方法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With this in place, we can start implementing the strategies that we will support.
    For brevity, we will only implement the Caesar and Atbash cipher. Implementing
    a custom cipher, as in *Figure 9**.1*, would be a trivial extension of this. To
    implement the Caesar cipher, we will first define a struct to represent this strategy:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以开始实现我们将支持的战略。为了简洁，我们只会实现凯撒和Atbash密码。实现自定义密码，如*图9**.1*所示，将是这个的简单扩展。为了实现凯撒密码，我们首先定义一个结构体来表示这个策略：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Caesar cipher is a cipher whereby a letter in the input is exchanged for
    a letter a certain number of positions further in the alphabet. The number of
    positions that we use is defined as the *rotation* of the cipher. For example,
    if we have the `abc` input and a rotation of `1`, each letter is replaced with
    the letter 1 position further in the alphabet, so the output would be `bcd`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是一种密码，其中输入中的字母被替换为字母表中一定位置的字母。我们使用的位置数定义为密码的*旋转*。例如，如果我们有`abc`输入和一个旋转`1`，每个字母都被替换为字母表中位置更进一步的字母，所以输出将是`bcd`。
- en: 'Similarly, if the rotation were `2`, the output would be `cde`, and so on.
    The following is an implementation of the Caesar `Cipher` and `Decipher` methods
    in Go. Understanding the implementation is not that important; the important part
    is to note how we select which implementation `CipherService` uses and even change
    it during the execution of our program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果旋转是`2`，输出将是`cde`，依此类推。以下是在Go中实现凯撒`Cipher`和`Decipher`方法的实现。理解实现并不那么重要；重要的是要注意我们如何选择`CipherService`使用的实现，甚至在程序执行期间更改它：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have the Caesar cipher implemented, let’s also implement the Atbash
    cipher.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了凯撒密码，让我们也实现Atbash密码。
- en: Atbash
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Atbash
- en: The Atbash cipher is a straightforward replacement of each letter with the letter
    at the same index but with the alphabet in reverse. So, `a` becomes `z`, `b` becomes
    `y`, and on until `z` becomes `a`. As a result, deciphering can be achieved by
    calling the cipher again, as we are effectively mirroring the alphabet (and mirroring
    twice returns the original result).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Atbash密码是直接将每个字母替换为字母表中相同索引位置的字母，但字母表是反向的。所以，`a`变成`z`，`b`变成`y`，以此类推，直到`z`变成`a`。因此，解密可以通过再次调用密码来实现，因为我们实际上是在镜像字母表（镜像两次会返回原始结果）。
- en: 'We don’t need any real state to manage with the `AtbashCipher` struct, unlike
    `CaesarCipher`, where we maintained the rotation as a class variable. However,
    we will still need to create the struct for our strategy pattern implementation
    to work correctly. It will just be an empty struct with functions attached to
    it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CaesarCipher`不同，我们不需要任何真实的状态来管理`AtbashCipher`结构体，因为`CaesarCipher`中我们维护旋转作为一个类变量。然而，我们仍然需要创建这个结构体，以便我们的策略模式实现能够正确工作。它将只是一个空的结构体，带有附加到它的函数：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, the actual implementation of the code here is not that important. It
    is neat that we can decipher it by just calling `Cipher` again, and this will
    become even more interesting in the functional example. Either way, let’s look
    at how we can change the implementation during execution and switch between `CaesarCipher`
    and `AtbashCipher`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里的代码实现并不那么重要。很整洁的是，我们可以通过再次调用`Cipher`来解密它，这在函数式示例中会变得更加有趣。无论如何，让我们看看我们如何在执行期间更改实现，并在`CaesarCipher`和`AtbashCipher`之间切换：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the object-oriented implementation of the strategy pattern. We have
    created three classes (`CipherService`, `CaesarCipher`, and `AtbashCipher`) one
    interface (`CipherStrategy`), and two functions per struct (to cipher and decipher).
    Now, let’s take a look at a functional implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是策略模式的面向对象实现。我们创建了三个类（`CipherService`、`CaesarCipher`和`AtbashCipher`），一个接口（`CipherStrategy`），以及每个struct两个函数（用于加密和解密）。现在，让我们看看函数式实现。
- en: Functional implementation of the strategy pattern
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略模式的函数式实现
- en: We have already seen in previous chapters how we can dynamically change the
    implementation details of an algorithm by leveraging the fact that functions are
    first-class citizens, and we can pass them around like objects in a traditional
    object-oriented language. If we refactored our `CipherService`, all we would need
    to know is that this service needs a function to take a string and return a string
    twice (one for ciphering and one for deciphering).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中看到，我们可以通过利用函数是一等公民的事实，像在传统的面向对象语言中一样传递它们，动态地改变算法的实现细节。如果我们重构了我们的`CipherService`，我们只需要知道这个服务需要一个函数，该函数接受一个字符串并返回一个字符串两次（一次用于加密，一次用于解密）。
- en: 'To start off, let’s define the struct for this new service, as well as two
    types to define the `Cipher` and `Decipher` functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义这个新服务的结构，以及两个类型来定义`Cipher`和`Decipher`函数：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have `CipherService` in place, we need to define our Caesar and
    Atbash cipher-related functions. Unlike in the object-oriented example, we don’t
    need to define a new struct to do so. We can define our functions in the same
    package as our `CipherService` but we would not have to do so. In fact, any function
    of the correct type can be used as a `Cipher` or `Decipher` function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`CipherService`，我们需要定义我们的Caesar和Atbash加密相关的函数。与面向对象的例子不同，我们不需要定义一个新的struct来这样做。我们可以在与我们的`CipherService`相同的包中定义我们的函数，但我们不必这样做。事实上，任何正确类型的函数都可以用作`Cipher`或`Decipher`函数。
- en: 'Let’s implement `CaesarCipher` first. The one thing we do have to be aware
    of is that we do not have a struct that can hold the state anymore. In our example,
    the `CaesarCipher` struct stored `Rotation` as a class variable. In the functional
    approach, the rotation needs to be part of the `CaesarCipher` function itself.
    It’s a minor but important change. Apart from this change, the implementation
    remains the same:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现`CaesarCipher`。我们必须注意的一件事是我们不再有一个可以保存状态的struct。在我们的例子中，`CaesarCipher`
    struct将`Rotation`存储为一个类变量。在函数式方法中，旋转需要成为`CaesarCipher`函数本身的一部分。这是一个微小但重要的变化。除了这个变化之外，实现保持不变：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Similarly, we can implement `AtbashCipher` as a function. One nice thing here
    is that due to the relationship between ciphering and deciphering with Atbash,
    we don’t have to actually write any implementation for the `Decipher` function.
    Rather, we can just equate the `Decipher` function to the `Cipher` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将`AtbashCipher`实现为一个函数。这里的一个优点是由于Atbash加密和解密之间的关系，我们实际上不需要为`Decipher`函数编写任何实现。相反，我们可以直接将`Decipher`函数等同于`Cipher`函数：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last line effectively defines a new function, `AtbashDecipher`, with the
    same implementation as `AtbashCipher`, once again leveraging the fact that our
    functions are simply data, which can be stored as variables in Go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行实际上定义了一个新的函数，`AtbashDecipher`，其实现与`AtbashCipher`相同，再次利用了这样一个事实，即我们的函数仅仅是数据，可以在Go中以变量的形式存储。
- en: 'When using this functional implementation in Go, we have to provide a function
    of the `func(string) string` type to both the `Cipher` and `Decipher` implementation
    of our service. As a result of `CaesarCipher` requiring an extra variable to determine
    the rotation, we do need to create a closure for our `CipherService`. In our `main`
    method, we can dynamically update the cipher that we want to use to `AtbashCipher`
    without the need for a closure, as the Atbash cipher is a straightforward cipher
    that adheres to `func(string) string`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Go中使用这种函数式实现时，我们必须为我们的服务的`Cipher`和`Decipher`实现提供`func(string) string`类型的函数。由于`CaesarCipher`需要一个额外的变量来确定旋转，我们确实需要为我们的`CipherService`创建一个闭包。在我们的`main`方法中，我们可以动态地更新我们想要使用的加密方式为`AtbashCipher`，而不需要闭包，因为Atbash加密是一种简单的加密方式，遵循`func(string)
    string`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example prints some ciphered and deciphered content using our functional
    implementation. Using this functional implementation, we could easily implement
    ad hoc ciphers without defining them as standalone functions. Both the `Cipher`
    and `Decipher` implementation accept anonymous functions to specify the implementation
    details. This is what we have done to make the Caesar cipher work by wrapping
    it in such an anonymous function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何使用我们的函数式实现来打印一些加密和解密的内容。使用这个函数式实现，我们可以轻松地实现特定的加密算法，而不必将它们定义为独立的函数。`Cipher`和`Decipher`的实现都接受匿名函数来指定实现细节。这就是我们通过将凯撒密码包裹在匿名函数中来使其工作的方式。
- en: The decorator pattern
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: Let’s modify our code to also adhere to the decorator pattern. The decorator
    pattern is a way to add functionality to our methods and classes without having
    to modify them. This means that the *open-closed* part of SOLID is respected.
    When programming in an object-oriented fashion, this is done through function
    composition (and often with inheritance in languages that support this). In Go,
    composition is the favored way of composing structs, so the decorator pattern
    feels natural for both a functional and object-oriented style implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的代码，使其也遵循装饰器模式。装饰器模式是一种在不修改它们的情况下向我们的方法和类添加功能的方式。这意味着SOLID中的*开闭*部分得到了尊重。在面向对象编程中，这是通过函数组合（以及在支持这种功能的语言中通常与继承一起）来实现的。在Go语言中，组合是构建结构体的首选方式，因此装饰器模式对于函数式和面向对象风格的实现来说都很自然。
- en: SOLID principles for object-oriented design
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计的SOLID原则
- en: SOLID is a set of principles for designing robust object-oriented systems. It
    stands for **Single-Responsibility, Open-Closed, Liskov Substitution, Interface
    Segregation, and Dependency Inversion**. These principles are good to adhere to
    regardless of which paradigm you use, but their implementation differs. For example,
    functions should have a single responsibility, be closed to modification but open
    to extension, and functions should rely on abstract (higher-order) functions rather
    than concrete implementations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一组设计健壮面向对象系统的原则。它代表**单一职责、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则**。无论你使用哪种范式，这些原则都是值得遵循的，但它们的实现方式不同。例如，函数应该只有一个职责，对修改封闭但对扩展开放，并且函数应该依赖于抽象（高阶）函数而不是具体实现。
- en: Object-oriented decorator pattern
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象的装饰器模式
- en: First, let’s start off by implementing the decorator pattern in an object-oriented
    way. We’ll extend our strategy pattern example of the various ciphers. To keep
    things simple, let’s just say we want to log the input to each `Cipher` and `Decipher`
    function. To make our program more composable, we don’t want to add the `log`
    function by modifying the existing `CaesarCipher` and `AtbashCipher` structs.
    If we were to do so, we would also have to update the `log` functionality for
    each struct in case the logging requirements change. Instead, what we will do
    is implement a `LogCipherDecorator` struct. This struct adheres to the `CipherStrategy`
    interface by implementing a function for both `Cipher` and `Decipher`. These functions
    will first write to a log and then delegate each call to the underlying `Cipher`
    or `Decipher` implementation. *Figure 9**.2* shows the class diagram for this
    pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从以面向对象的方式实现装饰器模式开始。我们将扩展我们的策略模式示例，包括各种加密算法。为了保持简单，让我们假设我们只想为每个`Cipher`和`Decipher`函数记录输入。为了使我们的程序更易于组合，我们不希望通过修改现有的`CaesarCipher`和`AtbashCipher`结构体来添加`log`函数。如果我们这样做，我们还需要更新每个结构体的`log`功能，以防日志要求发生变化。相反，我们将实现一个`LogCipherDecorator`结构体。这个结构体通过实现`Cipher`和`Decipher`的函数来遵循`CipherStrategy`接口。这些函数将首先写入日志，然后将每个调用委托给底层的`Cipher`或`Decipher`实现。"图*9**.2"显示了该模式的类图。
- en: '![Figure 9.2: Class diagram for the decorator pattern](img/Figure_9.2_B18771.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：装饰器模式的类图](img/Figure_9.2_B18771.jpg)'
- en: 'Figure 9.2: Class diagram for the decorator pattern'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：装饰器模式的类图
- en: 'Now, we can turn this into code; let’s look at the struct definition first.
    We have a new `LogCipherDecorator` struct, which uses `CipherStrategy` through
    composition:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其转换为代码；让我们首先看看结构定义。我们有一个新的`LogCipherDecorator`结构体，它通过组合使用`CipherStrategy`：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will also implement the necessary functions to have this new struct
    adhere to `CipherStrategy` itself. In each function, first, we will log the input
    prior to dispatching the call to the underlying `CipherStrategy`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现必要的函数，使这个新的结构本身遵守`CipherStrategy`。在每个函数中，首先，我们将记录输入，然后再将调用分派到底层的`CipherStrategy`：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is essentially all that is required to implement the decorator pattern.
    It comes in handy in a variety of scenarios, but it’s encountered especially often
    when working with **User Interface** (**UI**) code (Java UI libraries such as
    Swing tend to use this extensively).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是实现装饰器模式所需的所有内容。它在各种场景中都很有用，但在与**用户界面**（**UI**）代码（例如Swing这样的Java UI库）一起工作时，尤其经常遇到。
- en: 'In the `main` function, we can now use `CipherLogDecorator` anywhere that we
    expect `CipherStrategy`. We’ll have to instantiate the decorator with the underlying
    class to get the additional functionality:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们现在可以在期望`CipherStrategy`的任何地方使用`CipherLogDecorator`。我们将必须实例化装饰器并使用底层类来获取额外的功能：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this snippet, we can see how `CipherService` accepts `CipherLogDecorator`
    just like any other `CipherService`. When we run this `main` function, the log
    statement appears before each print statement. Running that function, we get the
    following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们可以看到`CipherService`如何接受`CipherLogDecorator`，就像接受任何其他`CipherService`一样。当我们运行这个`main`函数时，日志语句出现在每个打印语句之前。运行该函数，我们得到以下结果：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, let’s functionally implement this and compare the two approaches.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以函数式的方式实现这一点，并比较两种方法。
- en: Functional decorator pattern implementation
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式装饰器模式实现
- en: Applying the decorator pattern to functional programming does not require anything
    that we haven’t seen before in this book. We have learned about function composition
    and used that in previous chapters. The decorator pattern for object-oriented
    code really is nothing more than function composition in the functional programming
    paradigm.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将装饰器模式应用于函数式编程并不需要我们在本书中之前没有见过的任何东西。我们已经学习了函数组合，并在前面的章节中使用了它。面向对象的代码中的装饰器模式实际上不过是函数式编程范式中的函数组合。
- en: 'As such, creating a function for adding a log statement prior to each `cipher`
    or `decipher` call is a matter of creating a higher-order function that takes
    either a `Cipher` or `Decipher` function as input, and returns a new function,
    which first calls `log` and then delegates the remainder of the functionality
    to the underlying function. Let’s make this concrete by looking at the decorating
    functions for ciphering and deciphering, `LogCipher` and `LogDecipher`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，创建一个在每次`cipher`或`decipher`调用之前添加日志语句的函数，就是一个创建高阶函数的问题，该函数接受一个`Cipher`或`Decipher`函数作为输入，并返回一个新的函数，该函数首先调用`log`，然后委托剩余的功能到底层函数。让我们通过查看加密和解密时的装饰函数`LogCipher`和`LogDecipher`来具体说明：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In essence, that’s all that needs to happen to decorate functions with new functionality.
    `LogCipher` accepts any function that adheres to the `CipherFunc` type definition
    and returns a new function that also adheres to that type definition. The new
    function, created as an anonymous function returned from `LogCipher`, then calls
    `log` and subsequently our `CipherFunc` that was passed initially.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这就是装饰函数以添加新功能所需发生的所有事情。`LogCipher`接受任何遵守`CipherFunc`类型定义的函数，并返回一个新的函数，该函数也遵守那个类型定义。然后，作为从`LogCipher`返回的匿名函数创建的新函数，调用`log`并随后调用最初传递的`CipherFunc`。
- en: The main difference in the implementation strategy with the object-oriented
    and functional paradigms is just how we define adherence to the expected functionality.
    With an object-oriented approach, we use interfaces to define adherence, while
    with the functional approach, we use the type system to define adherence.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象和函数式范式相比，实现策略中的主要区别只是我们如何定义对预期功能的遵守。在面向对象的方法中，我们使用接口来定义遵守，而在函数式方法中，我们使用类型系统来定义遵守。
- en: 'In our `main` function, we can create `CipherService` using the decorator functions
    rather than the underlying ciphers:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数中，我们可以使用装饰函数而不是底层加密来创建`CipherService`：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice that in this example, for readability, the decorator functions are split
    from the creation of `CipherService`, but this could have been done in line, as
    in the earlier strategy pattern implementation. If we created `CipherService`
    with `AtbashCipher` instead, it makes for a more readable example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，为了可读性，装饰器函数与`CipherService`的创建是分开的，但这也可能在一行内完成，就像早期策略模式实现中那样。如果我们用`AtbashCipher`来创建`CipherService`，这将是一个更易读的例子：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see from the examples, function composition is the key to decorating
    functions with additional functionality, which can then be shared across implementations.
    Another advantage of what we have done so far can be described as the *Hollywood
    principle*, also known as the *IoC* principle.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中我们可以看到，函数组合是装饰函数以添加额外功能的关键，这些功能随后可以在实现之间共享。我们迄今为止所做事情的另一个优点可以描述为“好莱坞原则”，也称为“IoC”原则。
- en: The Hollywood principle
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好莱坞原则
- en: The Hollywood principle of *don’t call us, we’ll call you* is also known as
    the IoC principle. IoC is an abstraction of the well-known Dependency Injection
    pattern. Dependency Injection is an important aspect of writing object-oriented
    applications and is useful for the functional paradigm as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好莱坞原则“别叫我们，我们会叫你”也被称为IoC原则。IoC是众所周知的依赖注入模式的抽象。依赖注入是编写面向对象应用程序的一个重要方面，并且对函数式范式也很有用。
- en: 'Without going too in-depth into the object-oriented implementation, the key
    takeaway is that objects should defer concrete implementations of their dependencies
    to the highest level in the object/call hierarchy. We have done this implicitly
    in the previous examples for our cipher implementations by leveraging interfaces
    rather than concrete implementations. Notice that the object-oriented `CipherService`
    did not specify which cipher it would use and instead, we deferred that choice
    to the creator of `CipherService` by just asking for an implementation of the
    `CipherStrategy` interface:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入面向对象的实现，关键要点是对象应该将它们依赖的具体实现推迟到对象/调用层次结构中的最高级别。我们在之前的例子中通过利用接口而不是具体实现来隐式地做到了这一点。注意，面向对象的`CipherService`没有指定它将使用哪种加密，而是通过请求`CipherStrategy`接口的实现来将这个选择推迟给了`CipherService`的创建者：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Go lends itself quite naturally to this way of programming by not having explicit
    constructors for structs. In a language such as Java, where objects can be instantiated
    with default class-level objects through object composition, it is easier to ignore
    programming against an abstract implementation. For example, the following Java
    snippet would show an implementation of a `CipherService` that does not adhere
    to IoC but uses a specific type of cipher (the Caesar cipher, in this case):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过没有为struct提供显式构造函数而非常自然地适合这种编程方式。在像Java这样的语言中，对象可以通过对象组合使用默认的类级对象进行实例化，因此更容易忽略针对抽象实现的编程。例如，以下Java代码片段将展示一个不遵循IoC但使用特定类型的加密（在这种情况下是凯撒加密）的`CipherService`实现：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Why do we highlight this Java code here? First, to show that Go’s struct paradigm
    lends itself naturally to IoC by way of struct instantiation without constructors.
    This means that structs do not have an inherent class state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这里突出显示这段Java代码？首先，为了展示Go的struct范式通过无构造函数的struct实例化自然地适合IoC。这意味着struct没有固有的类状态。
- en: 'This brings us to the functional implementations of services. In Go, we have
    two ways of making IoC happen:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们转向服务的函数式实现。在Go中，我们有两种方式来实现IoC：
- en: The first way is through the use of interfaces, as we have done in the object-oriented
    examples
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方式是通过使用接口，正如我们在面向对象示例中所做的那样
- en: The second way is to use type definitions and functions as first-class citizens
    to abstract over the behavior of a struct
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方式是使用类型定义和函数作为一等公民来抽象struct的行为
- en: To illustrate the difference, the following are the two definitions of the `CipherService`
    that we have used, and both apply IoC in alignment with their paradigm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明差异，以下是我们使用的`CipherService`的两个定义，并且两者都按照它们的范式应用IoC。
- en: 'First, let’s show the object-oriented way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们展示面向对象的方式：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And now the functional way:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看函数式的方式：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This was just a brief segue to point out what is happening in both instances.
    Let’s continue our discussion of design patterns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简短的过渡，目的是指出在这两种情况下都在发生什么。让我们继续讨论设计模式。
- en: Functional design patterns
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式设计模式
- en: In the preceding sections of this chapter, we have compared functional and object-oriented
    design patterns (strategy, decorator, and Dependency Injection/IoC). If we look
    at the main differences between the functional and object-oriented patterns, it
    becomes clear that our patterns are achieved through different combinations of
    functions. We are either using functions as first-class citizens to store them
    as variables within a struct, or we are using function composition, higher-order
    functions, anonymous functions, and closures to achieve what would traditionally
    have been achieved with interfaces and the inheritance of classes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的部分，我们比较了函数式和面向对象的设计模式（策略、装饰者和依赖注入/IoC）。如果我们看看函数式和面向对象模式之间的主要区别，那么我们的模式是通过不同的函数组合来实现的。我们要么使用函数作为一等公民，将它们存储在结构体中的变量中，要么使用函数组合、高阶函数、匿名函数和闭包来实现传统上通过接口和类的继承所实现的功能。
- en: And this really should be the main takeaway when writing functional code. Everything
    is a function. Design patterns become patterns of function combinations. As such,
    there is no real counterpart to the traditional design patterns outlined by the
    *Gang of Four* for the object-oriented world. So, what does the functional paradigm
    offer in terms of design patterns? Well, if we go back to the definition of design
    patterns, we can see that a pattern is a reusable solution to a commonly encountered
    problem. It is a cookie-cutter approach that might solve 85% of your problem,
    while the remaining 15% remains to be solved beyond the pattern. Functional programming
    does offer these solutions, and we discussed many of them earlier in this book.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上应该是编写函数式代码时的主要收获。一切都是函数。设计模式变成了函数组合的模式。因此，对于面向对象世界的传统设计模式，没有真正的对应物。那么，函数范式在设计模式方面提供了什么？好吧，如果我们回到设计模式的定义，我们可以看到，模式是针对常见问题的可重用解决方案。这是一种可能解决85%问题的模板方法，而剩余的15%则需要超出模式本身来解决。函数式编程确实提供了这些解决方案，我们在这本书的前面讨论了许多。
- en: When you think of function currying to compose different functions together
    and reducing each function to a 1-ary function to then combine them into any n-ary
    function, these steps can be thought of as a functional design pattern. Similarly,
    using closures, monads, and callbacks through CPS all can be thought of as patterns
    that are applied to solve a common problem. What we don’t have in functional programming
    is the overhead of object taxonomy, which is what the design patterns in object-oriented
    code reflect. You could argue that the need for design patterns in traditional
    object-oriented languages is more of a solution to a limitation in the programming
    language itself rather than a real benefit to the programmer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到函数柯里化，将不同的函数组合在一起，并将每个函数简化为1元函数，然后组合成任何n元函数时，这些步骤可以被视为一种函数式设计模式。同样，通过CPS使用闭包、单子以及回调都可以被视为解决常见问题的模式。在函数式编程中，我们没有对象分类法的开销，这正是面向对象代码中的设计模式所反映的。你可以争论，在传统的面向对象语言中，设计模式的需求更多的是对编程语言自身局限性的解决方案，而不是对程序员真正的益处。
- en: One of the ways traditional design patterns are avoided is through the use of
    function composition, but an equally critical component is leveraging the type
    system – a type system that can assign a concrete type to a function of a specified
    signature. Looking at object-oriented design patterns, whether the decorator pattern,
    factory pattern, or visitor pattern, they leverage interfaces extensively to abstract
    the implementation details. In Go, we can use the type system to abstract the
    implementation, as we have done in the earlier examples.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 避免传统设计模式的一种方式是通过函数组合的使用，但一个同样关键的部分是利用类型系统——一个可以将具体类型分配给具有指定签名的函数的类型系统。观察面向对象的设计模式，无论是装饰者模式、工厂模式还是访问者模式，它们都广泛利用接口来抽象实现细节。在Go语言中，我们可以使用类型系统来抽象实现，就像我们在前面的例子中所做的那样。
- en: 'If we summed up how to solve a particular design problem in the functional
    paradigm, it would be rather boring, as the problem either does not exist or is
    solved through functions. Our solution would just look like *Table 9.1*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们总结一下如何在函数范式下解决特定设计问题，那将会相当无聊，因为问题要么不存在，要么通过函数来解决。我们的解决方案看起来就像*表9.1*：
- en: '| **Design Pattern** | **Solution** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **设计模式** | **解决方案** |'
- en: '| Strategy pattern | Functions (higher-order functions + function types) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 策略模式 | 函数（高阶函数 + 函数类型）|'
- en: '| Decorator pattern | Function composition (closures) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 装饰器模式 | 函数组合（闭包）|'
- en: '| Factory pattern | No real need, as we don’t need objects, but we could create
    functions with a set of default values – so, this would be function currying |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 工厂模式 | 实际上不需要，因为我们不需要对象，但我们可以创建具有一组默认值的函数——因此，这将属于函数柯里化 |'
- en: '| Visitor pattern | Functions |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 访问者模式 | 函数 |'
- en: '| Singleton pattern | No need, as we avoid objects and mutable state |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 单例模式 | 不需要，因为我们避免使用对象和可变状态 |'
- en: '| Adapter | Could be seen as function mapping |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 适配器 | 可以看作是函数映射 |'
- en: '| Façade | Functions again |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 门面模式 | 再次提及函数 |'
- en: 'Table 9.1: Design patterns and their functional solution'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1：设计模式及其函数式解决方案
- en: In Go, however, we are working with a multi-paradigm language, so we get to
    have the best of both worlds. We can leverage some design patterns when we are
    working with structs, but their implementation is simplified in many ways through
    the use of functional programming principles rather than object-oriented ones.
    Despite creating an interface to abstract the implementation of a struct’s functionality,
    we can use a function that adheres to a given type, as we have done with `CipherService`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Go语言中，我们使用的是一种多范式语言，因此我们可以兼得两者之长。当我们与结构体一起工作时，我们可以利用一些设计模式，但它们的实现通过使用函数式编程原则而不是面向对象原则而大大简化。尽管我们创建了一个接口来抽象结构体功能的实现，但我们仍然可以使用一个符合给定类型的函数，就像我们使用`CipherService`时所做的那样。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a look at the design patterns common in object-oriented
    code, namely the strategy pattern, the decorator pattern, and the Hollywood principle
    (IoC). We saw that these can be implemented in Go without the need for extensive
    object taxonomy simply by leveraging functions as first-class citizens. We also
    discussed the need for design patterns in the functional paradigm and concluded
    that either the patterns are not needed or can be solved using functions. In terms
    of real functional code that is reusable for solving common problems, we pointed
    at concepts such as function currying and function composition. In the next chapter,
    we will take a look at how functional programming can be leveraged to implement
    concurrent code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在面向对象代码中常见的几种设计模式，即策略模式、装饰器模式和好莱坞原则（IoC）。我们了解到，这些模式可以在Go语言中通过利用函数作为一等公民来实现，而无需构建广泛的对象分类。我们还讨论了在函数式范式中对设计模式的需求，并得出结论：要么模式不是必需的，要么可以使用函数来解决。在解决常见问题的可重用实际函数式代码方面，我们指出了函数柯里化和函数组合等概念。在下一章中，我们将探讨如何利用函数式编程来实现并发代码。
