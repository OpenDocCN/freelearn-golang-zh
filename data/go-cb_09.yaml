- en: Parallelism and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行和并发
- en: 'In this chapter, the following recipes will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Using channels and the select statement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道和 select 语句
- en: Performing async operations with sync.WaitGroup
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sync.WaitGroup 执行异步操作
- en: Using atomic operations and mutex
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子操作和互斥锁
- en: Using the context package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文包
- en: Executing state management for channels
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行通道的状态管理
- en: Using the worker pool design pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作池设计模式
- en: Using workers to create pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作者创建管道
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter covers worker pools, wait groups for async operations, and the
    use of the `context` package. Parallelism and concurrency are some of the most
    advertised and promoted features of the Go language. This chapter will offer a
    number of useful patterns to get you started and help you understand these features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍工作池、异步操作等待组和 `context` 包的使用。并行和并发是 Go 语言最宣传和推广的特性之一。本章将提供一些有用的模式来帮助你入门，并帮助你理解这些特性。
- en: Go provides primitives that make parallel applications possible. Goroutines
    allow any function to become asynchronous and concurrent. Channels allow an application
    to set up communication with goroutines. One of the famous sayings in Go is *Do
    not communicate by sharing memory; instead, share memory by communicating* from
    [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了使并行应用程序成为可能的原语。Goroutines 允许任何函数成为异步和并发的。Channels 允许应用程序与 goroutines 建立通信。Go
    中的一条著名说法是 *不要通过共享内存来通信；相反，通过通信来共享内存*，出自 [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating)。
- en: Using channels and the select statement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道和 select 语句
- en: Go channels, in combination with goroutines, are first-class citizens for asynchronous
    communication. Channels become especially powerful when using select statements.
    These statements allow a goroutine to intelligently handle requests from multiple
    channels at once.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go channels 与 goroutines 结合，是异步通信的一等公民。当使用 select 语句时，Channels 变得特别强大。这些语句允许
    goroutine 同时智能地处理多个通道的请求。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://golang.org/doc/install](https://golang.org/doc/install) 下载并安装 Go
    到你的操作系统上，并配置你的 `GOPATH` 环境变量。
- en: Open a terminal/console application.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端/控制台应用程序。
- en: Navigate to `GOPATH/src` and create a project directory, such as `$GOPATH/src/github.com/yourusername/customrepo`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `GOPATH/src` 并创建一个项目目录，例如 `$GOPATH/src/github.com/yourusername/customrepo`。
- en: All code will be run and modified from this directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都将从这个目录运行和修改。
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，使用 `go get github.com/agtorre/go-cookbook/` 命令安装代码的最新测试版本。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'These steps cover writing and running your application:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter9/channels` directory
    and navigate to it.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中，创建 `chapter9/channels` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/channels](https://github.com/agtorre/go-cookbook/tree/master/chapter9/channels)
    or use this as an exercise to write some of your own code.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter9/channels](https://github.com/agtorre/go-cookbook/tree/master/chapter9/channels)
    复制测试用例，或者使用这个练习来编写你自己的代码。
- en: 'Create a file called `sender.go` with the following content:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `sender.go` 的文件，内容如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `printer.go` with the following content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `printer.go` 的文件，内容如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content and ensure that you
    modify the `channels` import to use the path you set up in step 2:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，内容如下，并确保将 `channels` 导入修改为步骤 2 中设置的路径：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run `go run main.go`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以运行以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should now see the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到以下输出：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试用例，请向上导航一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe demonstrates two ways to launch a worker process that either reads
    or writes to a channel, and may potentially do both. The terminate conditions
    are a `done` channel, or by using a `context` package. The *Using the context
    package* recipe will cover the context in more detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了两种启动工作进程的方法，该进程可以读取或写入通道，也可能两者都做。终止条件是一个`done`通道，或者使用`context`包。*使用上下文包*配方将更详细地介绍上下文。
- en: The `main` package is used to wire together the separate functions; thanks to
    this, it is possible to set up multiple pairs as long as the channels are not
    shared. In addition, it's possible to have multiple goroutines listening on the
    same channel, as we'll explore in the *Using the worker pool design pattern* recipe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`main`包将独立的函数连接起来；多亏了这一点，只要通道不共享，就可以设置多个对。此外，还可以有多个goroutine监听同一个通道，我们将在*使用工作池设计模式*的配方中探讨这一点。
- en: 'Lastly, due to the asynchronous nature of goroutines, it can be tricky to establish
    cleanup and terminate conditions; for example, a common mistake is to do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于goroutines的异步性质，建立清理和终止条件可能很棘手；例如，一个常见的错误是以下操作：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By putting the tick in the `select` statement, it's possible to prevent this
    case from ever occurring. There's also no simple way to prioritize traffic in
    a `select` statement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`select`语句中放置勾号，可以防止这种情况发生。在`select`语句中也没有简单的方法来优先处理流量。
- en: Performing async operations with sync.WaitGroup
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sync.WaitGroup执行异步操作
- en: Sometimes, it is useful to perform a number of operations asynchronously, then
    wait till they complete before moving on. For example, if an operation requires
    pulling information from multiple APIs and aggregate that information, it can
    be helpful to make those client requests asynchronously. This chapter will explore
    using `sync.WaitGroup` to orchestrate non-dependent tasks in parallel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，执行多个异步操作然后等待它们完成再继续是有用的。例如，如果操作需要从多个API中提取信息并汇总这些信息，那么异步地发出客户端请求可能会有所帮助。本章将探讨使用`sync.WaitGroup`来并行编排非依赖性任务。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中*使用通道和选择语句*配方中的*准备工作*部分。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中创建
- en: '`chapter9/waitgroup` directory and navigate to it.'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`chapter9/waitgroup`目录并导航到它。'
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/waitgroup](https://github.com/agtorre/go-cookbook/tree/master/chapter9/waitgroup)
    or use this as an exercise to write some of your own code.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter9/waitgroup](https://github.com/agtorre/go-cookbook/tree/master/chapter9/waitgroup)复制测试或将其作为练习来编写一些自己的代码。
- en: 'Create a file called `tasks.go` with the following content:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tasks.go`的文件，内容如下：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a file called `process.go` with the following content:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`process.go`的文件，内容如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `waitgroup` import to use the path you set up in step 2:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下。确保你修改`waitgroup`导入以使用你在步骤2中设置的路径：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run `go run main.go`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以运行以下命令：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下内容：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制了自己的测试或编写了自己的测试，请向上移动一个目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe shows how to use `waitgroups` as a synchronization mechanism when
    waiting for work. In essence, `waitgroup.Wait()` will wait until its internal
    counter has reached `0`. The `waitgroup.Add(int)` method will increment the counter
    by the amount entered, and `waitgroup.Done()` will decrement the counter by `1`.
    Because of this, it is necessary to asynchronously `Wait()` while the various
    goroutines mark the `waitgroup` as `Done()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何在等待工作时使用`waitgroups`作为同步机制。本质上，`waitgroup.Wait()`将等待其内部计数器达到`0`。`waitgroup.Add(int)`方法将计数器增加输入的数量，而`waitgroup.Done()`将计数器减`1`。因此，在各个goroutine将`waitgroup`标记为`Done()`的同时，需要异步地`Wait()`。
- en: In this recipe, we increment before dispatching each HTTP request and then call
    a defer `wg.Done()` method, so that we can decrement whenever the goroutine terminates.
    We then wait for all goroutines to finish before returning our aggregated results.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在发送每个HTTP请求之前增加计数，然后调用一个defer `wg.Done()`方法，这样我们就可以在goroutine终止时减少计数。然后我们等待所有goroutine完成，然后再返回我们的聚合结果。
- en: In practice, it's better to use channels for passing the error and responses
    around.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，最好使用通道来传递错误和响应。
- en: When performing operations asynchronously like this, you should consider thread
    safety for things such as modifying a shared map. If you keep this in mind, `waitgroups`
    are a useful feature for waiting on any kind of asynchronous operation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此类异步操作时，你应该考虑修改共享映射等线程安全。如果你记住这一点，`waitgroups`是等待任何类型异步操作的有用功能。
- en: Using atomic operations and mutex
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子操作和互斥锁
- en: In a language like Go, where you have build in asynchronous operations and parallelism,
    it becomes important to consider things such as thread safety. For example, it
    is dangerous to access a map from multiple goroutines simultaneously. Go provides
    a number of helpers in the `sync` and `sync/atomic` packages to make sure that
    certain events occur only once or that goroutines can serialize on an operation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Go这样的语言中，你拥有内置的异步操作和并行性，考虑线程安全变得很重要。例如，同时从多个goroutine访问映射是危险的。Go在`sync`和`sync/atomic`包中提供了一些辅助工具，以确保某些事件只发生一次，或者goroutine可以在操作上序列化。
- en: This recipe will demonstrate the use of these packages to safely modify a map
    with various goroutines and to keep a global ordinal value that can be safely
    accessed by numerous goroutines. It will also showcase the `Once.Do` method, which
    can be used to ensure that something is only done by a Go application once, such
    as reading a config or initializing a variable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示如何使用这些包安全地修改映射，以及如何保持一个可以被多个goroutine安全访问的全局序数值。它还将展示`Once.Do`方法，该方法可以用来确保Go应用程序只执行一次某些操作，例如读取配置或初始化变量。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中“使用通道和select语句”食谱的“准备就绪”部分。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter9/atomic` directory
    and navigate to it.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建`chapter9/atomic`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/atomic](https://github.com/agtorre/go-cookbook/tree/master/chapter9/atomic)
    or use this as an exercise to write some of your own code.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter9/atomic](https://github.com/agtorre/go-cookbook/tree/master/chapter9/atomic)复制测试或将其作为练习编写一些自己的代码。
- en: 'Create a file called `map.go` with the following content:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`map.go`的文件，内容如下：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a file called `ordinal.go` with the following content:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ordinal.go`的文件，内容如下：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content and ensure that you
    modify the `atomic` import to use the path you set up in step 2:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下，并确保你修改`atomic`导入以使用步骤2中设置的路径：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run `go run main.go`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should now see the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下内容：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For our map recipe, we used a `ReadWrite` mutex. The idea behind this mutex
    is that any number of readers can acquire a read lock, but only one writer can
    acquire a write lock. Additionally, a writer cannot acquire a lock when anyone
    else (reader or writer) has one. This is useful because reads are very fast and
    non-blocking when compared to a standard mutex. Whenever we want to set data,
    we use `Lock()` object and whenever we want to read data we use `RLock()`. It
    is critical that you use `Unlock()` or `RUnlock()` eventually so that you don't
    deadlock your application. A defer `Unlock()` object can be useful, but may be
    slower than calling `Unlock()` manually.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '对于我们的映射食谱，我们使用了`ReadWrite`互斥锁。这种互斥锁背后的想法是，任何数量的读者都可以获取读锁，但只有一个写者可以获取写锁。此外，当其他人（读者或写者）拥有锁时，写者无法获取锁。这很有用，因为与标准互斥锁相比，读取操作非常快且非阻塞。每次我们想要设置数据时，我们使用`Lock()`对象，每次我们想要读取数据时，我们使用`RLock()`。最终使用`Unlock()`或`RUnlock()`是至关重要的，这样您就不会使应用程序发生死锁。defer
    `Unlock()`对象可能很有用，但可能比手动调用`Unlock()`慢。 '
- en: This pattern may not be flexible enough when you want to group additional actions
    with the locked value. For example, in some cases, you may want to lock, do some
    additional processing, and only after you've completed this will you unlock. It's
    important to consider this for your designs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要将额外的操作与锁定值分组时，这种模式可能不够灵活。例如，在某些情况下，您可能想要锁定，执行一些额外的处理，然后才解锁。在设计时考虑这一点非常重要。
- en: The `sync/atmoic` package is used by `Ordinal` to get and set values. There
    are also atomic comparison operations such as `atomic.CompareAndSwapUInt64()`,
    which are extremely valuable. This recipe allows Init to be called on an `Ordinal`
    object only once; otherwise, it can only be incremented and does so atomically.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync/atomic`包被`Ordinal`用于获取和设置值。还有原子比较操作，如`atomic.CompareAndSwapUInt64()`，它们非常有价值。本食谱允许在`Ordinal`对象上仅调用一次Init；否则，它只能原子性地增加。'
- en: We loop and create 10 goroutines (synchronizing with `sync.Waitgroup`) and show
    that the ordinal correctly incremented 10 times and that every key in our map
    was appropriately set.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环创建10个goroutine（与`sync.Waitgroup`同步）并显示序号正确增加了10次，以及我们映射中的每个键都适当地设置了。
- en: Using the context package
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文包
- en: Several recipes throughout this book make use of the `context` package. This
    recipe will explore the basics of creating and managing contexts. A good reference
    for understanding context is [https://blog.golang.org/context](https://blog.golang.org/context).
    Since this blog post was written, context moved from `net/context` to a package
    called `context`. This still occasionally causes problems when interacting with
    third-party libraries such as GRPC.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的几个食谱都使用了`context`包。本食谱将探讨创建和管理上下文的基本知识。了解上下文的良好参考资料是[https://blog.golang.org/context](https://blog.golang.org/context)。自从这篇博客文章被撰写以来，上下文已从`net/context`移动到一个名为`context`的包。这仍然偶尔会在与GRPC等第三方库交互时引起问题。
- en: This recipe will explore setting and getting values for contexts, cancelation,
    and timeouts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将探讨为上下文设置和获取值、取消和超时。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中*使用通道和select语句*食谱的*准备就绪*部分。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter9/context` directory
    and navigate to it.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端/控制台应用程序中，创建`chapter9/context`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/context](https://github.com/agtorre/go-cookbook/tree/master/chapter9/context)
    or use this as an exercise to write some of your own code.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter9/context](https://github.com/agtorre/go-cookbook/tree/master/chapter9/context)复制测试或将其作为练习编写一些自己的代码。
- en: 'Create a file called `values.go` with the following content:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`values.go`的文件，内容如下：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec.go`的文件，内容如下：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `context` import to use the path you set up in step 2:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下。确保您修改`context`导入以使用步骤2中设置的路径：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run `go run main.go`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should now see the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下输出：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When working with context values, it's good to create a new type to represent
    the key. In this case, we created a `key` type, then declared some corresponding
    `const` values to represent all of our possible keys.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理上下文值时，创建一个新的类型来表示键是个好主意。在这种情况下，我们创建了一个 `key` 类型，然后声明了一些相应的 `const` 值来表示我们所有的可能键。
- en: 'In this case, we initialize all our key/value pairs at the same time using
    the `Setup()` function. When modifying contexts, functions generally take a `context`
    argument and return a `context` value. So the signature often looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `Setup()` 函数同时初始化所有的键值对。当修改上下文时，函数通常需要一个 `context` 参数并返回一个 `context`
    值。所以签名通常看起来像这样：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sometimes, these methods also return an error or `cancel()` function, such as
    in the cases of `context.WithCancel`, `context.WithTimeout`, and `context.WithDeadline`.
    All child contexts inherit the attributes of the parent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些方法也会返回一个错误或 `cancel()` 函数，例如在 `context.WithCancel`、`context.WithTimeout`
    和 `context.WithDeadline` 的情况下。所有子上下文都继承父上下文的属性。
- en: In this recipe, we create two child contexts, one with a deadline and one with
    a timeout. We set these to timeout to be random ranges, then terminate when either
    is received. Lastly, we extract a value given a set key and print it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了两个子上下文，一个带有截止日期，一个带有超时。我们将这些设置为随机范围的超时，然后在接收到任何一个时终止。最后，我们根据给定的键提取一个值并打印它。
- en: Executing state management for channels
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行通道的状态管理
- en: Channels can be any type in Go. A channel of structs allows you to pass a lot
    of state with a single message. This recipe will explore using of channels to
    pass around complex request structs and return their results in complex response
    structs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，通道可以是任何类型。结构体的通道允许你通过单个消息传递大量的状态。这个菜谱将探讨使用通道传递复杂的请求结构体并在复杂的响应结构体中返回它们的结果。
- en: In the next recipe, *Using the worker pool design pattern*, the value of this
    becomes even more apparent as you can create general purpose workers capable of
    performing a variety of tasks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一道菜谱中，*使用工作池设计模式*，这个值变得更加明显，因为你可以创建能够执行各种任务的一般用途的工作者。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中 *准备就绪* 部分的 *使用通道和选择语句* 菜谱。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create and navigate to the `chapter9/state`
    directory.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建并导航到 `chapter9/state` 目录。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/state](https://github.com/agtorre/go-cookbook/tree/master/chapter9/state)
    or [use this as an exercise to write some of your own code.](https://github.com/agtorre/go-cookbook/tree/master/chapter9/state)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter9/state](https://github.com/agtorre/go-cookbook/tree/master/chapter9/state)
    复制测试或[将其用作练习来编写你自己的代码。](https://github.com/agtorre/go-cookbook/tree/master/chapter9/state)
- en: 'Create a file called `state.go` with the following content:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `state.go` 的文件，内容如下：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a file called `processor.go` with the following content:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `processor.go` 的文件，内容如下：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a file called `process.go` with the following content:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `process.go` 的文件，内容如下：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `state` import to use the path you set up in step 2:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，内容如下。确保将 `state` 导入修改为你在步骤 2 中设置的路径：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run `go run main.go`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`.
- en: 'You may also run the following commands:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should now see the following output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下输出：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Processor()` function in this recipe is a function that loops forever until
    its context is canceled, either through explicit calls to cancel or via timeout.
    It dispatches all work to `Process()`, which can handle different functions given
    various operations. It would also be possible to have each of these cases dispatch
    another function for even more modular code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中的 `Processor()` 函数是一个无限循环直到其上下文被取消的函数，无论是通过显式调用取消还是通过超时。它将所有工作调度到 `Process()`，它可以处理各种操作给出的不同函数。也有可能让这些情况中的每一个调度另一个函数以实现更模块化的代码。
- en: Ultimately, the response is returned to a response channel, and we loop over
    and print all the results at the very end. We also demonstrate an error case in
    the divide by `0` example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，响应被返回到响应通道，我们在最后循环并打印所有结果。我们还演示了除以 `0` 的错误情况。
- en: Using the worker pool design pattern
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作池设计模式
- en: The worker pool design pattern is one where you dispatch long-running goroutines
    as workers. These workers can process a variety of work either using multiple
    channels or by using a stateful request struct that specifies the type as described
    in the preceding recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 工作池设计模式是一种将长时间运行的 goroutines 作为工作者调度的模式。这些工作者可以通过多个通道或使用具有指定类型的具有状态请求结构来处理各种工作，正如前一个菜谱中描述的那样。
- en: This recipe will create stateful workers and demonstrate how to coordinate and
    spin up multiple workers all handling requests concurrently on the same channel.
    These workers will be crypto workers like in a web authentication app. Their purpose
    will be to hash plain text strings using `bcrypt` package and compare a text password
    against a hash.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将创建具有状态的工作者，并演示如何协调和启动多个工作者，它们在同一个通道上并发处理请求。这些工作者将像在 Web 身份验证应用程序中的加密工作者一样。他们的目的是使用
    `bcrypt` 包对纯文本字符串进行哈希处理，并将文本密码与哈希进行比较。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中 *Using channels and the select statement* 菜谱的 *Getting ready* 部分。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter9/pool` directory
    and navigate to it.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建 `chapter9/pool` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/pool](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pool)
    or use this as an exercise to write some of your own code.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter9/pool](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pool)
    复制测试或使用这个练习来编写你自己的代码。
- en: 'Create a file called `worker.go` with the following content:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `worker.go` 的文件，并包含以下内容：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a file called `work.go` with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `work.go` 的文件，并包含以下内容：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a file called `crypto.go` with the following content:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `crypto.go` 的文件，并包含以下内容：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录，并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `state` import to use the path you set up in step 2:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，并包含以下内容。确保你修改 `state` 导入以使用你在第 2 步中设置的路径：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run `go run main.go`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should now see the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下内容：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe uses the `Dispatch()` method to create a number of workers on a
    single input channel, output channel, and those attached to a single `cancel()`
    function. This can be used if you want to make different pools for different purposes.
    For example, you can create 10 crypto and 20 compare workers by using separate
    pools. For this recipe, we use a single pool, send hash requests to the workers,
    retrieve the responses, and then send compare requests to the same pool. Because
    of this, the worker performing the work will be different each time, but they're
    all capable of performing either type of work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用 `Dispatch()` 方法在单个输入通道、输出通道以及连接到单个 `cancel()` 函数的通道上创建多个工作者。如果你想要为不同的目的创建不同的池，这可以用来。例如，你可以通过使用单独的池来创建
    10 个加密和 20 个比较工作者。对于这个菜谱，我们使用一个单独的池，向工作者发送哈希请求，检索响应，然后向同一个池发送比较请求。因此，执行工作的工作者每次都会不同，但它们都能执行这两种类型的工作。
- en: The advantage to this approach is that both allow for parallelism and can also
    control the maximum concurrency. Bounding the maximum number of goroutines can
    also be important for limiting memory. I chose crypto for this recipe because
    crypto is a good example of code that can overwhelm your CPU or memory if you
    spin up a new goroutine for every new request, for example in a web service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，它既允许并行处理，也可以控制最大并发量。限制goroutine的最大数量对于限制内存也很重要。我选择加密作为这个菜谱的例子，因为如果为每个新请求启动一个新的goroutine，例如在Web服务中，加密代码可能会耗尽你的CPU或内存。
- en: Using workers to create pipelines
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作者创建管道
- en: This recipe demonstrates creating groups of worker pools and connecting them
    together to form a pipeline. For this recipe, we link together two pools, but
    the pattern can be used for much more complex operations similar to middleware.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱演示了创建工作池组并将它们连接起来形成管道。对于这个菜谱，我们连接了两个池，但这个模式可以用于更复杂的操作，类似于中间件。
- en: Worker pools can be useful to keep workers relatively simple and to also further
    control concurrency. For example, it may be useful to serialize logging while
    parallelizing other operations. This may also be useful to have a smaller pool
    for more expensive operations, so you don't overload machine resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 工作池可以用来保持工作者相对简单，并进一步控制并发。例如，在并行其他操作的同时序列化日志可能很有用。这也可以用于为更昂贵的操作创建更小的池，这样就不会超载机器资源。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Refer to the *Getting ready* section of the *Using channels and the select statement*
    recipe in this chapter.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中 *准备就绪* 部分 *使用通道和select语句* 菜谱。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'These steps cover writing and running your application:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter9/pipeline` directory
    and navigate to it.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中，创建名为 `chapter9/pipeline` 的目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline)
    or [use this as an exercise to write some of your own code.](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline](https://github.com/agtorre/go-cookbook/tree/master/chapter9/pipeline)
    复制测试或将其作为练习编写你自己的代码。
- en: 'Create a file called `worker.go` with the following content:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `worker.go` 的文件，并包含以下内容：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a file called `print.go` with the following content:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `print.go` 的文件，并包含以下内容：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a file called `encode.go` with the following content:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `encode.go` 的文件，并包含以下内容：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Create a file called `pipeline.go` with the following content:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `pipeline.go` 的文件，并包含以下内容：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content and ensure that you
    modify the `state` import to use the path you set up in step 2:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，并包含以下内容，并确保将 `state` 导入修改为你在步骤2中设置的路径：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run `go run main.go`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以运行以下命令：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should now see the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下内容：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `main` package creates a pipeline consisting of 10 encoders and two printers.
    It enqueues 20 strings on the in channel and waits for 20 responses on the out
    channel. If messages reach the out channel, it indicates that they've gone through
    the entire pipeline successfully.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 包创建了一个由10个编码器和两个打印机组成的管道。它在输入通道上排队20个字符串，并在输出通道上等待20个响应。如果消息到达输出通道，则表示它们已成功通过整个管道。'
- en: The `NewPipeline` function is used to wire up the pools. It ensures that the
    channels are created with the proper buffered sizes and that the output channels
    of some pools are connected to the appropriate input channels of other pools.
    It's also possible to fan out the pipeline by using an array of in channels and
    an array of out channels on each worker, multiple named channels, or maps of channels.
    This would allow for things such as sending messages to a logger at each step.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewPipeline` 函数用于连接池。它确保通道以适当的缓冲大小创建，并且某些池的输出通道连接到其他池的适当输入通道。还可以通过在每个工作器上使用输入通道和输出通道的数组、多个命名通道或通道映射来扩展管道。这将允许发送消息到每个步骤的记录器等操作。'
