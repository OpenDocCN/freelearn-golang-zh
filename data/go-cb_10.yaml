- en: Distributed Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式系统
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Using service discovery with Consul
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Consul 进行服务发现
- en: Implementing basic consensus using Raft
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Raft 实现基本共识
- en: Using containerization with Docker
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 进行容器化
- en: Orchestration and deployment strategies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排和部署策略
- en: Monitoring applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控应用程序
- en: Collecting metrics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集指标
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Sometimes, application-level parallelism is not enough, and things that seem
    simple in development can become complex during deployment. Distributed systems
    provide a number of challenges not found when developing on a single machine.
    These applications have added complexity for things such as monitoring, writing
    applications that require strong consistency guarantees, and service discovery.
    In addition, you must always be mindful of single points of failure, such as a
    database. Otherwise your distributed applications can fail when this single component
    fails.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用级别的并行性不足以解决问题，开发中看似简单的事情在部署时可能会变得复杂。分布式系统在单机开发时不会遇到许多挑战。这些应用程序为监控、编写需要强一致性保证的应用程序和服务发现等问题增加了复杂性。此外，您必须始终注意单点故障，例如数据库。否则，当这个单一组件失败时，您的分布式应用程序可能会失败。
- en: This chapter will explore methods of managing distributed data, orchestration,
    containerization, metrics, and monitoring. These will become part of your toolbox
    for writing and maintaining microservices and large distributed applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨管理分布式数据、编排、容器化、指标和监控的方法。这些将成为您编写和维护微服务和大型分布式应用程序的工具箱的一部分。
- en: Using service discovery with Consul
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Consul 进行服务发现
- en: When using the microservice approach to applications, you end up with a lot
    of servers listening on a variety of IPs, domains, and ports. These IP addresses
    will vary by environment (staging versus production), and it can be tricky to
    keep them static for configuration between services. You also want to know when
    a machine or service is down or unreachable due to a network partition. Consul
    is a tool that provides a lot of functionality, but we'll explore registering
    services with Consul and querying them from our other services.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用微服务方法构建应用程序时，你将拥有许多服务器，它们监听各种 IP、域名和端口。这些 IP 地址会因环境（预发布与生产）而异，并且在不同服务之间保持静态配置可能会很棘手。你还想了解当机器或服务因网络分区而无法访问或宕机时的情况。Consul
    是一个提供许多功能的工具，但我们将探讨如何使用 Consul 注册服务以及如何从我们的其他服务中查询它们。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: "Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)\
    \ and [\uFEFF](https://golang.org/doc/install)configure your `GOPATH` environment\
    \ variable."
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://golang.org/doc/install](https://golang.org/doc/install) 下载并安装 Go
    到您的操作系统上，并配置您的 `GOPATH` 环境变量。
- en: Open a terminal/console application.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端/控制台应用程序。
- en: Navigate to `GOPATH/src` and create a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `GOPATH/src` 并创建一个项目目录，例如，`$GOPATH/src/github.com/yourusername/customrepo`。
- en: All code will be run and modified from this directory.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有代码都将从这个目录运行和修改。
- en: Optionally, install the latest tested version of the code by running the `go
    get github.com/agtorre/go-cookbook/` command.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，通过运行 `go get github.com/agtorre/go-cookbook/` 命令安装最新测试版本的代码。
- en: Install Consul from [https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.consul.io/intro/getting-started/install.html](https://www.consul.io/intro/getting-started/install.html)
    安装 Consul。
- en: Run the `go get github.com/hashicorp/consul/api` command.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get github.com/hashicorp/consul/api` 命令。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'These steps cover writing and running your application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序：
- en: From your terminal/console application, create the `chapter10/discovery` directory
    and navigate to it.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端/控制台应用程序中创建 `chapter10/discovery` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/discovery](https://github.com/agtorre/go-cookbook/tree/master/chapter10/discovery),
    or use this as an exercise to write some of your own code.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter10/discovery](https://github.com/agtorre/go-cookbook/tree/master/chapter10/discovery)
    复制测试，或者将其作为练习编写一些自己的代码。
- en: 'Create a file called `client.go` with the following content:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `client.go` 的文件，内容如下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `operations.go` with the following content:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `operations.go` 的文件，内容如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `exec.go` 的文件，并包含以下内容：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，并包含以下内容。确保你修改 `channels` 导入以使用你在步骤 2 中设置的路径：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Start Consul in a separate terminal using the `consul agent -dev -node=localhost`
    command.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的终端中使用 `consul agent -dev -node=localhost` 命令启动 Consul。
- en: Run the `go run main.go` command.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go` 命令。
- en: 'You may also run:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以运行：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Consul provides a robust Go API library. It can feel daunting when first starting,
    but this recipe shows how you might approach wrapping it. Configuring Consul further
    is beyond the scope of this recipe, but this shows the basic for registering a
    service and querying for other services given a key and tag.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Consul 提供了一个健壮的 Go API 库。一开始可能会觉得有些令人畏惧，但这个配方展示了你如何接近封装它。配置 Consul 超出了本配方的范围，但本配方展示了注册服务和根据键和标签查询其他服务的基本方法。
- en: It would be possible using this to register new microservices at startup time,
    query for all dependent services, and deregister at shutdown. You might also want
    to cache this information so that you're not hitting Consul for every request,
    but this recipe provides the basic tools that you can expand upon. The Consul
    agent also makes these repeated requests fast and efficient ([https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法可以在启动时注册新的微服务，查询所有依赖的服务，并在关闭时注销。你可能还希望缓存这些信息，这样你就不必为每个请求都调用 Consul，但本配方提供了你可以扩展的基本工具。Consul
    代理还使这些重复请求变得快速高效（[https://www.consul.io/intro/getting-started/agent.html](https://www.consul.io/intro/getting-started/agent.html)）。
- en: Implementing basic consensus using Raft
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Raft 实现基本共识
- en: Raft is a consensus algorithm that allows distributed systems to keep a shared
    and managed state ([https://raft.github.io/](https://raft.github.io/)). Setting
    up a Raft system is complex in many ways, for one you need consensus for an election
    to occur and succeed. This can be difficult to bootstrap when working with multiple
    nodes and it can be difficult to get started. A basic cluster can be run on a
    single node/leader, but if you want redundancy, at least three nodes allows for
    a single node failure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Raft 是一种共识算法，允许分布式系统保持共享和管理状态（[https://raft.github.io/](https://raft.github.io/)）。在许多方面设置
    Raft 系统都是复杂的，例如，你需要达成共识以进行选举并成功。当与多个节点一起工作时，这可能很难启动，也可能很难开始。一个基本的集群可以在单个节点/领导者上运行，但如果你想要冗余，至少需要三个节点以允许单个节点故障。
- en: This recipe implements a basic in-memory Raft cluster, constructs a state machine
    that can transition between certain allowed states, and connects the distributed
    state machine to a web handler that can trigger the transition. This can be useful
    when you're implementing the base finite state machine interface that Raft requires
    or when testing. This recipe uses [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)
    for the base Raft implementation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方实现了一个基本的内存 Raft 集群，构建了一个可以在某些允许的状态之间转换的状态机，并将分布式状态机连接到一个可以触发转换的 Web 处理器。当你实现
    Raft 所需的基本有限状态机接口或进行测试时，这可能很有用。本配方使用 [https://github.com/hashicorp/raft](https://github.com/hashicorp/raft)
    作为基本的 Raft 实现。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Using service discovery with Consul*
    recipe in this chapter.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章中 *使用 Consul 进行服务发现* 配方的 *准备工作* 部分。
- en: Run the `go get github.com/hashicorp/raft` command.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get github.com/hashicorp/raft` 命令。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These steps cover writing and running your application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter10/consensus` directory
    and navigate to it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建 `chapter10/consensus` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/consensus](https://github.com/agtorre/go-cookbook/tree/master/chapter10/consensus),
    or use this as an exercise to write some of your own code.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter10/consensus](https://github.com/agtorre/go-cookbook/tree/master/chapter10/consensus)
    复制测试，或者将其作为练习编写一些自己的代码。
- en: 'Create a file called `state.go` with the following content:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `state.go` 的文件，内容如下：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a file called `config.go` with the following content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `config.go` 的文件，内容如下：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a file called `fsm.go` with the following content:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `fsm.go` 的文件，内容如下：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `handler.go` 的文件，内容如下：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录，并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，内容如下。确保你修改 `channels` 导入以使用步骤 2 中设置的路径：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the `go run main.go` command. Alternatively, you may also run the following
    commands:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go` 命令。或者，你也可以运行以下命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should now see the following output by running the preceding command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的命令，你现在应该会看到以下输出：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a separate terminal, run the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，运行以下命令：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all tests pass.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the application starts, we initialize multiple Raft objects. These each
    have their own address and transport. The `InmemTransport{}` function also provides
    a method to connect the other transports called `Connect()`. Once these connections
    are established, the Raft cluster holds an election. When communicating to a Raft
    cluster, clients must communicate with the leader. In our case, one handler can
    talk to all of the nodes, so the handler is responsible for having the leader
    `Raft` object `call Apply()`. This in turn runs `apply()` on all of the other
    nodes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，我们初始化多个 Raft 对象。每个对象都有自己的地址和传输。`InmemTransport{}` 函数还提供了一个连接其他传输的方法，称为
    `Connect()`。一旦建立这些连接，Raft 集群就会进行选举。当与 Raft 集群通信时，客户端必须与领导者通信。在我们的情况下，一个处理器可以与所有节点通信，因此处理器负责让领导者
    `Raft` 对象调用 `Apply()`。这反过来在所有其他节点上运行 `apply()`。
- en: This recipe does not deal with snapshots and is only concerned with FSM state
    changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方不处理快照，仅关注有限状态机（FSM）状态的变化。
- en: The `InmemTransport{}` function simplifies the election and bootstrapping process
    by allowing everything to reside in memory. In practice, this isn't very helpful
    besides testing and proof of concepts since go routines can freely access shared
    memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`InmemTransport{}` 函数通过允许所有内容都驻留在内存中来简化选举和引导过程。在实践中，这除了测试和概念验证之外并不很有用，因为 go
    线程可以自由访问共享内存。'
- en: Using containerization with Docker
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 进行容器化
- en: Docker is a container technology for packaging and shipping applications. Other
    advantages include portability, a container will run the same way regardless of
    the host OS. It provides a lot of the advantages of a virtual machine, in a more
    light-weight container. It's possible to limit resources consumption of individual
    containers and sandbox your environment. It can be extremely useful for having
    a common environment for your applications locally and when you ship your code
    to production. Docker is written in Go and is open source, so it's simple to take
    advantage of the client and libraries. This recipe will set up a Docker container
    for a basic Go application, store some version information about the container,
    and demonstrate hitting a handler from a Docker endpoint.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一种用于打包和运输应用程序的容器技术。其他优点包括可移植性，容器将在宿主操作系统上以相同的方式运行。它提供了虚拟机的大部分优点，但更轻量级的容器。可以限制单个容器的资源消耗并沙盒化环境。对于在本地为应用程序创建一个通用环境以及将代码部署到生产环境时非常有用。Docker
    用 Go 编写且是开源的，因此可以利用客户端和库。本配方将为基本的 Go 应用程序设置 Docker 容器，存储有关容器的某些版本信息，并演示从 Docker
    端点调用处理器。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Using service discovery for Consul*
    recipe of this chapter.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章中 *使用服务发现进行 Consul* 配方的 *准备工作* 部分。
- en: Install Docker from [https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community).
    This will also include Docker compose.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://store.docker.com/search?type=edition&offering=community](https://store.docker.com/search?type=edition&offering=community)安装Docker。这将包括Docker
    Compose。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter10/docker` directory
    and navigate to it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中，创建`chapter10/docker`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/docker](https://github.com/agtorre/go-cookbook/tree/master/chapter10/docker)
    or use this as an exercise to write some of your own code.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter10/docker](https://github.com/agtorre/go-cookbook/tree/master/chapter10/docker)复制测试或使用这个练习来编写一些你自己的代码。
- en: 'Create a file called `dockerfile` with the following content:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`dockerfile`的文件，内容如下：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a file called `setup.sh` with the following content:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`setup.sh`的文件，内容如下：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a file called `version.go` with the following content:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`version.go`的文件，内容如下：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并导航到它。
- en: 'Create a file `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下。确保你修改了`channels`导入以使用你在步骤2中设置的路径：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Navigate back to the starting directory.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到起始目录。
- en: 'Run the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should now see the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下输出：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the following commands:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe created a script that compiles the Go binary for the Linux architecture
    and sets a variety of private variables in `main.go`. These variables are used
    to return version information on a version endpoint. Once the binary is compiled,
    a Docker container is created that contains the binary. This allows us to use
    very small container images as the Go runtime is self contained in the binary.
    We then run the container while exposing the port on which the container is listening
    for HTTP traffic. Lastly, we curl the port on localhost and see our version information
    returned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱创建了一个脚本，用于编译Linux架构的Go二进制文件，并在`main.go`中设置各种私有变量。这些变量用于在版本端点上返回版本信息。一旦编译了二进制文件，就会创建一个包含二进制文件的Docker容器。这允许我们使用非常小的容器镜像，因为Go运行时在二进制文件中是自包含的。然后我们运行容器，同时暴露容器监听HTTP流量的端口。最后，我们在localhost上curl该端口，并看到返回的版本信息。
- en: Orchestration and deployment strategies
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编排和部署策略
- en: Docker makes orchestration and deployment much more simple. In this recipe,
    we'll set up a connection to MongoDB, inserting a document and querying it all
    from Docker containers. This recipe will set up the same environment as the *Using
    NoSQL with MongoDB and mgo* recipe, in [Chapter 5](e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml),
    *All about Databases and Storage*, but will run the application and environment
    inside of containers and will use Docker compose to orchestrate and connect them.
    This can later be used in conjunction with Docker Swarm, an integrated Docker
    tool that allows you to manage a cluster, to create and deploy nodes that can
    be scaled up or down easily, and to manage load balancing ([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)).
    Another good example of container orchestration is Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)),
    a container orchestration framework written by Google using the Go programming
    language.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使得编排和部署变得更加简单。在这个菜谱中，我们将设置一个连接到MongoDB的连接，从Docker容器中插入文档并查询它。这个菜谱将设置与[第5章](e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml)中“所有关于数据库和存储”的*使用NoSQL与MongoDB和mgo*菜谱相同的相同环境，但将在容器内运行应用程序和环境，并使用Docker
    Compose来编排和连接它们。这可以后来与Docker Swarm结合使用，这是一个集成的Docker工具，允许你管理一个集群，创建和部署可以轻松扩展或缩减的节点，并管理负载均衡([https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/))。容器编排的另一个好例子是Kubernetes([https://kubernetes.io/](https://kubernetes.io/))，这是一个由Google使用Go编程语言编写的容器编排框架。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Using containerization with Docker*
    recipe.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考使用Docker进行容器化的*准备工作*部分。
- en: Run the `go get gopkg.in/mgo.v2` command.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `go get gopkg.in/mgo.v2` 命令。
- en: Run the `go get github.com/tools/godep` command.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `go get github.com/tools/godep` 命令。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter10/orchestrate` directory
    and navigate to it.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中，创建 `chapter10/orchestrate` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/orchestrate](https://github.com/agtorre/go-cookbook/tree/master/chapter10/orchestrate)
    or use this as an exercise to write some of your own code.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter10/orchestrate](https://github.com/agtorre/go-cookbook/tree/master/chapter10/orchestrate)
    复制测试或使用此作为练习编写一些你自己的代码。
- en: 'Create a file called `dockerfile` with the following content:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `dockerfile` 的文件，内容如下：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file called `docker-compose.yml` with the following content:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `docker-compose.yml` 的文件，内容如下：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a file called `mongo.go` with the following content:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `mongo.go` 的文件，内容如下：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a `main.go` file with the following content. Ensure that you modify
    the `orchestrate` import to use the path you set up in step 2:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件，内容如下。确保你修改 `orchestrate` 导入以使用步骤 2 中设置的路径：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Navigate back to the starting directory.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到起始目录。
- en: Run the `godep save ./...` command.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `godep save ./...` 命令。
- en: Run the `docker-compose up -d` command.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `docker-compose up -d` 命令。
- en: Run the `docker logs docker_app_1` command.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `docker logs docker_app_1` 命令。
- en: 'You should now see the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下输出：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This configuration is good for local development. Once the `docker-compose up`
    command is run, the local directory is rebuilt, it establishes a connection to
    a MongoDB instance using the latest version and begins operating against it. This
    recipe uses godeps for dependency management so that the entire `GOPATH` environment
    variable doesn't need to be mounted by the `Dockerfile` file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置适合本地开发。一旦运行了 `docker-compose up` 命令，本地目录将被重建，它将使用最新版本建立与 MongoDB 实例的连接，并开始对其操作。这个菜谱使用
    godeps 进行依赖管理，因此不需要通过 `Dockerfile` 文件挂载整个 `GOPATH` 环境变量。
- en: This can provide a good baseline when starting on apps that require connections
    to external services, all of the [Chapter 5](e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml),
    *All about Databases and Storage*, can make use of this approach rather than creating
    a local instance of the database. For production, you likely won't want to run
    your datastorage behind a Docker container, but you'll also generally have static
    host names for configuration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这在开始需要连接到外部服务的应用程序时可以提供一个良好的基线，所有 [第 5 章](e4c2a55e-c570-4490-b981-2685a89be7d2.xhtml)，*关于数据库和存储的一切*，都可以使用这种方法，而不是创建数据库的本地实例。对于生产环境，你可能不希望在
    Docker 容器后面运行数据存储，但你通常也会有静态的主机名用于配置。
- en: Monitoring applications
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控应用程序
- en: There are a variety of ways to monitor Go applications. One of the easiest ways
    is to set up Prometheus, a monitoring application written in Go ([https://prometheus.io](https://prometheus.io)).
    This is an application that polls an endpoint based on your configuration file
    and collects a lot of information about your app, including the number of goroutines,
    memory usage, and much more. This app will use the techniques from the previous
    recipe to set up a Docker environment to host Prometheus and connect to it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 Go 应用程序有多种方法。其中一种最简单的方法是设置 Prometheus，这是一个用 Go 编写的监控应用程序 ([https://prometheus.io](https://prometheus.io))。这是一个根据你的配置文件轮询端点的应用程序，并收集大量关于你的应用程序的信息，包括
    goroutine 的数量、内存使用情况等等。此应用程序将使用前一个菜谱中的技术来设置一个 Docker 环境，以托管 Prometheus 并连接到它。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Using containerization with Docker*
    recipe.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考使用 Docker 容器化的 *Using containerization with Docker* 菜谱中的 *Getting ready* 部分。
- en: Run the `go get github.com/prometheus/client_golang/prometheus/promhttp` command.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `go get github.com/prometheus/client_golang/prometheus/promhttp` 命令。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter10/monitoring` directory
    and navigate to it.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建 `chapter10/monitoring` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/monitoring](https://github.com/agtorre/go-cookbook/tree/master/chapter10/monitoring)
    or use this as an exercise to write some of your own code.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter10/monitoring](https://github.com/agtorre/go-cookbook/tree/master/chapter10/monitoring)
    复制测试或使用此作为练习编写一些自己的代码。
- en: 'Create a file called `Dockerfile` with the following content:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Dockerfile` 的文件，并包含以下内容：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a file called `docker-compose.yml` with the following content:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `docker-compose.yml` 的文件，并包含以下内容：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a file called `main.go` with the following content:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，并包含以下内容：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a file called `prometheus.yml` with the following content:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `prometheus.yml` 的文件，并包含以下内容：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the `godep save ./...` command.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `godep save ./...` 命令。
- en: Run the `docker-compose up -d` command.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `docker-compose up -d` 命令。
- en: 'You should now see the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下内容：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Navigate your browser to `http://localhost:9090/`. You should see a variety
    of metrics related to your app!
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的浏览器导航到 `http://localhost:9090/`。你应该能看到与你的应用程序相关的各种指标！
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Prometheus client handler will return a variety of stats about your application
    to a Prometheus server. This allows you to point multiple Prometheus servers at
    an app without the need to reconfigure or deploy the app. Most of these stats
    are generic and beneficial for things such as detecting memory leaks. A lot of
    other solutions require you to periodically send information to a server instead.
    The next recipe, *Collecting metrics*, will demonstrate how to ship custom metrics
    to the Prometheus server.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus客户端处理程序将返回有关你的应用程序的各种统计信息到Prometheus服务器。这允许你将多个Prometheus服务器指向应用程序，而无需重新配置或部署应用程序。大多数这些统计信息是通用的，对检测内存泄漏等事物有益。许多其他解决方案需要你定期向服务器发送信息。下一个配方
    *收集指标* 将演示如何将自定义指标发送到Prometheus服务器。
- en: Collecting metrics
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集指标
- en: In addition to general information about your app, it can be helpful to emit
    metrics that are app specific. For example, we might want to collect timing data
    or keep track of the number of times an event occurs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于你的应用程序的一般信息之外，发出特定于应用程序的指标可能很有帮助。例如，我们可能想要收集时间数据或跟踪事件发生的次数。
- en: This recipe will use the `github.com/rcrowley/go-metrics` package to collect
    metrics and expose them via an endpoint. There are various exporter tools to export
    metrics to places such as Prometheus and InfluxDB, also written in Go.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将使用 `github.com/rcrowley/go-metrics` 包来收集指标并通过端点公开它们。有各种导出工具可以将指标导出到Prometheus和InfluxDB等地方，这些工具也用Go编写。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Configure your environment according to these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Using service discovery with Consul*
    recipe in this chapter.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章中 *使用Consul进行服务发现* 配方的 *准备就绪* 部分。
- en: Run the `go get github.com/rcrowley/go-metrics` command.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get github.com/rcrowley/go-metrics` 命令。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter10/metrics` directory
    and navigate to it.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建 `chapter10/metrics` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter10/metrics](https://github.com/agtorre/go-cookbook/tree/master/chapter10/metrics),
    or use this as an exercise to write some of your own code.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter10/metrics](https://github.com/agtorre/go-cookbook/tree/master/chapter10/metrics)
    复制测试或使用此作为练习编写一些自己的代码。
- en: 'Create a file called `handler.go` with the following content:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `handler.go` 的文件，并包含以下内容：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a file called `report.go` with the following content:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `report.go` 的文件，并包含以下内容：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `channels` import to use the path you set up in step 2:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，并包含以下内容。确保将 `channels` 导入修改为你在第二步中设置的路径：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run `go run main.go`. Alternatively, you may also run the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。或者，你也可以运行以下命令：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should now see the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该看到以下内容：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the following commands from a separate shell:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的shell中运行以下命令：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Try hitting all the endpoints a few more times to see how they change.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试多次访问所有端点，看看它们是如何变化的。
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The gometrics keeps all of your metrics in a registry. Once it's set up, you
    can use any of the metric omit options, such as counter or timer, and it will
    store this update in the registry. There are multiple exporters that will export
    metrics to third-party tools. In our case, we set up a handler that omits all
    the metrics in the JSON format.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Gometrics 将所有度量存储在一个注册表中。一旦设置好，你可以使用任何度量选项，例如计数器或计时器，它将这个更新存储在注册表中。有多个导出器可以将度量导出到第三方工具。在我们的案例中，我们设置了一个处理器，将所有度量以
    JSON 格式导出。
- en: We set up three handlers--one that increments a counter, one that records the
    time to exit the handler, and one that prints a report (while also incrementing
    an additional counter). The `GetOrRegister` functions are useful for atomically
    getting or creating a metric emitter if it doesn't currently exist in a thread-safe
    way. Alternatively, you can register everything once in advance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了三个处理器——一个用于增加计数器，一个用于记录退出处理器的时间，还有一个用于打印报告（同时也会增加一个额外的计数器）。`GetOrRegister`
    函数在原子操作中获取或创建一个度量发射器非常有用，如果它当前不存在于线程安全的方式中。或者，你也可以预先一次性注册所有内容。
