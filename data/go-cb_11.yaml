- en: Reactive Programming and Data Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程和数据流
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Goflow for dataflow programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goflow 用于数据流编程
- en: Reactive programming with RxGo
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxGo 进行响应式编程
- en: Using Kafka with Sarama
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sarama 与 Kafka
- en: Using async producers with Kafka
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kafka 的异步生产者
- en: Connecting Kafka to Goflow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Kafka 连接到 Goflow
- en: Writing a GraphQL server in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中编写 GraphQL 服务器
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will discuss reactive programming design patterns in Go. Reactive
    programming is a programming concept that focuses on data streams and the propagation
    of change ([https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)).
    Technologies such as Kafka allow you to quickly produce or consume a stream of
    data. As a result, these technologies are a natural fit for one another. In the
    *Connecting Kafka to Goflow* recipe, we'll explore combining a `kafka` message
    queue with `goflow` to show a practical example of using these technologies. This
    chapter will also explore various ways to connect with Kafka and use it to process
    messages. Lastly, this chapter will demonstrate how to create a basic `graphql`
    server in Go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论 Go 中的响应式编程设计模式。响应式编程是一种编程概念，它关注数据流和变化的传播（[https://en.wikipedia.org/wiki/Reactive_programming](https://en.wikipedia.org/wiki/Reactive_programming)）。像
    Kafka 这样的技术允许你快速产生或消费数据流。因此，这些技术彼此之间是自然匹配的。在 *将 Kafka 连接到 Goflow* 的配方中，我们将探讨将
    `kafka` 消息队列与 `goflow` 结合起来，以展示使用这些技术的实际示例。本章还将探讨与 Kafka 连接的各种方式，并使用它来处理消息。最后，本章将演示如何在
    Go 中创建一个基本的 `graphql` 服务器。
- en: Goflow for dataflow programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goflow 用于数据流编程
- en: The `github.com/trustmaster/goflow` package is useful for creating dataflow-based
    applications. It tries to abstract concepts so that you can write components and
    connect them together using a custom network. This recipe will recreate the application
    discussed in [Chapter 8](ab72719b-7fbf-4127-a091-b4ca5cf59775.xhtml), *Testing*,
    but it will do so using the `goflow` package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/trustmaster/goflow` 包对于创建基于数据流的应用程序很有用。它试图抽象概念，以便您可以使用自定义网络编写组件并将它们连接起来。这个配方将重新创建第
    8 章 [Testing](ab72719b-7fbf-4127-a091-b4ca5cf59775.xhtml) 中讨论的应用程序，但它将使用 `goflow`
    包来完成。'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Download and install Go on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install)
    and configure your `GOPATH` environment variable.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://golang.org/doc/install](https://golang.org/doc/install) 下载并安装 Go
    到您的操作系统上，并配置您的 `GOPATH` 环境变量。
- en: Open a terminal/console application.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端/控制台应用程序。
- en: Navigate to your `GOPATH/src` and create a project directory, for example, `$GOPATH/src/github.com/yourusername/customrepo`.
    All code will be run and modified from this directory.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的 `GOPATH/src` 并创建一个项目目录，例如，`$GOPATH/src/github.com/yourusername/customrepo`。所有代码都将从这个目录运行和修改。
- en: Optionally, install the latest tested version of the code using the `go get
    github.com/agtorre/go-cookbook/` command.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，使用 `go get github.com/agtorre/go-cookbook/` 命令安装代码的最新测试版本。
- en: Run the `go get github.com/trustmaster/goflow` command.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get github.com/trustmaster/goflow` 命令。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These steps cover writing and running your application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter11/goflow` directory
    and navigate to it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端/控制台应用程序中创建 `chapter11/goflow` 目录并进入它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/goflow](https://github.com/agtorre/go-cookbook/tree/master/chapter11/goflow)
    or use this as an exercise to write some of your own.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter11/goflow](https://github.com/agtorre/go-cookbook/tree/master/chapter11/goflow)
    复制测试或将其用作练习来编写您自己的测试。
- en: 'Create a file called `components.go` with the following content:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `components.go` 的文件，内容如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called `network.go` with the following content:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `network.go` 的文件，内容如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并进入它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `goflow` import to use the path you set up in step 2:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，内容如下。确保将 `goflow` 导入修改为步骤 2 中设置的路径：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run `go run main.go`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should now see the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下输出：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `github.com/trustmaster/goflow` package works by defining a network/graph,
    registering some components, and then wiring them together. This can feel a bit
    error-prone since these are described using strings, but usually this will fail
    early in runtime until it's set up correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/trustmaster/goflow` 包通过定义一个网络/图、注册一些组件，然后将它们连接起来来工作。由于这些是用字符串描述的，所以这可能会感觉有点容易出错，但通常在运行时设置正确之前，这会在早期失败。'
- en: In this recipe, we set up two components, one that base64 encodes an incoming
    string and one that prints anything passed to it. We connect it to an in channel
    that is initialized in `main.go`, and anything passed onto that channel will flow
    through our pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们设置了两个组件，一个用于对传入的字符串进行 base64 编码，另一个用于打印传递给它的任何内容。我们将其连接到一个在 `main.go`
    中初始化的输入通道，任何传递到该通道的内容都将通过我们的管道流动。
- en: A lot of the emphasis of this approach is on ignoring the internals of what's
    going on. We treat everything like a connected black box and let `goflow` do the
    rest. You can see in this recipe how small the code is to accomplish this pipeline
    of tasks and that we have fewer knobs to control the number of workers, among
    other things.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的重点很多是忽略正在发生的事情的内部。我们像对待一个连接的黑盒一样对待一切，让 `goflow` 做其余的工作。您可以从这个食谱中看到完成这个任务管道所需的代码有多小，以及我们控制工人数量的旋钮更少，等等。
- en: Reactive programming with RxGo
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxGo 进行响应式编程
- en: ReactiveX ([http://reactivex.io/](http://reactivex.io/)) is an API for programming
    with observable streams. RxGo ([github.com/reactivex/rxgo](http://github.com/reactivex/rxgo))
    is a library to support this pattern in Go. It helps you to think of your application
    as a big stream of events that responds in different ways when those events occur.
    This recipe will create an application that uses this approach to process different
    wines. Ideally, this approach can be tied to wine data or wine APIs and can aggregate
    information about wine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveX ([http://reactivex.io/](http://reactivex.io/)) 是一个用于使用可观察流进行编程的 API。RxGo
    ([github.com/reactivex/rxgo](http://github.com/reactivex/rxgo)) 是一个库，用于在 Go 中支持这种模式。它帮助您将应用程序视为一个大的事件流，当这些事件发生时，它会以不同的方式做出响应。这个食谱将创建一个使用这种方法处理不同葡萄酒的应用程序。理想情况下，这种方法可以与葡萄酒数据或葡萄酒
    API 相关联，并汇总有关葡萄酒的信息。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Configure your environment according to these steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置您的环境：
- en: Refer to the *Getting ready* section of the *Goflow for dataflow programming*
    recipe in this chapter.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章中 *Goflow for dataflow programming* 食谱的 *准备就绪* 部分。
- en: Run the `go get github.com/reactivex/rxgo` command.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get github.com/reactivex/rxgo` 命令。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter11/reactive` directory
    and navigate to it.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端/控制台应用程序中，创建 `chapter11/reactive` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/reactive](https://github.com/agtorre/go-cookbook/tree/master/chapter11/reactive)
    or use this as an exercise to write some of your own.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter11/reactive](https://github.com/agtorre/go-cookbook/tree/master/chapter11/reactive)
    复制测试或将其作为练习编写一些自己的测试。
- en: 'Create a file called `wine.go` with the following content:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `wine.go` 的文件，内容如下：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `exec.go` 的文件，内容如下：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `reactive` import to use the path you set up in step 2:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，内容如下。确保您将 `reactive` 导入修改为在步骤 2 中设置的路径：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run `go run main.go`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。
- en: 'You may also run the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should now see the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: RxGo works by abstracting a source stream, which can be an array or a channel,
    allowing you to aggregate streams, and finally creating observers that handle
    events. These can handle errors or data. RxGo uses an `interface{}` type for its
    argument so that you can pass in arbitrary values. As a result, you must use reflection
    in order to convert incoming data to its correct type. This can be tricky if you
    need to return errors on your observers. In addition, the added reflection can
    be costly in terms of performance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: RxGo 通过抽象源流（可以是数组或通道）来工作，允许你聚合流，并最终创建处理事件的观察者。这些可以处理错误或数据。RxGo 使用 `interface{}`
    类型作为其参数，这样你可以传递任意值。因此，你必须使用反射来将传入的数据转换为正确的类型。如果你需要在观察者上返回错误，这可能很棘手。此外，增加的反射可能在性能上造成开销。
- en: Lastly, you must modify some shared state, either global or within a local closure,
    which will be used at the end. In our case, we have a `Results` type, which is
    a map with a key of the year and the value of the aggregate score and number of
    samples. This allows us to emit averages about each year. If we had used wine
    names instead of types, we could also aggregate by types. This library is still
    in its early stages. In many ways, you can achieve the same effect using basic
    Go channels. It helps to illustrate how some of these ideas may translate to Go.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须修改一些共享状态，无论是全局的还是局部闭包内的，这些状态将在最后使用。在我们的例子中，我们有一个 `Results` 类型，它是一个键为年份、值为总分和样本数量的映射。这使我们能够发出关于每年的平均值。如果我们使用酒名而不是类型，我们也可以按类型进行聚合。这个库还处于早期阶段。在许多方面，你可以使用基本的
    Go 通道达到相同的效果。这有助于说明这些想法如何转化为 Go。
- en: Using Kafka with Sarama
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sarama 与 Kafka
- en: Kafka is a popular distributed message queue with a lot of advanced functions
    for building distributed systems. This recipe will show how to write to a Kafka
    topic using a synchronous producer and how to consume the same topic using a partition
    consumer. This recipe will not explore different configurations of Kafka as that
    is a much wider topic, but I suggest beginning at [https://kafka.apache.org/intro](https://kafka.apache.org/intro).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka 是一个流行的分布式消息队列，具有许多用于构建分布式系统的先进功能。本菜谱将展示如何使用同步生产者写入 Kafka 主题，以及如何使用分区消费者消费相同的主题。本菜谱不会探讨
    Kafka 的不同配置，因为这是一个更广泛的话题，但我建议从 [https://kafka.apache.org/intro](https://kafka.apache.org/intro)
    开始。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Configure your environment according to these steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Goflow for dataflow programming*
    recipe in this chapter.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章中 *Goflow for dataflow programming* 菜单的 *Getting ready* 部分。
- en: Install Kafka using the steps mentioned at [https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_steps.htm](https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_steps.htm).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下步骤安装 Kafka：[https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_steps.htm](https://www.tutorialspoint.com/apache_kafka/apache_kafka_installation_steps.htm)。
- en: Alternatively, you can also access [https://github.com/spotify/docker-kafka](https://github.com/spotify/docker-kafka).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，你也可以访问 [https://github.com/spotify/docker-kafka](https://github.com/spotify/docker-kafka)。
- en: Run the `go get gopkg.in/Shopify/sarama.v1` command.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get gopkg.in/Shopify/sarama.v1` 命令。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These steps cover writing and running your application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序的过程：
- en: From your terminal/console application, create the `chapter11/synckafka` directory
    and navigate to it.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中创建 `chapter11/synckafka` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/synckafka](https://github.com/agtorre/go-cookbook/tree/master/chapter11/synckafka)
    or use this as an exercise to write some of your own.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter11/synckafka](https://github.com/agtorre/go-cookbook/tree/master/chapter11/synckafka)
    复制测试或将其作为练习来编写一些自己的测试。
- en: Ensure that Kafka is up and running on `localhost:9092`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Kafka 在 `localhost:9092` 上运行。
- en: 'Create a file called `main.go` in a directory named `consumer` with the following
    content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `consumer` 的目录中创建一个名为 `main.go` 的文件，内容如下：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a file called `main.go` in a directory named `producer` with the following
    content:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `producer` 的目录中创建一个名为 `main.go` 的文件，内容如下：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run `go run consumer/main.go`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run consumer/main.go`。
- en: In a separate terminal, run `go run producer/main.go`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中运行 `go run producer/main.go`。
- en: 'In the producer terminal, you should see the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产者终端中，你应该看到以下内容：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the consumer terminal, you should see this:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消费者终端中，你应该看到以下内容：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，向上导航一个目录并运行 `go test`。确保所有测试通过。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe demonstrates passing simple messages via Kafka. More complex methods
    should use a serialization format such as `json`, `gob`, `protobuf`, or others.
    The producer can send a message to Kafka synchronously through `sendMessage`.
    This does not the handle cases well where the Kafka cluster is down and may result
    in a hung process for these cases. This is important to consider for applications
    such as web handlers as it may result in timeouts and hard dependencies on the
    Kafka cluster.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱演示了通过 Kafka 传递简单消息。更复杂的方法应使用如 `json`、`gob`、`protobuf` 或其他序列化格式。生产者可以通过 `sendMessage`
    同步地将消息发送到 Kafka。这并不很好地处理 Kafka 集群宕机的情况，可能会导致进程挂起。对于像网络处理器这样的应用程序来说，这是一个重要的考虑因素，因为它可能导致超时和对
    Kafka 集群的硬依赖。
- en: Assuming the message queues correctly, our consumer will observe the Kafka stream
    and do something with the results. Previous recipes in this chapter might make
    use of this stream to do some additional processing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设消息队列正确无误，我们的消费者将观察 Kafka 流并处理结果。本章前面的食谱可能已经使用此流进行一些额外的处理。
- en: Using async producers with Kafka
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kafka 的异步生产者
- en: It's often useful to not wait for a Kafka producer to complete before moving
    on to the next task. In cases like this, you can use an async producer. These
    producers take Sarama messages on a channel and have methods to return a success/error
    channel that can be checked separately.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行下一项任务之前，通常不需要等待 Kafka 生产者完成。在这种情况下，你可以使用异步生产者。这些生产者从 Sarama 消息通道接收消息，并具有返回可以单独检查的成功/错误通道的方法。
- en: In this recipe, we'll create a go routine that will handle success and failure
    messages while we allow a handler to queue messages to send regardless of the
    result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个 go 线程来处理成功和失败的消息，同时允许处理器在结果未知的情况下排队发送消息。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备阶段
- en: Refer to the *Getting ready* section of the *Using Kafka with Sarama* recipe.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 参考使用 Sarama 与 Kafka 的 *准备阶段* 部分。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These steps cover writing and running your application:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter11/asyncsarama` directory
    and navigate to it.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端/控制台应用程序中，创建 `chapter11/asyncsarama` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/asyncsarama](https://github.com/agtorre/go-cookbook/tree/master/chapter11/asyncsarama)
    or use this as an exercise to write some of your own.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter11/asyncsarama](https://github.com/agtorre/go-cookbook/tree/master/chapter11/asyncsarama)
    复制测试或将其作为练习来编写你自己的测试。
- en: Ensure that Kafka is up and running on `localhost:9092`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Kafka 在 `localhost:9092` 上运行。
- en: Copy the consumer directory from the previous recipe.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个食谱复制消费者目录。
- en: Create a directory named `producer` and navigate to it.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `producer` 的目录并导航到它。
- en: 'Create a file called `producer.go`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `producer.go` 的文件：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a file called `handler.go`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `handler.go` 的文件：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a file called `main.go`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the `go build` command.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 命令。
- en: Navigate up a directory.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向上导航一个目录。
- en: Run `go run consumer/main.go`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run consumer/main.go`。
- en: In a separate terminal from the same directory, run `./producer/producer`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录下的另一个终端中，运行 `./producer/producer`。
- en: 'In a third terminal, run the following commands:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三个终端中，运行以下命令：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the producer terminal, you should see the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者终端中，你应该看到以下内容：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the consumer terminal, you should see this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消费者终端中，你应该看到以下内容：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure all tests pass.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，向上导航一个目录并运行 `go test`。确保所有测试通过。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our modifications in this chapter were all made to the producer. This time,
    we created a separate go routine to handle successes and errors. If these are
    left unhandled, your application will deadlock. Next, we attached our producer
    to a handler and we emit messages on it whenever a message is received via a `GET`
    call to the handler.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有修改都是针对生产者进行的。这次，我们创建了一个单独的 go 线程来处理成功和错误。如果这些没有被处理，你的应用程序将发生死锁。接下来，我们将我们的生产者附加到处理器，并在处理器通过
    `GET` 调收到的消息时在其上发出消息。
- en: The handler will immediately return success upon sending the message regardless
    of its response. If this is not acceptable, a synchronous approach should be used
    instead. In our case, we're okay with later processing success and errors separately.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论响应如何，处理程序在发送消息后会立即返回成功。如果这不可接受，应使用同步方法。在我们的情况下，我们接受稍后分别处理成功和错误。
- en: Lastly, we curl our endpoint with a few different messages and you can see them
    flow from the handler to where they're eventually printed by the Kafka consumer
    we wrote in the previous section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用几个不同的消息curl我们的端点，您可以看到它们从处理程序流向我们之前章节中编写的Kafka消费者最终打印的地方。
- en: Connecting Kafka to Goflow
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Kafka连接到Goflow
- en: This recipe will combine a Kafka consumer with a Goflow pipeline. As our consumer
    receives messages from Kafka, it will run `strings.ToUpper()` on them and then
    print the results. These naturally pair as Goflow is designed to operate on an
    incoming stream, which is exactly what Kafka provides us.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将结合一个Kafka消费者和一个Goflow管道。随着我们的消费者从Kafka接收消息，它将对它们运行`strings.ToUpper()`，然后打印结果。这些自然地配对，因为Goflow被设计为在传入的流上操作，这正是Kafka为我们提供的。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Refer to the *Getting ready* section of the *Using Kafka with Sarama* recipe*.*
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参考配方*使用Sarama的Kafka*中的*准备就绪*部分*.*。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These steps cover writing and running your application:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行您的应用程序：
- en: From your terminal/console application, create the `chapter11/kafkaflow` directory
    and navigate to it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端/控制台应用程序中，创建`chapter11/kafkaflow`目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/kafkaflow](https://github.com/agtorre/go-cookbook/tree/master/chapter11/kafkaflow)
    or use this as an exercise to write some of your own.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/agtorre/go-cookbook/tree/master/chapter11/kafkaflow](https://github.com/agtorre/go-cookbook/tree/master/chapter11/kafkaflow)复制测试或将其用作练习来编写一些自己的测试。
- en: Ensure that Kafka is up and running on `localhost:9092`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Kafka在`localhost:9092`上运行。
- en: 'Create a file called `components.go` with the following content:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`components.go`的文件，内容如下：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a file called `network.go` with the following content:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`network.go`的文件，内容如下：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file called `main.go` in a directory named `consumer` with the following
    content:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`consumer`的目录中创建一个名为`main.go`的文件，内容如下：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Copy the consumer directory from the *Using Kafka with Saram* recipe.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*使用Sarama的Kafka*配方复制消费者目录。
- en: Run `go run consumer/main.go`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run consumer/main.go`。
- en: In a separate terminal, run `go run producer/main.go`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中运行`go run producer/main.go`。
- en: 'In the producer terminal, you should now see the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产者终端中，您现在应该看到以下内容：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the consumer terminal, you should see the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者终端中，您应该看到以下内容：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请向上移动一个目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe combines ideas from previous recipes in this chapter. Like previous
    recipes, we set up a Kafka consumer and producer. This recipe uses the synchronous
    producer from the *Using Kafka With Sarama* recipe, but could have also used an
    asynchronous producer instead. Once a message is received, we enqueue it on an
    in channel just like we did in the *Goflow for dataflow programming* recipe*.*
    We modify the components from this recipe to uppercase our incoming string rather
    than base64 encoding it. We reuse the print components and the resultant network
    configuration is similar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方结合了本章中先前配方中的想法。像之前的配方一样，我们设置了一个Kafka消费者和生产者。这个配方使用了*使用Sarama的Kafka*配方中的同步生产者，但也可以使用异步生产者。一旦收到消息，我们就像在*Goflow数据流编程*配方中做的那样，将其入队到输入通道中。我们修改了这个配方中的组件，将传入的字符串转换为大写，而不是进行base64编码。我们重用了打印组件，并且最终的网络配置相似。
- en: The end result is that all messages received through the Kafka consumer are
    transported into our flow-based work pipeline to be operated on. This allows us
    to instrument our pipeline components to be modular and reusable, and we can use
    the same component multiple times in different configurations. Similarly, we'll
    receive traffic from any producer that writes to Kafka, so we can multiplex producers
    into a single data stream.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，通过Kafka消费者接收的所有消息都被传输到我们的基于流的作业管道中进行操作。这使我们能够将管道组件模块化和可重用，我们可以在不同的配置中使用相同的组件多次。同样，我们将接收任何写入Kafka的生产者的流量，因此我们可以将生产者多路复用到单个数据流中。
- en: Writing a GraphQL server in Go
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go编写GraphQL服务器
- en: GraphQL is an alternative to REST, created by Facebook ([http://graphql.org/](http://graphql.org/)).
    This technology allows a server to implement and publish a schema and the clients
    then can ask for the information they need rather than understanding and making
    use of various API endpoints.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是 Facebook 创建的 REST 的替代品 ([http://graphql.org/](http://graphql.org/))。这项技术允许服务器实现并发布一个模式，然后客户端可以请求他们所需的信息，而不是理解和利用各种
    API 端点。
- en: For this recipe, we'll create a `Graphql` schema that represents a deck of playing
    cards. We'll expose one resource card, which can be filtered by suit and value.
    Alternatively, it can return all the cards in the deck if no arguments are specified.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个 `Graphql` 模式，它代表一副扑克牌。我们将公开一个资源卡片，可以根据花色和值进行过滤。如果没有指定参数，它还可以返回牌组中的所有卡片。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Configure your environment according to these steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下步骤配置你的环境：
- en: Refer to the *Getting ready* section of the *Goflow for dataflow programming*
    recipe in this chapter.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考本章中 *Goflow for dataflow programming* 菜单的 *准备就绪* 部分。
- en: Run the `go get github.com/graphql-go/graphql` command.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go get github.com/graphql-go/graphql` 命令。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your terminal/console application, create the `chapter11/graphql` directory
    and navigate to it.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的终端/控制台应用程序中创建 `chapter11/graphql` 目录并导航到它。
- en: Copy tests from [https://github.com/agtorre/go-cookbook/tree/master/chapter11/graphql](https://github.com/agtorre/go-cookbook/tree/master/chapter11/graphql)
    or use this as an exercise to write some of your own.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://github.com/agtorre/go-cookbook/tree/master/chapter11/graphql](https://github.com/agtorre/go-cookbook/tree/master/chapter11/graphql)
    复制测试或将其作为练习编写一些自己的测试。
- en: Create and navigate to the `cards` directory.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并导航到 `cards` 目录。
- en: 'Create a file called `card.go` with the following content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `card.go` 的文件，内容如下：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a file called `type.go`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `type.go` 的文件：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a file called `resolve.go`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `resolve.go` 的文件：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a file called `schema.go`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `schema.go` 的文件：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Navigate back to the `graphql` directory.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `graphql` 目录。
- en: Create a new directory named `example` and navigate to it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `example` 的新目录并导航到它。
- en: 'Create a file named `main.go` with the following content. Ensure that you modify
    the `cards` import to use the path you set up in step 2:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件，内容如下。确保你修改 `cards` 导入以使用步骤 2 中设置的路径：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run `go run main.go`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go run main.go`。
- en: 'You may also run the following command:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should see the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Test some additional queries, such as the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试一些额外的查询，例如以下内容：
- en: '`cards(suit: "Spades")`'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cards(suit: "Spades")`'
- en: '`cards(value: "3", suit:"Diamonds")`'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cards(value: "3", suit:"Diamonds")`'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请向上移动一个目录并运行 `go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `cards.go` file defines a `card` object and initializes the base deck in
    a global variable called cards. This state could also be held in long-term storage
    such as a database. We then define `CardType` in `types.go` that allows `graphql`
    to resolve card objects to responses. Next, we jump into `resolve.go`, where we
    define how to filter cards by value and type. This `Resolve` function will be
    used by the final schema, which is defined in `schema.go`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`cards.go` 文件定义了一个 `card` 对象，并在名为 `cards` 的全局变量中初始化基础牌组。这种状态也可以存储在长期存储中，如数据库。然后我们在
    `types.go` 中定义 `CardType`，允许 `graphql` 将卡片对象解析为响应。接下来，我们跳转到 `resolve.go`，在那里我们定义如何根据值和类型过滤卡片。这个
    `Resolve` 函数将被最终的模式使用，该模式在 `schema.go` 中定义。'
- en: For example, you would modify the `Resolve` function in this recipe in order
    to retrieve data from a database. Lastly, we load the schema and run a query against
    it. It's a small modification to mount our schema onto a rest endpoint, but for
    brevity, this recipe just runs a hardcoded query. For more information about `GraphQL`
    queries, visit [http://graphql.org/learn/queries/](http://graphql.org/learn/queries/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能需要修改这个菜谱中的 `Resolve` 函数以从数据库中检索数据。最后，我们加载模式并对它运行查询。将我们的模式挂载到 REST 端点是一个小的修改，但为了简洁，这个菜谱只是运行了一个硬编码的查询。有关
    `GraphQL` 查询的更多信息，请访问 [http://graphql.org/learn/queries/](http://graphql.org/learn/queries/)。
