- en: Chapter 1. A First Step in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Go的第一步
- en: In the first chapter of the book, you will be introduced to Go and take a tour
    of the features that have made the language a favorite among its adopters. The
    start of the chapter provides the motivation behind the Go programming language.
    If you are impatient, however, you are welcome to skip to any of the other topics
    and learn how to write your first Go program. Finally, the *Go in a nutshell*
    section provides a high-level summary of the characteristics of the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，您将了解Go并游览使该语言成为其采用者喜爱的特性的功能。本章的开始提供了Go编程语言的动机。如果您不耐烦，欢迎您跳转到任何其他主题，学习如何编写您的第一个Go程序。最后，“Go概览”部分提供了语言特性的高级总结。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: The Go programming language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编程语言
- en: Playing with Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转Go
- en: Installing Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Go
- en: Your first Go program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个Go程序
- en: Go in a nutshell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go概览
- en: The Go programming language
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go编程语言
- en: 'Since the invention of the C language in the early 1970s by *Dennis Ritchie*
    at Bell Labs, the computing industry has produced many popular languages that
    are based directly on (or have borrowed ideas from) its syntax. Commonly known
    as the C-family of languages, they can be split into two broad evolutionary branches.
    In one branch, derivatives such as C++, C#, and Java have evolved to adopt a strong
    type system, object orientation, and the use of compiled binaries. These languages,
    however, tend to have a slow build-deploy cycle and programmers are forced to
    adopt a complex object-oriented type system to attain runtime safety and speed
    of execution:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自从1970年代初在贝尔实验室由*Dennis Ritchie*发明C语言以来，计算行业已经产生了许多直接基于（或借鉴了其语法）的流行语言。通常被称为C语言家族，它们可以分为两个广泛的进化分支。在一个分支中，如C++、C#和Java等衍生语言已经发展到采用强类型系统、面向对象和使用编译二进制文件。然而，这些语言往往具有缓慢的构建-部署周期，程序员被迫采用复杂的面向对象类型系统以获得运行时安全性和执行速度：
- en: '![The Go programming language](img/00001.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Go编程语言](img/00001.jpeg)'
- en: In the other evolutionary linguistic branch are languages such as Perl, Python,
    and JavaScript that are described as dynamic languages for their lack of type
    safety formalities, use of lightweight scripting syntax, and code interpretation
    instead of compilation. Dynamic languages have become the preferred tool for web
    and cloud scale development where speed and ease of deployment are valued over
    runtime safety. The interpreted nature of dynamic languages means, however, they
    generally run slower than their compiled counterparts. In addition, the lack of
    type safety at runtime means the correctness of the system scales poorly as the
    application grows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他进化语言分支中，有诸如Perl、Python和JavaScript等语言，它们因其缺乏类型安全形式、使用轻量级脚本语法以及代码解释而非编译而被描述为动态语言。动态语言已成为网络和云规模开发的优先工具，在这些领域，速度和部署的便捷性比运行时安全性更重要。然而，动态语言的解释性质意味着它们通常比编译型语言运行得慢。此外，运行时缺乏类型安全性意味着随着应用程序的增长，系统的正确性扩展得不好。
- en: 'Go was created as a system language at Google in 2007 by *Robert Griesemer*,
    *Rob Pike*, and *Ken Thomson* to handle the needs of application development.
    The designers of Go wanted to mitigate the issues with the aforementioned languages
    while creating a new language that is simple, safe, consistent, and predictable.
    As Rob Pike puts it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go是在2007年由*Robert Griesemer*、*Rob Pike*和*Ken Thomson*在Google创建的系统语言，用于处理应用程序开发的需求。Go的设计者希望减轻上述语言的问题，同时创建一个简单、安全、一致且可预测的新语言。正如Rob
    Pike所说：
- en: '*"Go is an attempt to combine the safety and performance of a statically-typed
    language with the expressiveness and convenience of a dynamically-typed interpreted
    language."*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Go是尝试将静态类型语言的安全性和性能与动态类型解释语言的表达性和便利性相结合。"*'
- en: 'Go borrows ideas from different languages that came before it, including:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go借鉴了之前出现的不同语言的理念，包括：
- en: Simplified but concise syntax that is fun and easy to use
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简洁但易于使用的语法
- en: A type of system that feels more like a dynamic language
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种感觉更像动态语言的系统类型
- en: Support for object-oriented programming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对面向对象编程的支持
- en: Statically typed for compilation and runtime safety
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型，用于编译和运行时安全性
- en: Compiled to native binaries for fast runtime execution
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译成本地二进制文件，以实现快速的运行时执行
- en: Near-zero compilation time that feels more like an interpreted language
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎零编译时间，感觉更像解释型语言
- en: A simple concurrency idiom to leverage multi-core, multi-chip machines
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的并发惯用语，以利用多核、多芯片机器
- en: A garbage collector for safe and automatic memory management
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于安全自动内存管理的垃圾回收器
- en: The remainder of this chapter will walk you through an introductory set of steps
    that will give you a preview of the language and get you started with building
    and running your first Go program. It is a precursor to the topics that are covered
    in detail in the remaining chapters of the book. You are welcome to skip to other
    chapters if you already have a basic understanding of Go.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将引导你通过一系列入门步骤，让你预览该语言，并开始构建和运行你的第一个 Go 程序。这是本书剩余章节详细讨论的主题的先导。如果你已经对 Go
    有基本的了解，欢迎跳转到其他章节。
- en: Playing with Go
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转 Go
- en: 'Before we jump head-first into installing and running Go tools on your local
    machine, let us take a look at the **Go Playground**. The creators of the language
    have made available a simple way to familiarize yourself with the language without
    installing any tools. Known as the Go Playground, it is a web-based tool, accessible
    from [https://play.golang.org/](https://play.golang.org/), that uses an editor
    metaphor to let developers test their Go skills by writing code directly within
    the web browser window. The Playground gives its users the ability to compile
    and run their code on Google''s remote servers and get immediate results as shown
    in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们一头扎进在本地机器上安装和运行 Go 工具之前，让我们先看看**Go 演练场**。语言的创造者提供了一种简单的方法，让你在不安装任何工具的情况下熟悉语言。被称为
    Go 演练场，这是一个基于网络的工具，可以通过[https://play.golang.org/](https://play.golang.org/)访问，它使用编辑器隐喻，让开发者可以在网页浏览器窗口中直接编写代码来测试他们的
    Go 技能。演练场允许用户在 Google 的远程服务器上编译和运行他们的代码，并立即获得以下截图所示的结果：
- en: '![Playing with Go](img/00002.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![玩转 Go](img/00002.jpeg)'
- en: 'The editor is basic, as it is meant to be used as a learning tool and a way
    to share code with others. The Playground includes practical features such as
    line numbers and formatting to ensure your code remains readable as it goes beyond
    a few lines long. Since this is a free service that consumes real compute resources,
    Google understandably imposes a few limitations on what can be done with Playground:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器很简单，因为它旨在用作学习工具和与他人分享代码的方式。演练场包括诸如行号和格式化等实用功能，以确保代码在超过几行长时仍然可读。由于这是一个消耗真实计算资源的免费服务，Google
    理所当然地对可以在演练场中完成的事情施加了一些限制：
- en: You are restricted on the amount of memory your code will consume
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你对代码消耗的内存量有限制
- en: Long-running programs will be killed
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时间长的程序将被终止
- en: Access to files is simulated with an in-memory filesystem.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件访问通过内存文件系统模拟。
- en: Network access is simulated against the loopback interface only
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络访问仅模拟回环接口
- en: No IDE required
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不需要 IDE
- en: Besides the Go Playground, how is one supposed to write Go code anyway? Writing
    Go does not require a fancy **Integrated Development Environment** (**IDE**).
    As a matter of fact, you can get started writing your simple Go programs with
    your favorite plain text editor that is bundled with your OS. There are, however,
    Go plugins for most major text editors (and full-blown IDEs) such as Atom, Vim,
    Emacs, Microsoft Code, IntelliJ, and many others. There is a complete list of
    editors and IDE plugins for Go which can be found at [https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Go 演练场，人们应该如何编写 Go 代码呢？编写 Go 代码不需要花哨的**集成开发环境**（**IDE**）。实际上，你可以使用操作系统捆绑的喜欢的纯文本编辑器开始编写简单的
    Go 程序。然而，大多数主要的文本编辑器（以及完整的 IDE）都有 Go 插件，例如 Atom、Vim、Emacs、Microsoft Code、IntelliJ
    以及许多其他编辑器。Go 的编辑器和 IDE 插件完整列表可以在[https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins)找到。
- en: Installing Go
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Go
- en: 'To start programming with Go on your local machine you will need to install
    the **Go Toolchain** on your computer. At the time of writing, Go comes ready
    to be installed on the following major OS platforms:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地机器上使用 Go 进行编程，你需要在计算机上安装**Go 工具链**。在撰写本文时，Go 已经准备好可以安装在以下主要操作系统平台上：
- en: Linux
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: FreeBSD Unix
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD Unix
- en: Mac OSX
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac OSX
- en: Windows
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: The official installation packages are all available for 32-bit and 64-bit Intel-based
    architectures. There are also official binary releases that are available for
    ARM architectures as well. As Go grows in popularity, there will certainly be
    more binary distribution choices made available in the future.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的安装包适用于所有基于32位和64位Intel架构的系统。同时，也有适用于ARM架构的官方二进制发布版本。随着Go语言的流行，未来肯定会有更多的二进制分发选项可供选择。
- en: 'Let us skip the detailed installation instructions as they will certainly change
    by the time you read this. Instead, you are invited to visit [http://golang.org/doc/install](http://golang.org/doc/install)
    and follow the directions given for your specific platform. Once completed, be
    sure to test your installation is working before continuing to use the following
    command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳过详细的安装说明，因为它们在你阅读时肯定会发生变化。相反，我们邀请你访问[http://golang.org/doc/install](http://golang.org/doc/install)并遵循针对你特定平台的指示。完成后，务必在继续使用以下命令之前测试你的安装是否正常工作。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous command should print the version number, target OS, and the machine
    architecture where Go and its tools are installed. If you do not get an output
    similar to that preceding command, ensure to add the path of the Go binaries to
    your OS's execution `PATH` environment variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令应该会打印出Go及其工具安装的版本号、目标操作系统和机器架构。如果你没有得到与前面命令类似的输出，请确保将Go二进制文件的路径添加到你的操作系统的执行`PATH`环境变量中。
- en: Before you start writing your own code, ensure that you have properly set up
    your `GOPATH`. This is a local directory where your Go source files and compiled
    artifacts are saved as you use the Go Toolchain. Follow the instructions found
    in [https://golang.org/doc/install#testing](https://golang.org/doc/install#testing)
    to set up your GOPATH.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写自己的代码之前，请确保你已经正确设置了你的`GOPATH`。这是一个本地目录，当你使用Go工具链时，你的Go源文件和编译后的工件都保存在这里。按照[https://golang.org/doc/install#testing](https://golang.org/doc/install#testing)中找到的说明来设置你的GOPATH。
- en: Source code examples
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码示例
- en: The programming examples presented throughout this book are available on the
    GitHub source code repository service. There you will find all source files grouped
    by chapters in the repository at [https://github.com/vladimirvivien/learning-go/](https://github.com/vladimirvivien/learning-go/).
    To save the readers a few keystrokes, the examples use a shortened URL, that starts
    with `golang.fyi`, that points directly to the respective file in GitHub.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的编程示例可在GitHub源代码仓库服务上找到。在那里，你可以找到按章节分组的所有源文件，位于[https://github.com/vladimirvivien/learning-go/](https://github.com/vladimirvivien/learning-go/)的仓库中。为了节省读者一些按键，示例使用了以`golang.fyi`开头的缩短URL，它直接指向GitHub中的相应文件。
- en: Alternatively, you can follow along by downloading and unzipping (or cloning)
    the repository locally. Create a directory structure in your `GOPATH` so that
    the root of the source files is located at `$GOPATH/src/github.com/vladimirvivien/learning-go/`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过下载并解压（或克隆）本地仓库来跟随。在你的`GOPATH`中创建一个目录结构，使得源文件的根目录位于`$GOPATH/src/github.com/vladimirvivien/learning-go/`。
- en: Your first Go program
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个Go程序
- en: 'After installing the Go tools successfully on your local machine, you are now
    ready to write and execute your first Go program. For that, simply open your favorite
    text editor and type in the simple Hello World program shown in the following
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的本地机器上成功安装Go工具后，你现在可以编写并执行你的第一个Go程序了。为此，只需打开你喜欢的文本编辑器，并输入以下代码中的简单Hello World程序：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch01/helloworld.go
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/helloworld.go
- en: 'Save the source code in a file called `helloworld.go` anywhere inside your
    GOPATH. Then use the following Go command to compile and run the program:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将源代码保存在名为`helloworld.go`的文件中，该文件位于你的GOPATH中的任何位置。然后使用以下Go命令来编译并运行程序：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If all goes well, you should see the message **Hello, World!** output on your
    screen. Congratulations, you have just written and executed your first Go program.
    Now, let us explore the attributes and characteristics of the Go language at a
    high level.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会在屏幕上看到消息**Hello, World!**输出。恭喜你，你已经编写并执行了你的第一个Go程序。现在，让我们从高层次上探讨Go语言的特征和属性。
- en: Go in a nutshell
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言概述
- en: 'By design, Go has a simple syntax. Its designers wanted to create a language
    that is clear, concise, and consistent with few syntactic surprises. When reading
    Go code, keep this mantra in mind: w*hat you see is what it is*. Go shies away
    from a clever and terse coding style in favor of code that is clear and readable
    as exemplified by the following program:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设计上，Go 语言拥有简洁的语法。其设计者希望创建一种清晰、简洁且语法一致，且没有太多语法惊喜的语言。在阅读 Go 代码时，请记住这个口诀：*所见即所得*。Go
    语言避免使用巧妙且紧凑的编码风格，而是倾向于编写清晰易读的代码，如下面的程序所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch01/metalloids.go
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/metalloids.go
- en: 'When the code is executed, it will give the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码执行时，它将给出以下输出：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you have never seen Go before, you may not understand some of the details
    of the syntax and idioms used in the previous program. Nevertheless, when you
    read the code, there is a good chance you will be able to follow the logic and
    form a mental model of the program's flow. That is the beauty of Go's simplicity
    and the reason why so many programmers use it. If you are completely lost, no
    need to worry, as the subsequent chapters will cover all aspects of the language
    to get you going.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前从未见过 Go，您可能无法理解前面程序中使用的语法和习惯用法的一些细节。然而，当您阅读代码时，您有很大机会能够跟随逻辑并形成一个程序流程的心理模型。这正是
    Go 简单之美以及为什么这么多程序员使用它的原因。如果您完全迷失方向，无需担心，因为后续章节将涵盖语言的各个方面，帮助您入门。
- en: Functions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Go programs are composed of functions, the smallest callable code unit in the
    language. In Go, functions are typed entities that can either be named (as shown
    in the previous example) or be assigned to a variable as a value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go 程序由函数组成，这是语言中最小的可调用代码单元。在 Go 中，函数是有类型的实体，可以是命名的（如前例所示），也可以作为值赋给变量：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another interesting feature about Go functions is their ability to return multiple
    values as a result of a call. For instance, the previous function could be re-written
    to return a value of type `error` in addition to the calculated `float64` value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Go 函数的另一个有趣特性是它们能够返回多个值作为函数调用的结果。例如，前面的函数可以被重写为除了返回计算出的 `float64` 类型的值外，还返回一个
    `error` 类型的值：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code uses the multi-return capabilities of Go functions to return
    both the mass and an error value. You will encounter this idiom throughout the
    book used as a mean to properly signal errors to the caller of a function. There
    will be further discussion on multi-return value functions covered in [Chapter
    5](part0035_split_000.html#11C3M2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 5. Functions
    in Go"), *Functions in Go*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了 Go 函数的多返回值功能来返回质量和错误值。你将在本书中遇到这种用法，它被用作向函数的调用者正确地传递错误信息的一种手段。关于多返回值函数的进一步讨论将在[第
    5 章](part0035_split_000.html#11C3M2-9c484ed022e64a0fb0e1aebf8e05d4fd "第 5 章。Go
    中的函数")，*Go 中的函数*中展开。
- en: Packages
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: Source files containing Go functions can be further organized into directory
    structures known as a package. Packages are logical modules that are used to share
    code in Go as libraries. You can create your own local packages or use tools provided
    by Go to automatically pull and use remote packages from a source code repository.
    You will learn more about Go packages in [Chapter 6](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 6. Go Packages and Programs"), *Go Packages and Programs*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 Go 函数的源文件可以进一步组织成称为包的目录结构。包是逻辑模块，用于在 Go 中作为库共享代码。您可以创建自己的本地包或使用 Go 提供的工具自动从源代码仓库拉取并使用远程包。您将在[第
    6 章](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd "第 6 章。Go
    包和程序")，*Go 包和程序*中了解更多关于 Go 包的内容。
- en: The workspace
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作空间
- en: Go follows a simple code layout convention to reliably organize source code
    packages and to manage their dependencies. Your local Go source code is stored
    in the workspace, which is a directory convention that contains the source code
    and runtime artifacts. This makes it easy for Go tools to automatically find,
    build, and install compiled binaries. Additionally, Go tools rely on the `workspace`
    setup to pull source code packages from remote repositories, such as Git, Mercurial,
    and Subversion, and satisfy their dependencies.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Go 采用简单的代码布局约定，以可靠地组织源代码包并管理它们的依赖关系。您的本地 Go 源代码存储在工作空间中，这是一个包含源代码和运行时文件的目录约定。这使得
    Go 工具能够自动查找、构建和安装编译后的二进制文件。此外，Go 工具还依赖于 `workspace` 设置来从远程仓库（如 Git、Mercurial 和
    Subversion）拉取源代码包，并满足它们的依赖关系。
- en: Strongly typed
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强类型
- en: 'All values in Go are statically typed. However, the language offers a simple
    but expressive type system that can have the feel of a dynamic language. For instance,
    types can be safely inferred as shown in the following code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的所有值都是静态类型的。然而，该语言提供了一个简单但表达力强的类型系统，它可以给人一种动态语言的感觉。例如，类型可以安全地推断，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you would expect, constant grams would be assigned a numeric type, `float64`,
    to be precise, by the Go type system. This is true not only for constants, but
    any variable can use a short-hand form of declaration and assignment as shown
    in the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，常量克会由 Go 类型系统分配一个数值类型，精确地说，是 `float64` 类型。这不仅适用于常量，任何变量都可以使用如下示例所示的简写形式进行声明和赋值：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Composite types
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'Besides the types for simple values, Go also supports composite types such
    as `array`, `slice`, and `map`. These types are designed to store indexed elements
    of values of a specified type. For instance, the `metalloid` example shown previously
    makes use of a slice, which is a variable-sized array. The variable `metalloid`
    is declared as a `slice` to store a collection of the type `metalloid`. The code
    uses the literal syntax to combine the declaration and assignment of a `slice`
    of type `metalloid`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单值的类型外，Go 还支持诸如 `array`、`slice` 和 `map` 这样的复合类型。这些类型被设计用来存储指定类型的值的索引元素。例如，之前展示的
    `metalloid` 示例就使用了切片，它是一个可变大小的数组。变量 `metalloid` 被声明为一个 `slice`，用来存储 `metalloid`
    类型的集合。代码使用字面量语法结合了 `metalloid` 类型的 `slice` 的声明和赋值：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Go also supports a `struct` type which is a composite that stores named elements
    called fields as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还支持一种 `struct` 类型，它是一个复合类型，存储了称为字段的命名元素，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous example uses the literal syntax to declare `struct{name string;
    diameter int}` with the value `{"earth", 12742}`. You can read all about composite
    types in [Chapter 7](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Composite Types"), *Composite Types*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用字面量语法声明了 `struct{name string; diameter int}`，其值为 `{"earth", 12742}`。你可以在[第7章](part0051_split_000.html#1GKCM2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第7章。复合类型") *复合类型* 中阅读有关复合类型的所有内容。
- en: The named type
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名类型
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Methods and objects
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法和对象
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The power of this concept is explored in detail in [Chapter 8](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这一概念的力量在[第8章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象") *方法、接口和对象* 中被详细探讨。
- en: Interfaces
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Go supports the notion of a programmatic interface. However, as you will see
    in [Chapter 8](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects*,
    the Go interface is itself a type that aggregates a set of methods that can project
    capabilities onto values of other types. Staying true to its simplistic nature,
    implementing a Go interface does not require a keyword to explicitly declare an
    interface. Instead, the type system implicitly resolves implemented interfaces
    using the methods attached to a type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Go 支持程序化接口的概念。然而，正如你将在[第8章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象") *方法、接口和对象* 中看到的，Go 的接口本身就是一个类型，它聚合了一组可以将能力投射到其他类型值的方法。保持其简单性，实现
    Go 接口不需要使用关键字显式声明接口。相反，类型系统隐式地使用附加到类型的函数来解析实现的接口。
- en: 'For instance, Go includes the built-in interface called `Stringer`, defined
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Go 包含一个名为 `Stringer` 的内置接口，其定义如下：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any type that has the method `String()` attached, automatically implements
    the `Stringer` interface. So, modifying the definition of the type `metalloid`,
    from the previous program, to attach the method `String()` will automatically
    implement the `Stringer` interface:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 任何附加了 `String()` 方法的类型，都会自动实现 `Stringer` 接口。因此，将 `metalloid` 类型的定义从之前的程序中修改为附加
    `String()` 方法，将自动实现 `Stringer` 接口：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch01/metalloids2.go
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/metalloids2.go
- en: 'The `String()` methods return a pre-formatted string that represents the value
    of a `metalloid`. The function `Print()`, from the standard library package `fmt`,
    will automatically call the method `String()`, if its parameter implements `stringer`.
    So, we can use this fact to print `metalloid` values as follow:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`String()` 方法返回一个预格式化的字符串，表示 `metalloid` 的值。标准库包 `fmt` 中的 `Print()` 函数会自动调用
    `stringer` 参数实现的 `String()` 方法。因此，我们可以使用这个事实来打印 `metalloid` 值，如下所示：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, refer to [Chapter 8](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects*,
    for a thorough treatment of the topic of interfaces.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，请参考[第8章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象")，*方法、接口和对象*，以深入了解接口这一主题。
- en: Concurrency and channels
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与通道
- en: One of the main features that has rocketed Go to its current level of adoption
    is its inherent support for simple concurrency idioms. The language uses a unit
    of concurrency known as a `goroutine`, which lets programmers structure programs
    with independent and highly concurrent code.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将Go推向当前采用水平的其中一个主要特性是其对简单并发习惯的固有支持。该语言使用一个称为`goroutine`的并发单元，允许程序员以独立和高度并发的代码结构化程序。
- en: 'As you will see in the following example, Go also relies on a construct known
    as a channel used for both communication and coordination among independently
    running `goroutines`. This approach avoids the perilous and (sometimes brittle)
    traditional approach of thread communicating by sharing memory. Instead, Go facilitates
    the approach of sharing by communicating using channels. This is illustrated in
    the following example that uses both `goroutines` and channels as processing and
    communication primitives:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，您将看到Go还依赖于一种称为通道的构造，用于独立运行的`goroutines`之间的通信和协调。这种方法避免了通过共享内存进行线程通信的传统方法的风险和（有时脆弱）的缺点。相反，Go通过使用通道进行通信来促进共享。以下示例展示了使用`goroutines`和通道作为处理和通信原语的方法：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch01/euler1.go
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/euler1.go
- en: The code in the previous example splits the work to be done between two concurrently
    running `goroutines` (declared with the `go` keyword) as annotated in the code
    comment. Each `goroutine` runs independently and uses the Go channels, `work`
    and `result`, to communicate and coordinate the calculation of the final result.
    Again, if this code does not make sense at all, rest assured, concurrency has
    the whole of [Chapter 9](part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9. Concurrency"), *Concurrency*, dedicated to it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的代码将待完成的工作分配给了两个并发运行的`goroutines`（使用`go`关键字声明），如代码注释所示。每个`goroutine`独立运行，并使用Go的通道`work`和`result`来通信和协调最终结果的计算。再次强调，如果这段代码完全看不懂，请放心，并发内容在[第9章](part0061_split_000.html#1Q5IA1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第9章。并发")，*并发*中进行了详细阐述。
- en: Memory management and safety
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理与安全性
- en: Similar to other compiled and statically-typed languages such as C and C++,
    Go lets developers have direct influence on memory allocation and layout. When
    a developer creates a `slice` (think `array`) of bytes, for instance, there is
    a direct representation of those bytes in the underlying physical memory of the
    machine. Furthermore, Go borrows the notion of pointers to represent the memory
    addresses of stored values giving Go programs the support of passing function
    parameters by both value and reference.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编译和静态类型语言（如C和C++）类似，Go允许开发者直接影响内存分配和布局。例如，当开发者创建一个字节的`slice`（相当于数组）时，这些字节在机器的底层物理内存中有直接的表示。此外，Go借鉴了指针的概念来表示存储值的内存地址，这使得Go程序能够通过值和引用两种方式传递函数参数。
- en: Go asserts a highly opinionated safety barrier around memory management with
    little to no configurable parameters. Go automatically handles the drudgery of
    bookkeeping for memory allocation and release using a runtime garbage collector.
    Pointer arithmetic is not permitted at runtime; therefore, developers cannot traverse
    memory blocks by adding to or subtracting from a base memory address.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Go在内存管理方面设定了一个高度意见化的安全屏障，几乎没有可配置的参数。Go使用运行时垃圾回收器自动处理内存分配和释放的繁琐工作。运行时不允许指针算术；因此，开发者不能通过向或从基本内存地址添加或减去来遍历内存块。
- en: Fast compilation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速编译
- en: Another one of Go's attractions is its millisecond build-time for moderately-sized
    projects. This is made possible with features such as a simple syntax, conflict-free
    grammar, and a strict identifier resolution that forbids unused declared resources
    such as imported packages or variables. Furthermore, the build system resolves
    packages using transitivity information stored in the closest source node in the
    dependency tree. Again, this reduces the code-compile-run cycle to feel more like
    a dynamic language instead of a compiled language.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go的另一个吸引力是它为中等规模项目提供的毫秒级构建时间。这是通过诸如简单语法、无冲突的语法和严格的标识符解析等特性实现的，这些特性禁止使用未使用的声明资源，例如导入的包或变量。此外，构建系统使用依赖树中最接近的源节点中存储的传递性信息来解决包。再次，这减少了代码-编译-运行周期，使其更像动态语言而不是编译语言。
- en: Testing and code coverage
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和代码覆盖率
- en: While other languages usually rely on third-party tools for testing, Go includes
    both a built-in API and tools designed specifically for automated testing, benchmarking,
    and code coverage. Similar to other features in Go, the test tools use simple
    conventions to automatically inspect and instrument the test functions found in
    your code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他语言通常依赖于第三方工具进行测试，但Go包含内置的API和专门为自动化测试、基准测试和代码覆盖率设计的工具。与Go中的其他功能类似，测试工具使用简单的约定来自动检查和仪器化代码中找到的测试函数。
- en: 'The following function is a simplistic implementation of the Euclidean division
    algorithm that returns a quotient and a remainder value (as variables `q` and
    `r`) for positive integers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是欧几里得除法算法的简单实现，它返回一个商和一个余数值（作为变量`q`和`r`）用于正整数：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch01/testexample/divide.go
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/testexample/divide.go
- en: 'In a separate source file, we can write a test function to validate the algorithm
    by checking the remainder value returned by the tested function using the Go test
    API as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在单独的源文件中，我们可以编写一个测试函数来验证算法，通过使用Go测试API检查被测试函数返回的余数值来验证，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch01/testexample/divide_test.go
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch01/testexample/divide_test.go
- en: 'To exercise the test source code, simply run Go''s test tool as shown in the
    following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试源代码，只需像以下示例中那样运行Go的测试工具：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The test tool reports a summary of the test result indicating the package that
    was tested and its pass/fail outcome. The Go Toolchain comes with many more features
    designed to help programmers create testable code, including:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具报告了测试结果的摘要，指示了被测试的包及其通过/失败结果。Go工具链包含许多更多功能，旨在帮助程序员创建可测试的代码，包括：
- en: Automatically instrument code to gather coverage statistics during tests
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动在测试期间对代码进行仪器化以收集覆盖率统计信息
- en: Generating HTML reports for covered code and tested paths
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为覆盖的代码和测试路径生成HTML报告
- en: A benchmark API that lets developers collect performance metrics from tests
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基准API，允许开发者从测试中收集性能指标
- en: Benchmark reports with valuable metrics for detecting performance issues
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准报告包含用于检测性能问题的有价值指标
- en: You can read all about testing and its related tools in [Chapter 12](part0083_split_000.html#2F4UM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 12. Code Testing"), *Code Testing*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第12章](part0083_split_000.html#2F4UM1-9c484ed022e64a0fb0e1aebf8e05d4fd "第12章。代码测试")*代码测试*中阅读有关测试及其相关工具的所有内容。
- en: Documentation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档
- en: 'Documentation is a first-class component in Go. Arguably, the language''s popularity
    is in part due to its extensive documentation (see [http://golang.org/pkg](http://golang.org/pkg)).
    Go comes with the Godoc tool, which makes it easy to extract documentation from
    comment text embedded directly in the source code. For example, to document the
    function from the previous section, we simply add comment lines directly above
    the `DivMod` function as shown in the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 文档在Go中是一个一等组件。可以说，该语言的部分流行度归因于其广泛的文档（参见[http://golang.org/pkg](http://golang.org/pkg)）。Go附带Godoc工具，这使得从源代码中直接嵌入的注释文本中提取文档变得容易。例如，要记录上一节中的函数，我们只需在`DivMod`函数上方直接添加注释行，如下面的示例所示：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Go documentation tool can automatically extract and create HTML-formatted
    pages. For instance, the following command will start the Godoc tool as a server
    on `localhost port 6000`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Go文档工具可以自动提取并创建HTML格式的页面。例如，以下命令将Godoc工具作为服务器在`localhost端口6000`上启动：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Documentation](img/00003.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![文档](img/00003.jpeg)'
- en: An extensive library
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个广泛的库
- en: 'For its short existence, Go rapidly grew a collection of high-quality APIs
    as part of its standard library that are comparable to other popular and more
    established languages. The following, by no means exhaustive, lists some of the
    core APIs that programmers get out-of-the-box:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其短暂的寿命，Go迅速积累了一系列高质量的API，作为其标准库的一部分，这些API与其他流行和更成熟的语言相当。以下列出的核心API并非详尽无遗，但程序员可以开箱即用：
- en: Complete support for regular expressions with search and replace
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持正则表达式，包括搜索和替换
- en: Powerful IO primitives for reading and writing bytes
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的IO原语，用于读取和写入字节
- en: Full support for networking from socket, TCP/UDP, IPv4, and IPv6
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持从套接字、TCP/UDP、IPv4和IPv6进行网络操作
- en: APIs for writing production-ready HTTP services and clients
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编写生产就绪的HTTP服务和客户端的API
- en: Support for traditional synchronization primitives (mutex, atomic, and so on)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持传统的同步原语（互斥锁、原子操作等）
- en: General-purpose template framework with HTML support
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持HTML的通用模板框架
- en: Support for JSON/XML serializations
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JSON/XML序列化
- en: RPC with multiple wire formats
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种线格式的RPC
- en: 'APIs for archive and compression algorithms: `tar`, `zip`/`gzip`, `zlib`, and
    so on'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档和压缩算法的API：`tar`、`zip`/`gzip`、`zlib`等
- en: Cryptography support for most major algorithms and hash functions
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对大多数主要算法和哈希函数的加密支持
- en: Access to OS-level processes, environment info, signaling, and much more
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问操作系统级别的进程、环境信息、信号等更多功能
- en: The Go Toolchain
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go工具链
- en: 'Before we end the chapter, one last aspect of Go that should be highlighted
    is its collection of tools. While some of these tools were already mentioned in
    previous sections, others are listed here for your awareness:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，应该强调Go的一个最后方面，那就是它的工具集合。虽然其中一些工具已经在之前的章节中提到过，但其他一些工具在此列出，以便您了解：
- en: '`fmt`: Reformats source code to adhere to the standard'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt`: 重新格式化源代码以符合标准'
- en: '`vet`: Reports improper usage of source code constructs'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vet`: 报告源代码结构的错误使用'
- en: '`lint`: Another source code tool that reports flagrant style infractions'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lint`: 另一个源代码工具，报告明显的样式违规'
- en: '`goimports`: Analyzes and fixes package import references in source code'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`goimports`: 分析并修复源代码中的包导入引用'
- en: '`godoc`: Generates and organizes source code documentation'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`godoc`: 生成和组织源代码文档'
- en: '`generate`: Generates Go source code from directives stored in source code'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate`: 从源代码中存储的指令生成Go源代码'
- en: '`get`: Remotely retrieves and installs packages and their dependencies'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 远程检索和安装包及其依赖项'
- en: '`build`: Compiles code in a specified package and its dependencies'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 编译指定包及其依赖项的代码'
- en: '`run`: Provides the convenience of compiling and running your Go program'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`: 提供编译和运行Go程序的便利性'
- en: '`test`: Performs unit tests with support for benchmark and coverage reports'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`: 执行单元测试，支持基准和覆盖率报告'
- en: '`oracle` static analysis tool: Queries source code structures and elements'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oracle`静态分析工具：查询源代码结构和元素'
- en: '`cgo`: Generates source code for interoperability between Go and C'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgo`: 为Go和C之间的互操作性生成源代码'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Within its relatively short existence, Go has won the hearts of many adopters
    who value simplicity as a way to write code that is exact and is able to scale
    in longevity. As you have seen from the previous sections in this chapter, it
    is easy to get started with your first Go program.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在其相对较短的存在期间，Go赢得了许多重视简洁性作为编写精确且能够长期扩展的代码方式的采用者的心。正如您在本章前面的部分所看到的，开始编写第一个Go程序很容易。
- en: The chapter also exposed its readers to a high-level summary of the most essential
    features of Go including its simplified syntax, its emphasis on concurrency, and
    the tools that make Go a top choice for software engineers, creating systems for
    the age of data center computing. As you may imagine, this is just a taste of
    what's to come.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向读者展示了Go最基本特性的高级概述，包括其简化的语法、对并发的强调以及使Go成为数据中心计算时代软件工程师首选的系统工具。正如您可能想象的那样，这仅仅是即将到来的一小部分。
- en: In the following chapters, the book will continue to explore in detail the syntactical
    elements and language concepts that make Go a great language to learn. Let's Go!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，本书将继续详细探讨构成Go成为优秀学习语言的句法和语言概念。让我们开始吧！
