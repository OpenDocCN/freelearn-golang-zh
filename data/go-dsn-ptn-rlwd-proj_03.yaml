- en: Chapter 2. Go Language Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Go语言基础
- en: In the previous chapter, we established the elemental characteristics that make
    Go a great language with which to create modern system programs. In this chapter,
    we dig deeper into the language's syntax to explore its components and features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们确立了使Go成为创建现代系统程序的优秀语言的元素特性。在本章中，我们将深入探讨语言的语法，以探索其组件和功能。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The Go source file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go源代码文件
- en: Identifiers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符
- en: Variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Constants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: The Go source file
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 源代码文件
- en: 'We have seen, in [Chapter 1](part0011_split_000.html#AFM61-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. A First Step in Go"), *A First Step in Go*, some examples of Go programs.
    In this section, we will examine the Go source file. Let us consider the following
    source code file (which prints `"Hello World"` greetings in different languages):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0011_split_000.html#AFM61-9c484ed022e64a0fb0e1aebf8e05d4fd "第1章。Go语言的第一步")中，即《Go语言的第一步》中，看到了一些Go程序的示例。在本节中，我们将检查Go源代码文件。让我们考虑以下源代码文件（该文件以不同语言打印"Hello
    World"问候语）：
- en: '![The Go source file](img/00004.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Go源代码文件](img/00004.jpeg)'
- en: golang.fyi/ch02/helloworld2.go
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/helloworld2.go
- en: 'A typical Go source file, such as the one listed earlier, can be divided into
    three main sections, illustrated as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Go源代码文件，如前面所列，可以分为三个主要部分，如下所示：
- en: 'The **Package Clause**:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包声明**：'
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The **Import Declaration**:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入声明**：'
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **Source Body**:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码体**：'
- en: '[PRE2]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **package** clause indicates the name of the package this source file belongs
    to (see [Chapter 6](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 6. Go Packages and Programs"), Go *Packages and Programs* for a detailed
    discussion on package organization). The **import** declaration lists any external
    package that the source code wishes to use. The Go compiler strictly enforces
    package declaration usage. It is considered an error (compilation) to include
    an unused package in your source file. The last portion of the source is considered
    the body of your source file. It is where you declare variables, constants, types,
    and functions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**包**子句表示此源文件所属的包的名称（有关包组织的详细讨论，请参阅[第6章](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第6章。Go包和程序")，Go *包和程序*）。**导入**声明列出源代码希望使用的任何外部包。Go编译器严格强制执行包声明使用。在源文件中包含未使用的包被认为是错误（编译错误）。源代码的最后部分被认为是源文件的主体。这是你声明变量、常量、类型和函数的地方。'
- en: All Go source files must end with the `.go` suffix. In general, you can name
    a Go source file whatever you want. Unlike Java, for instance, there is no direct
    association between a Go file name and the types it declared in its content. It
    is, however, considered good practice to name your file something indicative of
    its content.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Go源代码文件都必须以`.go`后缀结尾。通常，你可以根据需要命名Go源代码文件。例如，与Java不同，Go文件名与其内容中声明的类型之间没有直接关联。然而，将文件名命名为能表明其内容的名称被认为是良好的实践。
- en: Before we explore Go's syntax in greater detail, it is important to understand
    some basic structural elements of the language. While some of these elements are
    syntactically bolted into the language, others are simple idioms and conventions
    that you should be aware of to make your introduction to Go simple and enjoyable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地探讨Go的语法之前，了解一些语言的基本结构元素是很重要的。虽然其中一些元素在语法上被固定在语言中，但其他元素是简单的习语和约定，你应该了解这些，以便使你的Go语言入门简单而愉快。
- en: Optional semicolon
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的分号
- en: 'You may have noticed that Go does not require a semicolon as a statement separator.
    This is a trait borrowed from other lighter and interpreted languages. The following
    two programs are functionally equivalent. The first program uses idiomatic Go
    and omits the semicolons:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到Go不需要分号作为语句分隔符。这是从其他较轻和解释性语言中借用的一项特性。以下两个程序在功能上是等效的。第一个程序使用惯用的Go并省略了分号：
- en: '![Optional semicolon](img/00005.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![可选分号](img/00005.jpeg)'
- en: 'The second version of the program, shown as follows, uses superfluous semicolons
    to explicitly terminate its statements. While the compiler may thank you for your
    help, this is not idiomatic in Go:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二个版本，如下所示，使用了多余的分号来显式终止其语句。虽然编译器可能会感谢你的帮助，但这在Go中不是惯用的用法：
- en: '![Optional semicolon](img/00006.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![可选分号](img/00006.jpeg)'
- en: 'Although semicolons in Go are optional, Go''s formal grammar still requires
    them as statement terminators. So, the Go compiler will insert semicolons at the
    end of source code lines that end with the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Go 中分号是可选的，但 Go 的正式语法仍然要求它们作为语句终止符。因此，Go 编译器将在以下行末插入分号：
- en: An identifier
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符
- en: A literal value for string, Boolean, numeric, or complex
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串、布尔值、数值或复数的字面值
- en: A control flow directive such as break, continue, or return
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流指令，如 break、continue 或 return
- en: A closing parenthesis or bracket such as `)`, `}`, or `]`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个闭合括号或方括号，例如 `)`、`}` 或 `]`
- en: The increment `++` or the decrement `--` operator
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量 `++` 或递减 `--` 运算符
- en: 'Due to these rules, the compiler enforces strict syntactical forms that heavily
    influence source code style in Go. For instance, all code blocks must start with
    an open curly `{` brace on the same line as its preceding statement. Otherwise,
    the compiler may insert the semicolon in a location that breaks the code, as shown
    in the following `if` statement:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些规则，编译器强制执行严格的语法形式，这对 Go 中的源代码风格有很大影响。例如，所有代码块都必须在其前一个语句的同一行上以开大括号 `{` 开始。否则，编译器可能会在破坏代码的位置插入分号，如下面的
    `if` 语句所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Moving the curly brace to the next line causes the compiler to insert the semicolon
    prematurely, which will result in the following syntax error:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将花括号移动到下一行会导致编译器提前插入分号，这将导致以下语法错误：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is because the compiler inserted the semicolon after the `if` statement
    (`if "a"=="a";`), using the semicolon insertion rules discussed in this section.
    You can verify this by manually inserting a semicolon after the `if` condition
    statement; you will get the same error. This is an excellent place to transition
    into the next section, to discuss trailing commas in code blocks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器在 `if` 语句（`if "a"=="a";`）之后插入了分号，使用了本节讨论的分号插入规则。你可以通过手动在 `if` 条件语句后插入分号来验证这一点；你将得到相同的错误。这是一个很好的地方，可以过渡到下一节，讨论代码块中的尾随逗号。
- en: Multiple lines
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多行
- en: 'Breaking up expressions into multiple lines must follow the semi-colon rules
    discussed in the previous section. Mainly, in a multi-line expression, each line
    must end with a token that prevents the premature insertion of a semi-colon, as
    illustrated in the following table. It should be noted that rows in the table
    with an invalid expression will not compile:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式拆分成多行必须遵循上一节中讨论的分号规则。主要是在多行表达式中，每一行都必须以一个防止提前插入分号的标记结束，如下表所示。应注意，表中带有无效表达式的行将无法编译：
- en: '| **Expression** | **Valid** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **有效** |'
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Yes, the `+` operator prevents a premature semi-colon from being inserted.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 是的，`+` 运算符防止了提前插入分号。|'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| No, a semi-colon will be inserted after the first line, semantically breaking
    the line. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 不，分号将在第一行之后插入，从语义上破坏了该行。|'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Yes, the comma properly breaks the expression. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 是的，逗号正确地打破了表达式。|'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Yes, the compiler inserts a semi-colon only after the last line. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 是的，编译器只在最后一行之后插入分号。|'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '| No, the `Fri` line causes a premature semi-colon to be inserted. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 不，`Fri` 行导致提前插入分号。|'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| Yes, the `Fri` line contains a trailing comma, which causes compiler to insert
    a semi-colon at the next line. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 是的，`Fri` 行包含尾随逗号，导致编译器在下一行插入分号。|'
- en: '| `weekDays1 := []string{``"Mon", "Tue",``"Wed", "Thr",``"Fri"}` | Yes, the
    semi-colon is inserted after the line with the closing bracket. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `weekDays1 := []string{``"Mon", "Tue",``"Wed", "Thr",``"Fri"}` | 是的，分号是在闭合括号之后的行中插入的。|'
- en: You may wonder why the Go compiler puts the onus on the developer to provide
    line-break hints to indicate the end of a statement. Surely, Go designers could
    have devised an elaborate algorithm to figure this out automatically. Yes, they
    could have. However, by keeping the syntax simple and predictable, the compiler
    is able to quickly parse and compile Go source code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 Go 编译器将责任放在开发者身上，要求他们提供行断点提示以指示语句的结束。当然，Go 设计者可以设计一个复杂的算法来自动解决这个问题。是的，他们可以。然而，通过保持语法简单和可预测，编译器能够快速解析和编译
    Go 源代码。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Go toolchain includes the gofmt tool, which can be used to consistently
    apply proper formatting rules to your source code. There is also the `govet` tool,
    which goes much further by analyzing your code for structural problems with code
    elements.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go 工具链包括 gofmt 工具，它可以用来一致地应用适当的格式化规则到你的源代码中。还有一个 `govet` 工具，它通过分析你的代码中的结构问题来走得更远，这些问题与代码元素有关。
- en: Go identifiers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 标识符
- en: 'Go identifiers are used to name program elements including packages, variables,
    functions, and types. The following summarizes some attributes about identifiers
    in Go:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标识符用于命名程序元素，包括包、变量、函数和类型。以下总结了 Go 中标识符的一些属性：
- en: Identifiers support the Unicode character set
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符支持 Unicode 字符集
- en: The first position of an identifier must be a letter or an underscore
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符的第一个位置必须是字母或下划线
- en: Idiomatic Go favors mixed caps (camel case) naming
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 的惯用用法偏好混合大小写（驼峰式）命名
- en: Package-level identifiers must be unique across a given package
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包级别标识符必须在给定的包内是唯一的
- en: Identifiers must be unique within a code block (functions, control statements)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符必须在代码块（函数、控制语句）内是唯一的
- en: The blank identifier
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空标识符
- en: 'The Go compiler is particularly strict about the use of declared identifiers
    for variables or packages. The basic rule is: *you declare it, you must use it*.
    If you attempt to compile code with unused identifiers such as variables or named
    packages, the compilers will not be pleased and will fail compilation.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器对声明标识符用于变量或包的使用特别严格。基本规则是：“你声明了它，就必须使用它”。如果你尝试编译包含未使用标识符（如变量或命名包）的代码，编译器将不会高兴，并且会失败编译。
- en: Go allows you to turn off this behavior using the blank identifier, represented
    by the `_` (underscore) character. Any declaration or assignment that uses the
    blank identifier is not bound to any value and is ignored at compile time. The
    blank identifier is usually used in two contexts, as listed in the following subsections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许您使用空标识符（由下划线字符 `_` 表示）来关闭此行为。任何使用空标识符的声明或赋值都不会绑定到任何值，并且在编译时被忽略。空标识符通常用于以下两个上下文中，如下所述的小节。
- en: Muting package imports
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消除包导入
- en: 'When a package declaration is preceded by an underscore, the compiler allows
    the package to be declared without any further referenced usage:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当包声明前有一个下划线时，编译器允许在不进行任何进一步引用使用的情况下声明包：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Muting unwanted function results
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抑制不需要的函数结果
- en: 'When a Go function call returns multiple values, each value in the return list
    must be assigned to a variable identifier. In some cases, however, it may be desirable
    to mute unwanted results from the return list while keeping others, as shown in
    the following call:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Go 函数调用返回多个值时，返回列表中的每个值都必须分配给一个变量标识符。然而，在某些情况下，可能希望抑制返回列表中的不需要的结果，同时保留其他结果，如下面的调用所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous call to the function `filepath.Split("/opt/data/bigdata.txt")`
    takes a path and returns two values: the first is the parent path (`/opt/data`)
    and the second is the file name (`bigdata.txt`). The first value is assigned to
    the blank identifier and is, therefore, unbounded to a named identifier, which
    causes it to be ignored by the compiler. In future discussions, we will explore
    other uses of this idiom''s other contexts, such as error-handling and `for` loops.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之前对函数 `filepath.Split("/opt/data/bigdata.txt")` 的调用接受一个路径并返回两个值：第一个是父路径（`/opt/data`），第二个是文件名（`bigdata.txt`）。第一个值分配给空标识符，因此未绑定到任何命名标识符，这导致编译器忽略它。在未来的讨论中，我们将探讨该习语在其他上下文中的其他用途，例如错误处理和
    `for` 循环。
- en: Built-in identifiers
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置标识符
- en: Go comes with a number of built-in identifiers. They fall into different categories,
    including types, values, and built-in function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包含了许多内置标识符。它们分为不同的类别，包括类型、值和内置函数。
- en: Types
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: 'The following identifiers are used for Go''s built-in types:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标识符用于 Go 的内置类型：
- en: '| **Category** | **Identifier** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **标识符** |'
- en: '| Numeric | `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`,
    `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`, `complex64`, `complex128`,
    `uintptr` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `float32`, `float64`, `complex64`, `complex128`,
    `uintptr` |'
- en: '| String | `string` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `string` |'
- en: '| Boolean | `bool` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | `bool` |'
- en: '| Error | `error` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | `error` |'
- en: Values
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值
- en: 'These identifiers have preassigned values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标识符具有预分配的值：
- en: '| **Category** | **Identifier** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **标识符** |'
- en: '| Boolean constants | `true`, `false` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 布尔常量 | `true`, `false` |'
- en: '| Constant counter | `iota` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 常量计数器 | `iota` |'
- en: '| Uninitialized value | `nil` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 未初始化值 | `nil` |'
- en: Functions
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'The following functions are available as part of Go''s built-in pre-declared
    identifiers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数作为 Go 的内置预声明标识符的一部分可用：
- en: '| **Category** | **Identifier** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **标识符** |'
- en: '| Initialization | `make()`, `new()` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 初始化 | `make()`, `new()` |'
- en: '| Collections | `append()`, `cap()`, `copy()`, `delete()` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `append()`, `cap()`, `copy()`, `delete()` |'
- en: '| Complex numbers | `complex()`, `imag()`, `real()` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 复数 | `complex()`, `imag()`, `real()` |'
- en: '| Error Handling | `panic()`, `recover()` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 错误处理 | `panic()`, `recover()` |'
- en: Go variables
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 变量
- en: Go is a strictly typed language, which implies that all variables are named
    elements that are bound to both a value and a type. As you will see, the simplicity
    and flexibility of its syntax make declaring and initializing variables in Go
    feel more like a dynamically-typed language.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种强类型语言，这意味着所有变量都是命名元素，它们绑定到一个值和一个类型。您将看到，其语法简单灵活，这使得在 Go 中声明和初始化变量感觉更像动态类型语言。
- en: Variable declaration
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'Before you can use a variable in Go, it must be declared with a named identifier
    for future reference in the code. The long form of a variable declaration in Go
    follows the format shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中使用变量之前，必须使用命名标识符声明变量，以便在代码中将来引用。Go 变量声明的长格式如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch02/vardec1.go
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec1.go
- en: The zero-value
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零值
- en: The previous source code shows several examples of variables being declared
    with a variety of types. Then the variables are assigned a value inside the function
    `main()`. At first glance, it would appear that these declared variables do not
    have an assigned value when they are declared. This would contradict our previous
    assertion that all Go variables are bound to a type and a value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的源代码展示了几个使用不同类型的变量声明的例子。然后，这些变量在函数 `main()` 内部被赋予值。乍一看，似乎这些声明的变量在声明时并没有被赋予值。这会与我们的先前的断言相矛盾，即所有
    Go 变量都绑定到一个类型和一个值。
- en: How can we declare a variable and not bind a value to it? During declaration
    of a variable, if a value is not provided, Go will automatically bind a default
    value (or a zero-value) to the variable for proper memory initialization (we see
    how to do both declaration and initialization in one expression later).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何声明一个变量而不将其绑定到一个值上？在变量声明时，如果没有提供值，Go 会自动将默认值（或零值）绑定到变量上，以进行适当的内存初始化（我们稍后会看到如何在单个表达式中同时进行声明和初始化）。
- en: 'The following table shows Go types and their default zero-values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 Go 类型及其默认零值：
- en: '| **Type** | **Zero-Value** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **零值** |'
- en: '| `string` | `""` (empty string) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `""`（空字符串）|'
- en: '| Numeric - Integers: `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`,
    `uint`, `uint8`, `uint16`, `uint32`, `uint64`, `uintptr` | 0 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 数值 - 整数：`byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`,
    `uint8`, `uint16`, `uint32`, `uint64`, `uintptr` | 0 |'
- en: '| Numeric - Floating point: `float32`, `float64` | 0.0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 数值 - 浮点数：`float32`, `float64` | 0.0 |'
- en: '| `bool` | false |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | false |'
- en: '| `Array` | Each index position has a zero-value corresponding to the array''s
    element type. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Array` | 每个索引位置都有一个与数组元素类型对应的零值。 |'
- en: '| `Struct` | An empty `struct` with each member having its respective zero-value.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Struct` | 每个成员都有其相应零值的空 `struct`。 |'
- en: '| Other types: Interface, function, channel, slice, map, and pointer | nil
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 其他类型：接口、函数、通道、切片、映射和指针 | nil |'
- en: Initialized declaration
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化声明
- en: 'As hinted earlier, Go also supports the combination of both variable declaration
    and initialization as one expression using the following format:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go 还支持使用以下格式将变量声明和初始化组合为一个表达式：
- en: '*var <identifier list> <type> = <value list or initializer expressions>*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*var <标识符列表> <类型> = <值列表或初始化表达式>*'
- en: 'This declaration format has the following properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明格式具有以下特性：
- en: An identifier list provided on the left-hand side of the equal sign (followed
    by a type)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在等号左侧提供的标识符列表（后跟一个类型）
- en: A matching comma-separated value list on the right-hand side
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右侧的匹配的逗号分隔值列表
- en: Assignment occurs in the respective order of identifiers and values
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值按照标识符和值的相应顺序进行
- en: Initializer expressions must yield a matching list of values
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化表达式必须返回一个匹配的值列表
- en: 'The following abbreviated example shows the declaration and initialization
    combination at work:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简化的示例展示了声明和初始化组合的使用：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch02/vardec2.go
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec2.go
- en: Omitting variable types
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 省略变量类型
- en: 'So far, we have discussed what is called the long form of Go''s variable declaration
    and initialization. To make the language feel closer to its dynamically-typed
    cousins, the type specification can be omitted, as shown in the following declaration
    format:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了所谓的 Go 变量声明和初始化的长格式。为了使语言感觉更接近它的动态类型近亲，可以省略类型指定，如下面的声明格式所示：
- en: '*var <identifier list> = <value list or initializer expressions>*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*var <标识符列表> = <值列表或初始化表达式>*'
- en: During compilation, the compiler infers the type of the variable based on the
    assigned value or the initializer expression on the right-hand side of the equal
    sign, as shown in the following example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译期间，编译器根据赋值值或等号右侧的初始化表达式推断变量的类型，如下面的示例所示。
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch02/vardec3.go
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec3.go
- en: 'As stated earlier, when a variable is assigned a value, it must receive a type
    along with that value. When the type of the variable is omitted, the type information
    is deduced from the assigned value or the returned value of an expression. The
    following table shows the type that is inferred given a literal value:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当一个变量被赋予一个值时，它必须与该值一起接收一个类型。当省略变量的类型时，类型信息从赋值值或表达式的返回值中推断出来。以下表格显示了给定字面值时推断出的类型：
- en: '| **Literal value** | **Inferred type** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **字面值** | **推断类型** |'
- en: '| Double- or single-quoted (raw) text: `"Planet Mars"``"All planets revolve
    around the Sun."` | `string` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 双引号或单引号（原始）文本:`"火星"``"所有行星都围绕太阳旋转。"` | `string` |'
- en: '| Integers:`-76`0`1244``1840` | `int` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 整数:`-76`0`1244``1840` | `int` |'
- en: '| Decimals:`-0.25``4.0``3.1e4``7e-12` | `float64` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 小数:`-0.25``4.0``3.1e4``7e-12` | `float64` |'
- en: '| Complex numbers:`-5.0i``3i``(0+4i)` | `complex128` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 复数:`-5.0i``3i``(0+4i)` | `complex128` |'
- en: '| Booleans:`true``false` | `bool` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值:`true``false` | `bool` |'
- en: '| Array values:`[2]int{-76, 8080}` | The `array` type defined in the literal
    value. In this case it is: `[2]int` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 数组值:`[2]int{-76, 8080}` | 在字面值中定义的`array`类型。在这种情况下，它是:`[2]int` |'
- en: '| Map values:`map[string]int{``  "Sun": 685800,``  "Earth": 6378,``  "Mars":
    3396,``}` | The map type defined in the literal value. In this case it is: `map[string]int`
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 映射值:`map[string]int{ "Sun": 685800, "Earth": 6378, "Mars": 3396,}` | 在字面值中定义的映射类型。在这种情况下，它是:`map[string]int`
    |'
- en: '| Slice values:`[]int{-76, 0, 1244, 1840}` | The `slice` type defined in the
    literal value:`[]int` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 切片值:`[]int{-76, 0, 1244, 1840}` | 在字面值中定义的`slice`类型:`[]int` |'
- en: '| Struct values:`struct{``  name string``  diameter int}``{``  "Mars", 3396,``}`
    | A `struct` type as defined in the literal value. In this case the type is:`struct{name
    string; diameter int}` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 结构体值:`struct{ name string diameter int}``{ "Mars", 3396,}` | 在字面值中定义的结构体类型。在这种情况下，类型是:`struct{name
    string; diameter int}` |'
- en: '| Function values:`var sqr = func (v int)   int {``  return v * v``}` | The
    function type defined in the function definition literal. In this `case`, `variable``sqr`
    will have type:`func (v int) int` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 函数值:`var sqr = func (v int) int { return v * v }` | 在函数定义字面值中定义的函数类型。在这种情况下，`variable`sqr将具有类型:`func
    (v int) int` |'
- en: Short variable declaration
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短变量声明
- en: 'Go can further reduce the variable declaration syntax using the *short variable
    declaration* format. In this format, the declaration loses the var keyword and
    the type specification, and uses an assignment operator `:=` (colon-equal), as
    shown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言可以使用*短变量声明*格式进一步简化变量声明语法。在这个格式中，声明去掉了`var`关键字和类型指定，并使用赋值运算符`:=`（冒号等于），如下所示：
- en: '*<identifier list> := <value list or initializer expressions>*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*<标识符列表> := <值列表或初始化表达式>*'
- en: 'This is a simple and uncluttered idiom that is commonly used when declaring
    variables in Go. The following code sample shows usage of the short variable declarations:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单且简洁的惯用语，在Go语言中声明变量时常用。以下代码示例展示了短变量声明的用法：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch02/vardec4.go
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec4.go
- en: Notice the keyword `var` and variable types have been omitted in the declaration.
    Short variable declaration uses the same mechanism to infer the type of the variable
    discussed earlier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在声明中省略了关键字`var`和变量类型。短变量声明使用与前面讨论的相同机制来推断变量的类型。
- en: Restrictions for short variable declaration
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短变量声明的限制
- en: 'For convenience, the short form of the variable declaration does come with
    several restrictions that you should be aware of to avoid confusion:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，短变量声明的简写形式确实附带了一些限制，你应该注意这些限制以避免混淆：
- en: Firstly, it can only be used within a function block
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它只能在函数块中使用
- en: The assignment operator `:=`, declares variable and assign values
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符`:=`声明变量并赋值
- en: '`:=` cannot be used to update a previously declared variable'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:=`不能用来更新之前已声明的变量'
- en: Updates to variables must be done with an equal sign
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的更新必须使用等号
- en: While these restrictions may have their justifications rooted in the simplicity
    of Go's grammar, they are generally viewed as a source of confusion for newcomers
    to the language. For instance, the colon-equal operator cannot be used with package-level
    variables assignments. Developers learning Go may find it compelling to use the
    assignment operator as a way to update a variable, but that would cause a compilation
    error.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些限制可能有其根植于 Go 语法简单性的合理理由，但它们通常被视为语言新手的混淆来源。例如，不能在包级别变量赋值中使用冒号等于运算符。学习 Go
    的开发者可能会发现使用赋值运算符来更新变量很有吸引力，但这样做会导致编译错误。
- en: Variable scope and visibility
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域和可见性
- en: Go uses lexical scoping based on code blocks to determine the visibility of
    variables within a package. Depending on the location where a variable is declared,
    within the source text, will determine its scope. As a general rule, a variable
    is only accessible from within the block where it is declared and visible to all
    nested sub-blocks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用基于代码块的词法作用域来确定包内变量的可见性。根据变量在源文本中的声明位置，将决定其作用域。一般来说，变量只能从声明它的块内部访问，并且对所有嵌套的子块可见。
- en: 'The following screenshot illustrates the scope of several variables declared
    within a source text. Each variable declaration is marked with its scope (`package`,
    `function`, `for` loop, and `if...else` block):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了在源文本中声明的几个变量的作用域。每个变量声明都标有它的作用域（`package`、`function`、`for` 循环和 `if...else`
    块）：
- en: '![Variable scope and visibility](img/00007.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![变量作用域和可见性](img/00007.jpeg)'
- en: golang.fyi/ch02/makenums.go
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/makenums.go
- en: As explained earlier, variable visibility works top-down. Variables with package
    scope, such as `mapFile` and `numbersFile`, are globally visible to all other
    elements in the package. Moving down the scope ladder, function-block variables
    such as `data` and `err` are visible to all elements in the function and including
    sub-blocks. Variables `i` and `b` in the inner `for` loop block are only visible
    within that block. Once the loop is done, `i` and `b` would go out of scope.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，变量可见性是自顶向下的。具有包作用域的变量，如 `mapFile` 和 `numbersFile`，对包中的所有其他元素都是全局可见的。向下移动作用域层级，函数块变量如
    `data` 和 `err` 对函数及其子块中的所有元素可见。内层 `for` 循环块中的变量 `i` 和 `b` 只在该块内部可见。一旦循环完成，`i`
    和 `b` 就会超出作用域。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One source of confusion to newcomers to Go is the visibility of package-scoped
    variables. When a variable is declared at package level (outside of a function
    or method block), it is globally visible to the entire package, not just to the
    source file where the variable is declared. This means a package-scoped variable
    identifier can only be declared once in a group of files that make up a package,
    a fact that may not be obvious to developers starting out with Go. Refer to [Chapter
    6](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 6. Go
    Packages and Programs"), *Go Packages and Programs*, for details on package organization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Go 的新手来说，包作用域变量的可见性是一个容易混淆的问题。当一个变量在包级别（在函数或方法块之外）声明时，它对整个包都是全局可见的，而不仅仅是声明变量的源文件。这意味着包作用域的变量标识符只能在组成包的文件组中声明一次，这对于刚开始学习
    Go 的开发者来说可能并不明显。有关包组织的详细信息，请参阅[第 6 章](part0042_split_000.html#181NK2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第 6 章。Go 包和程序")，*Go 包和程序*。
- en: Variable declaration block
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明块
- en: 'Go''s syntax allows the declaration of top-level variables to be grouped together
    into blocks for greater readability and code organization. The following example
    shows a rewrite of one of the previous examples using the variable declaration
    block:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的语法允许将顶层变量的声明分组到一起，以提高可读性和代码组织。以下示例展示了使用变量声明块重写之前的一个示例：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch02/vardec5.go
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/vardec5.go
- en: Go constants
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 常量
- en: In Go, a constant is a value with a literal representation such as a string
    of text, Boolean, or numbers. The value for a constant is static and cannot be
    changed after initial assignment. While the concept they represent is simple,
    constants, however, have some interesting properties that make them useful, especially
    when working with numeric values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，常量是一个具有字面表示的值，例如文本字符串、布尔值或数字。常量的值是静态的，在初始赋值后不能更改。虽然它们所代表的概念很简单，但常量却有一些有趣的特性，使它们非常有用，尤其是在处理数值时。
- en: Constant literals
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量字面量
- en: Constants are values that can be represented by a text literal in the language.
    One of the most interesting properties of constants is that their literal representations
    can either be treated as typed or untyped values. Unlike variables, which are
    intrinsically bound to a type, constants can be stored as untyped values in memory
    space. Without that type constraint, numeric constant values, for instance, can
    be stored with great precision.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是语言中可以用文本字面量表示的值。常量最有趣的特性之一是它们的字面表示可以是带类型的或未指定类型的值。与本质上绑定到类型的变量不同，常量可以存储为内存空间中的未指定类型值。没有这种类型约束，例如，数值常量值可以以极高的精度存储。
- en: 'The followings are examples of valid constant literal values that can be expressed
    in Go:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Go中可以表示的有效常量字面值示例：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Typed constants
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带类型的常量
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Untyped constants
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未指定类型的常量
- en: 'Constants are even more interesting when they are untyped. An untyped constant
    is declared as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当常量未指定类型时，它们甚至更有趣。未指定类型的常量声明如下：
- en: '*const <identifier list> = <value list or initializer expression>*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`*const <标识符列表> = <值列表或初始化表达式>*'
- en: 'As before, the keyword `const` is used to declare a list of identifiers as
    constants along with their respective bounded values. However, in this format,
    the type specification is omitted in the declaration. As an untyped entity, a
    constant is merely a blob of bytes in memory without any type precision restrictions
    imposed. The following shows some sample declarations of untyped constants:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，使用关键字`const`来声明一系列标识符作为常量，以及它们各自的边界值。然而，在这个格式中，声明中省略了类型指定。作为一个未指定类型的实体，常量在内存中只是一个没有类型精度限制的字节块。以下是一些未指定类型常量的示例声明：
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Assigning untyped constants
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配未指定类型的常量
- en: 'Untyped constant values are of limited use until they are assigned to variables,
    used as function parameters, or are part of an expression assigned to a variable.
    In a strongly-typed language like Go, this means there is a potential for some
    type adjustment to ensure that the value stored in the constant can be properly
    assigned to the target variable. One advantage of using untyped constants is that
    the type system relaxes the strict application of type checking. An untyped constant
    can be assigned to different, though compatible, types of different precision
    without any complaint from the compiler, as shown in the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 未指定类型的常量值在分配给变量、用作函数参数或作为分配给变量的表达式的部分之前是有限的用途。在像Go这样的强类型语言中，这意味着存在一些类型调整的潜在可能性，以确保存储在常量中的值可以正确地分配给目标变量。使用未指定类型常量的一个优点是类型系统放宽了对类型检查的严格应用。未指定类型的常量可以分配给不同但兼容的不同精度的类型，而编译器不会提出任何异议，如下面的示例所示：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'While the type system will accommodate the assignment of `m2` to variables
    of different precision, the resulting assignment is adjusted to fit the variable
    type, as noted in the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型系统可以适应将`m2`分配给不同精度的变量，但结果分配会被调整以适应变量类型，如下所示：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What about variable `u3`, which is itself an untyped variable? Since `u3` does
    not have a specified type, it will rely on type inference from the constant value
    to receive a type assignment. Recall from the discussion in the section *Omitting
    Variable Types* earlier, that constant literals are mapped to basic Go types based
    on their textual representations. Since constant `m2` represents a decimal value,
    the compiler will infer its default to be a `float64`, which will be automatically
    assigned to variable `u3`, as shown:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量`u3`，它本身是一个未指定类型的变量，这是怎么回事呢？由于`u3`没有指定类型，它将依赖于从常量值中推断出的类型来接收类型分配。回想一下之前在*省略变量类型*部分中的讨论，常量字面量根据其文本表示映射到基本的Go类型。由于常量`m2`表示一个十进制值，编译器将推断其默认类型为`float64`，这将自动分配给变量`u3`，如下所示：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, Go's treatment of untyped raw constant literals increases the
    language's usability by automatically applying some simple, but effective, type
    inference rules without sacrificing type-safety. Unlike other languages, developers
    do not have to explicitly specify the type in the value literal or perform some
    sort of typecast to make this work.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Go对未指定类型的原始常量字面量的处理通过自动应用一些简单但有效的类型推断规则，在不牺牲类型安全性的情况下提高了语言的可用性。与其他语言不同，开发者不需要在值字面量中显式指定类型或执行某种类型的转换来使这成为可能。
- en: Constant declaration block
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量声明块
- en: 'As you may have guessed, constant declarations, can be organized as code blocks
    to increase readability. The previous example can be rewritten as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，常量声明可以组织为代码块以提高可读性。前面的示例可以重写如下：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch02/const2.go
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/const2.go
- en: Constant enumeration
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量枚举
- en: 'One interesting usage of constants is to create enumerated values. Using the
    declaration block format (shown in the preceding section), you can easily create
    numerically increasing enumerated integer values. Simply assign the pre-declared
    constant value `iota` to a constant identifier in the declaration block, as shown
    in the following code sample:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 常量的一种有趣用法是创建枚举值。使用声明块格式（如前一小节所示），您可以轻松创建数值递增的枚举整数值。只需将预声明的常量值 `iota` 赋给声明块中的常量标识符，如下面的代码示例所示：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch02/enum0.go
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum0.go
- en: 'The compiler will then automatically do the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将自动执行以下操作：
- en: Declare each member in the block as an untyped integer constant value
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将块中的每个成员声明为无类型的整型常量值
- en: Initialize `iota` with a value of zero
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用零值初始化 `iota`
- en: Assign `iota`, or zero, to the first constant member (`StarHyperGiant`)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `iota` 或零赋给第一个常量成员（`StarHyperGiant`）
- en: Each subsequent constant is assigned an `int` value increased by one
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个后续常量都被分配一个增加一的 `int` 值
- en: 'So the previous list of constants would be assigned a sequence of values going
    from zero to nine. Whenever `const` appears as a declaration block, it resets
    the counter to zero. In the following snippet, each set of constants is enumerated
    from zero to four separately:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的常量列表将被分配从零到九的值序列。每当 `const` 出现在声明块中时，它都会将计数器重置为零。在以下代码片段中，每组常量分别从零到四进行枚举：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch02/enum1.go
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum1.go
- en: Overriding the default enumeration type
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖默认枚举类型
- en: 'By default, an enumerated constant is declared as an untyped integer value.
    However, you can override the default type of the enumerated values by providing
    an explicit numeric type for your enumerated constants, as shown in the following
    code sample:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，枚举常量被声明为无类型的整数值。然而，您可以通过为枚举常量提供显式的数值类型来覆盖枚举值的默认类型，如下面的代码示例所示：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can specify any numeric type that can represent integers or floating point
    values. For instance, in the preceding code sample, each constant will be declared
    as type `byte`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定任何可以表示整数或浮点值的数值类型。例如，在前面的代码示例中，每个常量将被声明为类型 `byte`。
- en: Using iota in expressions
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在表达式中使用 `iota`
- en: 'When `iota` appears in an expression, the same mechanism works as expected.
    The compiler will apply the expression for each successive increasing value of
    `iota`. The following example assigns even numbers to the enumerated members of
    the constant declaration block:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `iota` 出现在表达式中时，相同的机制按预期工作。编译器将为 `iota` 的每个后续递增值应用表达式。以下示例将偶数分配给常量声明块中的枚举成员：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch02/enum2.go
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum2.go
- en: 'As you may expect, the previous example assigns an even value to each enumerated
    constants, starting with 0, as shown in the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，前面的示例将偶数值分配给每个枚举常量，从0开始，如下面的输出所示：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Skipping enumerated values
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过枚举值
- en: 'When working with enumerated constants, you may want to throw away certain
    values that should not be part of the enumeration. This can be accomplished by
    assigning iota to the blank identifier at the desired position in the enumeration.
    For instance, the following skips the values 0 and `64`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理枚举常量时，您可能希望丢弃某些不应包含在枚举中的值。这可以通过在枚举中所需位置将 `iota` 赋给空标识符来实现。例如，以下跳过了值0和 `64`：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch02/enum3.go
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch02/enum3.go
- en: 'Since we skip `iota` position `0`, the first assigned constant value is at
    position `1`. This results in expression `1 << iota` resolving to `1 << 1 = 2`.
    The same is done at the sixth position, where expression `1 << iota` returns `64`.
    That value will be skipped and not assigned to any constant, as shown in the following
    output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们跳过了 `iota` 位置 `0`，第一个分配的常量值位于位置 `1`。这导致表达式 `1 << iota` 解析为 `1 << 1 = 2`。同样，在第六个位置，表达式
    `1 << iota` 返回 `64`。该值将被跳过，不会分配给任何常量，如下面的输出所示：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Go operators
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go运算符
- en: Staying true to its simplistic nature, operators in Go do exactly what you would
    expect, mainly, they allow operands to be combined into expressions. There are
    no hidden surprise behaviors with Go operators as there is no support for operator-overloading
    as found in C++ or Scala. This was a deliberate decision from the designers to
    keep the semantics of the language simple and predictable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 保留其简洁的本质，Go语言中的运算符确实如您所期望的那样工作，主要允许操作数组合成表达式。Go语言的运算符没有像C++或Scala中那样的操作符重载，因此没有隐藏的意外行为。这是设计者有意做出的决定，以保持语言的语义简单和可预测。
- en: This section explores the most common operators that you will encounter as you
    start with Go. Other operators are covered throughout other chapters of the book.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了您开始学习Go语言时最常遇到的运算符。其他运算符将在本书的其他章节中介绍。
- en: Arithmetic operators
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: The following table summarizes the arithmetic operators supported in Go.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了Go语言支持的算术运算符。
- en: '| **Operator** | **Operation** | **Compatible types** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **操作** | **兼容类型** |'
- en: '| `*`, `/`, `-` | Multiplication, division, and subtraction | Integers, floating
    points, and complex numbers |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `*`, `/`, `-` | 乘法、除法和减法 | 整数、浮点数和复数 |'
- en: '| `%` | Remainder | Integers |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 余数 | 整数 |'
- en: '| `+` | Addition | Integers, floating points, complex numbers, and strings
    (concatenation) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 | 整数、浮点数、复数和字符串（连接）|'
- en: Note that the addition operator, `+`, can be applied to strings such as in the
    expression `var i = "G is" + " for Go"`. The two string operands are concatenated
    to create a new string that is assigned to variable `i`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，加法运算符`+`可以应用于字符串，例如在表达式`var i = "G is" + " for Go"`中。两个字符串操作数连接起来创建一个新的字符串，并将其赋值给变量`i`。
- en: The increment and decrement operators
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量和减量运算符
- en: 'As with other C-like languages, Go supports the `++` (increment) and the `--`
    (decrement) operators. When applied, these operators increase, or decrease, the
    operand''s value by one, respectively. The following shows a function that uses
    the decrement operator to traverse the letters in string s in the reverse order:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他C语言类似的语言一样，Go语言支持`++`（增量）和`--`（减量）运算符。当应用这些运算符时，它们分别将操作数的值增加或减少一。以下是一个使用减量运算符来以相反顺序遍历字符串`s`中的字母的函数示例：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is important to note that the increment and decrement operators are statements,
    not expressions, as shown in the following snippets:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：增量运算符和减量运算符是语句，而不是表达式，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Go assignment operators
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go语言赋值运算符
- en: '| **Operator** | **Description** |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `=` | The simple assignment works as expected. It updates the left operand
    with the value of the right. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 简单赋值按预期工作。它将右操作数的值更新到左操作数。|'
- en: '| `:=` | The colon-equal operator declares a new variable, the left-side operator,
    and assigns it the value (and type) of the operand on the right. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `:=` | 冒号等于运算符声明一个新变量，左侧运算符，并将其赋值为右侧操作数的值（和类型）。|'
- en: '| `+=`, `-=`, `*=`, `/=`, `%=` | Apply the indicated operation using the left
    and the right operator and store the result in the left operator. For instance,
    `a *= 8` implies `a = a * 8`. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `+=`, `-=`, `*=`, `/=`, `%=` | 使用左右运算符执行指定的操作，并将结果存储在左运算符中。例如，`a *= 8`表示`a
    = a * 8`。|'
- en: Bitwise operators
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位运算符
- en: 'Go includes full support for manipulating values at their most elemental forms.
    The following summarizes bitwise operators supported by Go:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言完全支持以最基本的形式操作值。以下总结了Go语言支持的按位运算符：
- en: '| **Operator** | **Description** |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **描述** |'
- en: '| `&` | Bitwise AND |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 按位与 |'
- en: '| `&#124;` | Bitwise OR |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 按位或 |'
- en: '| `a ^ b` | Bitwise XOR |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `a ^ b` | 按位异或 |'
- en: '| `&^` | Bitwise AND NOT |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `&^` | 按位与非 |'
- en: '| `^a` | Unary bitwise complement |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `^a` | 一元按位补码 |'
- en: '| `<<` | Left-shift |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 |'
- en: '| `>>` | Right-shift |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移 |'
- en: The right operand, in a shift operation, must be an unsigned integer or be able
    to be converted to an unsigned value. When the left operand is an untyped constant
    value, the compiler must be able to derive a signed integer type from its value
    or it will fail compilation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在位移操作中，右操作数必须是无符号整数或能够转换为无符号值。当左操作数是无类型的常量值时，编译器必须能够从其值推导出有符号整数类型，否则将无法编译。
- en: The shift operators in Go also support both arithmetic and logical shifts. If
    the left operand is unsigned, Go automatically applies logical shift, whereas
    if it is signed, Go will apply an arithmetic shift.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的位移操作符也支持算术位移和逻辑位移。如果左操作数是无符号的，Go 会自动应用逻辑位移；如果是符号的，Go 将应用算术位移。
- en: Logical Operators
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑操作符
- en: 'The following is a list of Go logical operations on Boolean values:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了 Go 语言对布尔值进行的逻辑操作：
- en: '| **Operator** | **Operation** |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **操作** |'
- en: '| `&&` | Logical AND |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 逻辑与 |'
- en: '| `&#124;&#124;` | Logical OR |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `||` | 逻辑或 |'
- en: '| `!` | Logical NOT |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 逻辑非 |'
- en: Comparison operators
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作符
- en: 'All Go types can be tested for equality, including basic and composite types.
    However, only string, integer, and floating-point values can be compared using
    ordering operators, as is summarized in the following table:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Go 类型都可以用于比较，包括基本类型和组合类型。然而，只有字符串、整数和浮点值可以使用排序运算符进行比较，如下表所示：
- en: '| **Operator** | **Operation** | **Supported type** |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **操作** | **支持类型** |'
- en: '| `==` | Equal | String, numeric, Boolean, interface, pointer, and struct types
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 等于 | 字符串、数值、布尔、接口、指针和结构体类型 |'
- en: '| `!=` | Not Equal | String, numeric, Boolean, interface, pointer, and struct
    types |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 不等于 | 字符串、数值、布尔、接口、指针和结构体类型 |'
- en: '| `<`, `<=`, `>`, `>=` | Ordering operators | String, integers, and floating
    points |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `<=`, `>`, `>=` | 排序操作符 | 字符串、整数和浮点数 |'
- en: Operator precedence
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符优先级
- en: 'Since Go has fewer operators than are found in its counterparts such as C or
    Java, its operator precedence rules are far simpler. The following table lists
    Go''s operator precedence echelon, starting with the highest:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 的操作符比其对应语言（如 C 或 Java）要少，因此其操作符优先级规则要简单得多。以下表格列出了 Go 的操作符优先级等级，从最高开始：
- en: '| **Operation** | **Precedence** |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **优先级** |'
- en: '| Multiplicative | `*`, `/`, `%`, `<<`, `>>`, `&`, `&^` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `*`, `/`, `%`, `<<`, `>>`, `&`, `&^` |'
- en: '| Additive | `+`, `-`, `&#124;`, `^` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `+`, `-`, `|`, `^` |'
- en: '| Comparative | `==`, `!=`, `<`, `<=`, `>`, `>=` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 比较操作符 | `==`, `!=`, `<`, `<=`, `>`, `>=` |'
- en: '| Logical AND | `&&` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑与 | `&&` |'
- en: '| Logical OR | `&#124;&#124;` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑或 | `||` |'
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered a lot of ground around the basic constructs of the Go language.
    It started with the structure of Go's source code text file and progressed to
    cover variable identifiers, declarations, and initializations. The chapter also
    provided extensive coverage of Go constants, constant declaration, and operators.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 Go 语言基本结构的大量内容。它从 Go 源代码文本文件的结构开始，逐步介绍变量标识符、声明和初始化。本章还广泛介绍了 Go 的常量、常量声明和操作符。
- en: At this point, you may feel a bit overwhelmed by so much pedestrian information
    about the language and its syntax. The good news is that you don't have to know
    all of these details to be productive with the language. In the following chapters,
    we will continue to explore some of the more interesting bits about Go, including
    data types, functions, and packages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能觉得关于语言及其语法的这么多基础信息让你有些不知所措。好消息是，你不必知道所有这些细节就能有效地使用这门语言。在接下来的章节中，我们将继续探讨
    Go 语言的一些更有趣的方面，包括数据类型、函数和包。
