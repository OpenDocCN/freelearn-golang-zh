- en: Chapter 5. Functions in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。Go 中的函数
- en: 'One of Go''s syntactical *tour de force* is via its support for higher-order
    functions as is found in dynamic languages such as Python or Ruby. As we will
    see in this chapter, a function is also a typed entity with a value that can be
    assigned to a variable. In this chapter, we are going to explore functions in
    Go covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语法中的一项*杰作*是其对高阶函数的支持，正如在 Python 或 Ruby 等动态语言中所发现的那样。正如我们在本章中将要看到的，函数也是一个具有值的类型实体，这个值可以被分配给一个变量。在本章中，我们将探讨
    Go 中的函数，包括以下主题：
- en: Go functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 函数
- en: Passing parameter values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递参数值
- en: Anonymous functions and closures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数和闭包
- en: Higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Error signaling handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信号处理
- en: Deferring function calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟函数调用
- en: Function panic and recovery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数恐慌和恢复
- en: Go functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 函数
- en: In Go, functions are first-class, typed programming elements. A declared function
    literal always has a type and a value (the defined function itself) and can optionally
    be bound to a named identifier. Because functions can be used as data, they can
    be assigned to variables or passed around as parameters of other functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，函数是一等、有类型的编程元素。声明的函数字面量始终具有类型和值（定义的函数本身），并且可以选择绑定到命名标识符。因为函数可以用作数据，所以它们可以被分配给变量或作为其他函数的参数传递。
- en: Function declaration
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数声明
- en: Declaring a function in Go takes the general form illustrated in the following
    figure. This canonical form is used to declare named and anonymous functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中声明函数采用以下一般形式，如图所示。这种规范形式用于声明命名和匿名函数。
- en: '![Function declaration](img/00013.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![函数声明](img/00013.jpeg)'
- en: The most common form of function definition in Go includes the function's assigned
    identifier in the function literal. To illustrate this, the following table shows
    the source code of several programs with definitions of named functions with different
    combinations of parameters and return types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，最常见的函数定义形式包括函数字面量中的函数的指定标识符。为了说明这一点，以下表格显示了几个程序的源代码，其中包含具有不同参数和返回类型组合的命名函数的定义。
- en: '| **Code** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** |'
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/func0.go | A function with the name identifier `printPi`. It
    takes no parameter and returns no values. Notice when there is nothing to return,
    the `return` statement is optional. |
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func0.go | 一个名为 `printPi` 的函数。它不接受任何参数，也不返回任何值。注意，当没有返回值时，`return`
    语句是可选的。|
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch05/func1.go | A function named `avogadro.` It takes no parameter
    but returns a value of type `float64`. Notice the `return` statement is required
    when a return value is declared as part of the function's signature. |
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func1.go | 一个名为 `avogadro` 的函数。它不接受任何参数，但返回一个 `float64` 类型的值。注意，当返回值作为函数签名的一部分声明时，需要
    `return` 语句。|
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch05/func2.go | This defines the function `fib`. It takes parameter
    `n` of type `int` and prints the Fibonacci sequence for up to `n`. Again, nothing
    to return, therefore the `return` statement is omitted. |
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func2.go | 这定义了函数 `fib`。它接受参数 `n`，类型为 `int`，并打印出最多到 `n` 的斐波那契数列。同样，没有返回值，因此省略了
    `return` 语句。|
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch05/func3.go | The last example defines the `isPrime` function.
    It takes a parameter of type `int` and returns a value of type `bool`. Since the
    function is declared to return a value of type `bool`, the last logical statement
    in the execution flow must be a `return` statement that returns a value of the
    declared type. |
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func3.go | 最后一个例子定义了 `isPrime` 函数。它接受一个 `int` 类型的参数，并返回一个 `bool`
    类型的值。由于函数被声明为返回 `bool` 类型的值，因此在执行流程中的最后一个逻辑语句必须是一个返回该声明类型的 `return` 语句。|
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Function signature**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数签名**'
- en: The set of specified parameter types, result types, and the order in which those
    types are declared is known as the signature of the function. It is another unique
    characteristic that help identify a function. Two functions may have the same
    number of parameters and result values; however, if the order of those elements
    are different, then the functions have different signatures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指定参数类型、结果类型及其声明的顺序的集合被称为函数的签名。这是帮助识别函数的另一个独特特征。两个函数可能有相同数量的参数和结果值；然而，如果这些元素的顺序不同，那么函数的签名就不同。
- en: The function type
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'Normally, the name identifier, declared in a function literal, is used to invoke
    the function using an invocation expression whereby the function identifier is
    followed by a parameter list. This is what we have seen throughout the book so
    far and it is illustrated in the following example calling the `fib` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在函数字面量中声明的名称标识符用于通过调用表达式调用函数，其中函数标识符后面跟着参数列表。这是我们到目前为止在书中看到的情况，以下示例展示了调用`fib`函数：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When, however, a function''s identifier appears without parentheses, it is
    treated as a regular variable with a type and a value as shown in the following
    program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当函数的标识符不带括号出现时，它被视为具有类型和值的普通变量，如下面的程序所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch05/functype.go
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/functype.go
- en: The type of a function is determined by its signature. Functions are considered
    to be of the same type when they have the same number of arguments with the same
    types in the same order. In the previous example the `opAdd` variable is declared
    having the type `func (int, int) int` . This is the same signature as the declared
    functions `add` and `sub`. Therefore, the `opAdd` variable is assigned the `add`
    function variable. This allows `opAdd` to be invoked as you would invoke the `add`
    function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的类型由其签名确定。当函数具有相同数量、相同类型且顺序相同的参数时，它们被认为是同一类型的。在之前的示例中，`opAdd`变量被声明为具有类型`func
    (int, int) int`。这与声明的函数`add`和`sub`的签名相同。因此，`opAdd`变量被分配了`add`函数变量。这允许`opAdd`以调用`add`函数的方式被调用。
- en: The same is done for the  `opSub` variable. It is assigned the value represented
    by the function identifier `sub` and type `func (int, int)`. Therefore, `opSub(99,13)`
    invokes the second function, which returns the result of a subtraction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`opSub`变量也是如此。它被分配了由函数标识符`sub`和类型`func (int, int)`表示的值。因此，`opSub(99,13)`调用了第二个函数，该函数返回减法的结果。
- en: Variadic parameters
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数
- en: The last parameter of a function can be declared as **variadic** (**variable
    length arguments**) by affixing ellipses (`…`) before the parameter's type. This
    indicates that zero or more values of that type may be passed to the function
    when it is called.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一个参数可以声明为**可变参数**（**可变长度参数**），通过在参数类型之前附加省略号（`…`）来实现。这表示在调用函数时，可以传递零个或多个该类型的值。
- en: 'The following example implements two functions that accept variadic parameters.
    The first function calculates the average of the passed values and the second
    function sums up the numbers passed in as arguments:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实现了两个接受可变参数的函数。第一个函数计算传递值的平均值，第二个函数将作为参数传递的数字求和：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: points := []float64{9, 4, 3.7, 7.1, 7.9, 9.2, 10}
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: points := []float64{9, 4, 3.7, 7.1, 7.9, 9.2, 10}
- en: fmt.Printf("sum(%v) = %f\n", points, sum(points...))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("sum(%v) = %f\n", points, sum(points...))
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Function result parameters
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数结果参数
- en: Go functions can be defined to return one or more result values. So far in the
    book, most of the functions we have encountered have been defined to return a
    single result value. In general, a function is able to return a list of result
    values, with diverse types, separated by a comma (see the previous section, *Function
    declaration*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Go函数可以被定义为返回一个或多个结果值。到目前为止，在书中，我们遇到的大多数函数都被定义为返回单个结果值。一般来说，一个函数能够返回由逗号分隔的多个结果值，具有不同的类型（参见上一节，*函数声明*）。
- en: 'To illustrate this concept, let us examine the following simple program which
    defines a function that implements an Euclidian division algorithm (see [http://en.wikipedia.org/wiki/Division_algorithm](http://en.wikipedia.org/wiki/Division_algorithm)).
    The `div` function returns both the quotient and the remainder values as its result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，让我们检查以下简单的程序，该程序定义了一个实现欧几里得除法算法（参见[http://en.wikipedia.org/wiki/Division_algorithm](http://en.wikipedia.org/wiki/Division_algorithm)）的函数。`div`函数返回商和余数值作为其结果：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch05/funcret0.go
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcret0.go
- en: The `**return**` keyword is followed by the number of result values matching
    (respectively) the declared results in the function's signature. In the previous
    example, the signature of the `div` function specifies two `int` values to be
    returned as result values. Internally, the function defines `int` variables `p`
    and `r` that are returned as result values upon completion of the function. Those
    returned values must match the types defined in the function's signature or risk
    compilation errors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`**return**` 关键字后面跟着与函数签名中声明的结果匹配的结果值数量。在先前的例子中，`div` 函数的签名指定了两个 `int` 值作为结果值。在函数内部，该函数定义了
    `int` 变量 `p` 和 `r`，在函数完成后作为结果值返回。这些返回值必须与函数签名中定义的类型匹配，否则可能会出现编译错误。'
- en: 'Functions with multiple result values must be invoked in the proper context:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个结果值的函数必须在正确的上下文中调用：
- en: They must be assigned to a list of identifiers of the same types respectively
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须分别分配给相同类型的标识符列表
- en: They can only be included in expressions that expect the same number of returned
    values
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能包含在期望相同数量返回值的表达式中
- en: 'This is illustrated in the following source snippet:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下源代码片段中得到了说明：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Named result parameters
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名结果参数
- en: 'In general, the result list of a function''s signature can be specified using
    variable identifiers along with their types. When using named identifiers, they
    are passed to the function as regular declared variables and can be accessed and
    modified as needed. Upon encountering a `return` statement, the last assigned
    result values are returned. This is illustrated in the following source snippet,
    which is a rewrite of the previous program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以使用变量标识符及其类型来指定函数签名的结果列表。当使用命名标识符时，它们作为常规声明的变量传递给函数，并且可以根据需要访问和修改。在遇到 `return`
    语句时，最后分配的结果值将被返回。这在下述源代码片段中得到了说明，这是先前程序的改写：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: golang.fyi/ch05/funcret1.go
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcret1.go
- en: Notice the `return` statement is naked; it omits all identifiers. As stated
    earlier, the values assigned in `q` and `r` will be returned to the caller. For
    readability, consistency, or style, you may elect not to use a naked `return`
    statement. It is perfectly legal to attach the identifier's name with the `return`
    statement (such as `return q, r`) as before.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `return` 语句是裸露的；它省略了所有标识符。如前所述，`q` 和 `r` 中分配的值将被返回给调用者。为了可读性、一致性或风格，您可以选择不使用裸露的
    `return` 语句。将标识符的名称附加到 `return` 语句（如 `return q, r`）是完全可以接受的。
- en: Passing parameter values
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数值
- en: 'In Go, all parameters passed to a function are done so by value. This means
    a local copy of the passed values is created inside the called function. There
    is no inherent concept of passing parameter values by reference. The following
    code illustrates this mechanism by modifying the value of the passed parameter,
    `val`, inside the `dbl` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，所有传递给函数的参数都是按值传递的。这意味着在调用函数内部创建了一个传递值的局部副本。没有传递参数值按引用传递的固有概念。以下代码通过在
    `dbl` 函数内部修改传递的参数 `val` 的值来演示这一机制：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch05/funcpassbyval.go
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcpassbyval.go
- en: 'When the program runs, it produces the following output that chronicles the
    state of the `p` variable before it is passed to the `dbl` function. The update
    is made locally to the passed parameter variable inside the `dbl` function, and
    lastly the value of the `p` variable after the `dbl` function is called:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它会产生以下输出，记录了在传递给 `dbl` 函数之前 `p` 变量的状态。更新是在 `dbl` 函数内部传递的参数变量本地进行的，最后是调用
    `dbl` 函数后 `p` 变量的值：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding output shows that the original value assigned to variable `p`
    remains variable unchanged, even after it is passed to a function that seems to
    update its value internally. This is because the `val` parameter in the `dbl`
    function receives a local copy of the passed parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，分配给变量 `p` 的原始值在传递给似乎在内部更新其值的函数之后保持不变。这是因为 `dbl` 函数中的 `val` 参数接收了传递参数的局部副本。
- en: Achieving pass-by-reference
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现按引用传递
- en: 'While the pass-by-value is appropriate in many cases, it is important to note
    that Go can achieve pass-by-reference semantics using pointer parameter values.
    This allows a called function to reach outside of its lexical scope and change
    the value stored at the location referenced by the pointer parameter as is done
    in the `half` function in the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然按值传递在许多情况下是合适的，但需要注意的是，Go可以通过使用指针参数值来实现按引用语义。这允许被调用的函数超出其词法作用域，并改变由指针参数引用的位置存储的值，就像以下示例中的`half`函数所做的那样：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: golang.fyi/ch05/funcpassbyref.go
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcpassbyref.go
- en: 'In the previous example, the call to the `half(&num)` function in `main()`
    updates, in place, the original value referenced by its `num` parameter. So, when
    the code is executed, it shows the original value of `num` and its value after
    the call to the `half` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，`main()`中对`half(&num)`函数的调用就地更新了其`num`参数引用的原始值。因此，当代码执行时，它显示了`num`的原始值和调用`half`函数后的值：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As was stated earlier, Go function parameters are passed by value. This is true
    even when the function takes a pointer value as its parameter. Go still creates
    and passes in a local copy of the pointer value. In the previous example, the
    `half` function receives a copy of the pointer value it receives via the `val`
    parameter. The code uses pointer operator (`*`) to dereference and manipulate,
    in place, the value referenced by `val`. When the `half` function exits and goes
    out of scope, its changes are accessible by calling the `main` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Go函数参数是按值传递的。即使函数接受指针值作为其参数，这也是正确的。Go仍然创建并传递指针值的本地副本。在先前的示例中，`half`函数通过`val`参数接收到的指针值的副本。代码使用指针运算符（`*`）进行解引用并就地操作由`val`引用的值。当`half`函数退出并超出作用域时，其更改可以通过调用`main`函数来访问。
- en: Anonymous Functions and Closures
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数和闭包
- en: 'Functions can be written as literals without a named identifier. These are
    known as anonymous functions and can be assigned to a variable to be invoked later
    as shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以写成字面量，而不需要命名标识符。这些被称为匿名函数，可以将它们赋给变量以供以后调用，如下面的示例所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch05/funcs.go
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcs.go
- en: The previous program shows two anonymous functions declared and bound to the
    `mul` and `sqr` variables. In both cases, the functions take in parameters and
    return a value. Later in `main()`, the variables are used to invoke the function
    code bound to them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序显示了两个声明并绑定到`mul`和`sqr`变量的匿名函数。在两种情况下，函数都接受参数并返回一个值。在`main()`的后面，这些变量被用来调用绑定到它们的函数代码。
- en: Invoking anonymous function literals
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用匿名函数字面量
- en: 'It is worth noting that an anonymous function does not have to be bound to
    an identifier. The function literal can be evaluated, in place, as an expression
    that returns the function''s result. This is done by ending the function literal
    with a list of argument values, enclosed in parentheses, as shown in the following
    program:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，匿名函数不必绑定到标识符。函数字面量可以直接作为返回函数结果的表达式进行评估。这是通过在函数字面量末尾添加一个括号内的参数值列表来完成的，如下面的程序所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the function literal ends with a parameter list enclosed within parentheses,
    the function is invoked as an expression.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数字面量以括号内的参数列表结束，因此函数作为表达式被调用。
- en: Closures
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Go function literals are closures. This means they have lexical visibility
    to non-local variables declared outside of their enclosing code block. The following
    example illustrates this fact:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Go函数字面量是闭包。这意味着它们对其封装代码块外部声明的非局部变量具有词法可见性。以下示例说明了这一点：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: github.com/vladimirvivien/learning-go/ch05/funcs.go
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: github.com/vladimirvivien/learning-go/ch05/funcs.go
- en: In the previous program, the function literal code block, `func() float64 {return
    deg * math.Pi / 180}()`, is defined as an expression that converts degrees to
    radians. With each iteration of the loop, a closure is formed between the enclosed
    function literal and the outer non-local variable, `i`. This provides a simpler
    idiom where the function naturally accesses non-local values without resorting
    to other means such as pointers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的程序中，函数字面量代码块`func() float64 {return deg * math.Pi / 180}()`被定义为将度数转换为弧度的表达式。在循环的每次迭代中，在封闭的函数字面量和外部非局部变量`i`之间形成一个闭包。这提供了一种更简单的语法，其中函数自然地访问非局部值，而无需求助于其他手段，如指针。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Go, lexically closed values can remain bounded to their closures long after
    the outer function that created the closure has gone out of scope. The garbage
    collector will handle cleanups as these closed values become unbounded.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，词法封闭的值可以在创建封闭的外部函数超出作用域很长时间后仍然与其封闭相关联。垃圾收集器将在这些封闭值变得无界时处理清理工作。
- en: Higher-order functions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: We have already established that Go functions are values bound to a type. So,
    it should not be a surprise that a Go function can take another function as a
    parameter and also return a function as a result value. This describes the notion
    known as a higher-order function, which is a concept adopted from mathematics.
    While types such as `struct` let programmers abstract data, higher-order functions
    provide a mechanism to encapsulate and abstract behaviors that can be composed
    together to form more complex behaviors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定 Go 函数是与类型绑定的值。因此，一个 Go 函数可以接受另一个函数作为参数，也可以返回一个函数作为结果值，这描述了被称为高阶函数的概念，这是一个从数学中采纳的概念。虽然
    `struct` 等类型允许程序员抽象数据，但高阶函数提供了一种封装和抽象行为的方式，这些行为可以组合在一起形成更复杂的行为。
- en: 'To make this concept clearer, let us examine the following program, which uses
    a higher-order function, `apply`, to do three things. It accepts a slice of integers
    and a function as parameters. It applies the specified function to each element
    in the slice. Lastly, the `apply` function also returns a function as its result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个概念更清晰，让我们检查以下程序，它使用一个高阶函数 `apply` 来完成三件事情。它接受一个整数切片和一个函数作为参数。它将指定的函数应用于切片中的每个元素。最后，`apply`
    函数还返回一个函数作为其结果：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch05/funchighorder.go
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funchighorder.go
- en: 'In the program, the `apply` function is invoked with an anonymous function
    that halves each element in the slice as highlighted in the following snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`apply` 函数通过一个匿名函数调用，将切片中的每个元素减半，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Error signaling and handling
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误信号和处理
- en: At this point, let us address how to idiomatically signal and handle errors
    when you make a function call. If you have worked with languages such as Python,
    Java, or C#, you may be familiar with interrupting the flow of your executing
    code by throwing an exception when an undesirable state arises.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们讨论在函数调用时如何惯用信号和处理错误。如果您使用过 Python、Java 或 C# 等语言，您可能熟悉在出现不希望的状态时通过抛出异常来中断执行流程。
- en: As we will explore in this section, Go has a simplified approach to error signaling
    and error handling that puts the onus on the programmer to handle possible errors
    immediately after a called function returns. Go discourages the notion of interrupting
    an execution by indiscriminately short-circuiting the executing program with an
    exception in the hope that it will be properly handled further up the call stack.
    In Go, the traditional way of signaling errors is to return a value of type `error`
    when something goes wrong during the execution of your function. So let us take
    a closer look how this is done.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本节中探讨的，Go 对错误信号和错误处理采用了简化的方法，将责任放在程序员身上，要求在调用函数返回后立即处理可能出现的错误。Go 不鼓励通过在执行程序中无差别地短路异常来中断执行，希望它将在调用堆栈的更高处得到适当处理。在
    Go 中，传统的错误信号方式是在函数执行过程中出现问题时返回一个类型为 `error` 的值。因此，让我们更详细地看看这是如何实现的。
- en: Signaling errors
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号错误
- en: To better understand what has been described in the previous paragraph, let
    us start with an example. The following source code implements an anagram program,
    as described in Column 2 from Jon Bentley's popular *Programming Pearls* book
    (second edition). The code reads a dictionary file (`dict.txt`) and groups all
    words with the same anagram. If the code does not quite make sense, please see
    [golang.fyi/ch05/anagram1.go](http://learning.golang.fyi/ch05/anagram1.go) for
    an annotated explanation of how each part of the program works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解前一段落中描述的内容，让我们从一个例子开始。以下源代码实现了 Jon Bentley 流行书籍 *Programming Pearls*（第二版）中第
    2 列描述的字母表程序。该代码读取字典文件（`dict.txt`）并将所有具有相同字母表的单词分组。如果代码不太清楚，请参阅 [golang.fyi/ch05/anagram1.go](http://learning.golang.fyi/ch05/anagram1.go)，以了解程序每个部分的注释说明。
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: when the expected filename (`fname`) is empty
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期的文件名（`fname`）为空时
- en: when the call to `os.Open()` fails (for example, permission error, or otherwise)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `os.Open()` 失败时（例如，权限错误，或其他情况）
- en: In the first case, when a filename is not provided, the code returns an error
    using `errors.New()` to create a value of type `error` to exit the function. In
    the second case, the `os.Open` function returns a pointer representing the file
    and an error assigned to the `file` and `err` variables respectively. If `err`
    is not `nil` (meaning an error was generated), the execution of the `load` function
    is halted prematurely and the value of `err` is returned to be handled by the
    calling function further up the call stack.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，当没有提供文件名时，代码使用`errors.New()`创建一个`error`类型的值来退出函数。在第二种情况下，`os.Open`函数返回一个表示文件的指针和一个错误，分别赋值给`file`和`err`变量。如果`err`不是`nil`（表示生成了错误），则`load`函数的执行会提前终止，并将`err`的值返回给调用栈上更高层的调用函数处理。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When returning an error for a function with multiple result parameters, it is
    customary to return the zero-value for the other (non-error type) parameters.
    In the example, a value of `nil` is returned for the result of type `[]string`.
    While not necessary, it simplifies error handling and avoids any confusion for
    function callers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数有多个结果参数时返回错误，通常习惯于为其他（非错误类型）参数返回零值。在示例中，对于`[]string`类型的返回值返回了`nil`值。虽然这不是必需的，但它简化了错误处理，并避免了函数调用者产生任何混淆。
- en: Error handling
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `main` function is the topmost caller in the call stack, it handles
    the error by terminating the entire program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`main`函数是调用栈中最顶层的调用者，它通过终止整个程序来处理错误。
- en: This is all there is to the mechanics of error handling in Go. The language
    forces the programmer to always test for an erroneous state on every function
    call that returns a value of the type `error`. The `if…not…nil error` handling
    idiom may seem excessive and verbose to some, especially if you are coming from
    a language with formal exception mechanisms. However, the gain here is that the
    program can construct a robust execution flow where programmers always know where
    errors may come from and handle them appropriately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Go中错误处理机制的全部内容。该语言强制程序员在每次返回`error`类型值的函数调用时都测试错误状态。`if…not…nil error`处理方法可能对某些人来说显得过于冗长，尤其是如果你来自具有正式异常机制的语言。然而，这里的优势是程序可以构建一个健壮的执行流程，程序员总是知道错误可能来自哪里，并适当地处理它们。
- en: The error type
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误类型
- en: 'The `error` type is a built-in interface and, therefore must be implemented
    before it can be used. Fortunately, the Go standard library comes with implementations
    ready to be used. We have already used one of the implementation from the package,
    `errors`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`类型是一个内置接口，因此在使用之前必须实现。幸运的是，Go标准库提供了现成的实现。我们已经使用了一个来自该包的实现，即`errors`：'
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also create parameterized error values using the `fmt.Errorf` function
    as shown in the following snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`fmt.Errorf`函数创建参数化的错误值，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)'
- en: You can also create your own implementation of the `error` interface to create
    custom errors. This topic is revisited in [Chapter 7](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces, and Objects* where
    the book discusses the notion of extending types.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的`error`接口实现来创建自定义错误。这个主题在[第7章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象")，*方法、接口和对象*中再次被提及，书中讨论了扩展类型的概念。
- en: Deferring function calls
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟函数调用
- en: 'Go supports the notion of deferring a function call. Placing the keyword `defer`
    before a function call has the interesting effect of pushing the function unto
    an internal stack, delaying its execution right before the enclosing function
    returns. To better explain this, let us start with the following simple program
    that illustrates the use of `defer`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持延迟函数调用的概念。在函数调用前放置关键字`defer`会产生有趣的效果，它将函数推入一个内部栈，延迟其执行直到包含函数返回之前。为了更好地解释这一点，让我们从一个简单的程序开始，该程序说明了`defer`的使用：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch05/defer1.go
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/defer1.go
- en: 'The previous example defines the `do` function that takes variadic parameter
    `steps`. The function defers the statement with `defer fmt.Println("All done!")`.
    Next, the function loops through slice `steps` and defers the output of each element
    with `defer fmt.Println(s).` The last statement in the function `do` is a non-deferred
    call to `fmt.Println("Starting").` Notice the order of the printed string values
    when the program is executed, as shown in the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例定义了 `do` 函数，该函数接受可变参数 `steps`。该函数使用 `defer fmt.Println("All done!")` 延迟语句。接下来，该函数遍历
    `steps` 切片，并使用 `defer fmt.Println(s)` 延迟输出每个元素。函数 `do` 中的最后一个语句是对 `fmt.Println("Starting")`
    的非延迟调用。注意程序执行时打印的字符串值的顺序，如下面的输出所示：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are a couple facts that explain the reverse order of the printout. First,
    recall that deferred functions are executed right before their enclosing function
    returns. Therefore, the first value printed is generated by the last non-deferred
    method call. Next, as stated earlier, deferred statements are pushed into a stack.
    Therefore, deferred calls are executed using a last-in-first-out order. That is
    why `"All done!"` is the last string value printed in the output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个事实可以解释打印输出的反向顺序。首先，回想一下，延迟函数是在其封装函数返回之前执行的。因此，第一个打印的值是由最后一个非延迟方法调用生成的。其次，如前所述，延迟语句被推入一个栈中。因此，延迟调用是按照后进先出的顺序执行的。这就是为什么
    `"All done!"` 是输出中最后一个打印的字符串值。
- en: Using defer
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 defer
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch05/anagram2.go
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram2.go
- en: The pattern of opening-defer-closing resources is widely used in Go. By placing
    the deferred intent immediately after opening or creating a resource allows the
    code to read naturally and reduces the likeliness of creating a resource leakage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，打开-defer-关闭资源的模式被广泛使用。通过在打开或创建资源后立即放置延迟意图，可以使代码读起来更自然，并减少资源泄漏的可能性。
- en: Function panic and recovery
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数 panic 和恢复
- en: Earlier in the chapter, it was stated that Go does not have the traditional
    exception mechanism offered by other languages. Nevertheless, in Go, there is
    a way to abruptly exit an executing function known as function panic. Conversely,
    when a program is panicking, Go provides a way of recovering and regaining control
    of the execution flow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，提到 Go 没有其他语言提供的传统异常机制。然而，在 Go 中，有一种突然退出执行函数的方法，称为函数 panic。相反，当程序处于 panic
    状态时，Go 提供了一种恢复和重新控制执行流程的方法。
- en: Function panic
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 panic
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Function panic recovery
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数 panic 恢复
- en: When a function panics, as explained earlier, it can crash an entire program.
    That may be the desired outcome depending on your requirements. It is possible,
    however, to regain control after a panic sequence has started. To do this, Go
    offers the built-in function called `recover`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数 panic 时，如前所述，它可以崩溃整个程序。这可能取决于你的需求。然而，在 panic 序列开始后，可以重新获得控制。为此，Go 提供了一个内置的函数，称为
    `recover`。
- en: 'Recover works in tandem with panic. A call to function recover returns the
    value that was passed as an argument to panic. The following code shows how to
    recover from the panic call that was introduced in the previous example. In this
    version, the write function is moved inside `makeAnagram()` for clarity. When
    the `write` function is invoked from `makeAnagram()` and fails to open a file,
    it will panic. However, additional code is now added to recover:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Recover 与 panic 一起工作。对函数 recover 的调用返回传递给 panic 的值。下面的代码显示了如何从上一个示例中引入的 panic
    调用中恢复。在这个版本中，为了清晰起见，将 `write` 函数移动到 `makeAnagram()` 内部。当从 `makeAnagram()` 调用 `write`
    函数并无法打开文件时，它将 panic。然而，现在添加了额外的代码来恢复：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: golang.fyi/ch05/anagram3.go
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram3.go
- en: 'To be able to recover from an unwinding panic sequence, the code must make
    a deferred call to the recover function. In the previous code, this is done in
    the `makeAnagrams` function by wrapping `recover()` inside an anonymous function
    literal, as highlighted in the following snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够从展开的 panic 序列中恢复，代码必须对 recover 函数进行延迟调用。在前面的代码中，这是通过在 `makeAnagrams` 函数中将
    `recover()` 包裹在匿名函数字面量中来实现的，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When the deferred `recover` function is executed, the program has an opportunity
    to regain control and prevent the panic from crashing the running program. If
    `recover()` returns `nil`, it means there is no current panic unwinding up the
    call stack or the panic was already handled downstream.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当延迟的 `recover` 函数执行时，程序有机会重新获得控制并防止 panic 崩溃正在运行的程序。如果 `recover()` 返回 `nil`，则表示没有当前
    panic 正在沿着调用栈展开，或者 panic 已经在下游被处理。
- en: 'So, now when the program is executed, instead of crashing with a stack trace,
    the program recovers and gracefully displays the issue as shown in the following
    output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当程序执行时，它不会因为堆栈跟踪而崩溃，而是恢复并优雅地显示问题，如下面的输出所示：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why we are using a `nil` to test the value returned by
    the `recover` function when a string was passed inside the call to `panic`. This
    is because both panic and recover take an empty interface type. As you will learn,
    the empty interface type is a generic type with the ability to represent any type
    in Go's type system. We will learn more about the empty interface in [Chapter
    7](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 8. Methods,
    Interfaces, and Objects"), *Methods, Interfaces and Objects* during discussions
    about interfaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们在调用`panic`函数时传递了一个字符串，却在测试`recover`函数返回的值时使用了一个`nil`。这是因为`panic`和`recover`都接受一个空的接口类型。正如你将要学习的，空的接口类型是一个泛型类型，它具有在Go的类型系统中表示任何类型的能力。我们将在[第7章](part0056_split_000.html#1LCVG1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第8章。方法、接口和对象")，*方法、接口和对象*的讨论中了解更多关于空接口的内容。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented its reader with an exploration of Go functions. It started
    with an overview of named function declarations, followed by a discussion on function
    parameters. The chapter delved into a discussion of function types and function
    values. The last portion of the chapter discussed the semantics of error handling,
    panic, and recovery. The next chapter continues the discussion of functions; however,
    it does so within the context of Go packages. It explains the role of a package
    as a logical grouping of Go functions (and other code elements) to form sharable
    and callable code modules.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向读者展示了Go函数的探索。它从命名函数声明的概述开始，然后讨论了函数参数。本章深入讨论了函数类型和函数值。章节的最后部分讨论了错误处理、panic和恢复的语义。下一章将继续讨论函数；然而，它是在Go包的上下文中进行的。它解释了包作为Go函数（和其他代码元素）的逻辑分组的作用，以形成可共享和可调用的代码模块。
