- en: Chapter 8. Methods, Interfaces, and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。方法、接口和对象
- en: 'Using your skills at this point, you can write an effective Go program using
    the fundamental concepts covered so far. As you will see in this chapter, the
    Go type system can support idioms that go beyond simple functions. While the designers
    of Go did not intend to create an object-oriented language with deep class hierarchies,
    the language is perfectly capable of supporting type compositions with advanced
    features to express the creation of complex object-like structures, as covered
    in the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你目前掌握的技能，你可以使用到目前为止所涵盖的基本概念编写一个有效的Go程序。正如你将在本章中看到的，Go的类型系统可以支持超越简单函数的惯用法。虽然Go的设计者并没有打算创建一个具有深层类层次结构的面向对象语言，但该语言完全能够支持具有高级功能的类型组合，以表达复杂对象结构的创建，以下将涵盖这些主题：
- en: Go methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go方法
- en: Objects in Go
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的对象
- en: The interface type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口类型
- en: Type assertion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言
- en: Go methods
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go方法
- en: A Go function can be defined with a scope narrowed to that of a specific type.
    When a function is scoped to a type, or attached to the type, it is known as a
    *method*. A method is defined just like any other Go function. However, its definition
    includes a *method receiver*, which is an extra parameter placed before the method's
    name, used to specify the host type to which the method is attached.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Go函数可以被定义为具有缩小到特定类型的范围。当一个函数的范围缩小到类型时，或者附加到类型上，它被称为*方法*。方法定义的方式就像任何其他Go函数一样。然而，其定义包括一个*方法接收器*，这是一个放在方法名称之前额外的参数，用于指定方法附加的主类型。
- en: 'To better illustrate this concept, the following figure highlights the different
    parts involved in defining a method. It shows the `quart` method attached to the
    `type gallon` based receiver via the `g gallon` receiver parameter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这个概念，以下图突出了定义方法时涉及的不同部分。它显示了通过`g gallon`接收器参数附加到`type gallon`基于接收器的`quart`方法：
- en: '![Go methods](img/00018.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Go方法](img/00018.jpeg)'
- en: 'As mentioned, a method has the scope of a type. Therefore, it can only be accessed
    via a declared value (concrete or pointer) of the attached type using *dot notation*.
    The following program shows how the declared method `quart` is accessed using
    this notation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，方法具有类型的范围。因此，它只能通过使用*点符号*的声明值（具体或指针）访问附加的类型。以下程序展示了如何使用这种表示法访问声明的方法`quart`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch08/method_basic.go
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/method_basic.go
- en: In the previous example, the `gal` variable is initialized as the `gallon` type.
    Therefore, the `quart` method can be accessed using `gal.quart()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`gal`变量被初始化为`gallon`类型。因此，可以通过`gal.quart()`使用`quart`方法。
- en: 'At runtime, the receiver parameter provides access to the value assigned to
    the base type of the method. In the example, the `quart` method receives the `g`
    parameter, which passes in a copy of the value for the declared type. So when
    the `gal` variable is initialized with a value of `5`, a call to `gal.quart()`
    sets the receiver parameter `g` to `5`. So the following would then print a value
    of `20`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，接收器参数提供了对方法基本类型分配的值的访问。在示例中，`quart`方法接收`g`参数，它传递了声明的类型的值副本。因此，当`gal`变量初始化为`5`时，对`gal.quart()`的调用将接收器参数`g`设置为`5`。因此，以下代码将打印出`20`的值：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is important to note that the base type for method receivers cannot be a
    pointer (nor an interface). For instance, the following will not compile:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，方法接收器的基本类型不能是指针（也不能是接口）。例如，以下代码将无法编译：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following shows a lengthier version of the source that implements a more
    general liquid volume conversion program. Each volumetric type receives its respective
    methods to expose behaviors attributed to that type:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了实现一个更通用液体体积转换程序的源代码的较长版本。每个体积类型都接收其相应的方法来暴露该类型所具有的行为：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: github.com/vladimirvivien/learning-go/ch08/methods.go
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: github.com/vladimirvivien/learning-go/ch08/methods.go
- en: 'For instance, converting `5` gallons to ounces can be done by invoking the
    proper conversion methods on a given value, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将`5`加仑转换为盎司可以通过在给定值上调用适当的转换方法来完成，如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entire implementation uses a simple, but effective, typical structure to
    represent both data type and behavior. Reading the code, it cleanly expresses
    its intended meaning without any reliance on heavy class structures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 整个实现使用了一种简单但有效的典型结构来表示数据类型和行为。阅读代码时，它清晰地表达了其预期的含义，而不依赖于任何重类的结构。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Method set**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法集**'
- en: The number of methods attached to a type, via the receiver parameter, is known
    as the type's *method set*. This includes both concrete and pointer value receivers.
    The concept of a method set is important in determining type equality, interface
    implementation, and support of the notion of the empty method set for the *empty
    interface* (all discussed in this chapter).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接收器参数附加到类型的方法数量被称为该类型的*方法集*。这包括具体的和指针值接收器。方法集的概念在确定类型相等性、接口实现以及支持*空接口*的空方法集概念中非常重要（本章中均有讨论）。
- en: Value and pointer receivers
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值和指针接收器
- en: One aspect of methods that has escaped discussion so far is that receivers are
    normal function parameters. Therefore, they follow the pass-by-value mechanism
    of Go functions. This implies that the invoked method gets a copy of the original
    value from the declared type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，尚未讨论的方法的一个方面是接收器是正常的函数参数。因此，它们遵循Go函数的按值传递机制。这意味着被调用的方法会从声明的类型中获取原始值的副本。
- en: 'Receiver parameters can be passed as either values of or pointers of the base
    type. For instance, the following program shows two methods, `half` and `double`;
    both directly update the value of their respective method receiver parameters,
    `g`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器参数可以是基类型的值或指针。例如，以下程序显示了两个方法，`half`和`double`；它们都直接更新各自的方法接收器参数`g`的值：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch08/receiver_ptr.go
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/receiver_ptr.go
- en: 'In the `half` method, the code updates the receiver parameter with `g = gallon(g
    * 0.5)`. As you would expect, this will not update the original declared value,
    but rather the copy stored in the `g` parameter. So, when `gal.half()` is invoked
    in `main`, the original value remains unchanged and the following would print
    `5`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`half`方法中，代码通过`g = gallon(g * 0.5)`更新接收器参数。正如你所预期的那样，这不会更新原始声明的值，而是更新存储在`g`参数中的副本。因此，当在`main`中调用`gal.half()`时，原始值保持不变，以下将打印`5`：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pointer receiver parameters are widely used in Go. This is because they make
    it possible to express object-like primitives that can carry both state and behaviors.
    As the next section shows, pointer receivers, along with other type features,
    are the basis for creating objects in Go.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 指针接收器参数在Go中广泛使用。这是因为它们使得表达既携带状态又具有行为的对象原语成为可能。正如下一节所示，指针接收器，连同其他类型特性，是创建Go中对象的基础。
- en: Objects in Go
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的对象
- en: The lengthy introductory material from the previous sections was the setup to
    lead to the discussion of objects in Go. It has been mentioned that Go was not
    designed to function as traditional object-oriented language. There are no object
    or class keywords defined in Go. So then, why are we discussing objects in Go
    at all? Well, it turns out that Go perfectly supports object idioms and the practice
    of object-oriented programming without the heavy baggage of classical hierarchies
    and complex inheritance structures found in other object-oriented languages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中冗长的介绍性材料是为了引出对Go中对象的讨论。已经提到，Go并非设计成作为传统的面向对象语言。Go中没有定义对象或类关键字。那么，我们为什么还要讨论Go中的对象呢？好吧，结果是Go完美地支持了面向对象的习惯用法和面向对象编程的实践，而没有其他面向对象语言中发现的经典层次结构和复杂继承结构的沉重负担。
- en: Let us review some of the primordial features usually attributed to an object-oriented
    language in the following table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下表中回顾一下通常归因于面向对象语言的一些原始特性。
- en: '| **Object feature** | **Go** | **Comment** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **对象特性** | **Go** | **注释** |'
- en: '| Object: A data type that stores states and exposes behavior | Yes | In Go
    all types can achieve this. There is no special type called a class or object
    to do this. Any type can receive a set of method to define its behavior, although
    the `struct` type comes the closest to what is commonly called an object in other
    languages. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 对象：存储状态并公开行为的类型 | 是 | 在Go中，所有类型都可以实现这一点。没有称为类或对象的特殊类型来完成这项工作。任何类型都可以接收一组方法来定义其行为，尽管`struct`类型在其它语言中通常称为对象最为接近。|'
- en: '| Composition | Yes | Using a type such as a `struct` or an `interface` (discussed
    later), it is possible to create objects and express their polymorphic relationships
    through composition. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 组合 | 是 | 使用`struct`或`interface`（稍后讨论）等类型，可以创建对象并通过组合表达它们的多态关系。|'
- en: '| Subtype via interface | Yes | A type that defines a set of behaviors (methods)
    that other types may implement. Later you will see how it is used to implement
    object sub-typing. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 通过接口的子类型 | 是 | 定义了一组行为（方法）的类型，其他类型可以实施这些行为。稍后你将看到它是如何用于实现对象子类化的。|'
- en: '| Modularity and encapsulation | Yes | Go supports physical and logical modularity
    at its core with concepts such packages and an extensible type system, and code
    element visibility. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 模块化和封装 | 是 | Go在核心上支持物理和逻辑模块化，具有诸如包和可扩展的类型系统以及代码元素可见性等概念。|'
- en: '| Type inheritance | No | Go does not support polymorphism through inheritance.
    A newly declared named type does not inherit all attributes of its underlying
    type and are treated differently by the type system. As a consequence, it is hard
    to implement inheritance via type lineage as found in other languages. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 类型继承 | 否 | Go不支持通过继承实现多态。新声明的命名类型并不继承其底层类型的所有属性，并且被类型系统以不同的方式处理。因此，很难像在其他语言中找到的那样通过类型谱系实现继承。|'
- en: '| Classes | No | There is no notion of a class type that serves as the basis
    for objects in Go. Any data type in Go can be used as an object. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 否 | Go中没有作为对象基础的类类型的概念。Go中的任何数据类型都可以用作对象。|'
- en: As the previous table suggests, Go supports the majority of concepts that are
    usually attributed to object-oriented programming. The remainder of this chapter
    covers topics and examples showing how to use Go as an object-oriented programming
    language.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，Go支持通常归因于面向对象编程的大多数概念。本章的剩余部分将涵盖主题和示例，展示如何将Go用作面向对象编程语言。
- en: The struct as object
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体作为对象
- en: 'Nearly all Go types can play the role of an object by storing states and exposing
    methods that are capable of accessing and modifying those states. The `struct`
    type, however, offers all of the features that are traditionally attributed to
    objects in other languages, such as:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Go类型都可以通过存储状态并公开能够访问和修改这些状态的方法来充当对象的角色。然而，`struct`类型提供了其他语言中传统上归因于对象的全部特性，例如：
- en: Ability to host methods
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够包含方法
- en: Ability to be extended via composition
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过组合进行扩展
- en: Ability to be sub-typed (with help from the Go `interface` type)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够被子类型化（借助Go的`interface`类型）
- en: The remainder of the chapter will base its discussion of objects on using the
    `struct` type.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将基于使用`struct`类型来讨论对象。
- en: Object composition
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象组合
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Go uses the *composition over inheritance* principle to achieve polymorphism
    using the type embedding mechanism supported by the `struct` type. In Go, there
    is no support for polymorphism via type inheritance. Recall that each type is
    independent and is considered to be different from all others. In fact, the semantics
    in the model above is slightly broken. Types `truck` and `plane` are shown to
    be composed of (or has-a) the `vehicle` type, which does not sound correct. Instead,
    the proper, or at least a more correct, representation would be to show that the
    types `truck` and `plane` *is a* `vehicle` via a subtype relationship. Later in
    the chapter, we will see how this can be achieved using the `interface` type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用*组合优于继承*原则，通过`struct`类型支持的类型嵌入机制来实现多态。在Go中，没有通过类型继承实现多态的支持。回想一下，每个类型都是独立的，并且被认为与其他所有类型都不同。实际上，上述模型中的语义略有错误。类型`truck`和`plane`被显示为由`vehicle`类型组成（或具有`has-a`关系），这听起来并不正确。相反，更合适，或者至少更正确的表示方式是通过子类型关系来显示类型`truck`和`plane`是`vehicle`的子类型。在章节的后面部分，我们将看到如何使用`interface`类型来实现这一点。
- en: Field and method promotion
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段和方法提升
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous fields are promoted from their embedded types. They are accessed
    as if they are members of the `plane` type when, in fact, they are coming from
    the types `vehicle` and `engine` respectively. To avoid ambiguity, the name of
    the fields can be qualified as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的字段是从它们的嵌入类型提升而来的。当它们作为`plane`类型的成员访问时，实际上它们分别来自`vehicle`和`engine`类型。为了避免歧义，字段的名称可以像下面这样进行限定：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Methods can also be promoted in a similar way. For instance, in the previous
    code we saw the methods `t.start()` and `p.start()` being invoked. However, neither
    type, `truck` nor `plane`, are receivers of a method named `start()`. As shown
    in the program from earlier, the `start()`method is defined for the `engine` type.
    Since the `engine` type is embedded in the types `truck` and `plane`, the `start()`method
    is promoted in scope to these enclosing types and is therefore  accessible.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以以类似的方式提升。例如，在之前的代码中，我们看到了`t.start()`和`p.start()`方法的调用。然而，`truck`和`plane`这两种类型都不是名为`start()`的方法的接收者。正如前面程序所示，`start()`方法是为`engine`类型定义的。由于`engine`类型嵌入在`truck`和`plane`类型中，`start()`方法在作用域中被提升到这些封装类型，因此是可访问的。
- en: The constructor function
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch08/structobj2.go
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/structobj2.go
- en: While not required, providing a function to help with the initialization of
    composite values, such as a struct, increases the usability of the code. It provides
    a place to encapsulate repeatable initialization logic that can enforce validation
    requirements. In the previous example, both constructor functions, `newTruck`
    and `newPlane`, are passed the make and model information to create and initialize
    their respected values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，但提供一个函数来帮助初始化复合值，如结构体，可以提高代码的可用性。它提供了一个封装可重复初始化逻辑的地方，可以强制执行验证要求。在先前的示例中，构造函数`newTruck`和`newPlane`都传入了制造和型号信息以创建和初始化它们各自的价值。
- en: The interface type
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口类型
- en: 'When you talk to people who have been doing Go for a while, they almost always
    list the interface as one of their favorite features of the language. The concept
    of interfaces in Go, similar to other languages, such as Java, is a set of methods
    that serves as a template to describe behavior. A Go interface, however, is a
    type specified by the `interface{}` literal, which is used to list a set of methods
    that satisfies the interface. The following example shows the `shape` variable
    being declared as an interface:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与已经使用Go语言一段时间的人交谈时，他们几乎总是将接口列为他们最喜欢的语言特性之一。Go语言中接口的概念，与其他语言如Java类似，是一组方法，作为描述行为的模板。然而，Go语言的接口是由`interface{}`字面量指定的类型，用于列出满足接口的一组方法。以下示例展示了如何将`shape`变量声明为接口：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementing an interface
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口
- en: The interesting aspect of interfaces in Go is how they are implemented and ultimately
    used. Implementing a Go interface is done implicitly. There is no separate element
    or keyword required to indicate the intent of implementation. Any type that defines
    the method set of an `interface` type automatically satisfies its implementation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中接口的有趣之处在于它们的实现和使用方式。实现Go语言接口是隐式进行的。不需要单独的元素或关键字来指示实现的意图。任何定义了`interface`类型方法集的类型都会自动满足其实现。
- en: 'The following source code shows the `rect` type as an implementation of the
    `interface` type `shape`. The `rect` type is defined as a `struct` with receiver
    methods `area` and `perim`. This fact automatically qualifies `rect` as an implementation
    of `shape`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下源代码展示了`rect`类型作为`shape`接口类型的实现。`rect`类型被定义为具有接收器方法`area`和`perim`的结构体。这一事实自动使`rect`成为`shape`的实现：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: golang.fyi/ch08/interface_impl.go
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/interface_impl.go
- en: Subtyping with Go interfaces
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Go接口进行子类型化
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch08/interface_impl.go
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/interface_impl.go
- en: Implementing multiple interfaces
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现多个接口
- en: 'The implicit mechanism of interfaces allows any named type to satisfy multiple
    interface types at once. This is achieved simply by having the method set of a
    given type intersect with the methods of each `interface` type to be implemented.
    Let us re-implement the previous code to show how this is done. Two new interfaces
    are introduced, `polygon` and `curved`, to better capture and categorize information
    and the behavior of shapes, as shown in the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的隐式机制允许任何命名类型同时满足多个接口类型。这仅仅是通过确保给定类型的方法集与要实现的每个`interface`类型的方法相交来实现的。让我们重新实现之前的代码，以展示这是如何完成的。引入了两个新的接口`polygon`和`curved`，以更好地捕捉和分类形状的信息和行为，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Interface embedding
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口嵌入
- en: 'Another interesting aspects of the `interface` type is its support for type
    embedding (similar to the `struct` type). This gives you the flexibility to structure
    your types in ways that maximize type reuse. Continuing with the shape example,
    the following code snippet reorganizes and reduces the previous interface count
    from three to two by embedding shape into the other two types:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`类型的另一个有趣之处在于它支持类型嵌入（类似于`struct`类型）。这为您提供了以最大化类型重用的方式来结构化类型。继续使用形状示例，以下代码片段通过将形状嵌入到其他两个类型中，重新组织并减少了之前的接口数量，从三个减少到两个：'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyi/ch08/interface_impl3.go
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/interface_impl3.go
- en: 'The following illustration shows how the interface types may be combined so
    the *is-a* relationship still satisfies the relationships between code components:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了接口类型如何组合，以便“是...的”关系仍然满足代码组件之间的关系：
- en: '![Interface embedding](img/00022.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![接口嵌入](img/00022.jpeg)'
- en: When embedding interface types, the enclosing type will inherit the method set
    of the embedded types. The compiler will complain if the embedded type causes
    method signatures to clash. Embedding becomes a crucial feature, especially when
    the code applies type validation using type checking. It allows a type to roll
    up type information, thus reducing unnecessary assertion steps (type assertion
    is discussed later).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌入接口类型时，封装类型将继承嵌入类型的函数集。如果嵌入类型导致方法签名冲突，编译器将报错。嵌入成为一个关键特性，尤其是在代码使用类型检查进行类型验证时。它允许类型汇总类型信息，从而减少不必要的断言步骤（类型断言将在后面讨论）。
- en: The empty interface type
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空接口类型
- en: The `interface{}` type, or the empty `interface` type, is the literal representation
    of an `interface` type with an empty method set. According to our discussion so
    far, it can be deduced that *all types implement the empty interface* since all
    types can have a method set with zero or more members.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface{}`类型，或空`interface`类型，是具有空方法集的`interface`类型的字面表示。根据我们之前的讨论，可以推断出*所有类型都实现了空接口*，因为所有类型都可以有一个包含零个或多个成员的方法集。'
- en: 'When a variable is assigned the `interface{}` type, the compiler relaxes its
    build-time type checks. The variable, however, still carries type information
    that can be queried at runtime. The following code illustrates how this works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量被分配`interface{}`类型时，编译器会放宽其构建时的类型检查。然而，该变量仍然携带可以在运行时查询的类型信息。以下代码说明了这是如何工作的：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: golang.fyi/ch08/interface_empty.go
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch08/interface_empty.go
- en: 'In the previous code, the `anyType` variable is declared to be of the type
    `interface{}`. It is able to be assigned values of different types without complaints
    from the compiler:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`anyType`变量被声明为`interface{}`类型。它能够分配不同类型的值而不会引起编译器的抱怨：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `printAnyType()` function takes a parameter of the type `interface{}`.
    This means the function can be passed the values of any valid type, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`printAnyType()`函数接受一个`interface{}`类型的参数。这意味着函数可以传递任何有效类型的值，如下所示：'
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The empty interface is crucially important for idiomatic Go. Delaying type-checking
    until runtime makes the language feels more dynamic without completely sacrificing
    strong typing. Go offers mechanisms such as type assertion (covered next) to query
    the type information carried by interfaces at runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 空接口对于习惯性的Go语言至关重要。将类型检查延迟到运行时使得语言感觉更加动态，而没有完全牺牲强类型。Go提供了诸如类型断言（将在下一节介绍）等机制，以在运行时查询接口携带的类型信息。
- en: Type assertion
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型断言
- en: 'When an interface (empty or otherwise) is assigned to a variable, it carries
    type information that can be queried at runtime. Type assertion is a mechanism
    that is available in Go to idiomatically narrow a variable (of `interface` type)
    down to a concrete type and value that are stored in the variable. The following
    example uses type assertion in the `eat` function to select which `food` type
    to select in the `eat` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个接口（空或非空）被赋值给一个变量时，它携带了可以在运行时查询的类型信息。类型断言是Go语言中一种机制，可以习惯性地将一个（`interface`类型）变量缩小到存储在变量中的具体类型和值。以下示例在`eat`函数中使用类型断言来选择在`eat`函数中要选择的`food`类型：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A type assertion expression can also return just the value, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言表达式也可以只返回值，如下所示：
- en: '*value := <interface_variable>**.**(concrete type name)*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*value := <interface_variable>**.**(具体类型名称)*'
- en: This form of assertion is risky to do as the runtime will cause a panic in the
    program if the value stored in the interface variable is not of the asserted type.
    Use this form only if you have other safeguards to either prevent or gracefully
    handle a panic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种断言形式是有风险的，因为如果接口变量中存储的值不是断言的类型，运行时将导致程序崩溃。只有在你有其他安全措施来防止或优雅地处理崩溃的情况下，才使用这种形式。
- en: 'Lastly, when your code requires multiple assertions to test many types at runtime,
    a much nicer idiom for assertions is the type `switch` statement. It uses the
    `switch` statement semantic to query static type information from an interface
    value using case clauses. The `eat` function from the previous food-related example
    can been updated to use a type `switch` instead of `if` statement, as shown in
    the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你的代码需要在运行时测试多个类型时，一个更优雅的断言方法是使用类型`switch`语句。它使用`switch`语句的语义，通过case子句从接口值中查询静态类型信息。上一个与食物相关的示例中的`eat`函数可以更新为使用类型`switch`而不是`if`语句，如下所示：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/interface_assert2.go
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/interface_assert2.go
- en: Notice the code is much nicer to read. It can support any number of cases and
    is clearly laid out with visual clues that makes it easy to reason about. The
    `switch` type also makes the panic issue go away by simply specifying a default
    case that can handle any types not specifically handled in the case clause.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码的可读性要好得多。它可以支持任意数量的案例，并且通过视觉线索清晰地布局，使得推理变得容易。`switch`类型还通过简单地指定一个默认情况来处理任何在情况子句中未明确处理的类型，从而消除了panic问题。
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter attempted to give a broad and, at the same, somewhat comprehensive
    view of several important topics including methods, interfaces, and objects in
    Go. The chapter started with coverage of attaching methods to types using receiver
    parameters. Next the reader was introduced to objects and how to create idiomatic
    object-based programming in Go. Lastly, the chapter presented a comprehensive
    overview of the interface type and how it is used to support object semantics
    in Go. The next chapter takes the reader through one of the most fundamental concepts
    that has made Go such a sensation among developers: concurrency!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章试图提供一个广泛且相对全面的视角，涵盖Go语言中的一些重要主题，包括方法、接口和对象。章节从使用接收器参数将方法附加到类型开始介绍。接下来，读者被引入对象以及如何在Go语言中创建惯用的基于对象的编程。最后，本章全面概述了接口类型及其在Go语言中支持对象语义的使用。下一章将带领读者了解一个使Go语言在开发者中如此受欢迎的最基本概念：并发！
