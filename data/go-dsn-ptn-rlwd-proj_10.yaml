- en: Chapter 9. Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。并发
- en: 'Concurrency is considered to be the one of the most attractive features of
    Go. Adopters of the language revel in the simplicity of its primitives to express
    correct concurrency implementations without the pitfalls that usually come with
    such endeavors. This chapter covers the necessary topics to understand and create
    concurrent Go programs, including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发被认为是 Go 语言最吸引人的特性之一。语言的采用者享受其原语表达正确并发实现的简单性，而无需承担通常与这种努力相关的陷阱。本章涵盖了理解和创建并发
    Go 程序所必需的主题，包括以下内容：
- en: Goroutines
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines
- en: Channels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Writing concurrent programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并发程序
- en: The sync package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sync 包
- en: Detecting race conditions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测竞态条件
- en: Parallelism in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的并行性
- en: Goroutines
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: If you have worked in other languages, such as Java or C/C++, you are probably
    familiar with the notion of concurrency. It is the ability of a program to run
    two or more paths of execution independently. This is usually done by exposing
    a thread primitive directly to the programmer to create and manage concurrency.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在其他语言（如 Java 或 C/C++）中工作过，你可能熟悉并发的概念。这是程序运行两个或更多独立执行路径的能力。这通常是通过直接向程序员暴露线程原语来创建和管理并发来实现的。
- en: Go has its own concurrency primitive called the *goroutine*, which allows a
    program to launch a function (routine) to execute independently from its calling
    function. Goroutines are lightweight execution contexts that are multiplexed among
    a small number of OS-backed threads and scheduled by Go's runtime scheduler. That
    makes them cheap to create without the overhead requirements of true kernel threads.
    As such, a Go program can initiate thousands (even hundreds of thousands) of goroutines
    with minimal impact on performance and resource degradation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有其自己的并发原语，称为 *goroutine*，它允许程序独立于调用函数启动一个函数（例程）执行。Goroutines 是轻量级的执行上下文，在少数几个由操作系统支持的线程之间进行多路复用，并由
    Go 的运行时调度器进行调度。这使得它们在创建时无需真正的内核线程的开销。因此，Go 程序可以启动成千上万（甚至数十万）的 goroutine，而对性能和资源退化影响最小。
- en: The go statement
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go 语句
- en: 'Goroutines are launched using the `go` statement as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines 是使用以下格式的 `go` 语句启动的：
- en: '*go <function or expression>*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*go <函数或表达式>*'
- en: 'A goroutine is created with the `go` keyword followed by the function to schedule
    for execution. The specified function can be an existing function, an anonymous
    function, or an expression that calls a function. The following code snippet shows
    an example of the use of goroutines:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go` 关键字后跟要调度的函数创建一个 goroutine。指定的函数可以是现有的函数、匿名函数或调用函数的表达式。以下代码片段展示了使用 goroutines
    的一个示例：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch09/goroutine0.go
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine0.go
- en: In the previous code sample, when the `go count()` statement is encountered
    in the `main` function, it launches the `count` function in an independent execution
    context. Both the `main` and `count` functions will be executing concurrently.
    As a side effect, `main` will complete before any of the `count` functions get
    a chance to print anything to the console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，当在 `main` 函数中遇到 `go count()` 语句时，它将在一个独立的执行上下文中启动 `count` 函数。`main`
    和 `count` 函数将并发执行。作为副作用，`main` 将在 `count` 函数有机会向控制台打印任何内容之前完成。
- en: 'Later in the chapter, we will see how to handle synchronization idiomatically
    between goroutines. For now, let us use `fmt.Scanln()` to block and wait for keyboard
    input, as shown in the following sample. In this version, the concurrent functions
    get a chance to complete while waiting for keyboard input:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到如何习惯性地在 goroutine 之间处理同步。现在，让我们使用 `fmt.Scanln()` 来阻塞并等待键盘输入，如下面的示例所示。在这个版本中，在等待键盘输入的同时，并发函数有机会完成：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch09/goroutine1.go
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine1.go
- en: 'Goroutines may also be defined as function literals directly in the `go` statement,
    as shown in this updated version of the example shown in the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines 也可以直接在 `go` 语句中定义为函数字面量，如下面代码片段中更新的示例所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch09/goroutine2.go
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine2.go
- en: 'The function literal provides a convenient idiom that allows programmers to
    assemble logic directly at the site of the `go` statement. When using the `go`
    statement with a function literal, it is treated as a regular closure with lexical
    access to non-local variables, as shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量提供了一种方便的惯用法，允许程序员在`go`语句的位置直接组装逻辑。当使用函数字面量与`go`语句一起使用时，它被视为一个常规闭包，具有对非局部变量的词法访问，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch09/goroutine4.go
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine4.go
- en: 'Since `j` is updated with each iteration, it is impossible to determine what
    value will be read by the closure. In most cases, the goroutine closures will
    see the last updated value of `j` by the time they are executed. This can be easily
    fixed by passing the variable as a parameter in the function literal for the goroutine,
    as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`j`在每次迭代中都会更新，因此无法确定闭包将读取什么值。在大多数情况下，goroutine闭包将在它们执行时看到`j`的最后一个更新值。这可以通过在函数字面量中将变量作为参数传递给goroutine来轻松修复，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch09/goroutine5.go
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine5.go
- en: The goroutine closures, invoked with each loop iteration, receive a copy of
    the `j` variable via the function parameter. This creates a local copy of the
    `j` value with the proper value to be used when the goroutine is scheduled to
    run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环迭代都会调用goroutine闭包，通过函数参数接收`j`变量的一个副本。这创建了一个带有正确值的`j`值的局部副本，以便在goroutine被调度运行时使用。
- en: Goroutine scheduling
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Goroutine调度
- en: 'In general, all goroutines run independently of each other, as depicted in
    the following illustration. A function that creates a goroutine does not wait
    for it to return, it continues with its own execution stream unless there is a
    blocking condition. Later, the chapter covers synchronization idioms to coordinate
    goroutines:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有goroutine都是相互独立运行的，如下面的插图所示。创建goroutine的函数不会等待其返回，除非存在阻塞条件，否则它将继续执行自己的执行流。稍后，本章将介绍同步惯用法来协调goroutine：
- en: '![Goroutine scheduling](img/00023.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Goroutine调度](img/00023.jpeg)'
- en: 'Go''s runtime scheduler uses a form of cooperative scheduling to schedule goroutines.
    By default, the scheduler will allow a running goroutine to execute to completion.
    However, the scheduler will automatically yield to another goroutine for execution
    if one of the following events occurs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go的运行时调度器使用一种协作调度形式来调度goroutine。默认情况下，调度器将允许正在运行的goroutine执行完成。然而，如果发生以下事件之一，调度器将自动将执行权让给另一个goroutine：
- en: A `go` statement is encountered in the executing goroutine
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行的goroutine中遇到`go`语句
- en: A channel operation is encountered (channels are covered later)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到通道操作（通道将在后面介绍）
- en: A blocking system call (file or network IO for instance) is encountered
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到阻塞的系统调用（例如文件或网络I/O）
- en: After the completion of a garbage collection cycle
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在垃圾回收周期完成后
- en: 'The scheduler will schedule a queued goroutines ready to enter execution when
    one of the previous events is encountered in a running goroutine. It is important
    to point out that the scheduler makes no guarantee of the order of execution of
    goroutines. When the following code snippet is executed, for instance, the output
    will be printed in an arbitrary order for each run:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当在运行的goroutine中遇到上述事件之一时，调度器将调度一个准备就绪的goroutine以进入执行。重要的是要指出，调度器不对goroutine的执行顺序做出保证。例如，当执行以下代码片段时，每次运行的输出顺序将是任意的：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch09/goroutine1.go
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/goroutine1.go
- en: 'The following shows possible output for the previous program:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了上一个程序的可能输出：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Channels
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: When talking about concurrency, one of the natural concerns that arises is that
    of data safety and synchronization among concurrently executing code. If you have
    done concurrent programming in languages such as Java or C/C++, you are likely
    familiar with the, sometimes brittle, choreography required to ensure running
    threads can safely access shared memory values to achieve communication and synchronization
    between threads.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈论并发时，一个自然出现的担忧是数据安全和同步。如果你在Java或C/C++等语言中做过并发编程，你可能会熟悉确保运行线程可以安全访问共享内存值以在线程之间进行通信和同步所需的，有时是脆弱的编排。
- en: 'This is one area where Go diverges from its C lineage. Instead of having concurrent
    code communicate by using shared memory locations, Go uses channels as a conduit
    between running goroutines to communicate and share data. The blog post *Effective
    Go* ([https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html))
    has reduced this concept to the following slogan:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Go与其C系谱有所不同的一个领域。Go不是通过使用共享内存位置来让并发代码进行通信，而是使用通道作为运行goroutine之间通信和数据共享的通道。博客文章*Effective
    Go*（[https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)）将这个概念简化为以下口号：
- en: '*Do not communicate by sharing memory; instead, share memory by communicating.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要通过共享内存来通信；相反，通过通信来共享内存。*'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of channel has its roots in **communicating sequential processes**
    (**CSP**), work done by renowned computer scientist C. A. Hoare, to model concurrency
    using communication primitives. As will be discussed in this section, channels
    provide the means to synchronize and safely communicate data between running goroutines.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的概念源于**通信顺序过程**（**CSP**），这是著名计算机科学家C. A. Hoare的工作，他用通信原语来模拟并发。正如本节将要讨论的，通道提供了同步和在不同运行goroutine之间安全通信数据的方法。
- en: This section discusses the Go channel type and provides insights into its characteristics.
    Later, you will learn how to use channels to craft concurrent programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论Go通道类型，并提供了对其特性的见解。稍后，你将学习如何使用通道来构建并发程序。
- en: The Channel type
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道类型
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Later in the chapter, we will learn how to use the channel to send data between
    concurrent portions of a running program.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将学习如何使用通道在运行程序的不同并发部分之间发送数据。
- en: The send and receive operations
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送和接收操作
- en: 'Go uses the `<-` (arrow) operator to indicate data movement within a channel.
    The following table summarizes how to send or receive data from a channel:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用`<-`（箭头）运算符来指示通道内的数据移动。以下表格总结了如何从通道发送或接收数据：
- en: '| **Example** | **Operation** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | **操作** | **描述** |'
- en: '| `intCh <- 12` | Send | When the arrow is placed to the left of the value,
    variable or expression, it indicates a send operation to the channel it points
    to. In this example, `12` is sent into channel `intCh`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `intCh <- 12` | 发送 | 当箭头放置在值、变量或表达式的左侧时，它表示向它指向的通道发送操作。在这个例子中，`12`被发送到`intCh`通道。
    |'
- en: '| `value := <- intCh` | Receive | When the `<-` operator is place to the left
    of a channel, it indicates a receive operation from the channel. The `value` variable
    is assigned the value received from the `intCh` channel. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `value := <- intCh` | 接收 | 当`<-`运算符放置在通道的左侧时，它表示从通道接收操作。`value`变量被分配从`intCh`通道接收到的值。'
- en: An uninitialized channel has a *nil* zero value and must be initialized using
    the built-in *make* function. As will be discussed in the following sections,
    a channel can be initialized as either unbuffered or buffered, depending on its
    specified capacity. Each of type of channel has different characteristics that
    are leveraged in different concurrency constructs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未初始化的通道具有*nil*的零值，必须使用内置的*make*函数进行初始化。正如以下章节将要讨论的，通道可以初始化为无缓冲或有缓冲，这取决于其指定的容量。每种类型的通道都有不同的特性，这些特性在不同的并发结构中被利用。
- en: Unbuffered channel
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无缓冲通道
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The characteristics of an unbuffered channel are illustrated in the following
    figure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道的特性在以下图中展示：
- en: '![Unbuffered channel](img/00024.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![无缓冲通道](img/00024.jpeg)'
- en: 'The sequence in the preceding figure (from left to right) shows how the unbuffered
    channel works:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图中的序列（从左到右）显示了无缓冲通道的工作方式：
- en: If the channel is empty, the receiver blocks until there is data
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果通道为空，接收者会阻塞，直到有数据。
- en: The sender can send only to an empty channel and blocks until the next receive
    operation
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者只能向空通道发送，并且会阻塞直到下一个接收操作
- en: When the channel has data, the receiver can proceed to receive the data.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道有数据时，接收者可以继续接收数据。
- en: 'Sending to an unbuffered channel can easily cause a *deadlock* if the operation
    is not wrapped in a goroutine. The following code will block after sending `12`
    to the channel:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作未在goroutine中包装，向无缓冲通道发送可能会轻易导致*死锁*。以下代码在向通道发送`12`后将会阻塞：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: golang.fyi/ch09/chan-unbuff0.go
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan-unbuff0.go
- en: 'When you run the previous program, you will get the following result:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的程序时，你会得到以下结果：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Recall that the sender blocks immediately upon sending to an unbuffered channel.
    This means any subsequent statement, to receive from the channel for instance,
    becomes unreachable, causing a deadlock. The following code shows the proper way
    to send to an unbuffered channel:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，发送者一旦向无缓冲通道发送数据就会立即阻塞。这意味着任何后续的语句，例如从通道接收，将变得不可达，导致死锁。以下代码展示了向无缓冲通道发送的正确方式：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch09/chan-unbuff1.go
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan-unbuff1.go
- en: Notice that the send operation is wrapped in an anonymous function invoked as
    a separate goroutine. This allows the `main` function to reach the receive operation
    without blocking. As you will see later, this blocking property of unbuffered
    channels is used extensively as a synchronization and coordination idioms between
    goroutines.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，发送操作被封装在一个匿名函数中，并作为单独的goroutine调用。这允许 `main` 函数在不阻塞的情况下到达接收操作。正如你将看到的，无缓冲通道的这种阻塞特性被广泛用作goroutine之间的同步和协调惯用语。
- en: Buffered channel
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'When the `make` function uses the capacity argument, it returns a bidirectional
    *buffered* channel, as shown in the following snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `make` 函数使用容量参数时，它返回一个双向 *缓冲* 通道，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous code will create a buffered channel with a capacity of `3`. The
    buffered channel operates as a first-in-first-out blocking queue, as illustrated
    in the following figure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将创建一个容量为 `3` 的缓冲通道。缓冲通道作为一个先进先出（FIFO）的阻塞队列，如下面的图所示：
- en: '![Buffered channel](img/00025.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![缓冲通道](img/00025.jpeg)'
- en: 'The buffered channel depicted in the preceding figure has the following characteristics:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中描述的缓冲通道具有以下特性：
- en: When the channel is empty, the receiver blocks until there is at least one element
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道为空时，接收者会阻塞，直到至少有一个元素。
- en: The sender always succeeds as long as the channel is not at capacity
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要通道未满，发送者总是成功的。
- en: When the channel is at capacity, the sender blocks until at least one element
    is received
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通道满时，发送者会阻塞，直到至少有一个元素被接收。
- en: 'Using a buffered channel, it is possible to send and receive values within
    the same goroutine without causing a deadlock. The following shows an example
    of sending and receiving using a buffered channel with a capacity of `4` elements:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓冲通道，可以在同一个goroutine中发送和接收值，而不会导致死锁。以下是一个使用容量为 `4` 个元素的缓冲通道发送和接收的示例：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch09/chan0.go
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan0.go
- en: 'The code in the previous example is able to send the values `2`, `4`, `6`,
    and `8` to the `ch` channel without the risk of blocking. The four `fmt.Println(<-ch)`
    statements are used to receive the values buffered in the channel successively.
    However, if a fifth send operation is added, prior to the first receive, the code
    will deadlock as highlighted in the following snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的代码能够将值 `2`、`4`、`6` 和 `8` 发送到 `ch` 通道，而不会阻塞。四个 `fmt.Println(<-ch)` 语句用于依次接收通道中缓冲的值。然而，如果在第一次接收之前添加第五次发送操作，代码将如以下片段所示死锁：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Later in the chapter, you will read more about idiomatic and safe ways to use
    channels for communications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将了解到使用通道进行通信的惯用和安全的用法。
- en: Unidirectional channels
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单向通道
- en: 'At declaration, a channel type may also include a unidirectional operator (using
    the `<-` arrow again) to indicate whether a channel is send-only or receive-only,
    as listed in the following table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明时，通道类型也可以包括一个单向操作符（再次使用 `<-` 箭头），以指示通道是单向发送还是单向接收，如下表所示：
- en: '| **Declaration** | **Operation** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **声明** | **操作** |'
- en: '| `<-` *chan <element type>* | Declares a receive-only channel as shown later.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| `<-` *chan <元素类型>* | 声明一个如后所述的单向接收通道。'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| *chan* `<-`*<element type>* | Declares a send-only channel as shown later.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '| *chan* `<-`*<元素类型>* | 声明一个如后所述的单向发送通道。'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: golang.fyi/ch09/chan1.go
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan1.go
- en: Since the directionality of the channel is baked in the type, access violations
    will be detected at compile time. So in the previous example, the `in` channel
    can only be used for receive operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通道的方向性在类型中是固定的，访问违规将在编译时被检测到。因此，在之前的示例中，`in` 通道只能用于接收操作。
- en: A bidirectional channel can be converted to a unidirectional channel explicitly
    or automatically. For instance, when `makeEvenNums()` is called from `main()`,
    it receives the bidirectional channel `ch` as a parameter. The compiler automatically
    converts the channel to the appropriate type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显式或自动地将双向通道转换为单向通道。例如，当从`main()`调用`makeEvenNums()`时，它接收双向通道`ch`作为参数。编译器自动将通道转换为适当类型。
- en: Channel length and capacity
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道长度和容量
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `cap` function returns the declared capacity of the channel type which,
    unlike length, remains constant throughout the life of the channel.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`cap`函数返回通道类型的声明容量，与长度不同，在整个通道的生命周期中保持不变。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An unbuffered channel has a length and a capacity of zero.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 无缓冲通道的长度和容量为零。
- en: Closing a channel
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'Once a channel is initialized it is ready for send and receive operations.
    A channel will remain in that open state until it is forcibly closed using the
    built-in *close* function, as shown in the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化通道，它就准备好进行发送和接收操作。通道将保持打开状态，直到使用内置的*close*函数强制关闭，如下例所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Go offers a long form of the receive operation that returns the value read
    from the channel followed by a Boolean indicating the closed status of the channel.
    This can be used to properly handle the zero value from a closed channel, as shown
    in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了接收操作的扩展形式，它返回从通道读取的值，后跟一个表示通道关闭状态的布尔值。这可以用来正确处理从关闭通道的零值，如下例所示：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: golang.fyi/ch09/chan3.go
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/chan3.go
- en: Writing concurrent programs
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写并发程序
- en: Up to this point, the discussions about goroutines and channels remained deliberately
    separated to ensure that each topic is properly covered. However, the true power
    of channels and goroutines are realized when they are combined to create concurrent
    programs, as covered in this section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于goroutines和通道的讨论有意识地保持分离，以确保每个主题都得到适当的覆盖。然而，通道和goroutines的真正力量在于它们结合在一起创建并发程序时，正如本节所述。
- en: Synchronization
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: 'One of the primary uses of channels is synchronization between running goroutines.
    To illustrate this use case, let us examine the following code, which implements
    a word histogram. The program reads the words from the `data` slice then, on a
    separate goroutine, collects the occurrence of each word:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的主要用途之一是在运行中的goroutines之间进行同步。为了说明这种用法，让我们检查以下代码，该代码实现了一个单词直方图。程序从`data`切片中读取单词，然后在单独的goroutine中收集每个单词的出现次数：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch09/pattern0.go
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern0.go
- en: The code in the previous example uses `done := make(chan bool)` to create the
    channel that will be used to synchronize the two running goroutines in the program.
    The `main` function launches a secondary goroutine, which does the word counting,
    and then it continues execution until it blocks at the `<-done` expression, causing
    it to wait.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的代码使用`done := make(chan bool)`创建用于同步程序中两个运行goroutines的通道。`main`函数启动一个次要goroutine，执行单词计数，然后它继续执行，直到在`<-done`表达式处阻塞，导致它等待。
- en: In the meantime, the secondary goroutine runs until it completes its loop. Then,
    it sends a value to the `done` channel with `done <- true`, causing the blocked
    `main` routine to become unblocked and continues with its execution.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，次要goroutine运行直到它完成其循环。然后，它向`done`通道发送一个值，使用`done <- true`，导致阻塞的`main`程序变为非阻塞并继续执行。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous code has a bug that may cause a race condition. A correction will
    be introduced later in the chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码有一个可能导致竞态条件的错误。将在本章后面介绍修正。
- en: 'In the previous example, the code allocates and actually sends a Boolean value
    that is used for the synchronization. Upon further inspection, it is clear that
    the value in the channel is irrelevant and we simply want it to signal. So, we
    can further distill the synchronization idiom into a colloquial form that is presented
    in the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，代码分配并发送了一个用于同步的布尔值。经过进一步检查，很明显通道中的值无关紧要，我们只想发出信号。因此，我们可以进一步提炼同步习语，以以下代码片段中的口语形式呈现：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch09/pattern1.go
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern1.go
- en: 'This version of the code achieves goroutine synchronization using:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本的代码使用以下方式实现goroutine同步：
- en: The done channel, declared as type `chan struct{}`
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已完成的通道，声明为类型 `chan struct{}`
- en: The main goroutine blocks at receive expression `<-done`
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主goroutine在接收表达式`<-done`处阻塞
- en: When the done channel is closed, all receivers succeed without blocking
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`done`通道关闭时，所有接收者都成功完成而不会阻塞
- en: Although the signaling is done using different constructs, this version of the
    code is equivalent to the first version (`pattern0.go`). The emtpy `struct{}`
    type stores no value and it is used strictly for signaling. This version of the
    code closes the `done` channel (instead of sending a value). This has the effect
    of allowing the main goroutine to unblock and continue execution.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用不同的结构来完成信号，但这个版本的代码与第一个版本（`pattern0.go`）等效。空的`struct{}`类型不存储任何值，它仅用于信号。这个版本的代码关闭了`done`通道（而不是发送一个值）。这允许主goroutine解除阻塞并继续执行。
- en: Streaming data
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式数据
- en: 'A natural use of channels is to stream data from one goroutine to another.
    This pattern is quite common in Go code and for it to work, the followings must
    be done:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的一个自然用途是从一个goroutine流式传输数据到另一个goroutine。这种模式在Go代码中相当常见，为了使其工作，必须执行以下操作：
- en: Continuously send data on a channel
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通道上持续发送数据
- en: Continuously receive the incoming data from that channel
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从该通道持续接收传入的数据
- en: Signal the end of the stream so the receiver may stop
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知接收者流的结束，以便它停止
- en: 'As you will see, all of this can be done using a single channel. The following
    code snippet is a rewrite of the previous example. It shows how to use a single
    channel to stream data from one goroutine to another. The same channel is also
    used as a signaling device to indicate the end of the stream:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，所有这些都可以使用单个通道完成。下面的代码片段是之前示例的重写。它展示了如何使用单个通道从一个goroutine流式传输数据到另一个goroutine。相同的通道也被用作信号设备，以指示流的结束：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch09/pattern2.go
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern2.go
- en: 'This version of the code produces the word histogram as before, but introduces
    a different approach. This is accomplished using the highlighted portion of the
    code shown in the following table:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码生成的单词直方图与之前相同，但引入了不同的方法。这是通过以下表格中显示的代码的高亮部分实现的：
- en: '| **Code** | **Description** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** |'
- en: '|'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| The channel used to stream data. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 用于流式传输数据的通道。|'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| The sender goroutine loops through the text line and sends a word at a time.
    It then blocks until the word is received by the receiving (main) goroutine. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 发送goroutine逐行遍历文本，每次发送一个单词。然后它会阻塞，直到接收（主）goroutine接收到该单词。|'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| As the words are continuously received (see later), the sender goroutine
    closes the channel when it is done. This will be the signal to the receiver that
    it should also stop. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 随着单词的持续接收（见后文），发送goroutine在完成时关闭通道。这将向接收者发出停止的信号。|'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| This is the receiver code. It is placed in a loop since it is does not know
    ahead of time how much data to expect. With each iteration of the loop, the code
    does the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '| 这是接收者代码。由于它事先不知道预期多少数据，所以被放置在一个循环中。在循环的每次迭代中，代码执行以下操作：'
- en: Pulls the data from the channel
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从通道中拉取数据
- en: Checks the open status of the channel
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查通道的打开状态
- en: If closed, break out of the loop
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已关闭，则退出循环
- en: Otherwise record histogram
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则记录直方图
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Using for…range to receive data
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用for…range接收数据
- en: 'The previous pattern is so common in Go that the idiom is built into the language
    in the form of the following `for…range` statement:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的模式在Go中非常常见，以至于这种习语以以下`for…range`语句的形式内置到语言中：
- en: '*for <elemem> := range <channel>{...}*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*for <elemem> := range <channel>{…}*'
- en: 'With each iteration, this `for…range` statement will block until it receives
    incoming data from the indicated channel, as shown in the following snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，这个`for…range`语句将阻塞，直到它从指定的通道接收到传入的数据，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch09/pattern3.go
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern3.go
- en: The previous code shows the an updated version of the code using a for-range
    statement, `for word := range wordsCh`. It successively emits the received value
    from the `wordsCh` channel. When the channel is closed (from the goroutine), the
    loop automatically breaks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码展示了使用for-range语句的代码更新版本，`for word := range wordsCh`。它依次发出从`wordsCh`通道接收到的值。当通道关闭（来自goroutine）时，循环会自动中断。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always remember to close the channel so receivers are signaled properly. Otherwise,
    the program may enter into a deadlock which could cause a panic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记得关闭通道，以便正确地通知接收者。否则，程序可能会进入死锁，这可能导致panic。
- en: Generator functions
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Channels and goroutines provide a natural substrate for implementing a form
    of producer/producer pattern using generator functions. In this approach, a goroutine
    is wrapped in a function which generates values that are sent via a channel returned
    by the function. The consumer goroutine receives these values as they are generated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通道和goroutines为使用生成函数实现生产者/生产者模式提供了一种自然的底层支持。在这种方法中，一个goroutine被封装在一个函数中，该函数生成通过函数返回的通道发送的值。消费者goroutine接收这些值，就像它们被生成一样。
- en: 'The word histogram has been updated to use this pattern, as shown in the following
    code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词histogram更新为使用此模式，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: golang.fyi/ch09/pattern4.go
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern4.go
- en: In this example, the generator function, declared as `func words(data []string)
    <-chan string`, returns a receive-only channel of string elements. The consumer
    function, in this instance `main()`, receives the data emitted by the generator
    function, which is processed using a `for…range` loop.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，生成函数，声明为`func words(data []string) <-chan string`，返回一个只读的字符串元素通道。消费者函数，在这个例子中是`main()`，接收生成函数发出的数据，该数据通过`for…range`循环进行处理。
- en: Selecting from multiple channels
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个通道中选择
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Channel timeout
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道超时
- en: One popular idiom that is commonly encountered with Go concurrency is the use
    of the select statement, introduced previously, to implement timeouts. This works
    by using the select statement to wait for a channel operation to succeed within
    a given time duration using the API from the `time` package ([https://golang.org/pkg/time/](https://golang.org/pkg/time/)).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go并发中常见的一个流行惯用法是使用之前介绍过的select语句来实现超时。这是通过使用select语句等待在给定时间范围内使用`time`包的API（[https://golang.org/pkg/time/](https://golang.org/pkg/time/））成功完成通道操作来实现的。
- en: 'The following code snippet shows a version of the word histogram example that
    times out if the program takes longer than 200 microseconds to count and print
    the words:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了单词直方图示例的一个版本，如果程序在200微秒内完成计数和打印单词，则会超时：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: golang.fyi/ch09/pattern6.go
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/pattern6.go
- en: This version of the histogram example introduces the `done` channel, which is
    used to signal when processing is done. In the `select` statement, the receive
    operation `case``<-done:` blocks until the goroutine closes the `done` channel.
    Also in the `select` statement, the `time.After()` function returns a channel
    which will close after the indicated duration. If the 200 microseconds elapse
    before done is closed, the channel from `time.After()` will close first, causing
    the timeout case to succeed first.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的直方图示例引入了`done`通道，用于在处理完成后发出信号。在`select`语句中，接收操作`case <-done:`会阻塞，直到goroutine关闭`done`通道。同样，在`select`语句中，`time.After()`函数返回一个通道，该通道将在指定的时间后关闭。如果在`done`关闭之前有200微秒的时间流逝，那么`time.After()`的通道将首先关闭，导致超时情况首先成功。
- en: The sync package
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The sync package
- en: There are instances when accessing shared values using traditional methods are
    simpler and more appropriate then the use of channels. The *sync* package ([https://golang.org/pkg/sync/](https://golang.org/pkg/sync/))
    provides several synchronization primitives including mutual exclusion (mutex)
    locks and synchronization barriers for safe access to shared values, as discussed
    in this section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，使用传统方法访问共享值比使用通道更简单、更合适。*sync*包（[https://golang.org/pkg/sync/](https://golang.org/pkg/sync/））提供了几个同步原语，包括互斥（mutex）锁和同步屏障，用于安全地访问共享值，如本节所述。
- en: Synchronizing with mutex locks
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用互斥锁同步
- en: 'Mutex locks allow serial access of shared resources by causing goroutines to
    block and wait until locks are released. The following sample illustrates a typical
    code scenario with the `Service` type, which must be started before it is ready
    to be used. After the service has started, the code updates an internal bool variable,
    `started`, to store its current state:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁允许通过使goroutines阻塞并等待锁释放来串行访问共享资源。以下示例展示了使用`Service`类型的典型代码场景，该类型必须在准备使用之前启动。服务启动后，代码更新一个内部布尔变量`started`以存储其当前状态：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: golang.fyi/ch09/sync3.go
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync3.go
- en: The `sync` package also offers the RWMutex (read-write mutex), which can be
    used in cases where there is one writer that updates the shared resource, while
    there may be multiple readers. The writer would update the resource using a full
    lock, as before. However, readers use the `RLock()`/`RUnlock()` method pair (for
    read-lock/read-unlock respectively) to apply a read-only lock when reading the
    shared resource. The RWMutex type is used in the next section, *Synchronizing
    Access to Composite Values*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`包还提供了RWMutex（读写互斥锁），在只有一个写者更新共享资源，而可能有多个读者的情况下可以使用。写者将使用完整的锁来更新资源，就像之前一样。然而，读者使用`RLock()`/`RUnlock()`方法对（分别用于读锁/解锁）来在读取共享资源时应用只读锁。RWMutex类型将在下一节，*同步访问复合值*中使用。'
- en: Synchronizing access to composite values
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步访问复合值
- en: 'The previous section discussed concurrency safety when sharing access to simple
    values. The same level of care must be applied when sharing access to composite
    type values such as maps and slices, since Go does not offer concurrency-safe
    version of these types, as illustrated in the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讨论了在共享简单值时的并发安全性。在共享复合类型值（如map和slice）的访问时，必须采取相同级别的谨慎，因为Go不提供这些类型的并发安全版本，如下面的示例所示：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: golang.fyi/ch09/sync4.go
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync4.go
- en: The preceding code uses a `sync.RWMutex` variable (see preceding section, *Synchronizing
    with Mutex Locks*) to manage the locks when accessing the map variable `cache`.
    The code wraps the update operation to the `cache` variable within a pair of method
    calls, `mutex.Lock()` and `mutex.Unlock()`. However, when reading values from
    the `cache` variable, the `mutex.RLock()` and `mutex.RUnlock()`methods are used
    to provide concurrency safety.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用`sync.RWMutex`变量（参见前述部分，*使用互斥锁进行同步*）来管理访问map变量`cache`时的锁。代码将更新`cache`变量的操作包裹在`mutex.Lock()`和`mutex.Unlock()`方法调用的一对中。然而，当从`cache`变量读取值时，使用`mutex.RLock()`和`mutex.RUnlock()`方法来提供并发安全性。
- en: Concurrency barriers with sync.WaitGroup
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sync.WaitGroup的并发屏障
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: golang.fyi/ch09/sync5.go
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync5.go
- en: In the previous code, the method call, `wg.Add(2)`, configures the `WaitGroup`
    variable `wg` because the work is distributed between two goroutines. The `work`
    function calls `defer wg.Done()` to decrement the WaitGroup counter by one every
    time it is completed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，方法调用`wg.Add(2)`配置了`WaitGroup`变量`wg`，因为工作被分配给了两个goroutine。`work`函数调用`defer
    wg.Done()`，每次完成时将WaitGroup计数器减一。
- en: Lastly, the `wg.Wait()`method call blocks until its internal counter reaches
    zero. As explained previously, this will happen when both goroutines' `work` running
    function complete successfully. When that happens, the program unblocks and gathers
    the partial results. It is important to remember that `wg.Wait()` will block indefinitely
    if its internal counter never reaches zero.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`wg.Wait()`方法调用会阻塞，直到其内部计数器达到零。如前所述，这将在两个goroutine的`work`运行函数成功完成后发生。当发生这种情况时，程序将解除阻塞并收集部分结果。重要的是要记住，如果其内部计数器永远不会达到零，`wg.Wait()`将无限期地阻塞。
- en: Detecting race conditions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测竞态条件
- en: Debugging concurrent code with a race condition can be time consuming and frustrating.
    When a race condition occurs, it is usually inconsistent and displays little to
    no discernible pattern. Fortunately, since Version 1.1, Go has included a race
    detector as part of its command-line tool chain. When building, testing, installing,
    or running Go source code, simply add the `-race` command flag to enable the race
    detector instrumentation of your code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有竞态条件的并发代码进行调试可能既耗时又令人沮丧。当发生竞态条件时，它通常是不一致的，并且显示很少或没有可识别的模式。幸运的是，自从版本1.1以来，Go已经将其竞态检测器作为其命令行工具链的一部分包含在内。在构建、测试、安装或运行Go源代码时，只需添加`-race`命令标志即可启用代码的竞态检测器。
- en: 'For instance, when the source file `golang.fyi/ch09/sync1.go` (a code with
    a race condition) is executed with the `-race` flag, the compiler''s output shows
    the offending goroutine locations that caused the race condition, as shown in
    the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用`-race`标志执行源文件`golang.fyi/ch09/sync1.go`（一个带有竞态条件的代码）时，编译器的输出显示了导致竞态条件的违规goroutine位置，如下面的输出所示：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The race detector lists the line numbers where there is concurrent access to
    shared values. It lists the *read* operations followed by the locations where
    *write* operations may happen concurrently. Racy conditions in code can go unnoticed,
    even in well-tested code, until it manifests itself randomly. If you are writing
    concurrent code, it is highly recommended that you integrate the race detector
    as part of your testing suite.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态检测器列出了存在对共享值并发访问的行号。它列出了随后的*读取*操作，然后是可能并发发生*写入*操作的地点。代码中的竞态条件可能不会被注意到，即使在经过良好测试的代码中，直到它随机地表现出来。如果您正在编写并发代码，强烈建议您将竞态检测器集成到您的测试套件中作为一部分。
- en: Parallelism in Go
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 中的并行性
- en: 'So far, the discussion in this chapter has focused on synchronizing concurrent
    programs. As was mentioned earlier in the chapter, the Go runtime scheduler automatically
    multiplexes and schedules goroutines across available OS-managed threads. This
    means concurrent programs that can be parallelized have the ability to take advantage
    of the underlying processor cores with little to no configuration. For instance,
    the following code cleanly segregates its work unit (to calculate sums of multiples
    of 3 and 5) to be calculated by launching `workers` number of goroutines:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章的讨论主要集中在同步并发程序上。正如本章前面提到的，Go 运行时调度器自动将 goroutines 多路复用和调度到可用的操作系统管理的线程中。这意味着可以并行化的并发程序能够利用底层处理器核心，而无需进行很少或没有配置。例如，以下代码干净地分离了其工作单元（计算3和5的倍数的和），通过启动`workers`数量的goroutines来计算：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: golang.fyi/ch09/sync6.go
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch09/sync6.go
- en: The previous code will automatically launch each goroutine, with `go work()`,
    in parallel when executed on a multi-core machine. The Go runtime scheduler, by
    default, will create a number of OS-backed threads for scheduling that is equal
    to the number of CPU cores. That quantity is identified by runtime value called
    *GOMAXPROCS*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在多核机器上执行时，前面的代码将自动以并行方式启动每个goroutine，使用`go work()`。默认情况下，Go 运行时调度器将为调度创建与CPU核心数量相等的操作系统支持的线程。这个数量由运行时值*GOMAXPROCS*标识。
- en: The GOMAXPROCS value can be explicitly changed to influence the number threads
    that are made available to the scheduler. That value can be changed using a command-line
    environment variable with the same name. GOMAXPROCS can also be updated in the
    using function `GOMAXPROCS()` from the *runtime* package ([https://golang.org/pkg/runtime](https://golang.org/pkg/runtime)).
    Either approach allows programmers to fine-tune the number of threads that will
    participate in scheduling goroutines.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以显式更改 GOMAXPROCS 值以影响提供给调度器的线程数量。该值可以使用同名的命令行环境变量进行更改。GOMAXPROCS 还可以通过`runtime`包中的使用函数`GOMAXPROCS()`进行更新（[https://golang.org/pkg/runtime](https://golang.org/pkg/runtime)）。两种方法都允许程序员微调将参与goroutine调度的线程数量。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Concurrency can be a complex topic in any language. This chapter covered the
    major topics to guide readers around the use of concurrency primitives in the
    Go language. The first section of the chapter outlined the crucial properties
    of goroutines, including the creation and usage of the *go* statement. Next, the
    chapter covered the mechanism of Go's runtime scheduler and the notion of channels
    used for communication between running goroutines. Lastly, users were introduced
    to several concurrency patterns used to create concurrent programs using goroutines,
    channels, and the synchronization primitives from the sync package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 并发在任何语言中都可能是一个复杂的话题。本章涵盖了主要主题，以指导读者了解 Go 语言中并发原语的使用。本章的第一部分概述了goroutines的关键属性，包括`go`语句的创建和使用。接下来，本章介绍了
    Go 的运行时调度机制以及用于运行中goroutines之间通信的通道概念。最后，用户被介绍了几种并发模式，这些模式用于使用goroutines、通道和来自sync包的同步原语创建并发程序。
- en: Next, you will be introduced to the standard APIs to do data input and output
    in Go.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将了解在 Go 中进行数据输入和输出的标准 API。
