- en: Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。行为模式 - 访问者、状态、中介者和观察者设计模式
- en: This is the last chapter about Behavioral patterns and it also closes this book's
    section about common, well known design patterns in Go language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于行为模式的最后一章，同时也结束了这本书关于Go语言中常见、知名设计模式的部分。
- en: In this chapter, we are going to look at three more design patterns. Visitor
    pattern is very useful when you want to abstract away some functionality from
    a set of objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨三个更多设计模式。访问者模式在你想从一组对象中抽象出某些功能时非常有用。
- en: State is used commonly to build **Finite State Machines** (**FSM**) and, in
    this section, we will develop a small *guess the number* game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通常用于构建**有限状态机**（**FSM**），在本节中，我们将开发一个小型的*猜数字*游戏。
- en: Finally, the Observer pattern is commonly used in event-driven architectures
    and is gaining a lot of traction again, especially in the microservices world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，观察者模式在事件驱动架构中很常见，并且在微服务世界中再次获得了大量关注。
- en: After this chapter, we'll need to feel very comfortable with common design patterns
    before digging in concurrency and the advantages (and complexity), it brings to
    design patterns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们需要在深入并发及其在设计模式中的优势（以及复杂性）之前，对常见设计模式感到非常熟悉。
- en: Visitor design pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者设计模式
- en: In the next design pattern, we are going to delegate some logic of an object's
    type to an external type called the visitor that will visit our object to perform
    operations on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个设计模式中，我们将将对象类型的某些逻辑委托给一个外部类型，称为访问者，它将访问我们的对象以执行操作。
- en: Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: In the Visitor design pattern, we are trying to separate the logic needed to
    work with a specific object outside of the object itself. So we could have many
    different visitors that do some things to specific types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问者设计模式中，我们试图将处理特定对象所需的逻辑与对象本身分离。因此，我们可以有许多不同的访问者对特定类型执行某些操作。
- en: For example, imagine that we have a log writer that writes to console. We could
    make the logger "visitable" so that you can prepend any text to each log. We could
    write a Visitor pattern that prepends the date, the time, and the hostname to
    a field stored in the object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个写入控制台的日志记录器。我们可以使记录器“可访问”，这样你就可以在每个日志前添加任何文本。我们可以编写一个访问者模式，将日期、时间和主机名添加到对象中存储的字段。
- en: Objectives
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'With Behavioral design patterns we are mainly dealing with algorithms. Visitor
    patterns are not an exception. The objectives that we are trying to achieve are
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为设计模式中，我们主要处理算法。访问者模式也不例外。我们试图实现的目标如下：
- en: To separate the algorithm of some type from its implementation within some other
    type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某些类型的算法与其在另一个类型中的实现分离
- en: To improve the flexibility of some types by using them with little or no logic
    at all so all new functionality can be added without altering the object structure
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用几乎没有任何逻辑的某些类型来提高它们的灵活性，这样所有新的功能都可以添加，而无需更改对象结构
- en: To fix a structure or behavior that would break the open/closed principle in
    a type
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了修复一个会破坏类型开放/封闭原则的结构或行为
- en: You might be thinking what the open/closed principle is. In computer science,
    the open/closed principle states that: *entities should be open for * *extension
    but closed for modification*. This simple state has lots of implications that
    allows building more maintainable software and less prone to errors. And the Visitor
    pattern helps us to delegate some commonly changing algorithm from a type that
    we need it to be "stable" to an external type that can change often without affecting
    our original one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道开放/封闭原则是什么。在计算机科学中，开放/封闭原则指出：*实体应该对扩展开放，但对修改封闭*。这种简单的状态有很多含义，允许构建更易于维护的软件，并且更不容易出错。访问者模式帮助我们将一些经常变化的算法从需要“稳定”的类型中委托给一个可以经常更改而不影响原始类型的外部类型。
- en: A log appender
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志追加器
- en: We are going to develop a simple log appender as an example of the Visitor pattern.
    Following the approach we have had in previous chapters, we will start with an
    extremely simple example to clearly understand how the Visitor design pattern
    works before jumping to a more complex one. We have already developed similar
    examples modifying texts too, but in slightly different ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个简单的日志追加器为例，来开发一个访问者模式的示例。遵循我们在前几章中采用的方法，我们将从一个极其简单的例子开始，以便清楚地理解访问者设计模式是如何工作的，然后再转向一个更复杂的例子。我们之前也开发过类似的例子，修改文本，但方式略有不同。
- en: For this particular example, we will create a Visitor that appends different
    information to the types it "visits".
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，我们将创建一个访问者，它将向它“访问”的类型追加不同的信息。
- en: Acceptance criteria
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'To effectively use the Visitor design pattern, we must have two roles--a visitor
    and a visitable. The `Visitor` is the type that will act within a `Visitable`
    type. So a `Visitable` interface implementation has an algorithm detached to the `Visitor`
    type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用访问者设计模式，我们必须有两个角色——访问者和可访问者。`访问者`是将在`可访问者`类型内执行操作的类型。因此，`可访问者`接口实现有一个与`访问者`类型分离的算法：
- en: 'We need two message loggers: `MessageA` and `MessageB` that will print a message
    with an `A:` or a `B:` respectively before the message.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个消息记录器：`MessageA`和`MessageB`，它们将在消息前分别打印`A:`或`B:`。
- en: We need a Visitor able to modify the message to be printed. It will append the
    text "Visited A" or "Visited B" to them, respectively.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个能够修改要打印的消息的访问者。它将分别向它们追加文本“Visited A”或“Visited B”。
- en: Unit tests
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'As we mentioned before, we will need a role for the `Visitor` and the `Visitable`
    interfaces. They will be interfaces. We also need the `MessageA` and `MessageB`
    structs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们需要为`访问者`和`可访问者`接口提供一个角色。它们将是接口。我们还需要`MessageA`和`MessageB`结构体：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The types `MessageA` and `MessageB` structs both have an `Msg` field to store
    the text that they will print. The output `io.Writer` will implement the `os.Stdout`
    interface by default or a new `io.Writer` interface, like the one we will use
    to check that the contents are correct.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageA`和`MessageB`结构体类型都有一个`Msg`字段来存储它们将要打印的文本。默认情况下，输出`io.Writer`将实现`os.Stdout`接口，或者一个新的`io.Writer`接口，就像我们将用它来检查内容是否正确的那样。'
- en: The `Visitor` interface has a `Visit` method, one for each of `Visitable` interface's
    `MessageA` and `MessageB` type. The `Visitable` interface has a method called `Accept(Visitor)`
    that will execute the decoupled algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`访问者`接口有一个`Visit`方法，对应于`可访问者`接口的`MessageA`和`MessageB`类型。`可访问者`接口有一个名为`Accept(Visitor)`的方法，它将执行解耦算法。'
- en: 'Like in previous examples, we will create a type that implements the `io.Writer`
    package so that we can use it in tests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将创建一个实现`io.Writer`包的类型，以便我们可以在测试中使用它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `TestHelper` struct implements the `io.Writer` interface. Its functionality
    is quite simple; it stores the written bytes on the `Received` field. Later we
    can check the contents of `Received` to test against our expected value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestHelper`结构体实现了`io.Writer`接口。它的功能相当简单；它将写入的字节存储在`Received`字段上。稍后我们可以检查`Received`的内容以测试我们的预期值。'
- en: 'We will write just one test that will check the overall correctness of the
    code. Within this test, we will write two sub tests: one for `MessageA` and one
    for `MessageB` types:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只编写一个测试来检查代码的整体正确性。在这个测试中，我们将编写两个子测试：一个用于`MessageA`类型，一个用于`MessageB`类型：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use a `TestHelper` struct and a `MessageVisitor` struct on each test
    for each message type. First, we will test the `MessageA` type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个消息类型的每个测试中使用一个`TestHelper`结构体和一个`MessageVisitor`结构体。首先，我们将测试`MessageA`类型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the full first test. We created `MessageA` struct, giving it a value
    `Hello World` for the `Msg` field and the pointer to `TestHelper`, which we created
    at the beginning of the test. Then, we execute its `Accept` method. Inside the
    `Accept(Visitor)` method on the `MessageA` struct, the `VisitA(*MessageA)` method
    is executed to alter the contents of the `Msg` field (that's why we passed the
    pointer to `VisitA` method, without a pointer the contents won't be persisted).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的第一个测试。我们创建了`MessageA`结构体，给它`Msg`字段一个值`Hello World`，并提供了我们在测试开始时创建的`TestHelper`的指针。然后，我们执行它的`Accept`方法。在`MessageA`结构体上的`Accept(Visitor)`方法内部，执行了`VisitA(*MessageA)`方法来更改`Msg`字段的内容（这就是为什么我们传递了`VisitA`方法的指针，如果没有指针，内容将不会持久化）。
- en: To test if the `Visitor` type has done its job within the `Accept` method, we
    must call the `Print()` method on the `MessageA` type later. This way, the `MessageA` struct
    must write the contents of `Msg` to the provided `io.Writer` interface (our `TestHelper`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`访问者`类型是否在`Accept`方法中完成了其工作，我们必须稍后在`MessageA`类型上调用`Print()`方法。这样，`MessageA`结构体必须将`Msg`字段的内容写入提供的`io.Writer`接口（我们的`TestHelper`）。
- en: 'The last part of the test is the check. According to the description of *acceptance
    criteria 2*, the output text of `MessageA` type must be prefixed with the text `A:`,
    the stored message and the text `"(Visited)"` just at the end. So, for the `MessageA`
    type, the expected text must be `"A: Hello World (Visited)"`, this is the check
    that we did in the `if` section.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '测试的最后部分是检查。根据 *验收标准 2* 的描述，`MessageA` 类型的输出文本必须以文本 `A:` 开头，存储的消息和文本 `"(Visited)"`
    在末尾。所以，对于 `MessageA` 类型，预期的文本必须是 `"A: Hello World (Visited)"`，这就是我们在 `if` 部分所做的检查。'
- en: 'The `MessageB` type has a very similar implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageB` 类型有一个非常相似的实现：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fact, we have just changed the type from `MessageA` to `MessageB` and the
    expected text now is `"B: Hello World (Visited B)"`. The `Msg` field is also `"Hello
    World"` and we also used the `TestHelper` type.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '事实上，我们只是将类型从 `MessageA` 改为 `MessageB`，现在期望的文本是 `"B: Hello World (Visited B)"`。`Msg`
    字段也是 `"Hello World"`，我们同样使用了 `TestHelper` 类型。'
- en: 'We still lack the correct implementations of the interfaces to compile the
    code and run the tests. The `MessageA` and `MessageB` structs have to implement
    the `Accept(Visitor)` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少接口的正确实现来编译代码和运行测试。`MessageA` 和 `MessageB` 结构体必须实现 `Accept(Visitor)` 方法：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need the implementations of the `VisitA(*MessageA)` and `VisitB(*MessageB)`
    methods that are declared on the `Visitor` interface. The `MessageVisitor` interface
    is the type that must implement them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现 `Visitor` 接口上声明的 `VisitA(*MessageA)` 和 `VisitB(*MessageB)` 方法。`MessageVisitor`
    接口是必须实现它们的类型：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will create a `Print()` method for each message type. This is the
    method that we will use to test the contents of the `Msg` field on each type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为每种消息类型创建一个 `Print()` 方法。这是我们用来测试每个类型 `Msg` 字段内容的工具：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can run the tests to really check if they are failing yet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行测试来真正检查它们是否已经失败：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The outputs of the tests are clear. The expected messages were incorrect because
    the contents were empty. It's time to create the implementations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出很清晰。预期的消息是不正确的，因为内容是空的。是时候创建实现啦。
- en: Implementation of Visitor pattern
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式的实现
- en: 'We will start completing the implementation of the `VisitA(*MessageA)` and
    `VisitB(*MessageB)` methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始完成 `VisitA(*MessageA)` 和 `VisitB(*MessageB)` 方法的实现：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Its functionality is quite straightforward--the `fmt.Sprintf` method returns
    a formatted string with the actual contents of `m.Msg`, a white space, and the
    message, `Visited`. This string will be stored on the `Msg` field, overriding
    the previous contents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其功能相当直接--`fmt.Sprintf` 方法返回一个格式化的字符串，包含 `m.Msg` 的实际内容、一个空格和消息 `Visited`。这个字符串将被存储在
    `Msg` 字段，覆盖之前的内 容。
- en: 'Now we will develop the `Accept` method for each message type that must execute
    the corresponding Visitor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为必须执行相应访问者的每种消息类型开发 `Accept` 方法：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This small code has some implications on it. In both cases, we are using a
    `Visitor`, which in our example is exactly the same as the `MessageVisitor` interface,
    but they could be completely different. The key is to understand that the Visitor
    pattern executes an algorithm in its `Visit` method that deals with the `Visitable`
    object. What could the `Visitor` be doing? In this example, it alters the `Visitable`
    object, but it could be simply fetching information from it. For example, we could
    have a `Person` type with lots of fields: name, surname, age, address, city, postal
    code, and so on. We could write a Visitor to fetch just the name and surname from
    a person as a unique string, a visitor to fetch the address info for a different
    section of an app, and so on.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码有一些含义。在两种情况下，我们都在使用 `Visitor`，在我们的例子中，它正好与 `MessageVisitor` 接口相同，但它们可能完全不同。关键是理解访问者模式在其
    `Visit` 方法中执行算法，该算法处理 `Visitable` 对象。`Visitor` 可以做什么？在这个例子中，它改变了 `Visitable` 对象，但它也可以简单地从它那里获取信息。例如，我们可以有一个
    `Person` 类型，有很多字段：姓名、姓氏、年龄、地址、城市、邮政编码等等。我们可以编写一个访问者来从一个人那里获取唯一的字符串（姓名和姓氏），一个访问者来获取应用程序不同部分的地址信息，等等。
- en: 'Finally, there is the `Print()` method, which will help us to test the types.
    We mentioned before that it must print to the `Stdout` call by default:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是 `Print()` 方法，它将帮助我们测试类型。我们之前提到，它默认必须打印到 `Stdout` 调用：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It first checks the content of the `Output` field to assign the output of the `os.Stdout` call
    in case it is null. In our tests, we are storing a pointer there to our `TestHelper`
    type so this line is never executed in our test. Finally, each message type prints
    to the `Output` field, the full message stored in the `Msg` field. This is done
    by using the `Fprintf` method, which takes an `io.Writer` package as the first
    argument and the text to format as the next arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先检查 `Output` 字段的内容，以分配 `os.Stdout` 调用的输出，以防它是空的。在我们的测试中，我们在这里存储了一个指向我们的 `TestHelper`
    类型的指针，所以这行代码在我们的测试中永远不会被执行。最后，每个消息类型都会将存储在 `Msg` 字段中的完整消息打印到 `Output` 字段。这是通过使用
    `Fprintf` 方法完成的，该方法将 `io.Writer` 包作为第一个参数，将格式化文本作为后续参数。
- en: 'Our implementation is now complete and we can run the tests again to see if
    they all pass now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的实现已经完成，我们可以再次运行测试，看看它们现在是否都通过了：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Everything is OK! The Visitor pattern has done its job flawlessly and the message
    contents were altered after calling their `Visit` methods. The very important
    thing here is that we can add more functionality to both the structs, `MessageA`
    and `MessageB`, without altering their types. We can just create a new Visitor
    type that does everything on the `Visitable`, for example, we can create a `Visitor`
    to add a method that prints the contents of the `Msg` field:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常！访问者模式完美地完成了它的任务，并且在调用它们的 `Visit` 方法之后，消息内容被修改了。这里非常重要的一点是，我们可以为这两个结构体，`MessageA`
    和 `MessageB`，添加更多功能，而不改变它们的类型。我们只需创建一个新的访问者类型，它可以在 `Visitable` 上做所有事情，例如，我们可以创建一个
    `Visitor` 来添加一个打印 `Msg` 字段内容的方法：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have just added some functionality to both types without altering their contents!
    That's the power of the Visitor design pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是为这两种类型添加了一些功能，而没有改变它们的内部内容！这就是访问者设计模式的力量。
- en: Another example
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个示例
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发第二个示例，这个示例稍微复杂一些。在这种情况下，我们将模拟一个在线商店，其中包含一些产品。产品将具有普通类型，只有字段，我们将创建几个访问者来处理这些产品。
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发接口。`ProductInfoRetriever` 类型有一个方法可以获取产品的价格和名称。`Visitor` 接口，就像之前一样，有一个
    `Visit` 方法，它接受 `ProductInfoRetriever` 类型。最后，`Visitable` 接口完全相同；它有一个 `Accept` 方法，该方法接受一个
    `Visitor` 类型作为参数：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在线商店的所有产品都必须实现 `ProductInfoRetriever` 类型。此外，大多数产品将有一些公共字段，例如名称或价格（在 `ProductInfoRetriever`
    接口中定义的）。我们创建了 `Product` 类型，实现了 `ProductInfoRetriever` 和 `Visitable` 接口，并将其嵌入到每个产品中：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常通用的 `Product` 类型，它可以存储商店几乎任何产品的信息。例如，我们可能有一个 `Rice` 和 `Pasta` 产品：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都嵌入了 `Product` 类型。现在我们需要创建几个 `Visitors` 接口，一个用于计算所有产品的价格总和，另一个用于打印每个产品的名称：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriceVisitor` 结构体接受作为参数传递的 `ProductInfoRetriever` 类型的 `Price` 变量的值，并将其添加到
    `Sum` 字段。`NamePrinter` 结构体存储作为参数传递的 `ProductInfoRetriever` 类型的名称，并将其追加到新的 `ProductList`
    字段行。'
- en: 'Time for the `main` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `main` 函数的时间：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含两个`Visitable`对象的切片：一个`Rice`和一个`Pasta`类型的对象，具有一些任意的名称。然后我们使用`PriceVisitor`实例作为参数对它们中的每一个进行迭代。在for循环结束后，我们打印出总价。最后，我们使用`NamePrinter`重复此操作并打印出结果`ProductList`。这个`main`函数的输出如下：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个访问者模式的良好示例，但是……如果对产品有特殊考虑怎么办？例如，如果我们需要将20加到冰箱类型的总价上怎么办？好的，让我们编写`Fridge`结构：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是只是重写`GetPrice()`方法以返回产品的价格加上20：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这对我们的示例还不够。`Fridge`结构不是`Visitable`类型。`Product`结构是`Visitable`类型，而`Fridge`结构包含一个`Product`结构体，但正如我们在前面的章节中提到的，嵌套第二个类型的类型不能被认为是后者类型，即使它具有所有字段和方法。解决方案是实现`Accept(Visitor)`方法，使其可以被认为是`Visitable`：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`main`函数，以添加这个新的`Fridge`产品到切片中：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切继续相同。运行这个新的`main`函数会产生以下输出：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，总价现在更高了，输出的是大米（32）、意大利面（40）和冰箱（产品50加上运输20，所以70）的总和。我们可以永远向这些产品添加访问者，但理念是清晰的——我们将一些算法从类型中解耦到了访问者中。
- en: Visitors to the rescue!
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者来拯救！
- en: We have seen a powerful abstraction to add new algorithms to some types. However,
    because of the lack of overloading in Go, this pattern could be limiting in some
    aspects (we have seen it in the first example, where we had to create the `VisitA`
    and `VisitB` implementations). In the second example, we haven't dealt with this
    limitation because we have used an interface to the `Visit` method of the `Visitor` struct,
    but we just used one type of visitor (`ProductInfoRetriever`) and we would have
    the same problem if we implemented a `Visit` method for a second type, which is
    one of the objectives of the original *Gang of Four* design patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个强大的抽象，可以将新算法添加到某些类型中。然而，由于Go中缺少重载，这个模式在某些方面可能有限制（我们在第一个示例中看到了这一点，当时我们必须创建`VisitA`和`VisitB`实现）。在第二个示例中，我们没有处理这个限制，因为我们使用了`Visitor`结构体的`Visit`方法接口，但我们只使用了一种类型的访问者（`ProductInfoRetriever`），如果我们为第二种类型实现`Visit`方法，我们也会遇到同样的问题，这是原始*四人帮*设计模式的一个目标。
- en: State design pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: State patterns are directly related to FSMs. An FSM, in very simple terms, is
    something that has one or more states and travels between them to execute some
    behaviors. Let's see how the State pattern helps us to define FSM.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式与FSM直接相关。在非常简单的术语中，FSM是具有一个或多个状态并在它们之间移动以执行某些行为的东西。让我们看看状态模式如何帮助我们定义FSM。
- en: Description
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: A light switch is a common example of an FSM. It has two states--on and off.
    One state can transit to the other and vice versa. The way that the State pattern
    works is similar. We have a `State` interface and an implementation of each state
    we want to achieve. There is also usually a context that holds cross-information
    between the states.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 开关灯是有限状态机（FSM）的一个常见示例。它有两个状态——开和关。一个状态可以转换到另一个状态，反之亦然。状态模式的工作方式与此类似。我们有一个`State`接口和每个我们想要实现的状态的实现。通常还有一个上下文，它持有状态之间的跨信息。
- en: With FSM, we can achieve very complex behaviors by splitting their scope between
    states. This way we can model pipelines of execution based on any kind of inputs
    or create event-driven software that responds to particular events in specified
    ways.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用有限状态机（FSM），我们可以通过在状态之间分割它们的范围来实现非常复杂的行为。这样，我们可以根据任何类型的输入来建模执行管道，或者创建响应特定事件的特定方式的基于事件的软件。
- en: Objectives
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The main objectives of the State pattern is to develop FSM are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 国家模式的主要目标是为了开发有限状态机（FSM），具体如下：
- en: To have a type that alters its own behavior when some internal things have changed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要有一个类型，当某些内部事物发生变化时改变其自身的行为
- en: Model complex graphs and pipelines can be upgraded easily by adding more states
    and rerouting their output states
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加更多状态并重新路由它们的输出状态，可以轻松升级复杂的图和管道模型
- en: A small guess the number game
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的猜数字游戏
- en: We are going to develop a very simple game that uses FSM. This game is a number
    guessing game. The idea is simple--we will have to guess some number between 0
    and 10 and we have just a few attempts or we'll lose.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个非常简单的游戏，该游戏使用有限状态机（FSM）。这个游戏是一个数字猜测游戏。想法很简单——我们将在0到10之间猜测一个数字，我们只有几次尝试，否则就会失败。
- en: We will leave the player to choose the level of difficulty by asking how many
    tries the user has before losing. Then, we will ask the player for the correct
    number and keep asking if they don't guess it or if the number of tries reaches
    zero.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让玩家通过询问他们在游戏失败前有多少次尝试机会来选择难度级别。然后，我们将询问玩家正确的数字，如果他们猜不对或者尝试次数达到零，我们将继续询问。
- en: Acceptance criteria
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'For this simple game, we have five acceptance criteria that basically describe
    the mechanics of the game:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的游戏，我们有五个验收标准，基本上描述了游戏的机制：
- en: The game will ask the player how many tries they will have before losing the
    game.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏将询问玩家在游戏失败前将有多少次尝试机会。
- en: The number to guess must be between 0 and 10.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要猜测的数字必须在0到10之间。
- en: Every time a player enters a number to guess, the number of retries drops by
    one.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次玩家输入一个猜测数字时，尝试次数就会减少一次。
- en: If the number of retries reaches zero and the number is still incorrect, the
    game finishes and the player has lost.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尝试次数达到零而数字仍然不正确，游戏结束，玩家失败。
- en: If the player guesses the number, the player wins.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家猜对了数字，玩家获胜。
- en: Implementation of State pattern
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式的实现
- en: The idea of unit tests is quite straightforward in a State pattern so we will
    spend more time explaining in detail the mechanism to use it, which is a bit more
    complex than usual.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态模式中，单元测试的想法非常直接，因此我们将花更多的时间详细解释如何使用它，这比通常要复杂一些。
- en: 'First of all, we need the interface to represent the different states and a
    game context to store the information between states. For this game, the context
    needs to store the number of retries, if the user has won or not, the secret number
    to guess, and the current state. The state will have an `executeState` method
    that accepts one of these contexts and returns `true` if the game has finished,
    or `false` if not:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个接口来表示不同的状态，以及一个游戏上下文来存储状态之间的信息。对于这个游戏，上下文需要存储重试次数、用户是否获胜、要猜测的秘密数字以及当前状态。状态将有一个
    `executeState` 方法，它接受这些上下文之一，如果游戏结束则返回 `true`，否则返回 `false`：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As described in *acceptance criteria 1*, the player must be able to introduce
    the number of retries they want. This will be achieved by a state called `StartState`.
    Also, the `StartState` struct must prepare the game, setting the context to its
    initial value before the player:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *验收标准 1* 所述，玩家必须能够输入他们想要的尝试次数。这将通过一个名为 `StartState` 的状态来实现。此外，`StartState`
    结构体必须在玩家之前准备游戏，将上下文设置为初始值：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First of all, the `StartState` struct implements the `GameState` structure because
    it has the `executeState(*Context)` method of Boolean type on its structure. At
    the beginning of this state, it sets the only state possible after executing this
    one--the `AskState` state. The `AskState` struct is not declared yet, but it will
    be the state where we ask the player for a number to guess.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`StartState` 结构体实现了 `GameState` 结构体，因为它在其结构体上有一个布尔类型的 `executeState(*Context)`
    方法。在这个状态开始时，它设置执行此状态后唯一可能的状态——`AskState` 状态。`AskState` 结构体尚未声明，但将是我们询问玩家猜测数字的状态。
- en: In the next two lines, we use the `Rand` package of Go to generate a random
    number. In the first line, we feed the random generator with the `int64` type
    number returned by the current moment, so we ensure a random feed in each execution
    (if you put a constant number here, the randomizer will also generate the same
    number too). The `rand.Intn(int)` method returns an integer number between zero
    and the specified number, so here we cover *acceptance criteria 2*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行中，我们使用 Go 的 `Rand` 包来生成随机数。在第一行，我们将随机生成器与当前时刻返回的 `int64` 类型数字相结合，以确保每次执行时都能提供随机的输入（如果你在这里放置一个常数，随机化器也会生成相同的数字）。`rand.Intn(int)`
    方法返回一个介于零和指定数字之间的整数，因此在这里我们涵盖了*接受标准 2*。
- en: Next, a message asking for a number of retries to set precedes the `fmt.Fscanf`
    method, a powerful function where you can pass it an `io.Reader` (the standard
    input of the console), a format (number), and an interface to store the contents
    of the reader, in this case, the `Retries` field of the context.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个请求设置重试次数的消息位于 `fmt.Fscanf` 方法之前，这是一个强大的函数，你可以向它传递一个 `io.Reader`（控制台的标准输入）、一个格式（数字）和一个接口来存储读取器的内容，在这种情况下，是上下文的
    `Retries` 字段。
- en: 'Finally, we return `true` to tell the engine that the game must continue. Let''s
    see the `AskState` struct, which we have used at the beginning of the function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回 `true` 来告诉引擎游戏必须继续。让我们看看我们一开始在函数中使用的 `AskState` 结构体：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `AskState` structure also implements the `GameState` state, as you have
    probably guessed already. This states starts with a message for the player, asking
    them to insert a new number. In the next three lines, we create a local variable
    to store the contents of the number that the player will introduce. We used the
    `fmt.Fscanf` method again, as we did in `StartState` struct to capture the player's
    input and store it in the variable `n`. Then, we have one retry less in our counter,
    so we have to subtract one to the number of retries represented in the `Retries`
    field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`AskState` 结构体也实现了 `GameState` 状态，正如你可能已经猜到的。这个状态从给玩家的消息开始，要求他们插入一个新的数字。在接下来的三行中，我们创建一个局部变量来存储玩家将要输入的数字的内容。我们再次使用了
    `fmt.Fscanf` 方法，就像我们在 `StartState` 结构体中所做的那样，来捕获玩家的输入并将其存储在变量 `n` 中。然后，我们的计数器中减少了一个重试，所以我们必须从
    `Retries` 字段表示的重试次数中减去一个。'
- en: 'Then, there are two checks: one that checks if the user has entered the correct
    number, in which case the context field `Won` is set to `true` and the next state
    is set to the `FinishState` struct (not declared yet).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个检查：一个检查用户是否输入了正确的数字，如果是这样，则将上下文字段的 `Won` 设置为 `true`，并将下一个状态设置为 `FinishState`
    结构体（尚未声明）。
- en: The second check is controlling that the number of retries has not reached zero,
    in which case it won't let the player ask again for a number and it will send
    the player to the `FinishState` struct directly. After all, we have to tell the
    game engine again that the game must continue by returning `true` in the `executeState`
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个检查是控制重试次数是否未达到零，如果是这样，它不会让玩家再次请求数字，并将玩家直接发送到 `FinishState` 结构体。毕竟，我们必须再次告诉游戏引擎游戏必须继续，通过在
    `executeState` 方法中返回 `true`。
- en: 'Finally, we define the `FinishState` struct. It controls the exit status of
    the game, checking the contents of the `Won` field in the context object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义 `FinishState` 结构体。它控制游戏的退出状态，检查上下文对象中 `Won` 字段的内容：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `TheFinishState` struct also implements the `GameState` state by having
    `executeState` method in its structure. The idea here is very simple--if the player
    has won (this field is set previously in the `AskState` struct), the `FinishState`
    structure will print the message `Congrats, you won`. If the player has not won
    (remember that the zero value of the Boolean variable is `false`), the `FinishState`
    prints the message `You lose.`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheFinishState` 结构体通过在其结构体中拥有 `executeState` 方法来实现 `GameState` 状态。这里的想法非常简单--如果玩家已经赢了（这个字段在
    `AskState` 结构体中之前已经设置），则 `FinishState` 结构体会打印消息 `恭喜，你赢了`。如果玩家没有赢（记住布尔变量的零值是 `false`），则
    `FinishState` 会打印消息 `你输了`。'
- en: In this case, the game can be considered finished, so we return `false` to say
    that the game must not continue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，游戏可以被认为是结束了，所以我们返回 `false` 来表示游戏必须不继续。
- en: 'We just need the `main` method to play our game:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要 `main` 方法来玩我们的游戏：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Well, yes, it can't be simpler. The game must begin with the `start` method,
    although it could be abstracted more outside in case that the game needs more
    initialization in the future, but in our case it is fine. Then, we create a context
    where we set the `Next` state as a pointer to the `start` variable. So the first
    state that will be executed in the game will be the `StartState` state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是的，这不能更简单了。游戏必须从`start`方法开始，尽管将来如果游戏需要更多的初始化，它可以在外面进一步抽象化，但就我们目前的情况来看，这是可以的。然后，我们创建一个上下文，我们将`Next`状态设置为指向`start`变量的指针。所以游戏将首先执行的是`StartState`状态。
- en: The last line of the `main` function has a lot of things just there. We create
    a loop, without any statement inside it. As with any loop, it keeps looping after
    the condition is not satisfied. The condition we are using is the returned value
    of the `GameStates` structure, `true` as soon as the game is not finished.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的最后一行有很多东西只是在那里。我们创建了一个循环，循环体内没有任何语句。就像任何循环一样，当条件不满足时，它会一直循环。我们使用的是`GameStates`结构的返回值，只要游戏没有结束，就返回`true`。'
- en: 'So, the idea is simple: we execute the state in the context, passing a pointer
    to the context to it. Each state returns `true` until the game has finished and
    the `FinishState` struct will return `false`. So our for loop will keep looping,
    waiting for a `false` condition sent by the `FinishState` structure to end the
    application.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个想法很简单：我们在上下文中执行状态，传递上下文的指针给它。每个状态都会返回`true`，直到游戏结束，`FinishState`结构将返回`false`。所以我们的for循环会一直循环，等待`FinishState`结构发送的`false`条件来结束应用程序。
- en: 'Let''s play once:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一次：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We lost! We set the number of retries to 5\. Then we kept inserting numbers,
    trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn't
    any of them. I don't even know what the correct number was; let's fix this!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输了！我们将重试次数设置为5。然后我们继续输入数字，试图猜出秘密数字。我们输入了8、2、1、3和4，但都不是。我甚至不知道正确的数字是什么；让我们修复这个问题！
- en: 'Go to the definition of the `FinishState` struct and change the line where
    it says `You lose`, and replace it with the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`FinishState`结构的定义，并更改显示“你输了”的那一行，将其替换为以下内容：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now it will show the correct number. Let''s play again:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它会显示正确的数字。让我们再玩一次：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time we make it a little harder by setting only three tries... and we
    lost again. I entered 6, 2, and 1, but the correct number was 9\. Last try:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们让它变得更难一些，只设置了三次尝试...我们又输了。我输入了6、2和1，但正确的数字是9。最后一次尝试：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great! This time we lowered the difficulty, allowing up to five tries and we
    won! we even had one more try left, but we guessed the number in the fourth try
    after entering 3, 4, 5\. The correct number was 6, which was my fourth try.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这次我们降低了难度，允许最多尝试五次，我们赢了！我们甚至还有一次额外的尝试，但在第四次尝试后，我们输入了3、4、5，猜出了数字。正确的数字是6，这是我第四次尝试。
- en: A state to win and a state to lose
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 胜利状态和失败状态
- en: 'Have you realized that we could have a winning and a lose state instead of
    printing the messages directly in the `FinishState` struct? This way we could,
    for example, check some hypothetical scoreboard in the win section to see if we
    have set a record. Let''s refactor our game. First we need a `WinState` and a
    `LoseState` struct:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到我们可以有一个胜利状态和一个失败状态，而不是直接在`FinishState`结构中打印消息吗？这样我们就可以，例如，检查胜利部分的一些假设的分数板，看看我们是否创下了记录。让我们重构我们的游戏。首先我们需要一个`WinState`和一个`LoseState`结构：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These two new states have nothing new. They contain the same messages that
    were previously in the `FinishState` state that, by the way, must be modified
    to use these new states:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新状态没有新内容。它们包含之前在`FinishState`状态中已有的相同信息，顺便说一句，必须修改以使用这些新状态：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the finish state doesn't print anything and, instead, delegates this to
    the next state in the chain--the `WinState` structure, if the user has won and
    the `LoseState` struct, if not. Remember that the game doesn't finish on the `FinishState`
    struct now, and we must return `true` instead of `false` to notify to the engine
    that it must keep executing states in the chain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成状态不会打印任何内容，而是将这个任务委托给链中的下一个状态——如果用户赢了，就是`WinState`结构，如果没有赢，就是`LoseState`结构。记住，现在游戏不会在`FinishState`结构中结束，我们必须返回`true`来通知引擎它必须继续执行链中的状态。
- en: The game built using the State pattern
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用状态模式构建的游戏
- en: You must be thinking now that you can extend this game forever with new states,
    and it's true. The power of the State pattern is not only the capacity to create
    a complex FSM, but also the flexibility to improve it as much as you want by adding
    new states and modifying some old states to point to the new ones without affecting
    the rest of the FSM.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能认为你可以通过添加新的状态来无限扩展这个游戏，这是真的。状态模式的强大之处不仅在于能够创建复杂的有限状态机（FSM），而且在于它具有足够的灵活性，可以通过添加新状态和修改一些旧状态来指向新状态，而不会影响整个
    FSM 的其余部分。
- en: Mediator design pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者设计模式
- en: Let's continue with the Mediator pattern. As its name implies, it's a pattern
    that will be in between two types to exchange information. But, why will we want
    this behavior at all? Let's look at this in detail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论中介者模式。正如其名称所暗示的，这是一种位于两种类型之间以交换信息的模式。但是，我们为什么想要这种行为呢？让我们详细看看。
- en: Description
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: One of the key objectives of any design pattern is to avoid tight coupling between
    objects. This can be done in many ways, as we have seen already.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 任何设计模式的关键目标之一是避免对象之间的紧密耦合。这可以通过许多方式实现，正如我们之前所看到的。
- en: But one particularly effective method when the application grows a lot is the
    Mediator pattern. The Mediator pattern is the perfect example of a pattern that
    is commonly used by every programmer without thinking very much about it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但当应用程序规模很大时，这是一种特别有效的方法，即中介者模式。中介者模式是程序员经常使用而很少思考的模式的一个完美例子。
- en: Mediator pattern will act as the type in charge of exchanging communication
    between two objects. This way, the communicating objects don't need to know each
    other and can change more freely. The pattern that maintains which objects give
    what information is the Mediator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式将充当负责在两个对象之间交换通信的类型。这样，通信对象不需要相互了解，可以更自由地改变。维护哪些对象提供什么信息的模式是中介者。
- en: Objectives
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'As previously described, the main objectives of the Mediator pattern are about
    loose coupling and encapsulation. The objectives are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，中介者模式的主要目标是关于松散耦合和封装。目标是：
- en: To provide loose coupling between two objects that must communicate between
    them
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在必须相互通信的两个对象之间提供松散耦合
- en: To reduce the amount of dependencies of a particular type to the minimum by
    passing these needs to the Mediator pattern
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将这些需求传递给中介者模式，将特定类型的依赖性减少到最小
- en: A calculator
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算器
- en: For the Mediator pattern, we are going to develop an extremely simple arithmetic
    calculator. You're probably thinking that a calculator is so simple that it does
    not need any pattern. But we will see that this is not exactly true.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中介者模式，我们将开发一个极其简单的算术计算器。你可能认为计算器如此简单，不需要任何模式。但我们会看到这并不完全正确。
- en: 'Our calculator will only do two very simple operations: sum and subtract.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算器只会执行两种非常简单的操作：求和和减法。
- en: Acceptance criteria
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'It sounds quite funny to talk about acceptance criteria to define a calculator,
    but let''s do it anyway:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 说到用接受标准来定义计算器，听起来相当有趣，但让我们这样做：
- en: Define an operation called `Sum` that takes a number and adds it to another
    number.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Sum` 的操作，它接受一个数字并将其添加到另一个数字上。
- en: Define an operation called `Subtract` that takes a number and substracts it
    to another number.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `Subtract` 的操作，它接受一个数字并将其从另一个数字中减去。
- en: Well, I don't know about you, but I really need a rest after this *complex*
    criteria. So why are we defining this so much? Patience, you will have the answer
    soon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我不知道你是否和我一样，我真的需要在这 *复杂* 的标准之后休息一下。那么我们为什么要定义这么多呢？耐心点，你很快就会得到答案。
- en: Implementation
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We have to jump directly to the implementation because we cannot test that the
    sum will be correct (well, we can, but we will be testing if Go is correctly written!).
    We could test that we pass the acceptance criteria, but it's a bit of an overkill
    for our example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须直接跳到实现，因为我们无法测试求和是否正确（嗯，我们可以，但我们将测试 Go 是否正确编写！）。我们可以测试是否通过了接受标准，但这对于我们这个例子来说有点过度。
- en: 'So let''s start by implementing the necessary types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先实现必要的类型：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Well... this look quite awkward. We already have numeric types in Go to perform
    these operations, we don't need a type for each number!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...这看起来相当尴尬。我们已经在 Go 中有了执行这些操作的数值类型，我们不需要为每个数字创建一个类型！
- en: 'But let''s continue for a second with this insane approach. Let''s implement
    the `One` struct:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们先继续这种疯狂的方法。让我们实现 `One` 结构体：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: OK , I'll stop here. What is wrong with this implementation? This is completely
    crazy! It's overkill to make every operation possible between numbers to make
    sums! Especially when we have more than one digit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我就说到这里。这个实现有什么问题？这完全疯狂！为了使数字之间所有可能的操作都成为可能的求和操作，这是过度杀鸡用牛刀！尤其是当我们有多个数字的时候。
- en: Well, believe it or not, this is how a lot of software is commonly designed
    today. A small app where an object uses two or three objects grows, and it ends
    up using dozens of them. It becomes an absolute hell to simply add or remove a
    type from the application because it is hidden in some of this craziness.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，信不信由你，这就是今天许多软件通常是如何设计的。一个小型应用程序，其中对象使用两个或三个对象开始，最终会使用几十个。简单地添加或删除应用程序中的一个类型变得绝对痛苦，因为它隐藏在这些疯狂之中。
- en: 'So what can we do in this calculator? Use a Mediator type that frees all the
    cases:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在这个计算器中我们能做什么呢？使用一个中介类型，释放所有情况：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have just developed a couple of numbers to keep things short. The `Sum` function
    acts as a mediator between two numbers. First it checks the type of the first
    number named `a`. Then, for each type of the first number, it checks the type
    of the second number named `b` and returns the resulting type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是开发了一对数字来简化事情。`Sum` 函数充当两个数字之间的中介。首先，它检查名为 `a` 的第一个数字的类型。然后，对于第一个数字的每种类型，它检查名为
    `b` 的第二个数字的类型，并返回结果类型。
- en: While the solution still looks very crazy now, the only one that knows about
    all possible numbers in the calculator is the `Sum` function. But take a closer
    look and you'll see that we have added a type case for the `int` type. We have
    cases `One`, `Two` , and `int`. Inside the `int` case, we also have another `int` case
    for the `b` number. What do we do here? If both types are of the `int` case, we
    can return the sum of them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解决方案现在看起来仍然非常疯狂，但唯一了解计算器中所有可能数字的是 `Sum` 函数。但仔细看看，你会发现我们为 `int` 类型添加了一个类型情况。我们有
    `One`、`Two` 和 `int` 的情况。在 `int` 情况内部，我们还有一个 `int` 情况用于数字 `b`。我们在这里做什么？如果两种类型都是
    `int` 情况，我们可以返回它们的和。
- en: 'Do you think that this will work? Let''s write a simple `main` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这会工作吗？让我们写一个简单的 `main` 函数：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We print the sum of type `One` and type `Two`. By using the `"%#v"` format,
    we ask to print information about the type. The second line in the function uses
    `int` types, and we also print the result. This in the console produces the following
    output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印类型 `One` 和类型 `Two` 的和。通过使用 `"%#v"` 格式，我们要求打印有关类型的详细信息。函数的第二行使用 `int` 类型，我们也打印了结果。这在控制台产生了以下输出：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Not very impressive, right? But let's think for a second. By using the Mediator
    pattern, we have been able to refactor the initial calculator, where we have to
    define every operation on every type to a Mediator pattern, the `Sum` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 并不太令人印象深刻，对吧？但让我们思考一下。通过使用中介者模式，我们已经能够重构最初的计算器，其中我们必须为每个类型定义每个操作，到中介者模式，即 `Sum`
    函数。
- en: 'The nice thing is that, thanks to the Mediator pattern, we have been able to
    start using integers as values for our calculator. We have just defined the simplest
    example by adding two integers, but we could have done the same with an integer
    and the `type`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好事是，多亏了中介者模式，我们能够开始使用整数作为计算器的值。我们只是通过添加两个整数定义了最简单的例子，但我们可以用整数和 `type` 做同样的事情：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this small modification, we can now use type `One` with an `int` as number
    `b`. If we keep working on this Mediator pattern, we could achieve a lot of flexibility
    between types, without having to implement every possible operation between them,
    generating a tight coupling.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小小的修改，我们现在可以使用类型 `One` 和 `int` 作为数字 `b`。如果我们继续在这个中介者模式上工作，我们可以在不实现它们之间所有可能的操作的情况下，实现类型之间的大量灵活性，从而避免产生紧密耦合。
- en: 'We''ll add a new `Sum` method in the main function to see this in action:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主函数中添加一个新的 `Sum` 方法来观察这个动作：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nice. The Mediator pattern is in charge of knowing about the possible types
    and returns the most convenient type for our case, which is an integer. Now we
    could keep growing this `Sum` function until we completely get rid of using the
    numeric types we have defined.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。中介者模式负责了解所有可能的类型，并返回最适合我们情况的类型，即整数。现在我们可以继续扩展这个 `Sum` 函数，直到我们完全摆脱使用我们定义的数值类型。
- en: Uncoupling two types with the Mediator
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中介者解耦两个类型
- en: We have carried out a disruptive example to try to think outside the box and
    reason deeply about the Mediator pattern. Tight coupling between entities in an
    app can become really complex to deal with in the future and allow more difficult
    refactoring if needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进行了一个颠覆性的示例，试图跳出思维定势，深入思考中介者模式。应用程序中实体的紧密耦合在未来可能会变得非常复杂，如果需要，允许更困难的重构。
- en: Just remember that the Mediator pattern is there to act as a managing type between
    two types that don't know about each other so that you can take one of the types
    without affecting the other and replace a type in a more easy and convenient way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，中介者模式的作用是在两种彼此不了解的类型之间充当管理类型，这样你就可以在不影响另一种类型的情况下替换一种类型，或者以更简单、更方便的方式替换一种类型。
- en: Observer design pattern
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: 'We will finish the common *Gang of Four* design patterns with my favorite:
    the Observer pattern, also known as publish/subscriber or publish/listener. With
    the State pattern, we defined our first event-driven architecture, but with the
    Observer pattern we will really reach a new level of abstraction.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完成常见的*四大家族*设计模式，以我最喜欢的模式——观察者模式，也称为发布/订阅或发布/监听器模式。使用状态模式，我们定义了第一个事件驱动架构，但使用观察者模式，我们将真正达到一个新的抽象层次。
- en: Description
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The idea behind the Observer pattern is simple--to subscribe to some event that
    will trigger some behavior on many subscribed types. Why is this so interesting?
    Because we uncouple an event from its possible handlers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式背后的思想很简单——订阅某些事件，这些事件将在许多订阅类型上触发某些行为。这为什么如此有趣？因为我们解耦了事件与其可能的处理器。
- en: For example, imagine a login button. We could code that when the user clicks
    the button, the button color changes, an action is executed, and a form check
    is performed in the background. But with the Observer pattern, the type that changes
    the color will subscribe to the event of the clicking of the button. The type
    that checks the form and the type that performs an action will subscribe to this
    event too.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个登录按钮。我们可以编写代码，当用户点击按钮时，按钮颜色改变，执行一个动作，并在后台执行表单检查。但使用观察者模式，改变颜色的类型将订阅按钮点击的事件。检查表单的类型和执行动作的类型也将订阅此事件。
- en: Objectives
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The Observer pattern is especially useful to achieve many actions that are
    triggered on one event. It is also especially useful when you don''t know how
    many actions are performed after an event in advance or there is a possibility
    that the number of actions is going to grow in the near future. To resume, do
    the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式特别适用于实现由一个事件触发的多个动作。它也特别适用于你事先不知道事件之后将执行多少动作，或者有可能会在不久的将来增加动作数量的可能性。总结如下：
- en: Provide an event-driven architecture where one event can trigger one or more
    actions
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个事件驱动架构，其中一个事件可以触发一个或多个动作
- en: Uncouple the actions that are performed from the event that triggers them
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦执行的动作与触发它们的动作
- en: Provide more than one event that triggers the same action
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个触发相同动作的事件
- en: The notifier
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知者
- en: We will develop the simplest possible application to fully understand the roots
    of the Observer pattern. We are going to make a `Publisher` struct, which is the
    one that triggers an event so it must accept new observers and remove them if
    necessary. When the `Publisher` struct is triggered, it must notify all its observers
    of the new event with the data associated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个尽可能简单的应用程序，以充分理解观察者模式的根源。我们将创建一个`Publisher`结构体，它是触发事件的那个，因此它必须接受新的观察者，并在必要时移除它们。当`Publisher`结构体被触发时，它必须通知所有订阅的新事件及其相关数据。
- en: Acceptance criteria
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'The requirements must tell us to have some type that triggers some method in
    one or more actions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 需求必须告诉我们有一个类型可以触发一个或多个动作：
- en: We must have a publisher with a `NotifyObservers` method that accepts a message
    as an argument and triggers a `Notify` method on every observer subscribed.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`NotifyObservers`方法的发布者，该方法接受一个消息作为参数，并在每个订阅的观察者上触发一个`Notify`方法。
- en: We must have a method to add new subscribers to the publisher.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一种方法可以向发布者添加新的订阅者。
- en: We must have a method to remove new subscribers from the publisher.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一种方法来从发布者中移除新的订阅者。
- en: Unit tests
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Maybe you have realized that our requirements defined almost exclusively the
    `Publisher` type. This is because the action performed by the observer is irrelevant
    for the Observer pattern. It should simply execute an action, in this case the
    `Notify` method, that one or many types will implement. So let''s define this
    only interface for this pattern:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经意识到，我们定义的要求几乎完全针对 `Publisher` 类型。这是因为观察者的动作对于观察者模式来说是不相关的。它应该简单地执行一个动作，在这种情况下是
    `Notify` 方法，这个动作由一个或多个类型实现。所以让我们只为这个模式定义这个接口：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Observer` interface has a `Notify` method that accepts a `string` type
    that will contain the message to spread. It does not need to return anything,
    but we could return an error if we want to check if all observers have been reached
    when calling the `publish` method of the `Publisher` structure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer` 接口有一个 `Notify` 方法，它接受一个 `string` 类型的参数，该参数将包含要传播的消息。它不需要返回任何内容，但如果我们想检查在调用
    `Publisher` 结构的 `publish` 方法时是否所有观察者都已到达，我们可以返回一个错误。'
- en: 'To test all the acceptance criteria, we just need a structure called `Publisher`
    with three methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试所有验收标准，我们只需要一个名为 `Publisher` 的结构，它有三个方法：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Publisher` structure stores the list of subscribed observers in a slice
    field called `ObserversList`. Then it has the three methods mentioned on the acceptance
    criteria-the `AddObserver` method to subscribe a new observer to the publisher,
    the `RemoveObserver` method to unsubscribe an observer, and the `NotifyObservers`
    method with a string that acts as the message we want to spread between all observers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher` 结构将订阅的观察者列表存储在一个名为 `ObserversList` 的切片字段中。然后它有在验收标准中提到的三个方法——`AddObserver`
    方法用于将新的观察者订阅到发布者，`RemoveObserver` 方法用于取消订阅观察者，以及 `NotifyObservers` 方法，该方法使用一个字符串作为我们希望在所有观察者之间传播的消息。'
- en: 'With these three methods, we have to set up a root test to configure the `Publisher`
    and three subtests to test each method. We also need to define a test type structure
    that implements the `Observer` interface. This structure is going to be called
    `TestObserver`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三种方法，我们必须设置一个根测试来配置 `Publisher` 和三个子测试来测试每个方法。我们还需要定义一个实现 `Observer` 接口的测试类型结构。这个结构将被命名为
    `TestObserver`：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `TestObserver` structure implements the Observer pattern by defining a `Notify(string)`
    method in its structure. In this case, it prints the received message together
    with its own observer ID. Then, it stores the message in its `Message` field.
    This allows us to check later if the content of the `Message` field is as expected.
    Remember that it could also be done by passing the `testing.T` pointer and the
    expected message and checking within the `TestObserver` structure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestObserver` 结构通过在其结构中定义一个 `Notify(string)` 方法来实现观察者模式。在这种情况下，它将接收到的消息与其自己的观察者
    ID 一起打印出来。然后，它将消息存储在其 `Message` 字段中。这允许我们稍后检查 `Message` 字段的内容是否如预期。记住，这也可以通过传递
    `testing.T` 指针和预期的消息，并在 `TestObserver` 结构内进行检查来实现。'
- en: 'Now we can set up the `Publisher` structure to execute the three tests. We
    will create three instances of the `TestObserver` structure:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置 `Publisher` 结构来执行三个测试。我们将创建三个 `TestObserver` 结构的实例：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have given a different ID to each observer so that we can see later that
    each of them has printed the expected message. Then, we have added the observers
    by calling the `AddObserver` method on the `Publisher` structure.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个观察者分配了不同的 ID，这样我们就可以在以后看到每个观察者都打印了预期的消息。然后，我们通过在 `Publisher` 结构上调用 `AddObserver`
    方法来添加观察者。
- en: 'Let''s write an `AddObserver` test, it must add a new observer to the `ObserversList`
    field of the `Publisher` structure:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 `AddObserver` 测试，它必须将一个新的观察者添加到 `Publisher` 结构的 `ObserversList` 字段：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We have added three observers to the `Publisher` structure, so the length of
    the slice must be 3\. If it's not 3, the test will fail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向 `Publisher` 结构添加了三个观察者，因此切片的长度必须是 3。如果不是 3，则测试将失败。
- en: 'The `RemoveObserver` test will take the observer with ID 2 and remove it from
    the list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveObserver` 测试将获取 ID 为 2 的观察者并将其从列表中移除：'
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After removing the second observer, the length of the `Publisher` structure
    must be 2 now. We also check that none of the observers left have the `ID` 2 because
    it must be removed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除第二个观察者后，`Publisher` 结构的长度现在必须是 2。我们还检查剩下的观察者中没有 ID 为 2 的，因为它必须被移除。
- en: 'The last method to test is the `Notify` method. When using the `Notify` method,
    all instances of `TestObserver` structure must change their `Message` field from
    empty to the passed message (`Hello World!` in this case). First we will check
    that all the `Message` fields are, in fact, empty before calling the `NotifyObservers`
    test:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要测试的方法是`Notify`方法。当使用`Notify`方法时，`TestObserver`结构体的所有实例都必须将它们的`Message`字段从空更改为传递的消息（在这种情况下是`Hello
    World!`）。首先，我们将在调用`NotifyObservers`测试之前检查所有`Message`字段实际上是否为空：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using a `for` statement, we are iterating over the `ObserversList` field to
    slice in the `publisher` instance. We need to make a type casting from a pointer
    to an observer, to a pointer to the `TestObserver` structure, and check that the
    casting has been done correctly. Then, we check that the `Message` field is actually
    empty.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`语句，我们正在遍历`ObserversList`字段以在`publisher`实例中切片。我们需要将观察者指针强制转换为`TestObserver`结构体的指针，并检查转换是否正确完成。然后，我们检查`Message`字段实际上是否为空。
- en: 'The next step is to create a message to send--in this case, it will be `"Hello
    World!"` and then pass this message to the `NotifyObservers` method to notify
    every observer on the list (currently observers 1 and 3 only):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建要发送的消息--在这种情况下，它将是`"Hello World!"`，然后将此消息传递给`NotifyObservers`方法以通知列表上的每个观察者（目前只有观察者1和3）：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After calling the `NotifyObservers` method, each `TestObserver` tests in the
    `ObserversList` field must have the message `"Hello World!"` stored in their `Message`
    field. Again, we use a `for` loop to iterate over every observer of the `ObserversList`
    field and we typecast each to a `TestObserver` test (remember that `TestObserver`
    structure doesn't have any field as it's an interface). We could avoid type casting
    by adding a new `Message()` method to `Observer` instance and implementing it
    in the `TestObserver` structure to return the contents of the `Message` field.
    Both methods are equally valid. Once we have type casted to a `TestObserver` method
    called `printObserver` variable as a local variable, we check that each instance
    in the `ObserversList` structure has the string `"Hello World!"` stored in their
    `Message` field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`NotifyObservers`方法之后，`ObserversList`字段中的每个`TestObserver`都必须在它们的`Message`字段中存储消息`"Hello
    World!"`。再次强调，我们使用一个`for`循环来遍历`ObserversList`字段中的每个观察者，并将每个观察者强制转换为`TestObserver`测试（记住，`TestObserver`结构体没有字段，因为它是一个接口）。我们可以通过向`Observer`实例添加一个新的`Message()`方法并在`TestObserver`结构体中实现它来返回`Message`字段的值来避免强制类型转换。这两种方法都是有效的。一旦我们将类型转换为名为`printObserver`的局部变量，我们就检查`ObserversList`结构体中的每个实例是否在它们的`Message`字段中存储了字符串`"Hello
    World!"`。
- en: 'Time to run the tests that must fail all to check their effectiveness in the
    later implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行必须全部失败的测试，以检查它们在后续实现中的有效性：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Something isn't working as expected. How is the `Notify` method passing the
    tests if we haven't implemented the function yet? Take a look at the test of the
    `Notify` method again. The test iterates over the `ObserversList` structure and
    each `F` `ail` call is inside this for loop. If the list is empty, it won't iterate,
    so it won't execute any `Fail call`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情没有按预期工作。如果我们还没有实现该函数，`Notify`方法是如何通过测试的？再次查看`Notify`方法的测试。测试遍历`ObserversList`结构，每个`Fail`调用都在这个`for`循环内部。如果列表为空，它不会遍历，因此不会执行任何`Fail`调用。
- en: 'Let''s fix this issue by adding a small non-empty list check at the beginning
    of the `Notify` test:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Notify`测试的开始处添加一个小的不为空列表检查来解决这个问题：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And we will rerun the tests to see if the `TestSubject/Notify` method is already
    failing:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新运行测试，以查看`TestSubject/Notify`方法是否已经失败：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Nice, all of them are failing and now we have some guarantee on our tests. We
    can proceed to the implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它们全部都失败了，现在我们对测试有了一些保证。我们可以继续实现。
- en: Implementation
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Our implementation is just to define the `AddObserver`, the `RemoveObserver`,
    and the `NotifyObservers` methods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现只是定义了`AddObserver`、`RemoveObserver`和`NotifyObservers`方法：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `AddObserver` method adds the `Observer` instance to the `ObserversList`
    structure by appending the pointer to the current list of pointers. This one was
    very easy. The `AddObserver` test must be passing now (but not the rest or we
    could have done something wrong):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddObserver`方法通过将指针附加到当前指针列表来将`Observer`实例添加到`ObserversList`结构体中。这个操作非常简单。现在`AddObserver`测试应该通过（但其他测试没有通过，我们可能做错了什么）：'
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Excellent. Just the `AddObserver` method has passed the test, so we can now
    continue to the `RemoveObserver` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。仅仅是`AddObserver`方法通过了测试，所以我们现在可以继续到`RemoveObserver`方法：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `RemoveObserver` method will iterate for each element in the `ObserversList`
    structure, comparing the `Observer` object''s `o` variable with the ones stored
    in the list. If it finds a match, it saves the index  in the local variable, `indexToRemove`,
    and stops the iteration. The way to remove indexes on a slice in Go is a bit tricky:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveObserver` 方法将遍历 `ObserversList` 结构中的每个元素，比较 `Observer` 对象的 `o` 变量与列表中存储的变量。如果找到匹配项，它将索引保存在局部变量
    `indexToRemove` 中，并停止迭代。在 Go 中在切片上删除索引的方式有点棘手：'
- en: First, we need to use slice indexing to return a new slice containing every
    object from the beginning of the slice to the index we want to remove (not included).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用切片索引来返回一个新的切片，包含从切片开始到要删除的索引（不包括）之间的每个对象。
- en: Then, we get another slice from the index we want to remove (not included) to
    the last object in the slice
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从要删除的索引（不包括）到最后一个对象获取另一个切片。
- en: Finally, we join the previous two new slices into a new one (the `append` function)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将前两个新切片连接到一个新的切片中（即 `append` 函数）
- en: For example, in a list from 1 to 10 in which we want to remove the number 5,
    we have to create a new slice, joining a slice from 1 to 4 and a slice from 6
    to 10.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个从 1 到 10 的列表中，我们想要删除数字 5，我们必须创建一个新的切片，将一个从 1 到 4 的切片和一个从 6 到 10 的切片连接起来。
- en: This index removal is done with the `append` function again because we are actually
    appending two lists together. Just take a closer look at the three dots at the
    end of the second argument of the `append` function. The `append` function adds
    an element (the second argument) to a slice (the first), but we want to append
    an entire list. This can be achieved using the three dots, which translate to
    something like *keep adding elements until you finish the second array*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个索引删除操作再次使用 `append` 函数完成，因为我们实际上是在将两个列表连接起来。只需仔细看看 `append` 函数第二个参数末尾的三个点。`append`
    函数将一个元素（第二个参数）添加到一个切片（第一个参数）中，但我们要添加一个整个列表。这可以通过使用三个点来实现，这相当于 *继续添加元素，直到完成第二个数组*。
- en: 'Ok, let''s run this test now:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们运行这个测试：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We continue in the good path. The `RemoveObserver` test has been fixed without
    fixing anything else. Now we have to finish our implementation by defining the
    `NotifyObservers` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续沿着正确的道路前进。`RemoveObserver` 测试已经修复，而没有修复其他任何内容。现在我们必须通过定义 `NotifyObservers`
    方法来完成我们的实现：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `NotifyObservers` method is quite simple because it prints a message to
    the console to announce that a particular message is going to be passed to the
    `Observers`. After this, we use a for loop to iterate over `ObserversList` structure
    and execute each `Notify(string)` method by passing the argument `m`. After executing
    this, all observers must have the message `Hello World!` stored in their `Message`
    field. Let''s see if this is true by running the tests:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyObservers` 方法相当简单，因为它向控制台打印一条消息，宣布要将特定消息传递给 `Observers`。之后，我们使用一个 for
    循环遍历 `ObserversList` 结构，并通过传递参数 `m` 执行每个 `Notify(string)` 方法。执行此操作后，所有观察者必须在他们的
    `Message` 字段中存储消息 `Hello World!`。让我们通过运行测试来验证这一点：'
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Excellent! We can also see the outputs of the `Publisher` and `Observer` types
    on the console. The `Publisher` structure prints the following message:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们还可以在控制台上看到 `Publisher` 和 `Observer` 类型的输出。`Publisher` 结构打印以下消息：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After this, all observers print their respective messages as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，所有观察者将按照以下方式打印各自的消息：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And the same for the third observer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第三位观察者也是如此。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We have unlocked the power of event-driven architectures with the State pattern
    and the Observer pattern. Now you can really execute asynchronous algorithms and
    operations in your application that respond to events in your system.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过状态模式和观察者模式解锁了事件驱动架构的力量。现在你可以在你的应用程序中真正执行异步算法和操作，这些算法和操作响应你系统中的事件。
- en: The Observer pattern is commonly used in UI's. Android programming is filled
    with Observer patterns so that the Android SDK can delegate the actions to be
    performed by the programmers creating an app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式在 UI 中被广泛使用。Android 编程充满了观察者模式，这样 Android SDK 就可以将程序员创建应用程序时要执行的操作委托给它们。
