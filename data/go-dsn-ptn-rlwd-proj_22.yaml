- en: Chapter 8. Introduction to Gos Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。Go并发简介
- en: We have just finished with the *Gang Of Four* design patterns that are commonly
    used in object oriented programming languages. They have been used extensively
    for the last few decades (even before they were explicitly defined in a book).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了在面向对象编程语言中常用到的**四人帮**设计模式。这些模式在过去几十年里被广泛使用（甚至在它们在书中被明确定义之前）。
- en: In this chapter, we are going to see concurrency in the Go language. We will,
    learn that with multiple cores and multiple processes, applications can help us
    to achieve better performance and endless possibilities. We will look at how to
    use some of the already known patterns in concurrently safe ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Go语言中的并发。我们将了解到，通过多个核心和多个进程，应用程序可以帮助我们实现更好的性能和无限的可能性。我们将探讨如何以并发安全的方式使用一些已知模式。
- en: A little bit of history and theory
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史和理论
- en: When we talk about Go's concurrency, it's impossible not to talk about history.
    In the last decades, we saw an improvement in the speed of CPUs until we reached
    the hardware limits imposed by current hardware materials, design, and architectures.
    When we reached this point, we started to play with the first multicore computers,
    the first double CPU motherboards, and then single CPUs with more than one core
    in their heart.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Go的并发时，不可避免地要谈到历史。在过去的几十年里，我们看到了CPU速度的提高，直到我们达到了由当前硬件材料、设计和架构强加的硬件限制。当我们达到这一点时，我们开始玩多核计算机，首先是双CPU主板，然后是具有一个以上核心的单核CPU。
- en: Unfortunately, the languages we are using are still the ones created when we
    had single core CPUs, such as Java or C++. While being terrific systems languages,
    they lack a proper concurrency support by design. You can develop concurrent apps
    in both of the languages used in your project by using third party tools or by
    developing your own (not a very easy task).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们使用的语言仍然是我们在单核CPU时代创建的，如Java或C++。虽然它们是出色的系统语言，但它们在设计上缺乏适当的并发支持。你可以在项目中使用的两种语言中通过使用第三方工具或开发自己的（这不是一件容易的任务）来开发并发应用程序。
- en: Go's concurrency was designed with these caveats in mind. The creators wanted
    garbage collected and procedural language that is familiar for newcomers, but
    which, at the same time, can be used to write concurrent applications easily and
    without affecting the core of the language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go的并发设计时考虑到了这些注意事项。创造者希望有一个垃圾回收和过程式语言，这对新手来说很熟悉，但同时又可以轻松地编写并发应用程序，而不会影响语言的内核。
- en: We have experienced this in the early chapters. We have developed more than
    20 design patterns without a word about concurrency. This clearly shows that the
    concurrent features of the Go language are completely separated from the core
    language while being part of it, a perfect example of abstraction and encapsulation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期章节中已经体验到了这一点。我们开发了20多个设计模式，而没有提及并发。这清楚地表明，Go语言的并发特性完全独立于核心语言，同时又是其一部分，这是抽象和封装的完美例子。
- en: There are many concurrency models in computer science, the most famous being
    the actor model present in languages such as **Erlang** or **Scala**. Go, on the
    other side, uses **Communicating Sequential Processes** (**CSP**), which has a
    different approach to concurrency.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中有许多并发模型，其中最著名的是存在于**Erlang**或**Scala**等语言中的actor模型。另一方面，Go使用**通信顺序进程**（**CSP**），它对并发有不同方法。
- en: Concurrency versus parallelism
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与并行
- en: 'Many people have misunderstood the differences between both, even thinking
    that they are the same. There is a popular speech by Rob Pike, one of the creators
    of Go, *Concurrency is not parallelism*, which I really agree with. As a quick
    summary of the talk, we can extract the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人误解了两者之间的区别，甚至认为它们是相同的。Go的创造者之一Rob Pike有一句流行的话，“并发不是并行”，我非常赞同。作为对这次谈话的简要总结，我们可以提取以下内容：
- en: Concurrency is about dealing with many things at once
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发是关于同时处理很多事情。
- en: Parallelism is about doing many things at the same time
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行性是关于同时做很多事情。
- en: Concurrency enables parallelism by designing a correct structure of concurrency
    work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 并发通过设计正确的并发工作结构来启用并行性。
- en: For example, we can think of the mechanism of a bike. When we pedal, we usually
    push down the pedal to produce force (and this push, raises our opposite leg on
    the opposite pedal). We cannot push with both legs at the same time because the
    cranks don't allow us to do it. But this design allows the construction of a parallel
    bike, commonly called a **tandem bike**. A tandem bike is a bike that two people
    can ride at the same time; they both pedal and apply force to the bike.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以思考自行车的机制。当我们踩踏板时，我们通常向下推踏板以产生力量（并且这种推力，也会抬起我们另一只脚对应的踏板）。我们不能同时用两只脚推，因为曲柄不允许我们这样做。但这个设计允许构建一种并行自行车，通常称为**双人自行车**。双人自行车是一种两个人可以同时骑行的自行车；他们两人都踩踏板并给自行车施加力量。
- en: In the bike example, concurrency is the design of a bike that, with two legs
    (Goroutines), you can produce power to move the bike by yourself. The design is
    concurrent and correct. If we use a tandem bike and two people (two cores), the
    solution is concurrent, correct, and parallel. But the key thing is that with
    a concurrent design, we don't have to worry about parallelism; we can think about
    it as an extra feature if our concurrent design is correct. In fact, we can use
    the tandem bike with only one person, but the concurrent design of the legs, pedals,
    chain, wheels of a bike is still correct.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在自行车示例中，并发是自行车的结构设计，通过两条腿（Goroutines），你可以自己产生力量来推动自行车。这个设计是并发的且是正确的。如果我们使用双人自行车和两个人（两个核心），解决方案是并发的、正确的，并且是并行的。但关键在于，在并发设计中，我们不必担心并行性；如果我们并发设计正确，我们可以将其视为一个额外功能。实际上，我们可以用一个人使用双人自行车，但自行车的腿、踏板、链条、轮子的并发设计仍然是正确的。
- en: '![Concurrency versus parallelism](img/00035.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![并发与并行](img/00035.jpeg)'
- en: With concurrency, on the left side, we have a design and a structure that is
    executed sequentially by the same CPU core. Once we have this design and structure,
    parallelism can be achieved by simply repeating this structure on a different
    thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发方面，在左侧，我们有一个由同一 CPU 核心顺序执行的设计和结构。一旦我们有了这个设计和结构，通过简单地在不同线程上重复这个结构，就可以实现并行性。
- en: This is how Go eases the reasoning about concurrent and parallel programs by
    simply not worrying too much about parallel execution and focusing much more on
    concurrent design and structure. Breaking a big task into smaller tasks that can
    be run concurrently usually provides much better performance in a single-core
    computer, but, if this design can also be run in parallel, we could achieve an
    even higher throughput (or not, depending on the design).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Go 通过简单地不过多担心并行执行，而更多地关注并发设计和结构，来简化对并发和并行程序推理的方法。将大任务分解成可以并行运行的小任务，通常在单核计算机上提供更好的性能，但如果这种设计也可以并行运行，我们就可以实现更高的吞吐量（或者不能，这取决于设计）。
- en: In fact, we can set the number of cores in use in a Go app by setting the environment
    variable `GOMAXPROCS` to the number of cores we want. This is not only useful
    when using schedulers, such as **Apache Mesos**, but it gives us more control
    about how a Go app works and performs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以在 Go 应用程序中通过设置环境变量 `GOMAXPROCS` 为我们想要的核数来设置使用的核心数。这不仅在使用调度器，如**Apache
    Mesos**时很有用，而且它让我们对 Go 应用程序的工作方式和性能有了更多的控制。
- en: So, to recap, it is very important to keep in mind that concurrency is about
    structure and parallelism is about execution. We must think about making our programs
    concurrent in a better way, by breaking them down into smaller pieces of work,
    and Go's scheduler will try to make them parallel if it's possible and allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，我们必须牢记，并发是关于结构，而并行是关于执行。我们必须考虑以更好的方式使我们的程序并发，通过将它们分解成更小的任务块，Go 的调度器将尝试在可能和允许的情况下使它们并行。
- en: CSP versus actor-based concurrency
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSP 与基于演员的并发
- en: The most common and, perhaps, intuitive way to think about concurrency is close
    to the way the actor model works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑并发的最常见和可能最直观的方式几乎与演员模型的工作方式相似。
- en: '![CSP versus actor-based concurrency](img/00036.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![CSP 与基于演员的并发](img/00036.jpeg)'
- en: In the actor model, if **Actor 1** wants to communicate with **Actor 2**, then
    **Actor 1** must know **Actor 2** first; for example, it must have its process
    ID, maybe from the creation step, and put a message on its inbox queue. After
    placing the message, **Actor 1** can continue its tasks without getting blocked
    if **Actor 2** cannot process the message immediately.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在actor模型中，如果**Actor 1**想要与**Actor 2**通信，那么**Actor 1**必须首先知道**Actor 2**；例如，它必须知道它的进程ID，可能来自创建步骤，并将消息放在它的收件箱队列中。放置消息后，如果**Actor
    2**不能立即处理消息，**Actor 1**可以继续其任务而不会阻塞。
- en: 'CSP, on the other side, introduces a new entity into the equation-channels.
    Channels are the way to communicate between processes because they are completely
    anonymous (unlike actors, where we need to know their process IDs). In the case
    of CSP, we don''t have a process ID to use to communicate. Instead, we have to
    create a channel to the processes to allow incoming and outgoing communication.
    In this case, what we know that the receiver is the channel it uses to receive
    data:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一方面，CSP引入了方程中的新实体——通道。通道是进程间通信的方式，因为它们是完全匿名的（与actor不同，我们需要知道它们的进程ID）。在CSP的情况下，我们没有进程ID来用于通信。相反，我们必须为进程创建一个通道，以允许传入和传出通信。在这种情况下，我们知道接收者是它用来接收数据的通道：
- en: '![CSP versus actor-based concurrency](img/00037.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![CSP与基于actor的并发对比](img/00037.jpeg)'
- en: In this diagram, we can see that the processes are anonymous, but we have a
    channel with ID 1, that is, **Channel 1**, which connects them together. This
    abstraction does not tell us how many processes are on each side of the channel;
    it simply connects them and allows communication between processes by using the
    channel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到进程是匿名的，但我们有一个ID为1的通道，即**通道1**，它将它们连接在一起。这种抽象并没有告诉我们通道两边的进程数量；它只是将它们连接起来，并允许通过通道进行进程间的通信。
- en: The key here is that channels isolate both extremes so that process A can send
    data through a channel that will be handled by potentially one or more processes
    that' are transparent to A. It also works the same in reverse; process B can receive
    data from many channels one at a time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于通道隔离了两个极端，使得进程A可以通过一个通道发送数据，这个通道将由一个或多个对A透明的进程处理。反之亦然；进程B可以逐个接收来自多个通道的数据。
- en: Goroutines
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: In Go, we achieve concurrency by working with Goroutines. They are like processes
    that run applications in a computer concurrently; in fact, the main loop of Go
    could be considered a Goroutine, too. Goroutines are used in places where we would
    use actors. They execute some logic and die (or keep looping if necessary).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们通过使用Goroutines来实现并发。它们就像在计算机上并发运行应用程序的进程；实际上，Go的主循环也可以被认为是Goroutine。Goroutines用于我们本应使用actor的地方。它们执行一些逻辑然后死亡（或如果需要则继续循环）。
- en: But Goroutines are not threads. We can launch thousands of concurrent Goroutines,
    even millions. They are incredibly cheap, with a small growth stack. We will use
    Goroutines to execute code that we want to work concurrently. For example, three
    calls to three services to compose a response can be designed concurrently with
    three Goroutines to do the service calls potentially in parallel and a fourth
    Goroutine to receive them and compose the response. What's the point here? That
    if we have a computer with four cores, we could potentially run this service call
    in parallel, but if we use a one-core computer, the design will still be correct
    and the calls will be executed concurrently in only one core. By designing concurrent
    applications, we don't need to worry about parallel execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但Goroutines不是线程。我们可以启动成千上万的并发Goroutines，甚至数百万。它们非常便宜，具有较小的增长堆栈。我们将使用Goroutines来执行我们想要并发工作的代码。例如，对三个服务的三个调用可以设计成三个Goroutines并发执行服务调用，以及一个第四个Goroutine来接收它们并组合响应。这里的要点是什么？如果我们有一台具有四个核心的计算机，我们可以在理论上并行运行这个服务调用，但如果我们使用单核计算机，设计仍然正确，调用将在单个核心中并发执行。通过设计并发应用程序，我们不需要担心并行执行。
- en: Returning to the bike analogy, we were pushing the pedals of the bike with our
    two legs. That's two Goroutines concurrently pushing the pedals. When we use the
    tandem, we had a total of four Goroutines, possibly working in parallel. But we
    also have two hands to handle the front and rear brakes. That's a total of eight
    Goroutines for our two threads bike. Actually, we don't pedal when we brake and
    we don't brake when we pedal; that's a correct concurrent design. Our nervous
    system transports the information about when to stop pedaling and when to start
    braking. In Go, our nervous system is composed of channels; we will see them after
    playing a bit with Goroutines first.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回到自行车的比喻，我们用两条腿推动自行车的踏板。这是两个 Goroutine 同时推动踏板。当我们使用双人自行车时，我们总共有四个 Goroutine，可能并行工作。但我们还有两只手来处理前后刹车。对于我们的双线程自行车，总共有八个
    Goroutine。实际上，我们在刹车时不会踩踏板，我们在踩踏板时不会刹车；这是一个正确的并发设计。我们的神经系统传递关于何时停止踩踏板和何时开始刹车的信息。在
    Go 中，我们的神经系统由通道组成；我们将在玩了一会儿 Goroutine 之后看到它们。
- en: Our first Goroutine
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个 Goroutine
- en: 'Enough of the explanations now. Let''s get our hands dirty. For our first Goroutine,
    we will print the message `Hello World!` in a Goroutine. Let''s start with what
    we''ve been doing up until now:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经解释得够多了。让我们动手实践一下。对于我们的第一个 Goroutine，我们将在一个 Goroutine 中打印消息 `Hello World!`。让我们从到目前为止我们所做的一切开始：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Not impressive at all. To run it in a new Goroutine, we just need to add the
    keyword `go` at the beginning of the call to the function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不令人印象深刻。要在一个新的 Goroutine 中运行它，我们只需要在函数调用的开头添加关键字 `go`：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this simple word, we are telling Go to start a new Goroutine running the
    contents of the `helloWorld` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个简单的词，我们告诉 Go 启动一个新的 Goroutine，运行 `helloWorld` 函数的内容。
- en: 'So, let''s run it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们运行它：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What? It printed nothing! Why is that? Things get complicated when you start
    to deal with concurrent applications. The problem is that the `main` function
    finishes before the `helloWorld` function gets executed. Let's analyse it step
    by step. The `main` function starts and schedules a new Goroutine that will execute
    the `helloWorld` function, but the function isn't executed when the function finishes--it
    is still in the scheduling process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？它什么都没打印出来！为什么？当你开始处理并发应用程序时，事情会变得复杂。问题是 `main` 函数在 `helloWorld` 函数执行之前就结束了。让我们一步一步地分析。`main`
    函数开始并安排一个新的 Goroutine 来执行 `helloWorld` 函数，但函数在结束时并没有执行——它仍然处于调度过程中。
- en: 'So, our `main` problem is that the `main` function has to wait for the Goroutine
    to be executed before finishing. So let''s pause for a second to give some room
    to the Goroutine:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的 `main` 问题在于 `main` 函数必须在完成之前等待 Goroutine 执行。所以让我们暂停一下，给 Goroutine 一些空间：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `time.Sleep` function effectively sleeps the main Goroutine for one second
    before continuing (and exiting). If we run this now, we must get the message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep` 函数有效地让主 Goroutine 睡眠一秒钟，然后再继续（并退出）。如果我们现在运行这个程序，我们必须得到以下消息：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I suppose you must have noticed by now the small gap of time where the program
    is freezing before finishing. This is the function for sleeping. If you are doing
    a lot of tasks, you might want to raise the waiting time to whatever you want.
    Just remember that in any application the `main` function cannot finish before
    the rest of the Goroutines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你现在一定注意到了程序在完成前短暂冻结的小间隙。这是睡眠函数。如果你要做很多任务，你可能想将等待时间提高到你想的任何长度。只需记住，在任何应用程序中，`main`
    函数不能在其余的 Goroutine 执行之前结束。
- en: Anonymous functions launched as new Goroutines
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为新 Goroutine 启动的匿名函数
- en: 'We have defined the `helloWorld` function so that it can be launched with a
    different Goroutine. This is not strictly necessary because you can launch snippets
    of code directly in the function''s scope:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `helloWorld` 函数，以便它可以由不同的 Goroutine 启动。这并不是严格必要的，因为你可以直接在函数的作用域内启动代码片段：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is also valid. We have used an anonymous function and we have launched
    it in a new Goroutine using the `go` keyword. Take a closer look at the closing
    braces of the function-they are followed by opening and closing parenthesis, indicating
    the execution of the function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的。我们使用了一个匿名函数，并且使用 `go` 关键字在新的 Goroutine 中启动了它。仔细看看函数的闭合括号——它们后面跟着一个开括号和一个闭括号，这表明函数的执行。
- en: 'We can also pass data to anonymous functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将数据传递给匿名函数：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is also valid. We had defined an anonymous function that received a string,
    which then printed the received string. When we called the function in a different
    Goroutine, we passed the message we wanted to print. In this sense, the following
    example would also be valid:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的。我们定义了一个匿名函数，它接收一个字符串，然后打印接收到的字符串。当我们在一个不同的 Goroutine 中调用该函数时，我们传递了想要打印的消息。从这个意义上说，以下示例也是有效的：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, we have defined a function within the scope of our `main` function
    and stored it in a variable called `messagePrinter`. Now we can concurrently print
    as many messages as we want by using the `messagePrinter(string)` signature:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在 `main` 函数的作用域内定义了一个函数，并将其存储在一个名为 `messagePrinter` 的变量中。现在我们可以通过使用
    `messagePrinter(string)` 签名并发地打印我们想要的任意数量的消息：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have just scratched the surface of concurrent programming in Go, but we can
    already see that it can be quite powerful. But we definitely have to do something
    with that sleeping period. WaitGroups can help us with this problem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚触及了 Go 中并发编程的表面，但我们已经可以看到它可以非常强大。但我们肯定必须做些什么来处理那个睡眠期。WaitGroups 可以帮助我们解决这个问题。
- en: WaitGroups
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WaitGroups
- en: 'WaitGroup comes in the synchronization package (the `sync` package) to help
    us synchronize many concurrent Goroutines. It works very easily--every time we
    have to wait for one Goroutine to finish, we add `1` to the group, and once all
    of them are added, we ask the group to wait. When the Goroutine finishes, it says
    `Done` and the WaitGroup will take one from the group:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: WaitGroup 属于同步包（`sync` 包），它帮助我们同步多个并发 Goroutine。它工作起来非常简单——每次我们不得不等待一个 Goroutine
    完成，我们就向组中添加 `1`，一旦所有这些都被添加，我们就要求组等待。当 Goroutine 完成时，它会说 `Done`，WaitGroup 将从组中减去一个：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the simplest possible example of a WaitGroup. First, we created a variable
    to hold it called the `wait` variable. Next, before launching the new Goroutine,
    we say to the WaitGroup `hey, you'll have to wait for one thing to finish` by
    using the `wait.Add(1)` method. Now we can launch the `1` that the WaitGroup has
    to wait for, which in this case is the previous Goroutine that prints `Hello World`
    and says `Done` (by using the `wait.Done()` method) at the end of the Goroutine.
    Finally, we indicate to the WaitGroup to wait. We have to remember that the function
    `wait.Wait()` was probably executed before the Goroutine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 WaitGroup 的最简单示例。首先，我们创建了一个变量来持有它，称为 `wait` 变量。然后，在启动新的 Goroutine 之前，我们通过使用
    `wait.Add(1)` 方法告诉 WaitGroup “嘿，你将不得不等待某件事情完成”。现在我们可以启动 WaitGroup 必须等待的那个 `1`，在这个例子中是打印
    `Hello World` 并在 Goroutine 结束时说 `Done`（通过使用 `wait.Done()` 方法）的之前的 Goroutine。最后，我们向
    WaitGroup 表明它需要等待。我们必须记住，函数 `wait.Wait()` 可能是在 Goroutine 之前执行的。
- en: 'Let''s run the code again:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行代码：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now it just waits the necessary time and not one millisecond more before exiting
    the application. Remember that when we use the `Add(value)` method, we add entities
    to the WaitGroup, and when we use the `Done()` method, we subtract one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它只等待必要的时长，而不是多一毫秒就退出应用程序。记住，当我们使用 `Add(value)` 方法时，我们向 WaitGroup 添加实体，当我们使用
    `Done()` 方法时，我们减去一个。
- en: 'Actually, the `Add` function takes a delta value, so the following code is
    equivalent to the previous:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Add` 函数接受一个增量值，所以以下代码与之前的代码等价：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, we added `1` before launching the Goroutine and we added `-1`
    (subtracted 1) at the end of it. If we know in advance how many Goroutines we
    are going to launch, we can also call the `Add` method just once:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在启动 Goroutine 之前添加了 `1`，并在其末尾添加了 `-1`（减去 1）。如果我们事先知道将要启动多少个 Goroutine，我们也可以只调用一次
    `Add` 方法：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we are going to create five Goroutines (as stated in the `goroutines`
    variable). We know it in advance, so we simply add them all to the WaitGroup.
    We are then going to launch the same amount of `goroutine` variables by using
    a `for` loop. Every time one Goroutine finishes, it calls the `Done()` method
    of the WaitGroup that is effectively waiting at the end of the main loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建五个 Goroutine（如 `goroutines` 变量所述）。我们事先知道这一点，所以我们只需将它们全部添加到 WaitGroup
    中。然后我们将使用 `for` 循环启动相同数量的 `goroutine` 变量。每次一个 Goroutine 完成，它都会调用 WaitGroup 的 `Done()`
    方法，该 WaitGroup 实际上是在主循环的末尾等待。
- en: 'Again, in this case, the code reaches the end of the `main` function before
    all Goroutines are launched (if any), and the WaitGroup makes the execution of
    the main flow wait until all `Done` messages are called. Let''s run this small
    program:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在这种情况下，代码在所有 Goroutine（如果有）启动之前就已经到达了 `main` 函数的末尾，WaitGroup 使得主流程的执行等待直到所有
    `Done` 消息都被调用。让我们运行这个小程序：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We haven''t mentioned it before, but we have passed the iteration index to
    each Goroutine as the parameter `GoroutineID` to print it with the message `Hello
    goroutines!` You might also have noticed that the Goroutines aren''t executed
    in order. Of course! We are dealing with a scheduler that doesn''t guarantee the
    order of execution of the Goroutines. This is something to keep in mind when programming
    concurrent applications. In fact, if we execute it again, we won''t necessarily
    get the same order of output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有提到过，但我们已经将迭代索引作为参数`GoroutineID`传递给每个Goroutine，以便用消息`Hello goroutines!`打印它。您可能也注意到了Goroutines不是按顺序执行的。当然！我们正在处理一个不保证Goroutine执行顺序的调度器。这是在编写并发应用程序时需要注意的事情。实际上，如果我们再次执行它，我们不一定能得到相同的输出顺序：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Callbacks
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Now that we know how to use WaitGroups, we can also introduce the concept of
    callbacks. If you have ever worked with languages like JavaScript that use them
    extensively, this section will be familiar to you. A callback is an anonymous
    function that will be executed within the context of a different function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用WaitGroups，我们也可以引入回调的概念。如果您曾经使用过像JavaScript这样的语言，这些语言广泛使用回调，那么这一节对您来说将是熟悉的。回调是一个匿名函数，它将在另一个函数的上下文中执行。
- en: 'For example, we want to write a function to convert a string to uppercase,
    as well as making it asynchronous. How do we write this function so that we can
    work with callbacks? There''s a little trick-we can have have a function that
    takes a string and returns a string:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要编写一个函数将字符串转换为大写，同时使其异步。我们如何编写这个函数以便我们可以使用回调？有一个小技巧——我们可以有一个函数，它接受一个字符串并返回一个字符串：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So take the returning type of this function (a string) and put it as the second
    parameter in an anonymous function, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将这个函数的返回类型（一个字符串）作为匿名函数的第二个参数，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, the `toUpperSync` function returns nothing, but also takes a function that,
    by coincidence, also takes a string. We can execute this function with the result
    we will usually return.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`toUpperSync`函数不返回任何内容，但它也接受一个函数，巧合的是，它也接受一个字符串。我们可以使用我们将通常返回的结果来执行这个函数。
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We execute the `f` function with the result of calling the `strings.ToUpper`
    method with the provided word (which returns the word `parameter` in uppercase).
    Let''s write the `main` function too:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用调用`strings.ToUpper`方法的结果（它返回大写单词`parameter`）来执行`f`函数。让我们也写一下`main`函数：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our main code, we have defined our callback. As you can see, we passed the
    test `Hello Callbacks!` to convert it to uppercase. Next we pass the callback
    to be executed with the result of passing our string to uppercase. In this case,
    we simply print the text in the console with the text `Callback` in front of it.
    When we execute this code, we get the following result:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主代码中，我们定义了我们的回调。如您所见，我们将测试`Hello Callbacks!`传递给它以将其转换为大写。接下来，我们传递回调以执行，我们将字符串传递给大写的结果。在这种情况下，我们只是在控制台前加上文本`Callback`来打印文本。当我们执行这段代码时，我们得到以下结果：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Strictly speaking, this is a synchronous callback. To make it asynchronous
    we have to introduce some concurrent handling:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这是一个同步回调。要使其异步，我们必须引入一些并发处理：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the same code executed asynchronously. We use WaitGroups to handle
    concurrency (we will see later that channels can also be used for this). Now,
    our function `toUpperAsync` is, as its name implies, asynchronous. We launched
    the callback in a different Goroutine by using the keyword `go` when calling the
    callback. We write a small message to show the ordering nature of the concurrent
    execution more precisely. We wait until the callback signals that it''s finished
    and we can exit the program safely. When we execute this, we get the following
    result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是以异步方式执行的。我们使用WaitGroups来处理并发（我们稍后会看到通道也可以用于此）。现在，我们的函数`toUpperAsync`正如其名所示，是异步的。我们在调用回调时使用关键字`go`在另一个Goroutine中启动了回调。我们写了一条小消息来更精确地显示并发执行中的顺序性。我们等待回调信号表示已完成，然后我们可以安全地退出程序。当我们执行这段代码时，我们得到以下结果：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the program reaches the end of the `main` function before executing
    the callback in the `toUpperAsync` function. This pattern brings many possibilities,
    but leaves us open to one big problem called callback hell.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序在执行`toUpperAsync`函数中的回调之前就到达了`main`函数的末尾。这种模式带来了许多可能性，但让我们面临一个称为回调地狱的大问题。
- en: Callback hell
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调地狱
- en: 'The term **callback hell** is commonly used to refer to when many callbacks
    have been stacked within each other. This makes them difficult to reason with
    and handle when they grow too much. For example, using the same code as before,
    we could stack another asynchronous call with the contents that we previously
    printed to the console:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **回调地狱** 通常用来指代当许多回调层层嵌套在一起时的情况。这使得它们在增长过多时难以推理和处理。例如，使用之前相同的代码，我们可以将另一个异步调用与之前打印到控制台的内容堆叠起来：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '(We have omitted imports, the package name, and the `toUpperAsync` function
    as they have not changed.) Now we have the `toUpperAsync` function within a `toUpperAsync`
    function, and we could embed many more if we want. In this case, we again pass
    the text that we previously printed on the console to use it in the following
    callback. The inner callback finally prints it on the console, giving the following
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: （我们省略了导入、包名和 `toUpperAsync` 函数，因为它们没有变化。）现在我们有一个 `toUpperAsync` 函数在另一个 `toUpperAsync`
    函数内部，如果我们想的话，可以嵌入更多。在这种情况下，我们再次传递之前打印到控制台上的文本，以便在下一个回调中使用。内部回调最终将其打印到控制台，得到以下输出：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we can assume that the outer callback will be executed before
    the inner one. That's why we don't need to add one more to the WaitGroup.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以假设外部回调将在内部回调之前执行。这就是为什么我们不需要向 WaitGroup 添加另一个的原因。
- en: The point here is that we must be careful when using callbacks. In very complex
    systems, too many callbacks are hard to reason with and hard to deal with. But
    with care and rationality, they are powerful tools.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，在使用回调时我们必须小心。在非常复杂的系统中，太多的回调难以推理和处理。但是，只要小心和理性，它们是强大的工具。
- en: Mutexes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: If you are working with concurrent applications, you have to deal with more
    than one resource potentially accessing some memory location. This is usually
    called **race condition**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理并发应用程序，你必须处理多个资源可能访问某些内存位置的情况。这通常被称为 **竞态条件**。
- en: In simpler terms, a race condition is similar to that moment where two people
    try to get the last piece of pizza at exactly the same time--their hands collide.
    Replace the pizza with a variable and their hands with Goroutines and we'll have
    a perfect analogy.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，竞态条件类似于两个人试图同时拿到最后一片披萨的那一刻——他们的手撞在一起。将披萨替换为一个变量，将他们的手替换为 Goroutines，我们就会有一个完美的类比。
- en: There is one character at the dinner table to solve this issues--a father or
    mother. They have kept the pizza on a different table and we have to ask for permission
    to stand up before getting our slice of pizza. It doesn't matter if all the kids
    ask at the same time--they will only allow one kid to stand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 桌上有一个角色可以解决这个问题——父亲或母亲。他们将披萨放在另一张桌子上，我们必须在拿到披萨片之前请求许可。无论所有孩子是否同时请求——他们只会允许一个孩子站起来。
- en: Well, a mutex is like our parents. They'll control who can access the pizza--I
    mean, a variable--and they won't allow anyone else to access it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，互斥锁就像我们的父母一样。他们会控制谁可以访问披萨——我的意思是，一个变量——并且不允许其他人访问它。
- en: To use a mutex, we have to actively lock it; if it's already locked (another
    Goroutine is using it), we'll have to wait until it's unlocked again. Once we
    get access to the mutex, we can lock it again, do whatever modifications are needed,
    and unlock it again. We'll look at this using an example.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用互斥锁（mutex），我们必须主动锁定它；如果它已经被锁定（另一个 Goroutine 正在使用它），我们就必须等待它再次解锁。一旦我们获得对互斥锁的访问权限，我们可以再次锁定它，进行所需的任何修改，然后再次解锁。我们将通过一个示例来查看这一点。
- en: An example with mutexes - concurrent counter
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用互斥锁的示例 - 并发计数器
- en: Mutexes are widely used in concurrent programming. Maybe not so much in Go because
    it has a more idiomatic way of concurrent programming in its use of channels,
    but it's worth seeing how they work for the situations where channels simply don't
    fit so well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁在并发编程中被广泛使用。也许在 Go 中不是那么多，因为 Go 在使用通道进行并发编程时有一个更符合语法的编程方式，但了解它们是如何工作的对于通道不适合的情况是很有价值的。
- en: For our example, we are going to develop a small concurrent counter. This counter
    will add one to an integer field in a `Counter` type. This should be done in a
    concurrent-safe way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将开发一个小型的并发计数器。这个计数器将向 `Counter` 类型的整数字段加一。这应该以并发安全的方式进行。
- en: 'Our `Counter` structure is defined like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Counter` 结构定义如下：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Counter` structure has a field of `int` type that stores the current value
    of the count. It also embeds the `Mutex` type from the `sync` package. Embedding
    this field will allow us to lock and unlock the entire structure without actively
    calling a specific field.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`结构有一个`int`类型的字段，用于存储计数的当前值。它还嵌入了`sync`包中的`Mutex`类型。嵌入这个字段将允许我们在不主动调用特定字段的情况下锁定和解锁整个结构。'
- en: 'Our `main` function launches 10 Goroutines that try to add one to the field
    value of `Counter` structure. All of this is done concurrently:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数启动了10个Goroutines，这些Goroutines试图将`Counter`结构字段的值加一。所有这些都是在并发中完成的：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have created a type called `Counter`. Using a `for` loop, we have launched
    a total of 10 Goroutines, as we saw in the *Anonymous functions launched as new
    Goroutines* section. But inside every Goroutine, we are locking the counter so
    that no more Goroutines can access it, adding one to the field value, and unlocking
    it again so others can access it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Counter`的类型。使用`for`循环，我们总共启动了10个Goroutines，正如我们在*作为新Goroutines启动的匿名函数*部分所看到的。但在每个Goroutine内部，我们锁定计数器，以便没有更多的Goroutines可以访问它，将`1`添加到字段值，然后再解锁，以便其他人可以访问它。
- en: Finally, we'll print the value held by the counter. It must be 10 because we
    have launched 10 Goroutines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将打印计数器持有的值。它必须是10，因为我们已经启动了10个Goroutines。
- en: But how can we know that this program is thread safe? Well, Go comes with a
    very handy built-in feature called the "race detector".
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道这个程序是线程安全的呢？嗯，Go自带一个非常实用的内置功能，称为“竞争检测器”。
- en: Presenting the race detector
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示竞争检测器
- en: We already know what a race condition is. To recap, it is used when two processes
    try to access the same resource at the same time with one or more writing operations
    (both processes writing or one process writing while the other reads) involved
    at that precise moment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道什么是竞争条件。为了回顾，当两个进程试图在同一个时间访问相同的资源，并且涉及一个或多个写操作（两个进程都写或一个进程写而另一个读）时，就会使用它。
- en: 'Go has a very handy tool to help diagnose race conditions, that you can run
    in your tests or your main application directly. So let''s reuse the example we
    just wrote for the *mutexes* section and run it with the race detector. This is
    as simple as adding the `-race` command-line flag to the command execution of
    our program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个非常实用的工具可以帮助诊断竞争条件，你可以在测试或主应用程序中直接运行它。所以让我们重用我们刚刚为*互斥锁*部分编写的示例，并使用竞争检测器运行它。这就像在我们的程序命令执行中添加`-race`命令行标志一样简单：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Well, not very impressive is it? But in fact it is telling us that it has not
    detected a potential race condition in the code of this program. Let''s make the
    detector of `-race` flag warn us of a possible race condition by not locking `counter`
    before we modify it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不是很令人印象深刻，对吧？但实际上，它告诉我们，它没有在程序的代码中检测到潜在的竞争条件。让我们通过在修改`counter`之前不锁定它来让`-race`标志的检测器警告我们可能存在的竞争条件：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the `for` loop, comment the `Lock` and `Unlock` calls before and after
    adding `1` to the field value. This will introduce a race condition. Let''s run
    the same program again with the race flag activated:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，在将`1`添加到字段值之前和之后，注释掉`Lock`和`Unlock`调用。这将引入竞争条件。让我们再次运行相同的程序，并激活竞争标志：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I have reduced the output a bit to see things more clearly. We can see a big,
    uppercase message reading `WARNING: DATA RACE`. But this output is very easy to
    reason with. First, it is telling us that some memory position represented by
    *line 19* on our `main.go` file is reading some variable. But there is also a
    write operation in *line 19* of the same file!'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '我已经减少了输出，以便更清楚地看到事情。我们可以看到一个大的、大写的信息，读取`WARNING: DATA RACE`。但这个输出很容易理解。首先，它告诉我们，在我们的`main.go`文件的*第19行*上，有一个内存位置正在读取某个变量。但在同一文件的*第19行*也有写操作！'
- en: This is because a "`++`" operation requires a read of the current value and
    a write to add one to it. That's why the race condition is in the same line, because
    every time it's executed it reads and writes the field in the `Counter` structure.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为一个"`++`"操作需要读取当前值并将其加一。这就是为什么竞争条件出现在同一行，因为每次执行时都会读取并写入`Counter`结构中的字段。
- en: 'But let''s keep in mind that the race detector works at runtime. It doesn''t
    analyze our code statically! What does it mean? It means that we can have a potential
    race condition in our design that the race detector will not detect. For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们记住，竞争检测器在运行时工作。它不会静态分析我们的代码！这意味着什么？这意味着我们可能有一个潜在的设计竞争条件，竞争检测器将无法检测到。例如：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will leave the code as shown in the preceding example. We will take all
    locks and unlocks from the code and launch a single Goroutine to update the `value`
    field:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留前面示例中的代码。我们将从代码中移除所有锁和解锁操作，并启动一个单独的Goroutine来更新`value`字段：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'No warnings, so the code is correct. Well, we know, by design, it''s not. We
    can raise the number of Goroutines executed to two and see what happens:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 没有警告，所以代码是正确的。然而，我们知道，按照设计，它并不是。我们可以将执行的Goroutines数量提高到两个，看看会发生什么：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s execute the program again:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行程序：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now yes, the race condition is detected. But what if we reduce the number of
    processors in use to just one? Will we have a race condition too?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是的，检测到了竞争条件。但如果我们减少使用的处理器数量到只有一个呢？我们也会出现竞争条件吗？
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It seems that no race condition has been detected. This is because the scheduler
    executed one Goroutine first and then the other, so, finally, the race condition
    didn't occur. But with a higher number of Goroutines it will also warn us about
    a race condition, even using only one core.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没有检测到竞争条件。这是因为调度器首先执行了一个Goroutine，然后是另一个，所以最终没有发生竞争条件。但是，即使只使用一个核心，更高的Goroutines数量也会警告我们存在竞争条件。
- en: So, the race detector can help us to detect race conditions that are happening
    in our code, but it won't protect us from a bad design that is not immediately
    executing race conditions. A very useful feature that can save us from lots of
    headaches.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，竞争检测器可以帮助我们检测代码中正在发生的竞争条件，但它不会保护我们免受那些不会立即执行竞争条件的糟糕设计的影响。这是一个非常有用的功能，可以让我们避免许多头疼的问题。
- en: Channels
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Channels
- en: Channels are the second primitive in the language that allows us to write concurrent
    applications. We have talked a bit about channels in the *Communicating sequential
    processes* section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Channels是Go语言中的第二个基本元素，它允许我们编写并发应用程序。我们在*通信顺序进程*部分已经谈到了一些关于channel的内容。
- en: Channels are the way we communicate between processes. We could be sharing a
    memory location and using mutexes to control the processes' access. But channels
    provide us with a more natural way to handle concurrent applications that also
    produces better concurrent designs in our programs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Channels是我们进程间通信的方式。我们可能会共享一个内存位置，并使用互斥锁来控制进程的访问。但channels为我们提供了一种更自然的方式来处理并发应用程序，这也会在我们的程序中产生更好的并发设计。
- en: Our first channel
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个channel
- en: Working with many Goroutines seems pretty difficult if we can't create some
    synchronization between them. The order of execution could be irrelevant as soon
    as they are synchronized. Channels are the second key feature to write concurrent
    applications in Go.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法在它们之间创建一些同步，那么与许多Goroutines一起工作似乎相当困难。一旦它们同步，执行顺序可能就无关紧要了。Channels是Go中编写并发应用程序的第二个关键特性。
- en: A TV channel in real life is something that connects an emission (from a studio)
    to millions of TVs (the receivers). Channels in Go work in a similar fashion.
    One or more Goroutines can work as emitters, and one or more Goroutine can act
    as receivers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，电视频道是将发射（来自工作室）连接到数百万台电视（接收器）的东西。Go中的channel以类似的方式工作。一个或多个Goroutines可以作为发射器工作，一个或多个Goroutine可以作为接收器工作。
- en: One more thing channels, by default, block the execution of Goroutines until
    something is received. It is as if our favourite TV show delays the emission until
    we turn the TV on so we don't miss anything.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点，channels默认情况下会阻塞Goroutines的执行，直到接收到某些东西。这就像我们最喜欢的电视剧延迟播出，直到我们打开电视，这样我们就不会错过任何内容。
- en: How is this done in Go?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中是如何做到这一点的？
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To create channels in Go, we use the same syntax that we use to create slices.
    The `make` keyword is used to create a channel, and we have to pass the keyword
    `chan` and the type that the channel will transport, in this case, strings. With
    this, we have a blocking channel with the name `channel`. Next, we launch a Goroutines
    that sends the message `Hello World!` to the channel. This is indicated by the
    intuitive arrow that shows the flow--the `Hello World!` text going to (`<-`) a
    channel. This works like an assignment in a variable, so we can only pass something
    to a channel by first writing the channel, then the arrow, and finally the value
    to pass. We cannot write `"Hello World!" -> channel`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中创建channel时，我们使用与创建切片相同的语法。`make`关键字用于创建channel，我们必须传递关键字`chan`以及channel将要传输的类型，在这种情况下是字符串。有了这个，我们就有一个名为`channel`的阻塞channel。接下来，我们启动一个Goroutine，将消息`Hello
    World!`发送到channel。这通过直观的箭头表示流程——`Hello World!`文本流向（`<-`）一个channel。这就像在变量中赋值一样工作，因此我们只能通过首先写出channel，然后是箭头，最后是传递的值来向channel传递东西。我们不能写出`"Hello
    World!" -> channel`。
- en: As we mentioned earlier, this channel is blocking the execution of Gorountines
    until a message is received. In this case, the execution of the `main` function
    is stopped until the message from the launched Goroutines reaches the other end
    of the channel in the line `message := <-channel`. In this case, the arrow points
    in the same direction, but it's placed before the channel, indicating that the
    data is being extracted from the channel and assigned to a new variable called
    `message` (using the new assignment "`:=`" operator).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这个通道会阻塞Goroutines的执行，直到接收到消息。在这种情况下，`main`函数的执行被停止，直到从启动的Goroutines发送的消息到达通道的另一端，在`message
    := <-channel`这一行。在这种情况下，箭头指向同一方向，但它放在通道之前，表示数据正在从通道中提取并分配给一个名为`message`的新变量（使用新的赋值操作符"`:=`"）。
- en: 'In this case, we don''t need to use a WaitGroup to synchronize the `main` function
    with the created Goroutines, as the default nature of channels is to block until
    data is received. But does it work the other way around? If there is no receiver
    when the Goroutine sends the message, does it continue? Let''s edit this example
    to see this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要使用WaitGroup来同步`main`函数与创建的Goroutines，因为通道的默认性质是阻塞直到接收到数据。但是反过来呢？如果Goroutine发送消息时没有接收者，它会继续吗？让我们编辑这个例子来看看：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We are going to use the `Sleep` function again. In this case, we print a message
    when the Goroutine is finished. The big difference is in the `main` function.
    Now we wait one second before we listen to the channel for data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`Sleep`函数。在这种情况下，当Goroutine完成时，我们打印一条消息。与`main`函数中的主要区别在于，现在我们在监听通道以获取数据之前等待一秒钟：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The output can differ because, again, there are no guarantees in the order of
    execution, but now we can see that no message is printed until one second has
    passed. After the initial delay, we start listening to the channel, take the data,
    and print it. So the emitter also has to wait for a cue from the other side of
    the channel to continue its execution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能不同，因为，同样地，执行顺序没有保证，但现在我们可以看到，直到一秒钟过去之前，没有任何消息被打印出来。在初始延迟之后，我们开始监听通道，获取数据，并打印它。因此，发射器也必须等待来自通道另一侧的提示才能继续执行。
- en: To recap, channels are ways to communicate between Goroutines by sending data
    through one end and receiving it at the other (like a pipe). In their default
    state, an emitter Goroutine will block its execution until a receiver Goroutine
    takes the data. The same goes for a receiver Goroutine, which will block until
    some emitter sends data through the channel. So you can have passive listeners
    (waiting for data) or passive emitters (waiting for listeners).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，通道是通过在一端发送数据并在另一端接收数据（就像管道一样）来在Goroutines之间进行通信的方式。在它们的默认状态下，发射器Goroutine会阻塞其执行，直到接收器Goroutine获取数据。同样，接收器Goroutine也会阻塞，直到某个发射器通过通道发送数据。因此，你可以有被动的监听者（等待数据）或被动的发射器（等待监听者）。
- en: Buffered channels
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'A buffered channel works in a similar way to default unbuffered channels. You
    also pass and take values from them by using the arrows, but, unlike unbuffered
    channels, senders don''t need to wait until some Goroutine picks the data that
    they are sending:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道的工作方式与默认的非缓冲通道类似。你同样可以通过使用箭头从它们中传递和获取值，但与未缓冲通道不同，发送者不需要等待某个Goroutine取走它们发送的数据：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This example is like the first example we used for channels, but now we have
    set the capacity of the channel to one in the `make` statement. With this, we
    tell the compiler that this channel has a capacity of one string before getting
    blocked. So the first string doesn''t block the emitter, but the second would.
    Let''s run this example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子就像我们最初用于通道的例子一样，但现在我们在`make`语句中将通道的容量设置为1。通过这种方式，我们告诉编译器，在阻塞之前，这个通道有一个字符串的容量。所以第一个字符串不会阻塞发射器，但第二个会。让我们运行这个例子：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we can run this small program as many times as we want--the output will
    always be in the same order. This time, we have launched the concurrent function
    and waited for one second. Previously, the anonymous function wouldn't continue
    until the second has passed and someone can pick the sent data. In this case,
    with a buffered channel, the data is held in the channel and frees the Goroutine
    to continue its execution. In this case, the Goroutine is always finishing before
    the wait time passes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行这个小程序无数次——输出将始终以相同的顺序出现。这次，我们启动了并发函数并等待了一秒钟。之前，匿名函数不会继续执行，直到第二秒过去并且有人可以取走发送的数据。在这种情况下，使用带缓冲的通道，数据被保持在通道中，并允许Goroutine继续其执行。在这种情况下，Goroutine总是会在等待时间过去之前完成。
- en: 'This new channel has a size of one, so a second message would block the Goroutine
    execution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新通道的大小为1，因此第二个消息将会阻塞Goroutine的执行：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, we add a second `Hello world! 2` message, and we provide it with an index.
    In this case, the output of this program could be like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们添加了第二条`Hello world! 2`消息，并给它提供了一个索引。在这种情况下，这个程序的输出可能如下所示：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Indicating that we have just taken one message from the channel buffer, we have
    printed it, and the `main` function finished before the launched Goroutine could
    finish. The Goroutine got blocked when sending the second message and couldn't
    continue until the other end took the first message. Then it prints it so quickly
    that it doesn't have time to print the message to show the ending of the Goroutine.
    If you keep executing the program on the console, sooner or later the scheduler
    will finish the Goroutine execution before the main thread.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表示我们刚刚从通道缓冲区中取出了一条消息，并打印了它，在启动的Goroutine完成之前，`main`函数已经结束。当发送第二条消息时，Goroutine被阻塞，直到另一端取走第一条消息。然后它打印得如此之快，以至于没有时间打印消息来显示Goroutine的结束。如果你在控制台持续执行程序，迟早调度器会在主线程之前完成Goroutine的执行。
- en: Directional channels
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方向性通道
- en: One cool feature about Go channels is that, when we use them as parameters,
    we can restrict their directionality so that they can be used only to send or
    to receive. The compiler will complain if a channel is used in the restricted
    direction. This feature applies a new level of static typing to Go apps and makes
    code more understandable and more readable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go通道的一个酷特性是，当我们将它们作为参数使用时，我们可以限制它们的方向性，使得它们只能用于发送或接收。如果在一个受限的方向上使用通道，编译器会报错。这个特性为Go应用带来了新的静态类型级别，使得代码更加易于理解和阅读。
- en: 'We''ll take a simple example with channels:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个简单的通道示例来展示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The line where we launch the new Goroutine `go func(ch chan<- string)` states
    that the channel passed to this function can only be used as an input channel,
    and you can't listen to it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动新Goroutine的行`go func(ch chan<- string)`表示传递给这个函数的通道只能用作输入通道，你不能监听它。
- en: 'We can also pass a channel that will be used as a receiver channel only:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递一个仅用作接收通道的通道：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the arrow is on the opposite side of the keyword `chan`, indicating
    an extracting operation from the channel. Keep in mind that the channel arrow
    always points left, to indicate a receiving channel, it must go on the left, and
    to indicate an inserting channel, it must go on the right.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，箭头位于关键字`chan`的对面，表示从通道中提取操作。请记住，通道箭头始终指向左边，表示接收通道，它必须位于左边，而表示插入通道，它必须位于右边。
- en: 'If we try to send a value through this *receive only* channel, the compiler
    will complain about it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试通过这个*只接收*通道发送一个值，编译器会对此报错：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This function has a receive only channel that we will try to use to send the
    message `hello` through. Let''s see what the compiler says:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个只接收的通道，我们将尝试通过它发送消息`hello`。让我们看看编译器会说什么：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It doesn't like it and asks us to correct it. Now the code is even more readable
    and safe, and we have just placed an arrow in front or behind the `chan` argument.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它不喜欢它，并要求我们进行修正。现在代码的阅读性和安全性都得到了提升，我们已经在`chan`参数前或后放置了一个箭头。
- en: The select statement
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择语句
- en: The select statement is also a key feature in Go. It is used to handle more
    than one channel input within a Goroutine. In fact, it opens lots of possibilities,
    and we will use it extensively in the following chapters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 选择语句也是Go中的一个关键特性。它用于在Goroutine中处理多个通道输入。实际上，它打开了众多可能性，我们将在接下来的章节中广泛使用它。
- en: '![The select statement](img/00038.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![选择语句](img/00038.jpeg)'
- en: In the `select` structure, we ask the program to choose between one or more
    channels to receive their data. We can save this data in a variable and make something
    with it before finishing the select. The `select` structure is just executed once;
    it doesn't matter if it is listening to more channels, it will be executed only
    once and the code will continue executing. If we want it to handle the same channels
    more than once, we have to put it in a `for` loop.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `select` 结构中，我们要求程序在多个通道中选择一个或多个来接收它们的数据。我们可以在变量中保存这些数据，并在完成 select 之前对其进行处理。`select`
    结构只执行一次；如果它正在监听更多通道，它也只会执行一次，代码将继续执行。如果我们想让它多次处理相同的通道，我们必须将其放入 `for` 循环中。
- en: We will make a small app that will send the message `hello` and the message
    `goodbye` to the same Goroutine, which will print them and exit if it doesn't
    receive anything else in five seconds.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小程序，它将向同一个 Goroutine 发送消息 `hello` 和消息 `goodbye`，该 Goroutine 将打印它们，并在五秒钟内没有收到其他任何消息时退出。
- en: 'First, we will make a generic function that sends a string over a channel:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个通用的函数，通过通道发送字符串：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we can send a string over a channel by simply calling the `sendString`
    method. It''s time for the receiver. The receiver will take messages from both
    channels--the one that sends `hello` messages and the one that sends `goodbye`
    messages. You can also see this in the previous diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过简单地调用 `sendString` 方法在通道上发送字符串。现在是接收者的时间。接收者将接收来自两个通道的消息——发送 `hello`
    消息的通道和发送 `goodbye` 消息的通道。你也可以在之前的图中看到这一点：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Let's start with the arguments. This function takes three channels--two receiving
    channels and one to send something through it. Then, it starts an infinite loop
    with the `for` keyword. This way we can keep listening to both channels forever.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从参数开始。这个函数接受三个通道——两个接收通道和一个通过它发送东西的通道。然后，它使用 `for` 关键字启动一个无限循环。这样我们就可以永远监听两个通道。
- en: 'Inside the scope of `select` block, we have to use a case for each channel
    we want to handle (have you realized how similar it is to the `switch` statement?).
    Let''s see the three cases step by step:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `select` 块的作用域内，我们必须为每个我们想要处理的通道使用一个 case（你有没有意识到它和 `switch` 语句多么相似？）。让我们一步一步地看看三个
    case：
- en: The first case takes the incoming data from the `helloCh` argument and saves
    it in a variable called `msg`. Then it prints the contents of this variable.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个情况从 `helloCh` 参数接收传入的数据，并将其保存到名为 `msg` 的变量中。然后它打印了这个变量的内容。
- en: The second case takes the incoming data from the `goodbyeCh` argument and saves
    it in a variable called `msg` too. Then it also prints the content of this variable.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个情况从 `goodbyeCh` 参数接收传入的数据，并将其保存到名为 `msg` 的变量中。然后它还打印了这个变量的内容。
- en: The third case is quite interesting. It calls the `time` function. After that,
    if we check its signature, it accepts a time and duration value and returns a
    receiving channel. This receiving channel will receive a time, the value of `time`
    after the specified duration has passed. In our example, we use the channel it
    returns as a timeout. Because the select is restarted after each handle, the timer
    is restarted too. This is a very simple way to set a timer to a Goroutine waiting
    for the response of one or many channels.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个情况非常有趣。它调用了 `time` 函数。之后，如果我们检查它的签名，它接受一个时间和持续时间值，并返回一个接收通道。这个接收通道将接收一个时间，即在指定持续时间过后
    `time` 的值。在我们的例子中，我们使用它返回的通道作为超时。因为 select 在每次处理后会重新启动，计时器也会重新启动。这是一种非常简单的方法，为等待一个或多个通道响应的
    Goroutine 设置计时器。
- en: 'Everything is ready for the `main` function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都为 `main` 函数准备好了：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, step by step, we created the three channels that we'll need in this exercise.
    Then, we launched our `receiver` function in a different Goroutine. This Goroutine
    is handled by Go's scheduler and our program continues. We launched a new Goroutine
    to send the message `hello` to the `helloCh` arguments. Again, this is going to
    occur eventually when the Go's scheduler decides.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一步一步地，我们创建了在这个练习中需要的三个通道。然后，我们在不同的 Goroutine 中启动了我们的 `receiver` 函数。这个 Goroutine
    由 Go 的调度器处理，我们的程序继续运行。我们启动了一个新的 Goroutine 来向 `helloCh` 参数发送消息 `hello`。同样，这最终会在
    Go 的调度器决定时发生。
- en: Our program continues again and waits for a second. In this break, Go's scheduler
    will have time to execute the receiver and the first message (if it hasn't done
    so yet), so the `hello!` message will appear on the console during the break.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序再次继续并等待一秒钟。在这个中断期间，Go 的调度器将有时间执行接收器和第一条消息（如果尚未执行），因此 `hello!` 消息将在中断期间出现在控制台上。
- en: A new message is sent over the `goodbye` channel with the `goodbye!` text in
    a new Goroutine, and our program continues again to a line where we wait for an
    incoming message in the `quitCh` argument.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的 Goroutine 中通过 `goodbye` 通道发送了一条包含 `goodbye!` 文本的新消息，我们的程序再次继续到等待 `quitCh`
    参数中传入消息的行。
- en: We have launched three Goroutines already--the receiver that it is still running,
    the first message that had finished when the message was handled by the `select`
    statement, and the second message was been printed almost immediately and had
    finished too. So just the receiver is running at this moment, and if it doesn't
    receive any other message in the following two seconds, it will handle the incoming
    message from the `time` structure. After `channel` type, print a message to say
    that it is quitting, send a `true` to the `quitCh`, and break the infinite loop
    where it was looping.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了三个 Goroutines——接收器仍在运行，第一条消息在`select`语句处理消息时已经完成，第二条消息几乎立即打印出来并也已完成。所以此刻只有接收器在运行，如果接下来两秒内没有接收到其他消息，它将处理来自`time`结构的传入消息。在`channel`类型之后，打印一条消息表示它正在退出，向`quitCh`发送一个`true`，并跳出它正在循环的无穷循环。
- en: 'Let''s run this small app:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个小应用程序：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The result  may not be very impressive, but the concept is clear. We can handle
    many incoming channels in the same Goroutine by using the select statement.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不太引人注目，但概念是清晰的。我们可以通过使用 select 语句在同一个 Goroutine 中处理多个传入通道。
- en: Ranging over channels too!
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道的遍历！
- en: 'The last feature about channels that we will see is ranging over channels.
    We are talking about the range keyword. We have used it extensively to range over
    lists, and we can use it to range over a channel too:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看到的关于通道的最后一个特性是遍历通道。我们正在讨论 range 关键字。我们已经广泛地使用它来遍历列表，我们也可以用它来遍历通道：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, we have created an unbuffered channel, but it would work with
    a buffered one too. We launched a function in a new Goroutine that sends the number
    "1" over a channel, waits a second, sends the number "2", and closes the channel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个无缓冲的通道，但它也可以与缓冲通道一起工作。我们在一个新的 Goroutine 中启动了一个函数，该函数通过通道发送数字 "1"，等待一秒，然后发送数字
    "2"，并关闭通道。
- en: The last step is to range over the channel. The syntax is quite similar to a
    list range. We store the incoming data from the channel in the variable `v` and
    we print this variable to the console. The range keeps iterating until the channel
    is closed, taking data from the channel.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是遍历通道。语法与列表范围非常相似。我们将来自通道的传入数据存储在变量 `v` 中，并将此变量打印到控制台。range 会持续迭代，直到通道关闭，从通道中获取数据。
- en: Can you guess the output of this little program?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜出这个小程序的输出吗？
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, not very impressive. It prints the number "1", then waits a second, prints
    the number "2", and exits the application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，并不十分引人注目。它打印数字 "1"，然后等待一秒，打印数字 "2"，并退出应用程序。
- en: According to the design of this concurrent app, the range was iterates over
    possible incoming data from the
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个并发应用程序的设计，范围遍历可能的传入数据
- en: channel
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通道
- en: until the concurrent Goroutine closes this channel. At that moment, the range
    finishes and the app can exit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 直到并发 Goroutine 关闭这个通道。在那个时刻，range 完成，应用程序可以退出。
- en: Range is very useful in taking data from a channel, and it's commonly used in
    fan-in patterns where many different Goroutines send data to the same channel.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Range 在从通道获取数据时非常有用，它通常用于扇入模式，其中许多不同的 Goroutines 将数据发送到同一个通道。
- en: Using it all - concurrent singleton
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用它所有 - 并发单例
- en: Now that we know how to create Goroutines and channels, we'll put all our knowledge
    in a single package. Think back to the first few chapter, when we explained the
    singleton pattern-it was some structure or variable that could only exist once
    in our code. All access to this structure should be done using the pattern described,
    but, in fact, it wasn't concurrent safe.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建 Goroutines 和通道，我们将所有知识放在一个单独的包中。回想一下前几章，当我们解释单例模式时——它是在我们的代码中只能存在一次的结构或变量。对这个结构的所有访问都应该使用所描述的模式进行，但实际上它并不是并发安全的。
- en: Now we will write with concurrency in mind. We will write a concurrent counter,
    like the one we wrote in the *mutexes* section, but this time we will solve it
    with channels.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将考虑到并发来编写代码。我们将编写一个并发计数器，就像我们在 *互斥锁* 部分所写的那样，但这次我们将使用通道来解决它。
- en: Unit test
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: To restrict concurrent access to the `singleton` instance, just one Goroutine
    will be able to access it. We'll access it using channels--the first one to add
    one, the second one to get the current count, and the third one to stop the Goroutine.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制对 `singleton` 实例的并发访问，只有一个 Goroutine 能够访问它。我们将使用通道来访问它——第一个用于加一，第二个用于获取当前计数，第三个用于停止
    Goroutine。
- en: We will add one 10,000 times using 10,000 different Goroutines launched from
    two different `singleton` instances. Then, we'll introduce a loop to check the
    count of the `singleton` until it is 5,000, but we'll write how much the count
    is before starting the loop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 10,000 个不同的 Goroutine，从两个不同的 `singleton` 实例启动，来加一 10,000 次。然后，我们将引入一个循环来检查
    `singleton` 的计数，直到它达到 5,000，但我们将先写出循环开始前的计数。
- en: 'Once the count has reached 5,000, the loop will exit and quit the running Goroutine-the
    test code looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当计数达到 5,000 时，循环将退出，并停止运行的 Goroutine——测试代码如下：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we can see the full test we'll use. After creating two instances of the
    `singleton`, we have created a `for` loop that launches the `AddOne` method 5,000
    times from each instance. This is not happening yet; they are being scheduled
    and will be executed eventually. We are printing the count of the `singleton`
    instance to clearly see this eventuality; depending on the computer, it will print
    some number greater than 0 and lower than 10,000.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将使用的完整测试。在创建了两个 `singleton` 实例之后，我们创建了一个 `for` 循环，从每个实例启动 `AddOne`
    方法 5,000 次。这还没有发生；它们正在被调度，最终将被执行。我们正在打印 `singleton` 实例的计数，以便清楚地看到这个可能性；根据计算机的不同，它将打印一个大于
    0 且小于 10,000 的数字。
- en: The last step before stopping the Goroutine that is holding the count is to
    enter a loop that checks the value of the count and waits 10 milliseconds if the
    value is not the expected value (10,000). Once it reaches this value, the loop
    will exit and we can stop the `singleton` instance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在停止保持计数的 Goroutine 之前，最后一步是进入一个循环，检查计数的值，如果值不是预期的值（10,000），则等待 10 毫秒。一旦达到这个值，循环将退出，我们就可以停止
    `singleton` 实例。
- en: We'll jump directly to the implementation as the requirement is quite simple.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接跳到实现，因为要求非常简单。
- en: Implementation
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'First of all, we''ll create the Goroutine that will hold the count:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个将保持计数的 Goroutine：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We created three channels, as we mentioned earlier:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们创建了三个通道：
- en: The `addCh` channel is used to communicate with the action of adding one to
    the count, and receives a `bool` type just to signal "add one" (we don't need
    to send the number, although we could).
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCh` 通道用于与将计数加一的动作进行通信，并接收一个 `bool` 类型的值，仅用于表示“加一”（我们不需要发送数字，尽管我们可以）。'
- en: The `getCountCh` channel will return a channel that will receive the current
    value of the count. Take a moment to reason about the `getCountCh` channel-it's
    a channel that receives a channel that receives integer types. It sounds a bit
    complicated, but it will make more sense when we finish the example, don't worry.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCountCh` 通道将返回一个通道，该通道将接收计数的当前值。花点时间来思考一下 `getCountCh` 通道——这是一个接收接收整数类型的通道的通道。听起来有点复杂，但当我们完成示例后，你就会明白，不用担心。'
- en: The `quitCh` channel will communicate to the Goroutine that it should end its
    infinite loop and finish itself too.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quitCh` 通道将通知 Goroutine 它应该结束其无限循环并自行结束。'
- en: Now we have the channels that we need to perform the actions we want. Next,
    we launch the Goroutine passing the channels as arguments. As you can see, we
    are restricting the direction of the channels to provide more type safety. Inside
    this Goroutine, we create an infinite `for` loop. This loop won't stop until a
    break is executed within it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了执行我们想要执行的操作所需的通道。接下来，我们启动一个传递通道作为参数的 Goroutine。正如你所看到的，我们限制了通道的方向，以提供更多的类型安全性。在这个
    Goroutine 内部，我们创建了一个无限 `for` 循环。这个循环将不会停止，直到其中执行了 `break`。
- en: 'Finally, the `select` statement, if you remember, was a way to receive data
    from different channels at the same time. We have three cases, so we listen to
    the three incoming channels that entered as arguments:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你还记得，`select` 语句是一种同时从不同通道接收数据的方法。我们有三种情况，所以我们要监听作为参数传入的三个输入通道：
- en: The `addCh` case will add one to the count. Remember that only one case can
    be executed on each iteration so that no Goroutine could be accessing the current
    count until we finish adding one.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCh` 的情况会将计数加一。记住，在每次迭代中只能执行一个情况，这样就没有任何 Goroutine 能够在加一完成之前访问当前的计数。'
- en: The `getCountCh` channel receives a channel that receives an integer, so we
    capture this new channel and send the current value through it to the other end.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCountCh` 通道接收一个接收整数的通道，因此我们捕获这个新通道并通过它发送当前值到另一端。'
- en: The `quitCh` channel breaks the `for` loop, so the Goroutine ends.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quitCh` 通道中断 `for` 循环，因此 Goroutine 结束。'
- en: One last thing. The `init()` function in any package will get executed on program
    execution, so we don't need to worry about executing this function specifically
    from our code.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情。任何包中的 `init()` 函数在程序执行时都会被执行，所以我们不需要担心从我们的代码中特别执行这个函数。
- en: 'Now, we''ll create the type that the tests are expecting. We will see that
    all the magic and logic is hidden from the end user in this type (as we have seen
    in the code of the test):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建测试所期望的类型。我们将看到所有魔法和逻辑都隐藏在这个类型中（正如我们在测试代码中所看到的）：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `singleton` type works similar to the way it worked in [Chapter 2](part0111_split_000.html#39REE2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 2. Creational Patterns - Singleton, Builder, Factory, Prototype, and
    Abstract Factory Design Patterns") , *Creational Patterns - Singleton, Builder,
    Factory, Prototype, and Abstract Factory*, but this time it won't hold the count
    value. We created a local value for it called `instance`, and we return the pointer
    to this instance when we call the `GetInstance()` method. It is not strictly necessary
    to do it this way, but we don't need to allocate a new instance of the `singleton`
    type every time we want to access the count variable.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleton` 类型的工作方式与它在[第2章](part0111_split_000.html#39REE2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第2章。创建型模式 - 单例、建造者、工厂、原型和抽象工厂设计模式")中的工作方式相似，*创建型模式 - 单例、建造者、工厂、原型和抽象工厂*，但这次它不会持有计数值。我们为它创建了一个局部值，称为
    `instance`，当我们调用 `GetInstance()` 方法时，我们返回这个实例的指针。这样做并不严格必要，但每次我们想要访问计数值变量时，我们不需要分配
    `singleton` 类型的新的实例。'
- en: 'First, the `AddOne()` method will have to add one to the current count. How?
    By sending `true` to the `addCh` channel. That''s simple:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`AddOne()` 方法必须将当前计数加一。如何做？通过向 `addCh` 通道发送 `true`。很简单：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `GetCount` method creates a channel every time it's called and defers the
    action of closing it at the end of the function. This channel is unbuffered as
    we have seen previously in this chapter. An unbuffered channel blocks the execution
    until it receives some data. So we send this channel to `getCountCh` which is
    a channel too and, effectively, expects a `chan int` type to send the current
    count value back through it. The `GetCount()` method will not return until the
    value of `count` variable arrives to the `resCh` channel.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCount` 方法每次被调用时都会创建一个通道，并在函数结束时延迟关闭它的动作。这个通道是无缓冲的，正如我们在本章前面所看到的。一个无缓冲的通道在接收到数据之前会阻塞执行。因此，我们将这个通道发送到
    `getCountCh`，它也是一个通道，并且实际上期望通过它发送当前的计数值。`GetCount()` 方法将不会返回，直到 `count` 变量的值到达
    `resCh` 通道。'
- en: 'You might be thinking, why aren''t we using the same channel in both directions
    to receive the value of the count? This way we will avoid an allocation. Well,
    if we use the same channel inside the `GetCount()` method, we will have two listeners
    in this channel--one in `select` statement, at the beginning of the file on the
    `init` function, and one there, so it could resolve to any of them when sending
    the value back:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们不在两个方向上使用相同的通道来接收计数值？这样我们可以避免分配。好吧，如果我们使用 `GetCount()` 方法中的相同通道，这个通道将有两个监听器--一个在文件的开始处的
    `select` 语句中，另一个在 `init` 函数的开始处，所以发送值回传时可能会解析到任何一个：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, we have to stop the Goroutine at some moment. The `Stop` method sends
    the value to the `singleton` type Goroutine so that the `quitCh` case is triggered
    and the `for` loop is broken. The next step is to close all channels so that no
    more data can be sent through them. This is very convenient when you know that
    you won't be using some of your channels anymore.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在某个时刻停止 Goroutine。`Stop` 方法将值发送到 `singleton` 类型的 Goroutine，从而触发 `quitCh`
    的情况并中断 `for` 循环。下一步是关闭所有通道，这样就不能再通过它们发送数据了。当你知道你不会再使用一些通道时，这非常方便。
- en: 'Time to execute the tests and take a look:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 执行测试并查看时间：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Very little code output, but everything has worked as expected. In the test,
    we printed the value of the count before entering the loop that iterates until
    it reaches the value 10,000\. As we saw previously, the Go scheduler will try
    to run the content of the Goroutines using as many OS threads as you configured
    by using the `GOMAXPROCS` configuration. In my computer, it is set to `4` because
    my computer has four cores. But the point is that we can see that a lot of things
    can happen after launching a Goroutine (or 10,000) and the next execution line.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出非常少，但一切如预期般工作。在测试中，我们在进入迭代直到达到10,000这个值的循环之前打印了计数器的值。正如我们之前所看到的，Go调度器会尝试使用你通过`GOMAXPROCS`配置设置的尽可能多的操作系统线程来运行Goroutines的内容。在我的电脑上，它被设置为`4`，因为我的电脑有四个核心。但关键是，我们可以看到在启动Goroutine（或10,000个）之后和下一执行行之间会发生很多事情。
- en: But what about its use of mutexes?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但它的互斥锁（mutexes）的使用又是如何呢？
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this case, the code is much leaner. As we saw previously, we can embed the
    mutex within the `singleton` structure. The count is also held in the `count`
    field and the `AddOne()` and `GetCount()` methods lock and unlock the value to
    be concurrently safe.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码更加简洁。正如我们之前所看到的，我们可以在`singleton`结构体内部嵌入互斥锁。计数器也保存在`count`字段中，`AddOne()`和`GetCount()`方法锁定和解锁要并发安全的值。
- en: One more thing. In this `singleton` instance, we are using the `RWMutex` type
    instead of the already known `sync.Mutex` type. The main difference here is that
    the `RWMutex` type has two types of locks--a read lock and a write lock. The read
    lock, executed by calling the `RLock` method, only waits if a write lock is currently
    active. At the same time, it only blocks a write lock, so that many read actions
    can be done in parallel. It makes a lot of sense; we don't want to block a Goroutine
    that wants to read a value just because another Goroutine is also reading the
    value-it won't change. The `sync.RWMutex` type helps us to achieve this logic
    in our code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。在这个`singleton`实例中，我们使用的是`RWMutex`类型而不是已知的`sync.Mutex`类型。这里的主要区别在于`RWMutex`类型有两种锁——读锁和写锁。通过调用`RLock`方法执行的读锁，只有在当前有一个写锁活动时才会等待。同时，它只阻止写锁，这样就可以并行执行许多读操作。这很有意义；我们不希望因为另一个Goroutine也在读取值而阻塞想要读取值的Goroutine——它不会改变。`sync.RWMutex`类型帮助我们实现代码中的这种逻辑。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen how to write a concurrent Singleton using mutexes and channels.
    While the channels example was more complex, it also shows the core power of Go's
    concurrency, as you can achieve complex levels of event-driven architectures by
    simply using channels.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用互斥锁和通道（channels）编写并发单例（Singleton）。虽然通道的例子更为复杂，但它也展示了Go并发机制的核心力量，因为你可以通过简单地使用通道来实现复杂的事件驱动架构。
- en: Just keep in mind that, if you haven't written concurrent code in the past,
    it can take some time to start thinking concurrently in a comfortable way. But
    it's nothing that practice cannot solve.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，如果你以前没有编写过并发代码，可能需要一些时间才能开始以舒适的方式并发思考。但这是练习可以解决的问题。
- en: We have seen the importance of designing concurrent apps to achieve parallelism
    in our programs. We have dealt with most of Go's primitives to write concurrent
    applications, and now we can write common concurrent design patterns.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了设计并发应用程序以在程序中实现并行性的重要性。我们已经处理了Go的大多数原语来编写并发应用程序，现在我们可以编写常见的并发设计模式。
