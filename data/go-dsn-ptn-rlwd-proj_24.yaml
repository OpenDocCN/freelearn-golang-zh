- en: Chapter 10. Concurrency Patterns - Workers Pool and Publish/Subscriber Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。并发模式 - 工作池和发布/订阅设计模式
- en: We have reached the final chapter of the book, where we will discuss a couple
    of patterns with concurrent structures. We will explain every step in detail so
    you can follow the examples carefully.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本书的最后一章，我们将讨论一些具有并发结构的模式。我们将详细解释每个步骤，以便您可以仔细地跟随示例。
- en: The idea is to learn about patterns to design concurrent applications in idiomatic
    Go. We are using channels and Goroutines heavily, instead of locks or sharing
    variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是了解如何使用Go的惯用方法设计并发应用程序的模式。我们大量使用通道和Goroutines，而不是锁或共享变量。
- en: We will look at one way to develop a pool of workers. This is useful to control
    the number of Goroutines in an execution.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨一种开发工作池的方法。这对于控制执行中的Goroutines数量非常有用。
- en: The second example is a rewrite of the Observer pattern, which we saw on [Chapter
    7](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 7. Behavioral
    Patterns - Visitor, State, Mediator, and Observer Design Patterns"), *Behavioral
    Patterns - Visitor, State, Mediator, and Observer Design Patterns*, written with
    a concurrent structure. With this example we'll dig a bit more into the concurrent
    structures and look at how they can differ from a common approach.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个示例是对观察者模式的重写，我们在[第7章](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第7章。行为模式 - 访问者、状态、中介者和观察者设计模式")中看到了它，*行为模式 - 访问者、状态、中介者和观察者设计模式*，它使用并发结构编写。通过这个例子，我们将更深入地了解并发结构，并看看它们如何与常见方法不同。
- en: Workers pool
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作池
- en: One problem we may face with some of the previous approaches to concurrency
    is their unbounded context. We cannot let an app create  an unlimited amount of
    Goroutines. Goroutines are light, but the work they perform could be very heavy.
    A workers pool helps us to solve this problem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的一些并发方法中可能会遇到的一个问题是它们的上下文无界。我们不能让一个应用程序无限制地创建Goroutines。Goroutines很轻量，但它们执行的工作可能非常繁重。工作池可以帮助我们解决这个问题。
- en: Description
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: With a pool of workers, we want to bound the amount of Goroutines available
    so that we have a deeper control of the pool of resources. This is easy to achieve
    by creating a channel for each worker and having workers with either an idle or
    busy status. The task can seem daunting, but it's not at all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工作池，我们希望限制可用的Goroutines数量，以便我们能够更深入地控制资源池。通过为每个工作创建一个通道并让工作处于空闲或忙碌状态，这很容易实现。这项任务可能看起来很艰巨，但实际上并非如此。
- en: Objectives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'Creating a Worker pool is all about resource control: CPU, RAM, time, connections,
    and so on. The workers pool design pattern helps us to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建工作池完全是关于资源控制：CPU、RAM、时间、连接等等。工作池设计模式帮助我们做到以下几点：
- en: Control access to shared resources using quotas
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配额控制对共享资源的访问
- en: Create a limited amount of Goroutines per app
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个应用程序创建有限数量的Goroutines
- en: Provide more parallelism capabilities to other concurrent structures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他并发结构提供更多的并行能力
- en: A pool of pipelines
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道池
- en: In the previous chapter, we saw how to work with a pipeline. Now we will launch
    a bounded number of them so that the Go scheduler can try to process requests
    in parallel. The idea here is to control the number of Goroutines, stop them gracefully
    when the app has finished, and maximize parallelism using a concurrent structure
    without race conditions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用管道。现在我们将启动有限数量的管道，以便Go调度器可以尝试并行处理请求。这里的想法是通过并发结构控制Goroutines的数量，当应用程序完成时优雅地停止它们，并最大限度地提高并行性，同时避免竞争条件。
- en: The pipeline we will use is similar to the one we used in the previous chapter,
    where we were generating numbers, raising them to the power of 2, and summing
    the final results. In this case, we are going to pass strings to which we will
    append and prefix data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的管道与上一章中使用的类似，当时我们在生成数字，将它们平方，并求和最终结果。在这种情况下，我们将传递字符串，我们将向其中添加和添加前缀数据。
- en: Acceptance criteria
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受标准
- en: 'In business terms, we want something that tells us that, worker has processed
    a request, a predefined ending, and incoming data parsed to uppercase:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业术语中，我们希望得到一些信息，表明工作者已经处理了一个请求，一个预定义的结束，以及解析为大写的传入数据：
- en: When making a request with a string value (any), it must be uppercase.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用字符串值（任何值）进行请求时，它必须是大写的。
- en: Once the string is uppercase, a predefined text must be appended to it. This
    text should not be uppercase.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦字符串是大写的，必须向其中添加一个预定义的文本。这个文本不应该是大写的。
- en: With the previous result, the worker ID must be prefixed to the final string.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的结果，必须将工作器 ID 前缀添加到最终字符串中。
- en: The resulting string must be passed to a predefined handler.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的字符串必须传递给预定义的处理程序。
- en: We haven't talked about how to do it technically, just what the business wants.
    With the entire description, we'll at least have workers, requests, and handlers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论如何从技术上实现它，只是讨论了业务需求。有了整个描述，我们至少会有工作器、请求和处理程序。
- en: Implementation
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The very beginning is a request type. According to the description, it must
    hold the string that will enter the pipeline as well as the handler function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始是一个请求类型。根据描述，它必须包含将进入管道的字符串以及处理函数：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where is the `return`? We have a `Data` field of type `interface{}` so we can
    use it to pass a string. By using an interface, we can reuse this type for a `string`,
    an `int`, or a `struct` data type. The receiver is the one who must know how to
    deal with the incoming interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` 在哪里？我们有一个 `Data` 字段，其类型为 `interface{}`，因此我们可以使用它来传递一个字符串。通过使用接口，我们可以重用此类型来传递
    `string`、`int` 或 `struct` 数据类型。接收者是必须知道如何处理传入接口的那个人。'
- en: 'The `Handler` field has the type `Request` handler, which we haven''t defined
    yet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler` 字段具有 `Request` 处理程序的类型，我们还没有定义它：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A request handler is any function that accepts an interface as its first argument,
    and returns nothing. Again, we see the `interface{}`, where we would usually see
    a string. This is one of the receivers we mentioned previously, which we'll need
    to cast the incoming result.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理程序是任何接受接口作为其第一个参数且不返回任何内容的函数。再次，我们看到 `interface{}`，我们通常在这里看到一个字符串。这是我们之前提到的一个接收者，我们需要将其转换为传入的结果。
- en: 'So, when sending a request, we must fill it with some value in the `Data` field
    and implement a handler; for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在发送请求时，我们必须在 `Data` 字段中填充一些值并实现一个处理程序；例如：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The handler is defined by using a closure. We again check the type if the interface
    (and we defer the call to the `Done()` method at the end). In case of an improper
    interface, we simply print its contents and return. If the casting is OK, we also
    print them, but here is where we will usually do something with the result of
    the operation; we have to use type casting to retrieve the contents of the `interface{}`
    (which is a string). This must be done in every step in the pipeline, although
    it will introduce a bit of overhead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序是通过使用闭包定义的。我们再次检查接口的类型（并在最后延迟调用 `Done()` 方法）。如果接口不正确，我们简单地打印其内容并返回。如果转换是正确的，我们也打印它们，但在这里我们通常会做些操作来处理操作的结果；我们必须使用类型转换来检索
    `interface{}`（它是一个字符串）的内容。这必须在管道的每个步骤中完成，尽管这会引入一点开销。
- en: 'Now we need a type that can handle `Request` types. Possible implementations
    are virtually infinite, so it is better to define an interface first:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个可以处理 `Request` 类型的类型。可能的实现几乎是无限的，因此最好首先定义一个接口：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WorkerLauncher` interface must implement only the `LaunchWorker(chan Request)`
    method. Any type that implements this interface will have to receive a channel
    of `Request` type to satisfy it. This channel of the `Request` type is the single
    entrance point to the pipeline.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerLauncher` 接口必须仅实现 `LaunchWorker(chan Request)` 方法。任何实现此接口的类型都必须接收一个
    `Request` 类型的通道以满足它。这个 `Request` 类型的通道是管道的单个入口点。'
- en: The dispatcher
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分发器
- en: 'Now, to launch workers in parallel and handle all the possible incoming channels,
    we''ll need something like a dispatcher:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了并行启动工作器并处理所有可能的传入通道，我们需要一个类似分发器的工具：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `Dispatcher` interface can launch an injected `WorkerLaunchers` type in its
    own `LaunchWorker` method. The `Dispatcher` interface must use the `LaunchWorker`
    method of any of the `WorkerLauncher` types to initialize a pipeline. This way
    we can reuse the `Dispatcher` interface to launch many types of `WorkerLaunchers`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher` 接口可以在其自己的 `LaunchWorker` 方法中启动注入的 `WorkerLaunchers` 类型。`Dispatcher`
    接口必须使用 `WorkerLauncher` 类型中的任何 `LaunchWorker` 方法来初始化管道。这样我们就可以重用 `Dispatcher`
    接口来启动许多类型的 `WorkerLaunchers`。'
- en: When using `MakeRequest(Request)`, the `Dispatcher` interface exposes a nice
    method to inject a new `Request` into the workers pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `MakeRequest(Request)` 时，`Dispatcher` 接口提供了一个将新的 `Request` 注入工作池的便捷方法。
- en: Finally, the user must call stop when all Goroutines must be finished. We must
    handle graceful shutdown in our apps, and we want to avoid Goroutine leaks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有 Goroutines 都必须完成时，用户必须调用 stop。我们必须在我们的应用程序中处理优雅的关闭，并且我们希望避免 Goroutine
    泄露。
- en: 'We have enough interfaces, so let''s start with the dispatcher which is a bit
    less complicated:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了足够的接口，所以让我们从稍微简单一点的分发器开始：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `dispatcher` structure stores a channel of `Request` type in one of its
    fields. This is going to be the single point of entrance for requests in any pipeline.
    We said that it must implement three methods, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`dispatcher`结构在其字段之一中存储了一个`Request`类型的通道。这将是要进入任何管道请求的单一点。我们说它必须实现三个方法，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `Dispatcher` interface doesn't need to do anything special
    to itself before launching a worker, so the `LaunchWorker` method on the `Dispatcher`
    simply executes the `LaunchWorker` method of the incoming `WorkerLauncher,`which
    also has a `LaunchWorker` method to initiate itself. We have previously defined
    that a `WorkerLauncher` type needs at least an ID and a channel for incoming requests,
    so that's what we are passing through.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Dispatcher`接口在启动一个worker之前不需要对自己做任何特殊的事情，所以`Dispatcher`上的`LaunchWorker`方法简单地执行传入的`WorkerLauncher`的`LaunchWorker`方法，这个`WorkerLauncher`也有一个`LaunchWorker`方法来自启动自己。我们之前定义了一个`WorkerLauncher`类型至少需要一个ID和一个用于传入请求的通道，所以这就是我们传递的内容。
- en: It may seem unnecessary to implement the `LaunchWorker` method in the `Dispatcher`
    interface. In different scenarios, it could be interesting to save running worker
    IDs in the dispatcher to control which ones are up or down; the idea is to hide
    launching implementation details. In this case, the `Dispatcher` interface is
    merely acting as a Facade design pattern hiding some implementation details from
    the user.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dispatcher`接口中实现`LaunchWorker`方法可能看起来是不必要的。在不同的场景中，保存正在运行的worker ID到分发器中，以控制哪些是开启或关闭的，可能是有趣的；这个想法是隐藏启动实现的细节。在这种情况下，`Dispatcher`接口仅仅充当一个外观设计模式，隐藏了一些实现细节给用户。
- en: The second method is `Stop`. It closes the incoming requests channel, provoking
    a chain reaction. We saw in the pipeline example that, when closing the incoming
    channel, each for-range loop within the Goroutines breaks and the Goroutine is
    also finished. In this case, when closing a shared channel, it will provoke the
    same reaction, but in every listening Goroutine, so all pipelines will be stopped.
    Cool, huh?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是`Stop`。它关闭了传入请求的通道，从而引发连锁反应。我们在管道示例中看到，当关闭传入通道时，Goroutines内部的每个for-range循环都会中断，Goroutine也会结束。在这种情况下，当关闭共享通道时，它将在每个监听Goroutine中引发相同的反应，因此所有管道都将停止。酷吧？
- en: 'Request implementation is very simple; we just pass the request in the argument
    to the channel of incoming requests. The Goroutine will block there forever until
    the opposite end of the channel retrieves the request. Forever? That seems like
    a lot if something happens. We can introduce a timeout, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请求实现非常简单；我们只需将请求作为参数传递给传入请求的通道。Goroutine将在这里永久阻塞，直到通道的另一端检索到请求。永远？如果发生什么情况，这似乎有点多。我们可以引入一个超时，如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you remember from previous chapters, we can use select to control which
    operation is performed over a channel. Like a `switch` case, just one operation
    can be executed. In this case, we have two different operations: sending and receiving.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得前面的章节，我们可以使用select来控制对通道执行的操作。就像`switch`案例一样，只能执行一个操作。在这种情况下，我们有两个不同的操作：发送和接收。
- en: The first case is a sending operation--try to send this, and it will block there
    until someone takes the value in the opposite side of the channel. Not a huge
    improvement, then. The second case is a receiving operation; it will be triggered
    after 5 seconds if the upper request can't be sent successfully, and the function
    will return. It would be very convenient to return an error here, but to make
    things simple, we will leave it empty
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是发送操作--尝试发送这个，它将在这里阻塞，直到有人从通道的另一端取走值。这并没有太大的改进。第二种情况是接收操作；如果上面的请求无法成功发送，它将在5秒后触发，函数将返回。在这里返回一个错误会很方便，但为了简单起见，我们将它留空。
- en: 'Finally, in the dispatcher, for convenience, we will define a `Dispatcher`
    creator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在分发器中，为了方便，我们将定义一个`Dispatcher`创建器：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By using this function instead of creating the dispatcher manually, we can simply
    avoid small mistakes, such as forgetting to initialize the channel field. As you
    can see, the `b` argument refers to the buffer size in the channel.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个函数而不是手动创建分发器，我们可以简单地避免一些小错误，比如忘记初始化通道字段。正如你所见，`b`参数指的是通道中的缓冲区大小。
- en: The pipeline
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: 'So, our dispatcher is done and we need to develop the pipeline described in
    the acceptance criteria. First, we need a type to implement the `WorkerLauncher`
    type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的调度器已经完成，我们需要开发符合验收标准的管道。首先，我们需要一个类型来实现`WorkerLauncher`类型：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `PreffixSuffixWorker` variable stores an ID, a string to prefix, and another
    string to suffix the incoming data of the `Request` type. So, the values to prefix
    and append will be static in these fields, and we will take them from there.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreffixSuffixWorker`变量存储一个ID，一个要前缀的字符串，以及一个要后缀`Request`类型输入数据的另一个字符串。因此，要前缀和追加的值将在这两个字段中是静态的，我们将从那里获取它们。'
- en: 'We will implement the `LaunchWorker` method later and begin with each step
    in the pipeline. According to *first acceptance criteria*, the incoming string
    must be uppercase. So, the uppercase method will be the first step in our pipeline:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后实现`LaunchWorker`方法，并从管道中的每个步骤开始。根据*第一个验收标准*，输入的字符串必须是大写的。因此，大写方法将是我们的管道中的第一步：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Good. As in the previous chapter, a step in the pipeline accepts a channel of
    incoming data and returns a channel of the same type. It has a very similar approach
    to the examples we developed in the previous chapter. This time, though, we aren't
    using package functions, and uppercase is part of the `PreffixSuffixWorker` type
    and the incoming data is a `struct` instead of an `int`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。正如前一章中提到的，管道中的步骤接受一个输入数据通道，并返回一个相同类型的通道。它与我们前一章开发的例子有非常相似的方法。不过，这次我们并没有使用包函数，大写是`PreffixSuffixWorker`类型的一部分，而输入数据是一个`struct`而不是`int`。
- en: The `msg` variable is a `Request` type and it will have a handler function and
    data in the form of an interface. The `Data` field should be a string, so we type
    cast it before using it. When type casting a value, we will receive the same value
    with the requested type and a `true` or `false` flag (represented by the `ok`
    variable). If the `ok` variable is `false`, the cast could not be done and we
    won't throw the value down the pipeline. We stop this `Request` here by sending
    a `nil` to the handler (which will also provoke a type-casting error).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg`变量是`Request`类型，它将有一个处理函数和数据，数据形式为一个接口。`Data`字段应该是一个字符串，因此在使用它之前我们应该进行类型转换。当进行类型转换时，我们将收到请求的类型值和一个`true`或`false`标志（由`ok`变量表示）。如果`ok`变量是`false`，则无法进行转换，我们不会将值向下传递到管道中。我们通过向处理程序发送`nil`来停止这个`Request`（这也会引发类型转换错误）。'
- en: Once we have a nice string in the `s` variable, we can uppercase it and store
    it again in the `Data` field to send down the pipeline to the next step. Be aware
    that the value will be sent as an interface again, so the next step will need
    to cast it again. This is the downside of using this approach.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`s`变量中有一个好的字符串，我们就可以将其转换为大写，并将其再次存储在`Data`字段中，以便发送到管道的下一个步骤。请注意，值将再次作为接口发送，因此下一个步骤将需要再次进行类型转换。这是使用这种方法的一个缺点。
- en: 'With the first step done, let''s continue with the second. According to the
    *second acceptance criteria* now, a predefined text must be appended. This text
    is the one stored in the `suffixS` field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步完成后，让我们继续第二步。根据现在的*第二个验收标准*，必须追加一个预定义的文本。这个文本是存储在`suffixS`字段中的：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `append` function has the same structure as the `uppercase` function. It
    receives and returns a channel of incoming requests, and launches a new Goroutine
    that iterates over the incoming channel until it is closed. We need to type cast
    the incoming value, as mentioned previously.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`函数的结构与`uppercase`函数相同。它接收并返回一个输入请求通道，并启动一个新的Goroutine，该Goroutine迭代输入通道直到其关闭。我们需要像之前提到的那样对输入值进行类型转换。'
- en: In this step in the pipeline the incoming string is uppercase (after doing a
    type assertion). To append any text to it, we just need to use the `fmt.Sprintf()`
    function, as we have done many times before, which formats a new string with the
    provided data. In this case, we pass the value of the `suffixS` field as the second
    value, to append it to the end of the string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个管道步骤中，输入的字符串是大写的（在类型断言之后）。要向其追加任何文本，我们只需使用`fmt.Sprintf()`函数，就像我们之前多次做的那样，它使用提供的数据格式化一个新的字符串。在这种情况下，我们将`suffixS`字段的值作为第二个值传递，以将其追加到字符串的末尾。
- en: 'Just the last step in the pipeline is missing, the prefix operation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中只缺少最后一步，即前缀操作：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What's calling your attention in this function? Yes, it doesn't return any channel
    now. We could have done this entire pipeline in two ways. I suppose you have realized
    that we have used a `Future` handler function to execute with the final result
    in the pipeline. A second approach would be to pass a channel to return the data
    back to its origin. In some cases, a Future would be enough, while in others it
    could be more convenient to pass a channel so that it can be connected to a different
    pipeline (for example).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，什么引起了你的注意？是的，它现在不返回任何通道。我们可以用两种方式完成整个管道。我想你可能已经意识到我们在管道中使用了`Future`处理程序函数来执行最终结果。第二种方法是将通道传递回其原始位置。在某些情况下，`Future`可能足够，而在其他情况下，传递通道可能更方便，以便它可以连接到不同的管道（例如）。
- en: In any case, the structure of a step in a pipeline must be very familiar to
    you already. We cast the value, check the result of the casting, and send nil
    to the handler if anything went wrong. But, in case everything was OK, the last
    thing to do is to format the text again to place the `prefixS` field at the beginning
    of the text, to send the resulting string back to the origin by calling the request's
    handler.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，管道中步骤的结构对你来说应该已经很熟悉了。我们转换值，检查转换的结果，如果出现任何错误，则向处理器发送nil。但是，如果一切正常，最后要做的就是再次格式化文本，将`prefixS`字段放置在文本的开头，通过调用请求的处理程序将结果字符串发送回原始位置。
- en: 'Now, with our worker almost finished, we can implement the `LaunchWorker` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们的工作者几乎完成，我们可以实现`LaunchWorker`方法：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's all for workers! We simply pass the returning channels to the next steps
    in the Pipeline, as we did in the previous chapter. Remember that the pipeline
    is executed from inside to outside of the calls. So, what's the order of execution
    of any incoming data to the pipeline?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作者来说，这就结束了！我们只需将返回的通道传递到管道中的下一步，就像我们在上一章中所做的那样。记住，管道是从调用内部到外部执行的。那么，任何传入管道的数据的执行顺序是什么？
- en: The data enters the pipeline through the Goroutine launched in the `uppercase`
    method.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据通过在`uppercase`方法中启动的Goroutine进入管道。
- en: Then, it goes to the Goroutine launched in `append`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它进入在`append`中启动的Goroutine。
- en: Finally, in enters the Goroutine launched in `prefix` method, which doesn't
    return anything but executes the handler after prefixing the incoming string with
    more data.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它进入在`prefix`方法中启动的Goroutine，这个Goroutine不返回任何内容，但在给传入的字符串添加更多数据后执行处理器。
- en: Now we have a full pipeline and a dispatcher of pipelines. The dispatcher will
    launch as many instances of the pipelines as we want to route the incoming requests
    to any available worker.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完整的管道和管道分发器。分发器将启动尽可能多的管道实例，以便将传入的请求路由到任何可用的工作者。
- en: If none of the workers takes the request within 5 seconds, the request is lost.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在5秒内没有工作者接收请求，请求就会丢失。
- en: Let's use this library in a small app.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小型应用程序中使用这个库。
- en: An app using the workers pool
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作者池的应用程序
- en: 'We will launch three workers of our defined pipeline. We use the `NewDispatcher`
    function to create the dispatcher and the channel that will receive all requests.
    This channel has a fixed buffer, which will be able to store up to 100 incoming
    messages before blocking:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动我们定义的管道的三个工作者。我们使用`NewDispatcher`函数创建分发器和接收所有请求的通道。这个通道有一个固定的缓冲区，能够在阻塞之前存储多达100条传入的消息：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we will launch the workers by calling the `LaunchWorker` method in the
    `Dispatcher` interface three times with an already filled `WorkerLauncher` type:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过在`Dispatcher`接口中三次调用`LaunchWorker`方法并使用已经填充的`WorkerLauncher`类型来启动工作者：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each `WorkerLauncher` type is an instance of `PreffixSuffixWorker`. The prefix
    will be a small text showing the worker ID and the suffix text `world`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`WorkerLauncher`类型是`PreffixSuffixWorker`的一个实例。前缀将是一个显示工作者ID的小文本，后缀文本为`world`。
- en: 'At this point, we have three workers with three Goroutines, each running concurrently
    and waiting for messages to arrive:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们有了三个工作者和三个Goroutines，它们并发运行并等待消息的到来：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will make 10 requests. We also need a WaitGroup to properly synchronize
    the app so that it doesn''t exit too early. You can find yourself using WaitGroups
    quite a lot when dealing with concurrent applications. For 10 requests, we''ll
    need to wait for 10 calls to the `Done()` method, so we call the `Add()` method
    with a *delta* of 10\. It''s called delta because you can also pass a -5 later
    to leave it in five requests. In some situations, it can be useful:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发起10个请求。我们还需要一个WaitGroup来正确同步应用程序，以便它不会太早退出。当处理并发应用程序时，您可能会大量使用WaitGroups。对于10个请求，我们需要等待10次对`Done()`方法的调用，因此我们使用带有*增量*为10的`Add()`方法。它被称为增量，因为您也可以稍后传递-5，以使其在五个请求中完成。在某些情况下，这可能很有用：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To make requests, we will iterate a `for` loop. First, we create a `Request`
    using the function `NewStringRequest` that we wrote at the beginning of the Implementation
    section. In this value, the `Data` field will be the text we'll pass down the
    pipeline, and it will be the text that is "in the middle" of the appending and
    suffixing operation. In this case, we will send the message number and the word
    `hello`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发起请求，我们将迭代一个`for`循环。首先，我们使用我们在实现部分开头编写的函数`NewStringRequest`创建一个`Request`。在这个值中，`Data`字段将是我们将通过管道传递的文本，它将是追加和后缀操作中的“中间”文本。在这种情况下，我们将发送消息编号和单词`hello`。
- en: Once we have a request, we call the `MakeRequest` method with it. After all
    requests have been done, we stop the dispatcher that, as explained previously,
    will provoke a chain reaction that will stop all Goroutines in the pipeline.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到请求，我们就用它调用`MakeRequest`方法。完成所有请求后，我们停止调度器，正如之前解释的那样，这将引发连锁反应，停止管道中的所有Goroutines。
- en: 'Finally, we wait for the group so that all calls to the `Done()` method are
    received, which signals that all operations have been finished. It''s time to
    try it out:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待组，以便接收到所有对`Done()`方法的调用，这表示所有操作都已完成。现在是时候尝试一下了：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze the first message:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析第一条消息：
- en: 'This would be zero, so the message sent is `(Msg_id: 0) -> Hello`.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将是零，所以发送的消息是`(Msg_id: 0) -> Hello`。'
- en: 'Then, the text is uppercased, so now we have `(MSG_ID: 0) -> HELLO`.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，文本被转换为大写，所以我们现在有`(MSG_ID: 0) -> HELLO`。'
- en: 'After uppercasing an append operation with the text `world` (note the space
    at the beginning of the text) is done. This will give us the text `(MSG_ID: 0)
    -> HELLO World`.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在将带有文本`world`（注意文本开头的空格）的追加操作转换为大写后完成。这将给我们文本`(MSG_ID: 0) -> HELLO World`。'
- en: 'Finally, the text `WorkerID: 1` (in this case, the first worker took the task,
    but it could be any of them) is appended to the text from step 3 to give us the
    full returned message, `WorkerID: 1 -> (MSG_ID: 0) -> HELLO World`.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，将文本`WorkerID: 1`（在这种情况下，第一个工作器接受了任务，但可能是任何一个）追加到步骤3中的文本，以给出完整的返回消息，`WorkerID:
    1 -> (MSG_ID: 0) -> HELLO World`。'
- en: No tests?
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有测试吗？
- en: 'Concurrent applications are difficult to test, especially if you are doing
    networking operations. It can be difficult, and code can change a lot just to
    test it. In any case, it is not justifiable to not perform tests. In this case,
    it is not especially difficult to test our small app. Create a test and copy/paste
    the contents of the `main` function there:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序很难测试，尤其是如果您正在进行网络操作。这可能很困难，代码可能需要大量更改才能进行测试。在任何情况下，不进行测试都是不可取的。在这种情况下，测试我们的小应用程序并不特别困难。创建一个测试并将`main`函数的内容复制/粘贴到那里：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have to rewrite our handler to test that the returned contents are the
    ones we are expecting. Go to the `for` loop to modify the function that we are
    passing as a handler on each `Request`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须重写我们的处理程序来测试返回的内容是否是我们预期的。转到`for`循环来修改我们传递给每个`Request`的处理函数：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are going to use regular expressions to test the business. If you are not
    familiar with regular expressions, they are a quite powerful feature that help
    you to match content within a string. If you remember in our exercises when we
    were using the `strings` package. `Contains` is the function to find a text inside
    a string. We can also do it with regular expressions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用正则表达式来测试业务。如果您不熟悉正则表达式，它们是一种非常强大的功能，可以帮助您在字符串中匹配内容。如果您记得在我们的练习中，当我们在使用`strings`包时。`Contains`是用于在字符串中查找文本的函数。我们也可以使用正则表达式来做这件事。
- en: The problem is that regular expressions are quite expensive and consume a lot
    of resources.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于正则表达式相当昂贵，消耗大量资源。
- en: 'We are using the `Match` function of the `regexp` package to provide a template
    to match. Our template is `WorkerID\: \d* -> \(MSG_ID: \d\) -> [A-Z]*\sWorld`
    (without quotes). Specifically, it describes the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '我们正在使用`regexp`包的`Match`函数提供一个模板进行匹配。我们的模板是`WorkerID: \d* -> (MSG_ID: \d) ->
    [A-Z]*\sWorld`（不带引号）。具体来说，它描述了以下内容：'
- en: 'A string that has the content `WorkerID: \d* -> (MSG_ID: \d*", here "\d*` indicates
    any digit written zero or more times, so it will match `WorkerID: 10 -> (MSG_ID:
    1"` and `"WorkerID: 1 -> (MSG_ID: 10`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个包含内容`WorkerID: \d* -> (MSG_ID: \d*`的字符串，这里`"\d*"`表示零次或多次出现的任何数字，因此它将匹配`WorkerID:
    10 -> (MSG_ID: 1"`和`"WorkerID: 1 -> (MSG_ID: 10"`。'
- en: '`"\) -> [A-Z]*\sWorld"` (parentheses must be escaped using backslashes). "`*`"
    means any uppercase character written zero or more times, so `"\s"` is a white
    space and it must finish with the text `World`, so `) -> HELLO World"` will match,
    but `) -> Hello World"` won''t, because `"Hello` must be all uppercase.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"\) -> [A-Z]*\sWorld"`（括号必须使用反斜杠转义）。`"*"`表示零次或多次出现的任何大写字母，所以`"\s"`是一个空白字符，它必须以文本`World`结束，所以`)
    -> HELLO World"`将匹配，但`) -> Hello World"`不会匹配，因为`"Hello"`必须全部大写。'
- en: 'Running this test gives us the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试给出了以下输出：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Not bad, but we aren't testing that code is being executed concurrently, so
    this is more a business test than a unit test. Concurrency testing would force
    us to write the code in a completely different manner to check that it is creating
    the proper amount of Goroutines and the pipeline is following the expected workflow.
    This is not bad, but it's quite complex, and outside of the context of this book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，但我们并没有测试代码是否正在并发执行，所以这更像是业务测试而不是单元测试。并发测试将迫使我们以完全不同的方式编写代码，以检查它是否创建了正确数量的Goroutine，并且管道是否遵循预期的流程。这并不坏，但相当复杂，超出了本书的上下文。
- en: Wrapping up the Worker pool
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作者池的封装
- en: With the workers pool, we have our first complex concurrent application that
    can be used in real-world production systems. It also has room to improve, but
    it is a very good design pattern to build concurrent bounded apps.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工作者池，我们有了第一个复杂的并发应用程序，它可以用于现实世界的生产系统。它也有改进的空间，但这是一个非常好的设计模式来构建并发的有界应用程序。
- en: It is key that we always have the number of Goroutines that are being launched
    under control. While it's easy to launch thousands to achieve more parallelism
    in an app, we must be very careful that they don't have code that can hang them
    in an infinite loop, too.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是我们始终要控制正在启动的Goroutine的数量。虽然启动数千个Goroutine以在应用程序中实现更多并行性很容易，但我们必须非常小心，确保它们没有可能导致无限循环的代码。
- en: With the workers pool, we can now fragment a simple operation in many parallel
    tasks. Think about it; this could achieve the same result with one simple call
    to `fmt.Printf`, but we have done a pipeline with it; then, we launched few instances
    of this pipeline and finally, distributed the workload between all those pipes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工作者池，我们现在可以将一个简单操作分解成许多并行任务。想想看；这可以通过一个简单的`fmt.Printf`调用实现相同的结果，但我们已经通过它建立了一个管道；然后，我们启动了这个管道的几个实例，最后，将工作负载分配给所有这些管道。
- en: Concurrent Publish/Subscriber design pattern
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发发布/订阅设计模式
- en: In this section, we will implement the Observer design pattern that we showed
    previously on Behavioral patterns, but with a concurrent structure and thread
    safety.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现之前在行为模式中展示的观察者设计模式，但使用并发结构和线程安全。
- en: Description
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: 'If you remember from the previous explanation, the Observer pattern maintains
    a list of observers or subscribers that want to be notified of a particular event.
    In this case, each subscriber is going to run in a different Goroutine as well
    as the publisher. We will have new problems with building this structure:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得前面的解释，观察者模式维护一个观察者或订阅者列表，这些观察者或订阅者希望被通知特定事件。在这种情况下，每个订阅者将运行在不同的Goroutine中，以及发布者。我们将遇到构建这种结构的新问题：
- en: Now, the access to the list of subscribers must be serialized. If we are reading
    the list with one Goroutine, we cannot be removing a subscriber from it or we
    will have a race.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，对订阅者列表的访问必须进行序列化。如果我们用一个Goroutine读取列表，我们不能从其中移除订阅者，否则我们将遇到竞争条件。
- en: When a subscriber is removed, the subscriber's Goroutine must be closed too,
    or it will keep iterating forever and we will run into Goroutine leaks.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当订阅者被移除时，订阅者的Goroutine也必须关闭，否则它将无限迭代，我们将遇到Goroutine泄漏。
- en: When stopping the publisher, all subscribers must stop their Goroutines, too.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当停止发布者时，所有订阅者也必须停止它们的Goroutine。
- en: Objectives
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objectives of this publish/subscriber are the same as the ones we wrote
    on the Observer pattern. The difference here is the way we will develop it. The
    idea is to make a concurrent structure to achieve the same functionality, which
    is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅的目标与我们在观察者模式中写下的目标相同。这里的区别在于我们将如何开发它。理念是创建一个并发结构以实现相同的功能，具体如下：
- en: Providing an event-driven architecture where one event can trigger one or more
    actions
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个事件驱动的架构，其中一个事件可以触发一个或多个动作
- en: Uncoupling the actions that are performed from the event that triggers them
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦执行的动作与触发它们的动作
- en: Providing more than one source event that triggers the same action
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个源事件以触发相同的动作
- en: The idea is to uncouple senders from receivers, hiding from the sender the identity
    of the receivers that will process its event, and hiding the receivers from the
    number of senders that can communicate with them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将发送者与接收者解耦，对发送者隐藏将处理其事件的接收者身份，并隐藏接收者从可以与之通信的发送者数量。
- en: In particular, if I develop a click in a button in some application, it could
    do something (such as log us in somewhere). Weeks later, we might decide to make
    it show a popup, too. If, every time we want to add some functionality to this
    button, we have to change the code where it handles the click action, that function
    will become huge and not very portable to other projects. If we use a publisher
    and one observer for every action, the click function only needs to publish one
    single event using a publisher, and we will just write subscribers to this event
    every time we want to improve the functionality. This is especially important
    in applications with user interfaces where many things to do in a single UI action
    can slow the responsiveness of an interface, completely destroying the user experience.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果我在某个应用程序中的按钮上开发一个点击事件，它可能执行某些操作（例如登录到某个地方）。几周后，我们可能会决定让它显示一个弹出窗口。如果我们每次想要向这个按钮添加一些功能时，都必须更改处理点击动作的代码，那么这个函数将变得很大，并且不太适合其他项目。如果我们使用发布者和每个动作的一个观察者，点击函数只需要使用发布者发布一个单一的事件，每次我们想要改进功能时，我们只需为这个事件编写订阅者即可。这在具有用户界面的应用程序中尤为重要，因为单个UI动作中要执行的多项任务可能会降低界面的响应速度，完全破坏用户体验。
- en: By using a concurrent structure to develop the Observer pattern, a UI cannot
    feel all the tasks that are being executed in the background if a concurrent structure
    is defined and the device allows us to execute parallel tasks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用并发结构来开发观察者模式，如果定义了并发结构并且设备允许我们执行并行任务，UI就无法感觉到正在后台执行的所有任务。
- en: Example - a concurrent notifier
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 并发通知器
- en: We will develop a *notifier* similar to the one we developed in  [Chapter 7](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns"), *Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns*. This is to focus on the concurrent nature of the structure instead
    of detailing too many things that have already been explained. We have developed
    an observer already, so we are familiar with the concept.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个类似于我们在[第7章](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第7章。行为模式 - 访问者、状态、中介者和观察者设计模式")中开发的那个通知器，*行为模式 - 访问者、状态、中介者和观察者设计模式*。这是为了关注结构的并发性，而不是详细说明已经解释过的太多内容。我们已经开发了一个观察者，因此我们对这个概念很熟悉。
- en: This particular notifier will work by passing around `interface{}` values, like
    in the workers pool example. This way, we can use it for more than a single type
    by introducing some overhead when casting on the receiver.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的通知器将通过传递`interface{}`值来工作，就像在工作者池示例中一样。这样，我们可以通过在接收者上进行类型转换时引入一些开销，来使用它处理多种类型。
- en: 'We will work with two interfaces now. First, a `Subscriber` interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用两个接口。首先是一个`Subscriber`接口：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like in the previous example, it must have a `Notify` method in the `Subscriber`
    interface of new events. This is the `Notify` method that accepts an `interface{}`
    value and returns an error. The `Close()` method, however, is new, and it must
    trigger whatever actions are needed to stop the Goroutine where the subscriber
    is listening for new events.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的示例中一样，它必须在`Subscriber`接口中有一个`Notify`方法来处理新事件。这是接受`interface{}`值并返回错误的`Notify`方法。然而，`Close()`方法却是新的，它必须触发停止订阅者监听新事件的Goroutine所需的任何动作。
- en: 'The second and final interface is the `Publisher` interface:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个也是最后一个接口是`Publisher`接口：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Publisher` interface has the same actions we already know for a publisher
    but to work with channels. The `AddSubscriberCh` and `RemoveSubscriberCh` methods
    accepts a `Subscriber` interface (any type that satisfies the `Subscriber` interface).
    It must have a method to publish messages and a `Stop` method to stop them all
    (publisher and subscriber Goroutines)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`接口具有我们已知的发布者相同的操作，但与通道一起工作。`AddSubscriberCh`和`RemoveSubscriberCh`方法接受一个`Subscriber`接口（任何满足`Subscriber`接口的类型）。它必须有一个发布消息的方法和一个`Stop`方法来停止所有（发布者和订阅者Goroutine）。'
- en: Acceptance criteria
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'Requirements between this example and the one in the [Chapter 7](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns") *, Behavioral patterns - Visitor, State, Mediator, and Observer Design
    Patterns* must not change. The objective in both examples is the same so the requirements
    must also be the same. In this case, our requirements are technical, so we actually
    need to add some more acceptance criteria:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第7章](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd "第7章。行为模式
    - 访问者、状态、中介者和观察者设计模式") *行为模式 - 访问者、状态、中介者和观察者设计模式* 中的示例之间的要求必须保持不变。这两个示例的目标是相同的，因此要求也必须相同。在这种情况下，我们的要求是技术的，因此我们实际上需要添加一些额外的验收标准：
- en: We must have a publisher with a `PublishingCh` method that returns a channel
    to send messages through and triggers a `Notify` method on every observer subscribed.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个具有`PublishingCh`方法的发布者，该方法返回一个用于发送消息的通道，并在每个已订阅的观察者上触发`Notify`方法。
- en: We must have a method to add new subscribers to the publisher.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个方法来向发布者添加新订阅者。
- en: We must have a method to remove new subscribers from the publisher.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个方法来从发布者中移除新订阅者。
- en: We must have a method to stop a subscriber.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个方法来停止订阅者。
- en: We must have a method to stop a `Publisher` interface that will also stop all
    subscribers.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个方法来停止一个`Publisher`接口，这将也会停止所有订阅者。
- en: All inter Goroutine communication must be synchronized so that no Goroutine
    is locked waiting for a response. In such cases, an error is returned after the
    specified timeout period has passed.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有跨Goroutine通信必须同步，以确保没有Goroutine被锁定等待响应。在这种情况下，在指定超时时间过后返回错误。
- en: Well, these criteria seem quite daunting. We have left out some requirements
    that would add even more complexity, such as removing non-responding subscribers
    or checks to monitor that the publisher Goroutine is always on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这些标准似乎相当令人畏惧。我们省略了一些会增加更多复杂性的要求，例如移除无响应的订阅者或检查以监控发布者Goroutine始终处于活动状态。
- en: Unit test
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: We have mentioned previously that testing concurrent applications can be difficult.
    With the correct mechanism, it still can be done, so let's see how much we can
    test without big headaches.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，测试并发应用程序可能很困难。有了正确的机制，这仍然可以做到，所以让我们看看我们可以在不遇到大麻烦的情况下测试多少。
- en: Testing subscriber
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试订阅者
- en: 'Starting with subscribers, which seem to have a more encapsulated functionality,
    the first subscriber must print incoming messages from the publisher to an `io.Writer`
    interface. We have mentioned that the subscriber has an interface with two methods,
    `Notify(interface{}) error` and the `Close()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从订阅者开始，它们似乎具有更封装的功能，第一个订阅者必须将发布者传入的消息打印到`io.Writer`接口。我们之前提到，订阅者有一个接口，包含两个方法，`Notify(interface{})
    error`和`Close()`方法：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'OK. This is going to be our `writer_sub.go` file. Create the corresponding
    test file, called the `writer_sub_test.go` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这将是我们`writer_sub.go`文件。创建相应的测试文件，称为`writer_sub_test.go`文件：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, the first problem we have is that the functionality prints to the `stdout`,
    so there''s no return value to check. We can solve it in three ways:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们面临的首要问题是功能输出到`stdout`，因此没有返回值可以检查。我们可以用三种方法解决这个问题：
- en: Capturing the `stdout` method.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获`stdout`方法。
- en: Injecting an `io.Writer` interface to print to it. This is the preferred solution,
    as it makes the code more manageable.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入`io.Writer`接口以打印到它。这是首选解决方案，因为它使代码更易于管理。
- en: Redirecting the `stdout` method to a different file.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`stdout`方法重定向到不同的文件。
- en: 'We''ll take the second approach. Redirection is also a possibility. The `os.Stdout`
    is a pointer to an `os.File` type, so it involves replacing this file with one
    we control, and reading from it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取第二种方法。重定向也是一个可能的选择。`os.Stdout`是一个指向`os.File`类型的指针，因此这涉及到用我们控制的文件替换这个文件，并从中读取：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `NewWriterSubscriber` subscriber isn''t defined yet. It must help in the
    creation of this particular subscriber, returning a type that satisfies the `Subscriber`
    interface, so let''s quickly declare it on the `writer_sub.go` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewWriterSubscriber`订阅者尚未定义。它必须帮助创建这个特定的订阅者，返回一个满足`Subscriber`接口的类型，因此让我们快速在`writer_sub.go`文件中声明它：'
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Ideally, it must accept an ID and an `io.Writer` interface as the destination
    for its writes. In this case, we need a custom `io.Writer` interface for our test,
    so we''ll create a `mockWriter` on the `writer_sub_test.go` file for it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，它必须接受一个ID和一个`io.Writer`接口作为其写入的目的地。在这种情况下，我们需要为我们的测试创建一个自定义的`io.Writer`接口，因此我们将在`writer_sub_test.go`文件中创建一个`mockWriter`：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `mockWriter` structure will accept a `testingFunc` as one of its fields.
    This `testingFunc` field accepts a string that represents the bytes written to
    the `mockWriter` structure. To implement an `io.Writer` interface, we need to
    define a `Write([]byte) (int, error)` method. In our definition, we pass the contents
    of `p` as a string (remember that we always need to return the bytes read and
    an error, or not, on every `Write` method). This approach delegates the definition
    of `testingFunc` to the scope of the test.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockWriter`结构将接受一个`testingFunc`作为其字段之一。这个`testingFunc`字段接受一个表示写入到`mockWriter`结构的字节的字符串。为了实现`io.Writer`接口，我们需要定义一个`Write([]byte)
    (int, error)`方法。在我们的定义中，我们将`p`的内容作为字符串传递（记住，我们总是在每个`Write`方法上返回读取的字节数和错误，或者不返回错误）。这种方法将`testingFunc`的定义委托给测试的作用域。'
- en: 'We are going to call the `Notify` method on the `Subcriber` interface, which
    must write on the `io.Writer` interface like the `mockWriter` structure. So, we''ll
    define the `testingFunc` of a `mockWriter` structure before calling the `Notify`
    method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Subcriber`接口上调用`Notify`方法，这个接口必须像`mockWriter`结构一样实现`io.Writer`接口。因此，在调用`Notify`方法之前，我们将定义`mockWriter`结构的`testingFunc`：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will send the `Hello` message. This also means that whatever the `Subscriber`
    interface does, it must eventually print the `Hello` message on the provided `io.Writer`
    interface.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发送`Hello`消息。这也意味着无论`Subscriber`接口执行什么操作，它最终必须在提供的`io.Writer`接口上打印出`Hello`消息。
- en: So if, eventually, we receive a string on the testing function, we'll need to
    synchronize with the `Subscriber` interface to avoid race conditions on tests.
    That's why we use so much `WaitGroup`. It's a very handy and easy-to-use type
    to handle this scenario. One `Notify` method call will need to wait for one call
    to the `Done()` method, so we call the `Add(1)` method (with one unit).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果最终在测试函数中接收到一个字符串，我们需要与`Subscriber`接口同步，以避免测试中的竞态条件。这就是为什么我们使用了大量的`WaitGroup`。它是一个非常方便且易于使用的类型，用于处理这种情况。一个`Notify`方法调用将需要等待一个`Done()`方法调用，因此我们调用`Add(1)`方法（一个单位）。
- en: Ideally, the `NewWriterSubscriber` function must return an interface, so we
    need to type assert it to the type we are working with during the test, in this
    case, the `stdoutPrinter` method. I have omitted error checking when doing the
    casting on purpose, just to make things easier. Once we have a `writerSubscriber`
    type, we can access its `Write` field to replace it with the `mockWriter` structure.
    We could have directly passed an `io.Writer` interface on the `NewWriterSubscriber`
    function, but we wouldn't cover the scenario where a nil object is passed and
    it sets the `os.Stdout` instance to a default value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`NewWriterSubscriber`函数必须返回一个接口，因此我们需要在测试期间将其类型断言为我们正在使用的类型，在这种情况下是`stdoutPrinter`方法。我故意省略了类型转换时的错误检查，只是为了使事情变得简单。一旦我们有了`writerSubscriber`类型，我们就可以访问它的`Write`字段，并用`mockWriter`结构替换它。我们本可以直接在`NewWriterSubscriber`函数中传递一个`io.Writer`接口，但这样我们就无法覆盖传递nil对象并将其设置为默认值的场景。
- en: So, the testing function will eventually receive a string containing what was
    written by the subscriber. We just need to check if the received string, the one
    that the `Subscriber` interface will receive, prints the word `Hello` at some
    point and nothing better that `strings.Contains` function for it. Everything is
    defined under the scope of the testing function, so we can use the value of the
    `t` object to also signal that the test has failed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试函数最终将接收到一个包含订阅者写入内容的字符串。我们只需检查接收到的字符串，即`Subscriber`接口将接收到的字符串，在某个时刻是否打印了单词`Hello`，而对于这一点，`strings.Contains`函数是最好的选择。所有这些都定义在测试函数的作用域内，因此我们可以使用`t`对象的值来指示测试失败。
- en: 'Once we have done the checking, we must call to the `Done()` method to signal
    that we have already tested the expected result:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成检查，我们必须调用`Done()`方法来表示我们已经测试了预期的结果：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We must actually call the `Notify` and `Wait` methods for the call to the `Done`
    method to check that everything was correct.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上必须调用`Notify`和`Wait`方法来检查调用`Done`方法是否正确。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you realize that we have defined the behavior on tests more or less in reverse?
    This is very common in concurrent apps. It can be confusing sometimes, as it becomes
    difficult to know what a function could be doing if we can't follow calls linearly,
    but you get used to it quite quickly. Instead of thinking "it does this, then
    this, then that," it's more like "this will be called when executing that." This
    is also because the order of execution in a concurrent application is unknown
    until some point, unless we use synchronization primitives (such as WaitGroups
    and channels) to pause execution at certain moments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到我们没有在测试中定义行为，而是基本上是反过来的吗？这在并发应用程序中非常常见。有时可能会令人困惑，因为如果我们不能线性地跟踪调用，就很难知道一个函数可能正在做什么，但你会很快习惯它。与其“这样做，然后这样做，然后那样做”的想法不同，它更像是“当执行那个时将会调用这个”。这也是因为在并发应用程序中，执行顺序在某个点之前是未知的，除非我们使用同步原语（如WaitGroups和通道）在特定时刻暂停执行。
- en: 'Let''s execute the test for this type now:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来执行这个类型的测试：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It has exited fast but it has failed. Actually, the call to the `Done()` method
    has not been executed, so it would be nice to change the last part of our test
    to this instead:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 它快速退出但失败了。实际上，调用`Done()`方法尚未执行，所以最好将我们的测试的最后部分改为这样：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, it doesn't stop execution because we are calling the `Error` function instead
    of the `Fatal` function, but we call the `Done()` method and the test ends where
    we prefer it to end, after the `Wait()` method is called. You can try to run the
    tests again, but the output will be the same.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不会停止执行，因为我们调用的是`Error`函数而不是`Fatal`函数，但我们调用了`Done()`方法，测试就在我们希望结束的地方结束，在调用`Wait()`方法之后。你可以再次尝试运行测试，但输出将相同。
- en: Testing publisher
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试发布者
- en: 'We have already seen a `Publisher` interface and the type that will satisfy
    which was the `publisher` type. The only thing we know for sure is that it will
    need some way to store subscribers, so it will at least have a `Subscribers` slice:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`Publisher`接口以及将满足该接口的类型，即`publisher`类型。我们唯一确定的是它将需要某种方式来存储订阅者，因此它至少将有一个`Subscribers`切片：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To test the `publisher` type, we will also need a mock for the `Subscriber`
    interface:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`publisher`类型，我们还需要对`Subscriber`接口进行模拟：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `mockSubscriber` type must implement the `Subscriber` interface, so it must
    have a `Close()` and a `Notify(interface{}) error` method. We can embed an existing
    type that implements it, such as,  the `writerSubscriber`, and override just the
    method that is interesting for us, but we will need to define both, so we won't
    embed anything.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockSubscriber`类型必须实现`Subscriber`接口，因此它必须有一个`Close()`和一个`Notify(interface{})
    error`方法。我们可以嵌入一个实现它的现有类型，例如`writerSubscriber`，并仅覆盖对我们有意义的那个方法，但我们需要定义两个，所以我们不会嵌入任何东西。'
- en: 'So, we need to override the `Notify` and `Close` methods in this case to call
    the testing functions stored on the fields of the `mockSubscriber` type:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们需要重写`Notify`和`Close`方法来调用存储在`mockSubscriber`类型字段上的测试函数：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'First of all, we will be sending messages through channels directly, this could
    lead to potential unwanted deadlocks so the first thing to define is a panic handler
    for cases such as, sending to close channels or no Goroutines listening on a channel.
    The message we will send to subscribers is `Hello`. So, each subscriber that has
    been received using the channel returned by the `AddSubscriberCh` method must
    receive this message. We will also use a *New* function to create Publishers,
    called `NewPublisher`. Change the `publisher.go` file now to write it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过通道直接发送消息，这可能导致潜在的死锁，所以首先需要定义一个用于处理诸如向关闭的通道发送或没有Goroutines监听通道的情况的恐慌处理程序。我们将发送给订阅者的消息是`Hello`。因此，使用`AddSubscriberCh`方法返回的通道接收到的每个订阅者都必须接收到这条消息。我们还将使用一个名为`New`的函数来创建发布者，称为`NewPublisher`。现在将`publisher.go`文件更改如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we''ll define the `mockSubscriber` to add it to the publisher list of known
    subscribers. Back to the `publisher_test.go` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义`mockSubscriber`并将其添加到已知的订阅者列表中。回到`publisher_test.go`文件：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As usual, we start with a WaitGroup. First, testing the function in our subscriber
    defers a call to the `Done()` method at the end of its execution. Then it needs
    to type cast `msg` variable because it's coming as an interface. Remember that
    this way, we can use the `Publisher` interface with many types by introducing
    the overhead of the type assertion. This is done on line `s, ok := msg.(string)`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们从一个`WaitGroup`开始。首先，在订阅者函数执行结束时调用`Done()`方法。然后它需要将`msg`变量类型转换为字符串，因为它是一个接口。记住，这样我们就可以通过引入类型断言的开销，使用`Publisher`接口与许多类型一起使用。这是在行`s,
    ok := msg.(string)`上完成的。
- en: 'Once we have type cast `msg` to a string, `s`, we just need to check if the
    value received in the subscriber is the same as the value we sent, or fail the
    test if not:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将`msg`类型转换为字符串`s`，我们只需检查订阅者接收到的值是否与我们发送的值相同，如果不相同，则测试失败：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We add the `mockSubscriber` type using the `AddSubscriberCh` method. We publish
    our message just after getting ready, by adding one to the `WaitGroup`, and just
    before setting the `WaitGroup` to wait so that the test doesn't continue until
    the `mockSubscriber` type calls the `Done()` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AddSubscriberCh`方法添加`mockSubscriber`类型。我们准备好后立即发布消息，通过将`WaitGroup`加一，然后在设置`WaitGroup`等待之前，这样测试就不会继续，直到`mockSubscriber`类型调用`Done()`方法。
- en: 'Also, we need to check if the number of the `Subscriber` interface has grown
    after calling the `AddSubscriberCh` method, so we''ll need to get the concrete
    instance of publisher on the test:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要检查在调用`AddSubscriberCh`方法后，`Subscriber`接口的数量是否增加，因此我们需要在测试中获取发布者的具体实例：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Type assertion is our friend today! Once we have the concrete type, we can
    access the underlying slice of subscribers for the `Publisher` interface. The
    number of subscribers must be 1 after calling the `AddSubscriberCh` method once,
    or the test will fail. The next step is to check just the opposite--when we remove
    a `Subscriber` interface, it must be taken from this list:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言是我们今天的良友！一旦我们有了具体类型，我们就可以访问`Publisher`接口的底层订阅者切片。在调用`AddSubscriberCh`方法一次之后，订阅者的数量必须是1，否则测试将失败。下一步是检查相反的情况——当我们移除一个`Subscriber`接口时，它必须来自这个列表：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The final step in our test is to stop the publisher so no more messages can
    be sent and all the Goroutines are stopped.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的最终步骤是停止发布者，这样就不会再发送更多消息，并且所有协程都会停止。
- en: 'The test is finished, but we can''t run tests until the `publisher` type has
    all the methods implemented; this must be the final result:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已经完成，但我们不能运行测试，直到`publisher`类型实现了所有方法；这必须是最终结果：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With this empty implementation, nothing good can happen when running the tests:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个空实现，在运行测试时什么好事都不会发生：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Yes it has failed but, it's not a controlled fail at all. This was done on purpose
    to show a couple of things to be careful of in Go. First of all, the error produced
    in this test is a **fatal** error, which usually points to a bug in the code.
    This is important because while a **panic** error can be recovered, you cannot
    do the same with a fatal error.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它失败了，但这根本不是受控失败。这是故意为之，为了展示在Go中需要注意的一些事情。首先，这个测试中产生的错误是一个**致命**错误，通常指向代码中的错误。这很重要，因为虽然**panic**错误可以被恢复，但你不能对致命错误做同样的事情。
- en: 'In this case, the error is telling us the problem: `goroutine 5 [chan send
    (nil chan)]`, a nil channel so it''s actually a bug in our code. How can we solve
    this? Well, this is also interesting.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，错误告诉我们问题：`goroutine 5 [chan send (nil chan)]`，一个`nil`通道，这实际上是我们代码中的一个错误。我们如何解决这个问题？嗯，这也是很有趣的。
- en: The fact that we have a `nil` channel is caused by the code we wrote to compile
    unit tests but this particular error won't be raised once the appropriate code
    is written (because we'll never return a nil channel in this case). We could return
    a channel that is never use we cause a fatal error with a deadlock, which wouldn't
    be any progress at all either.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有一个`nil`通道的事实是由于我们编写的用于编译单元测试的代码造成的，但一旦编写了适当的代码，这个特定的错误就不会发生（因为我们永远不会在这种情况下返回一个`nil`通道）。我们可以返回一个永远不会使用的通道，这会导致死锁，从而根本没有任何进展。
- en: An idiomatic way to solve it would be to return a channel and an error so that
    you can have an error package with a type implementing the `Error` interface that
    returns a specific error such as `NoGoroutinesListening` or `ChannelNotCreated`.
    We have already seen many of this implementations so we'll leave these as an exercise
    to the reader and we will move forward to maintain focus on the concurrent nature
    of the chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个习惯用法是返回一个通道和一个错误，这样你就可以有一个包含实现`Error`接口的特定错误类型（如`NoGoroutinesListening`或`ChannelNotCreated`）的错误包。我们已经看到了许多这样的实现，所以我们将把这些留作读者的练习，并将继续前进，以保持对章节并发特性的关注。
- en: Nothing surprising there, so we can move to the implementation phase.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么令人惊讶的，所以我们可以进入实现阶段。
- en: Implementation
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: To recall, the `writerSubscriber` must receive messages that it will write on
    a type that satisfies the `io.Writer` interface.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，`writerSubscriber`必须接收它将写入满足`io.Writer`接口的类型上的消息。
- en: 'So, where do we start? Well, each subscriber will run its own Goroutine, and
    we have seen that the best method to communicate with a Goroutine is a channel.
    So, we will need a field with a channel in the `Subscriber` type. We can use the
    same approach as in pipelines to end with the `NewWriterSubscriber` function and
    the `writerSubscriber` type:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从哪里开始呢？嗯，每个订阅者都会运行自己的Goroutine，我们已经看到，与Goroutine通信的最佳方法是使用通道。因此，我们需要在`Subscriber`类型中有一个包含通道的字段。我们可以使用与管道中相同的方法，以`NewWriterSubscriber`函数和`writerSubscriber`类型结束：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the first step, if no writer is specified (the `out` argument is nil), the
    default `io.Writer` interface is `stdout`. Then, we create a new pointer to the
    `writerSubscriber` type with the ID passed in the first argument, the value of
    out (`os.Stdout`, or whatever came in the argument if it wasn't nil), and a channel
    called in to maintain the same naming as in previous examples.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，如果没有指定写入器（`out`参数为nil），则默认的`io.Writer`接口是`stdout`。然后，我们创建一个新的指向`writerSubscriber`类型的指针，该指针包含通过第一个参数传入的ID，`out`的值（`os.Stdout`，或者如果它不为nil，则传入的参数），以及一个名为`in`的通道，以保持与之前示例中的相同命名。
- en: Then we launch a new Goroutine; this is the launching mechanism we mentioned.
    Like in the pipelines, the subscriber will iterate over the `in` channel every
    time a new message is received and it will format its contents to a string, which
    also contains the ID of the current subscriber.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动一个新的Goroutine；这是我们之前提到的启动机制。就像在管道中一样，订阅者会在每次接收到新消息时遍历`in`通道，并将它的内容格式化为一个字符串，该字符串也包含当前订阅者的ID。
- en: 'As we learned previously, if the `in` channel is closed, the `for range` loop
    will stop and that particular Goroutine will finish, so the only thing we need
    to do in the `Close` method is to actually close the `in` channel:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，如果`in`通道被关闭，`for range`循环将停止，并且那个特定的Goroutine将结束，所以我们在`Close`方法中实际上需要做的只是关闭`in`通道：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'OK, only the `Notify` method is left; the `Notify` method is a convenient method
    to manage a particular behavior when communicating, and we will use a pattern
    that is common in many calls:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，只剩下`Notify`方法了；`Notify`方法是一个方便的方法，用于在通信时管理特定的行为，我们将使用在许多调用中常见的模式：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When communicating with a channel, there are two behavior that we must usually
    control: one is waiting time and the other is when the channel is closed. The
    deferred function actually works for any panicking error that can occur within
    the function. If the Goroutine panics, it will still execute the deferred function
    with the `recover()` method. The `recover()` method returns an interface of whatever
    the error was, so in our case, we set the returning variable error to the formatted
    value returned by `recover` (which is an interface). The `"%#v"` parameter gives
    us most of the information about any type when formatted to a string. The returned
    error will be ugly, but it will contain most of the information we can extract
    about the error. For a closed channel, for example, it will return "send on a
    closed channel". Well, this seems clear enough.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过通道进行通信时，我们必须通常控制两种行为：一种是等待时间，另一种是通道关闭时。延迟函数实际上适用于函数内部可能发生的任何恐慌错误。如果Goroutine发生恐慌，它仍然会使用`recover()`方法执行延迟函数。`recover()`方法返回一个表示错误的接口，所以在这种情况下，我们将返回变量`error`设置为`recover`返回的格式化值（它是一个接口）。`"%#v"`参数在格式化为字符串时提供了关于任何类型的大部分信息。返回的错误可能看起来很糟糕，但它将包含我们可以提取的大部分错误信息。例如，对于已关闭的通道，它将返回“在已关闭的通道上发送”。嗯，这似乎已经很清楚了。
- en: 'The second rule is about waiting time. When we send a value over a channel,
    we will be blocked until another Goroutine takes the value from it (it will happen
    the same with a filled buffered channel). We don''t want to get blocked forever,
    so we set a timeout period of one second by using a select handler. In short,
    with select we are saying: either you take the value in less than 1 second or
    I will discard it and return an error.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则是关于等待时间。当我们通过通道发送一个值时，我们将被阻塞，直到另一个Goroutine从其中取出值（在填充的缓冲通道中也会发生相同的情况）。我们不希望永远被阻塞，所以通过使用select处理程序设置了一个一秒钟的超时期。简而言之，通过select我们是在说：要么你在不到1秒内取走值，要么我将丢弃它并返回一个错误。
- en: 'We have the `Close`, `Notify`, and `NewWriterSubscriber` methods, so we can
    try our test again:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`Close`、`Notify`和`NewWriterSubscriber`方法，因此我们可以再次尝试我们的测试：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Much better now. The `Writer` has taken the mock writer we wrote on the test
    and has written to it the value we pass to the Notify method. At the same time,
    close has probably closed the channel effectively, because the `Notify` method
    is returning an error after calling the `Close` method. One thing to mention is
    that we can't check if a channel is closed or not without interacting with it;
    that's why we had to defer the execution of a closure that will check the contents
    of the `recover()` function in the `Notify` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了。`Writer`已经将我们在测试中编写的模拟写入器写入，并将我们传递给`Notify`方法的值写入其中。同时，关闭操作可能已经有效地关闭了通道，因为`Notify`方法在调用`Close`方法后返回了一个错误。有一点需要提及的是，我们无法在不与通道交互的情况下检查通道是否已关闭；这就是为什么我们必须延迟执行一个将检查`Notify`方法中`recover()`函数内容的闭包的执行。
- en: Implementing the publisher
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现发布者
- en: OK, the publisher will need also a launching mechanism, but the main problems
    to deal with are race conditions accessing the subscriber list. We can solve this
    issue with a Mutex object from the `sync` package but we have already seen how
    to use this so we will use channels instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，发布者还需要一个启动机制，但主要需要处理的问题是访问订阅者列表的竞态条件。我们可以使用`sync`包中的Mutex对象来解决这个问题，但我们已经看到了如何使用它，所以我们将使用通道。
- en: 'When using channels, we will need a channel for each action that can be considered
    dangerous--add a subscriber, remove a subscriber, retrieve the list of subscribers
    to `Notify` method them of a message, and a channel to stop all the subscribers.
    We also need a channel for incoming messages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用通道时，我们需要为每个可能被视为危险的操作创建一个通道——添加订阅者、移除订阅者、检索订阅者列表以通过`Notify`方法通知他们消息，以及一个用于停止所有订阅者的通道。我们还需要一个用于接收消息的通道：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Names are self-descriptive but, in short, subscribers maintain the list of subscribers;
    this is the slice that needs multiplexed access. The `addSubCh` instance is the
    channel to communicate with when you want to add a new subscriber; that's why
    it's a channel of subscribers. The same explanation applies to the `removeSubCh`
    channel, but this channel is to remove the subscriber. The `in` channel will handle
    incoming messages that must be broadcast to all subscribers. Finally, the stop
    channel must be called when we want to kill all Goroutines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 名称具有自描述性，但简而言之，订阅者维护订阅者列表；这是需要复用访问的切片。`addSubCh`实例是在你想添加新订阅者时与之通信的通道；这就是为什么它是一个订阅者通道。同样的解释也适用于`removeSubCh`通道，但这个通道用于移除订阅者。`in`通道将处理必须广播给所有订阅者的传入消息。最后，当我们想要终止所有Goroutine时，必须调用停止通道。
- en: 'OK, let''s start with the `AddSubscriberCh`, `RemoveSubscriber` and `PublishingCh`
    methods, which must return the channel to add and remove subscribers and the channel
    to send messages to all of them:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们从`AddSubscriberCh`、`RemoveSubscriber`和`PublishingCh`方法开始，这些方法必须返回用于添加和移除订阅者的通道以及用于向所有订阅者发送消息的通道：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Stop()` function the `stop` channel by closing it. This will effectively
    spread the signal to every listening Goroutine:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关闭`stop`通道来调用`Stop()`函数。这将有效地将信号传播到每个监听的Goroutine：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `Stop` method, the function to stop the publisher and the subscribers, also
    pushes to its respective channel, called stop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`方法，用于停止发布者和订阅者的函数，也将推送到其各自的通道，称为停止通道。'
- en: You may be wondering why we don't simply leave the channels available so that
    users push directly to this channel instead of using the proxying function. Well,
    the idea is that the user that integrates the library in their app doesn't have
    to deal with the complexity of the concurrent structure associated with the library,
    so they can focus on their business while maximizing performance as much as possible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不简单地将通道保持可用，让用户直接向这个通道推送，而不是使用代理功能。好吧，想法是，将库集成到他们的应用程序中的用户不需要处理与库相关的并发结构的复杂性，这样他们就可以专注于他们的业务，尽可能最大化性能。
- en: Handling channels without race conditions
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无竞态条件的通道处理
- en: Until now, we have forwarded data to the channels on the publisher but we haven't
    actually handled any of that data. The launcher mechanism that is going to launch
    a different Goroutine will handle them all.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将数据转发到发布者的通道上，但我们实际上并没有处理任何这些数据。将要启动不同Goroutine的启动机制将处理所有这些数据。
- en: 'We will create a launch method that we will execute by using the `go` keyword
    instead of embedding the whole function inside the `NewPublisher` function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个启动方法，我们将通过使用`go`关键字来执行它，而不是将整个函数嵌入到`NewPublisher`函数中：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`Launch` is a private method and we haven''t tested it. Remember that private
    methods are usually called from public methods (the ones we have tested). Generally,
    if a private method is not called from a public method, it can''t be called at
    all!'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Launch`是一个私有方法，我们还没有对其进行测试。记住，私有方法通常是从公共方法（我们已经测试过的方法）中调用的。通常，如果一个私有方法没有被公共方法调用，那么它根本不能被调用！'
- en: The first thing we notice with this method is that it is an infinite for loop
    that will repeat a select operation between many channels but only one of them
    can be executed each time. The first of these operations is the one that receives
    a new message to publish to subscribers. The `case msg := <- p.in:` code handles
    this incoming operation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到这个方法是一个无限循环，它将在许多通道之间重复执行选择操作，但每次只能执行其中一个。这些操作中的第一个是接收新消息以发布给订阅者的操作。`case
    msg := <- p.in:`代码处理这个传入的操作。
- en: 'In this case, we are iterating over all subscribers and executing their `Notify`
    method. You may be wondering why we don''t add the `go` keyword in front so that
    the `Notify` method is executed as a different Goroutine and therefore iterates
    much faster. Well, this because we aren''t demultiplexing the actions of receiving
    a message and of closing the message. So, if we launch the subscriber in a new
    Goroutine and it is closed while the message is processed in the `Notify` method,
    we''ll have a race condition where a message will try to be sent within the `Notify`
    method to a closed channel. In fact, we are considering this scenario when we
    develop the `Notify` method but, still, we won''t control the number of Goroutines
    launched if we call the `Notify` method in a new Goroutine each time. For simplicity,
    we just call the `Notify` method, but it is a nice exercise to control the number
    of Goroutines waiting for a return in a `Notify` method execution. By buffering
    the `in` channel in each subscriber, we can also achieve a good solution:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在遍历所有订阅者并执行它们的`Notify`方法。你可能想知道为什么我们不添加`go`关键字，以便`Notify`方法作为一个不同的Goroutine执行，因此迭代得更快。好吧，这是因为我们不是解耦接收消息和关闭消息的动作。所以，如果我们在一个新的Goroutine中启动订阅者，而它在`Notify`方法处理消息时被关闭，我们就会有一个竞态条件，其中消息将尝试在`Notify`方法中向一个已关闭的通道发送。实际上，我们在开发`Notify`方法时考虑了这种场景，但如果我们每次都调用一个新的Goroutine中的`Notify`方法，我们仍然无法控制启动的Goroutine的数量。为了简单起见，我们只是调用`Notify`方法，但控制`Notify`方法执行中等待返回的Goroutine数量是一个很好的练习。通过在每个订阅者中缓冲`in`通道，我们也可以实现一个好的解决方案：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The next operation is what to do when a value arrives to the channel to add
    subscribers. In this case it''s simple: we update it, appending the new value
    to it. While this case is executed, not other calls can be executed in this selection:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个操作是在值到达通道并添加订阅者时应该做什么。在这种情况下很简单：我们更新它，将其新值附加到它上面。当这个案例被执行时，在这个选择中不能执行其他调用：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When a value arrives at the remove channel, the operation is a bit more complex
    because we have to search for the subscriber in the slice. We use a *O(N)* approach
    for it, iterating from the beginning until we find it, but the search algorithm
    could be greatly improved. Once we find the corresponding `Subscriber` interface,
    we remove it from the subscribers slice and stop it. One thing to mention is that
    on tests, we are accessing the length of the subscribers slice directly without
    demultiplexing the operation. This is clearly a race condition, but generally,
    it isn't reflected when running the race detector.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值到达远程通道时，操作稍微复杂一些，因为我们必须在切片中搜索订阅者。我们使用*O(N)*方法来处理，从开始迭代直到找到它，但搜索算法可以大大改进。一旦找到相应的`Subscriber`接口，我们就从订阅者切片中移除它并停止它。有一点需要提及的是，在测试中，我们直接访问订阅者切片的长度，而没有解复用操作。这显然是一个竞争条件，但通常在运行竞争检测器时并不会反映出来。
- en: 'The solution will be to develop a method just to multiplex calls to get the
    length of the slice, but it won''t belong to the public interface. Again, for
    simplicity, we''ll leave it like this, or this example may become too complex
    to handle:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案将是开发一个专门用于解复用获取切片长度调用的方法，但它不会属于公共接口。再次强调，为了简单起见，我们将保持现状，否则这个示例可能会变得过于复杂而难以处理：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The last operation to demultiplex is the `stop` operation, which must stop all
    Goroutines in the publisher and subscribers. Then we have to iterate through every
    Subscriber stored in the subscribers field to execute their `Close()` method,
    so their Goroutines are closed, too. Finally, if we return this Goroutine, it
    will finish, too.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个解复用操作是`stop`操作，它必须停止发布者和订阅者中的所有Goroutines。然后我们必须遍历存储在订阅者字段中的每个`Subscriber`，以执行它们的`Close()`方法，这样它们的Goroutines也会关闭。最后，如果我们返回这个Goroutine，它也会结束。
- en: 'OK, time to execute all tests and see how is it going:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是时候执行所有测试，看看进展如何：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Not so bad. All tests have passed successfully and we have our Observer pattern
    ready. While the example can still be improved, it is a great example of how we
    must handle an Observer pattern using channels in Go. As an exercise, we encourage
    you to try the same example using mutexes instead of channels to control access.
    It's a bit easier, and will also give you an insight of how to work with mutexes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。所有测试都成功通过，我们已经准备好了观察者模式。虽然示例还可以改进，但它是一个很好的例子，展示了我们必须如何使用Go中的通道来处理观察者模式。作为练习，我们鼓励你尝试使用互斥锁而不是通道来控制访问的相同示例。这会稍微简单一些，也会让你了解如何与互斥锁一起工作。
- en: A few words on the concurrent Observer pattern
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于并发观察者模式的一些话
- en: This example has demonstrated how to take advantage of multi-core CPUs to build
    a concurrent message publisher by implementing the Observer pattern. While the
    example was long, we have tried to show a common pattern when developing concurrent
    apps in Go.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何利用多核CPU通过实现观察者模式来构建一个并发消息发布者。虽然示例很长，但我们试图展示在Go中开发并发应用程序时的一个常见模式。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have seen few approaches to develop concurrent structures that can be run
    in parallel. We have tried to show a few ways to solve the same problem, one without
    concurrency primitives and one with them. We have seen how different the publish/subscriber
    example written with a concurrent structure can be compared to the classic one.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一些开发可以并行运行并发结构的方法。我们尝试展示了解决相同问题的几种方法，一种没有并发原语，另一种有。我们看到了使用并发结构编写的发布/订阅示例与经典示例相比有多么不同。
- en: We have also seen how to build a concurrent operation using a pipeline and we
    have parallelize it by using a worker pool, a very common Go pattern to maximize
    parallelism.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何使用管道构建并发操作，并通过使用工作池来并行化它，这是Go中非常常见的一种模式，旨在最大化并行性。
- en: Both examples were simple enough to grasp, while digging as much as possible
    in to the nature of the Go language instead of in the problem itself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 两个示例都足够简单，易于理解，但在尽可能深入挖掘Go语言本质的同时，并没有深入到问题本身。
