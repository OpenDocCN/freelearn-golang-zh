- en: Chapter 2.  Adding User Accounts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章：添加用户账户
- en: The chat application we built in the previous chapter focused on high performance
    transmission of messages from the clients to the server and back again. However,
    the way things stand, our users have no way of knowing who they would be talking
    to. One solution to this problem is building some kind of sign-up and login functionality
    and letting our users create accounts and authenticate themselves before they
    can open the chat page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建的聊天应用专注于从客户端到服务器以及从服务器返回的高性能消息传输。然而，目前的情况是，我们的用户不知道他们将和谁交谈。解决这个问题的方法之一是构建某种注册和登录功能，并让我们的用户在打开聊天页面之前创建账户并验证身份。
- en: Whenever we are about to build something from scratch, we must ask ourselves
    how others have solved this problem before (it is extremely rare to encounter
    genuinely original problems) and whether any open solutions or standards already
    exist that we can make use of. Authorization and authentication can hardly be
    considered new problems, especially in the world of the Web, with many different
    protocols out there to choose from. So how do we decide the best option to pursue?
    As always, we must look at this question from the point of view of the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们准备从头开始构建某样东西时，我们必须问自己，别人之前是如何解决这个问题（真正原创的问题极其罕见）的，以及是否已经存在我们可以利用的开放解决方案或标准。授权和认证几乎不能被认为是新问题，尤其是在网络世界中，有许多不同的协议可供选择。那么我们如何决定最佳选择呢？一如既往，我们必须从用户的角度来看待这个问题。
- en: A lot of websites these days allow you to sign in using your accounts that exist
    elsewhere on a variety of social media or community websites. This saves users
    the tedious job of entering all of their account information over and over again
    as they decide to try out different products and services. It also has a positive
    effect on the conversion rates for new sites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多网站都允许你使用存在于各种社交媒体或社区网站上的账户进行登录。这节省了用户在决定尝试不同的产品和服务时，反复输入所有账户信息的繁琐工作。这对新网站的转化率也有积极的影响。
- en: In this chapter, we will enhance our chat codebase to add authorization, which
    will allow our users to sign in using Google, Facebook, or GitHub, and you'll
    see how easy it is to add other sign-in portals too. In order to join the chat,
    users must first sign in. Following this, we will use the authorized data to augment
    our user experience so everyone knows who is in the room and who said what.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将增强我们的聊天代码库以添加授权功能，这将允许我们的用户使用Google、Facebook或GitHub进行登录，你将看到添加其他登录端口是多么简单。为了加入聊天，用户必须首先登录。在此之后，我们将使用授权数据来增强用户体验，以便每个人都知道房间里是谁，谁说了什么。
- en: 'In this chapter, you will learn to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到：
- en: Use the decorator pattern to wrap `http.Handler` types in order to add additional
    functionality to handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器模式将`http.Handler`类型包装起来，以便为处理器添加额外的功能
- en: Serve HTTP endpoints with dynamic paths
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态路径提供HTTP端点
- en: Use the `gomniauth` open source project to access authentication services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`gomniauth`开源项目访问认证服务
- en: Get and set cookies using the `http` package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`http`包获取和设置cookie
- en: Encode objects as Base64 and back to normal again
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象编码为Base64，然后再将其转换回正常格式
- en: Send and receive JSON data over a web socket
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Websocket发送和接收JSON数据
- en: Give different types of data to templates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模板提供不同类型的数据
- en: Work with the channels of your own types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你自己的类型通道
- en: Handlers all the way down
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理到底
- en: For our chat application, we implemented our own `http.Handler` type (the room)
    in order to easily compile, execute, and deliver HTML content to browsers. Since
    this is a very simple but powerful interface, we are going to continue to use
    it wherever possible when adding functionality to our HTTP processing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的聊天应用，我们实现了自己的`http.Handler`类型（房间），以便轻松编译、执行并将HTML内容传递给浏览器。由于这是一个非常简单但功能强大的接口，我们在添加HTTP处理功能时将尽可能继续使用它。
- en: In order to determine whether a user is allowed to proceed, we will create an
    authorization wrapper handler that will perform the check and pass the execution
    on to the inner handler only if the user is authorized.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定用户是否有权继续操作，我们将创建一个授权包装处理器，该处理器将执行检查，并且只有当用户被授权时，才会将执行传递给内部处理器。
- en: Our wrapper handler will satisfy the same `http.Handler` interface as the object
    inside it, allowing us to wrap any valid handler. In fact, even the authentication
    handler we are about to write could be later encapsulated inside a similar wrapper
    if required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外部处理器将满足与内部对象相同的`http.Handler`接口，允许我们包装任何有效的处理器。实际上，我们即将编写的认证处理器也可以在需要时封装在类似的包装器中。
- en: '![Handlers all the way down](img/00046.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![层层处理](img/00046.jpeg)'
- en: Chaining pattern when applied to HTTP handlers
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应用到HTTP处理器的链式模式
- en: The preceding diagram shows how this pattern could be applied in a more complicated
    HTTP handler scenario. Each object implements the `http.Handler` interface. This
    means that an object could be passed to the `http.Handle` method to directly handle
    a request, or it can be given to another object, which could add some kind of
    extra functionality. The `Logging` handler may write to a log file before and
    after the `ServeHTTP` method is called on the inner handler. Because the inner
    handler is just another `http.Handler`, any other handler can be wrapped in (or
    decorated with) the `Logging` handler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了如何在更复杂的HTTP处理器场景中应用此模式。每个对象都实现了`http.Handler`接口。这意味着一个对象可以被传递给`http.Handle`方法以直接处理请求，或者它可以被提供给另一个对象，该对象可以添加某种额外功能。`Logging`处理器可能在调用内部处理器的`ServeHTTP`方法前后写入日志文件。因为内部处理器只是另一个`http.Handler`，任何其他处理器都可以被`Logging`处理器包装（或装饰）。
- en: It is also common for an object to contain logic that decides which inner handler
    should be executed. For example, our authentication handler will either pass the
    execution to the wrapped handler, or handle the request itself by issuing a redirect
    to the browser.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个对象会包含决定哪个内部处理器应该被执行的逻辑。例如，我们的认证处理器将传递执行给包装的处理器，或者通过向浏览器发出重定向来处理请求本身。
- en: 'That''s plenty of theory for now; let''s write some code. Create a new file
    called `auth.go` in the `chat` folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经有了足够的理论；让我们编写一些代码。在`chat`文件夹中创建一个名为`auth.go`的新文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `authHandler` type not only implements the `ServeHTTP` method (which satisfies
    the `http.Handler` interface), but also stores (wraps) `http.Handler` in the `next`
    field. Our `MustAuth` helper function simply creates `authHandler` that wraps
    any other `http.Handler`. This is the pattern that allows us to easily add authorization
    to our code in `main.go`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`authHandler`类型不仅实现了`ServeHTTP`方法（满足`http.Handler`接口），还在`next`字段中存储（包装）`http.Handler`。我们的`MustAuth`辅助函数简单地创建一个包装任何其他`http.Handler`的`authHandler`。这就是允许我们在`main.go`中轻松添加授权的模式的例子。'
- en: 'Let''s tweak the following root mapping line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整以下根映射行：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s change the first argument to make it explicit about the page meant for
    chatting. Next, let''s use the `MustAuth` function to wrap `templateHandler` for
    the second argument:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改第一个参数，使其明确表示用于聊天的页面。接下来，让我们使用`MustAuth`函数将`templateHandler`包装为第二个参数：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Wrapping `templateHandler` with the `MustAuth` function will cause the execution
    to run through `authHandler` first; it will run only to `templateHandler` if the
    request is authenticated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MustAuth`函数包装`templateHandler`会导致执行首先通过`authHandler`；如果请求已认证，它将只运行到`templateHandler`。
- en: The `ServeHTTP` method in `authHandler` will look for a special cookie called
    `auth`, and it will use the `Header` and `WriteHeader` methods on `http.ResponseWriter`
    to redirect the user to a login page if the cookie is missing. Notice that we
    discard the cookie itself using the underscore character and capture only the
    returning error; this is because we only care about whether the cookie is present
    at this point.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`authHandler`中的`ServeHTTP`方法会寻找一个名为`auth`的特殊cookie，如果cookie缺失，它将使用`http.ResponseWriter`上的`Header`和`WriteHeader`方法将用户重定向到登录页面。请注意，我们使用下划线字符丢弃cookie本身，只捕获返回的错误；这是因为在这个阶段我们只关心cookie是否存在。'
- en: 'Build and run the chat application and try to hit `http://localhost:8080/chat`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行聊天应用程序，尝试访问`http://localhost:8080/chat`：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You need to delete your cookies to clear out previous authentication tokens
    or any other cookies that might be left over from other development projects served
    through the localhost.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要删除您的cookies以清除之前的认证令牌或任何可能遗留在通过localhost提供其他开发项目的其他cookies。
- en: If you look in the address bar of your browser, you will notice that you are
    immediately redirected to the `/login` page. Since we cannot handle that path
    yet, you'll just get a **404 page not found** error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看浏览器地址栏，您会注意到您立即被重定向到`/login`页面。由于我们目前无法处理该路径，您将只会得到**404页面未找到**错误。
- en: Making a pretty social sign-in page
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作一个漂亮的社交登录页面
- en: So far, we haven't paid much attention to making our application look nice;
    after all, this book is about Go and not user interface development. However,
    there is no excuse for building ugly apps, and so we will build a social sign-in
    page that is as pretty as it is functional.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们并没有太多关注使我们的应用程序看起来很漂亮；毕竟，这本书是关于 Go 语言，而不是用户界面开发。然而，没有理由去构建丑陋的应用程序，因此我们将构建一个既美观又实用的社交登录页面。
- en: Bootstrap is a frontend framework for developing responsive projects on the
    Web. It provides CSS and JavaScript code that solve many user interface problems
    in a consistent and good-looking way. While sites built using Bootstrap tend to
    look the same (although there are a plenty of ways in which the UI can be customized),
    it is a great choice for early versions of apps or for developers who don't have
    access to designers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个用于在网络上开发响应式项目的前端框架。它提供了 CSS 和 JavaScript 代码，以一致且美观的方式解决许多用户界面问题。虽然使用
    Bootstrap 构建网站往往看起来很相似（尽管有众多方法可以自定义 UI），但它对于应用程序的早期版本或没有设计师的开发商来说是一个很好的选择。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you build your application using the semantic standards set forth by Bootstrap,
    it will become easy for you to make a Bootstrap theme for your site or application,
    and you know it will slot right into your code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Bootstrap 提出的语义标准构建你的应用程序，那么为你的网站或应用程序创建一个 Bootstrap 主题将变得容易，而且你知道它将完美地嵌入到你的代码中。
- en: We will use the version of Bootstrap hosted on a CDN so we don't have to worry
    about downloading and serving our own version through our chat application. This
    means that in order to render our pages properly, we will need an active Internet
    connection even during development.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用托管在 CDN 上的 Bootstrap 版本，这样我们就不必担心通过我们的聊天应用程序下载和提供自己的版本。这意味着为了正确渲染我们的页面，即使在开发过程中，我们也需要一个活跃的互联网连接。
- en: 'If you prefer to download and host your own copy of Bootstrap, you can do so.
    Keep the files in an `assets` folder and add the following call to your `main`
    function (it uses `http.Handle` to serve the assets via your application):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢下载并托管你自己的 Bootstrap 版本，你可以这样做。将文件保存在一个 `assets` 文件夹中，并在你的 `main` 函数中添加以下调用（它使用
    `http.Handle` 通过你的应用程序提供资源）：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the `http.StripPrefix` and `http.FileServer` functions return objects
    that satisfy the `http.Handler` interface as per the decorator pattern that we
    implement with our `MustAuth` helper function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `http.StripPrefix` 和 `http.FileServer` 函数返回的对象满足我们通过 `MustAuth` 辅助函数实现的装饰器模式中的
    `http.Handler` 接口。
- en: 'In `main.go`, let''s add an endpoint for the login page:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，让我们为登录页面添加一个端点：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Obviously, we do not want to use the `MustAuth` method for our login page because
    it will cause an infinite redirection loop.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不希望在我们的登录页面中使用 `MustAuth` 方法，因为它将导致无限重定向循环。
- en: 'Create a new file called `login.html` inside our `templates` folder and insert
    the following HTML code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `templates` 文件夹内创建一个名为 `login.html` 的新文件，并插入以下 HTML 代码：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Restart the web server and navigate to `http://localhost:8080/login`. You will
    notice that it now displays our **Sign in** page:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动网络服务器并导航到 `http://localhost:8080/login`。你会注意到现在它显示了我们的 **登录** 页面：
- en: '![Making a pretty social sign-in page](img/00047.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![制作一个漂亮的社交登录页面](img/00047.jpeg)'
- en: Endpoints with dynamic paths
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路径的端点
- en: 'Pattern matching for the `http` package in the Go standard library isn''t the
    most comprehensive and fully featured implementation out there. For example, Ruby
    on Rails makes it much easier to have dynamic segments inside the path. You could
    map the route like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库中 `http` 包的匹配模式并不是最全面和功能最丰富的实现。例如，Ruby on Rails 使得在路径中拥有动态段变得容易得多。你可以像这样映射路由：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rails then provides a data map (or dictionary) containing the values that it
    automatically extracted from the matched path. So if you visit `auth/login/google`,
    then `params[:provider_name]` would equal `google` and `params[:action]` would
    equal `login`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 然后提供了一个数据映射（或字典），其中包含它从匹配的路径中自动提取的值。所以如果你访问 `auth/login/google`，那么 `params[:provider_name]`
    将等于 `google`，而 `params[:action]` 将等于 `login`。
- en: 'The most the `http` package lets us specify by default is a path prefix, which
    we can make use of by leaving a trailing slash at the end of the pattern:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 包默认允许我们指定的最多是路径前缀，我们可以通过在模式末尾留下一个尾随斜杠来利用它：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We would then have to manually parse the remaining segments to extract the
    appropriate data. This is acceptable for relatively simple cases. This suits our
    needs for the time being since we only need to handle a few different paths, such
    as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须手动解析剩余的段以提取适当的数据。这对于相对简单的情况是可以接受的。由于我们目前只需要处理几个不同的路径，例如以下路径，这符合我们的需求：
- en: '`/auth/login/google`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/google`'
- en: '`/auth/login/facebook`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/facebook`'
- en: '`/auth/callback/google`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/callback/google`'
- en: '`/auth/callback/facebook`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/callback/facebook`'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to handle more advanced routing situations, you may want to consider
    using dedicated packages, such as `goweb`, `pat`, `routes`, or `mux`. For extremely
    simple cases such as ours, built-in capabilities will do.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要处理更高级的路由情况，您可能需要考虑使用专用包，例如`goweb`、`pat`、`routes`或`mux`。对于像我们这样极其简单的情况，内置功能就足够了。
- en: 'We are going to create a new handler that powers our login process. In `auth.go`,
    add the following `loginHandler` code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的处理器来驱动我们的登录过程。在`auth.go`中添加以下`loginHandler`代码：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we break the path into segments using `strings.Split`
    before pulling out the values for `action` and `provider`. If the action value
    is known, we will run the specific code; otherwise, we will write out an error
    message and return an `http.StatusNotFound` status code (which in the language
    of HTTP status code is `404`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在提取`action`和`provider`的值之前，使用`strings.Split`将路径分解成段。如果已知动作值，我们将运行特定的代码；否则，我们将输出错误信息并返回一个`http.StatusNotFound`状态码（在HTTP状态码的术语中是`404`）。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not bulletproof our code right now. But it's worth noticing that if
    someone hits `loginHandler` with few segments, our code will panic because it
    would expect `segs[2]` and `segs[3]` to exist.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会使代码无懈可击。但值得注意的是，如果有人用少量段击中`loginHandler`，我们的代码会崩溃，因为它会期望`segs[2]`和`segs[3]`存在。
- en: For extra credit, see whether you can protect your code against this and return
    a nice error message instead of making it panic if someone hits `/auth/nonsense`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外加分项，看看您是否能保护您的代码免受此影响，并在有人击中`/auth/nonsense`时返回一个友好的错误消息而不是让它崩溃。
- en: 'Our `loginHandler` is only a function and not an object that implements the
    `http.Handler` interface. This is because, unlike other handlers, we don''t need
    it to store any state. The Go standard library supports this, so we can use the
    `http.HandleFunc` function to map it in a way similar to how we used `http.Handle`
    earlier. In `main.go`, update the handlers:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`loginHandler`只是一个函数，而不是实现`http.Handler`接口的对象。这是因为，与其他处理器不同，我们不需要它存储任何状态。Go标准库支持这一点，因此我们可以使用`http.HandleFunc`函数以类似于我们之前使用`http.Handle`的方式将其映射。在`main.go`中更新处理器：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rebuild and run the chat application:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行聊天应用：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Hit the following URLs and notice the output logged in the terminal:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下URL并注意终端中记录的输出：
- en: '`http://localhost:8080/auth/login/google` outputs `TODO handle login for google`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/auth/login/google`输出`TODO handle login for google`'
- en: '`http://localhost:8080/auth/login/facebook` outputs `TODO handle login for
    facebook`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/auth/login/facebook`输出`TODO handle login for facebook`'
- en: We have successfully implemented a dynamic path-matching mechanism that just
    prints out `TODO` messages so far; we need to integrate it with authorization
    services in order to make our login process work.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功实现了一个动态路径匹配机制，到目前为止只是打印出`TODO`消息；我们需要将其与授权服务集成，以便使我们的登录过程生效。
- en: Getting started with OAuth2
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用OAuth2
- en: OAuth2 is an open authorization standard designed to allow resource owners to
    give clients delegated access to private data (such as wall posts or tweets) via
    an access token exchange handshake. Even if you do not wish to access the private
    data, OAuth2 is a great option that allows people to sign in using their existing
    credentials, without exposing those credentials to a third-party site. In this
    case, we are the third party, and we want to allow our users to sign in using
    services that support OAuth2.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2是一个开放授权标准，旨在允许资源所有者通过访问令牌交换握手，允许客户端代表访问私有数据（如墙贴或推文）。即使您不想访问私有数据，OAuth2也是一个很好的选择，允许人们使用现有的凭据登录，而不必将这些凭据暴露给第三方网站。在这种情况下，我们是第三方，我们希望允许我们的用户使用支持OAuth2的服务登录。
- en: 'From a user''s point of view, the OAuth2 flow is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，OAuth2流程如下：
- en: The user selects the provider with whom they wish to sign in to the client app.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择他们希望登录到客户端应用的提供商。
- en: The user is redirected to the provider's website (with a URL that includes the
    client app ID) where they are asked to give permission to the client app.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将被重定向到提供者的网站（包含客户端应用 ID 的 URL），在那里他们被要求允许客户端应用。
- en: The user signs in from the OAuth2 service provider and accepts the permissions
    requested by the third-party application.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从 OAuth2 服务提供者登录并接受第三方应用请求的权限。
- en: The user is redirected to the client app with a request code.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将被重定向到客户端应用，并带有请求代码。
- en: In the background, the client app sends the grant code to the provider, who
    sends back an authentication token.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台，客户端应用将授权代码发送给提供者，提供者发送回一个身份验证令牌。
- en: The client app uses the access token to make authorized requests to the provider,
    such as to get user information or wall posts.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用使用访问令牌向提供者发送授权请求，例如获取用户信息或墙帖子。
- en: To avoid reinventing the wheel, we will look at a few open source projects that
    have already solved this problem for us.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复造轮子，我们将查看一些已经为我们解决这个问题的一些开源项目。
- en: Open source OAuth2 packages
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源 OAuth2 包
- en: Andrew Gerrand has been working on the core Go team since February 2010, that
    is, two years before Go 1.0 was officially released. His `goauth2` package (see
    [https://github.com/golang/oauth2](https://github.com/golang/oauth2)) is an elegant
    implementation of the OAuth2 protocol written entirely in Go.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安德鲁·杰拉德自 2010 年 2 月以来一直在核心 Go 团队工作，即在 Go 1.0 正式发布前两年。他的 `goauth2` 包（见 [https://github.com/golang/oauth2](https://github.com/golang/oauth2)）是
    OAuth2 协议的一个优雅实现，完全用 Go 编写。
- en: Andrew's project inspired `gomniauth` (see [https://github.com/stretchr/gomniauth](https://github.com/stretchr/gomniauth)).
    An open source Go alternative to Ruby's `omniauth` project, `gomniauth` provides
    a unified solution to access different OAuth2 services. In the future, when OAuth3
    (or whatever the next-generation authorization protocol will be) comes out, in
    theory `gomniauth` could take on the pain of implementing the details, leaving
    the user code untouched.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安德鲁的项目启发了 `gomniauth`（见 [https://github.com/stretchr/gomniauth](https://github.com/stretchr/gomniauth)）。作为
    Ruby 的 `omniauth` 项目的开源 Go 替代方案，`gomniauth` 提供了一个统一的解决方案来访问不同的 OAuth2 服务。在未来，当
    OAuth3（或下一代授权协议）出现时，理论上 `gomniauth` 可以承担实现细节的痛苦，而用户代码保持不变。
- en: 'For our application, we will use `gomniauth` to access OAuth services provided
    by Google, Facebook, and GitHub, so make sure you have it installed by running
    the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们将使用 `gomniauth` 来访问 Google、Facebook 和 GitHub 提供的 OAuth 服务，因此请确保您已通过运行以下命令安装它：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some of the project dependencies of `gomniauth` are kept in Bazaar repositories,
    so you'll need to head over to [http://wiki.bazaar.canonical.com](http://wiki.bazaar.canonical.com)
    to download them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`gomniauth` 的一些项目依赖项保存在 Bazaar 存储库中，因此您需要前往 [http://wiki.bazaar.canonical.com](http://wiki.bazaar.canonical.com)
    下载它们。'
- en: Tell the authorization providers about your app
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告知授权提供者您的应用信息
- en: 'Before we ask an authorization provider to help our users sign in, we must
    tell them about our application. Most providers have some kind of web tool or
    console where you can create applications to kick this process off. Here''s one
    from Google:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们请求授权提供者帮助我们的用户登录之前，我们必须告诉他们关于我们的应用信息。大多数提供者都有某种类型的网络工具或控制台，您可以在其中创建应用以启动此过程。以下是一个来自
    Google 的示例：
- en: '![Tell the authorization providers about your app](img/00048.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![告知授权提供者您的应用信息](img/00048.jpeg)'
- en: In order to identify the client application, we need to create a client ID and
    secret. Despite the fact that OAuth2 is an open standard, each provider has their
    own language and mechanism to set things up. Therefore, you will most likely have
    to play around with the user interface or the documentation to figure it out in
    each case.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别客户端应用，我们需要创建一个客户端 ID 和密钥。尽管 OAuth2 是一个开放标准，但每个提供者都有自己的语言和机制来设置这些内容。因此，您很可能会不得不在每个案例中与用户界面或文档进行交互来找出解决方案。
- en: At the time of writing, in **Google Cloud Console**, you navigate to **API Manager**
    and click on the **Credentials** section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，在 **Google Cloud Console** 中，您需要导航到 **API Manager** 并点击 **Credentials**
    部分。
- en: In most cases, for added security, you have to be explicit about the host URLs
    from where requests will come. For now, since we're hosting our app locally on
    `localhost:8080`, you should use it. You will also be asked for a redirect URI
    that is the endpoint in our chat application and to which the user will be redirected
    after they successfully sign in. The callback will be another action in `loginHandler`,
    so the redirect URL for the Google client will be `http://localhost:8080/auth/callback/google`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为了增加安全性，你必须明确指定请求将来自哪个主机URL。目前，由于我们正在本地托管我们的应用在`localhost:8080`，你应该使用它。你还将被要求提供一个重定向URI，这是我们聊天应用中的端点，用户在成功登录后将被重定向到该端点。回调将是`loginHandler`中的另一个操作，因此Google客户端的重定向URL将是`http://localhost:8080/auth/callback/google`。
- en: Once you finish the authorization process for the providers you want to support,
    you will be given a client ID and secret for each provider. Make a note of these
    details because we will need them when we set up the providers in our chat application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了你想要支持的提供者的授权过程，你将为每个提供者获得一个客户端ID和密钥。请记住这些详细信息，因为在我们设置聊天应用中的提供者时我们需要它们。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we host our application on a real domain, we have to create new client IDs
    and secrets or update the appropriate URL fields on our authorization providers
    to ensure that they point to the right place. Either way, it is good practice
    to have a different set of development and production keys for security.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的应用程序托管在真实域名上，我们必须创建新的客户端ID和密钥，或者更新我们的授权提供者上的适当URL字段，以确保它们指向正确的位置。无论如何，为了安全起见，拥有不同的一套开发和生产密钥是良好的实践。
- en: Implementing external logging in
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现外部日志记录
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should replace the `key` and `secret` placeholders with the actual values
    you noted down earlier. The third argument represents the callback URL that should
    match the ones you provided when creating your clients on the provider's website.
    Notice the second path segment is `callback`; while we haven't implemented this
    yet, this is where we handle the response from the authorization process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该用你之前记录的实际值替换`key`和`secret`占位符。第三个参数代表回调URL，它应该与你在提供者网站上创建客户端时提供的URL相匹配。注意第二个路径段是`callback`；虽然我们还没有实现它，但这是我们处理授权过程响应的地方。
- en: 'As usual, you will need to ensure all the appropriate packages are imported:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你需要确保所有适当的包都已导入：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Gomniauth requires the `SetSecurityKey` call because it sends state data between
    the client and server along with a signature checksum, which ensures that the
    state values are not tempered with while being transmitted. The security key is
    used when creating the hash in a way that it is almost impossible to recreate
    the same hash without knowing the exact security key. You should replace `some
    long key` with a security hash or phrase of your choice.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth需要`SetSecurityKey`调用，因为它在客户端和服务器之间发送带有签名校验和的状态数据，这确保了状态值在传输过程中没有被篡改。安全密钥在创建哈希时使用，使得不知道确切的安全密钥几乎不可能重新创建相同的哈希。你应该用你选择的密钥或短语替换`some
    long key`。
- en: Logging in
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录
- en: 'Now that we have configured Gomniauth, we need to redirect users to the provider''s
    authorization page when they land on our `/auth/login/{provider}` path. We just
    have to update our `loginHandler` function in `auth.go`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Gomniauth，当用户到达我们的`/auth/login/{provider}`路径时，我们需要将用户重定向到提供者的授权页面。我们只需更新`auth.go`中的`loginHandler`函数：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We do two main things here. First, we use the `gomniauth.Provider` function
    to get the provider object that matches the object specified in the URL (such
    as `google` or `github`). Then, we use the `GetBeginAuthURL` method to get the
    location where we must send users to in order to start the authorization process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们做两件主要的事情。首先，我们使用`gomniauth.Provider`函数来获取与URL中指定的对象（如`google`或`github`）匹配的提供者对象。然后，我们使用`GetBeginAuthURL`方法来获取我们必须将用户发送到以启动授权过程的位置。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetBeginAuthURL(nil, nil)` arguments are for the state and options respectively,
    which we are not going to use for our chat application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetBeginAuthURL(nil, nil)`参数分别代表状态和选项，我们不会在我们的聊天应用中使用它们。'
- en: The first argument is a state map of data that is encoded and signed and sent
    to the authentication provider. The provider doesn't do anything with the state;
    it just sends it back to our callback endpoint. This is useful if, for example,
    we want to redirect the user back to the original page they were trying to access
    before the authentication process intervened. For our purpose, we have only the
    `/chat` endpoint, so we don't need to worry about sending any state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个编码并签名的数据状态映射，它被发送到认证提供者。提供者不对状态做任何处理；它只是将其发送回我们的回调端点。如果，例如，我们希望用户在认证过程介入之前返回他们尝试访问的原始页面，这很有用。对于我们的目的，我们只有`/chat`端点，所以我们不需要担心发送任何状态。
- en: The second argument is a map of additional options that will be sent to the
    authentication provider, which somehow modifies the behavior of the authentication
    process. For example, you can specify your own `scope` parameter, which allows
    you to make a request for permission to access additional information from the
    provider. For more information about the available options, search for OAuth2
    on the Internet or read the documentation for each provider, as these values differ
    from service to service.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个包含额外选项的映射，这些选项将被发送到认证提供者，从而以某种方式修改认证过程的行为。例如，您可以指定自己的`scope`参数，这允许您请求访问提供者额外信息的权限。有关可用选项的更多信息，请在互联网上搜索OAuth2，或阅读每个提供者的文档，因为这些值因服务而异。
- en: If our code gets no error from the `GetBeginAuthURL` call, we simply redirect
    the user's browser to the returned URL.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的代码在`GetBeginAuthURL`调用中没有收到错误，我们只需将用户的浏览器重定向到返回的URL。
- en: If errors occur, we use the `http.Error` function to write the error message
    out with a `non-200` status code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，我们使用`http.Error`函数以`非200`状态码输出错误信息。
- en: 'Rebuild and run the chat application:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行聊天应用程序：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We will continue to stop, rebuild, and run our projects manually throughout
    this book, but there are some tools that will take care of this for you by watching
    for changes and restarting Go applications automatically. If you're interested
    in such tools, check out [https://github.com/pilu/fresh](https://github.com/pilu/fresh)
    and [https://github.com/codegangsta/gin](https://github.com/codegangsta/gin).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中继续手动停止、重新构建和运行我们的项目，但有一些工具会通过监视更改并自动重新启动Go应用程序来为您处理这些操作。如果您对此类工具感兴趣，请查看[https://github.com/pilu/fresh](https://github.com/pilu/fresh)和[https://github.com/codegangsta/gin](https://github.com/codegangsta/gin)。
- en: 'Open the main chat page by accessing `http://localhost:8080/chat`. As we aren''t
    logged in yet, we are redirected to our sign-in page. Click on the **Google**
    option to sign in using your Google account and you will notice that you are presented
    with a Google-specific sign-in page (if you are not already signed in to Google).
    Once you are signed in, you will be presented with a page asking you to give permission
    for our chat application before you can view basic information about your account:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`http://localhost:8080/chat`打开主聊天页面。由于我们尚未登录，我们被重定向到登录页面。点击**Google**选项使用您的Google账户登录，您会注意到您被展示了一个特定的Google登录页面（如果您尚未登录到Google）。一旦登录，您将看到一个页面，要求您在查看您账户的基本信息之前允许我们的聊天应用程序：
- en: '![Logging in](img/00049.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![登录](img/00049.jpeg)'
- en: This is the same flow that the users of our chat application will experience
    when signing in.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们聊天应用程序用户在登录时将体验到的相同流程。
- en: Click on **Accept** and you will notice that you are redirected to our application
    code but presented with an `Auth action callback not supported` error. This is
    because we haven't yet implemented the callback functionality in `loginHandler`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**接受**后，您会注意到您被重定向到我们的应用程序代码，但显示了一个`Auth action callback not supported`错误。这是因为我们尚未在`loginHandler`中实现回调功能。
- en: Handling the response from the provider
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理提供者的响应
- en: Once the user clicks on **Accept** on the provider's website (or if they click
    on the equivalent of **Cancel**), they will be redirected to the callback endpoint
    in our application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户在提供者网站上点击**接受**（或如果他们点击**取消**的等效选项），他们将被重定向到我们应用程序的回调端点。
- en: 'A quick glance at the complete URL that comes back shows us the grant code
    that the provider has given us:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看返回的完整URL，我们可以看到提供者给我们的授权码：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We don't have to worry about what to do with this code because Gomniauth does
    it for us; we can simply jump to implementing our callback handler. However, it's
    worth knowing that this code will be exchanged by the authentication provider
    for a token that allows us to access private user data. For added security, this
    additional step happens behind the scenes, from server to server rather than in
    the browser.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心如何处理这段代码，因为 Gomniauth 会为我们处理；我们只需跳转到实现我们的回调处理程序。然而，了解这一点是值得的，即这段代码将由身份验证提供者交换为允许我们访问私有用户数据的令牌。为了增加安全性，这一额外步骤是在服务器之间而不是在浏览器中幕后发生的。
- en: 'In `auth.go`, we are ready to add another switch case to our action path segment.
    Insert the following code before the default case:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `auth.go` 中，我们准备为我们的操作路径段添加另一个 switch case。在默认 case 之前插入以下代码：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the authentication provider redirects the users after they have granted
    permission, the URL specifies that it is a callback action. We look up the authentication
    provider as we did before and call its `CompleteAuth` method. We parse `RawQuery`
    from the request into `objx.Map` (the multipurpose map type that Gomniauth uses),
    and the `CompleteAuth` method uses the values to complete the OAuth2 provider
    handshake with the provider. All being well, we will be given some authorized
    credentials with which we will be able to access our user's basic data. We then
    use the `GetUser` method for the provider, and Gomniauth will use the specified
    credentials to access some basic information about the user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当身份验证提供者在用户授予权限后重定向用户时，URL 指定这是一个回调操作。我们像之前一样查找身份验证提供者，并调用其 `CompleteAuth` 方法。我们将请求的
    `RawQuery` 解析到 `objx.Map`（Gomniauth 使用的多功能映射类型），`CompleteAuth` 方法使用这些值与提供者完成 OAuth2
    提供者握手。如果一切顺利，我们将获得一些授权凭证，我们可以用这些凭证访问用户的基本数据。然后我们使用提供者的 `GetUser` 方法，Gomniauth
    将使用指定的凭证访问有关用户的一些基本信息。
- en: Once we have the user data, we **Base64-encode** the `Name` field in a JSON
    object and store it as a value for our `auth` cookie for later use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了用户数据，我们将在 JSON 对象中对 `Name` 字段进行 **Base64 编码**，并将其存储为 `auth` 甜点的值以供以后使用。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Base64-encoding data ensures it won't contain any special or unpredictable characters,
    which is useful for situations such as passing data to a URL or storing it in
    a cookie. Remember that although Base64-encoded data looks encrypted, it is not
    you can easily decode Base64-encoded data back to the original text with little
    effort. There are online tools that do this for you.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码数据确保它不会包含任何特殊或不可预测的字符，这在将数据传递到 URL 或将其存储在甜点中的情况下很有用。记住，尽管 Base64 编码的数据看起来是加密的，但你仍然可以轻松地将
    Base64 编码的数据解码回原始文本，只需一点努力。有一些在线工具可以为你做这件事。
- en: After setting the cookie, we redirect the user to the chat page, which we can
    safely assume was the original destination.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 设置甜点后，我们将用户重定向到聊天页面，我们可以安全地假设这是原始目的地。
- en: 'Once you build and run the code again and hit the `/chat` page, you will notice
    that the sign up flow works and we are finally allowed back to the chat page.
    Most browsers have an inspector or a console—a tool that allows you to view the
    cookies that the server has sent you-that you can use to see whether the `auth`
    cookie has appeared:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行代码后，访问 `/chat` 页面，你会注意到注册流程正常工作，我们最终被允许返回到聊天页面。大多数浏览器都有一个检查器或控制台——这是一个允许你查看服务器发送给你的甜点的工具——你可以用它来查看
    `auth` 甜点是否出现：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our case, the cookie value is `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`, which is a
    Base64-encoded version of `{"name":"Mat Ryer"}`. Remember, we never typed in a
    name in our chat application; instead, Gomniauth asked Google for a name when
    we opted to sign in with Google. Storing non-signed cookies like this is fine
    for incidental information, such as a user's name; however, you should avoid storing
    any sensitive information using non-signed cookies as it's easy for people to
    access and change the data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，甜点值是 `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`，这是 `{"name":"Mat Ryer"}` 的 Base64
    编码版本。记住，我们在聊天应用程序中从未输入过名字；相反，当我们选择使用 Google 登录时，Gomniauth 向 Google 请求了一个名字。以这种方式存储未签名的甜点对于偶然信息，如用户的名字，是可以的；然而，你应该避免使用未签名的甜点存储任何敏感信息，因为这很容易被他人访问和更改数据。
- en: Presenting the user data
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示用户数据
- en: Having the user data inside a cookie is a good start, but non-technical people
    will never even know it's there, so we must bring the data to the fore. We will
    do this by enhancing `templateHandler` that first passes the user data to the
    template's `Execute` method; this allows us to use template annotations in our
    HTML to display the user data to the users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户数据放在cookie中是一个好的开始，但非技术人员永远不会知道它的存在，因此我们必须将数据带到前台。我们将通过增强`templateHandler`来实现这一点，首先将用户数据传递给模板的`Execute`方法；这允许我们在HTML中使用模板注解来向用户显示用户数据。
- en: 'Update the `ServeHTTP` method of `templateHandler` in `main.go`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`main.go`中的`templateHandler`的`ServeHTTP`方法：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Instead of just passing the entire `http.Request` object to our template as
    data, we are creating a new `map[string]interface{}` definition for a data object
    that potentially has two fields: `Host` and `UserData` (the latter will only appear
    if an `auth` cookie is present). By specifying the map type followed by curly
    braces, we are able to add the `Host` entry at the same time as making our map
    while avoiding the `make` keyword altogether. We then pass this new `data` object
    as the second argument to the `Execute` method on our template.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是仅仅将整个`http.Request`对象作为数据传递给我们的模板，而是在一个可能有两个字段的数据对象`map[string]interface{}`定义中创建一个新的，这两个字段是`Host`和`UserData`（后者只有在存在`auth`cookie时才会出现）。通过指定映射类型后跟大括号，我们能够在创建映射的同时添加`Host`条目，同时完全避免使用`make`关键字。然后我们将这个新的`data`对象作为第二个参数传递给模板上的`Execute`方法。
- en: 'Now we add an HTML file to our template source to display the name. Update
    the `chatbox` form in `chat.html`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将一个HTML文件添加到模板源中，以显示名称。更新`chat.html`中的`chatbox`表单：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `{{.UserData.name}}` annotation tells the template engine to insert our
    user's name before the `textarea` control.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{.UserData.name}}`注解告诉模板引擎在`textarea`控件之前插入我们的用户名。'
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since we're using the `objx` package, don't forget to run `go get http://github.com/stretchr/objx`
    and import it. Additional dependencies add complexity to projects, so you may
    decide to copy and paste the appropriate functions from the package or even write
    your own code that marshals between Base64-encoded cookies and back.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`objx`包，别忘了运行`go get http://github.com/stretchr/objx`并导入它。额外的依赖项会增加项目的复杂性，因此你可能决定从包中复制粘贴适当的函数，甚至编写自己的代码，在Base64编码的cookie和回之间进行序列化和反序列化。
- en: Alternatively, you can **vendor** the dependency by copying the whole source
    code to your project (inside a root-level folder called `vendor`). Go will, at
    build time, first check the vendor folder for any imported packages before checking
    them in `$GOPATH` (which were put there by `go get`). This allows you to fix the
    exact version of a dependency rather than rely on the fact that the source package
    hasn't changed since you wrote your code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过复制整个源代码到你的项目（在名为`vendor`的根级文件夹中）来**供应商**依赖项。Go在构建时，首先会在`vendor`文件夹中查找任何导入的包，然后再在`$GOPATH`中查找（由`go
    get`放置在那里）。这允许你修复依赖项的确切版本，而不是依赖于源包自你编写代码以来没有发生变化的事实。
- en: For more information about using vendors in Go, check out Daniel Theophanes'
    post on the subject at [https://blog.gopheracademy.com/advent-2015/vendor-folder/](https://blog.gopheracademy.com/advent-2015/vendor-folder/)
    or search for `vendoring in Go`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Go中使用供应商的更多信息，请查看Daniel Theophanes关于该主题的帖子，网址为[https://blog.gopheracademy.com/advent-2015/vendor-folder/](https://blog.gopheracademy.com/advent-2015/vendor-folder/)，或搜索`vendoring
    in Go`。
- en: 'Rebuild and run the chat application again and you will notice the addition
    of your name before the chat box:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并再次运行聊天应用，你将注意到在聊天框之前添加了你的名字：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Augmenting messages with additional data
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过附加数据增强消息
- en: So far, our chat application has only transmitted messages as slices of bytes
    or `[]byte` types between the client and the server; therefore, the forward channel
    for our room has the `chan []byte` type. In order to send data (such as who sent
    it and when) in addition to the message itself, we enhance our forward channel
    and also how we interact with the web socket on both ends.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的聊天应用只在客户端和服务器之间以字节切片或`[]byte`类型传输消息；因此，我们房间的转发通道具有`chan []byte`类型。为了在消息本身之外发送数据（例如，谁发送了它以及何时发送），我们增强了我们的转发通道，并且也增强了我们在两端与WebSocket交互的方式。
- en: 'Define a new type that will replace the `[]byte` slice by creating a new file
    called `message.go` in the `chat` folder:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个新的类型，通过在`chat`文件夹中创建一个名为`message.go`的新文件来替换`[]byte`切片：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `message` type will encapsulate the message string itself, but we have also
    added the `Name` and `When` fields that respectively hold the user's name and
    a timestamp of when the message was sent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`message` 类型将封装消息字符串本身，但我们还添加了 `Name` 和 `When` 字段，分别存储用户的姓名和消息发送的时间戳。'
- en: 'Since the `client` type is responsible for communicating with the browser,
    it needs to transmit and receive more than just a single message string. As we
    are talking to a JavaScript application (that is, the chat client running in the
    browser) and the Go standard library has a great JSON implementation, this seems
    like the perfect choice to encode additional information in the messages. We will
    change the `read` and `write` methods in `client.go` to use the `ReadJSON` and
    `WriteJSON` methods on the socket, and we will encode and decode our new `message`
    type:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `client` 类型负责与浏览器通信，它需要传输和接收的不仅仅是单个消息字符串。既然我们正在与一个JavaScript应用程序（即运行在浏览器中的聊天客户端）通信，而Go标准库有一个出色的JSON实现，这似乎是将额外信息编码在消息中的完美选择。我们将更改
    `client.go` 中的 `read` 和 `write` 方法，以使用套接字的 `ReadJSON` 和 `WriteJSON` 方法，并将编码和解码我们的新
    `message` 类型：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we receive a message from the browser, we will expect to populate only
    the `Message` field, which is why we set the `When` and `Name` fields ourselves
    in the preceding code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从浏览器接收消息时，我们预计只会填充 `Message` 字段，这就是为什么我们在前面的代码中自己设置了 `When` 和 `Name` 字段。
- en: You will notice that when you try to build the preceding code, it complains
    about a few things. The main reason is that we are trying to send a `*message`
    object down our `forward` and `send chan []byte` channels. This is not allowed
    until we change the type of the channel. In `room.go`, change the `forward` field
    to be of the type `chan *message`, and do the same for the `send chan` type in
    `client.go`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你尝试构建前面的代码时，它会抱怨一些事情。主要原因是我们试图将 `*message` 对象发送到我们的 `forward` 和 `send
    chan []byte` 通道。在我们更改通道类型之前，这是不允许的。在 `room.go` 中，将 `forward` 字段更改为 `chan *message`
    类型，并在 `client.go` 中对 `send chan` 类型做同样的更改。
- en: 'We must update the code that initializes our channels since the types have
    now changed. Alternatively, you can wait for the compiler to raise these issues
    and fix them as you go. In `room.go`, you need to make the following changes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更新初始化我们通道的代码，因为类型已经更改。或者，你可以等待编译器提出这些问题，并在过程中修复它们。在 `room.go` 中，你需要进行以下更改：
- en: 'Change `forward: make(chan []byte)` to `forward: make(chan *message)`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将 `forward: make(chan []byte)` 改为 `forward: make(chan *message)`'
- en: 'Change `r.tracer.Trace("Message received: ", string(msg))` to `r.tracer.Trace("Message
    received: ", msg.Message)`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将 `r.tracer.Trace("Message received: ", string(msg))` 改为 `r.tracer.Trace("Message
    received: ", msg.Message)`'
- en: 'Change `send: make(chan []byte, messageBufferSize)` to `send: make(chan *message,
    messageBufferSize)`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将 `send: make(chan []byte, messageBufferSize)` 改为 `send: make(chan *message,
    messageBufferSize)`'
- en: 'The compiler will also complain about the lack of user data on the client,
    which is a fair point because the `client` type has no idea about the new user
    data we have added to the cookie. Update the `client` struct to include a new
    general-purpose `map[string]interface{}` called `userData`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还会对客户端缺少用户数据提出抱怨，这是一个合理的观点，因为 `client` 类型对我们添加到cookie中的新用户数据一无所知。更新 `client`
    结构体以包含一个新的通用 `map[string]interface{}`，称为 `userData`：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The user data comes from the client cookie that we access through the `http.Request`
    object''s `Cookie` method. In `room.go`, update `ServeHTTP` with the following
    changes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据来自我们通过 `http.Request` 对象的 `Cookie` 方法访问的客户端cookie。在 `room.go` 中，更新 `ServeHTTP`
    并进行以下更改：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the `Cookie` method on the `http.Request` type to get our user data before
    passing it to the client. We are using the `objx.MustFromBase64` method to convert
    our encoded cookie value back into a usable map object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `http.Request` 类型的 `Cookie` 方法在传递给客户端之前获取我们的用户数据。我们正在使用 `objx.MustFromBase64`
    方法将我们的编码cookie值转换回可用的map对象。
- en: 'Now that we have changed the type being sent and received on the socket from
    `[]byte` to `*message`, we must tell our JavaScript client that we are sending
    JSON instead of just a plain string. Also, we must ask that it send JSON back
    to the server when a user submits a message. In `chat.html`, first update the
    `socket.send` call:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将套接字上发送和接收的类型从 `[]byte` 更改为 `*message`，我们必须通知我们的JavaScript客户端我们正在发送JSON而不是纯字符串。此外，我们必须要求它在用户提交消息时将JSON发送回服务器。在
    `chat.html` 中，首先更新 `socket.send` 调用：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are using `JSON.stringify` to serialize the specified JSON object (containing
    just the `Message` field) into a string, which is then sent to the server. Our
    Go code will decode (or unmarshal) the JSON string into a `message` object, matching
    the field names from the client JSON object with those of our `message` type.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`JSON.stringify`将指定的JSON对象（仅包含`Message`字段）序列化为字符串，然后将其发送到服务器。我们的Go代码将解码（或反序列化）JSON字符串到一个`message`对象，将客户端JSON对象的字段名与我们的`message`类型的字段名相匹配。
- en: 'Finally, update the `socket.onmessage` callback function to expect JSON, and
    also add the name of the sender to the page:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`socket.onmessage`回调函数以期望JSON格式，并添加发送者的名字到页面中：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build and run the application, and if you can, log in with two different accounts
    in two different browsers (or invite a friend to help you test it):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，如果可能的话，在两个不同的浏览器中使用两个不同的账户登录（或者邀请一个朋友帮助你测试它）：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following screenshot shows the chat application''s browser chat screens:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了聊天应用程序的浏览器聊天界面：
- en: '![Augmenting messages with additional data](img/00050.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![使用附加数据增强消息](img/00050.jpeg)'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added a useful and necessary feature to our chat application
    by asking users to authenticate themselves using OAuth2 service providers before
    we allow them to join the conversation. We made use of several open source packages,
    such as `Gomniauth`, which dramatically reduced the amount of multiserver complexity
    we would otherwise have dealt with.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过要求用户在使用OAuth2服务提供商进行身份验证后才能加入对话，向我们的聊天应用程序添加了一个有用且必要的功能。我们使用了几个开源包，如`Gomniauth`，这大大减少了我们本应处理的跨服务器复杂度。
- en: We implemented a pattern when we wrapped `http.Handler` types to allow us to
    easily specify which paths require the user to be authenticated and which were
    available, even without an `auth` cookie. Our `MustAuth` helper function allowed
    us to generate the wrapper types in a fluent and simple way, without adding clutter
    and confusion to our code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`http.Handler`类型包装起来时，我们实现了一个模式，使我们能够轻松地指定哪些路径需要用户认证，哪些是可用的，即使没有`auth`cookie。我们的`MustAuth`辅助函数允许我们以流畅和简单的方式生成包装类型，而不会给我们的代码增加混乱和困惑。
- en: We saw how to use cookies and Base64-encoding to safely (although not securely)
    store the state of particular users in their respective browsers and to make use
    of that data over normal connections and through web sockets. We took more control
    of the data available to our templates in order to provide the name of the user
    to the UI and saw how to only provide certain data under specific conditions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用cookies和Base64编码来安全（尽管不是安全地）地在各自的浏览器中存储特定用户的会话状态，并利用这些数据在常规连接和通过web
    sockets中进行操作。我们增加了对模板可用数据的控制，以便将用户名提供给UI，并了解了如何在特定条件下仅提供某些数据。
- en: Since we needed to send and receive additional information over the web socket,
    we learned how easy it was to change the channels of native types into channels
    that work with types of our own, such as our `message` type. We also learned how
    to transmit JSON objects over the socket, rather than just slices of bytes. Thanks
    to the type safety of Go and the ability to specify types for channels, the compiler
    helps ensure that we do not send anything other than `message` objects through
    `chan *message`. Attempting to do so would result in a compiler error, alerting
    us to the fact right away.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在web socket上发送和接收额外的信息，我们了解到将原生类型的通道更改为与我们的类型（如我们的`message`类型）一起工作的通道是多么容易。我们还学习了如何通过socket传输JSON对象，而不仅仅是字节的切片。多亏了Go的类型安全性和为通道指定类型的能力，编译器帮助我们确保不会通过`chan
    *message`发送除`message`对象之外的内容。尝试这样做会导致编译器错误，立即提醒我们。
- en: From building a chat application to seeing the name of the person chatting is
    a great leap forward in terms of usability. But it's very formal and might not
    attract modern users of the Web, who are used to a much more visual experience.
    We are missing pictures of people chatting, and in the next chapter, we will explore
    different ways in which this could be done. We can allow users to better represent
    themselves in our application by pulling profile pictures (avatars) from the OAuth2
    provider, the Gravatar web service, or the local disk after the users have uploaded
    them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从构建聊天应用到现在看到聊天者的名字，在可用性方面是一个巨大的进步。但它非常正式，可能不会吸引习惯于更加视觉体验的现代网络用户。我们缺少聊天者的图片，在下一章中，我们将探讨不同的实现方式。我们可以在用户上传后，允许用户通过从OAuth2提供者、Gravatar网络服务或本地磁盘拉取个人资料图片（头像）来更好地在我们的应用中代表自己。
- en: As an extra assignment, see whether you can make use of the `time.Time` field
    that we put into the `message` type to tell users when the messages were sent.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外作业，看看你是否可以利用我们放入`message`类型的`time.Time`字段来告诉用户消息发送的时间。
