- en: Chapter 4.  Command-Line Tools to Find Domain Names
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 命令行工具查找域名
- en: The chat application we've built so far is ready to take the world by storm
    but not before we give it a home on the Internet. Before we invite our friends
    to join the conversation, we need to pick a valid, catchy, and available domain
    name, which we can point to the server running our Go code. Instead of sitting
    in front of our favorite domain name provider for hours on end trying different
    names, we are going to develop a few command-line tools that will help us find
    the right one. As we do so, we will see how the Go standard library allows us
    to interface with the terminal and other executing applications; we'll also explore
    some patterns and practices to build command-line programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的聊天应用程序准备好席卷全球，但在我们邀请朋友们加入对话之前，我们需要选择一个有效、吸引人且可用的域名，并将其指向运行我们的 Go 代码的服务器。我们不会长时间坐在我们最喜欢的域名提供商面前尝试不同的名称，而是将开发一些命令行工具来帮助我们找到正确的名称。在这个过程中，我们将看到
    Go 标准库如何允许我们与终端和其他执行应用程序接口；我们还将探索一些构建命令行程序的模式和惯例。
- en: 'In this chapter, you will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to build complete command-line applications with as little as a single code
    file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用最少的代码文件构建完整的命令行应用程序
- en: How to ensure that the tools we build can be composed with other tools using
    standard streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保我们构建的工具可以使用标准流与其他工具组合
- en: How to interact with a simple third-party JSON RESTful API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与简单的第三方 JSON RESTful API 交互
- en: How to utilize the standard in and out pipes in Go code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Go 代码中利用标准输入和输出管道
- en: How to read from a streaming source, one line at a time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何逐行读取流式源
- en: How to build a WHOIS client to look up domain information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建一个 WHOIS 客户端来查找域名信息
- en: How to store and use sensitive or deployment-specific information in environment
    variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在环境变量中存储和使用敏感或部署特定的信息
- en: Pipe design for command-line tools
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行工具的管道设计
- en: We are going to build a series of command-line tools that use the standard streams
    (`stdin` and `stdout`) to communicate with the user and with other tools. Each
    tool will take an input line by line via the standard input pipe, process it in
    some way, and then print the output line by line to the standard out pipe for
    the next tool or user.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一系列使用标准流（`stdin` 和 `stdout`）与用户和其他工具通信的命令行工具。每个工具将通过标准输入管道逐行读取输入，以某种方式处理它，然后逐行将输出打印到标准输出管道，以便下一个工具或用户。
- en: 'By default, the standard input is connected to the user''s keyboard, and the
    standard output is printed to the terminal from where the command was run; however,
    both can be redirected using **redirection metacharacters**. It''s possible to
    throw the output away by redirecting it to `NUL` on Windows or `/dev/null` on
    Unix machines, or redirecting it to a file that will cause the output to be saved
    to a disk. Alternatively, you can pipe (using the `|` pipe character) the output
    of one program to the input of another; it is this feature that we will make use
    of in order to connect our various tools together. For example, you could pipe
    the output from one program to the input of another program in a terminal using
    this code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，标准输入连接到用户的键盘，标准输出从运行命令的终端打印出来；然而，两者都可以使用 **重定向元字符** 进行重定向。可以将输出重定向到 Windows
    上的 `NUL` 或 Unix 机器上的 `/dev/null`，或者将其重定向到将输出保存到磁盘的文件。或者，您可以使用 `|` 管道字符将一个程序的输出管道到另一个程序的输入；我们将利用这个特性将我们的各种工具连接起来。例如，您可以使用以下代码在终端中将一个程序的输出管道到另一个程序的输入：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the `echo` command will be the string `Hello` (without the quotes),
    which is then **piped** to the `md5` command; this command will in turn calculate
    the MD5 hash of `Hello`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo` 命令的输出将是字符串 `Hello`（不带引号），然后通过 **管道** 传递给 `md5` 命令；这个命令将接着计算 `Hello`
    的 MD5 哈希值：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our tools will work with lines of strings where each line (separated by a linefeed
    character) represents one string. When run without any pipe redirection, we will
    be able to interact directly with the programs using the default in and out, which
    will be useful when testing and debugging our code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具将处理字符串的行，其中每一行（由换行符分隔）代表一个字符串。在没有任何管道重定向的情况下运行，我们将能够直接与使用默认输入和输出的程序交互，这在测试和调试我们的代码时将非常有用。
- en: Five simple programs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五个简单的程序
- en: 'In this chapter, we will build five small programs that we will combine at
    the end. The key features of the programs are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建五个小型程序，最后我们将它们组合在一起。这些程序的关键特性如下：
- en: '**Sprinkle**: This program will add some web-friendly sprinkle words to increase
    the chances of finding the available domain names.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sprinkle**：此程序将通过添加一些适合网络的点缀词来增加找到可用域名的机会。'
- en: '**Domainify**: This program will ensure words are acceptable for a domain name
    by removing unacceptable characters. Once this is done, it will replace spaces
    with hyphens and add an appropriate top-level domain (such as `.com` and `.net`)
    to the end.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Domainify**：此程序将通过删除不可接受的字符来确保单词适合作为域名。一旦完成，它将用连字符替换空格，并在末尾添加适当的顶级域名（如`.com`和`.net`）。'
- en: '**Coolify**: This program will change a boring old normal word to Web 2.0 by
    fiddling around with vowels.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Coolify**：此程序将通过调整元音来将一个无聊的普通词变成Web 2.0风格。'
- en: '**Synonyms**: This pro will use a third-party API to find synonyms.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同义词**：此程序将使用第三方API来查找同义词。'
- en: '**Available**: This gram will use a third-party API to find synonyms. Available:
    This program will check to see whether the domain is available or not using an
    appropriate **WHOIS** server.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：此语法将使用第三方API来查找同义词。可用性：此程序将使用适当的**WHOIS**服务器检查域名是否可用。'
- en: Five programs might seem like a lot for one chapter, but don't forget how small
    entire programs can be in Go.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 五个程序对于一个章节来说可能看起来很多，但不要忘记在Go中整个程序可以有多小。
- en: Sprinkle
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sprinkle
- en: Our first program augments the incoming words with some sugar terms in order
    to improve the odds of finding names that are available. Many companies use this
    approach to keep the core messaging consistent while being able to afford the
    `.com` domain. For example, if we pass in the word `chat`, it might pass out `chatapp`;
    alternatively, if we pass in `talk`, we may get back `talk time`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序通过添加一些糖分术语来增强传入的单词，以提高找到可用名称的机会。许多公司使用这种方法来保持核心信息的连贯性，同时能够负担得起`.com`域名。例如，如果我们传入单词`chat`，它可能会输出`chatapp`；或者，如果我们传入`talk`，我们可能会得到`talk
    time`。
- en: Go's `math/rand` package allows us to break away from the predictability of
    computers. It gives our program the appearance of intelligence by introducing
    elements of chance into its decision making.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`math/rand`包使我们能够摆脱计算机的预测性。它通过在决策过程中引入随机元素，使我们的程序看起来具有智能。
- en: 'To make our Sprinkle program work, we will:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的Sprinkle程序工作，我们将：
- en: Define an array of transformations, using a special constant to indicate where
    the original word will appear
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个转换数组，使用特殊常量来指示原始单词将出现的位置
- en: Use the `bufio` package to scan the input from `stdin` and `fmt.Println` in
    order to write the output to `stdout`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bufio`包从`stdin`读取输入，并使用`fmt.Println`将输出写入`stdout`
- en: Use the `math/rand` package to randomly select a transformation to apply
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`math/rand`包随机选择一个要应用的转换
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: All our programs will reside in the `$GOPATH/src` directory. For example, if
    your GOPATH is `~/Work/projects/go`, you would create your program folders in
    the `~/Work/projects/go/src` folder.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有程序都将位于`$GOPATH/src`目录下。例如，如果你的GOPATH是`~/Work/projects/go`，你将在`~/Work/projects/go/src`文件夹中创建你的程序文件夹。
- en: 'In the `$GOPATH/src` directory, create a new folder called `sprinkle` and add
    a `main.go` file containing the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$GOPATH/src`目录下，创建一个名为`sprinkle`的新文件夹，并添加一个包含以下代码的`main.go`文件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From now on, it is assumed that you will sort out the appropriate `import` statements
    yourself. If you need assistance, refer to the tips provided in [Appendix](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Appendix Appendix. Good Practices for a Stable Go Environment"), *Good Practices
    for a Stable Go Environment*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，假设你将自行解决适当的`import`语句。如果你需要帮助，请参阅提供的提示，见[附录](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "附录 附录。 稳定Go环境的良好实践")，*稳定Go环境的良好实践*。
- en: 'The preceding code represents our complete Sprinkle program. It defines three
    things: a constant, a variable, and the obligatory `main` function, which serves
    as the entry point to Sprinkle. The `otherWord` constant string is a helpful token
    that allows us to specify where the original word should occur in each of our
    possible transformations. It lets us write code, such as `otherWord+"extra"`,
    which makes it clear that in this particular case, we want to add the word "extra"
    to the end of the original word.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码代表了我们完整的 Sprinkle 程序。它定义了三件事：一个常量、一个变量以及必要的 `main` 函数，该函数作为 Sprinkle 的入口点。`otherWord`
    常量字符串是一个有用的标记，它允许我们指定原始单词在每个可能的转换中应该出现的位置。它让我们能够编写如 `otherWord+"extra"` 这样的代码，这清楚地表明在这个特定情况下，我们想在原始单词的末尾添加单词
    "extra"。
- en: The possible transformations are stored in the `transforms` variable that we
    declare as a slice of strings. In the preceding code, we defined a few different
    transformations, such as adding `app` to the end of a word or `lets` before it.
    Feel free to add some more; the more creative, the better.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的转换存储在我们声明的字符串切片 `transforms` 变量中。在上述代码中，我们定义了一些不同的转换，例如在单词末尾添加 `app` 或在其前面添加
    `lets`。请随意添加更多；越有创意越好。
- en: In the `main` function, the first thing we do is use the current time as a random
    seed. Computers can't actually generate random numbers, but changing the seed
    number of random algorithms gives the illusion that it can. We use the current
    time in nanoseconds because it's different each time the program is run (provided
    the system clock isn't being reset before each run). If we skip this step, the
    numbers generated by the `math/rand` package would be deterministic; they'd be
    the same every time we run the program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们首先使用当前时间作为随机种子。计算机实际上不能生成随机数，但改变随机算法的种子数字可以给人一种它可以的错觉。我们使用纳秒作为当前时间，因为每次程序运行时它都是不同的（前提是在每次运行之前系统时钟没有被重置）。如果我们跳过这一步，`math/rand`
    包生成的数字将是确定的；每次运行程序时它们都是相同的。
- en: We then create a `bufio.Scanner` object (by calling `bufio.NewScanner`) and
    tell it to read the input from `os.Stdin`, which represents the standard input
    stream. This will be a common pattern in our five programs since we are always
    going to read from the standard *in* and write to the standard *out*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `bufio.Scanner` 对象（通过调用 `bufio.NewScanner`），并告诉它从 `os.Stdin` 读取输入，它代表标准输入流。在我们的五个程序中，这将成为一个常见的模式，因为我们总是要从标准
    *in* 读取并写入标准 *out*。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `bufio.Scanner` object actually takes `io.Reader` as its input source, so
    there is a wide range of types that we could use here. If you were writing unit
    tests for this code, you could specify your own `io.Reader` for the scanner to
    read from, removing the need for you to worry about simulating the standard input
    stream.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio.Scanner` 对象实际上接受 `io.Reader` 作为其输入源，因此我们可以使用多种类型。如果您正在为此代码编写单元测试，您可以指定自己的
    `io.Reader` 以供扫描器读取，从而无需您担心模拟标准输入流。'
- en: As the default case, the scanner allows us to read blocks of bytes separated
    by defined delimiters, such as carriage return and linefeed characters. We can
    specify our own split function for the scanner or use one of the options built
    in the standard library. For example, there is `bufio.ScanWords`, which scans
    individual words by breaking on whitespace rather than linefeeds. Since our design
    specifies that each line must contain a word (or a short phrase), the default
    line-by-line setting is ideal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认情况，扫描器允许我们读取由定义的分隔符分隔的字节块，例如回车和换行符字符。我们可以为扫描器指定自己的分割函数，或者使用标准库中内置的选项。例如，有
    `bufio.ScanWords`，它通过在空白处而不是换行符处断开来扫描单个单词。由于我们的设计指定每行必须包含一个单词（或短语），因此默认的逐行设置是理想的。
- en: A call to the `Scan` method tells the scanner to read the next block of bytes
    (the next line) from the input, and then it returns a `bool` value indicating
    whether it found anything or not. This is how we are able to use it as the condition
    for the `for` loop. While there is content to work on, `Scan` returns `true` and
    the body of the `for` loop is executed; when `Scan` reaches the end of the input,
    it returns `false`, and the loop is broken. The bytes that are selected are stored
    in the `Bytes` method of the scanner, and the handy `Text` method that we use
    converts the `[]byte` slice into a string for us.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `Scan` 方法的调用告诉扫描器从输入中读取下一个字节数组（下一行），然后它返回一个 `bool` 值，指示它是否找到了任何内容。这就是我们能够将其用作
    `for` 循环的条件的原因。当有内容要处理时，`Scan` 返回 `true`，并执行 `for` 循环的主体；当 `Scan` 达到输入的末尾时，它返回
    `false`，循环被中断。所选的字节存储在扫描器的 `Bytes` 方法中，我们使用的方便的 `Text` 方法将 `[]byte` 切片转换为字符串。
- en: Inside the `for` loop (so for each line of input), we use `rand.Intn` to select
    a random item from the `transforms` slice and use `strings.Replace` to insert
    the original word where the `otherWord` string appears. Finally, we use `fmt.Println`
    to print the output to the default standard output stream.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环内部（因此对于每一行输入），我们使用 `rand.Intn` 从 `transforms` 切片中选择一个随机项，并使用 `strings.Replace`
    将原始单词插入到 `otherWord` 字符串出现的位置。最后，我们使用 `fmt.Println` 将输出打印到默认标准输出流。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `math/rand` package provides insecure random numbers. If you want to write
    code that utilizes random numbers for security purposes, you must use the `crypto/rand`
    package instead.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`math/rand` 包提供的随机数不安全。如果你想要编写用于安全目的的利用随机数的代码，你必须使用 `crypto/rand` 包。'
- en: 'Let''s build our program and play with it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的程序并玩玩它：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the program starts running, it will use the default behavior to read the
    user input from the terminal. It uses the default behavior because we haven''t
    piped in any content or specified a source for it to read from. Type `chat` and
    hit return. The scanner in our code notices the linefeed character at the end
    of the word and runs the code that transforms it, outputting the result. For example,
    if you type `chat` a few times, you would see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序开始运行，它将使用默认行为从终端读取用户输入。它使用默认行为是因为我们没有将任何内容管道输入或指定读取来源。输入 `chat` 并按回车键。我们代码中的扫描器注意到单词末尾的换行符，并运行变换它的代码，输出结果。例如，如果你多次输入
    `chat`，你会看到以下输出：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Sprinkle never exits (meaning the `Scan` method never returns `false` to break
    the loop) because the terminal is still running; in normal execution, the in pipe
    will be closed by whatever program is generating the input. To stop the program,
    hit *Ctrl + C*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Sprinkle 永远不会退出（这意味着 `Scan` 方法永远不会返回 `false` 来中断循环），因为终端仍在运行；在正常执行中，输入管道将由生成输入的程序关闭。要停止程序，请按
    *Ctrl + C*。
- en: 'Before we move on, let''s try to run Sprinkle, specifying a different input
    source. We are going to use the `echo` command to generate some content and pipe
    it to our Sprinkle program using the pipe character:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们尝试运行 Sprinkle，指定不同的输入源。我们将使用 `echo` 命令生成一些内容，并通过管道字符将其传递到我们的 Sprinkle
    程序：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The program will randomly transform the word, print it out, and exit since the
    `echo` command generates only one line of input before terminating and closing
    the pipe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将随机变换单词，打印出来，然后退出，因为 `echo` 命令在终止和关闭管道之前只生成一行输入。
- en: We have successfully completed our first program, which has a very simple but
    useful function, as we will see.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功完成了我们的第一个程序，它具有非常简单但有用的功能，正如我们将看到的。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an extra assignment, rather than hardcoding the `transformations` array as
    we have done, see whether you can externalize it via flags or store them in a
    text file or database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的作业，而不是像我们之前那样硬编码 `transformations` 数组，看看你是否可以通过标志或将其存储在文本文件或数据库中来实现外部化。
- en: Domainify
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Domainify
- en: 'Some of the words that output from Sprinkle contain spaces and perhaps other
    characters that are not allowed in domains. So we are going to write a program
    called Domainify; it converts a line of text into an acceptable domain segment
    and adds an appropriate **Top-level Domain** (**TLD**) to the end. Alongside the
    `sprinkle` folder, create a new one called `domainify` and add the `main.go` file
    with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Sprinkle 输出的某些单词包含空格，也许还有在域名中不允许的其他字符。因此，我们将编写一个名为 Domainify 的程序；它将一行文本转换为可接受的域名段，并在末尾添加一个合适的
    **顶级域名** (**TLD**)。在 `sprinkle` 文件夹旁边创建一个新的文件夹，命名为 `domainify`，并添加一个名为 `main.go`
    的文件，其中包含以下代码：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will notice a few similarities between Domainify and the Sprinkle program:
    we set the random seed using `rand.Seed`, generate a `NewScanner` method wrapping
    the `os.Stdin` reader, and scan each line until there is no more input.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到Domainify和Sprinkle程序之间有一些相似之处：我们使用`rand.Seed`设置随机种子，生成一个包装`os.Stdin`读取器的`NewScanner`方法，并扫描每一行直到没有更多输入。
- en: We then convert the text to lowercase and build up a new slice of `rune` types
    called `newText`. The `rune` types consist of only characters that appear in the
    `allowedChars` string, which `strings.ContainsRune` lets us know. If `rune` is
    a space that we determine by calling `unicode.IsSpace`, we replace it with a hyphen,
    which is an acceptable practice in domain names.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将文本转换为小写，并构建一个新的`rune`类型切片，称为`newText`。`rune`类型仅包含出现在`allowedChars`字符串中的字符，这是`strings.ContainsRune`函数告诉我们的。如果`rune`是一个空格，我们通过调用`unicode.IsSpace`来确定，我们将其替换为一个连字符，这在域名中是一种可接受的实践。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ranging over a string returns the index of each character and a `rune` type,
    which is a numerical value (specifically, `int32`) representing the character
    itself. For more information about runes, characters, and strings, refer to [http://blog.golang.org/strings](http://blog.golang.org/strings).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字符串返回每个字符的索引和一个`rune`类型，这是一个表示字符本身的数值（具体来说，是`int32`）。有关runes、字符和字符串的更多信息，请参阅[http://blog.golang.org/strings](http://blog.golang.org/strings)。
- en: Finally, we convert `newText` from a `[]rune` slice into a string and add either
    `.com` or `.net` at the end, before printing it out using `fmt.Println`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`newText`从`[]rune`切片转换为字符串，并在打印之前添加`.com`或`.net`，然后使用`fmt.Println`打印出来。
- en: 'Let''s build and run Domainify:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行Domainify：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Type in some of these options to see how `domainify` reacts:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一些这些选项以查看`domainify`的反应：
- en: Monkey
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Monkey
- en: Hello Domainify
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hello Domainify
- en: '"What''s up?"'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"What''s up?"'
- en: One (two) three!
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: One (two) three!
- en: You can see that, for example, `One (two) three!` might yield `one-two-three.com`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，例如，`One (two) three!`可能会产生`one-two-three.com`。
- en: 'We are now going to compose Sprinkle and Domainify to see them work together.
    In your terminal, navigate to the parent folder (probably `$GOPATH/src`) of `sprinkle`
    and `domainify` and run the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将组合Sprinkle和Domainify来观察它们是如何一起工作的。在你的终端中，导航到`sprinkle`和`domainify`的父文件夹（可能是`$GOPATH/src`），并运行以下命令：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we ran the `sprinkle` program and piped the output to the `domainify`
    program. By default, `sprinkle` uses the terminal as the input and `domanify`
    outputs to the terminal. Try typing in `chat` a few times again and notice the
    output is similar to what Sprinkle was outputting previously, except now they
    are acceptable for domain names. It is this piping between programs that allows
    us to compose command-line tools together.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了`sprinkle`程序，并将其输出管道传输到`domainify`程序。默认情况下，`sprinkle`使用终端作为输入，而`domanify`输出到终端。再次尝试输入`chat`几次，并注意输出与Sprinkle之前输出的相似，但现在它们是域名中可接受的。正是这种程序之间的管道连接使我们能够组合命令行工具。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Only supporting `.com` and `.net` top-level domains is fairly limiting. As an
    additional assignment, see whether you can accept a list of TLDs via a command-line
    flag.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 仅支持`.com`和`.net`顶级域名相当有限。作为额外的作业，看看你是否可以通过命令行标志接受一个TLDs列表。
- en: Coolify
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coolify
- en: Often, domain names for common words, such as `chat`, are already taken, and
    a common solution is to play around with the vowels in the words. For example,
    we might remove `a` and make it `cht` (which is actually less likely to be available)
    or add `a` to produce `chaat`. While this clearly has no actual effect on coolness,
    it has become a popular, albeit slightly dated, way to secure domain names that
    still sound like the original word.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像`chat`这样的常见单词的域名已经被占用，一个常见的解决方案是在单词的元音上玩弄。例如，我们可能会移除`a`并使其变为`cht`（这实际上更不可能可用）或者添加`a`以产生`chaat`。虽然这显然对酷度没有实际影响，但它已经成为一种流行但略显过时的方法，可以确保听起来像原始单词的域名。
- en: Our third program, Coolify, will allow us to play with the vowels of words that
    come in via the input and write modified versions to the output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个程序Coolify将允许我们玩转通过输入进入的单词的元音，并将修改后的版本写入输出。
- en: 'Create a new folder called `coolify` alongside `sprinkle` and `domainify`,
    and create the `main.go` code file with the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sprinkle`和`domainify`旁边创建一个名为`coolify`的新文件夹，并创建一个包含以下代码的`main.go`代码文件：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While the preceding Coolify code looks very similar to the code of Sprinkle
    and Domainify, it is slightly more complicated. At the very top of the code, we
    declare two constants, `duplicateVowel` and `removeVowel`, that help make the
    Coolify code more readable. The `switch` statement decides whether we duplicate
    or remove a vowel. Also, using these constants, we are able to express our intent
    very clearly, rather than use just `true` or `false`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的 Coolify 代码看起来与 Sprinkle 和 Domainify 的代码非常相似，但它稍微复杂一些。在代码的顶部，我们声明了两个常量，`duplicateVowel`
    和 `removeVowel`，这有助于使 Coolify 代码更易于阅读。`switch` 语句决定是否复制或删除元音。此外，使用这些常量，我们能够非常清楚地表达我们的意图，而不是仅仅使用
    `true` 或 `false`。
- en: We then define the `randBool` helper function that just randomly returns either
    `true` or `false`. This is done by asking the `rand` package to generate a random
    number and confirming whether that number comes out as zero. It will be either
    `0` or `1`, so there's a fifty-fifty chance of it being `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后定义了一个辅助函数 `randBool`，它随机返回 `true` 或 `false`。这是通过请求 `rand` 包生成一个随机数并确认该数字是否为零来完成的。它将是
    `0` 或 `1`，所以有一半的机会它是 `true`。
- en: The `main` function of Coolify starts the same way as that of Sprinkle and Domainify
    setting the `rand.Seed` method and creating a scanner of the standard input stream
    before executing the loop body for each line of input. We call `randBool` first
    to decide whether we are even going to mutate a word or not, so Coolify will only
    affect half the words passed through it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Coolify 的 `main` 函数与 Sprinkle 和 Domainify 的 `main` 函数以相同的方式开始，设置 `rand.Seed`
    方法并创建标准输入流的扫描器，然后在执行输入行的循环体之前。我们首先调用 `randBool` 来决定是否甚至要变异一个单词，因此 Coolify 只会影响通过它的单词的一半。
- en: We then iterate over each rune in the string and look for a vowel. If our `randBool`
    method returns `true`, we keep the index of the vowel character in the `vI` variable.
    If not, we keep looking through the string for another vowel, which allows us
    to randomly select a vowel from the words rather than always modify the same one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后遍历字符串中的每个 rune 并寻找元音。如果我们的 `randBool` 方法返回 `true`，我们保留元音字符在 `vI` 变量中的索引。如果不，我们继续在字符串中寻找另一个元音，这允许我们从单词中随机选择一个元音，而不是总是修改同一个元音。
- en: Once we have selected a vowel, we use `randBool` again to randomly decide what
    action to take.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个元音，我们再次使用 `randBool` 来随机决定采取什么行动。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is where the helpful constants come in; consider the following alternative
    switch statement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有用的常量发挥作用的地方；考虑以下替代的 `switch` 语句：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The three dots following the slices cause each item to pass as a separate argument
    to the `append` function. This is an idiomatic way of appending one slice to another.
    Inside the `switch` case, we do some slice manipulation to either duplicate the
    vowel or remove it altogether. We are slicing our `[]byte` slice again and using
    the `append` function to build a new one made up of sections of the original word.
    The following diagram shows which sections of the string we access in our code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片后面的三个点使得每个项目都能作为单独的参数传递给 `append` 函数。这是一种将一个切片附加到另一个切片的惯用方法。在 `switch` 案例中，我们进行一些切片操作，要么复制元音，要么完全删除它。我们再次对
    `[]byte` 切片进行切片，并使用 `append` 函数构建一个新的切片，该切片由原始单词的各个部分组成。以下图表显示了我们在代码中访问的字符串的哪些部分：
- en: '![Coolify](img/00055.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Coolify](img/00055.jpeg)'
- en: 'If we take the value `blueprints` as an example word and assume that our code
    has selected the first `e` character as the vowel (so that `vI` is `3`), the following
    table will illustrate what each new slice of the word will represent:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `blueprints` 作为示例单词的值，并假设我们的代码已选择第一个 `e` 字符作为元音（因此 `vI` 为 `3`），以下表格将说明单词的每个新切片将代表什么：
- en: '| **Code** | **Value** | **Description** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **值** | **描述** |'
- en: '| `word[:vI+1]` | blue | This describes the slice from the beginning of the
    word until the selected vowel. The `+1` is required because the value following
    the colon does not include the specified index; rather, it slices up to that value.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `word[:vI+1]` | blue | 这描述了从单词开头到所选元音的切片。`+1` 是必需的，因为冒号后面的值不包括指定的索引；相反，它切片到那个值。
    |'
- en: '| `word[vI:]` | eprints | This describes the slice starting from and including
    the selected vowel to the end of the slice. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `word[vI:]` | eprints | 这描述了从所选元音开始并包括所选元音的切片。 |'
- en: '| `word[:vI]` | blu | This describes the slice from the beginning of the word
    up to, but not including, the selected vowel. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `word[:vI]` | blu | 这描述了从单词开头到所选元音之前的切片。 |'
- en: '| `word[vI+1:]` | prints | This describes the slice from the item following
    the selected vowel to the end of the slice. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `word[vI+1:]` | 打印 | 这描述了从所选元音之后的项到切片末尾的切片。|'
- en: After we modify the word, we print it out using `fmt.Println`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 修改单词后，我们使用 `fmt.Println` 打印它。
- en: 'Let''s build Coolify and play with it to see what it can do:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建Coolify并尝试使用它看看它能做什么：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When Coolify is running, try typing `blueprints` to see what sort of modifications
    it comes up with:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当Coolify运行时，尝试输入 `blueprints` 来查看它提出了什么样的修改：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s see how Coolify plays with Sprinkle and Domainify by adding their names
    to our pipe chain. In the terminal, navigate back (using the `cd` command) to
    the parent folder and run the following commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Coolify如何通过将它们的名称添加到我们的管道链中来与Sprinkle和Domainify互动。在终端中，使用 `cd` 命令返回父文件夹，并运行以下命令：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will first spice up a word with extra pieces and make it cooler by tweaking
    the vowels before finally transforming it into a valid domain name. Play around
    by typing in a few words and seeing what suggestions our code makes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过添加额外的部分来丰富一个单词，并通过调整元音使其更加酷，最后将其转换成一个有效的域名。通过输入几个单词并查看代码的建议来尝试一下。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Coolify only works on vowels; as an additional exercise, see whether you can
    make the code operate on every character it encounters just to see what happens.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Coolify只作用于元音；作为一个额外的练习，看看你是否能让代码对遇到的每个字符都进行操作，以看看会发生什么。
- en: Synonyms
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Synonyms
- en: So far, our programs have only modified words, but to really bring our solution
    to life, we need to be able to integrate a third-party API that provides word
    synonyms. This allows us to suggest different domain names while retaining the
    original meaning. Unlike Sprinkle and Domainify, Synonyms will write out more
    than one response for each word given to it. Our architecture of piping programs
    together means this won't be much of a problem; in fact, we do not even have to
    worry about it since each of the three programs is capable of reading multiple
    lines from the input source.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的程序只修改了单词，但为了真正让我们的解决方案活起来，我们需要能够集成一个提供单词同义词的第三方API。这允许我们在保留原始意义的同时建议不同的域名。与Sprinkle和Domainify不同，Synonyms将为每个给定的单词写出多个响应。我们通过管道连接程序一起的架构意味着这不会成为太大的问题；事实上，我们甚至不必担心它，因为这三个程序中的每一个都能够从输入源中读取多行。
- en: Big Huge Thesaurus, [http://bighugelabs.com/](http://bighugelabs.com/), has
    a very clean and simple API that allows us to make a single HTTP `GET` request
    to look up synonyms.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大型同义词词典，[http://bighugelabs.com/](http://bighugelabs.com/)，提供了一个非常干净简单的API，允许我们通过发送单个HTTP
    `GET`请求来查找同义词。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In future, if the API we are using changes or disappears (after all, we're dealing
    with the Internet), you will find some options at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果我们使用的API发生变化或消失（毕竟，我们在处理互联网），你将在 [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    找到一些选项。
- en: Before you can use Big Huge Thesaurus, you'll need an API key, which you can
    get by signing up to the service at [http://words.bighugelabs.com/](http://words.bighugelabs.com/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用大型同义词词典之前，你需要一个API密钥，你可以通过在 [http://words.bighugelabs.com/](http://words.bighugelabs.com/)
    上注册服务来获取。
- en: Using environment variables for configuration
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境变量进行配置
- en: Your API key is a sensitive piece of configuration information that you don't
    want to share with others. We could store it as `const` in our code. However,
    this would mean we will not be able to share our code without sharing our key
    (not good, especially if you love open source projects). Additionally, perhaps
    more importantly, you will have to recompile your entire project if the key expires
    or if you want to use a different one (you don't want to get into such a situation).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API密钥是一段敏感的配置信息，你不希望与他人分享。我们可以在代码中将它存储为 `const`。然而，这意味着我们无法在不分享密钥的情况下分享我们的代码（特别是如果你喜欢开源项目的话）。此外，也许更重要的是，如果密钥过期或你想使用另一个密钥，你将不得不重新编译整个项目（你不想陷入这种境地）。
- en: A better solution is using an environment variable to store the key, as this
    will allow you to easily change it if you need to. You could also have different
    keys for different deployments; perhaps you could have one key for development
    or testing and another for production. This way, you can set a specific key for
    a particular execution of code so you can easily switch between keys without having
    to change your system-level settings. Also, different operating systems deal with
    environment variables in similar ways, so they are a perfect choice if you are
    writing cross-platform code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用环境变量来存储密钥，因为这将允许你轻松地更改它，如果你需要的话。你也可以为不同的部署有不同的密钥；也许你可以有一个用于开发或测试的密钥，另一个用于生产。这样，你可以为特定的代码执行设置一个特定的密钥，这样你就可以轻松地在密钥之间切换，而无需更改系统级别的设置。此外，不同的操作系统以类似的方式处理环境变量，所以如果你正在编写跨平台代码，它们是一个完美的选择。
- en: Create a new environment variable called `BHT_APIKEY` and set your API key as
    its value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`BHT_APIKEY`的新环境变量，并将API密钥设置为它的值。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For machines running a bash shell, you can modify your `~/.bashrc` file or
    similar to include `export` commands, such as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行bash shell的机器，你可以修改你的`~/.bashrc`文件或类似文件，以包含以下`export`命令：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On Windows machines, you can navigate to the properties of your computer and
    look for **Environment Variables** in the **Advanced** section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，你可以导航到计算机属性，并在**高级**部分查找**环境变量**。
- en: Consuming a web API
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费Web API
- en: 'Making a request for in a web browser shows us what the structure of JSON response
    data looks like when finding synonyms for the word `love`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中发出请求，显示了当寻找单词`love`的同义词时JSON响应数据的结构：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A real API will return a lot more actual words than what is printed here, but
    the structure is the important thing. It represents an object, where the keys
    describe the types of word (verbs, nouns, and so on). Also, values are objects
    that contain arrays of strings keyed on `syn` or `ant` (for the synonym and antonym,
    respectively); it is the synonyms we are interested in.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实的API将返回比这里打印的更多实际单词，但结构才是最重要的。它代表一个对象，其中键描述了单词的类型（动词、名词等）。此外，值是包含以`syn`或`ant`（分别代表同义词和反义词）为键的字符串数组的对象；我们感兴趣的是同义词。
- en: 'To turn this JSON string data into something we can use in our code, we must
    decode it into structures of our own using the capabilities found in the `encoding/json`
    package. Because we''re writing something that could be useful outside the scope
    of our project, we will consume the API in a reusable package rather than directly
    in our program code. Create a new folder called `thesaurus` alongside your other
    program folders (in `$GOPATH/src`) and insert the following code into a new `bighuge.go`
    file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个JSON字符串数据转换成我们可以在代码中使用的东西，我们必须使用`encoding/json`包中的功能将其解码成我们自己的结构。因为我们正在编写可能在我们项目范围之外有用的东西，所以我们将通过可重用的包来消费API，而不是直接在我们的程序代码中。在你的其他程序文件夹（在`$GOPATH/src`）旁边创建一个名为`thesaurus`的新文件夹，并将以下代码插入一个名为`bighuge.go`的新文件中：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, the `BigHuge` type we define houses the necessary API
    key and provides the `Synonyms` method that will be responsible for doing the
    work of accessing the endpoint, parsing the response, and returning the results.
    The most interesting parts of this code are the `synonyms` and `words` structures.
    They describe the JSON response format in Go terms, namely an object containing
    noun and verb objects, which in turn contain a slice of strings in a variable
    called `Syn`. The tags (strings in backticks following each field definition)
    tell the `encoding/json` package which fields to map to which variables; this
    is required since we have given them different names.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义的`BigHuge`类型包含必要的API密钥，并提供了一个`Synonyms`方法，它将负责访问端点、解析响应并返回结果。这段代码中最有趣的部分是`synonyms`和`words`结构。它们用Go术语描述了JSON响应格式，即包含名词和动词对象的对象，这些对象反过来包含一个名为`Syn`的字符串切片。标签（每个字段定义后面的反引号中的字符串）告诉`encoding/json`包将哪些字段映射到哪些变量；这是必需的，因为我们已经给了它们不同的名字。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Typically in JSON, keys have lowercase names, but we have to use capitalized
    names in our structures so that the `encoding/json` package would also know that
    the fields exist. If we don't, the package would simply ignore the fields. However,
    the types themselves (`synonyms` and `words`) do not need to be exported.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在JSON中，键名是小写的，但我们必须在我们的结构中使用大写名称，这样`encoding/json`包也会知道字段存在。如果我们不这样做，包将简单地忽略这些字段。然而，类型本身（`synonyms`和`words`）不需要被导出。
- en: The `Synonyms` method takes a `term` argument and uses `http.Get` to make a
    web request to the API endpoint in which the URL contains not only the API key
    value, but also the `term` value itself. If the web request fails for some reason,
    we will make a call to `log.Fatalln`, which will write the error to the standard
    error stream and exit the program with a non-zero exit code (actually an exit
    code of `1`). This indicates that an error has occurred.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Synonyms`方法接受一个`term`参数，并使用`http.Get`向包含API密钥值以及`term`值的API端点发起网络请求。如果由于某种原因网络请求失败，我们将调用`log.Fatalln`，这将错误写入标准错误流，并以非零退出代码（实际上是一个退出代码`1`）退出程序。这表示发生了错误。'
- en: If the web request is successful, we pass the response body (another `io.Reader`)
    to the `json.NewDecoder` method and ask it to decode the bytes into the `data`
    variable that is of our `synonyms` type. We defer the closing of the response
    body in order to keep the memory clean before using Go's built-in `append` function
    to concatenate both `noun` and `verb` synonyms to the `syns` slice that we then
    return.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络请求成功，我们将响应体（另一个`io.Reader`）传递给`json.NewDecoder`方法，并要求它将字节解码到我们的`synonyms`类型的`data`变量中。我们延迟关闭响应体，以便在使用Go的内置`append`函数将`noun`和`verb`同义词连接到我们随后返回的`syns`切片之前保持内存清洁。
- en: 'Although we have implemented the `BigHuge` thesaurus, it isn''t the only option
    out there, and we can express this by adding a `Thesaurus` interface to our package.
    In the `thesaurus` folder, create a new file called `thesaurus.go` and add the
    following interface definition to the file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经实现了`BigHuge`同义词库，但这并不是唯一的选择，我们可以通过向我们的包中添加`Thesaurus`接口来表达这一点。在`thesaurus`文件夹中，创建一个名为`thesaurus.go`的新文件，并将以下接口定义添加到该文件中：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This simple interface just describes a method that takes a `term` string and
    returns either a slice of strings containing the synonyms or an error (if something
    goes wrong). Our `BigHuge` structure already implements this interface, but now,
    other users could add interchangeable implementations for other services, such
    as [http://www.dictionary.com/](http://www.dictionary.com/) or the Merriam-Webster
    online service.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的接口仅仅描述了一个方法，该方法接受一个`term`字符串，并返回包含同义词的字符串切片或错误（如果发生错误）。我们的`BigHuge`结构已经实现了这个接口，但现在，其他用户可以为其他服务添加可互换的实现，例如[http://www.dictionary.com/](http://www.dictionary.com/)或Merriam-Webster在线服务。
- en: 'Next, we are going to use this new package in a program. Change the directory
    in the terminal back up a level to `$GOPATH/src`, create a new folder called `synonyms`,
    and insert the following code into a new `main.go` file you will place in this
    folder:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在程序中使用这个新包。在终端中，将目录向上移动一级到`$GOPATH/src`，创建一个名为`synonyms`的新文件夹，并将以下代码插入到该文件夹中一个名为`main.go`的新文件中：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now when you manage your imports again, you will have written a complete program
    that is capable of looking up synonyms of words by integrating the Big Huge Thesaurus
    API.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你再次管理你的导入时，你将编写一个完整的程序，该程序能够通过集成Big Huge Thesaurus API查找单词的同义词。
- en: In the preceding code, the first thing our `main` function does is that it gets
    the `BHT_APIKEY` environment variable value via the `os.Getenv` call. To protect
    your code, you might consider double-checking it to ensure the value is properly
    set; if not, report the error. For now, we will assume that everything is configured
    properly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的`main`函数首先通过`os.Getenv`调用获取`BHT_APIKEY`环境变量的值。为了保护你的代码，你可能需要再次检查以确保值已正确设置；如果没有，则报告错误。目前，我们将假设一切配置正确。
- en: Next, the preceding code starts to look a little familiar since it scans each
    line of input again from `os.Stdin` and calls the `Synonyms` method to get a list
    of the replacement words.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，前面的代码开始看起来有些熟悉，因为它再次从`os.Stdin`读取每一行输入，并调用`Synonyms`方法来获取替换词的列表。
- en: 'Let''s build a program and see what kind of synonyms the API comes back with
    when we input the word `chat`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个程序，看看当我们输入单词`chat`时，API返回了什么样的同义词：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The results you get will most likely differ from what we have listed here since
    we're hitting a live API. However, the important thing is that when we provide
    a word or term as an input to the program, it returns a list of synonyms as the
    output, one per line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果很可能与我们列出的不同，因为我们正在调用一个实时API。然而，重要的是，当我们向程序提供一个单词或术语作为输入时，它返回一个同义词列表作为输出，每行一个。
- en: Getting domain suggestions
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取域名建议
- en: 'By composing the four programs we have built so far in this chapter, we already
    have a useful tool for suggesting domain names. All we have to do now is to run
    the programs while piping the output to the input in an appropriate way. In a
    terminal, navigate to the parent folder and run the following single line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合本章中构建的四个程序，我们已经有了一个有用的工具来建议域名。我们现在需要做的就是以适当的方式将程序的输出管道传输到输入。在终端中，导航到父文件夹并运行以下单行命令：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because the `synonyms` program is first in our list, it will receive the input
    from the terminal (whatever the user decides to type in). Similarly, because `domainify`
    is last in the chain, it will print its output to the terminal for the user to
    see. Along the way, the lines of words will be piped through other programs, giving
    each of them a chance to do their magic.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`synonyms`程序在我们的列表中排在第一位，所以它将接收来自终端的输入（无论用户决定输入什么）。同样，因为`domainify`在链中排在最后，所以它将打印输出到终端供用户查看。在这个过程中，单词行将通过其他程序进行管道传输，给每个程序一个施展魔法的机会。
- en: 'Type in a few words to see some domain suggestions; for example, when you type
    `chat` and hit return, you may see the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输入几个词以查看一些域名建议；例如，当你输入`chat`并按回车键时，你可能看到以下内容：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The number of suggestions you get will actually depend on the number of synonyms.
    This is because it is the only program that generates more lines of output than
    what we input.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的建议数量实际上取决于同义词的数量。这是因为它是唯一一个输出行数多于输入行的程序。
- en: 'We still haven''t solved our biggest problem: the fact that we have no idea
    whether the suggested domain names are actually available or not. So we still
    have to sit and type each one of them into a website. In the next section, we
    will address this issue.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有解决我们最大的问题：我们不知道建议的域名实际上是否可用。所以我们仍然需要坐下来逐个将它们输入到网站上。在下一节中，我们将解决这个问题。
- en: Available
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Available
- en: Our final program, Available, will connect to a WHOIS server to ask for details
    about the domains passed to it of course, if no details are returned, we can safely
    assume that the domain is available for purchase. Unfortunately, the WHOIS specification
    (see [http://tools.ietf.org/html/rfc3912](http://tools.ietf.org/html/rfc3912))
    is very small and contains no information about how a WHOIS server should reply
    when you ask for details about a domain. This means programmatically parsing the
    response becomes a messy endeavor. To address this issue for now, we will integrate
    with only a single WHOIS server, which we can be sure will have `No match` somewhere
    in the response when it has no records for the domain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的程序，Available，将连接到WHOIS服务器以获取传递给它的域的详细信息，当然，如果没有返回详细信息，我们可以安全地假设该域名可供购买。不幸的是，WHOIS规范（见[http://tools.ietf.org/html/rfc3912](http://tools.ietf.org/html/rfc3912)）非常小，并且不包含有关当请求域名详细信息时WHOIS服务器应该如何回复的信息。这意味着程序化解析响应变成了一项繁琐的工作。为了解决这个问题，我们现在将仅与一个WHOIS服务器集成，我们可以确信当它没有该域的记录时，响应中会有“无匹配”字样。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A more robust solution is to have a WHOIS interface with a well-defined structure
    for the details and perhaps an error message for cases when the domain doesn't
    exist with different implementations for different WHOIS servers. As you can imagine,
    it's quite a project; it is perfect for an open source effort.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更健壮的解决方案是拥有一个WHOIS接口，具有定义良好的结构来显示详细信息，也许还有当域名不存在时的错误消息，以及针对不同WHOIS服务器的不同实现。正如你可以想象的那样，这是一个相当大的项目；它非常适合开源努力。
- en: 'Create a new folder called `available` alongside others and add a `main.go`
    file to it containing the following function code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他文件夹旁边创建一个名为`available`的新文件夹，并向其中添加一个`main.go`文件，包含以下函数代码：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `exists` function implements what little there is in the WHOIS specification
    by opening a connection to port `43` on the specified `whoisServer` instance with
    a call to `net.Dial`. We then defer the closing of the connection, which means
    that no matter how the function exits (successful, with an error, or even a panic),
    `Close()` will still be called on the `conn` connection. Once the connection is
    open, we simply write the domain followed by `rn` (the carriage return and linefeed
    characters). This is all that the specification tells us, so we are on our own
    from now on.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists` 函数通过调用 `net.Dial` 打开到指定 `whoisServer` 实例的 `43` 端口的连接来实现 WHOIS 规范中存在的内容。然后我们延迟关闭连接，这意味着无论函数如何退出（成功、错误，甚至恐慌），`Close()`
    都会在 `conn` 连接上被调用。一旦连接打开，我们只需写入域名后跟 `rn`（回车和换行字符）。这就是规范告诉我们的全部内容，所以从现在起我们就得自己动手了。'
- en: Essentially, we are looking for some mention of "no match" in the response,
    and this is how we will decide whether a domain exists or not (`exists` in this
    case is actually just asking the WHOIS server whether it has a record for the
    domain we specified). We use our favorite `bufio.Scanner` method to help us iterate
    over the lines in the response. Passing the connection to `NewScanner` works because
    `net.Conn` is actually an `io.Reader` too. We use `strings.ToLower` so we don't
    have to worry about case sensitivity and `strings.Contains` to check whether any
    one of the lines contains the `no match` text. If it does, we return `false` (since
    the domain doesn't exist); otherwise, we return `true`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们正在寻找响应中提到“没有匹配”的内容，这就是我们将如何决定域名是否存在（在这种情况下，`exists` 实际上是在询问 WHOIS 服务器是否有我们指定的域名的记录）。我们使用我们最喜欢的
    `bufio.Scanner` 方法来帮助我们遍历响应中的行。将连接传递给 `NewScanner` 是可行的，因为 `net.Conn` 实际上也是一个
    `io.Reader`。我们使用 `strings.ToLower` 以免担心大小写敏感，并使用 `strings.Contains` 来检查是否有任何一行包含
    `no match` 文本。如果有，我们返回 `false`（因为域名不存在）；否则，我们返回 `true`。
- en: The `com.whois-servers.net` WHOIS service supports domain names for `.com` and
    `.net`, which is why the Domainify program only adds these types of domains. If
    you had used a server that had WHOIS information for a wider selection of domains,
    you could have added support for additional TLDs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`com.whois-servers.net` WHOIS 服务支持 `.com` 和 `.net` 域名，这就是为什么 Domainify 程序只添加这些类型的域名。如果你使用了一个提供更广泛域名
    WHOIS 信息的服务器，你可以添加对其他顶级域（TLD）的支持。'
- en: Let's add a `main` function that uses our `exists` function to check whether
    the incoming domains are available or not. The check mark and cross mark symbols
    in the following code are optional if your terminal doesn't support them you are
    free to substitute them with simple `Yes` and `No` strings.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个 `main` 函数，使用我们的 `exists` 函数来检查传入的域名是否可用。以下代码中的勾号和叉号符号是可选的，如果你的终端不支持它们，你可以自由地将它们替换为简单的
    `Yes` 和 `No` 字符串。
- en: 'Add the following code to `main.go`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main.go` 中：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the check and cross characters in our code happily because all Go
    code files are UTF-8 compliant the best way to actually get these characters is
    to search the Web for them and use the copy and paste option to bring them into
    our code. Otherwise, there are platform-dependent ways to get such special characters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在代码中愉快地使用勾号和叉号字符，因为所有 Go 代码文件都是 UTF-8 兼容的。实际上获取这些字符的最佳方式是搜索网络并使用复制粘贴选项将它们带入我们的代码。否则，有平台依赖的方式可以获取这样的特殊字符。
- en: In the preceding code for the `main` function, we simply iterate over each line
    coming in via `os.Stdin`. This process helps us print out the domain with `fmt.Print`
    (but not `fmt.Println`, as we do not want the linefeed yet), call our `exists`
    function to check whether the domain exists or not, and print out the result with
    `fmt.Println` (because we *do* want a linefeed at the end).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个 `main` 函数的代码中，我们简单地遍历通过 `os.Stdin` 进来的每一行。这个过程帮助我们使用 `fmt.Print` 打印出域名（但不是
    `fmt.Println`，因为我们还不想要换行符），调用我们的 `exists` 函数来检查域名是否存在，并使用 `fmt.Println` 打印出结果（因为我们确实想要在末尾有一个换行符）。
- en: Finally, we use `time.Sleep` to tell the process to do nothing for a second
    in order to make sure we take it easy on the WHOIS server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `time.Sleep` 来告诉进程在一秒钟内什么也不做，以确保我们对 WHOIS 服务器不要太苛刻。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Most WHOIS servers will be limited in various ways in order to prevent you from
    taking up too much in terms of resources. So, slowing things down is a sensible
    way to make sure we don't make the remote servers angry.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 WHOIS 服务器都会以各种方式受限，以防止你占用过多的资源。因此，放慢速度是一种合理的做法，以确保我们不会让远程服务器生气。
- en: Consider what this also means for unit tests. If a unit test were actually making
    real requests to a remote WHOIS server, every time your tests run, you will be
    clocking up statistics against your IP address. A much better approach would be
    to stub the WHOIS server to simulate responses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这也对单元测试意味着什么。如果一个单元测试实际上正在向远程WHOIS服务器发送真实请求，每次你的测试运行时，你都会对你的IP地址进行统计。一个更好的方法是对WHOIS服务器进行存根以模拟响应。
- en: The `marks` map at the top is a nice way to map the `bool` response from `exists`
    to human-readable text, allowing us to just print the response in a single line
    using `fmt.Println(marks[!exist])`. We are saying *not exist* because our program
    is checking whether the domain is available or not (logically, the opposite of
    whether it exists in the WHOIS server or not).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的`marks`映射是一个将`bool`响应从`exists`映射到可读文本的好方法，允许我们只需使用`fmt.Println(marks[!exist])`在单行中打印出响应。我们说*不存在*，因为我们的程序正在检查域名是否可用（逻辑上，这是否存在于WHOIS服务器中的对立面）。
- en: 'After fixing the import statements for the main.go file, we can try out Available
    to see whether the domain names are available or not by typing the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复main.go文件的导入语句后，我们可以尝试运行Available，通过输入以下命令来查看域名是否可用：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once Available is running, type in some domain names and see the result appear
    on the next line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Available开始运行，输入一些域名，并查看结果出现在下一行：
- en: '![Available](img/00056.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![可用](img/00056.jpeg)'
- en: As you can see, for domains that are not available, we get a little cross mark
    next to them; however, when we make up a domain name using random numbers, we
    see that it is indeed available.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于不可用的域名，我们在它们旁边得到一个小十字标记；然而，当我们使用随机数字创建域名时，我们看到它确实是可用的。
- en: Composing all five programs
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合所有五个程序
- en: 'Now that we have completed all five programs, it''s time to put them all together
    so that we can use our tool to find an available domain name for our chat application.
    The simplest way to do this is to use the technique we have been using throughout
    this chapter: using pipes in a terminal to connect the output and input.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有五个程序，是时候将它们全部组合起来，这样我们就可以使用我们的工具为我们的聊天应用程序找到一个可用的域名。最简单的方法是使用我们在本章中一直在使用的技术：在终端中使用管道连接输出和输入。
- en: 'In the terminal, navigate to the parent folder of the five programs and run
    the following single line of code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到五个程序的父文件夹，并运行以下单行代码：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the programs are running, type in a starting word and see how it generates
    suggestions before checking their availability.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序开始运行，输入一个起始词，看看它如何生成建议，然后再检查它们的可用性。
- en: 'For example, typing in `chat` might cause the programs to take the following
    actions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，输入`chat`可能会使程序执行以下操作：
- en: 'The word `chat` goes into `synonyms`, which results in a series of synonyms:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词`chat`进入`synonyms`，这导致一系列同义词：
- en: confab
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: confab
- en: confabulation
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: confabulation
- en: schmooze
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: schmooze
- en: 'The synonyms flow into `sprinkle`; here they are augmented with web-friendly
    prefixes and suffixes, such as the following:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同义词流入`sprinkle`；在这里，它们被添加了网络友好的前缀和后缀，如下所示：
- en: confabapp
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: confabapp
- en: goconfabulation
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: goconfabulation
- en: schmooze time
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: schmooze time
- en: 'These new words flow into `coolify`; here the vowels are potentially tweaked:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些新词流入`coolify`；在这里，元音可能被调整：
- en: confabaapp
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: confabaapp
- en: goconfabulatioon
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: goconfabulatioon
- en: schmoooze time
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: schmoooze time
- en: 'The modified words then flow into `domainify`; here they are turned into valid
    domain names:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改后的单词随后流入`domainify`；在这里，它们被转换成有效的域名：
- en: confabaapp.com
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: confabaapp.com
- en: goconfabulatioon.net
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: goconfabulatioon.net
- en: schmooze-time.com
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: schmooze-time.com
- en: 'Finally, the domain names flow into `available`; here they are checked against
    the WHOIS server to see whether somebody has already taken the domain or not:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，域名流入`available`；在这里，它们会与WHOIS服务器进行核对，以查看是否有人已经注册了该域名：
- en: confabaapp.com ![Composing all five programs](img/00057.jpeg)
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: confabaapp.com ![组合所有五个程序](img/00057.jpeg)
- en: goconfabulatioon.net ![Composing all five programs](img/00058.jpeg)
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: goconfabulatioon.net ![组合所有五个程序](img/00058.jpeg)
- en: schmooze-time.com ![Composing all five programs](img/00058.jpeg)
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: schmooze-time.com ![组合所有五个程序](img/00058.jpeg)
- en: One program to rule them all
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一款程序统治一切
- en: Running our solution by piping programs together is an elegant form of architecture,
    but it doesn't have a very elegant interface. Specifically, whenever we want to
    run our solution, we have to type the long, messy line where each program is listed
    and separated by pipe characters. In this section, we are going to write a Go
    program that uses the `os/exec` package to run each subprogram while piping the
    output from one to the input of the next, as per our design.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过管道将程序连接起来运行是一种优雅的架构形式，但它的界面并不优雅。具体来说，每次我们想要运行我们的解决方案时，我们必须输入一个长而混乱的行，其中每个程序都列出来并通过管道字符分隔。在本节中，我们将编写一个
    Go 程序，该程序使用 `os/exec` 包来运行每个子程序，同时将一个程序的输出通过管道传递到下一个程序的输入，正如我们的设计一样。
- en: Create a new folder called `domainfinder` alongside the other five programs
    and create another new folder called `lib` inside this folder. The `lib` folder
    is where we will keep builds of our subprograms, but we don't want to copy and
    paste them every time we make a change. Instead, we will write a script that builds
    the subprograms and copies the binaries to the `lib` folder for us.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他五个程序旁边创建一个名为 `domainfinder` 的新文件夹，并在该文件夹内创建另一个名为 `lib` 的新文件夹。`lib` 文件夹是我们将保存子程序构建的地方，但我们不想每次更改时都复制粘贴。相反，我们将编写一个脚本来构建子程序并将二进制文件复制到
    `lib` 文件夹中。
- en: 'Create a new file called `build.sh` on Unix machines or `build.bat` for Windows
    and insert into it the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 机器上创建一个名为 `build.sh` 的新文件或在 Windows 上创建一个名为 `build.bat` 的新文件，并将以下代码插入到其中：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding script simply builds all our subprograms (including `domainfinder`,
    which we are yet to write), telling `go build` to place them in our `lib` folder.
    Be sure to give execution rights to the new script by doing `chmod +x build.sh`
    or something similar. Run this script from a terminal and look inside the `lib`
    folder to ensure that it has indeed placed the binaries for our subprograms.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本简单地构建了我们的所有子程序（包括我们尚未编写的 `domainfinder`），告诉 `go build` 将它们放置在我们的 `lib` 文件夹中。确保通过执行
    `chmod +x build.sh` 或类似操作为新脚本赋予执行权限。从终端运行此脚本，并检查 `lib` 文件夹以确保它确实放置了我们的子程序的二进制文件。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't worry about the `no buildable Go source files` error for now; it's just
    Go telling us that the `domainfinder` program doesn't have any `.go` files to
    build.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心 `没有可构建的 Go 源文件` 错误；这只是 Go 告诉我们 `domainfinder` 程序没有 `.go` 文件可以构建。
- en: 'Create a new file called `main.go` inside `domainfinder` and insert the following
    code into the file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `domainfinder` 内创建一个名为 `main.go` 的新文件，并将以下代码插入到文件中：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `os/exec` package gives us everything we need to work with to run external
    programs or commands from within Go programs. First, our `cmdChain` slice contains
    `*exec.Cmd` commands in the order in which we want to join them together.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`os/exec` 包为我们提供了在 Go 程序中运行外部程序或命令所需的一切。首先，我们的 `cmdChain` 切片包含我们想要按顺序连接的 `*exec.Cmd`
    命令。'
- en: At the top of the `main` function, we tie the `Stdin` (standard in stream) of
    the first program with the `os.Stdin` stream of this program and the `Stdout`
    (standard out stream) of the last program with the `os.Stdout` stream of this
    program. This means that, like before, we will be taking input through the standard
    input stream and writing output to the standard output stream.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数的顶部，我们将第一个程序的 `Stdin`（标准输入流）与该程序的 `os.Stdin` 流绑定，并将最后一个程序的 `Stdout`（标准输出流）与该程序的
    `os.Stdout` 流绑定。这意味着，就像之前一样，我们将通过标准输入流获取输入并将输出写入标准输出流。
- en: Our next block of code is where we join the subprograms together by iterating
    over each item and setting its `Stdin` to the `Stdout` stream of the program before
    it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的代码块是通过迭代每个项目并将它的 `Stdin` 设置为之前程序的 `Stdout` 流来连接子程序的。
- en: 'The following table shows each program with a description of where it gets
    its input from and where its output goes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个程序及其输入来源和输出去向的描述：
- en: '| **Program** | **Input (Stdin)** | **Output (Stdout)** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **程序** | **输入（标准输入）** | **输出（标准输出）** |'
- en: '| synonyms | The same `Stdin` as `domainfinder` | sprinkle |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 同义词 | 与 `domainfinder` 相同的 `Stdin` | sprinkle |'
- en: '| sprinkle | synonyms | coolify |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| sprinkle | 同义词 | coolify |'
- en: '| coolify | sprinkle | domainify |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| coolify | sprinkle | domainify |'
- en: '| domainify | coolify | available |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| domainify | coolify | available |'
- en: '| available | domainify | The same `Stdout` as `domainfinder` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| available | domainify | 与 `domainfinder` 相同的 `Stdout` |'
- en: We then iterate over each command calling the `Start` method, which runs the
    program in the background (as opposed to the `Run` method, which will block our
    code until the subprogram exists which would be no good since we will have to
    run five programs at the same time). If anything goes wrong, we bail with `log.Fatalln`;
    however, if the program starts successfully, we defer a call to kill the process.
    This helps us ensure the subprograms exit when our `main` function exits, which
    will be when the `domainfinder` program ends.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后遍历每个命令，调用`Start`方法，该方法在后台运行程序（与`Run`方法相反，它将阻塞我们的代码直到子程序存在，这会不好，因为我们将不得不同时运行五个程序）。如果发生任何错误，我们使用`log.Fatalln`退出；然而，如果程序成功启动，我们将延迟调用以终止进程。这有助于我们确保子程序在我们`main`函数退出时退出，这将是`domainfinder`程序结束时。
- en: Once all the programs start running, we iterate over every command again and
    wait for it to finish. This is to ensure that `domainfinder` doesn't exit early
    and kill off all the subprograms too soon.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有程序开始运行，我们再次遍历每个命令并等待其完成。这是为了确保`domainfinder`不会提前退出并过早地杀死所有子程序。
- en: Run the `build.sh` or `build.bat` script again and notice that the `domainfinder`
    program has the same behavior as we have seen before, with a much more elegant
    interface.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`build.sh`或`build.bat`脚本，注意`domainfinder`程序的行为与我们之前看到的行为相同，但界面更加优雅。
- en: 'The following screenshot shows the output from our programs when we type `clouds`;
    we have found quite a few available domain name options:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当我们输入`clouds`时我们程序的输出；我们找到了相当多的可用域名选项：
- en: '![One program to rule them all](img/00059.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![一个程序统治一切](img/00059.jpeg)'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how five small command-line programs can, when composed
    together, produce powerful results while remaining modular. We avoided tightly
    coupling our programs so they could still be useful in their own right. For example,
    we can use our Available program just to check whether the domain names we manually
    enter are available or not, or we can use our `synonyms` program just as a command-line
    thesaurus.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到五个小型命令行程序在组合在一起时可以产生强大的结果，同时保持模块化。我们避免了程序之间的紧密耦合，这样它们仍然可以单独使用。例如，我们可以使用我们的Available程序仅检查我们手动输入的域名是否可用，或者我们可以像命令行同义词词典一样使用我们的`synonyms`程序。
- en: We learned how standard streams could be used to build different flows of these
    types of programs and how the redirection of standard input and standard output
    lets us play around with different flows very easily.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到如何使用标准流构建这些类型程序的不同流程，以及标准输入和标准输出的重定向如何让我们能够非常容易地玩转不同的流程。
- en: We learned how simple it is in Go to consume a JSON RESTful API web service
    when we wanted to get the synonyms from Big Huge Thesaurus. We also consumed a
    non-HTTP API when we opened a connection to the WHOIS server and wrote data over
    raw TCP.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要从Big Huge Thesaurus获取同义词时，我们了解到在Go中消费JSON RESTful API web服务是多么简单。我们还消费了非HTTP
    API，当我们打开到WHOIS服务器的连接并使用原始TCP写入数据时。
- en: We saw how the `math/rand` package can bring a little variety and unpredictability
    by allowing us to use pseudo random numbers and decisions in our code, which means
    that each time we run our program, we will get different results.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`math/rand`包如何通过允许我们在代码中使用伪随机数和决策来带来一点多样性和不可预测性，这意味着每次我们运行程序时，我们都会得到不同的结果。
- en: Finally, we built our `domainfinder` super program that composes all the subprograms
    together, giving our solution a simple, clean, and elegant interface.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了`domainfinder`超级程序，将所有子程序组合在一起，为我们解决方案提供了一个简单、干净且优雅的界面。
- en: In the next chapter, we will take some ideas we have learned so far one step
    further by exploring how to connect programs using messaging queue technologies
    allowing them to distributed across many machines to achieve large scale.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索如何使用消息队列技术连接程序，使它们可以跨多台机器分布式运行，从而将我们迄今为止学到的某些想法进一步发展。
