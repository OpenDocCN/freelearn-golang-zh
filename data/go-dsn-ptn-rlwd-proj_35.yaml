- en: Chapter 9.  Building a Q&A Application for Google App Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：为 Google App Engine 构建 Q&A 应用程序
- en: Google App Engine gives developers a **NoOps** (short for **No Operations**,
    indicating that developers and engineers have no work to do in order to have their
    code running and available) way of deploying their applications, and Go has been
    officially supported as a language option for some years now. Google's architecture
    runs some of the biggest applications in the world, such as Google Search, Google
    Maps, and Gmail, among others, so is a pretty safe bet when it comes to deploying
    our own code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Google App Engine 为开发者提供了一种 **NoOps**（即 **No Operations**，表示开发者和工程师无需进行任何操作即可使代码运行并可用）的方式来部署他们的应用程序，而
    Go 语言已经作为官方支持的语言选项存在了数年。Google 的架构运行着世界上一些最大的应用程序，例如 Google 搜索、Google 地图和 Gmail
    等，因此在部署我们自己的代码时，这是一个相当安全的赌注。
- en: Google App Engine allows you to write a Go application, add a few special configuration
    files, and deploy it to Google's servers, where it will be hosted and made available
    in a highly available, scalable, and elastic environment. Instances will automatically
    spin up to meet demand and tear down gracefully when they are no longer needed
    with a healthy free quota and preapproved budgets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Google App Engine 允许你编写一个 Go 应用程序，添加一些特殊的配置文件，并将其部署到 Google 的服务器上，在那里它将被托管并在一个高度可用、可扩展和弹性的环境中提供。实例将自动启动以满足需求，并在不再需要时优雅地关闭，同时保持健康的免费配额和预先批准的预算。
- en: Along with running application instances, Google App Engine makes available
    a myriad of useful services, such as fast and high-scale data stores, search,
    memcache, and task queues. Transparent load balancing means you don't need to
    build and maintain additional software or hardware to ensure servers don't get
    overloaded and that requests are fulfilled quickly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行应用程序实例外，Google App Engine 还提供了一系列有用的服务，例如快速和大规模的数据存储、搜索、memcache 和任务队列。透明的负载均衡意味着你不需要构建和维护额外的软件或硬件来确保服务器不会过载，并且请求能够快速得到满足。
- en: In this chapter, we will build the API backend for a question and answer service
    similar to Stack Overflow or Quora and deploy it to Google App Engine. In the
    process, we'll explore techniques, patterns, and practices that can be applied
    to all such applications, as well as dive deep into some of the more useful services
    available to our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个类似于 Stack Overflow 或 Quora 的问答服务的 API 后端，并将其部署到 Google App Engine。在这个过程中，我们将探讨可以应用于所有此类应用程序的技术、模式和最佳实践，并深入了解一些对我们应用程序更有用的服务。
- en: 'Specifically, in this chapter, you will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，你将学习：
- en: How to use the Google App Engine SDK for Go to build and test applications locally
    before deploying to the cloud
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Google App Engine SDK for Go 在将应用程序部署到云端之前在本地构建和测试应用程序
- en: How to use `app.yaml` to configure your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `app.yaml` 配置你的应用程序
- en: How Modules in Google App Engine let you independently manage the different
    components that make up your application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google App Engine 中的模块如何让你独立管理构成应用程序的不同组件
- en: How the Google Cloud Datastore lets you persist and query data at scale
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Datastore 如何让你以规模化的方式持久化和查询数据
- en: A sensible pattern for the modeling of data and working with keys in Google
    Cloud Datastore
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Google Cloud Datastore 中建模数据和与键交互的合理模式
- en: How to use the Google App Engine Users API to authenticate people with Google
    accounts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Google App Engine Users API 对具有 Google 账户的人进行身份验证
- en: A pattern to embed denormalized data into entities
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将非规范化数据嵌入到实体中的模式
- en: How to ensure data integrity and build counters using transactions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保数据完整性和使用事务构建计数器
- en: Why maintaining a good line of sight in code helps improve maintainability
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在代码中保持良好的可读性有助于提高可维护性
- en: How to achieve simple HTTP routing without adding a dependency to a third-party
    package
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不添加第三方包依赖的情况下实现简单的 HTTP 路由
- en: The Google App Engine SDK for Go
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google App Engine SDK for Go
- en: In order to run and deploy Google App Engine applications, we must download
    and configure the Go SDK. Head over to [https://cloud.google.com/appengine/downloads](https://cloud.google.com/appengine/downloads)
    and download the latest *Google App Engine SDK for Go* for your computer. The
    ZIP file contains a folder called `go_appengine`, which you should place in an
    appropriate folder outside of your `GOPATH`, for example, in `/Users/yourname/work/go_appengine`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行和部署 Google App Engine 应用程序，我们必须下载和配置 Go SDK。请访问 [https://cloud.google.com/appengine/downloads](https://cloud.google.com/appengine/downloads)
    并下载适用于您计算机的最新 *Google App Engine SDK for Go*。ZIP 文件包含一个名为 `go_appengine` 的文件夹，您应该将其放置在
    `GOPATH` 外的适当文件夹中，例如，在 `/Users/yourname/work/go_appengine`。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is possible that the names of these SDKs will change in the future; if that
    happens, ensure that you consult the project home page for notes pointing you
    in the right direction at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SDK 的名称将来可能会更改；如果发生这种情况，请确保您查阅项目主页上的说明，这些说明会在 [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    指引您正确的方向。
- en: Next, you will need to add the `go_appengine` folder to your `$PATH` environment
    variable, much like what you did with the `go` folder when you first configured
    Go.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要将 `go_appengine` 文件夹添加到您的 `$PATH` 环境变量中，就像您第一次配置 Go 时对 `go` 文件夹所做的那样。
- en: 'To test your installation, open a terminal and type this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的安装，请打开终端并输入以下内容：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see something like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会看到以下类似的内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The actual version of Go is likely to differ and is often a few months behind
    actual Go releases. This is because the Cloud Platform team at Google needs to
    do work on its end to support new releases of Go.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 Go 版本可能有所不同，通常比实际的 Go 发布版落后几个月。这是因为 Google 的云平台团队需要在其端进行工作以支持 Go 的新版本。
- en: The `goapp` command is a drop-in replacement for the `go` command with a few
    additional subcommands; so you can do things like `goapp test` and `goapp vet`,
    for example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`goapp` 命令是 `go` 命令的替代品，具有一些额外的子命令；因此，您可以执行类似 `goapp test` 和 `goapp vet` 之类的操作。'
- en: Creating your application
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的应用程序
- en: In order to deploy an application to Google's servers, we must use the Google
    Cloud Platform Console to set it up. In a browser, go to [https://console.cloud.google.com](https://console.cloud.google.com/)
    and sign in with your Google account. Look for the **Create Project** menu item,
    which often gets moved around as the console changes from time to time. If you
    already have some projects, click on a project name to open a submenu, and you'll
    find it in there.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将应用程序部署到 Google 的服务器，我们必须使用 Google Cloud Platform 控制台来设置它。在浏览器中，转到 [https://console.cloud.google.com](https://console.cloud.google.com/)
    并使用您的 Google 账户登录。寻找 **创建项目** 菜单项，该菜单项通常会随着控制台的偶尔更改而移动。如果您已经有了一些项目，请点击项目名称以打开子菜单，您将在其中找到它。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you can't find what you're looking for, just search **Creating App Engine
    project** and you'll find it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到您想要的内容，只需搜索 **创建 App Engine 项目**，您就会找到它。
- en: When the **New Project** dialog box opens, you will be asked for a name for
    your application. You are free to call it whatever you like (for example, Answers),
    but note the Project ID that is generated for you; you will need to refer to this
    when you configure your app later. You can also click on **Edit** and specify
    your own ID, but know that the value must be globally unique, so you'll have to
    get creative when thinking one up. In this book, we will use `answersapp` as the
    application ID, but you won't be able to use that one since it has already been
    taken.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **新建项目** 对话框打开时，您将被要求为您的应用程序提供一个名称。您可以随意命名（例如，Answers），但请注意为您生成的项目 ID；您稍后配置应用程序时需要引用它。您还可以点击
    **编辑** 并指定您自己的 ID，但请注意，该值必须是全局唯一的，因此您在构思时需要发挥创意。在这本书中，我们将使用 `answersapp` 作为应用程序
    ID，但您无法使用它，因为它已经被占用。
- en: You may need to wait a minute or two for your project to get created; there's
    no need to watch the page you can continue and check back later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要等待一分钟或两分钟以创建您的项目；您不需要监视页面，您可以继续并稍后检查。
- en: App Engine applications are Go packages
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: App Engine 应用程序是 Go 包
- en: Now that the Google App Engine SDK for Go is configured and our application
    has been created, we can start building it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Google App Engine SDK for Go 已配置，我们的应用程序也已创建，我们可以开始构建它了。
- en: In Google App Engine, an application is just a normal Go package with an `init`
    function that registers handlers via the `http.Handle` or `http.HandleFunc` functions.
    It does not need to be the `main` package like normal tools.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google App Engine中，一个应用程序只是一个带有`init`函数的正常Go包，该函数通过`http.Handle`或`http.HandleFunc`函数注册处理程序。它不需要像正常工具那样是`main`包。
- en: 'Create a new folder (somewhere inside your `GOPATH` folder) called `answersapp/api`
    and add the following `main.go` file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`GOPATH`文件夹内创建一个名为`answersapp/api`的新文件夹，并添加以下`main.go`文件：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will be familiar with most of this by now, but note that there is no `ListenAndServe`
    call, and the handlers are set inside the `init` function rather than `main`.
    We are going to handle every request with our simple `handleHello` function, which
    will just write a welcoming string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉大部分内容，但请注意，没有`ListenAndServe`调用，处理程序是在`init`函数中而不是`main`函数中设置的。我们将使用简单的`handleHello`函数来处理每个请求，该函数将只写入欢迎字符串。
- en: The app.yaml file
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: app.yaml文件
- en: 'In order to turn our simple Go package into a Google App Engine application,
    we must add a special configuration file called `app.yaml`. The file will go at
    the root of the application or module, so create it inside the `answersapp/api`
    folder with the following contents:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的简单Go包转换为Google App Engine应用程序，我们必须添加一个特殊的配置文件，称为`app.yaml`。该文件将位于应用程序或模块的根目录下，因此请在`answersapp/api`文件夹内创建它，并包含以下内容：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The file is a simple human-(and machine) readable configuration file in **YAML**
    (**Yet Another Markup Language** format refer to yaml.org for more details). The
    following table describes each property:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件是一个简单的人类（和机器）可读的配置文件，以**YAML**（**另一种标记语言**）格式。以下表格描述了每个属性：
- en: '| **Property** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `application` | The application ID (copied and pasted from when you created
    your project). |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `application` | 应用程序ID（在创建项目时复制粘贴的）。 |'
- en: '| `version` | Your application version number you can deploy multiple versions
    and even split traffic between them to test new features, among other things.
    We''ll just stick with version 1 for now. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `version` | 你的应用程序版本号。你可以部署多个版本，甚至可以在它们之间分割流量来测试新功能等。我们现在将坚持使用版本1。 |'
- en: '| `runtime` | The name of the runtime that will execute your application. Since
    this is a Go book and since we''re building a Go application, we''ll use `go`.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `runtime` | 将执行你的应用程序的运行时名称。由于这是一本Go书，而且我们正在构建Go应用程序，我们将使用`go`。 |'
- en: '| `api_version` | The `go1` api version is the runtime version supported by
    Google; you can imagine that this could be `go2` in the future. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `api_version` | `go1` api版本是Google支持的运行时版本；你可以想象未来这可能是`go2`。 |'
- en: '| `handlers` | A selection of configured URL mappings. In our case, everything
    will be mapped to the special `_go_app` script, but you can also specify static
    files and folders here. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `handlers` | 配置的URL映射的选择。在我们的例子中，所有内容都将映射到特殊`_go_app`脚本，但你也可以在这里指定静态文件和文件夹。
    |'
- en: Running simple applications locally
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地运行简单应用程序
- en: Before we deploy our application, it makes sense to test it locally. We can
    do this using the App Engine SDK we downloaded earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署应用程序之前，在本地测试它是有意义的。我们可以使用我们之前下载的App Engine SDK来完成这项工作。
- en: 'Navigate to your `answersapp/api` folder and run the following command in a
    terminal:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到你的`answersapp/api`文件夹，并在终端中运行以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should see the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Running simple applications locally](img/00063.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![在本地运行简单应用程序](img/00063.jpeg)'
- en: This indicates that an API server is running locally on port `:56443`, an admin
    server is running on :`8000`, and our application (the module `default`) is now
    serving at `localhost:8080`, so let's hit that one in a browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示API服务器正在本地端口`:56443`上运行，管理服务器正在`:8000`上运行，我们的应用程序（默认模块）现在在`localhost:8080`上提供服务，所以让我们在浏览器中打开它。
- en: '![Running simple applications locally](img/00064.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![在本地运行简单应用程序](img/00064.jpeg)'
- en: As you can see by the `Hello from App Engine` response, our application is running
    locally. Navigate to the admin server by changing the port from `:8080` to `:8000`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过`Hello from App Engine`响应，我们的应用程序正在本地运行。通过将端口从`:8080`更改为`:8000`，导航到管理服务器。
- en: '![Running simple applications locally](img/00065.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![在本地运行简单应用程序](img/00065.jpeg)'
- en: The preceding screenshot shows the web portal that we can use to interrogate
    the internals of our application, including viewing running instances, inspecting
    the data store, managing task queues, and more.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了我们可以用来查询应用程序内部结构的Web门户，包括查看运行实例、检查数据存储、管理任务队列等。
- en: Deploying simple applications to Google App Engine
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将简单应用程序部署到 Google App Engine
- en: 'To truly understand the power of Google App Engine''s NoOps promise, we are
    going to deploy this simple application to the cloud. Back in the terminal, stop
    the server by hitting *Ctrl*+*C* and run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正理解 Google App Engine 无操作（NoOps）承诺的力量，我们将把这个简单应用程序部署到云端。回到终端，通过按 *Ctrl*+*C*
    停止服务器，并运行以下命令：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your application will be packaged and uploaded to Google''s servers. Once it''s
    finished, you should see something like the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序将被打包并上传到 Google 的服务器。一旦完成，您应该看到以下类似的内容：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It really is as simple as that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是这样简单。
- en: You can prove this by navigating to the endpoint you get for free with every
    Google App Engine application, remembering to replace the application ID with
    your own: `https://YOUR_APPLICATION_ID_HERE.appspot.com/`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到每个 Google App Engine 应用程序免费提供的端点来证明这一点，记得用您自己的应用程序 ID 替换：`https://YOUR_APPLICATION_ID_HERE.appspot.com/`。
- en: You will see the same output as earlier (the font may render differently since
    Google's servers will make assumptions about the content type that the local dev
    server doesn't).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到与之前相同的输出（字体渲染可能会有所不同，因为 Google 的服务器将对内容类型做出假设，而本地开发服务器不会）。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application is being served over HTTP/2 and is already capable of pretty
    massive scale, and all we did was write a `config` file and a few lines of code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在通过 HTTP/2 提供，并且已经能够处理相当大的规模，而我们所做的只是编写一个 `config` 文件和几行代码。
- en: Modules in Google App Engine
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google App Engine 中的模块
- en: A module is a Go package that can be versioned, updated, and managed independently.
    An app might have a single module, or it can be made up of many modules, each
    distinct but part of the same application with access to the same data and services.
    An application must have a default module even if it doesn't do much.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个可以版本化、更新和管理独立的 Go 包。一个应用程序可能只有一个模块，或者它可以由许多模块组成，每个模块都是独立的，但又是同一应用程序的一部分，可以访问相同的数据和服务。即使应用程序没有做很多事情，它也必须有一个默认模块。
- en: 'Our application will be made up of the following modules:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将由以下模块组成：
- en: '| **Description** | **The module name** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **模块名称** |'
- en: '| The obligatory default module | default |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 必要的默认模块 | default |'
- en: '| An API package delivering RESTful JSON | api |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 提供RESTful JSON的API包 | api |'
- en: '| A static website serving HTML, CSS, and JavaScript that makes AJAX calls
    to the API module | web |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 提供HTML、CSS和JavaScript的静态网站，该网站向API模块发出AJAX调用 | web |'
- en: Each module will be a Go package and will, therefore, live inside its own folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都将是一个 Go 包，因此将存在于自己的文件夹中。
- en: Let's reorganize our project into modules by creating a new folder alongside
    the `api` folder called `default`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在 `api` 文件夹旁边创建一个新的文件夹来重新组织我们的项目，命名为 `default`。
- en: We are not going to make our default module do anything other than use it for
    configuration, as we want our other modules to do all the meaningful work. But
    if we leave this folder empty, the Google App Engine SDK will complain that it
    has nothing to build.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会让默认模块做任何其他事情，除了用它来配置，因为我们希望其他模块做所有有意义的工作。但如果我们让这个文件夹为空，Google App Engine
    SDK 将会抱怨它没有东西可以构建。
- en: 'Inside the `default` folder, add the following placeholder `main.go` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `default` 文件夹内，添加以下占位符 `main.go` 文件：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This file does nothing except allow our `default` module to exist
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件什么也不做，只是允许我们的 `default` 模块存在
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It would have been nice for our package names to match the folders, but `default`
    is a reserved keyword in Go, so we have a good reason to break that rule.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的包名能与文件夹匹配，那将很好，但 `default` 是 Go 中的一个保留关键字，所以我们有很好的理由打破这个规则。
- en: The other module in our application will be called `web`, so create another
    folder alongside the `api` and `default` folders called `web`. In this chapter,
    we are only going to build the API for our application and cheat by downloading
    the web module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的另一个模块将被命名为 `web`，所以创建一个与 `api` 和 `default` 文件夹并排的新文件夹，命名为 `web`。在这一章中，我们只将构建我们应用程序的
    API，并通过下载网络模块来作弊。
- en: Head over to the project home page at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints),
    access the content for **Second Edition**, and look for the download link for
    the *web components for* [Chapter 9](part0201_split_000.html#5VM122-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 9.  Building a Q&A Application for Google App Engine"), *Building a Q&A
    Application for Google App Engine* in the Downloads section of the `README` file.
    The ZIP file contains the source files for the web component, which should be
    unzipped and placed inside the `web` folder.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问项目主页[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)，访问**第二版**的内容，并在`README`文件的下载部分查找[第9章](part0201_split_000.html#5VM122-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第9章。为Google App Engine构建问答应用")的*Web组件*下载链接，即*为Google App Engine构建问答应用*。ZIP文件包含Web组件的源文件，应将其解压缩并放置在`web`文件夹内。
- en: 'Now, our application structure should look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序结构应该看起来像这样：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Specifying modules
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定模块
- en: 'To specify which module our `api` package will become, we must add a property
    to the `app.yaml` inside our **api** folder. Update it to include the `module`
    property:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定我们的`api`包将成为哪个模块，我们必须在我们的**api**文件夹中的`app.yaml`中添加一个属性。更新它以包含`module`属性：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since our default module will need to be deployed as well, we also need to
    add an `app.yaml` configuration file to it. Duplicate the `api/app.yaml` file
    inside `default/app.yaml`, changing the module to `default`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的默认模块也需要部署，因此我们还需要向其中添加一个`app.yaml`配置文件。在`default/app.yaml`中复制`api/app.yaml`文件，将模块更改为`default`：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Routing to modules with dispatch.yaml
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用dispatch.yaml路由到模块
- en: In order to route traffic appropriately to our modules, we will create another
    configuration file called `dispatch.yaml`, which will let us map URL patterns
    to the modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将流量适当地路由到我们的模块，我们将创建另一个名为`dispatch.yaml`的配置文件，它将允许我们将URL模式映射到模块。
- en: We want all traffic beginning with the `/api/` path to be routed to the `api`
    module and everything else to the `web` module. As mentioned earlier, we won't
    expect our `default` module to handle any traffic, but it will have more utility
    later.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望所有以`/api/`路径开始的流量都路由到`api`模块，其他所有内容都路由到`web`模块。如前所述，我们不会期望我们的`default`模块处理任何流量，但它在以后会有更多用途。
- en: 'In the `answersapp` folder (alongside our module folders not inside any of
    the module folders), create a new file called `dispatch.yaml` with the following
    contents:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`answersapp`文件夹中（位于我们的模块文件夹之外），创建一个名为`dispatch.yaml`的新文件，内容如下：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The same `application` property tells the Google App Engine SDK for Go which
    application we are referring to, and the `dispatch` section routes URLs to modules.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的`application`属性告诉Google App Engine SDK for Go我们正在引用哪个应用程序，而`dispatch`部分将URL路由到模块。
- en: Google Cloud Datastore
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Datastore
- en: One of the services available to App Engine developers is Google Cloud Datastore,
    a NoSQL document database built for automatic scaling and high performance. Its
    limited featureset guarantees very high scale, but understanding the caveats and
    best practices is vital to a successful project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine开发者可用的服务之一是Google Cloud Datastore，这是一个为自动扩展和高性能而构建的NoSQL文档数据库。其有限的功能集保证了非常高的可扩展性，但了解注意事项和最佳实践对于成功项目至关重要。
- en: Denormalizing data
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反规范化数据
- en: Developers with experience of relational databases (RDBMS) will often aim to
    reduce data redundancy (trying to have each piece of data appear only once in
    their database) by **normalizing** data, spreading it across many tables, and
    adding references (foreign keys) before joining it back via a query to build a
    complete picture. In schemaless and NoSQL databases, we tend to do the opposite.
    We **denormalize** data so that each document contains the complete picture it
    needs, making read times extremely fast since it only needs to go and get a single
    thing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 具有关系型数据库（RDBMS）经验的开发者通常会通过**规范化**数据，将其分散到多个表中，并在合并之前添加引用（外键），以减少数据冗余（试图让每条数据只在其数据库中显示一次），从而构建一个完整的图像。在无模式数据库和NoSQL数据库中，我们倾向于做相反的事情。我们**反规范化**数据，以便每个文档都包含它需要的完整图像，这使得读取时间极快，因为它只需要获取一个单一的事物。
- en: 'For example, consider how we might model tweets in a relational database such
    as MySQL or Postgres:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们如何在MySQL或Postgres等关系型数据库中建模推文：
- en: '![Denormalizing data](img/00066.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![反规范化数据](img/00066.jpeg)'
- en: A tweet itself contains only its unique ID, a foreign key reference to the Users
    table representing the author of the tweet, and perhaps many URLs that were mentioned
    in `TweetBody`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个推文本身只包含其唯一的ID，一个指向表示推文作者的Users表的键外参照，以及可能在`TweetBody`中提到的许多URL。
- en: One nice feature of this design is that a user can change their Name or AvatarURL
    and it will be reflected in all of their tweets, past and future, something you
    wouldn't get for free in a denormalized world.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的一个优点是，用户可以更改他们的名字或头像URL，这将反映在他们过去和未来的所有推文中，这在去规范化世界中是免费的。
- en: However, in order to present a tweet to the user, we must load the tweet itself,
    look up (via a join) the user to get their name and avatar URL, and then load
    the associated data from the URLs table in order to show a preview of any links.
    At scale, this becomes difficult because all three tables of data might well be
    physically separated from each other, which means lots of things need to happen
    in order to build up this complete picture.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了向用户展示推文，我们必须加载推文本身，通过连接查找用户以获取他们的名字和头像URL，然后从URL表加载相关数据以显示链接的预览。在规模上，这变得很困难，因为这三个数据表可能物理上彼此分离，这意味着需要发生很多事情才能构建出这个完整的画面。
- en: 'Consider what a denormalized design would look like instead:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下去规范化设计会是什么样子：
- en: '![Denormalizing data](img/00067.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![去规范化数据](img/00067.jpeg)'
- en: We still have the same three buckets of data, except that now our tweet contains
    everything it needs in order to render to the user without having to look up data
    from anywhere else. The hardcore relational database designers out there are realizing
    what this means by now, and it is no doubt making them feel uneasy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有相同的三类数据，但现在我们的推文包含了渲染给用户所需的所有内容，而无需从其他地方查找数据。现在，那些硬核的关系型数据库设计者已经意识到这意味着什么，这无疑让他们感到不安。
- en: 'Following this approach means that:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法意味着：
- en: Data is repeated - `AvatarURL` in User is repeated as `UserAvatarURL` in the
    tweet (waste of space, right?)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是重复的 - 用户中的`AvatarURL`在推文中重复为`UserAvatarURL`（空间浪费，对吧？）
- en: If the user changes their `AvatarURL`, `UserAvatarURL` in the tweet will be
    out of date
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户更改了`AvatarURL`，推文中的`UserAvatarURL`将过时
- en: Database design, at the end of the day, comes down to physics. We are deciding
    that our tweet is going to be read far more times than it is going to be written,
    so we'd rather take the pain upfront and take a hit in storage. There's nothing
    wrong with repeated data as long as there is an understanding about which set
    is the master set and which is duplicated for speed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，数据库设计归结于物理层面。我们决定我们的推文将被阅读得比被写入的次数多得多，所以我们宁愿在前期承受痛苦并在存储上做出牺牲。只要理解了哪个集合是主集合，哪个是为了速度而复制的，重复的数据就没有什么问题。
- en: Changing data is an interesting topic in itself, but let's think about a few
    reasons why we might be OK with the trade-offs.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的变更本身就是一个有趣的话题，但让我们思考一下我们可能为什么接受这种权衡。
- en: Firstly, the speed benefit to reading tweets is probably worth the unexpected
    behavior of changes to master data not being reflected in historical documents;
    it would be perfectly acceptable to decide to live with this emerged functionality
    for that reason.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，读取推文的速度优势可能值得主数据变更未反映在历史文档中的意外行为；出于这个原因，决定接受这种出现的功能是完全可以接受的。
- en: Secondly, we might decide that it makes sense to keep a snapshot of data at
    a specific moment in time. For example, imagine if someone tweets asking whether
    people like their profile picture. If the picture changed, the tweet context would
    be lost. For a more serious example, consider what might happen if you were pointing
    to a row in an Addresses table for an order delivery and the address later changed.
    Suddenly, the order might look like it was shipped to a different place.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可能会决定保留特定时间点的数据快照是有意义的。例如，想象一下如果有人发推文询问人们是否喜欢他们的个人资料图片。如果图片改变了，推文上下文就会丢失。对于更严重的例子，考虑一下如果你在指向订单交付的地址表中的一行，而地址后来发生了变化，会发生什么。突然之间，订单可能看起来像被运往了不同的地方。
- en: Finally, storage is becoming increasingly cheaper, so the need for normalizing
    data to save space is lessened. Twitter even goes as far as copying the entire
    tweet document for each of your followers. 100 followers on Twitter means that
    your tweet will be copied at least 100 times, maybe more for redundancy. This
    sounds like madness to relational database enthusiasts, but Twitter is making
    smart trade-offs based on its user experience; they'll happily spend a lot of
    time writing a tweet and storing it many times to ensure that when you refresh
    your feed, you don't have to wait very long to get updates.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，存储变得越来越便宜，因此为了节省空间而进行数据规范化的需求减少了。Twitter甚至将每个粉丝的整个推文文档都复制过来。在Twitter上有100个粉丝意味着你的推文至少会被复制100次，可能更多以增加冗余。这对关系型数据库爱好者来说听起来像是疯狂，但Twitter正在基于其用户体验做出明智的权衡；他们愿意花很多时间写推文并多次存储，以确保当你刷新你的信息流时，你不必等待很长时间才能获取更新。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to get a sense of the scale of this, check out the Twitter API and
    look at what a tweet document consists of. It's a lot of data. Then, go and look
    at how many followers Lady Gaga has. This has become known in some circles as
    "the Lady Gaga problem" and is addressed by a variety of different technologies
    and techniques that are out of the scope of this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解这个规模的感受，请查看Twitter API并查看一条推文文档包含的内容。这是一大批数据。然后，去看看Lady Gaga有多少粉丝。这在某些圈子中被称为“Lady
    Gaga问题”，并且通过各种不同的技术和方法来解决，这些技术和方法超出了本章的范围。
- en: Now that we have an understanding of good NoSQL design practices, let's implement
    the types, functions, and methods required to drive the data part of our API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了良好的NoSQL设计实践，让我们实现驱动我们API数据部分的类型、函数和方法。
- en: Entities and data access
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和数据访问
- en: To persist data in Google Cloud Datastore, we need a struct to represent each
    entity. These entity structures will be serialized and deserialized when we save
    and load data through the `datastore` API. We can add helper methods to perform
    the interactions with the data store, which is a nice way to keep such functionality
    physically close to the entities themselves. For example, we will model an answer
    with a struct called `Answer` and add a `Create` method that in turn calls the
    appropriate function from the `datastore` package. This prevents us from bloating
    our HTTP handlers with lots of data access code and allows us to keep them clean
    and simple instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Google Cloud Datastore中持久化数据，我们需要一个结构体来表示每个实体。这些实体结构体将在我们通过`datastore`API保存和加载数据时进行序列化和反序列化。我们可以添加辅助方法来执行与数据存储的交互，这是一种将此类功能物理上靠近实体的好方法。例如，我们将使用名为`Answer`的结构体来建模答案，并添加一个`Create`方法，该方法会调用`datastore`包中的适当函数。这防止了我们的HTTP处理器因为大量的数据访问代码而膨胀，并允许我们保持它们的简洁和简单。
- en: One of the foundation blocks of our application is the concept of a question.
    A question can be asked by a user and answered by many. It will have a unique
    ID so that it is addressable (referable in a URL), and we'll store a timestamp
    of when it was created.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用的基础块之一是问题的概念。一个问题可以被用户提出并由多人回答。它将有一个唯一的ID，以便它是可寻址的（可以在URL中引用），我们还会存储创建时的时间戳。
- en: 'Create a new file inside `answersapp` called `questions.go` and add the following
    `struct` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`answersapp`内部创建一个名为`questions.go`的新文件，并添加以下`struct`函数：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The structure describes a question in our application. Most of it will seem
    quite obvious, as we've done similar things in the previous chapters. The `UserCard`
    struct represents a denormalized `User` entity, both of which we'll add later.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结构描述了我们应用中的一个问题。其中大部分内容看起来相当明显，因为我们已经在之前的章节中做过类似的事情。`UserCard`结构体代表一个非规范化的`User`实体，这两个我们都会稍后添加。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can import the `datastore` package in your Go project using this: `import
    "google.golang.org/appengine/datastore"`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式在你的Go项目中导入`datastore`包：`import "google.golang.org/appengine/datastore"`
- en: It's worth spending a little time understanding the `datastore.Key` type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花点时间理解`datastore.Key`类型。
- en: Keys in Google Cloud Datastore
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google Cloud Datastore中的键
- en: Every entity in Datastore has a key, which uniquely identifies it. They can
    be made up of either a string or an integer depending on what makes sense for
    your case. You are free to decide the keys for yourself or let Datastore automatically
    assign them for you; again, your use case will usually decide which is the best
    approach to take and we'll explore both in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Datastore中的每个实体都有一个键，它唯一地标识了它。它们可以由字符串或整数组成，具体取决于你的情况。你可以自己决定键，或者让Datastore为你自动分配它们；再次强调，你的用例通常将决定哪种方法最好，我们将在本章中探讨这两种方法。
- en: Keys are created using the `datastore.NewKey` and `datastore.NewIncompleteKey`
    functions and are used to put and get data into and out of Datastore via the `datastore.Get`
    and `datastore.Put` functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 键是通过`datastore.NewKey`和`datastore.NewIncompleteKey`函数创建的，并且通过`datastore.Get`和`datastore.Put`函数将数据放入和从Datastore中取出。
- en: In Datastore, keys and entity bodies are distinct, unlike in MongoDB or SQL
    technologies, where it is just another field in the document or record. This is
    why we are excluding `Key` from our `Question` struct with the `datastore:"-"`
    field tag. Like the `json` tags, this indicates that we want Datastore to ignore
    the `Key` field altogether when it is getting and putting data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Datastore中，键和实体体是分开的，与MongoDB或SQL技术不同，在那里它只是文档或记录中的另一个字段。这就是为什么我们使用`datastore:"-"`字段标签从`Question`结构体中排除`Key`的原因。就像`json`标签一样，这表示我们希望Datastore在获取和存储数据时完全忽略`Key`字段。
- en: Keys may optionally have parents, which is a nice way of grouping associated
    data together and Datastore makes certain assurances about such groups of entities,
    which you can read more about in the Google Cloud Datastore documentation online.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 键可以可选地有父键，这是一种将相关数据分组在一起的好方法，Datastore对这类实体组做出了一些保证，你可以在Google Cloud Datastore在线文档中了解更多信息。
- en: Putting data into Google Cloud Datastore
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据放入Google Cloud Datastore
- en: 'Before we save data into Datastore, we want to ensure that our question is
    valid. Add the following method underneath the Question struct definition:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将数据保存到Datastore之前，我们想要确保我们的问题是有效的。在`Question`结构体定义下面添加以下方法：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `OK` function will return an error if something is wrong with the question,
    or else it will return `nil`. In this case, we just check to make sure the question
    has at least 10 characters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题有错误，`OK`函数将返回一个错误，否则将返回`nil`。在这种情况下，我们只是确保问题至少有10个字符。
- en: 'To persist this data in the data store, we are going to add a method to the
    `Question` struct itself. At the bottom of `questions.go`, add the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此数据持久化到数据存储中，我们将在`Question`结构体本身中添加一个方法。在`questions.go`的底部添加以下代码：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Create` method takes a pointer to `Question` as the receiver, which is
    important because we want to make changes to the fields.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Create`方法接受一个指向`Question`的指针作为接收者，这是很重要的，因为我们想修改字段。'
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the receiver was `(q Question)` without `*`, we would get a copy of the question
    rather than a pointer to it, and any changes we made to it would only affect our
    local copy and not the original `Question` struct itself.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者没有`*`而是`(q Question)`，我们会得到问题的副本而不是指向它的指针，并且我们对它所做的任何更改只会影响我们的本地副本，而不会影响原始的`Question`结构体本身。
- en: The first thing we do is use `log` (from the [https://godoc.org/google.golang.org/appengine/log](https://godoc.org/google.golang.org/appengine/log) package)
    to write a debug statement saying we are saving the question. When you run your
    code in a development environment, you will see this appear in the terminal; in
    production, it goes into a dedicated logging service provided by Google Cloud
    Platform.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`log`（来自[https://godoc.org/google.golang.org/appengine/log](https://godoc.org/google.golang.org/appengine/log)包）来写入一个调试语句，说明我们正在保存问题。当你在一个开发环境中运行你的代码时，你将在终端中看到这个语句；在生产环境中，它将进入由Google
    Cloud Platform提供的专用日志服务中。
- en: If the key is `nil` (that means this is a new question), we assign an incomplete
    key to the field, which informs Datastore that we want it to generate a key for
    us. The three arguments we pass are `context.Context` (which we must pass to all
    datastore functions and methods), a string describing the kind of entity, and
    the parent key; in our case, this is `nil`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是`nil`（这意味着这是一个新问题），我们将一个不完整的键分配给字段，这会通知Datastore我们希望它为我们生成一个键。我们传递的三个参数是`context.Context`（我们必须传递给所有数据存储函数和方法），一个描述实体类型的字符串，以及父键；在我们的情况下，这是`nil`。
- en: Once we know there is a key in place, we call a method (which we will add later)
    to get or create `User` from an App Engine user and set it to the question and
    then set the `CTime` field (created time) to `time.Now`, timestamping the point
    at which the question was asked.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道已经有一个键存在，我们就调用一个方法（我们将在稍后添加）从 App Engine 用户获取或创建 `User` 并将其设置到问题中，然后设置
    `CTime` 字段（创建时间）为 `time.Now`，标记问题被提出的时间点。
- en: One we have our `Question` function in good shape, we call `datastore.Put` to
    actually place it inside the data store. As usual, the first argument is `context.Context`,
    followed by the question key and the question entity itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `Question` 函数处于良好状态时，我们调用 `datastore.Put` 将其实际放置在数据存储中。像往常一样，第一个参数是 `context.Context`，然后是问题键和问题实体本身。
- en: 'Since Google Cloud Datastore treats keys as separate and distinct from entities,
    we have to do a little extra work if we want to keep them together in our own
    code. The `datastore.Put` method returns two arguments: the complete key and `error`.
    The key argument is actually useful because we''re sending in an incomplete key
    and asking the data store to create one for us, which it does during the put operation.
    If successful, it returns a new `datastore.Key` object to us, representing the
    completed key, which we then store in our `Key` field in the `Question` object.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Google Cloud Datastore 将键视为与实体分开且不同的，如果我们想在我们的代码中将它们放在一起，我们就必须做一些额外的工作。`datastore.Put`
    方法返回两个参数：完整的键和 `error`。键参数实际上是有用的，因为我们发送了一个不完整的键并要求数据存储为我们创建一个，它在 put 操作期间这样做。如果成功，它返回一个新的
    `datastore.Key` 对象给我们，代表完整的键，然后我们将其存储在 `Question` 对象的 `Key` 字段中。
- en: If all is well, we return `nil`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们返回 `nil`。
- en: 'Add another helper to update an existing question:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个辅助函数来更新现有问题：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method is very similar except that it doesn't set the `CTime` or `User`
    fields, as they will already have been set.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常相似，只是它没有设置 `CTime` 或 `User` 字段，因为它们已经设置好了。
- en: Reading data from Google Cloud Datastore
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Google Cloud Datastore 读取数据
- en: 'Reading data is as simple as putting it with the `datastore.Get` method, but
    since we want to maintain keys in our entities (and `datastore` methods don''t
    work like that), it''s common to add a helper function like the one we are going
    to add to `questions.go`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据就像使用 `datastore.Get` 方法将其放入一样简单，但由于我们希望在实体中维护键（而 `datastore` 方法并不这样做），因此通常需要添加一个辅助函数，就像我们要添加到
    `questions.go` 中的那样：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `GetQuestion` function takes `context.Context` and the `datastore.Key` method
    of the question to get. It then does the simple task of calling `datastore.Get`
    and assigning the key to the entity before returning it. Of course, errors are
    handled in the usual way.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetQuestion` 函数接受 `context.Context` 和要获取的问题的 `datastore.Key` 方法。然后它执行一个简单的任务，调用
    `datastore.Get` 并在返回之前将键分配给实体。当然，错误以通常的方式处理。'
- en: This is a nice pattern to follow so that users of your code know that they never
    have to interact with `datastore.Get` and `datastore.Put` directly but rather
    use the helpers that can ensure the entities are properly populated with the keys
    (along with any other tweaks that they might want to do before saving or after
    loading).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的模式，以便你的代码的用户知道他们永远不需要直接与 `datastore.Get` 和 `datastore.Put` 交互，而是使用可以确保实体正确填充键（以及他们可能在保存或加载之前想要做的任何其他调整）的辅助函数。
- en: Google App Engine users
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google App Engine 用户
- en: Another service we are going to make use of is the Google App Engine Users API,
    which provides the authentication of Google accounts (and Google Apps accounts).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用另一个服务是 Google App Engine Users API，它提供 Google 帐户（和 Google Apps 帐户）的认证。
- en: 'Create a new file called `users.go` and add the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `users.go` 的新文件，并添加以下代码：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similar to the `Question` struct, we have `Key` and a few fields that make up
    the `User` entity. This struct represents an object that belongs to our application
    that describes a user; we will have one for every authenticated user in our system,
    but this isn't the same user object that we'll get from the Users API.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Question` 结构体类似，我们有 `Key` 和一些组成 `User` 实体的字段。这个结构体代表一个属于我们应用程序的对象，描述了一个用户；我们将在系统中为每个经过认证的用户有一个，但这不是我们从
    Users API 获取的用户对象。
- en: Importing the [https://godoc.org/google.golang.org/appengine/user](https://godoc.org/google.golang.org/appengine/user) package
    and calling the `user.Current(context.Context)` function will return either nil
    (if no user is authenticated) or a `user.User` object. This object belongs to
    the Users API and isn't suitable for our data store, so we need to write a helper
    function that will translate the App Engine user into our `User`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 [https://godoc.org/google.golang.org/appengine/user](https://godoc.org/google.golang.org/appengine/user)
    包并调用 `user.Current(context.Context)` 函数将返回 nil（如果没有用户经过身份验证）或 `user.User` 对象。此对象属于
    Users API，不适合我们的数据存储，因此我们需要编写一个辅助函数，将 App Engine 用户转换为我们的 `User`。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Watch out that `goimports` doesn't automatically import `os/user` instead; sometimes
    it's best if you handle imports manually.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `goimports` 不会自动导入 `os/user`；有时最好手动处理导入。
- en: 'Add the following code to `users.go`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `users.go` 文件中：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We get the currently authenticated user by calling `user.Current`, and if it
    is `nil`, we return with an error. This means that the user is not logged in and
    the operation cannot complete. Our web package will be checking and ensuring that
    users are logged in for us, so by the time they hit an API endpoint, we'll expect
    them to be authenticated.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `user.Current` 来获取当前经过身份验证的用户，如果它是 `nil`，则返回错误。这意味着用户未登录，操作无法完成。我们的 web
    包将为我们检查并确保用户已登录，因此当它们到达 API 端点时，我们期望它们已经经过身份验证。
- en: We then create a new `appUser` variable (which is of our `User` type) and set
    `datastore.Key`. This time, we aren't making an incomplete key; instead, we are
    using `datastore.NewKey` and specifying a string ID, matching the User API ID.
    This key predictability means that not only will there only be one `User` entity
    per authenticated user in our application, but it also allows us to load a `User`
    entity without having to use a query.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的 `appUser` 变量（它属于我们的 `User` 类型）并设置 `datastore.Key`。这次，我们不是创建一个不完整的键；相反，我们使用
    `datastore.NewKey` 并指定一个字符串 ID，与用户 API ID 匹配。这个键的可预测性意味着在我们的应用程序中，每个经过身份验证的用户将只有一个
    `User` 实体，同时它还允许我们无需查询即可加载 `User` 实体。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we had the App Engine User ID as a field instead, we would need to do a query
    to find the record we are interested in. Querying is a more expensive operation
    compared to a direct `Get` method, so this approach is always preferred if you
    can do it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 App Engine 用户 ID 作为字段，那么我们需要进行查询以找到我们感兴趣的记录。与直接 `Get` 方法相比，查询是一个更昂贵的操作，因此如果可能，这种方法总是首选。
- en: We then call `datastore.Get` to attempt to load the `User` entity. If this is
    the first time the user has logged in, there will be no entity and the returned
    error will be the special `datastore.ErrNoSuchEntity` variable. If that's the
    case, we set the appropriate fields and use `datastore.Put` to save it. Otherwise,
    we just return the loaded `User`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `datastore.Get` 来尝试加载 `User` 实体。如果这是用户第一次登录，将没有实体，返回的错误将是特殊的 `datastore.ErrNoSuchEntity`
    变量。如果是这种情况，我们设置适当的字段并使用 `datastore.Put` 来保存它。否则，我们只需返回加载的 `User`。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are checking for early returns in this function. This is to ensure
    that it is easy to read the execution flow of our code without having to follow
    it in and out of indented blocks. I call this the line of sight of code and have
    written about it on my blog at [https://medium.com/@matryer](https://medium.com/@matryer).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在该函数中检查了早期返回。这是为了确保在不跟随代码的缩进块进进出出的情况下，我们的代码执行流程易于阅读。我称之为代码的视线，并在我的博客上写了一些关于它的内容，博客地址为
    [https://medium.com/@matryer](https://medium.com/@matryer)。
- en: 'For now, we''ll use Gravatar again for avatar pictures, so add the following
    helper function to the bottom of `users.go`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将再次使用 Gravatar 来处理头像图片，所以请将以下辅助函数添加到 `users.go` 文件的底部：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Embedding denormalized data
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入非规范化数据
- en: If you recall, our Question type doesn't take the author as `User`; rather,
    the type was `UserCard`. When we embed denormalized data into other entities,
    sometimes we will want them to look slightly different from the master entity.
    In our case, since we do not store the key in the `User` entity (remember the
    `Key` fields have `datastore:"-"`), we need to have a new type that stores the
    key.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们的 `Question` 类型不将作者作为 `User`；相反，类型是 `UserCard`。当我们将非规范化数据嵌入到其他实体中时，有时我们希望它们看起来与主实体略有不同。在我们的例子中，由于我们没有在
    `User` 实体中存储键（记住 `Key` 字段有 `datastore:"-"`），我们需要有一个新的类型来存储键。
- en: 'At the bottom of `users.go`, add the `UserCard` struct and the associated helper
    method for `User`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `users.go` 文件的底部添加 `UserCard` 结构体及其为 `User` 相关的辅助方法：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that `UserCard` doesn't specify a `datastore` tag, so the `Key` field will
    indeed be persisted in the data store. Our `Card()` helper function just builds
    and returns `UserCard` by copying the values of each field. This seems wasteful
    but offers great control, especially if you want embedded data to look very different
    from its original entity.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UserCard`没有指定`datastore`标签，所以`Key`字段确实会被持久化在数据存储中。我们的`Card()`辅助函数只是通过复制每个字段的值来构建和返回`UserCard`。这看起来很浪费，但提供了很好的控制，特别是如果你想嵌入的数据看起来与原始实体非常不同。
- en: Transactions in Google Cloud Datastore
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Datastore中的事务
- en: Transactions allow you to specify a series of changes to the data store and
    commit them as one. If any of the individual operations fails, the whole transaction
    will not be applied. This is extremely useful if you want to maintain counters
    or have multiple entities that depend on each other's state. During a transaction
    in Google Cloud Datastore, all entities that are read are locked (other code is
    prevented from making changes) until the transaction is complete, providing an
    additional sense of security and preventing data races.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 事务允许您指定一系列对数据存储的更改，并将它们作为一个整体提交。如果任何单个操作失败，整个事务将不会应用。如果您想维护计数器或有多个人物实体依赖于彼此的状态，这将非常有用。在Google
    Cloud Datastore的事务期间，所有读取的实体都会被锁定（其他代码将阻止更改），直到事务完成，这提供了额外的安全性，并防止数据竞争。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you were building a bank (it seems crazy, but the guys at Monzo in London
    are indeed building a bank using Go), you might represent user accounts as an
    entity called `Account`. To transfer money from one account to another, you'd
    need to make sure the money was deducted from account A and deposited into account
    B as a single transaction. If either fails, people aren't going to be happy (to
    be fair, if the deduction operation failed, the owner of account A would probably
    be happy because B would get the money without it costing A anything).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在构建一家银行（这似乎很疯狂，但伦敦的Monzo公司确实正在使用Go构建一家银行），你可能将用户账户表示为一个名为`Account`的实体。要从账户A转账到账户B，你需要确保从账户A扣除资金并作为单一事务存入账户B。如果其中任何一个操作失败，人们可能不会高兴（公平地说，如果扣除操作失败，账户A的持有人可能会很高兴，因为B会得到钱而A不需要付出任何代价）。
- en: To see where we are going to use transactions, let's first add model answers
    to the questions.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们将在哪里使用事务，让我们首先将模型答案添加到问题中。
- en: 'Create a new file called `answers.go` and add the following struct and validation
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`answers.go`的新文件，并添加以下结构和验证方法：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Answer` is similar to a question, has `datastore.Key` (which will not be persisted),
    has `CTime` to capture the timestamp, and embeds `UserCard` (representing the
    person answering the question). It also has a `Score` integer field, which will
    go up and down as users vote on the answers.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Answer`类似于问题，有`datastore.Key`（将不会被持久化），有`CTime`来捕获时间戳，并嵌入`UserCard`（代表回答问题的人）。它还有一个`Score`整数字段，当用户对答案投票时，该字段会上升或下降。'
- en: Using transactions to maintain counters
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事务来维护计数器
- en: Our `Question` struct has a field called `AnswerCount`, where we intend to store
    an integer that represents the number of answers that a question has solicited.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Question`结构体有一个名为`AnswerCount`的字段，我们打算在其中存储一个整数，表示问题所吸引的答案数量。
- en: 'First, let''s look at what can happen if we don''t use a transaction to keep
    track of the `AnswerCount` field by tracking the concurrent activity of answers
    4 and 5 of a question:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如果我们不使用事务来跟踪问题的答案4和5的并发活动来保持`AnswerCount`字段会发生什么：
- en: '| **Step** | **Answer 4** | **Answer 5** | **Question.AnswerCount** |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **答案4** | **答案5** | **Question.AnswerCount** |'
- en: '| 1 | Load question | Load question | 3 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 加载问题 | 加载问题 | 3 |'
- en: '| 2 | AnswerCount=3 | AnswerCount=3 | 3 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 2 | AnswerCount=3 | AnswerCount=3 | 3 |'
- en: '| 3 | AnswerCount++ | AnswerCount++ | 3 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 3 | AnswerCount++ | AnswerCount++ | 3 |'
- en: '| 4 | AnswerCount=4 | AnswerCount=4 | 3 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 4 | AnswerCount=4 | AnswerCount=4 | 3 |'
- en: '| 5 | Save the answer and question | Save the answer and question | 4 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 保存答案和问题 | 保存答案和问题 | 4 |'
- en: 'You can see from the table that without locking Question, AnswerCount would
    end up being 4 instead of 5 if the answers came in at the same time. Locking with
    a transaction will look more like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中可以看出，如果没有锁定问题，如果答案同时到达，`AnswerCount`将最终变为4而不是5。使用事务锁定将看起来像这样：
- en: '| **Step** | **Answer 4** | **Answer 5** | **Question.AnswerCount** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **答案4** | **答案5** | **Question.AnswerCount** |'
- en: '| 1 | Lock the question | Lock the question | 3 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 锁定问题 | 锁定问题 | 3 |'
- en: '| 2 | AnswerCount=3 | Waiting for unlock | 3 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 2 | AnswerCount=3 | 等待解锁 | 3 |'
- en: '| 3 | AnswerCount++ | Waiting for unlock | 3 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 3 | AnswerCount++ | 等待解锁 | 3 |'
- en: '| 4 | Save the answer and question | Waiting for unlock | 4 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 保存答案和问题 | 等待解锁 | 4 |'
- en: '| 5 | Release lock | Waiting for unlock | 4 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 释放锁 | 等待解锁 | 4 |'
- en: '| 6 | Finished | Lock the question | 4 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 完成 | 锁定问题 | 4 |'
- en: '| 7 |  | AnswerCount=4 | 4 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 7 |  | AnswerCount=4 | 4 |'
- en: '| 8 |  | AnswerCount++ | 4 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 8 |  | AnswerCount++ | 4 |'
- en: '| 9 |  | Save the answer and question | 5 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 9 |  | 保存答案和问题 | 5 |'
- en: In this case, whichever answer obtains the lock first will perform its operation,
    and the other operation will wait before continuing. This is likely to slow down
    the operation (since it has to wait for the other one to finish), but that's a
    price worth paying in order to get the numbers right.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，首先获得锁的答案将执行其操作，而其他操作将在继续之前等待。这可能会减慢操作速度（因为它必须等待另一个操作完成），但为了得到正确的数字，这是值得付出的代价。
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's best to keep the amount of work inside a transaction as small as possible
    because you are essentially blocking other people while the transaction is underway.
    Outside of transactions, Google Cloud Datastore is extremely fast because it isn't
    making the same kinds of guarantees.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将事务内的操作量尽可能保持小，因为在事务进行期间，您实际上是在阻止其他人。在事务之外，Google Cloud Datastore非常快，因为它不提供相同类型的保证。
- en: 'In code, we use the `datastore.RunInTransaction` function. Add the following
    to `answers.go`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用`datastore.RunInTransaction`函数。将以下内容添加到`answers.go`中：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We first create a new incomplete key (using the `Answer` kind) and set the parent
    as the question key. This will mean that the question will become the ancestor
    to all these answers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的不完整键（使用`Answer`类型），并将父键设置为问题键。这意味着问题将成为所有这些答案的祖先。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ancestor keys are special in Google Cloud Datastore, and it is recommended that
    you read about the nuances behind them in the documentation on the Google Cloud
    Platform website.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Cloud Datastore中，祖先键是特殊的，建议您在Google Cloud Platform网站上阅读有关其细微之处的文档。
- en: Using our `UserFromAEUser` function, we get the user who is answering the question
    and set `UserCard` inside `Answer` before setting `CTime` to the current time,
    as done earlier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`UserFromAEUser`函数，我们获取回答问题的用户，并在设置`CTime`为当前时间之前，在`Answer`内部设置`UserCard`，就像之前做的那样。
- en: Then, we start our transaction by calling the `datastore.RunInTransaction` function
    that takes a context as well as a function where the transactional code will go.
    There is a third argument, which is a set of `datastore.TransactionOptions` that
    we need to use in order to set `XG` to `true`, which informs the data store that
    we'll be performing a transaction across entity groups (both `Answer` and `Question`
    kinds).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`datastore.RunInTransaction`函数开始我们的事务，该函数接受一个上下文以及一个事务代码将要执行的函数。还有一个第三个参数，即一组`datastore.TransactionOptions`，我们需要使用它来将`XG`设置为`true`，这会通知数据存储我们将执行跨实体组的事务（包括`Answer`和`Question`类型）。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When it comes to writing your own functions and designing your own APIs, it
    is highly recommended that you place any function arguments at the end; otherwise,
    inline function blocks such as the ones in the preceding code obscure the fact
    that there is another argument afterwards. It's quite difficult to realize that
    the `TransactionOptions` object is an argument being passed into the `RunInTransaction`
    function, and I suspect somebody on the Google team regrets this decision.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写自己的函数和设计自己的API时，强烈建议将任何函数参数放在末尾；否则，如前述代码中的内联函数块会掩盖后面还有另一个参数的事实。很难意识到`TransactionOptions`对象是传递给`RunInTransaction`函数的参数，我怀疑谷歌团队中有人对此决定感到后悔。
- en: Transactions work by providing a new context for us to use, which means that
    code inside the transaction function looks the same, as if it weren't in a transaction.
    This is a nice piece of API design (and it means that we can forgive the function
    for not being the final argument).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 事务通过为我们提供一个新上下文来工作，这意味着事务函数内的代码看起来与不在事务中时相同。这是一项很好的API设计（这也意味着我们可以原谅该函数不是最终参数）。
- en: Inside the transaction function, we use our `GetQuestion` helper to load the
    question. Loading data inside the transaction function is what obtains a lock
    on it. We then put the answer to save it, update the `AnswerCount` integer, and
    update the question. If all is well (provided none of these steps returns an error),
    the answer will be saved and `AnswerCount` will increase by one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务函数内部，我们使用我们的`GetQuestion`辅助函数来加载问题。在事务函数内部加载数据是获取其锁的方式。然后我们保存答案，更新`AnswerCount`整数，并更新问题。如果一切顺利（前提是这些步骤中没有返回错误），答案将被保存，`AnswerCount`将增加一。
- en: If we do return an error from our transaction function, the other operations
    are canceled and the error is returned. If that happens, we'll just return that
    error from our `Answer.Create` method and let the user try again.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从事务函数返回错误，其他操作将被取消，并返回错误。如果发生这种情况，我们只需从我们的`Answer.Create`方法返回该错误，并让用户再次尝试。
- en: 'Next, we are going to add our `GetAnswer` helper, which is similar to our `GetQuestion`
    function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们的`GetAnswer`辅助函数，它与我们的`GetQuestion`函数类似：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we are going to add our `Put` helper method in `answers.go`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`answers.go`中添加我们的`Put`辅助方法：
- en: '[PRE24]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These two functions are very similar to the `GetQuestion` and `Question.Put`
    methods, but let's resist the temptation of abstracting it and drying up the code
    for now.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数与`GetQuestion`和`Question.Put`方法非常相似，但让我们现在抵制抽象和简化代码的诱惑。
- en: Avoiding early abstraction
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免过早抽象
- en: Copying and pasting is generally seen by programmers as a bad thing because
    it is usually possible to abstract the general idea and **DRY** (**Don't repeat
    yourself**) up the code. However, it is worth resisting the temptation to do this
    right away because it is very easy to design a bad abstraction, which you are
    then stuck with since your code will start to depend on it. It is better to duplicate
    the code in a few places first and later revisit them to see whether a sensible
    abstraction is lurking there.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 复制和粘贴通常被程序员视为坏事，因为这通常可以抽象出一般想法并**DRY**（**不要重复自己**）代码。然而，值得抵制立即这样做，因为很容易设计出一个糟糕的抽象，然后你将陷入其中，因为你的代码将开始依赖于它。最好是首先在几个地方复制代码，然后稍后回过头来看是否有一个合理的抽象隐藏在那里。
- en: Querying in Google Cloud Datastore
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Datastore的查询
- en: So far, we have only been putting and getting single objects into and out of
    Google Cloud Datastore. When we display a list of answers to a question, we want
    to load all of these answers in a single operation, which we can do with `datastore.Query`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只将单个对象放入和取出Google Cloud Datastore。当我们显示问题的答案列表时，我们希望一次性加载所有这些答案，这可以通过`datastore.Query`实现。
- en: The querying interface is a fluent API, where each method returns the same object
    or a modified object, allowing you to chain calls together. You can use it to
    build up a query consisting of ordering, limits, ancestors, filters, and so on.
    We will use it to write a function that will load all the answers for a given
    question, showing the most popular (those with a higher `Score` value) first.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查询接口是一个流畅的API，其中每个方法都返回相同的对象或修改后的对象，允许你将调用链在一起。你可以用它来构建一个包含排序、限制、祖先、过滤器等的查询。我们将用它来编写一个函数，该函数将加载给定问题的所有答案，首先显示最受欢迎的（那些具有更高`Score`值的）。
- en: 'Add the following function to `answers.go`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到`answers.go`中：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We first create an empty slice of pointers to `Answer` and use `datastore.NewQuery`
    to start building a query. The `Ancestor` method indicates that we're looking
    only for answers that belong to the specific question, where the `Order` method
    calls specify that we want to first order by descending `Score` and then by the
    newest first. The `GetAll` method performs the operation, which takes in a pointer
    to our slice (where the results will go) and returns a new slice containing all
    the keys.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个指向`Answer`的空切片，并使用`datastore.NewQuery`开始构建查询。`Ancestor`方法表示我们只查找属于特定问题的答案，`Order`方法调用指定我们首先按降序`Score`排序，然后按最新排序。`GetAll`方法执行操作，它接受指向我们的切片的指针（结果将放入其中）并返回一个包含所有键的新切片。
- en: Tip
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The order of the keys returned will match the order of the entities in the slice.
    This is how we know which key corresponds to each item.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的键的顺序将与切片中实体的顺序相匹配。这就是我们知道哪个键对应于每个项目的方式。
- en: Since we are keeping keys and the entity fields together, we range over the
    answers and assign `answer.Key` to the corresponding `datastore.Key` argument
    returned from `GetAll`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将键和实体字段放在一起，我们在答案上遍历，并将`answer.Key`分配给`GetAll`返回的相应`datastore.Key`参数。
- en: Note
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are keeping our API simple for the first version by not implementing paging,
    but ideally you would need to; otherwise, as the number of questions and answers
    grows, you will end up trying to deliver everything in a single request, which
    would overwhelm the user and maybe the servers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第一版中为了保持API简单，没有实现分页，但理想情况下你确实需要这样做；否则，随着问题和答案数量的增加，你最终会尝试在一个请求中发送所有内容，这可能会让用户和服务器不堪重负。
- en: 'If we had a step in our application of authorizing the answer (to protect it
    from spam or inappropriate content), we might want to add an additional filter
    for `Authorized` to be `true`, in which case we could do this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的应用程序中有一个步骤是授权答案（以保护它免受垃圾邮件或不适当内容的影响），我们可能希望添加一个额外的过滤器，使`Authorized`为`true`，在这种情况下，我们可以这样做：
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on querying and filtering, consult the Google Cloud Datastore
    API documentation online.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于查询和过滤的更多信息，请参阅在线的Google Cloud Datastore API文档。
- en: Another place where we need to query data is when we show the top questions
    on the home page of our app. Our first version of top questions will just show
    those questions that have the most answers; we consider them to be the most interesting,
    but you could change this functionality in the future without breaking the API
    to order by score or even question views.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查询数据的另一个地方是在我们展示应用主页上的热门问题时。我们热门问题的第一版将只显示那些答案最多的问题；我们认为它们是最有趣的，但你可以将来更改此功能，而不会破坏API，按分数或甚至按问题查看次数排序。
- en: We will build `Query` on the `Question` kind and use the `Order` method to first
    order by the number of answers (with the highest first), followed by time (also,
    highest/latest first). We will also use the `Limit` method to make sure we only
    select the top 25 questions for this API. Later, if we implement paging, we can
    even make this dynamic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`Question`类型上构建`Query`，并使用`Order`方法首先按答案数量排序（数量最多者排在前面），然后按时间排序（也是数量最多/最新者排在前面）。我们还将使用`Limit`方法确保我们只为这个API选择前25个问题。稍后，如果我们实现了分页，我们甚至可以使这个排序动态化。
- en: 'In `questions.go`, add the `TopQuestions` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`questions.go`中添加`TopQuestions`函数：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code is similar to loading the answers, and we end up returning a slice
    of `Question` objects or an error.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与加载答案类似，我们最终返回一个`Question`对象切片或一个错误。
- en: Votes
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投票
- en: Now that we have modeled questions and answers in our application, it's time
    to think about how voting might work.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在应用程序中建模了问题和答案，是时候考虑投票可能的工作方式了。
- en: 'Let''s design it a little:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作设计：
- en: Users vote answers up and down based on their opinion of them
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户根据自己的观点对答案进行上下投票
- en: Answers are ordered by their score so the best ones appear first
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案按其分数排序，因此最好的答案排在前面
- en: Each person is allowed one vote per answer
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个人对每个答案只能投一次票
- en: If a user votes again, they should replace their previous vote
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户再次投票，他们应该替换他们之前的投票
- en: We will make use of a few things we have learned so far in this chapter; transactions
    will help us ensure the correct score is calculated for answers, and we'll use
    predictable keys again to ensure that each person gets only one vote per answer.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用本章学到的几个知识点；事务将帮助我们确保正确计算答案的分数，我们还将再次使用可预测的键来确保每个人对每个答案只能投一次票。
- en: We will first build a structure to represent each vote and use field tags to
    be a little more specific about how we want the data store to index our data.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建一个结构来表示每个投票，并使用字段标签来更具体地说明我们希望数据存储如何索引我们的数据。
