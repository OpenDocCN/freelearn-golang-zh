- en: Chapter 1. Ready... Steady... Go!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。准备...开始...Go！
- en: 'Design Patterns have been the foundation for hundreds of thousands of pieces
    of software. Since the *Gang Of Four* (Erich Gamma, Richard Helm, Ralph Johnson
    and John Vlissides) wrote the book *Design Patterns: Elements of Reusable Object-Oriented
    Software* in 1994 with examples in C++ and Smalltalk, the twenty-three classic
    patterns have been re-implemented in most of major languages of today and they
    have been used in almost every project you know about.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式已经成为数以千计的软件基础。自从*四人帮*（Erich Gamma，Richard Helm，Ralph Johnson和John Vlissides）在1994年用C++和Smalltalk编写了《设计模式：可复用面向对象软件的元素》一书以来，这二十三种经典模式已经在今天的大多数主要语言中重新实现，并且它们已经在你所知道的几乎每个项目中被使用。
- en: The *Gang of Four* detected that many small architectures were present in many
    of their projects, they started to rewrite them in a more abstract way and they
    released the famous book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*四人帮*发现他们的许多项目中存在许多小型架构，他们开始以更抽象的方式重写它们，并发布了这本著名的书。'
- en: This book is a comprehensive explanation and implementation of the most common
    design patterns from the *Gang of Four* and today's patterns plus some of the
    most idiomatic concurrency patterns in Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是对*四人帮*最常见的设计模式和今天的模式以及一些Go中最惯用的并发模式的全面解释和实现。
- en: But what is Go...?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但Go是什么...？
- en: A little bit of history
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史
- en: On the last 20 years, we have lived an incredible growth in computer science.
    Storage spaces have been increased dramatically, RAM has suffered a substantial
    growth, and CPU's are... well... simply faster. Have they grown as much as storage
    and RAM memory? Not really, CPU industry has reached a limit in the speed that
    their CPU's can deliver, mainly because they have become so fast that they cannot
    get enough power to work while they dissipate enough heat. The CPU manufacturers
    are now shipping more cores on each computer. This situation crashes against the
    background of many systems programming languages that weren't designed for multi-processor
    CPUs or large distributed systems that act as a unique machine. In Google, they
    realized that this was becoming more than an issue while they were struggling
    to develop distributed applications in languages like Java or C++ that weren't
    designed with concurrency in mind.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的20年里，我们在计算机科学领域经历了令人难以置信的增长。存储空间大幅增加，RAM也有了实质性的增长，而CPU...嗯...就是更快了。它们的增长是否和存储和RAM内存一样多？实际上并不是，CPU行业已经达到了CPU可以提供的速度极限，主要是因为它们变得如此快，以至于在散热时无法获得足够的电力。CPU制造商现在在每台计算机上都提供了更多的核心。这种情况与许多系统编程语言的背景相冲突，这些语言并不是为多处理器CPU或充当唯一机器的大型分布式系统而设计的。在Google，他们意识到这已经不仅仅是一个问题，而是在努力开发像Java或C++这样没有考虑并发性的语言的分布式应用程序时变得更加困难。
- en: At the same time, our programs were bigger, more complex, more difficult to
    maintain and with a lot of room for bad practices. While our computers had more
    cores and were faster, we were not faster when developing our code neither our
    distributed applications. This was Go's target.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们的程序变得更大、更复杂、更难以维护，而且存在很多不良实践的空间。虽然我们的计算机拥有更多的核心并且更快，但我们在开发代码和分布式应用程序时并没有变得更快。这就是Go的目标。
- en: 'Go design started in 2007 by three Googlers in the research of a programming
    language that could solve common issues in large scale distributed systems like
    the ones you can find at Google. The creators were:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go设计始于2007年，由三名谷歌员工研究一种可以解决像谷歌这样的大规模分布式系统中常见问题的编程语言。创作者是：
- en: 'Rob Pike: Plan 9 and Inferno OS.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rob Pike：Plan 9和Inferno操作系统。
- en: 'Robert Griesemer: Worked at Google''s V8 JavaScript engine that powers Google
    Chrome.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robert Griesemer：曾在谷歌的V8 JavaScript引擎工作，该引擎为Google Chrome提供动力。
- en: 'Ken Thompson: Worked at Bell labs and the Unix team. It has been involved in
    designing of the Plan 9 operating system as well as the definition of the UTF-8
    encoding.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ken Thompson：曾在贝尔实验室和Unix团队工作。他参与设计了Plan 9操作系统以及UTF-8编码的定义。
- en: In 2008, the compiler was done and the team got the help of Russ Cox and Ian
    Lance Taylor. The team started their journey to open source the project in 2009
    and in March 2012 they reached a version 1.0 after more than fifty releases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，编译器完成了，团队得到了Russ Cox和Ian Lance Taylor的帮助。团队于2009年开始了开源项目的旅程，并在2012年3月经过50多次发布后达到了1.0版本。
- en: Installing Go
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Go
- en: 'Any Go Installation needs two basic things: the binaries of the language somewhere
    on your disk and a **GOPATH** path in your system where your projects and the
    projects that you download from other people will be stored.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Go安装都需要两个基本的东西：语言的二进制文件在您的磁盘上的某个位置，以及系统中的**GOPATH**路径，您的项目和您从其他人那里下载的项目将存储在其中。
- en: In the following lines, we will explore how to install Go binaries in Linux,
    Windows and OS X. For a detailed explanation of how to install the latest version
    of Go, you can refer to the official documentation at [https://golang.org/doc/install](https://golang.org/doc/install).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们将探讨如何在Linux、Windows和OS X中安装Go二进制文件。有关如何安装最新版本的Go的详细说明，您可以参考官方文档[https://golang.org/doc/install](https://golang.org/doc/install)。
- en: Linux
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux
- en: 'To install Go in Linux you have two options:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中安装Go有两种选择：
- en: '**Easy option**: Use your distribution package manager:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单选项**：使用你的发行包管理器：'
- en: RHEL/Fedora/Centos users with YUM/DNF:`sudo yum install -y golang`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHEL/Fedora/Centos用户使用YUM/DNF：`sudo yum install -y golang`
- en: Ubuntu/Debian users using APT with:`sudo apt-get install -y golang`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu/Debian用户使用APT：`sudo apt-get install -y golang`
- en: '**Advanced**: Downloading the latest distribution from [https://golang.org](https://golang.org).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级**：从[https://golang.org](https://golang.org)下载最新的发行版。'
- en: I recommend using the second and downloading a distribution. Go's updates maintains
    backward compatibility and you usually should not be worried about updating your
    Go binaries frequently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用第二种方法并下载一个发行版。Go的更新保持向后兼容性，通常不需要频繁更新Go二进制文件。
- en: Go Linux advanced installation
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go Linux高级安装
- en: The advanced installation of Go in Linux requires you to download the binaries
    from **golang** webpage. After entering [https://golang.org](https://golang.org)
    , click the **Download Go** button (usually at the right) some **Featured Downloads**
    option is available for each distribution. Select **Linux** distribution to download
    the latest stable version.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中高级安装Go需要你从**golang**网页下载二进制文件。进入[https://golang.org](https://golang.org)，点击**Download
    Go**按钮（通常在右侧），每个发行版都有一些**Featured Downloads**选项。选择**Linux**发行版下载最新的稳定版本。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At [https://golang.org](https://golang.org) you can also download beta versions
    of the language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://golang.org](https://golang.org)上，您也可以下载语言的beta版本。
- en: 'Let''s say we have saved the `tar.gz` file in Downloads folder so let''s extract
    it and move it to a different path. By convention, Go binaries are usually placed
    in `/usr/local/go` directory:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经将`tar.gz`文件保存在Downloads文件夹中，所以让我们解压它并将它移动到另一个路径。按照惯例，Go二进制文件通常放在`/usr/local/go`目录中：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On extraction remember to replace asterisks (`*`) with the version you have
    downloaded.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取时，请记住用您下载的版本替换星号（`*`）。
- en: Now we have our Go installation in`/usr/local/go` path so now we have to add
    the `bin` subfolder to our `PATH` and the `bin` folder within our GOPATH.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Go安装在`/usr/local/go`路径中，所以现在我们必须将`bin`子文件夹添加到我们的`PATH`和GOPATH中的`bin`文件夹。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With -p we are telling bash to create all directories that are necessary. Now
    we need to append bin folder paths to our PATH, append the following lines at
    the end of your `~/.bashrc`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用-p我们告诉bash创建所有必要的目录。现在我们需要将bin文件夹路径附加到我们的PATH，在您的`~/.bashrc`的末尾添加以下行：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check that our `go/bin` directory is available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的`go/bin`目录是否可用：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Windows
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows
- en: To install Go in Windows, you will need administrator privileges. Open your
    favorite browser and navigate to `https://golang.org` . Once there click the **Download
    Go** button and select **Microsoft Windows** distribution. A `*.msi` file will
    start downloading.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows中安装Go，您需要管理员权限。打开您喜欢的浏览器，导航到`https://golang.org`。一旦到达那里，点击**Download
    Go**按钮，然后选择**Microsoft Windows**发行版。一个`*.msi`文件将开始下载。
- en: Execute the MSI installer by double clicking it. An installer will appear asking
    you to accept the **End User License Agreement** (**EULA**) and select a target
    folder for your installation. We will continue with the default path that in my
    case was `C:\Go`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 双击执行MSI安装程序。一个安装程序将出现，要求您接受**最终用户许可协议**（**EULA**）并选择安装的目标文件夹。我们将继续使用默认路径，在我的情况下是`C:\Go`。
- en: Once the installation is finished you will have to add the **binary Go** folder,
    located in `C:\Go\bin` to your Path. For this, you must go to Control Panel and
    select **System** option. Once in System, select the **Advanced** tab and click
    the **Environment variables** button. Here you'll find a window with variables
    for your current user and system variables. In system variables, you'll find the
    **Path** variable. Click it and click the **Edit** button to open a text box.
    You can add your path by adding `;C:\Go/bin` at the end of the current line (note
    the semicolon at the beginning of the path). In recent Windows versions (Windows
    10) you will have a manager to add variables easily.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您需要将位于`C:\Go\bin`的**二进制Go**文件夹添加到您的Path。为此，您必须转到控制面板，并选择**系统**选项。在系统中，选择**高级**选项卡，然后点击**环境变量**按钮。在这里，您会找到当前用户和系统变量的变量窗口。在系统变量中，您会找到**Path**变量。点击它，然后点击**编辑**按钮打开一个文本框。您可以通过在当前行的末尾添加`;C:\Go/bin`来添加您的路径（注意路径开头的分号）。在最近的Windows版本（Windows
    10）中，您将有一个简单添加变量的管理器。
- en: Mac OS X
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mac OS X
- en: In Mac OS X the installation process is very similar to Linux. Open your favorite
    browser and navigate to [https://golang.org](https://golang.org) and click the
    **Download Go**. From the list of possible distributions that appear, select **Apple
    OS X**. This will download a `*.pkg` file to your download folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X中，安装过程与Linux非常相似。打开您喜欢的浏览器，导航到[https://golang.org](https://golang.org)，并点击**Download
    Go**。从出现的可能的发行版列表中，选择**Apple OS X**。这将在您的下载文件夹中下载一个`*.pkg`文件。
- en: 'A window will guide you through the installation process where you have to
    type your administrator password so that it can put Go binary files in `/usr/local/go/bin`
    folder with the proper permissions. Now, open **Terminal** to test the installation
    by typing this on it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个窗口将引导您完成安装过程，在这个过程中，您需要输入管理员密码，以便它可以将Go二进制文件放在`/usr/local/go/bin`文件夹中，并赋予适当的权限。现在，打开**终端**，通过在终端上输入以下内容来测试安装：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you see the installed version, everything was fine. If it doesn't work check
    that you have followed correctly every step or refer to the documentation at [https://golang.org](https://golang.org).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到已安装的版本，一切都很好。如果不起作用，请检查您是否正确地按照每个步骤进行了操作，或者参考[https://golang.org](https://golang.org)上的文档。
- en: Setting the workspace - Linux and Apple OS X
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置工作空间 - Linux和Apple OS X
- en: Go will always work under the same workspace. This helps the compiler to find
    packages and libraries that you could be using. This workspace is commonly called
    **GOPATH**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go将始终在相同的工作空间下工作。这有助于编译器找到您可能正在使用的包和库。这个工作空间通常被称为**GOPATH**。
- en: GOPATH has a very important role in your working environment while developing
    Go software. When you import a library in your code it will search for this library
    in your `$GOPATH/src`. The same when you install some Go apps, binaries will be
    stored in `$GOPATH/bin`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Go软件时，GOPATH在您的工作环境中起着非常重要的作用。当您在代码中导入一个库时，它将在您的`$GOPATH/src`中搜索这个库。当您安装一些Go应用程序时，二进制文件将存储在`$GOPATH/bin`中。
- en: 'At the same, all your source code must be stored in a valid route within `$GOPATH/src`
    folder. For example, I store my projects in GitHub and my username is *Sayden*
    so, for a project called **minimal-mesos-go-framework** I will have this folder
    structure like `$GOPATH/src/github.com/sayden/minimal-mesos-go-framework` which
    reflects the URI where this repo is stored at GitHub:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，所有源代码必须存储在`$GOPATH/src`文件夹中的有效路径中。例如，我将我的项目存储在GitHub中，我的用户名是*Sayden*，所以，对于一个名为**minimal-mesos-go-framework**的项目，我的文件夹结构将如下所示：`$GOPATH/src/github.com/sayden/minimal-mesos-go-framework`，这反映了此存储库在GitHub上存储的URI。
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `$HOME/go` path is going to be the destination of our `$GOPATH`. We have
    to set an environment variable with our `$GOPATH` pointing to this folder. To
    set the environment variable, open again the file `$HOME/.bashrc` with your favorite
    text editor and add the following line at the end of it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`$HOME/go`路径将成为我们的`$GOPATH`的目的地。我们必须设置一个环境变量，将我们的`$GOPATH`指向这个文件夹。要设置环境变量，请再次用您喜欢的文本编辑器打开文件`$HOME/.bashrc`，并在其末尾添加以下行：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the file and open a new terminal. To check that everything is working,
    just write an echo to the `$GOPATH` variable like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并打开一个新的终端。要检查一切是否正常工作，只需像这样向`$GOPATH`变量写一个echo：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the output of the preceding command points to your chosen Go path, everything
    is correct and you can continue to write your first program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令的输出指向您选择的Go路径，则一切正确，您可以继续编写您的第一个程序。
- en: Starting with Hello World
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Hello World开始
- en: 'This wouldn''t be a good book without a Hello World example. Our Hello World
    example can''t be simpler, open your favorite text editor and create a file called
    `main.go` within our `$GOPATH/src/[your_name]/hello_world` with the following
    content:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一个Hello World示例，这本书就不会是一本好书。我们的Hello World示例不能更简单，打开您喜欢的文本编辑器，在我们的`$GOPATH/src/[your_name]/hello_world`中创建一个名为`main.go`的文件，内容如下：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save the file. To run our program, open the Terminal window of your operating
    system:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。要运行我们的程序，请打开操作系统的终端窗口：
- en: In Linux, go to programs and find a program called **Terminal**.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中，转到程序并找到一个名为**Terminal**的程序。
- en: In Windows, hit Windows + R, type `cmd` without quotes on the new window and
    hit *Enter*.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中，按下Windows + R，键入`cmd`（不带引号）在新窗口中按*Enter*。
- en: In Mac OS X, hit Command + Space to open a spotlight search, type `terminal`
    without quotes. The terminal app must be highlighted so hit Enter.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS X中，按Command + Space打开聚光灯搜索，键入`terminal`（不带引号）。终端应用程序必须被突出显示，然后按Enter。
- en: 'Once we are in our terminal, navigate to the folder where we have created our
    `main.go` file. This should be under your `$GOPATH/src/[your_name]/hello_world`
    and execute it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在终端中，导航到我们创建`main.go`文件的文件夹。这应该在您的`$GOPATH/src/[your_name]/hello_world`下，并执行它：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That''s all. The `go run [file]` command will compile and execute our application
    but it won''t generate an executable file. If you want just to build it and get
    an executable file, you must build the app using the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部。`go run [file]`命令将编译并执行我们的应用程序，但不会生成可执行文件。如果只想构建它并获得一个可执行文件，您必须使用以下命令构建应用程序：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Nothing happens. But if you search in the current directory (`ls` command in
    Linux and Mac OS X; and `dir` in Windows), you''ll find an executable file with
    the name `hello_world`. We have given this name to the executable file when we
    wrote `-o hello_world` command while building. You can now execute this file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 什么也没有发生。但是，如果在当前目录中搜索（在Linux和Mac OS X中使用`ls`命令，在Windows中使用`dir`命令），您将找到一个名为`hello_world`的可执行文件。我们在构建时给可执行文件命名为`-o
    hello_world`。现在您可以执行此文件：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: And our message appeared! In Windows, you just need to type the name of the
    `.exe` file to get the same result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的消息出现了！在Windows中，您只需要键入`.exe`文件的名称即可获得相同的结果。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `go run [my_main_file.go]` command will build and execute the app without
    intermediate files. The `go build -o [filename]` command will create an executable
    file that I can take anywhere and has no dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run [my_main_file.go]`命令将构建并执行应用程序，而不生成中间文件。`go build -o [filename]`命令将创建一个可执行文件，我可以随身携带，没有依赖关系。'
- en: Integrated Development Environment - IDE
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境 - IDE
- en: An **IDE** (**Integrated Development Environment**) is basically a user interface
    to help developers, code their programs by providing a set of tools to speed up
    common tasks during development process like compiling, building, or managing
    dependencies. The IDEs are powerful tools that take some time to master and the
    purpose of this book is not to explain them (an IDE like Eclipse has its own books).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDE**（集成开发环境）基本上是一个用户界面，它通过提供一组工具来加快开发过程中的常见任务，如编译、构建或管理依赖项，来帮助开发人员编写他们的程序。IDE是强大的工具，需要一些时间来掌握，而本书的目的并不是解释它们（像Eclipse这样的IDE有自己的书籍）。'
- en: 'In Go, you have many options but there are only two that are fully oriented
    to Go development **LiteIDE** and **Intellij Gogland**. LiteIDE is not the most
    powerful though but Intellij has put lots of efforts to make Gogland a very nice
    editor with completion, debugging, refactoring, testing, visual coverage, inspections,
    etc. Common IDEs or text editors that have a Go plugin/integration are as following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，您有许多选择，但只有两个是完全面向Go开发的**LiteIDE**和**Intellij Gogland**。LiteIDE虽然不是最强大的，但Intellij已经付出了很多努力，使Gogland成为一个非常好的编辑器，具有完成、调试、重构、测试、可视化覆盖、检查等功能。以下是具有Go插件/集成的常见IDE或文本编辑器：
- en: IntelliJ Idea
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ Idea
- en: Sublime Text 2/3
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime Text 2/3
- en: Atom
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Atom
- en: Eclipse
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: 'But you can also find Go plugins for:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但您也可以找到以下Go插件：
- en: Vim
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim
- en: Visual Studio and Visual Code
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio和Visual Code
- en: The IntelliJ Idea and Atom IDEs, for the time of this writing, has the support
    for debugging using a plugin called **Delve**. The IntelliJ Idea is bundled with
    the official Go plugin. In Atom you'll have to download a plugin called **Go-plus**
    and a debugger that you can find searching the word `Delve`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，IntelliJ Idea和Atom IDE具有使用名为**Delve**的插件进行调试的支持。IntelliJ Idea捆绑了官方的Go插件。在Atom中，您必须下载一个名为**Go-plus**的插件和一个调试器，您可以通过搜索单词`Delve`找到。
- en: Types
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: 'Types give the user the ability to store values in mnemonic names. All programming
    languages have types related with numbers (to store integers, negative numbers,
    or floating point for example) with characters (to store a single character) with
    strings (to store complete words) and so on. Go language has the common types
    found in most programming languages:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类型使用户能够使用助记符名称存储值。所有编程语言都有与数字相关的类型（用于存储整数、负数或浮点数，例如）与字符相关的类型（用于存储单个字符）与字符串相关的类型（用于存储完整的单词）等。Go语言具有大多数编程语言中常见的类型：
- en: The `bool` keyword is for Boolean type which represents a `True` or `False`
    state.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`关键字是布尔类型，表示`True`或`False`状态。'
- en: 'Many numeric types being the most common:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多数字类型是最常见的：
- en: The `int` type represents a number from 0 to 4294967295 in 32 bits machines
    and from 0 to 18446744073709551615 in 64 bits.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`类型在32位机器上表示从0到4294967295的数字，在64位机器上表示从0到18446744073709551615的数字。'
- en: The `byte` type represents a number from 0 to 255.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`类型表示从0到255的数字。'
- en: The `float32` and `float64` types are the set of all IEEE-754 64/-bit floating-point
    numbers respectively.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float32`和`float64`类型分别是所有IEEE-754 64/-位浮点数的集合。'
- en: You also have `signed int` type like `rune` which is an alias of `int32` type,
    a number that goes from -2147483648 to 2147483647 and `complex64` and `complex128`
    which are the set of all complex numbers with `float32`/ `float64` real and imaginary
    parts like *2.0i*.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还有`signed int`类型，如`rune`，它是`int32`类型的别名，表示从-2147483648到2147483647的数字，以及`complex64`和`complex128`，它们是所有具有`float32`/`float64`实部和虚部的复数的集合，例如*2.0i*。
- en: The `string` keyword for string type represents an array of characters enclosed
    in quotes like `"golang"` or `"computer"`.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`关键字表示字符串类型，表示用引号括起来的字符数组，例如`"golang"`或`"computer"`。'
- en: An `array` that is a numbered sequence of elements of a single type and a fixed
    size (more about arrays later in this chapter). A list of numbers or lists of
    words with a fixed size is considered arrays.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`是单一类型和固定大小的元素的编号序列（本章后面会详细介绍数组）。一组数字或具有固定大小的单词列表被认为是数组。'
- en: The `slice` type is a segment of an underlying array (more about this later
    in this chapter). This type is a bit confusing at the beginning because it seems
    like an array but we will see that actually, they are more powerful.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice`类型是底层数组的一个段（本章后面会详细介绍）。这种类型在开始时有点令人困惑，因为它看起来像一个数组，但实际上，它们更强大。'
- en: The structures that are the objects that are composed of another objects or
    types.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构是由其他对象或类型组成的对象。
- en: The pointers (more about this later in this chapter)are like directions in the
    memory of our program (yes, like mailboxes that you don't know what's inside).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针（本章后面会详细介绍）就像程序内存中的方向（是的，就像你不知道里面装了什么的邮箱）。
- en: The functions are interesting (more about this later in this chapter). You can
    also define functions as variables and pass them to other functions (yes, a function
    that uses a function, did you like Inception movie?).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数很有趣（本章后面会详细介绍）。您还可以将函数定义为变量，并将它们传递给其他函数（是的，一个使用函数的函数，你喜欢《盗梦空间》电影吗？）。
- en: The `interface` is incredibly important for the language as they provide many
    encapsulation and abstraction functionalities that we'll need often. We'll use
    interfaces extensively during the book and they are presented in greater detail
    later.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface`对于语言来说非常重要，因为它们提供了许多封装和抽象功能，这些功能我们经常需要。我们将在本书中广泛使用接口，并在后面更详细地介绍它们。'
- en: The `map` types are unordered key-value structures. So for a given key, you
    have an associated value.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`类型是无序的键值结构。因此，对于给定的键，您有一个关联的值。'
- en: The channels are the communication primitive in Go for concurrency programs.
    We'll look on channels with more detail on Chapter 8, *Dealing with Go's CSP concurrency*.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道是Go语言中用于并发程序的通信原语。我们将在第8章《处理Go的CSP并发》中更详细地了解通道。
- en: Variables and constants
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和常量
- en: 'Variables are spaces in computer''s memory to store values that can be modified
    during the execution of the program. Variables and constants have a type like
    the ones described in preceding text. Although, you don''t need to explicitly
    write the type of them (although you can do it). This property to avoid explicit
    type declaration is what is called **Inferred types**. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是计算机内存中的空间，用于存储在程序执行期间可以修改的值。变量和常量具有与前文描述的类型相同的类型。尽管如此，您不需要显式地编写它们的类型（尽管您可以这样做）。避免显式类型声明的这种属性称为**推断类型**。例如：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we are declaring a variable (with the keyword `var`) called `explicit`
    of string type. At the same time, we are defining the value to `Hello World!`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`explicit`的字符串类型变量（使用关键字`var`）。同时，我们将值定义为`Hello World!`。
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But here we are doing exactly the same thing. We have avoided the `var` keyword
    and the `string` type declaration. Internally, Go's compiler will infer (guess)
    the type of the variable to a string type. This way you have to write much less
    code for each variable definition.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们做的事情完全相同。我们避免了`var`关键字和`string`类型声明。Go的编译器会内部推断（猜测）变量的类型为字符串类型。这样，您就不必为每个变量定义编写更少的代码。
- en: 'The following lines use the `reflect` package to gather information about a
    variable. We are using it to print the type of (the `TypeOf` variable in the code)
    of both variables:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用`reflect`包来收集有关变量的信息。我们使用它来打印代码中的`TypeOf`变量的类型。
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run the program, the result is the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，结果如下：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we expected, the compiler has inferred the type of the implicit variable
    to string too. Both have written the expected output to the console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，编译器也将隐式变量的类型推断为字符串。两者都已将预期的输出写入控制台。
- en: Operators
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: The operators are used to perform arithmetic operations and make comparisons
    between many things. The following operators are reserved by Go language.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符用于执行算术运算并在许多事物之间进行比较。以下运算符由Go语言保留。
- en: '![Operators](img/image_01_001.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Operators](img/image_01_001.jpg)'
- en: 'Most commonly used operators are the arithmetic operators and comparators.
    Arithmetic operators are as following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的运算符是算术运算符和比较运算符。算术运算符如下：
- en: The `+` operator for sums
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于求和的`+`运算符
- en: The `-` operator for subtractions
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`运算符用于减法'
- en: The `*` operator for multiplications
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`运算符用于乘法'
- en: The `/` operator for divisions
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`运算符用于除法'
- en: The `%` operator for division remainders
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`运算符用于除法余数'
- en: The `++` operator to add 1 to the current variable
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`++`运算符用于将当前变量加1'
- en: The `--` operator to subtract 1 to the current variable
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`运算符用于从当前变量中减去1'
- en: 'On the other side, comparators are used to check the differences between two
    statements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，比较器用于检查两个语句之间的差异：
- en: The `==` operator to check if two values are equal
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`运算符用于检查两个值是否相等'
- en: The `!=` operator to check if two values are different
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=`运算符用于检查两个值是否不同'
- en: The `>` operator to check if left value is higher than right value
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`运算符用于检查左值是否大于右值'
- en: The `<` operator to check if left value is lower than right value
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`运算符用于检查左值是否小于右值'
- en: The `>=` operator to check if left value is higher or equal to right value
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=`运算符用于检查左值是否大于或等于右值'
- en: The `<=` operator to check if left value is lower or equal to right value
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=`运算符用于检查左值是否小于或等于右值'
- en: The `&&`operator to check if two values are `true`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`运算符用于检查两个值是否为`true`'
- en: You also have the shifters to perform a binary shift to left or right of a value
    and a negated operator to invert some value. We´ll use these operators a lot during
    the following chapters so don´t worry too much about them now, just keep in mind
    that you cannot set the name of any variable, field or function in your code like
    this operators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还有移位器来对值进行左移或右移的二进制移位，以及一个取反操作符来反转一些值。在接下来的章节中，我们将大量使用这些运算符，所以现在不要太担心它们，只要记住你不能在你的代码中像这些运算符那样设置任何变量、字段或函数的名称。
- en: Tip
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What's the inverted value of 10? What's the negated value of 10? -10? Incorrect..
    10 in binary code is `1010` so if we negate every number we will have `0101` or
    `101` which is the number 5.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 10的倒数值是多少？10的负值是多少？-10？不正确。10在二进制代码中是`1010`，所以如果我们对每个数字取反，我们将得到`0101`或`101`，这是数字5。
- en: Flow control
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: Flow control is referred as the ability to decide which portion of code or how
    many times you execute some code on a condition. In Go, it is implemented using
    familiar imperative clauses like if, else, switch and for. The syntax is easy
    to grasp. Let´s review major flow control statements in Go.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制是指在条件下决定代码的哪一部分或多少次执行某些代码的能力。在Go中，它是使用熟悉的命令式子句如if、else、switch和for来实现的。语法很容易理解。让我们来回顾一下Go中的主要流程控制语句。
- en: The if... else statement
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if... else语句
- en: 'Go language, like most programming languages, has `if…else` conditional statement
    for flow control. The Syntax is similar to other languages but you don''t need
    to encapsulate the condition between parenthesis:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言，像大多数编程语言一样，有用于流程控制的`if…else`条件语句。语法与其他语言类似，但你不需要在括号中封装条件：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `else...if` condition works in a similar fashion, you don''t need parentheses
    either and they are declared as programmer would expect:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`else...if`条件以类似的方式工作，你也不需要括号，它们被声明为程序员所期望的那样：'
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Go does not have ternary conditions like `condition ? true : false`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'Go没有像`condition ? true : false`这样的三元条件。'
- en: The switch statement
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch语句
- en: 'The `switch` statement is also similar to most imperative languages. You take
    a variable and check possible values for it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句也与大多数命令式语言类似。你取一个变量并检查可能的值：'
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The for…range statement
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for…range语句
- en: The `_for_` loop is also similar than in common programming languages but you
    don't use parentheses either
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`_for_`循环也与常见的编程语言类似，但你也不使用括号'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you have probably imagined if you have computer science background, we infer
    an `int` variable defined as `0` and execute the code between the brackets while
    the condition (`i<=10`) is satisfied. Finally, for each execution, we added `1`
    to the value of `i`. This code will print the numbers from 0 to 10\. You also
    have a special syntax to iterate over arrays or slices which is `range`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有计算机科学背景，你可能已经想象到了，我们推断出一个定义为`0`的`int`变量，并在括号中执行代码，同时条件（`i<=10`）得到满足。最后，对于每次执行，我们将`i`的值加1。这段代码将打印出从0到10的数字。你还有一个特殊的语法来遍历数组或切片，即`range`：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, the `fmt` (format) is a very common Go package that we will use extensively
    to give shape to the message that we will print in the console.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`fmt`（格式）是一个非常常见的Go包，我们将广泛使用它来给控制台中打印的消息赋予形状。
- en: 'Regarding for, you can use the `range` keyword to retrieve every item in a
    collection like `my_array` and assign them to the value temporal variable. It
    will also give you an `index` variable to know the position of the value you''re
    retrieving. It''s equivalent to write the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于for，你可以使用`range`关键字来检索集合中的每个项目，比如`my_array`，并将它们分配给临时变量的值。它还会给你一个`index`变量来知道你正在检索的值的位置。它相当于写下面的内容：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `len` method is used to know the length of a collection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`方法用于知道集合的长度。'
- en: If you execute this code, you'll see that the result is the same.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行这段代码，你会发现结果是一样的。
- en: Functions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: A function is a small portion of code that surrounds some action you want to
    perform and returns one or more values (or nothing). They are the main tool for
    developer to maintain structure, encapsulation, and code readability but also
    allow an experienced programmer to develop proper unit tests against his or her
    functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是围绕你想要执行的某些操作的一小部分代码，并返回一个或多个值（或者什么也不返回）。它们是开发人员维护结构、封装和代码可读性的主要工具，但也允许有经验的程序员对他或她的函数进行适当的单元测试。
- en: 'Functions can be very simple or incredibly complex. Usually, you''ll find that
    simpler functions are also easier to maintain, test and debug. There is also a
    very good advice in computer science world that says: *A function must do just
    one thing, but it must do it damn well*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以非常简单，也可以非常复杂。通常，你会发现简单的函数也更容易维护、测试和调试。在计算机科学世界中也有一个非常好的建议，那就是：*一个函数必须只做一件事，但必须做得非常好*。
- en: What does a function look like?
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数是什么样子的？
- en: 'A function is a piece of code with its own variables and flow that doesn''t
    affect anything outside of the opening and close brackets but global package or
    program variables. Functions in Go has the following composition:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一段代码，有自己的变量和流程，不会影响到开放和关闭括号之外的任何东西，但会影响全局包或程序变量。Go语言中的函数具有以下组成部分：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following the previous definition, we could have the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的定义，我们可以有以下例子：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Functions can call other functions. For example, in our previous `hello` function,
    we are receiving a message argument of type string and we are calling a different
    function `fmt.Printf("Hello %s\n", message)` with our argument as parameter. Functions
    can also be used as parameters when calling other functions or be returned.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以调用其他函数。例如，在我们之前的`hello`函数中，我们接收一个类型为字符串的消息参数，并调用一个不同的函数`fmt.Printf("Hello
    %s\n", message)`并将我们的参数作为参数。函数也可以在调用其他函数时用作参数，或者被返回。
- en: It is very important to choose a good name for your function so that it is very
    clear what it is about without writing too many comments over it. This can look
    a bit trivial but choosing a good name is not so easy. A short name must show
    what the function does and let the reader imagine what error is it handling or
    if it's doing any kind of logging. Within your function, you want to do everything
    that a particular behavior need but also to control expected errors and wrapping
    them properly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的函数选择一个好的名字非常重要，这样它就非常清楚它是关于什么的，而不需要写太多的注释。这可能看起来有点琐碎，但选择一个好的名字并不容易。一个简短的名字必须显示函数的功能，并让读者想象它正在处理什么错误，或者是否在进行任何类型的日志记录。在你的函数中，你希望做任何特定行为需要的一切，但也要控制预期的错误并适当地包装它们。
- en: So, to write a function is more than simply throw a couple of lines that does
    what you need, that's why it is important to write a unit test, make them small
    and concise.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编写函数不仅仅是简单地写出几行代码来完成你需要的功能，这就是为什么编写单元测试、使它们小而简洁是很重要的。
- en: What is an anonymous function?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是匿名函数？
- en: 'An anonymous function is a function without a name. This is useful when you
    want to return a function from another function that doesn''t need a context or
    when you want to pass a function to a different function. For example, we will
    create a function that accepts one number and returns a function that accepts
    a second number that it adds it to the first one. The second function does not
    have a declarative name (as we have assigned it to a variable) that is why it
    is said to be anonymous:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是没有名字的函数。当你想要从另一个函数返回一个不需要上下文的函数，或者当你想要将一个函数传递给另一个函数时，这是很有用的。例如，我们将创建一个接受一个数字并返回一个接受第二个数字并将其加到第一个数字的函数。第二个函数没有声明的名称（因为我们将其分配给一个变量），所以它被称为匿名函数：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `add` variable points to an anonymous function that adds one to the specified
    parameter. As you can see, it can be used only for the scope its parent function
    `main` and cannot be called from anywhere else.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`变量指向一个匿名函数，该函数将指定参数加一。正如你所看到的，它只能在其父函数`main`的作用域中使用，不能从其他任何地方调用。'
- en: Anonymous functions are really powerful tools that we will use extensively on
    design patterns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是非常强大的工具，在设计模式中我们会广泛使用它们。
- en: Closures
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are something very similar to anonymous functions but even more powerful.
    The key difference between them is that an anonymous function has no context within
    itself and a closure has. Let''s rewrite the previous example to add an arbitrary
    number instead of one:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包与匿名函数非常相似，但更加强大。它们之间的关键区别在于匿名函数在自身内部没有上下文，而闭包有。让我们重新编写前面的例子，以便添加任意数量而不是一个：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `addN` variable points to a function that returns another function. But
    the returned function has the context of the `m` parameter within it. Every call
    to `addN` will create a new function with a fixed `m` value, so we can have main `addN`
    functions, each adding a different value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`addN`变量指向一个返回另一个函数的函数。但是返回的函数在其中具有`m`参数的上下文。每次调用`addN`都会创建一个具有固定`m`值的新函数，因此我们可以有主`addN`函数，每个函数都添加不同的值。'
- en: This ability of closures is very useful to create libraries or deal with functions
    with unsupported types.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的这种能力非常有用，可以用来创建库或处理不支持类型的函数。
- en: Creating errors, handling errors and returning errors.
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建错误，处理错误和返回错误。
- en: 'Errors are extensively used in Go, probably thanks to its simplicity. To create
    an error simply make a call to `errors.New(string)` with the text you want to
    create on the error. For example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 错误在Go中被广泛使用，可能是因为它的简单性。要创建一个错误，只需调用`errors.New(string)`并提供你想要在错误中创建的文本。例如：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we have seen before, we can return errors to a function. To handle an error
    you''ll see the following pattern extensively in Go code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们可以向函数返回错误。在Go代码中，你会经常看到以下模式来处理错误：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Function with undetermined number of parameters
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有不确定数量参数的函数
- en: 'Functions can be declared as *variadic*. This means that its number of arguments
    can vary. What this does is to provide an array to the scope of the function that
    contains the arguments that the function was called with. This is convenient if
    you don''t want to force the user to provide an array when using this function.
    For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以声明为*可变参数*。这意味着它的参数数量可以变化。这样做的作用是为函数的作用域提供一个包含函数调用时使用的参数的数组。如果你不想在使用这个函数时强制用户提供一个数组，这是很方便的。例如：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we have a `sum` function that will return the sum of all its
    arguments but take a closer look at the `main` function where we call `sum`. As
    you can see now, first we call `sum` with three arguments and then with five arguments.
    For `sum` functions, it doesn't matter how many arguments you pass as it treats
    its arguments as an array all in all. So on our `sum` definition, we simply iterate
    over the array to add each number to the `result` integer.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个`sum`函数，它将返回所有参数的总和，但是仔细看一下我们在`main`函数中调用`sum`的地方。现在你可以看到，首先我们用三个参数调用`sum`，然后用五个参数调用。对于`sum`函数来说，你传递多少参数都无所谓，因为它将其参数视为一个数组。因此，在我们的`sum`定义中，我们只是遍历数组，将每个数字加到`result`整数上。
- en: Naming returned types
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名返回类型
- en: Have you realized that we have given a name to the returned type? Usually, our
    declaration would be written as `func sum(args int) int` but you can also name
    the variable that you'll use within the function as a return value. Naming the
    variable in the return type would also zero-value it (in this case, an `int` will
    be initialized as zero). At the end, you just need to return the function (without
    value) and it will take the respective variable from the scope as returned value.
    This also makes easier to follow the mutation that the returning variable is suffering
    as well as to ensure that you aren't returning a mutated argument.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到我们给返回类型取了一个名字？通常，我们的声明会写成`func sum(args int) int`，但你也可以给你在函数中用作返回值的变量取一个名字。在返回类型中命名变量也会将其零值化（在这种情况下，一个`int`会被初始化为零）。最后，你只需要返回函数（无需值），它就会取相应的变量作为返回值。这也更容易跟踪返回变量所经历的变化，以及确保你没有返回一个经过变异的参数。
- en: Arrays, slices, and maps
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组、切片和映射
- en: Arrays are one of the most widely used types of computer programming. They are
    lists of other types that you can access by using their position on the list.
    The only downside of an array is that its size cannot be modified. Slices allow
    the use of arrays with variable size. The `maps` type will let us have a dictionary
    like structures in Go. Let's see how each work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是计算机编程中最常用的类型之一。它们是可以通过它们在列表中的位置访问的其他类型的列表。数组的唯一缺点是它的大小不能被修改。切片允许使用大小可变的数组。`maps`类型将让我们在Go中拥有类似字典的结构。让我们看看每个是如何工作的。
- en: Arrays
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a numbered sequence of elements of a single type. You can store
    100 different unsigned integers in a unique variable, three strings or 400 `bool`
    values. Their size cannot be changed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是单一类型元素的编号序列。您可以在一个唯一的变量中存储100个不同的无符号整数，三个字符串或400个布尔值。它们的大小不能被改变。
- en: 'You must declare the length of the array on its creation as well as the type.
    You can also assign some value on creation. For example here you have 100 `int`
    values all with `0` as value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在创建数组时声明数组的长度以及类型。你也可以在创建时赋值。例如，这里有100个值为`0`的`int`值：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or an array of size 3 with `strings` already assigned:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个大小为3的`strings`数组已经被赋值：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here you have an array of 2 `bool` values that we initialize later:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个我们稍后初始化的包含2个布尔值的数组：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Zero-initialization
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零初始化
- en: In our previous example, we have initialized an `array` of `bool` values of
    size `2`. We wouldn't need to assign `arr[1]` to `false` because of the nature
    of zero-initialization in the language. Go will initialize every value in a `bool`
    array to `false`. We will look deeper to zero-initialization later in this chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们初始化了一个大小为2的布尔值数组。我们不需要将`arr[1]`赋值为`false`，因为语言的零初始化特性。Go将会将布尔数组中的每个值初始化为`false`。我们稍后会更深入地了解零初始化。
- en: Slices
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: 'Slices are similar to arrays, but their size can be altered on runtime. This
    is achieved, thanks to the underlying structure of a slice that is an array. So,
    like arrays, you have to specify the type of the slice and its size. So, use the
    following line to create a slice:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 切片类似于数组，但它们的大小可以在运行时改变。这得益于切片的底层结构是一个数组。因此，就像数组一样，你必须指定切片的类型和大小。因此，使用以下行来创建一个切片：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This command has created an underlying array of ten elements. If we need to
    change the size of the slice by, for example, adding a new number, we would append
    the number to the slice:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个包含十个元素的基础数组。如果我们需要改变切片的大小，例如添加一个新的数字，我们可以将数字附加到切片上：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The syntax of append is of the form ([array to append an item to], [item to
    append]) and returns the new slice, it does not modify the actual slice. This
    is also true to delete an item. For example, let''s delete the first item of the
    array as following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: append的语法是（[要附加项的数组]，[要附加的项]），并返回新的切片，它不会修改实际的切片。删除项也是如此。例如，让我们删除数组的第一个项如下：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Yes, like in arrays. But what about deleting the second item? We use the same
    syntax:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就像数组一样。但是删除第二个项呢？我们使用相同的语法：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We take all elements from zero index (included) to the first index (not included)
    and each element from the second index (included) to the end of the array, effectively
    deleting the value at the second position in the slice (index 1 as we start counting
    with 0). As you can see, we use the undetermined arguments syntax as the second
    parameter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取从零索引（包括）到第一个索引（不包括）的所有元素，以及从第二个索引（包括）到数组末尾的每个元素，有效地删除了切片中第二个位置的值（索引1，因为我们从0开始计数）。正如你所看到的，我们使用了未确定参数的语法作为第二个参数。
- en: Maps
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: 'Maps are like dictionaries--for each word, we have a definition but we can
    use any type as word or definition and they''ll never be ordered alphabetically.
    We can create maps of string that point to numbers, a string that points to `interfaces` and
    `structs` that point to `int` and `int` to `function`. You cannot use as key:
    slices, the functions, and maps. Finally, you create maps by using the keyword
    make and specifying the key type and the value type:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 映射就像字典一样——对于每个单词，我们有一个定义，但我们可以使用任何类型作为单词或定义，它们永远不会按字母顺序排序。我们可以创建指向数字的字符串映射，指向`interfaces`的字符串映射，指向`int`和`int`到`function`的`structs`映射。你不能使用切片、函数和映射作为键。最后，你可以使用关键字`make`来创建映射，并指定键类型和值类型：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When parsing JSON content, you can also use them to get a `string[interface]`
    map:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析JSON内容时，您还可以使用它们来获取“string[interface]”映射：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `myJsonMap` variable is a map that will store the contents of JSON and that
    we will need to pass its pointer to the `Unmarshal` function. The `jsonData` variable
    declares an array of bytes with the typical content of a JSON object; we are using
    this as the mock object. Then, we unmarshal the contents of the JSON storing the
    result of the memory location of `myJsonMap` variable. After checking that the
    conversion was ok and the JSON byte array didn't have syntax mistakes, we can
    access the contents of the map in a JSON-like syntax.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: “myJsonMap”变量是一个将存储JSON内容并且我们需要将其指针传递给“Unmarshal”函数的映射。 “jsonData”变量声明了一个字节数组，其中包含JSON对象的典型内容；我们将其用作模拟对象。然后，我们解析JSON的内容，将结果存储在“myJsonMap”变量的内存位置。在检查转换是否正确以及JSON字节数组没有语法错误后，我们可以以类似JSON的语法访问映射的内容。
- en: Visibility
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性
- en: Visibility is the attribute of a function or a variable to be visible to different
    parts of the program. So a variable can be used only in the function that is declared,
    in the entire package or in the entire program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性是函数或变量可见于程序不同部分的属性。因此，变量只能在声明的函数中使用，在整个包中使用或在整个程序中使用。
- en: 'How can I set the visibility of a variable or function? Well, it can be confusing
    at the beginning but it cannot be simpler:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如何设置变量或函数的可见性？嗯，一开始可能会有点混乱，但实际上并不复杂：
- en: Uppercase definitions are public (visible in the entire program).
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写定义是公共的（在整个程序中可见）。
- en: Lowercase are private (not seen at the package level) and function definitions
    (variables within functions) are visible just in the scope of the function.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小写是私有的（在包级别不可见），函数定义（函数内的变量）只在函数范围内可见。
- en: 'Here you can see an example of a `public` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到一个“public”函数的示例：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `Hello_world` is a global function (a function that is visible across
    the entire source code and to third party users of your code). So, if our package
    is called `hello`, we could call this function from outside of this package by
    using `hello.Hello_world()` method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“Hello_world”是一个全局函数（在整个源代码和代码的第三方用户中可见的函数）。因此，如果我们的包叫做“hello”，我们可以通过使用“hello.Hello_world（）”方法从包外调用这个函数。
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are in the `different_package` package. We have to import
    the package we want to use with the keyword import. The route then is the path
    within your `$GOPATH/src` that contains the package we are looking for. This path
    conveniently matches the URL of a GitHub account or any other **Concurrent Versions
    System**(**CVS**) repository.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在“different_package”包中。我们必须使用关键字import导入我们想要使用的包。然后路径就是包含我们要查找的包的路径在您的$GOPATH/src中。这个路径方便地匹配了GitHub账户或任何其他**Concurrent
    Versions System**（**CVS**）存储库的URL。
- en: Zero-initialization
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 零初始化
- en: 'Zero-initialization is a source of confusion sometimes. They are default values
    for many types that are assigned even if you don''t provide a value for the definition.
    Following are the zero-initialization for various types:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 零初始化有时会引起混淆。它们是许多类型的默认值，即使您没有为定义提供值，它们也会被赋值。以下是各种类型的零初始化：
- en: The `false` initialization for `bool` type.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于“bool”类型使用“false”初始化。
- en: Using `0` values for `int` type.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于“int”类型使用“0”值。
- en: Using `0.0` for `float` type.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于“float”类型使用“0.0”。
- en: Using `""` (empty strings) for `string` type.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于“string”类型使用“”（空字符串）。
- en: Using `nil` keyword for pointers, functions, interfaces, slices, channels and
    maps.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于指针、函数、接口、切片、通道和映射使用“nil”关键字。
- en: Empty `struct` for structures without fields.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于没有字段的结构使用空“struct”。
- en: Zero-initialized `struct` for structures with fields. The zero value of a structure
    is defined as the structure that has its fields initialized as zero value too.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有字段的结构，零初始化的“struct”。结构的零值被定义为其字段也被初始化为零值的结构。
- en: Zero-initialization is important when programming in Go because you won't be
    able to return a `nil` value if you have to return an `int` type or a `struct`.
    Keep this in mind, for example, in functions where you have to return a `bool`
    value. Imagine that you want to know if a number is divisible by a different number
    but you pass `0` (zero) as the divisor.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中编程时，零初始化是重要的，因为如果您必须返回一个“int”类型或一个“struct”，您将无法返回一个“nil”值。例如，在必须返回一个“bool”值的函数中，请记住这一点。想象一下，您想知道一个数字是否能被另一个数字整除，但您将“0”（零）作为除数。
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of this program is `false` but this is incorrect. A number divided
    by zero is an error, it''s not that 10 isn''t divisible by zero but that a number
    cannot be divided by zero by definition. Zero-initialization is making things
    awkward in this situation. So, how can we solve this error? Consider the following
    code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出是“false”，但这是不正确的。被零除的数字是一个错误，不是10不能被零整除，而是根据定义，一个数字不能被零整除。零初始化在这种情况下使事情变得尴尬。那么，我们如何解决这个错误呢？考虑以下代码：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're dividing `10` by `0` again but now the output of this function is `A number
    cannot be divided by zero`. Error captured, the program finished gracefully.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次将“10”除以“0”，但现在这个函数的输出是“一个数字不能被零整除”。错误被捕获，程序优雅地结束了。
- en: Pointers and structures
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针和结构
- en: Pointers are the number one source of a headache of every C or C++ programmer.
    But they are one of the main tools to achieve high-performance code in non-garbage-collected
    languages. Fortunately for us, Go's pointers have achieved the best of both worlds
    by providing high-performance pointers with garbage-collector capabilities and
    easiness.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是每个C或C++程序员头痛的主要原因。但它们是非垃圾收集语言中实现高性能代码的主要工具之一。幸运的是，对于我们来说，Go的指针通过提供具有垃圾收集器功能和易用性的高性能指针，实现了两全其美。
- en: On the other side for its detractors, Go lacks inheritance in favor of composition.
    Instead of talking about the objects that *are* in Go, your objects *have other *.
    So, instead of having a `car` structure that inherits the class `vehicle` (a car
    is a vehicle), you could have a `vehicle` structure that contains a `car` structure
    within.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于它的批评者来说，Go 缺乏继承，而更倾向于组合。与其谈论在 Go 中 *是* 的对象，不如谈论你的对象 *有其他的*。所以，你可以有一个包含
    `car` 结构的 `vehicle` 结构，而不是一个继承类 `vehicle` 的 `car` 结构（汽车是一种车辆）。
- en: What is a pointer? Why are they good?
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针是什么？为什么它们很好？
- en: Pointers are hated, loved, and very useful at the same time. To understand what
    a pointer is can be difficult so let's try with a real world explanation. As we
    mentioned earlier in this chapter, a pointer is a like a mailbox. Imagine a bunch
    of mailboxes in a building; all of them have the same size and shape but each
    refers to a different house within the building. Just because all mailboxes are
    the same size does not mean that each house will have the same size. We could
    even have a couple of houses joined, a house that was there but now has a license
    of commerce, or a house that is completely empty. So the pointers are the mailboxes,
    all of them of the same size and that refer to a house. The building is our memory
    and the houses are the types our pointers refer to and the memory they allocate.
    If you want to receive something in your house, it's far easier to simply send
    the address of your house (to send the pointer) instead of sending the entire
    house so that your package is deposited inside. But they have some drawbacks as
    if you send your address and your house (variable it refers to) disappears after
    sending, or its type owner change--you'll be in trouble.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 指针同时受到憎恨、喜爱和非常有用。理解指针是什么可能很困难，所以让我们试着用一个现实世界的解释。正如我们在本章前面提到的，指针就像一个邮箱。想象一栋建筑里有一堆邮箱；它们都有相同的大小和形状，但每个邮箱都指向建筑物内的不同房子。只是因为所有邮箱的大小都一样，并不意味着每个房子都有相同的大小。我们甚至可以有几栋房子连接在一起，一个曾经存在但现在拥有商业许可的房子，或者一个完全空的房子。所以指针就是邮箱，它们都是相同大小的，指向一个房子。建筑物是我们的内存，房子是我们的指针引用的类型和它们分配的内存。如果你想在你的房子里收到一些东西，只需简单地发送你的房子的地址（发送指针）而不是发送整个房子，这样你的包裹就被放在里面了。但它们也有一些缺点，比如如果你发送了你的地址，然后你的房子（它引用的变量）在发送后消失了，或者它的类型所有者发生了变化——你就会陷入麻烦。
- en: How is this useful? Imagine that somehow you have 4 GB of data in a variable
    and you need to pass it to a different function. Without a pointer, the entire
    variable is cloned to the scope of the function that is going to use it. So, you'll
    have 8 GB of memory occupied by using this variable twice that, hopefully, the
    second function isn't going to use in a different function again to raise this
    number even more.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用？想象一下，你以某种方式有一个 4 GB 的变量，你需要将它传递给另一个函数。没有指针，整个变量都会被克隆到将要使用它的函数的范围内。所以，你将有
    8 GB 的内存被使用，通过两次使用这个变量，希望第二个函数不会再在另一个函数中使用它，以进一步增加这个数字。
- en: You could use a pointer to pass a very small reference to this chunk to the
    first function so that just the small reference is cloned and you can keep your
    memory usage low.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用指针将一个非常小的引用传递给第一个函数，这样只需克隆一个小引用，就可以保持内存使用量较低。
- en: While this isn't the most academic nor exact explanation, it gives a good view
    of what a pointer is without explaining what a stack or a heap is or how they
    work in x86 architectures.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是最学术的、也不是最准确的解释，但它给出了指针是什么的一个很好的观点，而不解释堆栈或堆在 x86 架构中是如何工作的。
- en: Pointers in Go are very limited compared with C or C++ pointers. You can't use
    pointer arithmetic nor can you create a pointer to reference an exact position
    in the stack.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 或 C++ 指针相比，Go 中的指针非常有限。你不能使用指针算术，也不能创建一个指向栈中确切位置的指针。
- en: 'Pointers in Go can be declared like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，指针可以这样声明：
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here `number := 5` code represents our 4 GB variable and `pointer_to_number`
    contains the reference (represented by an ampersand) to this variable. It''s the
    direction to the variable (the one that you put in the mailbox of this `house/type/variable`).
    Let''s print the variable `pointer_to_number` , which is a simple variable:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `number := 5` 代码表示我们的 4 GB 变量，`pointer_to_number` 包含对此变量的引用（用 & 表示）。这是指向变量的方向（你放在这个
    `house/type/variable` 的邮箱里）。让我们打印变量 `pointer_to_number`，这是一个简单的变量：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What's that number? Well, the direction to our variable in memory. And how can
    I print the actual value of the house? Well, with an asterisk (`*)` we tell the
    compiler to take the value that the pointer is referencing, which is our 4 GB
    variable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那个数字是什么？嗯，是我们内存中变量的方向。我如何打印房子的实际值？嗯，通过一个星号（`*`），我们告诉编译器取指针引用的值，也就是我们的 4 GB 变量。
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Structs
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构
- en: A struct is an object in Go. It has some similarities with classes in OOP as
    they have fields. Structs can implement interfaces and declare methods. But, for
    example, in Go, there's not inheritance. Lack of inheritance looks limiting but
    in fact, *composition over inheritance* was a requirement of the language.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 结构是 Go 中的一个对象。它与面向对象编程中的类有一些相似之处，因为它们有字段。结构可以实现接口并声明方法。但是，例如，在 Go 中，没有继承。缺乏继承看起来是有限的，但实际上，*组合优于继承*
    是这种语言的要求。
- en: 'To declare a structure, you have to prefix its name with the keyword `type`
    and suffix with the keyword `struct` and then you declare any field or method
    between brackets, for example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个结构，你必须用关键字 `type` 作为前缀，用关键字 `struct` 作为后缀，然后在括号之间声明任何字段或方法，例如：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this piece of code, we have declared a `Person` structure with three public
    fields (`Name`, `Age` , and `Hobbies`) and one private field (`id`, if you recall
    the *Visibility* section in this chapter, lowercase fields in Go refers to private
    fields are just visible within the same package). With this `struct`, we can now
    create as many instances of `Person` as we want. Now we will write a function
    called `GetFullName` that will give the composition of the name and the surname
    of the `struct` it belongs to:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们声明了一个`Person`结构，其中有三个公共字段（`Name`，`Age`和`Hobbies`）和一个私有字段（`id`，如果你回忆一下本章的*可见性*部分，Go中的小写字段指的是私有字段，只在同一个包内可见）。有了这个`struct`，我们现在可以创建任意多个`Person`的实例。现在我们将编写一个名为`GetFullName`的函数，该函数将给出`struct`所属的名字和姓氏的组合：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Methods are defined similarly to functions but in a slightly different way.
    There is a`(p *Person)` that refers to a pointer to the created instance of the
    `struct` (recall the *Pointers* section in this chapter). It's like using the
    keyword `this` in Java or `self` in Python when referring to the pointing object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的定义方式与函数类似，但略有不同。有一个`(p *Person)`，它指的是指向`struct`创建的实例的指针（回忆一下本章的*指针*部分）。这就像在Java中使用关键字`this`或在Python中引用指向对象时使用`self`一样。
- en: Maybe you are thinking why does (`p *Person`) have the pointer operator to reflect
    that `p` is actually a pointer and not a value? This is because you can also pass
    Person by value by removing the pointer signature, in which case a copy of the
    value of Person is passed to the function. This has some implications, for example,
    any change that you make in p if you pass it by value won't be reflected in source
    `p`. But what about our `GetFullName()` method?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想为什么(`p *Person`)有指针运算符来反映`p`实际上是一个指针而不是一个值？这是因为你也可以通过删除指针签名来传递Person的值。在这种情况下，将传递Person值的副本给函数。这有一些影响，例如，如果你通过值传递p进行更改，那么在源`p`中不会反映出这些更改。但是我们的`GetFullName()`方法呢？
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Its console output has no effect in appearance but a full copy was passed before
    evaluating the function. But if we modify `person` here, the source `p` won't
    be affected and the new `person` value will be available only on the scope of
    this function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它的控制台输出在外观上没有影响，但在评估函数之前进行了完全复制。但是，如果我们在这里修改`person`，源`p`不会受到影响，新的`person`值只会在此函数的范围内可用。
- en: On the `main` function, we create an instance of our structure called `p`. As
    you can see, we have used implicit notation to create the variable (the `:=` symbol).
    To set the fields, you have to refer to the name of the field, colon, the value,
    and the comma (don't forget the comma at the end!). To access the fields of the
    instantiated structure, we just refer to them by their name like `p.Name` or `p.Surname`.
    You use the same syntax to access the methods of the structure like `p.GetFullName()`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们创建了一个名为`p`的结构的实例。正如你所看到的，我们使用了隐式表示法来创建变量（`:=`符号）。要设置字段，你必须引用字段的名称，冒号，值和逗号（不要忘记最后的逗号！）。要访问实例化结构的字段，我们只需通过它们的名称引用它们，如`p.Name`或`p.Surname`。你可以使用相同的语法来访问结构的方法，如`p.GetFullName()`。
- en: 'The output of this program is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出是：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Structures can also contain another structure (composition) and implement interface
    methods apart from their own but, what's an interface method?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 结构也可以包含另一个结构（组合）并实现接口方法，除了它们自己的方法之外，但是，什么是接口方法？
- en: Interfaces
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are essential in object-oriented programming, in functional programming
    (`traits`) and, especially, in design patterns. Go's source code is full of interfaces
    everywhere because they provide the abstraction needed to deliver uncoupled code
    with the help of functions. As a programmer, you also need this type of abstraction
    when you write libraries but also when you write code that is going to be maintained
    in the future with new functionality.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在面向对象编程、函数式编程（`traits`）以及设计模式中至关重要。Go的源代码中到处都是接口，因为它们提供了通过函数提供所需的抽象来交付无耦合的代码。作为程序员，当你编写库时，也需要这种类型的抽象，但也需要在编写将来需要新功能维护的代码时使用这种抽象。
- en: Interfaces are something difficult to grasp at the beginning but very easy once
    you have understood their behavior and provide very elegant solutions for common
    problems. We will use them extensively during this book so put special focus on
    this section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在开始时很难理解，但一旦理解了它们的行为并为常见问题提供了非常优雅的解决方案，就会变得非常容易。我们将在本书中广泛使用它们，因此请特别关注本节。
- en: Interfaces - signing a contract
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口 - 签署合同
- en: An interface is something really simple but powerful. It's usually defined as
    a contract between the objects that implement it but this explanation isn't clear
    enough in my honest opinion for newcomers to the interface world.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一种非常简单但强大的东西。它通常被定义为实现它的对象之间的合同，但对于接口世界的新手来说，这种解释并不够清晰。
- en: A water-pipe is a contract too; whatever you pass through it must be a liquid.
    Anyone can use the pipe, and the pipe will transport whatever liquid you put in
    it (without knowing the content). The water-pipe is the interface that enforces
    that the users must pass liquids (and not something else).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 水管也是一种合同；你通过它传递的任何东西都必须是液体。任何人都可以使用这根管子，管子将运输你放入其中的任何液体（而不知道其内容）。水管是强制要求用户必须传递液体（而不是其他东西）的接口。
- en: 'Let''s think about another example: a train. The railroads of a train are like
    an interface. A train must construct (implement) its width with a specified value
    so that it can enter the railroad but the railroad never knows exactly what it''s
    carrying (passengers or cargo). So for example, an interface of the railroad will
    have the following aspect:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子：火车。火车的铁轨就像一个接口。火车必须使用指定的值构建（实现）其宽度，以便它可以进入铁路，但铁路永远不知道它究竟装载了什么（乘客或货物）。因此，例如，铁路的接口将具有以下方面：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `RailroadWideChecker` is the type our trains must implement to provide
    information about their width. The trains will verify that the train isn''t too
    wide or too narrow to use its railroads:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`RailroadWideChecker`是我们的火车必须实现的类型，以提供有关其宽度的信息。火车将验证火车的宽度是否过宽或过窄以使用其铁路：'
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Railroad` is implemented by an imaginary station object that contains
    the information about the width of the railroads in this station and that has
    a method to check whether a train fits the needs of the railroad with the `IsCorrectSizeTrain`
    method. The `IsCorrectSizeTrain` method receives an interface object which is
    a pointer to a train that implements this interface and returns a validation between
    the width of the train and the railroad:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`铁路`由一个虚构的车站对象实现，该对象包含有关该车站铁路宽度的信息，并具有一个方法来检查火车是否符合铁路的需求，即`IsCorrectSizeTrain`方法。`IsCorrectSizeTrain`方法接收一个实现了该接口的火车的指针，并返回火车宽度与铁路之间的验证：'
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we have created a passenger's train. It has a field to contain its width
    and implements our `CheckRailsWidth` interface method. This structure is considered
    to fulfill the needs of a `RailRoadWideChecker` interface (because it has an implementation
    of the methods that the interfaces ask for).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一列乘客列车。它有一个字段来包含其宽度，并实现了我们的`CheckRailsWidth`接口方法。这个结构被认为满足`RailRoadWideChecker`接口的需求（因为它实现了接口要求的方法）。
- en: So now, we'll create a railroad of `10` units wide and two trains--one of `10`
    units wide that fit the railroad size and another of `15` units that cannot use
    the railroad.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个宽度为`10`个单位的铁路和两列火车--一列宽度为`10`个单位的火车符合铁路尺寸，另一列宽度为`15`个单位的火车无法使用铁路。
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s dissect this `main` function. First, we created a railroad object of
    `10` units called `railroad`. Then two trains, of `10` and `15` units'' width
    for passengers and cargo respectively. Then, we pass both objects to the railroad
    method that accepts interfaces of the `RailroadWideChecker` interface. The railroad
    itself does not know the width of each train separately (we''ll have a huge list
    of trains) but it has an interface that trains must implement so that it can ask
    for each width and returns a value telling you if a train can or cannot use of
    the railroads. Finally, the output of the call to `printf` function is the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析这个`main`函数。首先，我们创建了一个名为`railroad`的宽度为`10`个单位的铁路对象。然后，分别为乘客和货物创建了宽度为`10`和`15`个单位的两列火车。然后，我们将这两个对象传递给接受`RailroadWideChecker`接口的铁路方法。铁路本身不知道每列火车的宽度（我们将有一个巨大的火车列表），但它有一个火车必须实现的接口，以便它可以询问每个宽度并返回一个值，告诉您火车是否可以或不能使用铁路。最后，对`printf`函数的调用输出如下：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As I mentioned earlier, interfaces are so widely used during this book that
    it doesn't matter if it still looks confusing for the reader as they'll be plenty
    of examples during the book.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，接口在本书中被广泛使用，所以即使对读者来说它看起来仍然很困惑，因为在本书中将有大量的例子。
- en: Testing and TDD
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和TDD
- en: When you write the first lines of some library, it's difficult to introduce
    many bugs. But once the source code gets bigger and bigger, it becomes easier
    to break things. The team grows and now many people are writing the same source
    code, new functionality is added on top of the code that you wrote at the beginning.
    And code stopped working by some modification in some function that now nobody
    can track down.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写某个库的第几行时，很难引入许多错误。但是一旦源代码变得越来越大，就会变得更容易出错。团队壮大了，现在有很多人在编写相同的源代码，新功能是在您最初编写的代码之上添加的。现在，由于某个函数的某些修改，代码停止工作，现在没有人能够追踪到。
- en: This is a common scenario in enterprises that testing tries to reduce (it doesn't
    completely solve it, it's not a holy grail). When you write unit tests during
    your development process, you can check whether some new feature is breaking something
    older or whether your current new feature is achieving everything expected in
    the requirements.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是企业中测试试图减少的常见情况（它并不能完全解决问题，不是圣杯）。在开发过程中编写单元测试时，您可以检查一些新功能是否破坏了旧功能，或者您当前的新功能是否符合需求中的所有预期。
- en: Go has a powerful testing package that allows you also to work in a TDD environment
    quite easily. It is also very convenient to check the portions of your code without
    the need to write an entire main application that uses it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有一个强大的测试包，使您也可以很容易地在TDD环境中工作。它还非常方便，可以在不需要编写使用它的整个主应用程序的情况下检查代码的部分。
- en: The testing package
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试包
- en: Testing is very important in every programming language. Go creators knew it
    and decided to provide all libraries and packages needed for the test in the core
    package. You don't need any third-party library for testing or code coverage.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，测试都非常重要。Go的创建者知道这一点，并决定在核心包中提供所有测试所需的库和包。您不需要任何第三方库进行测试或代码覆盖。
- en: 'The package that allows for testing Go apps is called, conveniently, testing.
    We will create a small app that sums two numbers that we provide through the command
    line:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 允许测试Go应用程序的包称为`testing`。我们将创建一个小应用程序，通过命令行提供两个数字并对其进行求和：
- en: '[PRE54]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s execute our program in the terminal to get the sum:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中执行我们的程序以得到总和：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: By the way, we're using the `strconv` package to convert strings to other types,
    in this case, to `int`. The method `Atoi` receives a string and returns an `int` and
    an `error` that, for simplicity, we are ignoring here (by using the underscore).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们正在使用`strconv`包将字符串转换为其他类型，这种情况下是转换为`int`。`Atoi`方法接收一个字符串并返回一个`int`和一个`error`，为简单起见，我们在这里忽略了（使用下划线）。
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can ignore variable returns by using the underscores if necessary, but usually,
    you don't want to ignore errors.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以使用下划线忽略变量返回，但通常不希望忽略错误。
- en: 'Ok, so let''s write a test that checks the correct result of the sum. We''re
    creating a new file called `main_test.go`. By convention, test files are named
    like the files they''re testing plus the `_test` suffix:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们编写一个测试，检查求和的正确结果。我们正在创建一个名为`main_test.go`的新文件。按照惯例，测试文件的命名方式与它们测试的文件相同，加上`_test`后缀：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Testing in Go is used by writing methods started with the prefix `Test`, a test
    name, and the injection of the `testing.T` pointer called `t`. Contrary to other
    languages, there are no asserts nor special syntax for testing in Go. You can
    use Go syntax to check for errors and you call `t` with information about the
    error in case it fails. If the code reaches the end of the `Test` function without
    arising errors, the function has passed the tests.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中进行测试是通过编写以前缀`Test`开头的方法，一个测试名称和名为`t`的`testing.T`指针的注入来完成的。与其他语言相反，在Go中没有断言，也没有用于测试的特殊语法。您可以使用Go语法来检查错误，并在失败时使用`t`调用有关错误的信息。如果代码在没有出现错误的情况下到达`Test`函数的末尾，则该函数已通过测试。
- en: 'To run a test in Go, you must use the `go test -v` command (`-v` is to receive
    verbose output from the test) keyword, as following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Go中运行测试，您必须使用`go test -v`命令（`-v`是为了从测试中接收详细输出）关键字，如下所示：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our tests were correct. Let''s see what happens if we break things on purpose
    and we change the expected value of the test from `11` to `10`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试是正确的。让我们看看如果我们故意破坏事情并将测试的预期值从`11`改为`10`会发生什么：
- en: '[PRE58]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The test has failed (as we expected). The testing package provides the information
    you set on the test. Let''s make it work again and check test coverage. Change
    the value of the variable `expected` from `10` to `11` again and run the command
    `go test -cover` to see code coverage:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了（正如我们预料的那样）。测试包提供了您在测试中设置的信息。让我们再次使其工作，并检查测试覆盖率。将变量`expected`的值从`10`更改为`11`，然后运行命令`go
    test -cover`以查看代码覆盖率：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `-cover` options give us information about the code coverage for a given
    package. Unfortunately, it doesn't provide information about overall application
    coverage.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`-cover`选项为我们提供了有关给定包的代码覆盖率的信息。不幸的是，它不提供有关整体应用程序覆盖率的信息。'
- en: What is TDD?
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是TDD？
- en: TDD is the acronym for **Test Driven Development**. It consists of writing the
    tests first before writing the function (instead of what we did just before when
    we wrote the `sum` function first and then we wrote the `test` function).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是**测试驱动开发**的缩写。它包括在编写函数之前先编写测试（而不是我们之前所做的，先编写`sum`函数，然后再编写`test`函数）。
- en: TDD changes the way to write code and structure code so that it can be tested
    (a lot of code you can find in GitHub, even code that you have probably written
    in the past is probably very difficult, if not impossible, to test).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: TDD改变了编写代码和结构代码的方式，以便可以进行测试（您可以在GitHub上找到很多代码，甚至您以前可能编写的代码可能非常难以测试，甚至是不可能的）。
- en: 'So, how does it work? Let''s explain this with a real life example--imagine
    that you are in summer and you want to be refreshed somehow. You can build a pool,
    fill it with cold water, and jump into it. But in TDD terms, the steps will be:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？让我们用一个现实生活的例子来解释一下--想象一下你在夏天，你想要得到一些清凉。你可以建造一个游泳池，把它装满冷水，然后跳进去。但是在TDD术语中，步骤将是：
- en: You jump into a place where the pool will be built (you write a test that you
    know it will fail).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你跳进一个将要建造游泳池的地方（你写一个你知道会失败的测试）。
- en: It hurts... and you aren't cool either (yes... the test failed, as we predicted).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它很疼...而且你也不酷（是的...测试失败了，正如我们预料的那样）。
- en: You build a pool and fill it with cold water (you code the functionality).
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你建造了一个游泳池，把它装满冷水（你编写了功能）。
- en: You jump into the pool (you repeat the point 1 test again).
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你跳进游泳池（你再次重复第1点的测试）。
- en: You're cold now. Awesome! Object completed (test passed).
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在很冷。太棒了！对象完成了（测试通过）。
- en: Go to the fridge and take a beer to the pool. Drink. Double awesomeness (refactor
    the code).
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 去冰箱拿一瓶啤酒到游泳池。喝。双倍的美妙（重构代码）。
- en: 'So let''s repeat the previous example but with a multiplication. First, we
    will write the declaration of the function that we''re going to test:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们重复之前的例子，但是用乘法。首先，我们将写下我们要测试的函数的声明：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now let''s write the test that will check the correctness of the previous function:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个测试，检查之前函数的正确结果：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And we test it through the command line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过命令行进行测试：
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Nice. Like in our pool example where the water wasn''t there yet, our function
    returns an incorrect value too. So now we have a function declaration (but isn''t
    defined yet) and the test that fails. Now we have to make the test pass by writing
    the function and executing the test to check:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。就像在我们的游泳池例子中水还没有到位一样，我们的函数返回的值也是不正确的。所以现在我们有了一个函数声明（但还没有定义），以及失败的测试。现在我们必须通过编写函数并执行测试来使测试通过以检查：
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And we execute again our testing suite. After writing our code correctly, the
    test should pass so we can continue to the refractoring process:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次执行我们的测试套件。在正确编写我们的代码之后，测试应该通过，这样我们就可以继续进行重构过程：
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Great! We have developed the `multiply` function following TDD. Now we must
    refactor our code but we cannot make it more simple or readable so the loop can
    be considered closed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经按照TDD开发了`multiply`函数。现在我们必须重构我们的代码，但我们不能使它更简单或更可读，所以循环可以被认为是封闭的。
- en: During this book, we will write many tests that define the functionality that
    we want to achieve in our patterns. TDD promotes encapsulation and abstraction
    (just like design patterns do).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将编写许多测试，定义我们在模式中要实现的功能。TDD促进了封装和抽象（就像设计模式一样）。
- en: Libraries
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: Until now, most of our examples were applications. An application is defined
    by its `main` function and package. But with Go, you can also create pure libraries.
    In libraries, the package need not be called main nor do you need the `main` function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们大多数的例子都是应用程序。应用程序由其`main`函数和包定义。但是在Go中，您也可以创建纯库。在库中，包的名称不需要被称为main，也不需要`main`函数。
- en: As libraries aren't applications, you cannot build a binary file with them and
    you need the `main` package that is going to use them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 由于库不是应用程序，因此无法使用它们构建二进制文件，您需要使用将使用它们的`main`包。
- en: 'For example, let''s create an arithmetic library to perform common operations
    on integers: sums, subtractions, multiplications, and divisions. We''ll not get
    into many details about the implementation to focus on the particularities of
    Go''s libraries:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个算术库，对整数执行常见操作：求和、减法、乘法和除法。我们不会深入讨论实现的细节，而是专注于Go库的特殊之处：
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'First, we need a name for our library; we set this name by giving a name to
    the entire package. This means that every file in this folder must have this package
    name too and the entire group of files composes the library called **arithmetic**
    too in this case (because it only contains one package). This way, we won''t need
    to refer to the filenames for this library and to provide the library name and
    path will be enough to import and use it. We have defined a `Sum` function that
    takes as many arguments as you need and that will return an integer that, during
    the scope of the function, is going to be called `res`. This allows us to initialize
    to `0` the value we''re returning. We defined a package (not the `main` package
    but a library one) and called it `arithmetic`. As this is a library package, we
    can''t run it from the command line directly so we''ll have to create the `main`
    function for it or a unit test file. For simplicity , we''ll create a `main` function
    that runs some of the operations now but let''s finish the library first:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的库命名；我们通过为整个包命名来设置这个名称。这意味着此文件夹中的每个文件也必须具有此包名称，所有文件组成的整个库在这种情况下也被称为**arithmetic**（因为它只包含一个包）。这样，我们就不需要引用此库的文件名，只需提供库名称和路径即可导入和使用它。我们定义了一个`Sum`函数，它接受您需要的任意数量的参数，并返回一个整数，在函数的范围内，它将被称为`res`。这使我们能够将我们返回的值初始化为`0`。我们定义了一个包（不是`main`包，而是一个库包），并将其命名为`arithmetic`。由于这是一个库包，我们无法直接从命令行运行它，因此我们必须为其创建`main`函数或单元测试文件。为了简单起见，我们将创建一个`main`函数，现在运行一些操作，但让我们先完成库：
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Subtraction` code will return `0` if the number of arguments is less than
    zero and the subtraction of all its arguments if it has two arguments or more:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subtraction`代码将在参数数量少于零时返回`0`，如果有两个或更多参数，则返回所有参数的减法：'
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `Multiply` function works in a similar fashion. It returns `0` when arguments
    are less than two and the multiplication of all its arguments when it has two
    or more. Finally, the `Division` code changes a bit because it will return an
    error if you ask it to divided by zero:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Multiply`函数的工作方式类似。当参数少于两个时，它返回`0`，当参数为两个或更多时，它返回所有参数的乘积。最后，`Division`代码有些变化，因为如果要求它除以零，它将返回一个错误：'
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So now we have our library finished, but we need a `main` function to use it
    as libraries cannot be converted to executable files directly. Our main function
    looks like the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的库已经完成，但我们需要一个`main`函数来使用它，因为库不能直接转换为可执行文件。我们的主函数如下所示：
- en: '[PRE69]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We are performing an operation over every function that we have defined. Take
    a closer look at the `import` clause. It is taking the library we have written
    from its folder within `$GOPATH` that matches its URL in [https://bitbucket.org/](https://bitbucket.org/)
    . Then, to use every one of the functions that are defined within a library, you
    have to name the package name that the library has before each method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在对我们定义的每个函数执行操作。仔细看一下`import`子句。它从与[https://bitbucket.org/](https://bitbucket.org/)中的URL匹配的`$GOPATH`中的文件夹中获取我们编写的库。然后，要使用库中定义的每个函数，您必须在每个方法之前命名库的包名称。
- en: Note
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have you realized that we called our functions with uppercase names? Because
    of the visibility rules we have seen before, exported functions in a package must
    have uppercase names or they won't be visible outside of the scope of the package.
    So, with this rule in mind, you cannot call a lowercase function or variable within
    a package and package calls will always be followed by uppercase names.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否意识到我们使用大写名称来调用我们的函数？根据我们之前看到的可见性规则，包中的导出函数必须具有大写名称，否则它们将在包的范围之外不可见。因此，根据此规则，您无法在包中调用小写函数或变量，并且包调用将始终后跟大写名称。
- en: 'Let''s recall, some naming conventions about libraries:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下关于库的一些命名约定：
- en: Each file in the same folder must contain the same package name. Files don't
    need to be named in any special way.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一文件夹中的每个文件必须包含相同的包名称。文件不需要以任何特殊方式命名。
- en: A folder represents a package name within a library. The folder name will be
    used on import paths and it doesn't need to reflect the package name (although
    it's recommended for the parent package).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹代表库中的包名称。文件夹名称将用于导入路径，不需要反映包名称（尽管建议为父包）。
- en: A library is one or many packages representing a tree that you import by the
    parent of all packages folder.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个库是一个或多个代表树的包，您通过所有包文件夹的父级导入。
- en: You call things within a library by their package name.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过包名称调用库中的内容。
- en: The Go get tool
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go get工具
- en: Go get is a tool to get third party projects from CVS repositories. Instead
    of using the `git clone` command, you can use Go get to receive a series of added
    benefits. Let's write an example using CoreOS's **ETCD **project which is a famous
    distributed key-value store.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Go get是一个从CVS存储库获取第三方项目的工具。您可以使用Go get而不是使用`git clone`命令来获得一系列的附加好处。让我们以CoreOS的ETCD项目为例，这是一个著名的分布式键值存储。
- en: 'CoreOS''s ETCD is hosted on GitHub at  [https://github.com/coreos/etcd.git](https://github.com/coreos/etcd.git).
    To download this project source code using the Go get tool, we must type in the
    Terminal it''s resulting import path that it will have in our GOPATH:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS的ETCD托管在GitHub上，网址为[https://github.com/coreos/etcd.git](https://github.com/coreos/etcd.git)。要使用Go
    get工具下载此项目的源代码，我们必须在终端中输入它在GOPATH中将具有的导入路径：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that we have just typed the most relevant information so that Go get figures
    out the rest. You'll get some output, depending on the state of the project, but
    after, while, it will disappear. But what did happen?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是输入了最相关的信息，以便Go get找出其余部分。您将获得一些输出，取决于项目的状态，但之后，它将消失。但发生了什么？
- en: Go get has created a folder in `$GOPATH/src/github.com/coreos`.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go get已在`$GOPATH/src/github.com/coreos`中创建了一个文件夹。
- en: It has cloned the project in that location, so now the source code of ETCD is
    available at `$GOPATH/src/github.com/coreos/etcd`.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它已在该位置克隆了项目，因此现在ETCD的源代码可在`$GOPATH/src/github.com/coreos/etcd`中使用。
- en: Go get has cloned any repository that ETCD could need.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go get已克隆了ETCD可能需要的任何存储库。
- en: It has tried to install the project if it is not a library. This means, it has
    generated a binary file of ETCD and has put it in `$GOPATH/bin` folder.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它不是库，它会尝试安装项目。这意味着它已生成了ETCD的二进制文件，并将其放在`$GOPATH/bin`文件夹中。
- en: 'By simply typing the `go get [project]` command, you''ll get all that material
    from a project in your system. Then in your Go apps, you can just use any library
    by importing the path within the source. So for the ETCD project, it will be:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 只需键入`go get [project]`命令，您就可以从系统中获取项目的所有材料。然后在您的Go应用程序中，您可以通过导入源路径来使用任何库。因此，对于ETCD项目，它将是：
- en: '[PRE71]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It's very important that you get familiar with the use of the Go get tool and
    stop using `git clone` when you want a project from a Git repository. This will
    save you some headaches when trying to import a project that isn't contained within
    your GOPATH.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，您要熟悉使用Go get工具，并在想要从Git存储库获取项目时停止使用`git clone`。这将在尝试导入不包含在GOPATH中的项目时为您节省一些麻烦。
- en: Managing JSON data
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理JSON数据
- en: 'JSON is the acronym for **JavaScript Object Notation** and, like the name implies,
    it''s natively JavaScript. It has become very popular and it''s the most used
    format for communication today. Go has very good support for JSON serialization/deserialization
    with the `JSON` package that does most of the dirty work for you. First of all,
    there are two concepts to learn when working with JSON:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是**JavaScript对象表示**的首字母缩写，正如名称所暗示的那样，它是JavaScript的本地格式。它已变得非常流行，并且是今天通信中使用最多的格式。Go对JSON序列化/反序列化有很好的支持，`JSON`包为您完成了大部分繁重的工作。首先，在处理JSON时有两个概念需要学习：
- en: '**Marshal**: When you marshal an instance of a structure or object, you are
    converting it to its JSON counterpart.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marshal**：当您对结构或对象的实例进行编组时，您正在将其转换为其JSON对应项。'
- en: '**Unmarshal**: When you are unmarshaling some data, in the form of an array
    of bytes, you are trying to convert some JSON-expected-data to a known struct
    or object. You can also *unmarshal* to a `map[string]interface{}` in a fast but
    not very safe way to interpret the data as we''ll see now.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unmarshal**：当您对某些数据进行解组时，以字节数组的形式，您正在尝试将一些预期为JSON的数据转换为已知的结构或对象。您还可以以一种快速但不太安全的方式将其*解组*为`map[string]interface{}`，以解释数据，我们将在下面看到。'
- en: 'Let''s see an example of marshaling a string:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个编组字符串的示例：
- en: '[PRE72]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: First, we have defined a variable called `packt` to hold the contents of the
    `packt` string. Then, we have used the `json` library to use the `Marshal` command
    with our new variable. This will return a new `bytearray` with the JSON and a
    flag to provide and `boolOK` result for the operation. When we print the contents
    of the bytes array (previous casting to string) the expected value appears. Note
    that `packt` appeared actually between quotes as the JSON representation would
    be.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`packt`的变量来保存`packt`字符串的内容。然后，我们使用`json`库使用我们的新变量执行`Marshal`命令。这将返回一个带有JSON和提供`boolOK`操作结果的新`bytearray`。当我们打印字节数组的内容（先转换为字符串），预期值将出现。请注意，`packt`实际上出现在引号之间，就像JSON表示一样。
- en: The encoding package
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码包
- en: Have you realized that we have imported the package `encoding/json`? Why is
    it prefixed with the word `encoding`? If you take a look at Go's source code to
    the `src/encoding` folder you'll find many interesting packages for encoding/decoding
    such as, XML, HEX, binary, or even CSV.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否意识到我们已导入了`encoding/json`包？为什么它以`encoding`为前缀？如果您查看Go的源代码到`src/encoding`文件夹，您将找到许多有趣的编码/解码包，例如XML、HEX、二进制，甚至CSV。
- en: 'Now something a bit more complicated:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有点复杂的东西：
- en: '[PRE73]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Conveniently, it also works pretty well with structures but what if I want
    to not use uppercase in the JSON data? You can define the output/input name of
    the JSON in the structure declaration:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，它也与结构非常配合得很好，但是如果我不想在JSON数据中使用大写字母怎么办？您可以在结构声明中定义JSON的输出/输入名称：
- en: '[PRE74]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We have not only lowercased the names of the keys, but we have even changed
    the name of the `Word` key to string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将键的名称改为小写，甚至还将`Word`键的名称更改为字符串。
- en: 'Enough of marshalling, we will receive JSON data as an array of bytes, but
    the process is very similar with some changes:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的编组，我们将接收JSON数据作为字节数组，但是过程非常相似，有一些变化：
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The big difference here is that you have to allocate the space for the structure
    first (with a zero value) and the pass the reference to the method `Unmarshal`
    so that it tries to fill it. When you use `Unmarshal`, the first parameter is
    the array of bytes that contains the JSON information while the second parameter
    is the reference (that''s why we are using an ampersand) to the structure we want
    to fill. Finally, let''s use a generic `map[string]interface{}` method to hold
    the content of a JSON:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重大区别在于您首先必须为结构分配空间（具有零值），然后将引用传递给`Unmarshal`方法，以便它尝试填充它。当您使用`Unmarshal`时，第一个参数是包含JSON信息的字节数组，而第二个参数是我们要填充的结构的引用（这就是为什么我们使用了`&`）。最后，让我们使用通用的`map[string]interface{}`方法来保存JSON的内容：
- en: '[PRE76]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: What happened in the result? This is why we described the object as dangerous.
    You can point to a `nil` location when using this mode if you call a non-existing
    key in the JSON. Not only this, like in the example, it could also interpret a
    value as a `float64` when it is simply a `byte`, wasting a lot of memory.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发生了什么？这就是为什么我们描述这个对象是危险的。如果在使用这种模式时调用JSON中不存在的键，你可能会指向一个`nil`位置。不仅如此，就像在例子中一样，它也可能将一个值解释为`float64`，而实际上是一个`byte`，浪费了大量内存。
- en: So remember to just use `map[string]interface{}` when you need dirty quick access
    to JSON data that is fairly simple and you have under control the type of scenarios
    described previously.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所以记住，当你需要快速访问相当简单的JSON数据并且你控制了之前描述的类型场景时，只需使用`map[string]interface{}`。
- en: Go tools
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go工具
- en: Go comes with a series of useful tools to ease the development process every
    day. Also in the golang page of GitHub, there are some tools that are supported
    by the Go team but they are not part of the compiler.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Go带有一系列有用的工具，以便每天都能简化开发过程。此外，在GitHub的golang页面上，有一些工具得到了Go团队的支持，但它们并不是编译器的一部分。
- en: Most of the projects use tools such as `gofmt` so that all the code base looks
    similar. Godoc helps us to find useful information in Go's documentation and the `goimport`
    command to auto-import the packages we are using. Let's see them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都使用诸如`gofmt`之类的工具，以便整个代码库看起来相似。Godoc帮助我们在Go的文档中找到有用的信息，而`goimport`命令则自动导入我们正在使用的包。让我们来看看它们。
- en: The golint tool
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: golint工具
- en: 'A linter analyzes source code to detect errors or improvements. The `golint`
    linter is available on [https://github.com/golang/lint](https://github.com/golang/lint) for
    installation (it doesn''t come bundled with the compiler). It is very easy to
    use and is integrated some IDEs to be run when you save a source code file (Atom
    or Sublime Text, for example). Do you remember the implicit/explicit code that
    we run when talking about variables? Let''s lint it:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一个linter分析源代码以检测错误或改进。`golint` linter可以在[https://github.com/golang/lint](https://github.com/golang/lint)上安装（它不随编译器捆绑）。它非常容易使用，并且集成在一些IDE中，可以在保存源代码文件时运行（例如Atom或Sublime
    Text）。你还记得我们在谈论变量时运行的隐式/显式代码吗？让我们来lint它：
- en: '[PRE77]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `main.go:10:21:` command should omit the type string from the declaration
    of the `explicitString` variable; it will be inferred from the right-hand side.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go:10:21:`命令应该省略`explicitString`变量的声明中的字符串类型；它将从右侧推断出来。'
- en: It is telling us that Go compiler will actually infer this type of a variable
    from the code and you don't need to declare its type. What about the `Train` type
    on the interface section?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们，Go编译器实际上会从代码中推断出这种类型的变量，你不需要声明它的类型。接口部分的`Train`类型呢？
- en: '[PRE78]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `main.go:5:6:` type exported `Train` type should have a comment or remain
    not exported.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的`Train`类型应该有一个注释或者保持不导出。
- en: In this case, it's pointing us that a public type such as `Train` type must
    be commented so that users can read the generated documentation to know its behavior.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它告诉我们，像`Train`这样的公共类型必须被注释，以便用户可以阅读生成的文档了解其行为。
- en: The gofmt tool
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gofmt工具
- en: 'The `gofmt` tool comes bundled with the compiler that already has access to
    it. Its purpose is to provide a set of indentation, formatting, spacing and few
    other rules to achieve good-looking Go code. For example, let''s take the code
    of Hello World and make it a bit weirder by inserting spaces everywhere:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`gofmt`工具已经随编译器捆绑在一起。它的目的是提供一组缩进、格式化、间距和其他规则，以实现漂亮的Go代码。例如，让我们拿Hello World的代码，并在每个地方插入空格，使它看起来有点奇怪：'
- en: '[PRE79]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `gofmt` command prints it correctly again. What is more, we can use the
    `-w` flag to overwrite the original file:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`gofmt`命令再次正确打印出来。而且，我们可以使用`-w`标志来覆盖原始文件：'
- en: '[PRE80]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: And now we'll have our file properly corrected.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的文件将被正确纠正。
- en: The godoc tool
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: godoc工具
- en: 'Go documentation is pretty extended and verbose. You can find detailed information
    about any topic you want to achieve. The `godoc` tool also helps you access this
    documentation directly from the command line. For example, we can query the package
    `encoding/json`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Go文档非常广泛和冗长。你可以找到关于任何你想要实现的主题的详细信息。`godoc`工具还可以帮助你直接从命令行访问这些文档。例如，我们可以查询`encoding/json`包：
- en: '[PRE81]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can also use **grep**, a bash utility for Linux and Mac, to find specific
    information about some functionality. For example, we''ll use grep to look for
    text that mentions anything about parsing JSON files:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用**grep**，这是Linux和Mac的一个bash实用程序，来查找有关某些功能的特定信息。例如，我们将使用grep来查找提到解析JSON文件的文本：
- en: '[PRE82]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `Unmarshal` command parses the JSON encoded data and stores the result in
    the object being parsed.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unmarshal`命令解析JSON编码的数据，并将结果存储在被解析的对象中。'
- en: One of the things that the `golint` command warns about is to use the beginning
    of a comment with the same name of the function it describes. This way, if you
    don't remember the name of the function that parses JSON, you can use `godoc`
    with `grep` and search for `parse` so the beginning of the line will always be
    the function name like in the example preceding the `Unmarshal` command.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`golint`命令警告的一件事是使用与描述函数相同的名称开头的注释。这样，如果你忘记了解析JSON的函数名称，你可以使用`godoc`和`grep`搜索`parse`，这样行的开头将始终是函数名称，就像在`Unmarshal`命令之前的例子中一样。'
- en: The goimport tool
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: goimport工具
- en: The `goimport` tool is a must have in Go. Sometimes you remember your packages
    so well that you don't need to search much to remember their API but it's more
    difficult to remember the project they belong to when doing the import. The `goimport`
    command helps you by searching your `$GOPATH` for occurrences of a package that
    you could be using to provide you with the project `import` line automatically.
    This is very useful if you configure your IDE to run `goimport` on save so that
    all used packages in the source file are imported automatically if you used them.
    It also works the other way around--if you delete the function you were using
    from a package and the package isn't being used anymore, it will remove the `import`
    line.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`goimport`工具在Go中是必不可少的。有时您对自己的包如此了解，以至于不需要搜索太多就能记住它们的API，但在导入时更难记住它们所属的项目。`goimport`命令通过搜索您的`$GOPATH`中的包出现来为您提供项目`import`行，这对您非常有帮助。如果您配置您的IDE在保存时运行`goimport`，那么源文件中使用的所有包都将自动导入。它也可以反过来运行-如果您从包中删除了您正在使用的函数，并且不再使用该包，它将删除`import`行。'
- en: Contributing to Go open source projects in GitHub
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GitHub上为Go开源项目做贡献
- en: One important thing to mention about Go packaging system is that it needs to
    have a proper folder structure within the GOPATH. This introduces a small problem
    when working with GitHub projects. We are used to forking a project, cloning our
    fork and start working before committing the pull-request to the original project.
    Wrong!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Go打包系统的一个重要事项是，它需要在GOPATH中有适当的文件夹结构。这在与GitHub项目一起工作时会引入一个小问题。我们习惯于fork一个项目，克隆我们的fork并开始工作，然后再提交拉取请求到原始项目。错了！
- en: 'When you fork a project, you create a new repository on GitHub within your
    username. If you clone this repository and start working with it, all new import
    references in the project will point to your repository instead of the original!
    Imagine the following case in the original repository:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当您fork一个项目时，您在GitHub上的用户名下创建了一个新的存储库。如果您克隆此存储库并开始使用它，项目中的所有新的导入引用将指向您的存储库，而不是原始存储库！想象一下原始存储库中的以下情况：
- en: '[PRE83]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, you make a fork and add a subfolder with a library called `a_library/my_library`
    that you want to use from the main package. The result is going to be the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以fork并添加一个名为`a_library/my_library`的库的子文件夹，您希望从主包中使用。结果将如下所示：
- en: '[PRE84]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now if you commit this line, the original repository that contains the code
    you have pushed will download this code anyways from your account again and it
    will use the references downloaded! Not the ones contained in the project!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您提交了这行代码，包含您推送的代码的原始存储库将再次从您的帐户下载此代码，并使用下载的引用！而不是项目中包含的引用！
- en: 'So, the solution to this is simply to replace the `git clone` command with
    a `go get` pointing to the original library:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决此问题的方法很简单，就是用指向原始库的`go get`命令替换`git clone`命令：
- en: '[PRE85]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With this modification, you can work normally in the original code without fear
    as the references will stay correct. Once you are done you just have to commit
    and push to your remote.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种修改，您可以在原始代码中正常工作，而不必担心引用会出错。完成后，您只需提交并推送到您的远程存储库。
- en: '[PRE86]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This way, you can now access the GitHub web user interface and open the pull
    request without polluting the actual original code with references to your account.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您现在可以访问GitHub的Web用户界面，并在不污染实际原始代码的情况下打开拉取请求。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After this first chapter, you must be familiar with the syntax of Go and some
    of the command-line tools that come bundled with the compiler. We have left apart
    concurrency capabilities for a later chapter as they are large and pretty complex
    to grasp at the beginning so that the reader learns the syntax of the language
    first, becomes familiar and confident with it, and then they can jump to understanding **Communicating
    Sequential Processes** (**CSP**) concurrency patterns and distributed applications.
    The next steps are to start with the creational design patterns.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第一章之后，您必须熟悉Go的语法和一些与编译器捆绑在一起的命令行工具。我们将并发能力留到后面的章节，因为它们在一开始就很庞大和复杂，所以读者首先要学习语言的语法，熟悉并对其有信心，然后才能开始理解**通信顺序进程**（**CSP**）并发模式和分布式应用程序。接下来的步骤是从创建设计模式开始。
