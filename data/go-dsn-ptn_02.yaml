- en: Chapter 2. Creational Patterns - Singleton, Builder, Factory, Prototype, and
    Abstract Factory Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。创建模式-单例、生成器、工厂、原型和抽象工厂设计模式
- en: We have defined two types of cars-luxury and family. The car Factory will have
    to return The first groups of design patterns that we are going to cover are the
    Creational patterns. As the name implies, it groups common practices for creating
    objects, so object creation is more encapsulated from the users that need those
    objects. Mainly, creational patterns try to give ready-to-use objects to users
    instead of asking for their creation, which, in some cases, could be complex,
    or which would couple your code with the concrete implementations of the functionality
    that should be defined in an interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两种类型的汽车-豪华和家庭。汽车工厂将返回我们将要涵盖的第一组设计模式是创建模式。顾名思义，它将常见的创建对象的实践分组在一起，因此对象的创建更多地封装在需要这些对象的用户之外。主要是，创建模式试图为用户提供可直接使用的对象，而不是要求它们的创建，这在某些情况下可能是复杂的，或者会将您的代码与应该在接口中定义的功能的具体实现耦合在一起。
- en: Singleton design pattern - having a unique instance of a type in the entire
    program
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例设计模式-在整个程序中具有唯一实例的类型
- en: Have you ever done interviews for software engineers? It's interesting that
    when you ask them about design patterns, more than 80% will mention **Singleton**
    design pattern. Why is that? Maybe it's because it is one of the most used design
    patterns out there or one of the easiest to grasp. We will start our journey on
    creational design patterns because of the latter reason.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有为软件工程师做过面试？有趣的是，当你问他们关于设计模式时，超过80%的人会提到**Singleton**设计模式。为什么呢？也许是因为它是最常用的设计模式之一，或者是最容易理解的设计模式之一。由于后一种原因，我们将从创建型设计模式开始我们的旅程。
- en: Description
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Singleton pattern is easy to remember. As the name implies, it will provide
    you with a single instance of an object, and guarantee that there are no duplicates.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式很容易记住。顾名思义，它将为您提供对象的单一实例，并保证没有重复。
- en: At the first call to use the instance, it is created and then reused between
    all the parts in the application that need to use that particular behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次调用实例时，它被创建，然后在应用程序中需要使用特定行为的所有部分之间重复使用。
- en: 'You''ll use the Singleton pattern in many different situations. For example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在许多不同的情况下使用单例模式。例如：
- en: When you want to use the same connection to a database to make every query
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您想要使用相同的数据库连接来进行每次查询时
- en: When you open a **Secure Shell** (**SSH**) connection to a server to do a few
    tasks, and don't want to reopen the connection for each task
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您打开**安全外壳**（**SSH**）连接到服务器以执行一些任务，并且不想为每个任务重新打开连接时
- en: If you need to limit the access to some variable or space, you use a Singleton
    as the door to this variable (we'll see in the following chapters that this is
    more achievable in Go using channels anyway)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要限制对某个变量或空间的访问，可以使用Singleton作为访问该变量的门（在接下来的章节中，我们将看到在Go中使用通道更容易实现这一点）
- en: If you need to limit the number of calls to some places, you create a Singleton
    instance to make the calls in the accepted window
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要限制对某些地方的调用次数，可以创建一个Singleton实例来在接受的窗口中进行调用
- en: The possibilities are endless, and we have just mentioned some of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性是无穷无尽的，我们只是提到了其中一些。
- en: Objectives
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'As a general guide, we consider using the Singleton pattern when the following
    rule applies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般指南，我们考虑在以下规则适用时使用Singleton模式：
- en: We need a single, shared value, of some particular type.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个特定类型的单一共享值。
- en: We need to restrict object creation of some type to a single unit along the
    entire program.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将某种类型的对象创建限制为整个程序中的单个单元。
- en: Example - a unique counter
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例-唯一计数器
- en: As an example of an object of which we must ensure that there is only one instance,
    we will write a counter that holds the number of times it has been called during
    program execution. It shouldn't matter how many instances we have of the counter,
    all of them must *count* the same value and it must be consistent between the
    instances.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们必须确保只有一个实例的对象的示例，我们将编写一个计数器，它保存程序执行期间调用的次数。无论我们有多少计数器实例，它们都必须*计数*相同的值，并且在实例之间必须保持一致。
- en: Requirements and acceptance criteria
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'There are some requirements and acceptance criteria to write the described
    single counter. They are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编写所述的单一计数器有一些要求和验收标准。它们如下：
- en: When no counter has been created before, a new one is created with the value
    0
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当之前没有创建计数器时，将创建一个新的计数器，其值为0
- en: If a counter has already been created, return this instance that holds the actual
    count
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计数器已经被创建，返回持有实际计数的实例
- en: If we call the method `AddOne`, the count must be incremented by 1
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们调用方法`AddOne`，计数必须增加1
- en: We have a scenario with three tests to check in our unit tests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个测试场景要在我们的单元测试中检查。
- en: Writing unit tests first
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先编写单元测试
- en: Go's implementation of this pattern is slightly different from what you'll find
    in pure object-oriented languages such as Java or C++, where you have static members.
    In Go, there's nothing like static members, but we have package scope to deliver
    a similar result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Go对这种模式的实现与您在Java或C++等纯面向对象语言中找到的实现略有不同，那里有静态成员。在Go中，没有静态成员，但我们有包范围来提供类似的结果。
- en: To set up our project, we must create a new folder within our `$GOPATH/src`
    directory. The general rule as we mentioned in the [Chapter 1](ch01.html "Chapter 1. Ready...
    Steady... Go!"), *Ready... Steady... Go!*, is to create a subfolder with the VCS
    provider (such as GitHub), the username, and the name of the project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的项目，我们必须在我们的`$GOPATH/src`目录中创建一个新文件夹。正如我们在[第1章](ch01.html "第1章。准备...开始...Go！")中提到的一般规则，*准备...开始...Go！*，是创建一个带有VCS提供者（如GitHub）、用户名和项目名称的子文件夹。
- en: 'For example, in my case, I use GitHub as my VCS and my username is *sayden,*
    so I will create the path `$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton`.
    The `go-design-patterns` instance in the path is the project name, the creational
    subfolder will also be our library name, and singleton the name of this particular
    package and subfolder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的情况下，我使用GitHub作为我的VCS，我的用户名是*sayden*，所以我将创建路径`$GOPATH/src/github.com/sayden/go-design-patterns/creational/singleton`。路径中的`go-design-patterns`是项目名称，creational子文件夹也将是我们的库名称，singleton是此特定包和子文件夹的名称：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new file inside the singleton folder called `singleton.go` to also
    reflect the name of the package and write the following package declarations for
    the `singleton` type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在singleton文件夹内创建一个名为`singleton.go`的新文件，以反映包的名称，并编写以下`singleton`类型的包声明：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we are following a TDD approach while writing the code, let''s code the
    tests that use the functions we have just declared. The tests are going to be
    defined by following the acceptance criteria that we have written earlier. By
    convention in test files, we must create a file with the same name as the file
    to test, suffixed with `_test.go`. Both must reside in the same folder:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在编写代码时遵循TDD方法，让我们编写使用我们刚刚声明的函数的测试。测试将根据我们之前编写的验收标准来定义。按照测试文件的惯例，我们必须创建一个与要测试的文件同名的文件，后缀为`_test.go`。两者必须驻留在同一个文件夹中：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first test checks something obvious, but no less important, in complex
    applications. We actually receive something when we ask for an instance of the
    counter. We have to think of it as a Creational pattern--we delegate the creation
    of the object to an unknown package that could fail in the creation or retrieval
    of the object. We also store the current counter in the `expectedCounter` variable
    to make a comparison later:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试检查了复杂应用程序中显而易见但同样重要的事情。当我们请求计数器的实例时，我们实际上收到了一些东西。我们必须将其视为一个创建模式——我们将对象的创建委托给一个可能在对象的创建或检索中失败的未知包。我们还将当前计数器存储在`expectedCounter`变量中，以便稍后进行比较：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we take advantage of the zero-initialization feature of Go. Remember that
    integer types in Go cannot be nil and as we know, that this is the first call
    to the counter, and it is an integer type of variable, and we also know that it
    is zero-initialized. So after the first call to the `AddOne()` function, the value
    of the count must be 1.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们利用Go的零初始化特性。请记住，Go中的整数类型不能为nil，而且我们知道这是对计数器的第一次调用，它是一个整数类型的变量，我们也知道它是零初始化的。因此，在对`AddOne()`函数的第一次调用之后，计数的值必须为1。
- en: 'The test that checks the second condition proves that the `expectedConnection`
    variable is not different to the returned connection that we requested later.
    If they were different, the message `Singleton instances must be different` will
    cause the test to fail:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 检查第二个条件的测试证明了`expectedConnection`变量与我们稍后请求的返回连接没有不同。如果它们不同，消息`Singleton instances
    must be different`将导致测试失败：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last test is simply counting 1 again with the second instance. The previous
    result was 1, so now it must give us 2:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试只是再次计数1，使用第二个实例。之前的结果是1，所以现在必须给我们2：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The last thing we have to do to finish our test part is to execute the tests
    to make sure that they are failing before implementation. If one of them doesn''t
    fail, it implies that we have done something wrong, and we have to reconsider
    that particular test. We must open the terminal and navigate to the path of the
    singleton package to execute:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完成测试部分的最后一件事是执行测试，以确保它们在实施之前失败。如果其中一个没有失败，那就意味着我们做错了什么，我们必须重新考虑那个特定的测试。我们必须打开终端并导航到singleton包的路径以执行：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implementation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Finally, we have to implement the Singleton pattern. As we mentioned earlier,
    we''ll usually write a `static` method and instance to retrieve the Singleton
    instance in languages such as Java or C++. In Go, we don''t have the keyword `static`,
    but we can achieve the same result by using the scope of the package. First, we
    create a `struct` that contains the object which we want to guarantee to be a
    Singleton during the execution of the program:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须实现单例模式。正如我们之前提到的，通常会在诸如Java或C++之类的语言中编写一个`static`方法和实例来检索单例实例。在Go中，我们没有关键字`static`，但我们可以通过使用包的作用域来实现相同的结果。首先，我们创建一个包含我们希望在程序执行期间保证为单例的对象的`struct`：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We must pay close attention to this piece of code. In languages such as Java
    or C++, the variable instance would be initialized to NULL at the beginning of
    the program. In Go, you can initialize a pointer to a struct as `nil`, but you
    cannot initialize a structure to `nil` (the equivalent of NULL). So the `var instance
    *singleton` line defines a pointer to a struct of type Singleton as nil, and the
    variable called `instance`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须密切关注这段代码。在诸如Java或C++之类的语言中，变量实例将在程序开始时初始化为NULL。在Go中，您可以将指向结构的指针初始化为`nil`，但不能将结构初始化为`nil`（相当于NULL）。因此，`var
    instance *singleton`行将指针定义为nil的Singleton类型结构，并命名为`instance`。
- en: We created a `GetInstance` method that checks if the instance has not been initialized
    already (`instance == nil`), and creates an instance in the space already allocated
    in the line `instance = new(singleton)`. Remember, when we use the keyword `new`,
    we are creating a pointer to an instance of the type between the parentheses.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`GetInstance`方法，检查实例是否已经初始化（`instance == nil`），并在`instance = new(singleton)`行中创建一个实例。记住，当我们使用关键字`new`时，我们正在创建指向括号内类型的实例的指针。
- en: The `AddOne` method will take the count of the variable instance, raise it by
    1, and return the current value of the counter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOne`方法将获取变量实例的计数，将其增加1，并返回计数器的当前值。'
- en: 'Let''s run now our unit tests again:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在再次运行我们的单元测试：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A few words about the Singleton design pattern
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于单例设计模式的一些话
- en: We have seen a very simple example of the Singleton pattern, partially applied
    to some situation, that is, a simple counter. Just keep in mind that the Singleton
    pattern will give you the power to have a unique instance of some struct in your
    application and that no package can create any clone of this struct.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了单例模式的一个非常简单的例子，部分应用于某些情况，即一个简单的计数器。只需记住，单例模式将使您能够在应用程序中拥有某个结构的唯一实例，并且没有任何包可以创建此结构的任何克隆。
- en: With Singleton, you are also hiding the complexity of creating the object, in
    case it requires some computation, and the pitfall of creating it every time you
    need an instance of it if all of them are similar. All this code writing, checking
    if the variable already exists, and storage, are encapsulated in the singleton
    and you won't need to repeat it everywhere if you use a global variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例，您还隐藏了创建对象的复杂性，以防它需要一些计算，并且如果它们都是相似的话，每次需要一个实例时都要创建它的陷阱。所有这些代码编写、检查变量是否已经存在和存储都封装在单例中，如果使用全局变量，则无需在每个地方重复。
- en: Here we are learning the classic singleton implementation for single threaded
    context. We will see a concurrent singleton implementation when we reach the chapters
    about concurrency because this implementation is not thread safe!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在学习单线程上的经典单例实现。当我们到达有关并发的章节时，我们将看到并发单例实现，因为这种实现不是线程安全的！
- en: Builder design pattern - reusing an algorithm to create many implementations
    of an interface
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者设计模式 - 重用算法来创建接口的多个实现
- en: Talking about **Creational** design patterns, it looks pretty semantic to have
    a **Builder** design pattern. The Builder pattern helps us construct complex objects
    without directly instantiating their struct, or writing the logic they require.
    Imagine an object that could have dozens of fields that are more complex structs
    themselves. Now imagine that you have many objects with these characteristics,
    and you could have more. We don't want to write the logic to create all these
    objects in the package that just needs to use the objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到**创建型**设计模式，拥有**建造者**设计模式似乎非常合理。建造者模式帮助我们构建复杂的对象，而不是直接实例化它们的结构，或编写它们所需的逻辑。想象一个对象可能有数十个字段，这些字段本身是更复杂的结构。现在想象一下，您有许多具有这些特征的对象，而且您可能还有更多。我们不想在只需要使用这些对象的包中编写创建所有这些对象的逻辑。
- en: Description
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: Instance creation can be as simple as providing the opening and closing braces
    `{}` and leaving the instance with zero values, or as complex as an object that
    needs to make some API calls, check states, and create objects for its fields.
    You could also have an object that is composed of many objects, something that's
    really idiomatic in Go, as it doesn't support inheritance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实例创建可以简单到提供开放和关闭大括号`{}`并将实例留有零值，也可以复杂到需要进行一些API调用、检查状态并为其字段创建对象的对象。您还可以拥有由许多对象组成的对象，这在Go中非常惯用，因为它不支持继承。
- en: At the same time, you could be using the same technique to create many types
    of objects. For example, you'll use almost the same technique to build a car as
    you would build a bus, except that they'll be of different sizes and number of
    seats, so why don't we reuse the construction process? This is where the Builder
    pattern comes to the rescue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，您可以使用相同的技术来创建许多类型的对象。例如，您将使用几乎相同的技术来构建汽车和构建公共汽车，只是它们的大小和座位数不同，那么为什么不重用构建过程呢？这就是建造者模式发挥作用的地方。
- en: Objectives
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'A Builder design pattern tries to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式尝试：
- en: Abstract complex creations so that object creation is separated from the object
    user
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象复杂的创建，使对象创建与对象用户分离
- en: Create an object step by step by filling its fields and creating the embedded
    objects
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过填充其字段和创建嵌入对象逐步创建对象
- en: Reuse the object creation algorithm between many objects
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多对象之间重用对象创建算法
- en: Example - vehicle manufacturing
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 车辆制造
- en: The Builder design pattern has been commonly described as the relationship between
    a director, a few Builders, and the product they build. Continuing with our example
    of the car, we'll create a vehicle Builder. The process (widely described as the
    algorithm) of creating a vehicle (the product) is more or less the same for every
    kind of vehicle--choose vehicle type, assemble the structure, place the wheels,
    and place the seats. If you think about it, you could build a car and a motorbike
    (two Builders) with this description, so we are reusing the description to create
    cars in manufacturing. The director is represented by the `ManufacturingDirector`
    type in our example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式通常被描述为导演、几个建造者和他们构建的产品之间的关系。继续我们的汽车示例，我们将创建一个车辆建造者。创建车辆（产品）的过程（通常描述为算法）对于每种类型的车辆来说基本相同
    - 选择车辆类型、组装结构、放置轮子和放置座位。如果您仔细想想，您可以使用此描述构建汽车和摩托车（两个建造者），因此我们正在重用描述来在制造中创建汽车。在我们的示例中，导演由`ManufacturingDirector`类型表示。
- en: Requirements and acceptance criteria
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'As far as we have described, we must dispose of a Builder of type `Car` and
    `Motorbike` and a unique director called `ManufacturingDirector` to take builders
    and construct products. So the requirements for a `Vehicle` builder example would
    be the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们所描述的而言，我们必须处理`Car`和`Motorbike`类型的建造者以及一个名为`ManufacturingDirector`的唯一导演，以接受建造者并构建产品。因此，`Vehicle`建造者示例的要求如下：
- en: I must have a manufacturing type that constructs everything that a vehicle needs
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我必须有一个制造类型，可以构造车辆所需的一切
- en: When using a car builder, the `VehicleProduct` with four wheels, five seats,
    and a structure defined as `Car` must be returned
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用汽车建造者时，必须返回具有四个轮子、五个座位和结构定义为`Car`的`VehicleProduct`
- en: When using a motorbike builder, the `VehicleProduct` with two wheels, two seats,
    and a structure defined as `Motorbike` must be returned
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用摩托车建造者时，必须返回具有两个轮子、两个座位和结构定义为`Motorbike`的`VehicleProduct`
- en: A `VehicleProduct` built by any `BuildProcess` builder must be open to modifications
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由任何`BuildProcess`建造者构建的`VehicleProduct`必须可以进行修改
- en: Unit test for the vehicle builder
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 车辆建造者的单元测试
- en: 'With the previous acceptance criteria, we will create a director variable,
    the `ManufacturingDirector` type, to use the build processes represented by the
    product builder variables for a car and motorbike. The director is the one in
    charge of construction of the objects, but the builders are the ones that return
    the actual vehicle. So our builder declaration will look as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据先前的验收标准，我们将创建一个主管变量，即`ManufacturingDirector`类型，以使用产品建造者变量表示的汽车和摩托车的构建过程。主管负责构建对象，但建造者返回实际的车辆。因此，我们的建造者声明将如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This preceding interface defines the steps that are necessary to build a vehicle.
    Every builder must implement this `interface` if they are to be used by the manufacturing.
    On every `Set` step, we return the same build process, so we can chain various
    steps together in the same statement, as we''ll see later. Finally, we''ll need
    a `GetVehicle` method to retrieve the `Vehicle` instance from the builder:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述接口定义了构建车辆所需的步骤。如果要被制造使用，每个建造者都必须实现这个`interface`。在每个`Set`步骤上，我们返回相同的构建过程，因此我们可以在同一语句中链接各种步骤，正如我们将在后面看到的。最后，我们需要一个`GetVehicle`方法来从建造者中检索`Vehicle`实例：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ManufacturingDirector` director variable is the one in charge of accepting
    the builders. It has a `Construct` method that will use the builder that is stored
    in `Manufacturing`, and will reproduce the required steps. The `SetBuilder` method
    will allow us to change the builder that is being used in the `Manufacturing`
    director:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManufacturingDirector`主管变量负责接受建造者。它有一个`Construct`方法，将使用存储在`Manufacturing`中的建造者，并复制所需的步骤。`SetBuilder`方法将允许我们更改在`Manufacturing`主管中使用的建造者：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The product is the final object that we want to retrieve while using the manufacturing.
    In this case, a vehicle is composed of wheels, seats, and a structure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 产品是我们在使用制造时要检索的最终对象。在这种情况下，车辆由车轮、座位和结构组成：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first Builder is the `Car` builder. It must implement every method defined
    in the `BuildProcess` interface. This is where we''ll set the information for
    this particular builder:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个建造者是`Car`建造者。它必须实现`BuildProcess`接口中定义的每个方法。这是我们为这个特定建造者设置信息的地方：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Motorbike` structure must be the same as the `Car` structure, as they
    are all Builder implementations, but keep in mind that the process of building
    each can be very different. With this declaration of objects, we can create the
    following tests:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Motorbike`结构必须与`Car`结构相同，因为它们都是建造者实现，但请记住，构建每个的过程可能会有很大的不同。有了这些对象的声明，我们可以创建以下测试：'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will start with the `Manufacturing` director and the `Car` Builder to fulfill
    the first two acceptance criteria. In the preceding code, we are creating our
    `Manufacturing` director that will be in charge of the creation of every vehicle
    during the test. After creating the `Manufacturing` director, we created a `CarBuilder`
    that we then passed to manufacturing by using the `SetBuilder` method. Once the
    `Manufacturing` director knows what it has to construct now, we can call the `Construct`
    method to create the `VehicleProduct` using `CarBuilder`. Finally, once we have
    all the pieces for our car, we call the `GetVehicle` method on `CarBuilder` to
    retrieve a `Car` instance:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Manufacturing`主管和`Car`建造者开始，以满足前两个验收标准。在上述代码中，我们正在创建我们的`Manufacturing`主管，它将负责在测试期间创建每辆车辆。创建`Manufacturing`主管后，我们创建了一个`CarBuilder`，然后通过使用`SetBuilder`方法将其传递给制造。一旦`Manufacturing`主管知道现在它必须构建什么，我们就可以调用`Construct`方法来使用`CarBuilder`创建`VehicleProduct`。最后，一旦我们为我们的汽车准备好所有零件，我们就调用`CarBuilder`上的`GetVehicle`方法来检索`Car`实例：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have written three small tests to check if the outcome is a car. We checked
    that the car has four wheels, the structure has the description `Car`, and the
    number of seats is five. We have enough data to execute the tests and make sure
    that they are failing so that we can consider them reliable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了三个小测试来检查结果是否为汽车。我们检查汽车是否有四个车轮，结构是否具有描述`Car`，座位数为五。我们有足够的数据来执行测试，并确保它们失败，以便我们可以认为它们是可靠的：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Perfect! Now we will create tests for a `Motorbike` builder that covers the
    third and fourth acceptance criteria:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们将为`Motorbike`建造者创建测试，以满足第三和第四个验收标准：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code is a continuation of the car tests. As you can see, we reuse
    the previously created manufacturing to create the bike now by passing the `Motorbike` builder
    to it. Then we hit the `construct` button again to create the necessary parts,
    and call the builder `GetVehicle` method to retrieve the motorbike instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是对汽车测试的延续。正如您所看到的，我们重用了先前创建的制造来通过将`Motorbike`建造者传递给它来创建摩托车。然后我们再次点击`construct`按钮来创建必要的零件，并调用建造者的`GetVehicle`方法来检索摩托车实例。
- en: Take a quick look, because we have changed the default number of seats for this
    particular motorbike to 1\. What we want to show here is that even while having
    a builder, you must also be able to change the default information in the returned
    instance to fit some specific needs. As we set the wheels manually, we won't test
    this feature.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览一下，因为我们已经将这辆摩托车的默认座位数更改为1。我们想要展示的是，即使有了建造者，您也必须能够更改返回实例中的默认信息，以满足某些特定需求。由于我们手动设置了车轮，我们不会测试这个功能。
- en: 'Re-running the tests triggers the expected behavior:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试会触发预期的行为：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We will start implementing the manufacturing. As we said earlier (and as we
    set in our unit tests), the `Manufacturing` director must accept a builder and
    construct a vehicle using the provided builder. To recall, the `BuildProcess`
    interface will define the common steps needed to construct any vehicle and the
    `Manufacturing` director must accept builders and construct vehicles together
    with them:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始实施制造。正如我们之前所说（并且在我们的单元测试中设置），“制造”总监必须接受一个建造者并使用提供的建造者构建车辆。回想一下，“BuildProcess”接口将定义构建任何车辆所需的常见步骤，“制造”总监必须接受建造者并与他们一起构建车辆：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our `ManufacturingDirector` needs a field to store the builder in use; this
    field will be called `builder`. The `SetBuilder` method will replace the stored
    builder with the one provided in the arguments. Finally, take a closer look at
    the `Construct` method. It takes the builder that has been stored and reproduces
    the `BuildProcess` method that will create a full vehicle of some unknown type.
    As you can see, we have used all the setting calls in the same line thanks to
    returning the `BuildProcess` interface on each of the calls. This way the code
    is more compact:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“制造总监”需要一个字段来存储正在使用的建造者；这个字段将被称为“建造者”。 “SetBuilder”方法将用参数中提供的建造者替换存储的建造者。最后，仔细看一下“构造”方法。它接受已存储的建造者并重现将创建某种未知类型的完整车辆的“BuildProcess”方法。正如您所看到的，我们已经在同一行中使用了所有设置调用，这要归功于在每个调用上返回“BuildProcess”接口。这样代码更加紧凑：
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Have you realized that the director entity in the Builder pattern is a clear
    candidate for a Singleton pattern too? In some scenarios, it could be critical
    that just an instance of the Director is available, and that is where you'll create
    a Singleton pattern for the Director of the Builder only. Design patterns composition
    is a very common technique and a very powerful one!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否意识到建造者模式中的总监实体也是单例模式的明显候选者？在某些情况下，只有总监的一个实例可用可能非常关键，这就是您将为建造者的总监创建单例模式的地方。设计模式组合是一种非常常见且非常强大的技术！
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here is our first builder, the `car` builder. A builder will need to store a
    `VehicleProduct` object, which here we have named `v`. Then we set the specific
    needs that a car has in our business--four wheels, five seats, and a structure
    defined as `Car`. In the `GetVehicle` method, we just return the `VehicleProduct`
    stored within the Builder that must be already constructed by the `ManufacturingDirector` type.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个建造者，“汽车”建造者。一个建造者将需要存储一个名为“v”的“VehicleProduct”对象。然后我们设置了我们业务中汽车的特定需求-四个轮子，五个座位和一个名为“汽车”的结构。在“GetVehicle”方法中，我们只返回建造者内部存储的“VehicleProduct”，这个产品必须已经由“制造总监”类型构建。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Motorbike` Builder is the same as the `car` builder. We defined a motorbike
    to have two wheels, two seats, and a structure called `Motorbike`. It's very similar
    to the `car` object, but imagine that you want to differentiate between a sports
    motorbike (with only one seat) and a cruise motorbike (with two seats). You could
    simply create a new structure for sports motorbikes that implements the build
    process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “摩托车”建造者与“汽车”建造者相同。我们定义了摩托车有两个轮子，两个座位和一个名为“摩托车”的结构。它与“汽车”对象非常相似，但想象一下，您想要区分运动摩托车（只有一个座位）和巡航摩托车（有两个座位）。您可以简单地为运动摩托车创建一个实现构建过程的新结构。
- en: You can see that it's a repetitive pattern, but within the scope of every method
    of the `BuildProcess` interface, you could encapsulate as much complexity as you
    want such that the user need not know the details about the object creation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这是一个重复的模式，但在“BuildProcess”接口的每个方法的范围内，您可以封装尽可能多的复杂性，以便用户不需要了解有关对象创建的详细信息。
- en: 'With the definition of all the objects, let''s run the tests again:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有对象的定义，让我们再次运行测试：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Well done! Think how easy it could be to add new vehicles to the `ManufacturingDirector`
    director just create a new class encapsulating the data for the new vehicle. For
    example, let´s add a `BusBuilder` struct:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！想象一下向“制造总监”添加新车辆有多么容易，只需创建一个封装新车辆数据的新类。例如，让我们添加一个“BusBuilder”结构：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That's all; your `ManufacturingDirector` would be ready to use the new product
    by following the Builder design pattern.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；通过遵循建造者设计模式，您的“制造总监”将准备好使用新产品。
- en: Wrapping up the Builder design pattern
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装建造者设计模式
- en: The Builder design pattern helps us maintain an unpredictable number of products
    by using a common construction algorithm that is used by the director. The construction
    process is always abstracted from the user of the product.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式通过使用总监使用的通用构建算法来帮助我们维护不可预测数量的产品。构建过程始终从产品的用户中抽象出来。
- en: At the same time, having a defined construction pattern helps when a newcomer
    to our source code needs to add a new product to the *pipeline*. The `BuildProcess`
    interface specifies what he must comply to be part of the possible builders.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，当我们的源代码新手需要向*管道*添加新产品时，拥有定义的构建模式会有所帮助。“BuildProcess”接口指定了他必须遵守以成为可能的建造者的一部分。
- en: However, try to avoid the Builder pattern when you are not completely sure that
    the algorithm is going to be more or less stable because any small change in this
    interface will affect all your builders and it could be awkward if you add a new
    method that some of your builders need and others Builders do not.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当您不完全确定算法是否会更加稳定时，请尽量避免使用建造者模式，因为此接口的任何小更改都将影响到所有建造者，如果您添加一种新方法，有些建造者需要它，而其他建造者则不需要，这可能会很尴尬。
- en: Factory method - delegating the creation of different types of payments
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法-委托创建不同类型的付款
- en: The Factory method pattern (or simply, Factory) is probably the second-best
    known and used design pattern in the industry. Its purpose is to abstract the
    user from the knowledge of the struct he needs to achieve for a specific purpose,
    such as retrieving some value, maybe from a web service or a database. The user
    only needs an interface that provides him this value. By delegating this decision
    to a Factory, this Factory can provide an interface that fits the user needs.
    It also eases the process of downgrading or upgrading of the implementation of
    the underlying type if needed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式（或简称工厂）可能是行业中第二为人熟知和使用的设计模式。它的目的是将用户与他需要为特定目的实现的结构体的知识抽象出来，比如从网络服务或数据库中检索一些值。用户只需要一个提供这个值的接口。通过将这个决定委托给工厂，这个工厂可以提供适合用户需求的接口。如果需要，它还可以简化底层类型的实现的降级或升级过程。
- en: Description
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: When using the Factory method design pattern, we gain an extra layer of encapsulation
    so that our program can grow in a controlled environment. With the Factory method,
    we delegate the creation of families of objects to a different package or object
    to abstract us from the knowledge of the pool of possible objects we could use.
    Imagine that you want to organize your holidays using a trip agency. You don't
    deal with hotels and traveling and you just tell the agency the destination you
    are interested in so that they provide you with everything you need. The trip
    agency represents a Factory of trips.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂方法设计模式时，我们获得了一个额外的封装层，以便我们的程序可以在受控环境中增长。通过工厂方法，我们将对象族的创建委托给不同的包或对象，以使我们抽象出我们可以使用的可能对象池的知识。想象一下，您想要使用旅行社组织您的假期。您不需要处理酒店和旅行，只需告诉旅行社您感兴趣的目的地，他们将为您提供一切所需。旅行社代表了旅行的工厂。
- en: Objectives
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'After the previous description, the following objectives of the Factory Method
    design pattern must be clear to you:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的描述之后，工厂方法设计模式的以下目标必须对您清晰：
- en: Delegating the creation of new instances of structures to a different part of
    the program
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新实例的结构的创建委托给程序的不同部分
- en: Working at the interface level instead of with concrete implementations
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口级别工作，而不是使用具体的实现
- en: Grouping families of objects to obtain a family object creator
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象族分组以获得一个对象族创建者
- en: The example - a factory of payment methods for a shop
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例-商店的支付方法工厂
- en: For our example, we are going to implement a payments method Factory, which
    is going to provide us with different ways of paying at a shop. In the beginning,
    we will have two methods of paying--cash and credit card. We'll also have an interface
    with the method, `Pay`, which every struct that wants to be used as a payment
    method must implement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，我们将实现一个支付方法工厂，它将为我们提供在商店支付的不同方式。一开始，我们将有两种支付方式--现金和信用卡。我们还将有一个带有`Pay`方法的接口，每个想要用作支付方法的结构体都必须实现。
- en: Acceptance criteria
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'Using the previous description, the requirements for the acceptance criteria
    are the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述描述，验收标准的要求如下：
- en: To have a common method for every payment method called `Pay`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个称为`Pay`的每种支付方法的通用方法
- en: To be able to delegate the creation of payments methods to the Factory
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够将支付方法的创建委托给工厂
- en: To be able to add more payment methods to the library by just adding it to the
    factory method
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过将其添加到工厂方法来将更多的支付方法添加到库中
- en: First unit test
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个单元测试
- en: 'A Factory method has a very simple structure; we just need to identify how
    many implementations of our interface we are storing, and then provide a method,
    `GetPaymentMethod`, where you can pass a type of payment as an argument:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法有一个非常简单的结构；我们只需要确定我们存储了多少个接口的实现，然后提供一个`GetPaymentMethod`方法，您可以将支付类型作为参数传递：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding lines define the interface of the payment method. They define a
    way of making a payment at the shop. The Factory method will return instances
    of types that implement this interface:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行定义了支付方法的接口。它们定义了在商店支付的方式。工厂方法将返回实现此接口的类型的实例：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have to define the identified payment methods of the Factory as constants
    so that we can call and check the possible payment methods from outside of the
    package.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将工厂的已识别支付方法定义为常量，以便我们可以从包外部调用和检查可能的支付方法。
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code is the function that will create the objects for us. It returns
    a pointer, which must have an object that implements the `PaymentMethod` interface,
    and an error if asked for a method which is not registered.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是将为我们创建对象的函数。它返回一个指针，必须有一个实现`PaymentMethod`接口的对象，并且如果要求一个未注册的方法，则返回一个错误。
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To finish the declaration of the Factory, we create the two payment methods.
    As you can see, the `CashPM` and `DebitCardPM` structs implement the `PaymentMethod`
    interface by declaring a method, `Pay(amount float32) string`. The returned string
    will contain information about the payment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成工厂的声明，我们创建了两种支付方法。正如您所看到的，`CashPM`和`DebitCardPM`结构体通过声明一个`Pay(amount float32)
    string`方法来实现`PaymentMethod`接口。返回的字符串将包含有关支付的信息。
- en: 'With this declaration, we will start by writing the tests for the first acceptance
    criteria: to have a common method to retrieve objects that implement the `PaymentMethod`
    interface:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个声明，我们将从编写第一个验收标准的测试开始：拥有一个通用方法来检索实现`PaymentMethod`接口的对象：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we'll have to separate the tests among a few of the test functions. `GetPaymentMethod`
    is a common method to retrieve methods of payment. We use the constant `Cash`,
    which we have defined in the implementation file (if we were using this constant
    outside for the scope of the package, we would call it using the name of the package
    as the prefix, so the syntax would be `creational.Cash`). We also check that we
    have not received an error when asking for a payment method. Observe that if we
    receive the error when asking for a payment method, we call `t.Fatal` to stop
    the execution of the tests; if we called just `t.Error` like in the previous tests,
    we would have a problem in the next lines when trying to access the `Pay` method
    of a nil object, and our tests would crash execution. We continue by using the
    `Pay` method of the interface by passing 10.30 as the amount. The returned message
    will have to contain the text `paid using cash`. The `t.Log(string)` method is
    a special method in testing. This struct allows us to write some logs when we
    run the tests if we pass the `-v` flag.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把测试分成几个测试函数。`GetPaymentMethod`是一个常用的检索支付方式的方法。我们使用常量`Cash`，我们已经在实现文件中定义了它（如果我们在包的范围之外使用这个常量，我们将使用包的名称作为前缀来调用它，所以语法将是`creational.Cash`）。我们还检查在请求支付方式时是否没有收到错误。请注意，如果我们在请求支付方式时收到错误，我们将调用`t.Fatal`来停止测试的执行；如果我们像之前的测试一样只调用`t.Error`，那么当我们尝试访问nil对象的`Pay`方法时，我们将在下一行中遇到问题，我们的测试将崩溃执行。我们继续通过将10.30作为金额传递给接口的`Pay`方法来使用接口。返回的消息将包含文本`paid
    using cash`。`t.Log(string)`方法是测试中的一个特殊方法。这个结构允许我们在运行测试时写一些日志，如果我们传递了`-v`标志。
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We repeat the same operation with the debit card method. We ask for the payment
    method defined with the constant `DebitCard,` and the returned message, when paying
    with debit card, must contain the `paid using debit card` string.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用相同的方法重复相同的操作。我们请求使用常量`DebitCard`定义的支付方式，当使用借记卡支付时，返回的消息必须包含`paid using debit
    card`字符串。
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we are going to test the situation when we request a payment method
    that doesn´t exist (represented by the number 20, which doesn't match any recognized
    constant in the Factory). We will check if an error message (any) is returned
    when asking for an unknown payment method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将测试请求一个不存在的支付方式的情况（用数字20表示，它与工厂中的任何已识别的常量都不匹配）。当请求未知的支付方式时，我们将检查是否返回了错误消息（任何错误消息）。
- en: 'Let''s check whether all tests are failing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下所有的测试是否都失败了：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in this example, we can only see tests that return the `PaymentMethod`
    interfaces failing. In this case, we'll have to implement just a part of the code,
    and then test again before continuing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个例子中所看到的，我们只能看到返回“PaymentMethod”接口的测试失败。在这种情况下，我们将不得不实现代码的一部分，然后再次进行测试，然后才能继续。
- en: Implementation
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: We will start with the `GetPaymentMethod` method. It must receive an integer
    that matches with one of the defined constants of the same file to know which
    implementation it should return.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`GetPaymentMethod`方法开始。它必须接收一个与同一文件中定义的常量匹配的整数，以知道应该返回哪种实现。
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We use a plain switch to check the contents of the argument `m` (method). If
    it matches any of the known methods--cash or debit card, it returns a new instance
    of them. Otherwise, it will return a nil and an error indicating that the payment
    method has not been recognized. Now we can run our tests again to check the second
    part of the unit tests:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个普通的switch来检查参数`m`（方法）的内容。如果它匹配任何已知的方法--现金或借记卡，它将返回它们的新实例。否则，它将返回一个nil和一个指示支付方式未被识别的错误。现在我们可以再次运行我们的测试，以检查单元测试的第二部分：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we do not get the errors saying it couldn''t find the type of payment methods.
    Instead, we receive a `message not correct` error when it tries to use any of
    the methods that it covers. We also got rid of the `Not implemented` message that
    was being returned when we asked for an unknown payment method. Let''s implement
    the structs now:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不会再收到找不到支付方式类型的错误，而是在尝试使用它所涵盖的任何方法时，会收到“消息不正确”的错误。当我们请求一个未知的支付方式时，我们也摆脱了“未实现”的消息。现在让我们实现结构体：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We just get the amount, printing it in a nicely formatted message. With this
    implementation, the tests will all be passing now:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是得到金额，以一个格式良好的消息打印出来。有了这个实现，现在所有的测试都会通过：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Do you see the `LOG`: messages? They aren''t errors, we just print some information
    that we receive when using the package under test. These messages can be omitted
    unless you pass the `-v` flag to the test command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了`LOG`：消息吗？它们不是错误，我们只是打印一些在使用被测试的包时收到的信息。除非您将`-v`标志传递给测试命令，否则可以省略这些消息：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Upgrading the Debitcard method to a new platform
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将借记卡方法升级到新平台
- en: 'Now imagine that your `DebitCard` payment method has changed for some reason,
    and you need a new struct for it. To achieve this scenario, you will only need
    to create the new struct and replace the old one when the user asks for the `DebitCard`
    payment method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，由于某种原因，您的`DebitCard`支付方式已经更改，您需要一个新的结构。为了实现这种情况，您只需要创建新的结构，并在用户请求`DebitCard`支付方式时替换旧的结构。
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is our new type that will replace the `DebitCardPM` structure. The `CreditCardPM`
    implements the same `PaymentMethod` interface as the debit card. We haven''t deleted
    the previous one in case we need it in the future. The only difference lies in
    the returned message that now contains the information about the new type. We
    also have to modify the method to retrieve the payment methods:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将替换`DebitCardPM`结构的新类型。`CreditCardPM`实现了与借记卡相同的`PaymentMethod`接口。我们没有删除以后可能需要的旧结构。唯一的区别在于返回的消息现在包含了关于新类型的信息。我们还必须修改检索支付方式的方法：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The only modification is in the line where we create the new debit card that
    now points to the newly created struct. Let''s run the tests to see if everything
    is still correct:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的修改是在创建新的借记卡的那一行，现在指向新创建的结构。让我们运行测试，看看一切是否仍然正确：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Uh, oh! Something has gone wrong. The expected message when paying with a credit
    card does not match the returned message. Does it mean that our code isn''t correct?
    Generally speaking, yes, you shouldn''t modify your tests to make your program
    work. When defining tests, you should be also aware of not defining them too much
    because you could achieve some coupling in the tests that you didn''t have in
    your code. With the message restriction, we have a few grammatically correct possibilities
    for the message, so we''ll change it to the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，糟糕！出了些问题。使用信用卡支付时返回的预期消息与返回的消息不匹配。这是否意味着我们的代码不正确？一般来说，是的，你不应该修改你的测试来使你的程序工作。在定义测试时，你还应该注意不要定义得太多，因为这样你可能会在测试中实现一些你的代码中没有的耦合。由于消息限制，我们有一些语法上正确的消息可能性，所以我们将把它改为以下内容：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We run the tests again now:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次运行测试：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Everything is okay again. This was just a small example of how to write good
    unit tests, too. When we wanted to check that a debit card payment method returns
    a message that contains `paid using debit card` string, we were probably being
    a bit restrictive, and it would be better to check for those words separately
    or define a better formatting for the returned messages.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一切又恢复正常了。这只是一个写好单元测试的小例子。当我们想要检查使用借记卡支付方法返回的消息是否包含“使用借记卡支付”字符串时，我们可能有点过于严格，最好分别检查这些单词，或者定义一个更好的格式来返回消息。
- en: What we learned about the Factory method
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们从工厂方法中学到了什么
- en: With the Factory method pattern, we have learned how to group families of objects
    so that their implementation is outside of our scope. We have also learned what
    to do when we need to upgrade an implementation of a used structs. Finally, we
    have seen that tests must be written with care if you don't want to tie yourself
    to certain implementations that don't have anything to do with the tests directly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过工厂方法模式，我们已经学会了如何将对象家族分组，使其实现在我们的范围之外。我们还学会了在需要升级已使用结构的实现时该怎么做。最后，我们已经看到，如果你不想将自己与与测试无关的某些实现绑定在一起，那么测试必须小心编写。
- en: Abstract Factory - a factory of factories
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂 - 工厂的工厂
- en: After learning about the factory design pattern, where we grouped a family of
    related objects in our case payment methods, one can be quick to think--what if
    I group families of objects in a more structured hierarchy of families?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了工厂设计模式之后，我们将一个相关对象家族（在我们的例子中是支付方法）进行了分组，人们很快就会想到——如果我将对象家族分组到一个更有结构的家族层次结构中会怎样？
- en: Description
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Abstract Factory design pattern is a new layer of grouping to achieve a
    bigger (and more complex) composite object, which is used through its interfaces.
    The idea behind grouping objects in families and grouping families is to have
    big factories that can be interchangeable and can grow more easily. In the early
    stages of development, it is also easier to work with factories and abstract factories
    than to wait until all concrete implementations are done to start your code. Also,
    you won't write an Abstract Factory from the beginning unless you know that your
    object's inventory for a particular field is going to be very large and it could
    be easily grouped into families.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式是一种新的分组层，用于实现一个更大（和更复杂）的复合对象，通过它的接口来使用。将对象分组到家族中并将家族分组的想法是拥有可以互换并且更容易扩展的大工厂。在开发的早期阶段，使用工厂和抽象工厂比等到所有具体实现都完成后再开始编写代码要更容易。此外，除非你知道你的特定领域的对象库将非常庞大并且可以轻松地分组到家族中，否则你不会从一开始就编写抽象工厂。
- en: The objectives
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'Grouping related families of objects is very convenient when your object number
    is growing so much that creating a unique point to get them all seems the only
    way to gain the flexibility of the runtime object creation. The following objectives
    of the Abstract Factory method must be clear to you:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的对象数量增长到需要创建一个唯一的点来获取它们时，将相关的对象组合在一起是非常方便的，这样可以获得运行时对象创建的灵活性。抽象工厂方法的以下目标必须对你清晰明了：
- en: Provide a new layer of encapsulation for Factory methods that return a common
    interface for all factories
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为返回所有工厂的通用接口提供新的封装层
- en: Group common factories into a *super Factory* (also called a factory of factories)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将常见工厂组合成一个*超级工厂*（也称为工厂的工厂）
- en: The vehicle factory example, again?
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 车辆工厂的例子，又来了？
- en: For our example, we are going to reuse the Factory we created in the Builder
    design pattern. We want to show the similarities to solve the same problem using
    a different approach so that you can see the strengths and weaknesses of each
    approach. This is going to show you the power of implicit interfaces in Go, as
    we won't have to touch almost anything. Finally, we are going to create a new
    Factory to create shipment orders.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，我们将重用我们在生成器设计模式中创建的工厂。我们想展示使用不同方法解决相同问题的相似之处，以便你可以看到每种方法的优势和劣势。这将向你展示Go中隐式接口的强大之处，因为我们几乎不用改动任何东西。最后，我们将创建一个新的工厂来创建装运订单。
- en: Acceptance criteria
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'The following are the acceptance criteria for using the `Vehicle` object''s
    Factory method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用“车辆”对象工厂方法的验收标准：
- en: We must retrieve a `Vehicle` object using a factory returned by the abstract
    factory.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使用抽象工厂返回的工厂来检索“车辆”对象。
- en: The vehicle must be a concrete implementation of a `Motorbike` or a `Car` that
    implements both interfaces (`Vehicle` and `Car` or `Vehicle` and `Motorbike`).
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车辆必须是“摩托车”或“汽车”的具体实现，它实现了两个接口（“车辆”和“汽车”或“车辆”和“摩托车”）。
- en: Unit test
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'This is going to be a long example, so pay attention, please. We will have
    the following entities:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个很长的例子，所以请注意。我们将有以下实体：
- en: '**Vehicle**: The interface that all objects in our factories must implement:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**车辆**：我们工厂中的所有对象必须实现的接口：'
- en: '**Motorbike**: An interface for motorbikes of the types sport (one seat) and
    cruise (two seats).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩托车**：一种摩托车的接口，类型为运动（一座）和巡航（两座）。'
- en: '**Car**: An interface for cars of types luxury (with four doors) and family
    (with five doors).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汽车**：用于豪华车（四门）和家庭车（五门）的汽车接口。'
- en: '**VehicleFactory**: An interface (the Abstract Factory) to retrieve factories
    that implement the `VehicleFactory` method:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VehicleFactory**：一个接口（抽象工厂），用于检索实现`VehicleFactory`方法的工厂：'
- en: '**Motorbike** Factory: A factory that implements the `VehicleFactory` interface
    to return vehicle that implements the `Vehicle` and `Motorbike` interfaces.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩托车**工厂：一个实现`VehicleFactory`接口的工厂，返回实现`Vehicle`和`Motorbike`接口的车辆。'
- en: '**Car** Factory: Another factory that implements the `VehicleFactory` interface
    to return vehicles that implement the `Vehicle` and `Car` interfaces.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汽车**工厂：另一个实现`VehicleFactory`接口的工厂，返回实现`Vehicle`和`Car`接口的车辆。'
- en: 'For clarity, we are going to separate each entity into a different file. We
    will start with the `Vehicle` interface, which will be in the `vehicle.go` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们将每个实体分开放在不同的文件中。我们将从`Vehicle`接口开始，它将在`vehicle.go`文件中：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Car` and `Motorbike` interfaces will be in the `car.go` and `motorbike.go`
    files, respectively:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`和`Motorbike`接口将分别放在`car.go`和`motorbike.go`文件中：'
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We have one last interface, the one that each factory must implement. This
    will be in the `vehicle_factory.go` file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个最后的接口，每个工厂都必须实现这个接口。这将在`vehicle_factory.go`文件中：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, now we are going to declare the car factory. It must implement the `VehicleFactory`
    interface defined previously to return `Vehicles` instances:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们要声明汽车工厂。它必须实现之前定义的`VehicleFactory`接口，以返回`Vehicles`实例：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have defined two types of cars--luxury and family. The `car` Factory will
    have to return cars that implement the `Car` and the `Vehicle` interfaces, so
    we need two concrete implementations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两种类型的汽车--豪华车和家庭车。`car`工厂将返回实现`Car`和`Vehicle`接口的汽车，因此我们需要两种具体的实现：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s all for cars. Now we need the motorbike factory, which, like the car
    factory, must implement the `VehicleFactory` interface:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车完成了。现在我们需要摩托车工厂，它必须像汽车工厂一样实现`VehicleFactory`接口：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For the motorbike Factory, we have also defined two types of motorbikes using
    the `const` keywords: `SportMotorbikeType` and `CruiseMotorbikeType`. We will
    switch over the `v` argument in the `Build` method to know which type shall be
    returned. Let''s write the two concrete motorbikes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于摩托车工厂，我们还使用`const`关键字定义了两种摩托车类型：`SportMotorbikeType`和`CruiseMotorbikeType`。我们将在`Build`方法中切换`v`参数，以知道应返回哪种类型。让我们写两种具体的摩托车：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To finish, we need the abstract factory itself, which we will put in the previously
    created `vehicle_factory.go` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要抽象工厂本身，我们将把它放在之前创建的`vehicle_factory.go`文件中。
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are going to write enough tests to make a reliable check as the scope of
    the book doesn''t cover 100% of the statements. It will be a good exercise for
    the reader to finish these tests. First, a `motorbike` Factory test:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写足够的测试来进行可靠的检查，因为本书的范围并不涵盖100%的语句。这将是一个很好的练习，让读者完成这些测试。首先是`motorbike`工厂的测试：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We use the package method, `BuildFactory` , to retrieve a motorbike Factory
    (passing the `MotorbikeFactory` ID in the parameters), and check if we get any
    error. Then, already with the motorbike factory, we ask for a vehicle of the type
    `SportMotorbikeType` and check for errors again. With the returned vehicle, we
    can ask for methods of the vehicle interface (`NumWheels` and `NumSeats`). We
    know that it is a motorbike, but we cannot ask for the type of motorbike without
    using the type assertion. We use the type assertion on the vehicle to retrieve
    the motorbike that the `motorbikeVehicle` represents in the code line `sportBike,
    found := motorbikeVehicle.(Motorbike)`, and we must check that the type we have
    received is correct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用包方法`BuildFactory`来检索摩托车工厂（在参数中传递`MotorbikeFactory` ID），并检查是否有任何错误。然后，已经有了摩托车工厂，我们要求一个`SportMotorbikeType`类型的车辆，并再次检查错误。通过返回的车辆，我们可以询问车辆接口的方法（`NumWheels`和`NumSeats`）。我们知道它是一辆摩托车，但是我们不能在不使用类型断言的情况下询问摩托车的类型。我们使用类型断言在车辆上检索摩托车，代码行`sportBike,
    found := motorbikeVehicle.(Motorbike)`，我们必须检查我们收到的类型是否正确。
- en: 'Finally, now we have a motorbike instance, we can ask for the bike type by
    using the `GetMotorbikeType` method. Now we are going to write a test that checks
    the car factory in the same manner:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，现在我们有了摩托车实例，我们可以使用`GetMotorbikeType`方法询问摩托车类型。现在我们要编写一个检查汽车工厂的测试：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Again, we use the `BuildFactory` method to retrieve a `Car` Factory by using
    the `CarFactoryType` in the parameters. With this factory, we want a car of the `Luxury`
    type so that it returns a `vehicle` instance. We again do the type assertion to
    point to a car instance so that we can ask for the number of doors using the `NumDoors`
    method.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`BuildFactory`方法通过参数中的`CarFactoryType`来检索`Car`工厂。使用这个工厂，我们想要一个`Luxury`类型的汽车，以便返回一个`vehicle`实例。我们再次进行类型断言，指向汽车实例，以便我们可以使用`NumDoors`方法询问门的数量。
- en: 'Let''s run the unit tests:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行单元测试：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Done. It can't recognize any factory as their implementation is still not done.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。它无法识别任何工厂，因为它们的实现还没有完成。
- en: Implementation
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'The implementation of every factory is already done for the sake of brevity.
    They are very similar to the Factory method with the only difference being that
    in the Factory method, we don''t use an instance of the Factory method because
    we use the package functions directly. The implementation of the `vehicle` Factory
    is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，每个工厂的实施已经完成。它们与工厂方法非常相似，唯一的区别是在工厂方法中，我们不使用工厂方法的实例，因为我们直接使用包函数。`vehicle`工厂的实现如下：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Like in any factory, we switched between the factory possibilities to return
    the one that was demanded. As we have already implemented all concrete vehicles,
    the tests must run too:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在任何工厂中，我们在工厂可能性之间切换，以返回被要求的那个。由于我们已经实现了所有具体的车辆，测试也必须运行：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'All of them passed. Take a close look and note that we have used the `-cover`
    flag when running the tests to return a coverage percentage of the package: 45.8%.
    What this tells us is that 45.8% of the lines are covered by the tests we have
    written, but 54.2% are still not under the tests. This is because we haven''t
    covered the cruise motorbike and the family car with the tests. If you write those
    tests, the result should rise to around 70.8%.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过了。仔细观察并注意，我们在运行测试时使用了`-cover`标志，以返回包的覆盖率百分比：45.8%。这告诉我们的是，45.8%的代码行被我们编写的测试覆盖，但仍有54.2%没有被测试覆盖。这是因为我们没有用测试覆盖游轮摩托车和家庭汽车。如果你编写这些测试，结果应该会上升到大约70.8%。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Type assertion is also known as **casting** in other languages. When you have
    an interface instance, which is essentially a pointer to a struct, you just have
    access to the interface methods. With type assertion, you can tell the compiler
    the type of the pointed struct, so you can access the entire struct fields and
    methods.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言在其他语言中也被称为**转换**。当你有一个接口实例时，它本质上是一个指向结构体的指针，你只能访问接口方法。通过类型断言，你可以告诉编译器指向的结构体的类型，这样你就可以访问整个结构体的字段和方法。
- en: A few lines about the Abstract Factory method
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于抽象工厂方法的几行
- en: We have learned how to write a factory of factories that provides us with a
    very generic object of vehicle type. This pattern is commonly used in many applications
    and libraries, such as cross-platform GUI libraries. Think of a button, a generic
    object, and button factory that provides you with a factory for Microsoft Windows
    buttons while you have another factory for Mac OS X buttons. You don't want to
    deal with the implementation details of each platform, but you just want to implement
    the actions for some specific behavior raised by a button.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何编写一个工厂的工厂，它为我们提供了一个非常通用的车辆类型对象。这种模式通常用于许多应用程序和库，比如跨平台GUI库。想象一个按钮，一个通用对象，以及一个为Microsoft
    Windows按钮提供工厂的按钮工厂，同时你还有另一个为Mac OS X按钮提供工厂。你不想处理每个平台的实现细节，而只想为某些特定行为引发的行为实现操作。
- en: Also, we have seen the differences when approaching the same problem with two
    different solutions--the Abstract factory and the Builder pattern. As you have
    seen, with the Builder pattern, we had an unstructured list of objects (cars with
    motorbikes in the same factory). Also, we encouraged reusing the building algorithm
    in the Builder pattern. In the Abstract factory, we have a very structured list
    of vehicles (the factory for motorbikes and a factory for cars). We also didn't
    mix the creation of cars with motorbikes, providing more flexibility in the creation
    process. The Abstract factory and Builder patterns can both resolve the same problem,
    but your particular needs will help you find the slight differences that should
    lead you to take one solution or the other.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经看到了使用两种不同解决方案（抽象工厂和生成器模式）来解决同一个问题时的差异。如你所见，使用生成器模式时，我们有一个无结构的对象列表（在同一个工厂中有汽车和摩托车）。此外，我们鼓励在生成器模式中重用构建算法。在抽象工厂中，我们有一个非常结构化的车辆列表（摩托车工厂和汽车工厂）。我们也没有混合创建汽车和摩托车，提供了更多的灵活性在创建过程中。抽象工厂和生成器模式都可以解决同样的问题，但你的特定需求将帮助你找到应该采用哪种解决方案的细微差别。
- en: Prototype design pattern
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计模式
- en: The last pattern we will see in this chapter is the **Prototype** pattern. Like
    all creational patterns, this too comes in handy when creating objects, and it
    is very common to see the Prototype pattern surrounded by more patterns.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中看到的最后一个模式是**原型**模式。像所有创建模式一样，当创建对象时，这也非常方便，而且很常见的是原型模式被更多的模式所包围。
- en: While with the Builder pattern, we are dealing with repetitive building algorithms
    and with the factories we are simplifying the creation of many types of objects;
    with the Prototype pattern, we will use an already created instance of some type
    to clone it and complete it with the particular needs of each context. Let's see
    it in detail.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用生成器模式时，我们处理重复的构建算法；而在工厂模式中，我们简化了许多类型对象的创建；而在原型模式中，我们将使用某种类型的已创建实例进行克隆，并根据每个上下文的特定需求进行完善。让我们详细看一下。
- en: Description
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The aim of the Prototype pattern is to have an object or a set of objects that
    is already created at compilation time, but which you can clone as many times
    as you want at runtime. This is useful, for example, as a default template for
    a user who has just registered with your webpage or a default pricing plan in
    some service. The key difference between this and a Builder pattern is that objects
    are cloned for the user instead of building them at runtime. You can also build
    a cache-like solution, storing information using a prototype.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式的目的是在编译时已经创建了一个对象或一组对象，但你可以在运行时克隆它们任意多次。例如，作为刚刚在您的网页上注册的用户的默认模板，或者某项服务中的默认定价计划。与生成器模式的关键区别在于，对象是为用户克隆的，而不是在运行时构建它们。你还可以构建类似缓存的解决方案，使用原型存储信息。
- en: Objective
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The main objective for the Prototype design pattern is to avoid repetitive
    object creation. Imagine a default object composed of dozens of fields and embedded
    types. We don''t want to write everything needed by this type every time that
    we use the object, especially if we can mess it up by creating instances with
    different *foundations*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计模式的主要目标是避免重复的对象创建。想象一个由数十个字段和嵌入类型组成的默认对象。我们不想每次使用对象时都写这个类型所需的一切，尤其是如果我们可以通过创建具有不同*基础*的实例来搞砸它：
- en: Maintain a set of objects that will be cloned to create new instances
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护一组对象，这些对象将被克隆以创建新实例
- en: Provide a default value of some type to start working on top of it
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供某种类型的默认值以便开始在其上进行工作
- en: Free CPU of complex object initialization to take more memory resources
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放复杂对象初始化的CPU，以占用更多内存资源
- en: Example
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: We will build a small component of an imaginary customized shirts shop that
    will have a few shirts with their default colors and prices. Each shirt will also
    have a **Stock Keeping Unit (SKU)**, a system to identify items stored at a specific
    location) that will need an update.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个想象中的定制衬衫商店的小组件，其中将有一些默认颜色和价格的衬衫。每件衬衫还将有一个**库存保留单位（SKU）**，用于识别存储在特定位置的物品，需要进行更新。
- en: Acceptance criteria
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'To achieve what is described in the example, we will use a prototype of shirts.
    Each time we need a new shirt we will take this prototype, clone it and work with
    it. In particular, those are the acceptance criteria for using the Prototype pattern
    design method in this example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现示例中描述的内容，我们将使用衬衫的原型。每次我们需要一件新的衬衫，我们将取原型，克隆它并使用它。特别是，这些是在此示例中使用原型模式设计方法的验收标准：
- en: To have a shirt-cloner object and interface to ask for different types of shirts
    (white, black, and blue at 15.00, 16.00, and 17.00 dollars respectively)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了拥有一个衬衫克隆器对象和接口，以请求不同类型的衬衫（白色、黑色和蓝色分别为15.00、16.00和17.00美元）
- en: When you ask for a white shirt, a clone of the white shirt must be made, and
    the new instance must be different from the original one
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您要求一件白色衬衫时，必须制作白色衬衫的克隆，并且新实例必须与原始实例不同
- en: The SKU of the created object shouldn't affect new object creation
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建的对象的SKU不应影响新对象的创建
- en: An info method must give me all the information available on the instance fields,
    including the updated SKU
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个信息方法必须给我所有可用的实例字段信息，包括更新后的SKU
- en: Unit test
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'First, we will need a `ShirtCloner` interface and an object that implements
    it. Also, we need a package-level function called `GetShirtsCloner` to retrieve
    a new instance of the cloner:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`ShirtCloner`接口和一个实现它的对象。此外，我们需要一个名为`GetShirtsCloner`的包级函数来检索克隆器的新实例：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we need an object struct to clone, which implements an interface to retrieve
    the information of its fields. We will call the object `Shirt` and the `ItemInfoGetter`
    interface:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个对象结构来克隆，它实现了一个接口来检索其字段的信息。我们将称该对象为`Shirt`和`ItemInfoGetter`接口：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Have you realized that the type called `ShirtColor` that we defined is just
    a `byte` type? Maybe you are wondering why we haven't simply used the byte `type`.
    We could, but this way we created an easily readable struct, which we can upgrade
    with some methods in the future if required. For example, we could write a `String()`
    method that returns the color in the string format (`White` for type 1, `Black`
    for type 2, and `Blue` for type 3).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否意识到我们定义的名为`ShirtColor`的类型只是一个`byte`类型？也许您想知道为什么我们没有简单地使用`byte`类型。我们可以，但这样我们创建了一个易于阅读的结构，如果需要，我们可以在将来升级一些方法。例如，我们可以编写一个`String()`方法，返回字符串格式的颜色（类型1为`White`，类型2为`Black`，类型3为`Blue`）。
- en: 'With this code, we can already write our first tests:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们现在可以编写我们的第一个测试：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will cover the first case of our scenario, where we need a cloner object
    that we can use to ask for different shirt colors.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖我们场景的第一种情况，我们需要一个克隆器对象，可以用来请求不同颜色的衬衫。
- en: For the second case, we will take the original object (which we can access because
    we are in the scope of the package), and we will compare it with our `shirt1`
    instance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种情况，我们将获取原始对象（因为我们可以访问它，所以我们在包的范围内），并将其与我们的`shirt1`实例进行比较。
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, for the third case. First, we will type assert `item1` to a shirt so that
    we can set an SKU. We will create a second shirt, also white, and we will type
    assert it too to check that the SKUs are different:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于第三种情况。首先，我们将`item1`类型断言为衬衫，以便我们可以设置SKU。我们将创建第二件衬衫，也是白色，我们也将对其进行类型断言，以检查SKU是否不同：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, for the fourth case, we log the info of the first and second shirts:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于第四种情况，我们记录第一件和第二件衬衫的信息：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We will be printing the memory positions of both shirts, so we make this assertion
    at a more physical level:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打印两件衬衫的内存位置，因此我们在更物理层面上做出这种断言：
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we run the tests so we can check that it fails:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们运行测试，以便检查它是否失败：
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We have to stop there so that the tests don't panic if we try to use a nil object
    that is returned by the `GetShirtsCloner` function.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里停下来，以免测试在尝试使用`GetShirtsCloner`函数返回的空对象时出现恐慌。
- en: Implementation
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We will start with the `GetClone` method. This method should return an item
    of the specified type and we have three type: white, black and blue:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`GetClone`方法开始。这个方法应该返回指定类型的物品，我们有三种类型：白色、黑色和蓝色：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'So now that we have the three prototypes to work over we can implement `GetClone(s
    int)` method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了三个原型可以操作，我们可以实现`GetClone(s int)`方法：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `Shirt` structure also needs a `GetInfo` implementation to print the contents
    of the instances.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shirt`结构还需要一个`GetInfo`实现来打印实例的内容。'
- en: '[PRE65]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, let''s run the tests to see that everything is now working:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行测试，看看现在是否一切正常：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the log, (remember to set the `-v` flag when running the tests) you can check
    that `shirt1` and `shirt2` have different SKUs. Also, we can see the memory positions
    of both objects. Take into account that the positions shown on your computer will
    probably be different.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中（运行测试时记得设置`-v`标志），您可以检查`shirt1`和`shirt2`的SKU是否不同。此外，我们可以看到两个对象的内存位置。请注意，您的计算机上显示的位置可能会有所不同。
- en: What we learned about the Prototype design pattern
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于原型设计模式的学习
- en: The Prototype pattern is a powerful tool to build caches and default objects.
    You have probably realized too that some patterns can overlap a bit, but they
    have small differences that make them more appropriate in some cases and not so
    much in others.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式是构建缓存和默认对象的强大工具。您可能也意识到了一些模式可能有些重叠，但它们之间有一些细微差别，使它们在某些情况下更合适，在其他情况下则不太合适。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen the five main creational design patterns commonly used in the software
    industry. Their purpose is to abstract the user from the creation of objects for
    complexity or maintainability purposes. They have been the foundation of thousands
    of applications and libraries since the 1990s, and most of the software we use
    today has many of these creational patterns under the hood.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了软件行业中常用的五种主要的创建型设计模式。它们的目的是为了将用户从对象的创建中抽象出来，以应对复杂性或可维护性的需求。自上世纪90年代以来，它们已经成为成千上万个应用程序和库的基础，而今天我们使用的大多数软件在内部都有许多这些创建型模式。
- en: It's worth mentioning that these patterns are not thread-free. In a more advanced
    chapter, we will see concurrent programming in Go, and how to create some of the
    more critical design patterns using a concurrent approach.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，这些模式并不是无缝的。在更高级的章节中，我们将会看到如何在Go中进行并发编程，以及如何使用并发方法来创建一些更为关键的设计模式。
