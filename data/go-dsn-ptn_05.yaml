- en: Chapter 5. Behavioral Patterns - Strategy, Chain of Responsibility, and Command
    Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。行为模式-策略，责任链和命令设计模式
- en: The last group of common patterns we are going to see are the behavioral patterns.
    Now, we aren't going to define structures or encapsulate object creation but we
    are going to deal with behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的最后一组常见模式是行为模式。现在，我们不会定义结构或封装对象创建，而是要处理行为。
- en: What's to deal with in behavior patterns? Well, now we will encapsulate behaviors,
    for example, algorithms in the Strategy pattern or executions in the command pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式中有什么要处理的？嗯，现在我们将封装行为，例如策略模式中的算法或命令模式中的执行。
- en: Correct Behavior design is the last step after knowing how to deal with object
    creation and structures. Defining the behavior correctly is the last step of good
    software design because, all in all, good software design lets us improve algorithms
    and fix errors easily while the best algorithm implementation will not save us
    from bad software design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的行为设计是在了解如何处理对象创建和结构之后的最后一步。正确定义行为是良好软件设计的最后一步，因为总的来说，良好的软件设计让我们能够轻松改进算法并轻松修复错误，而最佳算法实现将无法拯救我们免受糟糕的软件设计。
- en: Strategy design pattern
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略设计模式
- en: The Strategy pattern is probably the easiest to understand of the Behavioral
    patterns. We have used it a few times while developing the previous patterns but
    without stopping to talk about it. Now we will.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式可能是行为模式中最容易理解的。在开发之前的模式时，我们已经使用了几次，但没有停下来谈论它。现在我们将。
- en: Description
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Strategy pattern uses different algorithms to achieve some specific functionality.
    These algorithms are hidden behind an interface and, of course, they must be interchangeable.
    All algorithms achieve the same functionality in a different way. For example,
    we could have a `Sort` interface and few sorting algorithms. The result is the
    same, some list is sorted, but we could have used quick sort, merge sort, and
    so on.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式使用不同的算法来实现特定功能。这些算法隐藏在接口后面，并且它们必须是可互换的。所有算法以不同的方式实现相同的功能。例如，我们可以有一个`Sort`接口和一些排序算法。结果是相同的，某个列表被排序，但我们可以使用快速排序，归并排序等。
- en: Can you guess when we used a Strategy pattern in the previous chapters? Three,
    two, one... Well, we heavily used the strategy pattern when we used the `io.Writer`
    interface. The `io.Writer` interface defines a strategy to write, and the functionality
    is always the same--to write something. We could write it to the standard out,
    to some file or to a user-defined type, but we do the same thing at the end--to
    write. We just change the strategy to write (in this case, we change the place
    where we write).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到我们在前几章中何时使用了策略模式吗？ 三，二，一...嗯，在我们使用`io.Writer`接口时，我们大量使用了策略模式。 `io.Writer`接口定义了写入的策略，功能始终相同-写入某些内容。我们可以将其写入标准输出，写入某个文件或写入用户定义的类型，但最终做的事情是相同的-写入。我们只是改变了写入的策略（在这种情况下，我们改变了写入的位置）。
- en: Objectives
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objectives of the Strategy pattern are really clear. The pattern should
    do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的目标非常明确。模式应该做到以下几点：
- en: Provide a few algorithms to achieve some specific functionality
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些算法来实现特定功能
- en: All types achieve the same functionality in a different way but the client of
    the strategy isn't affected
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有类型以不同的方式实现相同的功能，但策略的客户端不受影响
- en: The problem is that this definition covers a huge spectrum of possibilities.
    This is because Strategy pattern is actually used for a variety of scenarios and
    many software engineering solutions come with some kind of strategy within. Therefore
    it's better to see it in action with a real example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这个定义涵盖了广泛的可能性。这是因为策略模式实际上用于各种场景，并且许多软件工程解决方案都包含某种策略。因此最好通过一个真实的例子来看它的实际应用。
- en: Rendering images or text
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染图像或文本
- en: We are going to do something different for this example. Instead of printing
    text on the console only, we are also going to paint objects on a file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将做一些不同的事情。我们不仅要在控制台上打印文本，还要在文件上绘制对象。
- en: 'In this case, we will have two strategies: console and file. But the user of
    the library won''t have to deal with the complexity behind them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有两种策略：控制台和文件。但是库的用户不必处理它们背后的复杂性。
- en: 'The key feature is that the "caller" doesn´t know how the underlying library
    is working and he just knows the information available on the defined strategy.
    This is nicely seen on the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键特征是“调用者”不知道底层库是如何工作的，他只知道定义的策略上可用的信息。这在下图中很明显：
- en: '![Rendering images or text](img/B05557_05_01-300x136.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![渲染图像或文本](img/B05557_05_01-300x136.jpg)'
- en: In this diagram, we have chosen to print to console but we won´t deal with the
    **ConsoleStrategy** type directly, we´ll always use an interface that represents
    it. The **ConsoleStrategy** type will hide the implementation details of printing
    to console to caller in `main` function. **FileStrategy** hides its implementation details
    as well as any future strategy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们选择打印到控制台，但我们不会直接处理**ConsoleStrategy**类型，我们将始终使用代表它的接口。**ConsoleStrategy**类型将隐藏打印到控制台的实现细节给`main`函数中的调用者。**FileStrategy**也隐藏其实现细节以及任何未来的策略。
- en: Acceptance criteria
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'A strategy must have a very clear objective and we will have two ways to achieve
    it. Our objectives will be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 策略必须有一个非常明确的目标，我们将有两种实现它的方式。我们的目标将如下：
- en: Provide a way to show to the user an object (a square) in text or image
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种方法向用户显示文本或图像中的对象（正方形）
- en: The user must choose between image or text when launching the app
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在启动应用程序时必须选择图像或文本
- en: The app must be able to add more visualization strategies (audio, for example)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须能够添加更多的可视化策略（例如音频）
- en: If the user selects text, the word *Square* must be printed in the console
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择文本，则必须在控制台中打印单词* Square *
- en: If the user selects image, an image of a white square on a black background
    will be printed on a file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户选择图像，将在文件上打印一个白色正方形在黑色背景上的图像
- en: Implementation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We aren''t going to write tests for this example as it will be quite complicated
    to check that an image has appeared on the screen (although not impossible by
    using **OpenCV**, an impressive library for computer vision). We will start directly
    by defining our strategy interface that each printing strategy must implement
    (in our case, the file and console types):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算为这个例子编写测试，因为检查图像是否出现在屏幕上将会非常复杂（虽然使用**OpenCV**，一个令人印象深刻的计算机视觉库，这并非不可能）。我们将直接开始定义每个打印策略必须实现的策略接口（在我们的情况下，文件和控制台类型）：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That''s all. Our strategy defines a simple `Print()` method that returns an
    `error` (the error-returning type is mandatory when dealing with files, for example).
    The types that needs to implement `PrintStrategy` will be called `ConsoleSquare`
    and a `ImageSquare` type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。我们的策略定义了一个简单的`Print()`方法，返回一个`error`（在处理文件时，必须返回错误类型）。需要实现`PrintStrategy`的类型将被称为`ConsoleSquare`和`ImageSquare`类型：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `ConsoleSquare` struct doesn''t need any inner field because it will always
    print the word `Square` to the console. The `ImageSquare` struct will store a
    field for the destination of the image file where we will print the square. We
    will start with the implementation of the `ConsoleSquare` type as it is the simplest:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleSquare`结构不需要任何内部字段，因为它将始终将单词`Square`打印到控制台。`ImageSquare`结构将存储一个字段，用于打印正方形的图像文件的目的地。我们将从实现`ConsoleSquare`类型开始，因为它是最简单的：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Very easy, but the image is more complex. We won''t spend too much time in
    explaining in detail how the `image` package works because the code is easily
    understandable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，但图像更复杂。我们不会花太多时间详细解释`image`包的工作原理，因为代码很容易理解：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, here is a short explanation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个简短的解释：
- en: We define a size for the image (`width` and `height` variables) of 800 pixels
    of width and 600 pixels of height. Those are going to be the size limits of our
    image and anything that we write outside of that size won't be visible.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为图像定义了一个大小（`width`和`height`变量），宽度为800像素，高度为600像素。这些将是我们图像的大小限制，任何超出该大小的内容都将不可见。
- en: The `origin` variable stores an `image.Point`, a type to represent a position
    in any two-dimensional space. We set the position of this point at *(0, 0)*, the
    upper-left corner of the image.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`origin`变量存储一个`image.Point`，表示任何二维空间中的位置的类型。我们将此点的位置设置为*(0, 0)*，即图像的左上角。'
- en: We need a bitmap that will represent our background, here we called it `bgImage`.
    We have a very handy function in the image package to create the `image.RGBA`
    types called `image.NewRGBA`. We need to pass a rectangle to this function so
    that it knows the bounds of the image. A rectangle is represented by two `image.Point`
    types--its upper left corner point (the `Min` field) and its lower right corner
    point (the `Max` field). We use `origin` as the upper-left and a new point with
    the values of `width` and `height` as the lower-right point.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个位图来表示我们的背景，这里我们称之为`bgImage`。在图像包中有一个非常方便的函数，用于创建`image.RGBA`类型，称为`image.NewRGBA`。我们需要向此函数传递一个矩形，以便它知道图像的边界。矩形由两个`image.Point`类型表示--它的左上角点（`Min`字段）和它的右下角点（`Max`字段）。我们使用`origin`作为左上角，一个具有`width`和`height`值的新点作为右下角点。
- en: The image will have a gray background color (`bgColor`). This is done by instancing
    a type of `image.Uniform`, which represents a uniform color (hence the name).
    The `image.Uniform` type needs an instance of a `color.Color` interface. A `color.Color`
    type is any type that implements the `RGBA() (r, g, b, a uint32)`  method to return
    a `uint32` value for red, green, blue, and alpha colors (RGBA). Alpha is a value
    for the transparency of a pixel. The `color` package conveniently provides a type
    called `color.RGBA` for this purpose (in case we don't need to implement our own,
    which is our case).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像将具有灰色背景颜色（`bgColor`）。这是通过实例化`image.Uniform`类型来实现的，该类型表示均匀颜色（因此得名）。`image.Uniform`类型需要`color.Color`接口的实例。`color.Color`类型是实现`RGBA()
    (r, g, b, a uint32)`方法以返回红色、绿色、蓝色和alpha颜色（RGBA）的`uint32`值的任何类型（RGBA）。 Alpha是像素透明度的值。`color`包方便地提供了一个名为`color.RGBA`的类型（如果我们不需要实现自己的类型，这就是我们的情况）。
- en: When storing an image in certain formats, we have to specify the quality of
    the image. It will affect not only the quality but the size of the file, of course.
    Here, it is defined as 75; 100 is the maximum quality possible that we can set.
    As you can see, we are using the `jpeg` package here to set the value of a type
    called `Options` that simply stores the value of the quality, it doesn't have
    more values to apply.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储图像的某些格式时，我们必须指定图像的质量。当然，这不仅会影响质量，还会影响文件的大小。在这里，它被定义为75；100是我们可以设置的最大质量。正如您所看到的，我们在这里使用`jpeg`包来设置一个名为`Options`的类型的值，它只是存储质量的值，没有更多的值可应用。
- en: Finally, the `draw.Print` function writes the pixels on the supplied image (`bgImage`)
    with the characteristics that we have defined on the bounds defined by the same
    image. The first argument of the `draw.Print` method takes the destination image,
    where we used `bgImage`. The second argument is the bounds of the object to draw
    in the destination image, we used the same bounds of the image but we could use
    any other if we wanted a smaller rectangle. The third argument is the color to
    use to colorize the bounds. The `Origin` variable is used to tell where the upper-left
    corner of the bound must be placed. In this case, the bounds are the same size
    as the image so we need to set it to the origin. The last argument specified is
    the operation type; just leave it in the `draw.Src` argument.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`draw.Print`函数将以我们在相同图像边界上定义的特征写入所提供的图像（`bgImage`）上的像素。`draw.Print`方法的第一个参数接受目标图像，我们使用了`bgImage`。第二个参数是要在目标图像中绘制的对象的边界，我们使用了图像的相同边界，但如果需要更小的矩形，我们也可以使用其他边界。第三个参数是要用于给边界上色的颜色。`Origin`变量用于告诉边界的左上角必须放置在哪里。在这种情况下，边界与图像大小相同，所以我们需要将其设置为原点。指定的最后一个参数是操作类型；只需将其保留在`draw.Src`参数中。
- en: 'Now we have to draw the square. The operation is essentially the same as to
    draw the background but, in this case, we are drawing a square over the previously
    drawn `bgImage`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须画正方形。这个操作本质上与绘制背景相同，但在这种情况下，我们是在之前绘制的`bgImage`上绘制一个正方形：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The square will be of 200*200 pixels of red color. When using the method `Add`,
    the `Rect` type origin is translated to the supplied point; this is to center
    the square on the image. We create an image with the square `Rect` and call the
    `Print` function on the `bgImage` image again to draw the red square over it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正方形将是200*200像素的红色。使用`Add`方法时，`Rect`类型的原点被转换为提供的点；这是为了将正方形居中放置在图像上。我们使用正方形`Rect`创建一个图像，并再次在`bgImage`图像上调用`Print`函数来绘制红色正方形：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we will create a file to store the contents of the image. The file
    will be stored in the path supplied in the `DestinationFilePath` field of the
    `ImageSquare` struct. To create a file, we use `os.Create` that returns the `*os.File`.
    As with every file, it must be closed after using it so don't forget to use the
    `defer` keyword to ensure that you close it when the method finishes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个文件来存储图像的内容。文件将存储在`ImageSquare`结构的`DestinationFilePath`字段中提供的路径中。要创建文件，我们使用返回`*os.File`的`os.Create`。与每个文件一样，在使用后必须关闭它，因此不要忘记使用`defer`关键字来确保在方法完成时关闭它。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To defer, or not to defer?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 推迟，还是不推迟？
- en: Some people ask why the use of `defer` at all? Wouldn't it be the same to simply
    write it without `defer` at the end of the function? Well, actually not. If any
    error occurs during the method execution and you return this error, the `Close`
    method won't be executed if it's at the end of the function. You can close the
    file before returning but you'll have to do it in every error check. With `defer,`
    you don't have to worry about this because the deferred function is executed always
    (with or without error). This way, we ensure that the file is closed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人问为什么要使用`defer`？不使用`defer`在函数末尾简单写入会不会一样？实际上并不是。如果在方法执行期间发生任何错误，并且您返回此错误，则如果它位于函数末尾，则`Close`方法将不会被执行。您可以在返回之前关闭文件，但您必须在每个错误检查中都这样做。使用`defer`，您不必担心这一点，因为延迟函数始终执行（无论有无错误）。这样，我们确保文件被关闭。
- en: 'To parse the arguments, we''ll use the `flag` package. We have used it before
    but let''s recall its usage. A flag is a command that the user can pass when executing
    our app. We can define a flag by using the `flag.[type]` methods defined in the
    `flag` package. We want to read the output that the user wants to use from the
    console. This flag will be called `output`. A flag can have a default value; in
    this case, it will have the value `console` that will be used when printing to
    console. So, if the user executes the program without arguments, it prints to
    console:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析参数，我们将使用`flag`包。我们以前使用过它，但让我们回顾一下它的用法。标志是用户在执行我们的应用程序时可以传递的命令。我们可以使用`flag.[type]`方法在`flag`包中定义标志。我们想要从控制台读取用户想要使用的输出。这个标志将被称为`output`。标志可以有一个默认值；在这种情况下，当打印到控制台时，它将具有值`console`。
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our final step is to write the main function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一步是编写主函数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember that the first thing to do in the main when using flags is to parse
    them using the `flag.Parse()` method! It''s very common to forget this step:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用标志时，主函数中的第一件事是使用`flag.Parse()`方法解析它们！很容易忘记这一步：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We define a variable for the strategy that the user has chosen, called `activeStrategy`.
    But check that the `activeStrategy` variable has the `PrintStrategy` type so it
    can be populated with any implementation of the `PrintStrategy` variable. We will
    set `activeStrategy` to a new instance of `TextSquare` when the user writes the 
    `**--output=console**`  command and an `ImageSquare` when we write the  `**--output=image**`
    command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为用户选择的策略定义了一个变量，称为`activeStrategy`。但要检查`activeStrategy`变量是否具有`PrintStrategy`类型，以便可以用`PrintStrategy`变量的任何实现来填充它。当用户写入`**--output=console**`命令时，我们将`activeStrategy`设置为`TextSquare`的新实例，并在写入`**--output=image**`命令时设置为`ImageSquare`。
- en: 'Finally, here is the design pattern execution:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是设计模式的执行：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `activeStrategy` variable is a type implementing `PrintStrategy` and either
    the `TextSquare` or `ImageSquare` classes. The user will choose at runtime which
    strategy he wants to use for each particular case. Also, we could have written
    a factory method pattern to create strategies, so that the strategy creation will
    also be uncoupled from the main function and abstracted in a different independent
    package. Think about it: if we have the strategy creation in a different package,
    it will also allow us to use this project as a library and not only as a standalone
    app.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`activeStrategy`变量是一个实现`PrintStrategy`的类型，可以是`TextSquare`或`ImageSquare`类。用户将在运行时选择他想要在每种特定情况下使用的策略。此外，我们可以编写一个工厂方法模式来创建策略，这样策略的创建也将与主函数解耦，并抽象成一个不同的独立包。想想看：如果我们将策略创建放在一个不同的包中，这也将允许我们将这个项目作为一个库来使用，而不仅仅是一个独立的应用程序。
- en: 'Now we will execute both strategies; the `TextSquare` instance will give us
    a square by printing the word `Square` on the console:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将执行两种策略；`TextSquare`实例将通过在控制台上打印单词`Square`来给我们一个正方形：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It has worked as expected. Recalling how flags work, we have to use the `--` (double
    dash) and the defined flag, `output` in our case. Then you have two options--using
    `=` (equals) and immediately writing the value for the flag or writing `<space>`
    and the value for the flag. In this case, we have defined the default value of
    output to the console so the following three executions are equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经按预期工作。回想一下标志的工作方式，我们必须使用`--`（双破折号）和定义的标志，例如我们的情况下的`output`。然后你有两个选项——使用`=`（等号）并立即写入标志的值，或者写入`<空格>`和标志的值。在这种情况下，我们已经将输出的默认值定义为控制台，因此以下三个执行是等效的：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we have to try the file strategy. As defined before, the file strategy
    will print a red square to a file as an image with dark gray background:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要尝试文件策略。如前所述，文件策略将在文件中打印一个红色的正方形作为带有深灰色背景的图像：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Nothing happened? But everything worked correctly. This is actually bad practice.
    Users must always have some sort of feedback when using your app or your library.
    Also, if they are using your code as a library, maybe they have a specific format
    for output so it won't be nice to directly print to the console. We will solve
    this issue later. Right now, open the folder `/tmp` with your favourite file explorer
    and you will see a file called `image.jpg` with our red square in a dark grey
    background.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没发生？但一切都正确地工作了。这实际上是不好的做法。用户在使用您的应用程序或库时必须始终有某种反馈。此外，如果他们正在将您的代码作为库使用，也许他们对输出有特定的格式，因此直接打印到控制台是不好的。我们稍后将解决这个问题。现在，用您喜欢的文件浏览器打开`/tmp`文件夹，您将看到一个名为`image.jpg`的文件，其中有我们的红色正方形和深灰色背景。
- en: Solving small issues in our library
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的库中解决小问题
- en: 'We have a few issues in our code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中有一些问题：
- en: It cannot be used as a library. We have critical code written in the `main`
    package (strategy creation).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能作为一个库来使用。我们在`main`包（策略创建）中编写了关键代码。
- en: '**Solution**: Abstract to two different packages the strategy creation from
    the command-line application.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：将命令行应用程序中的策略创建抽象到两个不同的包中。'
- en: None of the strategies are doing any logging to file or console. We must provide
    a way to read some logs that an external user can integrate in their logging strategies
    or formats.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何策略在文件或控制台上进行记录。我们必须提供一种方法来读取一些日志，外部用户可以将其集成到他们的日志策略或格式中。
- en: '**Solution**: Inject an `io.Writer` interface as dependency to act as a logging
    sink.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：注入一个`io.Writer`接口作为日志接收器的依赖。'
- en: Our `TextSquare` class is always writing to the console (an implementer of the `io.Writer`
    interface) and the `ImageSquare` is always writing to file (another implementer
    of the `io.Writer` interface). This is too coupled.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`TextSquare`类总是写入控制台（实现了`io.Writer`接口），而`ImageSquare`总是写入文件（另一个实现了`io.Writer`接口）。这种耦合度太高了。
- en: '**Solution**: Inject an `io.Writer` interface so that the `TextSquare` and
    `ImageSquare` can write to any of the `io.Writer` implementations that are available
    (file and console, but also bytes buffer, binary encoders, `JSON` handlers...
    dozens of packages).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：注入一个`io.Writer`接口，以便`TextSquare`和`ImageSquare`可以写入任何可用的`io.Writer`实现（文件和控制台，还有字节缓冲区、二进制编码器、`JSON`处理程序等等数十个包）。'
- en: 'So, to use it as a library and solve the first issue, we will follow a common
    approach in Go file structures for apps and libraries. First, we will place our
    main package and function outside of the root package; in this case, in a folder
    called `cli`. It is also common to call this folder `cmd` or even `app`. Then,
    we will place our `PrintStrategy` interface in the root package, which now will
    be called the `strategy` package. Finally, we will create a `shapes` package in
    a folder with the same name where we will put both text and image strategies.
    So, our file structure will be like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将其作为一个库来使用并解决第一个问题，我们将遵循Go文件结构中应用程序和库的常见方法。首先，我们将把我们的主包和函数放在根包之外；在这种情况下，放在一个名为`cli`的文件夹中。通常也会将此文件夹称为`cmd`或者`app`。然后，我们将把我们的`PrintStrategy`接口放在根包中，现在将被称为`strategy`包。最后，我们将在一个同名的文件夹中创建一个`shapes`包，其中我们将放置文本和图像策略。因此，我们的文件结构将如下所示：
- en: '**Root package**: strategy'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根包**：策略'
- en: 'File: `print_strategy.go`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`print_strategy.go`
- en: '**SubPackage**: shapes'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子包**：形状'
- en: 'Files: `image.go`, `text.go`, `factory.go`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`image.go`，`text.go`，`factory.go`
- en: '**SubPackage**: cli'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子包**：cli'
- en: 'File: `main.go`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`main.go`
- en: 'We are going to modify our interface a bit to fit the needs we have written
    previously:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍微修改我们的接口以满足我们之前编写的需求：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have added the `SetLog(io.Writer)` method to add a logger strategy to our
    types; this is to provide feedback to users. Also, it has a `SetWriter` method
    to set the `io.Writer` strategy. This interface is going to be located on the
    root package in the `print_strategy.go` file. So the final schema looks like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了`SetLog(io.Writer)`方法来向我们的类型添加一个记录器策略；这是为了向用户提供反馈。它还有一个`SetWriter`方法来设置`io.Writer`策略。这个接口将位于根包中的`print_strategy.go`文件中。因此，最终的架构看起来像这样：
- en: '![Solving small issues in our library](img/B05557_05_02-300x127.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的库中解决小问题](img/B05557_05_02-300x127.jpg)'
- en: 'Both the `TextSquare` and `ImageSquare` strategies have to satisfy the `SetLog`
    and `SetWriter` methods which simply store some object on their fields so, instead
    of implementing the same twice, we can create a struct that implements them and
    embed this struct in the strategies. By the way, this would be the composite pattern
    we have seen previously:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextSquare`和`ImageSquare`策略都必须满足`SetLog`和`SetWriter`方法，这些方法只是简单地在它们的字段上存储一些对象，所以我们可以创建一个实现它们的结构，并将这个结构嵌入到策略中，而不是重复实现两次。顺便说一句，这就是我们之前看到的组合模式：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So now each strategy must have the `PrintOutput` struct embedded if we want
    to modify their `Writer` and `logger` fields.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在每个策略必须嵌入`PrintOutput`结构，如果我们想修改它们的`Writer`和`logger`字段。
- en: 'We also need to modify our strategy implementation. The `TextSquare` struct now
    needs a field to store the output `io.Writer` (the place where it is going to
    write instead of writing always to the console) and the `log` writer. These two
    fields can be provided by embedding the `PrintOutput` struct. The `TextSquare` struct
    is also stored in the file `text.go` within the shapes package. So, the struct
    is now like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的策略实现。`TextSquare`结构现在需要一个字段来存储输出的`io.Writer`（它将写入的地方，而不是总是写入控制台）和`log`写入器。这两个字段可以通过嵌入`PrintOutput`结构来提供。`TextSquare`结构也存储在shapes包的文件`text.go`中。因此，该结构现在是这样的：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So now the `Print()` method is slightly different because, instead of writing
    directly to the console by using the `println` function, we have to write whichever
    `io.Writer` is stored in the `Writer` field:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在`Print()`方法略有不同，因为我们不再直接使用`println`函数写入控制台，而是要写入存储在`Writer`字段中的任何`io.Writer`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `bytes.NewReader` is a very useful function that takes an array of bytes
    and converts them to an `io.Reader` interface. We need an `io.Reader` interface
    to use the `io.Copy` function. The `io.Copy` function is also incredibly useful
    as it takes an `io.Reader` (as the second parameter) and pipes it to an `io.Writer`
    (its first parameter). So, we won''t return an error in any case. However, it''s
    easier to do so using directly the `Write` method of `t.Writer`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes.NewReader`是一个非常有用的函数，它接受一个字节数组并将其转换为`io.Reader`接口。我们需要一个`io.Reader`接口来使用`io.Copy`函数。`io.Copy`函数也非常有用，因为它接受一个`io.Reader`（作为第二个参数）并将其传输到一个`io.Writer`（作为第一个参数）。因此，在任何情况下我们都不会返回错误。然而，直接使用`t.Writer`的`Write`方法更容易：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can use whichever method you like more. Usually, you will use the `Write`
    method but it's nice to know the `bytes.NewReader` function too.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你更喜欢的任何方法。通常，你会使用`Write`方法，但了解`bytes.NewReader`函数也很好。
- en: Did you realize that when we use `t.Writer`, we are actually accessing `PrintOutput.Writer`?
    The `TextSquare` type has a `Writer` field because the `PrintOutput` struct has
    it and it's embedded on the `TextSquare` struct.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到当我们使用`t.Writer`时，实际上是在访问`PrintOutput.Writer`？`TextSquare`类型有一个`Writer`字段，因为`PrintOutput`结构体有它，并且它被嵌入到`TextSquare`结构体中。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Embedding is not inheritance. We have embedded the `PrintOutput` struct on
    the `TextSquare` struct. Now we can access `PrintOutput` fields as if they were
    in `TextSquare` fields. This feels a bit like inheritance but there is a very
    important difference here: `TextSquare` is not a `PrintOutput` value but it has
    a `PrintOutput` in its composition. What does it mean? That if you have a function
    that expects a `PrintOutput`, you cannot a pass `TextSquare` just because it has
    a `PrintOutput` embedded.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入不是继承。我们在`TextSquare`结构体中嵌入了`PrintOutput`结构体。现在我们可以像访问`TextSquare`字段一样访问`PrintOutput`字段。这感觉有点像继承，但这里有一个非常重要的区别：`TextSquare`不是`PrintOutput`值，而是在其组合中有一个`PrintOutput`。这是什么意思？如果你有一个期望`PrintOutput`的函数，你不能传递`TextSquare`，只是因为它嵌入了`PrintOutput`。
- en: But, if you have a function that accepts an interface that `PrintOutput` implements,
    you can pass `TextSquare` if it has a `PrintOutput` embedded. This is what we
    are doing in our example.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你有一个接受`PrintOutput`实现的接口的函数，你可以传递`TextSquare`，如果它嵌入了`PrintOutput`。这就是我们在示例中所做的。
- en: 'The `ImageSquare` struct is now like the `TextSquare`, with a `PrintOutput`
    embedded:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageSquare`结构现在与`TextSquare`类似，都嵌入了`PrintOutput`：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Print` method also needs to be modified. Now, we aren''t creating a file
    from the `Print` method, as it was breaking the single responsibility principle.
    A file implements an `io.Writer` so we will open the file outside of the `ImageSquare`
    struct and inject it on the `Writer` field. So, we just need to modify the end
    of the `Print()` method where we wrote to the file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print`方法也需要修改。现在，我们不再从`Print`方法中创建文件，因为这违反了单一职责原则。文件实现了`io.Writer`，所以我们将在`ImageSquare`结构体之外打开文件，并将其注入`Writer`字段。因此，我们只需要修改`Print()`方法的结尾，我们在其中写入文件：'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you check our previous implementation, after using `draw`, you can see that
    we used the `Print` method, we created a file with `os.Create` and passed it to
    the `jpeg.Encode` function. We have deleted this part about creating the file
    and we have replaced it with a check looking for a `Writer` in the fields (`if
    i.Writer != nil`). Then, on `jpeg.Encode` we can replace the file value we were
    using previously with the content of the `i.Writer` field. Finally, we are using
    `io.Copy` again to log some message to the `LogWriter` if a logging strategy is
    provided.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查我们之前的实现，在使用`draw`之后，你会发现我们使用了`Print`方法，我们用`os.Create`创建了一个文件，并将其传递给`jpeg.Encode`函数。我们已经删除了关于创建文件的部分，并用一个检查替换了它，查找字段中的`Writer`（`if
    i.Writer != nil`）。然后，在`jpeg.Encode`中，我们可以用之前使用的文件值替换`i.Writer`字段的内容。最后，如果提供了日志策略，我们再次使用`io.Copy`来将一些消息记录到`LogWriter`中。
- en: 'We also have to abstract the knowledge needed from the user to create instances
    of implementors of the `PrintStrategy` for which we are going to use a Factory
    method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从用户那里抽象出创建`PrintStrategy`实现者实例所需的知识，为此我们将使用工厂方法：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have two constants, one of each of our strategies: `TEXT_STRATEGY` and `IMAGE_STRATEGY`.
    Those are the constants that must be provided to the factory to retrieve each
    square drawer strategy. Our factory method receives an argument `s`, which is
    a string with one of the previous constants.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个常量，分别是我们的两种策略：`TEXT_STRATEGY`和`IMAGE_STRATEGY`。这些常量必须提供给工厂以检索每个方形抽屉策略。我们的工厂方法接收一个参数`s`，它是一个包含前述常量之一的字符串。
- en: Each strategy has a `PrintOutput` type embedded with a default logger to `stdout`
    but you can override it later by using the `SetLog(io.Writer)` methods. This approach
    could be considered a Factory of prototypes. If it is not a recognized strategy,
    a proper message error will be returned.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个策略都嵌入了一个默认记录器到`stdout`的`PrintOutput`类型，但是你可以通过使用`SetLog(io.Writer)`方法来覆盖它。这种方法可以被认为是原型的工厂。如果它不是一个被识别的策略，将返回一个适当的错误消息。
- en: 'What we have now is a library. We have all the functionality we need between
    the `strategy` and `shapes` packages. Now we will write the `main` package and
    function in a new folder called `cli`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个库。我们在`strategy`和`shapes`包之间拥有了所有需要的功能。现在我们将在一个名为`cli`的新文件夹中编写`main`包和函数：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, like before, the `main` function starts by parsing the input arguments
    on the console to gather the chosen strategy. We can use the variable output now
    to create a strategy without Factory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，`main`函数首先通过解析控制台上的输入参数来开始，以获取所选择的策略。我们现在可以使用变量output来创建一个不需要工厂的策略：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this snippet, we have our strategy or we stop program execution in the
    `log.Fatal` method if any error is found (such as an unrecognized strategy).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们有了我们的策略，或者如果发现任何错误（比如一个未被识别的策略），我们会在`log.Fatal`方法中停止程序执行。
- en: 'Now we will implement the business needs by using our library. For the purpose
    of the `TextStrategy`, we want to write, for example, to `stdout`. For the purpose
    of the image, we will write to `/tmp/image.jpg`. Just like before. So, following
    the previous statements, we can write:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用我们的库来实现业务需求。对于`TextStrategy`，我们想要写入，例如，到`stdout`。对于图像，我们将写入到`/tmp/image.jpg`。就像之前一样。因此，根据前述陈述，我们可以写：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the case of `TEXT_STRATEGY`, we use `SetWriter` to set the `io.Writer` to
    `os.Stdout`. In the case of `IMAGE_STRATEGY`, we create an image in any of our
    folders and pass the file variable to the `SetWriter` method. Remember that `os.File`
    implements the `io.Reader` and `io.Writer` interfaces, so it''s perfectly legal
    to pass it as an `io.Writer` to the `SetWriter` method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TEXT_STRATEGY`的情况下，我们使用`SetWriter`将`io.Writer`设置为`os.Stdout`。在`IMAGE_STRATEGY`的情况下，我们在我们的任何一个文件夹中创建一个图像，并将文件变量传递给`SetWriter`方法。记住，`os.File`实现了`io.Reader`和`io.Writer`接口，所以将它作为`io.Writer`传递给`SetWriter`方法是完全合法的：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we call the `Print` method of whichever strategy was chosen by the
    user and check for possible errors. Let''s try the program now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用用户选择的任何策略的`Print`方法并检查可能的错误。现在让我们尝试一下程序：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It has worked as expected. What about the image strategy?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经按预期工作。那么图片策略呢？
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we check in `/tmp/image.jpg`, we can find our red square on the dark background.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`/tmp/image.jpg`中检查，我们可以在黑色背景上找到我们的红色方块。
- en: Final words on the Strategy pattern
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于策略模式的最后一句话
- en: We have learned a powerful way to encapsulate algorithms in different structs.
    We have also used embedding instead of inheritance to provide cross-functionality
    between types, which will come in handy very often in our apps. You'll find yourself
    combining strategies here and there as we have seen in the second example, where
    we have strategies for logging and writing by using the `io.Writer` interface,
    a strategy for byte-streaming operations.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了一种将算法封装在不同的结构体中的强大方式。我们还使用了嵌入而不是继承来在类型之间提供交叉功能，这在我们的应用程序中经常会派上用场。你会发现自己在这里和那里组合策略，就像我们在第二个例子中看到的那样，我们通过使用`io.Writer`接口有日志和写入的策略，有一个用于字节流操作的策略。
- en: Chain of responsibility design pattern
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链设计模式
- en: Our next pattern is called **chain of responsibility**. As its name implies,
    it consists of a chain and, in our case, each link of the chain follows the single
    responsibility principle.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个模式被称为**责任链**。顾名思义，它由一条链组成，在我们的情况下，链的每个链接都遵循单一职责原则。
- en: Description
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The single responsibility principle implies that a type, function, method, or
    any similar abstraction must have one single responsibility only and it must do
    it quite well. This way, we can apply many functions that achieve one specific
    thing each to some struct, slice, map, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则意味着一个类型、函数、方法或任何类似的抽象必须只有一个单一的职责，并且必须做得很好。这样，我们可以将许多实现一个特定功能的函数应用到某个结构体、切片、映射等中。
- en: When we apply many of these abstractions in a logical way very often, we can
    chain them to execute in order such as, for example, a logging chain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们经常以一种逻辑的方式应用许多这些抽象时，我们可以将它们链接起来按顺序执行，比如，例如一个日志链。
- en: A logging chain is a set of types that logs the output of some program to more
    than one `io.Writer` interface. We could have a type that logs to the console,
    a type that logs to a file, and a type that logs to a remote server. You can make
    three calls every time you want to do some logging, but it's more elegant to make
    only one and provoke a chain reaction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 日志链是一组类型，将某个程序的输出记录到多个`io.Writer`接口。我们可以有一个记录到控制台的类型，一个记录到文件的类型，以及一个记录到远程服务器的类型。每次想要进行一些记录时，你可以进行三次调用，但是只进行一次调用并引发一次链式反应更加优雅。
- en: But also, we could have a chain of checks and, in case one of them fails, break
    the chain and return something. This is the authentication and authorization middleware
    works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以有一系列检查，并且如果其中一个失败，就中断链并返回一些东西。这就是认证和授权中间件的工作方式。
- en: Objectives
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objective of the chain of responsibility is to provide to the developer
    a way to chain actions at runtime. The actions are chained to each other and each
    link will execute some action and pass the request to the next link (or not).
    The following are the objectives followed by this pattern:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链的目标是为开发人员提供一种在运行时链接操作的方法。这些操作相互链接，每个链接将执行某些操作并将请求传递给下一个链接（或不传递）。以下是此模式遵循的目标：
- en: Dynamically chain the actions at runtime based on some input
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时根据某些输入动态地链接操作
- en: Pass a request through a chain of processors until one of them can process it,
    in which case the chain could be stopped
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一系列处理器传递请求，直到其中一个可以处理它，此时链可能会停止
- en: A multi-logger chain
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多记录器链
- en: 'We are going to develop a multi-logger solution that we can chain in the way
    we want. We will use two different console loggers and one general-purpose logger:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个多记录器解决方案，可以按我们想要的方式进行链接。我们将使用两个不同的控制台记录器和一个通用记录器：
- en: We need a simple logger that logs the text of a request with a prefix *First
    logger* and passes it to the next link in the chain.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个简单的记录器，记录带有前缀*First logger*的请求文本，并将其传递给链中的下一个链接。
- en: A second logger will write on the console if the incoming text has the word
    `hello` and pass the request to a third logger. But, if not, the chain will be
    broken and it will return immediately.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个记录器将在控制台上写入文本，如果传入文本包含单词`hello`，则将请求传递给第三个记录器。但是，如果没有，则链将被中断并立即返回。
- en: A third logger type is a general purpose logger called `WriterLogger` that uses
    an `io.Writer` interface to log.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个记录器类型是一个名为`WriterLogger`的通用记录器，它使用`io.Writer`接口进行记录。
- en: A concrete implementation of the `WriterLogger` writes to a file and represents
    the third link in the chain.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WriterLogger`的具体实现写入文件，代表链中的第三个链接。'
- en: 'The implementation of these steps is described in the following figure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤的实现如下图所示：
- en: '![A multi-logger chain](img/B05557_05_03.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![多日志链](img/B05557_05_03.jpg)'
- en: Unit test
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'The very first thing to do for the chain is, as usual, to define the interface.
    A chain of responsibility interface will usually have, at least, a  `Next()` method.
    The `Next()` method is the one that executes the next link in the chain, of course:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 链的第一件事，通常是定义接口。责任链接口通常至少有一个`Next()`方法。`Next()`方法是执行链中下一个链接的方法：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Next` method on our example''s interface takes the message we want to
    log and passes it to the following link in the chain. As written in the acceptance
    criteria, we need three loggers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例接口的`Next`方法接受我们想要记录的消息，并将其传递给链中的下一个链接。如验收标准所述，我们需要三个记录器：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `FirstLogger` and `SecondLogger` types have exactly the same structure--both
    implement `ChainLogger` and have a `NextChain` field that points to the next `ChainLogger`.
    The `WriterLogger` type is equal to the `FirstLogger` and `SecondLogger` types
    but also has a field to write its data to, so you can pass any `io.Writer` interface
    to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstLogger`和`SecondLogger`类型具有完全相同的结构--都实现`ChainLogger`，并具有指向下一个`ChainLogger`的`NextChain`字段。`WriterLogger`类型等同于`FirstLogger`和`SecondLogger`类型，但还具有一个字段用于将其数据写入，因此您可以将任何`io.Writer`接口传递给它。'
- en: 'As we have done before, we''ll implement an `io.Writer` struct to use in our
    testing. In our test file, we define the following struct:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们将实现一个`io.Writer`结构以在测试中使用。在我们的测试文件中，我们定义以下结构：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will pass an instance of the `myTestWriter` struct to `WriterLogger` so we
    can track what's being logged on testing. The `myTestWriter` class implements
    the common `Write([]byte) (int, error)` method from the `io.Writer` interface.
    Remember, if it has the `Write` method, it can be used as `io.Writer`. The `Write`
    method simply stored the string argument to the `receivedMessage` field so we
    can check later its value on tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递`myTestWriter`结构的实例给`WriterLogger`，以便在测试中跟踪被记录的内容。`myTestWriter`类实现了`io.Writer`接口的常见`Write([]byte)
    (int, error)`方法。请记住，如果它具有`Write`方法，它可以被用作`io.Writer`。`Write`方法简单地将字符串参数存储到`receivedMessage`字段中，以便我们稍后在测试中检查其值。
- en: 'This is the beginning of the first test function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个测试函数的开始：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let's describe these few lines a bit as they are quite important. We create
    a variable with a default `myTestWriter` type that we'll use as an `io.Writer` interface
    in the last link of our chain. Then we create the last piece of the link chain,
    the `writerLogger` interface. When implementing the chain, you usually start with
    the last piece on the link and, in our case, it is a `WriterLogger`. The `WriterLogger`
    writes to an `io.Writer` so we pass `myWriter` as `io.Writer` interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微描述一下这几行，因为它们非常重要。我们创建一个默认的`myTestWriter`类型的变量，我们将在链的最后一个链接中用作`io.Writer`接口。然后我们创建链的最后一部分，`writerLogger`接口。在实现链时，通常从链的最后一部分开始，在我们的例子中是`WriterLogger`。`WriterLogger`写入`io.Writer`，因此我们将`myWriter`作为`io.Writer`接口传递。
- en: Then we have created a `SecondLogger`, the middle link in our chain, with a
    pointer to the `writerLogger`. As we mentioned before, `SecondLogger` just logs
    and passes the message in case it contains the word `hello`. In a production app,
    it could be an error-only logger.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个`SecondLogger`，即我们链中的中间链接，指向`writerLogger`。如前所述，`SecondLogger`只是在包含单词`hello`的情况下记录并传递消息。在生产应用程序中，它可能是仅错误记录器。
- en: 'Finally, the first link in the chain has the variable name chain. It points
    to the second logger. So, to resume, our chain looks like this: `FirstLogger`
    | `SecondLogger` | `WriterLogger`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链中的第一个链接具有变量名`chain`。它指向第二个记录器。因此，总结一下，我们的链如下所示：`FirstLogger` | `SecondLogger`
    | `WriterLogger`。
- en: 'This is going to be our default setup for our tests:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们测试的默认设置：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Continuing with Go 1.7 or later testing signatures, we define an inner test
    with the following description: *three loggers, two of them write to console,
    the second only if it finds the word ''hello'', the third writes to some variable
    if the second found ''hello''*. It''s quite descriptive and very easy to understand
    if someone else has to maintain this code.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用Go 1.7或更高版本的测试签名，我们定义了一个内部测试，描述如下：*三个记录器，其中两个写入控制台，第二个只有在找到单词'hello'时才写入，第三个只有在第二个找到'hello'时才写入一些变量*。如果有人需要维护这段代码，这是非常描述性的，也很容易理解。
- en: First, we use a message on the `Next` method that will not reach the third link
    in the chain as it doesn't contain the word `hello`. We check the contents of
    the `receivedMessage` variable, that by default is empty, to see if it has changed
    because it shouldn't.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Next`方法上的消息，它不会到达链中的第三个链接，因为它不包含`hello`这个词。我们检查`receivedMessage`变量的内容，它默认为空，看看它是否已经改变，因为它不应该改变。
- en: Next, we use the chain variable again, our first link in the chain, and pass
    the message `"Hello\n"`. According to the description of the test, it should log
    using `FirstLogger`, then in `SecondLogger` and finally in `WriterLogger` because
    it contains the word `hello` and the `SecondLogger` will let it pass.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次使用链变量，我们链中的第一个链接，并传递消息`"Hello\n"`。根据测试的描述，它应该使用`FirstLogger`进行记录，然后在`SecondLogger`中，最后在`WriterLogger`中，因为它包含`hello`这个词，而`SecondLogger`会让它通过。
- en: 'The test checks that `myWriter`, the last link in the chain that stored the
    past message in a variable called `receivedMessage`, has the word that we passed
    first in the chain: hello. Let''s run it so it fails:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查`myWriter`，链中存储了过去消息的最后一个链接，是否包含我们在链中首次传递的单词：hello。让我们运行它，看看它是否失败：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The test passed for the first check of the test and didn''t for the second
    check. Well... ideally no check should pass before any implementation is done.
    Remember that in test-driven development, tests must fail on the first launch
    because the code they are testing isn''t implemented yet. Go zero-initialization
    misleads us with this passed check on the test. We can solve this in two ways:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了测试的第一个检查，但没有通过第二个检查。嗯...理想情况下，在任何实现之前都不应该通过任何检查。请记住，在测试驱动的开发中，测试必须在第一次启动时失败，因为它们正在测试的代码尚未实现。零初始化误导了我们，使得测试通过了。我们可以用两种方法解决这个问题：
- en: 'Making the signature of the `ChainLogger` to return an error: `Next(string)`
    error. This way, we would break the chain returning an error. This is a much more
    convenient way in general, but it will introduce quite a lot of boilerplate right
    now.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ChainLogger`的签名更改为返回一个错误：`Next(string)` error。这样，我们将通过返回错误来打破链。这通常是一个更方便的方法，但现在会引入相当多的样板代码。
- en: Changing the `receivedMessage` field to a pointer. A default value of a pointer
    is nil, instead of an empty string.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`receivedMessage`字段更改为指针。指针的默认值是nil，而不是空字符串。
- en: 'We will use the second option now, as it''s much simpler and quite effective
    too. So let''s change the signature of the `myTestWriter` struct to the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用第二个选项，因为它更简单，而且也相当有效。所以让我们将`myTestWriter`结构的签名更改为以下内容：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Check that the type of `receivedMessage` has the asterisk (`*`) now to indicate
    that it's a pointer to a string. The `Write` function needed to change too. Now
    we have to check the contents of the `receivedMessage` field because, as every
    pointer, it's initialized to nil. Then we have to store the message in a variable
    first, so we can take the address in the next line on the assignment `(m.receivedMessage
    = &tempMessage)`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`receivedMessage`的类型现在是否有星号（`*`），以指示它是一个指向字符串的指针。`Write`函数也需要更改。现在我们必须检查`receivedMessage`字段的内容，因为像每个指针一样，它被初始化为nil。然后我们必须首先将消息存储在一个变量中，这样我们就可以在赋值的下一行中取地址（`m.receivedMessage
    = &tempMessage`）。
- en: 'So now our test code should change a bit too:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们的测试代码也应该有所改变：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we are checking that `myWriter.receivedMessage` is actually `nil`, so no
    content has been written for sure on the variable. Also, we have to change the
    second if to check first that the member isn''t nil before checking its contents
    or it can throw a panic on test. Let''s test it again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在检查`myWriter.receivedMessage`是否实际上是`nil`，因此可以确定变量上确实没有写入任何内容。此外，我们必须更改第二个if语句，首先检查成员是否为nil，然后再检查其内容，否则测试可能会引发恐慌。让我们再次测试一下：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It fails again and, again, the first half of the test passes correctly without
    implemented code. So what should we do now? We have change the signature of the `myWriter`
    type to make the test fail in both checks and, again, just fail in the second.
    Well, in this case we can pass this small issue. When writing tests, we must be
    very careful to not get too crazy about them; unit tests are tools to help us
    write and maintain code, but our target is to write functionality, not tests.
    This is important to keep in mind as you can get really crazy engineering unit
    tests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次失败了，而且再次，测试的前半部分在没有实现代码的情况下正确通过了。那么现在我们该怎么办呢？我们必须更改`myWriter`类型的签名，使得测试在两个检查中都失败，而且只在第二个检查中失败。嗯，在这种情况下，我们可以忽略这个小问题。在编写测试时，我们必须非常小心，不要对它们过于疯狂；单元测试是帮助我们编写和维护代码的工具，但我们的目标是编写功能，而不是测试。这一点很重要，因为你可能会对工程化单元测试感到非常疯狂。
- en: Implementation
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Now we have to implement the first, second, and third loggers called `FirstLogger`,
    `SecondLogger`, and `WriterLogger` respectively. The `FirstLogger` logger is the
    easiest one as described in the first acceptance criterion: *We need a simple
    logger that logs the text of a request with a prefix First logger: and passes
    it to the next link in the chain*. So let''s do it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须分别实现第一个、第二个和第三个名为`FirstLogger`、`SecondLogger`和`WriterLogger`的记录器。`FirstLogger`记录器是最简单的，正如第一个验收标准中所描述的那样：*我们需要一个简单的记录器，记录请求的文本，并在前缀为First
    logger:的情况下将其传递给链中的下一个链接*。所以让我们来做吧：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The implementation is quite easy. Using the `fmt.Printf` method to format and
    print the incoming string, we appended the text `First Logger:` text. Then, we
    check that the `NextChain` type has actually some content and pass the control
    to it by calling its `Next(string)` method. The test shouldn''t pass yet so we''ll
    continue with the `SecondLogger` logger:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实现起来非常简单。使用 `fmt.Printf` 方法对传入的字符串进行格式化和打印，我们附加了文本 `First Logger:`。然后，我们检查 `NextChain`
    类型是否实际上有一些内容，并通过调用其 `Next(string)` 方法将控制权传递给它。测试还没有通过，所以我们将继续使用 `SecondLogger`
    记录器：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As mentioned in the second acceptance criterion, the `SecondLogger` description
    is: *A second logger will write on the console if the incoming text has the word
    "hello" and pass the request to a third logger*. First of all, it checks whether
    the incoming text contains the text `hello`. If it''s true, it prints the message
    to the console, appending the text `Second logger:` and passes the message to
    the next link in the chain (check previous instance that a third link exists).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如第二个验收标准所述，`SecondLogger` 的描述是：*如果传入的文本包含单词 "hello"，第二个记录器将在控制台上写入并将请求传递给第三个记录器*。首先，它检查传入的文本是否包含文本
    `hello`。如果是，它会将消息打印到控制台，并附加文本 `Second logger:`，并将消息传递给链中的下一个链接（检查之前的实例是否存在第三个链接）。
- en: But if it doesn't contain the text `hello`, the chain is broken and it prints
    the message `Finishing in second logging`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果它不包含文本 `hello`，链就会断开，并打印消息 `Finishing in second logging`。
- en: 'We''ll finalize with the `WriterLogger` type:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以 `WriterLogger` 类型结束：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `WriterLogger` struct's `Next` method checks that there is an existing `io.Writer`
    interface stored in the `Writer` member and writes there the incoming message
    appending the text `WriterLogger:` to it. Then, like the previous links, check
    that there are more links to pass the message.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriterLogger` 结构的 `Next` 方法检查 `Writer` 成员中是否存储了现有的 `io.Writer` 接口，并将传入的消息写入其中，附加文本
    `WriterLogger:`。然后，就像之前的链接一样，检查是否有更多的链接来传递消息。'
- en: 'Now the tests will pass successfully:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试将成功通过：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first half of the test prints two messages--the `First logger:` message
    that breaks the chain, which is the expected message for the `FirstLogger`. But
    it halts in the `SecondLogger` because no `hello` word has been found on the incoming
    message; that's why it prints the `Finishing in second logging` string.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的前半部分打印了两条消息——`First logger:` 打破了链，这是 `FirstLogger` 的预期消息。但它在 `SecondLogger`
    中停止，因为在传入的消息中找不到 `hello` 一词；这就是为什么它打印了 `Finishing in second logging` 字符串。
- en: The second half of the test receives the message `Hello`. So the `FirstLogger`
    prints and the `SecondLogger` prints too. The third logger doesn't print to console
    at all but to our `myWriter.receivedMessage` line defined in the test.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的后半部分接收到消息 `Hello`。所以 `FirstLogger` 打印，`SecondLogger` 也打印。第三个记录器根本不打印到控制台，而是打印到我们在测试中定义的
    `myWriter.receivedMessage` 行。
- en: What about a closure?
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么闭包呢？
- en: 'Sometimes it can be useful to define an even more flexible link in the chain
    for quick debugging. We can use closures for this so that the link functionality
    is defined by the caller. What does a closure link look like? Similar to the `WriterLogger`
    logger:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了快速调试，定义链中更灵活的链接可能会很有用。我们可以使用闭包来实现这一点，以便链接功能由调用者定义。闭包链接是什么样子的？类似于 `WriterLogger`
    记录器：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ClosureChain` type has a `NextChain`, as usual, and a `Closure` member.
    Look at the signature of the `Closure: func(string)`. This means it is a function
    that takes a `string` and returns nothing.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosureChain` 类型有一个 `NextChain`，和一个 `Closure` 成员。看一下 `Closure` 的签名：`func(string)`。这意味着它是一个接受
    `string` 并且不返回任何东西的函数。'
- en: The `Next(string)` method for `ClosureChain` checks that the `Closure` member
    is stored and executes it with the incoming string. As usual, the link checks
    for more links to pass the message as every link in the chain.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClosureChain` 的 `Next(string)` 方法检查 `Closure` 成员是否已存储，并使用传入的字符串执行它。和往常一样，该链接检查更多的链接以传递消息，就像链中的每个链接一样。'
- en: 'So, how do we use it now? We''ll define a new test to show its functionality:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们现在如何使用它呢？我们将定义一个新的测试来展示它的功能：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The description of this test makes it clear: `"2 loggers, second uses the closure
    implementation".` We simply use two `ChainLogger` implementations and we use the
    `closureLogger` in the second link. We have created a new `myTestWriter` to store
    the contents of the message. When defining the `ClosureChain`, we defined an anonymous
    function directly on the `Closure` member when creating `closureLogger`. It prints
    `"My closure logger! Message: %s\n" with the incoming message replacing "%s"`.
    Then, we store the incoming message on `myWriter`, to check later.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '这个测试的描述很清楚：`"2 loggers, second uses the closure implementation"`。我们简单地使用两个
    `ChainLogger` 实现，并且在第二个链接中使用 `closureLogger`。我们创建了一个新的 `myTestWriter` 来存储消息的内容。在定义
    `ClosureChain` 时，我们在创建 `closureLogger` 时直接在 `Closure` 成员上定义了一个匿名函数。它打印 `"My closure
    logger! Message: %s\n"`，并用传入的消息替换 "%s"。然后，我们将传入的消息存储在 `myWriter` 上，以便稍后检查。'
- en: After defining this new link, we use the third link from the previous test,
    add the closure as the fourth link, and passed the message `Hello closure logger`.
    We use the word `Hello` at the beginning so that we ensure that the message will
    pass the `SecondLogger`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这个新链接之后，我们使用了上一个测试的第三个链接，将闭包添加为第四个链接，并传递了消息 `Hello closure logger`。我们在开头使用单词
    `Hello`，以确保消息将通过 `SecondLogger`。
- en: 'Finally, the contents of `myWriter.receivedMessage` must contain the pased
    text: `Hello closure logger`. This is quite a flexible approach with one drawback:
    when defining a closure like this, we cannot test its contents in a very elegant
    way. Let''s run the tests again:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`myWriter.receivedMessage` 的内容必须包含传递的文本：`Hello closure logger`。这是一种非常灵活的方法，但有一个缺点：在定义这样的闭包时，我们无法以非常优雅的方式测试其内容。让我们再次运行测试：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look at the third `RUN`: the message passes correctly through the first, second,
    and third links to arrive at the closure that prints the expected  `My closure
    logger! Message: Hello closure logger` message.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '看一下第三个 `RUN`：消息正确地通过第一个、第二个和第三个链接到达闭包，打印了预期的 `My closure logger! Message: Hello
    closure logger` 消息。'
- en: It's very useful to add a closure method implementation to some interfaces as
    it provides quite a lot of flexibility when using the library. You can find this
    approach very often in Go code, being the most known the one of package `net/http`.
    The `HandleFunc` function which we used previously in the structural patterns
    to define a handler for an HTTP request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些接口中添加闭包方法实现非常有用，因为它在使用库时提供了相当大的灵活性。你可以在Go代码中经常发现这种方法，最著名的是`net/http`包的方法`HandleFunc`，我们之前在结构模式中使用它来定义HTTP请求的处理程序。
- en: Putting it together
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将其放在一起
- en: We learned a powerful tool to achieve dynamic processing of actions and state
    handling. The Chain of responsibility pattern is widely used, also to create **Finite
    State Machines** (**FSM**). It is also used interchangeably with the Decorator
    pattern with the difference that when you decorate, you change the structure of
    an object while with the chain you define a behavior for each link in the chain
    that can break it too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了一个强大的工具，可以实现动态处理操作和状态处理。责任链模式被广泛使用，也用于创建**有限状态机**（**FSM**）。它也可以与装饰者模式互换使用，不同之处在于装饰时改变对象的结构，而链式定义了链中每个链接的行为，也可能会破坏它。
- en: Command design pattern
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: To finish with this chapter, we will see also the **Command** pattern--a tiny
    design pattern but still frequently used. You need a way to connect types that
    are really unrelated? So design a Command for them.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还将看到**命令**模式--一个小型的设计模式，但仍然经常使用。需要一种方法来连接真正不相关的类型吗？那就为它们设计一个命令。
- en: Description
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The Command design pattern is quite similar to the Strategy design pattern but
    with key differences. While in the strategy pattern we focus on changing algorithms,
    in the Command pattern, we focus on the invocation of something or on the abstraction
    of some type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式与策略设计模式非常相似，但也有关键的区别。在策略模式中，我们专注于改变算法，而在命令模式中，我们专注于调用某些东西或者对某种类型进行抽象。
- en: A Command pattern is commonly seen as a container. You put something like the
    info for user interaction on a UI that could be `click on login` and pass it as
    a command. You don't need to have the complexity related to the `click on login`
    action in the command but simply the action itself.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常被视为一个容器。你可以将用户界面上的用户交互信息（如`点击登录`）放入命令中并传递。命令中不需要包含与`点击登录`操作相关的复杂性，只需要包含操作本身。
- en: An example for the organic world would be a box for a delivery company. We can
    put anything on it but, as a delivery company, we are interested in managing the
    box instead of its contents directly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有机世界的一个例子是快递公司的包裹。我们可以在上面放任何东西，但作为快递公司，我们更感兴趣的是管理包裹而不是直接管理其内容。
- en: The command pattern will be used heavily when dealing with channels. With channels
    you can send any message through it but, if we need a response from the receiving
    side of the channel, a common approach is to create a command that has a second,
    response channel attached where we are listening.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理通道时，命令模式将被大量使用。通过通道可以发送任何消息，但是，如果我们需要从通道的接收端获得响应，一种常见的方法是创建一个命令，附加一个第二个响应通道，我们在这里进行监听。
- en: Similarly, a good example would be a multi-player video game, where every stroke
    of each user can be sent as commands to the rest of the users through the network.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一个很好的例子是多人游戏，每个用户的每一次操作都可以通过网络发送给其他用户作为命令。
- en: Objectives
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'When using the Command design pattern, we are trying to encapsulate some sort
    of action or information in a light package that must be processed somewhere else.
    It''s similar to the Strategy pattern but, in fact, a Command could trigger a
    preconfigured Strategy somewhere else, so they are not the same. The following
    are the objectives for this design pattern:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命令设计模式时，我们试图将某种操作或信息封装在一个轻量级的包裹中，这个包裹必须在其他地方进行处理。这类似于策略模式，但实际上，命令可以触发其他地方预先配置的策略，因此它们并不相同。以下是这种设计模式的目标：
- en: Put some information into a box. Just the receiver will open the box and know
    its contents.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把一些信息放进一个盒子里。只有接收者才会打开盒子并知道其中的内容。
- en: Delegate some action somewhere else.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某些操作委托给其他地方。
- en: 'The behavior is also explained in the following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 行为也可以在以下图表中解释：
- en: '![Objectives](img/B05557_05_04.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![目标](img/B05557_05_04.jpg)'
- en: There we have a **Command** interface with a **Get() interface{}** method. We
    have a type **A** and a type **B**. The idea is that **A** and **B** implement
    the **Command** interface to return themselves as an `interface{}`. As now they
    implement **Command**, they can be used in a **Command handler** which doesn't
    care very much about the underlying type. Now **A** and **B** can travel through
    functions that handles commands or store Commands freely. But **B** handler can
    take an object from any **Command** handler to "unwrap" it and take its **B**
    content as well as **A** command handler with its `A` content.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个**命令**接口，带有一个**Get() interface{}**方法。我们有一个类型**A**和一个类型**B**。想法是**A**和**B**实现**命令**接口，将自己作为`interface{}`返回。现在它们实现了**命令**，它们可以在不太关心底层类型的**命令处理程序**中自由使用。现在**A**和**B**可以在处理命令的函数中传递或存储命令。但是**B**处理程序可以从任何**命令**处理程序中获取对象来“解包”它，并获取其**B**内容，以及**A**命令处理程序和其`A`内容。
- en: We put the information in a box (the **Command**) and delegate what to do with
    it to the handlers of Commands.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把信息放在一个盒子里（**命令**），并将如何处理它委托给命令的处理程序。
- en: A simple queue
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的队列
- en: Our first example is going to be pretty small. We will put some information
    into a Command implementer and we will have a queue. We will create many instances
    of a type implementing a Command pattern and we will pass them to a queue that
    will store the commands until three of them are in the queue, at which time it
    will process them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子将会很简单。我们将把一些信息放入一个命令实现者中，并创建一个队列。我们将创建许多实现命令模式的类型的实例，并将它们传递给一个队列，直到队列中有三个命令时，它将对它们进行处理。
- en: Acceptance criteria
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'So the ideal acceptance criteria to understand well the implications of the
    Command should reflect somehow the creation of a box that can accept unrelated
    types and the execution of the Command itself:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解命令的理想验收标准应该在某种程度上反映出可以接受不相关类型并执行命令本身的盒子的创建：
- en: We need a constructor of console printing commands. When using this constructor
    with a `string`, it will return a command that will print it. In this case, the
    handler is inside the command that acts as a box and as a handler.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个控制台打印命令的构造函数。当使用这个构造函数和一个 `string` 时，它将返回一个打印它的命令。在这种情况下，处理程序在充当盒子和处理程序的命令内部。
- en: We need a data structure that stores incoming commands in a queue and prints
    them once the queue reaches the length of three.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个数据结构，它可以将传入的命令存储在队列中，并在队列达到三个长度时打印它们。
- en: Implementation
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'This pattern is quite simple and we will write a few different examples so
    we''ll implement the library directly to keep things light and short. The classical
    Command design pattern usually has a common type structure with an `Execute` method.
    We are also going to use this structure as it''s quite flexible and simple:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常简单，我们将编写一些不同的示例，因此我们将直接实现库以保持轻便和简短。经典的命令设计模式通常具有具有 `Execute` 方法的通用类型结构。我们也将使用这个结构，因为它非常灵活和简单：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is generic enough to fill a lot of unrelated types! Think about it--we
    are going to create a type that prints to console when using the `Execute()` method
    but it could print a number or launch a rocket as well! The key here is to focus
    on invocations because the handlers are also in Command. So we need some type
    implementing this interface and printing to the console some sort of message:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够通用，可以填充很多不相关的类型！想想看——我们将创建一个类型，当使用 `Execute()` 方法时会打印到控制台，但它也可以打印数字或发射火箭！关键在于专注于调用，因为处理程序也在命令中。因此，我们需要一些实现这个接口并打印到控制台某种消息的类型：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ConsoleOutput` type implements the `Command` interface and prints to the
    console the member called `message`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConsoleOutput` 类型实现了 `Command` 接口，并打印了名为 `message` 的成员到控制台。'
- en: 'As defined in the first acceptance criterion, we need a `Command` constructor
    that accepts a message string and returns the `Command` interface. It will have
    the signature `func CreateCommand(s string) Command`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第一个验收标准的定义，我们需要一个接受消息字符串并返回 `Command` 接口的 `Command` 构造函数。它将具有签名 `func CreateCommand(s
    string) Command`：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the command `queue`, we''ll define a very simple type called `CommandQueue`
    to store in a queue any type implementing the `Command` interface:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令 `queue`，我们将定义一个非常简单的类型 `CommandQueue`，用于存储实现了 `Command` 接口的任何类型的队列：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `CommandQueue` type stores an array of the `Commands` interface. When the
    queue array reaches three items, it executes all the commands stored in the queue
    field. If it hasn't reached the required length yet, it just stores the command.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandQueue` 类型存储了一个 `Commands` 接口的数组。当队列数组达到三个项目时，它会执行队列字段中存储的所有命令。如果还没有达到所需的长度，它只是存储命令。'
- en: 'We will create five commands, enough to trigger the command queue mechanism,
    and add them to the queue. Each time a command is created, the message `Creating
    command` will be printed to the console. When we create the third command, the
    automatic command executor will be launched, printing the first three messages.
    We create and add two commands more, but because we haven''t reached the third
    command again, they won''t be printed and just the `Creating command` messages
    will be printed:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建五个命令，足以触发命令队列机制，并将它们添加到队列中。每次创建一个命令时，消息 `Creating command` 将被打印到控制台。当我们创建第三个命令时，自动命令执行器将被启动，打印前三条消息。我们创建并添加两个命令，但因为我们还没有再次达到第三个命令，它们不会被打印，只会打印
    `Creating command` 消息：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s run the `main` program. Our definition said that the commands are processed
    once every three messages and we will create a total of five messages. The first
    three messages must be printed but not the fourth and fifth because we didn''t
    reach a sixth message to trigger the command processing:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `main` 程序。我们的定义说，命令每三条消息处理一次，我们将创建总共五条消息。前三条消息必须被打印，但第四条和第五条不会被打印，因为我们没有达到第六条消息来触发命令处理：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, the fourth and fifth messages aren't printed, as expected, but
    we know that the commands were created and stored on the array. They just weren't
    processed because the queue was waiting for one command more to trigger the processor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，第四条和第五条消息没有被打印，这是预期的，但我们知道命令已经被创建并存储在数组中。它们只是没有被处理，因为队列正在等待一个命令来触发处理器。
- en: More examples
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多例子
- en: The previous example shows how to use a Command handler that executes the content
    of the command. But a common way to use a Command pattern is to delegate the information,
    instead of the execution, to a different object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了如何使用一个命令处理程序来执行命令的内容。但使用命令模式的常见方式是将信息委托给不同的对象，而不是执行。
- en: 'For example, instead of printing to the console, we will create a command that
    extracts information:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将创建一个提取信息的命令，而不是打印到控制台：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this case, our `Command` interface will have a method named `Info` that
    will retrieve some information from its implementor. We will create two implementations;
    one will return the time passed since the creation of the command to its execution:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的 `Command` 接口将有一个名为 `Info` 的方法，它将从其实现者那里检索一些信息。我们将创建两个实现；一个将返回自创建命令到执行之间经过的时间：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `time.Since` function returns the time elapsed since the time stored in
    the provided parameter. We returned the string representation of the passed time
    by calling the `String()` method on the `time.Time` type. The second implementation
    of our new `Command` will return the message `Hello World!`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Since` 函数返回自提供参数中存储的时间以来经过的时间。我们通过调用 `time.Time` 类型的 `String()` 方法返回传递时间的字符串表示。我们的新
    `Command` 的第二个实现将返回消息 `Hello World!`：'
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And our `main` function will simply create an instance of each type, then waits
    for a second and print the info returned from each `Command`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数将简单地创建每种类型的实例，然后等待一秒，并打印每个`Command`返回的信息：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `time.Sleep` function stops the execution of the current goroutine for the
    specified period (a second). So, to recall--the `timeCommand` variable stores
    the time when the program was started and its `Info()` method returns a string
    representation of the time that passed since we give a value to the type to the
    moment were we called the `Info()` method on it. The `helloCommand` variable returns
    the message `Hello World!` when we call its `Info()` method. Here we haven't implemented
    a `Command` handler again to keep things simple but we can consider the console
    as the handler because we can only print ASCII characters on it like the ones
    retrieved by the `Info()` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep`函数会暂停当前goroutine的执行指定的时间（一秒）。因此，回顾一下，`timeCommand`变量存储了程序启动时的时间，它的`Info()`方法返回了自我们给定类型值到调用`Info()`方法时经过的时间的字符串表示。`helloCommand`变量在调用其`Info()`方法时返回消息`Hello
    World!`。这里我们没有再次实现`Command`处理程序，以保持简单，但我们可以将控制台视为处理程序，因为我们只能在控制台上打印ASCII字符，就像`Info()`方法检索到的字符一样。'
- en: 'Let''s run the `main` function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`main`函数：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here we are. In this case, we retrieve some information by using the Command
    pattern. One type stores `time` information while the other stores nothing and
    it simply returns the same simple string. Each time we run the `main` function
    will return a different elapsed time, so don't worry if the time doesn't match
    with the one in the example.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这里。在这种情况下，我们使用命令模式来检索一些信息。一个类型存储`time`信息，而另一个类型不存储任何信息，只是返回相同的简单字符串。每次运行`main`函数都会返回不同的经过时间，所以不用担心时间与示例中的时间不匹配。
- en: Chain of responsibility of commands
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令的责任链
- en: Do you remember the chain of responsibility design pattern? We were passing
    a `string` message between links to print its contents. But we could be using
    the previous Command to retrieve information for logging to the console. We'll
    mainly reuse the code that we have written already.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得责任链设计模式吗？我们之前是在链接之间传递`string`消息来打印其内容。但我们也可以使用之前的命令来检索信息并记录到控制台上。我们将主要重用我们已经编写的代码。
- en: 'The `Command` interface will be from the type interface that returns a `string`
    from the previous example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`接口将是前面示例中返回`string`的接口类型：'
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will use the `Command` implementation of the `TimePassed` type too:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`TimePassed`类型的`Command`实现：
- en: '[PRE55]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember that this type returns the elapsed time from the object creation on
    its `Info() string` method. We also need the `ChainLogger` interface from the
    *Chain of responsibility design pattern* section of this chapter but, this time,
    it will pass Commands on its `Next` method instead of `string`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种类型返回的是从对象创建到其`Info() string`方法的经过时间。我们还需要来自本章*责任链设计模式*部分的`ChainLogger`接口，但这次它将在其`Next`方法中传递`Command`而不是`string`：
- en: '[PRE56]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We''ll use just the same type for two links in the chain for simplicity. This
    link is very similar to the `FirstLogger` type from the chain of responsibility
    example, but this time it will append the message `Elapsed time from creation:`
    and it will wait 1 second before printing. We''ll call it `Logger` instead of
    `FirstLogger`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将在链中使用相同的类型作为两个链接。这个链接与责任链示例中的`FirstLogger`类型非常相似，但这次它会附加消息`Elapsed
    time from creation:`，并且在打印之前等待1秒。我们将其称为`Logger`而不是`FirstLogger`：
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, we need a `main` function to execute the chain that takes `Command`
    pointers:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`main`函数来执行接受`Command`指针的链：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Line by line, we create a variable called `second` with a pointer to a `Logger`;
    this is going to be the second link in our chain. Then we create a variable called
    `first`, that will be the first link in the chain. The first link points to the
    `second` variable, the second link in the chain.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行创建一个名为`second`的变量，指向`Logger`的指针；这将成为我们链中的第二个链接。然后创建一个名为`first`的变量，它将成为链中的第一个链接。第一个链接指向`second`变量，即链中的第二个链接。
- en: Then, we create an instance of `TimePassed` to use it as the `Command` type.
    The start time of this command is the execution time (the `time.Now()` method
    returns the time in the moment of the execution).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`TimePassed`的实例来用作`Command`类型。这个命令的开始时间是执行时间（`time.Now()`方法返回执行时的时间）。
- en: 'Finally, we pass the `Command` interface to the chain on the `first.Next(command)`
    statement. The output of this program is the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`Command`接口传递给链的`first.Next(command)`语句。该程序的输出如下：
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The resulting output is reflected in the following diagram: The command with
    the time field is pushed to the first link that knows how to execute Commands
    of any type. Then it passes the Command to the second link that also knows how
    to execute Commands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出反映在以下图表中：带有时间字段的命令被推送到知道如何执行任何类型命令的第一个链接。然后它将命令传递给第二个链接，它也知道如何执行命令：
- en: This approach hides the complexity behind each `Command` execution from the
    Command handlers on each link. The functionality hidden behind a Command can be
    simple or incredibly complex but the idea here is to reuse the handler to manage
    many types of unrelated implementations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将每个`Command`执行的复杂性隐藏在每个链接的命令处理程序后面。命令背后隐藏的功能可以是简单的，也可以是非常复杂的，但这里的想法是重用处理程序来管理许多不相关实现的类型。
- en: Rounding-up the Command pattern up
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结命令模式
- en: Command is a very tiny design pattern; its functionality is quite easy to understand
    but it's widely used for its simplicity. It looks very similar to the Strategy
    pattern but remember that Strategy is about having many algorithms to achieve
    some specific task, but all of them achieve the same task. In the Command pattern,
    you have many tasks to execute, and not all of them need to be equal.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是一个非常微小的设计模式；它的功能非常容易理解，但由于其简单性而被广泛使用。它看起来非常类似于策略模式，但请记住，策略是关于拥有许多算法来实现特定任务，但所有这些算法都实现了相同的任务。在命令模式中，您有许多任务需要执行，并不是所有的任务都需要相等。
- en: So, in short, the Command pattern is about execution encapsulation and delegation
    so that just the receiver or receivers trigger that execution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，命令模式是关于执行封装和委托，以便只有接收者或接收者触发该执行。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have taken our first steps in the Behavioral patterns. The objective of this
    chapter was to introduce the reader to the concept of algorithm and execution
    encapsulation using proper interfaces and structures. With the strategy, we have
    encapsulated algorithms, with the chain of responsibility handlers and with the
    Command design pattern executions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经迈出了行为模式的第一步。本章的目标是向读者介绍使用适当的接口和结构来封装算法和执行的概念。通过策略，我们封装了算法，通过责任链处理程序和命令设计模式执行。
- en: Now, with the knowledge we have acquired about the strategy pattern, we can
    uncouple heavily our applications from their algorithms, just for testing, this
    is a very useful feature to inject mocks in different types that would be almost
    impossible to test. But also for anything that could need different approaches
    based on some context (such as shorting a list; some algorithms perform better
    depending on the distribution of the list).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过我们对策略模式的了解，我们可以将应用程序与其算法大大解耦，仅用于测试，这是一个非常有用的功能，可以在几乎不可能测试的不同类型中注入模拟。但也适用于任何可能根据某些上下文需要不同方法的情况（例如对列表进行排序；根据列表的分布，某些算法的性能会更好）。
- en: The Chain of Responsibility pattern opens the door of middleware of any type
    and plugin-like libraries to improve the functionality of some part. Many open
    source projects uses a Chain of Responsibility to handler HTTP requests and responses
    to extract information to the end user (such as cookies info) or check authentication
    details (I'll let you pass to the next link only if I have you on my database).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链模式打开了任何类型的中间件和类似插件的库的大门，以改进某些部分的功能。许多开源项目使用责任链来处理HTTP请求和响应，以提取信息给最终用户（例如cookie信息）或检查身份验证细节（只有在我的数据库中有您的情况下，我才会让您通过到下一个链接）。
- en: Finally, the Command pattern is the most common pattern for UI handling but
    also very useful in many other scenarios where we need some type of handling between
    many unrelated types that are travelling through the code (such as a message passed
    through a channel).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，命令模式是UI处理中最常见的模式，但在许多其他场景中也非常有用，其中我们需要在代码中传递许多不相关类型之间进行某种处理（例如通过通道传递的消息）。
