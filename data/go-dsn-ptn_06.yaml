- en: Chapter 6. Behavioral Patterns - Template, Memento, and Interpreter Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 行为模式 - 模板、备忘录和解释器设计模式
- en: In this chapter, we will see the next three Behavioral design patterns. The
    difficulty is being raised as now we will use combinations of Structural and Creational
    patterns to better solve the objective of some of the Behavioral patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到接下来的三种行为设计模式。难度正在提高，因为现在我们将使用结构和创建模式的组合来更好地解决一些行为模式的目标。
- en: We will start with Template design pattern, a pattern that looks very similar
    to the Strategy pattern but that provides greater flexibility. Memento design
    pattern is used in 99% of applications we use every day to achieve undo functions
    and transactional operations. Finally, we will write a reverse polish notation
    interpreter to perform simple mathematical operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从模板设计模式开始，这是一种看起来非常类似于策略模式但提供更大灵活性的模式。备忘录设计模式在我们每天使用的99%的应用程序中使用，以实现撤销功能和事务操作。最后，我们将编写一个逆波兰符号解释器来执行简单的数学运算。
- en: Let's start with the Template design pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模板设计模式开始。
- en: Template design pattern
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板设计模式
- en: The **Template** pattern is one of those widely used patterns that are incredibly
    useful, especially when writing libraries and frameworks. The idea is to provide
    a user some way to execute code within an algorithm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板**模式是那些广泛使用的模式之一，特别是在编写库和框架时非常有用。其思想是为用户提供一种在算法中执行代码的方式。'
- en: In this section, we will see how to write idiomatic Go Template patterns and
    see some Go source code where it's wisely used. We will write an algorithm of
    three steps where the second step is delegated to the user while the first and
    third aren't. The first and third steps on the algorithm represent the template.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何编写成语法Go模板模式，并查看一些智能使用的Go源代码。我们将编写一个三步算法，其中第二步委托给用户，而第一步和第三步则不是。算法中的第一步和第三步代表模板。
- en: Description
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: While with the Strategy pattern we were encapsulating algorithm implementation
    in different strategies, with the Template pattern we will try to achieve something
    similar but with just part of the algorithm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与策略模式封装算法实现在不同的策略中不同，模板模式将尝试实现类似的功能，但只是算法的一部分。
- en: The Template design pattern lets the user write a part of an algorithm while
    the rest is executed by the abstraction. This is common when creating libraries
    to ease in some complex task or when reusability of some algorithm is compromised
    by only a part of it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模板设计模式允许用户在算法的一部分中编写代码，而其余部分由抽象执行。这在创建库以简化某些复杂任务或者某些算法的可重用性仅受其一部分影响时很常见。
- en: 'Imagine, for example, that we have a long transaction of HTTP requests. We
    have to perform the following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个长时间的HTTP请求事务。我们必须执行以下步骤：
- en: Authenticate user.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证用户。
- en: Authorize him.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权他。
- en: Retrieve some details from a database.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中检索一些详细信息。
- en: Make some modification.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行一些修改。
- en: Send the details back in a new request.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将详细信息发送回一个新的请求。
- en: It wouldn't make sense to repeat steps 1 to 5 in the user's code every time
    he needs to modify something on the database. Instead, steps 1, 2, 3, and 5 will
    be abstracted in the same algorithm that receives an interface with whatever the
    fifth step needs to finish the transaction. It doesn't need to be a interface
    either, it could be a callback.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复步骤1到5在用户的代码中，每次他需要修改数据库中的内容。相反，步骤1、2、3和5将被抽象成相同的算法，该算法接收一个接口，其中包含第五步需要完成事务的内容。它也不需要是一个接口，它可以是一个回调。
- en: Objectives
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The Template design pattern is all about reusability and giving responsibilities
    to the user. So the objectives for this pattern are following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模板设计模式关乎可重用性和将责任交给用户。因此，这种模式的目标如下：
- en: Defer a part of an algorithm of the library to a the user
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库的算法的一部分延迟给用户。
- en: Improve reusability by abstracting the parts of the code that are not common
    between executions
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过抽象代码的部分来提高可重用性，这些部分在执行之间是不常见的
- en: Example - a simple algorithm with a deferred step
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 一个包含延迟步骤的简单算法
- en: In our first example, we are going to write an algorithm that is composed of
    three steps and each of them returns a message. The first and third steps are
    controlled by the Template and just the second step is deferred to the user.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将编写一个由三个步骤组成的算法，每个步骤都返回一个消息。第一步和第三步由模板控制，只有第二步延迟到用户。
- en: Requirements and acceptance criteria
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'A brief description of what the Template pattern has to do is to define a template
    for an algorithm of three steps that defers the implementation of the second step
    to the user:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式必须做的事情的简要描述是定义一个算法的模板，其中包括三个步骤，将第二步的实现延迟到用户：
- en: Each step in the algorithm must return a string.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法中的每个步骤必须返回一个字符串。
- en: The first step is a method called `first()` and returns the string `hello`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是一个名为`first()`的方法，返回字符串`hello`。
- en: The third step is a method called `third()` and returns the string `template`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是一个名为`third()`的方法，返回字符串`template`。
- en: The second step is whatever string the user wants to return but it's defined
    by the `MessageRetriever` interface that has a `Message() string` method.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是用户想要返回的任何字符串，但它由`MessageRetriever`接口定义，该接口具有`Message() string`方法。
- en: The algorithm is executed sequentially by a method called `ExecuteAlgorithm`
    and returns the strings returned by each step joined in a single string by a space.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法由一个名为`ExecuteAlgorithm`的方法顺序执行，并返回每个步骤返回的字符串，这些字符串由一个空格连接在一起。
- en: Unit tests for the simple algorithm
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单算法的单元测试
- en: 'We will focus on testing the public methods only. This is a very common approach.
    All in all, if your private methods aren''t called from some level of the public
    ones, they aren''t called at all. We need two interfaces here, one for the Template
    implementors and one for the abstract step of the algorithm:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于仅测试公共方法。这是一个非常常见的方法。总的来说，如果你的私有方法没有从公共方法的某个级别被调用，它们根本就没有被调用。我们需要两个接口，一个用于模板实现者，一个用于算法的抽象步骤：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A Template implementor will accept a `MessageRetriever` interface to execute
    as part of its execution algorithm. We need a type that implements this interface
    called `Template`, we will call it `TemplateImpl`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实现者将接受一个`MessageRetriever`接口作为其执行算法的一部分。我们需要一个实现这个接口的类型，称为`Template`，我们将称之为`TemplateImpl`：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So our first test checks the fourth and fifth acceptance criteria. We will
    create the `TestStruct` type that implements the `MessageRetriever` interface
    returning the string `world` and has embedded the Template so that it can call
    the `ExecuteAlgorithm` method. It will act as the Template and the abstraction:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的第一个测试检查了第四和第五个验收标准。我们将创建一个实现`MessageRetriever`接口的`TestStruct`类型，返回字符串`world`并嵌入模板，以便它可以调用`ExecuteAlgorithm`方法。它将充当模板和抽象：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we will define the `TestStruct` type. In this case, the part of the algorithm
    deferred to us is going to return the `world` text. This is the string we will
    look for later in the test doing a check of type "is the word `world` present
    on this string?".
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义`TestStruct`类型。在这种情况下，我们需要延迟到我们的算法的部分将返回`world`文本。这是我们稍后在测试中要查找的字符串，进行类型检查“这个字符串中是否存在`world`这个词？”。
- en: Take a close look, the `TestStruct` embeds a type called `Template` which represents
    the Template pattern of our algorithm.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，`TestStruct`嵌入了一个名为`Template`的类型，它代表了我们算法的模板模式。
- en: 'When we implement the `Message()` method, we are implicitly implementing the
    `MessageRetriever` interface. So now we can use `TestStruct` type as a pointer
    to a `MessageRetriever` interface:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现`Message()`方法时，我们隐式地实现了`MessageRetriever`接口。所以现在我们可以将`TestStruct`类型用作`MessageRetriever`接口的指针：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the test, we will use the type we have just created. When we call the `ExecuteAlgorithm`
    method, we need to pass the `MessageRetriever` interface. As the `TestStruct`
    type also implements the `MessageRetriever` interface, we can pass it as an argument,
    but this is not mandatory, of course.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们将使用刚刚创建的类型。当我们调用`ExecuteAlgorithm`方法时，我们需要传递`MessageRetriever`接口。由于`TestStruct`类型也实现了`MessageRetriever`接口，我们可以将其作为参数传递，但这当然不是强制的。
- en: The result of the `ExecuteAlgorithm` method, as defined in the fifth acceptance
    criterion, must return a string that contains the returned value of the `first()` method,
    the returned value of `TestStruct` (the `world` string) and the returned value
    of the `third()` method separated by a space. Our implementation is on the second
    place; that's why we checked that a space is prefixed and suffixed on the string
    `world`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第五个验收标准中定义的`ExecuteAlgorithm`方法的结果，必须返回一个字符串，其中包含`first()`方法的返回值，`TestStruct`的返回值（`world`字符串）和`third()`方法的返回值，它们之间用一个空格分隔。我们的实现在第二个位置；这就是为什么我们检查了字符串`world`前后是否有空格。
- en: So, if the returned string, when calling the `ExecuteAlgorithm` method, doesn't
    contain the string `world`, the test fails.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用`ExecuteAlgorithm`方法时返回的字符串不包含字符串`world`时，测试失败。
- en: 'This is enough to make the project compile and run the tests that should fail:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足够使项目编译并运行应该失败的测试：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Time to pass to the implementation of this pattern.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候转向实现这种模式了。
- en: Implementing the Template pattern
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现模板模式
- en: 'As defined in the acceptance criteria, we have to return the string `hello`
    in the `first()` method and the string `template` in the `third()` method. That''s
    pretty easy to implement:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据验收标准的定义，我们必须在`first()`方法中返回字符串`hello`，在`third()`方法中返回字符串`template`。这很容易实现：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this implementation, we should be covering the *second* and *third* acceptance
    criteria and partially covering the *first* criterion (each step in the algorithm
    must return a string).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，我们应该覆盖*第二*和*第三*个验收标准，并部分覆盖*第一个*标准（算法中的每个步骤必须返回一个字符串）。
- en: 'To cover the *fifth* acceptance criterion, we define an `ExecuteAlgorithm`
    method that accepts the `MessageRetriever` interface as argument and returns the
    full algorithm: a single string done by joining the strings returned by the `first()`,
    `Message() string` and `third()` methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足*第五*个验收标准，我们定义了一个`ExecuteAlgorithm`方法，它接受`MessageRetriever`接口作为参数，并返回完整的算法：通过连接`first()`、`Message()
    string`和`third()`方法返回的字符串来完成：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `strings.Join` function has the following signature:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.Join`函数具有以下签名：'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It takes an array of strings and joins them, placing the second argument between
    each item in the array. In our case, we create a string array on the fly to pass
    it as the first argument. Then we pass a whitespace as the second argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个字符串数组并将它们连接起来，将第二个参数放在数组中的每个项目之间。在我们的情况下，我们创建一个字符串数组，然后将其作为第一个参数传递。然后我们传递一个空格作为第二个参数。
- en: 'With this implementation, the tests must be passing already:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种实现，测试必须已经通过了：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The tests passed. The test has checked that the string `world` is present in
    the returned result, which is the `hello world template` message. The `hello` text
    was the string returned by the `first()` method, the `world` string was returned
    by our `MessageRetriever` implementation, and `template` was the string returned
    by the `third()` method. The whitespaces are inserted by Go's `strings.Join` function.
    But any use of the `TemplateImpl.ExecuteAlgorithm` type will always return "hello
    [something] template" in its result.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通过了。测试已经检查了返回结果中是否存在字符串`world`，这是`hello world template`消息。`hello`文本是`first()`方法返回的字符串，`world`字符串是我们的`MessageRetriever`实现返回的，`template`是`third()`方法返回的字符串。空格是由Go的`strings.Join`函数插入的。但是，任何对`TemplateImpl.ExecuteAlgorithm`类型的使用都将始终在其结果中返回“hello
    [something] template”。
- en: Anonymous functions
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: This is not the only way to achieve the Template design pattern. We can also
    use an anonymous function to give our implementation to the `ExecuteAlgorithm`
    method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是实现模板设计模式的唯一方法。我们还可以使用匿名函数将我们的实现传递给`ExecuteAlgorithm`方法。
- en: 'Let''s write a test in the same method that was used previously just after
    the test (marked in bold):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前使用的相同方法中编写一个测试，就在测试之后（用粗体标记）：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our new test is called *Using anonymous functions*. We have also extracted the
    checking on the test to an external function to reuse it in this test. We have
    called this function `expectedOrError` because it will fail with an error if the
    expected value isn't received.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新测试被称为*使用匿名函数*。我们还将测试中的检查提取到一个外部函数中，以便在这个测试中重用它。我们将这个函数称为`expectedOrError`，因为如果没有收到预期的值，它将失败并抛出错误。
- en: In our test, we will create a type called `AnonymousTemplate` that replaces
    the previous `Template` type. The `ExecuteAlgorithm` method of this new type accepts
    the `func()` method `string` type that we can implement directly in the test to
    return the string `world`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将创建一个名为`AnonymousTemplate`的类型，用它来替换之前的`Template`类型。这个新类型的`ExecuteAlgorithm`方法接受`func()
    string`类型的方法，我们可以直接在测试中实现它来返回字符串`world`。
- en: 'The `AnonymousTemplate` type will have the following structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnonymousTemplate`类型将具有以下结构：'
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The only difference with the `Template` type is that the `ExecuteAlgorithm`
    method accepts a function that returns a string instead of a `MessageRetriever`
    interface. Let''s run the new test:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Template`类型的唯一区别是`ExecuteAlgorithm`方法接受一个返回字符串的函数，而不是`MessageRetriever`接口。让我们运行新的测试：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can read in the output of the test execution, the error is thrown on
    the *Using anonymous functions* test, which is what we were expecting. Now we
    will write the implementation as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在测试执行的输出中所读到的，错误是在*使用匿名函数*测试中抛出的，这正是我们所期望的。现在我们将按照以下方式编写实现：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The implementation is quite similar to the one in the `Template` type. However,
    now we have passed a function called `f` that we will use as the second item in
    the string array we used on `Join` function. As `f` is simply a function that
    returns a string, the only thing we need to do with it is to execute it in the
    proper place (the second position in the array).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与`Template`类型中的实现非常相似。然而，现在我们传递了一个名为`f`的函数，我们将在`Join`函数中使用它作为字符串数组中的第二项。由于`f`只是一个返回字符串的函数，我们需要做的唯一事情就是在正确的位置执行它（数组中的第二个位置）。
- en: 'Run the tests again:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Awesome! Now we know two ways to implement the Template design pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们知道两种实现模板设计模式的方法。
- en: How to avoid modifications on the interface
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何避免对接口进行修改
- en: The problem of the previous approach is that now we have two templates to maintain
    and we could end duplicating code. What can we do in the situation that we cannot
    change the interface are we using? Our interface was `MessageRetriever` but we
    want to use an anonymous function now.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之前方法的问题是现在我们有两个模板需要维护，我们可能会重复代码。在我们使用的接口不能更改的情况下，我们该怎么办？我们的接口是`MessageRetriever`，但现在我们想要使用一个匿名函数。
- en: 'Well, do you remember the Adapter design pattern? We just have to create an
    `Adapter` type that, accepting a `func() string` type, returns an implementation
    of the `MessageRetriever` interface. We will call this type `TemplateAdapter`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你还记得适配器设计模式吗？我们只需要创建一个`Adapter`类型，它接受一个`func() string`类型，返回一个`MessageRetriever`接口的实现。我们将称这个类型为`TemplateAdapter`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, the `TemplateAdapter` type has a field called `myFunc` which
    is of type `func() string`. We have also defined adapter as private because it
    shouldn''t be used without a function defined in the `myFunc` field. We have created
    a public function called the `MessageRetrieverAdapter` to achieve this. Our test
    should look more or less like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`TemplateAdapter`类型有一个名为`myFunc`的字段，它的类型是`func() string`。我们还将适配器定义为私有，因为在没有在`myFunc`字段中定义函数的情况下，它不应该被使用。我们创建了一个名为`MessageRetrieverAdapter`的公共函数来实现这一点。我们的测试应该看起来是这样的：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Look at the statement where we called the `MessageRetrieverAdapter` method.
    We passed an anonymous function as an argument defined as `func()` string. Then,
    we reuse the previously defined `Template` type from our first test to pass the
    `messageRetriever` variable. Finally, we checked again with the `expectedOrError`
    method. Take a look at the `MessageRetrieverAdapter` method, it will return a
    function that has nil value. If strictly following the test-driven development
    rules, we must do tests first and they must not pass before implementation is
    done. That's why we returned nil on the `MessageRetrieverAdapter` function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们调用`MessageRetrieverAdapter`方法的语句。我们传递了一个匿名函数作为参数，定义为`func() string`。然后，我们重用了我们第一个测试中定义的`Template`类型来传递`messageRetriever`变量。最后，我们再次使用`expectedOrError`方法进行检查。看一下`MessageRetrieverAdapter`方法，它将返回一个具有nil值的函数。如果严格遵循测试驱动开发规则，我们必须先进行测试，实现完成之前测试不能通过。这就是为什么我们在`MessageRetrieverAdapter`函数中返回nil。
- en: 'So, let''s run the tests:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们运行测试：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The test fails on *line 39* of the code and it doesn't continue (again, depending
    on how you wrote your code, the line representing your error could be somewhere
    else). We stop test execution because we will need a valid `MessageRetriever`
    interface when we call the `ExecuteAlgorithm` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的*第39行*测试失败，而且没有继续执行（再次取决于你如何编写你的代码，表示错误的行可能在其他地方）。我们停止测试执行，因为当我们调用`ExecuteAlgorithm`方法时，我们将需要一个有效的`MessageRetriever`接口。
- en: 'For the implementation of the adapter for our Template pattern, we will start
    with `MessageRetrieverAdapter` method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Template模式的适配器实现，我们将从`MessageRetrieverAdapter`方法开始：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It's very easy, right? You could be wondering what happens if we pass `nil` value
    for the `f` argument. Well, we will cover this issue by calling the `myFunc` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易，对吧？你可能会想知道如果我们为`f`参数传递`nil`值会发生什么。好吧，我们将通过调用`myFunc`函数来解决这个问题。
- en: 'The `adapter` type is finished with this implementation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`adapter`类型通过这个实现完成了：'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When calling the `Message()` function, we check that we actually have something
    stored in the `myFunc` function before calling. If nothing was stored, we return
    an empty string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Message()`函数时，我们检查在调用之前`myFunc`函数中是否实际存储了东西。如果没有存储任何东西，我们返回一个空字符串。
- en: 'Now, our third implementation of the `Template` type, using the Adapter pattern,
    is done:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用适配器模式实现的`Template`类型的第三个实现已经完成：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Looking for the Template pattern in Go's source code
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Go的源代码中寻找模板模式
- en: The `Sort` package in Go's source code can be considered a Template implementation
    of a sort algorithm. As defined in the package itself, the `Sort` package provides
    primitives for sorting slices and user-defined collections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的源代码中，`Sort`包可以被认为是一个排序算法的模板实现。正如包本身所定义的那样，`Sort`包提供了对切片和用户定义集合进行排序的基本操作。
- en: 'Here, we can also find a good example of why Go authors aren''t worried about
    implementing generics. Sorting the lists is maybe the best example of generic
    usage in other languages. The way that Go deals with this is very elegant too-it
    deals with this issue with an interface:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还可以找到一个很好的例子，说明为什么Go的作者不担心实现泛型。在其他语言中，对列表进行排序可能是泛型使用的最佳例子。Go处理这个问题的方式也非常优雅-它通过接口来处理这个问题：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the interface for lists that need to be sorted by using the `sort`
    package. In the words of Go''s authors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要使用`sort`包进行排序的列表的接口。用Go的作者的话来说：
- en: '*"A type, typically, is a collection that satisfies sort. Interface can be
    sorted by the routines in this package. The methods require that the elements
    of the collection be enumerated by an integer index."*'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个类型，通常是一个集合，满足sort.Interface可以通过这个包中的例程进行排序。这些方法要求集合的元素通过整数索引进行枚举。"*'
- en: In other words, write a type that implements this `Interface` so that the `Sort`
    package can be used to sort any slice. The sorting algorithm is the template and
    we must define how to retrieve values in our slice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，编写一个实现这个`Interface`的类型，以便`Sort`包可以用来对任何切片进行排序。排序算法是模板，我们必须定义如何检索我们切片中的值。
- en: 'If we peek in the `sort` package, we can also find an example of how to use
    the sorting template but we will create our own example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`sort`包，我们还可以找到一个使用排序模板的示例，但我们将创建我们自己的示例：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we have done a very simple type that stores an `int` list. This could
    be any kind of list, usually a list of some kind of struct. Then we have implemented
    the `sort.Interface` interface by defining the `Len`, `Swap`, and `Less` methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们做了一个非常简单的存储`int`列表的类型。这可以是任何类型的列表，通常是某种结构的列表。然后，我们通过定义`Len`、`Swap`和`Less`方法来实现`sort.Interface`接口。
- en: 'Finally, the `main` function creates an unordered list of numbers of the `MyList`
    type:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main`函数创建了一个`MyList`类型的无序数字列表：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We print the list that we created (unordered) and then we sort it (the `sort.Sort`
    method actually modifies our variable instead of returning a new list so beware!).
    Finally, we print again the resulting list. The console output of this `main`
    method is the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印我们创建的列表（无序），然后对其进行排序（`sort.Sort`方法实际上修改了我们的变量，而不是返回一个新列表，所以要小心！）。最后，我们再次打印结果列表。这个`main`方法的控制台输出如下：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `sort.Sort` function has sorted our list in a transparent way. It has a
    lot of code written and delegates `Len`, `Swap` and `Less` methods to an interface,
    like we did in our template delegating to the `MessageRetriever` interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort.Sort`函数以透明的方式对我们的列表进行了排序。它有很多代码编写，并将`Len`、`Swap`和`Less`方法委托给一个接口，就像我们在我们的模板中委托给`MessageRetriever`接口一样。'
- en: Summarizing the Template design pattern
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结模板设计模式
- en: We wanted to put a lot of focus on this pattern because it is very important
    when developing libraries and frameworks and allows a lot of flexibility and control
    to users of our library.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在这个模式上放很多重点，因为在开发库和框架时非常重要，并且允许我们的库的用户有很大的灵活性和控制。
- en: We have also seen again that it's very common to mix patterns to provide flexibility
    to the users, not only in a behavioral way but also structural. This will come
    very handy when working with concurrent apps where we need to restrict access
    to parts of our code to avoid races.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了混合模式是非常常见的，以提供灵活性给用户，不仅在行为上，而且在结构上。当我们需要限制对我们代码的某些部分的访问以避免竞争时，这将非常有用。
- en: Memento design pattern
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录设计模式
- en: 'Let''s now look at a pattern with a fancy name. If we check a dictionary to
    see the meaning of *memento*, we will find the following description:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个有着花哨名字的模式。如果我们查字典查看*memento*的含义，我们会找到以下描述：
- en: '*"An object kept as a reminder of a person or event."*'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"作为对某人或事件的提醒而保留的对象。"*'
- en: Here, the key word is **reminder** as we will remember actions with this design
    pattern.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，关键词是**reminder**，因为我们将用这种设计模式来记住动作。
- en: Description
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The meaning of memento is very similar to the functionality it provides in design
    patterns. Basically, we'll have a type with some state and we want to be able
    to save milestones of its state. Having a finite amount of states saved, we can
    recover them if necessary for a variety of tasks-undo operations, historic, and
    so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录的含义与它在设计模式中提供的功能非常相似。基本上，我们将有一个带有一些状态的类型，我们希望能够保存其状态的里程碑。保存有限数量的状态后，我们可以在需要时恢复它们，以执行各种任务-撤销操作、历史记录等。
- en: 'The Memento design pattern usually has three players (usually called **actors**):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录设计模式通常有三个参与者（通常称为**演员**）：
- en: '**Memento**: A type that stores the type we want to save. Usually, we won''t
    store the business type directly and we provide an extra layer of abstraction
    through this type.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：存储我们想要保存的类型的类型。通常，我们不会直接存储业务类型，而是通过这种类型提供额外的抽象层。'
- en: '**Originator**: A type that is in charge of creating mementos and storing the
    current active state. We said that the Memento type wraps states of the business
    type and we use originator as the creator of mementos.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发起者**：负责创建备忘录并存储当前活动状态的类型。我们说备忘录类型包装了业务类型的状态，我们使用发起者作为备忘录的创建者。'
- en: '**Care Taker**: A type that stores the list of mementos that can have the logic
    to store them in a database or to not store more than a specified number of them.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Care Taker**：一种存储备忘录列表的类型，可以具有将它们存储在数据库中或不存储超过指定数量的逻辑。'
- en: Objectives
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: Memento is all about a sequence of actions over time, say to undo one or two
    operations or to provide some kind of transactionality to some application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录完全是关于随时间的一系列操作，比如撤消一两个操作或为某个应用程序提供某种事务性。
- en: 'Memento provides the foundations for many tasks, but its main objectives could
    be defined as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录为许多任务提供了基础，但其主要目标可以定义如下：
- en: Capture an object state without modifying the object itself
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获对象状态而不修改对象本身
- en: Save a limited amount of states so we can retrieve them later
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存有限数量的状态，以便以后可以检索它们。
- en: A simple example with strings
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的字符串示例
- en: We will develop a simple example using a string as the state we want to save.
    This way, we will focus on the common Memento pattern implementations before making
    it a bit more complex with a new example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字符串作为要保存的状态的简单示例。这样，我们将在使其变得更加复杂之前，专注于常见的备忘录模式实现。
- en: The string, stored in a field of a `State` instance, will be modified and we
    will be able to undo the operations done in this state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`State`实例的字段中的字符串将被修改，我们将能够撤消在此状态下进行的操作。
- en: Requirements and acceptance criteria
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求和验收标准
- en: 'We are constantly talking about state; all in all, the Memento pattern is about
    storing and retrieving states. Our acceptance criteria must be all about states:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不断谈论状态；总之，备忘录模式是关于存储和检索状态的。我们的验收标准必须完全关于状态：
- en: We need to store a finite amount of states of type string.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要存储有限数量的字符串类型的状态。
- en: We need a way to restore the current stored state to one of the state list.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种方法来将当前存储的状态恢复到状态列表中的一个。
- en: With these two simple requirements, we can already start writing some tests
    for this example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个简单的要求，我们就可以开始为这个示例编写一些测试了。
- en: Unit test
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'As mentioned previously, the Memento design pattern is usually composed of
    three actors: state, memento, and originator. So we will need three types to represent
    these actors:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，备忘录设计模式通常由三个角色组成：状态、备忘录和originator。因此，我们将需要三种类型来表示这些角色：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `State` type is the core business object we will be using during this example.
    It''s any kind of object that we want to track:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`类型是我们在本例中将使用的核心业务对象。它是我们想要跟踪的任何类型的对象：'
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `memento` type has a field called `state` representing a single value of
    a `State` type. Our `states` will be containerized within this type before storing
    them into the `care taker` type. You could be wondering why we don''t store directly
    `State` instances. Basically, because it will couple the `originator` and the
    `careTaker` to the business object and we want to have as little coupling as possible.
    It will also be less flexible, as we will see in the second example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`memento`类型有一个名为`state`的字段，表示`State`类型的单个值。在将它们存储到`care taker`类型之前，我们的`states`将被封装在这种类型中。您可能会想知道为什么我们不直接存储`State`实例。基本上，因为这将使`originator`和`careTaker`与业务对象耦合在一起，而我们希望尽可能少地耦合。这也将更不灵活，正如我们将在第二个例子中看到的：'
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `originator` type also stores a state. The `originator` struct's objects
    will take states from mementos and create new mementos with their stored state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`originator`类型还存储状态。`originator`结构的对象将从备忘录中获取状态，并使用其存储的状态创建新的备忘录。'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What's the difference between the originator object and the Memento pattern?
    Why don't we use Originator pattern's object directly? Well, if the Memento contains
    a specific state, the `originator` type contains the state that is currently loaded.
    Also, to save the state of something could be as simple as to take some value
    or as complex as to maintain the state of some distributed application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原始对象和备忘录模式之间有什么区别？为什么我们不直接使用Originator模式的对象？嗯，如果Memento包含特定状态，`originator`类型包含当前加载的状态。此外，保存某物的状态可能像获取某个值那样简单，也可能像维护某个分布式应用程序的状态那样复杂。
- en: 'The Originator will have two public methods--the `NewMemento()` method and
    the `ExtractAndStoreState(m memento)` method. The `NewMemento` method will return
    a new Memento built with `originator` current `State` value. The `ExtractAndStoreState`
    method will take the state of a Memento and store it in the `Originator`''s state
    field:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Originator将有两个公共方法--`NewMemento()`方法和`ExtractAndStoreState(m memento)`方法。`NewMemento`方法将返回一个使用`originator`当前`State`值构建的新Memento。`ExtractAndStoreState`方法将获取Memento的状态并将其存储在`Originator`的状态字段中：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `careTaker` type stores the Memento list with all the states we need to
    save. It also stores an `Add` method to insert a new Memento on the list and a
    Memento retriever that takes an index on the Memento list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`careTaker`类型存储了我们需要保存的所有状态的Memento列表。它还存储了一个`Add`方法，用于在列表中插入新的Memento，以及一个Memento检索器，它在Memento列表上获取一个索引。'
- en: 'So let''s start with the `Add` method of the `careTaker` type. The `Add` method
    must take a `memento` object and add it to the `careTaker` object''s list of Mementos:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们从`careTaker`类型的`Add`方法开始。`Add`方法必须获取一个`memento`对象，并将其添加到`careTaker`对象的Mementos列表中：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At the beginning of our test, we created two basic actors for memento--the `originator`
    and the `careTaker`. We set a first state on the originator with the description
    `Idle`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试开始时，我们为备忘录创建了两个基本的角色--`originator`和`careTaker`。我们在originator上设置了第一个状态，描述为`Idle`。
- en: Then, we create the first Memento calling the `NewMemento` method. This should
    wrap the current originator's state in a `memento` type. Our first check is very
    simple--the state description of the returned Memento must be like the state description
    we pass to the originator, that is, the `Idle` description.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`NewMemento`方法创建第一个Memento。这应该将当前originator的状态封装在`memento`类型中。我们的第一个检查非常简单--返回的Memento的状态描述必须与我们传递给originator的状态描述相同，即`Idle`描述。
- en: 'The last step to check whether our Memento''s `Add` method works correctly
    is to see whether the Memento list has grown after adding one item:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的Memento的`Add`方法是否正确工作的最后一步是看看在添加一个项目后Memento列表是否增长：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also have to test the `Memento(int) memento` method. This should take a
    `memento` value from the `careTaker` list. It takes the index you want to retrieve
    from the list so, as usual with lists, we must check that it behaves correctly
    against negative numbers and out of index values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须测试`Memento(int) memento`方法。这应该从`careTaker`列表中获取一个`memento`值。它获取你想要从列表中检索的索引，所以像通常一样，我们必须检查它对负数和超出索引值的行为是否正确：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have to start like we did in our previous test--creating an `originator`
    and `careTaker` objects and adding the first Memento to the `caretaker`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须像在之前的测试中一样开始--创建`originator`和`careTaker`对象，并将第一个Memento添加到`caretaker`中：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once we have the first object on the `careTaker` object, we can ask for it using `careTaker.Memento(0)`.
    Index `0` on the `Memento(int)` method retrieves the first item on the slice (remember
    that slices start with `0`). No error should be returned because we have already
    added a value to the `caretaker` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`careTaker`对象上有了第一个对象，我们就可以使用`careTaker.Memento(0)`来请求它。`Memento(int)`方法中的索引`0`检索切片上的第一个项目（记住切片从`0`开始）。不应该返回错误，因为我们已经向`caretaker`对象添加了一个值。
- en: 'Then, after retrieving the first memento, we checked that the description matches
    the one that we passed at the beginning of the test:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在检索第一个memento之后，我们检查描述是否与测试开始时传递的描述匹配：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last step on this test involves using a negative number to retrieve some
    value. In this case, an error must be returned that shows that no negative numbers
    can be used. It is also possible to return the first index when you pass negative
    numbers but here we will return an error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的最后一步涉及使用负数来检索一些值。在这种情况下，必须返回一个错误，显示不能使用负数。当传递负数时，也可能返回第一个索引，但在这里我们将返回一个错误。
- en: 'The last function to check is the `ExtractAndStoreState` method. This function
    must take a Memento and extract all its state information to set it in the `Originator`
    object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的最后一个函数是`ExtractAndStoreState`方法。这个函数必须获取一个Memento并提取它的所有状态信息，然后将其设置在`Originator`对象中：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This test is simple. We create a default `originator` variable with an `Idle`
    state. Then, we retrieve a new Memento object to use it later. We change the state
    of the `originator` variable to the `Working` state to ensure that the new state
    will be written.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很简单。我们用一个`Idle`状态创建一个默认的`originator`变量。然后，我们检索一个新的Memento对象以便以后使用。我们将`originator`变量的状态更改为`Working`状态，以确保新状态将被写入。
- en: Finally, we have to call the `ExtractAndStoreState` method with the `idleMemento`
    variable. This should restore the state of the originator to the `idleMemento`
    state's value, something that we checked in the last `if` statement.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须使用`idleMemento`变量调用`ExtractAndStoreState`方法。这应该将原始对象的状态恢复到`idleMemento`状态的值，这是我们在最后的`if`语句中检查的。
- en: 'Now it''s time to run the tests:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是运行测试的时候了：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because the three tests fail, we can continue with the implementation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为三个测试失败，我们可以继续实现。
- en: Implementing the Memento pattern
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现备忘录模式
- en: 'The Memento pattern''s implementation is usually very simple if you don''t
    get too crazy. The three actors (`memento`, `originator`, and `care taker`) have
    a very defined role in the pattern and their implementation is very straightforward:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不要太疯狂，实现备忘录模式通常非常简单。模式中的三个角色（`memento`，`originator`和`care taker`）在模式中有非常明确定义的角色，它们的实现非常直接：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Originator` object needs to return a new values of Memento types when
    calling the `NewMemento` method. It also needs to store the value of a `memento`
    object in the state field of the struct as needed for the `ExtractAndStoreState`
    method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`NewMemento`方法时，`Originator`对象需要返回Memento类型的新值。它还需要根据`ExtractAndStoreState`方法的需要将`memento`对象的值存储在结构的状态字段中。
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `careTaker` type is also straightforward. When we call the `Add` method,
    we overwrite the `mementoList` field by calling the `append` method with the value
    passed in the argument. This creates a new list with the new value included.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`careTaker`类型也很简单。当我们调用`Add`方法时，通过调用带有传入参数的`append`方法来覆盖`mementoList`字段。这将创建一个包含新值的新列表。'
- en: When calling the `Memento` method, we have to do a couple of checks beforehand.
    In this case, we check that the index is not outside of the range of the slice
    and that the index is not a negative number in the `if` statement, in which case
    we return an error. If everything goes fine, it just returns the specified `memento`
    object and no errors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Memento`方法时，我们必须先进行一些检查。在这种情况下，我们检查索引是否不超出切片的范围，并且在`if`语句中检查索引是否不是负数，如果是，则返回错误。如果一切顺利，它只返回指定的`memento`对象，没有错误。
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A note about method and function naming conventions. You could find some people
    that like to give slightly more descriptive names to methods such as `Memento`.
    An example would be to use a name such as `MementoOrError` method, clearly showing
    that you return two objects when calling this function or even `GetMementoOrError`
    method. This could be a very explicit approach for naming and it's not necessarily
    bad, but you won't find it very common in Go's source code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方法和函数命名约定的一点说明。你可能会发现一些人喜欢给方法取名字更具描述性，比如`Memento`。一个例子是使用一个名为`MementoOrError`的方法，清楚地显示在调用此函数时返回两个对象，甚至是`GetMementoOrError`方法。这可能是一种非常明确的命名方法，不一定是坏事，但你在Go的源代码中不会经常看到这种情况。
- en: 'Time to check the test results:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 检查测试结果的时间到了：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That was enough to reach 100% of coverage. While this is far from being a perfect
    metric, at least we know that we are reaching every corner of our source code
    and that we haven't cheated in our tests to achieve it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以达到100%的覆盖率。虽然这远非完美的度量标准，但至少我们知道我们正在触及源代码的每一个角落，而且我们没有在测试中作弊来实现它。
- en: Another example using the Command and Facade patterns
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个使用命令和外观模式的例子
- en: The previous example is good and simple enough to understand the functionality
    of the Memento pattern. However, it is more commonly used in conjunction with
    the Command pattern and a simple Facade pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子足够好而简单，以理解Memento模式的功能。然而，它更常用于与命令模式和简单的Facade模式结合使用。
- en: The idea is to use a Command pattern to encapsulate a set of different types
    of states (those that implement a `Command` interface) and provide a small facade
    to automate the insertion in the `caretaker` object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是使用命令模式来封装一组不同类型的状态（实现“Command”接口的那些状态），并提供一个小的外观来自动将其插入“caretaker”对象中。
- en: 'We are going to develop a small example of a hypothetical audio mixer. We are
    going to use the same Memento pattern to save two types of states: `Volume` and
    `Mute`. The `Volume` state is going to be a byte type and the `Mute` state a Boolean
    type. We will use two completely different types to show the flexibility of this
    approach (and its drawbacks).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个假想音频混音器的小例子。我们将使用相同的Memento模式来保存两种类型的状态：“Volume”和“Mute”。 “Volume”状态将是一个字节类型，“Mute”状态将是一个布尔类型。我们将使用两种完全不同的类型来展示这种方法的灵活性（以及它的缺点）。
- en: As a side note, we can also ship each `Command` interface with their own serialization
    methods on the interface. This way, we can give the ability to the caretaker to
    store states in some kind of storage without really knowing what's storing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们还可以在接口上为每个“Command”接口提供自己的序列化方法。这样，我们可以让caretaker在不真正知道正在存储什么的情况下将状态存储在某种存储中。
- en: 'Our `Command` interface is going to have one method to return the value of
    its implementer. It''s very simple, every command in our audio mixer that we want
    to undo will have to implement this interface:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“Command”接口将有一个方法来返回其实现者的值。这很简单，我们想要撤消的音频混音器中的每个命令都必须实现这个接口：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is something interesting in this interface. The `GetValue` method returns
    an interface to a value. This also means that the return type of this method is...
    well... untyped? Not really, but it returns an interface that can be a representation
    of any type and we will need to typecast it later if we want to use its specific
    type. Now we have to define the `Volume` and `Mute` types and implement the `Command`
    interface:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口中有一些有趣的地方。“GetValue”方法返回一个值的接口。这也意味着这个方法的返回类型是...嗯...无类型的？不是真的，但它返回一个接口，可以是任何类型的表示，我们稍后需要对其进行类型转换，如果我们想使用其特定类型。现在我们必须定义“Volume”和“Mute”类型并实现“Command”接口：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: They are both quite easy implementations. However, the `Mute` type will return
    a `bool` type on the `GetValue()` method and `Volume` will return a `byte` type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是相当简单的实现。但是，“Mute”类型将在“GetValue()”方法上返回一个“bool”类型，“Volume”将返回一个“byte”类型。
- en: 'As in the previous example, we''ll need a `Memento` type that will hold a `Command`.
    In other words, it will store a pointer to a `Mute` or a `Volume` type:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子一样，我们需要一个将保存“Command”的“Memento”类型。换句话说，它将存储指向“Mute”或“Volume”类型的指针：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `originator` type works as in the previous example but uses the `Command`
    keyword instead of the `state` keyword:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “originator”类型的工作方式与之前的例子相同，但是使用“Command”关键字而不是“state”关键字：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And the `caretaker` object is almost the same, but this time we''ll use a stack
    instead of a simple list and we will store a command instead of a state:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 而“caretaker”对象几乎相同，但这次我们将使用堆栈而不是简单列表，并且我们将存储命令而不是状态：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, our `Memento` list is replaced with a `Pop` method. It also returns
    a `memento` object but it will return them acting as a stack (last to enter, first
    to go out). So, we take the last element on the stack and store it in the `tempMemento`
    variable. Then we replace the stack with a new version that doesn't contain the
    last element on the next line. Finally, we return the `tempMemento` variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的“Memento”列表被替换为“Pop”方法。它也返回一个“memento”对象，但它将它们作为堆栈返回（最后进入，最先出）。因此，我们取堆栈上的最后一个元素并将其存储在“tempMemento”变量中。然后，我们用不包含下一行上的最后一个元素的新版本替换堆栈。最后，我们返回“tempMemento”变量。
- en: 'Until now, everything looks almost like in the previous example. We also talked
    about automating some tasks by using the Facade pattern, so let''s do it. This
    is going to be called the `MementoFacade` type and will have the `SaveSettings`
    and `RestoreSettings` methods. The `SaveSettings` method takes a `Command`, stores
    it in an inner originator, and saves it in an inner `careTaker` field. The `RestoreSettings`
    method makes the opposite flow-restores an index of the `careTaker` and returns
    the `Command` inside the `Memento` object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来几乎与之前的例子一样。我们还谈到了通过使用Facade模式自动化一些任务，所以让我们来做吧。这将被称为“MementoFacade”类型，并将具有“SaveSettings”和“RestoreSettings”方法。“SaveSettings”方法接受一个“Command”，将其存储在内部originator中，并保存在内部的“careTaker”字段中。“RestoreSettings”方法执行相反的流程-恢复“careTaker”的索引并返回“Memento”对象中的“Command”：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Our Facade pattern will hold the contents of the originator and the care taker
    and will provide those two easy-to-use methods to save and restore settings.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Facade模式将保存originator和care taker的内容，并提供这两个易于使用的方法来保存和恢复设置。
- en: So, how do we use this?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这个？
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we get a variable with a Facade pattern. Zero-value initialization will
    give us zero-valued `originator` and `caretaker` objects. They don't have any
    unexpected field so everything will initialize correctly (if any of them had a
    pointer, for example, it would be initialized to `nil` as mentioned in the *Zero
    initialization* section of [Chapter 1](ch01.html "Chapter 1. Ready... Steady...
    Go!"), *Ready... Steady... Go!*).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用Facade模式获取一个变量。零值初始化将给我们零值的“originator”和“caretaker”对象。它们没有任何意外的字段，因此一切都将正确初始化（例如，如果它们中的任何一个有一个指针，它将被初始化为“nil”，如[第1章](ch01.html
    "第1章。准备...开始...跑！")中提到的*零初始化*部分，*准备...开始...跑！*）。
- en: We create a `Volume` value with `Volume(4)` and, yes, we have used parentheses.
    The `Volume` type does not have any inner field like structs so we cannot use
    curly braces to set its value. The way to set it is to use parentheses (or create
    a pointer to the type `Volume` and then set the value of the pointed space). We
    also save a value of the type `Mute` using the Facade pattern.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Volume(4)`创建了一个`Volume`值，是的，我们使用了括号。`Volume`类型没有像结构体那样的内部字段，因此我们不能使用大括号来设置其值。设置它的方法是使用括号（或者创建指向`Volume`类型的指针，然后设置指向空间的值）。我们还使用外观模式保存了一个`Mute`类型的值。
- en: 'We don''t know what `Command` type is returned here, so we need to make a type
    assertion. We will make a small function to help us with this that checks the
    type and prints an appropriate value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道这里返回了什么类型的`Command`，因此我们需要进行类型断言。我们将编写一个小函数来帮助我们进行检查类型并打印适当的值：
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `assertAndPrint` method takes a `Command` type and casts it to the two
    possible types-`Volume` or `Mute`. In each case, it prints a message to the console
    with a personalized message. Now we can continue and finish the `main` function,
    which will look like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertAndPrint`方法接受一个`Command`类型并将其转换为两种可能的类型-`Volume`或`Mute`。在每种情况下，它都会向控制台打印一条消息。现在我们可以继续并完成`main`函数，它将如下所示：'
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The part highlighted in bold shows the new changes within the `main` function.
    We took the index 0 from the `careTaker` object and passed it to the new function
    and the same with the index `1`. Running this small program, we should get the
    `Volume` and `Mute` values on the console:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体部分显示了`main`函数中的新更改。我们从`careTaker`对象中取出索引0并将其传递给新函数，索引`1`也是一样。运行这个小程序，我们应该在控制台上得到`Volume`和`Mute`的值：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Great! In this small example, we have combined three different design patterns
    to keep getting comfortable using various patterns. Keep in mind that we could
    have abstracted the creation of `Volume` and `Mute` states to a Factory pattern
    too so this is not where would stop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在这个小例子中，我们结合了三种不同的设计模式，以便继续舒适地使用各种模式。请记住，我们也可以将`Volume`和`Mute`状态的创建抽象为工厂模式，所以这并不是我们停下来的地方。
- en: Last words on the Memento pattern
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于备忘录模式的最后一句话
- en: 'With the Memento pattern, we have learned a powerful way to create undoable
    operations that are very useful when writing UI applications but also when you
    have to develop transactional operations. In any case, the situation is the same:
    you need a `Memento`, an `Originator`, and a `caretaker` actor.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过备忘录模式，我们学会了一种强大的方式来创建可撤销的操作，这在编写UI应用程序时非常有用，也在开发事务操作时非常有用。无论如何，情况都是一样的：您需要一个`Memento`，一个`Originator`和一个`caretaker`角色。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A **transaction operation** is a set of atomic operations that must all be done
    or fail. In other words, if you have a transaction composed of five operations
    and just one of them fails, the transaction cannot be completed and every modification
    done by the other four must be undone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务操作**是一组必须全部完成或失败的原子操作。换句话说，如果您有一个由五个操作组成的事务，只有其中一个失败，事务就无法完成，其他四个操作所做的每个修改都必须被撤消。'
- en: Interpreter design pattern
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器设计模式
- en: Now we are going to dig into a quite complex pattern. The **Interpreter** pattern
    is, in fact, widely used to solve business cases where it's useful to have a language
    to perform common operations. Let's see what we mean by language.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入研究一个相当复杂的模式。事实上，**解释器**模式被广泛用于解决业务案例，其中有一个语言执行常见操作的需求。让我们看看我们所说的语言是什么意思。
- en: Description
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The most famous interpreter we can talk about is probably SQL. It's defined
    as a special-purpose programming language for managing data held in relational
    databases. SQL is quite complex and big but, all in all, is a set of words and
    operators that allow us to perform operations such as insert, select, or delete.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以谈论的最著名的解释器可能是SQL。它被定义为用于管理关系数据库中保存的数据的特定编程语言。SQL非常复杂和庞大，但总的来说，它是一组单词和操作符，允许我们执行插入、选择或删除等操作。
- en: Another typical example is musical notation. It's a language itself and the
    interpreter is the musician who knows the connection between a note and its representation
    on the instrument they are playing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个典型的例子是音乐符号。它本身就是一种语言，解释器是懂得音符与乐器上的表示之间连接的音乐家。
- en: 'In computer science, it can be useful to design a small language for a variety
    of reasons: repetitive tasks, higher-level languages for non-developers, or **Interface
    Definition Languages** (**IDL**) such as **Protocol buffers** or **Apache Thrift**.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，为各种原因设计一个小语言可能是有用的：重复的任务，非开发人员的高级语言，或者**接口定义语言**（**IDL**）如**Protocol
    buffers**或**Apache Thrift**。
- en: Objectives
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'Designing a new language, big or small, can be a time consuming task so it''s
    very important to have the objectives clear before investing time and resources
    on writing an interpreter of it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个新的语言，无论大小，都可能是一项耗时的任务，因此在投入时间和资源编写其解释器之前，明确目标非常重要：
- en: Provide syntax for very common operations in some scope (such as playing notes).
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一些范围内非常常见操作的语法（比如播放音符）。
- en: Have a intermediate language to translate actions between two systems. For example,
    the apps that generate the **Gcode** needed to print with 3D printers.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个中间语言来在两个系统之间转换操作。例如，生成3D打印所需的**Gcode**的应用程序。
- en: Ease the use of some operations in an easier-to-use syntax.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化某些操作的使用，使用更易于使用的语法。
- en: SQL allows the use of relational databases in a very easy-to-use syntax (that
    can become incredibly complex too) but the idea is to not need to write your own
    functions to make insertions and searches.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: SQL允许使用关系数据库的非常易于使用的语法（也可能变得非常复杂），但其思想是不需要编写自己的函数来进行插入和搜索。
- en: Example - a polish notation calculator
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例如 - 逆波兰表达式计算器
- en: A very typical example of an interpreter is to create a reverse polish notation
    calculator. For those who don't know what polish notation is, it's a mathematical
    notation to make operations where you write your operation first (sum) and then
    the values (3 4), so *+ 3 4* is equivalent to the more common *3 + 4* and its
    result would be *7*. So, for a reverse polish notation, you put first the values
    and then the operation, so *3 4 +* would also be *7*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器的一个非常典型的例子是创建一个逆波兰表示法计算器。对于那些不知道波兰表示法是什么的人来说，它是一种数学表示法，用于进行操作，其中你首先写下你的操作（求和），然后是值（3
    4），因此*+ 3 4*等同于更常见的*3 + 4*，其结果将是*7*。因此，对于逆波兰表示法，你首先放置值，然后是操作，因此*3 4 +*也将是*7*。
- en: Acceptance criteria for the calculator
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算器的验收标准
- en: 'For our calculator, the acceptance criteria we should pass to consider it done
    are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的计算器，我们应该通过的验收标准如下：
- en: Create a language that allows making common arithmetic operations (sums, subtractions,
    multiplications, and divisions). The syntax is `sum` for sums, `mul` for multiplications,
    `sub` for subtractions, and `div` for divisions.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一种允许进行常见算术运算（求和、减法、乘法和除法）的语言。语法是`sum`表示求和，`mul`表示乘法，`sub`表示减法，`div`表示除法。
- en: It must be done using reverse polish notation.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须使用逆波兰表示法。
- en: The user must be able to write as many operations in a row as they want.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户必须能够连续写入任意多个操作。
- en: The operations must be performed from left to right.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作必须从左到右执行。
- en: So the `3 4 sum 2 sub` notation is the same than *(3 + 4) - 2* and result would
    be *5*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`3 4 sum 2 sub`表示的是*(3 + 4) - 2*，结果将是*5*。
- en: Unit test of some operations
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些操作的单元测试
- en: 'In this case, we will only have a public method called `Calculate` that takes
    an operation with its values defined as a string and will return a value or an
    error:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只有一个名为`Calculate`的公共方法，它接受一个操作及其值定义为字符串，并将返回一个值或一个错误：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, we will send a string like `"3 4 +"` to the `Calculate` method and it should
    return *7, nil*. Two tests more will check the correct implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将发送一个字符串，如`"3 4 +"`到`Calculate`方法，它应该返回*7, nil*。另外两个测试将检查正确的实现：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, we are going to make the operation we have used as an example. The `3
    4 sum 2 sub` notation is part of our language and we use it in the `Calculate`
    function. If an error is returned, the test fails. Finally, the result must be
    equal to `5` and we check it on the last lines. The next test checks the rest
    of the operators on slightly more complex operations:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将进行我们作为示例使用的操作。`3 4 sum 2 sub`表示是我们语言的一部分，我们在`Calculate`函数中使用它。如果返回错误，则测试失败。最后，结果必须等于`5`，我们在最后几行进行检查。下一个测试检查了稍微复杂一些的操作的其余操作符：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here, we repeated the preceding process with a longer operation, the *(((5
    - 3) * 8) + 4) / 5* notation which is equal to *4*. From left to right, it would
    be as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个更长的操作重复了前面的过程，即*(((5 - 3) * 8) + 4) / 5*，它等于*4*。从左到右，它将如下进行：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The test must fail, of course!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测试必须失败！
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Implementation
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Implementation is going to be longer than testing this time. To start, we will
    define our possible operators in constants:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这次实现的时间要比测试长。首先，我们将在常量中定义可能的运算符：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Interpreter patterns are usually implemented using an abstract syntax tree,
    something that is commonly achieved using a stack. We have created stacks before
    during the book so this should be already familiar to readers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式通常使用抽象语法树来实现，这通常使用堆栈来实现。我们在本书中之前已经创建了堆栈，所以这对读者来说应该已经很熟悉了：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have two methods--the `Push` method to add elements to the top of the stack
    and the `Pop` method to remove elements and return them. In case you are thinking
    that the line `*p = (*p)[:length-1]` is a bit cryptic, we'll explain it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法——`Push`方法用于将元素添加到堆栈顶部，`Pop`方法用于移除元素并返回它们。如果你认为`*p = (*p)[:length-1]`这一行有点神秘，我们会解释它。
- en: The value stored in the direction of `p` will be overridden with the actual
    value in the direction of `p (*p)` but taking only the elements from the beginning
    to the penultimate element of the array `(:length-1)`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`p`方向的值将被覆盖为`p`方向的实际值（*p*），但只取数组的开始到倒数第二个元素(:length-1)。
- en: 'So, now we will go step by step with the `Calculate` function, creating more
    functions as far as we need them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将逐步进行`Calculate`函数，根据需要创建更多的函数：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first two things we need to do are to create the stack and to get all different
    symbols from the incoming operation (in this case, we aren't checking that it
    isn't empty). We split the incoming string operations by the space to get a nice
    slice of symbols (values and operators).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的前两件事是创建堆栈并从传入的操作中获取所有不同的符号（在这种情况下，我们没有检查它是否为空）。我们通过空格拆分传入的字符串操作，以获得一个漂亮的符号（值和运算符）切片。
- en: 'Next, we will iterate over every symbol by using range but we need a function
    to know whether the incoming symbol is a value or an operator:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用range迭代每个符号，但我们需要一个函数来知道传入的符号是值还是运算符：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If the incoming symbol is any of the ones defined in our constants, the incoming
    symbol is an operator:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的符号是我们常量中定义的任何一个，那么传入的符号就是一个运算符。
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If it is an operator, we consider that we have already passed two values so
    what we have to do is to take those two values from the stack. The first value
    taken would be the rightmost and the second the leftmost (remember that in subtractions
    and divisions, the order of the operands is important). Then, we need some function
    to get the operation we want to perform:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个运算符，我们认为我们已经传递了两个值，所以我们要做的就是从堆栈中取出这两个值。取出的第一个值将是最右边的，第二个值将是最左边的（请记住，在减法和除法中，操作数的顺序很重要）。然后，我们需要一些函数来获取我们想要执行的操作：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `getOperationFunc` functions returns a two-argument function that returns
    an integer. We check the incoming operator and we return an anonymous function
    that performs the specified operation. So, now our `for range` continues like
    this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOperationFunc`函数返回一个返回整数的两参数函数。我们检查传入的运算符，然后返回执行指定操作的匿名函数。因此，现在我们的`for
    range`继续如下：'
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `mathFunc` variable is returned by the function. We use it immediately to
    perform the operation on the left and right values taken from the stack and we
    store its result in a new variable called `res`. Finally, we need to push this
    new value to the stack to keep operating with it later.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathFunc`变量由该函数返回。我们立即使用它对从堆栈中取出的左值和右值执行操作，并将其结果存储在一个名为`res`的新变量中。最后，我们需要将这个新值推送到堆栈中，以便稍后继续操作。'
- en: 'Now, here is the implementation when the incoming symbol is a value:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当传入的符号是一个值时，这是实现：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What we need to do every time we get a symbol is to push it to the stack. We
    have to parse the string symbol to a usable `int` type. This is commonly done
    with the `strconv` package by using its `Atoi` function. The `Atoi` function takes
    a string and returns an integer from it or an error. If everything goes well,
    the value is pushed into the stack.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们得到一个符号时，我们需要将其推送到堆栈中。我们必须将字符串符号解析为可用的`int`类型。这通常使用`strconv`包来完成，通过使用其`Atoi`函数。`Atoi`函数接受一个字符串并返回一个整数或一个错误。如果一切顺利，该值将被推送到堆栈中。
- en: 'At the end of the `range` statement, just one value must be stored on it, so
    we just need to return it and the function is done:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`range`语句结束时，只需存储一个值，所以我们只需要返回它，函数就完成了。
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Time to run the tests again:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候再次运行测试了：
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Great! We have just created a reverse polish notation interpreter in a very
    simple and easy way (we still lack the parser, but that's another story).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚以一种非常简单和容易的方式创建了一个逆波兰表示法解释器（我们仍然缺少解析器，但那是另一回事）。
- en: Complexity with the Interpreter design pattern
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释器设计模式的复杂性
- en: In this example, we haven't used any interfaces. This is not exactly how the
    Interpreter design pattern is defined in more object-oriented languages. However,
    this example is the simplest example possible to understand the objectives of
    the language and the next level is inevitably much more complex and not intended
    for beginner users.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们没有使用任何接口。这并不完全符合更面向对象的语言中定义的解释器设计模式。然而，这个例子是最简单的例子，可以理解语言的目标，下一个级别不可避免地会更复杂，不适合初学者用户。
- en: With a more complex example, we will have to define a type containing more types
    of itself, a value, or nothing. With a parser, you create this abstract syntax
    tree to interpret it later.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的例子中，我们将不得不定义一个包含更多类型的类型，一个值或无类型。通过解析器，您可以创建这个抽象语法树以后进行解释。
- en: The same example, done by using interfaces, would be as in the following description
    section.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口完成相同的示例，如下所述。
- en: Interpreter pattern again - now using interfaces
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次使用接口的解释器模式
- en: 'The main interface we are going to use is called the `Interpreter` interface.
    This interface has a `Read()` method that every symbol (value or operator) must
    implement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的主要接口称为`Interpreter`接口。该接口具有一个`Read()`方法，每个符号（值或运算符）都必须实现：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will implement only the sum and the subtraction from the operators and a
    type called `Value` for the numbers:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅实现运算符的求和和减法，以及称为`Value`的数字类型：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `Value` is a type `int` that, when implementing the `Read` method, just
    returns its value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value`是一个`int`类型，当实现`Read`方法时，只返回其值：'
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `operationSum` struct has the `Left` and `Right` fields and its `Read`
    method returns the sum of each of their `Read` methods. The `operationSubtract` struct
    is the same but subtracting:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`operationSum`结构具有`Left`和`Right`字段，其`Read`方法返回其各自的`Read`方法的和。`operationSubtract`结构也是一样，但是减去：'
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We also need a Factory pattern to create operators; we will call it the `operatorFactory`
    method. The difference now is that it not only accepts the symbol but also the
    `Left` and `Right` values taken from the stack:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个工厂模式来创建运算符；我们将称之为`operatorFactory`方法。现在的区别在于它不仅接受符号，还接受从堆栈中取出的`Left`和`Right`值：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As we have just mentioned, we also need a stack. We can reuse the one from
    the previous example by changing its type:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，我们还需要一个堆栈。我们可以通过更改其类型来重用前面示例中的堆栈：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now the stack works with Interpreter pointers instead of `int` but its functionality
    is the same. Finally, our `main` method also looks similar to our previous example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在堆栈使用解释器指针而不是`int`，但其功能是相同的。最后，我们的`main`方法看起来也与之前的示例类似：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Like before, we check whether the symbol is operator or value first. When it's
    a value, it pushes it into the stack.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们首先检查符号是运算符还是值。当它是一个值时，它将其推送到堆栈中。
- en: When the symbol is an operator, we also take the right and left values from
    the stack, we call the Factory pattern using the current operator and the left
    and right values that we just took from the stack. Once we have the operator type,
    we just need to call its `Read` method to push the returned value to the stack
    too.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号是一个运算符时，我们还从堆栈中取出右值和左值，我们使用当前运算符和刚刚从堆栈中取出的左值和右值调用工厂模式。一旦我们有了运算符类型，我们只需要调用其`Read`方法将返回的值也推送到堆栈中。
- en: 'Finally, just one example must be left on the stack, so we print it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只剩下一个例子必须留在堆栈上，所以我们打印它：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The power of the Interpreter pattern
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释器模式的力量
- en: This pattern is extremely powerful but it must also be used carefully. To create
    a language, it generates a strong coupling between its users and the functionality
    it provides. One can fall into the error of trying to create a too flexible language
    that is incredibly complex to use and maintain. Also, one can create a fairly
    small and useful language that doesn't interpret correctly sometimes and it could
    be a pain for its users.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常强大，但也必须谨慎使用。创建一种语言会在其用户和提供的功能之间产生强大的耦合。人们可能会犯错误，试图创建一种过于灵活、难以使用和维护的语言。另外，人们可能会创建一种相当小而有用的语言，有时解释不正确，这可能会给用户带来痛苦。
- en: In our example, we have omitted quite a lot of error-checking to focus on the
    implementation of the Interpreter. However, you'll need quite a lot of error checking
    and verbose output on errors to help the user correct its syntax errors. So, have
    fun writing your language but be nice to your users.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们省略了相当多的错误检查，以便专注于解释器的实现。然而，你需要相当多的错误检查和错误时冗长的输出，以帮助用户纠正其语法错误。所以，写你的语言时要开心，但要对用户友好。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter has dealt with three extremely powerful patterns that require
    a lot of practice before using them in production code. It''s a very good idea
    to make some exercises with them by simulating typical production problems:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了三种非常强大的模式，在将它们用于生产代码之前，需要进行大量的练习。通过模拟典型的生产问题来进行一些练习是一个非常好的主意：
- en: Create a simple REST server that reuses most of the error-checking and connection
    functionality to provide an easy-to-use interface to practice the Template pattern
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的REST服务器，重用大部分错误检查和连接功能，提供一个易于使用的接口来练习模板模式
- en: Make a small library that can write to different databases but only in the case
    that all writes were OK, or delete the newly created writes to practice Memento
    for example
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个小型库，可以写入不同的数据库，但前提是所有写入都没有问题，或者删除新创建的写入以练习备忘录，例如
- en: Write your own language, to make simple things such as answering simple questions
    like bots usually do so you can practice a bit of the Interpreter pattern
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你自己的语言，做一些简单的事情，比如回答简单的问题，就像机器人通常做的那样，这样你就可以练习一下解释器模式
- en: The idea is to practice coding and reread any section until you get comfortable
    with each pattern.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是练习编码并重新阅读任何部分，直到你对每个模式都感到舒适。
