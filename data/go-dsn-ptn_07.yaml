- en: Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。行为模式 - 访问者，状态，中介者和观察者设计模式
- en: This is the last chapter about Behavioral patterns and it also closes this book's
    section about common, well known design patterns in Go language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于行为模式的最后一章，也是本书关于Go语言中常见的、众所周知的设计模式的部分的结束。
- en: In this chapter, we are going to look at three more design patterns. Visitor
    pattern is very useful when you want to abstract away some functionality from
    a set of objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究另外三种设计模式。当您想要从一组对象中抽象出一些功能时，访问者模式非常有用。
- en: State is used commonly to build **Finite State Machines** (**FSM**) and, in
    this section, we will develop a small *guess the number* game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 状态通常用于构建**有限状态机**（**FSM**），在本节中，我们将开发一个小的*猜数字*游戏。
- en: Finally, the Observer pattern is commonly used in event-driven architectures
    and is gaining a lot of traction again, especially in the microservices world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，观察者模式通常用于事件驱动的架构，并且在微服务世界中再次获得了很多关注。
- en: After this chapter, we'll need to feel very comfortable with common design patterns
    before digging in concurrency and the advantages (and complexity), it brings to
    design patterns.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们需要在深入并发和它带来的设计模式的优势（和复杂性）之前，对常见的设计模式感到非常舒适。
- en: Visitor design pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者设计模式
- en: In the next design pattern, we are going to delegate some logic of an object's
    type to an external type called the visitor that will visit our object to perform
    operations on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个设计模式中，我们将把对象类型的一些逻辑委托给一个名为访问者的外部类型，该类型将访问我们的对象以对其执行操作。
- en: Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: In the Visitor design pattern, we are trying to separate the logic needed to
    work with a specific object outside of the object itself. So we could have many
    different visitors that do some things to specific types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问者设计模式中，我们试图将与特定对象一起工作所需的逻辑与对象本身分离。因此，我们可以有许多不同的访问者对特定类型执行某些操作。
- en: For example, imagine that we have a log writer that writes to console. We could
    make the logger "visitable" so that you can prepend any text to each log. We could
    write a Visitor pattern that prepends the date, the time, and the hostname to
    a field stored in the object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们有一个写入控制台的日志记录器。我们可以使记录器“可访问”，以便您可以在每个日志前添加任何文本。我们可以编写一个访问者模式，它将日期、时间和主机名添加到对象中存储的字段。
- en: Objectives
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'With Behavioral design patterns we are mainly dealing with algorithms. Visitor
    patterns are not an exception. The objectives that we are trying to achieve are
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为设计模式中，我们主要处理算法。访问者模式也不例外。我们试图实现的目标如下：
- en: To separate the algorithm of some type from its implementation within some other
    type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将某种类型的算法与其在其他类型中的实现分离
- en: To improve the flexibility of some types by using them with little or no logic
    at all so all new functionality can be added without altering the object structure
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用一些类型来提高其灵活性，几乎不需要任何逻辑，因此所有新功能都可以添加而不改变对象结构
- en: To fix a structure or behavior that would break the open/closed principle in
    a type
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复会破坏类型中的开闭原则的结构或行为
- en: You might be thinking what the open/closed principle is. In computer science,
    the open/closed principle states that: *entities should be open for * *extension
    but closed for modification*. This simple state has lots of implications that
    allows building more maintainable software and less prone to errors. And the Visitor
    pattern helps us to delegate some commonly changing algorithm from a type that
    we need it to be "stable" to an external type that can change often without affecting
    our original one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道开闭原则是什么。在计算机科学中，开闭原则指出：*实体应该对扩展开放，但对修改关闭*。这个简单的状态有很多含义，可以构建更易于维护且不太容易出错的软件。访问者模式帮助我们将一些常常变化的算法从我们需要它“稳定”的类型委托给一个经常变化的外部类型，而不会影响我们的原始类型。
- en: A log appender
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志附加器
- en: We are going to develop a simple log appender as an example of the Visitor pattern.
    Following the approach we have had in previous chapters, we will start with an
    extremely simple example to clearly understand how the Visitor design pattern
    works before jumping to a more complex one. We have already developed similar
    examples modifying texts too, but in slightly different ways.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个简单的日志附加器作为访问者模式的示例。遵循我们在之前章节中的方法，我们将从一个极其简单的示例开始，以清楚地理解访问者设计模式的工作原理，然后再转向更复杂的示例。我们已经开发了类似的示例，但以稍微不同的方式修改文本。
- en: For this particular example, we will create a Visitor that appends different
    information to the types it "visits".
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，我们将创建一个访问者，它会向“访问”的类型附加不同的信息。
- en: Acceptance criteria
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'To effectively use the Visitor design pattern, we must have two roles--a visitor
    and a visitable. The `Visitor` is the type that will act within a `Visitable`
    type. So a `Visitable` interface implementation has an algorithm detached to the `Visitor`
    type:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要有效地使用访问者设计模式，我们必须有两个角色--访问者和可访问者。`Visitor`是将在`Visitable`类型内执行的类型。因此，`Visitable`接口实现将算法分离到`Visitor`类型：
- en: 'We need two message loggers: `MessageA` and `MessageB` that will print a message
    with an `A:` or a `B:` respectively before the message.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要两个消息记录器：`MessageA`和`MessageB`，它们将在消息之前分别打印带有`A：`或`B：`的消息。
- en: We need a Visitor able to modify the message to be printed. It will append the
    text "Visited A" or "Visited B" to them, respectively.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个访问者能够修改要打印的消息。它将分别将文本“Visited A”或“Visited B”附加到它们。
- en: Unit tests
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'As we mentioned before, we will need a role for the `Visitor` and the `Visitable`
    interfaces. They will be interfaces. We also need the `MessageA` and `MessageB`
    structs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们将需要`Visitor`和`Visitable`接口的角色。它们将是接口。我们还需要`MessageA`和`MessageB`结构：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The types `MessageA` and `MessageB` structs both have an `Msg` field to store
    the text that they will print. The output `io.Writer` will implement the `os.Stdout`
    interface by default or a new `io.Writer` interface, like the one we will use
    to check that the contents are correct.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageA` 和 `MessageB` 结构都有一个 `Msg` 字段来存储它们将要打印的文本。输出 `io.Writer` 将默认实现 `os.Stdout`
    接口，或者一个新的 `io.Writer` 接口，就像我们将用来检查内容是否正确的接口一样。'
- en: The `Visitor` interface has a `Visit` method, one for each of `Visitable` interface's
    `MessageA` and `MessageB` type. The `Visitable` interface has a method called `Accept(Visitor)`
    that will execute the decoupled algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visitor` 接口有一个 `Visit` 方法，分别用于 `Visitable` 接口的 `MessageA` 和 `MessageB` 类型。`Visitable`
    接口有一个名为 `Accept(Visitor)` 的方法，将执行解耦的算法。'
- en: 'Like in previous examples, we will create a type that implements the `io.Writer`
    package so that we can use it in tests:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的示例一样，我们将创建一个实现 `io.Writer` 包的类型，以便我们可以在测试中使用它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `TestHelper` struct implements the `io.Writer` interface. Its functionality
    is quite simple; it stores the written bytes on the `Received` field. Later we
    can check the contents of `Received` to test against our expected value.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestHelper` 结构实现了 `io.Writer` 接口。它的功能非常简单；它将写入的字节存储在 `Received` 字段上。稍后我们可以检查
    `Received` 的内容来测试是否符合我们的预期值。'
- en: 'We will write just one test that will check the overall correctness of the
    code. Within this test, we will write two sub tests: one for `MessageA` and one
    for `MessageB` types:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只编写一个测试，检查代码的整体正确性。在这个测试中，我们将编写两个子测试：一个用于 `MessageA`，一个用于 `MessageB` 类型：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use a `TestHelper` struct and a `MessageVisitor` struct on each test
    for each message type. First, we will test the `MessageA` type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个消息类型的每个测试中使用一个 `TestHelper` 结构和一个 `MessageVisitor` 结构。首先，我们将测试 `MessageA`
    类型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the full first test. We created `MessageA` struct, giving it a value
    `Hello World` for the `Msg` field and the pointer to `TestHelper`, which we created
    at the beginning of the test. Then, we execute its `Accept` method. Inside the
    `Accept(Visitor)` method on the `MessageA` struct, the `VisitA(*MessageA)` method
    is executed to alter the contents of the `Msg` field (that's why we passed the
    pointer to `VisitA` method, without a pointer the contents won't be persisted).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的第一个测试。我们创建了 `MessageA` 结构，为 `Msg` 字段赋予了值 `Hello World`，并为其传递了在测试开始时创建的
    `TestHelper` 的指针。然后，我们执行它的 `Accept` 方法。在 `MessageA` 结构的 `Accept(Visitor)` 方法中，将执行
    `VisitA(*MessageA)` 方法来改变 `Msg` 字段的内容（这就是为什么我们传递了 `VisitA` 方法的指针，没有指针内容将不会被持久化）。
- en: To test if the `Visitor` type has done its job within the `Accept` method, we
    must call the `Print()` method on the `MessageA` type later. This way, the `MessageA` struct
    must write the contents of `Msg` to the provided `io.Writer` interface (our `TestHelper`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `Visitor` 类型在 `Accept` 方法中是否完成了其工作，我们必须稍后在 `MessageA` 类型上调用 `Print()` 方法。这样，`MessageA`
    结构必须将 `Msg` 的内容写入提供的 `io.Writer` 接口（我们的 `TestHelper`）。
- en: 'The last part of the test is the check. According to the description of *acceptance
    criteria 2*, the output text of `MessageA` type must be prefixed with the text `A:`,
    the stored message and the text `"(Visited)"` just at the end. So, for the `MessageA`
    type, the expected text must be `"A: Hello World (Visited)"`, this is the check
    that we did in the `if` section.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '测试的最后一部分是检查。根据*验收标准2*的描述，`MessageA` 类型的输出文本必须以文本 `A:` 为前缀，存储的消息和文本 `"(Visited)"`
    为结尾。因此，对于 `MessageA` 类型，期望的文本必须是 `"A: Hello World (Visited)"`，这是我们在 `if` 部分进行的检查。'
- en: 'The `MessageB` type has a very similar implementation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageB` 类型有一个非常相似的实现：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fact, we have just changed the type from `MessageA` to `MessageB` and the
    expected text now is `"B: Hello World (Visited B)"`. The `Msg` field is also `"Hello
    World"` and we also used the `TestHelper` type.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，我们刚刚将类型从 `MessageA` 更改为 `MessageB`，现在期望的文本是 `"B: Hello World (Visited B)"`。`Msg`
    字段也是 `"Hello World"`，我们还使用了 `TestHelper` 类型。'
- en: 'We still lack the correct implementations of the interfaces to compile the
    code and run the tests. The `MessageA` and `MessageB` structs have to implement
    the `Accept(Visitor)` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少正确的接口实现来编译代码并运行测试。`MessageA` 和 `MessageB` 结构必须实现 `Accept(Visitor)` 方法：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need the implementations of the `VisitA(*MessageA)` and `VisitB(*MessageB)`
    methods that are declared on the `Visitor` interface. The `MessageVisitor` interface
    is the type that must implement them:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现在 `Visitor` 接口上声明的 `VisitA(*MessageA)` 和 `VisitB(*MessageB)` 方法。`MessageVisitor`
    接口是必须实现它们的类型：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will create a `Print()` method for each message type. This is the
    method that we will use to test the contents of the `Msg` field on each type:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为每种消息类型创建一个 `Print()` 方法。这是我们将用来测试每种类型的 `Msg` 字段内容的方法：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can run the tests to really check if they are failing yet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行测试，真正检查它们是否已经失败：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The outputs of the tests are clear. The expected messages were incorrect because
    the contents were empty. It's time to create the implementations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出很清楚。期望的消息是不正确的，因为内容是空的。现在是创建实现的时候了。
- en: Implementation of Visitor pattern
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式的实现
- en: 'We will start completing the implementation of the `VisitA(*MessageA)` and
    `VisitB(*MessageB)` methods:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始完成 `VisitA(*MessageA)` 和 `VisitB(*MessageB)` 方法的实现：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Its functionality is quite straightforward--the `fmt.Sprintf` method returns
    a formatted string with the actual contents of `m.Msg`, a white space, and the
    message, `Visited`. This string will be stored on the `Msg` field, overriding
    the previous contents.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它的功能非常简单- `fmt.Sprintf` 方法返回一个格式化的字符串，其中包含 `m.Msg` 的实际内容、一个空格和消息 `Visited`。这个字符串将被存储在
    `Msg` 字段上，覆盖先前的内容。
- en: 'Now we will develop the `Accept` method for each message type that must execute
    the corresponding Visitor:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为每种消息类型开发 `Accept` 方法，该方法必须执行相应的 Visitor：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This small code has some implications on it. In both cases, we are using a
    `Visitor`, which in our example is exactly the same as the `MessageVisitor` interface,
    but they could be completely different. The key is to understand that the Visitor
    pattern executes an algorithm in its `Visit` method that deals with the `Visitable`
    object. What could the `Visitor` be doing? In this example, it alters the `Visitable`
    object, but it could be simply fetching information from it. For example, we could
    have a `Person` type with lots of fields: name, surname, age, address, city, postal
    code, and so on. We could write a Visitor to fetch just the name and surname from
    a person as a unique string, a visitor to fetch the address info for a different
    section of an app, and so on.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码有一些含义。在这两种情况下，我们都使用了一个`Visitor`，在我们的例子中，它与`MessageVisitor`接口完全相同，但它们可以完全不同。关键是要理解访问者模式在其`Visit`方法中执行处理`Visitable`对象的算法。`Visitor`可能在做什么？在这个例子中，它改变了`Visitable`对象，但它也可以简单地从中获取信息。例如，我们可以有一个`Person`类型，有很多字段：姓名、姓氏、年龄、地址、城市、邮政编码等等。我们可以编写一个访问者，仅从一个人中获取姓名和姓氏作为唯一的字符串，一个访问者从应用程序的不同部分获取地址信息，等等。
- en: 'Finally, there is the `Print()` method, which will help us to test the types.
    We mentioned before that it must print to the `Stdout` call by default:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个`Print()`方法，它将帮助我们测试这些类型。我们之前提到它必须默认打印到`Stdout`：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It first checks the content of the `Output` field to assign the output of the `os.Stdout` call
    in case it is null. In our tests, we are storing a pointer there to our `TestHelper`
    type so this line is never executed in our test. Finally, each message type prints
    to the `Output` field, the full message stored in the `Msg` field. This is done
    by using the `Fprintf` method, which takes an `io.Writer` package as the first
    argument and the text to format as the next arguments.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查`Output`字段的内容，以便在`os.Stdout`调用的输出为空时将其赋值。在我们的测试中，我们在那里存储了一个指向我们的`TestHelper`类型的指针，因此在我们的测试中永远不会执行这行。最后，每个消息类型都会将存储在`Msg`字段中的完整消息打印到`Output`字段。这是通过使用`Fprintf`方法完成的，该方法将`io.Writer`包作为第一个参数，要格式化的文本作为下一个参数。
- en: 'Our implementation is now complete and we can run the tests again to see if
    they all pass now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现现在已经完成，我们可以再次运行测试，看看它们是否都通过了：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Everything is OK! The Visitor pattern has done its job flawlessly and the message
    contents were altered after calling their `Visit` methods. The very important
    thing here is that we can add more functionality to both the structs, `MessageA`
    and `MessageB`, without altering their types. We can just create a new Visitor
    type that does everything on the `Visitable`, for example, we can create a `Visitor`
    to add a method that prints the contents of the `Msg` field:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好！访问者模式已经完美地完成了它的工作，调用它们的`Visit`方法后，消息内容已经被改变。这里非常重要的一点是，我们可以为这两个结构体添加更多功能，`MessageA`和`MessageB`，而不改变它们的类型。我们只需创建一个新的访问者类型，对`Visitable`上的所有操作进行处理，例如，我们可以创建一个`Visitor`来添加一个打印`Msg`字段内容的方法：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have just added some functionality to both types without altering their contents!
    That's the power of the Visitor design pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为这两种类型添加了一些功能，而没有改变它们的内容！这就是访问者设计模式的威力。
- en: Another example
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个例子
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发第二个例子，这个例子会更加复杂一些。在这种情况下，我们将模拟一个有几种产品的在线商店。产品将具有简单的类型，只有字段，我们将创建一对访问者来处理它们。
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发接口。`ProductInfoRetriever` 类型有一个方法来获取产品的价格和名称。`Visitor` 接口，就像之前一样，有一个接受
    `ProductInfoRetriever` 类型的 `Visit` 方法。最后，`Visitable` 接口完全相同；它有一个接受 `Visitor` 类型作为参数的
    `Accept` 方法。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在线商店的所有产品都必须实现`ProductInfoRetriever`类型。此外，大多数产品都将具有一些共同的字段，例如名称或价格（在`ProductInfoRetriever`接口中定义的字段）。我们创建了`Product`类型，实现了`ProductInfoRetriever`和`Visitable`接口，并将其嵌入到每个产品中：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常通用的`Product`类型，可以存储商店几乎任何产品的信息。例如，我们可以有一个`Rice`和一个`Pasta`产品：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都嵌入了`Product`类型。现在我们需要创建一对`Visitors`接口，一个用于计算所有产品的价格总和，一个用于打印每个产品的名称：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriceVisitor`结构体获取`ProductInfoRetriever`类型的`Price`变量的值，作为参数传递，并将其添加到`Sum`字段。`NamePrinter`结构体存储`ProductInfoRetriever`类型的名称，作为参数传递，并将其附加到`ProductList`字段的新行上。'
- en: 'Time for the `main` function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`main`函数的时间：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个`Visitable`对象的切片：一个`Rice`和一个`Pasta`类型，带有一些任意的名称。然后我们使用`PriceVisitor`实例作为参数对它们进行迭代。在`range
    for`之后，我们打印总价格。最后，我们使用`NamePrinter`重复这个操作，并打印结果的`ProductList`。这个`main`函数的输出如下：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是访问者模式的一个很好的例子，但是...如果产品有特殊的考虑呢？例如，如果我们需要在冰箱类型的总价格上加20呢？好的，让我们编写`Fridge`结构：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是只需重写`GetPrice()`方法，以返回产品的价格加20：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这对我们的例子来说还不够。`Fridge`结构不是`Visitable`类型。`Product`结构是`Visitable`类型，而`Fridge`结构嵌入了一个`Product`结构，但是正如我们在前几章中提到的，嵌入第二种类型的类型不能被视为后者的类型，即使它具有所有的字段和方法。解决方案是还要实现`Accept(Visitor)`方法，以便它可以被视为`Visitable`：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`main`函数以将这个新的`Fridge`产品添加到切片中：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切都保持不变。运行这个新的`main`函数会产生以下输出：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，总价格现在更高了，输出了大米（32）、意大利面（40）和冰箱（50的产品加上20的运输，所以是70）的总和。我们可以不断地为这些产品添加访问者，但是想法很清楚——我们将一些算法解耦到访问者之外。
- en: Visitors to the rescue!
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者来拯救！
- en: We have seen a powerful abstraction to add new algorithms to some types. However,
    because of the lack of overloading in Go, this pattern could be limiting in some
    aspects (we have seen it in the first example, where we had to create the `VisitA`
    and `VisitB` implementations). In the second example, we haven't dealt with this
    limitation because we have used an interface to the `Visit` method of the `Visitor` struct,
    but we just used one type of visitor (`ProductInfoRetriever`) and we would have
    the same problem if we implemented a `Visit` method for a second type, which is
    one of the objectives of the original *Gang of Four* design patterns.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个强大的抽象，可以向某些类型添加新的算法。然而，由于Go语言中缺乏重载，这种模式在某些方面可能有限（我们在第一个示例中已经看到了这一点，在那里我们不得不创建`VisitA`和`VisitB`的实现）。在第二个示例中，我们没有处理这个限制，因为我们使用了`Visitor`结构的`Visit`方法的接口，但我们只使用了一种类型的访问者（`ProductInfoRetriever`），如果我们为第二种类型实现了`Visit`方法，我们将会遇到相同的问题，这是原始*四人帮*设计模式的目标之一。
- en: State design pattern
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态设计模式
- en: State patterns are directly related to FSMs. An FSM, in very simple terms, is
    something that has one or more states and travels between them to execute some
    behaviors. Let's see how the State pattern helps us to define FSM.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式与FSM直接相关。FSM，简单来说，是具有一个或多个状态并在它们之间移动以执行某些行为的东西。让我们看看状态模式如何帮助我们定义FSM。
- en: Description
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: A light switch is a common example of an FSM. It has two states--on and off.
    One state can transit to the other and vice versa. The way that the State pattern
    works is similar. We have a `State` interface and an implementation of each state
    we want to achieve. There is also usually a context that holds cross-information
    between the states.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个灯开关是FSM的一个常见例子。它有两种状态——开和关。一种状态可以转移到另一种状态，反之亦然。状态模式的工作方式类似。我们有一个`State`接口和我们想要实现的每个状态的实现。通常还有一个上下文，用于在状态之间保存交叉信息。
- en: With FSM, we can achieve very complex behaviors by splitting their scope between
    states. This way we can model pipelines of execution based on any kind of inputs
    or create event-driven software that responds to particular events in specified
    ways.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过FSM，我们可以通过将其范围分割为状态来实现非常复杂的行为。这样我们可以基于任何类型的输入来建模执行管道，或者创建对特定事件以指定方式做出响应的事件驱动软件。
- en: Objectives
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The main objectives of the State pattern is to develop FSM are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式的主要目标是开发FSM，如下所示：
- en: To have a type that alters its own behavior when some internal things have changed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一些内部事物发生变化时，拥有一种可以改变自身行为的类型
- en: Model complex graphs and pipelines can be upgraded easily by adding more states
    and rerouting their output states
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过添加更多状态并重新路由它们的输出状态轻松升级模型复杂的图形和管道
- en: A small guess the number game
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个小猜数字游戏
- en: We are going to develop a very simple game that uses FSM. This game is a number
    guessing game. The idea is simple--we will have to guess some number between 0
    and 10 and we have just a few attempts or we'll lose.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个非常简单的使用FSM的游戏。这个游戏是一个猜数字游戏。想法很简单——我们将不得不猜出0到10之间的某个数字，我们只有几次尝试，否则就会输掉。
- en: We will leave the player to choose the level of difficulty by asking how many
    tries the user has before losing. Then, we will ask the player for the correct
    number and keep asking if they don't guess it or if the number of tries reaches
    zero.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让玩家选择难度级别，询问用户在失去之前有多少次尝试。然后，我们将要求玩家输入正确的数字，并在他们猜不中或尝试次数达到零时继续询问。
- en: Acceptance criteria
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'For this simple game, we have five acceptance criteria that basically describe
    the mechanics of the game:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的游戏，我们有五个验收标准，基本上描述了游戏的机制：
- en: The game will ask the player how many tries they will have before losing the
    game.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏将询问玩家在失去游戏之前有多少次尝试。
- en: The number to guess must be between 0 and 10.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要猜的数字必须在0到10之间。
- en: Every time a player enters a number to guess, the number of retries drops by
    one.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当玩家输入一个要猜的数字时，重试次数就会减少一个。
- en: If the number of retries reaches zero and the number is still incorrect, the
    game finishes and the player has lost.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果重试次数达到零且数字仍然不正确，游戏结束，玩家输了。
- en: If the player guesses the number, the player wins.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家猜中数字，玩家获胜。
- en: Implementation of State pattern
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式的实现
- en: The idea of unit tests is quite straightforward in a State pattern so we will
    spend more time explaining in detail the mechanism to use it, which is a bit more
    complex than usual.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的想法在状态模式中非常简单，因此我们将花更多时间详细解释如何使用它的机制，这比通常更复杂一些。
- en: 'First of all, we need the interface to represent the different states and a
    game context to store the information between states. For this game, the context
    needs to store the number of retries, if the user has won or not, the secret number
    to guess, and the current state. The state will have an `executeState` method
    that accepts one of these contexts and returns `true` if the game has finished,
    or `false` if not:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个接口来表示不同的状态和一个游戏上下文来存储状态之间的信息。对于这个游戏，上下文需要存储重试次数，用户是否已经赢得游戏，要猜的秘密数字和当前状态。状态将有一个`executeState`方法，该方法接受这些上下文之一，并在游戏结束时返回`true`，否则返回`false`：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As described in *acceptance criteria 1*, the player must be able to introduce
    the number of retries they want. This will be achieved by a state called `StartState`.
    Also, the `StartState` struct must prepare the game, setting the context to its
    initial value before the player:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如*验收标准1*中所述，玩家必须能够输入他们想要的重试次数。这将通过一个名为`StartState`的状态来实现。此外，`StartState`结构必须在玩家之前设置上下文的初始值：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First of all, the `StartState` struct implements the `GameState` structure because
    it has the `executeState(*Context)` method of Boolean type on its structure. At
    the beginning of this state, it sets the only state possible after executing this
    one--the `AskState` state. The `AskState` struct is not declared yet, but it will
    be the state where we ask the player for a number to guess.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`StartState`结构实现了`GameState`结构，因为它在其结构上具有`executeState(*Context)`方法，返回布尔类型。在这个状态的开始，它设置了执行完这个状态后唯一可能的状态--`AskState`状态。`AskState`结构尚未声明，但它将是我们询问玩家猜数字的状态。
- en: In the next two lines, we use the `Rand` package of Go to generate a random
    number. In the first line, we feed the random generator with the `int64` type
    number returned by the current moment, so we ensure a random feed in each execution
    (if you put a constant number here, the randomizer will also generate the same
    number too). The `rand.Intn(int)` method returns an integer number between zero
    and the specified number, so here we cover *acceptance criteria 2*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行中，我们使用Go的`Rand`包生成一个随机数。在第一行中，我们用当前时刻返回的`int64`类型数字来喂入随机生成器，因此我们确保每次执行都有一个随机的喂入（如果你在这里放一个常数，随机生成器也会生成相同的数字）。`rand.Intn(int)`方法返回0到指定数字之间的整数，因此我们满足了*验收标准2*。
- en: Next, a message asking for a number of retries to set precedes the `fmt.Fscanf`
    method, a powerful function where you can pass it an `io.Reader` (the standard
    input of the console), a format (number), and an interface to store the contents
    of the reader, in this case, the `Retries` field of the context.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置一个消息询问要设置的重试次数，然后使用`fmt.Fscanf`方法，一个强大的函数，您可以向其传递一个`io.Reader`（控制台的标准输入）、一个格式（数字）和一个接口来存储读取器的内容，在这种情况下是上下文的`Retries`字段。
- en: 'Finally, we return `true` to tell the engine that the game must continue. Let''s
    see the `AskState` struct, which we have used at the beginning of the function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回`true`告诉引擎游戏必须继续。让我们看看我们在函数开头使用的`AskState`结构：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `AskState` structure also implements the `GameState` state, as you have
    probably guessed already. This states starts with a message for the player, asking
    them to insert a new number. In the next three lines, we create a local variable
    to store the contents of the number that the player will introduce. We used the
    `fmt.Fscanf` method again, as we did in `StartState` struct to capture the player's
    input and store it in the variable `n`. Then, we have one retry less in our counter,
    so we have to subtract one to the number of retries represented in the `Retries`
    field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`AskState`结构也实现了`GameState`状态，你可能已经猜到了。这个状态从一个向玩家的消息开始，要求他们插入一个新的数字。在接下来的三行中，我们创建一个本地变量来存储玩家将要输入的数字的内容。我们再次使用`fmt.Fscanf`方法，就像我们在`StartState`结构中做的那样，来捕获玩家的输入并将其存储在变量`n`中。然后，我们的计数器中的重试次数减少了一个，所以我们必须在上下文的`Retries`字段中减去一个。'
- en: 'Then, there are two checks: one that checks if the user has entered the correct
    number, in which case the context field `Won` is set to `true` and the next state
    is set to the `FinishState` struct (not declared yet).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个检查：一个检查用户是否输入了正确的数字，如果是，则上下文字段`Won`设置为`true`，下一个状态设置为`FinishState`结构（尚未声明）。
- en: The second check is controlling that the number of retries has not reached zero,
    in which case it won't let the player ask again for a number and it will send
    the player to the `FinishState` struct directly. After all, we have to tell the
    game engine again that the game must continue by returning `true` in the `executeState`
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个检查是控制重试次数是否已经达到零，如果是，则不会让玩家再次要求输入数字，并直接将玩家发送到`FinishState`结构。毕竟，我们必须再次告诉游戏引擎游戏必须继续，通过在`executeState`方法中返回`true`。
- en: 'Finally, we define the `FinishState` struct. It controls the exit status of
    the game, checking the contents of the `Won` field in the context object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`FinishState`结构。它控制游戏的退出状态，检查上下文对象中`Won`字段的内容：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `TheFinishState` struct also implements the `GameState` state by having
    `executeState` method in its structure. The idea here is very simple--if the player
    has won (this field is set previously in the `AskState` struct), the `FinishState`
    structure will print the message `Congrats, you won`. If the player has not won
    (remember that the zero value of the Boolean variable is `false`), the `FinishState`
    prints the message `You lose.`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheFinishState`结构也通过在其结构中具有`executeState`方法来实现`GameState`状态。这里的想法非常简单——如果玩家赢了（这个字段之前在`AskState`结构中设置），`FinishState`结构将打印消息`恭喜，你赢了`。如果玩家没有赢（记住布尔变量的零值是`false`），`FinishState`将打印消息`你输了`。'
- en: In this case, the game can be considered finished, so we return `false` to say
    that the game must not continue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，游戏可以被认为已经结束，所以我们返回`false`来表示游戏不应该继续。
- en: 'We just need the `main` method to play our game:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要`main`方法来玩我们的游戏。
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Well, yes, it can't be simpler. The game must begin with the `start` method,
    although it could be abstracted more outside in case that the game needs more
    initialization in the future, but in our case it is fine. Then, we create a context
    where we set the `Next` state as a pointer to the `start` variable. So the first
    state that will be executed in the game will be the `StartState` state.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的，它不能再简单了。游戏必须从`start`方法开始，尽管在未来游戏需要更多初始化的情况下，它可以更抽象地放在外面，但在我们的情况下没问题。然后，我们创建一个上下文，将`Next`状态设置为指向`start`变量的指针。因此，在游戏中将执行的第一个状态将是`StartState`状态。
- en: The last line of the `main` function has a lot of things just there. We create
    a loop, without any statement inside it. As with any loop, it keeps looping after
    the condition is not satisfied. The condition we are using is the returned value
    of the `GameStates` structure, `true` as soon as the game is not finished.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的最后一行有很多东西。我们创建了一个循环，里面没有任何语句。和任何循环一样，在条件不满足后它会继续循环。我们使用的条件是`GameStates`结构的返回值，在游戏未结束时为`true`。'
- en: 'So, the idea is simple: we execute the state in the context, passing a pointer
    to the context to it. Each state returns `true` until the game has finished and
    the `FinishState` struct will return `false`. So our for loop will keep looping,
    waiting for a `false` condition sent by the `FinishState` structure to end the
    application.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，思路很简单：我们在上下文中执行状态，将上下文的指针传递给它。每个状态都返回`true`，直到游戏结束，`FinishState`结构将返回`false`。所以我们的循环将继续循环，等待`FinishState`结构发送的`false`条件来结束应用程序。
- en: 'Let''s play once:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再玩一次：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We lost! We set the number of retries to 5\. Then we kept inserting numbers,
    trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn't
    any of them. I don't even know what the correct number was; let's fix this!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输了！我们把重试次数设为5。然后我们继续插入数字，试图猜出秘密数字。我们输入了8、2、1、3和4，但都不对。我甚至不知道正确的数字是多少；让我们来修复这个！
- en: 'Go to the definition of the `FinishState` struct and change the line where
    it says `You lose`, and replace it with the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 去到`FinishState`结构的定义并且改变那一行写着`You lose`的地方，用以下内容替换它：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now it will show the correct number. Let''s play again:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它会显示正确的数字。让我们再玩一次：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time we make it a little harder by setting only three tries... and we
    lost again. I entered 6, 2, and 1, but the correct number was 9\. Last try:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们把难度加大了，只设置了三次尝试……但我们又输了。我输入了6、2和1，但正确的数字是9。最后一次尝试：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great! This time we lowered the difficulty, allowing up to five tries and we
    won! we even had one more try left, but we guessed the number in the fourth try
    after entering 3, 4, 5\. The correct number was 6, which was my fourth try.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这次我们降低了难度，允许最多五次尝试，我们赢了！我们甚至还有一次尝试剩下，但我们在第四次尝试后猜中了数字，输入了3、4、5。正确的数字是6，这是我的第四次尝试。
- en: A state to win and a state to lose
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个赢的状态和一个输的状态
- en: 'Have you realized that we could have a winning and a lose state instead of
    printing the messages directly in the `FinishState` struct? This way we could,
    for example, check some hypothetical scoreboard in the win section to see if we
    have set a record. Let''s refactor our game. First we need a `WinState` and a
    `LoseState` struct:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到我们可以有一个赢和一个输的状态，而不是直接在`FinishState`结构中打印消息？这样我们可以，例如，在赢的部分检查一些假设的得分板，看看我们是否创造了记录。让我们重构我们的游戏。首先我们需要一个`WinState`和一个`LoseState`结构：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These two new states have nothing new. They contain the same messages that
    were previously in the `FinishState` state that, by the way, must be modified
    to use these new states:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新状态没有什么新东西。它们包含了之前在`FinishState`状态中的相同消息，顺便说一句，必须修改为使用这些新状态：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, the finish state doesn't print anything and, instead, delegates this to
    the next state in the chain--the `WinState` structure, if the user has won and
    the `LoseState` struct, if not. Remember that the game doesn't finish on the `FinishState`
    struct now, and we must return `true` instead of `false` to notify to the engine
    that it must keep executing states in the chain.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结束状态不再打印任何东西，而是将其委托给链中的下一个状态——如果用户赢了，则是`WinState`结构，如果没有，则是`LoseState`结构。记住，游戏现在不会在`FinishState`结构上结束，我们必须返回`true`而不是`false`来通知引擎必须继续执行链中的状态。
- en: The game built using the State pattern
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用状态模式构建的游戏
- en: You must be thinking now that you can extend this game forever with new states,
    and it's true. The power of the State pattern is not only the capacity to create
    a complex FSM, but also the flexibility to improve it as much as you want by adding
    new states and modifying some old states to point to the new ones without affecting
    the rest of the FSM.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能会想，你可以用新状态无限扩展这个游戏，这是真的。状态模式的威力不仅在于创建复杂的有限状态机的能力，还在于通过添加新状态和修改一些旧状态指向新状态而不影响有限状态机的其余部分来改进它的灵活性。
- en: Mediator design pattern
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者设计模式
- en: Let's continue with the Mediator pattern. As its name implies, it's a pattern
    that will be in between two types to exchange information. But, why will we want
    this behavior at all? Let's look at this in detail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用中介者模式。顾名思义，它是一种将处于两种类型之间以交换信息的模式。但是，为什么我们会想要这种行为呢？让我们仔细看一下。
- en: Description
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: One of the key objectives of any design pattern is to avoid tight coupling between
    objects. This can be done in many ways, as we have seen already.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 任何设计模式的关键目标之一是避免对象之间的紧密耦合。这可以通过多种方式实现，正如我们已经看到的。
- en: But one particularly effective method when the application grows a lot is the
    Mediator pattern. The Mediator pattern is the perfect example of a pattern that
    is commonly used by every programmer without thinking very much about it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当应用程序增长很多时，特别有效的一种方法是中介者模式。中介者模式是一个很好的例子，它是每个程序员通常在不太考虑的情况下使用的模式。
- en: Mediator pattern will act as the type in charge of exchanging communication
    between two objects. This way, the communicating objects don't need to know each
    other and can change more freely. The pattern that maintains which objects give
    what information is the Mediator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式将充当两个对象之间交换通信的类型。这样，通信的对象不需要彼此了解，可以更自由地进行更改。维护对象提供什么信息的模式是中介者。
- en: Objectives
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'As previously described, the main objectives of the Mediator pattern are about
    loose coupling and encapsulation. The objectives are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，中介者模式的主要目标是松散耦合和封装。目标是：
- en: To provide loose coupling between two objects that must communicate between
    them
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提供两个必须相互通信的对象之间的松散耦合
- en: To reduce the amount of dependencies of a particular type to the minimum by
    passing these needs to the Mediator pattern
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将这些需求传递给中介者模式，减少特定类型的依赖量
- en: A calculator
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个计算器
- en: For the Mediator pattern, we are going to develop an extremely simple arithmetic
    calculator. You're probably thinking that a calculator is so simple that it does
    not need any pattern. But we will see that this is not exactly true.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中介者模式，我们将开发一个非常简单的算术计算器。你可能认为计算器如此简单，不需要任何模式。但我们会看到这并不完全正确。
- en: 'Our calculator will only do two very simple operations: sum and subtract.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算器只会执行两个非常简单的操作：求和和减法。
- en: Acceptance criteria
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'It sounds quite funny to talk about acceptance criteria to define a calculator,
    but let''s do it anyway:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 谈论验收标准来定义一个计算器听起来相当有趣，但无论如何我们都要做：
- en: Define an operation called `Sum` that takes a number and adds it to another
    number.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Sum`的操作，它接受一个数字并将其加到另一个数字。
- en: Define an operation called `Subtract` that takes a number and substracts it
    to another number.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`Subtract`的操作，它接受一个数字并将其减去另一个数字。
- en: Well, I don't know about you, but I really need a rest after this *complex*
    criteria. So why are we defining this so much? Patience, you will have the answer
    soon.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我不知道你怎么想，但在这个*复杂*的标准之后，我真的需要休息。那么为什么我们要这么定义呢？耐心点，你很快就会得到答案。
- en: Implementation
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We have to jump directly to the implementation because we cannot test that the
    sum will be correct (well, we can, but we will be testing if Go is correctly written!).
    We could test that we pass the acceptance criteria, but it's a bit of an overkill
    for our example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须直接跳到实现，因为我们无法测试求和是否正确（嗯，我们可以，但那样就是在测试Go是否写得正确！）。我们可以测试是否符合验收标准，但对于我们的例子来说有点过度了。
- en: 'So let''s start by implementing the necessary types:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们从实现必要的类型开始：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Well... this look quite awkward. We already have numeric types in Go to perform
    these operations, we don't need a type for each number!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...这看起来相当尴尬。我们在Go中已经有数字类型来执行这些操作，我们不需要为每个数字都定义一个类型！
- en: 'But let''s continue for a second with this insane approach. Let''s implement
    the `One` struct:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们再继续一下这种疯狂的方法。让我们实现`One`结构：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: OK , I'll stop here. What is wrong with this implementation? This is completely
    crazy! It's overkill to make every operation possible between numbers to make
    sums! Especially when we have more than one digit.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我就说到这里。这个实现有什么问题？这完全疯狂！为了进行求和而使每种可能的数字操作都变得太过了！特别是当我们有多于一位数时。
- en: Well, believe it or not, this is how a lot of software is commonly designed
    today. A small app where an object uses two or three objects grows, and it ends
    up using dozens of them. It becomes an absolute hell to simply add or remove a
    type from the application because it is hidden in some of this craziness.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，信不信由你，这就是今天许多软件通常设计的方式。一个对象使用两个或三个对象的小应用程序会增长，最终使用数十个对象。仅仅因为它隐藏在某些疯狂的地方，所以要简单地添加或删除应用程序中的类型变得非常困难。
- en: 'So what can we do in this calculator? Use a Mediator type that frees all the
    cases:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在这个计算器中我们能做什么？使用一个中介者类型来解放所有情况：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have just developed a couple of numbers to keep things short. The `Sum` function
    acts as a mediator between two numbers. First it checks the type of the first
    number named `a`. Then, for each type of the first number, it checks the type
    of the second number named `b` and returns the resulting type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只开发了一对数字来简化。`Sum`函数充当两个数字之间的中介者。首先它检查名为`a`的第一个数字的类型。然后，对于第一个数字的每种类型，它检查名为`b`的第二个数字的类型，并返回结果类型。
- en: While the solution still looks very crazy now, the only one that knows about
    all possible numbers in the calculator is the `Sum` function. But take a closer
    look and you'll see that we have added a type case for the `int` type. We have
    cases `One`, `Two` , and `int`. Inside the `int` case, we also have another `int` case
    for the `b` number. What do we do here? If both types are of the `int` case, we
    can return the sum of them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解决方案现在看起来仍然非常疯狂，但唯一知道计算器中所有可能数字的是`Sum`函数。但仔细看，你会发现我们为`int`类型添加了一个类型情况。我们有`One`、`Two`和`int`情况。在`int`情况下，我们还有另一个`int`情况用于`b`数字。我们在这里做什么？如果两种类型都是`int`情况，我们可以返回它们的和。
- en: 'Do you think that this will work? Let''s write a simple `main` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这样会有效吗？让我们写一个简单的`main`函数：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We print the sum of type `One` and type `Two`. By using the `"%#v"` format,
    we ask to print information about the type. The second line in the function uses
    `int` types, and we also print the result. This in the console produces the following
    output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印类型`One`和类型`Two`的总和。通过使用`"%#v"`格式，我们要求打印有关类型的信息。函数中的第二行使用`int`类型，并且我们还打印结果。这在控制台上产生以下输出：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Not very impressive, right? But let's think for a second. By using the Mediator
    pattern, we have been able to refactor the initial calculator, where we have to
    define every operation on every type to a Mediator pattern, the `Sum` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不是很令人印象深刻，对吧？但是让我们思考一下。通过使用中介者模式，我们已经能够重构最初的计算器，在那里我们必须为每种类型定义每个操作，转换为中介者模式的`Sum`函数。
- en: 'The nice thing is that, thanks to the Mediator pattern, we have been able to
    start using integers as values for our calculator. We have just defined the simplest
    example by adding two integers, but we could have done the same with an integer
    and the `type`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于，由于中介者模式的存在，我们已经能够开始将整数作为计算器的值使用。我们刚刚通过添加两个整数定义了最简单的示例，但我们也可以使用整数和`type`来做同样的事情：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With this small modification, we can now use type `One` with an `int` as number
    `b`. If we keep working on this Mediator pattern, we could achieve a lot of flexibility
    between types, without having to implement every possible operation between them,
    generating a tight coupling.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小修改，我们现在可以使用类型`One`和`int`作为数字`b`。如果我们继续在中介者模式上工作，我们可以在类型之间实现很大的灵活性，而无需实现它们之间的每种可能操作，从而产生紧密耦合。
- en: 'We''ll add a new `Sum` method in the main function to see this in action:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主函数中添加一个新的`Sum`方法，以查看其运行情况：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Nice. The Mediator pattern is in charge of knowing about the possible types
    and returns the most convenient type for our case, which is an integer. Now we
    could keep growing this `Sum` function until we completely get rid of using the
    numeric types we have defined.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。中介者模式负责了解可能的类型并返回最适合我们情况的类型，即整数。现在我们可以继续扩展这个`Sum`函数，直到完全摆脱使用我们定义的数值类型。
- en: Uncoupling two types with the Mediator
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中介者解耦两种类型
- en: We have carried out a disruptive example to try to think outside the box and
    reason deeply about the Mediator pattern. Tight coupling between entities in an
    app can become really complex to deal with in the future and allow more difficult
    refactoring if needed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了一个颠覆性的示例，试图超越传统思维，深入思考中介者模式。应用程序中实体之间的紧密耦合可能在未来变得非常复杂，并且如果需要进行更复杂的重构，则可能更加困难。
- en: Just remember that the Mediator pattern is there to act as a managing type between
    two types that don't know about each other so that you can take one of the types
    without affecting the other and replace a type in a more easy and convenient way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，中介者模式的作用是作为两种不相互了解的类型之间的管理类型，以便您可以获取其中一种类型而不影响另一种类型，并以更轻松和便捷的方式替换类型。
- en: Observer design pattern
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者设计模式
- en: 'We will finish the common *Gang of Four* design patterns with my favorite:
    the Observer pattern, also known as publish/subscriber or publish/listener. With
    the State pattern, we defined our first event-driven architecture, but with the
    Observer pattern we will really reach a new level of abstraction.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用我最喜欢的*四人帮*设计模式之一结束，即观察者模式，也称为发布/订阅或发布/监听器。通过状态模式，我们定义了我们的第一个事件驱动架构，但是通过观察者模式，我们将真正达到一个新的抽象层次。
- en: Description
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: The idea behind the Observer pattern is simple--to subscribe to some event that
    will trigger some behavior on many subscribed types. Why is this so interesting?
    Because we uncouple an event from its possible handlers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式背后的思想很简单--订阅某个事件，该事件将触发许多订阅类型上的某些行为。为什么这么有趣？因为我们将一个事件与其可能的处理程序解耦。
- en: For example, imagine a login button. We could code that when the user clicks
    the button, the button color changes, an action is executed, and a form check
    is performed in the background. But with the Observer pattern, the type that changes
    the color will subscribe to the event of the clicking of the button. The type
    that checks the form and the type that performs an action will subscribe to this
    event too.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个登录按钮。我们可以编写代码，当用户点击按钮时，按钮颜色会改变，执行一个操作，并在后台执行表单检查。但是通过观察者模式，更改颜色的类型将订阅按钮点击事件。检查表单的类型和执行操作的类型也将订阅此事件。
- en: Objectives
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The Observer pattern is especially useful to achieve many actions that are
    triggered on one event. It is also especially useful when you don''t know how
    many actions are performed after an event in advance or there is a possibility
    that the number of actions is going to grow in the near future. To resume, do
    the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式特别有用，可以在一个事件上触发多个操作。当您事先不知道有多少操作会在事件之后执行，或者有可能操作的数量将来会增加时，它也特别有用。总之，执行以下操作：
- en: Provide an event-driven architecture where one event can trigger one or more
    actions
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个事件驱动的架构，其中一个事件可以触发一个或多个操作
- en: Uncouple the actions that are performed from the event that triggers them
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行的操作与触发它们的事件解耦
- en: Provide more than one event that triggers the same action
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供触发相同操作的多个事件
- en: The notifier
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知者
- en: We will develop the simplest possible application to fully understand the roots
    of the Observer pattern. We are going to make a `Publisher` struct, which is the
    one that triggers an event so it must accept new observers and remove them if
    necessary. When the `Publisher` struct is triggered, it must notify all its observers
    of the new event with the data associated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发最简单的应用程序，以充分理解观察者模式的根源。我们将创建一个`Publisher`结构，它是触发事件的结构，因此必须接受新的观察者，并在必要时删除它们。当触发`Publisher`结构时，它必须通知所有观察者有关关联数据的新事件。
- en: Acceptance criteria
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验收标准
- en: 'The requirements must tell us to have some type that triggers some method in
    one or more actions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 需求必须告诉我们有一些类型会触发一个或多个操作的某种方法：
- en: We must have a publisher with a `NotifyObservers` method that accepts a message
    as an argument and triggers a `Notify` method on every observer subscribed.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个带有`NotifyObservers`方法的发布者，该方法接受消息作为参数并触发订阅的每个观察者上的`Notify`方法。
- en: We must have a method to add new subscribers to the publisher.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个方法向发布者添加新的订阅者。
- en: We must have a method to remove new subscribers from the publisher.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须有一个方法从发布者中删除新的订阅者。
- en: Unit tests
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Maybe you have realized that our requirements defined almost exclusively the
    `Publisher` type. This is because the action performed by the observer is irrelevant
    for the Observer pattern. It should simply execute an action, in this case the
    `Notify` method, that one or many types will implement. So let''s define this
    only interface for this pattern:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经意识到，我们的要求几乎完全定义了`Publisher`类型。这是因为观察者执行的操作对观察者模式来说是无关紧要的。它应该只执行一个动作，即`Notify`方法，在这种情况下，一个或多个类型将实现。因此，让我们为此模式定义唯一的接口：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Observer` interface has a `Notify` method that accepts a `string` type
    that will contain the message to spread. It does not need to return anything,
    but we could return an error if we want to check if all observers have been reached
    when calling the `publish` method of the `Publisher` structure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`接口有一个`Notify`方法，它接受一个`string`类型，其中包含要传播的消息。它不需要返回任何东西，但是当调用`Publisher`结构的`publish`方法时，我们可以返回一个错误，以便检查是否已经到达了所有观察者。'
- en: 'To test all the acceptance criteria, we just need a structure called `Publisher`
    with three methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试所有的验收标准，我们只需要一个名为`Publisher`的结构，其中包含三种方法：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Publisher` structure stores the list of subscribed observers in a slice
    field called `ObserversList`. Then it has the three methods mentioned on the acceptance
    criteria-the `AddObserver` method to subscribe a new observer to the publisher,
    the `RemoveObserver` method to unsubscribe an observer, and the `NotifyObservers`
    method with a string that acts as the message we want to spread between all observers.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`结构将订阅的观察者列表存储在名为`ObserversList`的切片字段中。然后它具有接受标准的三种方法--`AddObserver`方法用于向发布者订阅新的观察者，`RemoveObserver`方法用于取消订阅观察者，以及`NotifyObservers`方法，其中包含一个作为我们想要在所有观察者之间传播的消息的字符串。'
- en: 'With these three methods, we have to set up a root test to configure the `Publisher`
    and three subtests to test each method. We also need to define a test type structure
    that implements the `Observer` interface. This structure is going to be called
    `TestObserver`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三种方法，我们必须设置一个根测试来配置`Publisher`和三个子测试来测试每种方法。我们还需要定义一个实现`Observer`接口的测试类型结构。这个结构将被称为`TestObserver`：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `TestObserver` structure implements the Observer pattern by defining a `Notify(string)`
    method in its structure. In this case, it prints the received message together
    with its own observer ID. Then, it stores the message in its `Message` field.
    This allows us to check later if the content of the `Message` field is as expected.
    Remember that it could also be done by passing the `testing.T` pointer and the
    expected message and checking within the `TestObserver` structure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestObserver`结构通过在其结构中定义`Notify(string)`方法来实现观察者模式。在这种情况下，它打印接收到的消息以及自己的观察者ID。然后，它将消息存储在其`Message`字段中。这使我们可以稍后检查`Message`字段的内容是否符合预期。请记住，也可以通过传递`testing.T`指针和预期消息并在`TestObserver`结构内部进行检查来完成。'
- en: 'Now we can set up the `Publisher` structure to execute the three tests. We
    will create three instances of the `TestObserver` structure:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置`Publisher`结构来执行这三个测试。我们将创建`TestObserver`结构的三个实例：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We have given a different ID to each observer so that we can see later that
    each of them has printed the expected message. Then, we have added the observers
    by calling the `AddObserver` method on the `Publisher` structure.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个观察者分配了不同的ID，以便稍后可以看到它们每个人都打印了预期的消息。然后，我们通过在`Publisher`结构上调用`AddObserver`方法来添加观察者。
- en: 'Let''s write an `AddObserver` test, it must add a new observer to the `ObserversList`
    field of the `Publisher` structure:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`AddObserver`测试，它必须将新的观察者添加到`Publisher`结构的`ObserversList`字段中：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We have added three observers to the `Publisher` structure, so the length of
    the slice must be 3\. If it's not 3, the test will fail.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向`Publisher`结构添加了三个观察者，因此切片的长度必须为3。如果不是3，测试将失败。
- en: 'The `RemoveObserver` test will take the observer with ID 2 and remove it from
    the list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveObserver`测试将获取ID为2的观察者并将其从列表中删除：'
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After removing the second observer, the length of the `Publisher` structure
    must be 2 now. We also check that none of the observers left have the `ID` 2 because
    it must be removed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 删除第二个观察者后，`Publisher`结构的长度现在必须为2。我们还检查剩下的观察者中没有一个的`ID`为2，因为它必须被移除。
- en: 'The last method to test is the `Notify` method. When using the `Notify` method,
    all instances of `TestObserver` structure must change their `Message` field from
    empty to the passed message (`Hello World!` in this case). First we will check
    that all the `Message` fields are, in fact, empty before calling the `NotifyObservers`
    test:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后一个方法是`Notify`方法。使用`Notify`方法时，所有`TestObserver`结构的实例都必须将它们的`Message`字段从空更改为传递的消息（在本例中为`Hello
    World!`）。首先，我们将检查在调用`NotifyObservers`测试之前所有的`Message`字段是否实际上都是空的：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using a `for` statement, we are iterating over the `ObserversList` field to
    slice in the `publisher` instance. We need to make a type casting from a pointer
    to an observer, to a pointer to the `TestObserver` structure, and check that the
    casting has been done correctly. Then, we check that the `Message` field is actually
    empty.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`语句，我们正在迭代`publisher`实例中的`ObserversList`字段。我们需要将指针从观察者转换为`TestObserver`结构的指针，并检查转换是否已正确完成。然后，我们检查`Message`字段实际上是否为空。
- en: 'The next step is to create a message to send--in this case, it will be `"Hello
    World!"` and then pass this message to the `NotifyObservers` method to notify
    every observer on the list (currently observers 1 and 3 only):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建要发送的消息--在本例中，它将是`"Hello World!"`，然后将此消息传递给`NotifyObservers`方法，以通知列表上的每个观察者（目前只有观察者1和3）：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After calling the `NotifyObservers` method, each `TestObserver` tests in the
    `ObserversList` field must have the message `"Hello World!"` stored in their `Message`
    field. Again, we use a `for` loop to iterate over every observer of the `ObserversList`
    field and we typecast each to a `TestObserver` test (remember that `TestObserver`
    structure doesn't have any field as it's an interface). We could avoid type casting
    by adding a new `Message()` method to `Observer` instance and implementing it
    in the `TestObserver` structure to return the contents of the `Message` field.
    Both methods are equally valid. Once we have type casted to a `TestObserver` method
    called `printObserver` variable as a local variable, we check that each instance
    in the `ObserversList` structure has the string `"Hello World!"` stored in their
    `Message` field.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`NotifyObservers`方法后，`ObserversList`字段中的每个`TestObserver`测试必须在其`Message`字段中存储`"Hello
    World!"`消息。同样，我们使用`for`循环来遍历`ObserversList`字段中的每个观察者，并将每个类型转换为`TestObserver`测试（请记住，`TestObserver`结构没有任何字段，因为它是一个接口）。我们可以通过向`Observer`实例添加一个新的`Message()`方法并在`TestObserver`结构中实现它来避免类型转换，以返回`Message`字段的内容。这两种方法都是有效的。一旦我们将类型转换为`TestObserver`方法调用`printObserver`变量作为局部变量，我们检查`ObserversList`结构中的每个实例是否在其`Message`字段中存储了字符串`"Hello
    World!"`。
- en: 'Time to run the tests that must fail all to check their effectiveness in the
    later implementation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行测试了，必须全部失败以检查它们在后续实现中的有效性：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Something isn't working as expected. How is the `Notify` method passing the
    tests if we haven't implemented the function yet? Take a look at the test of the
    `Notify` method again. The test iterates over the `ObserversList` structure and
    each `F` `ail` call is inside this for loop. If the list is empty, it won't iterate,
    so it won't execute any `Fail call`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有些地方不如预期。如果我们还没有实现函数，`Notify`方法是如何通过测试的？再看一下`Notify`方法的测试。测试遍历`ObserversList`结构，并且每个`Fail`调用都在此`for`循环内。如果列表为空，它将不会进行迭代，因此不会执行任何`Fail`调用。
- en: 'Let''s fix this issue by adding a small non-empty list check at the beginning
    of the `Notify` test:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Notify`测试的开头添加一个小的非空列表检查来解决这个问题：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And we will rerun the tests to see if the `TestSubject/Notify` method is already
    failing:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新运行测试，看看`TestSubject/Notify`方法是否已经失败：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Nice, all of them are failing and now we have some guarantee on our tests. We
    can proceed to the implementation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它们全部失败了，现在我们对测试有了一些保证。我们可以继续实现。
- en: Implementation
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Our implementation is just to define the `AddObserver`, the `RemoveObserver`,
    and the `NotifyObservers` methods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现只是定义`AddObserver`、`RemoveObserver`和`NotifyObservers`方法：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `AddObserver` method adds the `Observer` instance to the `ObserversList`
    structure by appending the pointer to the current list of pointers. This one was
    very easy. The `AddObserver` test must be passing now (but not the rest or we
    could have done something wrong):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddObserver`方法通过将指针附加到当前指针列表来将`Observer`实例添加到`ObserversList`结构中。这很容易。`AddObserver`测试现在必须通过（但其他测试不通过，否则我们可能做错了什么）：'
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Excellent. Just the `AddObserver` method has passed the test, so we can now
    continue to the `RemoveObserver` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。只有`AddObserver`方法通过了测试，所以我们现在可以继续进行`RemoveObserver`方法：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `RemoveObserver` method will iterate for each element in the `ObserversList`
    structure, comparing the `Observer` object''s `o` variable with the ones stored
    in the list. If it finds a match, it saves the index  in the local variable, `indexToRemove`,
    and stops the iteration. The way to remove indexes on a slice in Go is a bit tricky:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveObserver`方法将遍历`ObserversList`结构中的每个元素，将`Observer`对象的`o`变量与列表中存储的对象进行比较。如果找到匹配项，它将保存在本地变量`indexToRemove`中，并停止迭代。在Go中删除切片的索引有点棘手：'
- en: First, we need to use slice indexing to return a new slice containing every
    object from the beginning of the slice to the index we want to remove (not included).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用切片索引来返回一个新的切片，其中包含从切片开头到我们想要移除的索引（不包括）的每个对象。
- en: Then, we get another slice from the index we want to remove (not included) to
    the last object in the slice
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从要删除的索引（不包括）到切片中的最后一个对象获取另一个切片
- en: Finally, we join the previous two new slices into a new one (the `append` function)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将前两个新切片合并成一个新的切片（使用`append`函数）
- en: For example, in a list from 1 to 10 in which we want to remove the number 5,
    we have to create a new slice, joining a slice from 1 to 4 and a slice from 6
    to 10.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个从1到10的列表中，我们想要移除数字5，我们必须创建一个新的切片，将从1到4的切片和从6到10的切片连接起来。
- en: This index removal is done with the `append` function again because we are actually
    appending two lists together. Just take a closer look at the three dots at the
    end of the second argument of the `append` function. The `append` function adds
    an element (the second argument) to a slice (the first), but we want to append
    an entire list. This can be achieved using the three dots, which translate to
    something like *keep adding elements until you finish the second array*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个索引移除是使用`append`函数完成的，因为我们实际上是将两个列表连接在一起。仔细看一下`append`函数第二个参数末尾的三个点。`append`函数将一个元素（第二个参数）添加到一个切片（第一个参数），但我们想要添加整个列表。这可以通过使用三个点来实现，它们的作用类似于*继续添加元素，直到完成第二个数组*。
- en: 'Ok, let''s run this test now:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们运行这个测试：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We continue in the good path. The `RemoveObserver` test has been fixed without
    fixing anything else. Now we have to finish our implementation by defining the
    `NotifyObservers` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续在正确的路径上。`RemoveObserver`测试已经修复，而没有修复其他任何东西。现在我们必须通过定义`NotifyObservers`方法来完成我们的实现：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `NotifyObservers` method is quite simple because it prints a message to
    the console to announce that a particular message is going to be passed to the
    `Observers`. After this, we use a for loop to iterate over `ObserversList` structure
    and execute each `Notify(string)` method by passing the argument `m`. After executing
    this, all observers must have the message `Hello World!` stored in their `Message`
    field. Let''s see if this is true by running the tests:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: “NotifyObservers”方法非常简单，因为它在控制台上打印一条消息，宣布特定消息将传递给“观察者”。之后，我们使用for循环遍历“ObserversList”结构，并通过传递参数“m”执行每个“Notify(string)”方法。执行完毕后，所有观察者必须在其“Message”字段中存储消息“Hello
    World!”。让我们通过运行测试来看看这是否成立：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Excellent! We can also see the outputs of the `Publisher` and `Observer` types
    on the console. The `Publisher` structure prints the following message:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们还可以在控制台上看到“发布者”和“观察者”类型的输出。 “发布者”结构打印以下消息：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After this, all observers print their respective messages as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，所有观察者按如下方式打印各自的消息：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: And the same for the third observer.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个观察者也是如此。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We have unlocked the power of event-driven architectures with the State pattern
    and the Observer pattern. Now you can really execute asynchronous algorithms and
    operations in your application that respond to events in your system.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经利用状态模式和观察者模式解锁了事件驱动架构的力量。现在，您可以在应用程序中真正执行异步算法和操作，以响应系统中的事件。
- en: The Observer pattern is commonly used in UI's. Android programming is filled
    with Observer patterns so that the Android SDK can delegate the actions to be
    performed by the programmers creating an app.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式通常用于UI。Android编程中充满了观察者模式，以便Android SDK可以将操作委托给创建应用程序的程序员。
