- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Generic Algorithm Superpowers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用算法超级能力
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will discuss the versatility and expressive strength that Go’s
    type parameter syntax brings developers. As we explore this chapter, we’ll uncover
    the means to create algorithms that transcend the limitations of single variable
    types. By harnessing the power of type parameters, developers gain the ability
    to craft generic versions of their code, enabling it to seamlessly operate on
    multiple types. This chapter will highlight the overarching goal to reduce code
    duplication while preserving the robust safety intrinsic to Go’s strong typing
    system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论Go的类型参数语法为开发者带来的灵活性和表达力。随着我们探索本章内容，我们将揭示创建超越单一变量类型限制的算法的方法。通过利用类型参数的力量，开发者能够创建代码的泛型版本，使其能够无缝地在多种类型上运行。本章将强调减少代码重复的同时，保留Go强类型系统内固有的稳健安全性的总体目标。
- en: This chapter will also navigate the world of constraints, showcasing how Go
    fortifies generic algorithms against unintended mishaps, as well as help you understand
    when to use generic algorithms versus interfaces. Through practical examples and
    activities, you will grasp the art of designing generic algorithms and understand
    the superpowers of generic algorithms. By the end of the chapter, you will be
    equipped with a profound understanding of when, why, and how to wield the generic
    algorithm superpowers in Go. We’ll also cover some best practices and provide
    clarity on when to use interfaces versus generics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将带您进入约束的世界，展示Go语言如何通过加固通用算法来防止意外错误，并帮助您了解何时使用通用算法而不是接口。通过实际示例和活动，您将掌握设计通用算法的技巧，并了解通用算法的超级能力。到本章结束时，您将具备深刻理解在Go语言中何时、为什么以及如何运用通用算法超级能力的知识。我们还将介绍一些最佳实践，并阐明何时使用接口与通用类型。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google的Go团队始终在思考如何让Go开发者的生活更轻松，以及我们未来需要哪些工具、包和支持——始终以完全向后兼容的方式。在本章中，我们将扩展我们迄今为止获得的知识，并讨论Go泛型。
- en: For this chapter, you'll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要Go版本1.21或更高版本。本章的代码可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08)找到。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The Go team at Google is always thinking about how to make the lives of Go developers
    easier and what tools, packages, and support we need for the future – always in
    a fully backward-compatible way. In this chapter, we will expand upon our knowledge
    gained so far and discuss Go generics.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求
- en: Generics officially became a part of the language in Go version 1.18\. Go generics
    provide a powerful means of developing code that removes duplication, simplifies
    readability, and enables developers a way to use multiple types within a function.
    However, with great power comes great responsibility. Let’s discuss generics further.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在Go 1.18版本中正式成为语言的一部分。Go泛型提供了一种强大的开发代码的方法，可以消除重复，简化可读性，并使开发者能够在函数中使用多种类型。然而，权力越大，责任越大。让我们进一步讨论泛型。
- en: When to use generics?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用泛型？
- en: The decision to finally incorporate generics into the Go programming language
    was not a trivial one. As they are such a large change to the language, it is
    important to remember our roots as developers and not to allow support such as
    generics to change *how* we write our code. In other words, you should continue
    writing normal Go code and not overly design types right from the get-go. These
    are fundamental Go philosophies rooted in simplicity and readability, which are
    the core tenets of the language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最终决定将泛型引入Go编程语言的决定并非易事。由于它们对语言的影响如此之大，因此记住我们作为开发者的根源，并不要让泛型这样的支持改变我们编写代码的方式。换句话说，您应该继续编写正常的Go代码，而不是从一开始就过度设计类型。这些都是根植于简单性和可读性的基本Go哲学，这些是语言的核心原则。
- en: 'The following is a synopsis of insights to consider when incorporating Go generics
    into a code base:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Go泛型集成到代码库时需要考虑的见解如下：
- en: '**Write normal Go code, and don’t design types**: Start with your typical concrete
    types and straightforward functions, leveraging Go’s strong static typing and
    simplicity. Generics were never meant to replace the fundamental principles guiding
    the use of the language but, rather, be a tool to be applied judiciously.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编写正常的Go代码，不要设计类型**：从你典型的具体类型和简单函数开始，利用Go强大的静态类型和简洁性。泛型从未打算取代指导语言使用的根本原则，而是一个需要明智应用的工具。'
- en: '**Avoid boilerplate code**: This was one of the main motivating factors behind
    introducing generics to the language. When you find yourself writing repetitive
    and nearly identical code for different types, then it is a signal that generics
    can help streamline your implementation. Instead of duplicating logic for various
    data structures and types, you can create generic functions or types that work
    seamlessly with different types. This removes code redundancy and improves developer
    maintainability of the logic.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免样板代码**：这是引入泛型到语言中的主要动机之一。当你发现自己为不同的类型编写重复且几乎相同的代码时，那么这是一个信号，表明泛型可以帮助简化你的实现。而不是为各种数据结构和类型重复逻辑，你可以创建与不同类型无缝工作的泛型函数或类型。这消除了代码冗余并提高了开发者对逻辑的维护性。'
- en: '**Code complexity considerations**: If your project involves intricate data
    structures or algorithms, generics can help abstract away the complexity and make
    your code more comprehensible. However, be cautious to not over-engineer; only
    introduce generics when they genuinely simplify your code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑代码复杂性**：如果你的项目涉及复杂的数据结构或算法，泛型可以帮助抽象复杂性，使你的代码更易于理解。然而，要小心不要过度设计；只有在泛型真正简化你的代码时才引入泛型。'
- en: '**Enhance code flexibility**: Generics allow functions and data structures
    to work with various types. If your code needs to accommodate diverse data types
    without sacrificing performance or safety, then generics can be a valuable addition.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强代码灵活性**：泛型允许函数和数据结构与各种类型一起工作。如果你的代码需要适应不同的数据类型，同时不牺牲性能或安全性，那么泛型可以是一个宝贵的补充。'
- en: '**Future-proofing code**: If you anticipate changes or expansion where introducing
    new types is likely, incorporating generics early on can future-proof your code
    and reduce the need for extensive refactoring down the line.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对未来代码进行加固**：如果你预计会有变化或扩展，其中引入新类型很可能是必然的，那么尽早采用泛型可以加固你的代码，并减少未来大量重构的需求。'
- en: 'To take a look at what generics look like in action in Go, let’s first look
    at a regular implementation for a function, finding the maximum value for integer
    values passed into a function using a naive approach:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看泛型在Go中的实际应用，让我们首先看看一个常规函数的实现，使用直观的方法找到一个函数传入的整数值的最大值：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we wanted to now find the maximum value for a different type of input, such
    as floating-point values, then we’d have to add a new function containing duplicate
    logic:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要现在找到不同类型输入的最大值，例如浮点值，那么我们就必须添加一个包含重复逻辑的新函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see how this is already repetitive. If we wanted to check for the max
    value for additional types, then so far, we’d have a lot of repeated logic. However,
    now we can take a look at how having a generic maximum function can be beneficial
    here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这已经重复了。如果我们想要检查额外类型的最大值，那么到目前为止，我们会有一大堆重复的逻辑。然而，现在我们可以看看拥有一个泛型最大值函数在这里如何有益：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Albeit, this is a simple example to find a maximum, we’ve made progress by moving
    from expanded code to adding generics to it and removing code duplication, making
    for cleaner code. You can also see that the preceding function signature uses
    a different notation utilizing generics in Go that allows for integer input or
    float-point input to the function. Now, let’s introduce type parameters, a fundamental
    aspect of generics that helps developers enhance code clarity and maintainability,
    which will explain the different notations in the function signature on our preceding
    generic function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子来寻找最大值，但我们通过将扩展代码转换为添加泛型并去除代码重复，使得代码更加简洁。你还可以看到，前面的函数签名使用了不同的符号，利用Go中的泛型允许函数接受整数输入或浮点数输入。现在，让我们引入类型参数，这是泛型的一个基本方面，有助于开发者提高代码的清晰度和可维护性，这将在我们前面的泛型函数签名中解释不同的符号。
- en: Type parameters
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数
- en: Type parameters for Go functions give you the ability to parameterize a function
    with types that support generic input. It’s a way to specify to the compiler the
    types allowed when invoking a generic function and represents a placeholder for
    a type within a given function. Type parameter lists look like normal parameter
    lists but are encompassed by square brackets. For example, `[T any]` declares
    a `T` type parameter that can be any type. The `any` keyword was touched on in
    the previous chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Go 函数的类型参数允许你使用支持泛型输入的类型来参数化一个函数。这是一种向编译器指定调用泛型函数时允许的类型的方式，并在给定函数中代表类型的占位符。类型参数列表看起来像正常的参数列表，但被方括号包围。例如，`[T
    any]` 声明了一个可以是任何类型的 `T` 类型参数。`any` 关键字在前一章中已经提到。
- en: 'To continue to understand type parameters, let’s return to our maximum generic
    function signature from the earlier example code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续理解类型参数，让我们回到先前的示例代码中的最大泛型函数签名：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This indicates that our function, titled `findMaxGeneric`, includes a type parameter,
    `Num`, that can be instantiated by an integer or float64 type. It will take in
    a slice of `Num` and return the resulting maximum integer or float64 value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的函数，名为 `findMaxGeneric`，包含一个类型参数 `Num`，它可以由整数或 float64 类型实例化。它将接受一个 `Num`
    的切片，并返回结果的最大整数或 float64 值。
- en: An interesting concept associated with type parameters is type sets. In the
    preceding example function signature, we discussed how `Num` can be instantiated
    by an integer or float64 type. This means that the type set for the `Num` type
    parameter is the union of integer and float64 types. So, our `findMaxGeneric`
    function may be called with those constrained allowed types for `Num`. Type constraints
    will be discussed further in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型参数相关的一个有趣的概念是类型集。在先前的示例函数签名中，我们讨论了 `Num` 可以由整数或 float64 类型实例化。这意味着 `Num`
    类型参数的类型集是整数和 float64 类型的并集。因此，我们的 `findMaxGeneric` 函数可以用这些受约束允许的类型为 `Num` 调用。类型约束将在本章进一步讨论。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Type parameters are usually uppercase to emphasize that they are indeed types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数通常使用大写字母来强调它们确实是类型。
- en: 'We can call the generic function and pass in our input with the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码调用泛型函数并传入我们的输入：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The numbers we pass into the function are called our type arguments. Providing
    type arguments to a function is called instantiation. Instantiation is important
    in generics when you provide type arguments for type parameters. The type argument
    is the actual type that is provided or inferred when using generic functions.
    It is the concrete type that replaces the type parameter when the generic code
    is instantiated or called upon.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给函数的数字被称为我们的类型参数。向函数提供类型参数称为实例化。在泛型中，当你为类型参数提供类型参数时，实例化很重要。类型参数是使用泛型函数时提供的或推断的实际类型。它是泛型代码实例化或调用时替换类型参数的具体类型。
- en: 'Furthermore, if we were to pass in an invalid type argument for our type parameter,
    then the Go compiler would complain. For example, if we tried to pass in string
    values, then we’d see an error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们为我们的类型参数传递无效的类型参数，Go 编译器会报错。例如，如果我们尝试传递字符串值，我们会看到错误：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our code did not compile properly, as the Go type system prevented us from passing
    in an invalid type argument for our type parameter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码没有正确编译，因为 Go 的类型系统阻止我们为我们的类型参数传递无效的类型参数。
- en: Activity 8.01 – a minimum value
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01 – 最小值
- en: 'In this activity, we write a simple function to calculate a minimum value,
    where the input can be of the integer or float64 type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们编写一个简单的函数来计算最小值，其中输入可以是整数或 float64 类型：
- en: Create a `findMinGeneric` function that calculates the minimum value of a slice
    of input.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `findMinGeneric` 函数，用于计算输入切片的最小值。
- en: The input can only be of integer or float64 type.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入只能为整数或 float64 类型。
- en: Print the resulting minimum value for both integers and floating-point values.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出整数和浮点值的结果最小值。
- en: 'For input using `[]int{1, 32, 5, 8, 10, 11}`, your output should look like
    this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `[]int{1, 32, 5, 8, 10, 11}` 的输入，你的输出应该如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For input using `[]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1}`, your output should
    look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 `[]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1}` 的输入，你的输出应该如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在本章的GitHub仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01)。
- en: Type parameters are useful when working with functions that operate on slices,
    maps, and channels of any element type. Furthermore, when the function has parameters
    with those types and doesn’t make assumptions based on the element type, it can
    be generalized– for example, returning keys in any map type. This is also useful
    when working with general-purpose data structures such as linked lists or binary
    trees. Replacing an element type with a type parameter can provide a more general
    data structure that is far more reusable. You should not make use type parameters
    prematurely. Wait until you’re about to write boilerplate code. Premature abstractions
    can lead to unnecessary complexity and make code harder for others to understand.
    It is recommended to wait until you encounter a specific need for generic solutions,
    especially when faced with repetitive patterns or boilerplate code. This approach
    aligns well with Go’s philosophy of simplicity and incremental design, ensuring
    that the introduction of generics to a code base is purposeful and justified.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数在处理操作任何元素类型的切片、映射和通道的函数时很有用。此外，当函数具有这些类型的参数且不基于元素类型做出假设时，它可以被泛化——例如，返回任何映射类型的键。这在与通用数据结构（如链表或二叉树）一起使用时也很有用。用类型参数替换元素类型可以提供更通用的数据结构，这种结构具有更高的可重用性。你不应该过早地使用类型参数。等到你即将编写样板代码时再使用。过早的抽象可能导致不必要的复杂性，并使代码更难被他人理解。建议等到你遇到对泛型解决方案的具体需求时再使用，尤其是在面对重复模式或样板代码时。这种方法与Go的简单性和渐进式设计哲学相吻合，确保泛型引入代码库是有目的和合理的。
- en: Now, let’s explore type constraints and how they give us a way to specify capabilities
    or properties that a type parameter must have, in order to be used with a generic
    function.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨类型约束以及它们如何为我们提供一种指定类型参数必须具备的能力或属性的方法，以便与泛型函数一起使用。
- en: Type constraints
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型约束
- en: Type constraints are a sort of meta-type for the function type parameter. Type
    constraints dictate the allowed type arguments for any given type parameter of
    a function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束是函数类型参数的一种元类型。类型约束规定了任何给定类型参数允许的类型参数。
- en: Type constraints in Go generics refer to interfaces that define sets of types.
    These interfaces play a powerful role in specifying the requirements or capabilities
    that a type parameter must satisfy when working with generic functions or types.
    To use these interfaces effectively, they must be placed in what is known as the
    “constraint position” within the syntax, specifically in the type parameter list
    where the type parameter is declared.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go泛型中的类型约束指的是定义类型集合的接口。这些接口在指定类型参数在处理泛型函数或类型时必须满足的要求或能力方面发挥着强大的作用。为了有效地使用这些接口，它们必须放置在所谓的“约束位置”中，具体是在类型参数列表中声明类型参数的地方。
- en: In this constraint position, when declaring a generic function or type, the
    constraints are expressed using an interface type to define the expected behavior
    of the type parameter. This ensures that the provided types adhere to the specified
    constraints, allowing the generic code to operate on them safely. By enforcing
    these constraints, the Go compiler can perform thorough type checking at compile
    time, enhancing code reliability and maintainability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此约束位置，当声明泛型函数或类型时，约束是通过使用接口类型来定义类型参数的预期行为来表达的。这确保了提供的类型遵守指定的约束，允许泛型代码安全地操作它们。通过强制执行这些约束，Go编译器可以在编译时进行彻底的类型检查，增强代码的可靠性和可维护性。
- en: When dealing with more complex types, oftentimes you will declare constraints
    as an interface. The constraint allows any type that implements the interface
    to be used with the function. Constraint interfaces can refer to specific and
    more basic types. Using constraint interfaces can help pull out the type constraints
    into a more readable form.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理更复杂类型时，通常您会声明约束为接口。约束允许任何实现了该接口的类型与函数一起使用。约束接口可以引用特定的更基本类型。使用约束接口可以帮助将类型约束提取为更易于阅读的形式。
- en: Containing a distinct set of logic for constraints for the added generics in
    the Go programming language, a standard library package called `constraints` has
    been added experimentally that you can explore for more insights on defining constraints
    when working with type parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 包含对 Go 编程语言中添加的泛型约束的独立逻辑集，一个名为 `constraints` 的标准库包已被实验性地添加，您可以探索它以获取更多关于在处理类型参数时定义约束的见解。
- en: Exercise 8.01 – calculate the maximum value using interfaces
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.01 – 使用接口计算最大值
- en: 'Let’s take a look at expanding our maximum logic from earlier into a more readable
    form, using interfaces for our type constraints. We will continue only allowing
    integer and float64 values for now:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将之前的最大逻辑扩展为更易于阅读的形式，使用接口作为我们的类型约束。现在，我们仍然只允许整数和 float64 值：
- en: Create a new folder and add a `main.go` file.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将主包名添加到文件顶部：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, add the imports that we’ll use in this file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在此文件中使用的导入：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `Number` interface that will represent the types of values we allow
    as input:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Number` 接口，它将代表我们允许作为输入的类型：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a function that takes a slice of numbers and returns the maximum value:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它接受一个数字切片并返回最大值：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Ensure valid input by verifying that there are inputs passed into the function:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过验证是否向函数传递了输入来确保有效输入：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Get the first value to have a placeholder maximum value, before checking the
    remaining values:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取第一个值以设置一个占位符最大值，然后再检查剩余的值：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Traverse the numbers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历数字：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Check whether the current number is greater than the placeholder maximum value,
    and reset the maximum to the current value as needed:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当前数字是否大于占位符最大值，并在需要时将最大值重置为当前值：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Close the `for` loop:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `for` 循环：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Return the maximum:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回最大值：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Close the function:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Define the main function:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主函数：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Call our function and print out the results for integer and float64 input:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们的函数并打印出整数和 float64 输入的结果：
- en: '[PRE20]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Close the main function:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭主函数：
- en: '[PRE21]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将显示以下输出：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have now seen what it looks like to make our type constraint interface more
    readable, by defining a `Number` interface to find the maximum value. You can
    see the benefits of defining one function that can be used for integer and float64
    values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何通过定义一个 `Number` 接口来查找最大值，使我们的类型约束接口更易于阅读。您可以看到定义一个可以用于整数和 float64
    值的函数的好处。
- en: In the last chapter, we learned a lot about interfaces and how they define a
    set of methods that a type must implement. When working with generics, you can
    express constraints on the types that can be used as type parameters, by specifying
    that they must satisfy certain interface requirements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了大量的接口知识以及它们如何定义一组类型必须实现的方法。当使用泛型时，您可以通过指定它们必须满足某些接口要求来表达对用作类型参数的类型的约束。
- en: For type parameters, you might see constraints such as `comparable` or custom
    interfaces that define specific methods. Let’s take a peek at leveraging a more
    complex example using `comparable`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型参数，您可能会看到如 `comparable` 或定义特定方法的自定义接口等约束。让我们看看如何利用一个更复杂的 `comparable` 示例。
- en: Exercise 8.02 – calculate the largest stock of items on a ranch
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.02 – 计算农场物品的最大库存
- en: 'Let’s say that there is a ranch with different items in stock. We can use generics
    to calculate the largest stock of different items on the ranch:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个仓库，里面存放着不同的库存物品。我们可以使用泛型来计算农场不同物品的最大库存：
- en: Create a new folder and add a `main.go` file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'In `main.go`, add the main package name at the top of the file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将主包名添加到文件顶部：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, add the imports that we’ll use in this file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在此文件中使用的导入：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Define the function to find the largest ranch stock using generics:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个使用泛型查找最大农场库存的函数：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Define variables to save the largest stock found so far and the name of the
    stocked item:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义变量以保存迄今为止找到的最大库存和库存物品的名称：
- en: '[PRE26]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Loop over the map, and if the new value found is greater than the largest stock
    at the time, then update the values to the largest and save the item name:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历映射，如果找到的新值大于当时的最大库存，则更新值为最大值并保存物品名称：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Return the name of the item with the largest stock on the ranch:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回牧场中库存量最大的物品的名称：
- en: '[PRE28]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Close the function:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the `main` function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数：
- en: '[PRE30]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define our ranch items in stock:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的牧场库存物品：
- en: '[PRE31]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Call our function, and print out the results for the largest stocked items
    in the ranch:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们的函数，并打印出牧场中库存量最大的物品的结果：
- en: '[PRE32]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Close the `main` function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main`函数：
- en: '[PRE33]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码显示以下输出：
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve now seen a generics example using `comparable`. The constraint on our
    `K` type parameter in the function was `comparable`. This is thanks to the type
    of the commonly used constraint, enabled by helpers from Go using the `comparable`
    standard library. `comparable` allows any type whose value can be used as an operand
    of the comparison operators, such as `==` and `!=`. Go requires the keys of maps
    to be comparable, so the `comparable` declaration is necessary on our map key
    type to use `K` as the key in the ranch map. If we didn’t declare `K` to be `comparable`,
    then the Go compiler would reject the reference to `map[K]V` in our function’s
    argument.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到了一个使用`comparable`的泛型示例。在函数中，我们对`K`类型参数的约束是`comparable`。这得益于Go使用`comparable`标准库提供的辅助器启用的常用约束类型。`comparable`允许任何值可以作为比较运算符（如`==`和`!=`）的操作数。Go要求映射的键是可比较的，因此我们的映射键类型上的`comparable`声明对于在牧场映射中使用`K`作为键是必要的。如果我们没有声明`K`为`comparable`，那么Go编译器将拒绝在函数参数中引用`map[K]V`。
- en: As you can see, Go allows a very powerful form of interface type to express
    constraints. We can easily expand this example to work on even more complex interfaces
    and constraints.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Go允许一种非常强大的接口类型形式来表达约束。我们可以轻松地扩展这个例子，使其适用于更复杂的接口和约束。
- en: It is noteworthy to mention that replacing an interface type with a type parameter
    can make the underlying storage of data more efficient. It can also mean that
    code can avoid type assertions and be fully type-checked at compile time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，用类型参数替换接口类型可以使数据的底层存储更高效。这也可能意味着代码可以避免类型断言，并在编译时进行全面类型检查。
- en: Now that we’ve discussed type parameters and type constraints, let’s take a
    peek at what’s going on when it comes to type inference.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了类型参数和类型约束，让我们看看类型推断时发生了什么。
- en: Type inference
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: The Go compiler infers the types we want to use from the function arguments.
    This is called type inference. The compiler will deduce type arguments from type
    parameter constraints.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go编译器从函数参数中推断我们想要使用的类型。这被称为类型推断。编译器将从类型参数约束中推断类型参数。
- en: Type inference either succeeds or fails. The compiler will complain, and we
    are provided the type arguments that need correcting upon finding an issue. Using
    generics is meant to be easy; however, the underlying details of type inference
    are highly complicated. It is also something the authors are iterating on to improve.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断要么成功，要么失败。当编译器发现问题时，它会抱怨，并提供了需要纠正的类型参数。使用泛型旨在简单；然而，类型推断的底层细节非常复杂。这也是作者们正在迭代以改进的内容。
- en: At this point, when it comes to calling generic functions, we’ve covered how
    you can specify type arguments in square brackets as type names. This allows the
    compiler to know to replace the type parameters within the function you’re invoking.
    However, you can omit the type arguments, as most of the time Go can infer them.
    However, it is not always possible to simplify your code by dropping type arguments.
    As the compiler runs your code, it replaces each type parameter with the concrete
    types.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们谈到调用泛型函数时，我们已经介绍了如何通过在方括号中指定类型名称来指定类型参数。这允许编译器知道在您调用的函数中替换类型参数。然而，您可以选择省略类型参数，因为大多数情况下Go可以推断它们。但是，通过省略类型参数来简化代码并不总是可能的。当编译器运行您的代码时，它会将每个类型参数替换为具体的类型。
- en: 'A concrete example of this can be seen in many of our function signatures where
    we’ve allowed the compiler to infer our types. For example, in the last exercise,
    we discussed ranch item stocks. Our function signature in the code was as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过我们许多函数签名中的具体例子来看到，我们允许编译器推断我们的类型。例如，在上一个练习中，我们讨论了牧场物品库存。我们的函数签名在代码中如下所示：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This invocation allows the compiler to infer the type of `animalStock`. However,
    it is also identical to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用允许编译器推断 `animalStock` 的类型。然而，它也等同于以下：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we explicitly state the types for our key and values getting passed in.
    There are a few scenarios where it may not be possible or advisable to rely on
    the compiler to infer types when working with generic functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确声明了传递给我们的键和值的类型。在处理泛型函数时，有一些情况下可能无法或不建议依赖编译器推断类型：
- en: '`PrintType` function that prints the type of a value. If you pass in a string,
    it should recognize it as a string; if you pass in an integer, it should recognize
    it as an integer. When calling this function, you explicitly state the types using
    `PrintType("Hello")`, `PrintType(42)`, `PrintType(3.14)`, and so on.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrintType` 函数用于打印值的类型。如果你传入一个字符串，它应该识别为字符串；如果你传入一个整数，它应该识别为整数。在调用此函数时，你明确使用
    `PrintType("Hello")`、`PrintType(42)`、`PrintType(3.14)` 等方式声明类型。'
- en: '`PrintTwoTypes` function that takes two parameters of potentially different
    types. When calling this function, you might specify the types explicitly for
    various reasons. Then, `PrintTwoTypes` could be defined with an integer and string
    parameter and used as such – `PrintTwoTypes(42, "Hello)`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PrintTwoTypes` 函数接受两个可能不同类型的参数。在调用此函数时，你可能出于各种原因明确指定类型。然后，`PrintTwoTypes`
    可以定义为一个整数和一个字符串参数，并按此方式使用 - `PrintTwoTypes(42, "Hello")`。'
- en: '`ChainCalls`, that processes a value and then calls another function, `AnotherFunction`.
    Here, you might explicitly state the types of chained calls to ensure a smooth
    flow.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainCalls`，处理一个值然后调用另一个函数 `AnotherFunction`。在这里，你可能明确声明链式调用的类型以确保流畅性。'
- en: You can also add explicit types to add clarity in complex scenarios or to enhance
    readability, reducing time spent debugging when it comes to type inference.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加显式类型以在复杂场景中增加清晰度或提高可读性，减少在类型推断时花费的调试时间。
- en: When to use generics versus interfaces
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用泛型与接口
- en: The question of when to use generics versus interfaces in Go often depends on
    the nature of the problem you’re solving and the specific requirements of your
    code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中何时使用泛型与接口的问题通常取决于你解决问题的本质和代码的具体要求。
- en: Generics in Go allow you to write functions or data structures that can operate
    on a variety of types, without sacrificing type safety. With generics, you can
    create functions or structures that work with different types, without the need
    for code duplication and while maintaining compile-time safety checks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的泛型允许你编写可以在多种类型上操作的功能或数据结构，而不会牺牲类型安全。使用泛型，你可以创建与不同类型一起工作的函数或结构，无需代码重复，同时保持编译时的安全检查。
- en: Interfaces in Go define a set of method signatures. Any type that implements
    all the methods of an interface is said to satisfy the interface. Interfaces provide
    a way to achieve polymorphism in Go, enabling code to work with different types
    that share a common set of behaviors. Interfaces are technically a form of generic
    programming by allowing developers to capture common aspects of different types
    and express them as methods. This allows for not only a nice abstraction layer
    but also duplicate logic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的接口定义了一组方法签名。任何实现接口所有方法的类型都被说成是满足接口的。接口提供了一种在 Go 中实现多态的方法，使代码能够与共享一组共同行为的不同类型一起工作。接口在技术上是一种泛型编程的形式，允许开发者捕获不同类型的共同方面并将它们作为方法表达。这不仅提供了一个很好的抽象层，还避免了重复逻辑。
- en: You should use interfaces when your work requires an abstraction layer that
    others may implement, or you have distinct behavior you want captured. Generics
    are good for maintaining compilation type safety in a statically typed language
    when writing type-agnostic functions and methods. Other considerations such as
    performance and optimizations benchmarking can be considered for different use
    cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的工作需要其他可能实现或你希望捕获的特定行为时，你应该使用接口。泛型在编写类型无关函数和方法时，对于在静态类型语言中保持编译时的类型安全非常有用。对于不同的用例，还可以考虑性能和优化基准测试等其他因素。
- en: What are some best practices?
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有哪些最佳实践？
- en: 'The following are a few best practices to consider when working with generic
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理泛型代码时，以下是一些值得考虑的最佳实践：
- en: '**Use functions over methods**: A method is a function associated with a type
    and is called with a receiver; therefore, a function in the context of generics
    is more flexible, as it is not tied to a specific type. This allows for easier
    reuse and the ability to compose functions with different types.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先使用函数而非方法**：方法是与类型关联的函数，并通过接收者调用；因此，在泛型的上下文中，函数更灵活，因为它不受特定类型的限制。这允许更容易的重用，以及将不同类型的函数组合在一起的能力。'
- en: '**Ease of transformation**: It is easier to turn methods into functions than
    it is to add a function to a type. Functions can be defined independently of specific
    types. In the context of generics, you can use generic functions with any type
    that satisfies the required constraints. If it later makes sense to convert to
    a method, then you can do so without modifying the original function more easily.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换的简便性**：将方法转换为函数比向类型中添加函数要容易。函数可以独立于特定类型定义。在泛型的上下文中，你可以使用满足所需约束的任何类型的泛型函数。如果后来有理由将其转换为方法，那么你可以更容易地这样做，而无需修改原始函数。'
- en: '`comparable`. This allows flexibility in the future when working with type
    parameters and a broader range of types to be used with the function.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparable`。这为未来在处理类型参数和更广泛类型的函数使用中提供了灵活性。'
- en: When working with generics in Go, it is also best to be mindful of the complexity
    that can be involved. They are a tool in our toolbelt to be used wisely and properly.
    By doing so, you can leverage the power of generics without compromising the simplicity
    and readability that define the Go programming language.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中使用泛型时，也要注意可能涉及的复杂性。它们是我们工具箱中的工具，要明智和正确地使用。通过这样做，你可以利用泛型的力量，而不会损害定义 Go
    编程语言的简洁性和可读性。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of Go generics, a groundbreaking enhancement
    to the language that provides key features such as type parameters, constraints,
    and type inference. Type parameters, encapsulated within square brackets, emerged
    as versatile placeholders, enabling the creation of functions and data structures
    without prior knowledge of the specific types they are to interact with. The incorporation
    of constraints such as `comparable` bolstered type safety and clarity, ensures
    that the generic constructs adhere to specific rules or interfaces. Moreover,
    the compiler’s type inference unveiled a new era of concise and streamlined code,
    where developers can leverage static typing without the burden of explicit type
    annotations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Go 泛型的世界，这是语言的一项突破性增强，提供了诸如类型参数、约束和类型推断等关键特性。类型参数，封装在方括号内，作为多才多艺的占位符出现，使得在不了解它们将要与之交互的具体类型的情况下，也能创建函数和数据结构。引入如`comparable`之类的约束增强了类型安全性和清晰度，确保泛型构造遵循特定的规则或接口。此外，编译器的类型推断开启了一个简洁和精简代码的新时代，开发者可以借助静态类型而不必承担显式类型注解的负担。
- en: While Go generics is still being smoothened out and added to, it is a powerful
    addition that aims to empower developers to write efficient, reusable code with
    unprecedented ease. Now that we know how to write optimal and reusable code thanks
    to generics, we can look at expanding this knowledge in the next chapter. There,
    we will enhance our understanding by covering Go modules and seeing how to reuse
    code at a much larger scale and collaborative effort.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 泛型仍在不断完善和添加中，但它是一项强大的补充，旨在赋予开发者以前所未有的轻松程度编写高效、可重用代码的能力。现在我们知道了如何利用泛型编写最优和可重用代码，我们可以在下一章中扩展这一知识。在那里，我们将通过涵盖
    Go 模块和了解如何在大规模和协作努力中重用代码来加深我们的理解。
- en: 'Part 3: Modules'
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：模块
- en: A module serves as a repository for reusable code utilized by various applications.
    Whether large or small, a module enables efficient code organization and enhances
    reusability. In this section, you’ll learn how to create and manage modules effectively,
    leveraging packages and external modules to streamline your development process.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 模块作为各种应用程序使用的可重用代码的存储库。无论大小，模块都使得代码组织高效，并提高了可重用性。在本节中，你将学习如何有效地创建和管理模块，利用包和外部模块来简化你的开发过程。
- en: 'This part has the following chapters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B18621_09.xhtml#_idTextAnchor1367), *Using Go Modules to Define
    a Project*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18621_09.xhtml#_idTextAnchor1367)，*使用 Go 模块定义项目*'
- en: '[*Chapter 10*](B18621_10.xhtml#_idTextAnchor1405), *Package Keep Projects Manageable*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18621_10.xhtml#_idTextAnchor1405), *保持项目可管理*'
- en: '[*Chapter 11*](B18621_11.xhtml#_idTextAnchor1462), *Bug-Busting Debugging Skills*,'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18621_11.xhtml#_idTextAnchor1462), *解决虫害的调试技巧*,'
- en: '[*Chapter 12*](B18621_12.xhtml#_idTextAnchor1532), *About Time*'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18621_12.xhtml#_idTextAnchor1532), *关于时间*'
