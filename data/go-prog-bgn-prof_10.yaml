- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Packages Keep Projects Manageable
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包保持项目可管理
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to demonstrate the importance of the use of packages in our
    Go programs. We will discuss how packages can be used to assist our code in being
    more maintainable, reusable, and modular. In this chapter, you will see how they
    can be used to bring structure and organization to our code. This will also be
    seen in our exercises, activities, and some examples from the Go standard library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在展示在Go程序中使用包的重要性。我们将讨论如何使用包来帮助我们的代码更易于维护、重用和模块化。在本章中，您将看到它们如何为我们的代码带来结构和组织。这将在我们的练习、活动和Go标准库的一些示例中也有所体现。
- en: By the end of the chapter, you will be able to describe a package and its structure
    and declare a package. You will learn to evaluate exported and unexported names
    in a package, create your own package, and import your custom package. You will
    also be able to distinguish between executable packages and non-executable packages
    and create an alias for a package.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够描述一个包及其结构，并声明一个包。您将学习如何评估包中的导出和非导出名称，创建自己的包，并导入您的自定义包。您还将能够区分可执行包和非可执行包，并为包创建别名。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at interfaces. We saw how we can use interfaces
    to describe the behavior of a type. We also discovered that we can pass different
    types to functions that accept an interface, as long as the type satisfies the
    interface’s method sets. We also saw how we can achieve polymorphism using interfaces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了接口。我们看到了如何使用接口来描述类型的行怍。我们还发现，只要类型满足接口的方法集，我们就可以将不同类型的参数传递给接受接口的函数。我们还看到了如何使用接口实现多态。
- en: In this chapter, we will look at how Go organizes its code into packages. We
    will see how we can hide or expose different Go constructs such as structs, interfaces,
    functions, and more, using packages. Our programs have been rather small in the
    number of lines of code and in complexity to a certain extent. Most of our programs
    have been contained in a single code file, often named `main.go`, and inside a
    single package named `main`. Later in this chapter, we will explore the significance
    of `package main`, so do not be worried at this juncture if you do not understand
    it. This will not always be the case when you are working on a development team.
    Often, your code base can become rather large, with multiple files, multiple libraries,
    and multiple members of the team. It would be rather restrictive if we could not
    break our code into smaller, manageable parts. The Go programming language solves
    the complexity of managing large code bases with the ability to modularize similar
    concepts into packages. The creators of Go use packages for their own standard
    libraries to tackle this problem. In this book, you have been working with many
    Go packages, such as `fmt`, `string`, `os`, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Go如何将代码组织成包。我们将看到如何使用包来隐藏或暴露不同的Go结构，如结构体、接口、函数等。我们的程序在代码行数和复杂度上一直相对较小。大多数程序都包含在一个代码文件中，通常命名为`main.go`，并在一个名为`main`的单个包内。在本章的后面部分，我们将探讨`package
    main`的重要性，所以如果您在这个阶段还不理解它，请不要担心。当您在开发团队中工作时，情况并不总是如此。通常，您的代码库可以变得相当庞大，包含多个文件、多个库和多个团队成员。如果我们不能将代码分解成更小的、可管理的部分，这将相当受限。Go编程语言通过将类似的概念模块化到包中来解决管理大型代码库的复杂性。Go的创造者使用包来解决他们自己的标准库中的这个问题。在本书中，您已经使用了许多Go包，例如`fmt`、`string`、`os`等。
- en: Let’s look at an example of a package structure from the Go standard library.
    The Go `strings` package encapsulates string functions that manipulate strings.
    By keeping the `strings` package focused on only the functions that manipulate
    strings, we, as Go developers, know that this function should contain all that
    we need for string manipulation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Go标准库中的一个包结构的例子。Go的`strings`包封装了操作字符串的字符串函数。通过保持`strings`包只关注操作字符串的函数，作为Go开发者，我们知道这个函数应该包含我们需要的所有字符串操作功能。
- en: 'The Go `strings` package is structured as follows ([https://pkg.go.dev/strings#section-sourcefiles](https://pkg.go.dev/strings#section-sourcefiles)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`strings`包结构如下([https://pkg.go.dev/strings#section-sourcefiles](https://pkg.go.dev/strings#section-sourcefiles))：
- en: '![Figure 10.1: The strings package along with the files contained within it
    as of Go 1.21](img/B18621_10_1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：截至Go 1.21的strings包及其包含的文件](img/B18621_10_1.jpg)'
- en: 'Figure 10.1: The strings package along with the files contained within it as
    of Go 1.21'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：截至Go 1.21的strings包及其包含的文件
- en: The preceding diagram shows the `strings` package and the files that are in
    the package. Each file in the `strings` package is named after the functionality
    it is supporting. The logical organization of the code goes from package to file.
    We can easily conclude that the `strings` package contains code for manipulating
    strings. We can then further conclude that the `replace.go` file contains functions
    for replacing strings. You can already see that the conceptual structure of packages
    can organize your code into modular chunks. You start with code that is working
    together to serve a purpose, string manipulation, and it gets stored in a package
    called `strings`. You can then further organize the code into `.go` files and
    name them according to their purpose. The next step is keeping functions in there
    that perform a single purpose that reflects the name of the file and the name
    of the package. We will discuss these conceptual ideas later in the chapter when
    we discuss structuring code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了`strings`包及其包含的文件。`strings`包中的每个文件都以其支持的功能命名。代码的逻辑组织从包到文件。我们可以很容易地得出结论，`strings`包包含用于操作字符串的代码。然后我们可以进一步得出结论，`replace.go`文件包含用于替换字符串的函数。您已经可以看到，包的概念结构可以将您的代码组织成模块化块。您从一起工作以实现某个目的的代码开始，即字符串操作，并将其存储在名为`strings`的包中。然后您可以将代码进一步组织到`.go`文件中，并根据其目的命名它们。下一步是将执行单个目的的函数放入其中，该目的反映了文件名和包名。我们将在本章讨论代码结构时进一步讨论这些概念思想。
- en: It is important to develop software that is maintainable, reusable, and modular.
    Let’s briefly discuss each of these core components of software development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发可维护、可重用和模块化的软件非常重要。让我们简要讨论软件开发的核心组件。
- en: Maintainable
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护
- en: For code to be maintainable, it must be easy to change, and any changes must
    have a low risk of having an adverse impact on the program. Maintainable code
    is easy to modify and extend and is readable. As code progresses through the different
    stages of the **software development life cycle** (**SDLC**), the cost of changes
    to the code increases. These changes can be due to bugs, enhancements, or a change
    in requirements. Costs also increase when code is not easily maintainable. Another
    reason that code needs to be maintainable is the need to be competitive in the
    industry. If your code is not easily maintainable, it may be hard to react to
    a competitor who is releasing a software feature that could be used to outsell
    your application. These are just some of the reasons for code needing to be maintainable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码可维护，它必须易于更改，并且任何更改都必须具有低风险，不会对程序产生不利影响。可维护的代码易于修改和扩展，并且易于阅读。随着代码通过软件开发生命周期的不同阶段，代码更改的成本会增加。这些更改可能是由错误、增强或需求变更引起的。当代码不易维护时，成本也会增加。代码需要可维护的另一个原因是需要在行业中保持竞争力。如果你的代码不易维护，可能难以应对竞争对手发布可能用于超越你应用的软件功能的反应。这些只是代码需要可维护的一些原因。
- en: Reusable
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用
- en: Reusable code is code that can be used in new software. For example, I have
    code in my existing application that has a function that returns an address for
    my mailing application; that function may be used in a new piece of software.
    That function that returns the address could be used in my new software that returns
    a customer address for an order the customer has placed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用代码是可以在新软件中使用的代码。例如，我在现有的应用程序中有一个函数，该函数为我的邮件应用程序返回地址；这个函数可能被用于新的软件。返回地址的函数可以用于我新的软件，该软件为顾客返回他们已下订单的地址。
- en: 'The advantages of having reusable code are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有可重用代码的优势如下：
- en: It decreases future project costs by using existing packages
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用现有的包来降低未来项目的成本
- en: It decreases the time it takes to deliver an application, due to not having
    to reinvent the wheel
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于无需重新发明轮子，它减少了交付应用程序所需的时间
- en: The quality of the program will increase through increased testing and more
    usage
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加测试和更多使用，程序的质量将得到提高
- en: More time can be spent on other areas of innovation during the development cycle
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发周期中，可以花更多的时间在其他创新领域
- en: As your packages grow, it becomes easier to lay the foundations for future projects
    in a timely manner
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着你的包的增长，及时为未来项目打下基础变得更加容易
- en: It is easy to see the many benefits of making reusable code for our projects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看到为我们的项目创建可重用代码的许多好处。
- en: Modular
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化
- en: Modular and reusable code is related to a certain extent, in the sense that
    having modular code makes it more likely that it will be reusable. One of the
    prominent problems when developing code is the organization of the code. Finding
    code that performs a certain function in a large program that is unorganized would
    be near to impossible, and even finding out whether there is code that performs
    a certain task would be difficult to ascertain without some code organization.
    Modularization aids in that area. The idea is that each discrete task that your
    code performs has its own section of code located in a specific spot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化和可重用代码在一定程度上是相关的，因为拥有模块化代码使得它更有可能被重用。在开发代码时，代码的组织是一个突出的问题。在一个未组织的大型程序中找到执行特定功能的代码几乎是不可能的，甚至在不知道是否有执行特定任务的代码的情况下，确定这一点也是困难的。模块化有助于解决这个问题。理念是，你的代码执行的每个离散任务都有其自己的代码部分，位于特定的位置。
- en: 'Go encourages you to develop maintainable, reusable, and modular code by using
    packages. It was designed to encourage good software practices. We will be diving
    into how Go utilizes packages to accomplish those tasks:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言鼓励你通过使用包来开发可维护、可重用和模块化的代码。它旨在鼓励良好的软件开发实践。我们将深入探讨Go语言如何利用包来完成这些任务：
- en: '![Figure 10.2: The types of code packages can provide](img/B18621_10_2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：代码包的类型可以提供的内容](img/B18621_10_2.jpg)'
- en: 'Figure 10.2: The types of code packages can provide'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：代码包可以提供的类型
- en: In the next topic, we are going to discuss what a package is and what the components
    that make up a package are.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将讨论什么是包以及构成包的组件。
- en: What is a package?
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是包？
- en: 'Go follows the **Don’t Repeat Yourself** (**DRY**) principle. This means that
    you should not write the same code twice. Refactoring your code into functions
    is the first step of the DRY principle. What if you had hundreds or even thousands
    of functions that you used regularly? How would you keep track of all those functions?
    Some of those functions might even have common characteristics. You could have
    a group of functions that perform math operations, string manipulations, printing,
    or file-based operations. You may be thinking of breaking them up into individual
    files:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言遵循**不要重复自己**（DRY）原则。这意味着你不应该重复编写相同的代码。将你的代码重构为函数是DRY原则的第一步。如果你有数百甚至数千个你经常使用的函数，你将如何跟踪所有这些函数？其中一些函数可能具有共同的特征。你可能有一组执行数学运算、字符串操作、打印或基于文件的操作的函数。你可能正在考虑将它们拆分成单独的文件：
- en: '![Figure 10.3: Group functions by files](img/B18621_10_3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：按文件分组函数](img/B18621_10_3.jpg)'
- en: 'Figure 10.3: Group functions by files'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：按文件分组函数
- en: 'That could alleviate some of the issues. However, what if your string’s functionality
    started to grow further? You would then have a ton of string functions in one
    file or even multiple files. Every program you build would also have to include
    all of the code for `string`, `math`, and `io`. You would be copying code to every
    application that you built. Bugs in one code base would have to be fixed in multiple
    programs. That kind of code structure is not maintainable, nor does it encourage
    code reusability. The packages in Go are the next step to organizing your code
    in a way that makes it easy to reuse the components of your code. The following
    diagram shows the progression of organizing code from functions to source files
    to packages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于缓解一些问题。然而，如果你的字符串功能开始进一步增长呢？那么你将有一个大量的字符串函数在一个文件中，甚至多个文件中。你构建的每个程序也必须包含`string`、`math`和`io`的所有代码。你将不得不将代码复制到你所构建的每个应用程序中。一个代码库中的错误必须在多个程序中修复。这种代码结构是不可维护的，也不鼓励代码重用。Go中的包是组织代码的下一步，以便轻松重用代码组件。以下图表显示了从函数到源文件再到包的代码组织进展：
- en: '![Figure 10.4: Code progression organization](img/B18621_10_4.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4：代码进度组织](img/B18621_10_4.jpg)'
- en: 'Figure 10.4: Code progression organization'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：代码进度组织
- en: Go organizes its code for reusability into directories called packages. A package
    is essentially a directory inside your workspace that contains one or more Go
    source files, which is used for grouping code that performs a task. It exposes
    only the necessary parts in order for those using your package to get a job done.
    The package concept is akin to using directories to organize files on a computer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go将代码组织成包以提高可重用性，这些包被称为目录。一个包本质上是你工作空间中的一个目录，包含一个或多个Go源文件，用于对执行特定任务的代码进行分组。它只暴露必要的部分，以便使用你包的人能够完成任务。包的概念类似于在计算机上使用目录来组织文件。
- en: Package structure
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包结构
- en: 'It does not matter to Go how many different files are in a package. You should
    separate code into as many files as makes sense for readability and logic grouping.
    However, all the files that are in a package must live in the same directory.
    The source files should contain code that is related, meaning that if the package
    is for configuration parsing, you should not have code in there for connecting
    to a database. The basic structure of a package consists of a directory and contains
    one or more Go files and related code. The following diagram summarizes the core
    components of a package structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go语言来说，一个包中包含多少个不同的文件并不重要。你应该根据可读性和逻辑分组将代码分成尽可能多的文件。然而，一个包中的所有文件必须位于同一个目录下。源文件应包含相关的代码，这意味着如果包是用于配置解析，那么其中不应该包含连接到数据库的代码。一个包的基本结构包括一个目录，包含一个或多个Go文件和相关代码。以下图表总结了包结构的核心组件：
- en: '![Figure 10.5: Package structure](img/B18621_10_5.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：包结构](img/B18621_10_5.jpg)'
- en: 'Figure 10.5: Package structure'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：包结构
- en: 'One of the commonly used packages in Go is the `strings` package. It contains
    several Go files that are referred to in the Go documentation as package files.
    Package files are `.go` source files that are part of the package; for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，常用的包之一是`strings`包。它包含几个Go文件，在Go文档中被称为包文件。包文件是包的一部分的`.go`源文件；例如：
- en: '`builder.go`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder.go`'
- en: '`compare.go`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare.go`'
- en: '`reader.go`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reader.go`'
- en: '`replace.go`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace.go`'
- en: '`search.go`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search.go`'
- en: '`strings.go`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings.go`'
- en: The files in the preceding list all play their part in sharing related code
    for string operations within the standard library. Before we discuss how to declare
    a package, we need to discuss proper Go naming conventions for a package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表中的文件都在标准库中共享与字符串操作相关的相关代码。在我们讨论如何声明一个包之前，我们需要讨论包的正确Go命名约定。
- en: Package naming
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包命名
- en: 'The name of your package is significant. It represents what your package contains
    and identifies its purpose. You can think of a package name as self-documentation.
    Careful consideration needs to go into naming a package. The name of the package
    should be short and concise. It should not be verbose. Simple nouns are often
    chosen for a package name. The following would be poor names for a package:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包名很重要。它代表你的包包含的内容，并标识其目的。你可以将包名视为自文档化。在命名包时需要仔细考虑。包名应该简短且简洁。它不应该冗长。通常选择简单名词作为包名。以下将是不好的包名：
- en: '`stringconversion`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringconversion`'
- en: '`synchronizationprimitives`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronizationprimitives`'
- en: '`measuringtime`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`measuringtime`'
- en: 'Better alternatives would be the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择可能是以下这些：
- en: '`strconv`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strconv`'
- en: '`sync`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`'
- en: '`time`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`'
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`strconv`, `sync`, and `time` are actual Go packages found in the standard
    library.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv`、`sync`和`time`是标准库中实际存在的Go包。'
- en: 'Also, the styling of a package is something to take into consideration. The
    following would be poor style choices for a Go package name:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，包的样式也是需要考虑的因素。以下是一些Go包名的较差选择：
- en: '`StringConversion`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringConversion`'
- en: '`synchronization_primitives`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronization_primitives`'
- en: '`measuringTime`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`measuringTime`'
- en: In Go, package names should be all lowercase with no underscores. Don’t use
    camel-case or snake-case styling. There are multiple packages with pluralized
    names.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，包名应该是全部小写，不带下划线。不要使用驼峰式或蛇形风格。存在多个复数命名的包。
- en: 'Abbreviations are encouraged, just as long as they are familiar or common in
    the programming community. The user of the package should easily understand what
    the package is used for just from its name; for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励使用缩写，只要它们在编程社区中熟悉或常见。用户应该能够仅从包名中轻松理解该包的用途；例如：
- en: '`strconv` (string conversion)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strconv`（字符串转换）'
- en: '`regexp` (regular expression search)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp`（正则表达式搜索）'
- en: '`sync` (synchronization)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`（同步）'
- en: '`os` (operating system)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os`（操作系统）'
- en: 'Avoid package names such as `misc`, `util`, `common`, or `data`. These package
    names make it harder for the user of your package to understand its purpose. In
    some cases, there is a deviation from these guidelines, but for the most part,
    it is something we should strive for:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`misc`、`util`、`common`或`data`等包名。这些包名会让用户难以理解其用途。在某些情况下，可能会有一些偏离这些指南的情况，但大部分情况下，这是我们应努力追求的：
- en: '![Figure 10.6: Package naming conventions](img/B18621_10_6.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：包命名约定](img/B18621_10_6.jpg)'
- en: 'Figure 10.6: Package naming conventions'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：包命名约定
- en: You can see how there is almost an art to making a good package name. You want
    to be concise, descriptive, and clear on the package usage when picking package
    names. Now that we’ve discussed package names, let’s take a peek at package declarations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在挑选包名时，几乎是一门艺术。你希望包名简洁、描述性强，且在使用时清晰易懂。既然我们已经讨论了包名，让我们来看看包声明。
- en: Package declarations
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包声明
- en: 'Every Go file starts with a package declaration. The package declaration is
    the name of the package. The first line of each file in a package must be the
    package declaration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Go文件都以包声明开始。包声明是包的名称。包中的每个文件的第一行必须是包声明：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Recall that the `strings` package from the standard library has the following
    Go source files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，标准库中的`strings`包包含以下Go源文件：
- en: '![Figure 10.7: The strings package along with the files contained within it
    as of Go 1.21](img/B18621_10_7.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7：截至Go 1.21的字符串包及其包含的文件](img/B18621_10_7.jpg)'
- en: 'Figure 10.7: The strings package along with the files contained within it as
    of Go 1.21'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：截至Go 1.21的字符串包及其包含的文件
- en: 'Each one of those files starts with a package declaration, even though they
    are all separate files. We will look at an example from the Go standard library.
    In the Go standard library, there is a package called `strings\`. It is made up
    of multiple files. We will only be looking at a snippet of code from the files
    in the package: `builder.go`, `compare.go`, and `replace.go`. We have removed
    comments and some code just to demonstrate that the package files start with the
    package name. There will be no output from the code snippet. This is an example
    of how Go organizes code into multiple files but in the same package ([https://golang.org/src/strings/builder.go](https://golang.org/src/strings/builder.go)):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的每一个都以包声明开始，尽管它们都是独立的文件。我们将从Go标准库中的一个示例中查看。在Go标准库中，有一个名为`strings\`的包。它由多个文件组成。我们只将查看包中的代码片段：`builder.go`、`compare.go`和`replace.go`。我们已删除注释和一些代码，仅为了展示包文件以包名开头。代码片段将不会有输出。这是Go如何将代码组织到多个文件但仍在同一包中的示例（[https://golang.org/src/strings/builder.go](https://golang.org/src/strings/builder.go)）：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go)找到。
- en: All functions, types, and variables that are defined in the Go source file are
    accessible within that package. Though your package could spread across multiple
    files, it is all part of the same package. Internally, all code is accessible
    across the files. Simply stated, the code is visible within the package. Notice
    that not all of the code is visible outside of the package. The preceding snippet
    is from the official Go libraries. For a further explanation of the code, visit
    the links in the preceding Go snippet.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 源文件中定义的所有函数、类型和变量都可以在该包内访问。尽管你的包可能分布在多个文件中，但它仍然是同一个包的一部分。内部，所有代码都可以跨文件访问。简单来说，代码在包内是可见的。注意，并非所有代码在包外都是可见的。前面的代码片段来自官方的
    Go 库。有关代码的进一步解释，请访问前面的 Go 代码片段中的链接。
- en: Exported and unexported code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和未导出代码
- en: Go has a very simple way to determine whether code is exported or unexported.
    Exported means that variables, types, functions, and so on are visible from outside
    of the package. Unexported means it is only visible from inside the package. If
    a function, type, variable, and so on starts with an uppercase letter, it is exportable;
    if it starts with a lowercase letter, it is unexportable. There are no access
    modifiers to be concerned with in Go. If the function name is capitalized, then
    it is exported, and if it is lowercase, then it is unexported.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有一个非常简单的方式来确定代码是导出还是未导出。导出意味着变量、类型、函数等在包外部是可见的。未导出意味着它只对包内部可见。如果一个函数、类型、变量等以大写字母开头，它是可导出的；如果以小写字母开头，它是不可导出的。在
    Go 中没有需要关心的访问修饰符。如果函数名称是大写的，那么它是导出的，如果是小写的，那么它是未导出的。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice to only expose code that we want other packages to see.
    We should hide everything else that is not needed by external packages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 只暴露我们希望其他包看到的代码是一种良好的实践。我们应该隐藏所有其他外部包不需要的内容。
- en: 'Let’s look at the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的代码片段：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code snippet uses the `strings` package. We are calling a `strings` function
    called `Contains`. The `strings.Contains` function searches the `str` variable
    to see whether it has the value `"found"` within it. If `"found"` is within the
    `str` variable, the `strings.Contains` function will return `true`; if `"found"`
    is not within the `str` variable, the `strings.Contains` function will return
    `false`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段使用了`strings`包。我们正在调用一个名为`Contains`的`strings`函数。`strings.Contains`函数会搜索`str`变量，看它是否包含值`"found"`。如果`"found"`在`str`变量中，`strings.Contains`函数将返回`true`；如果`"found"`不在`str`变量中，`strings.Contains`函数将返回`false`：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To call the function, we prefix it with the package name and then the function
    name.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，我们在包名前加上函数名。
- en: This function is exportable and thus is accessible to others outside of the
    `strings` package. We know it is an exported function because the first letter
    of the function is capitalized.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是可导出的，因此对`strings`包外的其他人来说是可访问的。我们知道它是一个导出函数，因为函数的第一个字母是大写的。
- en: When you import a package, you only have access to the exported names.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个包时，你只能访问导出的名称。
- en: 'We can validate whether the function exists in the `strings` package by looking
    at the `strings.go` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看`strings.go`文件来验证函数是否存在于`strings`包中：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next code snippet will attempt to access an unexported function in the
    `strings` package:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段将尝试访问`strings`包中的一个未导出函数：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function is unexported because it starts with a lowercase letter. Only code
    within the package can access the function; it is not visible outside of the package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 函数未导出，因为它以小写字母开头。只有包内的代码可以访问该函数；它对包外不可见。
- en: 'The code is attempting to call an unexported function in the `strings.go` package
    file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尝试在`strings.go`包文件中调用一个未导出的函数：
- en: '![Figure 10.8: Program output](img/B18621_10_8.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8：程序输出](img/B18621_10_8.jpg)'
- en: 'Figure 10.8: Program output'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：程序输出
- en: 'The following code snippet is from the Go standard library `strings` package
    and from the `strings.go` file inside of that package ([https://packt.live/2RMxXqh](https://packt.live/2RMxXqh)).
    You can see that the `explode()` function is unexportable because the function
    name starts with a lowercase letter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自 Go 标准库的`strings`包以及该包内部的`strings.go`文件（[https://packt.live/2RMxXqh](https://packt.live/2RMxXqh)）。你可以看到`explode()`函数是不可导出的，因为函数名以小写字母开头：
- en: main.go
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go)找到。
- en: Package alias
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包别名
- en: 'Go also has the ability to alias package names. There are a few reasons that
    you may want to use alias names:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Go也有别名包名的功能。您可能希望使用别名名的原因有以下几点：
- en: The package name may not make it easy to understand its purpose. For clarity,
    it might be better to alias (use) a different name for the package.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名可能不容易让人理解其用途。为了清晰起见，可能更好的是为包使用不同的别名。
- en: The package name might be too long. In this case, you want the alias to be more
    concise and less verbose.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名可能太长。在这种情况下，您希望别名更简洁、更简洁。
- en: There could be scenarios where the package path is unique but both package names
    are the same. You would need to then use aliasing to differentiate between the
    two packages.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在包路径唯一但包名相同的场景。这时，您需要使用别名来区分这两个包。
- en: 'The package-aliasing syntax is very simple. You place the alias name before
    the `import` package path:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 包别名语法非常简单。您在`import`包路径之前放置别名名：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is a simple example showing how to use package aliasing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，展示了如何使用包别名：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are aliasing the `fmt` package as `f`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`fmt`包别名为`f`：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the `main()` function, we are now able to call the `Println()` function using
    the `f` alias.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们现在可以使用`f`别名调用`Println()`函数。
- en: Main package
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主包
- en: 'The `main` package is a special package. There are two basic types of packages
    in Go: executable and non-executable. The `main` package is an executable package
    in Go. Logic that resides in this package may not be consumed by other packages.
    The `main` package requires there to be a `main()` function in its package. The
    `main()` function is the entry point for a Go executable. When you perform `go
    build` on the `main` package, it will compile the package and create a binary.
    The binary is created inside the directory where the `main` package is located.
    The name of the binary will be the name of the folder it resides in:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`包是一个特殊的包。Go中有两种基本的包类型：可执行包和非可执行包。`main`包是Go中的一个可执行包。位于此包中的逻辑可能不会被其他包消费。`main`包要求在其包中存在一个`main()`函数。`main()`函数是Go可执行程序的入口点。当您对`main`包执行`go
    build`时，它将编译该包并创建一个二进制文件。二进制文件将创建在`main`包所在的目录中。二进制文件的名字将是它所在的文件夹名：'
- en: '![Figure 10.9: Why main package is special](img/B18621_10_9.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9：为什么main包是特殊的](img/B18621_10_9.jpg)'
- en: 'Figure 10.9: Why main package is special'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：为什么main包是特殊的
- en: 'Here’s a simple example of the `main` package code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`main`包代码的简单示例：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The expected output is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercise 10.01 – Creating a package to calculate areas of various shapes
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01 – 创建一个包来计算各种形状的面积
- en: In [*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291), *Getting Flexible with
    Interfaces*, we implemented code to calculate areas of different shapes. In this
    exercise, we will move all the code about shapes into a package called `shape`.
    We will then update the code in the `shape` package to be exportable. Then, we
    will update `main` to import our new `shape` package. However, we want it to still
    perform the same functionality in the `main()` function of the `main` package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18621_07.xhtml#_idTextAnchor1291)，“利用接口变得灵活”，我们实现了计算不同形状面积的代码。在这个练习中，我们将所有关于形状的代码移动到一个名为`shape`的包中。然后，我们将`shape`包中的代码更新为可导出。然后，我们将更新`main`包以导入我们新的`shape`包。然而，我们希望它在`main`包的`main()`函数中仍然执行相同的功能。
- en: 'Here is the code that we will be converting into packages:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要转换为包的代码：
- en: '[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go)'
- en: 'You should have a directory structure, as displayed in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该有一个目录结构，如下面的截图所示：
- en: '![Figure 10.10: Program directory structure](img/B18621_10_10.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10：程序目录结构](img/B18621_10_10.jpg)'
- en: 'Figure 10.10: Program directory structure'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：程序目录结构
- en: 'The `shape.go` file should contain the entire code: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape.go` 文件应包含整个代码：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go)。'
- en: 'We will only be going over changes that are relevant to making this code a
    package; for details on the parts of the code that we have gone over in a previous
    chapter, please see [*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291), *Getting
    Flexible* *with Interfaces*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只介绍与将此代码转换为包相关的更改；有关我们已在上一章中介绍过的代码部分，请参阅[*第7章*](B18621_07.xhtml#_idTextAnchor1291)，*通过接口*
    *变得灵活*：
- en: Create a directory called `Exercise10.01` inside `Chapter10`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter10` 内创建一个名为 `Exercise10.01` 的目录。
- en: 'Create a new Go module within the `Exercise10.01` directory:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise10.01` 目录内创建一个新的 Go 模块：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create two more directories called `cmd` and a nested directory of `pkg/shape`
    inside the `Exercise10.01` directory.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise10.01` 目录内创建两个更多目录，分别命名为 `cmd` 和 `pkg/shape` 的嵌套目录。
- en: Create a file called `main.go` inside the `Exercise10.01/cmd` directory.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise10.01/cmd` 目录内创建一个名为 `main.go` 的文件。
- en: Create a file called `shape.go` inside the `Exercise10.01/pkg/shape` directory.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise10.01/pkg/shape` 目录内创建一个名为 `shape.go` 的文件。
- en: Open the `Exercise10.01/pkg/shape.go` file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Exercise10.01/pkg/shape.go` 文件。
- en: 'Add the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE13]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first line of code in this file tells us this is a non-executable package
    called `shape`. A non-executable package, when compiled, does not result in binary
    or executable code. Recall that the `main` package is an executable package.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件中的第一行代码告诉我们这是一个名为 `shape` 的不可执行包。不可执行包在编译时不会产生二进制或可执行代码。回想一下，`main` 包是一个可执行包。
- en: 'Next, we need to make the types exportable. For each `struct` type, we have
    to capitalize on the type name and its fields to make it exportable. Exportable
    means that it is visible outside of this package:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使类型可导出。对于每个 `struct` 类型，我们必须将类型名称及其字段大写化以使其可导出。可导出意味着它可以在包外部可见：
- en: '[PRE14]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We also have to make the methods non-exportable by changing the method name
    to lowercase. There is no need at the moment to make those methods visible outside
    of the package.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须通过将方法名称更改为小写来使方法不可导出。目前没有必要让这些方法在包外部可见。
- en: 'The `shape.go` file contents should now include the following:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shape.go` 文件内容应包括以下内容：'
- en: '[PRE15]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The full code for this step is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go)。
- en: 'The `PrintShapeDetails()` function also needs to be capitalized:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrintShapeDetails()` 函数也需要大写化：'
- en: '[PRE16]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Perform a build to ensure that there are no compilation errors:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行构建以确保没有编译错误：
- en: '[PRE17]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the listing for the `main.go` file. By having a package as `main`,
    we know that this is executable:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 `main.go` 文件的列表。通过将包命名为 `main`，我们知道这是一个可执行的：
- en: '[PRE18]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `import` declaration only has one import. It is the `shape` package. We
    can see the name of the package is `shape` since it is the last directory name
    in the path declaration. The path for where my package is located may differ from
    yours:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import` 声明只有一个导入。它是 `shape` 包。我们可以看到包名是 `shape`，因为它是在路径声明中的最后一个目录名。我的包所在路径可能与您的不一样：'
- en: '[PRE19]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the `main()` function, we are initializing the `shape` package’s exportable
    types:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们正在初始化 `shape` 包的导出类型：
- en: '[PRE20]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then call the `shape()` function, `PrintShapeDetails`, to get the area of
    each shape:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用 `shape()` 函数和 `PrintShapeDetails`，以获取每个形状的面积：
- en: '[PRE21]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At the command line, go to the `Exercise10.01/cmd` directory structure.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，进入 `Exercise10.01/cmd` 目录结构。
- en: 'Type the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `go build` command will compile your program and create an executable named
    after the directory, `cmd`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go build`命令将编译你的程序并创建一个以目录命名的可执行文件，名为`cmd`。'
- en: 'Type the executable name and hit *Enter*:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入可执行文件名并按*Enter*键：
- en: '[PRE23]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The expected output is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We now have the functionality that we previously had in the interface chapter’s
    implementation of `shape`. We have the `shape` functionality now encapsulated
    in the `shape` package. We exposed or made visible only functions or methods that
    are needed to maintain the previous implementation. The `main` package has less
    clutter and imports the local `shape` package to provide the functionality that
    was in the previous implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了之前在接口章节的`shape`实现中拥有的功能。现在`shape`功能被封装在`shape`包中。我们只暴露或使需要维护之前实现的功能或方法可见。`main`包更加简洁，并导入本地`shape`包以提供之前实现中的功能。
- en: The init() function
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`init()`函数'
- en: 'As we have discussed, every Go program (executable) starts in the `main` package
    and the entry point is the `main()` function. There is another special function
    that we should be aware of, called `init()`. Each source file can have an `init()`
    function, but for now, we will look at the `init()` function in the context of
    the `main` package. When you start writing packages, you might need to provide
    some initialization (the `init()` function) for the package. The `init()` function
    is used to set up states or values. The `init()` function adds initialization
    logic for your package. Here are some examples of uses of the `init()` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，每个Go程序（可执行程序）都是从`main`包开始的，入口点是`main()`函数。还有一个我们应该注意的特殊函数，称为`init()`。每个源文件都可以有一个`init()`函数，但到目前为止，我们将从`main`包的角度来看`init()`函数。当你开始编写包时，你可能需要为包提供一些初始化（`init()`函数）。`init()`函数用于设置状态或值。`init()`函数为你的包添加初始化逻辑。以下是一些`init()`函数使用示例：
- en: Setting database objects and connections
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库对象和连接
- en: The initialization of package variables
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包变量的初始化
- en: Creating files
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件
- en: Loading configuration data
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载配置数据
- en: Verifying or repairing the program state
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证或修复程序状态
- en: 'The `init()` function requires the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数需要以下内容：'
- en: Imported packages are initialized first
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的包首先初始化
- en: Package-level variables are initialized
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包级别变量初始化
- en: The package’s `init()` function is called
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用包的`init()`函数
- en: '`main()` is executed'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`main()`函数
- en: 'The following diagram shows the execution order that a typical Go program follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了典型Go程序遵循的执行顺序：
- en: '![Figure 10.11: Order of execution](img/B18621_10_11.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11：执行顺序](img/B18621_10_11.jpg)'
- en: 'Figure 10.11: Order of execution'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：执行顺序
- en: 'Here is a simple example that demonstrates the `package main` order of execution:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，演示了`package main`的执行顺序：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the code is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s understand the code in parts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分理解这段代码：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Based on the output of the code, the package-level variable declaration gets
    executed first. We know this because the `name` variable is printed in the `init()`
    function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码的输出，包级别的变量声明首先执行。我们知道这一点是因为`name`变量在`init()`函数中被打印出来：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `init()` function then gets called and prints out `"``Hello, Gopher"`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`init()`函数被调用并打印出`"Hello, Gopher"`：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, the `main()` function is executed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行`main()`函数：
- en: '![Figure 10.12: Execution flow of the code snippet](img/B18621_10_12.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12：代码片段的执行流程](img/B18621_10_12.jpg)'
- en: 'Figure 10.12: Execution flow of the code snippet'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：代码片段的执行流程
- en: 'The `init()` function cannot have any arguments or return values:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数不能有任何参数或返回值：'
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running this code snippet will result in the following error:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段将导致以下错误：
- en: '![Figure 10.13: Program output](img/B18621_10_13.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13：程序输出](img/B18621_10_13.jpg)'
- en: 'Figure 10.13: Program output'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：程序输出
- en: Exercise 10.02 – Loading budget categories
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02 – 加载预算类别
- en: 'Write a program that will load budget categories into a global map, before
    the `main()` function runs. The `main()` function should then print out the data
    on the map:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，在`main()`函数运行之前将预算类别加载到全局映射中。然后`main()`函数应打印映射中的数据：
- en: Create a `main.go` file.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件。
- en: 'The code file will belong to `package main` and will need to import the `fmt`
    package:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码文件将属于`package main`，并且需要导入`fmt`包：
- en: '[PRE31]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a global variable that will contain a map of budget categories with
    a key of `int` and a value of `string`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局变量，它将包含一个键为`int`、值为`string`的预算类别映射：
- en: '[PRE32]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will need to use an `init()` function to load our budget categories before
    `main()` runs:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`main()`函数运行之前使用一个`init()`函数来加载我们的预算类别：
- en: '[PRE33]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since our budget categories have been loaded, we can now iterate over the map
    and print them:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的预算类别已经加载，我们现在可以遍历映射并打印它们：
- en: '[PRE34]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will get the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output may differ in terms of the order displayed; Go maps do not guarantee
    the order of data.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的顺序可能会有所不同；Go映射不保证数据的顺序。
- en: The aim here was to demonstrate how the `init()` function can be used to perform
    data initialization and loading before the `main()` function executes. Data that
    generally needs to be loaded before `main()` runs is static data, such as picklist
    values or some sort of configuration. As demonstrated, after the data gets loaded
    through the `init()` function, it can be used by the `main()` function. In the
    next topic, we will see how multiple `init()` functions get executed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是展示如何使用`init()`函数在`main()`函数执行之前执行数据初始化和加载。通常需要在`main()`运行之前加载的数据是静态数据，例如下拉列表值或某种配置。如所示，数据通过`init()`函数加载后，可以被`main()`函数使用。在下一个主题中，我们将看到多个`init()`函数是如何执行的。
- en: Executing multiple init() functions
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行多个`init()`函数
- en: 'There can be more than one `init()` function in a package. This enables you
    to modularize your initialization for better code maintenance. For example, suppose
    you need to set up various files and database connections and repair the state
    of the environment your program will be executed in. Doing all that in one `init()`
    function would make it complicated for maintaining and debugging. The order of
    execution of multiple `init()` functions is the order in which the functions are
    placed in the code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包中可以有多个`init()`函数。这使您能够模块化初始化，以更好地维护代码。例如，假设您需要设置各种文件和数据库连接以及修复程序执行的环境状态。在一个`init()`函数中完成所有这些会使维护和调试变得复杂。多个`init()`函数的执行顺序是函数在代码中放置的顺序：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s break the code into parts and evaluate it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将代码分解成部分并评估它：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Go initializes the `name` variable first, before the `init()` function gets
    executed:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Go首先初始化`name`变量，在`init()`函数执行之前：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This prints out first since it is the first `init` in the function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先打印出来，因为它是在函数中第一个`init`：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding gets printed out second since it is the second `init` in the
    function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是函数中的第二个`init`，所以先前的内容被打印出来：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding gets printed out third since it is the third `init` in the function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是函数中的第三个`init`，所以先前的内容被打印出来：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Finally, the `main()` function gets executed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行`main()`函数。
- en: 'The results would be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Exercise 10.03 – Assigning payees to budget categories
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03 – 将收款人分配给预算类别
- en: 'We are going to expand our program from *Exercise 10.02*, *Loading budget categories*,
    to now assign payees to budget categories. This is similar to many budgeting applications
    that try to match payees to commonly used categories. We will then print the mapping
    of a payee to a category:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的程序，从*练习10.02*，*加载预算类别*，到现在为预算类别分配收款人。这类似于许多尝试将收款人与常用类别匹配的预算应用程序。然后我们将打印收款人与类别之间的映射：
- en: Create a `main.go` file.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件。
- en: Copy the code from *Exercise 10.02*, *Loading Budget Categories*, (https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.02/main.go)
    into the `main.go` file.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*练习10.02*，*加载预算类别*（https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.02/main.go）中的代码复制到`main.go`文件中。
- en: 'Add a `payeeToCategory` map after `budgetCategories`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`budgetCategories`之后添加一个`payeeToCategory`映射：
- en: '[PRE43]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add another `init()` function. This `init()` function will be used to populate
    our new `payeeToCategory` map. We will assign payees to the key value of the categories:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个`init()`函数。这个`init()`函数将用于填充我们的新`payeeToCategory`映射。我们将把收款人分配给类别的键值：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The full code for this step is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go).
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go)找到。
- en: 'In the `main()` function, we will print out the payees to categories. We iterate
    over the `payeeToCategory` map, printing the key (`payee`). We print the category
    by passing the value of the `payeeToCategory` map as a key to the `budgetCategories`
    map:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将打印出收款人到类别。我们遍历`payeeToCategory`映射，打印键（`payee`）。我们通过将`payeeToCategory`映射的值作为键传递给`budgetCategories`映射来打印类别：
- en: '[PRE45]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here’s the expected output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是预期的输出：
- en: '![Figure 10.14: Assigning a payee to budget categories](img/B18621_10_14.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14：将收款人分配到预算类别](img/B18621_10_14.jpg)'
- en: 'Figure 10.14: Assigning a payee to budget categories'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：将收款人分配到预算类别
- en: You have now created a program that executes multiple `init()` functions before
    the execution of the `main()` function. Each of the `init()` functions loaded
    data into our global map variables. We have determined the order of `init()` functions
    executing because of the `print` statements that get displayed. This demonstrates
    that the `init()` functions print in the order they are present in the code. It
    is important to be aware of the order of your `init()` functions as you may have
    unforeseen results based on the order of the code execution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在创建了一个程序，在`main()`函数执行之前执行多个`init()`函数。每个`init()`函数将数据加载到我们的全局映射变量中。我们确定了`init()`函数执行的顺序，因为显示的`print`语句。这表明`init()`函数按照它们在代码中出现的顺序打印。了解您`init()`函数的顺序很重要，因为您可能会根据代码执行的顺序得到不可预见的结果。
- en: In the upcoming activity, we will be using all these concepts that we have looked
    at with packages and see how they all work together.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的活动中，我们将使用所有这些概念，包括我们查看的包，看看它们是如何一起工作的。
- en: Activity 10.01 – Creating a function to calculate payroll and performance review
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01 – 创建一个计算工资和绩效评估的函数
- en: 'In this activity, we are going to take *Activity 7.01*, *Calculating pay and
    performance review*, from [*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291) and
    modularize it using packages. We will be refactoring the code from [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将从[*第7章*](B18621_07.xhtml#_idTextAnchor1291)中的*活动7.01*，*计算工资和绩效评估*，使用包进行模块化。我们将重构从[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go)的代码：
- en: Move the types and methods of `Developer`, `Employee`, and `Manager` into their
    own package under `pkg/payroll`. Types, methods, and functions must be properly
    exported or unexported.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Developer`、`Employee`和`Manager`的类型和方法移动到`pkg/payroll`下的自己的包中。类型、方法和函数必须正确导出或未导出。
- en: Name the package `payroll`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包命名为`payroll`。
- en: Logically separate the types and their methods into different package files.
    Recall that good code organization involves separating similar functionality into
    separate files.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型及其方法逻辑上分离到不同的包文件中。回想一下，良好的代码组织涉及将类似功能分离到单独的文件中。
- en: Create a `main()` function as an alias to the `payroll` package.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main()`函数作为`payroll`包的别名。
- en: Introduce two `init()` functions in the `main` package under the `cmd` directory.
    The first `init()` function should simply print a greeting message to `stdout`.
    The second `init()` function should initialize/set up key-value pairs.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cmd`目录下的`main`包中引入两个`init()`函数。第一个`init()`函数应该简单地打印一条问候消息到`stdout`。第二个`init()`函数应该初始化/设置键值对。
- en: 'The expected output would be as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this activity, we have seen how to use packages to separate our code and
    then logically separate the code into individual files. We can see that each of
    those files makes up a package. Each file of the package has internal access to
    the other files regardless of the fact that they are in separate files. This activity
    demonstrates how to create a package with multiple files and how those separate
    files can be used to further organize our code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们看到了如何使用包来分离我们的代码，然后将代码逻辑上分离成单个文件。我们可以看到每个文件都构成了一个包。包中的每个文件都可以访问其他文件，无论它们是否在单独的文件中。这个活动演示了如何创建包含多个文件的包，以及如何使用这些单独的文件进一步组织我们的代码。
- en: Note
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在本章的GitHub仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01)。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the importance of developing software that is
    maintainable, reusable, and modular. We discovered how Go’s packages play an important
    part in meeting those criteria for developing software. We looked at the overall
    structure of a package. It is made up of a directory, can contain one or more
    files, and has code that is related. A package is essentially a directory inside
    of your workspace that contains one or more files that are used for grouping code
    that is to perform a task. It exposes only the necessary parts to those using
    your package to get a job done. We discussed the importance of naming packages
    properly. We also learned how to name a package; that is, concisely, in lowercase,
    descriptively, using non-plural names, and avoiding generic names. Packages can
    be executable or non-executable. If a package is the `main` package, then it is
    an executable package. The `main` package must have a `main()` function, and that
    is where the entry point is for our package.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了开发可维护、可重用和模块化软件的重要性。我们发现了Go的包在满足这些软件开发标准方面发挥着重要作用。我们研究了包的整体结构。它由一个目录组成，可以包含一个或多个文件，并包含相关的代码。包本质上是你工作空间中的一个目录，包含一个或多个用于分组执行任务的文件。它仅向使用你的包的人公开必要的部分以完成任务。我们讨论了正确命名包的重要性。我们还学习了如何命名一个包；即简洁、小写、描述性、使用非复数名称，并避免使用通用名称。包可以是可执行的或不可执行的。如果一个包是`main`包，那么它是一个可执行包。`main`包必须有一个`main()`函数，这是我们包的入口点。
- en: 'We also talked about what is exportable and unexportable code. When we capitalize
    the name of a function, type, or method, it is visible to others using our package.
    Lowercasing a function, type, or method makes it not visible to other users from
    outside our package. We learned that `init()` functions can perform the following
    duties: initializing variables, loading configuration data, setting database connections,
    or verifying that our program state is ready for execution. `init()` functions
    have certain rules when they get executed and on how to utilize them. This chapter
    will help you to write highly manageable, reusable, and modular code.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了什么是可导出和不可导出的代码。当我们将函数、类型或方法的名称大写时，它对使用我们的包的其他人是可见的。将函数、类型或方法小写化使其对包外部的其他用户不可见。我们了解到`init()`函数可以执行以下任务：初始化变量、加载配置数据、设置数据库连接或验证我们的程序状态是否已准备好执行。`init()`函数在执行时和如何利用它们方面有一些规则。本章将帮助你编写高度可管理、可重用和模块化的代码。
- en: In the next chapter, we will start exploring debugging skills, a crucial aspect
    of software development. This will include learning about effective troubleshooting
    to enable a robust development experience.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探索调试技巧，这是软件开发的一个关键方面。这包括学习有效的故障排除，以实现稳健的开发体验。
