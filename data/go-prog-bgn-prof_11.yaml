- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Bug-Busting Debugging Skills
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除bug的调试技能
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at basic debugging methodologies. We will look
    at some proactive measures we can take to reduce the number of bugs we introduce
    into our program. Once we understand these measures, we will investigate the ways
    in which we can locate a bug.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨基本的调试方法。我们将探讨我们可以采取的一些主动措施来减少我们程序中引入的bug数量。一旦我们理解了这些措施，我们将研究我们可以定位bug的方法。
- en: You will be able to acquaint yourself with debugging in Go and implement various
    ways to format printing. You will evaluate various techniques of basic debugging
    and find the general location of a bug in code. By the end of the chapter, you
    will know how to print out variable types and values using Go code and log the
    state of an application for debugging purposes. You will also see what debugging
    measures are available in different or restricted environments that your code
    may eventually be deployed to.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够熟悉Go中的调试，并实现各种格式化打印的方法。你将评估基本的调试技术，并找到代码中bug的一般位置。到本章结束时，你将知道如何使用Go代码打印变量类型和值，以及为了调试目的记录应用程序的状态。你还将看到在不同的或受限环境中，你的代码可能部署到的环境中可用的调试措施。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'As you develop software programs, there are going to be times when your program
    behaves in an unintended way. For instance, the program could throw an error and
    might crash. A crash is when our code stops functioning midway and then exits
    abruptly. Perhaps the program has given us unexpected results. For example, we
    request a video-streaming service for the movie *Rocky 1* but instead get *Creed
    1!* Or you deposited a check into your bank account but, instead of being credited,
    the bank software debited your account. These examples of software programs behaving
    in an unintended way are called bugs. Sometimes, “bug” and “error” are used interchangeably.
    In [*Chapter 6*](B18621_06.xhtml#_idTextAnchor1210), *Don’t Panic! Handle Your
    Errors*, in the *What are errors?* section, we discussed how there are three different
    types of errors or bugs: syntax errors, runtime errors, and logic errors. We also
    examined examples and saw the difficulty of discovering the location of each type
    of error.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开发软件程序的过程中，程序可能会以非预期的方式运行。例如，程序可能会抛出错误并可能崩溃。崩溃是指我们的代码在中间停止运行并突然退出。也许程序给出了我们意料之外的结果。例如，我们请求视频流服务来观看电影
    *Rocky 1*，但反而得到了 *Creed 1!* 或者你将支票存入银行账户，但银行软件却从你的账户中扣除。这些软件程序以非预期方式运行的情况被称为“bug”。有时，“bug”和“error”可以互换使用。在[*第6章*](B18621_06.xhtml#_idTextAnchor1210)，“不要慌张！处理你的错误”部分，我们在“什么是错误？”一节中讨论了存在三种不同类型的错误或bug：语法错误、运行时错误和逻辑错误。我们还考察了示例，并看到了发现每种类型错误位置的难度。
- en: 'The process of determining the cause of unintended behavior is called debugging.
    There are various causes of bugs that get released into production:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 确定意外行为原因的过程称为调试。将发布到生产环境的bug有各种原因：
- en: '**Testing is performed as an afterthought**: During the development life cycle,
    it is tempting to not perform testing incrementally. For instance, we are creating
    multiple functions for an application, and once we finish all the functions, they
    then get tested. A possibly better way of testing our code would be to test each
    function as we complete it. This is known as incrementally testing or delivering
    code in smaller chunks. This gives us better code stability. This is accomplished
    by testing a function to ensure it works before continuing to the next function.
    The function that we just completed could be used by other functions. If we do
    not test it before we continue, the other functions that use our function could
    be using a buggy function. Depending on the bug and the change to our function,
    it could impact other users of our function. Later in the chapter, we will discuss
    more benefits of testing incrementally.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试作为事后考虑**：在开发生命周期中，不进行增量测试是很诱人的。例如，我们正在为应用程序创建多个函数，一旦我们完成所有函数，它们然后被测试。测试我们代码的一个可能更好的方式是在完成每个函数后测试它。这被称为增量测试或以更小的块交付代码。这使我们拥有更好的代码稳定性。这是通过在继续到下一个函数之前测试一个函数以确保它正常工作来实现的。我们刚刚完成的函数可能被其他函数使用。如果我们不测试它就继续，那么使用我们的函数的其他函数可能会使用一个有错误的函数。根据错误和我们对函数的更改，它可能会影响我们函数的其他用户。在本章的后面部分，我们将讨论增量测试的更多好处。'
- en: '**Application enhancements or changes to requirements**: Our code often changes
    between the development phase and when we release it to production. Once in production,
    we receive feedback from the users; the feedback could be additional requirements
    or even enhancements to the code. Changing the production-level code in one area
    could have a negative impact on another area. If the development team uses unit
    tests, then this would aid in mitigating some of the bugs introduced in a change
    to the code base. By using unit tests, we could run our unit test before we deliver
    the code to see whether our change had a negative impact. We will discuss what
    a unit test is later.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用增强或需求变更**：我们的代码在开发阶段和发布到生产阶段之间通常会发生变化。一旦进入生产阶段，我们会收到用户的反馈；反馈可能是额外的需求或对代码的增强。在一个区域更改生产级代码可能会对另一个区域产生负面影响。如果开发团队使用单元测试，那么这有助于减轻代码库更改中引入的一些错误。通过使用单元测试，我们可以在将代码交付之前运行我们的单元测试，以查看我们的更改是否产生了负面影响。我们将在稍后讨论单元测试是什么。'
- en: '**Unrealistic development timeframe**: There are times when functionality is
    requested to be delivered in very tight timeframes. This can lead to taking shortcuts
    in best practices, shortening the design phase, performing less testing, and receiving
    unclear requirements. All of those can increase the chance of introducing bugs.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不切实际的开发时间表**：有时，功能请求在非常紧张的时间框架内交付。这可能导致在最佳实践中走捷径，缩短设计阶段，进行较少的测试，以及收到不明确的需求。所有这些都会增加引入错误的机会。'
- en: '**Unhandled errors**: Some developers may choose not to handle errors as they
    occur; for example, a file that is needed for the application to load configuration
    data is not found, not handling an error return for an invalid mathematical operation
    such as dividing by zero, or perhaps a connection to a server could not be established.
    If your program does not properly handle these and other types of errors, this
    can cause bugs.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未处理的错误**：一些开发者可能选择不处理发生的错误；例如，应用程序加载配置数据所需的文件未找到，未处理无效数学运算（如除以零）的错误返回，或者可能无法建立与服务器的连接。如果你的程序没有正确处理这些和其他类型的错误，这可能会导致错误。'
- en: These are just a few causes of bugs. Bugs have a negative impact on our programs.
    The results of a bug that causes a miscalculation can be life-threatening. In
    the medical industry, a machine is used to administer a drug called heparin; this
    drug is a blood thinner and is used to prevent blood clots. If the code that determines
    the calculation of how often and how much heparin can be administered has a bug
    that causes it to malfunction, the machine could deliver too much or too little
    of the drug. This could have an adverse effect on the patient. As you can see,
    it is critical to deliver software that is as bug-free as possible. In this chapter,
    we are going to look at some ways to minimize the number of bugs that are introduced
    and ways of isolating the location of bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是bug的几个原因。bug对我们的程序有负面影响。一个导致计算错误的bug的结果可能是致命的。在医疗行业，有一种机器用于注射一种名为肝素的药物；这种药物是一种抗凝血剂，用于预防血栓。如果确定肝素给药频率和剂量的代码中存在导致其故障的bug，机器可能会给药过多或过少。这可能会对病人产生不利影响。正如你所看到的，交付尽可能无bug的软件至关重要。在本章中，我们将探讨一些减少引入bug数量以及隔离bug位置的方法。
- en: Methods for bug-free code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无bug代码的方法
- en: 'We will briefly look at some methods that will help us to minimize the number
    of bugs that could be introduced into our code. These methods will also aid in
    giving us confidence as to the portions of the code that introduced the bug:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要地探讨一些方法，这些方法将帮助我们最小化可能被引入代码中的bug数量。这些方法还将帮助我们增强对引入bug的代码部分的信心：
- en: '![Figure 11.1: Different methods to debug code](img/B18621_11_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：调试代码的不同方法](img/B18621_11_01.jpg)'
- en: 'Figure 11.1: Different methods to debug code'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：调试代码的不同方法
- en: Let’s look at these methods in more detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些方法。
- en: Coding incrementally and testing often
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐步编码和经常测试
- en: Let’s consider the approach of developing incrementally. This means developing
    the program incrementally and testing it often after adding an incremental piece
    of code. This pattern will help you to track bugs easily because you are testing
    every small snippet of code as opposed to one large program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑逐步开发的方法。这意味着逐步开发程序，并在添加增量代码后经常对其进行测试。这种模式将帮助你轻松跟踪bug，因为你正在测试每一小段代码，而不是一个大的程序。
- en: Writing unit tests
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: When a test is written and code changes occur, the unit test protects the code
    from potential bugs being introduced. A typical unit test takes a given input
    and validates that a given result is produced. If the unit test is passing before
    the code change but is now failing after the code change, then we can conclude
    that we introduced some unintended behavior. The unit test needs to pass before
    we push our code to a production system. In other words, development teams verify
    that tests pass and that the code still works as expected before accepting new
    changes to the code base.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写测试并更改代码时，单元测试可以保护代码免受潜在bug的引入。典型的单元测试接受一个给定的输入并验证是否产生了一个给定的结果。如果在代码更改之前单元测试通过，但在代码更改后失败，那么我们可以得出结论，我们引入了一些意外的行为。在将代码推送到生产系统之前，单元测试必须通过。换句话说，开发团队在接受代码库的新更改之前，验证测试是否通过，代码是否仍然按预期工作。
- en: Handling all errors
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理所有错误
- en: This was discussed in [*Chapter 6*](B18621_06.xhtml#_idTextAnchor1210), *Don’t
    Panic! Handle Your Errors*. Ignoring errors can lead to potentially unintended
    results in our program. We need to handle errors properly to make the debugging
    process easier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[*第6章*](B18621_06.xhtml#_idTextAnchor1210)中讨论过，“不要慌张！处理你的错误”。忽略错误可能导致程序中出现意外结果。我们需要正确处理错误，以便使调试过程更容易。
- en: Performing logging
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行日志记录
- en: Logging is another technique that we can use to determine what is occurring
    in the program. There are various types of logging; some common logging types
    are debug, info, warn, error, fatal, and trace. We will not go into the details
    of each type; we will focus instead on performing debug-type logging. This type
    of logging is typically used to determine the state of the program before a bug
    occurs. Some of the information that is gathered includes the values of the variables,
    the portion of the code that is being executed (one example would be the function
    name), the values of the arguments being passed, the output of the function or
    method, and more. In this chapter, we will be performing our own custom debug
    logging using the built-in features of the Go standard library. The built-in `log`
    package of Go can provide timestamps. This is useful when trying to understand
    the timing of various events. When you perform logging, you will need to keep
    in mind the performance implications. Depending on the application and the load
    it is under (that is, the number of users interacting with the system around the
    same time), the application logging output amount could be extensive during peak
    times and may have a negative impact on the performance of the application. Depending
    on the number of logs added to the application, the more the users that interact
    with the system the more logs it will generate, and the more of a negative impact
    on the performance of the application this could create. In certain circumstances,
    it could cause it to be unresponsive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是另一种我们可以用来确定程序中发生情况的技巧。有各种类型的日志；一些常见的日志类型包括 debug、info、warn、error、fatal
    和 trace。我们不会深入到每种类型的细节；相反，我们将专注于执行 debug 类型的日志。这种类型的日志通常用于确定在出现错误之前程序的状态。收集的一些信息包括变量的值、正在执行的代码部分（一个例子是函数名）、传递的参数的值、函数或方法的输出，等等。在本章中，我们将使用
    Go 标准库的内置功能执行我们自己的自定义 debug 日志。Go 的内置 `log` 包可以提供时间戳。这在试图理解各种事件的时机时很有用。当你进行日志记录时，你需要考虑到性能的影响。根据应用程序及其承受的负载（即，在同一时间与系统交互的用户数量），在高峰时段应用程序的日志输出量可能会很大，可能会对应用程序的性能产生负面影响。根据添加到应用程序中的日志数量，与系统交互的用户越多，生成的日志就越多，这可能会对应用程序的性能产生更大的负面影响。在某些情况下，它可能会导致程序无响应。
- en: Formatting using fmt
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fmt 进行格式化
- en: One of the uses of the `fmt` package is to display data to the console or to
    the filesystem, such as a text file, that will contain information that could
    be helpful in debugging the code. We have used the `fmt.Println()` function on
    numerous occasions. Let’s take a slightly deeper look at the functionality of
    `fmt.Println()`. The `fmt.Println()` function places spaces between arguments
    passed to the function and then appends a newline character at the end of the
    string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt` 包的一个用途是将数据显示到控制台或文件系统，例如一个包含可能有助于调试代码的信息的文本文件。我们已经多次使用了 `fmt.Println()`
    函数。让我们稍微深入地看看 `fmt.Println()` 的功能。`fmt.Println()` 函数在传递给函数的参数之间放置空格，然后在字符串的末尾追加一个换行符。'
- en: Each type in Go has a default way that it is formatted when printed. For example,
    strings are printed as they are, and integers are printed in decimal format. The
    `fmt.Println()` function prints the default formats of arguments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，每种类型在打印时都有一个默认的格式化方式。例如，字符串按原样打印，整数以十进制格式打印。`fmt.Println()` 函数打印参数的默认格式。
- en: Exercise 11.01 – Working with fmt.Println
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01 – 使用 fmt.Println 操作
- en: 'In this exercise, we will print a `hello` statement using `fmt.Println`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `fmt.Println` 打印一个 `hello` 语句：
- en: 'Import the `fmt` package:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `fmt` 包：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare the `fname` and `lname` variables in a `main()` function and assign
    two strings to a variable:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中声明 `fname` 和 `lname` 变量，并将两个字符串赋给变量：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Call the `Println` method from the `fmt` package. It will print `Hello:` and
    then the value of both variables followed by a space. Then, it will print a `\n`
    (newline character) to the standard output:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `fmt` 包中调用 `Println` 方法。它将打印 `Hello:` 然后打印两个变量的值，后面跟着一个空格。然后，它将打印一个 `\n`（换行符）到标准输出：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following statement prints `Next Line` plus `\n` to the standard output:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句将 `Next Line` 加上 `\n` 打印到标准输出：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have demonstrated the basics of printing out messages. In the next topic,
    we will look at how we can format the data that we want to print.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了打印消息的基本方法。在下一个主题中，我们将探讨如何格式化我们想要打印的数据。
- en: Formatting using fmt.Printf()
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fmt.Printf()进行格式化
- en: The `fmt` package also has numerous ways of formatting the output of our various
    `print` statements. We will look next at the `fmt.Printf()` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`包也有多种格式化我们各种`print`语句输出的方式。接下来，我们将探讨`fmt.Printf()`函数。'
- en: '`fmt.Printf()` formats the string according to the verb and prints it to `stdout`.
    The standard output (`stdout`) is a stream for output. By default, the standard
    output is pointed to the terminal. The function uses something called format verbs,
    sometimes called a format specifier. The verbs tell the `fmt` function where to
    insert the variable. For example, `%s` prints a string; it is a placeholder for
    a string. These verbs are based on the C language:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Printf()`根据动词格式化字符串并将其打印到`stdout`。标准输出（`stdout`）是一个输出流。默认情况下，标准输出指向终端。该函数使用一种称为格式动词的东西，有时也称为格式说明符。动词告诉`fmt`函数在哪里插入变量。例如，`%s`打印一个字符串；它是一个字符串的占位符。这些动词基于C语言：'
- en: '![Figure 11.2: Explanation of Printf](img/B18621_11_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：Printf解释](img/B18621_11_02.jpg)'
- en: 'Figure 11.2: Explanation of Printf'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：Printf解释
- en: 'Consider the following example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `fname` variable is assigned as `Edward`. When the `fmt.Printf()` function
    runs, the `%s` verb will have the value of `fname`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fname`变量被赋值为`Edward`时，当`fmt.Printf()`函数运行时，`%s`动词的值将是`fname`。
- en: 'The output is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But what happens when we have more than one variable that we want to print?
    How can we print more than one variable in the `fmt.Printf()` function? Let’s
    take a look:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们想要打印多个变量时会发生什么？我们如何在`fmt.Printf()`函数中打印多个变量？让我们看看：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you see in the preceding code, we now have `fname` and `lname` assigned to
    a string. The `fmt.Printf()` function has two verb strings and two variables.
    The first variable, `fname`, is assigned to the first `%s` instance. The second
    variable, `lname`, is assigned to the second `%s` instance. The variables replace
    the verbs in the order they are placed in the `fmt.Printf()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们现在将`fname`和`lname`赋值给一个字符串。`fmt.Printf()`函数有两个动词字符串和两个变量。第一个变量`fname`被分配给第一个`%s`实例。第二个变量`lname`被分配给第二个`%s`实例。变量按照它们在`fmt.Printf()`函数中的放置顺序替换动词。
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `fmt.Printf()` function does not add a new line to the end of the string
    that it prints. We must add a newline character in the string if we want to return
    the output with a new line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Printf()`函数不会在其打印的字符串末尾添加新行。如果我们想在输出中返回带有新行的内容，我们必须在字符串中添加换行符：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Go, you can escape characters using `\`. If you ever wanted to print the
    `\` character, then you’d put `fmt.Println("\\")` to escape the character. This
    tells us that a character should not be printed because it has a special meaning.
    When you use `\n`, it denotes a newline. We can place a newline anywhere within
    the string.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你可以使用`\`来转义字符。如果你想打印`\`字符，那么你需要输入`fmt.Println("\\")`来转义该字符。这告诉我们一个字符不应该被打印，因为它有特殊的意义。当你使用`\n`时，它表示换行。我们可以在字符串的任何地方放置换行符。
- en: 'The output is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following would be the result if we did not place `\n` in the string:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在字符串中放置`\n`，以下将是结果：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Go language has several printing verbs. We will introduce some basic verbs
    that are frequently used. We will introduce others as they become pertinent to
    performing basic debugging:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言有多个打印动词。我们将介绍一些常用的基本动词。当它们与基本调试相关时，我们将介绍其他动词：
- en: '![Figure 11.3: Table representing verbs and their meanings](img/B18621_11_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3：表示动词及其含义的表格](img/B18621_11_03.jpg)'
- en: 'Figure 11.3: Table representing verbs and their meanings'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：表示动词及其含义的表格
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A full list of verbs available with the `fmt` package can be found at [https://pkg.go.dev/fmt#hdr-Printing](https://pkg.go.dev/fmt#hdr-Printing).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fmt`包可用的完整动词列表可以在[https://pkg.go.dev/fmt#hdr-Printing](https://pkg.go.dev/fmt#hdr-Printing)找到。
- en: 'Let’s look at an example of using verbs for printing out various data types:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用动词打印各种数据类型的示例：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We initialize various variables of different types that will be used in our
    `Printf()` function:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们初始化了各种不同类型的变量，这些变量将在我们的`Printf()`函数中使用：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`%s` is the placeholder for a string; when the `Printf()` function runs, the
    value from the `fname` variable will replace `%s`. `%f` is the placeholder for
    a float; when the `Printf()` statement runs, the value in the `gpa` variable will
    replace `%f`.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%s` 是字符串的占位符；当 `Printf()` 函数运行时，`fname` 变量的值将替换 `%s`。`%f` 是浮点数的占位符；当 `Printf()`
    语句运行时，`gpa` 变量中的值将替换 `%f`。'
- en: 'Check whether the person has a job as follows:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查这个人是否有工作如下：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`%t` is the placeholder for a `bool` type. When the `Printf()` statement runs,
    the value in the `hasJob` variable will replace `%t`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%t` 是 `bool` 类型的占位符。当 `Printf()` 语句运行时，`hasJob` 变量中的值将替换 `%t`。'
- en: 'Print the age of the person and their wage per hour:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印人的年龄和他们的时薪：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`%d` is the placeholder for an `int` base-10\. When the `Printf` statement
    runs, the value in the `age` variable will replace `%d`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%d` 是十进制 `int` 的占位符。当 `Printf` 语句运行时，`age` 变量中的值将替换 `%d`。'
- en: '`%v` is the placeholder for the value in a default format.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%v` 是默认格式中值的占位符。'
- en: 'The following is the expected output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we will demonstrate how to format verbs, such as `gpa`, to make them round
    to a specific number of decimal places.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示如何格式化动词，例如 `gpa`，使它们四舍五入到特定的位数。
- en: Additional options for formatting
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化选项的附加选项
- en: 'Verbs can also be formatted by adding additional options to the verb. In our
    previous example, the `gpa` variable printed out some erroneous zeros. In this
    topic, we are going to demonstrate how to control the printing of certain verbs.
    If we want to round to a certain precision when using the `%f` verb, we can do
    so by placing a decimal and a number following the `%` symbol: `%.2f`. That would
    specify two decimal places, with the second one being rounded. Given the following
    examples, notice how the *n*th number is rounded to what is specified by the number
    (n) used in the `%.``nf` verb:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 动词也可以通过向动词添加额外的选项来格式化。在我们之前的例子中，`gpa` 变量打印了一些错误的零。在本主题中，我们将演示如何控制某些动词的打印。如果我们想在使用
    `%f` 动词时四舍五入到特定的精度，我们可以通过在 `%` 符号后放置一个小数和一个数字来实现：`%.2f`。这将指定两位小数，第二位将被四舍五入。根据以下示例，请注意第
    *n* 个数字是如何四舍五入到由 `%.nf` 动词中使用的数字 (n) 指定的：
- en: '![Figure 11.4: Rounding off decimals](img/B18621_11_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：四舍五入小数](img/B18621_11_04.jpg)'
- en: 'Figure 11.4: Rounding off decimals'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：四舍五入小数
- en: You can also specify the overall width of a number. The width of a number refers
    to the total characters of the number you are formatting, including the decimal
    point. You can specify the width of the number you are formatting by putting a
    number before the decimal point. `%10.0f` states the format will be a total width
    of 10; this includes the decimal point. It will pad with spaces if the width is
    less than what is being formatted, and it will be right aligned.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以指定一个数字的整体宽度。一个数字的宽度指的是您正在格式化的数字的总字符数，包括小数点。您可以通过在数字前放置一个数字来指定您正在格式化的数字的宽度。`%10.0f`
    表示格式将具有总共 10 个字符的宽度；这包括小数点。如果宽度小于格式化的宽度，它将用空格填充，并且它将右对齐。
- en: 'Let’s look at an example of formatting various numbers using the width and
    `%.f` verb together:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用宽度和 `%.f` 动词一起格式化各种数字的例子：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s understand this code in detail:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细理解这段代码：
- en: 'In the `main()` function, we declared variables with different decimal places:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们声明了具有不同小数位的变量：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`%10.0f` states that the total width is ten with a precision of zero:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.0f` 表示总宽度为十，精度为零：'
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`%10.1f` states that the total width is ten with a precision of one:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.1f` 表示总宽度为十，精度为一位：'
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`%10.2f` states that the total width is ten with a precision of two:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.2f` 表示总宽度为十，精度为两位：'
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`%10.3f` states that the total width is ten with a precision of three:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.3f` 表示总宽度为十，精度为三位：'
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`%10.4f` states that the total width is ten with a precision of four:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.4f` 表示总宽度为十，精度为四位：'
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`%10.5f` states that the total width is ten with a precision of five:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.5f` 表示总宽度为十，精度为五位：'
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 11.5: Output after formatting verbs](img/B18621_11_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：格式化动词后的输出](img/B18621_11_05.jpg)'
- en: 'Figure 11.5: Output after formatting verbs'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：格式化动词后的输出
- en: 'To make the results left align your fields, you can use the `–` flag after
    the `%` symbol as follows:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使字段左对齐，您可以在 `%` 符号后使用 `–` 标志，如下所示：
- en: '[PRE25]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the same variables as before, the results would be as follows:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用之前相同的变量，结果如下：
- en: '![Figure 11.6: Output after left aligning the formatted verbs](img/B18621_11_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：格式化动词后左对齐的输出](img/B18621_11_06.jpg)'
- en: 'Figure 11.6: Output after left aligning the formatted verbs'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：格式化动词后左对齐的输出
- en: We have just skimmed the surface of Go’s support for using verbs. You should,
    by now, have a fundamental understanding of how verbs work. We will continue to
    build on using verbs and the various ways to format `print` in the upcoming topics.
    This topic laid the groundwork for the techniques that we will be using to do
    basic debugging.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚只是触及了Go对动词支持的表面。到现在为止，你应该已经对动词的工作原理有了基本的理解。我们将在接下来的主题中继续探讨使用动词和格式化`print`的多种方式。这个主题为我们将要使用的基本调试技术奠定了基础。
- en: Exercise 11.02 – Printing decimal, binary, and hex values
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02 – 打印十进制、二进制和十六进制值
- en: 'In this exercise, we will be printing decimal, binary, and hex values from
    1 to 255\. The results should be right aligned. The decimal width should be set
    to 3, the binary or base 2 width set to 8, and the hex width set to 2\. The aim
    of this exercise is to properly format the output of our data by using a Go standard
    library package:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从1到255打印十进制、二进制和十六进制值。结果应右对齐。十进制宽度应设置为3，二进制或基2宽度设置为8，十六进制宽度设置为2。这个练习的目的是通过使用Go标准库包来正确格式化我们的数据输出：
- en: Create a directory called `Exercise11.02` inside the `Chapter11` directory.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter11`目录内创建一个名为`Exercise11.02`的目录。
- en: Create a file called `main.go` inside the `Chapter11/Exercise11.02/` directory.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter11/Exercise11.02/`目录内创建一个名为`main.go`的文件。
- en: Open the `main.go` file.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.go`文件。
- en: 'Import the following packages:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a `main()` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`main()`函数：
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `main()` function, use a `for` loop that will loop up to 255 times:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，使用一个循环，该循环将循环255次：
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we want to print the variable in three different ways, formatted to the
    following specifications:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要以以下格式打印变量：
- en: Display `i` as a decimal value with a width of 3 and right aligned.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以3位宽度和右对齐的方式显示`i`的十进制值。
- en: Display `i` as a base 2 value with a width of 8 and right aligned.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以8位宽度和右对齐的方式显示`i`的基2值。
- en: Display `i` as a hex value with a width of 2 and right aligned.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以2位宽度和右对齐的方式显示`i`的十六进制值。
- en: 'This code should be placed inside of the `for` loop:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码应放置在`for`循环内部：
- en: '[PRE29]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the command line, change the directory using the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，使用以下代码更改目录：
- en: '[PRE30]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the command line, type the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE31]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Type the executable that was created from the `go build` command and hit *Enter*.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入由`go build`命令创建的可执行文件并按*Enter*键。
- en: 'Here are the expected results of the program:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的预期结果：
- en: '![Figure 11.7: Expected output after printing the decimal, binary, and hex
    values](img/B18621_11_07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：打印十进制、二进制和十六进制值后的预期输出](img/B18621_11_07.jpg)'
- en: 'Figure 11.7: Expected output after printing the decimal, binary, and hex values'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：打印十进制、二进制和十六进制值后的预期输出
- en: We have seen how to format our data using the `Printf()` function from the Go
    standard library `fmt` package. We will use this knowledge to perform some basic
    debugging of printing code markers in our programs. We will learn more about this
    in the following section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用Go标准库`fmt`包中的`Printf()`函数来格式化我们的数据。我们将利用这一知识来对我们程序中的打印代码标记进行一些基本的调试。我们将在下一节中了解更多关于这方面的内容。
- en: Basic debugging
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本调试
- en: 'We have been happily coding along. The big moment has arrived; it is time to
    run our program. We run our program and find the results are not as we expected
    them to be. In fact, something is grossly wrong. Our inputs and outputs are not
    matching up. So, how do we figure out what went wrong? Well, having bugs appear
    in our programs is something that we all face as developers. However, there is
    some basic debugging that we can perform to aid us in remediating or, at the very
    least, gathering information about these bugs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直快乐地编写代码。重大时刻已经到来；现在是时候运行我们的程序了。我们运行程序，发现结果并不像我们预期的那样。事实上，有些地方出现了严重错误。我们的输入和输出不匹配。那么，我们如何找出哪里出了问题呢？嗯，程序中出现错误是我们作为开发者都会面临的问题。然而，我们可以进行一些基本的调试来帮助我们修复这些问题，或者至少收集有关这些错误的信息：
- en: '`print` statements that help us to identify where we are in the program when
    the bug occurred:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`语句帮助我们识别在出现错误时我们在程序中的位置：'
- en: '[PRE32]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Printing out the type of** **the variable**:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印变量类型**：'
- en: 'While debugging, it might be useful to know the variable type that we are evaluating:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调试过程中，了解我们正在评估的变量类型可能很有用：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Printing out the value of** **the variable**:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印变量的值**：'
- en: 'Along with knowing the type of the variable, it is sometimes valuable to know
    the value that is stored in the variable:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了知道变量的类型外，有时了解变量中存储的值也很有价值：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`debug` statements to a file: maybe there is an error that only occurs in a
    production environment, or perhaps we would like to compare the results of data
    printed in a file for different inputs to our code. This log-formatted message
    adjusting the message from the standard logger can help in this case:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `debug` 语句输出到文件：可能存在仅在生产环境中发生的错误，或者我们可能想比较代码不同输入下打印到文件中的数据结果。在这种情况下，调整来自标准日志记录器的消息的日志格式化消息可能会有所帮助：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Formatting directives such as `%T` and `%#v` will be discussed a bit more later
    in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面将更详细地讨论如 `%T` 和 `%#v` 这样的格式化指令。
- en: 'Here are some basic debugging methods:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基本的调试方法：
- en: '![Figure 11.8: Basic debugging methods](img/B18621_11_08.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：基本的调试方法](img/B18621_11_08.jpg)'
- en: 'Figure 11.8: Basic debugging methods'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：基本的调试方法
- en: One of the first steps in debugging is to identify the general location of where
    the bug is in the code. Before you can start to analyze any data, we need to know
    where this bug is occurring. We do this by printing out markers in our code. Markers
    in our code are typically nothing more than `print` statements that help us to
    identify where we were in the program when the bug occurred. They are also used
    to narrow the scope of the location of the bug. Generally, this process involves
    placing a `print` statement with a message that shows us where we are in the code.
    If our code reaches that point, we can then determine, based on some conditions,
    whether that area is where the bug is. If we find that it is not, we potentially
    remove that `print` statement and place it in other spots in the code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的第一步之一是确定代码中错误的总体位置。在开始分析任何数据之前，我们需要知道这个错误发生在哪里。我们通过在代码中打印标记来实现这一点。代码中的标记通常只是帮助我们识别错误发生时程序位置的
    `print` 语句。它们也用于缩小错误位置的搜索范围。通常，这个过程涉及放置一个带有显示我们代码位置的信息的 `print` 语句。如果我们的代码达到那个点，我们就可以根据某些条件确定该区域是否是错误所在。如果我们发现它不是，我们可能会移除那个
    `print` 语句并将其放置在代码的其他位置。
- en: 'Given the following trivial example, here is a bug that returns some output:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下简单的示例，这里有一个返回一些输出的错误：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code is reporting an error, but we do not know where the error is coming
    from. This code generates a random number, and that random number is passed to
    `func a` and `func b`. The value of the random number will depend on which function
    the error occurs in. The following code demonstrates the importance of having
    properly placed `debug` statements to help determine the area of code where a
    potential bug is located:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码报告了一个错误，但我们不知道错误是从哪里来的。这个代码生成一个随机数，这个随机数被传递给 `func a` 和 `func b`。随机数的值将取决于错误发生在哪个函数中。以下代码演示了正确放置
    `debug` 语句以帮助确定潜在错误所在代码区域的重要性：
- en: main.go
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter11/Example01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter11/Example01/main.go).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter11/Example01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter11/Example01/main.go)找到。
- en: We are using the `rand` package to generate a random number.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用 `rand` 包来生成一个随机数。
- en: '`rand.Seed()` is used so that each time you run the program with `rand.Intn`,
    it lowers the possibility of returning the same number. `rand.Seed()` is deprecated
    as of Go 1.20 as there is no reason to call `Seed` with a random value. Programs
    that call `Seed` with a known value to get a specific sequence of results should
    use `New(NewSource(seed))` to obtain a local random value in future versions of
    Go. However, if you use the same seed each time, the random number generator will
    return the same number the first time you run the code. To minimize the probability
    of the same number being generated, we need to provide the seed function with
    a unique number each time. We use `time.Now().UTC.UnixNano()` to help our program
    get a more random number. It should be noted, though, that if you put this in
    a loop, the loop could iterate at a speed that `time.Now().UTC.UnixNano()` could
    generate the same time value. However, for our program, this is not as likely;
    rather, it is just something to consider in future code.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand.Seed()` 用于确保每次运行程序时使用 `rand.Intn`，它降低了返回相同数字的可能性。自 Go 1.20 版本起，`rand.Seed()`
    已被弃用，因为没有理由使用随机值调用 `Seed`。应该使用 `New(NewSource(seed))` 来获取本地随机值，以获取未来版本中调用 `Seed`
    并使用已知值以获取特定结果序列的程序。然而，如果您每次都使用相同的种子，随机数生成器将在第一次运行代码时返回相同的数字。为了最大限度地减少生成相同数字的概率，我们需要每次都向种子函数提供一个唯一的数字。我们使用
    `time.Now().UTC.UnixNano()` 来帮助我们的程序获得更随机的数字。不过，需要注意的是，如果您将其放入循环中，循环的迭代速度可能会使
    `time.Now().UTC.UnixNano()` 生成相同的时间值。然而，对于我们的程序来说，这种情况不太可能；这只是一个在未来的代码中需要考虑的因素。'
- en: '`rand.Intn((max-min)+1)+min` is starting to generate a random number between
    two other numbers. In our program, it is 1 and 20:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand.Intn((max-min)+1)+min` 开始生成两个其他数字之间的随机数。在我们的程序中，它是 1 和 20：'
- en: '[PRE38]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding two functions evaluate `i` to see whether it falls within a given
    range. If the value that falls within that range returns an error, it also prints
    a `debug` statement to let us know where the error occurred.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的两个函数评估 `i` 以查看它是否在给定的范围内。如果该范围内的值返回错误，它也会打印一个 `debug` 语句，让我们知道错误发生的位置。
- en: By strategically placing `print` statements in our code, we can see which function
    an error is in.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码中战略性地放置 `print` 语句，我们可以看到错误发生在哪个函数中。
- en: 'The output should look something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This section covered debugging basics. We were introduced to using `print` statements
    for debugging. In the next topic, we will build on our knowledge of printing and
    look at how to print the variable type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了调试基础知识。我们介绍了使用 `print` 语句进行调试。在下一个主题中，我们将基于打印的知识，探讨如何打印变量类型。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the randomness of the value of `r`, it can be different, which will impact
    the results of the program to be either `func a` or `func b`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `r` 的值具有随机性，它可能不同，这将影响程序的结果，可能是 `func a` 或 `func b`。
- en: Additionally, if you run the preceding program in the Go playground, it will
    give you the same result every time. This is due to the fact that the playground
    caches, so it does not adhere to the randomness of the answer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您在 Go playground 中运行前面的程序，它将每次都给出相同的结果。这是由于 playground 缓存的原因，所以它不遵循答案的随机性。
- en: Printing Go variable types
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印 Go 变量类型
- en: 'It is often useful to know the type of a variable when debugging. Go provides
    this functionality through the use of a `%T` verb. Go is case-sensitive. A capital
    `%T` means the type of the variable, and a lowercase `%t` means the `bool` type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时了解变量的类型通常很有用。Go 通过使用 `%T` 动词提供了这种功能。Go 是区分大小写的。大写的 `%T` 表示变量的类型，而小写的 `%t`
    表示 `bool` 类型：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here are the results of the preceding code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码片段的结果：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `%T` verb is used in each `print` statement to print the concrete type
    of the variable. In a previous topic, we printed out values. We can also print
    out a Go syntax representation of the type using `%#v`. It is useful to be able
    to print out the Go representation of a variable. The Go representation of a variable
    is the syntax that can be copied and pasted into the Go code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 `print` 语句中使用 `%T` 动词来打印变量的具体类型。在先前的主题中，我们打印了值。我们还可以使用 `%#v` 打印出类型的 Go 语法表示。能够打印出变量的
    Go 表示非常有用。变量的 Go 表示是可以在 Go 代码中复制粘贴的语法：
- en: '![Figure 11.9: Syntax representation of the type using %T and the Go syntax
    representation, %#v](img/B18621_11_09.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9：使用 %T 和 Go 语法表示法的类型语法表示](img/B18621_11_09.jpg)'
- en: 'Figure 11.9: Syntax representation of the type using %T and the Go syntax representation,
    %#v'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9：使用 %T 和 Go 语法表示的类型语法表示
- en: Exercise 11.03 – Printing the Go representation of a variable
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.03 – 打印 Go 变量的表示
- en: 'In this exercise, we will create a simple program that will demonstrate how
    to print out the Go representation of various variables. We will use various types
    (such as a string, slice, map, and a struct) and print the Go representations
    of those types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的程序，演示如何打印出各种变量的 Go 表示。我们将使用各种类型（如字符串、切片、映射和结构体）并打印这些类型的 Go
    表示：
- en: Create a directory called `Exercise11.03` inside the `Chapter11` directory.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter11` 目录下创建一个名为 `Exercise11.03` 的目录。
- en: Create a file called `main.go` inside the `Chapter11/Exercise11.03/` directory.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter11/Exercise11.03/` 目录下创建一个名为 `main.go` 的文件。
- en: Open the `main.go` file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.go` 文件。
- en: 'Add the following code to `main.go`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main.go` 中：
- en: '[PRE42]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, create a `person` struct with the same fields listed as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接下来，创建一个具有以下字段的 `person` 结构体:'
- en: '[PRE43]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Inside the `main` function, assign a value to the `fname` variable:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，将值赋给 `fname` 变量：
- en: '[PRE44]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a `slice` literal and assign it to a `grades` variable:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `slice` 字面量并将其赋值给名为 `grades` 的变量：
- en: '[PRE45]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a `map` literal of a key string and a value string and assign it to
    a variable of states. This is a map of state abbreviations and their respective
    names:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个键为字符串、值为字符串的 `map` 字面量并将其赋值给名为 `states` 的变量。这是一个州缩写及其相应名称的映射：
- en: '[PRE46]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a `person` literal and assign it to `p`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个名为 `person` 的字面量并将其赋值给 `p`:'
- en: '[PRE47]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we will be printing out the Go representation of each of our variables
    using `%#v`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `%#v` 打印出我们每个变量的 Go 表示：
- en: '[PRE48]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At the command line, change the directory using the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，使用以下代码更改目录：
- en: '[PRE49]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'At the command line, type the following:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE50]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Type the executable that was created from the `go build` command and hit *Enter*:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入由 `go build` 命令创建的可执行文件并按 *Enter* 键：
- en: '[PRE51]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You will get the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![Figure 11.10: Go representation of the types](img/B18621_11_10.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10：Go 类型表示](img/B18621_11_10.jpg)'
- en: 'Figure 11.10: Go representation of the types'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：Go 类型表示
- en: In this exercise, we saw how we can print the Go representation of simple types
    (the `fname` string) to more complex types such as a `person` struct. This is
    another tool in our toolbox that we can use for debugging; it allows us to see
    the data the way Go sees it. In the next topic, we will be looking at another
    tool to help us debug our code. We will be looking at how we log information that
    can be used to further aid in debugging.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何打印简单类型（如 `fname` 字符串）的 Go 表示，以及更复杂的类型，如 `person` 结构体。这是我们工具箱中的另一个工具，我们可以用它来调试；它允许我们以
    Go 的方式查看数据。在下一个主题中，我们将探讨另一个帮助我们调试代码的工具。我们将探讨如何记录信息，这些信息可以进一步帮助我们调试。
- en: Logging
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录
- en: Logging can be used to help debug a bug in our program. Operating systems log
    various information such as access to resources, what an application is doing,
    the overall health of the system, and much more. It is not doing this because
    there is an error; rather, it is logging to make it easier for the system administrator
    to determine what is going on with the operating system at various times. It allows
    for easier debugging when the operating system acts in an unusual way or performs
    a certain task that was not expected. This is the same attitude we should take
    when logging our application. We need to think about the information that we gather
    and how that would help us to debug the application if something is not performing
    the way we think it should.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可以帮助我们调试程序中的错误。操作系统记录各种信息，例如对资源的访问、应用程序正在做什么、系统的整体健康状况等等。这不是因为存在错误；相反，它是为了记录，以便系统管理员更容易确定在各个时间点操作系统发生了什么。当操作系统以异常方式运行或执行某些未预期的任务时，它允许更容易地进行调试。我们在记录应用程序时应该采取同样的态度。我们需要考虑我们收集的信息以及这些信息如何帮助我们调试应用程序，如果某些操作没有按预期执行的话。
- en: We should be performing logging regardless of whether the program needs debugging.
    Logging is useful for understanding events that happen, the health of the application,
    any potential issues, and who is accessing our application or data. Logging is
    an infrastructure to your program that can be utilized when an abnormality occurs
    in the application. Logging helps us to track abnormalities that we would otherwise
    miss. In production, our code could be executed in different conditions compared
    to a development environment, such as an increase in the number of requests to
    the server.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该进行日志记录，无论程序是否需要调试。日志记录对于理解发生的事件、应用程序的健康状况、任何潜在问题以及谁访问我们的应用程序或数据都很有用。日志记录是程序的基础设施，当应用程序出现异常时可以加以利用。日志记录帮助我们跟踪我们可能错过的异常。在生产中，我们的代码可能在不同条件下执行，与开发环境相比，例如服务器请求数量的增加。
- en: If we do not have the ability to log this information and how our code performs,
    we could spend endless hours trying to figure out why our code behaves the way
    it does in production but not in development environments. Another example would
    be that we get some malformed data as a request in production, and our code does
    not handle the format properly and causes undesired behavior. Without proper logging,
    it could take an extraordinary amount of time to determine that we received data
    that we were not adequately handling.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有记录这些信息以及我们的代码性能的能力，我们可能会花费无数小时试图弄清楚为什么我们的代码在生产环境中表现的方式与开发环境不同。另一个例子是我们可能在生产中接收到一些格式不正确的请求数据，我们的代码没有正确处理格式，导致不期望的行为。没有适当的日志记录，可能需要非常多的时间来确定我们收到了我们没有适当处理的数据。
- en: The Go standard library provides a package called `log`. It includes basic logging
    that can be used by our programs. We will investigate how the package can be used
    to log various information.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了一个名为 `log` 的包。它包括基本日志记录，可以被我们的程序使用。我们将研究如何使用该包来记录各种信息。
- en: 'Consider the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Println()`, `Printf()`, and `Print()` log functions perform the same functionality
    as their `fmt` counterparts, with one exception. When the log functions execute,
    it gives additional details such as the date and time of the execution, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Println()`、`Printf()` 和 `Print()` 日志函数与它们的 `fmt` 对应函数执行相同的功能，但有一个例外。当日志函数执行时，它会提供额外的详细信息，例如执行的时间和日期，如下所示：'
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This information can be useful when investigating and reviewing the logs later
    and for understanding the order of events. We can even get more details to be
    logged by our logger. The Go `log` package has a `SetFlags` function that allows
    us to be more specific.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在以后调查和审查日志以及理解事件顺序时，这些信息可能很有用。我们甚至可以让我们的日志记录器记录更多详细信息。Go 的 `log` 包提供了一个 `SetFlags`
    函数，允许我们更加具体。
- en: 'Here is a list of options for logging provided by the Go package that we can
    set in the function ([https://go.dev/src/log/log.go?s=8483:8506#L28](https://go.dev/src/log/log.go?s=8483:8506#L28)):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Go 包提供的日志选项列表，我们可以在函数中设置它们（[https://go.dev/src/log/log.go?s=8483:8506#L28](https://go.dev/src/log/log.go?s=8483:8506#L28)）：
- en: '![Figure 11.11: List of flags in Go](img/B18621_11_11.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11：Go 中的标志列表](img/B18621_11_11.jpg)'
- en: 'Figure 11.11: List of flags in Go'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：Go 中的标志列表
- en: Let’s set some of the flags in *Figure 11**.11* and observe the difference in
    behavior from what we had before.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *图 11.11* 中设置一些标志并观察与之前行为的不同。
- en: 'Consider the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s break down the code to understand it better:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解它：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`log.Ldate` is the date of the local time zone. This is the same information
    that was logged before.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`log.Ldate` 是本地时区的日期。这是之前记录的信息。'
- en: '`log.Lmicroseconds` will give the microseconds of the formatted date. Note
    that we have not discussed time yet; for further details on time, please refer
    to [*Chapter 12*](B18621_12.xhtml#_idTextAnchor1532), *About Time*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`log.Lmicroseconds` 将提供格式化日期的微秒数。请注意，我们尚未讨论时间；有关时间的更多详细信息，请参阅[*第 12 章*](B18621_12.xhtml#_idTextAnchor1532)，*关于时间*。'
- en: '`log.LlongFile` will give us the full filename and line number that the log
    comes from.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`log.LlongFile` 将提供日志来源的完整文件名和行号。'
- en: 'The output is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 11.12: Output](img/B18621_11_12.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12：输出](img/B18621_11_12.jpg)'
- en: 'Figure 11.12: Output'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：输出
- en: Logging fatal errors
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录致命错误
- en: 'Using the `log` package, we can also log fatal errors. The `Fatal()`, `Fatalf()`,
    and `Fatalln()` functions are similar to `Print()`, `Printf()`, and `Println()`.
    The difference is after logging, `Fatal()` functions are followed by an `os.Exit(1)`
    system call. The `log` package also has the following functions: `Panic`, `Panicf`,
    and `Panicln`. The difference between the `Panic` functions and the `Fatal` functions
    is that the `Panic` functions are recoverable. When using the `Panic` functions,
    you can use the `defer()` function, whereas when using the `Fatal` functions,
    you cannot. As stated earlier, the `Fatal` functions call `os.Exit()`; a `defer`
    function will not be called when `os.Exit()` gets called. There may be some instances
    where you want to abort the program immediately with no possibility of recovery.
    For example, the application may have gotten to a state where it is best to exit
    it before data corruption or undesired behavior results. Or, you may have developed
    a command-line utility that is used by others and you need to provide an exit
    code to the callers of your executable to signal it has completed its tasks.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`log`包，我们还可以记录致命错误。`Fatal()`、`Fatalf()`和`Fatalln()`函数与`Print()`、`Printf()`和`Println()`类似。区别在于记录后，`Fatal()`函数后面跟着一个`os.Exit(1)`系统调用。`log`包还有以下函数：`Panic`、`Panicf`和`Panicln`。`Panic`函数和`Fatal`函数之间的区别在于`Panic`函数是可恢复的。当使用`Panic`函数时，你可以使用`defer()`函数，而当使用`Fatal`函数时，则不能。如前所述，`Fatal`函数调用`os.Exit()`；当调用`os.Exit()`时，`defer`函数将不会被调用。可能有一些情况下，你可能希望立即终止程序而没有恢复的可能性。例如，应用程序可能已经到达了一个最佳退出状态，以防止数据损坏或产生不期望的行为。或者，你可能开发了一个由他人使用的命令行工具，你需要向你的可执行文件的调用者提供一个退出代码，以表示它已经完成了其任务。
- en: 'In the following code example, we will look at how `log.Fataln` is used:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将查看如何使用`log.Fataln`：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s break down the code to understand it better:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解它：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The statement prints to `stdout` with the date, time, and line number of the
    log message:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句将日期、时间和日志消息的行号打印到`stdout`：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We create an error to test the logging of `Fatal()` errors:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个错误来测试`Fatal()`错误的记录：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We log the error, and then it exits the program:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录错误，然后程序退出：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The line did not execute because we logged the error as `fatal`, and that caused
    the program to exit.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码没有执行，因为我们记录了错误为`fatal`，这导致程序退出。
- en: 'Here are the results. Notice that even though it was an error, it still logs
    the same details about the error as it does the print functionality, and then
    it exits:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果。请注意，尽管这是一个错误，但它仍然记录了与打印功能相同的错误详细信息，然后退出：
- en: '![Figure 11.13: Logging a fatal error](img/B18621_11_13.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13：记录致命错误](img/B18621_11_13.jpg)'
- en: 'Figure 11.13: Logging a fatal error'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：记录致命错误
- en: Activity 11.01 – Building a program to validate Social Security Numbers
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.01 – 编写一个验证社会保障号码的程序
- en: 'In this activity, we are going to be validating **Social Security Numbers**
    (**SSNs**). Our program will be accepting SSNs without the dashes. We will want
    to log the validation process for the SSNs so that we can trace the entire process.
    Logging real SSNs in production applications is not a recommended practice as
    it includes sensitive information and would violate security measures; however,
    it is useful for a fun book activity. We do not want our application to stop if
    an SSN is invalid; we want it to log the invalid number and continue to the next
    one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将验证**社会保障号码**（**SSNs**）。我们的程序将接受不带连字符的SSNs。我们希望记录SSN的验证过程，以便我们可以追踪整个过程。在生产应用程序中记录真实的SSNs不是一个推荐的做法，因为它包含敏感信息，并且会违反安全措施；然而，这对于一个有趣的活动是有用的。我们不希望我们的应用程序在SSN无效时停止；我们希望它记录无效的数字并继续到下一个：
- en: Create a custom error called `ErrInvalidSSNLength` for invalid SSN length.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为无效的SSN长度创建一个名为`ErrInvalidSSNLength`的自定义错误。
- en: Create a custom error called `ErrInvalidSSNNumbers` for SSNs that have non-numeric
    digits.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为具有非数字数字的SSN创建一个名为`ErrInvalidSSNNumbers`的自定义错误。
- en: Create a custom error called `ErrInvalidSSNPrefix` for an SSN that has three
    zeros as the prefix.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以三个零为前缀的SSN创建一个名为`ErrInvalidSSNPrefix`的自定义错误。
- en: Create a custom error called `ErrInvalidDigitPlace` for SSNs that start with
    a 9 if it requires 7 or 9 in the fourth place.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果SSN以9开头且第四位需要7或9，则创建一个名为`ErrInvalidDigitPlace`的自定义错误。
- en: Create a function that returns an error if the SSN length is not 9.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，如果SSN长度不是9，则返回错误。
- en: Create a function that checks whether the SSN is a length of 9\. The function
    returns an error that has the SSN that was invalid and a custom error, `ErrInvalidSSNLength`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于检查SSN的长度是否为9。该函数返回一个错误，其中包含无效的SSN和自定义错误`ErrInvalidSSNLength`。
- en: Create a function that checks whether the SSN contains all numbers. The function
    returns an error that has the SSN that was invalid and a custom error, `ErrInvalidSSNNumbers`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于检查SSN是否全部由数字组成。该函数返回一个错误，其中包含无效的SSN和自定义错误`ErrInvalidSSNNumbers`。
- en: Create a function that checks whether the SSN does not have a prefix of 000\.
    The function returns an error that has the SSN that was invalid and a custom error,
    `ErrInvalidSSNPrefix`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于检查SSN是否没有以000为前缀。该函数返回一个错误，其中包含无效的SSN和自定义错误`ErrInvalidSSNPrefix`。
- en: Create a function that checks that if the SSN starts with a 9, then it requires
    a 7 or 9 in the fourth place. The function returns an error that has the SSN that
    was invalid and a custom error, `ErrInvalidDigitPlace`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于检查如果SSN以9开头，那么第四位需要是7或9。该函数返回一个错误，其中包含无效的SSN和自定义错误`ErrInvalidDigitPlace`。
- en: In the `main()` function, create a slice of SSNs so that your program will validate
    each of them.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，创建一个SSN切片，以便你的程序可以验证每个SSN。
- en: For each SSN that you are validating, if errors are returned from your functions
    that are being used to validate, then log those errors and continue processing
    the slice.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于你正在验证的每个SSN，如果从用于验证的函数返回错误，则记录这些错误并继续处理切片。
- en: 'An example slice to validate is as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面是一个用于验证的示例切片：
- en: '[PRE61]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding slice should have the following output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的切片应该有以下输出：
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11/Activity11.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11/Activity11.01).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在本章节的GitHub仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11/Activity11.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11/Activity11.01)。
- en: In this activity, we used the `log` package to capture information to trace
    the process of validating an SSN. If we ever need to debug the validation process
    for our SSN, then we can look at the logging messages and follow the validation
    failures of the SSN. We also demonstrated how to format logging messages to contain
    information that would be needed for debugging.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们使用了`log`包来捕获信息以跟踪验证SSN的过程。如果我们需要调试我们的SSN验证过程，那么我们可以查看日志消息并跟踪SSN的验证失败。我们还演示了如何格式化日志消息以包含调试所需的信息。
- en: Debugging in live or restricted environments
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实时或受限环境中进行调试
- en: Debugging is an indispensable skill in software development, especially when
    dealing with elusive bugs that only manifest in certain environments. In real-world
    scenarios, modifying code on the fly might not be feasible, making it crucial
    to master techniques that work seamlessly in live or restricted environments.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是软件开发中不可或缺的技能，尤其是在处理只在特定环境中出现的难以捉摸的bug时。在现实场景中，即时修改代码可能不可行，因此掌握在实时或受限环境中无缝工作的技术至关重要。
- en: 'To best debug in those kinds of environments, you should consider the following
    points:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些环境中进行最佳调试时，你应该考虑以下要点：
- en: '**Understand the environment**: Before diving into debugging, take a step back.
    Understand the deployment setup, network configurations, and any security constraints.
    This information helps to anticipate potential issues and streamline debugging.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解环境**：在深入调试之前，先退一步。了解部署设置、网络配置以及任何安全限制。这些信息有助于预测潜在问题并简化调试过程。'
- en: '**Remote debugging with proper tools**: Delve is a powerful debugger for Go
    that supports remote debugging. By using Delve, you can connect to a running Go
    process and inspect variables, set breakpoints, and step through code. This is
    an invaluable debugging tool.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用适当工具进行远程调试**：Delve是Go的一个强大调试器，支持远程调试。通过使用Delve，你可以连接到正在运行的Go进程，检查变量、设置断点和逐步执行代码。这是一个非常有价值的调试工具。'
- en: '`pprof`, allow you to gather runtime statistics and profile your application’s
    performance. By exposing a profiling endpoint in your code, you can collect data
    from live systems without modifying the code after it’s deployed. The same can
    be said if you add metrics and additional observability to your application. There
    are also tools available to capture application logs and aggregate them to be
    searchable in the future. This provides additional context that can assist the
    debugging process.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pprof` 允许你收集运行时统计信息和分析应用程序的性能。通过在代码中公开一个分析端点，你可以在代码部署后不修改代码的情况下从实时系统中收集数据。如果你向应用程序添加指标和额外的可观察性，也是如此。还有可用的工具可以捕获应用程序日志并将它们聚合起来以便将来可搜索。这提供了额外的上下文，可以帮助调试过程。'
- en: '**Utilize log levels**: Utilizing the different log levels available in the
    language is useful in different environments. However, you should be cautious
    to not over-share information via logging – especially in the event of dealing
    with private data.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用日志级别**：利用语言中可用的不同日志级别在不同的环境中很有用。然而，你应该小心不要通过日志过度共享信息——尤其是在处理私人数据时。'
- en: '**Set up integrated development environment (IDE) debuggers**: Modern IDEs
    such as Visual Studio Code or JetBrains GoLand provide robust debugging capabilities.
    You can use breakpoints, watch expressions, and walk-through code using your debugger
    in the IDE. This is extremely efficient in pinpointing problems but is not something
    you can do in every deployment environment.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置集成开发环境（IDE）调试器**：现代IDE，如Visual Studio Code或JetBrains GoLand，提供了强大的调试功能。你可以在IDE中使用调试器设置断点、监视表达式和逐步执行代码。这在定位问题方面非常高效，但并不是每个部署环境都能做到。'
- en: '**Feature flags and canary releases**: Leveraging feature flags and/or canary
    releases enables you to selectively enable or disable specific functionalities
    in production. By gradually rolling out changes, you can observe the impact on
    a subset of users. This makes it easier to identify and address issues before
    a widespread release.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性标志和金丝雀发布**：利用特性标志和/或金丝雀发布可以使你选择性地在生产环境中启用或禁用特定的功能。通过逐步推出更改，你可以观察对用户子集的影响。这使得在广泛发布之前更容易识别和解决问题。'
- en: Overall, it’s important to note that debugging can be an art. What works in
    some environments may not work in others. For example, you cannot set up an IDE
    debugger on code already running in a production environment, but you can leverage
    this approach easily in developing your code. You may also only have issues that
    plague certain environments. This is the classic tale of “it works locally for
    me,” but you are plagued with dealing with the issue and could end up spending
    several hours/days testing code commits by committing against your **continuous
    integration** (**CI**) environment. It happens to the best of us and is also a
    fair approach to debugging, trying out changes in small increments until it’s
    fixed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，需要注意的是调试可能是一门艺术。在某些环境中有效的方法可能在其他环境中不起作用。例如，你无法在生产环境中设置已经运行的代码的IDE调试器，但你可以在开发代码时轻松地利用这种方法。你也可能只遇到困扰某些环境的特定问题。这就是“它在我的本地运行正常”的经典故事，但你可能被这个问题困扰，最终可能花费几个小时/几天的时间通过**持续集成（CI**）环境提交代码来测试代码提交。这种情况可能发生在我们所有人身上，这也是一种合理的调试方法，通过小幅度尝试更改直到问题解决。
- en: At the end of the day, knowledge is power, and knowing the tools available to
    best debug an issue can drastically reduce your debugging time. In addition, practicing
    debugging in different environments and forcing issues/incidents sometimes upon
    a team in planned scenarios can be a great way to prepare teams for production-level
    incidents where speed is key.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，知识就是力量，了解最佳调试问题的工具可以大大减少你的调试时间。此外，在不同环境中练习调试，并在计划场景中强制团队处理问题/事件，可以是一种为生产级别事件做准备的好方法，在这些事件中速度是关键。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied various methodologies for easing the debugging process
    such as coding incrementally and testing the code often, writing unit tests, handling
    all errors, and performing logging on the code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了各种简化调试过程的方法，例如逐步编码和频繁测试代码、编写单元测试、处理所有错误以及在代码上执行日志记录。
- en: Looking at the `fmt` package, we discovered various ways to output information
    to help us to find bugs. The `fmt` package offered different print formatting,
    verbs, and ways to control the output of verbs by the use of various flags.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `fmt` 包，我们发现各种输出信息的方式，帮助我们找到错误。`fmt` 包提供了不同的打印格式化、动词以及通过使用各种标志来控制动词输出的方式。
- en: With the usage of logging from Go’s standard library, we were able to see details
    of how our application was executed. The `log` package allowed us to see the file
    path and line number on which the log event took place. The `log` package came
    with various print functions that mimic some of the `fmt` print functions, which
    provided us with various insights into the usage of the verbs we learned in this
    chapter. We were able to perform basic debugging by using the standard library
    that is provided by Go. We looked at the `log` package and were introduced to
    the `time` type. We did not go into the details of Go’s implementations of time.
    We also saw various additional methodologies to debug code in live or restricted
    environments.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 标准库中的日志功能，我们能够看到应用程序执行的详细信息。`log` 包使我们能够看到日志事件发生的文件路径和行号。`log` 包附带各种打印函数，这些函数模仿了
    `fmt` 打印函数的一些功能，这为我们提供了关于本章所学动词用法的各种见解。我们能够通过使用 Go 提供的标准库进行基本的调试。我们查看了 `log` 包，并介绍了
    `time` 类型。我们没有深入探讨 Go 对时间实现的细节。我们还看到了在实时或受限环境中调试代码的各种附加方法。
- en: In the next chapter, we will be looking at how time is represented in Go. We
    will be discussing the various functions used with the `time.Time` type. We will
    also demonstrate how to convert time to various time constructs (such as nanoseconds,
    microseconds, milliseconds, seconds, minutes, hours, and so on). Then, we will
    finally learn about the underlying type of time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Go 中时间的表示方式。我们将讨论与 `time.Time` 类型一起使用的各种函数。我们还将演示如何将时间转换为各种时间结构（如纳秒、微秒、毫秒、秒、分钟、小时等）。然后，我们将最终了解时间的基本类型。
