- en: '21'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '21'
- en: Go in the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云端Go
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will show you how to take your Go application to the next level
    of readiness for deployment. It will cover the considerations you have to make
    your Go application run reliably once deployed to your server or cloud infrastructure
    by demonstrating how to add monitoring capabilities to the system through an open
    source monitoring and alerting toolkit known as **Prometheus**. The chapter will
    also discuss how to run your application using an orchestrator and all of the
    benefits you get out of the box. Lastly, the chapter will cover insights that
    **OpenTelemetry** allows, as well as best practices for containerizing your Go
    application code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何将您的Go应用程序提升到部署准备就绪的下一个级别。它将涵盖您必须考虑的因素，以确保您的Go应用程序在部署到您的服务器或云基础设施后能够可靠地运行，通过演示如何通过一个名为**Prometheus**的开源监控和警报工具包向系统中添加监控能力来展示这一点。本章还将讨论如何使用编排器运行您的应用程序，以及您从中获得的所有即开即用的好处。最后，本章将涵盖**OpenTelemetry**允许的见解，以及容器化您的Go应用程序代码的最佳实践。
- en: By the end of this chapter, you will be empowered to deploy your Go application
    reliably, and with valuable insights into the system to ensure its success.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够可靠地部署您的Go应用程序，并凭借对系统的宝贵见解来确保其成功。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter21](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter21).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要Go版本1.21或更高版本。本章的代码可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter21](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter21)找到。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned about the various Go tools that enable
    developers to write better code and be more productive. We covered the Go tools
    to compile and run your Go code using the `go build` and `go run` commands. We
    then looked at how to format Go code using `gofmt`. We also saw the power of working
    with the Go ecosystem through its dependencies with the `goimports` and `go get`
    command-line tools. After having functional dependencies in our code, we can see
    issues that might be present using the `Go vet` tool and the `Go race` detector.
    Lastly, with any good code comes a well-rounded project through proper documentation
    using the `Go doc` tool. The previous chapter empowered you with the tools right
    at your fingertips in the Go ecosystem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了各种Go工具，这些工具使开发者能够编写更好的代码并提高生产力。我们介绍了使用`go build`和`go run`命令编译和运行Go代码的Go工具。然后我们探讨了如何使用`gofmt`格式化Go代码。我们还看到了通过`goimports`和`go
    get`命令行工具与Go生态系统依赖项一起工作的力量。在代码中有了功能依赖项之后，我们可以使用`Go vet`工具和`Go race`检测器看到可能存在的问题。最后，任何好的代码都伴随着通过`Go
    doc`工具进行适当的文档，从而形成一个全面的项目。上一章使您在Go生态系统中拥有了触手可及的工具。
- en: 'In this chapter, we focus on the fact that at some point in a project, your
    application development journey will lead you to the final frontier: deploying
    the application. But, before you hit the deploy button or run the final command,
    there are essential considerations to ensure your application runs reliably and
    efficiently in its destination environment.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们关注的是在项目的某个阶段，您的应用程序开发之旅将引导您进入最终领域：部署应用程序。但是，在您点击部署按钮或运行最终命令之前，有一些基本考虑因素是确保您的应用程序在其目标环境中可靠且高效运行的关键。
- en: Where your Go application will be deployed depends on numerous factors. This
    can be a stakeholder and leadership-led decision, based on existing infrastructure,
    or even based on the specifications of your project or customer base. No matter
    the destination, your Go code will be able to be packaged up and shipped to it.
    However, it is on you to ensure your project is ready for deployment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Go应用程序将部署在哪里取决于许多因素。这可能是由利益相关者和领导层主导的决定，基于现有基础设施，或者甚至基于您项目或客户群的规格。无论目的地如何，您的Go代码都将能够打包并运送到那里。然而，确保您的项目为部署做好准备的责任在于您自己。
- en: This chapter will teach you about running your application in the cloud successfully
    and some of the considerations you might make before deploying it into the cloud,
    or wherever you choose to deploy it to really. We will cover topics such as monitoring,
    orchestration, tracing, and containerization, equipping you with the knowledge
    and tools to navigate the complexities of cloud infrastructure effectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍在云中成功运行应用程序的方法，以及您在将其部署到云中或您选择的任何地方之前可能需要考虑的一些事项。我们将涵盖监控、编排、跟踪和容器化等主题，为您提供知识和工具，以有效地导航云基础设施的复杂性。
- en: First and foremost, we’ll discuss the importance of monitoring your application’s
    performance and health in a cloud-native environment. We’ll explore how to integrate
    monitoring systems such as Prometheus into your Go application, enabling you to
    gather vital metrics and gain insights into its ongoing behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论在云原生环境中监控应用程序性能和健康的重要性。我们将探讨如何将Prometheus等监控系统集成到您的Go应用程序中，使您能够收集关键指标并对其持续行为获得洞察。
- en: Next, we’ll delve into the realm of distributed tracing and logs with OpenTracing.
    By implementing tracing and logging into your Go application, you’ll gain visibility
    into the flow of requests and responses across microservices. This will provide
    you with additional insights to make debugging issues a breeze – hopefully – and
    provide you with insights to potentially make performance optimizations in the
    future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨使用OpenTracing的分布式跟踪和日志领域。通过将跟踪和日志集成到您的Go应用程序中，您将能够了解请求和响应在微服务之间的流动。这将为您提供额外的洞察，使调试问题变得轻而易举——希望如此——并为您提供洞察，以便未来可能进行性能优化。
- en: Finally, we’ll cover essential containerization practices for Go applications,
    including image optimization, dependency management, and security considerations.
    You’ll learn how to build robust container images for your Go application, ready
    for deployment in any environment. That will allow for a seamless transition to
    where we’ll tackle the challenge of orchestrating your application using platforms
    such as Kubernetes. Orchestrators allow for scalability, resiliency, and ease
    of management for your application at a greater scale.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍Go应用程序的基本容器化实践，包括镜像优化、依赖关系管理和安全考虑。您将学习如何构建健壮的容器镜像，以便在任何环境中部署。这将使我们能够无缝过渡到解决使用Kubernetes等平台编排应用程序的挑战。编排器允许您以更大的规模对应用程序进行可伸缩性、弹性和易于管理的操作。
- en: By the end of the chapter, you will be well equipped to deploy your Go application
    confidently to the cloud, armed with the knowledge and tools to ensure its reliability,
    scalability, performance, and visibility into production environments. Let’s dive
    in!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将准备好自信地将Go应用程序部署到云中，并拥有确保其可靠性、可伸缩性、性能以及在生产环境中的可见性的知识和工具。让我们开始吧！
- en: Making your app monitorable by systems such as Prometheus
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序可通过Prometheus等系统进行监控
- en: Monitoring is a critical aspect of maintaining the health and performance of
    any application, no matter the language. Monitoring is especially important in
    a cloud-native environment where resources are dynamic and distributed. There
    are certain nuances as to the differences between monitoring and observability
    in software engineering.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 监控是维护任何应用程序健康和性能的关键方面，无论使用何种语言。在资源动态且分布式的云原生环境中，监控尤为重要。在软件工程中，监控和可观察性之间有一些细微的差别。
- en: The monitoring aspects abide more by collecting data through predefined metrics
    and thresholds to detect and alert upon issues to define the overall health of
    the system, whereas observability is much more investigative and goes into a more
    comprehensive understanding of system behavior and performance to enable effective
    debugging and troubleshooting in complex environments. To focus on enabling monitoring
    capabilities and insights into the health of our application, we will focus on
    monitoring instead of observability in this book chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 监控方面更多地依赖于通过预定义的指标和阈值收集数据来检测和警报问题，以定义系统的整体健康状况，而可观察性则更加注重调查，并深入理解系统行为和性能，以便在复杂环境中进行有效的调试和故障排除。为了专注于启用监控能力和对我们应用程序健康状况的洞察，我们将在本书的这一章节中专注于监控而不是可观察性。
- en: Prometheus is a powerful tool when it comes to enabling monitoring capabilities
    on an application. It operates on a pull-based model, where it scrapes metrics
    from instrumented applications at regular intervals. These metrics are then stored
    in a time-series database, allowing developers to query, visualize, and alert
    them in real time. As a Go developer, integrating Prometheus into an application
    enables you to gain valuable insights into its performance and behavior.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在应用程序上启用监控功能时，Prometheus是一个强大的工具。它基于拉取模型运行，定期从配置了指标的应用程序中抓取指标。这些指标随后存储在时间序列数据库中，允许开发者在实时中查询、可视化和发出警报。作为一名Go开发者，将Prometheus集成到应用程序中可以使您获得有关其性能和行为的宝贵见解。
- en: To make your Go application monitorable with Prometheus, you need to instrument
    it with metrics that capture relevant information about its internal state and
    performance. This involves adding instrumentation code to your application’s code
    base to expose metrics endpoints that Prometheus can then scrape.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的Go应用程序可由Prometheus监控，您需要使用捕获其内部状态和性能相关信息的指标对其进行配置。这涉及到向您的应用程序代码库中添加配置代码，以暴露Prometheus可以抓取的指标端点。
- en: 'The Prometheus Go client library provides a convenient way to instrument your
    Go application with metrics. It offers a range of metric types that allow you
    to capture different aspects of your application’s behavior:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus Go客户端库提供了一种方便的方法，可以将指标配置到您的Go应用程序中。它提供了一系列指标类型，允许您捕获应用程序行为的各个方面：
- en: '**Counters**: Monotonically increasing values used to track the number of occurrences
    of an event over time. They reset to zero when the application restarts and are
    useful for measuring event frequencies, such as the number of requests or errors.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：用于随时间跟踪事件发生次数的单调递增值。当应用程序重新启动时，它们重置为零，并且对于测量事件频率（如请求数或错误数）非常有用。'
- en: '**Gauges**: Instantaneous measurements of a particular value at a specific
    point in time. They can increase or decrease and represent the current state of
    a system, such as CPU usage, memory consumption, or the number of active connections.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：在特定时间点对特定值的瞬时测量。它们可以增加或减少，并代表系统的当前状态，例如CPU使用率、内存消耗或活动连接数。'
- en: '**Histograms**: A means to track the distribution of values over time, allowing
    you to understand the variability and spread of data. They collect observations
    into configurable buckets and provide metrics such as percentiles, median, and
    average, which are useful for understanding response times, latencies, and request
    durations.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直方图**：一种跟踪值随时间分布的方法，使您能够了解数据的变异性和分布范围。它们将观察结果收集到可配置的桶中，并提供诸如百分位数、中位数和平均值等指标，这些指标对于理解响应时间、延迟和请求持续时间非常有用。'
- en: '**Summaries**: Similar to histograms, summaries provide a more accurate representation
    of the data distribution, especially for high-cardinality datasets. They calculate
    quantiles and percentiles dynamically, allowing you to analyze data distribution
    with precision and granularity, making them suitable for measuring latency, duration,
    and response-time distributions.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要**：与直方图类似，摘要提供了对数据分布的更准确表示，特别是对于高基数数据集。它们动态计算分位数和百分位数，允许您以精确和细粒度分析数据分布，这使得它们适合于测量延迟、持续时间和响应时间分布。'
- en: Once you’ve instrumented your application using the aforementioned metric types
    that are appropriate to the metrics you desire and use case, you then need to
    expose metrics endpoints for Prometheus to scrape. These endpoints typically serve
    metrics in a format compatible with the Prometheus exposition format, such as
    `/metrics`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用上述适合您所需指标和用例的指标类型对应用程序进行了配置，接下来您需要暴露指标端点供Prometheus抓取。这些端点通常以与Prometheus展示格式兼容的格式提供指标，如`/metrics`。
- en: Prometheus uses configuration files called scrape configs to define targets
    it should scrape for metrics. You’ll need to configure Prometheus to scrape your
    application’s metrics endpoint(s) and specify the scrape interval to collect data
    at regular intervals.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus使用名为抓取配置的配置文件来定义它应该抓取指标的目标。您需要配置Prometheus以抓取您的应用程序指标端点，并指定抓取间隔以定期收集数据。
- en: With Prometheus collecting metrics from your Go application, you can now visualize
    them using tools such as Grafana and set up alerts based on predefined thresholds
    or conditions. This allows you to proactively monitor your application’s health
    and performance and take corrective action when necessary.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prometheus 从你的 Go 应用程序收集指标后，你现在可以使用像 Grafana 这样的工具来可视化它们，并基于预定义的阈值或条件设置警报。这允许你主动监控应用程序的健康状况和性能，并在必要时采取纠正措施。
- en: Exercise 21.01 – Creating an app with a /healthz endpoint
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 21.01 – 创建具有 /healthz 端点的应用程序
- en: 'We’ve just walked through an overview of how monitoring works, a powerful tool
    you can utilize to capture metrics, and how you can then visualize those metrics
    and use them for the betterment of your project. We will now take a look at what
    this looks like in code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚概述了监控的工作原理，这是一个强大的工具，你可以用它来捕获指标，以及你如何可视化这些指标并用于改进你的项目。现在，我们将看看这在代码中是什么样的：
- en: Create a new directory called `Exercise21.01`. Within that directory, create
    a new file called `main.go`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `Exercise21.01` 的目录下创建一个新的目录。在该目录内，创建一个名为 `main.go` 的新文件。
- en: 'Run the following two commands to create a `go` module for the exercise:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下两个命令以创建用于练习的 `go` 模块：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code to the file to create a simple application we can monitor:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中，以创建一个我们可以监控的简单应用程序：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a counter metric we will use to monitor the count of calls to the endpoint:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们将用于监控端点调用次数的计数器指标：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Register the metric with Prometheus:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指标注册到 Prometheus：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define a handler for the `/``healthz` endpoint:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `/`healthz 端点的处理器：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Define a handler for viewing the metrics:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于查看指标的处理器：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define and start the server, and then close the function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义并启动服务器，然后关闭函数：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run the program, you need to open your terminal and navigate to the directory
    that you created the `main.go` file in. Then, run the `go build` tool by writing
    the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行程序，你需要打开你的终端，导航到包含 `main.go` 文件的目录。然后，通过编写以下内容来运行 `go build` 工具：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will create an executable called `monitored_app` that you can execute
    the binary in by running it on the command line:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `monitored_app` 的可执行文件，你可以在命令行上运行它来执行二进制文件：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output will look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The server is now listening for requests. You can now navigate to the `/healthz`
    endpoint in your web browser, or through a `curl` command to perform the HTTP
    request. Navigate to the web browser at the endpoint, and reload the page a few
    times: `http://localhost:8080/healthz`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在正在监听请求。你现在可以通过在网页浏览器中导航到 `/healthz` 端点，或者通过 `curl` 命令执行 HTTP 请求来访问该端点。导航到网页浏览器并刷新页面几次：`http://localhost:8080/healthz`。
- en: 'If you return to your terminal, you will see that the counter was incremented
    with each request or, in other words, each time you refreshed the web page:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到你的终端，你会看到计数器随着每个请求增加，换句话说，每次你刷新网页：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will see the same number of lines of that output as the number of times
    you made a request to the web server for that endpoint. Now that we’ve made a
    few requests to the server, we’ve generated some data on our monitored application.
    We can view the available Prometheus metrics at `http://localhost:8080/metrics`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到与你对该端点的 web 服务器请求次数相同数量的输出行。现在我们已经向服务器发送了一些请求，我们在监控的应用程序上生成了一些数据。我们可以在 `http://localhost:8080/metrics`
    查看可用的 Prometheus 指标。
- en: 'If you go to the web browser at the `/metrics` endpoint, you will see the metric
    we created, among a bunch of other metrics that have been abbreviated with three
    dots, as there are too many to list nicely on a page:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问网页浏览器的 `/metrics` 端点，你将看到我们创建的指标，以及许多其他用三个点缩写的指标，因为太多而无法在页面上很好地列出：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see our custom metric:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们的自定义指标：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We invoked our endpoint three times; therefore, we see a counter value of `3`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了我们的端点三次；因此，我们看到计数器值为 `3`。
- en: The additional metrics you are seeing are provided by the Prometheus client
    library itself and are related to Go runtime metrics, including memory allocation,
    garbage collection, goroutines, and other runtime statistics. These metrics are
    automatically exposed by the Prometheus client library when you import and use
    it in your Go application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的额外指标是由 Prometheus 客户端库本身提供的，与 Go 运行时指标相关，包括内存分配、垃圾回收、goroutines 以及其他运行时统计信息。这些指标在你在
    Go 应用程序中导入和使用 Prometheus 客户端库时自动暴露。
- en: In this exercise, you defined a counter metric for an endpoint on an HTTP server
    using Prometheus. By instrumenting your Go application with Prometheus and following
    best practices for monitoring, you can gain valuable insights into its behavior
    and performance in a cloud-native environment. With Prometheus, we saw how you
    can use it to be well equipped to define the monitoring capabilities of an application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用Prometheus为HTTP服务器上的一个端点定义了一个计数器指标。通过使用Prometheus对您的Go应用程序进行仪表化并遵循监控的最佳实践，您可以在云原生环境中获得对其行为和性能的宝贵见解。通过Prometheus，我们看到了如何使用它来定义应用程序的监控能力。
- en: Expanding the example by adding additional custom metrics allows teams to detect
    issues early on, effectively troubleshoot their applications, and ensure the reliability
    and scalability of Go applications in production-level environments. Prometheus
    also enables alerting upon metrics upon certain criteria, proving it to be quite
    a powerful tool when gaining insights into your application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加额外的自定义指标来扩展示例，可以使团队在早期发现问题，有效地调试他们的应用程序，并确保Go应用程序在生产级环境中的可靠性和可伸缩性。Prometheus还能够在满足某些标准时对指标进行警报，证明它在深入了解您的应用程序时是一个相当强大的工具。
- en: Enabling deep insights through OpenTelemetry
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过OpenTelemetry实现深入洞察
- en: In today’s complex distributed systems landscape, understanding how our applications
    behave and perform is crucial for maintaining reliability and performance. We
    will now take a look at another useful monitoring tool readily available. **OpenTelemetry**
    is a pivotal tool for gaining profound insights into the functionality and performance
    of distributed systems. OpenTelemetry, often referred to as OTel, provides a standardized
    approach to collect and correlate data across various components of the system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今复杂的分布式系统环境中，了解我们的应用程序的行为和性能对于维护可靠性和性能至关重要。现在，我们将探讨另一个现成的有用监控工具。**OpenTelemetry**是深入了解分布式系统功能和性能的关键工具。OpenTelemetry，通常被称为OTel，提供了一种标准化的方法来收集和关联系统各个组件的数据。
- en: 'By incorporating OpenTelemetry into your Go applications, you can seamlessly
    capture telemetry data, including traces, metrics, and logs, to gain a holistic
    understanding of your system’s operation. Let’s take a look at the three main
    pillars OpenTelemetry encompasses:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将OpenTelemetry集成到您的Go应用程序中，您可以无缝地捕获遥测数据，包括跟踪、指标和日志，从而全面了解您系统的工作情况。让我们看看OpenTelemetry包含的三个主要支柱：
- en: '**Tracing** allows us to track the flow of requests as they travel through
    different services and components, providing invaluable insights into latency,
    dependencies, and error propagation. For tracing, we create and propagate trace
    contexts across service boundaries in order to achieve end-to-end visibility into
    request flows. This enables us to visualize requests as they flow through the
    system, identify performance bottlenecks, diagnose errors, and optimize resource
    utilization.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**使我们能够跟踪请求在穿越不同的服务和组件时的流动，提供了关于延迟、依赖关系和错误传播的宝贵见解。为了跟踪，我们在服务边界之间创建和传播跟踪上下文，以实现端到端请求流的可见性。这使得我们能够可视化请求在系统中的流动，识别性能瓶颈，诊断错误，并优化资源利用。'
- en: '**Metrics** offer a quantitative view of our system’s health and performance,
    enabling us to monitor key indicators and identify potential bottlenecks or anomalies.
    OpenTelemetry provides a means of collecting metrics similar to providing insights
    into the health and performance of our applications.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指标**为我们系统的健康和性能提供了一个量化的视角，使我们能够监控关键指标并识别潜在的瓶颈或异常。OpenTelemetry提供了一种收集指标的方法，类似于提供对我们应用程序健康和性能的洞察。'
- en: '**Logs** provide a narrative of events and actions within our applications,
    aiding in troubleshooting and debugging efforts. This also allows us to trace
    the flow of information across our distributed systems and capture logs as events
    occur internal to the application.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**提供了我们应用程序中事件和动作的叙述，有助于故障排除和调试工作。这也允许我们在分布式系统中跟踪信息流，并在应用程序内部事件发生时捕获日志。'
- en: To harness the power of OpenTelemetry in your application, you must first instrument
    the application with the necessary instrumentation libraries and **software development
    kits**, or **SDKs**. This is similar to how we saw you must instrument the application
    for Prometheus in the previous section of this chapter. For OpenTelemetry, it
    is a similar process of integrating the OpenTelemetry SDKs into the code base
    and configuring instrumentation for tracing, metrics, and logging.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中利用 OpenTelemetry 的力量，您必须首先使用必要的仪器库和**软件开发工具包**或**SDK**来对应用程序进行仪器化。这与我们在本章前一部分中看到您必须对应用程序进行
    Prometheus 仪器化的过程类似。对于 OpenTelemetry 来说，这是一个将 OpenTelemetry SDK 集成到代码库并配置跟踪、指标和日志仪器化的类似过程。
- en: Let’s see what some of this looks like in practice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些在实际中是什么样子。
- en: Exercise 21.02 – Using OpenTelemetry for queryable logs and tracing
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 21.02 – 使用 OpenTelemetry 进行可查询日志和跟踪
- en: We now understand the monitoring capabilities that OpenTelemetry allows developers.
    We will now see how it helps to make structured logs that enable developers to
    more easily query their logs later on, as well as see what tracing is like with
    OpenTelemetry.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了 OpenTelemetry 允许开发者使用的监控能力。我们将现在看看它是如何帮助创建结构化日志的，这些日志使开发者能够更容易地在以后查询他们的日志，以及了解
    OpenTelemetry 中的跟踪是什么样的。
- en: 'Create a new directory called `Exercise21.02`. Within that directory, create
    a new Go file called `main.go`, then do the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `Exercise21.02` 的新目录中创建一个名为 `main.go` 的新 Go 文件，然后执行以下操作：
- en: 'Run the following two commands to create a `go` module for the exercise:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下两个命令来为练习创建一个 `go` 模块：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code to the file, including all of the imports necessary
    for our OpenTelemetry monitoring:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中，包括我们 OpenTelemetry 监控所需的所有导入：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a function to initialize a trace exporter:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始化跟踪导出器的函数：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a function to initialize a log exporter:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始化日志导出器的函数：
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a function to initialize a structured logger:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始化结构化日志器的函数：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function to initialize the tracing provider:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个初始化跟踪提供者的函数：
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, define an HTTP handler that will handle the incoming monitored request
    and capture log information, as well as start the span for the incoming request:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，定义一个 HTTP 处理器，该处理器将处理传入的监控请求并捕获日志信息，以及为传入的请求启动跨度：
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Last, define a `main()` function where you will call all of the initialization
    helper functions we just defined:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义一个 `main()` 函数，在其中调用我们刚刚定义的所有初始化辅助函数：
- en: '[PRE20]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Wrap the HTTP handler with OpenTelemetry instrumentation, start the HTTP server,
    and close the `main()` function:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 OpenTelemetry 仪器包装 HTTP 处理器，启动 HTTP 服务器，并关闭 `main()` 函数：
- en: '[PRE21]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To run the program, you need to open your terminal and navigate to the directory
    that you created the `main.go` file in. Then, run the `go build` tool by writing
    the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行程序，您需要打开您的终端并导航到创建 `main.go` 文件的目录。然后，通过编写以下内容来运行 `go build` 工具：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will create an executable called `monitored_app` that you can execute
    the binary in by running it on the command line:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `monitored_app` 的可执行文件，您可以通过在命令行上运行它来执行该二进制文件：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output will look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The server is now listening for requests. You can now navigate to the `/healthz`
    endpoint in your web browser, or through a `curl` command to perform the HTTP
    request. Navigate to the web browser at the endpoint, and reload the page a few
    times: `http://localhost:8080/healthz`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器现在正在监听请求。您现在可以通过在网页浏览器中导航到 `/healthz` 端点或通过 `curl` 命令执行 HTTP 请求来导航到该端点。在网页浏览器中导航到端点，然后重新加载页面几次：`http://localhost:8080/healthz`。
- en: 'The web page will now show the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 网页现在将显示以下内容：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you return to your terminal, you will see the structured log we defined:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回到您的终端，您将看到我们定义的结构化日志：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will also see the results of the tracing information exported to standard
    output, so we can see the trace in the terminal. Here, you can see part of the
    output, shortened to allow ease of visibility:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将看到跟踪信息导出到标准输出的结果，这样我们就可以在终端中看到跟踪。在这里，您可以看到部分输出，缩短以方便查看：
- en: '![Figure 21.1: OpenTelemetry tracing output – this image is meant to show the
    output and text; readability is not essential](img/B18621_21_1.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 21.1：OpenTelemetry 跟踪输出 – 这张图片旨在显示输出和文本；可读性不是关键](img/B18621_21_1.jpg)'
- en: 'Figure 21.1: OpenTelemetry tracing output – this image is meant to show the
    output and text; readability is not essential'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1：OpenTelemetry 跟踪输出 – 这张图片旨在显示输出和文本；可读性不是关键
- en: In this exercise, you worked with OpenTelemetry to gain valuable monitoring
    insights into the application, including structured logging and tracing information
    on requests. The logs help to provide information on what occurred, and we saw
    how you can structure the logs to include information relevant to your use case
    and project. From there, you can use different aspects of the logs to query. For
    example, our logs included the service name, HTTP method used, and endpoint invoked.
    We could easily create queries based on all service requests or all requests to
    a specific endpoint. This could provide valuable insights to enable teams to practice
    on their projects. We also saw tracing information using OpenTelemetry. This information
    is useful for timing insights and execution flow if there are sub-requests made.
    We can also visualize these results with different exporters or UI tools to more
    easily see what is going on in our request flows in more complex use cases.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用了OpenTelemetry来获取有关应用程序的有价值监控洞察，包括请求的结构化日志和跟踪信息。日志有助于提供有关发生情况的信息，我们看到了如何根据您的用例和项目结构化日志以包含相关信息。从那里，您可以使用日志的不同方面进行查询。例如，我们的日志包括服务名称、使用的HTTP方法和调用的端点。我们可以轻松地基于所有服务请求或特定端点的所有请求创建查询。这可以为团队提供有价值的洞察，以便在他们的项目中实践。我们还看到了使用OpenTelemetry的跟踪信息。如果有子请求，这些信息对于时间洞察和执行流程非常有用。我们还可以使用不同的导出器或UI工具来可视化这些结果，以便在更复杂的用例中更容易地看到我们的请求流程中正在发生什么。
- en: Best practices for putting your Go application in a container
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的Go应用程序放入容器的最佳实践
- en: In recent years, containerization has revolutionized the way software engineers
    deploy and manage software applications. By encapsulating an application along
    with its dependencies into a lightweight, portable container, containerization
    provides numerous benefits, including consistency, scalability, and portability
    for our applications. This approach has gained widespread adoption across industries
    and is considered a standard practice for modern software development and deployment
    workflows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，容器化技术彻底改变了软件工程师部署和管理软件应用的方式。通过将应用程序及其依赖项封装进轻量级、可移植的容器中，容器化技术为我们的应用程序提供了众多好处，包括一致性、可扩展性和便携性。这种方法在各个行业中得到了广泛应用，并被认为是最现代软件开发和部署工作流程的标准实践。
- en: Containerization is essential to software nowadays as it ensures consistency
    by packaging the application and its dependencies into a single unit, eliminating
    the infamous and dreaded “it works on my machine” problem This consistency extends
    to different environments, including production, reducing the risk of configuration
    drift. It also allows scalability on demand, as it is efficient to add or remove
    instances of the application when it is lightweight and fast to spin up in a container.
    Lastly, containers can be run on-premises, in **cloud service providers** (**CSPs**),
    or even in hybrid environments. Therefore, it is essential to understand how to
    package up your Go application dependencies into a container to run your Go code
    to be consistent, scalable, and portable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化对于当今的软件至关重要，因为它通过将应用程序及其依赖项打包成一个单一单元来确保一致性，消除了臭名昭著且令人讨厌的“在我的机器上它工作”问题。这种一致性扩展到不同的环境，包括生产环境，降低了配置漂移的风险。它还允许按需进行可扩展性，因为当应用程序轻量级且在容器中启动快速时，添加或删除应用程序实例是高效的。最后，容器可以在本地、**云服务提供商**（**CSPs**）或混合环境中运行。因此，了解如何将您的Go应用程序依赖项打包到容器中，以运行您的Go代码，确保其一致性、可扩展性和便携性是至关重要的。
- en: Docker is a big player in the containerization ecosystem, serving as one of
    the most widely used containerization platforms. Docker provides a containerization
    engine, image management, container orchestration, and a widely integrated ecosystem.
    It provides tools, workflows, and infrastructure for creating, deploying, and
    managing containers effectively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是容器化生态系统中的大玩家，作为最广泛使用的容器化平台之一。Docker提供了一个容器化引擎、镜像管理、容器编排以及广泛集成的生态系统。它提供了创建、部署和管理容器的工具、工作流程和基础设施。
- en: 'There are a few best practices to keep in mind when containerizing your Go
    application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化您的Go应用程序时，有一些最佳实践需要牢记：
- en: '**Leverage Go modules for dependency management**: Go modules provide a convenient
    way to manage dependencies for your Go applications. When containerizing your
    Go application, ensure that you are using Go modules to manage dependencies effectively.
    Go modules were covered early on in the book in [*Chapter 9*](B18621_09.xhtml#_idTextAnchor1367),
    *Using Go Modules to Define* *a Project*.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用 Go 模块进行依赖管理**：Go 模块为管理 Go 应用程序的依赖提供了一个便捷的方式。在容器化您的 Go 应用程序时，请确保您正在使用 Go
    模块来有效地管理依赖。本书在[*第 9 章*](B18621_09.xhtml#_idTextAnchor1367)，*使用 Go 模块定义* *项目*中早期就介绍了
    Go 模块。'
- en: '**Keep containers lightweight**: One of the fundamental principles of containerization
    is to keep containers lightweight. This means minimizing the size of your container
    images to reduce deployment times and resource usage. When building container
    images for Go applications, use multi-stage builds to compile your application
    binary and copy only the necessary files into the final image. Additionally, leverage
    Alpine-based or scratch images as base images to further reduce image size.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持容器轻量**：容器化的一个基本原理是保持容器轻量。这意味着最小化容器镜像的大小，以减少部署时间和资源使用。在为 Go 应用程序构建容器镜像时，使用多阶段构建来编译您的应用程序二进制文件，并将必要的文件复制到最终的镜像中。此外，利用基于
    Alpine 或 scratch 的镜像作为基础镜像，进一步减小镜像大小。'
- en: '**Optimize Dockerfile instructions**: When writing Dockerfiles for your Go
    applications, optimize Dockerfile instructions to improve build performance and
    reduce image size. Use multi-stage builds to separate the build environment from
    the final production image, minimizing the size of the final image. Additionally,
    leverage Docker’s layer-caching mechanism by ordering your Dockerfile instructions
    from least frequently changing to most frequently changing, ensuring that only
    necessary steps are executed when rebuilding the image.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化 Dockerfile 指令**：在为您的 Go 应用程序编写 Dockerfile 时，优化 Dockerfile 指令以提高构建性能并减小镜像大小。使用多阶段构建将构建环境与最终生产镜像分开，最小化最终镜像的大小。此外，通过按从最少变化到最多变化的顺序排列您的
    Dockerfile 指令，利用 Docker 的层缓存机制，确保在重建镜像时只执行必要的步骤。'
- en: '**Secure your container environment**: Security should be a top priority when
    containerizing your Go applications. Follow security best practices such as using
    minimal and trusted base images, scanning container images for vulnerabilities
    using tools such as **Trivy**, and applying least privilege principles by running
    containers with non-root users whenever possible. Additionally, ensure that sensitive
    information such as credentials or API keys are not hardcoded into your container
    images but instead provided as environment variables or mounted as secrets at
    runtime. Lastly, consider leveraging Chainguard images for your Dockerfiles to
    enhance the security of container images by relying upon their enhanced security
    measures.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护您的容器环境**：在容器化您的 Go 应用程序时，安全性应该是首要考虑的。遵循安全最佳实践，例如使用最小和可信的基础镜像，使用像 **Trivy**
    这样的工具扫描容器镜像以查找漏洞，并在可能的情况下通过运行非 root 用户来应用最小权限原则。此外，确保敏感信息，如凭证或 API 密钥，不会硬编码到您的容器镜像中，而是在运行时作为环境变量提供或挂载为机密信息。最后，考虑利用
    Chainguard 镜像增强 Dockerfile 的安全性，通过依赖其增强的安全措施来提高容器镜像的安全性。'
- en: '**Implement health checks and logging**: Implement health checks and logging
    in your Go applications to improve observability and reliability in a containerized
    environment. Define health check endpoints to allow container orchestration platforms
    such as Kubernetes to monitor the health of your application and automatically
    restart unhealthy containers. Additionally, use structured logging to provide
    valuable insights into the behavior of your application, making it easier to troubleshoot
    issues and debug problems in production.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现健康检查和日志记录**：在您的 Go 应用程序中实现健康检查和日志记录，以提高容器化环境中的可观察性和可靠性。定义健康检查端点，以便容器编排平台如
    Kubernetes 能够监控应用程序的健康状况，并自动重启不健康的容器。此外，使用结构化日志提供有关应用程序行为的宝贵见解，使解决问题和在生产环境中调试问题变得更加容易。'
- en: '**Use container orchestration platforms**: We will discuss why this is important
    in the next section of this chapter.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用容器编排平台**：我们将在本章的下一节讨论为什么这很重要。'
- en: Now that we understand why it is crucial to know how to containerize our Go
    applications, let’s see what this looks like in practice.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解到了解如何容器化我们的 Go 应用程序的重要性，让我们看看在实践中这看起来是什么样子。
- en: Exercise 21.03 – Creating a Dockerfile for a Go application
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 21.03 – 为 Go 应用程序创建 Dockerfile
- en: 'To containerize your Go application, you’ll need to create a Dockerfile, which
    is a text document that contains instructions for Docker on how to build your
    application’s image. Let’s walk through the process of creating a Dockerfile for
    a simple Go application and then see how to build and run the container. We will
    use the code from earlier on in the chapter, in the `Exercise21.01` directory:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要容器化您的 Go 应用程序，您需要创建一个 Dockerfile，这是一个包含 Docker 如何构建应用程序镜像的指令的文本文件。让我们通过创建一个简单
    Go 应用程序的 Dockerfile 的过程，然后看看如何构建和运行容器。我们将使用本章前面的 `Exercise21.01` 目录中的代码：
- en: Create a new directory called `Exercise21.03`. Within that directory, create
    a new file called `main.go`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Exercise21.03` 目录下创建一个名为 `main.go` 的新文件：
- en: Copy the contents of `Exercise21.03/main.go`, `Exercise21.03/go.mod`, and `Exercise21.03/go.sum`
    into the new directory.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Exercise21.03/main.go`、`Exercise21.03/go.mod` 和 `Exercise21.03/go.sum` 的内容复制到新目录中。
- en: Create a new file called `Dockerfile` that contains instructions.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含指令的新文件 `Dockerfile`。
- en: 'Start with the official Go image as the base image:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以官方的 Go 镜像作为基础镜像：
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Ensure the Go compiler builds a statically linked binary, including all necessary
    libraries within the binary:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Go 编译器构建一个静态链接的二进制文件，包括二进制文件内的所有必要库：
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set the working directory inside of the container:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置容器内的工作目录：
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Copy over the Go modules files and our code for the monitored application:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 Go 模块文件和监控应用程序的代码：
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Build our Go binary:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 Go 二进制文件：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Start a new stage to create a minimal final image:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的阶段以创建一个最小的最终镜像：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Copy over the binary to our final stage:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制文件复制到我们的最终阶段：
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Expose the port we will use to interact with our application:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露我们将用于与应用程序交互的端口：
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run our monitored application:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行我们的监控应用程序：
- en: '[PRE35]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have filled the contents of our `Dockerfile` file, we can build
    our Docker image by running the following command in the terminal:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经填充了 `Dockerfile` 文件的内容，我们可以在终端中运行以下命令来构建我们的 Docker 镜像：
- en: '[PRE36]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can then run our Docker container using the following command, which will
    start a container based on our monitored application image and map port `8080`
    on our host machine to port 8080 of the container:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行我们的 Docker 容器，该命令将基于我们监控的应用程序镜像启动一个容器，并将主机机器上的端口 `8080` 映射到容器的端口
    `8080`：
- en: '[PRE37]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can now access our application at the same URL we’ve been hitting: `http://localhost:8080/healthz`.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过我们一直在访问的相同 URL 访问我们的应用程序：`http://localhost:8080/healthz`。
- en: 'We still see the same output as we did before with the application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然看到了与之前相同的应用程序输出：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’ve now seen how to take our Go application into a lightweight, ephemeral
    container and run it using Docker commands. Docker is a platform that enables
    us to build, ship, and run our application in a Docker container by packaging
    up our Go application dependencies into a portable container that can be deployed
    across different environments.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何将我们的 Go 应用程序转换为轻量级、短暂的容器，并使用 Docker 命令运行它。Docker 是一个平台，它使我们能够通过将我们的
    Go 应用程序依赖项打包到一个可移植的容器中，从而在 Docker 容器中构建、传输和运行我们的应用程序，该容器可以在不同的环境中部署。
- en: Let’s now expand on this idea of portability and container orchestration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在扩展这个可移植性和容器编排的想法。
- en: Making your app ready to work with orchestrators such as Kubernetes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序准备好与 Kubernetes 等编排器一起工作
- en: '**Kubernetes**, often abbreviated as **K8s**, has emerged as the de facto standard
    for container orchestration and management. It provides the capabilities to automate
    the deployment, scaling, and management of containerized applications. At its
    core, Kubernetes abstracts away the complexities of managing individual containers
    and offers a unified API and control plane for orchestrating containerized workloads
    across a cluster of machines. Orchestrators such as Kubernetes are what you turn
    to when you want to streamline the deployment and management of modern, cloud-native
    applications.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes**，通常缩写为 **K8s**，已成为容器编排和管理的既定标准。它提供了自动化部署、扩展和管理容器化应用程序的能力。在其核心，Kubernetes
    抽象了管理单个容器的复杂性，并为跨机器集群编排容器化工作负载提供了一个统一的 API 和控制平面。当您想要简化现代、云原生应用程序的部署和管理时，编排器如
    Kubernetes 就是您所依赖的。'
- en: In today’s dynamic and rapidly evolving software landscape, where microservices
    architectures and containerization have become mainstream, Kubernetes offers a
    scalable and resilient platform for deploying and operating these distributed
    applications. However, it is not without its complexities and learning curve.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今动态且快速发展的软件领域中，微服务架构和容器化已成为主流，Kubernetes提供了一个可扩展且具有弹性的平台，用于部署和运行这些分布式应用程序。然而，它并非没有其复杂性和学习曲线。
- en: 'There are a few things to do in order for your application to work with orchestrators
    such as Kubernetes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的应用程序能够与Kubernetes等编排器协同工作，你需要做几件事情：
- en: '**Containerize your application**: Package your Go application and its dependencies
    into a Docker container, as we saw in the previous section.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化你的应用程序**：将你的Go应用程序及其依赖项打包到Docker容器中，正如我们在上一节中看到的。'
- en: '**Deploy your containerized application**: Once you’ve built your container
    image, you need to deploy it into your Kubernetes cluster. This typically involves
    pushing your container image to a container registry (such as Docker Hub, **Google
    Container Registry** (**GCR**), or **Amazon Elastic Container Registry** (**Amazon
    ECR**), and then deploying it into your Kubernetes cluster using Kubernetes deployment
    manifests.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署你的容器化应用程序**：一旦你构建了容器镜像，你需要将其部署到你的Kubernetes集群中。这通常涉及将容器镜像推送到容器注册库（如Docker
    Hub、**Google Container Registry**（**GCR**）或**Amazon Elastic Container Registry**（**Amazon
    ECR**）），然后使用Kubernetes部署清单将其部署到你的Kubernetes集群中。'
- en: '**Define Kubernetes resources**: In Kubernetes, you define the desired state
    of your application using Kubernetes resources such as Deployments, Services,
    ConfigMaps, and Secrets. You will need to create Kubernetes manifests (YAML files)
    that describe these resources and specify how Kubernetes should manage your Go
    application.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义Kubernetes资源**：在Kubernetes中，你使用如Deployments、Services、ConfigMaps和Secrets等Kubernetes资源来定义应用程序的期望状态。你需要创建描述这些资源的Kubernetes清单（YAML文件），并指定Kubernetes应该如何管理你的Go应用程序。'
- en: '**Handle application life cycle**: Kubernetes manages the life cycle of your
    application, including scaling, rolling updates, and monitoring. Ensure that your
    application is designed to work well with Kubernetes by implementing features
    such as health checks, readiness probes, graceful shutdowns, and logging/metrics
    instrumentation.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理应用程序生命周期**：Kubernetes管理应用程序的生命周期，包括扩展、滚动更新和监控。确保你的应用程序通过实现健康检查、就绪性探测、优雅关闭以及日志/指标工具来实现与Kubernetes的良好协同工作。'
- en: '**Service discovery and load balancing**: Use Kubernetes services to expose
    your application internally within the cluster and to external clients. This allows
    other parts of your application to discover and communicate with your Go application
    and enables Kubernetes to load-balance traffic to multiple instances of your application.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现和负载均衡**：使用Kubernetes服务在集群内部和外部客户端中公开你的应用程序。这允许应用程序的其他部分发现并与你的Go应用程序通信，并使Kubernetes能够对应用程序的多个实例进行负载均衡。'
- en: '**Monitoring and logging**: Instrument your Go application for monitoring and
    logging using tools such as Prometheus, Grafana, Fluentd, OpenTelemetry, and so
    on. Emit metrics, logs, and trace information in a structured format so that Kubernetes
    can collect and analyze them. This allows you to gain visibility into the health
    and performance of your application running in Kubernetes.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和日志记录**：使用Prometheus、Grafana、Fluentd、OpenTelemetry等工具对你的Go应用程序进行监控和日志记录。以结构化格式发出指标、日志和跟踪信息，以便Kubernetes可以收集和分析它们。这让你能够了解在Kubernetes中运行的应用程序的健康状况和性能。'
- en: By following these steps, you can successfully deploy and run your Go application
    using an orchestrator, such as a Kubernetes environment. It’s important to familiarize
    yourself with Kubernetes concepts and best practices to ensure that your application
    runs smoothly and efficiently in production. You should also acknowledge a much
    more complex environment and learning curve to bring yourself up to speed on working
    with Kubernetes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些步骤，你可以成功地将你的Go应用程序部署并运行在如Kubernetes环境这样的编排器中。熟悉Kubernetes概念和最佳实践对于确保你的应用程序在生产环境中平稳高效地运行至关重要。你还应该认识到，为了跟上与Kubernetes协同工作的步伐，你需要面对一个更加复杂的环境和学习曲线。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was an exciting one that expanded our understanding of where we
    are running the Go applications that we write. We learned how to run our Go code
    in the cloud, all packaged up nicely and providing us with the monitoring insights
    that we need to ensure success for our services.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容非常精彩，它扩展了我们对于运行我们编写的Go应用程序的理解。我们学习了如何在云端运行我们的Go代码，并且这些代码被完美地打包，为我们提供了确保服务成功的监控洞察。
- en: We started with understanding why and how to make our Go application code instrumented
    with monitoring using Prometheus. That was a nice segue into gaining even richer
    insights into our application using OpenTelemetry. We then demonstrated how to
    containerize our application using Docker, and then looked at how to run that
    containerized application in an orchestrated environment, such as in Kubernetes.
    We’ve covered a lot of ground in this chapter and in this book in its entirety.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解为什么以及如何使用Prometheus来监控我们的Go应用程序代码开始。这为使用OpenTelemetry获取更丰富的应用程序洞察提供了一个很好的过渡。然后，我们展示了如何使用Docker容器化我们的应用程序，并探讨了如何在如Kubernetes这样的编排环境中运行这个容器化应用程序。在这一章以及整本书中，我们覆盖了大量的内容。
- en: Over the course of the book, we have covered the basics of Go with variables
    and various type declarations. We moved into control flow and data rules with
    Go, to include some of the newest features of working with complex types such
    as using generics and interfaces. We covered good software engineering practices
    as they apply to Go through code reuse, error handling, and how to work with large-scale
    projects through Go modules and packages. We even touched on time and files and
    systems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们学习了Go语言的基础，包括变量和各种类型声明。我们使用Go语言进入了控制流和数据规则的学习，还涵盖了使用泛型和接口等一些处理复杂数据类型的新特性。我们通过代码重用、错误处理以及如何通过Go模块和包来处理大规模项目，介绍了适用于Go语言的良好软件工程实践。我们还简要提到了时间和文件以及系统。
- en: The book transformed our skills to a professional level demonstrating debugging
    best practices with Go, crafting state-of-the-art CLI applications, and how to
    perform application development by connecting to databases, and working with web
    servers and clients. We tied everything up with a nice bow ending with covering
    the concurrency Go primitives, strong testing practices, and even highlighting
    the best of the Go ecosystem with the tools it offers. Lastly, we saw how to run
    our Go code in the cloud and gain insights into how our application is performing.
    This book should provide you with the tools and knowledge to transform your Go
    knowledge into a professional Go developer!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将我们的技能提升到了专业水平，展示了使用Go进行调试的最佳实践，构建最先进的CLI应用程序，以及如何通过连接数据库、与Web服务器和客户端协作来进行应用程序开发。我们通过涵盖Go的并发原语、强大的测试实践，甚至突出Go生态系统提供的最佳工具，将所有内容完美地串联起来。最后，我们看到了如何在云端运行我们的Go代码，并深入了解我们的应用程序性能。这本书应该为你提供将Go知识转化为专业Go开发者的工具和知识！
