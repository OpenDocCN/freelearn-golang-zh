- en: Chapter 3. Three Ways to Implement Profile Pictures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。实现个人资料图片的三种方法
- en: So far, our chat application has made use of the OAuth2 protocol to allow users
    to sign in to our application so that we know who is saying what. In this chapter,
    we are going to add profile pictures to make the chatting experience more engaging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的聊天应用程序已经使用了OAuth2协议，允许用户登录到我们的应用程序，以便我们知道谁在说什么。在本章中，我们将添加个人资料图片，使聊天体验更加引人入胜。
- en: 'We will look at the following ways to add pictures or avatars alongside the
    messages in our application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究以下几种方法来在我们的应用程序中的消息旁边添加图片或头像：
- en: Using the avatar picture provided by the authentication server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用认证服务器提供的头像图片
- en: Using the [Gravatar.com](http://Gravatar.com) web service to look up a picture
    by the user's e-mail address
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[Gravatar.com](http://Gravatar.com)网络服务通过用户的电子邮件地址查找图片
- en: Allowing the user to upload their own picture and host it themselves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户上传自己的图片并自行托管
- en: The first two options allow us to delegate the hosting of pictures to a third
    party—either an authentication service or [Gravatar.com](http://Gravatar.com)
    —which is great because it reduces the cost of hosting our application (in terms
    of storage costs and bandwidth, since the user's browsers will actually download
    the pictures from the servers of the authenticating service, not ours). The third
    option requires us to host pictures ourselves at a location that is web accessible.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个选项允许我们将图片的托管委托给第三方——要么是认证服务，要么是[Gravatar.com](http://Gravatar.com)——这很棒，因为它减少了我们应用程序的托管成本（存储成本和带宽成本，因为用户的浏览器实际上会从认证服务的服务器上下载图片，而不是我们自己的服务器）。第三个选项要求我们在可以通过web访问的位置托管图片。
- en: These options aren't mutually exclusive; you will most likely use some combination
    of them in a real-world production application. Towards the end of the chapter,
    we will see how the flexible design that emerges allows us to try each implementation
    in turn, until we find an appropriate avatar.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项并不是互斥的；在真实的生产应用程序中，您很可能会使用它们的某种组合。在本章结束时，我们将看到灵活的设计使我们能够依次尝试每种实现，直到找到合适的头像。
- en: We are going to be agile with our design throughout this chapter, doing the
    minimum work needed to accomplish each milestone. This means that at the end of
    each section, we will have working implementations that are demonstrable in the
    browser. This also means that we will refactor code as and when we need to and
    discuss the rationale behind the decisions we make as we go.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将灵活设计，尽量做到每个里程碑所需的最低工作量。这意味着在每个部分结束时，我们将拥有在浏览器中可演示的工作实现。这也意味着我们将根据需要重构代码，并讨论我们做出的决定背后的原因。
- en: 'Specifically, in this chapter, you will learn the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，您将学到以下内容：
- en: What are good practices to get additional information from authentication services,
    even when there are no standards in place
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使没有标准，也有哪些获取认证服务的额外信息的良好实践
- en: When it is appropriate to build abstractions into our code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时适合将抽象构建到我们的代码中
- en: How Go's zero-initialization pattern can save time and memory
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的零初始化模式如何节省时间和内存
- en: How reusing an interface allows us to work with collections and individual objects
    in the same way as the existing interface did
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何重用接口使我们能够以与现有接口相同的方式处理集合和单个对象
- en: How to use the [Gravatar.com](http://Gravatar.com) web service
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用[Gravatar.com](http://Gravatar.com)网络服务
- en: How to do MD5 hashing in Go
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Go中进行MD5哈希
- en: How to upload files over HTTP and store them on a server
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过HTTP上传文件并将其存储在服务器上
- en: How to serve static files through a Go web server
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过Go web服务器提供静态文件
- en: How to use unit tests to guide the refactoring of code
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用单元测试指导代码重构
- en: How and when to abstract functionality from `struct` types into interfaces
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何将`struct`类型的功能抽象为接口
- en: Avatars from the authentication server
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证服务器的头像
- en: It turns out that most authentication servers already have images for their
    users, and they make them available through the protected user resource that we
    already know how to access in order to get our users' names. To use this avatar
    picture, we need to get the URL from the provider, store it in the cookie for
    our user, and send it through a web socket so that every client can render the
    picture alongside the corresponding message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，大多数认证服务器已经为其用户准备了图片，并通过我们已经知道如何访问的受保护用户资源使其可用。要使用这个头像图片，我们需要从提供者那里获取URL，将其存储在我们用户的cookie中，并通过web套接字发送，以便每个客户端可以在相应的消息旁边呈现图片。
- en: Getting the avatar URL
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取头像URL
- en: The schema for user or profile resources is not part of the OAuth2 spec, which
    means that each provider is responsible for deciding how to represent that data.
    Indeed, providers do things differently, for example, the avatar URL in a GitHub
    user resource is stored in a field called `avatar_url` , whereas in Google, the
    same field is called `picture` . Facebook goes even further by nesting the avatar
    URL value in a `url` field inside an object called `picture` . Luckily, Gomniauth
    abstracts this for us; its `GetUser` call on a provider standardizes the interface
    to get common fields.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户或个人资料资源的架构不是OAuth2规范的一部分，这意味着每个提供者都负责决定如何表示这些数据。事实上，提供者的做法各不相同，例如，GitHub用户资源中的头像URL存储在名为`avatar_url`的字段中，而在Google中，相同的字段称为`picture`。Facebook甚至通过在名为`picture`的对象内嵌套头像URL值的`url`字段来进一步进行。幸运的是，Gomniauth为我们抽象了这一点；它在提供者上的`GetUser`调用标准化了获取常见字段的接口。
- en: 'In order to make use of the avatar URL field, we need to go back and store
    its information in our cookie. In `auth.go` , look inside the `callback` action
    switch case and update the code that creates the `authCookieValue` object as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用头像URL字段，我们需要回去并将其信息存储在我们的cookie中。在`auth.go`中，查看`callback`操作开关情况，并更新创建`authCookieValue`对象的代码如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `AvatarURL` method called in the preceding code will return the appropriate
    URL value which we then store in the `avatar_url` field which will be stored in
    the cookie.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中调用的`AvatarURL`方法将返回适当的URL值，然后我们将其存储在`avatar_url`字段中，该字段将存储在cookie中。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Gomniauth defines a `User` type of interface and each provider implements their
    own version. The generic `map[string]interface{}` data returned from the authentication
    server is stored inside each object, and the method calls access the appropriate
    value using the right field name for that provider. This approach—describing the
    way information is accessed without being strict about implementation details—is
    a great use of interfaces in Go.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth定义了一个接口类型的`User`，每个提供者都实现了自己的版本。从认证服务器返回的通用`map[string]interface{}`数据存储在每个对象内，方法调用使用适当的字段名访问相应的值。这种方法描述了访问信息的方式，而不严格关注实现细节，是Go中接口的一个很好的用法。
- en: Transmitting the avatar URL
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输头像URL
- en: 'We need to update our `message` type so that it can also carry with it the
    avatar URL. In `message.go` , add the `AvatarURL` string field:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新我们的`message`类型，以便它也可以携带头像URL。在`message.go`中，添加`AvatarURL`字符串字段：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far, we have not actually assigned a value to `AvatarURL` like we do for
    the `Name` field, so we must update our `read` method in `client.go` :'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上还没有为`AvatarURL`分配一个值，就像我们为`Name`字段所做的那样，因此我们必须更新`client.go`中的`read`方法：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All we have done here is we took the value from the `userData` field that represents
    what we put into the cookie and assigned it to the appropriate field in `message`
    if the value was present in the map. We will now take the additional step of checking
    whether the value is present because we cannot guarantee that the authentication
    service will provide a value for this field. And since it could be `nil` , it
    might cause a panic to assign it to a `string` type if it's actually missing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的一切就是从`userData`字段中取出代表我们放入cookie的值，并将其分配给`message`中的适当字段，如果该值在映射中存在的话。我们现在将进一步检查该值是否存在，因为我们不能保证认证服务将为此字段提供一个值。并且由于它可能是`nil`，如果它实际上缺失，将其分配给`string`类型可能会导致恐慌。
- en: Adding the avatar to the user interface
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将头像添加到用户界面
- en: 'Now that our JavaScript client gets an avatar URL value via the socket, we
    can use it to display the image alongside the messages. We do this by updating
    the `socket.onmessage` code in `chat.html` :'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的JavaScript客户端通过套接字获取了一个头像URL值，我们可以使用它来在消息旁边显示图像。我们通过更新`chat.html`中的`socket.onmessage`代码来实现这一点：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we receive a message, we will insert an `img` tag with the source set to
    the `AvatarURL` field from the message. We will use jQuery's `css` method to force
    a width of `50` pixels. This protects us from massive pictures spoiling our interface
    and allows us to align the image to the middle of the surrounding text.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到一条消息时，我们将插入一个`img`标签，其中源设置为消息的`AvatarURL`字段。我们将使用jQuery的`css`方法强制宽度为`50`像素。这可以防止大图片破坏我们的界面，并允许我们将图像对齐到周围文本的中间。
- en: If we build and run our application having logged in with a previous version,
    you will find that the `auth` cookie that doesn't contain the avatar URL is still
    there. We are not asked to sign in again (since we are already logged in), and
    the code that adds the `avatar_url` field never gets a chance to run. We could
    delete our cookie and refresh the page, but we would have to keep doing so whenever
    we make changes during development. Let's solve this problem properly by adding
    a logout feature.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用先前版本登录后构建和运行我们的应用程序，你会发现不包含头像URL的`auth` cookie仍然存在。我们不会被要求重新登录（因为我们已经登录了），添加`avatar_url`字段的代码也永远不会运行。我们可以删除cookie并刷新页面，但是在开发过程中每次进行更改时都需要这样做。让我们通过添加注销功能来正确解决这个问题。
- en: Logging out
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注销
- en: 'The simplest way to log a user out is to get rid of the `auth` cookie and redirect
    the user to the chat page, which will in turn cause a redirect to the login page
    since we just removed the cookie. We do this by adding a new `HandleFunc` call
    to `main.go` :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注销用户的最简单方法是删除`auth` cookie并将用户重定向到聊天页面，这将导致重定向到登录页面，因为我们刚刚删除了cookie。我们通过在`main.go`中添加一个新的`HandleFunc`调用来实现这一点：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding handler function uses `http.SetCookie` to update the cookie setting
    `MaxAge` to `-1` , which indicates that it should be deleted immediately by the
    browser. Not all browsers are forced to delete the cookie, which is why we also
    provide a new `Value` setting of an empty string, thus removing the user data
    that would previously have been stored.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的处理函数使用`http.SetCookie`来更新`MaxAge`设置为`-1`的cookie设置，这表示它应该立即被浏览器删除。并非所有浏览器都被强制删除cookie，这就是为什么我们还提供了一个新的`Value`设置为空字符串的设置，从而删除以前存储的用户数据。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As an additional assignment, you can bulletproof your app a little by updating
    the first line in `ServeHTTP` for your `authHandler` in `auth.go` to make it cope
    with the empty-value case as well as the missing-cookie case:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，你可以通过更新`auth.go`中`authHandler`的`ServeHTTP`的第一行来使其适应空值情况以及缺少cookie的情况，从而使你的应用程序更加健壮：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Instead of ignoring the return of `r.Cookie` , we keep a reference to the returned
    cookie (if there was actually one) and also add an additional check to see whether
    the `Value` string of the cookie is empty or not.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忽略`r.Cookie`的返回，我们保留返回的cookie的引用（如果实际上有的话），并添加额外的检查，看看cookie的`Value`字符串是否为空。
- en: 'Before we continue, let''s add a `Sign Out` link to make it even easier to
    get rid of the cookie, and also to allow our users to log out. In `chat.html`
    , update the `chatbox` form to insert a simple HTML link to the new `/logout`
    handler:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们添加一个“登出”链接，以便更轻松地删除cookie，并允许我们的用户注销。在`chat.html`中，更新`chatbox`表单，插入一个简单的HTML链接到新的`/logout`处理程序：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now build and run the application and open a browser to `localhost:8080/chat`
    :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序，并在浏览器中打开`localhost:8080/chat`：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Log out if you need to and log back in. When you click on **Send** , you will
    see your avatar picture appear next to your messages.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，注销并重新登录。当您点击**发送**时，您将看到您的头像图片出现在您的消息旁边。
- en: '![Logging out](img/Image00007.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![注销](img/Image00007.jpg)'
- en: Making things prettier
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使事情更美观
- en: 'Our application is starting to look a little ugly, and it''s time to do something
    about it. In the previous chapter, we implemented the Bootstrap library into our
    login page, and we are now going to extend its use to our chat page. We will make
    three changes in `chat.html` : include Bootstrap and tweak the CSS styles for
    our page, change the markup for our form, and tweak how we render messages on
    the page.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序开始看起来有点丑陋，是时候做点什么了。在上一章中，我们将Bootstrap库引入了我们的登录页面，现在我们将扩展其用途到我们的聊天页面。我们将在`chat.html`中进行三处更改：包括Bootstrap并调整页面的CSS样式，更改我们表单的标记，并调整我们在页面上呈现消息的方式。
- en: 'First, let''s update the `style` tag at the top of the page and insert a `link`
    tag above it to include Bootstrap:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新页面顶部的`style`标签，并在其上插入一个`link`标签以包含Bootstrap：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let''s replace the markup at the top of the `body` tag (before the `script`
    tags) with the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们用以下代码替换`body`标签顶部的标记（在`script`标签之前）：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This markup follows Bootstrap standards of applying appropriate classes to various
    items, for example, the `form-control` class neatly formats elements within `form`
    (you can check out the Bootstrap documentation for more information on what these
    classes do).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标记遵循Bootstrap标准，将适当的类应用于各种项目，例如，`form-control`类可以整洁地格式化`form`中的元素（您可以查看Bootstrap文档，了解这些类的更多信息）。
- en: 'Finally, let''s update our `socket.onmessage` JavaScript code to put the sender''s
    name as the `title` attribute for our image. This makes our app display the image
    when you hover the mouse over it rather than displaying it next to every message:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新我们的`socket.onmessage` JavaScript代码，将发送者的名称作为我们图像的`title`属性。这样，当您将鼠标悬停在图像上时，我们的应用程序将显示图像，而不是在每条消息旁边显示它：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Build and run the application and refresh your browser to see whether a new
    design appears:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，刷新浏览器，看看是否出现新的设计：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command shows the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令显示以下输出：
- en: '![Making things prettier](img/Image00008.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使事情更美观](img/Image00008.jpg)'
- en: With relatively few changes to the code, we have dramatically improved the look
    and feel of our application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行相对较少的更改，我们大大改善了应用程序的外观和感觉。
- en: Implementing Gravatar
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Gravatar
- en: Gravatar is a web service that allows users to upload a single profile picture
    and associate it with their e-mail address to make it available from any website.
    Developers, like us, can access those images for our application, just by performing
    a `GET` operation on a specific API endpoint. In this section, we will see how
    to implement Gravatar rather than use the picture provided by the authentication
    service.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Gravatar是一个网络服务，允许用户上传单个个人资料图片，并将其与其电子邮件地址关联，以便从任何网站获取。像我们这样的开发人员可以通过在特定API端点上执行`GET`操作来访问这些图像，用于我们的应用程序。在本节中，我们将看到如何实现Gravatar，而不是使用认证服务提供的图片。
- en: Abstracting the avatar URL process
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象化头像URL过程
- en: Since we have three different ways of obtaining the avatar URL in our application,
    we have reached the point where it would be sensible to learn how to abstract
    the functionality in order to cleanly implement the options. Abstraction refers
    to a process in which we separate the idea of something from its specific implementation.
    `http.Handler` is a great example of how a handler will be used along with its
    ins and outs, without being specific about what action is taken by each handler.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序有三种不同的获取头像URL的方式，我们已经达到了一个合理的学习如何将功能抽象化以清晰地实现这些选项的点。抽象化是指我们将某物的概念与其具体实现分离的过程。`http.Handler`是一个很好的例子，它展示了如何使用处理程序以及其细节，而不具体说明每个处理程序采取的操作。
- en: 'In Go, we start to describe our idea of getting an avatar URL by defining an
    interface. Let''s create a new file called `avatar.go` and insert the following
    code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，我们开始通过定义一个接口来描述获取头像URL的想法。让我们创建一个名为`avatar.go`的新文件，并插入以下代码：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Avatar` interface describes the `GetAvatarURL` method that a type must
    satisfy in order to be able to get avatar URLs. We took the client as an argument
    so that we know for which user to return the URL. The method returns two arguments:
    a string (which will be the URL if things go well) and an error in case something
    goes wrong.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`接口描述了一个类型必须满足的`GetAvatarURL`方法，以便能够获取头像URL。我们将客户端作为参数，以便知道为哪个用户返回URL。该方法返回两个参数：一个字符串（如果一切顺利，将是URL），以及一个错误，以防出现问题。'
- en: One of the things that could go wrong is simply that one of the specific implementations
    of `Avatar` is unable to get the URL. In that case, `GetAvatarURL` will return
    the `ErrNoAvatarURL` error as the second argument. The `ErrNoAvatarURL` error
    therefore becomes a part of the interface; it's one of the possible returns from
    the method and something that users of our code should probably explicitly handle.
    We mention this in the comments part of the code for the method, which is the
    only way to communicate such design decisions in Go.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出错的一件事是`Avatar`的特定实现之一无法获取URL。在这种情况下，`GetAvatarURL`将作为第二个参数返回`ErrNoAvatarURL`错误。因此，`ErrNoAvatarURL`错误成为接口的一部分；它是该方法可能返回的一个可能值，也是我们代码的用户可能需要明确处理的内容。我们在方法的注释部分提到了这一点，这是在Go中传达这种设计决策的唯一方式。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Because the error is initialized immediately using `errors.New` and stored in
    the `ErrNoAvatarURL` variable, only one of these objects will ever be created;
    passing the pointer of the error as a return is very inexpensive. This is unlike
    Java's checked exceptions—which serve a similar purpose—where expensive exception
    objects are created and used as part of the control flow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为错误是立即使用`errors.New`初始化并存储在`ErrNoAvatarURL`变量中的，所以只会创建一个这样的对象；将错误的指针作为返回传递是非常廉价的。这与Java的检查异常不同，后者用作控制流的一部分时会创建并使用昂贵的异常对象。
- en: The authentication service and avatar's implementation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证服务和头像的实现
- en: 'The first implementation of `Avatar` we write will replace the existing functionality
    where we hardcoded the avatar URL obtained from the authentication service. Let''s
    use a **Test-driven Development** ( **TDD** ) approach so we can be sure our code
    works without having to manually test it. Let''s create a new file called `avatar_test.go`
    in the `chat` folder:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一个`Avatar`实现将替换现有的功能，其中我们硬编码了从认证服务获取的头像URL。让我们使用**测试驱动开发**（**TDD**）的方法，这样我们就可以确保我们的代码可以正常工作，而不必手动测试。让我们在`chat`文件夹中创建一个名为`avatar_test.go`的新文件：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This test file contains a test for our as-of-yet nonexistent `AuthAvatar` type's
    `GetAvatarURL` method. First, it uses a client with no user data and ensures that
    the `ErrNoAvatarURL` error is returned. After setting a suitable value, our test
    calls the method again—this time to assert that it returns the correct value.
    However, building this code fails because the `AuthAvatar` type doesn't exist,
    so we'll declare `authAvatar` next.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试文件包含了我们尚不存在的`AuthAvatar`类型的`GetAvatarURL`方法的测试。首先，它使用一个没有用户数据的客户端，并确保返回`ErrNoAvatarURL`错误。在设置合适的值之后，我们的测试再次调用该方法，这次是为了断言它返回正确的值。然而，构建这段代码失败了，因为`AuthAvatar`类型不存在，所以我们将接下来声明`authAvatar`。
- en: Before we write our implementation, it's worth noticing that we only declare
    the `authAvatar` variable as the `AuthAvatar` type, but never actually assign
    anything to it so its value remains `nil` . This is not a mistake; we are actually
    making use of Go's zero-initialization (or default initialization) capabilities.
    Since there is no state needed for our object (we will pass `client` as an argument),
    there is no need to waste time and memory on initializing an instance of it. In
    Go, it is acceptable to call a method on a `nil` object, provided that the method
    doesn't try to access a field. When we actually come to writing our implementation,
    we will look at a way in which we can ensure this is the case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的实现之前，值得注意的是，我们只声明了`authAvatar`变量作为`AuthAvatar`类型，但实际上从未给它赋值，所以它的值保持为`nil`。这不是一个错误；我们实际上正在利用Go的零初始化（或默认初始化）能力。由于我们的对象不需要状态（我们将`client`作为参数传递），因此没有必要在初始化一个实例上浪费时间和内存。在Go中，可以在`nil`对象上调用方法，前提是该方法不会尝试访问字段。当我们实际编写我们的实现时，我们将考虑一种方法，以确保这种情况成立。
- en: 'Let''s head back over to `avatar.go` and make our test pass. Add the following
    code to the bottom of the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`avatar.go`，让我们的测试通过。在文件底部添加以下代码：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we define our `AuthAvatar` type as an empty struct and define the implementation
    of the `GetAvatarURL` method. We also create a handy variable called `UseAuthAvatar`
    that has the `AuthAvatar` type but which remains of `nil` value. We can later
    assign the `UseAuthAvatar` variable to any field looking for an `Avatar` interface
    type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`AuthAvatar`类型定义为空结构，并定义`GetAvatarURL`方法的实现。我们还创建了一个方便的变量`UseAuthAvatar`，它具有`AuthAvatar`类型，但其值保持为`nil`。我们以后可以将`UseAuthAvatar`变量分配给任何寻找`Avatar`接口类型的字段。
- en: Normally, the receiver of a method (the type defined in parentheses before the
    name) will be assigned to a variable so that it can be accessed in the body of
    the method. Since, in our case, we assume the object can have `nil` value, we
    can use an underscore to tell Go to throw away the reference. This serves as an
    added reminder to ourselves that we should avoid using it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，方法的接收器（在名称之前括号中定义的类型）将被分配给一个变量，以便在方法体中访问它。由于在我们的情况下，我们假设对象可以具有`nil`值，我们可以使用下划线告诉Go丢弃引用。这也作为一个额外的提醒，告诉我们自己应该避免使用它。
- en: 'The body of our implementation is otherwise relatively simple: we are safely
    looking for the value of `avatar_url` and ensuring it is a string before returning
    it. If anything fails along the way, we return the `ErrNoAvatarURL` error as defined
    in the interface.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现主体在其他方面相对简单：我们安全地寻找`avatar_url`的值，并确保它是一个字符串，然后将其返回。如果沿途出现任何问题，我们将返回接口中定义的`ErrNoAvatarURL`错误。
- en: 'Let''s run the tests by opening a terminal and then navigating to the `chat`
    folder and typing the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开终端并导航到`chat`文件夹，然后输入以下内容来运行测试：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All being well, our tests will pass and we will have successfully created our
    first `Avatar` implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的测试将通过，我们将成功创建我们的第一个`Avatar`实现。
- en: Using an implementation
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用一个实现
- en: When we use an implementation, we could refer to either the helper variables
    directly or create our own instance of the interface whenever we need the functionality.
    However, this would defeat the very object of the abstraction. Instead, we use
    the `Avatar` interface type to indicate where we need the capability.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个实现时，我们可以直接引用辅助变量，或者在需要功能时创建自己的接口实例。然而，这样做会违背抽象的初衷。相反，我们使用`Avatar`接口类型来指示我们需要的功能的位置。
- en: 'For our chat application, we will have a single way to obtain an avatar URL
    per chat room. So let''s update the `room` type so it can hold an `Avatar` object.
    In `room.go` , add the following field definition to the type `room struct` :'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的聊天应用程序，我们将有一种方法来获取每个聊天室的头像URL。所以让我们更新`room`类型，使其可以保存一个`Avatar`对象。在`room.go`中，向`room
    struct`类型的字段定义中添加以下内容：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Update the `newRoom` function so we can pass in an `Avatar` implementation
    for use; we will just assign this implementation to the new field when we create
    our `room` instance:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`newRoom`函数，以便我们可以传入一个`Avatar`实现来使用；当我们创建我们的`room`实例时，我们将简单地将这个实现分配给新字段：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Building the project now will highlight the fact that the call to `newRoom`
    in `main.go` is broken because we have not provided an `Avatar` argument; let''s
    update it by passing in our handy `UseAuthAvatar` variable as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建项目将突出显示`main.go`中对`newRoom`的调用是错误的，因为我们没有提供`Avatar`参数；让我们通过传入我们方便的`UseAuthAvatar`变量来更新它：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We didn't have to create an instance of `AuthAvatar` , so no memory was allocated.
    In our case, this doesn't result in great savings (since we only have one room
    for our whole application), but imagine the size of the potential savings if our
    application has thousands of rooms. The way we named the `UseAuthAvatar` variable
    means that the preceding code is very easy to read and it also makes our intention
    obvious.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必创建`AuthAvatar`的实例，因此没有分配内存。在我们的情况下，这并不会带来很大的节省（因为我们的整个应用程序只有一个房间），但是想象一下，如果我们的应用程序有成千上万个房间，潜在的节省规模是多么庞大。我们命名`UseAuthAvatar`变量的方式意味着前面的代码非常容易阅读，也使我们的意图明显。
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Thinking about code readability is important when designing interfaces. Consider
    a method that takes a Boolean input—just passing in true or false hides the real
    meaning if you don''t know the argument names. Consider defining a couple of helper
    constants as in the following short example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口时考虑代码的可读性是很重要的。考虑一个接受布尔输入的方法——如果你不知道参数名称，只传递true或false会隐藏真正的含义。考虑定义一些辅助常量，如以下简短示例中所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Think about which of the following calls to `move` are easier to understand:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下以下对`move`的调用哪一个更容易理解：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All that is left now is to change `client` to use our new `Avatar` interface.
    In `client.go` , update the `read` method as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是将`client`更改为使用我们的新`Avatar`接口。在`client.go`中，更新`read`方法如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are asking the `avatar` instance on `room` to get the avatar URL for
    us instead of extracting it from `userData` ourselves.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求`room`上的`avatar`实例为我们获取头像URL，而不是从`userData`中提取它。
- en: When you build and run the application, you will notice that (although we have
    refactored things a little) the behavior and user experience hasn't changed at
    all. This is because we told our room to use the `AuthAvatar` implementation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建和运行应用程序时，您会注意到（尽管我们稍微重构了一些东西），行为和用户体验根本没有改变。这是因为我们告诉我们的房间使用`AuthAvatar`实现。
- en: Now let's add another implementation to the room.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向房间添加另一个实现。
- en: Gravatar implementation
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gravatar实现
- en: 'The Gravatar implementation in `Avitar` will do the same job as the `AuthAvatar`
    implementation, except it will generate a URL for a profile picture hosted on
    [Gravatar.com](http://Gravatar.com) . Let''s start by adding a test to our `avatar_test.go`
    file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avitar`中的Gravatar实现将执行与`AuthAvatar`实现相同的工作，只是它将生成托管在[Gravatar.com](http://Gravatar.com)上的个人资料图片的URL。让我们首先在`avatar_test.go`文件中添加一个测试：'
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Gravatar uses a hash of the e-mail address to generate a unique ID for each
    profile picture, so we set up a client and ensure `userData` contains an e-mail
    address. Next, we call the same `GetAvatarURL` method, but this time on an object
    that has the `GravatarAvatar` type. We then assert that a correct URL was returned.
    We already know this is the appropriate URL for the specified e-mail address because
    it is listed as an example in the Gravatar documentation—a great strategy to ensure
    our code is doing what it should be.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Gravatar使用电子邮件地址的哈希来生成每个个人资料图片的唯一ID，因此我们设置一个客户端，并确保`userData`包含一个电子邮件地址。接下来，我们调用相同的`GetAvatarURL`方法，但这次是在具有`GravatarAvatar`类型的对象上。然后我们断言返回了正确的URL。我们已经知道这是指定电子邮件地址的适当URL，因为它在Gravatar文档中作为示例列出了，这是确保我们的代码正在执行应该执行的工作的一个很好的策略。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Recall that all the source code for this book is available on GitHub. You can
    save time on building the preceding core by copying and pasting bits and pieces
    from [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    . Hardcoding things such as the base URL is not usually a good idea; we have hardcoded
    throughout the book to make the code snippets easier to read and more obvious,
    but you are welcome to extract them as you go along if you like.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，本书的所有源代码都可以在GitHub上找到。您可以通过从[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)复制和粘贴片段来节省构建前述核心的时间。通常硬编码诸如基本URL之类的东西并不是一个好主意；我们在整本书中都进行了硬编码，以使代码片段更容易阅读和更明显，但是如果您愿意，您可以在进行过程中提取它们。
- en: 'Running these tests (with `go test` ) obviously causes errors because we haven''t
    defined our types yet. Let''s head back to `avatar.go` and add the following code
    while being sure to import the `io` package:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试（使用`go test`）显然会导致错误，因为我们还没有定义我们的类型。让我们回到`avatar.go`，并在确保导入`io`包的情况下添加以下代码：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We used the same pattern as we did for `AuthAvatar` : we have an empty struct,
    a helpful `UseGravatar` variable, and the `GetAvatarURL` method implementation
    itself. In this method, we follow Gravatar''s guidelines to generate an MD5 hash
    from the e-mail address (after we ensured it was lowercase) and append it to the
    hardcoded base URL.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与`AuthAvatar`相同的模式：一个空的结构体，一个有用的`UseGravatar`变量，以及`GetAvatarURL`方法的实现本身。在这个方法中，我们遵循Gravatar的指南，从电子邮件地址生成MD5哈希（在确保它是小写之后），并将其附加到硬编码的基本URL上。
- en: It is very easy to achieve hashing in Go, thanks to the hard work put in by
    the writers of the Go standard library. The `crypto` package has an impressive
    array of cryptography and hashing capabilities—all very easy to use. In our case,
    we create a new `md5` hasher; because the hasher implements the `io.Writer` interface,
    we can use `io.WriteString` to write a string of bytes to it. Calling `Sum` returns
    the current hash for the bytes written.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中很容易实现哈希处理，这要归功于Go标准库的作者们的辛勤工作。`crypto`包具有令人印象深刻的密码学和哈希处理能力——所有这些都非常容易使用。在我们的情况下，我们创建一个新的`md5`哈希处理器；因为哈希处理器实现了`io.Writer`接口，我们可以使用`io.WriteString`向其中写入一串字节。调用`Sum`返回已写入字节的当前哈希值。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might have noticed that we end up hashing the e-mail address every time
    we need the avatar URL. This is pretty inefficient, especially at scale, but we
    should prioritize getting stuff done over optimization. If we need to, we can
    always come back later and change the way this works.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，每次需要头像URL时，我们都会对电子邮件地址进行哈希处理。这在规模上是相当低效的，但我们应该优先考虑完成工作而不是优化。如果需要，我们随时可以回来改变这种工作方式。
- en: 'Running the tests now shows us that our code is working, but we haven''t yet
    included an e-mail address in the `auth` cookie. We do this by locating the code
    where we assign to the `authCookieValue` object in `auth.go` and updating it to
    grab the `Email` value from Gomniauth:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试会显示我们的代码正在工作，但我们还没有在`auth` cookie中包含电子邮件地址。我们通过定位在`auth.go`中为`authCookieValue`对象分配值的代码，并更新它以从Gomniauth获取`Email`值来实现这一点：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final thing we must do is tell our room to use the Gravatar implementation
    instead of the `AuthAvatar` implementation. We do this by calling `newRoom` in
    `main.go` and making the following change:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的最后一件事是告诉我们的房间使用Gravatar实现而不是`AuthAvatar`实现。我们通过在`main.go`中调用`newRoom`并进行以下更改来实现这一点：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Build and run the chat program once again and head to the browser. Remember,
    since we have changed the information stored in the cookie, we must sign out and
    sign back in again in order to see our changes take effect.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行聊天程序，然后转到浏览器。请记住，由于我们已更改cookie中存储的信息，我们必须注销并重新登录，以便看到我们的更改生效。
- en: Assuming you have a different image for your Gravatar account, you will notice
    that the system is now pulling the image from Gravatar instead of the authentication
    provider. Using your browser's inspector or debug tool will show you that the
    `src` attribute of the `img` tag has indeed changed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的Gravatar帐户有不同的图像，您会注意到系统现在从Gravatar而不是认证提供程序中获取图像。使用浏览器的检查器或调试工具将显示`img`标签的`src`属性确实已更改。
- en: '![Gravatar implementation](img/Image00009.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Gravatar implementation](img/Image00009.jpg)'
- en: If you don't have a Gravatar account, you'll likely see a default placeholder
    image in place of your profile picture.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有Gravatar帐户，您可能会看到一个默认的占位图像代替您的个人资料图片。
- en: Uploading an avatar picture
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传头像图片
- en: In the third and final approach of uploading a picture, we will look at how
    to allow users to upload an image from their local hard drive to use as their
    profile picture when chatting. We will need a way to associate a file with a particular
    user to ensure that we associate the right picture with the corresponding messages.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传图片的第三种方法中，我们将看看如何允许用户从本地硬盘上传图像，以便在聊天时用作他们的个人资料图片。我们需要一种方法来将文件与特定用户关联起来，以确保我们将正确的图片与相应的消息关联起来。
- en: User identification
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户识别
- en: In order to uniquely identify our users, we are going to copy Gravatar's approach
    by hashing their e-mail address and using the resulting string as an identifier.
    We will store the user ID in the cookie along with the rest of the user-specific
    data. This will actually have the added benefit of removing from `GravatarAuth`
    the inefficiency associated with continuous hashing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唯一标识我们的用户，我们将复制Gravatar的方法，通过对他们的电子邮件地址进行哈希处理，并使用结果字符串作为标识符。我们将用户ID与其他用户特定数据一起存储在cookie中。这实际上还有一个额外的好处，就是从`GravatarAuth`中删除了与持续哈希处理相关的低效。
- en: 'In `auth.go` , replace the code that creates the `authCookieValue` object with
    the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.go`中，用以下代码替换创建`authCookieValue`对象的代码：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here we have hashed the e-mail address and stored the resulting value in the
    `userid` field at the point at which the user logs in. Henceforth, we can use
    this value in our Gravatar code instead of hashing the e-mail address for every
    message. To do this, first we update the test by removing the following line from
    `avatar_test.go` :'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户登录时，我们对电子邮件地址进行了哈希处理，并将结果值存储在`userid`字段中。从此时起，我们可以在我们的Gravatar代码中使用这个值，而不是为每条消息对电子邮件地址进行哈希处理。为了做到这一点，首先我们通过从`avatar_test.go`中删除以下行来更新测试：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then replace the preceding line with this line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用这行替换前面的行：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We no longer need to set the `email` field since it is not used; instead, we
    just have to set an appropriate value to the new `userid` field. However, if you
    run `go test` in a terminal, you will see this test fail.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要设置`email`字段，因为它没有被使用；相反，我们只需要为新的`userid`字段设置一个合适的值。但是，如果您在终端中运行`go test`，您会看到这个测试失败。
- en: 'To make the test pass, in `avatar.go` , update the `GetAvatarURL` method for
    the `GravatarAuth` type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，在`avatar.go`中，更新`GravatarAuth`类型的`GetAvatarURL`方法：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This won't change the behavior, but it allows us to make an unexpected optimization,
    which is a great example of why you shouldn't optimize code too early—the inefficiencies
    that you spot early on may not last long enough to warrant the effort required
    to fix them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会改变行为，但它允许我们进行意外的优化，这是一个很好的例子，说明为什么不应该过早优化代码——你早期发现的低效可能不值得修复所需的努力。
- en: An upload form
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个上传表单
- en: 'If our users are to upload a file as their avatar, they need a way to browse
    their local hard drive and submit the file to the server. We facilitate this by
    adding a new template-driven page. In the `chat/templates` folder, create a file
    called `upload.html` :'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户要上传文件作为他们的头像，他们需要一种方法来浏览本地硬盘并将文件提交到服务器。我们通过添加一个新的基于模板的页面来实现这一点。在`chat/templates`文件夹中，创建一个名为`upload.html`的文件：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We used Bootstrap again to make our page look nice and also to make it fit in
    with the other pages. However, the key point to note here is the HTML form that
    will provide the user interface necessary for uploading files. The action points
    to `/uploader` , the handler for which we have yet to implement, and the `enctype`
    attribute must be `multipart/form-data` so the browser can transmit binary data
    over HTTP. Then, there is an `input` element of the type `file` , which will contain
    the reference to the file we want to upload. Notice also that we have included
    the `userid` value from the `UserData` map as a hidden input—this will tell us
    which user is uploading a file. It is important that the `name` attributes are
    correct, as this is how we will refer to the data when we implement our handler
    on the server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用Bootstrap使我们的页面看起来漂亮，并且使其与其他页面相匹配。但是，这里需要注意的关键点是HTML表单，它将为上传文件提供必要的用户界面。操作指向
    `/uploader`，我们尚未实现的处理程序，`enctype` 属性必须是 `multipart/form-data`，以便浏览器可以通过HTTP传输二进制数据。然后，有一个
    `file` 类型的 `input` 元素，它将包含我们要上传的文件的引用。还要注意，我们已将 `UserData` 映射中的 `userid` 值作为隐藏输入包含在内
    —— 这将告诉我们哪个用户正在上传文件。重要的是 `name` 属性是正确的，因为这是我们在服务器上实现处理程序时将引用数据的方式。
- en: 'Let''s now map the new template to the `/upload` path in `main.go` :'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将新模板映射到 `main.go` 中的 `/upload` 路径：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Handling the upload
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理上传
- en: When the user clicks on **Upload** after selecting a file, the browser will
    send the data for the file as well as the user ID to `/uploader` , but right now,
    that data doesn't actually go anywhere. We will implement a new `HandlerFunc`
    that is capable of receiving the file, reading the bytes that are streamed through
    the connection, and saving it as a new file on the server. In the `chat` folder,
    let's create a new folder called `avatars` —this is where we will save the avatar
    image files.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在选择文件后点击 **上传** 时，浏览器将发送文件的数据以及用户ID到 `/uploader`，但是现在，这些数据实际上并没有去任何地方。我们将实现一个新的
    `HandlerFunc`，能够接收文件，读取通过连接流传输的字节，并将其保存为服务器上的新文件。在 `chat` 文件夹中，让我们创建一个名为 `avatars`
    的新文件夹 —— 这是我们将保存头像图像文件的地方。
- en: 'Next, create a new file called `upload.go` and insert the following code—make
    sure to add the appropriate package name and imports (which are `ioutils` , `net/http`
    , `io` , and `path` ):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `upload.go` 的新文件，并插入以下代码 —— 确保添加适当的包名和导入（即 `ioutils`，`net/http`，`io`
    和 `path`）。
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, first `uploaderHandler` uses the `FormValue` method on `http.Request`
    to get the user ID that we placed in the hidden input in our HTML form. Then it
    gets an `io.Reader` type capable of reading the uploaded bytes by calling `req.FormFile`
    , which returns three arguments. The first argument represents the file itself
    with the `multipart.File` interface type, which is also an `io.Reader` . The second
    is a `multipart.FileHeader` object that contains metadata about the file, such
    as the filename. And finally, the third argument is an error that we hope will
    have a `nil` value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，首先 `uploaderHandler` 使用 `http.Request` 上的 `FormValue` 方法来获取我们在HTML表单中隐藏输入中放置的用户ID。然后通过调用
    `req.FormFile` 获取一个能够读取上传字节的 `io.Reader` 类型，它返回三个参数。第一个参数表示文件本身，具有 `multipart.File`
    接口类型，也是一个 `io.Reader`。第二个是一个包含有关文件的元数据的 `multipart.FileHeader` 对象，例如文件名。最后，第三个参数是一个我们希望具有
    `nil` 值的错误。
- en: What do we mean when we say that the `multipart.File` interface type is also
    an `io.Reader` ? Well, a quick glance at the documentation at [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    makes it clear that the type is actually just a wrapper interface for a few other
    more general interfaces. This means that a `multipart.File` type can be passed
    to methods that require `io.Reader` , since any object that implements `multipart.File`
    must therefore implement `io.Reader` .
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 `multipart.File` 接口类型也是 `io.Reader` 时，我们是什么意思呢？嗯，快速浏览一下 [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    上的文档，就会清楚地看到该类型实际上只是一些其他更一般接口的包装接口。这意味着 `multipart.File` 类型可以传递给需要 `io.Reader`
    的方法，因为任何实现 `multipart.File` 的对象必须实现 `io.Reader`。
- en: Tip
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Embedding standard library interfaces to describe new concepts is a great way
    to make sure your code works in as many contexts as possible. Similarly, you should
    try to write code that uses the simplest interface type you can find, ideally
    from the standard library. For example, if you wrote a method that needed to read
    the contents of a file, you could ask the user to provide an argument of the type
    `multipart.File` . However, if you ask for `io.Reader` instead, your code will
    become significantly more flexible because any type that has the appropriate `Read`
    method can be passed in, which includes user-defined types too.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入标准库接口来描述新概念是确保代码在尽可能多的上下文中工作的好方法。同样，您应该尝试编写使用尽可能简单的接口类型的代码，理想情况下是来自标准库。例如，如果您编写了一个需要读取文件内容的方法，您可以要求用户提供
    `multipart.File` 类型的参数。但是，如果您要求使用 `io.Reader`，您的代码将变得更加灵活，因为任何具有适当的 `Read` 方法的类型都可以传递进来，这也包括用户定义的类型。
- en: The `ioutil.ReadAll` method will just keep reading from the specified `io.Reader`
    until all of the bytes have been received, so this is where we actually receive
    the stream of bytes from the client. We then use `path.Join` and `path.Ext` to
    build a new filename using `userid` , and copy the extension from the original
    filename that we can get from `multipart.FileHeader` .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioutil.ReadAll` 方法将继续从指定的 `io.Reader` 读取，直到接收到所有字节，因此这是我们实际从客户端接收字节流的地方。然后我们使用
    `path.Join` 和 `path.Ext` 来使用 `userid` 构建一个新的文件名，并从 `multipart.FileHeader` 中获取原始文件名的扩展名。'
- en: We then use the `ioutil.WriteFile` method to create a new file in the `avatars`
    folder. We use `userid` in the filename to associate the image with the correct
    user, much in the same way as Gravatar does. The `0777` value specifies that the
    new file we create has full file permissions, which is a good default setting
    if you're not sure what other permissions should be set.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ioutil.WriteFile`方法在`avatars`文件夹中创建一个新文件。我们在文件名中使用`userid`来将图像与正确的用户关联起来，就像Gravatar一样。`0777`值指定我们创建的新文件具有完整的文件权限，这是一个很好的默认设置，如果您不确定应设置什么其他权限。
- en: If an error occurs at any stage, our code will write it out to the response,
    which will help us debug it, or it will write **Successful** if everything went
    well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何阶段发生错误，我们的代码将将其写入响应，这将帮助我们调试它，或者如果一切顺利，它将写入**成功**。
- en: 'In order to map this new handler function to `/uploader` , we need to head
    back to `main.go` and add the following line to `func main` :'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个新的处理程序函数映射到`/uploader`，我们需要回到`main.go`并在`func main`中添加以下行：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now build and run the application and remember to log out and log back in again
    to give our code a chance to upload the `auth` cookie.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序，并记得注销并重新登录，以便我们的代码有机会上传`auth` cookie。
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open `http://localhost:8080/upload` and click on **Choose File** , then select
    a file from your hard drive and click on **Upload** . Navigate to your `chat/avatars`
    folder and you will notice that the file was indeed uploaded and renamed to the
    value of your `userid` field.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/upload`，单击**选择文件**，然后从硬盘中选择一个文件，然后单击**上传**。转到您的`chat/avatars`文件夹，您会注意到文件确实已上传并重命名为您的`userid`字段的值。
- en: Serving the images
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供图像
- en: 'Now that we have a place to keep our users'' avatar images on the server, we
    need a way to make them accessible to the browser. We do this by using the `net/http`
    package''s built-in file server. In `main.go` , add the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个在服务器上保存用户头像图像的地方，我们需要一种方法使它们可以被浏览器访问。我们通过使用`net/http`包的内置文件服务器来实现这一点。在`main.go`中，添加以下代码：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is actually a single line of code that has been broken up to improve readability.
    The `http.Handle` call should feel familiar: we are specifying that we want to
    map the `/avatars/` path with the specified handler—this is where things get interesting.
    Both `http.StripPrefix` and `http.FileServer` return `Handler` , and they make
    use of the decorator pattern we learned about in the previous chapter. The `StripPrefix`
    function takes `Handler` in, modifies the path by removing the specified prefix,
    and passes functionality onto an inner handler. In our case, the inner handler
    is an `http.FileServer` handler that will simply serve static files, provide index
    listings, and generate the `404 Not Found` error if it cannot find the file. The
    `http.Dir` function allows us to specify which folder we want to expose publicly.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这实际上是一行代码，已经被分解以提高可读性。`http.Handle`调用应该感觉很熟悉：我们正在指定我们要将`/avatars/`路径与指定的处理程序进行映射-这就是有趣的地方。`http.StripPrefix`和`http.FileServer`都返回`Handler`，它们使用我们在上一章中学到的装饰器模式。`StripPrefix`函数接受`Handler`，通过删除指定的前缀修改路径，并将功能传递给内部处理程序。在我们的情况下，内部处理程序是一个`http.FileServer`处理程序，它将简单地提供静态文件，提供索引列表，并在找不到文件时生成`404
    Not Found`错误。`http.Dir`函数允许我们指定要公开的文件夹。
- en: If we didn't strip the `/avatars/` prefix from the requests with `http.StripPrefix`
    , the file server would look for another folder called `avatars` inside the actual
    `avatars` folder, that is, `/avatars/avatars/filename` instead of `/avatars/filename`
    .
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用`http.StripPrefix`从请求中去掉`/avatars/`前缀，文件服务器将在实际`avatars`文件夹内寻找另一个名为`avatars`的文件夹，即`/avatars/avatars/filename`而不是`/avatars/filename`。
- en: Let's build the program and run it before opening `http://localhost:8080/avatars/`
    in a browser. You'll notice that the file server has generated a listing of the
    files inside our `avatars` folder. Clicking on a file will either download the
    file, or in the case of an image, simply display it. If you haven't done so already,
    go to `http://localhost:8080/upload` and upload a picture, then head back to the
    listing page and click on it to see it in the browser.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开浏览器之前，让我们构建程序并运行它`http://localhost:8080/avatars/`。您会注意到文件服务器已经生成了`avatars`文件夹内文件的列表。单击文件将要么下载文件，要么在图像的情况下简单地显示它。如果您还没有这样做，请转到`http://localhost:8080/upload`并上传一张图片，然后返回到列表页面并单击它以在浏览器中查看它。
- en: The Avatar implementation for local files
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地文件的Avatar实现
- en: The final piece to making filesystem avatars work is to write an implementation
    of our `Avatar` interface that generates URLs that point to the filesystem endpoint
    we created in the last section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使文件系统头像工作的最后一步是编写我们的`Avatar`接口的实现，生成指向我们在上一节中创建的文件系统端点的URL。
- en: 'Let''s add a test function to our `avatar_test.go` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`avatar_test.go`文件中添加一个测试函数：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This test is similar to, but slightly more involved than, the `GravatarAvatar`
    test because we are also creating a test file in our `avatars` folder and deleting
    it afterwards.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与`GravatarAvatar`测试类似，但稍微复杂一些，因为我们还在`avatars`文件夹中创建一个测试文件，并在之后将其删除。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `defer` keyword is a great way to ensure the code runs regardless of what
    happens in the rest of the function. Even if our test code panics, the deferred
    functions will still be called.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`关键字是确保代码运行的一个很好的方法，无论在函数的其余部分发生了什么。即使我们的测试代码发生恐慌，延迟函数仍将被调用。'
- en: 'The rest of the test is simple: we set a `userid` field in `client.userData`
    and call `GetAvatarURL` to ensure we get back the right value. Of course, running
    this test will fail, so let''s go and add the following code to make it pass in
    `avatar.go` :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的其余部分很简单：我们在`client.userData`中设置了一个`userid`字段，并调用`GetAvatarURL`以确保我们得到正确的值。当然，运行此测试将失败，所以让我们去添加以下代码以使其在`avatar.go`中通过：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we see here, to generate the correct URL, we simply get the `userid` value
    and build the final string by adding the appropriate segments together. You may
    have noticed that we have hardcoded the file extension to `.jpg` , which means
    that the initial version of our chat application will only support JPEGs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，为了生成正确的URL，我们只需获取`userid`的值，并通过将适当的段连接在一起来构建最终的字符串。您可能已经注意到，我们已经将文件扩展名硬编码为`.jpg`，这意味着我们的聊天应用的初始版本只支持JPEG格式的图片。
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Supporting only JPEGs might seem like a half-baked solution, but following Agile
    methodologies, this is perfectly fine; after all, custom JPEG profile pictures
    are better than no custom profile pictures at all.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只支持JPEG可能看起来像是一个半成品的解决方案，但遵循敏捷方法论，这是完全可以的；毕竟，自定义JPEG个人资料图片总比没有个人资料图片要好。
- en: 'Let''s see our new code in action by updating `main.go` to use our new `Avatar`
    implementation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新`main.go`来查看我们的新代码的运行情况，以使用我们的新的`Avatar`实现：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now build and run the application as usual and go to `http://localhost:8080/upload`
    and use a web form to upload a JPEG image to use as your profile picture. To make
    sure it's working correctly, choose a unique image that isn't your Gravatar picture
    or the image from the authentication service. Once you see the successful message
    after clicking on **Upload** , go to `http://localhost:8080/chat` and post a message.
    You will notice that the application has indeed used the profile picture that
    you uploaded.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像往常一样构建和运行应用程序，然后转到`http://localhost:8080/upload`，使用Web表单上传一个JPEG图像作为您的个人资料图片。为了确保它正常工作，请选择一个不是您Gravatar图片或认证服务图片的独特图片。在点击**上传**后看到成功消息后，转到`http://localhost:8080/chat`并发布一条消息。您会注意到应用程序确实使用了您上传的个人资料图片。
- en: To change your profile picture, go back to the `/upload` page and upload a different
    picture, then jump back to the `/chat` page and post more messages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改您的个人资料图片，请返回到`/upload`页面并上传不同的图片，然后跳转回`/chat`页面并发布更多消息。
- en: Supporting different file types
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持不同的文件类型
- en: To support different file types, we have to make our `GetAvatarURL` method for
    the `FileSystemAvatar` type a little smarter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持不同的文件类型，我们必须让我们的`FileSystemAvatar`类型的`GetAvatarURL`方法变得更加智能。
- en: Instead of just blindly building the string, we will use the very useful `ioutil.ReadDir`
    method to get a listing of the files. The listing also includes directories, so
    we will use the `IsDir` method to determine whether we should skip it or not.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用非常有用的`ioutil.ReadDir`方法来获取文件列表，而不是盲目地构建字符串。列表还包括目录，因此我们将使用`IsDir`方法来确定我们是否应该跳过它。
- en: We will then check to see whether each file starts with the `userid` field (remember
    that we named our files in this way) by a call to `path.Match` . If the filename
    matches the `userid` field, then we have found the file for that user and we return
    the path. If anything goes wrong or if we can't find the file, we return the `ErrNoAvatarURL`
    error as usual.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将检查每个文件是否以`userid`字段开头（记住我们以这种方式命名我们的文件），通过调用`path.Match`来进行检查。如果文件名与`userid`字段匹配，那么我们已经找到了该用户的文件，并返回路径。如果出现任何问题或者我们找不到文件，我们像往常一样返回`ErrNoAvatarURL`错误。
- en: 'Update the appropriate method in `avatar.go` with the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`avatar.go`中的适当方法：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Delete all the files in the `avatar` folder to prevent confusion and rebuild
    the program. This time upload an image of a different type and notice that our
    application has no difficulty handling it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`avatar`文件夹中的所有文件以防混淆，并重新构建程序。这次上传一个不同类型的图像，并注意到我们的应用程序没有任何困难地处理它。
- en: Refactoring and optimizing our code
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构和优化我们的代码
- en: When we look back at how our `Avatar` type is used, you will notice that every
    time someone sends a message, the application makes a call to `GetAvatarURL` .
    In our latest implementation, each time the method is called, we iterate over
    all the files in the `avatars` folder. For a particularly chatty user, this could
    mean that we end up iterating over and over again many times a minute. This is
    an obvious waste of resources and would, at some point very soon, become a scaling
    problem.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾我们的`Avatar`类型的使用方式时，您会注意到每当有人发送消息时，应用程序都会调用`GetAvatarURL`。在我们最新的实现中，每次调用该方法时，我们都会遍历`avatars`文件夹中的所有文件。对于一个特别健谈的用户，这可能意味着我们会在一分钟内多次重复迭代。这显然是一种资源浪费，并且很快就会成为一个扩展问题。
- en: Instead of getting the avatar URL for every message, we will get it only once
    when the user first logs in and cache it in the `auth` cookie. Unfortunately,
    our `Avatar` interface type requires that we pass in a `client` object to the
    `GetAvatarURL` method and we do not have such an object at the point at which
    we are authenticating the user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只在用户首次登录时获取头像URL并将其缓存在`auth` cookie中，而不是为每条消息获取。不幸的是，我们的`Avatar`接口类型要求我们在`GetAvatarURL`方法中传入一个`client`对象，而在我们对用户进行身份验证时并没有这样的对象。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: So did we make a mistake when we designed our `Avatar` interface? While this
    is a natural conclusion to come to, in fact we did the right thing. We designed
    the solution with the best information we had available at the time and therefore
    had a working chat application much sooner than if we'd tried to design for every
    possible future case. Software evolves and almost always changes during the development
    process and will definitely change throughout the lifetime of the code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们设计`Avatar`接口时，我们是否犯了一个错误？虽然这是一个自然的结论，但事实上我们做得很对。我们根据当时可用的最佳信息设计了解决方案，因此比起尝试为每种可能的情况设计，我们更早地拥有了一个可用的聊天应用。软件会在开发过程中演变并几乎总是会发生变化，并且在代码的整个生命周期中肯定会发生变化。
- en: Replacing concrete types with interfaces
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用接口替换具体类型
- en: We have concluded that our `GetAvatarURL` method depends on a type that is not
    available to us at the point we need it, so what would be a good alternative?
    We could pass each required field as a separate argument but this would make our
    interface brittle, since as soon as an `Avatar` implementation needs a new piece
    of information, we'd have to change the method signature. Instead, we will create
    a new type that will encapsulate the information our `Avatar` implementations
    need while conceptually remaining decoupled from our specific case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得出结论，我们的`GetAvatarURL`方法依赖于我们在需要它的时候无法获得的类型，那么有什么好的替代方案呢？我们可以将每个所需的字段作为单独的参数传递，但这将使我们的接口变得脆弱，因为一旦`Avatar`实现需要新的信息，我们就必须更改方法签名。相反，我们将创建一个新类型，封装我们的`Avatar`实现需要的信息，同时在概念上保持与我们的特定情况解耦。
- en: 'In `auth.go` , add the following code to the top of the page (underneath the
    `package` keyword of course):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.go`中，在页面顶部添加以下代码（当然是在`package`关键字下面）：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, the `import` statement imported the `common` package from Gomniauth and
    at the same time gave it a specific name through which it will be accessed: `gomniauthcommon`
    . This isn''t entirely necessary since we have no package name conflicts. However,
    it makes the code easier to understand.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`import`语句从Gomniauth导入了`common`包，并同时为其指定了一个特定的名称，通过该名称可以访问它：`gomniauthcommon`。这并不是完全必要的，因为我们没有包名冲突。但是，这样做可以使代码更容易理解。
- en: 'In the preceding code snippet, we also defined a new interface type called
    `ChatUser` , which exposes the information needed in order for our `Avatar` implementations
    to generate the correct URLs. Then, we defined an actual implementation called
    `chatUser` (notice the lowercase starting letter) that implements the interface.
    It also makes use of a very interesting feature in Go: type embedding. We actually
    embedded the interface type `gomniauth/common.User` , which means that our `struct`
    implements the interface automatically.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们还定义了一个名为`ChatUser`的新接口类型，它公开了我们的`Avatar`实现生成正确URL所需的信息。然后，我们定义了一个名为`chatUser`的实际实现（注意小写字母开头），它实现了该接口。它还利用了Go中一个非常有趣的特性：类型嵌入。我们实际上嵌入了接口类型`gomniauth/common.User`，这意味着我们的`struct`自动实现了该接口。
- en: You may have noticed that we only actually implemented one of the two required
    methods to satisfy our `ChatUser` interface. We got away with this because the
    Gomniauth `User` interface happens to define the same `AvatarURL` method. In practice,
    when we instantiate our `chatUser` struct—provided we set an appropriate value
    for the implied Gomniauth `User` field—our object implements both Gomniauth's
    `User` interface and our own `ChatUser` interface at the same time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们实际上只实现了满足`ChatUser`接口所需的两个方法中的一个。我们之所以能够这样做，是因为Gomniauth的`User`接口碰巧定义了相同的`AvatarURL`方法。实际上，当我们实例化我们的`chatUser`结构时——只要我们为暗示的Gomniauth`User`字段设置适当的值——我们的对象同时实现了Gomniauth的`User`接口和我们自己的`ChatUser`接口。
- en: Changing interfaces in a test-driven way
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以测试驱动的方式更改接口
- en: Before we can use our new type, we must update the `Avatar` interface and appropriate
    implementations to make use of it. As we will follow TDD practices, we are going
    to make these changes in our test file, see compiler errors when we try to build
    our code, and see failing tests once we fix those errors before finally making
    the tests pass.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用新类型之前，我们必须更新`Avatar`接口和适当的实现以利用它。由于我们将遵循TDD实践，我们将在测试文件中进行这些更改，看到我们尝试构建代码时的编译器错误，并在最终使测试通过之前看到失败的测试。
- en: 'Open `avatar_test.go` and replace `TestAuthAvatar` with the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`avatar_test.go`，并用以下代码替换`TestAuthAvatar`：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You will also need to import the `gomniauth/test` package as `gomniauthtest`
    like we did in the last section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要像在上一节中那样将`gomniauth/test`包导入为`gomniauthtest`。
- en: Using our new interface before we have defined it is a good way to check the
    sanity of our thinking, which is another advantage of practicing TDD. In this
    new test, we create `TestUser` provided by Gomniauth and embed it into a `chatUser`
    type. We then pass the new `chatUser` type into our `GetAvatarURL` calls and make
    the same assertions about output as we always have done.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义接口之前就使用我们的新接口是检查我们思路的合理性的好方法，这是练习TDD的另一个优势。在这个新测试中，我们创建了Gomniauth提供的`TestUser`，并将其嵌入到`chatUser`类型中。然后我们将新的`chatUser`类型传递给我们的`GetAvatarURL`调用，并对输出进行了与以往相同的断言。
- en: Tip
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Gomniauth's `TestUser` type is interesting as it makes use of the `Testify`
    package's mocking capabilities. See [https://github.com/stretchr/testify](https://github.com/stretchr/testify)
    for more information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth的`TestUser`类型很有趣，因为它利用了`Testify`包的模拟能力。有关更多信息，请参阅[https://github.com/stretchr/testify](https://github.com/stretchr/testify)。
- en: The `On` and `Return` methods allow us to tell `TestUser` what to do when specific
    methods are called. In the first case, we tell the `AvatarURL` method to return
    the error, and in the second case, we ask it to return the `testUrl` value, which
    simulates the two possible outcomes we are covering in this test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`On`和`Return`方法允许我们告诉`TestUser`在调用特定方法时该做什么。在第一种情况下，我们告诉`AvatarURL`方法返回错误，而在第二种情况下，我们要求它返回`testUrl`值，这模拟了我们在这个测试中涵盖的两种可能结果。'
- en: Updating the `TestGravatarAvatar` and `TestFileSystemAvatar` tests is much simpler
    because they rely only on the `UniqueID` method, the value of which we can control
    directly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`TestGravatarAvatar`和`TestFileSystemAvatar`测试要简单得多，因为它们仅依赖于`UniqueID`方法，其值我们可以直接控制。
- en: 'Replace the other two tests in `avatar_test.go` with the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`avatar_test.go`中的另外两个测试：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Of course, this test code won''t even compile because we are yet to update
    our `Avatar` interface. In `avatar.go` , update the `GetAvatarURL` signature in
    the `Avatar` interface type to take a `ChatUser` type rather than a `client` type:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个测试代码甚至不会编译，因为我们还没有更新我们的`Avatar`接口。在`avatar.go`中，更新`Avatar`接口类型中的`GetAvatarURL`签名，以接受`ChatUser`类型而不是`client`类型：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we are using the `ChatUser` interface (uppercase starting letter)
    rather than our internal `chatUser` implementation struct—after all, we want to
    be flexible about the types our `GetAvatarURL` methods accept.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的是`ChatUser`接口（大写字母开头），而不是我们内部的`chatUser`实现结构——毕竟，我们希望对我们的`GetAvatarURL`方法接受的类型保持灵活。
- en: Trying to build this will reveal that we now have broken implementations because
    all the `GetAvatarURL` methods are still asking for a `client` object.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试构建将会发现我们现在有破损的实现，因为所有的`GetAvatarURL`方法仍在要求一个`client`对象。
- en: Fixing existing implementations
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复现有的实现
- en: Changing an interface like the one we have is a good way to automatically find
    the parts of our code that have been affected because they will cause compiler
    errors. Of course, if we were writing a package that other people would use, we
    would have to be far stricter towards changing the interfaces.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 更改像我们这样的接口是自动查找受影响代码部分的好方法，因为它们会导致编译器错误。当然，如果我们正在编写其他人将使用的包，我们必须对更改接口更加严格。
- en: 'We are now going to update the three implementation signatures to satisfy the
    new interface and change the method bodies to make use of the new type. Replace
    the implementation for `FileSystemAvatar` with the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新三个实现签名以满足新的接口，并更改方法体以使用新类型。用以下内容替换`FileSystemAvatar`的实现：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The key change here is that we no longer access the `userData` field on the
    client, and instead just call `UniqueID` directly on the `ChatUser` interface.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键变化是我们不再访问客户端上的`userData`字段，而是直接在`ChatUser`接口上调用`UniqueID`。
- en: 'Next, we update the `AuthAvatar` implementation with the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码更新`AuthAvatar`的实现：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our new design is proving to be much simpler; it's always a good thing if we
    can reduce the amount of code needed. The preceding code makes a call to get the
    `AvatarURL` value, and provided it isn't empty (or `len(url) > 0` ), we return
    it; else, we return the `ErrNoAvatarURL` error instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新设计正在证明更简单；如果我们能减少所需的代码量，这总是一件好事。上面的代码调用了`AvatarURL`值，并且只要它不为空（或`len(url)
    > 0`），我们就返回它；否则，我们返回`ErrNoAvatarURL`错误。
- en: 'Finally, update the `GravatarAvatar` implementation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`GravatarAvatar`的实现：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Global variables versus fields
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量与字段
- en: 'So far, we have assigned the `Avatar` implementation to the `room` type, which
    enables us to use different avatars for different rooms. However, this has exposed
    an issue: when our users sign in, there is no concept of which room they are headed
    to so we cannot know which `Avatar` implementation to use. Because our application
    only supports a single room, we are going to look at another approach toward selecting
    implementations: the use of global variables.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将`Avatar`实现分配给了`room`类型，这使我们可以为不同的房间使用不同的头像。然而，这暴露了一个问题：当用户登录时，我们不知道他们要去哪个房间，所以我们无法知道要使用哪种`Avatar`实现。因为我们的应用程序只支持一个房间，我们将考虑另一种选择实现的方法：使用全局变量。
- en: 'A global variable is simply a variable that is defined outside any type definition
    and is accessible from every part of the package (and from outside the package
    if it''s exported). For a simple configuration, such as which type of `Avatar`
    implementation to use, they are an easy and simple solution. Underneath the `import`
    statements in `main.go` , add the following line:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量就是在任何类型定义之外定义的变量，并且可以从包的任何部分访问（如果它被导出，则还可以从包外部访问）。对于简单的配置，比如使用哪种“Avatar”实现，它们是一个简单易行的解决方案。在`main.go`的`import`语句下面，添加以下行：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This defines `avatars` as a global variable that we can use when we need to
    get the avatar URL for a particular user.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`avatars`作为一个全局变量，当我们需要获取特定用户的头像URL时可以使用它。
- en: Implementing our new design
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现我们的新设计
- en: 'We need to change the code that calls `GetAvatarURL` for every message to just
    access the value that we put into the `userData` cache (via the `auth` cookie).
    Change the line where `msg.AvatarURL` is assigned, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改调用`GetAvatarURL`的代码，以便只访问我们放入`userData`缓存中的值（通过`auth` cookie）。更改分配`msg.AvatarURL`的行，如下所示：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Find the code inside `loginHandler` in `auth.go` where we call `provider.GetUser`
    and replace it down to where we set the `authCookieValue` object with the following
    code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.go`的`loginHandler`中找到我们调用`provider.GetUser`的代码，并将其替换为设置`authCookieValue`对象的代码：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we created a new `chatUser` variable while setting the `User` field (which
    represents the embedded interface) to the `User` value returned from Gomniauth.
    We then saved the `userid` MD5 hash to the `uniqueID` field.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在设置`User`字段（表示嵌入接口）为从Gomniauth返回的`User`值时创建了一个新的`chatUser`变量。然后我们将`userid`的MD5哈希保存到`uniqueID`字段中。
- en: 'The call to `avatars.GetAvatarURL` is where all of our hard work has paid off,
    as we now get the avatar URL for the user far earlier in the process. Update the
    `authCookieValue` line in `auth.go` to cache the avatar URL in the cookie and
    remove the e-mail address since it is no longer needed:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`avatars.GetAvatarURL`是我们辛苦工作的成果，因为现在我们在流程中更早地获取了用户的头像URL。在`auth.go`中更新`authCookieValue`行，将头像URL缓存在cookie中，并删除电子邮件地址，因为它不再需要：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: However expensive the work that the `Avatar` implementation needs to do, like
    iterating over files on the filesystem, it is mitigated by the fact that the implementation
    only does so when the user first logs in, and not every time they send a message.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Avatar`实现需要做什么工作，比如在文件系统上迭代文件，都会因为实现只在用户首次登录时执行，而不是每次发送消息时执行而得到缓解。
- en: Tidying up and testing
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整理和测试
- en: Finally, we get to snip away some of the fat that has accumulated during our
    refactoring process.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于可以剪掉在重构过程中积累的一些废料。
- en: 'Since we no longer store the `Avatar` implementation in `room` , let''s remove
    the field and all references to it from the type. In `room.go` , delete the `avatar
    Avatar` definition from the `room` struct and update the `newRoom` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再将`Avatar`实现存储在`room`中，让我们从类型中删除该字段以及所有对它的引用。在`room.go`中，从`room`结构中删除`avatar
    Avatar`的定义，并更新`newRoom`方法：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to use the compiler as your to-do list where possible, and follow the
    errors to find where you have impacted other code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 记住尽可能使用编译器作为待办事项列表，并跟随错误找出你影响其他代码的地方。
- en: In `main.go` , remove the parameter passed into the `newRoom` function call
    since we are using our global variable instead of this one.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中，删除传递给`newRoom`函数调用的参数，因为我们使用全局变量而不是这个。
- en: After this exercise, the end user experience remains unchanged. Usually, when
    refactoring the code, it is the internals that are modified while the public-facing
    interface remains stable and unchanged.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习之后，最终用户体验保持不变。通常，在重构代码时，修改的是内部结构，而公共接口保持稳定和不变。
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's usually a good idea to run tools such as `golint` and `go vet` against
    your code as well to make sure it follows good practices and doesn't contain any
    Go faux pas such as missing comments or badly named functions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，运行诸如`golint`和`go vet`之类的工具对你的代码进行检查是一个好主意，以确保它遵循良好的实践，并且不包含任何Go的错误，比如缺少注释或命名不当的函数。
- en: Combining all three implementations
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并所有三种实现
- en: To close this chapter off with a bang, we will implement a mechanism in which
    each `Avatar` implementation takes a turn in trying to get the value. If the first
    implementation returns the `ErrNoAvatarURL` error, we will try the next and so
    on until we find a useable value.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以一个轰轰烈烈的方式结束这一章，我们将实现一个机制，其中每个`Avatar`实现轮流尝试获取值。如果第一个实现返回`ErrNoAvatarURL`错误，我们将尝试下一个，依此类推，直到找到可用的值。
- en: 'In `avatar.go` , underneath the `Avatar` type, add the following type definition:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在`avatar.go`中，在`Avatar`类型下面，添加以下类型定义：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `TryAvatars` type is simply a slice of `Avatar` objects; therefore, we
    will add the following `GetAvatarURL` method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryAvatars`类型只是`Avatar`对象的一个切片；因此，我们将添加以下`GetAvatarURL`方法：'
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This means that `TryAvatars` is now a valid `Avatar` implementation and can
    be used in place of any specific implementation. In the preceding method, we iterated
    over the slice of `Avatar` objects in an order, calling `GetAvatarURL` for each
    one. If no error is returned, we return the URL; otherwise, we carry on looking.
    Finally, if we are unable to find a value, we just return `ErrNoAvatarURL` as
    per the interface design.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`TryAvatars`现在是一个有效的`Avatar`实现，并且可以用来替代任何特定的实现。在前面的方法中，我们按顺序迭代`Avatar`对象的切片，为每个对象调用`GetAvatarURL`。如果没有返回错误，我们返回URL；否则，我们继续寻找。最后，如果我们无法找到一个值，我们只需根据接口设计返回`ErrNoAvatarURL`。
- en: 'Update the `avatars` global variable in `main.go` to use our new implementation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中更新`avatars`全局变量以使用我们的新实现：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here we created a new instance of our `TryAvatars` slice type while putting
    the other `Avatar` implementations inside it. The order matters since it iterates
    over the objects in the order in which they appear in the slice. So, first our
    code will check to see whether the user has uploaded a picture; if they haven't,
    the code will check whether the authentication service has a picture for us to
    use. If both the approaches fail, a Gravatar URL will be generated, which in the
    worst case (for example, if the user hasn't added a Gravatar picture), will render
    a default placeholder image.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`TryAvatars`切片类型的实例，同时将其他`Avatar`实现放在其中。顺序很重要，因为它按照它们在切片中出现的顺序对对象进行迭代。因此，首先我们的代码将检查用户是否上传了图片；如果没有，代码将检查认证服务是否有图片供我们使用。如果这两种方法都失败，将生成一个Gravatar
    URL，在最坏的情况下（例如，如果用户没有添加Gravatar图片），将呈现一个默认的占位图像。
- en: 'To see our new functionality in action, perform the following steps:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们的新功能的运行情况，请执行以下步骤：
- en: 'Build and rerun the application:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并重新运行应用程序：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Log out by visiting `http://localhost:8080/logout` .
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问`http://localhost:8080/logout`注销。
- en: Delete all the pictures from the `avatars` folder.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`avatars`文件夹中删除所有图片。
- en: Log back in by navigating to `http://localhost:8080/chat` .
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到`http://localhost:8080/chat`重新登录。
- en: Send some messages and take note of your profile picture.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一些消息并注意你的个人资料图片。
- en: Visit `http://localhost:8080/upload` and upload a new profile picture.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`http://localhost:8080/upload`并上传新的个人资料图片。
- en: Log out again and log back in as before.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次注销，然后像以前一样登录。
- en: Send some more messages and notice that your profile picture has updated.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一些消息并注意你的个人资料图片已更新。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added three different implementations of profile pictures
    to our chat application. First we asked the authentication service to provide
    a URL for us to use. We did this by using Gomniauth's abstraction of the user
    resource data, which we then included as part of the user interface every time
    a user would send a message. Using Go's zero (or default) initialization pattern,
    we were able to refer to different implementations of our `Avatar` interface without
    actually creating any instances.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的聊天应用程序添加了三种不同的个人资料图片实现。首先，我们要求认证服务为我们提供一个URL来使用。我们通过使用Gomniauth对用户资源数据的抽象来实现这一点，然后将其作为用户界面的一部分包含在每次用户发送消息时。使用Go的零（或默认）初始化模式，我们能够引用`Avatar`接口的不同实现而不实际创建任何实例。
- en: We stored data in a cookie for when the user would log in. Therefore, and also
    given the fact that cookies persist between builds of our code, we added a handy
    logout feature to help us validate our changes, which we also exposed to our users
    so that they could log out too. Other small changes to the code and the inclusion
    of Bootstrap on our chat page dramatically improved the look and feel of our application.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在用户登录时将数据存储在cookie中。因此，还有一个事实是，由于cookie在我们的代码构建之间保持持久性，我们添加了一个方便的注销功能来帮助我们验证我们的更改，我们还向用户公开了这个功能，以便他们也可以注销。对代码进行其他小的更改，并在我们的聊天页面上包含Bootstrap，大大改善了我们应用程序的外观和感觉。
- en: We used MD5 hashing in Go to implement the [Gravatar.com](http://Gravatar.com)
    API by hashing the e-mail address that the authentication service provided. If
    the e-mail address is not known to Gravatar, they will deliver a nice default
    placeholder image for us, which means our user interface will never be broken
    due to missing images.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Go中使用MD5哈希来实现[Gravatar.com](http://Gravatar.com) API，通过对认证服务提供的电子邮件地址进行哈希处理。如果Gravatar不知道电子邮件地址，他们会为我们提供一个漂亮的默认占位图像，这意味着我们的用户界面永远不会因缺少图像而出现问题。
- en: We then built and completed an upload form and associated the server functionality
    that saved uploaded pictures in the `avatars` folder. We saw how to expose the
    saved uploaded pictures to users via the standard library's `http.FileServer`
    handler. As this introduced inefficiencies in our design by causing too much filesystem
    access, we refactored our solution with the help of our unit tests. By moving
    the `GetAvatarURL` call to the point at which users log in, rather than every
    time a message is sent, we made our code significantly more scalable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建并完成了一个上传表单，并关联了保存上传图片的服务器功能到`avatars`文件夹。我们看到如何通过标准库的`http.FileServer`处理程序向用户公开保存的上传图片。由于这在我们的设计中引入了效率低下的问题，导致了过多的文件系统访问，我们通过单元测试的帮助重构了我们的解决方案。通过将`GetAvatarURL`调用移动到用户登录时而不是每次发送消息时，我们使我们的代码显著提高了可扩展性。
- en: Our special `ErrNoAvatarURL` error type was used as part of our interface design
    to allow us to inform the calling code when it was not possible to obtain an appropriate
    URL—this became particularly useful when we created our `Avatars` slice type.
    By implementing the `Avatar` interface on a slice of `Avatar` types, we were able
    to make a new implementation that took turns trying to get a valid URL from each
    of the different options available, starting with the filesystem, then the authentication
    service, and finally Gravatar. We achieved this with zero impact on how the user
    would interact with the interface. If an implementation returned `ErrNoAvatarURL`
    , we tried the next one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特殊的`ErrNoAvatarURL`错误类型被用作接口设计的一部分，以便在无法获取适当的URL时通知调用代码——当我们创建`Avatars`切片类型时，这变得特别有用。通过在一系列`Avatar`类型上实现`Avatar`接口，我们能够创建一个新的实现，轮流尝试从每个可用选项中获取有效的URL，首先是文件系统，然后是认证服务，最后是Gravatar。我们实现了这一点，而用户与接口交互的方式完全没有受到影响。如果一个实现返回`ErrNoAvatarURL`，我们就尝试下一个。
- en: Our chat application is ready to go live so we can invite our friends and have
    a real conversation. But first we need to choose a domain name to host it at,
    something we will look at in the next chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用已经准备好上线，这样我们就可以邀请朋友进行真正的对话。但首先，我们需要选择一个域名来托管它，这是我们将在下一章中讨论的事情。
