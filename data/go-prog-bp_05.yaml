- en: Chapter 5. Building Distributed Systems and Working with Flexible Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。构建分布式系统并使用灵活数据
- en: In this chapter, we will explore transferrable skills that allow us to use schemaless
    data and distributed technologies to solve big data problems. The system we will
    build in this chapter will prepare us for a future where democratic elections
    all happen online—on Twitter of course. Our solution will collect and count votes
    by querying Twitter's streaming API for mentions of specific hashtags, and each
    component will be capable of horizontally scaling to meet demand. Our use case
    is a fun and interesting one, but the core concepts we'll learn and specific technology
    choices we'll make are the real focus of this chapter. The ideas discussed here
    are directly applicable to any system that needs true-scale capabilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可转移的技能，使我们能够使用无模式数据和分布式技术来解决大数据问题。本章中我们将构建的系统将为我们准备一个未来，在那里民主选举都将在线进行——当然是在Twitter上。我们的解决方案将通过查询Twitter的流API来收集和计算投票特定标签的提及，并且每个组件都能够水平扩展以满足需求。我们的用例是有趣而有趣的，但我们将学习的核心概念和我们将做出的具体技术选择是本章的真正重点。这里讨论的思想直接适用于任何需要真正规模能力的系统。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Horizontal scaling refers to adding nodes, such as physical machines, to a system
    in order to improve its availability, performance, and/or capacity. Big data companies
    such as Google can scale by adding affordable and easy-to-obtain hardware (commonly
    referred to as commodity hardware) due to the way they write their software and
    architect their solutions. Vertical scaling is synonymous with increasing the
    resource available to a single node, such as adding additional RAM to a box, or
    a processor with more cores.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展是指向系统添加节点，如物理机器，以改善其可用性、性能和/或容量。谷歌等大数据公司可以通过添加廉价且易获得的硬件（通常称为商品硬件）来扩展，因为他们编写软件和设计解决方案的方式。垂直扩展意味着增加单个节点的可用资源，例如向盒子添加额外的RAM，或者具有更多内核的处理器。
- en: 'In this chapter, you will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将：
- en: Learn about distributed NoSQL datastores; specifically how to interact with
    MongoDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解分布式NoSQL数据存储；特别是如何与MongoDB交互
- en: Learn about distributed messaging queues; specifically Bit.ly's NSQ and how
    to use the `go-nsq` package to easily publish and subscribe to events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解分布式消息队列；特别是Bit.ly的NSQ以及如何使用`go-nsq`包轻松发布和订阅事件
- en: Stream live tweet data through Twitter's streaming APIs and manage long running
    net connections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Twitter的流API流式传输实时推文数据并管理长时间运行的网络连接
- en: Learn about how to properly stop programs with many internal goroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何正确停止具有许多内部goroutine的程序
- en: Learn how to use low memory channels for signaling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用低内存通道进行信令
- en: System design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统设计
- en: Having a basic design sketched out is often useful, especially in distributed
    systems where many components will be communicating with each other in different
    ways. We don't want to spend too long on this stage because our design is likely
    to evolve as we get stuck into the details, but we will look at a high-level outline
    so we can discuss the constituents and how they fit together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个基本的设计草图通常是有用的，特别是在分布式系统中，许多组件将以不同的方式相互通信。我们不希望在这个阶段花费太长时间，因为我们的设计可能会随着我们深入细节而发展，但我们将看一下高层次的概述，以便我们可以讨论组成部分以及它们如何相互配合。
- en: '![System design](img/Image00011.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![系统设计](img/Image00011.jpg)'
- en: 'The preceding image shows the basic overview of the system we are going to
    build:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图片显示了我们将要构建的系统的基本概述：
- en: Twitter is the social media network we all know and love.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter是我们都熟悉和喜爱的社交媒体网络。
- en: Twitter's streaming API allows long-running connections where tweet data is
    streamed as quickly as possible.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter的流API允许长时间运行的连接，其中推文数据尽可能快地流式传输。
- en: '`twittervotes` is a program we will write that reads tweets and pushes the
    votes into the messaging queue. `twittervotes` pulls the relevant tweet data,
    figures out what is being voted for (or rather, which options are mentioned),
    and pushes the vote into NSQ.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twittervotes`是我们将编写的一个程序，它读取推文并将投票推送到消息队列中。`twittervotes`获取相关的推文数据，找出正在投票的内容（或者说，提到了哪些选项），并将投票推送到NSQ中。'
- en: NSQ is an open source, real-time distributed messaging platform designed to
    operate at scale, built and maintained by Bit.ly. NSQ carries the message across
    its instances making it available to anyone who has expressed an interest in the
    vote data.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSQ是一个开源的、实时的分布式消息平台，旨在大规模运行，由Bit.ly构建和维护。NSQ在其实例之间传递消息，使其对任何对选举数据表示兴趣的人都可用。
- en: '`counter` is a program we will write that listens out for votes on the messaging
    queue, and periodically saves the results in the MongoDB database. `counter` receives
    the vote messages from NSQ and keeps an in-memory tally of the results, periodically
    pushing an update to persist the data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter`是我们将编写的一个程序，它监听消息队列上的投票，并定期将结果保存在MongoDB数据库中。`counter`从NSQ接收投票消息，并在内存中定期计算结果，定期推送更新以持久化数据。'
- en: MongoDB is an open source document database designed to operate at scale.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB是一个设计用于大规模运行的开源文档数据库。
- en: '`web` is a web server program that will expose the live results that we will
    write in the next chapter.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web`是一个Web服务器程序，将在下一章中公开我们将编写的实时结果。'
- en: It could be argued that a single Go program could be written that reads the
    tweets, counts the votes, and pushes them to a user interface but such a solution,
    while being a great proof of concept, would be very limited in scale. In our design,
    any one of the components can be horizontally scaled as the demand for that particular
    capability increases. If we have relatively few polls, but lots of people viewing
    the data, we can keep the `twittervotes` and `counter` instances down and add
    more `web` and MongoDB nodes, or vice versa if the situation is reversed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，可以编写一个单个的Go程序来读取推文，计算投票并将它们推送到用户界面，但是这样的解决方案，虽然是一个很好的概念验证，但在规模上非常有限。在我们的设计中，任何一个组件都可以在特定能力的需求增加时进行水平扩展。如果我们有相对较少的投票，但有很多人查看数据，我们可以保持`twittervotes`和`counter`实例不变，并添加更多的`web`和MongoDB节点，或者反之亦然。
- en: Another key advantage to our design is redundancy; since we can have many instances
    of our components working at the same time, if one of our boxes disappears (due
    to a system crash or power cut, for example) the others can pick up the slack.
    Modern architectures often distribute such a system over the geographical expanse
    to protect from local natural disasters too. All of these options are available
    to use if we build our solution in this way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的另一个关键优势是冗余；因为我们可以同时拥有许多组件的实例在工作，如果其中一个箱子消失了（例如由于系统崩溃或断电），其他箱子可以接管工作。现代架构通常会将这样的系统分布在地理范围内，以防止本地自然灾害。如果我们以这种方式构建我们的解决方案，所有这些选项都是可用的。
- en: We chose the specific technologies in this chapter because of their links to
    Go (NSQ, for example, is written entirely in Go), and the availability of well-tested
    drivers and packages. Conceptually, however, you can drop in a variety of alternatives
    as you see fit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择本章中的特定技术，是因为它们与Go的关联（例如，NSQ完全使用Go编写），以及有经过充分测试的驱动程序和软件包可用。然而，从概念上讲，您可以根据需要选择各种替代方案。
- en: Database design
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库设计
- en: 'We will call our MongoDB database `ballots` . It will contain a single collection
    called `polls` which is where we will store the poll details, such as the title,
    the options, and the results (in a single JSON document). The code for a poll
    will look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称我们的MongoDB数据库为`ballots`。它将包含一个名为`polls`的单个集合，这是我们将存储投票详细信息的地方，例如标题、选项和结果（在一个JSON文档中）。投票的代码将如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `_id` field is automatically generated by MongoDB and will be how we identify
    each poll. The `options` field contains an array of string options; these are
    the hashtags we will look for on Twitter. The `results` field is a map where the
    key represents the option, and the value represents the total number of votes
    for each item.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`_id`字段是由MongoDB自动生成的，将是我们标识每个投票的方式。`options`字段包含一个字符串选项数组；这些是我们将在Twitter上寻找的标签。`results`字段是一个映射，其中键表示选项，值表示每个项目的总投票数。'
- en: Installing the environment
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装环境
- en: The code we write in this chapter has real external dependencies that we need
    to get set up before we can start to build our system.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中编写的代码具有真正的外部依赖关系，我们需要在开始构建系统之前设置这些依赖关系。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure to check out the chapter notes at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    if you get stuck on installing any of the dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在安装任何依赖项时遇到困难，请务必查看[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)上的章节注释。
- en: In most cases, services such as `mongod` and `nsqd` will have to be started
    before we can run our programs. Since we are writing components of a distributed
    system, we will have to run each program at the same time, which is as simple
    as opening many terminal windows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，诸如`mongod`和`nsqd`之类的服务在我们运行程序之前必须启动。由于我们正在编写分布式系统的组件，我们将不得不同时运行每个程序，这就像打开许多终端窗口一样简单。
- en: NSQ
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSQ
- en: NSQ is a messaging queue that allows one program to send messages or events
    to another, or to many other programs running either locally on the same machine,
    or on different nodes connected by a network. NSQ guarantees the delivery of messages,
    which means it keeps undelivered messages cached until all interested parties
    have received them. This means that, even if we stop our `counter` program, we
    won't miss any votes. You can contrast this capability with fire-and-forget message
    queues where information is deemed out-of-date, and therefore is forgotten if
    it isn't delivered in time, and where the sender of the messages doesn't care
    if the consumer received them or not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ是一个消息队列，允许一个程序向另一个程序发送消息或事件，或者向通过网络连接的不同节点上运行的许多其他程序发送消息。NSQ保证消息的传递，这意味着它会将未传递的消息缓存，直到所有感兴趣的方收到它们。这意味着，即使我们停止`counter`程序，我们也不会错过任何投票。您可以将此功能与“发送并忘记”消息队列进行对比，其中信息被视为过时，因此如果在规定时间内未传递，则被遗忘，并且发送消息的人不关心消费者是否收到它们。
- en: A message queue abstraction allows you to have different components of a system
    running in different places, provided they have network connectivity to the queue.
    Your programs are decoupled from others; instead, your designs start to care about
    the ins and outs of specialized micro-services, rather than the flow of data through
    a monolithic program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列抽象允许您在不同的位置运行系统的不同组件，只要它们与队列有网络连接。您的程序与其他程序解耦；相反，您的设计开始关心专门的微服务的细节，而不是数据通过单片程序的流动。
- en: NSQ transfers raw bytes, which means it is up to us how we encode data into
    those bytes. For example, we could encode the data as JSON or in a binary format
    depending on our needs. In our case, we are going to send the vote option as a
    string without any additional encoding, since we are only sharing a single data
    field.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ传输原始字节，这意味着我们可以自行决定如何将数据编码为这些字节。例如，根据我们的需求，我们可以将数据编码为JSON或二进制格式。在我们的情况下，我们将投票选项作为字符串发送，而不需要任何额外的编码，因为我们只共享一个数据字段。
- en: 'Open [http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)
    in a browser (or search `install nsq` ) and follow the instructions for your environment.
    You can either download pre-compiled binaries or build your own from the source.
    If you have homebrew installed, installing NSQ is as simple as typing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开[http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)（或搜索`install
    nsq`）并按照您的环境的说明进行操作。您可以下载预编译的二进制文件，也可以从源代码构建自己的。如果您已经安装了homebrew，安装NSQ就像输入以下命令一样简单：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you have installed NSQ, you will need to add the `bin` folder to your `PATH`
    environment variable so that the tools are available in a terminal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装NSQ后，您需要将`bin`文件夹添加到您的`PATH`环境变量中，以便在终端中使用这些工具。
- en: 'To validate that NSQ is properly installed, open a terminal and run `nsqlookupd`
    ; if the program successfully starts, you should see some output similar to the
    following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证NSQ是否正确安装，打开一个终端并运行`nsqlookupd`；如果程序成功启动，您应该会看到类似以下的一些输出：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are going to use the default ports to interact with NSQ so take note of the
    TCP and HTTP ports listed in the output, as we will be referring to them in our
    code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用默认端口与NSQ进行交互，所以请注意输出中列出的TCP和HTTP端口，因为我们将在我们的代码中引用它们。
- en: Press *Ctrl* + *C* to stop the process for now; we'll start them properly later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*暂停进程；稍后我们会正确启动它们。
- en: The key tools from the NSQ install that we are going to use are `nsqlookupd`
    and `nsqd` . The `nsqlookupd` program is a daemon that manages topology information
    about the distributed NSQ environment; it keeps track of all the `nsqd` producers
    for specific topics and provides interfaces for clients to query such information.
    The `nsqd` program is a daemon that does the heavy lifting for NSQ such as receiving,
    queuing, and delivering messages from and to interested parties. For more information
    and background on NSQ, visit [http://nsq.io/](http://nsq.io/) .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用NSQ安装中的关键工具`nsqlookupd`和`nsqd`。`nsqlookupd`程序是一个管理分布式NSQ环境的拓扑信息的守护进程；它跟踪特定主题的所有`nsqd`生产者，并为客户端提供查询此类信息的接口。`nsqd`程序是一个守护进程，负责NSQ的重要工作，如接收、排队和传递来自和到感兴趣的各方的消息。有关NSQ的更多信息和背景，请访问[http://nsq.io/](http://nsq.io/)。
- en: NSQ driver for Go
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go的NSQ驱动程序
- en: 'The NSQ tools themselves are written in Go, so it is logical that the Bit.ly
    team already has a Go package that makes interacting with NSQ very easy. We will
    need to use it, so in a terminal, get it using `go get` :'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ工具本身是用Go编写的，因此Bit.ly团队已经有一个使与NSQ交互非常容易的Go包。我们需要使用它，所以在终端中使用`go get`获取它：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: MongoDB
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: 'MongoDB is a document database, which basically allows you to store and query
    JSON documents and the data within them. Each document goes into a collection
    that can be used to group the documents together without enforcing any schema
    on the data inside them. Unlike rows in a traditional RDBMS such as Oracle, Microsoft
    SQL Server, or MySQL, it is perfectly acceptable for documents to have a different
    shape. For example, a `people` collection can contain the following three JSON
    documents at the same time:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个文档数据库，基本上允许您存储和查询JSON文档及其中的数据。每个文档都进入一个集合，可以用来将文档组合在一起，而不对其中的数据强制执行任何模式。与传统的Oracle、Microsoft
    SQL Server或MySQL中的行不同，文档可以具有不同的结构是完全可以接受的。例如，一个`people`集合可以同时包含以下三个JSON文档：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This flexibility allows data with varying structure to coexist without impacting
    performance or wasting space. It is also extremely useful if you expect your software
    to evolve over time, as we really always should.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性使得具有不同结构的数据可以共存，而不会影响性能或浪费空间。如果您期望软件随着时间的推移而发展，这也非常有用，因为我们确实应该这样做。
- en: MongoDB was designed to scale while also remaining very easy to work with on
    single-box install such as our development machine. When we host our application
    for production, we would likely install a more complex multi-sharded, replicated
    system, which is distributed across many nodes and locations, but for now, just
    running `mongod` will do.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB被设计为可以扩展，同时在单机安装上也非常易于操作，比如我们的开发机。当我们将应用程序托管到生产环境时，我们可能会安装一个更复杂的多分片、复制系统，分布在许多节点和位置，但现在，只需运行`mongod`即可。
- en: Head over to [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)
    to grab the latest version of MongoDB and install it, making sure to register
    the `bin` folder with your `PATH` environment variable as usual.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)下载最新版本的MongoDB并安装它，确保像往常一样将`bin`文件夹注册到您的`PATH`环境变量中。
- en: To validate that MongoDB is successfully installed, run the `mongod` command,
    then hit *Ctrl* + *C* to stop it for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证MongoDB是否成功安装，运行`mongod`命令，然后按下*Ctrl* + *C*暂停它。
- en: MongoDB driver for Go
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go的MongoDB驱动程序
- en: 'Gustavo Niemeyer has done a great job in simplifying interactions with MongoDB
    with his `mgo` (pronounced "mango") package hosted at [http://labix.org/mgo](http://labix.org/mgo)
    , which is *go gettable* with the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Gustavo Niemeyer通过他在[http://labix.org/mgo](http://labix.org/mgo)托管的`mgo`（发音为"mango"）包，大大简化了与MongoDB的交互，这个包是可以通过以下命令*go
    gettable*的：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Starting the environment
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动环境
- en: 'Now that we have all the pieces we need installed, we need to start our environment.
    In this section, we are going to:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了所有需要的部件，我们需要启动我们的环境。在本节中，我们将：
- en: Start `nsqlookupd` so that our `nsqd` instances are discoverable
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动`nsqlookupd`以便我们的`nsqd`实例可以被发现
- en: Start `nsqd` and tell it which `nsqlookupd` to use
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动`nsqd`并告诉它要使用哪个`nsqlookupd`
- en: Start `mongod` for data services
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动`mongod`进行数据服务
- en: Each of these daemons should run in their own terminal window, which will make
    it easy for us to stop them by just hitting *Ctrl* + *C* .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些守护进程中的每一个都应该在自己的终端窗口中运行，这样我们就可以通过按下*Ctrl* + *C*来轻松停止它们。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember the page number for this section as you will likely revisit it a few
    times as you work through this chapter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一节的页码，因为在您阅读本章时，您可能会多次回顾它。
- en: 'In a terminal window, run:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端窗口中运行：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take note of the TCP port, which by default is `4160` , and in another terminal
    window, run:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意TCP端口，默认为`4160`，然后在另一个终端窗口中运行：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure the port number in the `--lookupd-tcp-address` flag matches the TCP
    port of the `nsqlookupd` instance. Once you start `nsqd` , you will notice some
    output is printed to the terminal from both `nsqlookupd` and `nsqd` ; this indicates
    that the two processes are talking to each other.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`--lookupd-tcp-address`标志中的端口号与`nsqlookupd`实例的TCP端口匹配。一旦启动`nsqd`，您将注意到一些输出会从`nsqlookupd`和`nsqd`的终端打印出来；这表明这两个进程正在互相通信。
- en: 'In yet another window or tab, start MongoDB by running:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口或选项卡中，通过运行启动MongoDB：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `dbpath` flag tells MongoDB where to store the data files for our database.
    You can pick any location you like, but you'll have to make sure the folder exists
    before `mongod` will run.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbpath`标志告诉MongoDB在哪里存储我们数据库的数据文件。您可以选择任何位置，但在`mongod`运行之前，您必须确保文件夹存在。'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By deleting the `dbpath` folder at any time, you can effectively erase all data
    and start afresh. This is especially useful during development.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过随时删除`dbpath`文件夹，您可以有效地擦除所有数据并重新开始。这在开发过程中特别有用。
- en: Now that our environment is running, we are ready to start building our components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经运行，我们准备开始构建我们的组件。
- en: Votes from Twitter
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自Twitter的投票
- en: 'In your `$GOPATH/src` folder, alongside other projects, create a new folder
    called `socialpoll` for this chapter. This folder won''t be a Go package or program
    by itself, but will contain our three component programs. Inside `socialpoll`
    , create a new folder called `twittervotes` and add the obligatory `main.go` template
    (this is important as `main` packages without a `main` function won''t compile):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$GOPATH/src`文件夹中，与其他项目一起，为本章创建一个名为`socialpoll`的新文件夹。该文件夹本身不是Go包或程序，但将包含我们的三个组件程序。在`socialpoll`中，创建一个名为`twittervotes`的新文件夹，并添加必需的`main.go`模板（这很重要，因为没有`main`函数的`main`包将无法编译）：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `twittervotes` program is going to:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`twittervotes`程序将：
- en: Load all polls from the MongoDB database using `mgo` , and collect all options
    from the `options` array in each document
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`mgo`从MongoDB数据库加载所有投票，并从每个文档的`options`数组中收集所有选项。
- en: Open and maintain a connection to Twitter's streaming APIs looking for any mention
    of the options
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开并保持与Twitter的流API的连接，寻找任何提及选项的内容。
- en: For each tweet that matches the filter, figure out which option is mentioned
    and push that option through to NSQ
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于与筛选器匹配的每条推文，找出提到的选项，并将该选项推送到NSQ。
- en: If the connection to Twitter is dropped (which is common in long-running connections
    as it is actually part of Twitter's streaming API specification) after a short
    delay (so we do not bombard Twitter with connection requests), reconnect and continue
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果与Twitter的连接中断（这在长时间运行的连接中很常见，因为它实际上是Twitter的流API规范的一部分），则在短暂延迟后（以便我们不会用连接请求轰炸Twitter），重新连接并继续。
- en: Periodically re-query MongoDB for the latest polls and refresh the connection
    to Twitter to make sure we are always looking out for the right options
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期重新查询MongoDB以获取最新的投票，并刷新与Twitter的连接，以确保我们始终关注正确的选项。
- en: When the user terminates the program by hitting *Ctrl* + *C* , it will gracefully
    stop itself
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户通过按*Ctrl* + *C*终止程序时，它将自动停止。
- en: Authorization with Twitter
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与Twitter进行授权。
- en: In order to use the streaming API, we will need authentication credentials from
    Twitter's Application Management console, much in the same way we did for our
    Gomniauth service providers in [Chapter 3](text00027.html#ch03 "Chapter 3. Three
    Ways to Implement Profile Pictures") , *Three Ways to Implement Profile Pictures*
    . Head over to [https://apps.twitter.com](https://apps.twitter.com) and create
    a new app called something like `SocialPoll` (the names have to be unique, so
    you can have some fun here; the choice of name doesn't affect the code either
    way). When your app has been created, visit the **API Keys** tab and locate the
    **Your access token** section where you need to create a new access token. After
    a short delay, refresh the page and notice that you in fact have two sets of keys
    and secrets; an API key and a secret, and an access token and the corresponding
    secret. Following good coding practices, we are going to set these values as environment
    variables so that our program can have access to them without us having to hardcode
    them in our source files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用流API，我们将需要从Twitter的应用程序管理控制台获取身份验证凭据，就像我们在[第3章](text00027.html#ch03 "第3章。实现个人资料图片的三种方法")中为我们的Gomniauth服务提供者所做的那样，*实现个人资料图片的三种方法*。转到[https://apps.twitter.com](https://apps.twitter.com)并创建一个名为`SocialPoll`的新应用程序（名称必须是唯一的，因此您可以在这里玩得很开心；名称的选择不会影响代码）。创建应用程序后，访问**API密钥**选项卡，并找到**您的访问令牌**部分，在那里您需要创建一个新的访问令牌。短暂延迟后，刷新页面并注意到您实际上有两组密钥和秘钥；一个API密钥和秘钥，以及一个访问令牌和相应的秘密。遵循良好的编码实践，我们将这些值设置为环境变量，以便我们的程序可以访问它们，而无需在源文件中硬编码它们。
- en: 'The keys we will use in this chapter are:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将使用的密钥是：
- en: '`SP_TWITTER_KEY`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_KEY`'
- en: '`SP_TWITTER_SECRET`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_SECRET`'
- en: '`SP_TWITTER_ACCESSTOKEN`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_ACCESSTOKEN`'
- en: '`SP_TWITTER_ACCESSSECRET`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_ACCESSSECRET`'
- en: 'You can set the environment variables however you like, but since the app relies
    on them in order to work, creating a new file called `setup.sh` (for bash shells)
    or `setup.bat` (on Windows) is a good idea since you can check such files into
    your source code repository. Insert the following code in `setup.sh` or `setup.bat`
    by copying the appropriate values from the Twitter app page:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要设置环境变量，但由于应用程序依赖于它们才能工作，因此创建一个名为`setup.sh`（对于bash shell）或`setup.bat`（在Windows上）的新文件是一个好主意，因为您可以将这些文件检入到源代码存储库中。通过从Twitter应用程序页面复制相应的值将以下代码插入`setup.sh`或`setup.bat`中：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the file with the source or call commands to have the values appropriately
    set, or add them to your `.bashrc` or `C:\cmdauto.cmd` files to save you running
    them every time you open a new terminal window.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件并使用源或调用命令来适当设置值，或将它们添加到您的`.bashrc`或`C:\cmdauto.cmd`文件中，以节省每次打开新终端窗口时运行它们的时间。
- en: Extracting the connection
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取连接
- en: The Twitter streaming API supports HTTP connections that stay open for a long
    time, and given the design of our solution, we are going to need to access the
    `net.Conn` object in order to close it from outside of the goroutine in which
    requests occur. We can achieve this by providing our own `dial` method to an `http.Transport`
    object that we will create.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter流API支持保持长时间打开的HTTP连接，并且考虑到我们解决方案的设计，我们需要从请求发生的goroutine之外访问`net.Conn`对象以关闭它。我们可以通过为我们将创建的`http.Transport`对象提供自己的`dial`方法来实现这一点。
- en: 'Create a new file called `twitter.go` inside `twittervotes` (which is where
    all things Twitter-related will live), and insert the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twittervotes`（所有与Twitter相关的内容都将驻留在此处）中创建一个名为`twitter.go`的新文件，并插入以下代码：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our bespoke `dial` function first ensures `conn` is closed, and then opens a
    new connection keeping the `conn` variable updated with the current connection.
    If a connection dies (Twitter's API will do this from time to time) or is closed
    by us, we can redial without worrying about zombie connections.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定制的`dial`函数首先确保关闭`conn`，然后打开一个新连接，保持`conn`变量更新为当前连接。如果连接中断（Twitter的API偶尔会这样做）或被我们关闭，我们可以重新拨号，而不必担心僵尸连接。
- en: 'We will periodically close the connection ourselves and initiate a new one,
    because we want to reload the options from the database at regular intervals.
    To do this, we need a function that closes the connection, and also closes an
    `io.ReadCloser` that we will use to read the body of the responses. Add the following
    code to `twitter.go` :'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定期关闭连接并启动新连接，因为我们希望定期从数据库重新加载选项。为此，我们需要一个关闭连接的函数，并且还需要关闭我们将用于读取响应主体的`io.ReadCloser`。将以下代码添加到`twitter.go`中：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now we can call `closeConn` at any time to break the ongoing connection with
    Twitter and tidy things up. In most cases, our code will load the options from
    the database again and open a new connection right away, but if we're shutting
    the program down (in response to a *Ctrl* + *C* hit) then we can call `closeConn`
    just before we exit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以随时调用`closeConn`来中断与Twitter的持续连接并整理事情。在大多数情况下，我们的代码将再次从数据库加载选项并立即打开新连接，但如果我们正在关闭程序（响应*Ctrl*
    + *C*按键），那么我们可以在退出之前调用`closeConn`。
- en: Reading environment variables
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取环境变量
- en: 'Next we are going to write a function that will read the environment variables
    and set up the `OAuth` objects we''ll need in order to authenticate the requests.
    Add the following code in the `twitter.go` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个函数，该函数将读取环境变量并设置我们需要验证请求的`OAuth`对象。在`twitter.go`文件中添加以下代码：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we define a `struct` type to store the environment variables that we need
    to authenticate with Twitter. Since we don't need to use the type elsewhere, we
    define it inline and creating a variable called `ts` of this anonymous type (that's
    why we have the somewhat unusual `var ts struct…` code). We then use Joe Shaw's
    elegant `envdecode` package to pull in those environment variables for us. You
    will need to run `go get github.com/joeshaw/envdecode` and also import the `log`
    package. Our program will try to load appropriate values for all the fields marked
    `required` , and return an error if it fails to do so, which reminds people that
    the program won't work without Twitter credentials.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`struct`类型来存储我们需要用来验证Twitter的环境变量。由于我们不需要在其他地方使用这种类型，我们内联定义它，并创建一个名为`ts`的变量，它是这种匿名类型（这就是为什么我们有了有些不寻常的`var
    ts struct…`代码）。然后我们使用Joe Shaw优雅的`envdecode`包来为我们拉取这些环境变量。您需要运行`go get github.com/joeshaw/envdecode`，并且还要导入`log`包。我们的程序将尝试为所有标记为`required`的字段加载适当的值，并在失败时返回错误，提醒人们如果没有Twitter凭据，程序将无法工作。
- en: The strings inside the back ticks alongside each field in `struct` are called
    tags, and are available through a reflection interface, which is how `envdecode`
    knows which variables to look for. Tyler Bunnell and I added the required argument
    to this package, which indicates that it is an error for any of the environment
    variables to be missing (or empty).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`struct`中每个字段旁边的反引号内的字符串称为标签，并且可以通过反射接口获得，这就是`envdecode`知道要查找哪些变量的方式。Tyler
    Bunnell和我为这个包添加了required参数，这表明如果缺少（或为空）任何环境变量都是错误的。
- en: Once we have the keys, we use them to create `oauth.Credentials` and an `oauth.Client`
    object from Gary Burd's `go-oauth` package, which will allow us to authorize requests
    with Twitter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得了密钥，我们将使用它们来创建`oauth.Credentials`和`oauth.Client`对象，这些对象来自Gary Burd的`go-oauth`包，它将允许我们使用Twitter进行授权请求。
- en: 'Now that we have the ability to control the underlying connection and authorize
    requests, we are ready to write the code that will actually build the authorized
    request, and return the response. In `twitter.go` , add the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了控制底层连接和授权请求的能力，我们准备编写实际构建授权请求并返回响应的代码。在`twitter.go`中，添加以下代码：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use `sync.Once` to ensure our initialization code only gets run once despite
    the number of times we call `makeRequest` . After calling the `setupTwitterAuth`
    method, we create a new `http.Client` using an `http.Transport` that uses our
    custom `dial` method. We then set the appropriate headers needed for authorization
    with Twitter by encoding the specified `params` object that will contain the options
    we are querying for.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sync.Once`来确保我们的初始化代码只运行一次，尽管我们调用`makeRequest`的次数有多少。在调用`setupTwitterAuth`方法之后，我们使用`http.Transport`创建一个新的`http.Client`，该`http.Transport`使用我们自定义的`dial`方法。然后，我们通过对包含我们要查询的选项的指定`params`对象进行编码，设置与Twitter授权所需的适当标头。
- en: Reading from MongoDB
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从MongoDB读取
- en: 'In order to load the polls, and therefore the options to search Twitter for,
    we need to connect to and query MongoDB. In `main.go` , add the two functions
    `dialdb` and `closedb` :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载投票，并因此搜索Twitter的选项，我们需要连接并查询MongoDB。在`main.go`中，添加两个函数`dialdb`和`closedb`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These two functions will connect to and disconnect from the locally running
    MongoDB instance using the `mgo` package, and store `mgo.Session` (the database
    connection object) in a global variable called `db` .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将使用`mgo`包连接到本地运行的MongoDB实例，并将`mgo.Session`（数据库连接对象）存储在名为`db`的全局变量中，并从中断开连接。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an additional assignment, see if you can find an elegant way to make the
    location of the MongoDB instance configurable so that you don't need to run it
    locally.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，看看是否可以找到一种优雅的方式来使MongoDB实例的位置可配置，以便您不需要在本地运行它。
- en: 'Assuming MongoDB is running and our code is able to connect, we need to load
    the poll objects and extract all the options from the documents, which we will
    then use to search Twitter. Add the following `Options` function to `main.go`
    :'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设MongoDB正在运行并且我们的代码能够连接，我们需要加载投票对象并从文档中提取所有选项，然后我们将使用这些选项来搜索Twitter。将以下`Options`函数添加到`main.go`中：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our poll document contains more than just `Options` , but our program doesn't
    care about anything else, so there's no need for us to bloat our `poll` struct.
    We use the `db` variable to access the `polls` collection from the `ballots` database,
    and call the `mgo` package's fluent `Find` method, passing `nil` (meaning no filtering).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票文档包含的不仅仅是`Options`，但我们的程序不关心其他任何内容，因此我们不需要膨胀我们的`poll`结构。我们使用`db`变量访问`ballots`数据库中的`polls`集合，并调用`mgo`包的流畅`Find`方法，传递`nil`（表示没有过滤）。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A fluent interface (first coined by Eric Evans and Martin Fowler) refers to
    an API design that aims to make the code more readable by allowing you to chain
    together method calls. This is achieved by each method returning the context object
    itself, so that another method can be called directly afterwards. For example,
    `mgo` allows you to write queries such as this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅接口（由Eric Evans和Martin Fowler首次创造）是指旨在通过允许您链接方法调用来使代码更可读的API设计。这是通过每个方法返回上下文对象本身来实现的，以便可以直接调用另一个方法。例如，`mgo`允许您编写诸如此类的查询：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We then get an iterator by calling the `Iter` method, which allows us to access
    each poll one by one. This is a very memory-efficient way of reading the poll
    data, because it only ever uses a single `poll` object. If we were to use the
    `All` method instead, the amount of memory we'd use would depend on the number
    of polls we had in our database, which would be out of our control.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过调用`Iter`方法获得迭代器，这允许我们逐个访问每个投票。这是一种非常节省内存的读取投票数据的方式，因为它只使用一个`poll`对象。如果我们使用`All`方法，我们将使用的内存量取决于我们在数据库中拥有的投票数量，这将超出我们的控制。
- en: When we have a poll, we use the `append` method to build up the options slice.
    Of course, with millions of polls in the database, this slice too would grow large
    and unwieldy. For that kind of scale, we would probably run multiple `twittervotes`
    programs, each dedicated to a portion of the poll data. A simple way to do this
    would be to break polls into groups based on the letters the titles begin with,
    such as group A-N and O-Z. A somewhat more sophisticated approach would be to
    add a field to the `poll` document grouping it up in a more controlled manner,
    perhaps based on the stats for the other groups so that we are able to balance
    the load across many `twittervotes` instances.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个投票时，我们使用`append`方法来构建选项切片。当然，随着数据库中有数百万个投票，这个切片也会变得庞大而难以控制。对于这种规模，我们可能会运行多个`twittervotes`程序，每个程序专门用于一部分投票数据。一个简单的方法是根据标题的首字母将投票分成组，例如A-N组和O-Z组。一个更复杂的方法是向`poll`文档添加一个字段，以更受控制的方式对其进行分组，也许是基于其他组的统计数据，以便我们能够在许多`twittervotes`实例之间平衡负载。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `append` built-in function is actually a `variadic` function, which means
    you can pass multiple elements for it to append. If you have a slice of the correct
    type, you can add `...` to the end, which simulates the passing of each item of
    the slice as a different argument.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`内置函数实际上是一个`variadic`函数，这意味着您可以为其附加多个元素。如果您有正确类型的切片，可以在末尾添加`...`，这模拟了将切片的每个项目作为不同参数传递。'
- en: Finally, we close the iterator and clean up any used memory before returning
    the options and any errors that occurred while iterating (by calling the `Err`
    method on the `mgo.Iter` object).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们关闭迭代器并清理任何使用的内存，然后返回选项和在迭代过程中发生的任何错误（通过在`mgo.Iter`对象上调用`Err`方法）。
- en: Reading from Twitter
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Twitter阅读
- en: 'Now we are able to load the options and make authorized requests to the Twitter
    API. We are thus ready to write the code that initiates the connection, and continuously
    reads from the stream until either we call our `closeConn` method, or Twitter
    closes the connection for one reason or another. The structure contained in the
    stream is a complex one containing all kinds of information about the tweet—who
    made it and when, and even what links or mentions of users occur in the body (see
    Twitter''s API documentation for more details). However, we are only interested
    in the tweet text itself so you need not worry about all the other noise; add
    the following structure to `twitter.go` :'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够加载选项并向Twitter API发出授权请求。因此，我们准备编写启动连接的代码，并持续从流中读取，直到我们调用我们的`closeConn`方法，或者Twitter因某种原因关闭连接。流中包含的结构是一个复杂的结构，包含有关推文的各种信息-谁发表了它以及何时，甚至在正文中出现了哪些链接或用户提及（有关更多详细信息，请参阅Twitter的API文档）。但是，我们只对推文文本本身感兴趣，因此您无需担心所有其他噪音；将以下结构添加到`twitter.go`中：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This may feel incomplete, but think about how clear it makes our intentions
    to other programmers who might see our code: a tweet has some text, and that is
    all we care about.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉不完整，但请考虑它如何清晰地表达了我们对其他程序员可能看到我们的代码的意图：推文有一些文本，这就是我们关心的全部。
- en: 'Using this new structure, in `twitter.go` , add the following `readFromTwitter`
    function that takes a send-only channel called `votes` ; this is how this function
    will inform the rest of our program that it has noticed a vote on twitter:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新结构，在`twitter.go`中添加以下`readFromTwitter`函数，该函数接收一个名为`votes`的只发送通道；这是该函数通知程序的其余部分它已经在Twitter上注意到了一次投票的方式：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, after loading the options from all the polls data (by
    calling the `loadOptions` function), we use `url.Parse` to create a `url.URL`
    object describing the appropriate endpoint on Twitter. We build a `url.Values`
    object called `query` , and set the options as a comma-separated list. As per
    the API, we make a new `POST` request using the encoded `url.Values` object as
    the body, and pass it to `makeRequest` along with the query object itself. All
    being well, we make a new `json.Decoder` from the body of the request, and keep
    reading inside an infinite `for` loop by calling the `Decode` method. If there
    is an error (probably due to the connection being closed), we simply break the
    loop and exit the function. If there is a tweet to read, it will be decoded into
    the `tweet` variable, which will give us access to the `Text` property (the 140
    characters of the tweet itself). We then iterate over all possible options, and
    if the tweet has mentioned it, we send it on the `votes` channel. This technique
    also allows a tweet to contain many votes at the same time, something you may
    or may not decide to change based on the rules of the election.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，加载所有投票数据的选项（通过调用`loadOptions`函数）后，我们使用`url.Parse`创建一个描述Twitter上适当端点的`url.URL`对象。我们构建一个名为`query`的`url.Values`对象，并将选项设置为逗号分隔的列表。根据API，我们使用编码后的`url.Values`对象作为主体发出新的`POST`请求，并将其与查询对象一起传递给`makeRequest`。如果一切顺利，我们将从请求的主体中创建一个新的`json.Decoder`，并通过调用`Decode`方法在无限的`for`循环中不断读取。如果出现错误（可能是由于连接关闭），我们简单地中断循环并退出函数。如果有要读取的推文，它将被解码为`tweet`变量，这将使我们可以访问`Text`属性（推文本身的140个字符）。然后，我们遍历所有可能的选项，如果推文提到了它，我们就在`votes`通道上发送它。这种技术还允许一个推文同时包含许多投票，这取决于选举规则，您可能会决定是否更改。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `votes` channel is **send-only** (which means we cannot receive on it),
    since it is of the type `chan<- string` . Think of the little "arrow" telling
    us which way messages will flow: either into the channel or out of it. This is
    a great way to express intent—it''s clear that we never intend to read votes using
    our `readFromTwitter` function; rather we will only send them on that channel.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`votes`通道是**只发送**的（这意味着我们不能在其上接收），因为它的类型是`chan<- string`。想象一下小箭头告诉我们消息流向的方式：要么进入通道，要么离开通道。这是一种表达意图的好方法——很明显，我们从不打算使用`readFromTwitter`函数来读取投票；相反，我们只会在该通道上发送它们。'
- en: Terminating the program whenever `Decode` returns an error doesn't provide a
    very robust solution. This is because the Twitter API documentation states that
    the connection will drop from time to time, and clients should consider this when
    consuming the services. And remember, we are going to terminate the connection
    periodically too, so we need to think about a way to reconnect once the connection
    is dropped.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`Decode`返回错误时终止程序并不提供一个非常健壮的解决方案。这是因为Twitter API文档规定连接会不时中断，客户端在消费服务时应考虑到这一点。而且请记住，我们也会定期终止连接，所以我们需要考虑一种在连接中断后重新连接的方法。
- en: Signal channels
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号通道
- en: A great use of channels in Go is to signal events between code running in different
    goroutines. We are going to see a real-world example of this when we write our
    next function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用通道的一个很好的用途是在不同goroutine中运行的代码之间发出信号事件。当我们编写下一个函数时，我们将看到一个真实世界的例子。
- en: The purpose of the function is to start a goroutine that continually calls the
    `readFromTwitter` function (with the specified `votes` channel to receive the
    votes on), until we signal that we want it to stop. And once it has stopped, we
    want to be notified through another signal channel. The return of the function
    will be a channel of `struct{}` ; a signal channel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的目的是启动一个goroutine，不断调用`readFromTwitter`函数（使用指定的`votes`通道接收投票），直到我们发出停止信号。一旦它停止，我们希望通过另一个信号通道得到通知。函数的返回值将是一个`struct{}`类型的通道；一个信号通道。
- en: Signal channels have some interesting properties that are worth taking a closer
    look at. Firstly, the type sent down the channels is an empty `struct{}` , instances
    of which actually take up zero bytes, since it has no fields. So `struct{}{}`
    is a great memory-efficient option for signaling events. Some people use `bool`
    types, which is also fine, although `true` and `false` both take up a byte of
    memory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道具有一些有趣的特性值得仔细研究。首先，通过通道发送的类型是一个空的`struct{}`，实际上不占用任何字节，因为它没有字段。因此，`struct{}{}`是一个用于信号事件的内存高效选项。有些人使用`bool`类型，这也可以，尽管`true`和`false`都占用一个字节的内存。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Head over to [http://play.golang.org](http://play.golang.org) and try this out
    for yourself.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[http://play.golang.org](http://play.golang.org)并自己尝试一下。
- en: 'The size of a `bool` is 1:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型的大小为1：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Whereas the size of `struct{}{}` is `0` :'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体`struct{}{}`的大小为`0`：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The signal channels also have a buffer size of 1, which means that execution
    will not block until something reads the signal from the channel.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道还具有缓冲区大小为1，这意味着执行不会阻塞，直到有东西从通道中读取信号。
- en: We are going to employ two signal channels in our code, one that we pass into
    our function that tells our goroutine that it should stop, and another (provided
    by the function) that signals once stopping is complete.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的代码中使用两个信号通道，一个是我们传递给函数的，告诉我们的goroutine它应该停止，另一个是函数提供的，一旦停止完成就发出信号。
- en: 'In `twitter.go` , add the following function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twitter.go`中添加以下函数：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, the first argument `stopchan` is a channel of type `<-chan
    struct{}` , a **receive-only** signal channel. It is this channel that, outside
    the code, will signal on, which will tell our goroutine to stop. Remember that
    it's receive-only inside this function, the actual channel itself will be capable
    of sending. The second argument is the `votes` channel on which votes will be
    sent. The return type of our function is also a signal channel of type `<-chan
    struct{}` ; a receive-only channel that we will use to indicate that we have stopped.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，第一个参数`stopchan`是一个类型为`<-chan struct{}`的通道，一个**只接收**的信号通道。在代码外部，将在此通道上发出信号，这将告诉我们的goroutine停止。请记住，在此函数内部它是只接收的，实际通道本身将能够发送。第二个参数是`votes`通道，用于发送投票。我们函数的返回类型也是一个类型为`<-chan
    struct{}`的信号通道；一个只接收的通道，我们将用它来指示我们已经停止。
- en: These channels are necessary because our function triggers its own goroutine,
    and immediately returns, so without this, calling code would have no idea if the
    spawned code were still running or not.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通道是必要的，因为我们的函数会触发自己的goroutine，并立即返回，所以没有这些，调用代码将不知道生成的代码是否仍在运行。
- en: The first thing we do in the `startTwitterStream` function is make our `stoppedchan`
    , and defer the sending of a `struct{}{}` to indicate that we have finished when
    our function exits. Notice that `stoppedchan` is a normal channel so even though
    it is returned as a receive-only, we will be able to send on it from within this
    function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startTwitterStream`函数中，我们首先创建了`stoppedchan`，并延迟发送`struct{}{}`以指示我们的函数退出时已经完成。请注意，`stoppedchan`是一个普通通道，因此即使它作为只接收返回，我们也可以在此函数内部发送它。
- en: We then start an infinite `for` loop in which we select from one of two channels.
    The first is the `stopchan` (the first argument), which would indicate that it
    was time to stop, and return (thus triggering the deferred signaling on `stoppedchan`
    ). If that hasn't happened, we will call `readFromTwitter` (passing in the `votes`
    channel), which will go and load the options from the database and open the connection
    to Twitter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们开始一个无限的`for`循环，在其中我们从两个通道中选择一个。第一个是`stopchan`（第一个参数），这将表明是时候停止并返回（从而触发`stoppedchan`上的延迟信号）。如果还没有发生这种情况，我们将调用`readFromTwitter`（传入`votes`通道），它将从数据库中加载选项并打开到Twitter的连接。
- en: When the Twitter connection dies, our code will return here where we sleep for
    ten seconds using the `time.Sleep` function. This is to give the Twitter API a
    rest in case it closed the connection due to overuse. Once we've rested, we re-enter
    the loop and check again on the `stopchan` channel to see if the calling code
    wants us to stop or not.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当Twitter连接断开时，我们的代码将返回到这里，在这里我们使用`time.Sleep`函数睡眠十秒。这是为了让Twitter API休息一下，以防它由于过度使用而关闭连接。一旦休息过后，我们重新进入循环，并再次检查`stopchan`通道，看看调用代码是否希望我们停止。
- en: To make this flow clear, we are logging out key statements that will not only
    help us debug our code, but also let us peek into the inner workings of this somewhat
    complicated mechanism.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个流程清晰，我们记录了一些关键语句，这些语句不仅有助于我们调试代码，还让我们窥视这个有些复杂的机制的内部工作。
- en: Publishing to NSQ
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到NSQ
- en: Once our code is successfully noticing votes on Twitter and sending them down
    the `votes` channel, we need a way to publish them into an NSQ topic; after all,
    this is the point of the `twittervotes` program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的代码成功地注意到Twitter上的投票并将它们发送到`votes`通道中，我们需要一种方法将它们发布到NSQ主题；毕竟，这是`twittervotes`程序的目的。
- en: We will write a function called `publishVotes` that will take the `votes` channel,
    this time of type `<-chan string` (a receive-only channel) and publish each string
    that is received from it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`publishVotes`的函数，它将接收类型为`<-chan string`（只接收通道）的`votes`通道，并发布从中接收到的每个字符串。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our previous functions, the `votes` channel was of type `chan<- string` ,
    but this time it's of the type `<-chan string` . You might think this is a mistake,
    or even that it means we cannot use the same channel for both but you would be
    wrong. The channel we create later will be made with `make(chan string)` , neither
    receive or only send, and can act in both cases. The reason for using the `<-`
    operator on a channel in arguments is to make clear the intent of what the channel
    will be used for; or in the case where it is the return type, to prevent users
    from accidentally sending on channels intended for receiving or vice versa. The
    compiler will actually produce an error if they use such a channel incorrectly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的函数中，`votes`通道的类型是`chan<- string`，但这次它的类型是`<-chan string`。您可能会认为这是一个错误，甚至认为这意味着我们不能同时使用同一个通道，但您是错误的。我们稍后创建的通道将使用`make(chan
    string)`，既不是接收也不是发送，可以在两种情况下都起作用。在参数中使用`<-`运算符的原因是为了明确通道的使用意图；或者在它是返回类型的情况下，防止用户意外地在预期用于接收或发送的通道上发送。如果用户错误地使用这样的通道，编译器实际上会产生错误。
- en: Once the `votes` channel is closed (this is how external code will tell our
    function to stop working), we will stop publishing and send a signal down the
    returned stop signal channel.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`votes`通道关闭（这是外部代码告诉我们的函数停止工作的方式），我们将停止发布并向返回的停止信号通道发送信号。
- en: 'Add the `publishVotes` function to `main.go` :'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将`publishVotes`函数添加到`main.go`：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again the first thing we do is to create the `stopchan` , which we later return,
    this time not deferring the signaling but doing it inline by sending a `struct{}{}`
    down `stopchan` .
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是创建`stopchan`，然后将其返回，这次不是延迟发送信号，而是通过向`stopchan`发送`struct{}{}`来内联执行。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The difference is to show alternative options: within one codebase you should
    pick a style you like and stick with it, until a standard emerges within the community;
    in which case we should all go with that.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于显示备选选项：在一个代码库中，您应该选择自己喜欢的风格并坚持下去，直到社区内出现一个标准；在这种情况下，我们都应该遵循这个标准。
- en: We then create an NSQ producer by calling `NewProducer` and connecting to the
    default NSQ port on `localhost` , using a default configuration. We start a goroutine,
    which uses another great built-in feature of the Go language that lets us continually
    pull values from a channel (in our case the `votes` channel) just by doing a normal
    `for…range` operation on it. Whenever the channel has no values, execution will
    be blocked until a value comes down the line. If the `votes` channel is closed,
    the `for` loop will exit.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过调用`NewProducer`创建一个NSQ生产者，并连接到`localhost`上的默认NSQ端口，使用默认配置。我们启动一个goroutine，它使用Go语言的另一个很棒的内置功能，让我们可以通过在通道上执行正常的`for…range`操作来不断地从通道中拉取值（在我们的情况下是`votes`通道）。每当通道没有值时，执行将被阻塞，直到有值传送过来。如果`votes`通道被关闭，`for`循环将退出。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To learn more about the power of channels in Go, it is highly recommended that
    you seek out blog posts and videos by John Graham-Cumming, in particular one entitled
    *A Channel Compendium* that he presented at Gophercon 2014 and which contains
    a brief history of channels, including their origin. (Interestingly, John was
    also the guy who successfully petitioned the British Government to officially
    apologize for its treatment of Alan Turing.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Go语言中通道的强大之处，强烈建议您查找John Graham-Cumming的博客文章和视频，特别是他在2014年Gophercon上介绍的*通道概览*，其中包含了通道的简要历史，包括它们的起源。（有趣的是，John还成功地请求英国政府正式为对待Alan
    Turing的方式道歉。）
- en: When the loop exits (after the `votes` channel is closed) the publisher is stopped,
    following which the `stopchan` signal is sent.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环退出（在`votes`通道关闭后），发布者将停止，随后发送`stopchan`信号。
- en: Gracefully starting and stopping
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅地启动和停止
- en: When our program is terminated, we want to do a few things before actually exiting;
    namely closing our connection to Twitter and stopping the NSQ publisher (which
    actually deregisters its interest in the queue). To achieve this, we have to override
    the default *Ctrl + C* behavior.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序被终止时，我们希望在实际退出之前做一些事情；即关闭与Twitter的连接并停止NSQ发布者（实际上是取消其对队列的兴趣）。为了实现这一点，我们必须覆盖默认的*Ctrl
    + C*行为。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The upcoming code blocks all go inside the main function; they are broken up
    so we can discuss each section before continuing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的代码块都在`main`函数内部；它们被分开，以便我们在继续之前讨论每个部分。
- en: 'Add the following code inside the `main` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内添加以下代码：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we create a stop `bool` with an associated `sync.Mutex` so that we can
    access it from many goroutines at the same time. We then create two more signal
    channels, `stopChan` and `signalChan` , and use `signal.Notify` to ask Go to send
    the signal down the `signalChan` when someone tries to halt the program (either
    with the `SIGINT` interrupt, or the `SIGTERM` termination POSIX signals). The
    `stopChan` is how we indicate that we want our processes to terminate, and we
    pass it as an argument to `startTwitterStream` later.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个带有关联`sync.Mutex`的停止`bool`，以便我们可以同时从许多goroutine中访问它。然后我们创建了另外两个信号通道，`stopChan`和`signalChan`，并使用`signal.Notify`要求Go在有人尝试终止程序时将信号发送到`signalChan`（无论是使用`SIGINT`中断还是`SIGTERM`终止POSIX信号）。`stopChan`是我们指示要终止进程的方式，我们将其作为参数传递给`startTwitterStream`。
- en: We then run a goroutine that blocks waiting for the signal by trying to read
    from `signalChan` ; this is what the `<-` operator does in this case (it's trying
    to read from the channel). Since we don't care about the type of signal, we don't
    bother capturing the object returned on the channel. Once a signal is received,
    we set `stop` to `true` , and close the connection. Only when one of the specified
    signals is sent will the rest of the goroutine code run, which is how we are able
    to perform teardown code before exiting the program.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行一个goroutine，通过尝试从`signalChan`读取来阻塞等待信号；这就是这种情况下`<-`操作符的作用（它正在尝试从通道中读取）。由于我们不关心信号的类型，因此我们不需要捕获通道上返回的对象。一旦收到信号，我们将`stop`设置为`true`，并关闭连接。只有在发送了指定的信号之一后，才会运行剩余的goroutine代码，这就是我们能够在退出程序之前执行拆卸代码的方式。
- en: 'Add the following piece of code (inside the main function) to open and defer
    the closing of the database connection:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内添加以下代码片段，以打开并延迟关闭数据库连接：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since the `readFromTwitter` method reloads the options from the database each
    time, and because we want to keep our program updated without having to restart
    it, we are going to introduce one final goroutine. This goroutine will simply
    call `closeConn` every minute, causing the connection to die, and cause `readFromTwitter`
    to be called over again. Insert the following code at the bottom of the `main`
    function to start all of these processes, and then wait for them to gracefully
    stop:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`readFromTwitter`方法每次都会从数据库重新加载选项，并且我们希望在无需重新启动程序的情况下保持程序更新，因此我们将引入最后一个goroutine。这个goroutine将每分钟调用`closeConn`，导致连接断开，并导致`readFromTwitter`再次被调用。在`main`函数的底部插入以下代码，以启动所有这些进程，然后等待它们优雅地停止：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First we make the `votes` channel that we have been talking about throughout
    this section, which is a simple channel of string. Notice that it is neither a
    send (`chan<-` ) or receive (`<-chan` ) channel; in fact, making such channels
    makes little sense. We then call `publishVotes` , passing in the `votes` channel
    for it to receive from, and capturing the returned stop signal channel as `publisherStoppedChan`
    . Similarly, we call `startTwitterStream` passing in our `stopChan` from the beginning
    of the `main` function, and the `votes` channel for it to send to, while capturing
    the resulting stop signal channel as `twitterStoppedChan` .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了我们在本节中一直在谈论的`votes`通道，它是一个简单的字符串通道。请注意，它既不是发送（`chan<-`）也不是接收（`<-chan`）通道；实际上，创建这样的通道没有多大意义。然后我们调用`publishVotes`，将`votes`通道传递给它进行接收，并将返回的停止信号通道捕获为`publisherStoppedChan`。类似地，我们调用`startTwitterStream`，传入我们在`main`函数开头的`stopChan`，以及`votes`通道进行发送，并捕获生成的停止信号通道为`twitterStoppedChan`。
- en: We then start our refresher goroutine, which immediately enters an infinite
    `for` loop before sleeping for a minute and closing the connection via the call
    to `closeConn` . If the stop `bool` has been set to true (in that previous goroutine),
    we will `break` the loop and exit, otherwise we will loop around and wait another
    minute before closing the connection again. The use of the `stoplock` is important
    because we have two goroutines that might try to access the stop variable at the
    same time but we want to avoid collisions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动刷新goroutine，它立即进入无限的`for`循环，然后睡眠一分钟并通过调用`closeConn`关闭连接。如果停止`bool`已经设置为true（在之前的goroutine中），我们将`break`循环并退出，否则我们将继续循环并等待另一分钟再次关闭连接。使用`stoplock`是重要的，因为我们有两个goroutine可能同时尝试访问停止变量，但我们希望避免冲突。
- en: Once the goroutine has started, we then block on the `twitterStoppedChan` by
    attempting to read from it. When successful (which means the signal was sent on
    the `stopChan` ), we close the `votes` channel which will cause the publisher's
    `for…range` loop to exit, and the publisher itself to stop, after which the signal
    will be sent on the `publisherStoppedChan` , which we wait for before exiting.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦goroutine启动，我们就会在`twitterStoppedChan`上阻塞，尝试从中读取。当成功时（这意味着在`stopChan`上发送了信号），我们关闭`votes`通道，这将导致发布者的`for…range`循环退出，并且发布者本身停止，之后会在`publisherStoppedChan`上发送信号，我们等待后退出。
- en: Testing
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: 'To make sure our program works, we need to do two things: first we need to
    create a poll in the database, and second, we need to peer inside the messaging
    queue to see if the messages are indeed being generated by `twittervotes` .'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的程序正常工作，我们需要做两件事：首先，我们需要在数据库中创建一个投票，其次，我们需要查看消息队列，看看消息是否确实由`twittervotes`生成。
- en: 'In a terminal, run the `mongo` command to open a database shell that allows
    us to interact with MongoDB. Then enter the following commands to add a test poll:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，运行`mongo`命令打开一个数据库shell，允许我们与MongoDB交互。然后输入以下命令添加一个测试投票：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding commands add a new item to the `polls` collection in the `ballots`
    database. We are using some common words for options that are likely to be mentioned
    by people on Twitter so that we can observe real tweets being translated into
    messages. You might notice that our poll object is missing the `results` field;
    this is fine since we are dealing with unstructured data where documents do not
    have to adhere to a strict schema. The `counter` program we are going to write
    in the next section will add and maintain the `results` data for us later.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令向`ballots`数据库的`polls`集合中添加了一个新项目。我们使用一些常见的选项词，这些选项可能会被Twitter上的人提到，以便我们可以观察到真实的推文被翻译成消息。您可能会注意到我们的投票对象缺少`results`字段；这没关系，因为我们处理的是非结构化数据，文档不必遵循严格的模式。我们将在下一节中编写的`counter`程序稍后为我们添加和维护`results`数据。
- en: 'Press *Ctrl + C* to exit the MongoDB shell and type the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl + C*退出MongoDB shell，并输入以下命令：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `nsq_tail` tool connects to the specified messaging queue topic and outputs
    any messages that it notices. This is where we will validate that our `twittervotes`
    program is sending messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`nsq_tail`工具连接到指定的消息队列主题，并输出它注意到的任何消息。这是我们验证我们的`twittervotes`程序是否正在发送消息的地方。'
- en: 'In a separate terminal window, let''s build and run the `twittervotes` program:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的终端窗口中，让我们构建并运行`twittervotes`程序：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now switch back to the window running `nsq_tail` and notice that messages are
    indeed being generated in response to live Twitter activity.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在切换回运行`nsq_tail`的窗口，并注意确实会生成消息以响应实时Twitter活动。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you aren't seeing much activity, try looking up trending hashtags on Twitter
    and adding another poll containing those options.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到太多活动，请尝试在Twitter上查找热门标签，并添加另一个包含这些选项的投票。
- en: Counting votes
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计票
- en: The second program we are going to implement is the `counter` tool, which will
    be responsible for watching out for votes in NSQ, counting them, and keeping MongoDB
    up to date with the latest numbers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第二个程序是`counter`工具，它将负责监视NSQ中的投票，对其进行计数，并将MongoDB与最新数字保持同步。
- en: 'Create a new folder called `counter` alongside `twittervotes` , and add the
    following code to a new `main.go` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twittervotes`旁边创建一个名为`counter`的新文件夹，并将以下代码添加到一个新的`main.go`文件中：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Normally when we encounter an error in our code, we use a call like `log.Fatal`
    or `os.Exit` , which immediately terminates the program. Exiting the program with
    a non-zero exit code is important, because it is our way of telling the operating
    system that something went wrong, and we didn't complete our task successfully.
    The problem with the normal approach is that any deferred functions we have scheduled
    (and therefore any tear down code we need to run), won't get a chance to execute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们在代码中遇到错误时，我们使用`log.Fatal`或`os.Exit`这样的调用，它会立即终止程序。以非零退出代码退出程序很重要，因为这是我们告诉操作系统出现问题，我们没有成功完成任务的方式。常规方法的问题在于我们安排的任何延迟函数（因此我们需要运行的任何拆卸代码）都不会有机会执行。
- en: The pattern employed in the preceding code snippet lets us call the `fatal`
    function to record that an error occurred. Note that only when our main function
    exits will the deferred function run, which in turn calls `os.Exit(1)` to exit
    the program with an exit code of `1` . Because the deferred statements are run
    in LIFO (last in, first out) order, the first function we defer will be the last
    function to be executed, which is why the first thing we do in the `main` function
    is to defer the exiting code. This allows us to be sure that other functions we
    defer will be called *before* the program exits. We'll use this feature to ensure
    our database connection gets closed regardless of any errors.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中使用的模式允许我们调用`fatal`函数来记录发生错误。请注意，只有当我们的主函数退出时，推迟的函数才会运行，然后调用`os.Exit(1)`以退出带有退出代码`1`的程序。因为推迟的语句按LIFO（后进先出）顺序运行，我们推迟的第一个函数将是最后执行的函数，这就是为什么我们在`main`函数中首先推迟退出代码。这使我们确信我们推迟的其他函数将在程序退出*之前*被调用。我们将使用此功能来确保无论发生任何错误，我们的数据库连接都会关闭。
- en: Connecting to the database
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'The best time to think about cleaning up resources, such as database connections,
    is immediately after you have successfully obtained the resource; Go''s `defer`
    keyword makes this easy. At the bottom of the main function, add the following
    code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功获取资源后，立即考虑清理资源（例如数据库连接）是最佳时机；Go的`defer`关键字使这变得容易。在主函数的底部，添加以下代码：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code uses the familiar `mgo.Dial` method to open a session to the locally
    running MongoDB instance and immediately defers a function that closes the session.
    We can be sure that this code will run before our previously deferred statement
    containing the exit code (because deferred functions are run in the reverse order
    in which they were called). Therefore, whatever happens in our program, we know
    that the database session will definitely and properly close.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用熟悉的`mgo.Dial`方法打开到本地运行的MongoDB实例的会话，并立即推迟一个关闭会话的函数。我们可以确信这段代码将在先前推迟的包含退出代码的语句之前运行（因为推迟的函数按照它们被调用的相反顺序运行）。因此，无论我们的程序发生什么，我们都知道数据库会话一定会正确关闭。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The log statements are optional, but will help us see what's going on when we
    run and exit our program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 日志语句是可选的，但将帮助我们在运行和退出程序时查看发生了什么。
- en: At the end of the snippet, we use the `mgo` fluent API to keep a reference of
    the `ballots.polls` data collection in the `pollData` variable, which we will
    use later to make queries.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段的末尾，我们使用`mgo`流畅的API将`ballots.polls`数据集的引用保存在`pollData`变量中，稍后我们将使用它来进行查询。
- en: Consuming messages in NSQ
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在NSQ中消费消息
- en: 'In order to count the votes, we need to consume the messages on the `votes`
    topic in NSQ, and we''ll need a place to store them. Add the following variables
    to the `main` function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算选票，我们需要消耗NSQ中“votes”主题上的消息，并且我们需要一个地方来存储它们。将以下变量添加到`main`函数中：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A map and a lock (`sync.Mutex` ) is a common combination in Go, because we will
    have multiple goroutines trying to access the same map and we need to avoid corrupting
    it by trying to modify or read it at the same time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，地图和锁（`sync.Mutex`）是常见的组合，因为我们将有多个goroutine尝试访问相同的地图，并且我们需要避免在同时尝试修改或读取它时破坏它。
- en: 'Add the following code to the `main` function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`函数中：
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `NewConsumer` function allows us to set up an object that will listen on
    the `votes` NSQ topic, so when `twittervotes` publishes a vote on that topic,
    we can handle it in this program. If `NewConsumer` returns an error, we'll use
    our `fatal` function to record it and return.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewConsumer`函数允许我们设置一个对象，该对象将侦听`votes` NSQ主题，因此当`twittervotes`在该主题上发布选票时，我们可以在此程序中处理它。如果`NewConsumer`返回错误，我们将使用我们的`fatal`函数来记录并返回。'
- en: 'Next we are going to add the code that handles messages (votes) from NSQ:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加处理来自NSQ的消息（选票）的代码：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We call the `AddHandler` method on `nsq.Consumer` and pass it a function that
    will be called for every message received on the `votes` topic.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`nsq.Consumer`上调用`AddHandler`方法，并将一个函数传递给它，该函数将在接收到“votes”主题上的每条消息时调用。
- en: When a vote comes in, the first thing we do is lock the `countsLock` mutex.
    Next we defer the unlocking of the mutex for when the function exits. This allows
    us to be sure that while `NewConsumer` is running, we are the only ones allowed
    to modify the map; others will have to wait until our function exits before they
    can use it. Calls to the `Lock` method block execution while the lock is in place,
    and it only continues when the lock is released by a call to `Unlock` . This is
    why it's vital that every `Lock` call has an `Unlock` counterpart, otherwise we
    will deadlock our program.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当选票到来时，我们首先锁定`countsLock`互斥体。接下来，我们推迟了互斥体的解锁，以便在函数退出时解锁。这使我们确信，在`NewConsumer`运行时，我们是唯一被允许修改地图的人；其他人必须等到我们的函数退出后才能使用它。对`Lock`方法的调用在放置锁时阻止执行，只有在通过调用`Unlock`释放锁时才继续执行。这就是为什么每个`Lock`调用都必须有一个`Unlock`对应项的原因，否则我们将使程序死锁。
- en: Every time we receive a vote, we check if `counts` is `nil` and make a new map
    if it is, because once the database has been updated with the latest results,
    we want to reset everything and start at zero. Finally we increase the `int` value
    by one for the given key, and return `nil` indicating no errors.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收到一张选票时，我们都会检查`counts`是否为`nil`，如果是，则创建一个新地图，因为一旦数据库已更新为最新结果，我们希望重置一切并从零开始。最后，我们增加给定键的`int`值一次，并返回`nil`表示没有错误。
- en: 'Although we have created our NSQ consumer, and added our handler function,
    we still need to connect to the NSQ service, which we will do by adding the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经创建了NSQ消费者，并添加了处理程序函数，但我们仍然需要连接到NSQ服务，我们将通过添加以下代码来实现：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is important to note that we are actually connecting to the HTTP port of
    the `nsqlookupd` instance, rather than NSQ instances; this abstraction means that
    our program doesn't need to know *where* the messages are coming from in order
    to consume them. If we fail to connect to the server (for instance if we forget
    to start it), we'll get an error, which we report to our fatal function before
    immediately returning.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们实际上是连接到`nsqlookupd`实例的HTTP端口，而不是NSQ实例；这种抽象意味着我们的程序不需要知道消息来自何处才能消费它们。如果我们无法连接到服务器（例如，如果我们忘记启动它），我们将收到错误，我们会在立即返回之前将其报告给我们的致命函数。
- en: Keeping the database updated
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持数据库更新
- en: 'Our code will listen out for votes, and keep a map of the results in memory,
    but that information is so far trapped inside our program. Next, we need to add
    the code that will periodically push the results to the database:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将监听投票，并在内存中保留结果的映射，但是这些信息目前被困在我们的程序中。接下来，我们需要添加定期将结果推送到数据库的代码：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `time.AfterFunc` function calls the function after the specified duration
    in a goroutine of its own. At the end we call `Reset` , which starts the process
    again; this allows us to schedule our update code to run at regular intervals.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.AfterFunc`函数在指定的持续时间后调用函数的goroutine。最后我们调用`Reset`，重新开始这个过程；这允许我们定期安排我们的更新代码定期运行。'
- en: When our update function runs, the first thing we do is lock the `countsLock`
    , and defer its unlocking. We then check to see if there are any values in the
    counts map. If there aren't, we just log that we're skipping the update and wait
    for next time.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的更新函数运行时，我们首先锁定`countsLock`，并推迟其解锁。然后我们检查计数映射中是否有任何值。如果没有，我们只是记录我们正在跳过更新，并等待下一次。
- en: If there are some votes, we iterate over the `counts` map pulling out the option
    and number of votes (since the last update), and use some MongoDB magic to update
    the results.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一些投票，我们会遍历`counts`映射，提取选项和投票数（自上次更新以来），并使用一些MongoDB魔法来更新结果。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB stores BSON (short for Binary JSON) documents internally, which are
    easier to traverse than normal JSON documents, and is why the `mgo` package comes
    with `mgo/bson` encoding package. When using `mgo` , we will often use `bson`
    types, such as the `bson.M` map to describe concepts for MongoDB.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB在内部存储BSON（二进制JSON）文档，这比普通JSON文档更容易遍历，这就是为什么`mgo`包带有`mgo/bson`编码包。在使用`mgo`时，我们经常使用`bson`类型，例如`bson.M`映射来描述MongoDB的概念。
- en: 'We first create the selector for our update operation using the `bson.M` shortcut
    type, which is similar to creating `map[string]interface{}` types. The selector
    we create will look something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`bson.M`快捷类型创建我们的更新操作的选择器，这类似于创建`map[string]interface{}`类型。我们创建的选择器将大致如下：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In MongoDB, the preceding BSON specifies that we want to select polls where
    `"happy"` is one of the items in the `options` array.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，前面的BSON指定我们要选择`options`数组中包含`"happy"`的选项的投票。
- en: 'Next, we use the same technique to generate the update operation, which looks
    something like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用相同的技术生成更新操作，大致如下：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In MongoDB, the preceding BSON specifies that we want to increase the `results.happy`
    field by 3\. If there is no `results` map in the poll, one will be created, and
    if there is no `happy` key inside `results` , `0` will be assumed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB中，前面的BSON指定我们要将`results.happy`字段增加3。如果投票中没有`results`映射，将创建一个，如果`results`中没有`happy`键，则假定为`0`。
- en: We then call the `UpdateAll` method on our `pollsData` query to issue the command
    to the database, which will in turn update every poll that matches the selector
    (contrast this to the `Update` method, which will update only one). If something
    goes wrong, we report it and set the `ok` Boolean to false. If all goes well,
    we set the `counts` map to nil, since we want to reset the counter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`pollsData`查询上的`UpdateAll`方法来向数据库发出命令，这将依次更新与选择器匹配的每个投票（与`Update`方法相反，它只会更新一个）。如果出现问题，我们会报告并将`ok`布尔值设置为false。如果一切顺利，我们将`counts`映射设置为nil，因为我们想重置计数器。
- en: 'We are going to specify the `updateDuration` as a constant at the top of the
    file, which will make it easy for us to change when we are testing our program.
    Add the following code above the `main` function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在文件顶部将`updateDuration`指定为常量，这将使我们在测试程序时更容易进行更改。在`main`函数上面添加以下代码：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Responding to Ctrl + C
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应Ctrl + C
- en: 'The last thing to do before our program is ready is to make sure our `main`
    function waits for operations to complete before exiting, like we did in our `twittervotes`
    program. Add the following code at the end of the `main` function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序准备就绪之前要做的最后一件事是确保我们的`main`函数在退出之前等待操作完成，就像我们在`twittervotes`程序中所做的那样。在`main`函数的末尾添加以下代码：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we have employed a slightly different tactic than before. We trap the termination
    event, which will cause a signal to go down `termChan` when we hit *Ctrl + C*
    . Next we start an infinite loop, inside which we use Go's `select` structure
    to allow us to run code if we receive something on either `termChan` , or the
    `StopChan` of the consumer.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们采用了与以前略有不同的策略。我们捕获终止事件，这将导致在我们按下*Ctrl + C*时通过`termChan`发送信号。接下来，我们启动一个无限循环，在循环内部，我们使用Go的`select`结构，使我们能够在`termChan`或消费者的`StopChan`上接收到东西时运行代码。
- en: In fact, we will only ever get a `termChan` signal first in response to a `Ctrl+C`
    -press, at which point we stop the `updater` timer and ask the consumer to stop
    listening for votes. Execution then re-enters the loop and will block until the
    consumer reports that it has indeed stopped by signaling on its `StopChan` . When
    that happens, we're done and we exit, at which point our deferred statement runs,
    which, if you remember, tidies up the database session.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只会在按下`Ctrl+C`时首先收到`termChan`信号，此时我们会停止`updater`计时器，并要求消费者停止监听投票。然后执行重新进入循环，并阻塞直到消费者通过在其`StopChan`上发出信号来报告已经停止。当这发生时，我们完成并退出，此时我们的延迟语句运行，如果您记得的话，它会整理数据库会话。
- en: Running our solution
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的解决方案
- en: 'It''s time to see our code in action. Be sure to have `nsqlookupd` , `nsqd`
    , and `mongod` running in separate terminal windows with:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看到我们的代码在运行了。确保在单独的终端窗口中运行`nsqlookupd`，`nsqd`和`mongod`：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you haven''t already done so, make sure the `twittervotes` program is running
    too. Then in the `counter` folder, build and run our counting program:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请确保`twittervotes`程序也在运行。然后在`counter`文件夹中，构建并运行我们的计数程序：
- en: '[PRE42]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see periodic output describing what work `counter` is doing, such
    as:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到定期的输出，描述`counter`正在做的工作，比如：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The output will of course vary since we are actually responding to real live
    activity on Twitter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出当然会有所不同，因为我们实际上是在回应Twitter上的实时活动。
- en: 'We can see that our program is receiving vote data from NSQ, and reports to
    be updating the database with the results. We can confirm this by opening the
    MongoDB shell and querying the poll data to see if the `results` map is being
    updated. In another terminal window, open the MongoDB shell:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的程序正在从NSQ接收投票数据，并报告正在更新数据库的结果。我们可以通过打开MongoDB shell并查询投票数据来确认这一点，看看`results`
    map是否正在更新。在另一个终端窗口中，打开MongoDB shell：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Ask it to use the ballots database:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要求它使用选票数据库：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use the find method with no arguments to get all polls (add the `pretty` method
    to the end to get nicely formatted JSON):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无参数的find方法获取所有投票（在末尾添加`pretty`方法以获得格式良好的JSON）：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `results` map is indeed being updated, and at any point in time contains
    the total number of votes for each option.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`results` map 确实在更新，并且随时包含每个选项的总票数。'
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we covered a lot of ground. We learned different techniques
    for gracefully shutting down programs using signaling channels, which is especially
    important when our code has some work to do before it can exit. We saw that deferring
    the reporting of fatal errors at the start of our program can give our other deferred
    functions a chance to execute before the process ends.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。我们学习了使用信号通道优雅地关闭程序的不同技术，这在我们的代码在退出之前需要做一些工作时尤其重要。我们看到，在程序开始时推迟报告致命错误可以让我们的其他推迟函数有机会在进程结束之前执行。
- en: We also discovered how easy it is to interact with MongoDB using the `mgo` package,
    and how to use BSON types when describing concepts for the database. The `bson.M`
    alternative to `map[string]interface{}` helps us keep our code more concise, while
    still providing all the flexibility we need when working with unstructured or
    schemaless data.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现使用`mgo`包与MongoDB进行交互是多么容易，并且在描述数据库概念时如何使用BSON类型。`bson.M`替代了`map[string]interface{}`，帮助我们保持代码更简洁，同时仍然提供了我们在处理非结构化或无模式数据时所需的所有灵活性。
- en: We learned about message queues and how they allow us to break apart the components
    of a system into isolated and specialized micro-services. We started an instance
    of NSQ by first running the lookup daemon `nsqlookupd` , before running a single
    `nsqd` instance and connecting them together via a TCP interface. We were then
    able to publish votes to the queue in `twittervotes` , and connect to the lookup
    daemon to run a handler function for every vote sent in our `counter` program.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了消息队列以及它们如何允许我们将系统的组件分解为独立和专业化的微服务。我们首先运行查找守护程序`nsqlookupd`，然后运行单个`nsqd`实例，并通过TCP接口将它们连接在一起。然后我们能够在`twittervotes`中将投票发布到队列中，并连接到查找守护程序，在我们的`counter`程序中为每个发送的投票运行处理函数。
- en: While our solution is actually performing a pretty simple task, the architecture
    we have put together in this chapter is capable of doing some pretty great things.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的解决方案实际上执行的是一个非常简单的任务，但是我们在本章中构建的架构能够做一些非常了不起的事情。
- en: We eliminated the need for our `twittervotes` and `counter` programs to run
    on the same machine—as long as they can both connect to the appropriate NSQ, they
    will function as expected regardless of where they are running.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们消除了`twittervotes`和`counter`程序需要在同一台机器上运行的需求——只要它们都能连接到适当的NSQ，无论它们在哪里运行，它们都会按预期运行。
- en: We can distribute our MongoDB and NSQ nodes across many physical machines which
    would mean our system is capable of gigantic scale—whenever resources start running
    low, we can add new boxes to cope with the demand.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将我们的MongoDB和NSQ节点分布在许多物理机器上，这意味着我们的系统能够实现巨大的规模——每当资源开始不足时，我们可以添加新的盒子来满足需求。
- en: When we add other applications that need to query and read the results from
    polls, we can be sure that our database services are highly available and capable
    of delivering.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们添加其他需要查询和读取投票结果的应用程序时，我们可以确保我们的数据库服务是高度可用的，并且能够提供服务。
- en: We can spread our database across geographical expanses replicating data for
    backup so we don't lose anything when disaster strikes.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将我们的数据库分布在地理范围内，复制数据以备份，这样当灾难发生时我们不会丢失任何东西。
- en: We can build a multi-node, fault tolerant NSQ environment, which means when
    our `twittervotes` program learns of interesting tweets, there will always be
    somewhere to send the data.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以构建一个多节点、容错的NSQ环境，这意味着当我们的`twittervotes`程序了解到有趣的推文时，总会有地方发送数据。
- en: We could write many more programs that generate votes from different sources;
    the only requirement is that they know how to put messages into NSQ.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写更多的程序，从不同的来源生成投票；唯一的要求是它们知道如何将消息放入NSQ。
- en: In the next chapter, we will build a RESTful data service of our own, through
    which we will expose the functionality of our social polling application. We will
    also build a web interface that lets users create their own polls, and visualize
    the results.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建自己的RESTful数据服务，通过它我们将公开我们社交投票应用程序的功能。我们还将构建一个Web界面，让用户创建自己的投票，并可视化结果。
