- en: Chapter 6. Exposing Data and Functionality through a RESTful Data Web Service
    API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。通过RESTful数据Web服务API公开数据和功能
- en: In the previous chapter, we built a service that reads tweets from Twitter,
    counts the hashtag votes, and stores the results in a MongoDB database. We also
    used the MongoDB shell to add polls and see the poll results. This approach is
    fine if we are the only ones using our solution, but it would be madness if we
    released our project and expected users to connect directly to our MongoDB instance
    in order to use the service we built.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个从Twitter读取推文，计算标签投票并将结果存储在MongoDB数据库中的服务。我们还使用了MongoDB shell来添加投票并查看投票结果。如果我们是唯一使用我们的解决方案的人，那么这种方法是可以的，但是如果我们发布我们的项目并期望用户直接连接到我们的MongoDB实例以使用我们构建的服务，那将是疯狂的。
- en: Therefore, in this chapter, we are going to build a RESTful data service through
    which the data and functionality will be exposed. We will also put together a
    simple website that consumes the new API. Users may then either use our website
    to create and monitor polls or build their own application on top of the web services
    we release.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将构建一个RESTful数据服务，通过该服务将数据和功能公开。我们还将组建一个简单的网站来消费新的API。用户可以使用我们的网站创建和监视投票，或者在我们发布的Web服务之上构建自己的应用程序。
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The code in this chapter depends on the code in [Chapter 5](text00036.html#page
    "Chapter 5. Building Distributed Systems and Working with Flexible Data") , *Building
    Distributed Systems and Working with Flexible Data* , so it is recommended that
    you complete that chapter first, especially since it covers setting up the environment
    that the code in this chapter runs on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码依赖于[第5章](text00036.html#page "第5章。构建分布式系统并使用灵活数据")中的代码，*构建分布式系统并使用灵活数据*，因此建议您首先完成该章节，特别是因为它涵盖了设置本章代码运行的环境。
- en: 'Specifically, you will learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，您将学到：
- en: How wrapping `http.HandlerFunc` types can give us a simple but powerful pipeline
    of execution for our HTTP requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何包装`http.HandlerFunc`类型可以为我们的HTTP请求提供一个简单但强大的执行管道
- en: How to safely share data between HTTP handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在HTTP处理程序之间安全共享数据
- en: Best practices for writing handlers responsible for exposing data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写负责公开数据的处理程序的最佳实践
- en: Where small abstractions can allow us to write the simplest possible implementations
    now, but leave room to improve them later without changing the interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小的抽象可以让我们现在编写尽可能简单的实现，但留下改进它们的空间，而不改变接口
- en: How adding simple helper functions and types to our project will prevent us
    from (or at least defer) adding dependencies on external packages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向我们的项目添加简单的辅助函数和类型将防止我们（或至少推迟）对外部包添加依赖
- en: RESTful API design
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API设计
- en: For an API to be considered RESTful, it must adhere to a few principles that
    stay true to the original concepts behind the Web, and are already known to most
    developers. Such an approach allows us to make sure we aren't building anything
    strange or unusual into our API while also giving our users a head start towards
    consuming it, since they are already familiar with its concepts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使API被视为RESTful，它必须遵循一些原则，这些原则忠实于Web背后的原始概念，并且大多数开发人员已经了解。这种方法可以确保我们没有在API中构建任何奇怪或不寻常的东西，同时也让我们的用户提前消费它，因为他们已经熟悉其概念。
- en: 'Some of the most important RESTful design concepts are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最重要的RESTful设计概念是：
- en: HTTP methods describe the kind of action to take, for example, `GET` methods
    will only ever *read* data, while `POST` requests will *create* something
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法描述要采取的操作类型，例如，`GET`方法只会*读取*数据，而`POST`请求将*创建*某些东西
- en: Data is expressed as a collection of resources
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据表示为资源集合
- en: Actions are expressed as changes to data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作被表达为对数据的更改
- en: URLs are used to refer to specific data
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL用于引用特定数据
- en: HTTP headers are used to describe the kind of representation coming into and
    going out of the server
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头用于描述进入和离开服务器的表示形式
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For an in-depth overview of these and other details of RESTful designs, see
    the Wikipedia article at [http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer)
    .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解RESTful设计的这些和其他细节，请参阅维基百科文章[http://en.wikipedia.org/wiki/Representational_state_transfer](http://en.wikipedia.org/wiki/Representational_state_transfer)。
- en: 'The following table shows the HTTP methods and URLs that represent the actions
    that we will support in our API, along with a brief description and an example
    use case of how we intend the call to be used:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的API中支持的HTTP方法和URL，以及我们打算如何使用调用的简要描述和示例用例：
- en: '| Request | Description | Use case |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 请求 | 描述 | 用例 |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `GET /polls/` | Read all polls | Show a list of polls to the users |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `GET /polls/` | 读取所有投票 | 向用户显示投票列表 |'
- en: '| `GET /polls/{id}` | Read the poll | Show details or results of a specific
    poll |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `GET /polls/{id}` | 读取投票 | 显示特定投票的详细信息或结果 |'
- en: '| `POST /polls/` | Create a poll | Create a new poll |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `POST /polls/` | 创建投票 | 创建新的投票 |'
- en: '| `DELETE /polls/{id}` | Delete a poll | Delete a specific poll |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE /polls/{id}` | 删除投票 | 删除特定投票 |'
- en: The `{id}` placeholder represents where in the path the unique ID for a poll
    will go.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`{id}`占位符表示路径中唯一的投票ID的位置。'
- en: Sharing data between handlers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在处理程序之间共享数据
- en: 'If we want to keep our handlers as pure as the `http.Handler` interface from
    the Go standard library, while still extracting common functionality into our
    own methods, we need a way of sharing data between handlers. The `HandlerFunc`
    signature that follows tells us that we are only allowed to pass in an `http.ResponseWriter`
    object and an `http.Request` object, and nothing else:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望保持处理程序与Go标准库中的`http.Handler`接口一样纯净，同时将常见功能提取到我们自己的方法中，我们需要一种在处理程序之间共享数据的方法。以下的`HandlerFunc`签名告诉我们，我们只允许传入一个`http.ResponseWriter`对象和一个`http.Request`对象，什么都不能传入：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that we cannot create and manage database session objects in one
    place and pass them into our handlers, which is ideally what we want to do.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不能在一个地方创建和管理数据库会话对象，然后将它们传递给我们的处理程序，这理想情况下是我们想要做的。
- en: 'Instead, we are going to implement an in-memory map of per-request data, and
    provide an easy way for handlers to access it. Alongside the `twittervotes` and
    `counter` folders, create a new folder called `api` and create a new file called
    `vars.go` inside it. Add the following code to the file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将实现一个按请求数据的内存映射，并为处理程序提供一种轻松访问它的方式。在`twittervotes`和`counter`文件夹旁边，创建一个名为`api`的新文件夹，并在其中创建一个名为`vars.go`的新文件。将以下代码添加到文件中：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we declare a `vars` map that has a pointer to an `http.Request` type as
    its key, and another map as the value. We will store the map of variables keyed
    with the request instances that the variables belong to. The `varsLock` mutex
    is important, as our handlers will all be trying to access and change the `vars`
    map at the same time as handling many concurrent HTTP requests, and we need to
    ensure that they do this safely.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个`vars`映射，它的键是指向`http.Request`类型的指针，值是另一个映射。我们将存储与请求实例相关联的变量映射。`varsLock`互斥锁很重要，因为我们的处理程序将同时尝试访问和更改`vars`映射，同时处理许多并发的HTTP请求，我们需要确保它们可以安全地执行这些操作。
- en: 'Next we are going to add the `OpenVars` function that allows us to prepare
    the `vars` map to hold variables for a particular request:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`OpenVars`函数，允许我们准备`vars`映射以保存特定请求的变量：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function first locks the mutex so that we can safely modify the map, before
    ensuring that `vars` contains a non-nil map, which would otherwise cause a panic
    when we try to access its data. Finally, it assigns a new empty `map` value using
    the specified `http.Request` pointer as the key, before unlocking the mutex and
    therefore freeing other handlers to interact with it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先锁定互斥锁，以便我们可以安全地修改映射，然后确保`vars`包含一个非nil映射，否则当我们尝试访问其数据时会导致恐慌。最后，它使用指定的`http.Request`指针作为键，分配一个新的空`map`值，然后解锁互斥锁，从而释放其他处理程序与之交互。
- en: 'Once we have finished handling the request, we need a way to clean up the memory
    that we are using here; otherwise the memory footprint of our code would continuously
    increase (also known as a memory leak). We do this by adding a `CloseVars` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了处理请求，我们需要一种方法来清理我们在这里使用的内存；否则，我们的代码的内存占用将不断增加（也称为内存泄漏）。我们通过添加`CloseVars`函数来实现这一点：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function safely deletes the entry in the `vars` map for the request. As
    long as we call `OpenVars` before we try to interact with the variables, and `CloseVars`
    when we have finished, we will be free to safely store and retrieve data for each
    request. However, we don''t want our handler code to have to worry about locking
    and unlocking the map whenever it needs to get or set some data, so let''s add
    two helper functions, `GetVar` and `SetVar` :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数安全地删除了请求的`vars`映射中的条目。只要我们在尝试与变量交互之前调用`OpenVars`，并在完成后调用`CloseVars`，我们就可以自由地安全地存储和检索每个请求的数据。但是，我们不希望我们的处理程序代码在需要获取或设置一些数据时担心锁定和解锁映射，因此让我们添加两个辅助函数，`GetVar`和`SetVar`：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `GetVar` function will make it easy for us to get a variable from the map
    for the specified request, and `SetVar` allows us to set one. Notice that the
    `GetVar` function calls `RLock` and `RUnlock` rather than `Lock` and `Unlock`
    ; this is because we're using `sync.RWMutex` , which means it's safe for many
    reads to occur at the same time, as long as a write isn't happening. This is good
    for performance on items that are safe to concurrently read from. With a normal
    mutex, `Lock` would block execution—waiting for the thing that has locked it to
    unlock it—while `RLock` will not.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetVar`函数将使我们能够轻松地从映射中获取指定请求的变量，`SetVar`允许我们设置一个。请注意，`GetVar`函数调用`RLock`和`RUnlock`而不是`Lock`和`Unlock`；这是因为我们使用了`sync.RWMutex`，这意味着可以安全地同时进行许多读取，只要没有写入发生。这对于可以同时读取的项目的性能是有利的。对于普通的互斥锁，`Lock`会阻塞执行，等待锁定它的东西解锁它，而`RLock`则不会。'
- en: Wrapping handler functions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装处理程序函数
- en: One of the most valuable patterns to learn when building web services and websites
    in Go is one we already utilized in [Chapter 2](text00020.html#page "Chapter 2. Adding
    Authentication") , *Adding Authentication* , where we decorated `http.Handler`
    types by wrapping them with other `http.Handler` types. For our RESTful API, we
    are going to apply this same technique to `http.HandlerFunc` functions, to deliver
    an extremely powerful way of modularizing our code without breaking the standard
    `func(w http.ResponseWriter, r *http.Request)` interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Go中的Web服务和网站时，学习的最有价值的模式之一是我们在[第2章](text00020.html#page "第2章。添加身份验证")中已经使用过的*添加身份验证*，在那里我们通过用其他`http.Handler`类型包装它们来装饰`http.Handler`类型。对于我们的RESTful
    API，我们将应用相同的技术到`http.HandlerFunc`函数上，以提供一种非常强大的模块化代码的方式，而不会破坏标准的`func(w http.ResponseWriter,
    r *http.Request)`接口。
- en: API key
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API密钥
- en: Most web APIs require clients to register an API key for their application,
    which they are asked to send along with every request. Such keys have many purposes,
    ranging from simply identifying which app the requests are coming from to addressing
    authorization concerns in situations where some apps are only able to do limited
    things based on what a user has allowed. While we don't actually need to implement
    API keys for our application, we are going to ask clients to provide one, which
    will allow us to add an implementation later while keeping the interface constant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web API要求客户端为其应用程序注册一个API密钥，并要求他们在每个请求中发送该密钥。这些密钥有许多用途，从简单地识别请求来自哪个应用程序到解决授权问题，例如一些应用程序只能根据用户允许的内容做有限的事情。虽然我们实际上不需要为我们的应用程序实现API密钥，但我们将要求客户端提供一个，这将允许我们在保持接口不变的同时稍后添加实现。
- en: 'Add the essential `main.go` file inside your `api` folder:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`api`文件夹中添加必要的`main.go`文件：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next we are going to add our first `HandlerFunc` wrapper function called `withAPIKey`
    to the bottom of `main.go` :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`main.go`的底部添加我们的第一个`HandlerFunc`包装器函数，名为`withAPIKey`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, our `withAPIKey` function both takes an `http.HandlerFunc` type
    as an argument and returns one; this is what we mean by wrapping in this context.
    The `withAPIKey` function relies on a number of other functions that we are yet
    to write, but you can clearly see what's going on. Our function immediately returns
    a new `http.HandlerFunc` type that performs a check for the query parameter `key`
    by calling `isValidAPIKey` . If the key is deemed invalid (by the return of `false`
    ), we respond with an `invalid API key` error. To use this wrapper, we simply
    pass an `http.HandlerFunc` type into this function to enable the `key` parameter
    check. Since it returns an `http.HandlerFunc` type too, the result can then be
    passed into other wrappers or given directly to the `http.HandleFunc` function
    to actually register it as the handler for a particular path pattern.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`withAPIKey`函数既接受一个`http.HandlerFunc`类型作为参数，又返回一个；这就是我们在这个上下文中所说的包装。`withAPIKey`函数依赖于许多其他我们尚未编写的函数，但你可以清楚地看到发生了什么。我们的函数立即返回一个新的`http.HandlerFunc`类型，通过调用`isValidAPIKey`来检查查询参数`key`。如果密钥被认为是无效的（通过返回`false`），我们将回应一个`无效的API密钥`错误。要使用这个包装器，我们只需将一个`http.HandlerFunc`类型传递给这个函数，以启用`key`参数检查。由于它也返回一个`http.HandlerFunc`类型，因此结果可以被传递到其他包装器中，或者直接传递给`http.HandleFunc`函数，以实际将其注册为特定路径模式的处理程序。
- en: 'Let''s add our `isValidAPIKey` function next:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来添加我们的`isValidAPIKey`函数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For now, we are simply going to hardcode the API key as `abc123` ; anything
    else will return `false` and therefore be considered invalid. Later we could modify
    this function to consult a configuration file or database to check the authenticity
    of a key without affecting how we use the `isValidAPIKey` method, or indeed the
    `withAPIKey` wrapper.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是将API密钥硬编码为`abc123`；其他任何内容都将返回`false`，因此被视为无效。稍后，我们可以修改这个函数，以查阅配置文件或数据库来检查密钥的真实性，而不影响我们如何使用`isValidAPIKey`方法，或者`withAPIKey`包装器。
- en: Database session
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库会话
- en: 'Now that we can be sure a request has a valid API key, we must consider how
    handlers will connect to the database. One option is to have each handler dial
    its own connection, but this isn''t very **DRY** ( **Don''t Repeat Yourself**
    ), and leaves room for potentially erroneous code, such as code that forgets to
    close a database session once it is finished with it. Instead, we will create
    another `HandlerFunc` wrapper that manages the database session for us. In `main.go`
    , add the following function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以确保请求有一个有效的API密钥，我们必须考虑处理程序将如何连接到数据库。一种选择是让每个处理程序拨号自己的连接，但这并不是很**DRY**（**不要重复自己**），并且留下了潜在错误的空间，比如忘记在完成后关闭数据库会话的代码。相反，我们将创建另一个管理数据库会话的`HandlerFunc`包装器。在`main.go`中，添加以下函数：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `withData` function takes a MongoDB session representation using the `mgo`
    package, and another handler as per the pattern. The returned `http.HandlerFunc`
    type will copy the database session, defer the closing of that copy, and set a
    reference to the `ballots` database as the `db` variable using our `SetVar` helper,
    before finally calling the next `HandlerFunc` . This means that any handlers that
    get executed after this one will have access to a managed database session via
    the `GetVar` function. Once the handlers have finished executing, the deferred
    closing of the session will occur, which will clean up any memory used by the
    request without the individual handlers having to worry about it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`withData`函数使用`mgo`包来接受一个MongoDB会话表示，以及另一个处理程序，符合该模式。返回的`http.HandlerFunc`类型将复制数据库会话，延迟关闭该副本，并使用我们的`SetVar`助手将`ballots`数据库的引用设置为`db`变量，最后调用下一个`HandlerFunc`。这意味着在此之后执行的任何处理程序都将通过`GetVar`函数访问受管数据库会话。一旦处理程序执行完毕，延迟关闭会话将发生，这将清理请求使用的任何内存，而无需个别处理程序担心它。'
- en: Per request variables
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个请求的变量
- en: Our pattern allows us to very easily perform common tasks on behalf of our actual
    handlers. Notice that one of the handlers is calling `OpenVars` and `CloseVars`
    so that `GetVar` and `SetVar` may be used without individual handlers having to
    concern themselves with setting things up and tearing them down. The function
    will return an `http.HandlerFunc` that first calls `OpenVars` for the request,
    defers the calling of `CloseVars` , and calls the specified handler function.
    Any handlers wrapped with `withVars` will be able to use `GetVar` and `SetVar`
    .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式允许我们非常轻松地代表我们的实际处理程序执行常见任务。请注意，其中一个处理程序正在调用`OpenVars`和`CloseVars`，以便`GetVar`和`SetVar`可以在不必关心设置和拆卸的情况下使用。该函数将返回一个首先调用`OpenVars`进行请求的`http.HandlerFunc`，延迟调用`CloseVars`，并调用指定的处理程序函数。任何使用`withVars`包装的处理程序都可以使用`GetVar`和`SetVar`。
- en: 'Add the following code to `main.go` :'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.go`：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are lots of other problems that can be addressed using this pattern; and
    whenever you find yourself duplicating common tasks inside handlers, it's worth
    considering whether a handler wrapper function could help simplify code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式可以解决许多其他问题；每当你发现自己在处理程序内部重复常见任务时，都值得考虑是否处理程序包装函数可以帮助简化代码。
- en: Cross-browser resource sharing
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨浏览器资源共享
- en: 'The same-origin security policy mandates that AJAX requests in web browsers
    be only allowed for services hosted on the same domain, which would make our API
    fairly limited since we won''t be necessarily hosting all of the websites that
    use our web service. The CORS technique circumnavigates the same-origin policy,
    allowing us to build a service capable of serving websites hosted on other domains.
    To do this, we simply have to set the `Access-Control-Allow-Origin` header in
    response to `*` . While we''re at it—since we''re using the `Location` header
    in our create poll call—we''ll allow that header to be accessible by the client
    too, which can be done by listing it in the `Access-Control-Expose-Headers` header.
    Add the following code to `main.go` :'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同源安全策略要求Web浏览器中的AJAX请求只允许服务于同一域上托管的服务，这将使我们的API相当受限，因为我们不一定会托管使用我们Web服务的所有网站。CORS技术绕过了同源策略，允许我们构建一个能够为其他域上托管的网站提供服务的服务。为此，我们只需在响应中设置`Access-Control-Allow-Origin`头为`*`。顺便说一句，因为我们在创建投票调用中使用了`Location`头，我们也将允许客户端访问该头，这可以通过在`Access-Control-Expose-Headers`头中列出来实现。在`main.go`中添加以下代码：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the simplest wrapper function yet; it just sets the appropriate header
    on the `ResponseWriter` type and calls the specified `http.HandlerFunc` type.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的包装函数，它只是在`ResponseWriter`类型上设置适当的头，并调用指定的`http.HandlerFunc`类型。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this chapter, we are handling CORS explicitly so we can understand exactly
    what is going on; for real production code, you should consider employing an open
    source solution such as [https://github.com/fasterness/cors](https://github.com/fasterness/cors)
    .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们明确处理CORS，以便我们可以准确了解发生了什么；对于真正的生产代码，您应该考虑使用开源解决方案，比如[https://github.com/fasterness/cors](https://github.com/fasterness/cors)。
- en: 读累了记得休息一会哦~
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 网站：[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)
- en: 电子书搜索下载
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Responding
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应
- en: A big part of any API is responding to requests with a combination of status
    codes, data, errors, and sometimes headers—the `net/http` package makes all of
    this very easy to do. One option we have, which remains the best option for tiny
    projects or even the early stages of big projects, is to just build the response
    code directly inside the handler. As the number of handlers grows, however, we
    would end up duplicating a lot of code and sprinkling representation decisions
    all over our project. A more scalable approach is to abstract the response code
    into helper functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何API的重要部分是以状态码、数据、错误和有时头部的组合来响应请求，`net/http`包使得所有这些都非常容易实现。我们有一个选项，对于小型项目或者大项目的早期阶段来说，仍然是最好的选项，那就是直接在处理程序中构建响应代码。然而，随着处理程序数量的增加，我们将不得不重复大量的代码，并在整个项目中散布表示决策。一个更可扩展的方法是将响应代码抽象成助手函数。
- en: For the first version of our API, we are going to speak only JSON, but we want
    the flexibility to add other representations later if we need to.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们API的第一个版本，我们将只使用JSON，但如果需要，我们希望灵活地添加其他表示。
- en: 'Create a new file called `respond.go` , and add the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`respond.go`的新文件，并添加以下代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These two functions abstract the decoding and encoding of data from and to the
    `Request` and `ResponseWriter` objects respectively. The decoder also closes the
    request body, which is recommended. Although we haven't added much functionality
    here, it means that we do not need to mention JSON anywhere else in our code,
    and if we decide to add support for other representations or switch to a binary
    protocol instead, we need only touch these two functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数分别抽象了从`Request`和`ResponseWriter`对象解码和编码数据。解码器还关闭了请求体，这是推荐的。虽然我们在这里没有添加太多功能，但这意味着我们不需要在代码的其他地方提到JSON，如果我们决定添加对其他表示的支持或者切换到二进制协议，我们只需要修改这两个函数。
- en: 'Next we are going to add a few more helpers that will make responding even
    easier. In `respond.go` , add the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些更多的助手，使得响应变得更加容易。在`respond.go`中，添加以下代码：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function makes it easy to write the status code and some data to the `ResponseWriter`
    object using our `encodeBody` helper.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使得使用我们的`encodeBody`助手，可以轻松地将状态码和一些数据写入`ResponseWriter`对象。
- en: 'Handling errors is another important aspect that is worth abstracting. Add
    the following `respondErr` helper:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误是另一个值得抽象的重要方面。添加以下`respondErr`助手：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method gives us an interface similar to the `respond` function, but the
    data written will be enveloped in an `error` object, to make it clear that something
    went wrong. Finally, we can add an HTTP error-specific helper that will generate
    the correct message for us by using the `http.StatusText` function from the Go
    standard library:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法给我们提供了一个类似于`respond`函数的接口，但写入的数据将被包装在一个`error`对象中，以明确表示出现了问题。最后，我们可以添加一个特定于HTTP错误的助手，通过使用Go标准库中的`http.StatusText`函数为我们生成正确的消息：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that these functions are all dogfooding, which means they use each other
    (as in, eating your own dog food), which is important since we want actual responding
    to only happen in one place, for if (or more likely, when) we need to make changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些函数都是dogfooding，这意味着它们彼此使用（就像吃自己的狗粮一样），这很重要，因为我们希望实际的响应只发生在一个地方，以便在需要进行更改时（或更可能的是，何时需要进行更改）。
- en: Understanding the request
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解请求
- en: 'The `http.Request` object gives us access to every piece of information we
    might need about the underlying HTTP request, and therefore it is worth glancing
    through the `net/http` documentation to really get a feel for its power. Examples
    include, but are not limited to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Request`对象为我们提供了关于底层HTTP请求的所有信息，因此值得浏览`net/http`文档，真正感受其强大之处。例如，但不限于：'
- en: URL, path and query string
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL、路径和查询字符串
- en: HTTP method
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法
- en: Cookies
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookies
- en: Files
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Form values
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单值
- en: Referrer and user agent of requester
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求者的引荐者和用户代理
- en: Basic authentication details
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本身份验证详细信息
- en: Request body
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求体
- en: Header information
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头信息
- en: There are a few things it doesn't address, which we need to either solve ourselves
    or look to an external package to help us with. URL path parsing is one such example—while
    we can access a path (such as `/people/1/books/2` ) as a string via the `http.Request`
    type's `URL.Path` field, there is no easy way to pull out the data encoded in
    the path such as the people ID of `1` , or the books ID of `2` .
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些问题它没有解决，我们需要自己解决或寻求外部包的帮助。URL路径解析就是一个例子——虽然我们可以通过`http.Request`类型的`URL.Path`字段访问路径（例如`/people/1/books/2`），但没有简单的方法来提取路径中编码的数据，比如`1`的people
    ID或`2`的books ID。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A few projects do a good job of addressing this problem, such as Goweb or Gorillz's
    `mux` package. They let you map path patterns that contain placeholders for values
    that they then pull out of the original string and make available to your code.
    For example, you can map a pattern of `/users/{userID}/comments/{commentID}` ,
    which will map paths such as `/users/1/comments/2` . In your handler code, you
    can then get the values by the names placed inside the curly braces, rather than
    having to parse the path yourself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目很好地解决了这个问题，比如Goweb或Gorillz的`mux`包。它们允许您映射包含占位符值的路径模式，然后从原始字符串中提取这些值并使其可用于您的代码。例如，您可以映射`/users/{userID}/comments/{commentID}`的模式，这将映射路径，如`/users/1/comments/2`。在处理程序代码中，您可以通过放在花括号内的名称获取值，而不必自己解析路径。
- en: Since our needs are simple, we are going to knock together a simple path-parsing
    utility; we can always use a different package later if we have to, but that would
    mean adding a dependency to our project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的需求很简单，我们将编写一个简单的路径解析工具；如果必要，我们随时可以使用不同的包，但这意味着向我们的项目添加依赖。
- en: 'Create a new file called `path.go` , and insert the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`path.go`的新文件，并插入以下代码：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This simple parser provides a `NewPath` function that parses the specified path
    string and returns a new instance of the `Path` type. Leading and trailing slashes
    are trimmed (using `strings.Trim` ) and the remaining path is split (using `strings.Split`
    ) by the `PathSeparator` constant that is just a forward slash. If there is more
    than one segment (`len(s) > 1` ), the last one is considered to be the ID. We
    re-slice the slice of strings to select the last item for the ID using `s[len(s)-1]`
    , and the rest of the items for the remainder of the path using `s[:len(s)-1]`
    . On the same lines, we also re-join the path segments with the `PathSeparator`
    constant to form a single string containing the path without the ID.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的解析器提供了一个`NewPath`函数，它解析指定的路径字符串并返回`Path`类型的新实例。前导和尾随斜杠被修剪（使用`strings.Trim`），剩下的路径被`PathSeparator`常量（即斜杠）分割（使用`strings.Split`）。如果有多个段（`len(s)
    > 1`），最后一个被认为是ID。我们重新切片字符串切片以使用`len(s)-1`选择最后一个项目作为ID，并使用`s[:len(s)-1]`选择路径的其余部分。在同样的行上，我们还使用`PathSeparator`常量重新连接路径段，以形成一个包含路径但不包含ID的单个字符串。
- en: 'This supports any `collection/id` pair, which is all we need for our API. The
    following table shows the state of the `Path` type for the given original path
    string:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这支持任何`collection/id`对，这正是我们API所需要的。以下表格显示了给定原始路径字符串的`Path`类型的状态：
- en: '| Original path string | Path | ID | HasID |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 原始路径字符串 | 路径 | ID | 是否有ID |'
- en: '| --- | --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `/` | `/` | `nil` | `false` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `/` | `nil` | `false` |'
- en: '| `/people/` | `people` | `nil` | `false` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `/people/` | `people` | `nil` | `false` |'
- en: '| `/people/1/` | `people` | `1` | `true` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `/people/1/` | `people` | `1` | `true` |'
- en: A simple main function to serve our API
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于提供我们的API的简单main函数
- en: A web service is nothing more than a simple Go program that binds to a specific
    HTTP address and port and serves requests, so we get to use all our command-line
    tool-writing knowledge and techniques.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务只不过是绑定到特定HTTP地址和端口并提供请求的简单Go程序，因此我们可以使用所有我们的命令行工具编写知识和技术。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We also want to ensure that our `main` function is as simple and modest as possible,
    which is always a goal of coding, especially in Go.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保我们的`main`函数尽可能简单和适度，这始终是编码的目标，特别是在Go中。
- en: 'Before we write our `main` function, let''s look at a few design goals of our
    API program:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的`main`函数之前，让我们看一下我们的API程序的一些设计目标：
- en: We should be able to specify the HTTP address and port to which our API listens
    and the address of the MongoDB instances without having to recompile the program
    (through command-line flags)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够指定API监听的HTTP地址和端口以及MongoDB实例的地址，而无需重新编译程序（通过命令行标志）
- en: We want the program to gracefully shut down when we terminate it, allowing the
    in-flight requests (requests that are still being processed when the termination
    signal is sent to our program) to complete
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望程序在我们终止它时能够优雅地关闭，允许正在处理的请求（在发送终止信号给我们的程序时仍在处理的请求）完成。
- en: We want the program to log out status updates and report errors properly
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望程序能够记录状态更新并正确报告错误
- en: 'Atop the `main.go` file, replace the `main` function placeholder with the following
    code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`文件的顶部，用以下代码替换`main`函数占位符：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This function is the entirety of our API `main` function, and even as our API
    grows, there is just a little bloat we would need to add to this.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就是我们的API `main`函数的全部内容，即使我们的API增长，我们只需要添加一点点冗余。
- en: The first thing we do is to specify two command-line flags, `addr` and `mongo`
    , with some sensible defaults, and to ask the `flag` package to parse them. We
    then attempt to dial the MongoDB database at the specified address. If we are
    unsuccessful, we abort with a call to `log.Fatalln` . Assuming the database is
    running and we are able to connect, we store the reference in the `db` variable
    before deferring the closing of the connection. This ensures our program properly
    disconnects and tidies up after itself when it ends.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是指定两个命令行标志`addr`和`mongo`，并使用一些合理的默认值，并要求`flag`包解析它们。然后我们尝试拨号指定地址的MongoDB数据库。如果我们失败了，我们会通过调用`log.Fatalln`中止。假设数据库正在运行并且我们能够连接，我们会在延迟关闭连接之前将引用存储在`db`变量中。这确保我们的程序在结束时正确断开连接并整理自己。
- en: We then create a new `http.ServeMux` object, which is a request multiplexer
    provided by the Go standard library, and register a single handler for all requests
    that begin with the path `/polls/` .
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的`http.ServeMux`对象，这是Go标准库提供的请求多路复用器，并为所有以路径`/polls/`开头的请求注册一个处理程序。
- en: Finally, we make use of Tyler Bunnell's excellent `Graceful` package, which
    can be found at [https://github.com/stretchr/graceful](https://github.com/stretchr/graceful)
    to start the server. This package allows us to specify `time.Duration` when running
    any `http.Handler` (such as our `ServeMux` handler), which will allow any in-flight
    requests some time to complete before the function exits. The `Run` function will
    block until the program is terminated (for example, when someone presses *Ctrl*
    + *C* ).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用Tyler Bunnell的优秀的`Graceful`包，可以在[https://github.com/stretchr/graceful](https://github.com/stretchr/graceful)找到，来启动服务器。该包允许我们在运行任何`http.Handler`（例如我们的`ServeMux`处理程序）时指定`time.Duration`，这将允许任何正在进行的请求在函数退出之前有一些时间完成。`Run`函数将阻塞，直到程序终止（例如，当有人按下*Ctrl*
    + *C*）。
- en: Using handler function wrappers
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用处理程序函数包装器
- en: 'It is when we call `HandleFunc` on the `ServeMux` handler that we are making
    use of our handler function wrappers, with the line:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ServeMux`处理程序上调用`HandleFunc`时，我们使用了我们的处理程序函数包装器，代码如下：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since each function takes an `http.HandlerFunc` type as an argument and also
    returns one, we are able to chain the execution just by nesting the function calls
    as we have done previously. So when a request comes in with a path prefix of `/polls/`
    , the program will take the following execution path:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个函数都将`http.HandlerFunc`类型作为参数，并返回一个，我们可以通过嵌套函数调用来链接执行，就像我们之前做的那样。因此，当请求带有路径前缀`/polls/`时，程序将采取以下执行路径：
- en: '`withCORS` is called, which sets the appropriate header.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`withCORS`，设置适当的标头。
- en: '`withVars` is called, which calls `OpenVars` and defers `CloseVars` for the
    request.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`withVars`，调用`OpenVars`并为请求延迟`CloseVars`。
- en: '`withData` is then called, which copies the database session provided as the
    first argument and defers the closing of that session.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用`withData`，它会复制提供的数据库会话作为第一个参数，并延迟关闭该会话。
- en: '`withAPIKey` is called next, which checks the request for an API key and aborts
    if it''s invalid, or else calls the next handler function.'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用`withAPIKey`，检查请求是否有API密钥，如果无效则中止，否则调用下一个处理程序函数。
- en: '`handlePolls` is then called, which has access to variables and a database
    session, and which may use the helper functions in `respond.go` to write a response
    to the client.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用`handlePolls`，它可以访问变量和数据库会话，并且可以使用`respond.go`中的辅助函数向客户端编写响应。
- en: Execution goes back to `withAPIKey` that just exits.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行返回到`withAPIKey`，然后退出。
- en: Execution goes back to `withData` that exits, therefore calling the deferred
    session `Close` function and clearing up the database session.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行返回到`withData`，然后退出，因此调用延迟的会话`Close`函数并清理数据库会话。
- en: Execution goes back to `withVars` that exits, therefore calling `CloseVars`
    and tidying that up too.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行返回到`withVars`，然后退出，因此调用`CloseVars`并清理。
- en: Execution finally goes back to `withCORS` that just exits.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行返回到`withCORS`，然后退出。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order that we nest the wrapper functions in is important, because `withData`
    puts the database session for each request in that request's variables map using
    `SetVar` . So `withVars` must be outside `withData` . If this isn't respected,
    the code will likely panic and you may want to add a check so that the panic is
    more meaningful to other developers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们嵌套包装函数的顺序很重要，因为`withData`使用`SetVar`将每个请求的数据库会话放入该请求的变量映射中。因此，`withVars`必须在`withData`之外。如果不遵守这一点，代码很可能会出现panic，并且您可能希望添加一个检查，以便panic对其他开发人员更有意义。
- en: Handling endpoints
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理端点
- en: The final piece of the puzzle is the `handlePolls` function that will use the
    helpers to understand the incoming request and access the database, and generate
    a meaningful response that will be sent back to the client. We also need to model
    the poll data that we were working with in the previous chapter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图的最后一块是`handlePolls`函数，它将使用辅助函数来理解传入的请求并访问数据库，并生成一个有意义的响应，将发送回客户端。我们还需要对上一章中使用的投票数据进行建模。
- en: 'Create a new file called `polls.go` , and add the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`polls.go`的新文件，并添加以下代码：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we define a structure called `poll` that has three fields that in turn
    describe the polls being created and maintained by the code we wrote in the previous
    chapter. Each field also has a tag (two in the `ID` case), which allows us to
    provide some extra metadata.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`poll`的结构，它有三个字段，依次描述了我们在上一章中编写的代码创建和维护的投票。每个字段还有一个标签（在`ID`情况下有两个），这使我们能够提供一些额外的元数据。
- en: Using tags to add metadata to structs
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签向结构体添加元数据
- en: 'Tags are strings that follow a field definition within a `struct` type on the
    same line of code. We use the back tick character to denote literal strings, which
    means we are free to use double quotes within the tag string itself. The `reflect`
    package allows us to pull out the value associated with any key; in our case,
    both `bson` and `json` are examples of keys, and they are each key/value-pair-separated
    by a space character. Both the `encoding/json` and `gopkg.in/mgo.v2/bson` packages
    allow you to use tags to specify the field name that will be used with encoding
    and decoding (along with some other properties), rather than having it infer the
    values from the name of the fields themselves. We are using BSON to talk with
    the MongoDB database and JSON to talk to the client, so we can actually specify
    different views of the same `struct` type. For example, consider the ID field:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是跟随`struct`类型中字段定义的字符串，位于同一行代码中。我们使用反引号字符来表示字面字符串，这意味着我们可以在标签字符串本身中使用双引号。`reflect`包允许我们提取与任何键关联的值；在我们的情况下，`bson`和`json`都是键的示例，它们都是由空格字符分隔的键/值对。`encoding/json`和`gopkg.in/mgo.v2/bson`包允许您使用标签来指定将用于编码和解码的字段名称（以及一些其他属性），而不是从字段名称本身推断值。我们使用BSON与MongoDB数据库通信，使用JSON与客户端通信，因此我们实际上可以指定相同`struct`类型的不同视图。例如，考虑ID字段：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The name of the field in Go is `ID` , the JSON field is `id` , and the BSON
    field is `_id` , which is the special identifier field used in MongoDB.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中的字段名是`ID`，JSON字段是`id`，BSON字段是`_id`，这是MongoDB中使用的特殊标识符字段。
- en: Many operations with a single handler
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个处理程序的多个操作
- en: 'Because our simple path-parsing solution cares only about the path, we have
    to do some extra work when looking at the kind of RESTful operation the client
    is making. Specifically, we need to consider the HTTP method so we know how to
    handle the request. For example, a `GET` call to our `/polls/` path should read
    polls, where a `POST` call would create a new one. Some frameworks solve this
    problem for you, by allowing you to map handlers based on more than the path,
    such as the HTTP method or the presence of specific headers in the request. Since
    our case is ultra simple, we are going to use a simple `switch` case. In `polls.go`
    , add the `handlePolls` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们简单的路径解析解决方案只关心路径，所以当查看客户端正在进行的RESTful操作类型时，我们需要做一些额外的工作。具体来说，我们需要考虑HTTP方法，以便知道如何处理请求。例如，对我们的`/polls/`路径进行`GET`调用应该读取投票，而`POST`调用将创建一个新的投票。一些框架为您解决了这个问题，允许您基于更多内容而不仅仅是路径来映射处理程序，比如HTTP方法或请求中特定标头的存在。由于我们的情况非常简单，我们将使用一个简单的`switch`情况。在`polls.go`中，添加`handlePolls`函数：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We switch on the HTTP method and branch our code depending on whether it is
    `GET` , `POST` , or `DELETE` . If the HTTP method is something else, we just respond
    with a `404 http.StatusNotFound` error. To make this code compile, you can add
    the following function stubs underneath the `handlePolls` handler:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据HTTP方法进行分支，并根据是`GET`、`POST`还是`DELETE`来分支我们的代码。如果HTTP方法是其他的，我们只是用`404 http.StatusNotFound`错误进行响应。为了使这段代码编译，您可以在`handlePolls`处理程序下面添加以下函数存根：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this section, we learned how to manually parse elements of the requests (the
    HTTP method) and make decisions in code. This is great for simple cases, but it's
    worth looking at packages such as Goweb or Gorilla's `mux` package for some more
    powerful ways of solving these problems. Nevertheless, keeping external dependencies
    to a minimum is a core philosophy of writing good and contained Go code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何手动解析请求的元素（HTTP方法）并在代码中做出决策。这对于简单的情况来说很好，但值得看看像Goweb或Gorilla的`mux`包这样的包，以便以更强大的方式解决这些问题。然而，将外部依赖保持在最低限度是编写良好且包含的Go代码的核心理念。
- en: Reading polls
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阅读投票
- en: 'Now it''s time to implement the functionality of our web service. Inside the
    `GET` case, add the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们的Web服务的功能了。在`GET`情况下，添加以下代码：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The very first thing we do in each of our subhandler functions is to use `GetVar`
    to get the `mgo.Database` object that will allow us to interact with MongoDB.
    Since this handler was nested inside both `withVars` and `withData` , we know
    that the database will be available by the time execution reaches our handler.
    We then use `mgo` to create an object referring to the `polls` collection in the
    database—if you remember, this is where our polls live.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个子处理程序函数中的第一件事是使用`GetVar`获取`mgo.Database`对象，这将允许我们与MongoDB进行交互。由于此处理程序嵌套在`withVars`和`withData`中，我们知道数据库将在执行到达我们的处理程序时可用。然后，我们使用`mgo`创建一个对象，引用数据库中的`polls`集合——如果您记得，这就是我们的投票所在的地方。
- en: We then build up an `mgo.Query` object by parsing the path. If an ID is present,
    we use the `FindId` method on the `polls` collection, otherwise we pass `nil`
    to the `Find` method, which indicates that we want to select all the polls. We
    are converting the ID from a string to a `bson.ObjectId` type with the `ObjectIdHex`
    method so that we can refer to the polls with their numerical (hex) identifiers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过解析路径构建一个`mgo.Query`对象。如果存在ID，我们使用`polls`集合上的`FindId`方法，否则我们将`nil`传递给`Find`方法，这表示我们要选择所有的投票。我们使用`ObjectIdHex`方法将ID从字符串转换为`bson.ObjectId`类型，以便我们可以使用它们的数字（十六进制）标识符引用投票。
- en: Since the `All` method expects to generate a collection of poll objects, we
    define the result as `[]*poll` , or a slice of pointers to poll types. Calling
    the `All` method on the query will cause `mgo` to use its connection to MongoDB
    to read all the polls and populate the `result` object.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`All`方法期望生成一组投票对象，我们将结果定义为`[]*poll`，或者指向投票类型的指针切片。在查询上调用`All`方法将导致`mgo`使用其与MongoDB的连接来读取所有投票并填充`result`对象。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For small scale projects, such as a small number of polls, this approach is
    fine, but as the number of polls grow, we would need to consider paging the results
    or even iterating over them using the `Iter` method on the query, so we do not
    try to load too much data into memory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小规模项目，比如少量投票，这种方法是可以的，但随着投票数量的增加，我们需要考虑对结果进行分页或者使用查询中的`Iter`方法进行迭代，以便不要将太多数据加载到内存中。
- en: Now that we have added some functionality, let's try out our API for the first
    time. If you are using the same MongoDB instance that we set up in the previous
    chapter, you should already have some data in the `polls` collection; to see our
    API working properly, you should ensure there are at least two polls in the database.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一些功能，让我们第一次尝试我们的API。如果您使用的是我们在上一章中设置的相同的MongoDB实例，那么您应该已经在`polls`集合中有一些数据；为了确保我们的API正常工作，您应该确保数据库中至少有两个投票。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you need to add other polls to the database, in a terminal, run the `mongo`
    command to open a database shell that will allow you to interact with MongoDB.
    Then enter the following commands to add some test polls:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向数据库添加其他投票，在终端中运行`mongo`命令以打开一个允许您与MongoDB交互的数据库shell。然后输入以下命令以添加一些测试投票：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In a terminal, navigate to your `api` folder, and build and run the project:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到您的`api`文件夹，并构建和运行项目：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now make a `GET` request to the `/polls/` endpoint by navigating in your browser
    to `http://localhost:8080/polls/?key=abc123` ; remember to include the trailing
    slash. The result will be an array of polls in JSON format.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在浏览器中导航到`http://localhost:8080/polls/?key=abc123`，向`/polls/`端点发出`GET`请求；记得包括尾随斜杠。结果将以JSON格式返回一组投票。
- en: Copy and paste one of the IDs from the polls list, and insert it before the
    `?` character in the browser to access the data for a specific poll; for example,
    `http://localhost:8080/polls/5415b060a02cd4adb487c3ae?key=abc123` . Notice that
    instead of returning all the polls, it only returns one.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并粘贴投票列表中的一个ID，并将其插入到浏览器中`?`字符之前，以访问特定投票的数据；例如，`http://localhost:8080/polls/5415b060a02cd4adb487c3ae?key=abc123`。请注意，它只返回一个投票，而不是所有投票。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Test the API key functionality by removing or changing the key parameter to
    see what the error looks like.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除或更改密钥参数来测试API密钥功能，看看错误是什么样子。
- en: 'You might have also noticed that although we are only returning a single poll,
    this poll value is still nested inside an array. This is a deliberate design decision
    made for two reasons: the first and most important reason is that nesting makes
    it easier for users of the API to write code to consume the data. If users are
    always expecting a JSON array, they can write strong types that describe that
    expectation, rather than having one type for single polls and another for collections
    of polls. As an API designer, this is your decision to make. The second reason
    we left the object nested in an array is that it makes the API code simpler, allowing
    us to just change the `mgo.Query` object and to leave the rest of the code the
    same.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到，尽管我们只返回了一个投票，但这个投票值仍然嵌套在一个数组中。这是一个有意为之的设计决定，有两个原因：第一个和最重要的原因是，嵌套使得API的用户更容易编写代码来消费数据。如果用户总是期望一个JSON数组，他们可以编写描述这种期望的强类型，而不是为单个投票和投票集合编写另一种类型。作为API设计者，这是您的决定。我们将对象嵌套在数组中的第二个原因是，它使API代码更简单，允许我们只改变`mgo.Query`对象并保持其余代码不变。
- en: Creating a poll
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建投票
- en: 'Clients should be able to make a `POST` request to `/polls/` to create a poll.
    Let''s add the following code inside the `POST` case:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该能够向`/polls/`发出`POST`请求来创建一个投票。让我们在`POST`情况下添加以下代码：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we first attempt to decode the body of the request that, according to RESTful
    principles, should contain a representation of the poll object the client wants
    to create. If an error occurs, we use the `respondErr` helper to write the error
    to the user, and immediately return the function. We then generate a new unique
    ID for the poll, and use the `mgo` package's `Insert` method to send it into the
    database. As per HTTP standards, we then set the `Location` header of the response
    and respond with a `201 http.StatusCreated` message, pointing to the URL from
    which the newly created poll maybe accessed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先尝试解码请求的主体，根据RESTful原则，请求的主体应包含客户端想要创建的投票对象的表示。如果发生错误，我们使用`respondErr`助手将错误写入用户，并立即返回该函数。然后，我们为投票生成一个新的唯一ID，并使用`mgo`包的`Insert`方法将其发送到数据库。根据HTTP标准，我们设置响应的`Location`标头，并以`201
    http.StatusCreated`消息做出响应，指向新创建的投票的URL。
- en: Deleting a poll
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除投票
- en: 'The final piece of functionality we are going to include in our API is the
    capability to delete polls. By making a request with the `DELETE` HTTP method
    to the URL of a poll (such as `/polls/5415b060a02cd4adb487c3ae` ), we want to
    be able to remove the poll from the database and return a `200 Success` response:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要在API中包含的最后一个功能是能够删除投票。通过使用`DELETE` HTTP方法向投票的URL（例如`/polls/5415b060a02cd4adb487c3ae`）发出请求，我们希望能够从数据库中删除投票并返回`200
    Success`响应：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similar to the `GET` case, we parse the path, but this time we respond with
    an error if the path does not contain an ID. For now, we don't want people to
    be able to delete all polls with one request, and so use the suitable `StatusMethodNotAllowed`
    code. Then, using the same collection we used in the previous cases, we call `RemoveId`
    , passing in the ID in the path after converting it into a `bson.ObjectId` type.
    Assuming things go well, we respond with an `http.StatusOK` message, with no body.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与`GET`情况类似，我们解析路径，但这次如果路径不包含ID，我们会响应错误。目前，我们不希望人们能够通过一个请求删除所有投票，因此使用适当的`StatusMethodNotAllowed`代码。然后，使用我们在之前情况下使用的相同集合，我们调用`RemoveId`，传入路径中的ID并将其转换为`bson.ObjectId`类型。假设一切顺利，我们会以`http.StatusOK`消息做出响应，没有正文。
- en: CORS support
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CORS支持
- en: 'In order for our `DELETE` capability to work over CORS, we must do a little
    extra work to support the way CORS browsers handle some HTTP methods such as `DELETE`
    . A CORS browser will actually send a pre-flight request (with an HTTP method
    of `OPTIONS` ) asking for permission to make a `DELETE` request (listed in the
    `Access-Control-Request-Method` request header), and the API must respond appropriately
    in order for the request to work. Add another case in the `switch` statement for
    `OPTIONS` :'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`DELETE`功能在CORS上工作，我们必须做一些额外的工作，以支持CORS浏览器处理一些HTTP方法（如`DELETE`）的方式。CORS浏览器实际上会发送一个预检请求（HTTP方法为`OPTIONS`），请求权限进行`DELETE`请求（列在`Access-Control-Request-Method`请求标头中），API必须做出适当的响应才能使请求工作。在`switch`语句中添加另一个`OPTIONS`的情况：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the browser asks for permission to send a `DELETE` request, the API will
    respond by setting the `Access-Control-Allow-Methods` header to `DELETE` , thus
    overriding the default `*` value that we set in our `withCORS` wrapper handler.
    In the real world, the value for the `Access-Control-Allow-Methods` header will
    change in response to the request made, but since `DELETE` is the only case we
    are supporting, we can hardcode it for now.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器要求发送`DELETE`请求的权限，API将通过将`Access-Control-Allow-Methods`标头设置为`DELETE`来响应，从而覆盖我们在`withCORS`包装处理程序中设置的默认`*`值。在现实世界中，`Access-Control-Allow-Methods`标头的值将根据所做的请求而改变，但由于我们只支持`DELETE`，因此现在可以硬编码它。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The details of CORS are out of the scope of this book, but it is recommended
    that you research the particulars online if you intend to build truly accessible
    web services and APIs. Head over to [http://enable-cors.org/](http://enable-cors.org/)
    to get started.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: CORS的细节不在本书的范围之内，但建议您在打算构建真正可访问的Web服务和API时，如果打算构建真正可访问的Web服务和API，建议您在网上研究相关内容。请访问[http://enable-cors.org/](http://enable-cors.org/)开始。
- en: Testing our API using curl
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用curl测试我们的API
- en: '`curl` is a command-line tool that allows us to make HTTP requests to our service
    so that we can access it as though we were a real app or client consuming the
    service.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`是一个命令行工具，允许我们向我们的服务发出HTTP请求，以便我们可以像真正的应用程序或客户端一样访问它。'
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Windows users do not have access to `curl` by default, and will need to seek
    an alternative. Check out [http://curl.haxx.se/dlwiz/?type=bin](http://curl.haxx.se/dlwiz/?type=bin)
    or search the Web for "Windows `curl` alternative".
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户默认没有`curl`，需要寻找替代方法。请查看[http://curl.haxx.se/dlwiz/?type=bin](http://curl.haxx.se/dlwiz/?type=bin)或在网络上搜索“Windows`curl`替代方法”。
- en: 'In a terminal, let''s read all the polls in the database through our API. Navigate
    to your `api` folder and build and run the project, and also ensure MongoDB is
    running:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，让我们通过我们的API读取数据库中的所有投票。转到您的`api`文件夹，构建和运行项目，并确保MongoDB正在运行：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then perform the following steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行以下步骤：
- en: 'Enter the following `curl` command that uses the `-X` flag to denote we want
    to make a `GET` request to the specified URL:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下`curl`命令，使用`-X`标志表示我们要对指定的URL进行`GET`请求：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is printed after you hit *Enter* :'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按下*Enter*键后，输出将被打印：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While it isn''t pretty, you can see that the API returns the polls from your
    database. Issue the following command to create a new poll:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然不够美观，但您可以看到API从数据库返回了投票。发出以下命令来创建一个新的投票：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Get the list again to see the new poll included:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次获取列表，以查看新的投票包括在内：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Copy and paste one of the IDs, and adjust the URL to refer specifically to
    that poll:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制并粘贴其中一个ID，并调整URL以特指该投票：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we see only the selected poll, `Best Beatle` . Let''s make a `DELETE` request
    to remove the poll:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只看到了选定的投票`Best Beatle`。让我们发出`DELETE`请求来删除该投票：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now when we get all the polls again, we''ll see that the `Best Beatle` poll
    has gone:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当我们再次获取所有投票时，我们会看到`Best Beatle`投票已经消失了：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So now that we know that our API is working as expected, it's time to build
    something that consumes the API properly.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的API正在按预期工作，是时候构建一个正确消耗API的东西了。
- en: A web client that consumes the API
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消耗API的Web客户端
- en: 'We are going to put together an ultra-simple web client that consumes the capabilities
    and data exposed through our API, allowing users to interact with the polling
    system we built in the previous chapter and earlier in this chapter. Our client
    will be made up of three web pages:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组建一个超级简单的Web客户端，通过我们的API公开的功能和数据，允许用户与我们在上一章和本章早些时候构建的投票系统进行交互。我们的客户端将由三个网页组成：
- en: An `index.html` page that shows all the polls
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有投票的`index.html`页面
- en: A `view.html` page that shows the results of a specific poll
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示特定投票结果的`view.html`页面
- en: A `new.html` page that allows users to create new polls
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`new.html`页面，允许用户创建新的投票
- en: 'Create a new folder called `web` alongside the `api` folder, and add the following
    content to the `main.go` file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`api`文件夹旁边创建一个名为`web`的新文件夹，并将以下内容添加到`main.go`文件中：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These few lines of Go code really highlight the beauty of the language and the
    Go standard library. They represent a complete, highly scalable, static website
    hosting program. The program takes an `addr` flag and uses the familiar `http.ServeMux`
    type to serve static files from a folder called `public` .
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行Go代码真正突出了这种语言和Go标准库的美。它们代表了一个完整的、高度可扩展的、静态网站托管程序。该程序接受一个`addr`标志，并使用熟悉的`http.ServeMux`类型从名为`public`的文件夹中提供静态文件。
- en: Tip
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Building the next few pages—while we're building the UI—consists of writing
    a lot of HTML and JavaScript code. Since this is not Go code, if you'd rather
    not type it all out, feel free to head over to the GitHub repository for this
    book and copy and paste it from [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    .
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建下面的几个页面时，我们将编写大量的HTML和JavaScript代码。由于这不是Go代码，如果您不想全部输入，可以随时转到本书的GitHub存储库，从[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)复制并粘贴。
- en: An index page showing a list of polls
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示投票列表的索引页面
- en: 'Create the `public` folder inside `web` and add the `index.html` file after
    writing the following HTML code in it:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web`文件夹内创建`public`文件夹，并在其中添加`index.html`文件，然后写入以下HTML代码：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will use Bootstrap again to make our simple UI look nice, but we need to
    add two additional sections to the `body` tag of the HTML page. First, add the
    DOM elements that will display the list of polls:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Bootstrap来使我们的简单UI看起来漂亮，但是我们需要在HTML页面的`body`标签中添加两个额外的部分。首先，添加将显示投票列表的DOM元素：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we are using Bootstrap's grid system to center-align our content that is
    made up of a list of polls and a link to `new.html` , where users can create new
    polls.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Bootstrap的网格系统来居中对齐我们的内容，内容由一系列投票列表和一个指向`new.html`的链接组成，用户可以在那里创建新的投票。
- en: 'Next, add the following `script` tags and JavaScript underneath the previous
    code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在上述代码下面添加以下`script`标签和JavaScript：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are using jQuery's `$.get` function to make an AJAX request to our web service.
    We are also hardcoding the API URL. In practice, you might decide against this,
    but you should at least use a domain name to abstract it. Once the polls have
    loaded, we use jQuery to build up a list containing hyperlinks to the `view.html`
    page, passing the ID of the poll as a query parameter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用jQuery的`$.get`函数向我们的Web服务发出AJAX请求。我们还将API URL硬编码。在实践中，您可能会决定反对这样做，但至少应该使用域名来进行抽象。一旦投票加载完成，我们使用jQuery构建一个包含指向`view.html`页面的超链接的列表，并将投票的ID作为查询参数传递。
- en: A page to create a new poll
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新投票的页面
- en: 'To allow users to create a new poll, create a file called `new.html` inside
    the `public` folder, and add the following HTML code to the file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户创建新的投票，创建一个名为`new.html`的文件放在`public`文件夹中，并将以下HTML代码添加到文件中：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are going to add the elements for an HTML form that will capture the information
    we need when creating a new poll, namely the title of the poll and the options.
    Add the following code inside the `body` tags:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为HTML表单添加元素，以捕获创建新投票时所需的信息，即投票的标题和选项。在`body`标签内添加以下代码：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since our API speaks JSON, we need to do a bit of work to turn the HTML form
    into a JSON-encoded string, and also break the comma-separated options string
    into an array of options. Add the following `script` tag:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的API使用JSON，我们需要做一些工作，将HTML表单转换为JSON编码的字符串，并将逗号分隔的选项字符串拆分为选项数组。添加以下`script`标签：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here we add a listener to the `submit` event of our form, and use jQuery's `val`
    method to collect the input values. We split the options with a comma, and trim
    the spaces away before using the `$.post` method to make the `POST` request to
    the appropriate API endpoint. `JSON.stringify` allows us to turn the data object
    into a JSON string, and we use that string as the body of the request, as expected
    by the API. On success, we pull out the `Location` header and redirect the user
    to the `view.html` page, passing a reference to the newly created poll as the
    parameter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加一个监听器来监听表单的`submit`事件，并使用jQuery的`val`方法来收集输入值。我们用逗号分隔选项，并在使用`$.post`方法发出`POST`请求到适当的API端点之前去除空格。`JSON.stringify`允许我们将数据对象转换为JSON字符串，并将该字符串用作请求的主体，正如API所期望的那样。成功后，我们提取`Location`头并将用户重定向到`view.html`页面，将新创建的投票作为参数传递。
- en: A page to show details of the poll
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示投票详细信息的页面
- en: 'The final page of our app we need to complete is the `view.html` page where
    users can see the details and live results of the poll. Create a new file called
    `view.html` inside the `public` folder, and add the following HTML code to it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成应用程序的最终页面是`view.html`页面，用户可以在该页面上查看投票的详细信息和实时结果。在`public`文件夹中创建一个名为`view.html`的新文件，并将以下HTML代码添加到其中：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This page is mostly similar to the other pages; it contains elements for presenting
    the title of the poll, the options, and a pie chart. We will be mashing up Google''s
    Visualization API with our API to present the results. Underneath the final `div`
    tag in `view.html` (and above the closing `body` tag), add the following `script`
    tags:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面与其他页面大部分相似；它包含用于呈现投票标题、选项和饼图的元素。我们将使用谷歌的可视化API与我们的API结合，呈现结果。在`view.html`的最后一个`div`标签下（并在闭合的`body`标签上方），添加以下`script`标签：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We include the dependencies we will need to power our page, jQuery and Bootstrap,
    and also the Google JavaScript API. The code loads the appropriate visualization
    libraries from Google, and waits for the DOM elements to load before extracting
    the poll ID from the URL by splitting it on `poll=` . We then create a variable
    called `update` that represents a function responsible for generating the view
    of the page. This approach is taken to make it easy for us to use `window.setTimeout`
    to issue regular calls to update the view. Inside the `update` function, we use
    `$.get` to make a `GET` request to our `/polls/{id}` endpoint, replacing `{id}`
    with the actual ID we extracted from the URL earlier. Once the poll has loaded,
    we update the title on the page and iterate over the options to add them to the
    list. If there are results (remember in the previous chapter, the `results` map
    was only added to the data as votes start being counted), we create a new `google.visualization.PieChart`
    object and build a `google.visualization.DataTable` object containing the results.
    Calling `draw` on the chart causes it to render the data, and thus update the
    chart with the latest numbers. We then use `setTimeout` to tell our code to call
    `update` again in another second.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括我们将需要为页面提供动力的依赖项，jQuery和Bootstrap，以及Google JavaScript API。该代码从谷歌加载适当的可视化库，并在提取URL上的投票ID时等待DOM元素加载，通过在`poll=`上拆分它。然后，我们创建一个名为`update`的变量，表示负责生成页面视图的函数。采用这种方法是为了使我们能够使用`window.setTimeout`轻松地发出对视图的定期调用。在`update`函数内部，我们使用`$.get`向我们的`/polls/{id}`端点发出`GET`请求，将`{id}`替换为我们之前从URL中提取的实际ID。一旦投票加载完成，我们更新页面上的标题，并遍历选项以将它们添加到列表中。如果有结果（请记住在上一章中，`results`映射仅在开始计票时才添加到数据中），我们创建一个新的`google.visualization.PieChart`对象，并构建一个包含结果的`google.visualization.DataTable`对象。调用图表上的`draw`会导致它呈现数据，从而使用最新的数字更新图表。然后，我们使用`setTimeout`告诉我们的代码在另一个秒内再次调用`update`。
- en: Finally, we bind to the `click` event of the `delete` button we added to our
    page, and after asking the user if they are sure, make a `DELETE` request to the
    polls URL and then redirect them back to the home page. It is this request that
    will actually cause the `OPTIONS` request to be made first, asking for permission,
    which is why we added explicit support for it in our `handlePolls` function earlier.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们绑定到我们页面上添加的`delete`按钮的`click`事件，并在询问用户是否确定后，向投票URL发出`DELETE`请求，然后将其重定向回主页。这个请求实际上会导致首先进行`OPTIONS`请求，请求权限，这就是为什么我们在之前的`handlePolls`函数中添加了显式支持的原因。
- en: Running the solution
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行解决方案
- en: 'We have built many components over the last two chapters, and it is now time
    to see them all working together. This section contains everything you need to
    get all the items running, assuming you have the environment set up properly as
    described at the beginning of the previous chapter. This section assumes you have
    a single folder that contains four subfolders: `api` , `counter` , `twittervotes`
    , and `web` .'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们构建了许多组件，现在是时候看到它们一起工作了。本节包含了您需要使所有项目运行的所有内容，假设您已经按照上一章开头描述的那样正确设置了环境。本节假设您有一个包含四个子文件夹的单个文件夹：`api`，`counter`，`twittervotes`和`web`。
- en: 'Assuming nothing is running, take the following steps (each step in its own
    terminal window):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 假设没有任何运行中的内容，按照以下步骤进行（每个步骤在自己的终端窗口中）：
- en: 'In the top-level folder, start the `nsqlookupd` daemon:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶层文件夹中，启动`nsqlookupd`守护进程：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the same directory, start the `nsqd` daemon:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的目录中，启动`nsqd`守护进程：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Start the MongoDB daemon:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动MongoDB守护进程：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Navigate to the `counter` folder and build and run it:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`counter`文件夹并构建并运行它：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Navigate to the `twittervotes` folder and build and run it. Be sure that you
    have the appropriate environment variables set, otherwise you will see errors
    when you run the program:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`twittervotes`文件夹并构建并运行它。确保你设置了适当的环境变量，否则当你运行程序时会看到错误：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Navigate to the `api` folder and build and run it:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`api`文件夹并构建并运行它：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Navigate to the `web` folder and build and run it:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`web`文件夹并构建并运行它：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that everything is running, open a browser and head to `http://localhost:8081/`
    . Using the user interface, create a poll called `Moods` and input the options
    as `happy,sad,fail,and success` . These are common enough words that we are likely
    to see some relevant activity on Twitter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都在运行，打开浏览器，转到`http://localhost:8081/`。使用用户界面，创建一个名为`Moods`的投票，并输入选项`happy,sad,fail,and
    success`。这些是足够常见的词，我们很可能会在Twitter上看到一些相关的活动。
- en: Once you have created your poll, you will be taken to the view page where you
    will start to see the results coming in. Wait for a few seconds, and enjoy the
    fruits of your hard work as the UI updates in real time showing live, real-time
    results.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了投票后，您将被带到查看页面，在那里您将开始看到结果的出现。等待几秒钟，享受您的辛勤工作的成果，因为UI会实时更新，显示实时结果。
- en: '![Running the solution](img/Image00012.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![运行解决方案](img/Image00012.jpg)'
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we exposed the data for our social polling solution through
    a highly scalable RESTful API and built a simple website that consumes the API
    to provide an intuitive way for users to interact with it. The website consists
    of static content only, with no server-side processing (since the API does the
    heavy lifting for us). This allows us to host the website very cheaply on static
    hosting sites such as [bitballoon.com](http://bitballoon.com) , or to distribute
    the files to content delivery networks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过一个高度可扩展的RESTful API公开了我们社交投票解决方案的数据，并构建了一个简单的网站，该网站使用API来提供用户与之交互的直观方式。该网站仅包含静态内容，没有服务器端处理（因为API为我们处理了繁重的工作）。这使我们能够在静态托管网站（如[bitballoon.com](http://bitballoon.com)）上以非常低的成本托管网站，或者将文件分发到内容交付网络。
- en: Within our API service, we learned how to share data between handlers without
    breaking or obfuscating the handler pattern from the standard library. We also
    saw how writing wrapped handler functions allows us to build a pipeline of functionality
    in a very simple and intuitive way.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API服务中，我们学会了如何在不破坏或混淆标准库中的处理程序模式的情况下在处理程序之间共享数据。我们还看到编写包装处理程序函数如何使我们能够以一种非常简单和直观的方式构建功能管道。
- en: We wrote some basic encoding and decoding functions that—while only simply wrapping
    their counterparts from the `encoding/json` package for now—could be improved
    later to support a range of different data representations without changing the
    internal interface to our code. We wrote a few simple helper functions that make
    responding to data requests easy, while providing the same kind of abstraction
    that would allow us to evolve our API later.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一些基本的编码和解码函数，目前只是简单地包装了`encoding/json`包中的对应函数，以后可以改进以支持一系列不同的数据表示，而不改变我们代码的内部接口。我们编写了一些简单的辅助函数，使得响应数据请求变得容易，同时提供了相同类型的抽象，使我们能够以后发展我们的API。
- en: We saw how, for simple cases, switching on to HTTP methods is an elegant way
    to support many functions for a single endpoint. We also saw how, with a few extra
    lines of code, we are able to build in support for CORS to allow applications
    running on different domains to interact with our services—without the need for
    hacks like JSONP.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，对于简单的情况，切换到HTTP方法是支持单个端点的许多功能的一种优雅方式。我们还看到，通过添加几行额外的代码，我们能够构建支持CORS的功能，允许在不同域上运行的应用程序与我们的服务交互，而无需像JSONP那样的黑客。
- en: 'The code in this chapter, combined with the work we did in the previous chapter,
    provides a real-world, production-ready solution that implements the following
    flow:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码与我们在上一章中所做的工作结合起来，提供了一个实际的、可投入生产的解决方案，实现了以下流程：
- en: The user clicks on the **Create Poll** button on the website, and enters the
    title and options for a poll.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在网站上点击**创建投票**按钮，并输入投票的标题和选项。
- en: The JavaScript running in the browser encodes the data as a JSON string and
    sends it in the body of a `POST` request to our API.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中运行的JavaScript将数据编码为JSON字符串，并将其发送到我们的API的`POST`请求的主体中。
- en: The API receives the request, and after validating the API key, setting up a
    database session, and storing it in our variables map, calls the `handlePolls`
    function that processes the request and stores the new poll in the MongoDB database.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 收到请求后，验证 API 密钥，设置数据库会话，并将其存储在我们的变量映射中，调用 `handlePolls` 函数处理请求，并将新的投票存储在
    MongoDB 数据库中。
- en: The API redirects the user to the `view.html` page for the newly created poll.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API 将用户重定向到新创建的投票的 `view.html` 页面。
- en: Meanwhile, the `twittervotes` program loads all polls from the database, including
    the new one, and opens a connection to Twitter filtering on the hashtags that
    represent options from the polls.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此同时，`twittervotes` 程序从数据库中加载所有投票，包括新的投票，并打开到 Twitter 的连接，过滤代表投票选项的标签。
- en: As votes come in, `twittervotes` pushes them to NSQ.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选票进来时，`twittervotes` 将它们推送到 NSQ。
- en: The `counter` program is listening in on the appropriate channel and notices
    the votes coming in, counting each one and periodically making updates to the
    database.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`counter` 程序正在监听适当的频道，并注意到投票的到来，计算每一个，并定期更新数据库。'
- en: The user sees the results displayed (and refreshed) on the `view.html` page
    as the website continually makes `GET` requests to the API endpoint for the selected
    poll.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在 `view.html` 页面上看到结果显示（并刷新），因为网站不断地向所选投票的 API 端点发出 `GET` 请求。
- en: In the next chapter, we will evolve our API and web skills to build a brand
    new start-up app called Meander. We'll see how we can write a full, static web
    server in just a few lines of Go code, and explore an interesting way of representing
    enumerators in a language that doesn't officially support them!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将发展我们的 API 和 web 技能，构建一个全新的创业应用程序 Meander。我们将看到如何在几行 Go 代码中编写一个完整的静态
    web 服务器，并探索一种在官方不支持的语言中表示枚举器的有趣方式！
