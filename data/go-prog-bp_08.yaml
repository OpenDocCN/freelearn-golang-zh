- en: Chapter 8. Filesystem Backup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。文件系统备份
- en: There are many solutions that provide filesystem backup capabilities. These
    include everything from apps such as Dropbox, Box, Carbonite to hardware solutions
    such as Apple's Time Machine, Seagate, or network-attached storage products, to
    name a few. Most consumer tools provide some key automatic functionality, along
    with an app or website for you to manage your policies and content. Often, especially
    for developers, these tools don't quite do the things we need them to. However,
    thanks to Go's standard library (that includes packages such as `ioutil` and `os`
    ) we have everything we need to build a backup solution that behaves exactly as
    we need it to.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多解决方案提供文件系统备份功能。这些包括从应用程序（如Dropbox、Box、Carbonite）到硬件解决方案（如苹果的Time Machine、希捷或网络附加存储产品）等各种解决方案。大多数消费者工具提供一些关键的自动功能，以及一个应用程序或网站供您管理您的策略和内容。通常，特别是对于开发人员来说，这些工具并不能完全满足我们的需求。然而，由于Go的标准库（其中包括`ioutil`和`os`等包），我们有了构建备份解决方案所需的一切。
- en: For our final project, we will build a simple filesystem backup for our source
    code projects that archive specified folders and save a snapshot of them every
    time we make a change. The change could be when we tweak a file and save it, or
    if we add new files and folders, or even if we delete a file. We want to be able
    to go back to any point in time to retrieve old files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终项目，我们将为我们的源代码项目构建一个简单的文件系统备份，该备份将存档指定的文件夹并在每次更改时保存它们的快照。更改可能是当我们调整文件并保存它时，或者如果我们添加新文件和文件夹，甚至如果我们删除文件。我们希望能够回到任何时间点以检索旧文件。
- en: 'Specifically in this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，您将学到：
- en: How to structure projects that consist of packages and command-line tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建由包和命令行工具组成的项目
- en: A pragmatic approach to persisting simple data across tool executions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工具执行之间持久化简单数据的务实方法
- en: How the `os` package allows you to interact with a filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os`包如何允许您与文件系统交互'
- en: How to run code in an infinite timed loop, while respecting *Ctrl* + *C*
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在无限定时循环中运行代码，同时尊重*Ctrl* + *C*
- en: How to use `filepath.Walk` to iterate over files and folders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`filepath.Walk`来迭代文件和文件夹
- en: How to quickly determine if the contents of a directory have changed
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何快速确定目录的内容是否已更改
- en: How to use the `archive/zip` package to zip files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`archive/zip`包来压缩文件
- en: How to build tools that care about a combination of command-line flags and normal
    arguments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建关心命令行标志和普通参数组合的工具
- en: Solution design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案设计
- en: 'We will start by listing some high-level acceptance criteria for our solution
    and the approach we want to take:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先列出一些高层次的解决方案验收标准以及我们想要采取的方法：
- en: The solution should create a snapshot of our files at regular intervals, as
    we make changes to our source code projects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案应该在我们对源代码项目进行更改时定期创建我们文件的快照
- en: We want to control the interval at which the directories are checked for changes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望控制检查目录更改的间隔
- en: Code projects are primarily text-based, so zipping the directories to generate
    archives will save a lot of space
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码项目主要是基于文本的，因此将目录压缩以生成存档将节省大量空间
- en: We will build this project quickly, while keeping a close watch over where we
    might want to make improvements later
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将快速构建这个项目，同时密切关注我们可能希望以后进行改进的地方
- en: Any implementation decisions we make should be easily modified if we decide
    to change our implementation in the future
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们决定将来更改我们的实现，我们所做的任何实现决策都应该很容易修改
- en: We will build two command-line tools, the backend daemon that does the work,
    and a user interaction utility that will let us list, add, and remove paths from
    the backup service
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将构建两个命令行工具，后台守护进程执行工作，用户交互工具让我们列出、添加和删除备份服务中的路径
- en: Project structure
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: It is common in Go solutions to have, in a single project, both a package that
    allows other Go programmers to use your capabilities, and a command-line tool
    that allows end users to use your code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go解决方案中，通常在单个项目中，既有一个允许其他Go程序员使用您的功能的包，也有一个允许最终用户使用您的代码的命令行工具。
- en: A convention is emerging to structure the project by having the package in the
    main project folder, and the command-line tool inside a subfolder called `cmd`
    , or `cmds` if you have multiple commands. Because all packages (regardless of
    the directory tree) are equal in Go, you can import the main package from the
    subpackages, knowing you'll never need to import the commands from the main package.
    This may seem like an unnecessary abstraction, but is actually quite a common
    pattern and can be seen in the standard Go tool chain with examples such as `gofmt`
    and `goimports` .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一种约定正在兴起，即通过在主项目文件夹中放置包，并在名为`cmd`或`cmds`的子文件夹中放置命令行工具。由于在Go中所有包（无论目录树如何）都是平等的，您可以从子包中导入主包，知道您永远不需要从主包中导入命令。这可能看起来像是一个不必要的抽象，但实际上是一个非常常见的模式，并且可以在标准的Go工具链中看到，例如`gofmt`和`goimports`。
- en: 'For example, for our project we are going to write a package called `backup`
    , and two command-line tools: the daemon and the user interaction tool. We will
    structure our project in the following way:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的项目，我们将编写一个名为`backup`的包，以及两个命令行工具：守护进程和用户交互工具。我们将按以下方式构建我们的项目：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Backup package
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份包
- en: We are first going to write the `backup` package, of which we will become the
    first customer when we write the associated tools. The package will be responsible
    for deciding whether directories have changed and need backing up or not, as well
    as actually performing the backup procedure too.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将编写`backup`包，我们将成为编写相关工具时的第一个客户。该包将负责决定目录是否已更改并需要备份，以及实际执行备份过程。
- en: Obvious interfaces?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 明显的接口？
- en: The first thing to think about when embarking on a new Go program is whether
    any interfaces stand out to you. We don't want to over-abstract or waste too much
    time up front designing something that we know will change as we start to code,
    but that doesn't mean we shouldn't look for obvious concepts that are worth pulling
    out. Since our code will archive files, the `Archiver` interface pops out as a
    candidate.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手编写新的Go程序时，首先要考虑的是是否有任何接口吸引了你的注意。我们不希望在一开始就过度抽象或浪费太多时间设计我们知道在编码开始时会发生变化的东西，但这并不意味着我们不应该寻找值得提取的明显概念。由于我们的代码将对文件进行归档，`Archiver`接口显然是一个候选者。
- en: 'Create a new folder inside your `GOPATH` called `backup` , and add the following
    `archiver.go` code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GOPATH`中创建一个名为`backup`的新文件夹，并添加以下`archiver.go`代码：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An `Archiver` interface will specify a method called `Archive` that takes source
    and destination paths and returns an error. Implementations of this interface
    will be responsible for archiving the source folder, and storing it in the destination
    path.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Archiver`接口将指定一个名为`Archive`的方法，该方法接受源和目标路径，并返回一个错误。该接口的实现将负责对源文件夹进行归档，并将其存储在目标路径中。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Defining an interface up front is a nice way to get some concepts out of our
    heads and into code; it doesn't mean this interface can't change as we evolve
    our solution as long as we remember the power of simple interfaces. Also, remember
    that most of the I/O interfaces in the `io` package expose only a single method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 提前定义一个接口是将一些概念从我们的头脑中转移到代码中的好方法；这并不意味着随着我们解决方案的演变，这个接口就不能改变，只要我们记住简单接口的力量。还要记住，`io`包中的大多数I/O接口只公开一个方法。
- en: From the very beginning, we have made the case that while we are going to implement
    ZIP files as our archive format, we could easily swap this out later with another
    kind of `Archiver` format.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，我们就已经说明了，虽然我们将实现ZIP文件作为我们的存档格式，但以后我们可以很容易地用其他类型的`Archiver`格式来替换它。
- en: Implementing ZIP
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现ZIP
- en: Now that we have the interface for our `Archiver` types, we are going to implement
    one that uses the ZIP file format.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Archiver`类型的接口，我们将实现一个使用ZIP文件格式的接口。
- en: 'Add the following `struct` definition to `archiver.go` :'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`struct`定义添加到`archiver.go`：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are not going to export this type, which might make you jump to the conclusion
    that users outside of the package won't be able to make use of it. In fact, we
    are going to provide them with an instance of the type for them to use, to save
    them from having to worry about creating and managing their own types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算导出这种类型，这可能会让你得出结论，包外的用户将无法使用它。实际上，我们将为他们提供该类型的一个实例供他们使用，以免他们担心创建和管理自己的类型。
- en: 'Add the following exported implementation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下导出的实现：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This curious snippet of Go voodoo is actually a very interesting way of exposing
    the intent to the compiler, without using any memory (literally 0 bytes). We are
    defining a variable called `ZIP` of type `Archiver` , so from outside the package
    it's pretty clear that we can use that variable wherever `Archiver` is needed—if
    you want to zip things. Then we assign it with `nil` cast to the type `*zipper`
    . We know that `nil` takes no memory, but since it's cast to a `zipper` pointer,
    and given that our `zipper` struct has no fields, it's an appropriate way of solving
    a problem, which hides the complexity of code (and indeed the actual implementation)
    from outside users. There is no reason anybody outside of the package needs to
    know about our `zipper` type at all, which frees us up to change the internals
    without touching the externals at any time; the true power of interfaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段有趣的Go代码实际上是一种非常有趣的方式，可以向编译器暴露意图，而不使用任何内存（确切地说是0字节）。我们定义了一个名为`ZIP`的变量，类型为`Archiver`，因此从包外部很清楚，我们可以在需要`Archiver`的任何地方使用该变量——如果你想要压缩文件。然后我们将其赋值为`nil`，转换为`*zipper`类型。我们知道`nil`不占用内存，但由于它被转换为`zipper`指针，并且考虑到我们的`zipper`结构没有字段，这是解决问题的一种合适方式，它隐藏了代码的复杂性（实际实现）对外部用户。包外部没有任何理由需要知道我们的`zipper`类型，这使我们可以随时更改内部而不触及外部；这就是接口的真正力量。
- en: 'Another handy side benefit to this trick is that the compiler will now be checking
    whether our zipper type properly implements the `Archiver` interface or not, so
    if you try to build this code you''ll get a compiler error:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的另一个方便之处是，编译器现在将检查我们的`zipper`类型是否正确实现了`Archiver`接口，如果你尝试构建这段代码，你将会得到一个编译器错误：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see that our `zipper` type does not implement the `Archive` method as mandated
    in the interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的`zipper`类型没有实现接口中规定的`Archive`方法。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can also use the `Archive` method in test code to ensure that your types
    implement the interfaces they should. If you don''t need to use the variable,
    you can always throw it away by using an underscore and you''ll still get the
    compiler help:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在测试代码中使用`Archive`方法来确保你的类型实现了它们应该实现的接口。如果你不需要使用这个变量，你可以使用下划线将其丢弃，你仍然会得到编译器的帮助：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To make the compiler happy, we are going to add the implementation of the `Archive`
    method for our `zipper` type.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让编译器满意，我们将为我们的`zipper`类型添加`Archive`方法的实现。
- en: 'Add the following code to `archiver.go` :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`archiver.go`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will have to also import the `archive/zip` package from the Go standard
    library. In our `Archive` method, we take the following steps to prepare writing
    to a ZIP file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要从Go标准库中导入`archive/zip`包。在我们的`Archive`方法中，我们采取以下步骤来准备写入ZIP文件：
- en: Use `os.MkdirAll` to ensure the destination directory exists. The `0777` code
    represents the file permissions with which to create any missing directories.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.MkdirAll`确保目标目录存在。`0777`代码表示用于创建任何缺失目录的文件权限。
- en: Use `os.Create` to create a new file as specified by the `dest` path.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.Create`根据`dest`路径创建一个新文件。
- en: If the file is created without error, defer the closing of the file with `defer
    out.Close()` .
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件创建没有错误，使用`defer out.Close()`延迟关闭文件。
- en: Use `zip.NewWriter` to create a new `zip.Writer` type that will write to the
    file we just created, and defer the closing of the writer.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`zip.NewWriter`创建一个新的`zip.Writer`类型，它将写入我们刚刚创建的文件，并延迟关闭写入器。
- en: Once we have a `zip.Writer` type ready to go, we use the `filepath.Walk` function
    to iterate over the source directory `src` .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好一个`zip.Writer`类型，我们使用`filepath.Walk`函数来迭代源目录`src`。
- en: 'The `filepath.Walk` function takes two arguments: the root path, and a callback
    function `func` to be called for every item (files and folders) it encounters
    while iterating over the file system. The `filepath.Walk` function is recursive,
    so it will travel deep into subfolders too. The callback function itself takes
    three arguments: the full path of the file, the `os.FileInfo` object that describes
    the file or folder itself, and an error (it also returns an error in case something
    goes wrong). If any calls to the callback function result in an error being returned,
    the operation will be aborted and `filepath.Walk` returns that error. We simply
    pass that up to the caller of `Archive` and let them worry about it, since there''s
    nothing more we can do.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath.Walk`函数接受两个参数：根路径和回调函数`func`，用于在遍历文件系统时遇到的每个项目（文件和文件夹）进行调用。`filepath.Walk`函数是递归的，因此它也会深入到子文件夹中。回调函数本身接受三个参数：文件的完整路径，描述文件或文件夹本身的`os.FileInfo`对象，以及错误（如果发生错误，它也会返回错误）。如果对回调函数的任何调用导致返回错误，则操作将被中止，并且`filepath.Walk`将返回该错误。我们只需将其传递给`Archive`的调用者，并让他们担心，因为我们无法做更多事情。'
- en: 'For each item in the tree, our code takes the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于树中的每个项目，我们的代码采取以下步骤：
- en: If the `info.IsDir` method tells us that the item is a folder, we just return
    `nil` , effectively skipping it. There is no reason to add folders to ZIP archives,
    because anyway the path of the files will encode that information for us.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`info.IsDir`方法告诉我们该项目是一个文件夹，我们只需返回`nil`，有效地跳过它。没有理由将文件夹添加到ZIP存档中，因为文件的路径将为我们编码该信息。
- en: If an error is passed in (via the third argument), it means something went wrong
    when trying to access information about the file. This is uncommon, so we just
    return the error, which will eventually be passed out to the caller of `Archive`
    .
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传入错误（通过第三个参数），这意味着在尝试访问有关文件的信息时出现了问题。这是不常见的，所以我们只需返回错误，最终将其传递给`Archive`的调用者。
- en: Use `os.Open` to open the source file for reading, and if successful defer its
    closing.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.Open`打开源文件进行读取，如果成功则延迟关闭。
- en: Call `Create` on the `ZipWriter` object to indicate that we want to create a
    new compressed file, and give it the full path of the file, which includes the
    directories it is nested inside.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ZipWriter`对象上调用`Create`，表示我们要创建一个新的压缩文件，并给出文件的完整路径，其中包括它所嵌套的目录。
- en: Use `io.Copy` to read all of the bytes from the source file, and write them
    through the `ZipWriter` object to the ZIP file we opened earlier.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`io.Copy`从源文件读取所有字节，并通过`ZipWriter`对象将它们写入我们之前打开的ZIP文件。
- en: Return `nil` to indicate no errors.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`nil`表示没有错误。
- en: This chapter will not cover unit testing or **Test-driven Development** ( **TDD**
    ) practices, but feel free to write a test to ensure that our implementation does
    what it is meant to do.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不涉及单元测试或**测试驱动开发**（**TDD**）实践，但请随意编写一个测试来确保我们的实现达到预期的效果。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since we are writing a package, spend some time commenting the exported pieces
    so far. You can use `golint` to help you find any exported pieces you may have
    missed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个包，花一些时间注释到目前为止导出的部分。您可以使用`golint`来帮助您找到可能遗漏的任何导出部分。
- en: Has the filesystem changed?
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统是否发生了更改？
- en: 'One of the biggest problems our backup system has is deciding whether a folder
    has changed or not in a cross-platform, predictable, and reliable way. A few things
    spring to mind when we think about this problem: should we just check the last
    modified date on the top-level folder? Should we use system notifications to be
    informed whenever a file we care about changes? There are problems with both of
    these approaches, and it turns out it''s not a trivial problem to solve.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的备份系统面临的最大问题之一是如何以跨平台、可预测和可靠的方式确定文件夹是否发生了更改。当我们考虑这个问题时，有几件事情值得一提：我们应该只检查顶层文件夹的上次修改日期吗？我们应该使用系统通知来通知我们关心的文件何时发生更改吗？这两种方法都存在问题，事实证明这并不是一个微不足道的问题。
- en: We are instead going to generate an MD5 hash made up of all of the information
    that we care about when considering whether something has changed or not.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将生成一个由我们关心的所有信息组成的MD5哈希，以确定某些内容是否发生了更改。
- en: 'Looking at the `os.FileInfo` type, we can see that we can find out a lot of
    information about a file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`os.FileInfo`类型，我们可以看到关于文件的许多信息：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To ensure we are aware of a variety of changes to any file in a folder, the
    hash will be made up of the filename and path (so if they rename a file, the hash
    will be different), size (if a file changes size, it's obviously different), last
    modified date, whether the item is a file or folder, and file mode bits. Even
    though we won't be archiving the folders, we still care about their names and
    the tree structure of the folder.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们能够意识到文件夹中任何文件的各种更改，哈希将由文件名和路径（因此如果它们重命名文件，哈希将不同）、大小（如果文件大小发生变化，显然是不同的）、上次修改日期、项目是文件还是文件夹以及文件模式位组成。尽管我们不会存档文件夹，但我们仍然关心它们的名称和文件夹的树结构。
- en: 'Create a new file called `dirhash.go` and add the following function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`dirhash.go`的新文件，并添加以下函数：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We first create a new `hash.Hash` that knows how to calculate MD5s, before using
    `filepath.Walk` to iterate over all of the files and folders inside the specified
    path directory. For each item, assuming there are no errors, we write the differential
    information to the hash generator using `io.WriteString` , which lets us write
    a string to an `io.Writer` , and `fmt.Fprintf` , which does the same but exposes
    formatting capabilities at the same time, allowing us to generate the default
    value format for each item using the `%v` format verb.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个知道如何计算MD5的新`hash.Hash`，然后使用`filepath.Walk`来遍历指定路径目录中的所有文件和文件夹。对于每个项目，假设没有错误，我们使用`io.WriteString`将差异信息写入哈希生成器，这让我们可以将字符串写入`io.Writer`，以及`fmt.Fprintf`，它同时暴露了格式化功能，允许我们使用`%v`格式动词生成每个项目的默认值格式。
- en: Once each file has been processed, and assuming no errors occurred, we then
    use `fmt.Sprintf` to generate the result string. The `Sum` method on a `hash.Hash`
    calculates the final hash value with the specified values appended. In our case,
    we do not want to append anything since we've already added all of the information
    we care about, so we just pass `nil` . The `%x` format verb indicates that we
    want the value to be represented in hex (base 16) with lowercase letters. This
    is the usual way of representing an MD5 hash.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个文件都被处理，假设没有发生错误，我们就使用`fmt.Sprintf`生成结果字符串。`hash.Hash`上的`Sum`方法计算具有附加指定值的最终哈希值。在我们的情况下，我们不想附加任何东西，因为我们已经添加了所有我们关心的信息，所以我们只传递`nil`。`%x`格式动词表示我们希望该值以十六进制（基数16）的小写字母表示。这是表示MD5哈希的通常方式。
- en: Checking for changes and initiating a backup
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查更改并启动备份
- en: Now that we have the ability to hash a folder, and to perform a backup, we are
    going to put the two together in a new type called `Monitor` . The `Monitor` type
    will have a map of paths with their associated hashes, a reference to any `Archiver`
    type (of course, we'll use `backup.ZIP` for now), and a destination string representing
    where to put the archives.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了哈希文件夹的能力，并且可以执行备份，我们将把这两者放在一个名为`Monitor`的新类型中。`Monitor`类型将具有一个路径映射及其关联的哈希值，任何`Archiver`类型的引用（当然，我们现在将使用`backup.ZIP`），以及一个表示存档位置的目标字符串。
- en: 'Create a new file called `monitor.go` and add the following definition:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`monitor.go`的新文件，并添加以下定义：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to trigger a check for changes, we are going to add the following
    `Now` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发更改检查，我们将添加以下`Now`方法：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Now` method iterates over every path in the map and generates the latest
    hash of that folder. If the hash does not match the hash from the map (generated
    the last time it checked), then it is considered to have changed, and needs backing
    up again. We do this with a call to the as yet unwritten `act` method, before
    then updating the hash in the map with this new hash.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Now`方法遍历映射中的每个路径，并生成该文件夹的最新哈希值。如果哈希值与映射中的哈希值不匹配（上次检查时生成的哈希值），则认为它已更改，并需要再次备份。在调用尚未编写的`act`方法之前，我们会这样做，然后使用这个新的哈希值更新映射中的哈希值。'
- en: To give our users a high-level indication of what happened when they called
    `Now` , we are also maintaining a counter which we increment every time we back
    up a folder. We will use this later to keep our end users up-to-date on what the
    system is doing without bombarding them with information.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的用户一个高层次的指示，当他们调用`Now`时发生了什么，我们还维护一个计数器，每次备份一个文件夹时我们会增加这个计数器。我们稍后将使用这个计数器来让我们的最终用户了解系统正在做什么，而不是用信息轰炸他们。
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The compiler is helping us again and reminding us that we have yet to add the
    `act` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器再次帮助我们，并提醒我们还没有添加`act`方法：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because we have done the heavy lifting in our ZIP `Archiver` type, all we have
    to do here is generate a filename, decide where the archive will go, and call
    the `Archive` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在我们的ZIP `Archiver`类型中已经做了大部分工作，所以我们在这里所要做的就是生成一个文件名，决定存档的位置，并调用`Archive`方法。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the `Archive` method returns an error, the `act` method and then the `Now`
    method will each return it. This mechanism of passing errors up the chain is very
    common in Go and allows you to either handle cases where you can do something
    useful to recover, or else defer the problem to somebody else.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Archive`方法返回一个错误，`act`方法和`Now`方法将分别返回它。在Go中，这种将错误传递到链条上的机制非常常见，它允许你处理你可以做一些有用的恢复的情况，或者将问题推迟给其他人。
- en: The `act` method in the preceding code uses `time.Now().UnixNano()` to generate
    a timestamp filename and hardcodes the `.zip` extension.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`act`方法使用`time.Now().UnixNano()`生成时间戳文件名，并硬编码`.zip`扩展名。
- en: Hardcoding is OK for a short while
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬编码在短时间内是可以的
- en: Hardcoding the file extension like we have is OK in the beginning, but if you
    think about it we have blended concerns a little here. If we change the `Archiver`
    implementation to use RAR or a compression format of our making, the `.zip` extension
    would no longer be appropriate.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像我们这样硬编码文件扩展名在开始时是可以的，但是如果你仔细想想，我们在这里混合了一些关注点。如果我们改变`Archiver`的实现以使用RAR或我们自己制作的压缩格式，`.zip`扩展名将不再合适。
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Before reading on, think about what steps you might take to avoid hardcoding.
    Where does the filename extension decision live? What changes would you need to
    make in order to avoid hardcoding properly?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，想想你可能会采取哪些步骤来避免硬编码。文件扩展名决策在哪里？为了正确避免硬编码，你需要做哪些改变？
- en: The right place for the filename extensions decision is probably in the `Archiver`
    interface, since it knows the kind of archiving it will be doing. So we could
    add an `Ext()` string method and access that from our `act` method. But we can
    add a little extra power with not much extra work by instead allowing `Archiver`
    authors to specify the entire filename format, rather than just the extension.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名决定的正确位置可能在`Archiver`接口中，因为它知道将要进行的归档类型。所以我们可以添加一个`Ext()`字符串方法，并从我们的`act`方法中访问它。但是我们可以通过允许`Archiver`作者指定整个文件名格式，而不仅仅是扩展名，来增加一点额外的功能而不需要太多额外的工作。
- en: 'Back in `archiver.go` , update the `Archiver` interface definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`archiver.go`，更新`Archiver`接口定义：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `zipper` type needs to now implement this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`zipper`类型现在需要实现这个：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we can ask our `act` method to get the whole format string from the
    `Archiver` interface, update the `act` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以要求我们的`act`方法从`Archiver`接口获取整个格式字符串，更新`act`方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The user command-line tool
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户命令行工具
- en: The first of two tools we will build allows the user to add, list, and remove
    paths for the backup daemon tool (which we will write later). You could expose
    a web interface, or even use the binding packages for desktop user interface integration,
    but we are going to keep things simple and build ourselves a command-line tool.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的两个工具中的第一个允许用户为备份守护程序工具（稍后我们将编写）添加、列出和删除路径。你可以暴露一个web界面，或者甚至使用桌面用户界面集成的绑定包，但我们将保持简单，构建一个命令行工具。
- en: Create a new folder called `cmds` inside the `backup` folder and create another
    `backup` folder inside that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backup`文件夹内创建一个名为`cmds`的新文件夹，并在其中创建另一个`backup`文件夹。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's good practice to name the folder of the command and the command binary
    itself the same.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将命令的文件夹和命令二进制本身命名为相同的名称是一个好的做法。
- en: 'Inside our new `backup` folder, add the following code to `main.go` :'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新`backup`文件夹中，将以下代码添加到`main.go`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first define our `fatalErr` variable and defer the function that checks to
    ensure that value is `nil` . If it is not, it will print the error along with
    flag defaults and exit with a non-zero status code. We then define a flag called
    `db` that expects the path to the `filedb` database directory, before parsing
    the flags and getting the remaining arguments and ensuring there is at least one.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的`fatalErr`变量，并推迟检查该值是否为`nil`的函数。如果不是，它将打印错误以及标志默认值，并以非零状态代码退出。然后我们定义一个名为`db`的标志，它期望`filedb`数据库目录的路径，然后解析标志并获取剩余的参数，并确保至少有一个。
- en: Persisting small data
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化小数据
- en: 'In order to keep track of the paths, and the hashes that we generate, we will
    need some kind of data storage mechanism that ideally works even when we stop
    and start our programs. We have lots of choices here: everything from a text file
    to a full horizontally scalable database solution. The Go ethos of simplicity
    tells us that building-in a database dependency to our little backup program would
    not be a great idea; rather we should ask what is the simplest way we can solve
    this problem?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪路径和我们生成的哈希，我们需要一种数据存储机制，最好是在我们停止和启动程序时仍然有效。我们在这里有很多选择：从文本文件到完全水平可扩展的数据库解决方案。Go的简单原则告诉我们，将数据库依赖性构建到我们的小型备份程序中并不是一个好主意；相反，我们应该问问我们如何能以最简单的方式解决这个问题？
- en: The `github.com/matryer/filedb` package is an experimental solution for just
    this kind of problem. It lets you interact with the filesystem as though it were
    a very simple schemaless database. It takes its design lead from packages such
    as `mgo` , and can be used in the cases where data querying needs are very simple.
    In `filedb` , a database is a folder, and a collection is a file where each line
    represents a different record. Of course, this could all change as the `filedb`
    project evolves, but the interface hopefully won't.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/matryer/filedb`包是这种问题的实验性解决方案。它允许您与文件系统交互，就好像它是一个非常简单的无模式数据库。它从`mgo`等包中获取设计灵感，并且可以在数据查询需求非常简单的情况下使用。在`filedb`中，数据库是一个文件夹，集合是一个文件，其中每一行代表不同的记录。当然，随着`filedb`项目的发展，这一切都可能会发生变化，但接口希望不会变。'
- en: 'Add the following code to the end of the `main` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`函数的末尾：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we use the `filedb.Dial` function to connect with the `filedb` database.
    In actuality, nothing much happens here except specifying where the database is,
    since there are no real database servers to connect to (although this might change
    in the future, which is why such provisions exist in the interface). If that was
    successful, we defer the closing of the database. Closing the database does actually
    do something, since files may be open that need to be cleaned up.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`filedb.Dial`函数连接到`filedb`数据库。实际上，在这里并没有发生太多事情，除了指定数据库的位置，因为没有真正的数据库服务器可以连接（尽管这可能会在未来发生变化，这就是接口中存在这些规定的原因）。如果成功，我们推迟关闭数据库。关闭数据库确实会做一些事情，因为可能需要清理的文件可能是打开的。
- en: Following the `mgo` pattern, next we specify a collection using the `C` method
    and keep a reference to it in the `col` variable. If at any point an error occurs,
    we assign it to the `fatalErr` variable and return.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按照`mgo`模式，接下来我们使用`C`方法指定一个集合，并将其引用保存在`col`变量中。如果在任何时候发生错误，我们将把它赋给`fatalErr`变量并返回。
- en: 'To store data, we are going to define a type called `path` , which will store
    the full path and the last hash value, and use JSON encoding to store this in
    our `filedb` database. Add the following `struct` definition above the `main`
    function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储数据，我们将定义一个名为`path`的类型，它将存储完整路径和最后一个哈希值，并使用JSON编码将其存储在我们的`filedb`数据库中。在`main`函数之前添加以下`struct`定义：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Parsing arguments
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析参数
- en: When we call `flag.Args` (as opposed to `os.Args` ), we receive a slice of arguments
    excluding the flags. This allows us to mix flag arguments and non-flag arguments
    in the same tool.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`flag.Args`（而不是`os.Args`）时，我们会收到一个不包括标志的参数切片。这允许我们在同一个工具中混合标志参数和非标志参数。
- en: 'We want our tool to be able to be used in the following ways:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的工具能够以以下方式使用：
- en: 'To add a path:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加路径：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To remove a path:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除路径：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To list all paths:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有路径：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To achieve this, since we have already dealt with flags, we must check the first
    (non-flag) argument.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，因为我们已经处理了标志，我们必须检查第一个（非标志）参数。
- en: 'Add the following code to the `main` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`函数：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here we simply switch on the first argument, after setting it to lowercase (if
    the user types `backup LIST` , we still want it to work).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需切换到第一个参数，然后将其设置为小写（如果用户输入`backup LIST`，我们仍希望它能正常工作）。
- en: Listing the paths
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出路径
- en: 'To list the paths in the database, we are going to use a `ForEach` method on
    the path''s `col` variable. Add the following code to the list case:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出数据库中的路径，我们将在路径的`col`变量上使用`ForEach`方法。在列表情况下添加以下代码：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We pass in a callback function to `ForEach` that will be called for every item
    in that collection. We then `Unmarshal` it from JSON, into our `path` type, and
    just print it out using `fmt.Printf` . We return `false` as per the `filedb` interface,
    which tells us that returning `true` would stop iterating and that we want to
    make sure we list them all.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`ForEach`传递一个回调函数，该函数将为该集合中的每个项目调用。然后我们将其从JSON解封到我们的`path`类型，并使用`fmt.Printf`将其打印出来。我们根据`filedb`接口返回`false`，这告诉我们返回`true`将停止迭代，我们要确保列出它们所有。
- en: String representations for your own types
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义类型的字符串表示
- en: 'If you print structs in Go in this way, using the `%s` format verbs, you can
    get some messy results that are difficult for users to read. If, however, the
    type implements a `String()` string method, that will be used instead and we can
    use this to control what gets printed. Below the path struct, add the following
    method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以这种方式在Go中打印结构体，使用`%s`格式动词，你可能会得到一些混乱的结果，这些结果对用户来说很难阅读。但是，如果该类型实现了`String()`字符串方法，那么将使用该方法，我们可以使用它来控制打印的内容。在路径结构体下面，添加以下方法：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This tells the `path` type how it should represent itself as a string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`path`类型应该如何表示自己。
- en: Adding paths
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加路径
- en: 'To add a path, or many paths, we are going to iterate over the remaining arguments
    and call the `InsertJSON` method for each one. Add the following code to the `add`
    case:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个或多个路径，我们将遍历剩余的参数并为每个参数调用`InsertJSON`方法。在`add`情况下添加以下代码：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the user hasn't specified any additional arguments, like if they just called
    `backup add` without typing any paths, we will return a fatal error. Otherwise,
    we do the work and print out the path string (prefixed with a `+` symbol) to indicate
    that it was successfully added. By default, we'll set the hash to the `Not yet
    archived` string literal—this is an invalid hash but serves the dual purposes
    of letting the user know that it hasn't yet been archived, as well as indicating
    as such to our code (given that a hash of the folder will never equal that string).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有指定任何其他参数，比如他们只是调用`backup add`而没有输入任何路径，我们将返回一个致命错误。否则，我们将完成工作并打印出路径字符串（前缀为`+`符号）以指示成功添加。默认情况下，我们将哈希设置为`Not
    yet archived`字符串字面量-这是一个无效的哈希，但它具有双重目的，既让用户知道它尚未被归档，又向我们的代码指示这一点（因为文件夹的哈希永远不会等于该字符串）。
- en: Removing paths
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除路径
- en: 'To remove a path, or many paths, we use the `RemoveEach` method for the path''s
    collection. Add the following code to the `remove` case:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个或多个路径，我们使用路径的集合的`RemoveEach`方法。在`remove`情况下添加以下代码：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The callback function we provide to `RemoveEach` expects us to return two bool
    types: the first one indicates whether the item should be removed or not, and
    the second one indicates whether we should stop iterating or not.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供给`RemoveEach`的回调函数期望我们返回两个布尔类型：第一个指示是否应删除该项，第二个指示我们是否应停止迭代。
- en: Using our new tool
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的新工具
- en: We have completed our simple `backup` command-line tool. Let's see it in action.
    Create a folder called `backupdata` inside `backup/cmds/backup` ; this will become
    the `filedb` database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们简单的`backup`命令行工具。让我们看看它的运行情况。在`backup/cmds/backup`内创建一个名为`backupdata`的文件夹；这将成为`filedb`数据库。
- en: 'Build the tool in a terminal by navigating to the `main.go` file and running:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到`main.go`文件并运行终端中的以下命令来构建工具：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If all is well, we can now add a path:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们现在可以添加一个路径：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see the expected output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到预期的输出：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now let''s add another path:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加另一个路径：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should now see the complete list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到完整的列表：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our program should yield:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序应该产生：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s remove `test3` to make sure the remove functionality is working:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除`test3`以确保删除功能正常：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will take us back to:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把我们带回到：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are now able to interact with the `filedb` database in a way that makes sense
    for our use case. Next we build the daemon program that will actually use our
    `backup` package to do the work.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够以符合我们用例的方式与`filedb`数据库进行交互。接下来，我们构建将实际使用我们的`backup`包执行工作的守护程序。
- en: The daemon backup tool
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守护进程备份工具
- en: The `backup` tool, which we will call `backupd` , will be responsible for periodically
    checking the paths listed in the `filedb` database, hashing the folders to see
    whether anything has changed, and using the `backup` package to actually perform
    the archiving of folders that need it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`backup`工具，我们将其称为`backupd`，将负责定期检查`filedb`数据库中列出的路径，对文件夹进行哈希处理以查看是否有任何更改，并使用`backup`包来执行需要的文件夹的归档。'
- en: 'Create a new folder called `backupd` alongside the `backup/cmds/backup` folder,
    and let''s jump right into handling the fatal errors and flags:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`backup/cmds/backup`文件夹旁边创建一个名为`backupd`的新文件夹，让我们立即处理致命错误和标志：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You must be quite used to seeing this kind of code by now. We defer the handling
    of fatal errors before specifying three flags: `interval` , `archive` , and `db`
    . The `interval` flag represents the number of seconds between checks to see whether
    folders have changed, the `archive` flag is the path to the archive location where
    ZIP files will go, and the `db` flag is the path to the same `filedb` database
    that the `backup` command is interacting with. The usual call to `flag.Parse`
    sets the variables up and validates whether we''re ready to move on.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在一定很习惯看到这种代码了。在指定三个标志之前，我们推迟处理致命错误：`interval`，`archive`和`db`。`interval`标志表示检查文件夹是否更改之间的秒数，`archive`标志是ZIP文件将存储的存档位置的路径，`db`标志是与`backup`命令交互的相同`filedb`数据库的路径。通常调用`flag.Parse`设置变量并验证我们是否准备好继续。
- en: 'In order to check the hashes of the folders, we are going to need an instance
    of `Monitor` that we wrote earlier. Append the following code to the `main` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查文件夹的哈希值，我们将需要我们之前编写的`Monitor`的一个实例。将以下代码附加到`main`函数：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we create a `backup.Monitor` method using the `archive` value as the `Destination`
    type. We'll use the `backup.ZIP` archiver and create a map ready for it to store
    the paths and hashes internally. At the start of the daemon, we want to load the
    paths from the database so that it doesn't archive unnecessarily as we stop and
    start things.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`archive`值作为`Destination`类型创建了一个`backup.Monitor`方法。我们将使用`backup.ZIP`归档程序，并创建一个准备好在其中存储路径和哈希的映射。在守护程序开始时，我们希望从数据库加载路径，以便在停止和启动时不会不必要地进行归档。
- en: 'Add the following code to the `main` function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`函数中：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You have seen this code before too; it dials the database and creates an object
    that allows us to interact with the `paths` collection. If anything fails, we
    set `fatalErr` and return.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你以前也见过这段代码；它拨号数据库并创建一个允许我们与`paths`集合交互的对象。如果出现任何问题，我们设置`fatalErr`并返回。
- en: Duplicated structures
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复的结构
- en: 'Since we''re going to use the same path structure as in our user command-line
    tool program, we need to include a definition of it for this program too. Insert
    the following structure above the `main` function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用与用户命令行工具程序中相同的路径结构，因此我们也需要为该程序包含一个定义。在`main`函数之前插入以下结构：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The object-oriented programmers out there are no doubt by now screaming at the
    pages demanding for this shared snippet to exist in one place only and not be
    duplicated in both programs. I urge you to resist this compulsion of early abstraction.
    These four lines of code hardly justify a new package and therefore dependency
    for our code, when they can just as easily exist in both programs with very little
    overhead. Consider also that we might want to add a `LastChecked` field to our
    `backupd` program so that we could add rules where each folder only gets archived
    at most once an hour. Our `backup` program doesn't care about this and will chug
    along perfectly happy with its view into what fields constitute a path.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的程序员们毫无疑问现在正在对页面尖叫，要求这个共享的片段只存在于一个地方，而不是在两个程序中重复。我敦促你抵制这种早期抽象的冲动。这四行代码几乎不能证明我们的代码需要一个新的包和依赖，因此它们可以在两个程序中很容易地存在，而几乎没有额外开销。还要考虑到我们可能想要在我们的`backupd`程序中添加一个`LastChecked`字段，这样我们就可以添加规则，每个文件夹最多每小时归档一次。我们的`backup`程序不关心这一点，它将继续快乐地查看哪些字段构成了一个路径。
- en: Caching data
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存数据
- en: We can now query all existing paths and update the `Paths` map, which is a useful
    technique to increase the speed of a program, especially given slow or disconnected
    data stores. By loading the data into a cache (in our case, the `Paths` map),
    we can access it at lightening speeds without having to consult the files each
    time we need information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查询所有现有的路径并更新`Paths`映射，这是一种增加程序速度的有用技术，特别是在数据存储缓慢或断开连接的情况下。通过将数据加载到缓存中（在我们的情况下是`Paths`映射），我们可以以闪电般的速度访问它，而无需每次需要信息时都要查阅文件。
- en: 'Add the following code to the body of the `main` function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main`函数的主体中：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using the `ForEach` method again allows us to iterate over all the paths in
    the database. We `Unmarshal` the JSON bytes into the same path structure as we
    used in our other program and set the values in the `Paths` map. Assuming nothing
    goes wrong, we do a final check to make sure there is at least one path, and if
    not, return with an error.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`ForEach`方法使我们能够遍历数据库中的所有路径。我们将JSON字节解组成与我们在其他程序中使用的相同路径结构，并在`Paths`映射中设置值。假设没有出现问题，我们最后检查以确保至少有一个路径，如果没有，则返回错误。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One limitation to our program is that it will not dynamically add paths once
    it has started. The daemon would need to be restarted. If this bothers you, you
    could always build in a mechanism that updates the `Paths` map periodically.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的一个限制是一旦启动，它将无法动态添加路径。守护程序需要重新启动。如果这让你烦恼，你可以随时构建一个定期更新`Paths`映射的机制。
- en: Infinite loops
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环
- en: The next thing we need to do is to perform a check on the hashes right away
    to see whether anything needs archiving, before entering into an infinite timed
    loop where we check again at regular specified intervals.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要立即对哈希进行检查，看看是否需要进行归档，然后进入一个无限定时循环，在其中以指定的间隔定期进行检查。
- en: An infinite loop sounds like a bad idea; in fact to some it sounds like a bug.
    However, since we're talking about an infinite loop within this program, and since
    infinite loops can be easily broken with a simple `break` command, they're not
    as dramatic as they might sound.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环听起来像一个坏主意；实际上，对于一些人来说，它听起来像一个bug。然而，由于我们正在谈论这个程序内部的一个无限循环，并且由于无限循环可以很容易地通过简单的`break`命令打破，它们并不像听起来那么戏剧性。
- en: 'In Go, to write an infinite loop is as simple as:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，编写无限循环就像这样简单：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The instructions inside the braces get executed over and over again, as quickly
    as the machine running the code can execute them. Again this sounds like a bad
    plan, unless you're careful about what you're asking it to do. In our case, we
    are immediately initiating a `select` case on the two channels that will block
    safely until one of the channels has something interesting to say.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号内的指令会一遍又一遍地执行，尽可能快地运行代码的机器。再次听起来像一个坏计划，除非你仔细考虑你要求它做什么。在我们的情况下，我们立即启动了一个`select`
    case，它会安全地阻塞，直到其中一个通道有有趣的事情要说。
- en: 'Add the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Of course, as responsible programmers, we care about what happens when the
    user terminates our programs. So after a call to the `check` method, which doesn''t
    yet exist, we make a signal channel and use `signal.Notify` to ask for the termination
    signal to be given to the channel, rather than handled automatically. In our infinite
    `for` loop, we select on two possibilities: either the `timer` channel sends a
    message or the termination signal channel sends a message. If it''s the `timer`
    channel message, we call `check` again, otherwise we go about terminating the
    program.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为负责任的程序员，我们关心用户终止我们的程序时会发生什么。因此，在调用尚不存在的`check`方法之后，我们创建一个信号通道，并使用`signal.Notify`要求将终止信号发送到通道，而不是自动处理。在我们无限的`for`循环中，我们选择两种可能性：要么`timer`通道发送消息，要么终止信号通道发送消息。如果是`timer`通道消息，我们再次调用`check`，否则我们终止程序。
- en: The `time.After` function returns a channel that will send a signal (actually
    the current time) after the specified time has elapsed. The somewhat confusing
    `time.Duration(*interval) * time.Second` code simply indicates the amount of time
    to wait before the signal is sent; the first `*` character is a dereference operator
    since the `flag.Int` method represents a pointer to an int, and not the int itself.
    The second `*` character multiplies the interval value by `time.Second` , which
    gives a value equivalent to the specified interval in seconds. Casting the `*interval
    int` to `time.Duration` is required so that the compiler knows we are dealing
    with numbers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.After`函数返回一个通道，在指定的时间过去后发送一个信号（实际上是当前时间）。有些令人困惑的`time.Duration(*interval)
    * time.Second`代码只是指示在发送信号之前要等待的时间量；第一个`*`字符是解引用运算符，因为`flag.Int`方法表示指向int的指针，而不是int本身。第二个`*`字符将间隔值乘以`time.Second`，从而得到与指定间隔相等的值（以秒为单位）。将`*interval
    int`转换为`time.Duration`是必需的，以便编译器知道我们正在处理数字。'
- en: We take a short trip down the memory lane in the preceding code snippet by using
    the `goto` statement to jump out of the switch and to block loops. We could do
    away with the `goto` statement altogether and just return when a termination signal
    is received, but the pattern discussed here allows us to run non-deferred code
    after the `for` loop, should we wish to.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们通过使用`goto`语句来回顾一下内存中的短暂旅程，以跳出switch并阻止循环。我们可以完全不使用`goto`语句，只需在接收到终止信号时返回，但是这里讨论的模式允许我们在`for`循环之后运行非延迟代码，如果我们希望的话。
- en: Updating filedb records
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新filedb记录
- en: All that is left is for us to implement the `check` function that should call
    the `Now` method on the `Monitor` type and update the database with new hashes
    if there are any.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是实现`check`函数，该函数应该调用`Monitor`类型的`Now`方法，并在有任何新的哈希值时更新数据库。
- en: 'Underneath the `main` function, add the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数下面，添加以下代码：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `check` function first tells the user that a check is happening, before
    immediately calling `Now` . If the `Monitor` type did any work for us, which is
    to ask if it archived any files, we output them to the user and go on to update
    the database with the new values. The `SelectEach` method allows us to change
    each record in the collection if we so wish, by returning the replacement bytes.
    So we `Unmarshal` the bytes to get the path structure, update the hash value and
    return the marshaled bytes. This ensures that next time we start a `backupd` process,
    it will do so with the correct hash values.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`函数首先告诉用户正在进行检查，然后立即调用`Now`。如果`Monitor`类型为我们做了任何工作，即询问它是否归档了任何文件，我们将输出它们给用户，并继续使用新值更新数据库。`SelectEach`方法允许我们更改集合中的每个记录，如果我们愿意的话，通过返回替换的字节。因此，我们`Unmarshal`字节以获取路径结构，更新哈希值并返回编组的字节。这确保下次我们启动`backupd`进程时，它将使用正确的哈希值进行操作。'
- en: Testing our solution
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的解决方案
- en: Let's see whether our two programs play nicely together and what affects the
    code inside our `backup` package. You may want to open two terminal windows for
    this, since we'll be running two programs.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的两个程序是否能很好地配合，以及它们对我们的`backup`包内部代码产生了什么影响。您可能希望为此打开两个终端窗口，因为我们将运行两个程序。
- en: 'We have already added some paths to the database, so let''s use `backup` to
    see them:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向数据库中添加了一些路径，所以让我们使用`backup`来查看它们：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You should see the two test folders; if you don't, refer back to the *Adding
    paths* section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这两个测试文件夹；如果没有，可以参考*添加路径*部分。
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In another window, navigate to the `backupd` folder and create our two test
    folders called `test` and `test2` .
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口中，导航到`backupd`文件夹并创建我们的两个测试文件夹，名为`test`和`test2`。
- en: 'Build `backupd` using the usual method:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通常的方法构建`backupd`：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Assuming all is well, we can now start the backup process being sure to point
    the `db` path to the same path as we used for the `backup` program, and specify
    that we want to use a new folder called `archive` to store the ZIP files. For
    testing purposes, let''s specify an interval of `5` seconds to save time:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，我们现在可以开始备份过程，确保将`db`路径指向与`backup`程序相同的路径，并指定我们要使用一个名为`archive`的新文件夹来存储ZIP文件。为了测试目的，让我们指定一个间隔为`5`秒以节省时间：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Immediately, `backupd` should check the folders, calculate the hashes, notice
    that they are different (to `Not yet archived` ), and initiate the archive process
    for both folders. It will print the output telling us this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，`backupd`应该检查文件夹，计算哈希值，注意到它们是不同的（`尚未归档`），并启动两个文件夹的归档过程。它将打印输出告诉我们这一点：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Open the newly created `archive` folder inside `backup/cmds/backupd` and notice
    it has created two subfolders: `test` and `test2` . Inside those are compressed
    archive versions of the empty folders. Feel free to unzip one and see; not very
    exciting so far.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`backup/cmds/backupd`内新创建的`archive`文件夹，并注意它已经创建了两个子文件夹：`test`和`test2`。在这些文件夹中是空文件夹的压缩归档版本。随意解压一个并查看；到目前为止并不是很令人兴奋。
- en: 'Meanwhile, back in the terminal window, `backupd` has been checking the folders
    again for changes:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在终端窗口中，`backupd`一直在检查文件夹是否有变化：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In your favorite text editor, create a new text file inside the `test2` folder
    containing the word `test` , and save it as `one.txt` . After a few seconds, you
    will see that `backupd` has noticed the new file and created another snapshot
    inside the `archive/test2` folder.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中，在“test2”文件夹中创建一个包含单词“test”的新文本文件，并将其保存为“one.txt”。几秒钟后，您会发现“backupd”已经注意到了新文件，并在“archive/test2”文件夹中创建了另一个快照。
- en: Of course, it has a different filename because the time is different, but if
    you unzip it you will notice that it has indeed created a compressed archive version
    of the folder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它的文件名不同，因为时间不同，但是如果您解压缩它，您会注意到它确实创建了文件夹的压缩存档版本。
- en: 'Play around with the solution by taking the following actions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下操作来尝试解决方案：
- en: Change the contents of the `one.txt` file
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改“one.txt”文件的内容
- en: Add a file to the `test` folder too
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件添加到“test”文件夹中
- en: Delete a file
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we successfully built a very powerful and flexible backup system
    for your code projects. You can see how simple it would be to extend or modify
    the behavior of these programs. The scope for potential problems that you could
    go on to solve is limitless.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地为您的代码项目构建了一个非常强大和灵活的备份系统。您可以看到扩展或修改这些程序行为有多么简单。您可以解决的潜在问题范围是无限的。
- en: Rather than having a local archive destination folder like we did in the previous
    section, imagine mounting a network storage device and using that instead. Suddenly,
    you have off-site (or at least off-machine) backups of those vital files. You
    could easily set a Dropbox folder as the archive destination, which would mean
    not only do you get access to the snapshots yourself, but also a copy is stored
    in the cloud and can even be shared with other users.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节不同，我们不是将本地存档目标文件夹，而是想象挂载网络存储设备并使用该设备。突然间，您就可以对这些重要文件进行离站（或至少是离机）备份。您可以轻松地将Dropbox文件夹设置为存档目标，这意味着不仅您自己可以访问快照，而且副本存储在云中，甚至可以与其他用户共享。
- en: Extending the `Archiver` interface to support `Restore` operations (which would
    just use the `encoding/zip` package to unzip the files) allows you to build tools
    that can peer inside the archives and access the changes of individual files much
    like Time Machine allows you to do. Indexing the files gives you full search across
    the entire history of your code, much like GitHub does.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展“Archiver”接口以支持“Restore”操作（只需使用“encoding/zip”包解压文件）允许您构建可以查看存档内部并访问单个文件更改的工具，就像Time
    Machine允许您做的那样。索引文件使您可以在整个代码历史记录中进行全面搜索，就像GitHub一样。
- en: Since the filenames are timestamps, you could have backed up retiring old archives
    to less active storage mediums, or summarized the changes into a daily dump.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件名是时间戳，您可以将旧存档备份到不太活跃的存储介质，或者将更改总结为每日转储。
- en: Obviously, backup software exists, is well tested, and used through the world
    and it may be a smart move to focus on solving problems that haven't yet been
    solved. But when it requires such little effort to write small programs to get
    things done, it is often worth doing because of the control it gives you. When
    you write the code, you can get exactly what you want without compromise, and
    it's down to each individual to make that call.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，备份软件已经存在，经过充分测试，并且在全球范围内得到使用，专注于解决尚未解决的问题可能是一个明智的举措。但是，当写小程序几乎不费吹灰之力时，通常值得去做，因为它给予您控制权。当您编写代码时，您可以得到完全符合您要求的结果，而不需要妥协，这取决于每个人做出的决定。
- en: 'Specifically in this chapter, we explored how easy Go''s standard library makes
    it to interact with the filesystem: opening files for reading, creating new files,
    and making directories. The `os` package mixed in with the powerful types from
    the `io` package, blended further with capabilities like `encoding/zip` and others,
    gives a clear example of how extremely simple Go interfaces can be composed to
    deliver very powerful results.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们探讨了Go标准库如何轻松地与文件系统交互：打开文件进行读取，创建新文件和创建目录。与“io”包中的强大类型混合在一起的“os”包，再加上像“encoding/zip”等功能，清楚地展示了极其简单的Go接口如何组合以产生非常强大的结果。
