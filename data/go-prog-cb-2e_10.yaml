- en: Parallelism and Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行和并发
- en: The recipes in this chapter cover worker pools, wait groups for asynchronous
    operations, and the use of the `context` package. Parallelism and concurrency
    are some of the most advertised and promoted features of the Go language. This
    chapter will offer a number of useful patterns to get you started and help you
    understand these features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例涵盖了工作池、异步操作的等待组以及`context`包的使用。并行和并发是Go语言最广告和推广的特性之一。本章将提供一些有用的模式，帮助您入门并了解这些特性。
- en: Go provides primitives that make parallel applications possible. Goroutines
    allow any function to become asynchronous and concurrent. Channels allow an application
    to set up communication with Goroutines. One of the famous sayings in Go is, "*Do
    not communicate by sharing memory; instead, share memory by communicating*", and
    is from [https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了使并行应用程序成为可能的原语。Goroutines允许任何函数变成异步和并发的。通道允许应用程序与Goroutines建立通信。Go语言中有一句著名的话是：“*不要通过共享内存进行通信；相反，通过通信共享内存*”，出自[https://blog.golang.org/share-memory-by-communicating](https://blog.golang.org/share-memory-by-communicating)。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Using channels and the select statement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道和select语句
- en: Performing async operations with sync.WaitGroup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sync.WaitGroup执行异步操作
- en: Using atomic operations and mutex
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原子操作和互斥锁
- en: Using the context package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文包
- en: Executing state management for channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行通道的状态管理
- en: Using the worker pool design pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作池设计模式
- en: Using workers to create pipelines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工作进程创建管道
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed with all the recipes in this chapter, configure your environment
    according to these steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章中的所有示例，请按照以下步骤配置您的环境：
- en: Download and install Go 1.12.6 or greater on your operating system from [https://golang.org/doc/install](https://golang.org/doc/install).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的操作系统上下载并安装Go 1.12.6或更高版本，网址为[https://golang.org/doc/install](https://golang.org/doc/install)。
- en: Open a Terminal or console application, and create and navigate to a project
    directory such as `~/projects/go-programming-cookbook`. All the code will be run
    and modified from this directory.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端或控制台应用程序，并创建并转到一个项目目录，例如`~/projects/go-programming-cookbook`。所有的代码都将在这个目录中运行和修改。
- en: 'Clone the latest code into `~/projects/go-programming-cookbook-original` and
    (optionally) work from that directory, rather than typing in the examples manually:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将最新的代码克隆到`~/projects/go-programming-cookbook-original`，（可选）从该目录中工作，而不是手动输入示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using channels and the select statement
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道和select语句
- en: Go channels, in combination with Goroutines, are first-class citizens for asynchronous
    communication. Channels become especially powerful when we use select statements.
    These statements allow a Goroutine to intelligently handle requests from multiple
    channels at once.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go通道与Goroutines结合使用，是异步通信的一等公民。当我们使用select语句时，通道变得特别强大。这些语句允许Goroutine智能地处理来自多个通道的请求。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/channels` and
    navigate to it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/channels`的新目录，并转到该目录。
- en: 'Run the following command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see a file called `go.mod` that contains the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/channels`,
    or use this as an opportunity to write some of your own code!
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`~/projects/go-programming-cookbook-original/chapter10/channels`中的测试，或者利用这个机会编写一些您自己的代码！
- en: 'Create a file called `sender.go` with the following content:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sender.go`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a file called `printer.go` with the following content:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`printer.go`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录，并转到该目录。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run `go run main.go`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should now see the following output, but the print ordering may differ:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到以下输出，但打印顺序可能会有所不同：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，顶级示例目录中现在应该存在`go.sum`文件。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe demonstrates two ways to launch a worker process that either reads
    or writes to a channel, and may potentially do both. The worker will terminate
    when the `done` channel is written to, or when `context` is cancelled through
    the calling of the cancel function or by timing out. The *Using the context package*
    recipe will cover the `context` package in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了启动读取或写入通道的工作进程的两种方法，并且可能同时执行两者。当写入`done`通道或通过调用取消函数或超时取消`context`时，工作进程将终止。*使用上下文包*示例将更详细地介绍`context`包。
- en: The `main` package is used to wire together the separate functions; thanks to
    this, it is possible to set up multiple pairs as long as the channels are not
    shared. In addition to this, it's possible to have multiple Goroutines listening
    on the same channel, as we'll explore in the *Using the worker pool design pattern*
    recipe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`包用于将各个函数连接在一起；由于这一点，可以设置多个成对，只要通道不共享。除此之外，可以有多个Goroutines监听同一个通道，我们将在*使用工作池设计模式*示例中探讨。'
- en: 'Lastly, due to the asynchronous nature of Goroutines, it can be tricky to establish
    cleanup and terminate conditions; for example, a common mistake is to do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于Goroutines的异步性质，建立清理和终止条件可能会很棘手；例如，一个常见的错误是执行以下操作：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By putting the `Tick` in the `select` statement, it's possible to prevent this
    case from ever occurring. There's also no simple way to prioritize traffic in
    a `select` statement.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Tick`放在`select`语句中，可以防止这种情况发生。在`select`语句中也没有简单的方法来优先处理流量。
- en: Performing async operations with sync.WaitGroup
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sync.WaitGroup执行异步操作
- en: Sometimes, it is useful to perform a number of operations asynchronously, and
    then wait until they complete before moving on. For example, if an operation requires
    pulling information from multiple APIs and aggregating that information, it can
    be helpful to make those client requests asynchronously. This recipe will explore
    using `sync.WaitGroup` to orchestrate non-dependent tasks in parallel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，异步执行一些操作并等待它们完成是有用的。例如，如果一个操作需要从多个API中提取信息并聚合该信息，那么将这些客户端请求异步化将会很有帮助。这个示例将探讨如何使用`sync.WaitGroup`来编排并行的非依赖任务。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/waitgroup` and
    navigate to it.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/waitgroup`的新目录，并转到该目录。
- en: 'Run the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/waitgroup`,
    or use this as an opportunity to write some of your own code!
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter10/waitgroup`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `tasks.go` with the following content:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tasks.go`的文件，其中包含以下内容：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a file called `process.go` with the following content:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`process.go`的文件，其中包含以下内容：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录，并转到该目录。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，其中包含以下内容：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run `go run main.go`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会更新，顶级配方目录中现在应该存在`go.sum`文件。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe shows you how to use `waitgroups` as a synchronization mechanism
    when waiting for work. In essence, `waitgroup.Wait()` will wait until its internal
    counter has reached `0`. The `waitgroup.Add(int)` method will increment the counter
    by the amount that's entered, and `waitgroup.Done()` will decrement the counter
    by `1`. Because of this, it is necessary to asynchronously `Wait()` while the
    various Goroutines mark `waitgroup` as `Done()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向您展示了如何在等待工作时使用`waitgroups`作为同步机制。实质上，`waitgroup.Wait()`将等待其内部计数器达到`0`。`waitgroup.Add(int)`方法将按输入的数量递增计数器，`waitgroup.Done()`将递减计数器`1`。因此，必须异步`Wait()`，而各种Goroutines标记`waitgroup`为`Done()`。
- en: In this recipe, we increment before dispatching each HTTP request and then call
    a defer `wg.Done()` method so that we can decrement whenever the Goroutine terminates.
    We then wait for all Goroutines to finish before returning our aggregated results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在分派每个HTTP请求之前递增，然后调用defer `wg.Done()`方法，这样我们就可以在Goroutine终止时递减。然后我们等待所有Goroutines完成，然后返回我们聚合的结果。
- en: In practice, it's better to use channels for passing the errors and responses
    around.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，最好使用通道来传递错误和响应。
- en: When performing operations asynchronously like this, you should consider thread
    safety for things such as modifying a shared map. If you keep this in mind, `waitgroups`
    are a useful feature for waiting on any kind of asynchronous operation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此类异步操作时，您应该考虑诸如修改共享映射之类的事物的线程安全性。如果您记住这一点，`waitgroups`是等待任何类型的异步操作的有用功能。
- en: Using atomic operations and mutex
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原子操作和互斥
- en: In a language such as Go, where you can build in asynchronous operations and
    parallelism, it becomes important to consider things such as thread safety. For
    example, it is dangerous to access a map from multiple Goroutines simultaneously.
    Go provides a number of helpers in the `sync` and `sync/atomic` packages to make
    sure that certain events occur only once, or that Goroutines can serialize on
    an operation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如Go之类的语言中，您可以构建异步操作和并行性，考虑诸如线程安全之类的事情变得很重要。例如，同时从多个Goroutines访问映射是危险的。Go在`sync`和`sync/atomic`包中提供了许多辅助工具，以确保某些事件仅发生一次，或者Goroutines可以在操作上进行序列化。
- en: This recipe will demonstrate the use of these packages to safely modify a map
    with various Goroutines and to keep a global ordinal value that can be safely
    accessed by numerous Goroutines. It will also showcase the `Once.Do` method, which
    can be used to ensure that something is only done by a Go application once, such
    as reading a configuration file or initializing a variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将演示使用这些包来安全地修改具有各种Goroutines的映射，并保持可以被多个Goroutines安全访问的全局序数值。它还将展示`Once.Do`方法，该方法可用于确保Go应用程序只执行一次某些操作，例如读取配置文件或初始化变量。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/atomic` and
    navigate to it.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/atomic`的新目录，并转到该目录。
- en: 'Run the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/atomic`,
    or use this as an opportunity to write some of your own code!
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter10/atomic`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `map.go` with the following content:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`map.go`的文件，内容如下：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a file called `ordinal.go` with the following content:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ordinal.go`的文件，内容如下：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run `go run main.go`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You should now see the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到以下输出：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能已更新，`go.sum`文件现在应该存在于顶级配方目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: For our map recipe, we used a `ReadWrite` mutex. The idea behind this mutex
    is that any number of readers can acquire a read lock, but only one writer can
    acquire a write lock. Additionally, a writer cannot acquire a lock when anyone
    else (a reader or a writer) has one. This is useful because reads are very fast
    and non-blocking, compared to a standard mutex. Whenever we want to set data,
    we use the `Lock()` object, and whenever we want to read data, we use `RLock()`.
    It is critical that you use `Unlock()` or `RUnlock()` eventually so that you don't
    deadlock your application. A deferred `Unlock()` object can be useful, but may
    be slower than calling `Unlock()` manually.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的map配方，我们使用了`ReadWrite`互斥锁。这个互斥锁的思想是任意数量的读取者可以获取读取锁，但只有一个写入者可以获取写入锁。此外，当其他人（读取者或写入者）拥有锁时，写入者不能获取锁。这很有用，因为读取非常快速且非阻塞，与标准互斥锁相比。每当我们想要设置数据时，我们使用`Lock()`对象，每当我们想要读取数据时，我们使用`RLock()`。关键是你最终要使用`Unlock()`或`RUnlock()`，这样你就不会使你的应用程序死锁。延迟的`Unlock()`对象可能很有用，但可能比手动调用`Unlock()`慢。
- en: This pattern may not be flexible enough when you want to group additional actions
    with the locked value. For example, in some cases, you may want to lock, do some
    additional processing, and only after you've completed this will you unlock. It's
    important to consider this for your designs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要将额外的操作与锁定的值分组时，这种模式可能不够灵活。例如，在某些情况下，你可能想要锁定，进行一些额外的处理，只有在完成这些处理后才解锁。对于你的设计来说，考虑这一点是很重要的。
- en: The `sync/atmoic` package is used by `Ordinal` to get and set values. There
    are also atomic comparison operations, such as `atomic.CompareAndSwapUInt64()`,
    which are extremely valuable. This recipe allows `Init` to be called on an `Ordinal`
    object only once; otherwise, it can only be incremented and does so atomically.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync/atmoic`包被`Ordinal`用来获取和设置值。还有原子比较操作，比如`atomic.CompareAndSwapUInt64()`，非常有价值。这个配方允许只能在`Ordinal`对象上调用`Init`一次；否则，它只能被原子地递增。'
- en: We loop and create 10 Goroutines (synchronizing with `sync.Waitgroup`) and show
    that the ordinal correctly incremented 10 times and that every key in our map
    was appropriately set.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们循环创建10个Goroutines（与`sync.Waitgroup`同步），并展示序数正确递增了10次，我们的map中的每个键都被适当地设置。
- en: Using the context package
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文包
- en: Several recipes throughout this book make use of the `context` package. This
    recipe will explore the basics of creating and managing contexts. A good reference
    for understanding context is [https://blog.golang.org/context](https://blog.golang.org/context).
    Since this blog post was written, context moved from `net/context` to a package
    called `context`. This still occasionally causes problems when interacting with
    third-party libraries such as GRPC.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的几个配方都使用了`context`包。这个配方将探讨创建和管理上下文的基础知识。理解上下文的一个很好的参考是[https://blog.golang.org/context](https://blog.golang.org/context)。自从写这篇博客以来，上下文已经从`net/context`移动到一个叫做`context`的包中。这在与GRPC等第三方库交互时仍然偶尔会引起问题。
- en: This recipe will explore setting and getting values for contexts, cancellation,
    and timeouts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将探讨为上下文设置和获取值，取消和超时。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/context` and
    navigate to it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/context`的新目录并进入。
- en: 'Run the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/context`,
    or use this as an exercise to write some of your own code!
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`~/projects/go-programming-cookbook-original/chapter10/context`复制测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `values.go` with the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`values.go`的文件，内容如下：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a file called `exec.go` with the following content:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`exec.go`的文件，内容如下：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run `go run main.go`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should now see the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到以下输出：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能已更新，`go.sum`文件现在应该存在于顶级配方目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When working with context values, it's good to create a new type to represent
    the key. In this case, we created a `key` type, then declared some corresponding
    `const` values to represent all of our possible keys.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用上下文值时，最好创建一个新类型来表示键。在这种情况下，我们创建了一个`key`类型，然后声明了一些对应的`const`值来表示所有可能的键。
- en: 'In this case, we initialize all our key/value pairs at the same time using
    the `Setup()` function. When modifying contexts, functions generally take a `context`
    argument and return a `context` value. So, the signature often looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Setup()`函数同时初始化所有的键/值对。在修改上下文时，函数通常需要一个`context`参数并返回一个`context`值。因此，签名通常如下所示：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Sometimes, these methods also return an error or the `cancel()` function, such
    as in the cases of `context.WithCancel`, `context.WithTimeout`, and `context.WithDeadline`.
    All child contexts inherit the attributes of the parent.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些方法还会返回错误或`cancel()`函数，例如`context.WithCancel`、`context.WithTimeout`和`context.WithDeadline`的情况。所有子上下文都继承父上下文的属性。
- en: In this recipe, we created two child contexts, one with a deadline and one with
    a timeout. We set these to timeout to be random ranges, then terminated when either
    is received. Lastly, we extracted a value given a set key and printed it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了两个子上下文，一个带有截止日期，一个带有超时。我们将这些超时设置为随机范围，然后在接收到任何一个超时时终止。最后，我们提取了给定键的值并打印出来。
- en: Executing state management for channels
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行通道的状态管理
- en: Channels can be any type in Go. A channel of structs allows you to pass a lot
    of state with a single message. This recipe will explore the use of channels to
    pass around complex request structures and return their results in complex response
    structs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，通道可以是任何类型。结构体通道允许您通过单个消息传递大量状态。本示例将探讨使用通道传递复杂请求结构并在复杂响应结构中返回它们的结果。
- en: In the next recipe, *Using the worker pool design pattern*, the value of this
    becomes even more apparent as you can create general purpose workers capable of
    performing a variety of tasks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，*使用工作池设计模式*，这种价值变得更加明显，因为您可以创建能够执行各种任务的通用工作程序。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序的过程：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/state` and
    navigate to it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/state`的新目录并进入该目录。
- en: 'Run the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/state`,
    or use this as an opportunity to write some of your own code!
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`~/projects/go-programming-cookbook-original/chapter10/state`中的测试，或者利用这个机会编写一些自己的代码！
- en: 'Create a file called `state.go` with the following content:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`state.go`的文件，内容如下：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a file called `processor.go` with the following content:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`processor.go`的文件，内容如下：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a file called `process.go` with the following content:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`process.go`的文件，内容如下：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录并进入该目录。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，内容如下：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run `go run main.go`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以运行以下命令：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should now see the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该看到以下输出：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，顶级示例目录中现在应该存在`go.sum`文件。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Processor()` function in this recipe is a function that loops forever until
    its context is canceled, either through explicit calls to cancel or via timeout.
    It dispatches all work to `Process()`, which can handle different functions when
    given various operations. It would also be possible to have each of these cases
    dispatch another function for even more modular code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的`Processor()`函数是一个循环函数，直到其上下文被取消为止，可以通过显式调用取消或超时来取消。它将所有工作分派给`Process()`，当给定各种操作时，它可以处理不同的函数。也可以让每个这些情况分派另一个函数，以获得更模块化的代码。
- en: Ultimately, the response is returned to a response channel, and we loop over
    and print all the results at the very end. We also demonstrate an error case in
    the `divide by 0` example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，响应被返回到响应通道，并且我们在最后循环打印所有结果。我们还演示了`divide by 0`示例中的错误情况。
- en: Using the worker pool design pattern
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作池设计模式
- en: The worker pool design pattern is one where you dispatch long-running Goroutines
    as workers. These workers can process a variety of work either using multiple
    channels, or by using a stateful request structure that specifies the type, as
    described in the preceding recipe. This recipe will create stateful workers and
    demonstrate how to coordinate and spin up multiple workers who are all handling
    requests concurrently on the same channel. These workers will be `crypto` workers,
    as in a web authentication application. Their purpose will be to hash plaintext
    strings using the `bcrypt` package and compare a text password against a hash.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 工作池设计模式是一种将长时间运行的Goroutines作为工作程序分派的模式。这些工作程序可以使用多个通道处理各种工作，也可以使用描述类型的有状态请求结构，如前面的示例所述。本示例将创建有状态的工作程序，并演示如何协调和启动多个工作程序，它们都在同一个通道上并发处理请求。这些工作程序将是`crypto`工作程序，就像在Web身份验证应用程序中一样。它们的目的将是使用`bcrypt`包对明文字符串进行哈希处理，并将文本密码与哈希进行比较。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps cover writing and running your application:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行应用程序的过程：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/pool` and
    navigate to it.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/pool`的新目录并进入该目录。
- en: 'Run the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/pool`,
    or use this as an opportunity to write some of your own code!
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`~/projects/go-programming-cookbook-original/chapter10/pool`中的测试，或者利用这个机会编写一些你自己的代码！
- en: 'Create a file called `worker.go` with the following content:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`worker.go`的文件，其中包含以下内容：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a file called `work.go` with the following content:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`work.go`的文件，其中包含以下内容：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a file called `crypto.go` with the following content:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`crypto.go`的文件，其中包含以下内容：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录，并进入该目录。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，其中包含以下内容：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run `go run main.go`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You should now see the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到以下输出：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，`go.sum`文件现在应该存在于顶层示例目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe uses the `Dispatch()` method to create a number of workers on a
    single input channel, output channel, and those attached to a single `cancel()`
    function. This can be used if you want to make different pools for different purposes.
    For example, you can create 10 `crypto` and 20 `compare` workers by using separate
    pools. For this recipe, we use a single pool, send hash requests to the workers,
    retrieve the responses, and then send `compare` requests to the same pool. Because
    of this, the worker performing the work will be different each time, but they're
    all capable of performing either type of work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用`Dispatch()`方法在单个输入通道、输出通道和连接到单个`cancel()`函数上创建多个工作人员。如果你想为不同的目的创建不同的池，这个方法就可以使用。例如，你可以通过使用单独的池创建10个`crypto`和20个`compare`工作人员。对于这个示例，我们使用一个单一的池，将哈希请求发送给工作人员，检索响应，然后将`compare`请求发送到同一个池中。因此，执行工作的工作人员每次都会不同，但它们都能执行任何类型的工作。
- en: The advantage of this approach is that both requests allow for parallelism and
    can also control the maximum concurrency. Bounding the maximum number of Goroutines
    can also be important for limiting memory. I chose `crypto` for this recipe because
    `crypto` is a good example of code that can overwhelm your CPU or memory if you
    spin up a new Goroutine for every new request; for example, in a web service.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，这两种请求都允许并行处理，并且还可以控制最大并发数。限制Goroutines的最大数量对于限制内存也很重要。我选择了`crypto`作为这个示例，因为`crypto`是一个很好的例子，它可以通过为每个新请求启动一个新的Goroutine来压倒你的CPU或内存；例如，在一个web服务中。
- en: Using workers to create pipelines
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工作人员创建管道
- en: This recipe demonstrates creating groups of worker pools and connecting them
    together to form a pipeline. For this recipe, we link together two pools, but
    the pattern can be used for much more complex operations, similar to middleware.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了创建工作池组并将它们连接在一起形成一个管道。对于这个示例，我们将两个池连接在一起，但这种模式可以用于更复杂的操作，类似于中间件。
- en: Worker pools can be useful for keeping workers relatively simple and to also
    further control concurrency. For example, it may be useful to serialize logging
    while parallelizing other operations. It may also be useful to have a smaller
    pool for more expensive operations so that you don't overload machine resources.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 工作池对于保持工作人员相对简单并进一步控制并发非常有用。例如，将日志串行化，同时并行化其他操作可能很有用。对于更昂贵的操作，拥有一个较小的池也可能很有用，这样你就不会过载机器资源。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'These steps cover writing and running your application:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了编写和运行你的应用程序：
- en: From your Terminal or console application, create a new directory called `~/projects/go-programming-cookbook/chapter10/pipeline` and
    navigate to it.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从你的终端或控制台应用程序中，创建一个名为`~/projects/go-programming-cookbook/chapter10/pipeline`的新目录，并进入该目录。
- en: 'Run the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should see a file called `go.mod` that contains the following content:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个名为`go.mod`的文件，其中包含以下内容：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Copy the tests from `~/projects/go-programming-cookbook-original/chapter10/pipeline`,
    or use this as an opportunity to write some of your own code!
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`~/projects/go-programming-cookbook-original/chapter10/pipeline`中的测试，或者利用这个机会编写一些你自己的代码！
- en: 'Create a file called `worker.go` with the following content:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`worker.go`的文件，其中包含以下内容：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a file called `print.go` with the following content:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`print.go`的文件，其中包含以下内容：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a file called `encode.go` with the following content:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`encode.go`的文件，其中包含以下内容：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a file called `pipeline.go` with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`pipeline.go`的文件，其中包含以下内容：
- en: '[PRE52]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Create a new directory named `example` and navigate to it.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`example`的新目录，并进入该目录。
- en: 'Create a file named `main.go` with the following content:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件，其中包含以下内容：
- en: '[PRE53]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Run `go run main.go`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go run main.go`。
- en: 'You may also run the following commands:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以运行以下命令：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should now see the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到以下输出：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `go.mod` file may be updated and the `go.sum` file should now be present
    in the top-level recipe directory.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go.mod`文件可能会被更新，`go.sum`文件现在应该存在于顶层示例目录中。'
- en: If you copied or wrote your own tests, go up one directory and run `go test`.
    Ensure that all the tests pass.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你复制或编写了自己的测试，请返回上一级目录并运行`go test`。确保所有测试都通过。
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `main` package creates a pipeline consisting of 10 encoders and 2 printers.
    It enqueues 20 strings on the in channel and waits for 20 responses on the out
    channel. If messages reach the out channel, it indicates that they've gone through
    the entire pipeline successfully.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`包创建了一个包含10个编码器和2个打印机的管道。它在输入通道上排队了20个字符串，并等待在输出通道上获得20个响应。如果消息到达输出通道，表示它们已经成功通过整个管道。'
- en: The `NewPipeline` function is used to wire up the pools. It ensures that the
    channels are created with the properly buffered sizes and that the output channels
    of some pools are connected to the appropriate input channels of other pools.
    It's also possible to fan out the pipeline by using an array of in channels and
    an array of out channels on each worker, multiple named channels, or maps of channels.
    This would allow for things such as sending messages to a logger at each step.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewPipeline` 函数用于连接管道。它确保通道以适当的缓冲区大小创建，并且一些池的输出通道连接到其他池的适当输入通道。还可以通过在每个工作器上使用输入通道数组和输出通道数组，多个命名通道，或通道映射来扩展管道。这将允许诸如在每个步骤发送消息到记录器之类的操作。'
