- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Project Organization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目组织
- en: This chapter is about how you can start a new project, organize a source tree,
    and manage the packages you need to develop your programs. A well designed project
    structure is important because when other developers work on your project or try
    to use components from it, they can quickly and easily find what they are looking
    for. This chapter will first answer some of the questions you may have when you
    are starting a new project. Then, we will look at how you can use the Go package
    system, work with standard library and third-party packages, and make it easy
    for other developers to use your packages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何开始一个新项目，组织源代码树，以及管理您在开发程序时所需的包。一个良好的项目结构非常重要，因为当其他开发者处理您的项目或尝试使用其中的组件时，他们可以快速轻松地找到他们需要的东西。本章将首先回答您在开始新项目时可能遇到的一些问题。然后，我们将探讨如何使用
    Go 包系统，与标准库和第三方包一起工作，并使其他开发者更容易使用您的包。
- en: 'This chapter includes the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下内容：
- en: Creating a module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块
- en: Creating a source tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建源代码树
- en: Building and running programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行程序
- en: Importing third-party packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入第三方包
- en: Importing specific versions of packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入特定版本的包
- en: Using internal packages to reduce API surface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部包以减少 API 表面积
- en: Using a local copy of a module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块的本地副本
- en: Workspaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作区
- en: Managing the versions of your module
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理模块的版本
- en: Modules and packages
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块和包
- en: First, a few words about modules and packages would be helpful. A `main`, building
    it will result in an executable. You can run the `main` package without producing
    a binary (more specifically, the Go build system first builds the package, produces
    the binary in a temporary location, and runs it). To use another package, you
    import it. Modules help with organizing multiple packages and the resolution of
    package references within a project. A `go.mod`, and a checksum of the contents
    of that module will be added to `go.sum`. Modules also help you to manage versions
    of your programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关于模块和包的一些简要介绍可能会有所帮助。一个 `main` 包，构建它将生成一个可执行文件。您可以在不生成二进制文件的情况下运行 `main`
    包（更具体地说，Go 构建系统首先构建包，在临时位置生成二进制文件，然后运行它）。要使用另一个包，您需要导入它。模块有助于组织多个包以及项目内包引用的解析。一个
    `go.mod` 文件，以及该模块内容的校验和将被添加到 `go.sum` 文件中。模块还有助于您管理程序的版本。
- en: All files of a package are stored under a single directory on the filesystem.
    Every package has a name declared using the `package` directive, shared by all
    source files in it. The package name usually matches the directory name containing
    the files, but this is not necessarily so. For example, the `main` package is
    not usually under a directory named `main/`. The directory of the package determines
    the package’s “import path.” You import another package into your current package
    using the `import <importPath>` statement. Once you import a package, you use
    the names declared in that package using its package name (which is not necessarily
    the directory name).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包的所有文件都存储在文件系统中的单个目录下。每个包都使用 `package` 指令声明一个名称，该名称由包中的所有源文件共享。包名称通常与包含文件的目录名称相匹配，但这并不一定。例如，`main`
    包通常不在名为 `main/` 的目录下。包的目录决定了包的“导入路径”。您使用 `import <importPath>` 语句将另一个包导入到当前包中。一旦导入了一个包，您就使用该包中声明的名称，通过其包名称（这不一定与目录名称相同）来使用这些名称。
- en: A module name points to the location where the module contents are stored in
    a version control system on the Internet. At the time of writing, this is not
    a hard-and-fast requirement, so you can actually create module names that do not
    follow this convention. This should be avoided to prevent potential future incompatibilities
    with the build system. Your module names should be part of the import paths for
    the packages of those modules. In particular, module names whose first component
    (the part before the first `/`) does not have `.` are reserved for the standard
    library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模块名称指向模块内容在互联网上版本控制系统中的存储位置。在撰写本文时，这不是一个硬性要求，因此您实际上可以创建不遵循此约定的模块名称。应避免这样做，以防止未来与构建系统的潜在不兼容性。您的模块名称应该是这些模块包的导入路径的一部分。特别是，那些第一个组件（第一个
    `/` 之前的部分）没有 `.` 的模块名称是为标准库保留的。
- en: These concepts are illustrated in *Figure 1**.1*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念在 *图 1.1* 中得到了说明。
- en: '![Figure 1.1 – Modules and packages](img/B21961_01_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 模块和包](img/B21961_01_1.jpg)'
- en: Figure 1.1 – Modules and packages
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 模块和包
- en: The module name declared in `go.mod` is the repository path where the module
    can be found.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `go.mod` 中声明的模块名称是模块可以找到的仓库路径。
- en: The import path in `main.go` defines where the imported package can be found.
    The Go build system will locate the package using this import path, and then it
    will locate the module containing the package by scanning the parent directories
    of the package path. Once the module is found, it will be downloaded to the module
    cache.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main.go` 中的导入路径定义了导入的包可以找到的位置。Go构建系统将使用此导入路径定位包，然后通过扫描包路径的父目录来定位包含该包的模块。一旦找到模块，它将被下载到模块缓存中。'
- en: The package name defined in the imported module is the package name you use
    to access the symbols of that package. This can be different from the last component
    of the import path. In our example, the package name is `example`, but the import
    path for this package is `github.com/bserdar/go-recipes-module`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入模块中定义的包名是你用来访问该包符号的包名。这可以与导入路径的最后一部分不同。在我们的例子中，包名是 `example`，但这个包的导入路径是 `github.com/bserdar/go-recipes-module`。
- en: The `Example` function is located in the `example` package.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Example` 函数位于 `example` 包中。'
- en: The `example` package also imports another package contained in the same module.
    The build system will identify this package to be part of the same module and
    resolve the references, using the downloaded version of the module.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`example` 包还导入了同一模块中包含的另一个包。构建系统将识别这个包是同一模块的一部分，并使用下载的模块版本解决引用。'
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a recent version of Go on your computer to build and run the examples
    in this chapter. The examples in this book were tested using **Go version 1.22**.
    The code from this chapter can be found at [https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp1](https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的计算机上安装一个较新的Go版本来构建和运行本章中的示例。本书中的示例使用的是**Go版本1.22**。本章的代码可以在[https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp1](https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp1)找到。
- en: Creating a module
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: When you start working on a new project, the first thing to do is to create
    a module for it. A module is how Go manages dependencies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始一个新的项目时，首先要做的是为它创建一个模块。模块是Go管理依赖的方式。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a directory to store a new module.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录来存储新的模块。
- en: Under that directory, use `go mod init <moduleName>` to create the new module.
    The `go.mod` file marks the root directory of a module. Any package under this
    directory will be a part of this module unless that directory also has a `go.mod`
    file. Although such nested modules are supported by the build system, there is
    not much to be gained from them.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个目录下，使用 `go mod init <moduleName>` 创建新的模块。`go.mod` 文件标记了模块的根目录。除非该目录也有 `go.mod`
    文件，否则此目录下的任何包都将成为该模块的一部分。尽管构建系统支持嵌套模块，但从中获得的收益并不多。
- en: To import a package in the same module, use `moduleName/packagePath`. When `moduleName`
    is the same as the location of the module on the internet, there are no ambiguities
    about what you are referring to.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要导入同一模块中的包，使用 `moduleName/packagePath`。当 `moduleName` 与模块在互联网上的位置相同时，你引用的内容不会有歧义。
- en: For the packages under a module, the root of the module is the closest parent
    directory containing a `go.mod` file. All references to other packages within
    a module will be looked up in the directory tree under the module root.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于模块下的包，模块的根是包含 `go.mod` 文件的最近父目录。模块根目录下的所有其他包引用都将在这个目录树中进行查找。
- en: Start by creating a directory to store the project files. Your current directory
    can be anywhere on the filesystem. I have seen people use a common directory to
    store their work, such as `$HOME/projects` (or `\user\myUser\projects` in Windows).
    You may choose to use a directory structure that looks like the module name, such
    as `$HOME/github.com/mycompany/mymodule` (or `\user\myUser\github.com\mycompany\mymodule`
    in Windows). Depending on your operating system, you may find a more suitable
    location.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个目录来存储项目文件。你的当前目录可以在文件系统的任何位置。我见过人们使用一个常见的目录来存储他们的工作，例如 `$HOME/projects`（或在Windows中为
    `\user\myUser\projects`）。你也可以选择使用类似于模块名称的目录结构，例如 `$HOME/github.com/mycompany/mymodule`（或在Windows中为
    `\user\myUser\github.com\mycompany\mymodule`）。根据你的操作系统，你可能找到一个更合适的位置。
- en: Warning
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Do not work under the `src/` directory of your Go installation. That is the
    source code for the Go standard library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在你的 Go 安装目录的 `src/` 下工作。那是 Go 标准库的源代码。
- en: Tip
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should not have an environment variable, `GOPATH`; if you have to keep it,
    do not work under it. This variable was used by an older mode of operation (Go
    version <1.13) that is now deprecated in favor of the Go module system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该有一个环境变量 `GOPATH`；如果你必须保留它，不要在其下工作。这个变量曾用于旧的操作模式（Go 版本 <1.13），现在已被 Go 模块系统所取代。
- en: Throughout this chapter, we will be using a simple program that displays a form
    in a web browser and stores the entered information in a database.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个简单的程序，该程序在网页浏览器中显示表单并将输入的信息存储在数据库中。
- en: 'After creating the module directory, use `go mod init`. The following commands
    will create a `webform` directory under `projects` and initialize a Go module
    there:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模块目录后，使用 `go mod init`。以下命令将在 `projects` 目录下创建一个 `webform` 目录，并在其中初始化一个 Go
    模块：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will create a `go.mod` file in this directory that looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在该目录下创建一个 `go.mod` 文件，其外观如下：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use a name that describes where your module can be found. Always use a URL structure
    such as the `<host>.<domain>/location/to/module` format (e.g., `github.com/bserdar/jsonom`).
    In particular, the first component of the module name should have a dot (`.`)
    (the Go build system checks this).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个描述你的模块位置的名称。始终使用类似 `<host>.<domain>/location/to/module` 的 URL 结构（例如，`github.com/bserdar/jsonom`）。特别是，模块名称的第一个组成部分应该有一个点（`.`）（Go
    构建系统会检查这一点）。
- en: So, even though you can name the module something such as `webform` or `mywork/webform`,
    do not do so. However, you can use something such as `workspace.local/webform`.
    When in doubt, use the code repository name.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使你可以将模块命名为 `webform` 或 `mywork/webform`，也不要这样做。然而，你可以使用类似 `workspace.local/webform`
    的名称。如果有疑问，请使用代码仓库名称。
- en: Creating a source tree
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建源树
- en: Once you have a new module, it is time to decide how you are going to organize
    the source files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个新的模块，就是时候决定你将如何组织源文件了。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are several established conventions, depending on the project:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目，有几种已建立的约定：
- en: Use a standard layout, such as [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准布局，例如 [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)。
- en: A library with a narrow focus can put all the exported names at the module root,
    with implementation details optionally stored under internal packages. A module
    that produces a single executable with relatively few or no reusable components
    can also use the flat directory structure.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点狭窄的库可以将所有导出名称放在模块根目录下，实现细节可以可选地存储在内部包中。仅生成单个可执行文件且具有相对较少或没有可重用组件的模块也可以使用扁平的目录结构。
- en: 'For a project like ours that produces an executable, the structure laid out
    in [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)
    fits. So, let’s follow that template:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我们这样的生成可执行文件的项目，[https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout)
    中描述的结构是合适的。因此，让我们遵循这个模板：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `cmd/webform` directory will contain the `main` package. As you can
    see, this is one instance where the package name does not match the directory
    it is in. The Go build system will create executables using the directory name,
    so when you build the `main` package under `cmd/webform`, you get an executable
    named `webform`. If you have multiple executables built within a single module,
    you can accommodate them by creating a separate `main` package under a directory
    matching the program name, under the `cmd/` directory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cmd/webform` 目录将包含 `main` 包。正如你所见，这是一个包名与其所在目录不匹配的例子。Go 构建系统将使用目录名创建可执行文件，因此当你将在
    `cmd/webform` 目录下构建 `main` 包时，你会得到一个名为 `webform` 的可执行文件。如果你在单个模块内构建了多个可执行文件，你可以通过在
    `cmd/` 目录下创建一个与程序名匹配的单独的 `main` 包来容纳它们。
- en: The `pkg/` directory will contain the exported packages of the program. These
    are packages that can be imported and reused in other projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg/` 目录将包含程序的导出包。这些是可以被其他项目导入和重用的包。'
- en: If you have packages that are not usable outside this project, you should put
    them under the `internal/` directory. The Go build system recognizes this directory
    and does not allow you to import packages under `internal/` from other packages
    that are outside the directory containing the `internal/` directory. With this
    setup, all the packages of our `webform` program will have access to the packages
    under `internal/`, but it will be inaccessible to packages importing this module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些在这个项目外不可用的包，你应该将它们放在`internal/`目录下。Go构建系统识别这个目录，并且不允许你从包含`internal/`目录的外部包导入`internal/`下的包。使用这种设置，我们`webform`程序的所有包都将能够访问`internal/`下的包，但它将无法被导入此模块的包访问。
- en: The `web/` directory will contain any web-related assets. In this example, we
    will have a `web/static` directory containing static web pages. You can also add
    `web/templates` to store server-side templates if you have any.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`web/`目录将包含任何与Web相关的资产。在这个例子中，我们将有一个包含静态网页的`web/static`目录。如果你有任何服务器端模板，你也可以添加`web/templates`来存储。'
- en: The `build/package` directory should have packaging scripts and configuration
    for cloud, container, packaging systems (`dep`, `rpm`, `pkg`, etc.).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/package`目录应包含打包脚本和云、容器、打包系统（`dep`、`rpm`、`pkg`等）的配置。'
- en: The `build/ci` directory should have continuous integration tool scripts and
    configurations. If the continuous integration tool you are using requires its
    files to be in a certain directory other than this, you can create symbolic links,
    or simply put those files where the tool needs them instead of `/build/ci`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/ci`目录应包含持续集成工具脚本和配置。如果你使用的持续集成工具需要将其文件放在除这个目录之外的特定目录中，你可以创建符号链接，或者简单地将这些文件放在工具需要的目录中而不是`/build/ci`。'
- en: The `configs/` directory should contain the configuration file templates and
    default configurations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`configs/`目录应包含配置文件模板和默认配置。'
- en: 'You can also see projects that have the `main` package under the module root,
    eliminating the `cmd/` directory. This is a common layout when the module has
    only one executable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以看到在模块根目录下有`main`包的项目，消除了`cmd/`目录。当模块只有一个可执行文件时，这是一个常见的布局：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Then there are modules without any `main` package. These are usually libraries
    that you can import into your projects. For example, [https://github.com/google/uuid](https://github.com/google/uuid)
    contains the popular UUID implementation using a flat directory structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有一些没有`main`包的模块。这些通常是你可以导入到你的项目中的库。例如，[https://github.com/google/uuid](https://github.com/google/uuid)
    包含使用平面目录结构的流行UUID实现。
- en: Building and running programs
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行程序
- en: Now that you have a module and a source tree with some Go files, you can build
    or run your program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个模块和一些Go文件的源树，你可以构建或运行你的程序。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use `go build` to build the current package
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go build`来构建当前包
- en: Use `go build ./path/to/package` to build the package in the given directory
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go build ./path/to/package`在给定目录下构建包
- en: Use `go build <moduleName>` to build a module
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go build <moduleName>`构建模块
- en: Use `go run` to run the current `main` package
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go run`来运行当前的`main`包
- en: Use `go run ./path/to/main/package` to build and run the `main` package in the
    given directory
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go run ./path/to/main/package`在给定目录下构建和运行`main`包
- en: Use `go run <moduleName/mainpkg>` to build and run the module’s main under the
    given directory
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go run <moduleName/mainpkg>`在给定目录下构建和运行模块的`main`
- en: 'Let’s write the `main` function that starts an HTTP server. The following snippet
    is `cmd/webform/main.go`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个启动HTTP服务器的`main`函数。以下片段是`cmd/webform/main.go`：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Currently, `main` only imports the standard library’s `net/http` package. It
    starts a server that serves the files under the `web/static` directory. Note that
    for this to work, you have to run the program from the module root:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`main`只导入标准库的`net/http`包。它启动一个服务器，为`web/static`目录下的文件提供服务。注意，为了使这生效，你必须从模块根目录运行程序：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Always run the `main` package; avoid `go run main.go`. This will run `main.go`,
    excluding any other files in the main package. It will fail if you have other
    `.go` files that contain helper functions in the `main` package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 总是运行`main`包；避免使用`go run main.go`。这将运行`main.go`，排除`main`包中的任何其他文件。如果你在`main`包中有其他包含辅助函数的`.go`文件，它将失败。
- en: If you run this program from another directory, it will fail to find the `web/static`
    directory; because it is a **relative path**, it is resolved relative to the current
    directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这个目录之外运行此程序，它将无法找到`web/static`目录；因为它是一个**相对路径**，它是相对于当前目录解析的。
- en: 'When you run a program via `go run`, the program executable is placed in a
    temporary directory. To build the executable, use the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过`go run`运行程序时，程序的可执行文件会被放置在一个临时目录中。要构建可执行文件，请使用以下命令：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will create a binary in the current directory. The name of the binary
    will be determined by the last segment of the main package – in this case, `webform`.
    To build a binary with a different name, use the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中创建一个二进制文件。二进制文件的名字将由主包的最后一个部分决定——在这种情况下，是`webform`。要使用不同的名字构建二进制文件，请使用以下命令：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will build a binary called `wform`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个名为`wform`的二进制文件。
- en: Importing third-party packages
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入第三方包
- en: Most projects will depend on third-party libraries that must be imported into
    them. The Go module system manages these dependencies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目将依赖于必须导入到它们中的第三方库。Go模块系统管理这些依赖。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Find the import path of the package you need to use in your project.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你项目中需要使用的包的导入路径。
- en: Add the necessary imports to the source files you use in the external package.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的导入添加到你在外部包中使用的源文件中。
- en: Use the `go get` or `go mod tidy` command to add the module to `go.mod` and
    `go.sum`. If the module was not downloaded before, this step will also download
    the module.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`或`go mod tidy`命令将模块添加到`go.mod`和`go.sum`中。如果模块之前没有下载，这一步也会下载模块。
- en: Tip
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use [https://pkg.go.dev](https://pkg.go.dev) to discover packages. It
    is also the place to publish documentation for the Go projects you publish.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用[https://pkg.go.dev](https://pkg.go.dev)来发现包。这也是你发布Go项目文档的地方。
- en: Let’s add a database to our program from the previous section so that we can
    store the data submitted by the web form. For this exercise, we will use the `SQLite`
    database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在上一节中添加一个数据库到我们的程序，这样我们就可以存储由网页表单提交的数据。对于这个练习，我们将使用`SQLite`数据库。
- en: 'Change the `cmd/webform/main.go` file to import the database package and add
    the necessary database initialization code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将`cmd/webform/main.go`文件修改为导入数据库包并添加必要的数据库初始化代码：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `_ "modernc.org/sqlite"` line imports the `SQLite` driver into the project.
    The underscore is the `sqlite` package is not directly used by this file and is
    only included for its side effects. Without the blank identifier, the compiler
    would complain that the import was not used. In this case, the `modernc.org/sqlite`
    package is a database driver, and when you import it, its `init()` functions will
    register the required driver with the standard library.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ "modernc.org/sqlite"`这一行将`SQLite`驱动程序导入到项目中。下划线是`sqlite`包不是直接由这个文件使用，只是为了它的副作用。如果没有空白标识符，编译器会抱怨导入没有被使用。在这种情况下，`modernc.org/sqlite`包是一个数据库驱动程序，当你导入它时，它的`init()`函数将注册所需的驱动程序到标准库中。'
- en: The next declaration imports the `commentdb` package from our module. Note that
    the complete module name is used to import the package. The build system will
    recognize the prefix of this import declaration as the current module name, and
    it will translate it to a local filesystem reference, which, in this case, is
    `webform/pkg/commentdb`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个声明从我们的模块中导入`commentdb`包。注意，使用完整的模块名称来导入包。构建系统将识别这个导入声明的前缀作为当前模块名称，并将其转换为本地文件系统引用，在这种情况下，是`webform/pkg/commentdb`。
- en: On the `db, err := sql.Open("sqlite", "webform.db")` line, we use the `database/sql`
    package function, `Open`, to start a `SQLite` database instance. `sqlite` names
    the database driver, which was registered by the imported `_ "modernc.org/sqlite"`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`db, err := sql.Open("sqlite", "webform.db")`这一行，我们使用`database/sql`包的`Open`函数来启动一个`SQLite`数据库实例。`sqlite`命名了数据库驱动程序，它是由导入的`_
    "modernc.org/sqlite"`注册的。
- en: The `commentdb.InitDB(db)` statement will call a function from the `commentdb`
    package .
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`commentdb.InitDB(db)`语句将调用`commentdb`包中的一个函数。'
- en: 'Now, let’s see what `commentdb.InitDB` looks like. This is the `webform/pkg/commentdb/initdb.go`
    file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`commentdb.InitDB`是什么样子。这是`webform/pkg/commentdb/initdb.go`文件：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, this function creates the database tables if they have not been
    created yet.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数会在尚未创建的情况下创建数据库表。
- en: Note the capitalization of `InitDB`. If the first letter of a symbol name declared
    in a package is a capital letter, that symbol is accessible from other packages
    (i.e., it is *exported*). If not, the symbol can only be used within the package
    it is declared (i.e., it is *not exported*). The `createStmt` constant is not
    exported and will be invisible to other packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `InitDB` 的首字母大写。如果一个包中声明的符号名的第一个字母是大写，则该符号可以从其他包访问（即，它是 *导出的*）。如果不是，该符号只能在声明它的包中使用（即，它
    *未导出的*）。`createStmt` 常量未导出，对其他包不可见。
- en: 'Let’s build the program:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建程序：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can run `go get modernc.org/sqlite` to add a module to your project. Alternatively,
    you can run the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 `go get modernc.org/sqlite` 将模块添加到你的项目中。或者，你可以运行以下命令：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That will get all the missing modules. Alternatively, you can run the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取所有缺失的模块。或者，你可以运行以下命令：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`go mod tidy` will download all missing packages, update `go.mod` and `go.sum`
    with updated dependencies, and remove references to any unused modules. `go get`
    will only download missing modules.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`go mod tidy` 将下载所有缺失的包，更新 `go.mod` 和 `go.sum` 以包含更新的依赖项，并删除对任何未使用模块的引用。`go
    get` 只会下载缺失的模块。'
- en: Importing specific versions of packages
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入特定版本的包
- en: Sometimes, you need a specific version of a third-party package because of API
    incompatibilities or a particular behavior you depend on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要第三方包的特定版本，因为 API 不兼容或依赖于特定的行为。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To get a specific version of a package, specify the version label:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取特定版本的包，指定版本标签：
- en: '[PRE13]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To get the latest release of a specific major version of a package, use this:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取特定主版本的包的最新版本，请使用以下命令：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, use this:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用以下命令：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To import the latest available version, use this:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要导入最新可用的版本，请使用以下命令：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also specify a different branch. The following will get a module from
    the `devel` branch, if there is one:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以指定不同的分支。以下命令将从一个 `devel` 分支获取模块，如果存在的话：
- en: '[PRE17]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Alternatively, you can get a specific commit:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以获取一个特定的提交：
- en: '[PRE18]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, you can get a specific revision of a module using the `@``revision`
    convention:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以使用 `@` `revision` 习惯用法来获取模块的特定版本：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The revision part of the URL is evaluated by the version control system, which,
    in this case, is `git`, so any valid `git` revision syntax can be used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: URL 的修订部分由版本控制系统评估，在这种情况下是 `git`，因此可以使用任何有效的 `git` 修订语法。
- en: 'Tip:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: You can find which revision control systems are supported by checking out the
    `src/cmd/go/alldocs.go` file under your Go installation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查你的 Go 安装下的 `src/cmd/go/alldocs.go` 文件来找出支持的版本控制系统。
- en: 'That also means you can use branches:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以使用分支：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The [https://gopkg.in](https://gopkg.in) service translates version numbers
    to URLs compatible with the Go build system. Refer to the instructions on that
    website on how to use it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gopkg.in](https://gopkg.in) 服务将版本号转换为与 Go 构建系统兼容的 URL。请参阅该网站上的说明了解如何使用它。'
- en: Working with the module cache
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与模块缓存一起工作
- en: The module cache is a directory where the Go build system stores downloaded
    module files. This section describes how to work with the module cache.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模块缓存是一个目录，Go 构建系统在其中存储下载的模块文件。本节描述了如何与模块缓存一起工作。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The module cache is, by default, under `$GOPATH/pkg/mod`, which is `$HOME/go/pkg/mod`
    when `GOPATH` is not set:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模块缓存位于 `$GOPATH/pkg/mod`，当未设置 `GOPATH` 时为 `$HOME/go/pkg/mod`：
- en: By default, the Go build system creates read-only files under the module cache
    to prevent accidental modifications.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Go 构建系统在模块缓存下创建只读文件，以防止意外修改。
- en: 'To verify that the module cache is not modified and reflects the original versions
    of modules, use this:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要验证模块缓存未被修改且反映了模块的原始版本，请使用以下命令：
- en: '[PRE21]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To clean up the module cache, use this:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要清理模块缓存，请使用以下命令：
- en: '[PRE22]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The authoritative source for information about the module cache is the Go Modules
    Reference ([https://go.dev/ref/mod](https://go.dev/ref/mod))
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模块缓存的权威信息来源是 Go Modules 参考 ([https://go.dev/ref/mod](https://go.dev/ref/mod))。
- en: Using internal packages to reduce an API surface
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内部包来减少 API 表面积
- en: Not every piece of code is reusable. Having a smaller API surface makes it easier
    for others to adapt and use your code. So, you should not export APIs that are
    specific to your program.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有代码都是可重用的。较小的 API 表面积使得其他人更容易适应和使用你的代码。因此，你不应该导出仅针对你程序的 API。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create `internal` packages to hide implementation details from other packages.
    Anything under an `internal` package can only be imported from the packages under
    the package containing that `internal` package – that is, anything under `myproject/internal`
    can only be imported from the packages under `myproject`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `internal` 包以隐藏其他包的实现细节。任何在 `internal` 包下的内容只能从包含该 `internal` 包的包中导入 – 即，任何在
    `myproject/internal` 下的内容只能从 `myproject` 下的包中导入 – 那就是任何在 `myproject` 下的内容。
- en: In our example, we placed the database access code into a package where it can
    be accessed by other programs. However, it does not make sense to expose the HTTP
    routes to others, as they are specific to this program. So, we will put them under
    the `webform/internal` package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将数据库访问代码放入一个包中，以便其他程序可以访问。然而，将 HTTP 路由暴露给其他人没有意义，因为它们是特定于这个程序的。所以，我们将它们放在
    `webform/internal` 包下。
- en: 'This is the `internal/routes/routes.go` file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `internal/routes/routes.go` 文件：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we change the `main.go` file to use the internal package:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `main.go` 文件更改为使用内部包：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using a local copy of a module
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块的本地副本
- en: Sometimes, you will work on multiple modules, or you download a module from
    a repository, make some changes to it, and then want to use the changed version
    instead of the version available on the repository.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您将工作在多个模块上，或者从存储库下载一个模块，对其进行一些更改，然后想使用更改后的版本而不是存储库上的版本。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the `replace` directive in `go.mod` to point to the local directory containing
    a module.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go.mod` 中的 `replace` 指令指向包含模块的本地目录。
- en: 'Let’s return to our example – suppose you want to make some changes to the
    `sqlite` package:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子 – 假设你想对 `sqlite` 包做一些更改：
- en: 'Clone it:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆它：
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify the `go.mod` file under your project to point to the local copy of the
    module. `go.mod` becomes the following:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您项目下的 `go.mod` 文件以指向模块的本地副本。`go.mod` 变为以下内容：
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can now make changes in the `sqlite` module on your system, and those changes
    will be built into your application.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在系统上的 `sqlite` 模块中进行更改，并且这些更改将构建到您的应用程序中。
- en: Working on multiple modules – workspaces
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多个模块上工作 – 工作空间
- en: Sometimes you need to work with multiple interdependent modules. A convenient
    way to do this is by defining a workspace. A workspace is simply a set of modules.
    If one of the modules within a workspace refers to a package in another module
    in the same workspace, it is resolved locally instead of that module being downloaded
    over the network.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要与多个相互依赖的模块一起工作。一个方便的方法是通过定义工作空间来实现。工作空间只是一组模块。如果工作空间内的某个模块引用了同一工作空间内另一个模块的包，它将本地解析而不是从网络上下载该模块。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a workspace, you have to have a parent directory containing all your
    work modules:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建工作空间，你必须有一个包含所有工作模块的父目录：
- en: '[PRE27]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, start a workspace using this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下命令启动工作空间：
- en: '[PRE28]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will create a `go.work` file in this directory.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在当前目录下创建一个 `go.work` 文件。
- en: Place the module you are working on into this directory.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您正在工作的模块放入此目录。
- en: 'Let’s demonstrate this using our example. Let’s say we have the following directory
    structure:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们用我们的例子来演示这一点。假设我们有以下目录结构：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we want to add the two modules, `webform` and `sqlite`, to the workspace.
    To do that, use this:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们想要将两个模块 `webform` 和 `sqlite` 添加到工作空间中。为此，使用以下命令：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These commands will add the two modules to your workspace. Any `sqlite` reference
    from the `webform` module will now be resolved to use the local copy of the module.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些命令将两个模块添加到您的工作空间中。任何来自 `webform` 模块的 `sqlite` 引用现在将解析为使用模块的本地副本。
- en: Managing the versions of your module
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理您模块的版本
- en: 'Go tooling uses the semantic versioning system. This means that the version
    numbers are of the `X.Y.z` form, broken down as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Go 工具使用语义版本控制系统。这意味着版本号采用 `X.Y.z` 的形式，具体如下：
- en: '`X` is incremented for major releases that are not necessarily backward compatible.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X` 用于主要发布，这些发布可能不是向后兼容的。'
- en: '`Y` is incremented for minor releases that are incremental but backward-compatible'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Y` 用于增量但向后兼容的小版本发布进行递增'
- en: '`z` is incremented for backward-compatible patches'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`z` 用于向后兼容的补丁进行递增'
- en: You can learn more about semantic versioning at [https://semver.org](https://semver.org).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://semver.org](https://semver.org) 上了解更多关于语义版本化的信息。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To publish a patch or minor version, tag the branch containing your changes
    with the new version number:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发布补丁或小版本，请使用新版本号标记包含您更改的分支：
- en: '[PRE31]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you want to publish a new release that has an incompatible API with the
    previous releases, you should increment the major versions of that module. To
    release a new major version of your module, use a new branch:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要发布一个与先前版本不兼容的新版本，你应该增加该模块的主版本号。要发布模块的新主要版本，使用一个新的分支：
- en: '[PRE32]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, change your module name in `go.mod` to end with `/v2`, and update all
    references in the source tree to use the `/v2` version of the module.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将 `go.mod` 中的模块名称更改为以 `/v2` 结尾，并更新源树中的所有引用以使用模块的 `/v2` 版本。
- en: For example, let’s say you released the first version of the `webform` module,
    `v1.0.0`. Then, you decided you would like to add new API endpoints. This would
    not be a breaking change, so you simply increment the minor version number – `v1.1.0`.
    But then it turns out some of the APIs you added were causing problems, so you
    removed them. Now, that is a breaking change, so you should publish `v2.0.0` with
    it. How can you do that?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你发布了 `webform` 模块的第一版，`v1.0.0`。然后，你决定你想要添加新的 API 端点。这不会是一个破坏性变更，所以你只需简单地增加次要版本号——`v1.1.0`。但后来发现你添加的一些
    API 造成了问题，所以你移除了它们。现在，这是一个破坏性变更，所以你应该发布带有它的 `v2.0.0`。你该如何做到这一点呢？
- en: 'The answer is, you use a new branch in the version control system. Create the
    `v2` branch:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，你在版本控制系统中使用一个新的分支。创建 `v2` 分支：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, change `go.mod` to reflect the new version:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `go.mod` 更改为反映新版本：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If there are multiple packages in the module, you have to update the source
    tree so that any references to packages within that module also use the `v2` version.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块中有多个包，你必须更新源树，以便该模块内对包的任何引用也使用 `v2` 版本。
- en: 'Commit and push the new branch:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并推送新分支：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To use the new version, you now have to import the `v2` version of the packages:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新版本，你现在必须导入包的 `v2` 版本：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary and further reading
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和进一步阅读
- en: This chapter focused on the concepts and mechanics of setting up and managing
    Go projects. It is by no means an exhaustive reference, but the recipes presented
    here should give you the basics of using the Go build system effectively.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了设置和管理 Go 项目的概念和机制。这绝对不是一份详尽的参考，但这里提供的食谱应该能让你掌握有效使用 Go 构建系统的基本知识。
- en: The definitive guide for Go modules is the Go Modules Reference ([https://go.dev/ref/mod](https://go.dev/ref/mod)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块的确切指南是 Go Modules 参考 ([https://go.dev/ref/mod](https://go.dev/ref/mod))。
- en: Check out the *Managing dependencies* link ([https://go.dev/doc/modules/managing-dependencies](https://go.dev/doc/modules/managing-dependencies))
    for a detailed discussion on dependency management.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 查看关于依赖管理的详细讨论，请访问 *管理依赖项* 链接 ([https://go.dev/doc/modules/managing-dependencies](https://go.dev/doc/modules/managing-dependencies))。
- en: In the next chapter, we will start working with textual data.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始处理文本数据。
