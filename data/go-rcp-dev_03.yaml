- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Working with Date and Time
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理日期和时间
- en: Working with date and time can be difficult in any programming language. Go’s
    standard library offers easy-to-use tools to work with date and time constructs.
    These may be somewhat different from what many people are used to. For example,
    there are libraries in different languages that make a distinction between a `time`
    type and a `date` type. Go’s standard library only includes a `time.Time` type.
    That might make you feel disoriented when you’re working with Go’s time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中处理日期和时间都可能很困难。Go 的标准库提供了易于使用的工具来处理日期和时间结构。这些可能与许多人习惯的不同。例如，不同语言中的库会在
    `time` 类型与 `date` 类型之间做出区分。Go 的标准库只包含 `time.Time` 类型。这可能会让你在处理 Go 的时间时感到困惑。
- en: 'I’d like to think that Go’s treatment of date/time reduces the chances of creating
    subtle bugs. You see, you have to be really careful and clear about what you mean
    when you talk about time: are you talking about a point in time or an interval?
    A date is actually an interval (for instance, 08/01/2024 starts at 08/01/2024T00:00:00
    and continues until 08/01/2024T23:59:59) even though usually that is not the intent.
    A specific date/time value also depends on where you are measuring time. 2023-11-05T08:00
    in Denver, Colorado is different from 2023-11-05T08:00 in Berlin, Germany. Time
    always moves forward, but date/time may skip or go backward: after 2023-11-05T02:59
    in Denver, Colorado, time goes back to 2023-11-05T02:00 because that is when daylight
    savings time ends in Colorado. So there are actually two time instances for 2023-11-05T02:10:10,
    one in Mountain Daylight Time, and one in Mountain Standard Time.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望认为 Go 对日期/时间的处理减少了创建微妙错误的机会。你看，当你谈论时间时，你必须非常小心和明确你所说的意思：你是谈论一个时间点还是一个时间段？实际上，日期是一个时间段（例如，08/01/2024
    从 08/01/2024T00:00:00 开始，一直持续到 08/01/2024T23:59:59），尽管通常这不是意图。特定的日期/时间值也取决于你测量时间的位置。在科罗拉多州的丹佛，2023-11-05T08:00
    与在德国柏林的 2023-11-05T08:00 是不同的。时间总是向前移动，但日期/时间可能会跳过或倒退：在科罗拉多州的丹佛，2023-11-05T02:59
    之后，时间会倒退到 2023-11-05T02:00，因为那是科罗拉多州夏令时结束的时候。因此，实际上对于 2023-11-05T02:10:10 有两个时间实例，一个在山地夏令时，另一个在山地标准时。
- en: There are many software bugs in production today that handle time incorrectly.
    For example, if you are computing when the subscription of a customer ends, you
    have to take into account the location of that customer and the time of day that
    subscription ends, otherwise, their subscriptions may terminate early (or late)
    on their last day.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 目前生产中的许多软件错误都处理时间不正确。例如，如果你在计算客户订阅何时结束，你必须考虑该客户的位置和订阅结束的时间，否则，他们的订阅可能在最后一天提前（或延迟）结束。
- en: 'This chapter contains the following recipes for working with date/time correctly:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下关于正确处理日期/时间的食谱：
- en: Working with Unix time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Unix 时间
- en: Date/time components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期/时间组件
- en: Date/time arithmetic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期/时间算术
- en: Formatting and parsing date/time
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期/时间的格式化和解析
- en: Working with time zones
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时区
- en: Timers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器
- en: Tickers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时器
- en: Storing time information
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储时间信息
- en: Working with Unix time
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Unix 时间
- en: Unix time is the number of seconds (or milliseconds, microseconds, or nanoseconds)
    passed since January 1, 1970 UTC (the epoch.) Go uses `int64` to represent these
    values, so Unix time as seconds can represent billions of years into the past
    or the future. Unix time as nanoseconds can represent date values between 1678
    and 2262\. Unix time is an absolute measure of an instance as the duration since
    (or until) the epoch. It is independent of the location, so with two Unix times,
    `s` and `t`, if `s<t`, then `s` happened before `t`, no matter the location. Because
    of these properties, Unix time is usually used as a timestamp that marks when
    an event happened (when a log is written, when a record is inserted, etc.).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 时间是从 1970 年 1 月 1 日 UTC（纪元）开始经过的秒数（或毫秒、微秒或纳秒）。Go 使用 `int64` 来表示这些值，因此 Unix
    时间以秒为单位可以表示过去或未来数十亿年的时间。Unix 时间以纳秒为单位可以表示 1678 年至 2262 年之间的日期值。Unix 时间是自纪元以来（或直到纪元）的绝对时间实例度量。它是独立于位置的，因此如果有两个
    Unix 时间，`s` 和 `t`，如果 `s<t`，则 `s` 发生在 `t` 之前，无论位置如何。由于这些属性，Unix 时间通常用作标记事件发生时间（日志写入时、记录插入时等）的时间戳。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To get the current Unix time, use the following:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前 Unix 时间，请使用以下方法：
- en: '`time.Now().Unix() int64`: Unix time in seconds'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Now().Unix() int64`：Unix 时间以秒为单位'
- en: '`time.Now().UnixMilli() int64`: Unix time in milliseconds'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Now().UnixMilli() int64`：Unix 时间以毫秒为单位'
- en: '`time.Now().UnixMicro() int64`: Unix time in microseconds'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Now().UnixMicro() int64`：Unix 时间以微秒为单位'
- en: '`time.Now().UnixNano() int64`: Unix time in nanoseconds'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Now().UnixNano() int64`: 以纳秒为单位的Unix时间'
- en: 'Given a Unix time, convert it to a `time.Time` type using the following:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个Unix时间，使用以下方法将其转换为`time.Time`类型：
- en: '`time.Unix(sec, nanosec int64) time.Time`: Translate Unix time in seconds and/or
    nanoseconds to `time.Time`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Unix(sec, nanosec int64) time.Time`: 将秒和/或纳秒级的Unix时间转换为`time.Time`'
- en: '`time.UnixMilli(int64) time.Time`: Translate Unix time in milliseconds to `time.Time`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.UnixMilli(int64) time.Time`: 将毫秒级的Unix时间转换为`time.Time`'
- en: '`time.UnixMicro(int64) time.Time`: Translate Unix time in microseconds to `time.Time`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.UnixMicro(int64) time.Time`: 将微秒级的Unix时间转换为`time.Time`'
- en: To translate a Unix time to local time, use `localTime := time.Unix(unixTimeSeconds,0).In(location)`,
    where `location` is a `*time.Location` for the location in which to interpret
    the Unix time
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将Unix时间转换为本地时间，请使用`localTime := time.Unix(unixTimeSeconds,0).In(location)`，其中`location`是要解释Unix时间的位置的`*time.Location`
- en: Date/time components
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期/时间组成部分
- en: When working with date values, you often have to compose a date/time from its
    components or need to access the components of a date/time value. This recipe
    shows how it can be done.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理日期值时，你通常需要从其组成部分组合一个日期/时间，或者需要访问日期/时间的组成部分。这个菜谱展示了如何做到这一点。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To build a date/time value from parts, use the `time.Date` function
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从各个部分构建日期/时间值，请使用`time.Date`函数
- en: 'To get the parts of a date/time value, use the `time.Time` methods:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取日期/时间值的各个部分，请使用`time.Time`方法：
- en: '`time.Day() int`'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Day() int`'
- en: '`time.Month() time.Month`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Month() time.Month`'
- en: '`time.Year() int`'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Year() int`'
- en: '`time.Date() (year, month,` `day int)`'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Date() (year, month, day int)`'
- en: '`time.Hour() int`'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Hour() int`'
- en: '`time.Minute() int`'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Minute() int`'
- en: '`time.Second() int`'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Second() int`'
- en: '`time.Nanosecond() int`'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Nanosecond() int`'
- en: '`time.Zone() (name` `string,offset int)`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Zone() (name string,offset int)`'
- en: '`time.Location() *time.Location`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.Location() *time.Location`'
- en: '`time.Date` will create a time value from its components:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Date`将从其组成部分创建一个时间值：'
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will be normalized, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将被标准化，如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the day of the month starts from 1, creating a date with a `0` day will
    result in the last day of the previous month.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于月份的日期从1日开始，使用`0`天创建的日期将导致上一个月的最后一天。
- en: 'Once you have a `time.Time` value, you can get its components:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个`time.Time`值，你可以获取其组成部分：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, `time.Date` normalizes the date value, so `d.Day()` will return `29`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`time.Date`会标准化日期值，所以`d.Day()`将返回`29`。
- en: Date/time arithmetic
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期/时间算术
- en: 'Date/time arithmetic is necessary to answer questions such as the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 日期/时间算术对于回答以下问题等是必要的：
- en: How long did it take to complete an operation?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成一次操作需要多长时间？
- en: What time will it be after 5 minutes?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5分钟后将会是什么时间？
- en: How many days are there until next month?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下个月还有多少天？
- en: This recipe shows how you can answer these questions using the `time` package.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何使用`time`包来回答这些问题。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To find out how much time has passed between two instances in time, use the
    `Time.Sub` method to subtract them.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出两个时间实例之间经过的时间，请使用`Time.Sub`方法来减去它们。
- en: To find the duration from now to a later time, use `time.Until(laterTime)`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出从现在到较晚时间的时间间隔，请使用`time.Until(laterTime)`。
- en: To find how much time has passed since a given time, use `time.Since(beforeTime)`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出从给定时间以来经过的时间，请使用`time.Since(beforeTime)`。
- en: To find out what time it will be after a certain duration, use the `Time.Add`
    method. Use negative duration to find the time before a certain duration.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出经过一定时间后将会是什么时间，请使用`Time.Add`方法。使用负持续时间来查找在某个时间之前的时间。
- en: To add/subtract years, months, or days to/from a time, use the `Time.AddDate`
    method.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在时间上添加/减去年、月或日，请使用`Time.AddDate`方法。
- en: 'To compare two `time.Time` values, use the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要比较两个`time.Time`值，请使用以下方法：
- en: '`Time.Equal` to check whether two time values represent the same instance'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Time.Equal`来检查两个时间值是否表示相同的实例
- en: '`Time.Before` or `Time.After` to check whether a time value is before or after
    a given time value'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Time.Before`或`Time.After`来检查时间值是否在给定时间值之前或之后
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `time.Duration` type represents the time elapsed between two instances in
    nanoseconds as an `int64` value. In other words, if you subtract a `time.Time`
    value from another, you get a `time.Duration`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Duration`类型表示两个实例之间的时间间隔（以纳秒为单位）作为一个`int64`值。换句话说，如果你从一个`time.Time`值减去另一个值，你得到一个`time.Duration`：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since `Duration` is an `int64` representing nanoseconds, you can do duration
    arithmetic:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Duration`是一个表示纳秒的`int64`，你可以进行持续时间算术：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the last operation in the preceding also involves multiplication since
    `time.Hour` is of the `time.Duration` type itself.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面提到的最后一个操作也涉及到乘法，因为 `time.Hour` 本身就是 `time.Duration` 类型。
- en: 'You can add a duration value to a `time.Time` value:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将持续时间值添加到 `time.Time` 值中：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Duration being an `int64` means that a `time.Duration` value is limited to around
    290 years. This should be sufficient for most practical cases. However, if this
    is not the case for you, you need to build a solution for yourself or find a third-party
    library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间是一个 `int64` 类型意味着 `time.Duration` 值限制在大约290年左右。这对于大多数实际案例应该足够了。然而，如果你不满足这种情况，你需要为自己构建解决方案或寻找第三方库。
- en: 'You can subtract the duration from a `time.Time` value by adding a negative
    duration value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加一个负持续时间值从 `time.Time` 值中减去持续时间：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note the use of the `Time.Equal` method. This compares two time instances taking
    into account their time zones, which can be different. For instance, `Time.Equal`
    will return `true` for `2024-01-09 09:00 MST` and `2024-01-09` `08:00 PST`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Time.Equal` 方法的使用。它比较两个时间实例，考虑到它们的时间区可能不同。例如，`Time.Equal` 将对 `2024-01-09
    09:00 MST` 和 `2024-01-09 08:00 PST` 返回 `true`。
- en: 'Use `Time.Before` and `Time.After` to compare time values. For instance, you
    can check whether an object with an expiration date has expired by using the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Time.Before` 和 `Time.After` 来比较时间值。例如，你可以通过以下方式检查一个具有到期日期的对象是否已过期：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also add years/months/days to a given date:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以给一个给定的日期添加年/月/日：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result of these operations will be normalized. For instance, if you subtract
    a year from `2020-02-29`, you will get `2019-03-01`. This causes problems when
    you are working with a date at the end of a month and you have to add/subtract
    month values. Adding a month to `2020-03-31` twice will yield `2020-06-01`, but
    adding two months will yield `2020-05-31`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的结果将被标准化。例如，如果你从 `2020-02-29` 减去一年，你会得到 `2019-03-01`。这在你处理月底的日期并需要加减月份值时会引起问题。将月份加到
    `2020-03-31` 两次将得到 `2020-06-01`，但加两个月将得到 `2020-05-31`：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Formatting and parsing date/time
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期/时间的格式化和解析
- en: 'Go uses an interesting and somewhat controversial date/time formatting scheme.
    The date/time format is expressed using a specific point in time, adjusted such
    that every component of the date/time is a unique number:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用了一个有趣且有些有争议的日期/时间格式化方案。日期/时间格式使用一个特定的时间点来表示，调整后使得日期/时间的每个组成部分都是唯一的数字：
- en: '1 is the month: “Jan” “January” “01” “1”'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 是月份：“Jan” “January” “01” “1”
- en: '2 is the day of the month: “2” “_2” “02”'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 是月份中的天：“2” “_2” “02”
- en: '3 is the hour of the day in a 12-hour format: “15” “3” “03”'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 是12小时制中的小时：“15” “3” “03”
- en: 15 is the hour of the day in a 24-hour format,
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 15 是24小时制中的小时，
- en: '4 is the minute: “4” “04”'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 是分钟：“4” “04”
- en: '5 is the second: “5” “05”'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 是秒：“5” “05”
- en: '6 is the year: “2006” “06”'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6 是年份：“2006” “06”
- en: 'MST is the timezone: “-0700” “-07:00” “-07” “-070000” “-07:00:00” “MST”'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MST 是时区：“-0700” “-07:00” “-07” “-070000” “-07:00:00” “MST”
- en: '0 is the millisecond padded with 0s: “0” “000”'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 是填充了0的毫秒：“0” “000”
- en: '9 is the millisecond that is not padded: “9” “999”'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 是未填充的毫秒：“9” “999”
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use `time.Parse` with an appropriate format to parse date/time. Any parts of
    the date/time that are not specified in the format will be initialized to its
    zero value, which is January for months, 1 for the year, 1 for the day of the
    month, and 0 for everything else. If the time zone information is missing, the
    parsed date/time will be in UTC.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `time.Parse` 和适当的格式来解析日期/时间。在格式中未指定的日期/时间部分将被初始化为其零值，月份为1月，年份为1，月份中的天为1，其余部分为0。如果缺少时区信息，解析的日期/时间将使用UTC。
- en: Use `time.ParseInLocation` to parse date/time in a given location. The time
    zone will be determined based on the date value and the location.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `time.ParseInLocation` 在指定位置解析日期/时间。时区将根据日期值和位置确定。
- en: Use the `Format()` method to format a date/time value.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Format()` 方法来格式化日期/时间值。
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Time zones change by location and by date. In the following example, even though
    the same location is used to parse the date, the time zone changes because July
    9 is Mountain Daylight Time, but January 9 is Mountain Standard Time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 时区根据位置和日期而变化。在以下示例中，即使使用相同的位置来解析日期，时区也会变化，因为7月9日是山地夏令时，而1月9日是山地标准时：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Working with time zones
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理时区
- en: 'The Go `time.Time` value includes `time.Location`, which can be one of two
    things:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Go的 `time.Time` 值包括 `time.Location`，这可以是两种情况之一：
- en: A real location, such as `America/Denver`. If this is the case, the actual time
    zone depends on the time value. For `Denver`, the time zone will be either `MDT`
    (Mountain Daylight Time) or `MST` (Mountain Standard Time) depending on the actual
    time value
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个真实的位置，例如 `America/Denver`。如果是这种情况，实际时区将取决于时间值。对于 `Denver`，时区将是 `MDT`（山地夏令时）或
    `MST`（山地标准时），具体取决于实际的时间值。
- en: A fixed time zone that gives the offset.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提供偏移量的固定时区。
- en: Some applications work with **local time**. This is the date/time value captured
    at a particular location, and interpreted as the same value everywhere, as opposed
    to being interpreted as the same point in time. Birthdays (and thus, ages) are
    usually interpreted using local time. That is, if you are born on 2005-07-14,
    you will be considered 2 years old in New York (Eastern time zone) on 2007-07-14
    at 00:00, but still be 1 year old at the same moment in time in Los Angeles, which
    is 2007-07-13 at 21:00 (Pacific time zone).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序使用 **本地时间**。这是在特定位置捕获的日期/时间值，并在任何地方解释为相同的值，而不是解释为相同的时间点。生日（因此，年龄）通常使用本地时间来解释。也就是说，如果你在2005-07-14出生，你将在2007-07-14
    00:00（东部时区）在纽约被认为是2岁，但在同一点时间在洛杉矶，即2007-07-13 21:00（太平洋时区），你仍然是1岁。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If you are working with moments in time, always capture date/time values with
    the associated location. Such date/time values can be translated into other time
    zones easily.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理时间点，始终使用相关位置捕获日期/时间值。这些日期/时间值可以轻松转换为其他时区。
- en: If you are working with local time in multiple time zones, recreate `time.Time`
    in a new location or time zone to translate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理多个时区的本地时间，在新的位置或时区中重新创建 `time.Time` 以进行转换。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When you create a `time.Time`, it is always associated with a location:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 `time.Time` 时，它总是与一个位置相关联：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once you have a `time.Time`, you can get the same moment in time in different
    time zones:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个 `time.Time`，你就可以在不同的时区中获取同一时间点：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These are different representations of the same moment in time in different
    time zones.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在不同时区中同一时间点的不同表示。
- en: 'You can also create a custom time zone:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个自定义时区：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you are dealing with local time, you discard the location and time zone
    information:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理本地时间时，你会丢弃位置和时间区域信息：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To get the same time value in New York, use the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在纽约获取相同的时间值，请使用以下方法：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Storing time information
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储时间信息
- en: A common problem is storing date/time information in databases, files, and so
    on in a portable manner, so that it can be interpreted correctly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见问题是将日期/时间信息以可移植的方式存储在数据库、文件中等，以便可以正确解释。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You should first identify the exact needs: do you need to store an instant
    of time or time of day?'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先确定确切的需求：你需要存储一个时间点还是一天中的时间？
- en: 'To store an instant of time, do one of the following:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储一个时间点，执行以下操作之一：
- en: Store Unix time at the needed granularity (that is, `time.Unix` for seconds,
    `time.UnixMilli` for milliseconds, etc.)
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所需粒度上存储Unix时间（即 `time.Unix` 用于秒，`time.UnixMilli` 用于毫秒等）。
- en: Store UTC time (`time.UTC()`)
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储UTC时间 (`time.UTC()`)
- en: 'To store the time of day, store the `time.Duration` value that gives the instant
    in the day. The following function computes the instant within that day as `time.Duration`:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储一天中的时间，存储表示一天中瞬间的 `time.Duration` 值。以下函数计算该天内的瞬间作为 `time.Duration`：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To store a date value, you can clear the time portions of `time.Time`:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储日期值，你可以清除 `time.Time` 的时间部分：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that comparing dates stored in this manner can be problematic as each day
    will be interpreted to be a different instant in different time zones.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，以这种方式存储的日期比较可能会出现问题，因为每个时区都会将每天解释为不同的瞬间。
- en: Timers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: Use `time.Timer` to schedule some work to be done in the future. When the timer
    expires, you will receive a signal from a channel. You can use a timer to run
    a function later or to cancel a process that ran too long.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `time.Timer` 来安排将来要执行的一些工作。当定时器到期时，你将从一个通道接收到一个信号。你可以使用定时器在以后运行一个函数或取消运行时间过长的进程。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You can create a timer in one of two ways:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式之一创建一个定时器：
- en: Use `time.NewTimer` or `time.After`. The timer will send a signal through a
    channel when it expires. Use a `select` statement, or read from the channel to
    receive the timer expiration signal.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `time.NewTimer` 或 `time.After`。定时器将在到期时通过通道发送一个信号。使用 `select` 语句或从通道读取以接收定时器到期信号。
- en: Use `time.AfterFunc` to call a function when the timer expires.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `time.AfterFunc` 在计时器到期时调用一个函数。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `time.Timer` timer is created with `time.Duration`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `time.Duration` 创建 `time.Timer` 计时器：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The timer contains a channel that will receive the current timestamp after 10
    seconds pass. A timer is created with a channel capacity of `1`, so the timer
    runtime will always be able to write to that channel and stop the timer. In other
    words, if you fail to read from a timer, it will not leak; it will eventually
    be garbage collected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器包含一个通道，在10秒后将会接收到当前的时间戳。计时器创建时通道容量为 `1`，因此计时器运行时总能向该通道写入并停止计时器。换句话说，如果你未能从计时器中读取，它不会泄漏；它最终会被垃圾回收。
- en: 'The timer can be used to stop a long-running process:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器可以用来停止一个长时间运行的过程：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following example shows how a timer can be used to limit the time it takes
    to return from a function. If the computation completes within a second, the response
    is returned. If the computation takes longer, the function returns a channel that
    the caller can use to receive the result. This function also demonstrates how
    you can stop a timer:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用计时器来限制函数返回所需的时间。如果计算在一秒内完成，则返回响应。如果计算时间更长，则函数返回一个调用者可以使用以接收结果的通道。此函数还演示了如何停止计时器：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the timer can expire right before the `timer.Stop()` call. This is
    okay. Timers will eventually expire and be garbage collected. Calling `timer.Stop()`
    simply prevents the timer from being active longer than necessary.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，计时器可能在调用 `timer.Stop()` 之前就到期了。这是可以的。计时器最终都会到期并被垃圾回收。调用 `timer.Stop()` 只是为了防止计时器比必要的持续时间更长。
- en: Tip
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You cannot call `Timer.Stop` concurrently while another goroutine is listening
    from the timer. So, if you have to call `Timer.Stop`, call it from the same goroutine
    that listens to the timer’s channel.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当另一个goroutine正在监听计时器时，你不能并发地调用 `Timer.Stop`。所以，如果你必须调用 `Timer.Stop`，请从监听计时器通道的同一个goroutine中调用它。
- en: 'The same thing can be achieved with `time.After`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以使用 `time.After` 实现：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tickers
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: Use `time.Ticker` to perform a task periodically. You will periodically receive
    a signal through a channel. Unlike `time.Timer`, you have to be careful about
    how you dispose of tickers. If you forget to stop a ticker, it will not be garbage
    collected once it is out of scope, and it will leak.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `time.Ticker` 定期执行任务。你将通过通道定期接收到信号。与 `time.Timer` 不同，你必须小心处理计时器。如果你忘记停止计时器，一旦超出作用域，它就不会被垃圾回收，并且会发生泄漏。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use `time.Ticker` to create a new ticker.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `time.Ticker` 创建一个新的计时器。
- en: Read from the ticker’s channel to receive the periodic ticks.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从计时器的通道读取以接收周期性的滴答声。
- en: When you are done with the ticker, stop it. You don’t have to drain the ticker’s
    channel.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成对计时器的使用后，停止它。你不需要排空计时器的通道。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Use a ticker for periodic events. A common pattern is the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计时器进行周期性事件。一个常见的模式如下：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What happens if you miss ticks? This is possible if you run a long process that
    prevents you from listening to the ticker channel. Will the ticker send a flood
    of ticks when you start listening again?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了滴答声会发生什么？如果你运行了一个长时间的过程，阻止你监听计时器通道，那么当你再次开始监听时，计时器会发送大量的滴答声吗？
- en: 'Similar to `time.Timer`, `time.Ticker` uses a channel with a capacity of `1`.
    Because of this, if you do not read from the channel, it can store, at most, one
    tick. When you start listening from the channel again, you will receive the tick
    that you missed immediately, and the next tick when its period expires. For example,
    consider the following program that calls a given function every second:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `time.Timer` 类似，`time.Ticker` 也使用一个容量为 `1` 的通道。因此，如果你不从这个通道读取，它最多只能存储一个滴答声。当你再次从通道开始监听时，你会立即接收到你错过的滴答声，以及在其周期到期时的下一个滴答声。例如，考虑以下每秒调用给定函数的程序：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s say the first call to `f()` runs for 10 milliseconds, but the second
    call runs for 1.5 seconds. While `f()` is running, there is nobody reading from
    the ticker’s channel, so a tick will be missed. Once `f()` returns, the `select`
    statement will immediately read this missed tick, and after 500 milliseconds,
    it will receive the next tick. The output looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第一次调用 `f()` 运行时间为10毫秒，但第二次调用运行时间为1.5秒。在 `f()` 运行期间，没有人从计时器的通道读取，因此会错过一个滴答声。一旦
    `f()` 返回，`select` 语句将立即读取这个错过的滴答声，并在500毫秒后接收到下一个滴答声。输出看起来像这样：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Unlike `time.Timer`, you can stop a ticker concurrently while reading from its
    channel.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与`time.Timer`不同，你可以在从其通道读取的同时并发地停止一个计时器。
