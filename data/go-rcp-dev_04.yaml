- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Working with Arrays, Slices, and Maps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数组、切片和映射一起工作
- en: Arrays, slices, and maps are the built-in container types defined by the Go
    language. They are essential parts of almost every program, and usually, the building
    blocks of other data structures. This section describes some of the common patterns
    of working with these basic data structures, as they have nuances that may not
    be obvious to a newcomer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数组、切片和映射是Go语言定义的内置容器类型。它们是几乎所有程序的基本组成部分，通常是其他数据结构的基本构建块。本节描述了使用这些基本数据结构的某些常见模式，因为它们可能对新手不明显。
- en: 'In this chapter, we will talk about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Working with arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Working with slices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与切片一起工作
- en: Implementing a stack using slices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切片实现栈
- en: Working with maps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与映射一起工作
- en: Implementing sets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现集合
- en: Using maps for thread-safe caching
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射进行线程安全的缓存
- en: Working with arrays
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Arrays are fixed-size data structures. There is no way to resize an array or
    to create an array using a variable as its size (in other words, `[n]int` is valid
    only if `n` is a constant integer). Because of this, arrays are useful to represent
    an object with a fixed number of elements, such as a SHA256 hash, which is 32
    bytes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是固定大小的数据结构。无法调整数组的大小或使用变量作为其大小创建数组（换句话说，`[n]int`仅在`n`是一个常量整数时有效）。正因为如此，数组对于表示具有固定元素数量的对象非常有用，例如SHA256哈希，它是32字节。
- en: The zero-value for an array has zero-values for every element of the array.
    For instance, `[5]int` is initialized with five integers, all 0\. A string array
    will have empty strings.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的零值对于数组的每个元素都是零值。例如，`[5]int`初始化为五个整数，全部为0。字符串数组将包含空字符串。
- en: Creating arrays and passing them around
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组并在它们之间传递
- en: This recipe shows how you can create arrays and pass array values to functions
    and methods. We will also talk about the effects of passing arrays as values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱展示了如何创建数组并将数组值传递给函数和方法。我们还将讨论传递数组作为值的效应。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create arrays using a fixed size:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用固定大小创建数组：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can specify array indexes similar to defining a map:'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以指定数组索引，类似于定义映射：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use arrays to define new types of fixed-size data:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组定义新的固定大小数据类型：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Arrays are passed by value:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组是通过值传递的：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Warning
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Passing an array by value means that every time you use an array as an argument
    to a function, the array will be copied. If you pass an array `[1000]int64` to
    a function, the runtime will allocate and copy 8,000 bytes (int64 is 64 bits,
    which is 8 bytes, and 1,000 int64 values is 8,000 bytes.) The copy will be a shallow
    copy – that is, you pass an array containing pointers, or, if you pass an array
    containing structures containing pointers, the pointers will be copied, not the
    contents of those pointers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过值传递数组意味着每次你将数组作为函数的参数使用时，数组都会被复制。如果你将一个`[1000]int64`数组传递给一个函数，运行时将分配和复制8,000字节（int64是64位，即8字节，1,000个int64值是8,000字节。）复制将是一个浅复制——也就是说，你传递了一个包含指针的数组，或者如果你传递了一个包含包含指针的结构体的数组，指针将被复制，而不是这些指针的内容。
- en: 'See the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Working with slices
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与切片一起工作
- en: A slice is a view over an array. You may be dealing with multiple slices that
    work with the same underlying data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是数组的视图。你可能正在处理多个与相同底层数据一起工作的切片。
- en: The zero-value for a slice is nil. Reading or writing a nil slice will `panic`;
    however, you can append to a nil slice, which will create a new slice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的零值是nil。读取或写入nil切片将`panic`；然而，你可以向nil切片追加，这将创建一个新的切片。
- en: Creating slices
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建切片
- en: There are several ways a slice can be created.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以创建切片。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Use `make(sliceType,length[,capacity])`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make(sliceType,length[,capacity])`：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the previous code snippet, you see three different uses of `make` to create
    a slice:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你看到了`make`的三种不同用法来创建切片：
- en: '`slice1:=make([]int,0)` creates an empty slice, `0` being the length of the
    slice. The `slice1` variable is initialized as a non-nil, 0-length slice.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice1:=make([]int,0)`创建了一个空切片，`0`是切片的长度。`slice1`变量初始化为一个非空、0长度的切片。'
- en: '`slice2 := make([]int,0,10)` creates an empty slice with capacity `10`. This
    is what you should prefer if you know the likely maximum size for this slice.
    This slice allocation avoids an allocate/copy operation up until the 11th element
    is appended.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice2 := make([]int,0,10)`创建了一个容量为`10`的空切片。如果你知道这个切片可能的最大大小，你应该选择这种方式。这种切片分配避免了在追加第11个元素之前的分配/复制操作。'
- en: '`slice3 := make([]int,10)` creates a slice with size `10` and capacity `10`.
    The slice elements are initialized to 0\. In general, with this form, the allocated
    slice will be initialized to the zero-value of its element type.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice3 := make([]int,10)` 创建了一个大小为 `10`、容量为 `10` 的切片。切片元素被初始化为 0。一般来说，使用这种形式，分配的切片将被初始化为其元素类型的零值。'
- en: Tip
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be careful about allocating a slice with a non-zero length. I personally had
    to deal with really obscure bugs because I mistyped `make([]int,10)` instead of
    `make([]int,0,10)`, and continued to append the 10 elements to the allocated slice,
    ending with 20 elements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用非零长度的切片分配。我本人就因为误将 `make([]int,10)` 错写成 `make([]int,0,10)`，然后继续向分配的切片追加10个元素，最终导致有20个元素。
- en: 'See the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下示例：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The previous code snippet creates a string slice that has `10` empty strings,
    then the strings are appended by the for-loop.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段创建了一个包含 `10` 个空字符串的字符串切片，然后通过循环将这些字符串追加进去。
- en: 'You can also initialize a slice using a literal:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用字面量初始化切片：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, you can leave a slice variable `nil`, and append to it. The
    `append` built-in will accept a `nil` slice, and create one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将切片变量留为 `nil`，然后向其追加。内置的 `append` 函数将接受一个 `nil` 切片，并创建一个新的：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a slice from an array
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数组创建切片
- en: Many functions will accept slices and not arrays. If you have an array of values
    and need to pass it to a function that wants a slice, you need to create a slice
    from an array. This is easy and efficient. Creating a slice from an array is a
    constant-time operation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数将接受切片而不是数组。如果你有一个值数组，需要将其传递给需要一个切片的函数，你需要从数组创建一个切片。这很简单且高效。从数组创建切片是一个常数时间操作。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the `[:]` notation to create a slice from the array. The slice will have
    the array as its underlying storage:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `[:]` 语法从数组创建切片。该切片将以数组作为其底层存储：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can create a slice pointing to a section of the array:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个指向数组某部分的切片：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can slice an existing slice. The bounds of the slicing operation are determined
    by the capacity of the original slice:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以切片现有的切片。切片操作的界限由原始切片的容量决定：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A slice is a data structure containing three values: slice length, capacity,
    and pointer to the underlying array. Slicing an array simply creates this data
    structure with a pointer initialized to the array. It is a constant-time operation.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是一个包含三个值的数据结构：切片长度、容量以及指向底层数组的指针。切片一个数组简单地说就是创建这样一个数据结构，并将指针初始化为数组。这是一个常数时间操作。
- en: '![Figure 4.1 – Difference between an array arr and a slice arr[:]](img/B21961_04_1.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 数组 arr 和切片 arr[:] 之间的区别](img/B21961_04_1.jpg)'
- en: Figure 4.1 – Difference between an array arr and a slice arr[:]
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 数组 arr 和切片 arr[:] 之间的区别
- en: Appending/inserting/deleting slice elements
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加/插入/删除切片元素
- en: Slices use arrays as their underlying storage, but it is not possible to grow
    arrays when you run out of space. Because of this, if an `append` operation exceeds
    the slice capacity, a new and larger array is allocated, and slice contents are
    copied to this new array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 切片使用数组作为其底层存储，但在空间不足时无法增长数组。正因为如此，如果 `append` 操作超出了切片容量，就会分配一个新的更大的数组，并将切片内容复制到这个新数组中。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To add new values to the end of the slice, use the `append` built-in function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要向切片的末尾添加新值，请使用 `append` 内置函数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To remove elements from the beginning or the end of a slice, use slicing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要从切片的开始或结束处删除元素，请使用切片：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the `slices` package to insert/delete elements from arbitrary locations
    in a slice:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `slices` 包在切片的任意位置插入/删除元素：
- en: '`slices.Delete(slice,i,j)` removes `slice[i:j]` elements from the slice and
    returns the modified slice'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slices.Delete(slice,i,j)` 从切片中删除 `slice[i:j]` 的元素，并返回修改后的切片'
- en: '`slices.Insert(slice,i,value...)` inserts the values starting at index `i`,
    shifting all elements starting from `i` to make space'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slices.Insert(slice,i,value...)` 在索引 `i` 处插入值，并将从 `i` 开始的所有元素移动以腾出空间'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you can remove elements from a slice and truncate it using a
    for-loop, like in the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用循环从切片中删除元素并截断它，如下所示：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A slice is a view over an array. It contains three pieces of information:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是数组的视图。它包含三个信息：
- en: '`ptr`: A pointer to an element of an array, which is the starting location
    of the slice'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ptr`：指向数组元素的指针，这是切片的起始位置'
- en: '`len`: The number of elements in the slice'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`：切片中元素的数量'
- en: '`cap`: The capacity remaining in the underlying array for this slice'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cap`：此切片在基础数组中剩余的容量'
- en: If you append elements to a slice beyond its capacity, a larger array is allocated
    by the runtime, and the contents of the slice are copied there. After this, the
    new slice points to a new array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向切片添加的元素超出了其容量，运行时会分配一个更大的数组，并将切片的内容复制到那里。之后，新的切片指向一个新的数组。
- en: This is a source of confusion for many. A slice may share its elements with
    other slices. Thus, modifying one slice may modify others as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这对许多人来说是一个混淆的来源。切片可能与其他切片共享其元素。因此，修改一个切片也可能修改其他切片。
- en: '*Figure 4**.2* illustrates a case where the same underlying array is used for
    four different slices:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 展示了一个使用相同基础数组为四个不同切片的情况：'
- en: '![Figure 4.2 – Slices sharing the same underlying array](img/B21961_04_2.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 共享相同基础数组的切片](img/B21961_04_2.jpg)'
- en: Figure 4.2 – Slices sharing the same underlying array
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 共享相同基础数组的切片
- en: 'See the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that appending to `newSlice` also modified an element of `slice`, because
    `newSlice` has enough capacity to accommodate one more element, which overwrites
    `slice[4]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，向 `newSlice` 添加元素也会修改 `slice` 的一个元素，因为 `newSlice` 有足够的容量来容纳一个额外的元素，这会覆盖 `slice[4]`。
- en: 'Truncating a slice is simply creating a new slice that is shorter than the
    original. The underlying array does not change. See the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 截断切片只是创建一个比原始切片更短的新的切片。基础数组不会改变。请看以下：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, `newSlice` is simply a data structure containing the same `ptr` and
    `cap` as `slice`, with a shorter `len`. Because of this, creating a new slice
    from an existing slice or an array is a constant-time operation (O(1)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`newSlice` 只是一个包含相同 `ptr` 和 `cap` 的数据结构，但 `len` 较短。正因为如此，从现有切片或数组创建新切片是一个常数时间操作（O(1)）。
- en: Implementing a stack using a slice
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用切片实现栈
- en: A surprisingly common use of a slice is to implement a stack. Here is how it
    is done.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切片的一个令人惊讶的常见用途是实现栈。以下是实现方式。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'A stack push is simply `append`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 栈的推送操作简单就是 `append`：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To implement `pop`, truncate the slice:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `pop`，截断切片：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, note the use of parentheses and indirections. We cannot write `*s[len(*s)-1]`,
    because that is interpreted as `*(s[len(*s)-1]`. To prevent that, we have `(*s)`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意括号和间接引用的使用。我们不能写 `*s[len(*s)-1]`，因为这被解释为 `*(s[len(*s)-1])`。为了防止这种情况，我们使用
    `(*s)`。
- en: Working with maps
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与映射一起工作
- en: You access the elements of an array or a slice using integer indexes. Maps provide
    a similar syntax to use index keys that are not only integers but also any type
    that is “comparable” (which means it can be compared using `==` or `!=`.) A map
    is an associative data type – that is, it stores key-value pairs. Each key appears
    once in a map. A Go map provides amortized constant-time access to its elements
    (that is, when measured over time, map element access should look like a constant-time
    operation.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用整数索引访问数组或切片的元素。映射提供类似的语法来使用索引键，这些键不仅限于整数，还可以是任何“可比较”的类型（这意味着可以使用 `==` 或
    `!=` 进行比较。）映射是一种关联数据类型——也就是说，它存储键值对。映射中每个键只出现一次。Go 映射为其元素提供平均常数时间的访问（也就是说，当从时间角度测量时，映射元素访问应该看起来像是一个常数时间操作。）
- en: The Go `map` type provides convenient access to an underlying complicated data
    structure. It is one of the “reference” types – that is, assigning a map variable
    to another map simply assigns a pointer to the underlying structure and does not
    copy the elements of the map.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `map` 类型提供了对底层复杂数据结构的方便访问。它是一种“引用”类型——也就是说，将映射变量赋值给另一个映射只是分配了对底层结构的指针，并不会复制映射的元素。
- en: Warning
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: A map is an unordered collection. Do not rely on the ordering of elements in
    a map. The same order of insertion may result in different iteration orders in
    the same program at a different time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是无序集合。不要依赖于映射中元素的顺序。相同的插入顺序可能在不同的程序中不同时间导致不同的迭代顺序。
- en: Defining, initializing, and using maps
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义、初始化和使用映射
- en: Similar to a slice, the zero-value for a map is nil. Reading from a nil map
    will have the same result as reading from a non-nil map that has no elements.
    Writing to a nil map will panic. This section shows different ways a map can be
    initialized and used.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，映射的零值是 nil。从 nil 映射读取的结果与从没有元素的 non-nil 映射读取的结果相同。向 nil 映射写入将引发 panic。本节展示了初始化和使用映射的不同方式。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use `make` to create a new map, or use a literal. You cannot write to a nil
    map (but you can read from it!), so you must initialize all maps either with `make`,
    or by using a literal:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `make` 创建一个新的映射，或使用字面量。您不能向 nil 映射写入（但可以从中读取！），因此您必须使用 `make` 或字面量初始化所有映射：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Unlike a slice, map values are not **addressable**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片不同，映射的值不是 **可寻址的**：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous example, you cannot set a member variable of a struct stored
    in a map. When you access that map element with `usersByID[1]`, what you get back
    is a copy of `User` stored in the map, and the effect of setting its `Name` to
    something else will be lost, as that copy is not stored anywhere.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，您不能设置存储在映射中的结构体的成员变量。当您使用 `usersByID[1]` 访问该映射元素时，您得到的是映射中存储的 `User`
    的副本，将它的 `Name` 设置为其他值的效果将会丢失，因为这个副本没有存储在任何地方。
- en: 'So, instead, you can read and assign the map value to an addressable variable,
    change it, and set it back:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，相反，您可以读取并将映射值赋给可寻址的变量，更改它，并将其设置回：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Alternatively, you can store pointers in the map:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在映射中存储指针：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If the map does not have an element for the given key, it will return the zero-value
    for the map value type:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果映射没有给定键的元素，它将返回映射值类型的零值：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To distinguish whether the zero-value is returned because the map doesn’t have
    the element from the situation where the zero-value is stored in the map, use
    the two-return value version of map lookup:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分零值是返回因为映射没有元素，还是因为零值存储在映射中，请使用映射查找的两个值版本：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use `delete` to delete an element from a map:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `delete` 从映射中删除一个元素：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implementing a set using a map
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用映射实现集合
- en: A set is useful to remove duplicates from a collection of values. Maps can be
    used as sets efficiently by utilizing a zero-size value structure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 集合用于从值集合中删除重复项。通过利用零大小值结构，映射可以有效地用作集合。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use a map whose key type is the element type of the set, and whose value type
    is `struct{}`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键类型为集合元素类型，值类型为 `struct{}` 的映射：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add values to the set with the `struct{}{}` value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `struct{}{}` 值向集合中添加值：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Check for value existence using the two-value version of map lookup:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用映射查找的两个值版本检查值的存在：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A map is not ordered. If the ordering of elements is important, keep a slice
    with the map:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是无序的。如果元素的排序很重要，请保留一个与映射一起的切片：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `struct{}` structure is a zero-sized object. Such objects are handled separately
    by the compiler and the runtime. When used as a value in a map, the map will only
    allocate storage for its keys. So, it is an efficient way to implement sets.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct{}` 结构体是一个零大小对象。这样的对象由编译器和运行时分别处理。当用作映射中的值时，映射只为它的键分配存储空间。因此，这是一种实现集合的高效方式。'
- en: Warning
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Never rely on pointer equivalence for zero-sized structures. The compiler may
    choose to place two separate variables that have zero-size to the same memory
    location.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从不依赖于零大小结构的指针等价性。编译器可能会选择将两个具有零大小的不同变量放置在相同的内存位置。
- en: 'The result of the following comparison is not defined:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下比较的结果是未定义的：
- en: '`x:=&struct{}{}`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:=&struct{}{}`'
- en: '`y:=&struct{}{}`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`y:=&struct{}{}`'
- en: '`if` `x==y {`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`if x==y {`'
- en: '`//` `Do something`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`//` `执行某些操作`'
- en: '`}`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: The result of `x==y` may return `true` or `false`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`x==y` 的结果可能返回 `true` 或 `false`。'
- en: Composite keys
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合键
- en: You need composite keys when you have multiple values that identify a particular
    object. For example, say you are dealing with a system where users may have multiple
    sessions. You can store this information in a map of maps, or you can create a
    composite key containing the user ID and session ID.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个值用于标识特定对象时，您需要复合键。例如，假设您正在处理一个系统，其中用户可能有多个会话。您可以将这些信息存储在映射的映射中，或者创建一个包含用户
    ID 和会话 ID 的复合键。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use a comparable struct or an array as the map key. A comparable struct is,
    in general, a struct that does *not* contain the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可比较的结构体或数组作为映射键。一般来说，可比较的结构体是一个不包含以下内容的结构体：
- en: Slices
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片
- en: Channels
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道
- en: Functions
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Maps
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Other non-comparable structs
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他不可比较的结构体
- en: 'So, to use composite keys, perform the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使用复合键，请执行以下步骤：
- en: 'Define a comparable struct:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个可比较的结构体：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use an instance of the map key to access elements:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用映射键的实例来访问元素：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can use a literal map to initialize it:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用一个字面量映射来初始化它：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The map implementation generates hash values from its keys and then uses comparison
    operators to check for equivalence. Because of this, any data structure that is
    comparable can be used as a key value.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 映射实现从其键生成哈希值，然后使用比较运算符来检查等价性。因此，任何可比较的数据结构都可以用作键值。
- en: 'Be careful about pointer comparisons. A struct containing a pointer field will
    check for the equivalence of the pointer. Consider the following key:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意指针比较。包含指针字段的struct将检查指针的等价性。考虑以下键：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the previous code snippet, the composite map key contains a pointer to `session`,
    an integer. After you add an element to the map, changing the value of `session`
    will not affect the keys of the map pointing to that variable. The map key will
    still be pointing to the same variable. Another instance of `KeyWithPointer` can
    be used to locate the `User` object only if it is also pointing to the same `session`
    variable, as per the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，复合映射键包含对 `session` 的指针和一个整数。在你将元素添加到映射后，更改 `session` 的值不会影响指向该变量的映射键。映射键仍然指向相同的变量。只有当
    `KeyWithPointer` 的另一个实例也指向相同的 `session` 变量时，才能使用以下方式定位 `User` 对象：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Thread-safe caching with maps
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用映射的线程安全缓存
- en: Caching is sometimes necessary to attain an acceptable performance. The idea
    is to reuse values that have been computed or retrieved before. A map is a natural
    choice for caching such values but, due to their nature, caches are usually shared
    among multiple goroutines and you must be careful when using them.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时为了达到可接受的性能，缓存是必要的。想法是重用之前计算或检索的值。映射是缓存此类值的自然选择，但由于其本质，缓存通常在多个goroutine之间共享，因此在使用它们时必须小心。
- en: Simple cache
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单缓存
- en: This is a simple cache with a `get/put` method to retrieve objects from the
    cache and put elements into it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的缓存，具有 `get/put` 方法，用于从缓存中检索对象并将其放入其中。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To cache values that are accessible with a key, use a structure with a map
    and mutex:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要缓存可以通过键访问的值，请使用包含映射和互斥锁的结构：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Direct access to cache internals should be prevented to ensure the proper protocol
    is observed whenever the cache is used:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应防止直接访问缓存内部，以确保在每次使用缓存时都遵守适当的协议：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Cache with blocking behavior
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有阻塞行为的缓存
- en: If multiple goroutines ask for the same key from the simple cache in the previous
    example, they may all decide to retrieve the object and put it back into the cache.
    That is inefficient. Usually, you would want one of those goroutines to retrieve
    the object while the other waits. This can be done using `sync.Once`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个goroutine从前面示例中的简单缓存请求相同的键，它们都可能决定检索对象并将其放回缓存。这是低效的。通常，你希望其中一个goroutine检索对象，而其他goroutine等待。这可以通过使用
    `sync.Once` 来实现。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Cache elements are structures containing `sync.Once` to ensure one goroutine
    gets the object while others wait for it. Also, the cache contains a `Get` method
    that uses a `getObjectFunc` callback to retrieve an object if it is not in the
    cache:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存元素是包含 `sync.Once` 的结构，以确保一个goroutine获取对象，而其他goroutine等待它。此外，缓存包含一个 `Get` 方法，该方法使用
    `getObjectFunc` 回调函数来检索对象，如果它不在缓存中：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Get` method starts by read-locking the cache. Then it checks whether the
    key exists in the cache and unlocks it. If the value is cached, it is returned.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` 方法首先读取锁定缓存。然后它检查键是否存在于缓存中，并解锁它。如果值已缓存，则返回。'
- en: If the value is not in the cache, then the cache is write-locked, because this
    will be a concurrent modification to the `values` map. The `values` map is checked
    again to make sure another goroutine did not already put a value there. If not,
    this goroutine puts an uninitialized `cacheItem` in the cache and unlocks it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果值不在缓存中，则缓存被写入锁定，因为这将是 `values` 映射的并发修改。再次检查 `values` 映射，以确保另一个goroutine尚未将其放入其中。如果没有，此goroutine将在缓存中放入一个未初始化的
    `cacheItem` 并解锁它。
- en: The `cacheItem` contains a `sync.Once`, which will allow only one goroutine
    to call `Once.Go` while others are blocked waiting for the winning call to complete.
    This is when the `getObjectFunc` callback is invoked from the `cacheItem.get`
    method. At this point, there is no chance for a memory race, because only one
    goroutine can be executing the `item.Do` function. The result of the function
    will be stored in the `cacheItem`, so it will not cause any problems with the
    users of the `values` map. In fact, note that while `getObjectFunc` is running,
    the cache is not locked. There can be many other goroutines reading and/or writing
    to the cache.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheItem` 包含一个 `sync.Once`，这允许只有一个 goroutine 在其他 goroutine 正在等待获胜调用完成时调用
    `Once.Go`。这就是从 `cacheItem.get` 方法调用 `getObjectFunc` 回调的时候。在这个时候，不可能发生内存竞争，因为只有一个
    goroutine 可以执行 `item.Do` 函数。函数的结果将被存储在 `cacheItem` 中，因此不会对 `values` 映射的使用者造成任何问题。实际上，请注意，当
    `getObjectFunc` 正在运行时，缓存没有被锁定。可以有多个其他 goroutine 读取和/或写入缓存。'
