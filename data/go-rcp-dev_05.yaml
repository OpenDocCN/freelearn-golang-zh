- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Types, Structs, and Interfaces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理类型、结构体和接口
- en: Go is a strongly typed language. That means every value in a program must be
    defined using a set of predefined basic types. The rules of the type system determine
    what can be done with those values, and how values of different types interact.
    The Go type system takes a simplistic approach; it only allows explicit conversions
    between values of different compatible types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种强类型语言。这意味着程序中的每个值都必须使用一组预定义的基本类型来定义。类型系统的规则决定了可以对这些值做什么，以及不同类型的值如何交互。Go
    的类型系统采用了一种简化的方法；它只允许在不同兼容类型的值之间进行显式转换。
- en: Go is also a statically typed language, which means that types of values are
    explicitly declared and checked at compile time, as opposed to being checked at
    runtime. This is different from scripting languages such as Python or JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还是一种静态类型语言，这意味着值的类型在编译时被显式声明和检查，而不是在运行时检查。这与 Python 或 JavaScript 这样的脚本语言不同。
- en: In this chapter, we will look at some of the properties of the Go type system,
    defining new types, structures, and interfaces, and considering how to make effective
    use of it to implement some common patterns.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Go 类型系统的一些属性，定义新类型、结构体和接口，并考虑如何有效地使用它来实现一些常见模式。
- en: 'This chapter contains the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Creating new types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新类型
- en: Using composition to extend types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组合来扩展类型
- en: Initializing structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化结构体
- en: Working with interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理接口
- en: Factory pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Polymorphic containers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态容器
- en: Creating new types
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新类型
- en: There are several reasons why you want to define new types. An important one
    is ensuring type safety. Type safety ensures that operations receive the correct
    type of data. A type-safe program is free of type errors, limiting possible errors
    in the program to logic errors only.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要定义新类型的原因有很多。其中之一是确保类型安全。类型安全确保操作接收正确的数据类型。类型安全的程序没有类型错误，将程序中的错误限制为仅逻辑错误。
- en: 'Other reasons for creating new types also include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新类型的其他原因还包括以下：
- en: You can share the methods and data fields of a type in multiple different types
    by *embedding* it.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过 *嵌入* 来在多个不同类型中共享类型的方法和数据字段。
- en: Later in this chapter, we will look at interfaces. You can define a set of methods
    for a new type to implement a given interface that lets you use that type in different
    contexts.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将探讨接口。您可以定义一组方法来实现给定的接口，以便在不同的上下文中使用该类型。
- en: Creating a new type based on an existing type
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于现有类型创建新类型
- en: Creating a new type allows you to enforce type-safety rules, and add type-specific
    methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新类型允许您强制执行类型安全规则，并添加类型特定的方法。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new type based on an existing type using the following syntax:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语法根据现有类型创建新类型：
- en: '`type <NewTypeName> <ExistingTypeName>`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`type <NewTypeName> <ExistingTypeName>`'
- en: 'For example, the following declaration defines a new data type, `Duration`,
    as an unsigned 64-bit integer:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下声明定义了一个新的数据类型 `Duration`，作为一个无符号 64 位整数：
- en: '`type Duration uint64`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`type Duration uint64`'
- en: This is how the Go standard library defines `time.Duration`. To call the `time.Sleep(d
    Duration)` function, you now have to use a `time.Duration` value, or explicitly
    convert a numeric value to a `time.Duration` value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Go 标准库定义 `time.Duration` 的方式。要调用 `time.Sleep(d Duration)` 函数，您现在必须使用 `time.Duration`
    值，或者显式地将数值值转换为 `time.Duration` 值。
- en: Warning
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When you create a new type from an existing type, the new type is created without
    any methods even if the existing type has methods defined.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从现有类型创建新类型时，即使现有类型已定义了方法，新类型也会创建而没有任何方法。
- en: Creating type-safe enumerations
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类型安全的枚举
- en: In this recipe, we will define a set of constants (an enumeration) with a new
    type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用新类型定义一组常量（枚举）。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Define a new type:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新类型：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a sequence of constants representing the values of the enumeration using
    the new type. You can use `iota` for numeric constants to generate increasing
    numbers:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新类型创建表示枚举值的常量序列。您可以使用 `iota` 为数值常量生成递增的数字：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the new type in functions or data elements expecting this new type:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在期望此新类型的函数或数据元素中使用新类型：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This does not prevent someone from calling `SetDirection(Direction(3))`, which
    is an invalid value. This is usually only a problem for enumerated values read
    from user input or from third-party sources. You should validate the input at
    that point.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不阻止某人调用 `SetDirection(Direction(3))`，这是一个无效的值。这通常只会在从用户输入或第三方来源读取枚举值时成为问题。你应该在那个点验证输入。
- en: Creating struct types
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建结构体类型
- en: A Go struct is a collection of fields. Define structs to group interrelated
    data fields to form a record. This recipe shows how to create new struct types
    in your program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Go 结构体是一系列字段的集合。定义结构体以将相关数据字段分组，形成一个记录。这个菜谱展示了如何在程序中创建新的结构体类型。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a struct type using the following syntax:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语法创建结构体类型：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For instance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Extending types
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类型
- en: Go uses type composition through embedding, and structural typing through the
    use of interfaces. Let’s start by examining what these mean.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go 通过嵌入使用类型组合，并通过使用接口实现结构化类型。让我们首先检查这些意味着什么。
- en: 'When you embed an existing type into another, the methods and data fields defined
    for the embedded type become the methods and data fields of the embedding type.
    If you have worked with object-oriented languages, this may seem similar to class
    inheritance, but there is a crucial difference: if a class `A` is derived from
    a class `B`, then `A` is-a `B`, meaning wherever `B` is needed, you can substitute
    an instance of `A`. With composition, if `A` embeds `B`, `A` and `B` are distinct
    types, and you cannot use `A` where `B` is needed.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个现有类型嵌入到另一个类型中时，为嵌入类型定义的方法和数据字段将成为嵌入类型的方法和数据字段。如果你使用过面向对象的语言，这可能会让你觉得类似于类继承，但有一个关键的区别：如果一个类
    `A` 从类 `B` 继承，那么 `A` 是 `B` 的一个实例，意味着在需要 `B` 的任何地方，你可以用一个 `A` 的实例来替换。在使用组合的情况下，如果
    `A` 嵌入了 `B`，那么 `A` 和 `B` 是不同的类型，你不能在需要 `B` 的地方使用 `A`。
- en: Tip
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'There is no type inheritance in Go. Go chooses composition over inheritance.
    The primary reason for this is the simplicity of combining components to build
    more complex ones. Most use cases of inheritance in object-oriented languages
    can be rearchitected using composition, interfaces, and structural typing. I used
    the word “*rearchitecting*” intentionally here: do *not* try to port existing
    object-oriented programs to Go by emulating inheritance. Instead, redesign and
    refactor them to be idiomatic Go programs using composition and interfaces.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中没有类型继承。Go 选择组合而不是继承。这样做的主要原因是为了简化组合组件以构建更复杂的组件。面向对象语言中继承的大多数用例都可以通过组合、接口和结构化类型重新设计。在这里我故意使用了“*rearchitecting*”这个词：不要试图通过模拟继承来将现有的面向对象程序移植到
    Go 中。相反，重新设计和重构它们，以使用组合和接口成为惯用的 Go 程序。
- en: The next recipes will look at how this can be done.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个菜谱将探讨如何实现这一点。
- en: Extending a base type
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展基类型
- en: First, we’ll look at how we can extend a base type to share its data elements
    and methods in new types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看我们如何扩展一个基类型，以便在新类型中共享其数据元素和方法。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s say you have some data fields and functionality shared between multiple
    data types. Then you can create a base data type, and embed it into multiple other
    data types to share common parts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些在多个数据类型之间共享的数据字段和功能。然后你可以创建一个基数据类型，并将其嵌入到多个其他数据类型中，以共享共同的部分：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code snippet, the fields and methods of each struct are as
    follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，每个结构体的字段和方法如下：
- en: '| **Type** | **Fields** | **Methods** |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **字段** | **方法** |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Common | commonField | CommonMethod |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Common | commonField | CommonMethod |'
- en: '| A | commonField, aField | CommonMethod, AMethod |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| A | commonField, aField | CommonMethod, AMethod |'
- en: '| B | commonField, bField | CommonMethod, BMethod |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| B | commonField, bField | CommonMethod, BMethod |'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have used struct embedding to share common data elements and functionality
    in the previous section. The following example shows two structs, `Customer` and
    `Product`, that share the same `Metadata` structure. `Metadata` contains the unique
    identifier, creation date, and modification date of a record:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了结构体嵌入来共享常见的数据元素和功能。以下示例展示了两个结构体，`Customer` 和 `Product`，它们共享相同的 `Metadata`
    结构体。`Metadata` 包含记录的唯一标识符、创建日期和修改日期：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Embedding is not inheritance*. The receiver of an embedded struct method is
    *not* a copy of the defined struct. In the preceding snippet, when we call `c.New()`,
    the `Metedata.New()` method gets a receiver that is an instance of `*Metadata`,
    not an instance of `*Customer`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌入不是继承*。嵌入结构体方法的接收者*不是*定义的结构体的副本。在上面的代码片段中，当我们调用 `c.New()` 时，`Metedata.New()`
    方法得到的接收者是一个 `*Metadata` 实例，而不是 `*Customer` 实例。'
- en: Initializing structs
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化结构体
- en: This recipe shows how you can use struct literals to initialize complex data
    structures containing embedded structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用结构字面量初始化包含嵌入结构的复杂数据结构。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Go guarantees that all declared variables are initialized to their zero values.
    This is not very useful if you have a complicated data structure that should be
    initialized with default values or non-nil pointer components. For such cases,
    use constructor-like functions to create a new instance of a struct. The established
    convention is to write a `NewX` function for a type `X` that initializes an instance
    of `X` or `*X` and returns it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Go 保证所有声明的变量都被初始化为其零值。如果你有一个复杂的数据结构，应该使用默认值或非空指针组件进行初始化，这并不很有用。在这种情况下，使用类似构造函数的函数来创建结构体的新实例。对于类型
    `X`，已建立的约定是编写一个 `NewX` 函数，该函数初始化 `X` 或 `*X` 的实例并返回它。
- en: 'Here, `NewIndex` creates a new initialized instance of the `Index` type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`NewIndex` 创建了一个初始化的 `Index` 类型的新实例：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Also, observe that the `Index.name` and `Index.index` fields are not exported.
    Thus, they can only be accessed using exported methods of `Index`. This pattern
    is useful for preventing unintentional modification of data fields.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`Index.name` 和 `Index.index` 字段没有导出。因此，它们只能通过 `Index` 的导出方法访问。这种模式对于防止意外修改数据字段很有用。
- en: Defining interfaces
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义接口
- en: Go uses “structural typing.” If a type `T` defines all the methods of an interface
    `I`, then `T` implements `I.` This causes some confusion among developers who
    are well-versed in languages that use nominative typing, such as Java, where you
    explicitly have to *name* the constituent types.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用“结构化类型”。如果一个类型 `T` 定义了一个接口 `I` 的所有方法，那么 `T` 就实现了 `I`。这导致了一些熟悉使用命名类型语言的开发者（如
    Java，其中你必须显式地*命名*组成类型）感到困惑。
- en: Go interfaces are simply method sets. When a data type defines a set of methods,
    it also automatically implements all interfaces that contain a subset of its methods.
    For instance, if data type `A` defines a `func (A) F()` method, then `A` also
    implements the `interface { func F() }` and `interface{}` interfaces. If interface
    `A` is a subset of interface `B`, then a data type implementing interface `B`
    can be used wherever `A` is needed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的接口仅仅是方法集。当一个数据类型定义了一组方法时，它也会自动实现包含其方法子集的所有接口。例如，如果数据类型 `A` 定义了一个 `func (A)
    F()` 方法，那么 `A` 也实现了 `interface { func F() }` 和 `interface{}` 接口。如果接口 `A` 是接口 `B`
    的子集，那么实现接口 `B` 的数据类型可以在需要 `A` 的任何地方使用。
- en: Interfaces as contracts
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口作为契约
- en: An interface can be used as a “specification,” or like a “contract” that defines
    certain functions an implementation should satisfy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以用作“规范”，或像“契约”一样定义实现应满足的某些函数。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Define an interface or a set of interfaces to specify the expected behavior
    of an object. This is suitable when multiple different implementations of the
    same interface are expected. For instance, the standard library `database/driver`
    SQL driver package defines a set of interfaces that should be implemented by different
    database drivers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个接口或一组接口以指定对象的预期行为。当预期有多个不同接口的实现时，这很合适。例如，标准库 `database/driver` SQL 驱动程序包定义了一组接口，这些接口应由不同的数据库驱动程序实现。
- en: 'For example, the following code snippet defines a storage backend for storing
    files:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段定义了一个用于存储文件的存储后端：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use the instances of objects that implement the `Storage` interface
    to store data in different backends, such as a filesystem or some network storage
    system.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用实现 `Storage` 接口的对象的实例在不同的后端存储数据，例如文件系统或某些网络存储系统。
- en: 'In many cases, the data types used to declare the methods of such an interface
    are themselves dependent on the actual implementation. In that case, a system
    of interfaces is necessary. The standard library `database/driver` package uses
    this approach. As an example, consider the following authentication provider interface:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，用于声明接口方法的类型本身依赖于实际的实现。在这种情况下，需要一个接口系统。标准库 `database/driver` 包使用这种方法。例如，考虑以下认证提供者接口：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Factories
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂
- en: This section shows a recipe that is often used to support extendible structures,
    such as database drivers, where importing a particular database driver package
    automatically “registers” the driver to a factory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了常用于支持可扩展结构（如数据库驱动程序）的配方，其中导入特定的数据库驱动程序包会自动将驱动程序“注册”到工厂中。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Define an interface, or set of interfaces specifying how an implementation should
    behave.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个接口，或一组接口，指定实现应该如何行为。
- en: Create a registry (a map), and a function to register implementations.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个注册表（映射）和一个用于注册实现的函数。
- en: Every different implementation registers itself with the registry using `init()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个不同的实现都会使用 `init()` 函数将自己注册到注册表中。
- en: Import the implementations that will be included in the program using the `main`
    package.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `main` 包导入将包含在程序中的实现。
- en: Let’s implement an authentication framework using the `Authenticator` example
    from the last section. We will allow different implementations of the `Authenticator`
    framework.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一节中的 `Authenticator` 示例来实现一个认证框架。我们将允许 `Authenticator` 框架的不同实现。
- en: 'First, define a factory interface and a map to keep all registered implementations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个工厂接口和一个用于存储所有已注册实现的映射：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, declare an exported `Register` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明一个导出的 `Register` 函数：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To dynamically create instances of authenticator, we’ll need a function that
    looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动态创建认证器的实例，我们需要一个类似这样的函数：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implementations can register their own factories using the `init()` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以使用 `init()` 函数注册它们自己的工厂：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you have to stitch this together. The Go build system will only include
    packages that have been directly or indirectly used by the code accessible from
    `main()`, and the implementations are not directly referenced. We have to make
    sure those packages are imported, and thus, the implementations are registered.
    So, import them in `main`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须将这些部分拼接在一起。Go 的构建系统只会包含那些被从 `main()` 可访问的代码直接或间接使用过的包，并且实现不会被直接引用。我们必须确保这些包被导入，因此，实现被注册。所以，在
    `main` 中导入它们：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding `import` will include the implementation package in the program.
    Since the package is included in the program, its `init()` function will be called
    during program initialization, and the authenticator type it provides will be
    registered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `import` 语句将包含实现包到程序中。由于该包被包含在程序中，其 `init()` 函数将在程序初始化期间被调用，并且它提供的认证器类型将被注册。
- en: Defining interfaces where you use them
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在使用它们的地方定义接口
- en: Structural typing allows you to define an interface when you need to use one,
    as opposed to pre-defining an exported interface. This is sometimes confused with
    “duck-typing” (if something walks like a duck and talks like a duck, it is a duck).
    The difference is that duck-typing refers to determining data type compatibility
    by looking at the subset of a type’s structure at runtimes, whereas structural
    typing refers to looking at the structure of a type at compile time. This recipe
    shows how you can define interfaces as you need them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型允许你在需要使用接口时定义它，而不是预先定义导出的接口。这有时会与“鸭子类型”（如果某物像鸭子走路，像鸭子说话，那么它就是鸭子）混淆。区别在于，鸭子类型是通过在运行时查看类型的结构子集来确定数据类型兼容性的，而结构化类型是指在编译时查看类型的结构。这个配方展示了你可以如何按需定义接口。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let’s say you have code that looks like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一段如下所示的代码：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to write a function that will operate on the options of a variable
    of type `A` or `B` (or any type that has options), you can simply define an interface
    right there:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编写一个将操作类型 `A` 或 `B`（或任何具有选项的类型）的变量的选项的函数，你可以在那里简单地定义一个接口：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Remember, Go uses structural typing. So, you can create an interface specifying
    a set of methods, and any data type declaring those methods will automatically
    implement that interface. Thus, you can create such interfaces ad hoc, and write
    functions that take instances of those interfaces to work with a potentially large
    number of data types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Go使用结构化类型。因此，你可以创建一个指定了一组方法的接口，任何声明了这些方法的类型将自动实现该接口。因此，你可以随意创建这样的接口，并编写接受这些接口实例的函数来处理可能的大量数据类型。
- en: If you used a nominative language, you would have had to specify that those
    types implement your interface. Not so in Go.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是命名语言，你将不得不指定那些类型实现了你的接口。但在Go中并非如此。
- en: That also means that if you have an interface `A` and another interface `B`
    such that `A` declares the same methods as `B`, then any type that implements
    `A` also implements `B`. In other words, if you cannot import an interface because
    it is in a package that will cause a circular dependency if imported, or if that
    interface is not exported by that package, you can simply define an equivalent
    interface in your current package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，如果你有一个接口`A`和另一个接口`B`，其中`A`声明了与`B`相同的方法，那么任何实现了`A`的类型也实现了`B`。换句话说，如果你不能导入一个接口，因为它在一个如果导入将导致循环依赖的包中，或者如果该接口没有由该包导出，你可以在当前包中简单地定义一个等效的接口。
- en: Using a function as an interface
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数作为接口
- en: Sometimes, you might encounter a situation where you have a function when an
    interface is needed. This recipe shows how you can define a new function data
    type that also implements an interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到需要接口时却有一个函数的情况。这个示例展示了如何定义一个新的函数数据类型，它同时也实现了接口。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'If you need to implement a single-method interface without any data elements,
    you can define a new type based on an empty struct and declare a method for that
    type to implement that interface. Alternatively, you can simply use the function
    itself as an implementation of that interface. The following excerpt is from the
    standard library `net/http` package:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要实现一个没有数据元素的单一方法接口，你可以基于一个空结构体定义一个新的类型，并为该类型声明一个方法以实现该接口。或者，你也可以简单地使用该函数本身作为该接口的实现。以下摘录来自标准库`net/http`包：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you can use functions of the `HandlerFunc` type whenever an implementation
    of the `Handler` interface is needed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以在需要`Handler`接口实现的地方使用`HandlerFunc`类型的函数。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Go type system treats function types as any other defined type. Thus, you
    can declare methods for a function type. When you declare methods for a function
    type, the function type automatically implements all the interfaces that define
    all or some of those methods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Go的类型系统将函数类型视为任何其他定义的类型。因此，你可以为函数类型声明方法。当你为函数类型声明方法时，该函数类型将自动实现定义了所有或部分这些方法的接口。
- en: 'Let’s examine this statement with an example. We can declare a new empty type
    as an implementation of the `Handler` interface:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来检查这个声明。我们可以声明一个新的空类型作为`Handler`接口的实现：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With this declaration, you can use instances of `MyHandler` wherever a `Handler`
    is required. However, observe that `MyHandler` has no data elements and only one
    method. So instead, we define a function type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个声明，你可以在需要`Handler`的地方使用`MyHandler`的实例。然而，请注意`MyHandler`没有数据元素，只有一个方法。因此，我们定义了一个函数类型：
- en: '`type MyHandler func(ResponseWriter,*Request)`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`type MyHandler func(ResponseWriter,*Request)`'
- en: Now `MyHandler` is a new named type. This is not that much different from declaring
    `MyHandler` as a struct, but in this case, `MyHandler` is a function with a fixed
    signature.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`MyHandler`是一个新的命名类型。这并不比将`MyHandler`声明为结构体有太大的不同，但在这个情况下，`MyHandler`是一个具有固定签名的函数。
- en: 'Since `MyHandler` is a named type, we can define methods for it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MyHandler`是一个命名类型，我们可以为它定义方法：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since `MyHandler` now defined `ServeHTTP` method, it implements the `Handler`
    interface. However, `MyHandler` is a function type, so `h` is actually a function
    that has the same signature as `ServeHTTP`. Due to that, the `h(w,r)` call works,
    and `MyHandler` can be used in places where a `Handler` is required.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`MyHandler`现在定义了`ServeHTTP`方法，它实现了`Handler`接口。然而，`MyHandler`是一个函数类型，所以`h`实际上是一个具有与`ServeHTTP`相同签名的函数。正因为如此，`h(w,r)`调用才有效，`MyHandler`可以在需要`Handler`的地方使用。
- en: Discovering capabilities of data types at runtime – testing "implements" relationship
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时发现数据类型的特性——测试"实现"关系
- en: An interface provides a way to call the methods of an underlying data object.
    If the same interface is implemented by many different types, you can use a function
    to manipulate diverse data types by simply using their common interface. However,
    many times, you need to access the underlying object stored in an interface. Go
    provides several mechanisms to achieve that. We will look at `type-assertion`
    and `type-switch`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接口提供了一种调用底层数据对象的方法。如果许多不同的类型实现了相同的接口，你可以通过使用它们的公共接口来简单地使用一个函数来操作不同的数据类型。然而，很多时候，你需要访问接口中存储的底层对象。Go提供了几种机制来实现这一点。我们将探讨`type-assertion`和`type-switch`。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use interfaces and type assertions to discover different methods a type provides.
    Remember that an interface is a method set. A type that implements the methods
    given in an interface automatically implements that interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口和类型断言来发现一个类型提供的方法。记住，接口是一组方法。实现接口中给定方法的类型自动实现该接口。
- en: 'Use the following patterns to determine whether a data type has a method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下模式来确定数据类型是否有方法：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Type assertions have two forms. The following form tests if an `intf` interface
    variable contains a concrete value of the `concreteValue` type:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言有两种形式。以下形式测试`intf`接口变量是否包含`concreteValue`类型的具体值：
- en: '`value, ok:=intf.(concreteValue)`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`value, ok:=intf.(concreteValue)`'
- en: If the interface contains a value of that type, then `value` now has that value,
    and `ok` becomes `true`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接口包含该类型的值，那么`value`现在具有该值，并且`ok`变为`true`。
- en: 'The second form tests whether the concrete value contained within the `intf`
    interface also implements the `otherIntf` interface:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式测试`intf`接口中包含的具体值是否也实现了`otherIntf`接口：
- en: '`value, ok:=intf.(otherIntf)`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`value, ok:=intf.(otherIntf)`'
- en: If the value contained in `intf` also has the methods declared by `otherIntf`,
    then `value` is now an interface value of the `otherIntf` type containing the
    same concrete value as `intf`, and `ok` is set to `true`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`intf`中包含的值也具有`otherIntf`声明的那些方法，那么`value`现在是一个包含与`intf`相同具体值的`otherIntf`类型接口值，并且`ok`设置为`true`。
- en: Using this second form, you can test whether an interface variable implements
    the methods you need.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种第二种形式，你可以测试接口变量是否实现了你需要的那些方法。
- en: You may think you can do the same thing using reflection. Reflection is a method
    for discovering the names of fields and methods of types at runtime. It is not
    a performant or easy method to check such type equivalences.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为你可以使用反射来做同样的事情。反射是在运行时发现类型字段和方法名称的方法。这不是一个高效或简单的方法来检查这种类型等价性。
- en: Testing whether an interface value is one of the known types
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试接口值是否是已知类型之一
- en: A type-switch is used to test whether an interface value is a known concrete
    type, or whether it implements a certain interface. This recipe shows how it can
    be used.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 类型切换用于测试接口值是否是已知的具体类型，或者是否实现了某个接口。这个示例展示了如何使用它。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use a type-switch instead of a sequence of type assertions if you need to check
    an interface against multiple types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要检查接口与多个类型，请使用类型切换而不是一系列类型断言。
- en: 'The following example uses an `interface{}` to add two values. The values can
    either both be `int`, or both `float64`. The function also provides a way to override
    the addition behavior: if the value has a compatible `Add` method, it calls that
    instead:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`interface{}`来添加两个值。这两个值可以是`int`，也可以是`float64`。该函数还提供了一种覆盖加法行为的方法：如果值有一个兼容的`Add`方法，它将调用该方法：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the way the type switch is used to extract the value contained in the interface
    if the case matches. This only works if the case lists a single type, and if the
    case is not the `default` case. For those cases, the variable is simply not defined
    and you work with the interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意类型切换的使用方式，如果匹配，则提取接口中包含的值。这仅在情况列表只有一个类型，并且情况不是`default`情况时才有效。对于这些情况，变量简单地未定义，你只需与接口一起工作。
- en: Ensuring a type implements an interface during development
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发过程中确保类型实现接口
- en: During the development stages of a project, interface types may change quickly
    by adding new methods, or modifying existing method signatures by changing argument
    types or return types. How can developers make sure certain implementations of
    those interfaces are not broken by those changes?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的开发阶段，接口类型可能会快速变化，通过添加新方法，或者通过更改参数类型或返回类型来修改现有方法签名。开发者如何确保那些接口的实现不会被这些更改破坏？
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s say your team defined the following interface:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的团队定义了以下接口：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll also say that you implemented that interface with the following struct:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设你使用以下结构体实现了该接口：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, later in the development, it turned out not all cars can move successfully,
    so the signature of the interface changes to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开发后期，结果发现并非所有汽车都能成功移动，因此接口的签名更改为以下：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this change, `RaceCar` no longer implements `Car`. Many times this error
    will be caught at compile time, but not always. For instance, if instances of
    `*RaceCar` are passed to functions that require `any`, the compilation will succeed,
    but a runtime panic will be raised if that argument is converted to a `Car` or
    `*RaceCar` via type assertion:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改后，`RaceCar`不再实现`Car`。很多时候这个错误会在编译时被发现，但并不总是如此。例如，如果`*RaceCar`的实例被传递到需要`any`的函数中，编译将成功，但如果通过类型断言将该参数转换为`Car`或`*RaceCar`，将会引发运行时恐慌：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s say that you declare the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你声明了以下：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Any modification to the `Car` interface that makes `*RaceCar` no longer implement
    the `Car` interface will be a compile error.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Car`接口的任何修改，如果导致`*RaceCar`不再实现`Car`接口，将会导致编译错误。
- en: 'So, in general: declare a blank variable with the interface type, and assign
    it to the concrete type:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，一般来说：声明一个接口类型的空变量，并将其分配给具体类型：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If there are changes that cause the type to no longer implement that interface,
    a compile error will be raised.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更改导致类型不再实现该接口，将会引发编译错误。
- en: Deciding whether to use a pointer receiver or value receiver for methods
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定是否为方法使用指针接收者或值接收者
- en: In this recipe, we’ll explore how to choose between a pointer receiver and a
    value receiver for methods.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何选择方法使用指针接收者还是值接收者。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In general, use one kind, not both. There are two reasons for this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用一种类型，而不是两种。这样做有两个原因：
- en: Consistency throughout the code.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的一致性。
- en: Mixing value and pointer receivers can result in data races.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合值接收者和指针接收者可能导致数据竞争。
- en: If a method modifies the receiver object, use a pointer receiver. If a method
    does not modify the receiver object, or if the method relies on getting a copy
    of the receiver object, you can use a value receiver.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法修改接收者对象，请使用指针接收者。如果方法不修改接收者对象，或者如果方法依赖于获取接收者对象的副本，你可以使用值接收者。
- en: If you are implementing an immutable type, in most cases, you should use a value
    receiver.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个不可变类型，在大多数情况下，你应该使用值接收者。
- en: If your structures are large, using a pointer receiver will reduce copy overhead.
    You can find different guidelines on whether or not a structure can be considered
    large. When in doubt, write a benchmark and measure.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的结构体很大，使用指针接收者可以减少复制开销。你可以找到不同的指南来判断一个结构体是否可以被认为是大的。如果有疑问，编写基准测试并测量。
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For a type `T`, if you declare a method using a value receiver, that method
    is declared for both `T` and `*T`. The method gets a copy of the receiver, not
    a pointer to it, so any modifications performed on the receiver will not be reflected
    to the object used for calling the method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型`T`，如果你使用值接收者声明了一个方法，那么这个方法既适用于`T`也适用于`*T`。该方法获取接收者的副本，而不是指向它的指针，因此对接收者进行的任何修改都不会反映到调用该方法使用的对象上。
- en: 'For example, the following method returns a copy of the original object while
    modifying one field:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下方法在修改一个字段的同时返回原始对象的副本：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A value receiver creates a shallow copy of the original. If the receiver struct
    has maps, slices, or pointers to other objects, only the map headers, slice headers,
    or pointers will be copied, not the contents of the pointed object. That means
    that even though the method gets a value receiver in the following example, changes
    to the map are reflected in both the original and the copy:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 值接收者会创建原始值的浅拷贝。如果接收者结构体包含映射、切片或其他对象的指针，则只会复制映射头、切片头或指针，而不会复制指向的对象内容。这意味着，即使在以下示例中方法获取了一个值接收者，对映射的更改也会反映在原始值和副本中：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Be careful about how this affects slice operations. A slice is a triple `(pointer,
    len, cap)`, and that is what’s copied when you pass a value receiver:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这如何影响切片操作。切片是一个三元组`(pointer, len, cap)`，当你传递值接收者时，这是被复制的：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A pointer receiver is more straightforward to work with. The method always
    gets a pointer to the object it is called with. In the preceding example, declaring
    the `add` method with a pointer receiver behaves as expected:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 指针接收器更容易处理。方法总是获取它被调用的对象的指针。在先前的例子中，使用指针接收器声明`add`方法的行为符合预期：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At the beginning of this section, I also mentioned that mixing pointer and value
    receivers causes a data race. Here is how it happens.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开始，我也提到了混合指针和值接收器会导致数据竞争。以下是它发生的方式。
- en: 'Remember that a data race happens when a goroutine reads from a variable that
    is being concurrently modified by another. Consider the following example where
    the `Version` method uses a value receiver that causes a copy of `T` to be created:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当goroutine从另一个goroutine正在并发修改的变量中读取时，就会发生数据竞争。考虑以下示例，其中`Version`方法使用值接收器，这会导致创建`T`的一个副本：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The act of calling `t.Version()` creates a copy of the variable `t`, reading
    `t.X` concurrently as it is being modified, hence causing a race. This race is
    more obvious if `t.Version` reads from `t.X` explicitly. There is no guarantee
    that that read operation will see the effects of the write operation in the goroutine.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`t.Version()`的行为会创建变量`t`的一个副本，在它被修改的同时并发读取`t.X`，因此导致竞争。如果`t.Version`明确地从`t.X`读取，这种竞争会更明显。没有保证该读取操作将看到goroutine中的写入操作的效果。
- en: Polymorphic containers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态容器
- en: In this context, a container is a data structure that holds many objects. The
    principles of this section can be applied to single objects as well. In other
    words, you can use the same idea when you have a single polymorphic variable or
    a struct field.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，容器是一个包含许多对象的数据结构。本节的原则也可以应用于单个对象。换句话说，当你有一个单例多态变量或结构体字段时，你可以使用相同的思想。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Define an interface containing the methods common to all data types that will
    be stored in the container.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含所有将存储在容器中的数据类型共有方法的接口。
- en: Declare the container type using that interface.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该接口声明容器类型。
- en: Put instances of actual objects into the container.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实际对象的实例放入容器中。
- en: When you retrieve objects from the container, you can either work with the object
    through the interface, or type-assert, get the actual type or another interface,
    and work with that.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从容器中检索对象时，你可以通过接口与对象一起工作，或者进行类型断言，获取实际类型或另一个接口，并使用它。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here’s a simple example that works with `Shape` objects. A `Shape` object is
    something that can be drawn on an image, and moved around:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，它适用于`Shape`对象。`Shape`对象是可以在图像上绘制并移动的东西：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Shape has several implementations:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`有几个实现：'
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Both `*Rectangle` and `*Circle` implement the `Shape` interface (note that
    `Rectangle` and `Circle` do not.) Now we can work with a slice of `Shapes`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`*Rectangle`和`*Circle`都实现了`Shape`接口（注意`Rectangle`和`Circle`没有实现）。现在我们可以处理一个`Shapes`的切片：'
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is what the `shapes` slice looks like:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`shapes`切片的样子：
- en: '![Figure 5.1 – Slice of interface variables](img/B21961_05_1.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 接口变量的切片](img/B21961_05_1.jpg)'
- en: Figure 5.1 – Slice of interface variables
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 接口变量的切片
- en: 'Since every interface contains a pointer to the actual shape, it is possible
    to use the interface to call methods that modify the object as well:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个接口都包含对实际形状的指针，因此可以使用该接口调用修改对象的方法：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Accessing parts of an object not directly exposed via the interface
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过接口未直接暴露的对象部分
- en: When working with interfaces, there are many occasions where you need to access
    the underlying object. This is achieved by type-assertion, that is, testing whether
    the value of an interface satisfies a given type, and if so, retrieving it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理接口时，有许多场合需要访问底层对象。这是通过类型断言实现的，即测试接口值的类型是否满足给定的类型，如果是，则检索它。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use type assertion or a type switch to test the type of the object contained
    in an interface:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型断言或类型选择来测试接口中包含的对象的类型：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Accessing the embedding struct from the embedded struct
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从嵌入的结构体访问嵌入的结构体
- en: In object-oriented languages such as Java or C++, there is the concept of an
    abstract method or virtual method, together with type inheritance. One effect
    of this feature is that if you call a method `M` of a base class `base`, then
    the method that runs at runtime is the implementation of `M` that is declared
    for the actual object at runtime. In other words, you can invoke a method that
    will be overridden by other declarations, and you just don’t know which method
    you are actually calling.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Java或C++这样的面向对象语言中，有抽象方法或虚方法的概念，以及类型继承。这个特性的一个效果是，如果你调用基类`base`的`M`方法，那么在运行时执行的是为运行时实际对象声明的`M`的实现。换句话说，你可以调用将被其他声明覆盖的方法，但你并不知道你实际上调用的是哪个方法。
- en: There are ways of doing the same thing in Go. This recipe shows how.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，有几种做同样事情的方法。这个示例展示了如何做。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s say you need to write a circular linked list data structure whose elements
    will be structs embedding a base struct:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要编写一个循环链表数据结构，其元素将包含一个基结构体的结构体：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The list itself is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表本身如下所示：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, the list points to the `first` node, which is an arbitrary node in the list,
    and every node points to the next one, with the last node pointing back to the
    first.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，列表指向`first`节点，这是一个列表中的任意节点，每个节点都指向下一个节点，最后一个节点指向第一个节点。
- en: 'We need a `Node` interface that defines the mechanics of maintaining a list.
    Of course, the `Node` interface will be implemented by `ListNodeHeader`, and thus,
    by all the nodes of the list:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个定义维护列表机制的`Node`接口。当然，`Node`接口将由`ListNodeHeader`实现，因此，由列表的所有节点实现：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The users of the list are supposed to embed `ListHeader` to implement a `list`
    node:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的用户应该嵌入`ListHeader`以实现一个`list`节点：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now the hard part is to implement the `Node` interface. Let’s assume you would
    like to insert a `ByteSliceElement` in this list. Since `ByteSliceElement` embeds
    `ListNodeHeader`, it has all its methods and thus implements `Node`. However,
    we can’t write, for instance, an `Insert` method for `ListNodeHeader` without
    knowing the actual object being inserted.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在困难的部分是实现`Node`接口。假设你想要在这个列表中插入一个`ByteSliceElement`。由于`ByteSliceElement`嵌入`ListNodeHeader`，它具有所有的方法，因此实现了`Node`。然而，我们无法编写例如`Insert`方法为`ListNodeHeader`，除非我们知道实际被插入的对象。
- en: 'One way of doing this is by using the following pattern:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方式是使用以下模式：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are several things going on here. First, the `Insert` method gets two
    views of the node being inserted. If the node being inserted is a `*ByteSliceElement`,
    then it gets a `Node` version of this, and then it also gets the `*ListNodeHeader`
    embedded in `ByteSliceElement` as the receiver. Using this, it can adjust the
    members of the `ByteSliceElement` to point to the previous and next nodes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个事情在进行。首先，`Insert`方法获取要插入的节点的两个视图。如果被插入的节点是`*ByteSliceElement`，那么它获取这个节点的`Node`版本，然后它还获取嵌入在`ByteSliceElement`中的`*ListNodeHeader`作为接收者。使用这个，它可以调整`ByteSliceElement`的成员以指向前一个和下一个节点。
- en: However, it cannot access the `prev` and `next` members of a `Node`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它不能访问`Node`的`prev`和`next`成员。
- en: 'One option is what is shown: declare an unexported method in the `Node` interface
    that will return the `ListNodeHeader` from a given node. Another option is to
    add `getNext/setNext` and `getPrev/setPrev` methods to the interface.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是如下所示：在`Node`接口中声明一个未导出的方法，该方法将从给定的节点返回`ListNodeHeader`。另一个选项是向接口中添加`getNext/setNext`和`getPrev/setPrev`方法。
- en: 'Now you have achieved two things: first, any user of this list structure outside
    this package *must* embed `ListNodeHeader` to implement a list node. There is
    an unexported method in the interface. There is no way to implement such an interface
    in a different package. The only way is to embed a struct that already implements
    it.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经实现了两件事：首先，任何在这个包外使用这个列表结构的用户*必须*嵌入`ListNodeHeader`以实现一个列表节点。接口中有一个未导出的方法。没有在其他包中实现这样一个接口的方法。唯一的方法是嵌入一个已经实现了它的结构体。
- en: Second, you have a polymorphic container data structure whose mechanics are
    managed by a base struct.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你有一个多态的容器数据结构，其机制由一个基结构体管理。
- en: Checking whether an interface is nil
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查接口是否为nil
- en: You may wonder why this is even a problem. After all, don’t you just compare
    with nil? Not always.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这甚至是一个问题。毕竟，你不是只是比较nil吗？并不总是这样。
- en: 'An interface contains two values: the type of the value contained in the interface,
    and a pointer to that value. An interface is nil if both of those are nil. There
    are cases where an interface may point to a nil value of a type other than nil,
    which makes the interface non-nil.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含两个值：接口中包含的值的类型，以及指向该值的指针。如果这两个值都是nil，则接口为nil。存在一些情况，接口可能指向一个非nil类型的nil值，这使得接口非nil。
- en: You can’t check for this case easily. You have to avoid creating interfaces
    with nil values.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法轻松检查这种情况。你必须避免创建包含nil值的接口。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Avoid converting a pointer to a variable that can be nil to an interface:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 避免将指针转换为可能为nil的变量：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Check for nil interface values explicitly instead, such as the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 而应显式检查nil接口值，例如以下内容：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, use value errors instead of pointers. The following code avoids
    this problem altogether:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用值错误而不是指针。以下代码完全避免了这个问题：
- en: '`var x myerror`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`var x myerror`'
- en: There is no chance of `x` being nil.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`不可能为nil。'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As I explained earlier, an interface contains two values: type and value. What
    you are trying to avoid is creating an interface that contains a nil value with
    a non-nil type.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前解释的，接口包含两个值：类型和值。你试图避免的是创建一个包含nil值且类型非nil的接口。
- en: 'After the declaration that follows, the `y` interface is nil because both its
    type and its value are nil:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的声明之后，`y`接口为nil，因为它的类型和值都是nil：
- en: '`var y error`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`var y error`'
- en: 'After the following assignment, the type stored in `y` is now the type of `x`,
    and the value is nil. Thus, `y` is no longer nil:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下赋值之后，存储在`y`中的类型现在是`x`的类型，而值是nil。因此，`y`不再为nil：
- en: '`y=x`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`y=x`'
- en: 'This also applies to return from a function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于从函数返回：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `f` function never returns nil.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`函数从不返回nil。'
