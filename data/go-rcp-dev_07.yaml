- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Concurrency is a core part of the Go language. Unlike many other languages that
    support concurrency via rich multi-threading libraries, Go provides relatively
    few language primitives to write concurrent programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是 Go 语言的核心部分。与许多其他通过丰富的多线程库支持并发的语言不同，Go 提供了相对较少的语言原语来编写并发程序。
- en: Let’s start by emphasizing that concurrency is **not** parallelism. Concurrency
    is about how you write programs; parallelism is about how programs run. A concurrent
    program specifies what parts of the program can run in parallel. Depending on
    the actual execution, concurrent parts of a program may run sequentially, concurrently
    using time-sharing, or in parallel. A correct concurrent program yields the same
    result regardless of how it is run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，强调并发**不是**并行。并发是关于你如何编写程序；并行是关于程序如何运行。一个并发程序指定了程序中哪些部分可以并行运行。根据实际执行情况，程序中的并发部分可能按顺序运行，使用时间共享并发运行，或者并行运行。一个正确的并发程序无论以何种方式运行都会产生相同的结果。
- en: 'This chapter introduces some of the Go concurrency primitives using recipes.
    In this chapter, you will learn about the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过食谱介绍了 Go 并发原语的一些内容。在本章中，您将学习以下内容：
- en: Creating goroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 goroutines
- en: Running multiple independent functions concurrently and waiting for them to
    end
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行运行多个独立函数并等待它们结束
- en: Sending and receiving data using channels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道发送和接收数据
- en: Sending data to a channel from multiple goroutines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个 goroutine 向通道发送数据
- en: Collecting the results of concurrent computations using channels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通道收集并发计算的结果
- en: Working with multiple channels using the `select` statement
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `select` 语句处理多个通道
- en: Canceling a goroutine
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消一个 goroutine
- en: Detecting cancelation using nonblocking `select`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非阻塞 `select` 检测取消
- en: Updating shared variables concurrently
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发更新共享变量
- en: Doing things concurrently using goroutines
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 goroutine 进行并发操作
- en: 'A goroutine is a function that runs concurrently with other goroutines. When
    a program starts, the Go runtime creates several goroutines. One of these goroutines
    runs the garbage collector. Another goroutine runs the `main` function. As the
    program executes, it creates more goroutines as necessary. A typical go program
    may have thousands of goroutines all running concurrently. The Go runtime schedules
    these goroutines to operating system threads. Each operating system thread is
    assigned a number of goroutines that it runs using time sharing. At any given
    moment, there can be as many active goroutines as the number of logical processors:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutine 是一个与其他 goroutine 并行运行的函数。当程序启动时，Go 运行时会创建几个 goroutines。其中之一运行垃圾回收器。另一个运行
    `main` 函数。随着程序的执行，它会根据需要创建更多的 goroutines。一个典型的 Go 程序可能有数千个并发运行的 goroutines。Go
    运行时会将这些 goroutines 调度到操作系统线程。每个操作系统线程都会分配一定数量的 goroutines，并使用时间共享来运行它们。在任何给定时刻，活跃的
    goroutine 数量可以与逻辑处理器的数量相同：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating goroutines
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 goroutines
- en: Goroutines are an integral part of the Go language. You create goroutines using
    the `go` keyword.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines 是 Go 语言的一个基本组成部分。您可以使用 `go` 关键字创建 goroutines。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create goroutines using the `go` keyword followed by a function call:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go` 关键字后跟函数调用来创建 goroutines：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When `go f()` is evaluated, the runtime creates a new goroutine and calls the
    `f` function. The goroutine running `main` also continues running. In other words,
    when the `go` keyword is evaluated, the program execution splits into two concurrent
    execution streams – one is the original execution stream (in the preceding example,
    the stream that is running `main`) and the other runs the function that comes
    after the `go` keyword.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `go f()` 被评估时，运行时会创建一个新的 goroutine 并调用 `f` 函数。运行 `main` 的 goroutine 也会继续运行。换句话说，当
    `go` 关键字被评估时，程序执行会分为两个并发执行流——一个是原始执行流（在前面的例子中，运行 `main` 的流）和另一个运行 `go` 关键字后面的函数。
- en: 'The function can take arguments if necessary:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以根据需要接受参数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The arguments to the function are evaluated before the goroutine starts. That
    is, the `main` goroutine first evaluates the argument of `f` (which is, in this
    case, the `x` value) and then creates a new goroutine and runs `f`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数在 goroutine 开始之前被评估。也就是说，`main` goroutine 首先评估 `f` 的参数（在这种情况下，是 `x` 值），然后创建一个新的
    goroutine 并运行 `f`。
- en: 'It is common practice to use a closure to run goroutines. They provide the
    context necessary for understanding code. They also prevent passing many variables
    as arguments to goroutines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包运行 goroutine 是一种常见的做法。它们提供了理解代码所需的上下文。它们还防止将许多变量作为参数传递给 goroutine：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `x` is passed as an argument to the goroutine, but `y` is captured.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x` 作为参数传递给 goroutine，但 `y` 被捕获。
- en: When the function run by the `go` keyword ends, the goroutine terminates.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `go` 关键字运行的函数结束时，goroutine 将终止。
- en: Running multiple independent functions concurrently and waiting for them to
    complete
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发运行多个独立函数并等待它们完成
- en: When you have multiple independent functions that do not share data, you can
    use this recipe to run them concurrently. We will also use `sync.WaitGroup` to
    wait for the goroutines to finish.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多个不共享数据的独立函数时，你可以使用此食谱来并发运行它们。我们还将使用 `sync.WaitGroup` 来等待 goroutine 完成。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create an instance of `sync.WaitGroup` to wait for goroutines:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `sync.WaitGroup` 实例以等待 goroutine：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `sync.WaitGroup` is simply a thread-safe counter. We will use `wg.Add(1)`
    for each goroutine we create, and use `wg.Done()` to subtract 1 whenever a goroutine
    ends. Then we can wait for the waitgroup to reach zero, signaling the termination
    of all goroutines.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sync.WaitGroup` 简单来说是一个线程安全的计数器。我们将为每个创建的 goroutine 使用 `wg.Add(1)`，并在每个 goroutine
    结束时使用 `wg.Done()` 减去 1。然后我们可以等待等待组达到零，这表示所有 goroutine 的终止。'
- en: 'For each function that will run concurrently, do the following:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个将要并发运行的函数，执行以下操作：
- en: Add 1 to the wait group
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向等待组添加 1
- en: Start a new goroutine
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个新的 goroutine
- en: Call `defer wg.Done()` to make sure you signal goroutine termination
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `defer wg.Done()` 确保你发出 goroutine 终止的信号
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Instead of adding 1 to the wait group for every goroutine, you can simply add
    the number of goroutines. For instance, if you know that you will create 5 goroutines,
    you can simply do `wg.Add(5)` before creating the first goroutine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不向等待组为每个 goroutine 添加 1，而只需添加 goroutine 的数量。例如，如果你知道你将创建 5 个 goroutine，你可以在创建第一个
    goroutine 之前简单地做 `wg.Add(5)`。
- en: 'Wait for the goroutines to end:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待 goroutine 结束：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This call will block until `wg` reaches zero, that is, until all goroutines
    call `wg.Done()`.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此调用将阻塞，直到 `wg` 达到零，即直到所有 goroutine 调用 `wg.Done()`。
- en: Now, you can use the results of all the goroutines.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以使用所有 goroutine 的结果。
- en: 'The crucial detail of this recipe is that all goroutines are independent, which
    means the following:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此食谱的关键细节是所有 goroutine 都是独立的，这意味着以下内容：
- en: All variables written by each goroutine are used exclusively by that goroutine
    until `wg.Done()`. Goroutines may read shared variables, but they cannot write
    to them. After `wg.Done()`, all goroutines are terminated and the variables they
    wrote can be used.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个 goroutine 编写的所有变量都仅由该 goroutine 使用，直到 `wg.Done()`。goroutine 可以读取共享变量，但不能写入它们。在
    `wg.Done()` 之后，所有 goroutine 都将终止，它们所写入的变量可以被使用。
- en: No goroutine depends on the result of another goroutine.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有goroutine依赖于另一个goroutine的结果。
- en: You should not attempt to read the results of a goroutine before `wg.Wait`.
    That is a memory race with undefined behavior.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `wg.Wait` 之前，你不应该尝试读取 goroutine 的结果。这是一个具有未定义行为的内存竞争。
- en: A **memory race** happens when you write to a shared variable concurrently with
    other writes or reads. The result of a program containing a memory race is undefined.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与其他写入或读取同时写入共享变量时，会发生**内存竞争**。包含内存竞争的程序的结果是未定义的。
- en: Communicating between goroutines using channels
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道在 goroutine 之间进行通信
- en: More often than not, multiple goroutines have to communicate and coordinate
    to distribute work, manage state, and collate results of computations. Channels
    are the preferred mechanism for this. A channel is a synchronization mechanism
    with an optional fixed-size buffer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的时候，多个 goroutine 需要通信和协调以分配工作、管理状态和汇总计算结果。通道是这种情况下首选的机制。通道是一种带有可选固定大小缓冲区的同步机制。
- en: 'Tip:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: The following recipes show channels that are closed. Closing a channel is a
    method for communicating end of data. If you do not close a channel, it will be
    garbage collected when it is no longer referenced. In other words, you don't need
    to close a channel if you don't need to signal end of data to the receivers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了已关闭的通道。关闭通道是一种传达数据结束的方法。如果你不需要向接收者传达数据结束的信号，则不需要关闭通道。
- en: Sending and receiving data using channels
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通道发送和接收数据
- en: A goroutine can send to a channel if there is another goroutine waiting to receive
    from it, or in the case of a buffered channel, there is space available in the
    channel buffer. Otherwise, the goroutine is blocked until it can send.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有另一个goroutine正在等待从它接收数据，或者在有缓冲的channel中，channel缓冲区中有空间，那么goroutine可以向channel发送数据。否则，goroutine将被阻塞，直到它可以发送。
- en: A goroutine can receive from a channel if there is another goroutine waiting
    to send to it, or in the case of a buffered channel, there is data in the channel
    buffer. Otherwise, the receiver is blocked until it can receive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有另一个goroutine正在等待向它发送数据，或者在有缓冲的channel中，channel缓冲区中有数据，那么goroutine可以从channel接收数据。否则，接收器将被阻塞，直到它可以接收数据。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a channel with the type of data it will pass. The following example creates
    a channel that can pass strings.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个传递数据的channel类型。以下示例创建了一个可以传递字符串的channel。
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In a goroutine, send data elements to the channel. When all data elements are
    sent, close the channel:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中，将数据元素发送到channel。当所有数据元素都发送完毕后，关闭channel：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Receive data from the channel in another goroutine. In the following example,
    the main goroutine receives strings from the channel and prints them. The `for`
    loop ends when the channel is closed:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个goroutine中从channel接收数据。在以下示例中，主goroutine从channel接收字符串并打印它们。`for`循环在channel关闭时结束：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sending data to a channel from multiple goroutines
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个goroutines向channel发送数据
- en: There are cases where you have many goroutines working on a piece of a problem,
    and when they are done, they send the result using a channel. A problem with this
    situation is deciding when to close the channel. This recipe shows how it is done.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你有很多goroutine在处理问题的某个部分，当它们完成后，它们会通过channel发送结果。这种情况的一个问题是决定何时关闭channel。这个方法展示了如何做到这一点。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the result channel with the data type it will pass:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个传递数据的result channel：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the listener goroutine and a wait group to wait for its completion later.
    This goroutine will be blocked until the other goroutines start sending data:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建监听goroutine和一个等待组，稍后等待其完成。这个goroutine将在其他goroutine开始发送数据时被阻塞：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a wait group to keep track of the goroutines that will write to the
    result channel. Then, create goroutines that send to the channel:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个等待组来跟踪将要写入结果channel的goroutines。然后，创建向channel发送数据的goroutines：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Wait for the processing goroutines to end and close the result channel:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待处理goroutines结束并关闭结果channel：
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Wait for the listener goroutine to end:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待监听goroutine结束：
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you can use the `results` slice.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`results`切片。
- en: Collecting the results of concurrent computations using channels
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用channels收集并发计算的结果
- en: Often, you have multiple goroutines working on parts of a problem and you have
    to collect the result of each goroutine to compile a single result object. Channels
    are the perfect mechanism for this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你有多达多个goroutine在处理问题的各个部分，你必须收集每个goroutine的结果来编译一个单一的结果对象。Channels是完成这个任务的完美机制。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a channel to collect the results of the computation:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个channel来收集计算的结果：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the `resultCh` channel is a channel of `int` values. That is,
    the results of the computations will be integers.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，`resultCh` channel是一个`int`值的channel。也就是说，计算的结果将是整数。
- en: 'Create a `sync.WaitGroup` instance to wait for the goroutines:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`sync.WaitGroup`实例来等待goroutines：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Distribute work among goroutines. Each goroutine should have access to the `resultCh`.
    Add each goroutine to the wait group, and make sure to call `defer wg.Done()`
    in the goroutine.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutines之间分配工作。每个goroutine都应该能够访问`resultCh`。将每个goroutine添加到等待组中，并确保在goroutine中调用`defer
    wg.Done()`。
- en: 'Perform the computation in the goroutine, and send the result to the `resultCh`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中执行计算，并将结果发送到`resultCh`：
- en: '[PRE17]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, you have to do two things: wait for all goroutines to complete and collect
    the results from the `resultCh`. There are two ways you can do this:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你必须做两件事：等待所有goroutines完成并从`resultCh`收集结果。你可以这样做两种方式：
- en: 'Collect the results while waiting for the goroutines to end concurrently. That
    is, create a goroutine and wait for the goroutines to end. When all goroutines
    are done, close the channel:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在等待goroutines并发结束的同时收集结果。也就是说，创建一个goroutine并等待goroutines结束。当所有goroutines完成后，关闭channel：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Collect the results asynchronously while waiting for the goroutines to end.
    When all goroutines are completed, close the channel. However, when you close
    the channel, the goroutine that collects the results may still be running. We
    have to wait for that goroutine to end as well. We can use another wait group
    for that purpose:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在等待 goroutine 结束的同时异步收集结果。当所有 goroutine 完成后，关闭通道。然而，当你关闭通道时，收集结果的 goroutine
    可能仍在运行。我们必须等待该 goroutine 结束。为此，我们可以使用另一个等待组：
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Working with multiple channels using the select statement
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `select` 语句处理多个通道
- en: You can only send data or receive data from a channel at any given time. If
    you are interacting with multiple goroutines (and thus, multiple concurrent events),
    you need a language construct that will let you interact with multiple channels
    at once. That construct is the `select` statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间，你只能从通道发送数据或接收数据。如果你正在与多个 goroutine（以及因此，多个并发事件）交互，你需要一个语言结构，它将允许你同时与多个通道交互。这个结构就是
    `select` 语句。
- en: This section shows how `select` is used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用 `select`。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: A blocking `select` statement chooses an active case from zero or more cases.
    Each case is a channel send or channel receive event. If there are no active cases
    (that is, none of the channels can be sent to or received from), `select` is blocked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞 `select` 语句从零个或多个分支中选择一个活跃的分支。每个分支是一个通道发送或接收事件。如果没有活跃的分支（也就是说，没有通道可以发送到或从接收），`select`
    将被阻塞。
- en: 'In the following example, the `select` statement waits to receive from one
    of two channels. The program receives from only one of the channels. If both channels
    are ready, one of the channels will be picked randomly. The other channel will
    be left unread:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`select` 语句等待从两个通道中的一个接收数据。程序只从其中一个通道接收数据。如果两个通道都准备好了，其中一个通道将被随机选择。另一个通道将被留下未读取：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Canceling goroutines
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消 goroutine
- en: Creating goroutines is easy and efficient in Go, but you also have to make sure
    your goroutines end eventually. If a goroutine is left running unintentionally,
    it is called a “leaked” goroutine. If a program keeps leaking goroutines, eventually
    it crashes with an out-of-memory error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建 goroutine 很简单且高效，但你也要确保你的 goroutine 最终能够结束。如果一个 goroutine 无意中被留下运行，它被称为“泄漏”的
    goroutine。如果一个程序持续泄漏 goroutine，最终它可能会因为内存不足错误而崩溃。
- en: Some goroutines perform a limited number of operations and terminate naturally,
    but some run indefinitely until an external stimulus is received. A common pattern
    for long-running goroutines to receive such stimulus is to use a `done` channel.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 goroutine 执行有限数量的操作并自然终止，但有些会无限期地运行，直到接收到外部刺激。对于长时间运行的 goroutine 接收此类刺激的常见模式是使用一个
    `done` 通道。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a `done` channel with an empty data type:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据类型为空的 `done` 通道：
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a channel to provide input to goroutines:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个通道为 goroutine 提供输入：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create goroutines that look like this:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建如下所示的 goroutine：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To cancel the goroutine(s), simply close the `done` channel:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消 goroutine(s)，只需关闭 `done` 通道：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will enable the `case <-done` branch in all the goroutines that are listening
    to the `done` channel, and they will terminate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用所有监听 `done` 通道的 goroutine 中的 `case <-done` 分支，并且它们将终止。
- en: Detecting cancelation using nonblocking select
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非阻塞 `select` 检测取消
- en: A non-blocking `select` has a `default` case. When the `select` statement runs,
    it checks all the available cases, and if none of them are available, the `default`
    case is selected. This allows a `select` to continue without blocking.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 `select` 有一个 `default` 分支。当 `select` 语句运行时，它会检查所有可用的分支，如果没有一个可用，则选择 `default`
    分支。这允许 `select` 在不阻塞的情况下继续。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a `done` channel with an empty data type:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据类型为空的 `done` 通道：
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create goroutines that look like this:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建如下所示的 goroutine：
- en: '[PRE26]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To cancel the goroutine(s), simply close the `done` channel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消 goroutine(s)，只需关闭 `done` 通道。
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sharing memory
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存
- en: 'One of the most famous Go idioms is: “Do not communicate by sharing memory,
    share memory by communicating.” Channels are for sharing memory by communicating.
    Communicating by sharing memory is done using shared variables in multiple goroutines.
    Even though it is discouraged, there are many use cases where shared memory makes
    more sense than a channel. If at least one of the goroutines updates a shared
    variable that is read by other goroutines, you have to ensure that there are no
    memory races.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的Go惯用语句之一是：“不要通过共享内存来通信，要通过通信来共享内存。”通道是通过通信来共享内存的。通过共享内存进行通信是通过多个goroutine中的共享变量来完成的。尽管不鼓励这样做，但有许多情况下共享内存比通道更有意义。如果至少有一个goroutine更新了一个被其他goroutine读取的共享变量，你必须确保没有内存竞争。
- en: 'A memory race happens when a goroutine updates a variable concurrently while
    another goroutine reads from it or writes to it. When this happens, there is no
    guarantee that the update to that variable will be seen by other goroutines. A
    famous example of this situation is the `busy-wait` loop:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个goroutine在另一个goroutine读取或写入变量的同时更新变量时，会发生内存竞争。当这种情况发生时，无法保证其他goroutine会看到该变量的更新。这种情况的一个著名例子是`busy-wait`循环：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This program has a memory race. The `done=true` assignment is concurrent with
    the `for !done` loop. That means, even though the main goroutine runs `done=true`,
    the goroutine reading `done` may never see that update, staying in the `for` loop
    indefinitely.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个内存竞争。`done=true`的赋值与`for !done`循环并发。这意味着，尽管主goroutine运行`done=true`，但读取`done`的goroutine可能永远看不到这个更新，无限期地停留在`for`循环中。
- en: Updating shared variables concurrently
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发更新共享变量
- en: 'The Go memory model guarantees that the effect of a variable write is visible
    to instructions that come after that write within that goroutine only. That is,
    if you update a shared variable, you have to use special tools to make that update
    visible to other goroutines. A simple way to ensure this is to use a mutex. Mutex
    stands for “mutual exclusion.” A mutex is a tool you can use to ensure the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go内存模型保证在一个goroutine中，变量写入的效果只对写入之后执行的指令可见。也就是说，如果你更新一个共享变量，你必须使用特殊的工具来确保这个更新对其他goroutine可见。确保这一点的简单方法是使用互斥锁。互斥锁代表“互斥排他”。互斥锁是一个你可以用来确保以下内容的工具：
- en: Only one goroutine updates a variable at any given time
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何给定时间只有一个goroutine更新一个变量
- en: Once that update is done and the mutex is released, all goroutines can see that
    update
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦更新完成并且互斥锁被释放，所有goroutine都可以看到这个更新
- en: In this recipe, we show how this is done.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了如何做到这一点。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The section of a program that updates shared variables is a “critical section.”
    You use a mutex to ensure that only a single goroutine can enter its critical
    section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更新共享变量的程序部分是一个“临界区”。你使用互斥锁来确保只有一个goroutine可以进入其临界区。
- en: 'Declare a mutex to protect a critical section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个互斥锁来保护临界区：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A mutex protects a set of shared variables. For instance, if you have goroutines
    that update a single integer, you declare a mutex for the critical sections that
    update that integer. You must use the same mutex every time you read or write
    that integer value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁保护一组共享变量。例如，如果你有goroutine更新一个单个整数，你为更新该整数的临界区声明一个互斥锁。每次读取或写入该整数值时，你必须使用相同的互斥锁。
- en: 'When updating the shared variable(s), first lock the mutex. Then perform the
    update and unlock the mutex:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新共享变量时，首先锁定互斥锁。然后执行更新并解锁互斥锁：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this pattern, if multiple goroutines attempt to update `cache`, they will
    queue at `cacheMutex.Lock()` and only one will be allowed. When that goroutine
    performs the update, it will call `cacheMutex.Unlock()`, which will enable one
    of the waiting goroutines to acquire the lock and update the cache again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，如果有多个goroutine尝试更新`cache`，它们将在`cacheMutex.Lock()`处排队，并且只允许一个进行更新。当那个goroutine执行更新时，它将调用`cacheMutex.Unlock()`，这将允许一个等待的goroutine获取锁并再次更新缓存。
- en: 'When reading the shared variable, first lock the mutex. Then perform the read,
    and then unlock the mutex:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取共享变量时，首先锁定互斥锁。然后执行读取，然后解锁互斥锁：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
