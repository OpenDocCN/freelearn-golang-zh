- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Errors and Panics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误和恐慌
- en: Go error handling has been nothing but polarizing. Those who came from a background
    in languages with exception handling (such as Java) tend to hate it, and those
    who came from a background in languages where errors are values returned from
    functions (such as C) feel comfortable with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go的错误处理一直备受争议。那些来自具有异常处理语言背景（如Java）的人往往讨厌它，而那些来自错误是函数返回值语言背景（如C）的人则对此感到舒适。
- en: Having a background in both, I am of the opinion that the explicit nature of
    error handling forces you to think about exceptional situations at every step
    of the development. Error generation, error passing, and error handling require
    the same type of discipline and scrutiny as the “happy path” (which is when no
    errors happen).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在两者都有背景的情况下，我认为错误处理的显式性质迫使你在开发的每一步都考虑异常情况。错误生成、错误传递和错误处理需要与“正常路径”（即没有错误发生时）相同的纪律和审查。
- en: 'If you noticed, I make a distinction between three phases of dealing with errors:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，我在处理错误的三个阶段中做了区分：
- en: Detection and generation of errors deal with detecting an exceptional situation
    and capturing diagnostic information
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的检测和生成处理涉及检测异常情况并捕获诊断信息
- en: Passing of errors deals with allowing errors to be propagated up the stack,
    optionally decorating them with contextual information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的传递处理允许错误向上传播到堆栈，可选地用上下文信息装饰它们
- en: Handling of errors deals with actually resolving the error, which may include
    terminating the program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理涉及实际解决错误，这可能包括终止程序
- en: 'In this chapter, you will learn about the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下内容：
- en: How to generate errors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成错误
- en: How to pass them by annotating them using contextual information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用上下文信息来注释它们来传递它们
- en: How to handle errors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理错误
- en: Organizing errors in a project
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目中组织错误
- en: Dealing with panics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理恐慌
- en: Returning and handling errors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的返回和处理
- en: This recipe shows how to detect errors and how to wrap errors with additional
    contextual information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱展示了如何检测错误以及如何用额外的上下文信息包装错误。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the last return value of a function or method for errors:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数或方法的最后一个返回值作为错误：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the function or method is successful, it will return `nil` error. If an
    error condition is detected within the function or method, either return that
    error verbatim or wrap the error with another one containing contextual information:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数或方法成功，它将返回`nil`错误。如果在函数或方法中检测到错误条件，则直接返回该错误或用包含上下文信息的另一个错误包装该错误：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do not use `panic` as a replacement for error. `panic` should be used to signal
    a potential bug or unrecoverable situation. An error is used to signal a context-dependent
    situation, such as a missing file or invalid input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用`panic`来代替错误。`panic`应该用来表示潜在的bug或不可恢复的情况。错误用来表示上下文相关的情况，例如缺少文件或无效输入。
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Go uses explicit error detection and handling. That means there is no implicit
    or hidden execution path for errors (such as throwing an exception). Go errors
    are simply interface values and an error being `nil` is interpreted as the absence
    of an error. The above function calls some file management functions that can
    return an error. When that happens (that is, when the function returns a non-`nil`
    error), this function simply wraps that error with additional information and
    returns it. The additional information allows the caller, and sometimes the user
    of the program to determine the correct course of action.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用显式的错误检测和处理。这意味着没有隐式或隐藏的执行路径用于错误（如抛出异常）。Go的错误仅仅是接口值，一个错误为`nil`被解释为没有错误。上述函数调用了一些可能返回错误的文件管理函数。当这种情况发生时（即，当函数返回非`nil`错误时），这个函数只是用额外信息包装那个错误并返回它。这些额外信息允许调用者，有时是程序的用户确定正确的行动方案。
- en: Wrapping errors to add contextual information
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装错误以添加上下文信息
- en: Using the standard library `errors` package, you can wrap an error with another
    error that contains additional contextual information. This package also provides
    facilities and conventions that will let you check if an error tree contains a
    particular error or extract a particular error from an error tree.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库`errors`包，你可以用包含额外上下文信息的另一个错误包装一个错误。此包还提供了设施和约定，让你检查错误树是否包含特定错误或从错误树中提取特定错误。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add contextual information to an error using `fmt.Errorf`. In the following
    example, the returned error will contain the error returned from `os.Open`, and
    it will also include the file name:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fmt.Errorf`向错误添加上下文信息。在下面的例子中，返回的错误将包含来自`os.Open`的错误，并且它还将包括文件名：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note the use of `%w` verb in `fmt.Errorf` above. The %w verb is used to create
    an error wrapping the one given as its argument. If we used %v or %s, the returned
    error would contain the text of the original error, but it would not wrap it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上面`fmt.Errorf`中使用`%w`动词。`%w`动词用于创建一个包装其参数的错误。如果我们使用`%v`或`%s`，返回的错误将包含原始错误的文本，但它不会包装它。
- en: Comparing errors
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较错误
- en: When you wrap an error with additional information, the new error value is not
    of the same type or value as the original error. For instance, `os.Open` may return
    `os.ErrNotExist` if the file is not found, and if you wrap this error with additional
    information, such as the file name, the caller of this function will need a way
    to get to the original error to handle it properly. This recipe shows how to deal
    with such wrapped error values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用一个额外的信息包装错误时，新的错误值与原始错误不是同一类型或值。例如，如果文件未找到，`os.Open`可能会返回`os.ErrNotExist`，如果你用额外的信息（如文件名）包装这个错误，调用这个函数的调用者将需要一个方法来获取原始错误以正确处理它。这个菜谱展示了如何处理这样的包装错误值。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Checking if there is an error or not is simple: check if an error value is
    `nil` or not:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否有错误很简单：检查错误值是否为`nil`或不是：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Checking if an error is what you expect should be done using `errors.Is`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`errors.Is`来检查错误是否是你期望的：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`errors.Is(err,target error)` compares if `err` is equal to `target` by doing
    the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`errors.Is(err,target error)`通过以下方式比较`err`是否等于`target`：'
- en: It checks if `err==target`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查`err==target`。
- en: If that fails, it checks if `err` has an `Is(error) bool` method by calling
    `err.Is(target)`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这还失败，它会检查`err`是否有`Is(error) bool`方法，通过调用`err.Is(target)`。
- en: If that fails, it checks if `err` has an `Unwrap() error` method and `err.Unwrap()`
    is not `nil` by checking if `err.Unwrap()` is equal to `target`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这还失败，它会检查`err`是否有`Unwrap() error`方法，并且`err.Unwrap()`不是`nil`，通过检查`err.Unwrap()`是否等于`target`。
- en: If that fails, it checks if `err` has an `Unwrap() []error` method, and if `target`
    is equal to any one of those slice elements.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这还失败，它会检查`err`是否有`Unwrap() []error`方法，并且`target`等于那些切片元素中的任何一个。
- en: The meaning of this is that if you wrap an error, the caller can still check
    if the wrapped error happened and behave accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你包装了一个错误，调用者仍然可以检查包装的错误是否发生，并相应地行事。
- en: 'If you define an error using `errors.New()` or `fmt.Errorf()`, then the returned
    error interface contains a pointer to an object. In this case, the fact that two
    errors have the same string representation doesn’t mean that they are equal. The
    following program shows this situation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`errors.New()`或`fmt.Errorf()`定义了一个错误，那么返回的错误接口包含一个指向对象的指针。在这种情况下，两个错误具有相同的字符串表示并不意味着它们是相等的。以下程序展示了这种情况：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Above, even though the error strings are the same, `e1` and `e2` are pointers
    pointing to different objects. The program will print `Errors are different`.
    Thus, declaring errors like the following works:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，即使错误字符串相同，`e1`和`e2`都是指向不同对象的指针。程序将打印`Errors are different`。因此，声明如下错误是有效的：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A comparison to `ErrNotFound` will compare if an error value is a pointer to
    the same object as `ErrNotFound`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ErrNotFound`的比较将检查错误值是否是指向与`ErrNotFound`相同对象的指针。
- en: Structured errors
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化错误
- en: A **structured error** provides contextual information that can be crucial in
    handling the errors before they reach the user of a program. This recipe shows
    how such errors can be used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**结构化错误**提供了在错误到达程序用户之前处理错误时可能至关重要的上下文信息。这个菜谱展示了如何使用这样的错误。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Define a struct containing metadata that captures the error situation.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含捕获错误情况的元数据的结构体。
- en: Implement the `Error() string` method to make it an `error`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`Error() string`方法来使其成为一个`error`。
- en: If the error can wrap other errors, include an `error` or `[]error` to store
    those.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误可以包装其他错误，包括一个`error`或`[]error`来存储那些。
- en: Optionally, implement the `Is(error) bool` method to control how to compare
    this error.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地实现`Is(error) bool`方法来控制如何比较这个错误。
- en: Optionally, implement `Unwrap() error` or `Unwrap() []error` to return wrapped
    errors.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地实现`Unwrap() error`或`Unwrap() []error`来返回包装的错误。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Any data type implementing the `error` interface (containing only one method,
    `Error() string`) can be used as an error. This means that you can create data
    structures containing detailed error information that can be later acted upon.
    So, if you need several data fields to describe an error, instead of building
    an elaborate string and returning it via `fmt.Errorf`, you can use a struct.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了 `error` 接口（只包含一个方法，`Error() string`）的数据类型都可以用作错误。这意味着你可以创建包含详细错误信息的数据结构，稍后可以对其进行操作。所以，如果你需要几个数据字段来描述一个错误，而不是构建一个复杂的字符串并通过
    `fmt.Errorf` 返回它，你可以使用一个结构体。
- en: 'As an example, let’s assume you are parsing a multi-line formatted text input.
    Returning accurate and useful information to your users is important; nobody will
    enjoy receiving a `Syntax error` message without showing where the error is. So,
    you declare this error structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在解析多行格式化的文本输入。向用户提供准确和有用的信息很重要；没有人会喜欢在没有显示错误位置的情况下收到 `Syntax error` 消息。因此，你声明这个错误结构：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can now generate useful error information:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以生成有用的错误信息：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can use this error information to display useful messages to your users
    or control an interactive response, such as positioning the cursor to where the
    error is or highlighting text near the error location.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些错误信息向用户显示有用的消息或控制交互式响应，例如将光标定位到错误位置或突出显示错误附近的文本。
- en: Wrapping structured errors
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装结构化错误
- en: A structured error can be used to decorate another error with additional information
    by wrapping it. This recipe shows how to do that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化错误可以通过包装它来装饰另一个错误，并添加额外的信息。这个配方展示了如何做到这一点。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Keep an error member variable (or a slice of errors) to store the root cause
    in the structure.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结构中保留一个错误成员变量（或错误切片）来存储根本原因。
- en: Implement `Unwrap() error` (or `Unwrap() []``error`) method.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Unwrap() error`（或 `Unwrap() []error`）方法。
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can wrap the root cause error in a structured error. This allows you to
    add structured contextual information about the error:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将根原因错误包装在一个结构化错误中。这允许你添加有关错误的额外结构化上下文信息：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that `Unwrap` is necessary. Without that, the following code will fail
    to detect that the error is derived from `os.ErrNotFound`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Unwrap` 是必要的。如果没有它，以下代码将无法检测到错误是否源自 `os.ErrNotFound`：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With the `Unwrap` method, the `errors.Is` function can descend the enclosed
    errors, and determine if at least one of them is `os.ErrNotFound`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Unwrap` 方法，`errors.Is` 函数可以遍历封装的错误，并确定其中至少有一个是 `os.ErrNotFound`。
- en: Comparing structured errors by type
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过类型比较结构化错误
- en: In languages that support `try`-`catch` blocks, you usually catch errors based
    on their type. You can emulate the same functionality relying on `errors.Is`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持 `try`-`catch` 块的语言中，你通常根据错误类型来捕获错误。你可以依靠 `errors.Is` 来模拟相同的功能。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Implement the `Is(error) bool` method in your error type to define what type
    of equivalence you care about.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的错误类型中实现 `Is(error) bool` 方法来定义你关心的等价类型。
- en: How it works...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You may remember that the `errors.Is(err,target)` function first tests if `err
    = target`, and if that fails, it tests if `err.Is(target)`, provided `err` implements
    the `Is(error) bool` method. So, you can use the `Is(error) bool` method to tune
    how to compare your custom error types. Without the `Is(error) bool` method, `errors.Is`
    will compare using `==`, which will fail if the contents of two errors are different
    even if they are the same type. The following example allows you to check if the
    given error contains `ErrSyntax` somewhere in the error tree:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，`errors.Is(err,target)` 函数首先检查 `err = target`，如果失败，则检查 `err.Is(target)`，前提是
    `err` 实现了 `Is(error) bool` 方法。因此，你可以使用 `Is(error) bool` 方法来调整如何比较你的自定义错误类型。如果没有
    `Is(error) bool` 方法，`errors.Is` 将使用 `==` 进行比较，即使两个错误的类型相同，如果它们的内容不同，比较也会失败。以下示例允许你检查给定的错误是否在错误树中包含
    `ErrSyntax`：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can test if an error is a syntax error:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以测试一个错误是否是语法错误：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Extracting a specific error from the error tree
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从错误树中提取特定错误
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use the `errors.As` function to descend an error tree, find a particular error,
    and extract it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `errors.As` 函数遍历错误树，找到特定错误，并提取它。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Similar to the `errors.Is` function, `errors.As(err error, target any) bool`
    descends the error tree of `err` until an error that is assignable to `target`
    is found. That is done by the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `errors.Is` 函数类似，`errors.As(err error, target any) bool` 会遍历 `err` 的错误树，直到找到一个可以赋值给
    `target` 的错误。这是通过以下方式完成的：
- en: It checks if the value pointed to by `target` is assignable to the value pointed
    to by `err`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查`target`指向的值是否可以分配给`err`指向的值。
- en: If that fails, it checks if `err` has an `As(error) bool` method by calling
    `err.As(target)`. If it returns `true`, then an error is found.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这失败了，它会检查`err`是否有`As(error) bool`方法，通过调用`err.As(target)`。如果它返回`true`，那么就找到了一个错误。
- en: If not, it checks if `err` has an `Unwrap() error` method and `err.Unwrap()`
    is not `nil`, descending the tree.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有，它会检查`err`是否有`Unwrap() error`方法，并且`err.Unwrap()`不是`nil`，然后向下遍历树。
- en: Otherwise, it checks if `err` has an `Unwrap() []error` method, and if it returns
    a non-empty slice, it descends the tree for each of those until a match is found.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，它会检查`err`是否有`Unwrap() []error`方法，并且如果它返回一个非空切片，它会为这些切片中的每一个向下遍历树，直到找到匹配项。
- en: In other words, `errors.As` copies the error that can be assigned to `target`
    into `target`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`errors.As`将可以分配给`target`的错误复制到`target`中。
- en: 'The following example can be used to extract an instance of `ErrSyntax` from
    an error tree:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例可以用来从一个错误树中提取`ErrSyntax`的实例：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note the use of pointers here. The error struct is used as a value, and you
    want a copy of that error struct, so you pass a pointer to it: an instance of
    `ErrSyntax` can be copied into an instance of `*ErrSyntax`. If your program used
    `*ErrSyntax` as the error value, you need to send `**ErrSyntax` by declaring `var
    syntaxError *ErrSyntax` and passing `&syntaxError` to copy the pointer into the
    memory location pointed to by the double-pointer.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里指针的使用。错误结构体被用作值，而你想要一个错误结构体的副本，所以你传递一个指向它的指针：一个`ErrSyntax`实例可以被复制到一个`*ErrSyntax`实例中。如果你的程序使用`*ErrSyntax`作为错误值，你需要通过声明`var
    syntaxError *ErrSyntax`并将`&syntaxError`传递以复制指针到双指针指向的内存位置。
- en: Dealing with panics
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理恐慌
- en: In general, a **panic** is an unrecoverable situation, such as resource exhaustion
    or a violation of an invariant (that is, a bug). Some panics, such as out of memory
    or divide by zero, will be raised by the runtime (or raised by the hardware and
    transferred to the program as a panic). You should generate a panic in your program
    when you detect a bug. But how do you decide if a situation is a bug and you should
    panic or an error?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**恐慌**是一个不可恢复的情况，例如资源耗尽或违反了不变量（即错误）。一些恐慌，如内存不足或除以零，将由运行时（或由硬件引发并作为恐慌传递给程序）引发。当你检测到错误时，你应该在程序中引发恐慌。但是，你如何决定一个情况是否是错误并且你应该恐慌呢？
- en: In general, an external input (user input, data submitted by an API, or data
    read from a file) should not cause a panic. Such situations should be detected
    and returned as meaningful errors to the user. A panic in this situation would
    be, for instance, a failed compilation of a regular expression that is declared
    as a constant string in your program. The input is not something that can be fixed
    by re-running the program with different inputs; it is simply a bug.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，外部输入（用户输入、API提交的数据或从文件读取的数据）不应该引起恐慌。这种情况下应该检测并返回给用户有意义的错误。在这种情况下，恐慌可能是指定为你程序中常量字符串的正则表达式编译失败。输入不是可以通过重新运行程序并使用不同输入来修复的东西；它只是一个错误。
- en: If a panic is not handled with `recover`, the program will terminate by printing
    diagnostic output, including the reason for panic and the stacks of active goroutines.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用`recover`处理恐慌，程序将通过打印诊断输出（包括恐慌的原因和活动goroutine的堆栈）来终止。
- en: Panicking when necessary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在必要时恐慌
- en: Most of the time, deciding whether to panic or to return an error is not an
    easy decision. This recipe offers some guidelines to make that decision easier.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，决定是否恐慌或返回错误不是一个容易的决定。这个方法提供了一些指导方针，使这个决定更容易。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are two situations where you can panic. Panic if either of the following
    is the case:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况下你可以恐慌。如果以下任何一个情况成立，就恐慌：
- en: An invariant is violated
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 违反了不变量
- en: The program cannot continue in the current state
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序无法在当前状态下继续
- en: An invariant is a condition that cannot be violated in a program. Thus, if you
    detect that it is violated, instead of returning an error, panic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是在程序中不能被违反的条件。因此，如果你检测到它被违反，而不是返回一个错误，你应该恐慌。
- en: 'The following example is from a graph library I wrote. A graph contains nodes
    and edges, managed by a `*Graph` structure. The `Graph.NewEdge` method creates
    a new edge between two nodes. Those two nodes must belong to the same graph as
    the receiver of the `NewEdge` method so it is appropriate to panic if that is
    not the case, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例来自我编写的一个图形库。一个图包含节点和边，由`*Graph`结构管理。`Graph.NewEdge`方法在两个节点之间创建一条新边。这两个节点必须属于与`NewEdge`方法接收者相同的图，因此如果情况不是这样，应该恐慌，如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Above, there is nothing that can be gained by returning an error from this method.
    This is clearly a bug the caller did not realize, and if the program is allowed
    to continue, the integrity of the `Graph` object will be violated, creating hard-to-find
    bugs. The best course of action is to panic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，从这个方法返回错误没有任何好处。这显然是一个调用者没有意识到的错误，如果程序被允许继续，`Graph`对象的完整性将被违反，从而产生难以发现的错误。最好的做法是恐慌。
- en: The second situation is a broad case where continuation is not possible. As
    an example, consider you are writing a web application and you load HTML templates
    from the file system. If the compilation of such a template fails, the program
    cannot continue. You should panic.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是一个无法继续的情况。例如，假设你正在编写一个Web应用程序，并从文件系统中加载HTML模板。如果此类模板的编译失败，程序无法继续。你应该恐慌。
- en: Recovering from panics
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从恐慌中恢复
- en: An unhandled panic will terminate the program. Often, this is the only correct
    course of action. However, there are cases where you want to fail whatever caused
    the error, log it, and continue. For example, a server handling many requests
    concurrently does not terminate just because one of the requests panicked. This
    recipe shows how you can recover from a panic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 未处理的恐慌将终止程序。通常，这是唯一正确的做法。然而，有些情况下，你希望失败导致错误的原因，记录它，并继续。例如，一个处理多个并发请求的服务器不会因为其中一个请求恐慌而终止。这个配方展示了你如何从恐慌中恢复。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use a `recover` statement in a `defer` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`defer`函数中使用`recover`语句：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a program panics, the panicking function will return after all deferred
    blocks are executed. The stack of that goroutine will unroll one function after
    the other, cleaning up by running their `deferred` statements, until the beginning
    of the goroutine is reached, or one of the deferred functions invokes `recover`.
    If the panic is not recovered, the program will crash by printing out diagnostic
    and stack information. If the panic is recovered, the `recover()` function will
    return whatever parameter was given to `panic`, which can be any value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序恐慌时，在所有延迟块执行完毕后，恐慌的函数将返回。该goroutine的堆栈将一个接一个地展开函数，通过运行它们的`deferred`语句进行清理，直到达到goroutine的开始，或者其中一个延迟函数调用了`recover`。如果没有恢复恐慌，程序将通过打印诊断信息和堆栈信息而崩溃。如果恢复了恐慌，`recover()`函数将返回传递给`panic`的任何参数，这可以是任何值。
- en: So, if you recover from a panic, you should check if the recovered value is
    an error that you can use to give more useful information.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你从恐慌中恢复过来，你应该检查恢复的值是否是一个可以用来提供更多有用信息的错误。
- en: Changing return value in recover
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在恢复中更改返回值
- en: When you recover from a panic, you usually want to return some sort of error
    describing what happened. This recipe shows you how to do that.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从恐慌中恢复时，你通常想返回某种类型的错误来描述发生了什么。这个配方展示了你如何做到这一点。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To change the return value of a function when recovered from a panic, use named
    return values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当从恐慌中恢复函数的返回值时，使用命名返回值。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A **named return value** allows you to access and set the return values of
    a function. As shown below, you can change the return value of a function using
    named return values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名返回值**允许你访问和设置函数的返回值。如下所示，你可以使用命名返回值来更改函数的返回值：'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Capturing the stack trace of a panic
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获恐慌的堆栈跟踪
- en: Printing or logging a stack trace when a panic is detected is a critical tool
    in identifying problems at runtime. This recipe shows how you can add a stack
    trace to your logging messages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到恐慌时打印或记录堆栈跟踪是识别运行时问题的关键工具。这个配方展示了你如何将堆栈跟踪添加到你的日志消息中。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `debug.Stack` function with `recover`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`recover`的`debug.Stack`函数：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When inside the recovery function, the `debug.Stack` function will return the
    stack of the panic that is being recovered, not the stack where it is called.
    Thus, if you can log this information or print it, it will show you the exact
    location of the source of the panic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当在恢复函数内部时，`debug.Stack` 函数将返回正在恢复的 panic 的堆栈，而不是调用它的堆栈。因此，如果你能记录这个信息或打印它，它将显示
    panic 源的确切位置。
- en: Warning
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Getting the stack this way is an expensive operation. Use it carefully and only
    when necessary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式获取堆栈是一个昂贵的操作。请谨慎使用，并且仅在必要时使用。
- en: 'The preceding program will print the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将打印以下内容：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里：
- en: '`prog.go:13` is where `debug.Stack()` is called'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog.go:13` 是调用 `debug.Stack()` 的位置'
- en: '`prog.go:23` is where `*i=0` is executed'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog.go:23` 是执行 `*i=0` 的位置'
- en: '`prog.go:18` is where `f()` is called'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prog.go:18` 是调用 `f()` 的位置'
- en: As you can see, the stack pinpoints the exact location of the error (`prog.go:23`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，堆栈精确地指出了错误的所在位置 (`prog.go:23`)。
