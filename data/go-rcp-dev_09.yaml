- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: The Context Package
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文包
- en: Context is the circumstances in which something happens. When we are talking
    about a program, the context is the program environment, settings, and so on.
    For a server program (an HTTP server responding to a client request, an RPC server
    responding to function calls, etc.) or a program that responds to user requests
    (an interactive program, a command-line application, etc.), you can talk about
    a request-specific context. A request-specific context is created when the server
    or program starts processing a particular request and terminates when the processing
    ends. The request context contains information such as a request identifier that
    helps you identify log messages generated while processing a request, or the identity
    of the caller so you can determine the access rights of the caller. One of the
    uses of the `context` package is to provide an abstraction of such a request context,
    that is, an object that keeps request-specific data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是某事发生的情境。当我们谈论程序时，上下文是程序环境、设置等。对于服务器程序（响应客户端请求的HTTP服务器、响应函数调用的RPC服务器等）或响应用户请求的程序（交互式程序、命令行应用程序等），你可以谈论特定请求的上下文。特定请求的上下文是在服务器或程序开始处理特定请求时创建的，在处理结束时终止。请求上下文包含有助于你在处理请求时识别日志消息的请求标识符等信息，或者调用者的身份，以便你可以确定调用者的访问权限。`context`包的一个用途是提供此类请求上下文的抽象，即保持请求特定数据的对象。
- en: You may also have concerns about the running time of a request. You usually
    want to limit the amount of time a request is processed, or you may want to detect
    that the client is no longer interested in the results of the request (such as
    a WebSocket peer disconnecting). The `context` package is designed to handle these
    use cases as well.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还对请求的运行时间有所顾虑。你通常希望限制请求处理的时间，或者你可能想检测客户端是否不再对请求的结果感兴趣（例如WebSocket对等端断开连接）。`context`包旨在处理这些用例。
- en: 'The `context` package defines the `context.Context` interface. It has two uses:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`包定义了`context.Context`接口。它有两个用途：'
- en: Add a timeout and/or cancellation to request processing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为请求处理添加超时和/或取消
- en: Pass request-specific metadata down the stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求特定的元数据传递到堆栈中
- en: 'The use of `context.Context` is not limited to server programs. The term “request
    processing” should be taken in a broad sense: the request can be a network request
    through a TCP connection, an HTTP request, a command read from a command line,
    running a program with a certain flag, and so on. So, the uses for `context.Context`
    are much more diverse.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.Context`的使用不仅限于服务器程序。术语“请求处理”应从广义上理解：请求可以是TCP连接的网络请求、HTTP请求、从命令行读取的命令、以特定标志运行程序等。因此，`context.Context`的用途更加多样化。'
- en: 'This chapter shows common uses of the `context` package. In this chapter, you
    will learn about the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了`context`包的常见用法。在本章中，你将了解以下内容：
- en: Passing request-scoped data using context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文传递请求作用域的数据
- en: Using contexts for cancellation and timeouts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上下文进行取消和超时
- en: Using context for passing request-scoped data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文传递请求作用域的数据
- en: Request-scoped objects are those that are created when request processing starts
    and discarded when request processing ends. These are usually lightweight objects,
    such as a request identifier, authentication information identifying the caller,
    or loggers. In this section, you will see how these objects can be passed around
    using a context.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请求作用域的对象是在请求处理开始时创建的，在请求处理结束时丢弃的对象。这些通常是轻量级对象，例如请求标识符、标识调用者的认证信息或记录器。在本节中，你将了解如何使用上下文传递这些对象。
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The idiomatic way of adding data values to a context is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 向上下文中添加数据值的惯用方法是以下：
- en: 'Define a context key type. This avoids accidental name collisions. The use
    of an unexported type name such as the following is common. This pattern limits
    the ability to put or get context values of this particular type to the current
    package:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义上下文键类型。这可以避免意外的名称冲突。使用以下未导出类型名称是常见的做法。这种模式限制了将此特定类型的上下文值放入或从当前包中获取的能力：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Warning
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: You might be tempted to use `struct{}` instead of `int` here. After all, `struct{}`
    does not consume any additional memory. You have to be very careful when working
    with 0-size structures as the Go language specification does not offer any guarantees
    about the equivalence of two 0-size structures. That is, if you create multiple
    variables of a 0-size type, they may sometimes be equal and sometimes not. In
    short, do not use `struct{}` for this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想在这里使用 `struct{}` 而不是 `int`。毕竟，`struct{}` 不消耗任何额外的内存。当你与 0 大小结构工作时必须非常小心，因为
    Go 语言规范没有提供关于两个 0 大小结构等价性的任何保证。也就是说，如果你创建了多个 0 大小类型的变量，它们有时可能相等，有时可能不相等。简而言之，不要使用
    `struct{}`。
- en: 'Define the key value, or values, using the key type. In the following code
    line, `requestIDKey` is defined to be of type `requestIDKeyType` with the value
    `0` (`requestIDKey` is initialized to its `0` value when declared):'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键类型定义键值，或值。在以下代码行中，`requestIDKey` 被定义为 `requestIDKeyType` 类型，其值为 `0`（`requestIDKey`
    在声明时初始化为其 `0` 值）：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use `context.WithValue` to add the new value to the context. You can define
    a couple of helper functions to set and get values to and from the context:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `context.WithValue` 将新值添加到上下文中。你可以定义一些辅助函数来设置和获取上下文中的值：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Pass the new context to the functions called from the current function:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新上下文传递给从当前函数调用的函数：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You may have noticed that `context.Context` does not exactly look like a key-value
    map (there is no `SetValue` method; in fact, `context.Context` is immutable) even
    though you can use it to store key-value pairs. In fact, you cannot add a key
    value to a context, but you can get a new context containing that key value while
    keeping the old context. Contexts have layers like an onion; every addition to
    a context creates a new context that is linked to the old one, but with more features:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`context.Context` 并不完全像一个键值映射（没有 `SetValue` 方法；实际上，`context.Context`
    是不可变的），尽管你可以用它来存储键值对。实际上，你不能向上下文中添加键值，但你可以在保持旧上下文的同时获取包含该键值的新上下文。上下文就像洋葱一样有层级；向上下文中添加的每个元素都会创建一个新的上下文，它与旧上下文相连，但具有更多功能：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, `ctx`, `ctx1`, and `ctx2` are three different contexts.
    The `ctx` context is empty. `ctx1` contains `ctx` and the `key1: value1` key-value
    pair. `ctx2` contains `ctx1` and the `key2: value2` key-value pair . So, say you
    do the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，`ctx`、`ctx1` 和 `ctx2` 是三个不同的上下文。`ctx` 上下文为空。`ctx1` 包含 `ctx` 和 `key1:
    value1` 键值对。`ctx2` 包含 `ctx1` 和 `key2: value2` 键值对。所以，如果你这样做：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will print the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Say you do the same with `ctx1`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你对 `ctx1` 做同样的操作：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will print the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is used for `ctx`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下用于 `ctx`：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will print the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Even though you cannot set the values in a context (that is, a context is immutable),
    you can set a pointer to a struct and set the values in that struct.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你无法在上下文中设置值（也就是说，上下文是不可变的），你仍然可以设置一个指向结构的指针，并在该结构中设置值。
- en: 'That is:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The standard library provides a couple of predefined context values:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一些预定义的上下文值：
- en: '`context.Background()` returns a context that has no values and that cannot
    be canceled. This is usually the base context for most operations.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.Background()` 返回一个没有值且无法取消的上下文。这通常是大多数操作的基础上下文。'
- en: '`context.TODO()` is similar to `context.Background()` with a name that says
    wherever it is used should eventually be refactored to accept a real context.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context.TODO()` 与 `context.Background()` 类似，其名称表明在任何使用它的地方最终都应该重构以接受真实上下文。'
- en: There’s more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A context is usually shared among multiple goroutines. You have to be careful
    about concurrency issues especially if you put pointers to objects in a context.
    Take a look at the following example, which shows an authentication middleware
    for an HTTP service:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文通常在多个 goroutine 之间共享。你必须小心并发问题，特别是如果你在上下文中放置对象的指针。看看以下示例，它展示了 HTTP 服务的身份验证中间件：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The authentication middleware creates an `*AuthInfo` instance and calls the
    next handler in the chain using a context with the authentication info. The problem
    in this code is that `*AuthInfo` contains a `privileges` field that is initialized
    when `AuthInfo.GetPrivileges` is called. Since the context can be passed to multiple
    goroutines by the handlers, this lazy initialization scheme is prone to data races;
    several goroutines calling `AuthInfo.GetPrivileges` may attempt to initialize
    the map multiple times, one overwriting the other.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 认证中间件创建了一个 `*AuthInfo` 实例，并使用带有认证信息的上下文调用链中的下一个处理器。在这段代码中存在的问题是 `*AuthInfo`
    包含一个 `privileges` 字段，它在调用 `AuthInfo.GetPrivileges` 时被初始化。由于上下文可以通过处理器传递给多个 goroutines，这种延迟初始化方案容易发生数据竞争；多个
    goroutines 调用 `AuthInfo.GetPrivileges` 可能会尝试多次初始化映射，一次覆盖另一次。
- en: 'This can be corrected using a mutex:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用互斥锁来纠正这个问题：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It can also be corrected by initializing the privileges once in the middleware:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过在中间件中一次性初始化权限来纠正：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using context for cancellations
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文进行取消操作
- en: 'There are several reasons why you might want to cancel a computation: the client
    may have disconnected, or you may have multiple goroutines working on a computation
    and one of them failed, so you no longer want the others to continue. You can
    use other methods, such as a `done` channel that you close to signal cancellation,
    but a context can be more convenient depending on the use case. A context can
    be canceled many times (only the first call will actually cancel; the remaining
    ones will be ignored), whereas you cannot close an already closed channel as it
    will panic. Also, you can create a tree of contexts where canceling one context
    only cancels goroutines controlled by it, without affecting others.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要取消计算的原因有几个：客户端可能已经断开连接，或者你可能有多条 goroutines 正在处理一个计算，其中一条失败了，因此你不再希望其他继续。你可以使用其他方法，例如关闭一个
    `done` 通道来发出取消信号，但根据使用情况，上下文可能更方便。上下文可以被取消多次（只有第一次调用实际上会取消；其余的将被忽略），而你不能关闭已经关闭的通道，因为这会导致
    panic。此外，你可以创建一个上下文树，其中取消一个上下文只会取消它控制的 goroutines，而不会影响其他 goroutines。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'These are the steps to create a cancelable context and to detect a cancellation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建可取消上下文和检测取消的步骤：
- en: 'Use `context.WithCancel` to create a new cancelable context based on an existing
    context, and a cancellation function:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `context.WithCancel` 基于现有上下文和一个取消函数创建一个新的可取消上下文：
- en: '[PRE15]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Make sure the `cancel` function is eventually called. Canceling releases the
    resources associated with the context.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保最终调用了 `cancel` 函数。取消释放了与上下文关联的资源。
- en: 'Pass the cancelable context to computations or goroutines that can be canceled:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将可取消的上下文传递给可以取消的计算或 goroutines：
- en: '[PRE16]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the cancelable function, check whether the context is canceled using the
    `ctx.Done()` channel, or `ctx.Err()`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在取消函数中，使用 `ctx.Done()` 通道或 `ctx.Err()` 检查上下文是否被取消：
- en: '[PRE17]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or, use the following:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用以下方法：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To cancel a function manually, call the cancellation function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要手动取消一个函数，调用取消函数：
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ensure the `cancel` function is called eventually (use `defer cancel()`):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保最终调用了 `cancel` 函数（使用 `defer cancel()`）：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Warning
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Ensuring `cancel` is called is important. If you do not cancel a cancelable
    context, goroutines associated with that context will leak (i.e., there will be
    no way to terminate the goroutines and they will consume memory).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 确保调用 `cancel` 是很重要的。如果你没有取消一个可取消的上下文，与该上下文关联的 goroutines 将会泄漏（即，将无法终止这些 goroutines，它们将消耗内存）。
- en: Tip
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The `cancel` function can be called multiple times. Subsequent calls will be
    ignored.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel` 函数可以被多次调用。后续的调用将被忽略。'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`context.WithCancel` returns a new context and the `cancel` closure. The returned
    context is a cancelable context based on the original context:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.WithCancel` 返回一个新的上下文和 `cancel` 闭包。返回的上下文是基于原始上下文的一个可取消上下文：'
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use this context to control several goroutines:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个上下文来控制多个 goroutines：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also create other cancelable contexts based on a cancelable context:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以基于一个可取消的上下文创建其他可取消的上下文：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we have two cancelable contexts. Calling `cancel2` will only cancel `cancelableContext2`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个可取消的上下文。调用 `cancel2` 将只会取消 `cancelableContext2`：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Calling `cancel1` will cancel both `cancelableContext1` and `cancelableContext2`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `cancel1` 将会取消 `cancelableContext1` 和 `cancelableContext2`：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Context cancellation is not an automated way to cancel goroutines. You have
    to check for context cancellation and cleanup accordingly:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文取消不是自动取消goroutines的方式。您必须检查上下文取消并进行相应的清理：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using context for timeouts
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文进行超时
- en: A timeout is simply an automated cancellation. The context will cancel after
    a timer expires. This is useful in limiting resource consumption for computations
    that are not likely to finish.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 超时简单来说就是自动取消。上下文将在计时器到期后取消。这在限制不太可能完成的计算的资源消耗时很有用。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These are the steps to create a context with timeout and to detect when a timeout
    event happens:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有超时并检测超时事件发生的步骤如下：
- en: 'Use `context.WithTimeout` to create a new cancelable context that will auto-cancel
    after a given duration based on an existing context and a cancellation function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `context.WithTimeout` 创建一个新的可取消上下文，该上下文将在给定持续时间后自动取消，基于现有上下文和取消函数：
- en: '[PRE27]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Alternatively, you can use `WithDeadline` to cancel the context at a given moment.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `WithDeadline` 在指定时刻取消上下文。
- en: Make sure the `cancel` function is eventually called.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保最终调用 `cancel` 函数。
- en: 'Pass the timeout context to computations or goroutines that can time out:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将超时上下文传递给可能超时的计算或goroutine：
- en: '[PRE28]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the goroutine, check whether the context is canceled using the `ctx.Done()`
    channel or `ctx.Err()`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中，使用 `ctx.Done()` 通道或 `ctx.Err()` 检查上下文是否被取消：
- en: '[PRE29]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Alternatively, use the following:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，使用以下方法：
- en: '[PRE30]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To cancel a function manually, call the cancellation function:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要手动取消函数，请调用取消函数：
- en: '[PRE31]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Ensure the `cancel` function is called eventually (use `defer cancel()`):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保最终调用 `cancel` 函数（使用 `defer cancel()`）：
- en: '[PRE32]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The timeout feature is simply cancellation with an attached timer. When the
    timer expires, the context is canceled.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 超时功能简单来说就是附加了计时器的取消。当计时器到期时，上下文将被取消。
- en: There’s more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There may be situations where a goroutine blocks without any obvious way to
    cancel it. For instance, you may block waiting to read from a network connection:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在goroutine阻塞而没有明显取消方法的情况。例如，您可能阻塞等待从网络连接读取：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This operation cannot be canceled, because `Read` does not take `Context`.
    If you want to cancel such an operation, you can close the underlying connection
    (or file) asynchronously. The following code snippet demonstrates a use case where
    all data from a connection must be read within one second, or a goroutine will
    close the connection asynchronously:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作无法取消，因为 `Read` 不接受 `Context`。如果您想取消此类操作，可以异步关闭底层连接（或文件）。以下代码片段演示了一个用例，其中必须在1秒内读取连接的所有数据，否则goroutine将异步关闭连接：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using cancellations and timeouts in servers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器中使用取消和超时
- en: Network servers usually start a new context when a new request is received.
    Usually, the server cancels the context when the requester closes the connection.
    Most HTTP frameworks, including the standard library, follow this basic pattern.
    If you are writing your own TCP server, you have to implement it yourself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器通常在接收到新请求时启动一个新的上下文。通常，服务器在请求者关闭连接时取消上下文。大多数HTTP框架，包括标准库，都遵循这个基本模式。如果您正在编写自己的TCP服务器，您必须自己实现它。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'These are the steps to handle network connections with a timeout or cancellation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 处理具有超时或取消的网络连接的步骤如下：
- en: 'When you accept a network connection, create a new context with a cancellation
    or timeout:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您接受网络连接时，创建一个新的带有取消或超时的上下文：
- en: Ensure the context is canceled eventually.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保上下文最终被取消。
- en: 'Pass the context to the handler:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上下文传递给处理器：
- en: '[PRE35]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
