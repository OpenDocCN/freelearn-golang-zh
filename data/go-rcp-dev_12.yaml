- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Processes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: 'This chapter has recipes that show how to run external programs, how to interact
    with them, and how to terminate a process gracefully. There are some key points
    to keep in mind when dealing with external processes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了如何运行外部程序、如何与它们交互以及如何优雅地终止进程的食谱。在处理外部进程时，以下是一些需要记住的关键点：
- en: When you start an external process, it runs concurrently with your program.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你启动一个外部进程时，它与你的程序并发运行。
- en: If you need to communicate with a child process, you have to use an interprocess
    communication mechanism, such as pipes.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要与子进程通信，你必须使用进程间通信机制，例如管道。
- en: When you run a child process, its standard input and standard output streams
    appear to the parent process as independent concurrent streams. You cannot rely
    on the ordering of data you receive from these streams.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你运行一个子进程时，它的标准输入和标准输出流对父进程来说似乎是独立的并发流。你不能依赖从这些流中接收到的数据的顺序。
- en: 'This section covers the following main recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了以下主要食谱：
- en: Running external programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行外部程序
- en: Passing arguments to a process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向进程传递参数
- en: Processing output from a child process using a pipe
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道处理子进程的输出
- en: Providing input to a child process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向子进程提供输入
- en: Changing environment variables of a child process
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改子进程的环境变量
- en: Graceful termination using signals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号优雅地终止
- en: Running external programs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行外部程序
- en: There are many use cases where you want to execute an external program to perform
    a task. Usually, this is because performing the same task within your own program
    is not possible or not easy. For example, you may choose to execute several instances
    of an external image processing program to modify a group of images. Another use
    case is when you want to configure some device using programs provided by its
    manufacturer. This recipe includes several ways to execute external programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用例，你想要执行外部程序以执行任务。通常，这是因为在你自己的程序中执行相同的任务是不可能的或不容易的。例如，你可能选择执行多个外部图像处理程序的实例来修改一组图像。另一个用例是当你想使用制造商提供的程序配置某些设备时。本食谱包括执行外部程序的几种方法。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Use `exec.Command` or `exec.CommandContext` to run another program from your
    program. `exec.Command` is appropriate if you do not need to cancel (kill) the
    child process or impose a timeout. Otherwise, use `exec.CommandContext`, and cancel
    or time out the context to kill the child process:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exec.Command` 或 `exec.CommandContext` 从你的程序中运行另一个程序。如果不需要取消（终止）子进程或设置超时，则
    `exec.Command` 是合适的。否则，使用 `exec.CommandContext`，并取消或超时上下文来终止子进程：
- en: 'Create the `exec.Command` (or `exec.CommandContext`) object using the name
    of the program and its arguments:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用程序名称及其参数创建 `exec.Command`（或 `exec.CommandContext`）对象：
- en: If you need to search the program in the platform’s executable commands path,
    do not include any path separators
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要在平台的可执行命令路径中搜索程序，不要包含任何路径分隔符
- en: If you use path separators in the program name, it must be a path relative to
    `exec.Command.Dir`, or if `exec.Command.Dir` is empty, it must be a path relative
    to the current working directory
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在程序名称中使用路径分隔符，它必须是相对于 `exec.Command.Dir` 的路径，或者如果 `exec.Command.Dir` 为空，它必须是相对于当前工作目录的路径
- en: Use an absolute path if you know where the executable is
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道可执行文件的位置，请使用绝对路径
- en: Prepare the input and output streams to capture program output, or to send input
    via the standard input stream.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备输入和输出流以捕获程序输出，或通过标准输入流发送输入。
- en: Start the program.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动程序。
- en: Wait for the program to end.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待程序结束。
- en: 'The following example builds a Go program using the `go` command under the
    `sub/` directory:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在 `sub/` 目录下使用 `go` 命令构建一个 Go 程序：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above example will collect the process output as a combined string. The
    standard output and standard error from the program will be returned as a single
    string, so you have no way of identifying what parts of the output string came
    from standard output and what parts from standard error. Make sure you can parse
    the output correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将收集进程输出作为一个合并的字符串。程序的标准输出和标准错误将作为一个字符串返回，因此你无法识别输出字符串的哪些部分来自标准输出，哪些来自标准错误。确保你可以正确解析输出。
- en: Warning
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The standard output and standard error streams of a process are independent
    concurrent streams. In general, there is no portable way to determine which stream
    produced output first. This may have serious implications. For example, suppose
    you executed a program that produces a stream of lines on stdout, but whenever
    it detects an error, it prints a message to standard error that is something like
    “`last printed line has problems`.” But when you read the error in your program,
    the last printed line may not have arrived in your program yet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的标准输出和标准错误流是独立的并发流。通常，没有可移植的方法来确定哪个流首先产生了输出。这可能会产生严重的影响。例如，假设您执行了一个程序，该程序在`stdout`上产生一系列行，但每当它检测到错误时，它会将类似于“`最后打印的行有问题`”的消息打印到标准错误。但是当您在程序中读取错误时，最后打印的行可能还没有到达您的程序。
- en: 'The following program demonstrates the use of `exec.CommandContext` and pipes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序演示了`exec.CommandContext`和管道的使用：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous example taps into the standard output and standard error outputs
    of the child process. Note that the program starts reading from the `stderr` stream
    before the program starts. That goroutine will block until the child process outputs
    an error or until the child process terminates, at which point, the `stderr` pipe
    will be closed and the goroutine will terminate. The part that reads from the
    standard output runs in the main goroutine, before `cmd.Wait`. This ordering is
    important. If the child process starts producing output on `stdout` but the parent
    program is not listening, the child process will block. Calling `cmd.Wait` at
    this point would create a deadlock, but the runtime cannot detect this as such
    because the parent program is reliant on the behavior of the child.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子利用了子进程的标准输出和标准错误输出。请注意，程序在程序开始之前就开始从`stderr`流读取。那个goroutine将阻塞，直到子进程输出错误或子进程终止，此时`stderr`管道将关闭，goroutine将终止。从标准输出读取的部分在主goroutine中运行，在`cmd.Wait`之前。这种顺序很重要。如果子进程开始在`stdout`上产生输出，但父程序没有监听，子进程将阻塞。在此处调用`cmd.Wait`将创建死锁，但运行时无法检测到这一点，因为父程序依赖于子程序的行为。
- en: 'You can assign the same stream to `stdout` and `stderr` of the child process,
    as shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将相同的流分配给子进程的`stdout`和`stderr`，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding approach is similar to running the child process with `CombinedOutput`.
    Assigning `cmd.Stdout` and `cmd.Stderr` to the same stream has the same effect
    as combining both outputs of the child process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法与使用`CombinedOutput`运行子进程类似。将`cmd.Stdout`和`cmd.Stderr`分配到同一流具有将子进程的输出合并在一起的效果。
- en: Passing arguments to a process
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向进程传递参数
- en: The mechanics of passing arguments to a child process can be confusing. Shell
    environments parse and expand process arguments. For example, a `*.txt` argument
    is replaced by a list of filenames matching that pattern, and each of those filenames
    becomes a separate argument. This recipe talks about how to pass such arguments
    to child processes correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数传递给子进程的机制可能会令人困惑。Shell环境会解析和展开进程参数。例如，一个`*.txt`参数会被替换为匹配该模式的文件名列表，并且每个文件名都成为一个单独的参数。本食谱讨论了如何正确地将此类参数传递给子进程。
- en: There are two options to pass arguments to a child process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将参数传递给子进程。
- en: Expanding arguments
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展参数
- en: The first option is to perform the shell argument processing manually.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选择是手动执行shell参数处理。
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To manually perform shell processing, follow these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动执行shell处理，请按照以下步骤进行：
- en: 'Remove shell-specific quoting from arguments, such as the shell command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从参数中移除shell特定的引号，例如以下shell命令：
- en: The `./prog "test` `directory"` shell command becomes `cmd:=exec.Command("./prog","test
    directory")`.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./prog "test` `directory"` shell命令变为`cmd:=exec.Command("./prog","test directory")`。'
- en: The `./prog dir1 "long dir name" '"quoted name"'` Bash command becomes `cmd:=exec.Command("./prog",
    "long dir name", "'\"quoted name\"'")`. Note the Bash-specific treatment of quotes.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./prog dir1 "long dir name" ''"quoted name"''` Bash命令变为`cmd:=exec.Command("./prog",
    "long dir name", "''\"quoted name\"''")`。注意Bash对引号的特定处理。'
- en: Expand the patterns. `./prog *.txt` becomes `cmd:=exec.Command("./prog",listFiles("*.txt")...)`,
    where `listFiles` is a function that returns a slice of filenames.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展模式。`./prog *.txt`变为`cmd:=exec.Command("./prog",listFiles("*.txt")...)`，其中`listFiles`是一个返回文件名切片的函数。
- en: Tip
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Passing a list of files separated by a space will pass them as a single argument.
    That is, `cmd:=exec.Command("./prog","file1.txt file2.txt")` will pass a single
    argument to the process, which is `file1.txt file2.txt`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过空格分隔的文件列表作为单个参数传递。也就是说，`cmd:=exec.Command("./prog","file1.txt file2.txt")`将向进程传递单个参数，即`file1.txt
    file2.txt`。
- en: Substitute the environment variables. `/.prog $HOME` becomes `cmd:=exec.Command("./prog",
    os.Getenv("HOME"))`. Running `cmd:=exec.Command("./prog", "$HOME")` will pass
    the string `$HOME` to the program, not its value from the environment.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换环境变量。`/.prog $HOME`变为`cmd:=exec.Command("./prog", os.Getenv("HOME"))`。运行`cmd:=exec.Command("./prog",
    "$HOME")`将字符串`$HOME`传递给程序，而不是其环境中的值。
- en: Finally, you have to manually process pipelines. That is, for a `./prog >output.txt`
    shell command, you have to run `cmd:=exec.Command("./prog")`, create an `output.txt`
    file, and set `cmd.Stdout=outputFile`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您必须手动处理管道。也就是说，对于`./prog >output.txt`的shell命令，您必须运行`cmd:=exec.Command("./prog")`，创建一个`output.txt`文件，并将`cmd.Stdout=outputFile`。
- en: Running the command via the shell
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过shell运行命令
- en: The second option is to run the program via a shell.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是通过shell运行程序。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the platform-specific shell and its syntax to run a command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定平台的shell及其语法来运行命令：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This example selects `cmd` for Windows platforms, `/bin/sh` for Darwin (Mac),
    `/bin/bash` for Linux, and `/bin/sh` for anything else. The command passed to
    the shell contains a redirection, which is handled by the shell. The output of
    the command will be written to `test.txt`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例为Windows平台选择`cmd`，Darwin（Mac）选择`/bin/sh`，Linux选择`/bin/bash`，其他任何平台选择`/bin/sh`。传递给shell的命令包含一个重定向，由shell处理。命令的输出将被写入到`test.txt`文件中。
- en: Processing output from a child process using a pipe
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道处理子进程的输出
- en: Remember that the standard output and standard error streams of a process are
    concurrent streams. If the output generated by the child process is potentially
    unbounded, you can work with it in a separate goroutine. This recipe shows how.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，进程的标准输出和标准错误流是并发流。如果子进程生成的输出可能是无界的，您可以在单独的goroutine中处理它。这个示例展示了如何做。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'A few words about pipes. A pipe is a stream-based analog of a Go channel. It
    is a **first-in, first-out** (**FIFO**) communication mechanism with two ends:
    a writer and a reader. The reader side blocks until the writer writes something,
    and the writer side blocks until the reader reads from it. When you are done with
    a pipe, you close the writer side, which also closes the reader side of the pipe.
    This happens when a child process terminates. If you close the reader side of
    a pipe and then write to it, the program will receive a signal and possibly terminate.
    This happens if the parent program terminates before the child does.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于管道的一些话。管道是Go通道的基于流的类似物。它是一个**先进先出**（**FIFO**）的通信机制，有两个端点：一个写入器和一个读取器。读取器端在写入器写入内容之前阻塞，写入器端在读取器读取内容之前阻塞。当您完成管道时，您关闭写入器端，这也会关闭管道的读取器端。这发生在子进程终止时。如果您关闭管道的读取器端然后写入它，程序将收到信号并可能终止。如果父程序在子程序之前终止，就会发生这种情况。
- en: 'Create the command, and get its `StdoutPipe`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建命令，并获取其`StdoutPipe`：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new goroutine and read from the stdout of the child process. Work
    with the output of the child process in this goroutine:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的goroutine并从子进程的stdout读取。在这个goroutine中处理子进程的输出：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Start the process:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Wait for the process to end:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待进程结束：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Providing input to a child process
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向子进程提供输入
- en: 'There are two methods you can use to provide input to a child process: set
    `cmd.Stdin` to a stream or use `cmd.StdinPipe` to obtain a writer to send the
    input to the child process.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用两种方法向子进程提供输入：将`cmd.Stdin`设置为流或使用`cmd.StdinPipe`获取发送输入到子进程的写入器。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建命令：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Provide the input to the process by setting the `Stdin` stream:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置`Stdin`流为进程提供输入：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the program and wait for it to end:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并等待其结束：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternatively, you can provide a streaming input using a pipe.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用管道提供流式输入。
- en: 'Create the command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建命令：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Get the input pipe:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取输入管道：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Send the input to the program through the pipe. When done, close the pipe:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过管道将输入发送到程序。完成后，关闭管道：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the program and wait for it to end:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并等待其结束：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Changing environment variables of a child process
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改子进程的环境变量
- en: Environment variables are key-value pairs associated with a process. They are
    useful for passing information specific to the environment, such as the current
    user’s home directory, executable search path, configuration options, and more.
    In containerized deployments, environment variables are a convenient way to pass
    the credentials a program needs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是与进程相关联的键值对。它们对于传递特定于环境的信息非常有用，例如当前用户的家目录、可执行搜索路径、配置选项等。在容器化部署中，环境变量是传递程序所需凭证的便捷方式。
- en: The environment variables for a process are provided by its parent process,
    but once the process starts, a copy of those provided environment variables is
    assigned to the child process. Because of this, a parent process cannot change
    the environment variables of its child process after the child starts running.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的环境变量由其父进程提供，但一旦进程开始，就会为子进程分配提供的环境变量的副本。因此，父进程在子进程开始运行后不能更改其子进程的环境变量。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To use the same environment variables as the current process when launching
    a child process, set `Command.Env` to `nil`. That will copy the current process
    environment variables to the child.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当启动子进程时，要使用与当前进程相同的环境变量，请将 `Command.Env` 设置为 `nil`。这将复制当前进程的环境变量到子进程中。
- en: 'To start the child process using additional environment variables, append those
    new variables to the current process variables:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用额外的环境变量启动子进程，将这些新变量追加到当前进程变量中：
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Graceful termination using signals
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号进行优雅终止
- en: 'To gracefully terminate a program, you should do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要优雅地终止程序，你应该执行以下操作：
- en: No longer accept new requests
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不再接受新的请求
- en: Finish any requests that are accepted but not completed
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成已接受但未完成的任何请求
- en: Allow a certain amount of time for any long-running processes to finish, and
    terminate them if they cannot be completed in the given time
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许一定的时间让任何长时间运行的过程完成，如果它们在给定时间内无法完成，则终止它们
- en: Graceful termination is especially important in cloud-based service development
    because most cloud services are ephemeral and they get replaced by new instances
    often. This recipe shows how it can be done.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于云的服务开发中，优雅终止尤为重要，因为大多数云服务都是短暂的，并且经常被新的实例所取代。这个配方展示了如何实现它。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Handle interrupt and termination signals. An interrupt signal (`SIGINT`) is
    usually initiated by the user (for instance, by pressing *Ctrl* + *C*), and a
    termination signal (`SIGTERM`) is usually initiated by the host operating system,
    or for a containerized environment, the container orchestration system.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理中断和终止信号。中断信号（`SIGINT`）通常由用户发起（例如，通过按下 *Ctrl* + *C*），而终止信号（`SIGTERM`）通常由宿主操作系统发起，或者在容器化环境中，由容器编排系统发起。
- en: Disable acceptance of any new requests.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁止接受任何新的请求。
- en: Wait for existing requests to complete with a timeout
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待现有请求完成，并设置超时
- en: Terminate the process.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止进程。
- en: 'An example is shown next. This is a simple HTTP echo server. When the program
    starts, it creates a goroutine that listens to a channel responding to `SIGINT`
    and `SIGTERM` signals. When any one of these signals is received, it shuts down
    the server (which first disables the acceptance of new requests, and then waits
    for the existing requests to complete up to a timeout), which then terminates
    the program:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了如何操作。这是一个简单的HTTP回显服务器。当程序启动时，它创建一个goroutine，监听响应 `SIGINT` 和 `SIGTERM`
    信号的通道。当接收到这些信号中的任何一个时，它会关闭服务器（首先禁止单新请求的接受，然后等待现有请求完成，直到超时），然后终止程序：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
