- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Streaming Input/Output
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式输入/输出
- en: 'There is flexibility and elegance in simplicity. Unlike several languages that
    decided to implement a feature-rich streaming framework, Go chose a simple capability-based
    approach: a reader is something from which you read bytes, and a writer is something
    to which you write bytes. In-memory buffers, files, network connections, and so
    on are all readers and writers, defined by `io.Reader` and `io.Writer`. A file
    is also an `io.Seeker`, as you can randomly change the reading/writing location,
    but a network connection is not. A file and a network connection can be closed,
    so they are both `io.Closer`, but a memory buffer is not. Such simple and elegant
    abstractions are the key to writing algorithms that can be used in different contexts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性中蕴含着灵活性和优雅。与决定实现功能丰富的流式框架的几种语言不同，Go选择了简单的基于能力的途径：读取器是从中读取字节的东西，写入器是写入字节的东西。内存缓冲区、文件、网络连接等都是读取器和写入器，由`io.Reader`和`io.Writer`定义。文件也是一个`io.Seeker`，因为你可以随机更改读取/写入位置，但网络连接不是。文件和网络连接可以被关闭，因此它们都是`io.Closer`，但内存缓冲区不是。这种简单而优雅的抽象是编写可用于不同上下文的算法的关键。
- en: 'In this chapter, we will look at some recipes showing how this capability-based
    streaming framework can be used idiomatically. We will also look at how to work
    with files and the filesystem. The recipes covered in this chapter are in the
    following main sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些示例，展示如何惯用性地使用这种基于能力的流式框架。我们还将探讨如何处理文件和文件系统。本章涵盖的食谱分为以下主要部分：
- en: Readers/writers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取器/写入器
- en: Working with files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件
- en: Working with binary data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理二进制数据
- en: Copying data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数据
- en: Working with the filesystem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件系统
- en: Working with pipes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理管道
- en: Readers/writers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取器/写入器
- en: Remember, Go uses a structural type system. This makes any data type that implements
    `Read([]byte) (int,error)` an `io.Reader`, and any data type that implements `Write([]byte)
    (int,error)` an `io.Writer`. There are many uses of this property in the standard
    library. In this recipe, we will look at some of the common uses of readers and
    writers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Go使用结构化类型系统。这使得任何实现了`Read([]byte) (int,error)`的数据类型都是`io.Reader`，任何实现了`Write([]byte)
    (int,error)`的数据类型都是`io.Writer`。标准库中有许多使用这个特性的例子。在本食谱中，我们将探讨读取器和写入器的常见用法。
- en: Reading data from a reader
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从读取器读取数据
- en: 'An `io.Reader` fills a byte slice you pass to it. By passing a slice, you actually
    pass two pieces of information: how much you want to read (the length of the slice)
    and where to put the data that was read (the underlying array of the slice).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Reader`填充你传递给它的字节切片。通过传递一个切片，你实际上传递了两条信息：你想要读取多少（切片的长度）以及将读取的数据放在哪里（切片的底层数组）。'
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a byte slice large enough to hold the data you want to read:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个足够大的字节切片以容纳你想要读取的数据：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Read the data into the byte slice:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据读取到字节切片中：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check how much was read. The number of bytes actually read may be smaller than
    the buffer size:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查读取了多少。实际读取的字节数可能小于缓冲区大小：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check the error. If the error is `io.EOF`, then the reader reached the end
    of the stream. If the error is something else, handle the error or return it:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查错误。如果错误是`io.EOF`，则表示读取器已到达流末尾。如果错误是其他内容，则处理错误或返回它：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the ordering of *steps 3* and *4*. Returning `io.EOF` is not necessarily
    an error, it simply means the end of the file has been reached or the network
    connection has been closed, so you should stop reading. There is probably some
    data read in the buffer, and you should process that data. The reader returns
    how much data was read.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意步骤*3*和*4*的顺序。返回`io.EOF`不一定是错误，它仅仅意味着已到达文件末尾或网络连接已关闭，因此你应该停止读取。缓冲区中可能还有一些数据被读取，你应该处理这些数据。读取器返回读取的数据量。
- en: Writing data to a writer
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据写入写入器
- en: 'Encode the data you want to write as a byte slice; for instance, use `json.Marshal`
    to get the JSON representation of your data as a `[]byte`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要写入的数据编码为字节切片；例如，使用`json.Marshal`将你的数据编码为`[]byte`形式的JSON表示：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Write the encoded data:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入编码后的数据：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Check and handle errors.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查并处理错误。
- en: Warning
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Unlike a reader, all errors returned from a writer should be treated as errors.
    A writer does not return `io.EOF`. Even when there is an error, a write may have
    written some part of the data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与读取器不同，所有来自写入器的错误都应被视为错误。写入器不返回`io.EOF`。即使有错误，写入也可能已写入数据的一部分。
- en: Reading from and writing to a byte slice
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字节切片读取和写入
- en: A reader or a writer does not have to be a file or a network connection. This
    section shows how you can work with byte slices as readers and writers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器或写入器不一定是文件或网络连接。本节展示了如何将字节切片作为读取器和写入器进行操作。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a reader from a `[]byte`, use `bytes.NewReader`. The following example
    marshals a data structure to JSON (which returns a `[]byte`), then sends that
    `[]byte` to an HTTP `POST` request by creating a reader from it:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从一个`[]byte`创建一个读取器，使用`bytes.NewReader`。以下示例将一个数据结构序列化为JSON（返回一个`[]byte`），然后通过从它创建一个读取器将这个`[]byte`发送到HTTP
    `POST`请求：
- en: '[PRE6]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To use a `[]byte` as a writer, use `bytes.Buffer`. The buffer will append to
    the underlying byte slice as you write to it. When you are done, you can get the
    contents of the buffer:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将`[]byte`用作写入器，使用`bytes.Buffer`。缓冲区会在你写入时追加到底层的字节切片。当你完成时，你可以获取缓冲区的内容：
- en: '[PRE7]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `bytes.Buffer` is also an `io.Reader`, with a separate read location. Writing
    to a `bytes.Buffer` appends to the end of the underlying slice. Reading from a
    `bytes.Buffer` starts reading from the beginning of the underlying slice. Because
    of this, you can read the bytes you wrote, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes.Buffer`也是一个`io.Reader`，具有单独的读取位置。写入`bytes.Buffer`将追加到底层的切片末尾。从`bytes.Buffer`读取将从底层切片的开始读取。因此，你可以读取你写入的字节，如下所示：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Reading from and writing to a string
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从字符串读取和写入
- en: 'To create a reader from a string, use `strings.NewReader`, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个字符串创建一个读取器，使用`strings.NewReader`，如下所示：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Do *not* use `bytes.NewReader([]byte(stringValue))` instead of `strings.NewReader(stringValue)`.
    The former copies the contents of the string to create a byte slice. The latter
    accesses the underlying bytes without copying.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`bytes.NewReader([]byte(stringValue))`代替`strings.NewReader(stringValue)`。前者将字符串的内容复制到创建的字节切片中。后者不复制直接访问底层字节。
- en: 'To use a string as an `io.Writer`, use `strings.Builder`. For instance, as
    an `io.Writer`, `strings.Builder` can be passed to the `fmt.Fprint` family of
    functions:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串用作`io.Writer`，使用`strings.Builder`。例如，作为`io.Writer`，`strings.Builder`可以被传递给`fmt.Fprint`函数族：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理
- en: 'Files are simply sequences of bytes on a storage system. There are two ways
    of working with files: as a random access byte sequence or as a stream of bytes.
    We will look at both types of recipes in this section.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在存储系统上只是字节序列的简单集合。有两种处理文件的方式：作为随机访问的字节序列或作为字节流。我们将在本节中查看这两种类型的配方。
- en: Creating and opening files
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和打开文件
- en: To work with the contents of a file, you first have to open it or create it.
    This recipe shows how that can be done.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理文件的内容，你首先必须打开它或创建它。这个配方展示了如何做到这一点。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To open an existing file for reading, use `os.Open`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个现有文件进行读取，使用`os.Open`：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can read data from the returned file object, and when you are done, you
    should close it using `file.Close()`. So, you can use it as an `io.Reader` or
    `io.ReadCloser` (there are more interfaces that `*``os.File` implements!)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从返回的文件对象中读取数据，完成后，你应该使用`file.Close()`关闭它。因此，你可以将其用作`io.Reader`或`io.ReadCloser`（`*os.File`实现了更多接口！）
- en: If you attempt to write to the file, you will receive an error from the write
    operation. On my Linux system, this error is a `*fs.PathError` message saying
    `bad` `file descriptor`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试写入文件，你将收到一个来自写入操作的错误。在我的Linux系统中，这个错误是一个`*fs.PathError`消息，表示`bad` `file
    descriptor`。
- en: 'To create a new file or to overwrite an existing one, use `os.Create`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新文件或覆盖现有文件，使用`os.Create`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the above call is successful, the returned file can be read from or written
    to. The file is created with `0o666 & ^umask`. If the file already existed before
    this call, it will be truncated to a length of `0`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述调用成功，返回的文件可以读取或写入。文件是用`0o666 & ^umask`创建的。如果在此调用之前文件已经存在，它将被截断到长度为`0`。
- en: Tip
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`umask` defines the set of permissions applications cannot set on files. In
    the preceding text, `0o666` means that the owner, group, and others can read and
    write the file. A `umask` value of `0o022`, for instance, will change the file
    mode from `0o666` to `0o644`, which means the owner can read and write, but the
    group and others can only read.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`umask`定义了应用程序不能设置在文件上的权限集合。在前面文本中，`0o666`表示所有者、组和其他人都可以读取和写入文件。例如，`0o022`的`umask`值将文件模式从`0o666`更改为`0o644`，这意味着所有者可以读取和写入，但组和其他人只能读取。'
- en: 'To open an existing file for reading/writing, use `os.OpenFile`. This is the
    most general form of the open/create family of functions:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开一个现有文件进行读取/写入，使用`os.OpenFile`。这是open/create函数族中最通用的形式：
- en: 'To open an existing file for both reading and writing, use the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以读写模式打开一个现有文件，请使用以下方法：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The last argument is `0`. This argument is only used when creating the file
    is an option. We will see this case later shortly.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个参数是`0`。这个参数仅在创建文件是一个选项时使用。我们将在稍后看到这个情况。
- en: 'To open an existing file for reading only, use the following:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以只读模式打开一个现有文件，请使用以下方法：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To open an existing file for writing only, use the following:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以只写模式打开一个现有文件，请使用以下方法：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To open an existing file for appending only, use the following:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以追加模式打开一个现有文件，请使用以下方法：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Trying to write somewhere other than the end of the file will fail.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试在文件末尾之外的地方写入将会失败。
- en: 'To open an existing file or to create one if it does not exist, use the following:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要打开一个现有文件或创建一个如果它不存在，请使用以下方法：
- en: '[PRE17]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The above operation will open the file for reading and writing if it exists.
    If the file does not exist, it will be created using the `0o644 & ^umask` permission
    bits. `0o644` means the owner can read/write (`06`), users from the same group
    can read (`04`), and other users can read (`04`).
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述操作将在文件存在时打开文件以供读写。如果文件不存在，它将使用`0o644 & ^umask`权限位创建。`0o644`意味着所有者可以读写（`06`），同一组的用户可以读（`04`），其他用户可以读（`04`）。
- en: 'The following is equivalent to `os.Create`; that is, truncate and open the
    file if it exists but create if it does not:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下与`os.Create`等价；即，如果文件存在则截断并打开，如果不存在则创建：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you want to create the file only if it does not exist, use the “exclusive”
    bit:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在文件不存在时创建文件，请使用“独占”位：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This call will fail if the file already exists.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已经存在，这个调用将会失败。
- en: Tip
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: This is a common way of ensuring a single instance of a process is running,
    or to lock a resource if it is not locked. For instance, if you want to lock a
    directory, you can use this call to create a lock file. It will fail if some other
    process already locked it (created the file before you.)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种常见的确保一个进程实例正在运行的方法，或者在没有锁定资源的情况下锁定资源。例如，如果你想锁定一个目录，你可以使用这个调用来创建一个锁文件。如果其他进程已经锁定了它（在你之前创建了文件），那么它将会失败。
- en: Closing a file
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭文件
- en: 'There are two reasons why you should always explicitly close files you open:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终显式关闭你打开的文件有两个原因：
- en: All data stored in buffers are flushed when you close the file.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你关闭文件时，所有存储在缓冲区中的数据都会被刷新。
- en: There are limits to how many files you can keep open at any given time. These
    limits change from platform to platform.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在任何给定时间可以保持打开的文件数量是有限的。这些限制因平台而异。
- en: The following steps show how you can do this consistently.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了如何始终如一地完成这项操作。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When you are done working with a file, close it. Use `defer file.Close()` where
    possible:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成与文件的交互后，请关闭它。尽可能使用`defer file.Close()`：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Do *not* rely on `defer` if you are working with many files. Do not do this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理许多文件，不要依赖`defer`。不要这样做：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Deferred calls will execute when the function returns, not when the block in
    which you used them ends. The above code will keep all the files open until the
    function returns, and if there is a large number of files, `os.Open` will start
    failing once you pass the open file limit. You can do one of two things. The first
    is to explicitly close the file for all exit points:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟调用将在函数返回时执行，而不是在你使用它们的代码块结束时执行。上述代码将保持所有文件打开，直到函数返回，如果文件数量很多，一旦超过打开文件限制，`os.Open`将会开始失败。你可以做两件事之一。第一是显式关闭所有退出点的文件：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second is to use a closure with `defer`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用带有`defer`的闭包：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Files are garbage collected. If you open/create files and then work with file
    descriptors directly instead of using `*os.File`, the garbage collector is not
    your friend. Use `runtime.KeepAlive(file)` to prevent the garbage collector from
    closing the file while you’re working with it through the file descriptor and/or
    syscalls. Avoid relying on the garbage collector to close your files. Always close
    files explicitly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文件会被垃圾回收。如果你打开/创建文件然后直接使用文件描述符而不是使用`*os.File`来工作，垃圾回收器就不会是你的朋友。使用`runtime.KeepAlive(file)`来防止垃圾回收器在你通过文件描述符和/或系统调用与之交互时关闭文件。避免依赖垃圾回收器来关闭你的文件。始终显式关闭文件。
- en: Reading/writing data from/to files
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从/向文件读取/写入数据
- en: When you open a file for reading and writing, the operating system keeps the
    `0`. Then if you read 10 bytes from the file, the current location becomes `10`
    (assuming the file is larger than 10 bytes). The next time you read from the file
    or write to it, you will read the contents or write starting from an offset of
    `10`. Keep this behavior in mind, especially if you are mixing reads and writes
    to a file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您以读取和写入方式打开文件时，操作系统会保留 `0`。然后如果您从文件中读取 10 个字节，当前位置将变为 `10`（假设文件大于 10 个字节）。下次您从文件中读取或写入时，您将从偏移量
    `10` 开始读取内容或写入。请记住这种行为，特别是如果您正在对文件进行读写混合操作。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To read some data starting from the current location, use `file.Read`:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从当前位置读取一些数据，请使用 `file.Read`：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The ordering of checking for `n` (the number of bytes read) and checking whether
    there was an error is important. An `io.Reader` may do a partial read and return
    the number of bytes read along with an error. That error may be `io.EOF`, signifying
    that the file has less data than you attempted to read. For instance, a file with
    10 bytes will return `n=10` and `err=io.EOF`. Also note that this behavior is
    dependent on the current location of the file. The following code segment reads
    the file as a slice of byte slices:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 `n`（读取的字节数）和检查是否有错误顺序很重要。`io.Reader` 可能会进行部分读取并返回读取的字节数以及一个错误。这个错误可能是 `io.EOF`，表示文件中的数据少于您尝试读取的数据。例如，一个包含
    10 个字节的文件将返回 `n=10` 和 `err=io.EOF`。还请注意，这种行为取决于文件当前的位置。以下代码段将文件作为字节切片的切片读取：
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the current location in the file is `0` when the preceding code begins, after
    every read operation, the current location will progress by `n`. Note that all
    the byte slices will be `1024` bytes except the last. The last slice can be anywhere
    from `1` to `1024` bytes, depending on the file size.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果在先前的代码开始时文件中的当前位置是 `0`，则在每次读取操作后，当前位置将前进 `n`。请注意，除了最后一个之外，所有的字节切片都是 `1024`
    字节。最后一个切片的大小可以从 `1` 到 `1024` 字节不等，具体取决于文件大小。
- en: 'Writing to a file is done similarly:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入文件的操作类似：
- en: '[PRE26]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A write operation will not return `io.EOF`. If you write past the end of the
    file, the file will be enlarged to accommodate the written bytes. If the write
    operation cannot write all the given bytes, the error will always be non-nil,
    and you should check and handle the error.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写入操作不会返回 `io.EOF`。如果您写过了文件的末尾，文件将扩展以容纳写入的字节。如果写入操作不能写入所有给定的字节，错误始终是非空的，您应该检查并处理该错误。
- en: If the current location is `0` at the beginning, it will be `n` after the write
    operation.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果当前位置在开始时为 `0`，则在写入操作后它将是 `n`。
- en: 'To read everything from a file, use `os.ReadFile`:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从文件中读取所有内容，请使用 `os.ReadFile`：
- en: '[PRE27]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be careful when using `os.ReadFile`. It allocates a `[]byte` that is the size
    of the file. Use this function only if you are sure the file you are reading is
    of a reasonable size.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `os.ReadFile` 时要小心。它分配了一个大小与文件相同的 `[]byte`。只有当您确信您正在读取的文件大小合理时，才使用此函数。
- en: 'To read a large file in fixed-size chunks, allocate a fixed-size buffer and
    read iteratively until `io.EOF` is returned:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要以固定大小的块读取大文件，分配一个固定大小的缓冲区并迭代读取，直到返回 `io.EOF`：
- en: '[PRE28]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To write a byte slice to a new file, use `os.WriteFile`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将字节切片写入新文件，请使用 `os.WriteFile`：
- en: '[PRE29]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Reading/writing from/to a specific location
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从/到特定位置读取/写入
- en: We talked about the concept of the **current location** previously. This section
    is about moving the current location to start reading or writing from a random
    location in a file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了**当前位置**的概念。本节内容是关于将当前位置移动到文件的起始位置以进行读取或写入操作。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You may change the current location using `File.Seek`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `File.Seek` 来更改当前位置。
- en: 'To set the current location relative to the beginning of the file, use the
    following:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将当前位置相对于文件开头设置，请使用以下方法：
- en: '[PRE30]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The returned `newLocation` is the new current location of the file. Subsequent
    read or write operations will read from or write to that location.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回的 `newLocation` 是文件的新当前位置。后续的读取或写入操作将从该位置开始。
- en: 'To set the current location relative to the end of the file, use the following:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将当前位置相对于文件末尾设置，请使用以下方法：
- en: '[PRE31]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is also a quick way of determining the current file size, as `newLocation`
    is 0 bytes ahead of the end of the file.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也是一种快速确定当前文件大小的方法，因为 `newLocation` 在文件末尾之前是 0 字节。
- en: 'You can seek beyond the end of the file. Reading from such a location will
    read 0 bytes. Writing to such a location will extend the file size to accommodate
    the data written at that location:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定位到文件末尾之外的位置。从这样的位置读取将读取0字节。写入这样的位置将扩展文件大小以容纳在该位置写入的数据：
- en: '[PRE32]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you extend a file like this, the area between the end of the file and the
    newly written bytes is filled with 0s. The underlying platform may implement this
    as a **hole**; that is, the area that is not written may not be actually allocated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式扩展文件时，文件末尾和新增字节之间的区域会被填充为0s。底层平台可能会将其实现为一个**空洞**；也就是说，未写入的区域可能实际上并未分配。
- en: '`os.File` supports additional methods for such random access. `File.WriteAt`
    will write data to the given location (relative to the beginning of the file)
    without moving the current location. `File.ReadAt` will read from the given location
    without moving the current location:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.File`支持用于此类随机访问的附加方法。`File.WriteAt`将数据写入指定的位置（相对于文件开始的位置），而不会移动当前位置。`File.ReadAt`将从指定的位置读取，而不会移动当前位置：'
- en: '[PRE33]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Changing the file size
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变文件大小
- en: Extending a file is usually achieved by writing more data to the end of it,
    but how can you shrink an existing file? This recipe describes different ways
    to change the file size.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展文件通常是通过向其末尾写入更多数据来实现的，但如何缩小现有文件呢？这个配方描述了改变文件大小的不同方法。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To truncate a file to a size of `0`, you can open a file with the truncate
    flag:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将文件截断到`0`大小，你可以使用截断标志打开文件：
- en: '[PRE34]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the file is already open, you can use `File.Truncate` to set the file size.
    `File.Truncate` works both ways – you can extend a file or you can shrink it:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件已经打开，你可以使用`File.Truncate`来设置文件大小。`File.Truncate`具有双向功能——你可以扩展文件，也可以缩小它：
- en: '[PRE35]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also extend a file by appending to it. You can do this in one of two
    ways. You can open the file for append-only:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以通过追加内容来扩展文件。你可以通过两种方式之一来完成这个操作。你可以以追加模式打开文件：
- en: '[PRE36]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you open a file append-only, you cannot read/write from other locations of
    the file, you can only append to it.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你以追加模式打开文件，你不能从文件的其他位置进行读写，你只能追加到它。
- en: 'Alternatively, you can seek the end of the file and start writing there:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以定位到文件末尾并从那里开始写入：
- en: '[PRE37]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finding the file size
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找文件大小
- en: 'If the file is open, you can obtain the file size as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已打开，你可以按以下方式获取文件大小：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will return the current file size, including any data that was appended
    but not yet flushed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回当前文件大小，包括任何已追加但尚未刷新的数据。
- en: 'The above operation will move the file pointer to the end of the file. To preserve
    the current location, use the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将移动文件指针到文件末尾。为了保留当前位置，请使用以下方法：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the file is not open, use `os.Stat`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件未打开，请使用`os.Stat`：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have the file open and you appended data to the file, the file size reported
    by `os.Stat` may be different from the file size you obtained by `File.Seek`.
    The `os.Stat` function reads the file information from the directory. The `File.Seek`
    method uses process-specific file information that may not have been reflected
    in the directory entry yet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经打开了文件并向其中追加数据，`os.Stat`报告的文件大小可能与通过`File.Seek`获得的文件大小不同。`os.Stat`函数从目录中读取文件信息。`File.Seek`方法使用进程特定的文件信息，这些信息可能尚未反映在目录条目中。
- en: Working with binary data
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理二进制数据
- en: If you need to send a piece of data over a network connection or store it in
    a file, you first have to encode it (or serialize it, or marshal it.) This is
    necessary because the system at the other end of the network connection or the
    application that will read the file you wrote may be running on a different platform.
    A portable, easy-to-debug but not necessarily efficient way to do this is to use
    text-based encodings such as JSON. If performance is paramount or when the use
    case demands it, you use binary encoding.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要通过网络连接发送数据或将其存储在文件中，你首先必须对其进行编码（或序列化，或打包。）这是必要的，因为网络连接另一端的系统或将要读取你写入的文件的程序可能运行在不同的平台上。一种便携、易于调试但可能不是最高效的方法是使用基于文本的编码，如JSON。如果性能至关重要或使用场景要求这样做，你可以使用二进制编码。
- en: There are many high-level binary encoding schemes. Gob ([https://pkg.go.dev/encoding/gob](https://pkg.go.dev/encoding/gob))
    is a Go-specific encoding scheme that can be used for networking applications.
    Protocol buffers ([https://protobuf.dev](https://protobuf.dev)) provide a language-neutral,
    extensible, schema-driven mechanism for encoding structured data. There are more.
    Here, we will look at the basics of binary encoding that every software engineer
    should know about.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多高级的二进制编码方案。Gob ([https://pkg.go.dev/encoding/gob](https://pkg.go.dev/encoding/gob))
    是一种特定于 Go 的编码方案，可用于网络应用程序。协议缓冲区 ([https://protobuf.dev](https://protobuf.dev))
    提供了一种语言无关、可扩展、基于模式的机制，用于编码结构化数据。还有更多。在这里，我们将探讨每个软件工程师都应该了解的二进制编码基础知识。
- en: 'Encoding data involves transforming data elements into a stream of bytes. If
    you have a data element that is a single byte or a data element that is already
    a sequence of bytes, you can encode them verbatim. When working with multi-byte
    data types (`int16`, `int32`, `int64`, etc.), how you order those bytes becomes
    important. For example, if you have an `int16` value of `0xABCD`, how should you
    encode those bytes as a `[]byte`? There are two options:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编码数据涉及将数据元素转换成字节流。如果您有一个单字节的数据元素或已经是一系列字节的数据元素，您可以逐字编码它们。当处理多字节数据类型（`int16`、`int32`、`int64`
    等）时，字节顺序变得很重要。例如，如果您有一个 `int16` 值 `0xABCD`，您应该如何将这些字节编码为 `[]byte`？有两种选择：
- en: '`0xABCD` is encoded as `[]``byte{0xCD, 0xAB}`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xABCD` 被编码为 `[]``byte{0xCD, 0xAB}`'
- en: '`0xABCD` is encoded as `[]``byte{0xAB, 0xCD}`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xABCD` 被编码为 `[]``byte{0xAB, 0xCD}`'
- en: Similarly, a 32-bit integer, `0x01234567`, encoded in little-endian byte order
    gives `[]byte{0x67,0x45,0x23,0x01}` and encoded in big-endian byte ordering gives
    `[]byte{0x01,0x23,0x45,0x67}`. Most modern hardware uses little-endian byte ordering
    to represent values in memory. Network protocols (such as IP) tend to use big-endian.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一个 32 位整数，`0x01234567`，以小端字节序编码给出 `[]byte{0x67,0x45,0x23,0x01}`，以大端字节序编码给出
    `[]byte{0x01,0x23,0x45,0x67}`。大多数现代硬件使用小端字节序在内存中表示值。网络协议（如 IP）倾向于使用大端。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'There are two main approaches to encoding binary data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编码二进制数据主要有两种方法：
- en: The first is using a fixed structure. In this approach, the ordering and type
    of data fields are fixed. For instance, the IPv4 header defines where every header
    field starts and ends. There is no way to omit a field or add extensions in this
    approach. An example is shown in *Figure 14**.1*.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法是使用固定结构。在这种方法中，数据字段的顺序和类型是固定的。例如，IPv4 头部定义了每个头部字段开始和结束的位置。这种方法无法省略字段或添加扩展。一个例子在
    *图 14**.1* 中展示。
- en: '![Figure 14.1: Fixed-length encoding example](img/B21961_14_01.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1：固定长度编码示例](img/B21961_14_01.jpg)'
- en: 'Figure 14.1: Fixed-length encoding example'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1：固定长度编码示例
- en: The second is using a dynamic encoding scheme, such as `string` field, then
    the length, and then the string itself. An example TLV encoding scheme is shown
    in *Figure 14**.2*.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是使用动态编码方案，例如 `string` 字段，然后是长度，然后是字符串本身。一个 TLV 编码方案的例子在 *图 14**.2* 中展示。
- en: '![Figure 14.2: TLV encoding example](img/B21961_14_02.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2：TLV 编码示例](img/B21961_14_02.jpg)'
- en: 'Figure 14.2: TLV encoding example'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：TLV 编码示例
- en: This example uses 16-bit string length and 64-bit slice length encoding.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了 16 位字符串长度和 64 位切片长度编码。
- en: Use `encoding/binary` to encode data in big-endian or little-endian byte ordering.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `encoding/binary` 对数据进行大端或小端字节序编码。
- en: 'For fixed-length encoding, you can use `encoding.Write` to encode, and `encoding.Read`
    to decode data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于固定长度编码，您可以使用 `encoding.Write` 来编码，使用 `encoding.Read` 来解码数据：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This program outputs the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序输出以下内容：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Take special care when defining the `Data` structure. You cannot use variable
    length or platform-specific types if you want to use `encoding.Read` or `encoding.Write`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 `Data` 结构时，请特别注意。如果您想使用 `encoding.Read` 或 `encoding.Write`，则不能使用可变长度或平台特定的类型：
- en: No `int` because the size of `int` is platform-specific
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 `int`，因为 `int` 的大小是平台特定的
- en: No slices
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有切片
- en: No maps
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有映射
- en: No strings
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有字符串
- en: 'How can we encode these values, then? Let’s take a look at an LV encoding scheme
    to encode a string value:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编码这些值呢？让我们看看一个 LV 编码方案来编码一个字符串值：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is one to decode a string value:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个解码字符串值的例子：
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Copying data
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制数据
- en: '`io.Copy` reads data from a reader and writes it to a writer until one of the
    operations fails or the reader returns `io.EOF`. There are many use cases where
    you need to get chunks of data from a reader and send it to a writer. `io.Copy`
    works at an abstract layer that allows you to copy data from a file to a network
    connection, or from a string to a file. It also performs capability-based optimizations
    to minimize data copying. For instance, if the platform supports the splice system
    call, `io.Copy` can use it to bypass buffer usage. In this section, we will see
    some uses of `io.Copy`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy` 从读取器读取数据并将其写入写入器，直到其中一个操作失败或读取器返回 `io.EOF`。有许多需要从读取器获取数据块并将其发送到写入器的情况。`io.Copy`
    在一个抽象层上工作，允许您从文件复制数据到网络连接，或从字符串复制到文件。它还执行基于能力的优化以最小化数据复制。例如，如果平台支持 splice 系统调用，`io.Copy`
    可以使用它来绕过缓冲区使用。在本节中，我们将看到 `io.Copy` 的一些用法。'
- en: Copying files
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制文件
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To copy a file, follow these steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文件，请按照以下步骤操作：
- en: Open the source file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源文件。
- en: Create the target file.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建目标文件。
- en: Use `io.Copy` to copy data.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `io.Copy` 来复制数据。
- en: Close both files.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭两个文件。
- en: 'These steps are illustrated here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在此处展示：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Since `io.Copy` works with `io.Reader` and `io.Writer`, any object implementing
    these interfaces can be used as the source or the target. For example, the following
    code segment returns a file as a response to an HTTP request:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `io.Copy` 与 `io.Reader` 和 `io.Writer` 一起工作，任何实现这些接口的对象都可以用作源或目标。例如，以下代码段在
    HTTP 请求的响应中返回一个文件：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Working with the filesystem
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件系统
- en: There are many aspects of filesystems that are platform-specific. This section
    talks about portable ways of working with filesystems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统有许多方面是特定于平台的。本节讨论了在文件系统中使用便携式方法的讨论。
- en: Working with filenames
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理文件名
- en: Use `path/filepath` package to work with filenames in a portable way.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `path/filepath` 包以便携方式处理文件名。
- en: How do to it...
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To build a path from several path segments, use `filepath.Join`:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要从多个路径段构建路径，请使用 `filepath.Join`:'
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that `filepath.Join` does not allow consecutive separators, and interprets
    `".."` correctly.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`filepath.Join` 不允许连续的分隔符，并且正确解释 `".."`。
- en: 'To split a path to its directory and filename parts, use `filepath.Split`:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要将路径分割为其目录和文件名部分，请使用 `filepath.Split`:'
- en: '[PRE48]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Avoid using path separators (`/` and `\`) in your code. Use `filepath.Separator`,
    which is a platform-specific rune value.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在您的代码中使用路径分隔符（`/` 和 `\`）。使用 `filepath.Separator`，这是一个特定于平台的 rune 值。
- en: Creating temporary directories and files
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建临时目录和文件
- en: Sometimes, you will need to create unique directory names and filenames, mostly
    for temporary data.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要创建唯一的目录名和文件名，通常用于临时数据。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a temporary directory under the platform-specific default directory
    for temporary files, use `os.MkdirTemp("",prefix)`:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要在平台特定的默认临时文件目录下创建临时目录，请使用 `os.MkdirTemp("",prefix)`:'
- en: '[PRE49]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The created name is unique. If there are multiple calls to create a temporary
    directory, each will generate a unique name.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建的名称是唯一的。如果有多个调用创建临时目录，每个都会生成一个唯一的名称。
- en: 'To create a temporary directory under a specific directory, use `os.MkdirTemp(dir,prefix)`:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '要在特定目录下创建临时目录，请使用 `os.MkdirTemp(dir,prefix)`:'
- en: '[PRE50]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To create a temporary directory with the random part of the name not as a suffix,
    use `*`. The random string replaces the last `*` character:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个名称随机部分不是后缀的临时目录，请使用 `*`。随机字符串将替换最后一个 `*` 字符：
- en: '[PRE51]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To create a temporary file, use `os.CreateTemp`. A unique file is created and
    opened for reading and writing. The name of the created file can be obtained from
    the returned `file.Name` value:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建临时文件，请使用 `os.CreateTemp`。创建一个唯一的文件并打开以供读写。创建的文件名可以通过返回的 `file.Name` 值获得：
- en: '[PRE52]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Similar to `os.MkdirTemp`, if the filename contains `*`, a random string is
    inserted in place of the last `*` character. If the filename does not contain
    `*`, the random string is appended at the end of the name.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `os.MkdirTemp` 类似，如果文件名包含 `*`，则在最后一个 `*` 字符处插入随机字符串。如果文件名不包含 `*`，则随机字符串附加在名称的末尾。
- en: Reading directories
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取目录
- en: Use `os.ReadDir` to list or discover files under a directory.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `os.ReadDir` 列出或发现目录下的文件。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Call `os.ReadDir` to get the contents of a directory. This returns directory
    entries in order sorted by name:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `os.ReadDir` 获取目录的内容。这返回按名称排序的目录条目：
- en: '[PRE53]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You may notice that `os.ReadDir` is not your best bet if you are dealing with
    potentially large directories. It returns an unbounded slice, and it also spends
    time sorting it.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到，如果你处理的是可能非常大的目录，`os.ReadDir` 并不是你的最佳选择。它返回一个无界切片，并且它还花费时间进行排序。
- en: 'For performance and memory-conscious applications, open the directory and read
    it using `File.ReadDir`:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于性能和内存敏感的应用程序，打开目录并使用 `File.ReadDir` 读取它：
- en: '[PRE54]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To recursively iterate directory entries in a portable way, use `io.fs.WalkDir`.
    This function uses `"/"` as the path separator regardless of the platform. The
    following example prints all the files under `/tmp`, skipping directories:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可移植的方式递归迭代目录条目，请使用 `io.fs.WalkDir`。此函数无论在哪个平台上都使用 `"/"` 作为路径分隔符。以下示例打印出 `/tmp`
    下的所有文件，跳过目录：
- en: '[PRE55]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To recursively iterate directory entries, use `filepath.WalkDir`. This function
    uses a platform-specific path separator. The following example prints all directories
    under `/``tmp` recursively:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要递归迭代目录条目，请使用 `filepath.WalkDir`。此函数使用特定平台的路径分隔符。以下示例递归打印出 `/tmp` 下的所有目录：
- en: '[PRE56]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Working with pipes
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道进行工作
- en: If you have a piece of code that expects a reader and another piece of code
    that expects a writer, you can connect the two using `io.Pipe`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一段期望读取器的代码和另一段期望写入器的代码，你可以使用 `io.Pipe` 将它们连接起来。
- en: Connecting code expecting a reader with code expecting a writer
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将期望读取器的代码与期望写入器的代码连接起来
- en: A good example of this use case is preparing an HTTP `POST` request, which requires
    a reader. If you have all of the data available, or if you already have a reader
    (such as `os.File`), you can use that. However, if the data is produced by a function
    that takes a writer, use a pipe.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用例的一个好例子是准备一个 HTTP `POST` 请求，它需要一个读取器。如果你已经有了所有数据，或者如果你已经有了读取器（例如 `os.File`），你可以使用它。然而，如果数据是由一个接受写入器的函数产生的，请使用管道。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: A pipe is a synchronously connected reader and writer. That is, if you write
    to a pipe, there must be a reader consuming from it concurrently. So make sure
    you put the data-producing side (where you use the writer) in a different goroutine
    than the data-consuming side (where you use the reader).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一个同步连接的读取器和写入器。也就是说，如果你向管道写入，必须有一个读取器并发地从中消费。所以请确保你将数据生产方（使用写入器的地方）放在与数据消费方（使用读取器的地方）不同的
    goroutine 中。
- en: 'Create a pipe reader and pipe writer using `io.Pipe`:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `io.Pipe` 创建管道读取器和管道写入器：
- en: '[PRE57]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`pipeReader` will read everything written to `pipeWriter`.'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pipeReader` 将读取写入到 `pipeWriter` 的所有内容。'
- en: 'Use `pipeWriter` to produce data in a goroutine. When everything is written,
    close `pipeWriter`:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个 goroutine 中使用 `pipeWriter` 产生数据。当所有内容都写入后，关闭 `pipeWriter`：
- en: '[PRE58]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use `pipeReader` where a reader is needed. If the function fails and not everything
    in the pipe can be consumed, close `pipeReader` so the writer can terminate:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要读取器的地方使用 `pipeReader`。如果函数失败并且管道中的所有内容都无法消费，请关闭 `pipeReader` 以使写入器能够终止：
- en: '[PRE59]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Above, the goroutine that encodes the JSON data will block until the `POST`
    request establishes a connection and streams the data. If there is an error during
    this process, `pipeReader.Close()` ensures that the goroutine that encodes JSON
    data does not leak.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，编码 JSON 数据的 goroutine 将阻塞，直到 `POST` 请求建立连接并流式传输数据。如果在过程中出现错误，`pipeReader.Close()`
    确保编码 JSON 数据的 goroutine 不会泄漏。
- en: Intercepting a reader using TeeReader
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TeeReader 拦截读取器
- en: In plumbing, a tee pipe is a fitting that has a T shape. It splits the flow
    into two. `TeeReader` takes its name from that. An `io.TeeReader(r io.Reader,
    w io.Writer) io.Reader` function returns a new reader that reads from `r` at the
    same time as writing whatever it read to `w`. This is very useful for intercepting
    the data going through a reader.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道中，tee 管道是一种具有 T 形的配件。它将流量分成两部分。`TeeReader` 的名字就来源于此。`io.TeeReader(r io.Reader,
    w io.Writer) io.Reader` 函数返回一个新的读取器，它从 `r` 读取的同时将读取到的数据写入 `w`。这对于拦截通过读取器的数据非常有用。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a pipe:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个管道：
- en: '[PRE60]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a `TeeReader` from another reader, using `pipeWriter` as the writer
    that will receive data:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个读取器创建一个 `TeeReader`，使用 `pipeWriter` 作为接收数据的写入器：
- en: '[PRE61]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: At this stage, reading some data from `tee` will read data from `file` and write
    that data to `pipeWriter`.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，从 `tee` 读取数据将同时从 `file` 读取数据并将其写入 `pipeWriter`。
- en: 'Use `pipeReader` in a separate goroutine to process data read from the original
    reader:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个 goroutine 中使用 `pipeReader` 处理从原始读取器读取的数据：
- en: '[PRE62]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use the `TeeReader` to read the data:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `TeeReader` 读取数据：
- en: '[PRE63]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that working with a pipe requires at least one other goroutine where writing
    to or reading from the pipe happens. In case of error, make sure all goroutines
    working with the pipe terminate by closing one end of the pipe.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用管道至少需要另一个goroutine，其中涉及到向管道写入或从管道读取。如果发生错误，确保所有与管道一起工作的goroutine通过关闭管道的一端来终止。
