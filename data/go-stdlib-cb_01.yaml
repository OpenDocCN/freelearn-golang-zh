- en: Interacting with the Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与环境交互
- en: 'In this chapter, the following recipes are covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下配方：
- en: Retrieving the Golang version
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索Golang版本
- en: Accessing program arguments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问程序参数
- en: Creating a program interface with the flag package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用flag包创建程序接口
- en: Getting and setting environment variables with default values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取并设置带有默认值的环境变量
- en: Retrieving the current working directory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索当前工作目录
- en: Getting the current process PID
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前进程PID
- en: Handling operating system signals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理操作系统信号
- en: Calling an external process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用外部进程
- en: Retrieving child process information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索子进程信息
- en: Reading/writing from the child process
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从子进程读取/写入
- en: Shutting down the application gracefully
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地关闭应用程序
- en: File configuration with functional options
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能选项进行文件配置
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Every program, once it is executed, exists in the environment of the operating
    system. The program receives input and provides output to this environment. The
    operating system also needs to communicate with the program to let it know what's
    happening outside. And finally, the program needs to respond with appropriate
    actions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序一旦被执行，就存在于操作系统的环境中。程序接收输入并向该环境提供输出。操作系统还需要与程序通信，让程序知道外部发生了什么。最后，程序需要做出适当的响应。
- en: This chapter will walk you through the basics of the discovery of the system
    environment, the program parameterization via program arguments, and the concept
    of the operating system signals. You will also learn how to execute and communicate
    with the child process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您了解系统环境的发现基础知识，通过程序参数对程序进行参数化，以及操作系统信号的概念。您还将学习如何执行和与子进程通信。
- en: Retrieving the Golang version
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索Golang版本
- en: While building a program, it is a good practice to log the environment settings,
    build version, and runtime version, especially if your application is more complex.
    This helps you to analyze the problem, in case something goes wrong.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建程序时，最好记录环境设置、构建版本和运行时版本，特别是如果您的应用程序更复杂。这有助于您分析问题，以防出现故障。
- en: Besides the build version and, for example, the environmental variables, the
    Go version by which the binary was compiled could be included in the log. The
    following recipe will show you how to include the Go runtime version into such
    program information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建版本和例如环境变量之外，编译二进制文件的Go版本可以包含在日志中。以下的步骤将向您展示如何将Go运行时版本包含在程序信息中。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Install and verify the Go installation. The following steps could help:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并验证Go安装。以下步骤可能有所帮助：
- en: Download and install Go on your machine.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算机上下载并安装Go。
- en: Verify that your `GOPATH` and `GOROOT` environmental variables are set properly.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的 `GOPATH` 和 `GOROOT` 环境变量是否正确设置。
- en: Open your Terminal and execute `go version`. If you get output with a version
    name, then Go is installed properly.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并执行 `go version`。如果得到带有版本名称的输出，则Go已正确安装。
- en: Create a repository in the `GOPATH/src` folder.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GOPATH/src` 文件夹中创建存储库。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps cover the solution:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤涵盖了解决方案：
- en: Open the console and create the folder `chapter01/recipe01`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹 `chapter01/recipe01`。
- en: Navigate to the directory.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main.go` 文件，内容如下：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the code by executing the `go run main.go`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `go run main.go` 运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/da28c809-195a-49c5-83ad-1c4ef2b86da1.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da28c809-195a-49c5-83ad-1c4ef2b86da1.png)'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `runtime` package contains a lot of useful functions. To find out the Go
    runtime version, the `Version` function could be used. The documentation states
    that the function returns the hash of the commit, and the date or tag at the time
    of the binary build.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`runtime` 包包含许多有用的函数。要找出Go运行时版本，可以使用 `Version` 函数。文档说明该函数返回提交的哈希值，以及二进制构建时的日期或标签。'
- en: The `Version` function, in fact, returns the `runtime/internal/sys` .The `Version` constant.
    The constant itself is located in the `$GOROOT/src/runtime/internal/sys/zversion.go` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Version` 函数返回 `runtime/internal/sys` 的 `Version` 常量。常量本身位于 `$GOROOT/src/runtime/internal/sys/zversion.go`
    文件中。
- en: This `.go` file is generated by the `go dist` tool and the version is resolved
    by the `findgoversion` function in the `go/src/cmd/dist/build.go` file, as explained
    next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `.go` 文件是由 `go dist` 工具生成的，版本是通过 `go/src/cmd/dist/build.go` 文件中的 `findgoversion`
    函数解析的，如下所述。
- en: The `$GOROOT/VERSION` takes priority. If the file is empty or does not exist,
    the `$GOROOT/VERSION.cache` file is used. If the `$GOROOT/VERSION.cache` is also
    not found, the tool tries to resolve the version by using the Git information,
    but in this case, you need to initialize the Git repository for the Go source.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GOROOT/VERSION` 优先级最高。如果文件为空或不存在，则使用 `$GOROOT/VERSION.cache` 文件。如果也找不到 `$GOROOT/VERSION.cache`，则工具会尝试使用Git信息来解析版本，但在这种情况下，您需要为Go源代码初始化Git存储库。'
- en: Accessing program arguments
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问程序参数
- en: The most simple way to parameterize the program run is to use the command-line
    arguments as program parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化程序运行的最简单方法是使用命令行参数作为程序参数。
- en: Simply, the parameterized program call could look like this: `./parsecsv user.csv
    role.csv`. In this case, `parsecsv` is the name of the executed binary and `user.csv` and
    `role.csv` are the arguments, that modify the program call (in this case it refers
    to files to be parsed).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，参数化的程序调用可能如下所示：`./parsecsv user.csv role.csv`。在这种情况下，`parsecsv`是执行二进制文件的名称，`user.csv`和`role.csv`是修改程序调用的参数（在这种情况下是要解析的文件）。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter01/recipe02`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹 `chapter01/recipe02`。
- en: Navigate to the directory.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main.go` 文件，内容如下：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build the binary by executing `go build -o test`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `go build -o test` 构建二进制文件。
- en: Execute the command `./test arg1 arg2`. (Windows users can run `test.exe arg1
    arg2`).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令`./test arg1 arg2`。（Windows用户可以运行`test.exe arg1 arg2`）。
- en: 'See the output in the Terminal:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/2de10160-aead-4a1d-8f57-1d550b70c651.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2de10160-aead-4a1d-8f57-1d550b70c651.png)'
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Go standard library offers a few ways to access the arguments of the program
    call. The most generic way is to access the arguments by the `Args` variable from
    the OS package.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了几种访问程序调用参数的方法。最通用的方法是通过OS包中的`Args`变量访问参数。
- en: This way you can get all the arguments from the command line in a string slice. The
    advantage of this approach is that the number of arguments is dynamic and this
    way you can, for example, pass the names of the files to be processed by the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以在字符串切片中获取命令行中的所有参数。这种方法的优点是参数的数量是动态的，这样您可以，例如，将要由程序处理的文件的名称传递给程序。
- en: The preceding example just echoes all the arguments that are passed to the program.
    Finally, let's say the binary is called `test` and the program run is executed
    by the Terminal command `./test arg1 arg2`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例只是回显传递给程序的所有参数。最后，假设二进制文件名为`test`，程序运行由终端命令`./test arg1 arg2`执行。
- en: In detail, the `os.Args[0]` will return `./test`. The `os.Args[1:]` returns
    the rest of the arguments without the binary name. In the real world, it is better
    to not rely on the number of arguments passed to the program, but always check
    the length of the argument array. Otherwise, naturally, if the argument on a given
    index is not within the range, the program panics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，`os.Args[0]`将返回`./test`。`os.Args[1:]`返回不带二进制名称的其余参数。在现实世界中，最好不要依赖于传递给程序的参数数量，而是始终检查参数数组的长度。否则，如果给定索引上的参数不在范围内，程序将自然地发生恐慌。
- en: There's more…
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If the arguments are defined as flags, `-flag value`, additional logic is needed
    to assign the value to the flag. In this case, there is a better way to parse
    these by using the `flag` package. This approach is part of the next recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数被定义为标志，`-flag value`，则需要额外的逻辑来将值分配给标志。在这种情况下，使用`flag`包有更好的方法来解析这些标志。这种方法是下一个配方的一部分。
- en: Creating a program interface with the flag package
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用flag包创建程序接口
- en: The previous recipe describes how to access the program arguments by a very
    generic approach.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配方描述了如何通过非常通用的方法访问程序参数。
- en: This recipe will provide a way of defining an interface via the program flags.
    This approach dominates systems based on GNU/Linux, BSD, and macOS.  The example
    of the program call could be `ls -l` which will, on *NIX systems, list the files
    in a current directory.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将提供一种通过程序标志定义接口的方法。这种方法主导了基于GNU/Linux、BSD和macOS的系统。程序调用的示例可以是`ls -l`，在*NIX系统上，它将列出当前目录中的文件。
- en: The Go package for flag handling does not support flag combining like `ls -ll`,
    where there are multiple flags after a single dash. Each flag must be separate.
    The Go flag package also does not differentiate between long options and short
    ones. Finally, `-flag` and `--flag` are equivalent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Go标志处理包不支持像`ls -ll`这样的标志组合，其中在单个破折号后有多个标志。每个标志必须是单独的。Go标志包也不区分长选项和短选项。最后，`-flag`和`--flag`是等效的。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open the console and create the folder `chapter01/recipe03`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe03`。
- en: Navigate to the directory.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建带有以下内容的`main.go`文件：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Build the binary by executing the `go build -o util`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go build -o util`来构建二进制文件。
- en: From the console, execute `./util -retry 2 -prefix=example -array=1,2`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制台执行`./util -retry 2 -prefix=example -array=1,2`。
- en: 'See the output in the Terminal:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/24b5846a-4453-4fbc-9301-aa81704939ee.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24b5846a-4453-4fbc-9301-aa81704939ee.png)'
- en: How it works…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For the flag definition in code, the `flag` package defines two types of functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码中的标志定义，`flag`包定义了两种类型的函数。
- en: The first type is the simple name of the flag type such as`Int`*.* This function
    will return the pointer to the integer variable where the value of the parsed
    flag is.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种类型是标志类型的简单名称，例如`Int`。这个函数将返回整数变量的指针，解析标志的值将存储在其中。
- en: The `XXXVar` functions are the second type. These provide the same functionality,
    but you need to provide the pointer to the variable. The parsed flag value will
    be stored in the given variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`XXXVar`函数是第二种类型。它们提供相同的功能，但需要提供变量的指针。解析的标志值将存储在给定的变量中。'
- en: The Go library also supports a custom flag type. The custom type must implement
    the `Value` interface from the `flag` package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Go库还支持自定义标志类型。自定义类型必须实现`flag`包中的`Value`接口。
- en: As an example, let's say the flag `retry` defines the retry limit for reconnecting
    to the endpoint, the `prefix` flag defines the prefix of each row in a log, and
    the `array` is the array flag that will be send as an payload to server. The program
    call from the Terminal will look like `./util -retry 2 -prefix=example array=1,2`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设标志`retry`定义了重新连接到端点的重试限制，标志`prefix`定义了日志中每行的前缀，而`array`是作为有效负载发送到服务器的数组标志。终端中的程序调用将如`./util
    -retry 2 -prefix=example array=1,2`。
- en: The important part of the preceding code is the `Parse()` function which parses
    the defined flags from `Args[1:]`. The function must be called after all flags
    are defined and before the values are accessed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的重要部分是`Parse()`函数，它从`Args[1:]`中解析定义的标志。在定义所有标志并在访问值之前必须调用该函数。
- en: The preceding code shows how to parse some data types from the command-line
    flags. Analogously, the other built-in types are parsed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码显示了如何从命令行标志中解析一些数据类型。类似地，其他内置类型也可以解析。
- en: The last flag, `array`, demonstrates the definition of the custom type flag.
    Note that the `ArrayType` implements the `Value` interface from the `flag` package.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个标志`array`演示了自定义类型标志的定义。请注意，`ArrayType`实现了`flag`包中的`Value`接口。
- en: There's more…
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `flag` package contains more functions to design the interface with flags.
    It is worth reading the documentation for `FlagSet`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag`包包含更多函数来设计带有标志的接口。值得阅读`FlagSet`的文档。'
- en: By defining the new `FlagSet`, the arguments could be parsed by calling the `myFlagset.Parse(os.Args[2:])`.
    This way you can have flag subsets based on, for example, the first flag.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义新的`FlagSet`，可以通过调用`myFlagset.Parse(os.Args[2:])`来解析参数。这样你就可以基于第一个标志拥有标志子集。
- en: Getting and setting environment variables with default values
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认值获取和设置环境变量
- en: The previous recipe, *Creating a program interface with the flag package,* describes
    how to use flags as program parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个教程，*使用flag包创建程序接口*，描述了如何将标志用作程序参数。
- en: The other typical way of parameterization, especially for larger applications,
    is the configuration with the use of environment variables. Environment variables
    as a configuration option significantly simplify the deployment of the applications.
    These are also very common in cloud infrastructure.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于较大的应用程序，另一种典型的参数化方式是使用环境变量进行配置。环境变量作为配置选项显著简化了应用程序的部署。这在云基础设施中也非常常见。
- en: Usually, the configuration of a database connection for a local and for an automated
    build environment is different.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，本地数据库连接和自动构建环境的配置是不同的。
- en: If the configuration is defined by the environment variables, it is not necessary
    to change the application config files or even the application code. The exported
    environment variables (for example, `DBSTRING`) are all we need. It is also very
    practical to default the configuration if the environmental variable is not in
    place. This way, the life of the application developers is much easier.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置由环境变量定义，就不需要更改应用程序配置文件甚至应用程序代码。导出的环境变量（例如`DBSTRING`）就是我们所需要的。如果环境变量不存在，将配置默认值也非常实用。这样，应用程序开发人员的生活就轻松多了。
- en: This recipe will demonstrate how to read, set and unset the environment variable.
    It will also show you how to implement the default option if the variable is not
    set.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程将演示如何读取、设置和取消设置环境变量。它还将向您展示如何在变量未设置时实现默认选项。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Open the console and create the folder `chapter01/recipe04`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe04`。
- en: Navigate to the directory.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `get.go` file with the following content:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`get.go`文件，内容如下：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Execute the code by calling `DB_CONN=db:/user@example && go run get.go` in the
    Terminal.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中调用`DB_CONN=db:/user@example && go run get.go`来执行代码。
- en: 'See the output in the Terminal:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/10deaa7c-c4af-4ceb-b13c-4d3fda3c7bb5.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10deaa7c-c4af-4ceb-b13c-4d3fda3c7bb5.png)'
- en: 'Create the `lookup.go` file with the following content:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`lookup.go`文件，内容如下：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute the code by calling `unset DB_CONN && go run lookup.go` in the Terminal.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中调用`unset DB_CONN && go run lookup.go`来执行代码。
- en: 'See the output in the Terminal:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/aa749e9a-6241-4830-b558-2ff06a7506d5.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa749e9a-6241-4830-b558-2ff06a7506d5.png)'
- en: 'Create the `main.go` file with the following content:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.go`文件，内容如下：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the code by executing `go run main.go`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`go run main.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/20b7ef63-0921-49c4-94f4-3c6f1498de02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20b7ef63-0921-49c4-94f4-3c6f1498de02.png)'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The environment variables are accessed by the `Getenv` and `Setenv` functions 
    in the `os` package. The names of the functions are self-explanatory and do not
    need any further description.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以通过`os`包中的`Getenv`和`Setenv`函数来访问。这些函数的名称不言自明，不需要进一步的描述。
- en: There is one more useful function in the `os` package. The `LookupEnv` function
    provides two values as a result; the value of the variable, and the boolean value
    which defines if the variable was set or not in the environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包中还有一个有用的函数。`LookupEnv`函数提供两个值作为结果；变量的值，以及布尔值，定义变量在环境中是否设置。'
- en: The disadvantage of the `os.Getenv` function is that it returns an empty string,
    even in cases where the environment variable is not set.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Getenv`函数的缺点是，即使在环境变量未设置的情况下，它也会返回空字符串。'
- en: This handicap could be overcome by the `os.LookupEnv` function, which returns
    the string as a value of the environment variable and the boolean value that indicates
    whether the variable was set or not.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缺点可以通过`os.LookupEnv`函数来克服，该函数返回环境变量的字符串值和一个布尔值，指示变量是否设置。
- en: To implement the retrieval of the environment variable or the default one, use
    the `os.LookupEnv` function. Simply, if the variable is not set, which means that
    the second returned value is `false`, then the default value is returned. The
    use of the function is part of step 9.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现检索环境变量或默认值，使用`os.LookupEnv`函数。简单地说，如果变量未设置，也就是第二个返回值是`false`，那么就返回默认值。该函数的使用是第9步的一部分。
- en: Retrieving the current working directory
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索当前工作目录
- en: Another useful source of information for the application is the directory, where
    the program binary is located. With this information, the program can access the
    assets and files collocated with the binary file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的另一个有用信息来源是目录，程序二进制文件所在的位置。有了这些信息，程序就可以访问与二进制文件一起放置的资源和文件。
- en: This recipe is using the solution for Go since version 1.8\. This one is the
    preferred one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go 1.8版本以来，本教程使用了Go的解决方案。这是首选方案。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Open the console and create the folder `chapter01/recipe05`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe05`。
- en: Navigate to the directory.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.go`文件，内容如下：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Build the binary by the command `go build -o binary`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命令`go build -o binary`构建二进制文件。
- en: Execute the binary by the Terminal call `./binary`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过终端调用`./binary`来执行二进制文件。
- en: 'See the output. It should display the absolute path on your machine:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出。它应该显示在您的机器上的绝对路径：
- en: '![](img/a30ae134-4226-4698-8b10-4b85c626c9a3.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a30ae134-4226-4698-8b10-4b85c626c9a3.png)'
- en: How it works…
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Since Go 1.8, the `Executable` function from the `os` package is the preferred
    way of resolving the path of the executable. The `Executable` function returns
    the absolute path of the binary that is executed (unless the error is returned).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自Go 1.8以来，`os`包中的`Executable`函数是解析可执行文件路径的首选方法。`Executable`函数返回执行的二进制文件的绝对路径（除非返回错误）。
- en: To resolve the directory from the binary path, the `Dir` from the `filepath` package
    is applied. The only pitfall of this is that the result could be the `symlink`
    or the path it pointed to.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析二进制路径的目录，应用了`filepath`包中的`Dir`。唯一的问题是结果可能是`symlink`或它指向的路径。
- en: To overcome this unstable behavior, the `EvalSymlinks` from the `filepath` package
    could be applied to the resultant path. With this hack, the returned value would
    be the real path of the binary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种不稳定的行为，可以使用`filepath`包中的`EvalSymlinks`来应用到结果路径上。通过这种方法，返回的值将是二进制文件的真实路径。
- en: The information about the directory where the binary is located could be obtained
    with the use of the `Executable` function in the `os` library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`os`库中的`Executable`函数获取二进制文件所在目录的信息。
- en: Note that if the code is run by the command `go run`, the actual executable
    is located in a temporary directory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果代码是通过`go run`命令运行的，实际的可执行文件位于临时目录中。
- en: Getting the current process PID
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前进程PID
- en: Getting to know the PID of the running process is useful. The PID could be used
    by OS utilities to find out the information about the process itself. It is also
    valuable to know the PID in case of process failure, so you can trace the process
    behavior across the system in system logs, such as `/var/log/messages`, `/var/log/syslog`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 了解正在运行的进程的PID是有用的。PID可以被操作系统实用程序用来查找有关进程本身的信息。在进程失败的情况下，了解PID也很有价值，这样您可以在系统日志中跟踪进程行为，例如`/var/log/messages`，`/var/log/syslog`。
- en: This recipe shows you how to use the `os` package to obtain a PID of the executed
    program, and use it with the operating system utility to obtain some more information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例向您展示了如何使用`os`包获取执行程序的PID，并将其与操作系统实用程序一起使用以获取更多信息。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Open the console and create the folder `chapter01/recipe06`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe06`。
- en: Navigate to the directory.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`main.go`文件：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the code by executing the `go run main.go`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/82b6a9e7-9050-4819-b33f-8b74fee5d4fb.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82b6a9e7-9050-4819-b33f-8b74fee5d4fb.png)'
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The function `Getpid` from the `os` package returns the PID of a process. The
    sample code shows how to get more information on the process from the operating
    system utility `ps`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包中的`Getpid`函数返回进程的PID。示例代码展示了如何从操作系统实用程序`ps`获取有关进程的更多信息。'
- en: It could be useful to print the PID at the start of the application, so at the
    time of the crash, the cause could also be investigated by the retrieved PID.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动时打印PID可能很有用，这样在崩溃时也可以通过检索到的PID来调查原因。
- en: Handling operating system signals
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理操作系统信号
- en: Signals are the elementary way the operating systems communicate with the running
    process. Two of the most usual signals are called `SIGINT` and `SIGTERM`. These
    cause the program to terminate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是操作系统与正在运行的进程通信的基本方式。最常见的两个信号是`SIGINT`和`SIGTERM`。这些信号会导致程序终止。
- en: There are also signals such as `SIGHUP`. `SIGHUP` indicates that the terminal
    which called the process was closed and, for example, the program could decide
    to move to the background.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些信号，比如`SIGHUP`。`SIGHUP`表示调用进程的终端已关闭，例如，程序可以决定转移到后台。
- en: Go provides a way of handling the behavior in case the application received
    the signal. This recipe will provide an example of implementing the handling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一种处理应用程序接收到信号时的行为的方法。本示例将提供一个实现处理的示例。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Open the console and create the folder `chapter01/recipe07`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe07`。
- en: Navigate to the directory.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`main.go`文件：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the code by executing `go run main.go`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main.go`来运行代码。
- en: Send the `SIGINT` signal to the application by pressing *CTRL* + *C*.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*CTRL* + *C*发送`SIGINT`信号给应用程序。
- en: 'See the output:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/5f5a3b24-e84e-43fc-bc62-33181082f424.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f5a3b24-e84e-43fc-bc62-33181082f424.png)'
- en: How it works…
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In an application, where the resources are acquired, a resource leak could happen
    in the case of an instant termination. It is better to handle the signals and
    take some necessary steps to release the resources. The preceding code shows the
    concept of how to do that.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源被获取的应用程序中，如果立即终止可能会发生资源泄漏。最好处理信号并采取一些必要的步骤来释放资源。上述代码展示了如何做到这一点的概念。
- en: The `Notify` function from the `signal` package would be the one that helps
    us to handle the received signals.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal`包中的`Notify`函数将帮助我们处理接收到的信号。'
- en: If no signal is specified as an argument in a `Notify` function, the function
    will catch all possible signals.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`Notify`函数中未指定信号作为参数，函数将捕获所有可能的信号。
- en: Note that the `Notify` function of the `signal` package is communicating with
    the `goroutine` by the `sChan` channel. `Notify` then catches the defined signals
    and sends these to `goroutine` to be handled. Finally, `exitChan` is used to resolve
    the exit code of the process.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`signal`包的`Notify`函数通过`sChan`通道与`goroutine`通信。`Notify`然后捕获定义的信号并将其发送到`goroutine`进行处理。最后，`exitChan`用于解析进程的退出代码。
- en: The important information is that the `Notify` function will not block the signal
    if the assigned channel is not ready. This way the signal could be missed. To
    avoid missing the signal, it is better to create the buffered channel.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的信息是，如果分配的通道未准备好，`Notify`函数将不会阻止信号。这样信号可能会被错过。为了避免错过信号，最好创建缓冲通道。
- en: Note that the `SIGKILL` and `SIGSTOP` signals may not be caught by the `Notify`
    function, thus it is not possible to handle these.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`SIGKILL`和`SIGSTOP`信号可能无法被`Notify`函数捕获，因此无法处理这些信号。
- en: Calling an external process
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用外部进程
- en: The Go binary could also be used as a tool for various utilities and with use
    of `go run` as a replacement for the bash script. For these purposes, it is usual that
    the command-line utilities are called.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Go二进制文件也可以用作各种实用程序的工具，并且可以使用`go run`来替代bash脚本。出于这些目的，通常会调用命令行实用程序。
- en: In this recipe, the basics of how to execute and handle the child process will be
    provided.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，将提供如何执行和处理子进程的基础知识。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Test if the following commands work in your Terminal:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 测试以下命令是否在你的终端中工作：
- en: Test if the `ls` (`dir` for Windows) command exists in your `$PATH`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`ls`（Windows中为`dir`）命令是否存在于你的`$PATH`中。
- en: You should be able to execute the `ls` (`dir` in Windows) command in your Terminal.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够在终端中执行`ls`（Windows中为`dir`）命令。
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following steps cover the solution:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤涵盖了解决方案：
- en: Open the console and create the folder `chapter01/recipe08`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe08`。
- en: Navigate to the directory.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `run.go` file with the following content:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`run.go`文件，内容如下：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the code by executing `go run run.go`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run run.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/61af16dc-759a-4ebb-8383-bb6ce2456cc4.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61af16dc-759a-4ebb-8383-bb6ce2456cc4.png)'
- en: 'Create the `start.go` file with the following content:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`start.go`文件，内容如下：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the code by executing `go run start.go`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run start.go`来运行代码。
- en: 'See the output in Terminal:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/4d9b6e4d-a10b-477b-9087-74a829c2257c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d9b6e4d-a10b-477b-9087-74a829c2257c.png)'
- en: How it works…
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The Go standard library provides a simple way of calling the external process.
    This could be done by the `Command` function of the `os/exec` package.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了一种简单的调用外部进程的方法。这可以通过`os/exec`包的`Command`函数来实现。
- en: The simplest way is to create the `Cmd` struct and call the `Run` function.
    The `Run` function executes the process and waits until it completes. If the command
    exited with an error, the `err` value is not null.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建`Cmd`结构并调用`Run`函数。`Run`函数执行进程并等待其完成。如果命令退出时出现错误，`err`值将不为空。
- en: This is more suitable for calling the OS utils and tools, so the program does
    not hang too long.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这更适合调用操作系统的实用程序和工具，这样程序不会挂起太久。
- en: The process could be executed asynchronously too. This is done by calling the `Start`
    method of the `Cmd` structure. In this case, the process is executed, but the
    main `goroutine` does not wait until it ends. The `Wait` method could be used
    to wait until the process ends. After the `Wait` method finishes, the resources
    of the process are released.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 进程也可以异步执行。这可以通过调用`Cmd`结构的`Start`方法来实现。在这种情况下，进程被执行，但是主`goroutine`不会等待它结束。`Wait`方法可以用来等待进程结束。`Wait`方法完成后，进程的资源将被释放。
- en: This approach is more suitable for executing long-running processes and services
    that the program depends on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更适合执行长时间运行的进程和程序依赖的服务。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe describes how to simply execute the child process. There are *Retrieve
    child process information* and *Reading/writing from the child process* recipes
    in this chapter that also provide the steps on how to read from and write to the
    child process, and get useful information about the process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例描述了如何简单地执行子进程。本章还提供了*检索子进程信息*和*从子进程读取/写入*的示例，介绍了如何从子进程读取和写入，并获取有用的进程信息的步骤。
- en: Retrieving child process information
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索子进程信息
- en: The recipe *Calling an external process* describes how to call the child process,
    synchronously and asynchronously. Naturally, to handle the process behavior you
    need to find out more about the process.  This recipe shows how to obtain the
    PID and elementary information about the child process after it terminates.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用外部进程*示例描述了如何同步和异步调用子进程。自然地，要处理进程行为，你需要更多地了解进程。这个示例展示了如何在子进程终止后获取PID和基本信息。'
- en: The information about the running process could be obtained only via the `syscall`
    package and it is highly platform-dependent.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运行进程的信息只能通过`syscall`包获得，而且高度依赖于平台。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Test if the `sleep` (`timeout` for Windows) command exists in the Terminal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`sleep`（Windows中为`timeout`）命令是否存在于终端中。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Open the console and create the folder `chapter01/recipe09`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe09`。
- en: Navigate to the directory.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main_running.go` file with the following content:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main_running.go`文件，内容如下：
- en: '[PRE11]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the code by executing `go run main_running.go`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main_running.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/359c90e1-e52d-49fa-83ca-ace5d98533b1.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/359c90e1-e52d-49fa-83ca-ace5d98533b1.png)'
- en: 'Create the `main.go` file with the following content:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.go`文件，内容如下：
- en: '[PRE12]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the code by executing `go run main.go`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/2902d443-a9b7-4b4c-89aa-f127f2ea2095.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2902d443-a9b7-4b4c-89aa-f127f2ea2095.png)'
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `os/exec` standard library provides the way to execute the process. Using `Command`, the `Cmd` structure
    is returned. The `Cmd` provides the access to process the representation. When
    the process is running, you can only find out the PID.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`os/exec`标准库提供了执行进程的方法。使用`Command`，将返回`Cmd`结构。`Cmd`提供了对进程表示的访问。当进程正在运行时，你只能找到PID。'
- en: There is only a little information that you can retrieve about the process.
    But by retrieving the PID of the process, you are able to call the utilities from
    the OS to get more information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能获取有关进程的少量信息。但是通过检索进程的PID，你可以调用操作系统的实用程序来获取更多信息。
- en: Remember that it is possible to obtain the PID of the child process, even if
    it is running. On the other hand, the `ProcessState` structure of the `os` package
    is available, only after the process terminates.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使子进程正在运行，也可以获取其PID。另一方面，只有在进程终止后，`os`包的`ProcessState`结构才可用。
- en: See also
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There are *Reading/writing from the child process* and *Calling an external
    process* recipes in this chapter that are related to process handling.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有与进程处理相关的*从子进程中读取/写入*和*调用外部进程*的配方。
- en: Reading/writing from the child process
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从子进程中读取/写入
- en: Every process, that is executed, has the standard output, input and error output.
    The Go standard library provides the way to read and write to these.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个执行的进程都有标准输出、输入和错误输出。Go标准库提供了读取和写入这些内容的方法。
- en: This recipe will walk through the approaches on how to read the output and write
    to the input of the child process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将介绍如何读取进程的输出并写入子进程的输入的方法。
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Verify if the following commands work in the Terminal:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 验证以下命令是否在终端中工作：
- en: Test if the `ls` (`dir` for Windows) command exists in the Terminal.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试终端中是否存在`ls`（Windows中的`dir`）命令。
- en: You should be able to execute the `ls` (`dir` in Windows) command in your Terminal.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够在终端中执行`ls`（Windows中的`dir`）命令。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Open the console and create the folder `chapter01/recipe10`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe10`。
- en: Navigate to the directory.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main_read_output.go` file with the following content:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main_read_output.go`文件，内容如下：
- en: '[PRE13]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the code by executing `go run main_read_output.go`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main_read_output.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/e44bc828-1856-44f6-9573-0c962c6bf1c7.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e44bc828-1856-44f6-9573-0c962c6bf1c7.png)'
- en: 'Create the `main_read_stdout.go` file with the following content:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main_read_stdout.go`文件，内容如下：
- en: '[PRE14]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the code by executing `go run main_read_stdout.go`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main_read_stdout.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/8ac6c977-1a10-4af7-a567-b2789426c601.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ac6c977-1a10-4af7-a567-b2789426c601.png)'
- en: 'Create the `main_read_read.go` file with the following content:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main_read_read.go`文件，内容如下：
- en: '[PRE15]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the code by executing `go run main_read.go`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main_read.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/ab239155-9b87-489a-a215-258b1dc5f984.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab239155-9b87-489a-a215-258b1dc5f984.png)'
- en: 'Create the `sample.go` file with the following content:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`sample.go`文件，内容如下：
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `main.go` file with the following content:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.go`文件，内容如下：
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the code by executing `go run main.go`.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/03b5fa95-0181-4d5e-b404-9f782fbdf5ad.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03b5fa95-0181-4d5e-b404-9f782fbdf5ad.png)'
- en: How it works…
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `Cmd` structure of the `os/exec` package provides the functions to access
    the output/input of the process. There are a few approaches to read the output
    of the process.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`os/exec`包的`Cmd`结构提供了访问进程输出/输入的函数。有几种方法可以读取进程的输出。'
- en: One of the simplest ways to read the process output is to use the `Output` or `CombinedOutput` method
    of the `Cmd` structure (gets `Stderr` and `Stdout`). While calling this function,
    the program synchronously waits till the child process terminates and then returns
    the output to a byte buffer.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 读取进程输出的最简单方法之一是使用`Cmd`结构的`Output`或`CombinedOutput`方法（获取`Stderr`和`Stdout`）。在调用此函数时，程序会同步等待子进程终止，然后将输出返回到字节缓冲区。
- en: Besides the `Output` and `OutputCombined` methods, the `Cmd` structure provides
    the `Stdout` property, where the `io.Writer` could be assigned. The assigned writer
    then serves as a destination for the process output. It could be a file, byte
    buffer or any type implementing the `io.Writer` interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Output`和`OutputCombined`方法外，`Cmd`结构提供了`Stdout`属性，可以将`io.Writer`分配给它。分配的写入器然后作为进程输出的目的地。它可以是文件、字节缓冲区或任何实现`io.Writer`接口的类型。
- en: The last approach to read the process output is to get the `io.Reader` from
    the `Cmd` structure by calling the `StdoutPipe` method. The `StdoutPipe` method
    creates the pipe between the `Stdout`, where the process writes the output, and
    provides `Reader` which works as the interface for the program to read the process
    output. This way the output of the process is piped to the retrieved `io.Reader`
    .
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 读取进程输出的最后一种方法是通过调用`Cmd`结构的`StdoutPipe`方法获取`io.Reader`。`StdoutPipe`方法在`Stdout`之间创建管道，进程在其中写入输出，并提供`Reader`，它作为程序读取进程输出的接口。这样，进程的输出被传送到检索到的`io.Reader`。
- en: Writing to a process `stdin` works the same way. Of all the options, the one
    with `io.Writer` will be demonstrated.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 向进程的`stdin`写入的方式相同。在所有选项中，将演示使用`io.Writer`的方式。
- en: 'As could be seen, there are a few ways to read and write from the child process.
    The use of `stderr` and `stdin` is almost the same as described in steps 6-7\.
    Finally, the approach of how to access the input/output could be divided this
    way:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，有几种方法可以从子进程中读取和写入。使用`stderr`和`stdin`的方式几乎与步骤6-7中描述的方式相同。最后，访问输入/输出的方法可以这样分为：
- en: 'Synchronous (wait until the process ends and get the bytes): The `Output` and
    `CombinedOutput` methods of `Cmd` are used.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步（等待进程结束并获取字节）：使用`Cmd`的`Output`和`CombinedOutput`方法。
- en: 'IO: The output or input are provided in the form of `io.Writer/Reader`. The
    `XXXPipe` and `StdXXX` properties are the right ones for this approach.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IO：输出或输入以`io.Writer/Reader`的形式提供。`XXXPipe`和`StdXXX`属性是这种方法的正确选择。
- en: The IO type is more flexible and could also be used asynchronously.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: IO类型更加灵活，也可以异步使用。
- en: Shutting down the application gracefully
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅地关闭应用程序
- en: Servers and daemons are the programs that run for a long time (typically days
    or even weeks). These long-running programs usually allocate resources (database
    connections, network sock) at the start and keep these resources as long as they
    exist. If such a process is killed and the shutdown is not handled properly, a
    resource leak could happen. To avoid that behavior, the so-called graceful shutdown
    should be implemented.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和守护程序是长时间运行的程序（通常是几天甚至几周）。这些长时间运行的程序通常在开始时分配资源（数据库连接，网络套接字），并在资源存在的时间内保持这些资源。如果这样的进程被终止并且关闭未得到适当处理，可能会发生资源泄漏。为了避免这种行为，应该实现所谓的优雅关闭。
- en: Graceful, in this case, means that the application catches the termination signal,
    if possible, and tries to clean up and release the allocated resources before
    it terminates. This recipe will show you how to implement the graceful shutdown.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，优雅意味着应用程序捕获终止信号（如果可能的话），并在终止之前尝试清理和释放分配的资源。这个食谱将向您展示如何实现优雅关闭。
- en: The recipe, *Handling operating system signals* describes the catching of OS
    signals. The same approach will be used for implementing the graceful shutdown.
    Before the program terminates, it will clean up and carry out some other activities.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱*处理操作系统信号*描述了捕获操作系统信号。相同的方法将用于实现优雅关闭。在程序终止之前，它将清理并执行一些其他活动。
- en: How to do it…
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter01/recipe11`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe11`。
- en: Navigate to the directory.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.go`文件，内容如下：
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the code by executing `go run main.go`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run main.go`运行代码。
- en: Press *CTRL* + *C* to send a `SIGINT` signal.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*CTRL* + *C*发送`SIGINT`信号。
- en: 'Wait until the Terminal output looks like this:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待终端输出如下：
- en: '![](img/eef690db-8a92-41da-880d-4748b906c175.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eef690db-8a92-41da-880d-4748b906c175.png)'
- en: 'The `recipe11` folder should also contain a file called `test_XXXX.log`, which
    contains lines like this:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`recipe11`文件夹还应包含一个名为`test_XXXX.log`的文件，其中包含如下行：'
- en: '![](img/84079936-5b28-4df9-9622-d0cb003b50dd.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84079936-5b28-4df9-9622-d0cb003b50dd.png)'
- en: How it works…
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reading from a `sigChan` is blocking so the program keeps running until
    the Signal is sent through the channel. The `sigChan` is the channel where the
    `Notify` function sends the signals.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sigChan`读取是阻塞的，因此程序会一直运行，直到通过通道发送信号。`sigChan`是`Notify`函数发送信号的通道。
- en: The main code of the program runs in a new `goroutine`. This way, the work continues
    while the main function is blocked on the `sigChan`. Once the signal from operation
    system is sent to process, the `sigChan` receives the signal and the code below
    the line where the reading from the `sigChan` channel is executed. This code section
    could be considered as the cleanup section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要代码在一个新的`goroutine`中运行。这样，当主函数在`sigChan`上被阻塞时，工作将继续。一旦从操作系统发送信号到进程，`sigChan`接收到信号并在从`sigChan`通道读取的行下面的代码执行。这段代码可以被视为清理部分。
- en: Note that the step 7 terminal output contains the final log, `Application releasing
    all resources`, which is part of the cleanup section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，步骤7的终端输出包含最终日志`应用程序释放所有资源`，这是清理部分的一部分。
- en: See also
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A detailed description of how the signal catching works is in the recipe *Handling
    operating system signals*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有关信号捕获工作原理的详细描述在食谱*处理操作系统信号*中。
- en: File configuration with functional options
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用功能选项进行文件配置
- en: This recipe is not directly related to the Go standard library but includes
    how to handle an optional configuration for your application. The recipe will
    use the functional options pattern in a real case with a file configuration.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱与Go标准库没有直接关系，但包括如何处理应用程序的可选配置。该食谱将在实际情况下使用函数选项模式与文件配置。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter01/recipe12`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter01/recipe12`。
- en: Navigate to the directory.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `main.go` file with the following content:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main.go`文件，内容如下：
- en: '[PRE19]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same folder, create the file `config.json` with content:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中，创建名为`config.json`的文件，内容如下：
- en: '[PRE20]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Execute the code by the command `CONN_DB=oracle://local:5921 go run main.go`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命令`CONN_DB=oracle://local:5921 go run main.go`执行代码。
- en: 'See the output:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/0bba8cfd-8811-42fc-a255-28160367164c.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bba8cfd-8811-42fc-a255-28160367164c.png)'
- en: How it works...
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core concept of the functional options pattern is that the configuration
    API contains the functional parameters. In this case, the `NewClient` function
    accepts a various number of `ConfigFunc` arguments, which are then applied one
    by one on the `defaultClient` struct. This way, the default configuration is modified
    with huge flexibility.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 函数选项模式的核心概念是配置API包含功能参数。在这种情况下，`NewClient`函数接受各种数量的`ConfigFunc`参数，然后逐个应用于`defaultClient`结构。这样，可以以极大的灵活性修改默认配置。
- en: See the `FromFile` and `FromEnv` functions, which return the `ConfigFunc`, that
    is in fact, accessing the file or environmental variables.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`FromFile`和`FromEnv`函数，它们返回`ConfigFunc`，实际上是访问文件或环境变量。
- en: Finally, you can check the output which applied both the configuration options
    and resulting `Client` struct that contains the values from the file and environmental
    variables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以检查输出，该输出应用了配置选项和结果`Client`结构，其中包含来自文件和环境变量的值。
