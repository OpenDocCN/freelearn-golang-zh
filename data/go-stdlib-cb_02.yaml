- en: Strings and Things
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和其他内容
- en: 'The recipes in this chapter are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方有：
- en: Finding the substring in a string
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中查找子字符串
- en: Breaking the string into words
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串分解为单词
- en: Joining the string slice with a separator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分隔符连接字符串切片
- en: Concatenating a string with writer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用writer连接字符串
- en: Aligning text with tabwriter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tabwriter对齐文本
- en: Replacing part of the string
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换字符串的一部分
- en: Finding the substring in text by the regex pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过正则表达式模式在文本中查找子字符串
- en: Decoding a string from the non-Unicode charset
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从非Unicode字符集解码字符串
- en: Controlling case
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制大小写
- en: Parsing comma-separated data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析逗号分隔的数据
- en: Managing whitespace in a string
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理字符串中的空格
- en: Indenting a text document
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进文本文档
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Operations on strings and string-based data are common tasks in a developer's
    life. This chapter covers how to handle these using the Go standard library. It
    is no surprise that with the standard library it is possible to do a great deal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发人员的生活中，对字符串和基于字符串的数据进行操作是常见任务。本章介绍如何使用Go标准库处理这些任务。毫无疑问，使用标准库可以做很多事情。
- en: Check whether Go is properly installed. The *Getting ready* section from the *Retrieving
    the Golang version* recipe of [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    with the Environment,* will help you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Go是否已正确安装。[第1章](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)的*准备就绪*部分，*与环境交互*的*检索Golang版本*配方将对您有所帮助。
- en: Finding the substring in a string
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字符串中查找子字符串
- en: Finding the substring in a string is one of the most common tasks for developers.
    Most of the mainstream languages implement this in a standard library. Go is not
    an exception. This recipe describes the way Go implements this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发人员中，查找字符串中的子字符串是最常见的任务之一。大多数主流语言都在标准库中实现了这一点。Go也不例外。本配方描述了Go实现这一功能的方式。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe01`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe01`。
- en: Navigate to the directory.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `contains.go` file with the following content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`contains.go`文件，内容如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the code by executing `go run contains.go`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run contains.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/cfdd6ec3-b88c-4c16-b0ea-b27625bd827c.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfdd6ec3-b88c-4c16-b0ea-b27625bd827c.png)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Go library `strings` contain functions to handle the string operations.
    This time the function `Contains` could be used. The `Contains` function simply
    checks whether the string has a given substring. In fact, the function `Index`
    is used in `Contains` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go库`strings`包含处理字符串操作的函数。这次可以使用`Contains`函数。`Contains`函数只是检查字符串是否包含给定的子字符串。实际上，`Contains`函数中使用了`Index`函数。
- en: To check whether the string begins with the substring, the `HasPrefix` function
    is there. To check whether the string ends with the substring, the function `HasSuffix`
    will work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查字符串是否以子字符串开头，可以使用`HasPrefix`函数。要检查字符串是否以子字符串结尾，可以使用`HasSuffix`函数。
- en: 'In fact, the `Contains` function is implemented by use of the `Index` function
    from the same package. As you can guess, the actual implementation works like
    this: if the index of the given substring is greater than `-1`, the `Contains`
    function returns `true`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Contains`函数是通过使用同一包中的`Index`函数实现的。可以猜到，实际实现方式是这样的：如果给定子字符串的索引大于`-1`，则`Contains`函数返回`true`。
- en: 'The `HasPrefix` and `HasSuffix` functions work in a different way: the internal
    implementation just checks the length of both the string and substring, and if
    they are equal or the string is longer, the required part of the string is compared.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasPrefix`和`HasSuffix`函数的工作方式不同：内部实现只是检查字符串和子字符串的长度，如果它们相等或字符串更长，则比较字符串的所需部分。'
- en: See also
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe describes how to match the exact substring. The *Finding the substring
    in text by the regex pattern* recipe will help to find out how to use regex pattern
    matching.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方描述了如何匹配精确的子字符串。*通过正则表达式模式在文本中查找子字符串*配方将帮助您了解如何使用正则表达式模式匹配。
- en: Breaking the string into words
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串分解为单词
- en: Breaking the string into words could be tricky. First, decide what the word
    is, as well as what the separator is, and if there is any whitespace or any other
    characters.  After these decisions have been made, you can choose the appropriate
    function from the `strings` package. This recipe will describe common cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串分解为单词可能有些棘手。首先，决定单词是什么，分隔符是什么，是否有任何空格或其他字符。做出这些决定后，可以从`strings`包中选择适当的函数。本配方将描述常见情况。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe02`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe02`。
- en: Navigate to the directory.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `whitespace.go` file with the following content:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`whitespace.go`文件，内容如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the code by executing `go run whitespace.go`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run whitespace.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/aaf4051e-fe24-425c-9f49-cd929cfaed85.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaf4051e-fe24-425c-9f49-cd929cfaed85.png)'
- en: 'Create another file called `anyother.go` with the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`anyother.go`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the code by executing `go run anyother.go`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run anyother.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/c0abf1c1-01cc-4d1a-accd-44894c13b81f.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0abf1c1-01cc-4d1a-accd-44894c13b81f.png)'
- en: 'Create another file called `specfunction.go` with the following content:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`specfunction.go`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the code by executing `go run specfunction.go`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run specfunction.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/de72c9b7-3058-4e46-b357-2d46d78961a0.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de72c9b7-3058-4e46-b357-2d46d78961a0.png)'
- en: 'Create another file called `regex.go` with the following content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`regex.go`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code by executing `go run regex.go`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run regex.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/795483fa-ac1f-40af-8bdb-fe4867938c39.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/795483fa-ac1f-40af-8bdb-fe4867938c39.png)'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The simplest form of how to split the string into words considers any whitespace
    as a separator. In detail, the whitespace is defined by the `IsSpace` function
    in the `unicode` package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串拆分为单词的最简单形式考虑任何空白字符作为分隔符。具体来说，空白字符由`unicode`包中的`IsSpace`函数定义：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Fields` function of the `strings` package could be used to split the sentence
    by the whitespace chars as mentioned earlier. The steps **1 – 5** cover this first
    simple case.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`包的`Fields`函数可以用于按空格字符拆分句子，如前面提到的。步骤**1-5**涵盖了这种简单情况。'
- en: If any other separator is needed, the `Split` function comes into play. Splitting
    by another separator is covered in steps **6 – 8**. Just note that the whitespace
    in the string is omitted.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要其他分隔符，就需要使用`Split`函数。使用其他分隔符拆分在步骤**6-8**中介绍。只需注意字符串中的空白字符被省略。
- en: If you need a more complex function to decide whether to split the string at
    a given point, `FieldsFunc` could work for you. One of the function's argument
    is the function that consumes the rune of the given string and returns `true`
    if the string should split at that point.  This option is covered by steps **9
    – 11**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更复杂的函数来决定是否在给定点拆分字符串，`FieldsFunc`可能适合您。函数的一个参数是消耗给定字符串的符文并在该点返回`true`的函数。这个选项由步骤**9-11**覆盖。
- en: The regular expression is the last option mentioned in the example. The `Regexp`
    structure of the `regexp` package contains the `Split` method, which works as
    you would expect. It splits the string in the place of the matching group. This
    approach is used in steps **12 – 14.**
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是示例中提到的最后一个选项。`regexp`包的`Regexp`结构包含`Split`方法，它的工作方式与您期望的一样。它在匹配组的位置拆分字符串。这种方法在步骤**12-14**中使用。
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `strings` package also provides the various `SplitXXX` functions that could
    help you to achieve more specific tasks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`包还提供了各种`SplitXXX`函数，可以帮助您实现更具体的任务。'
- en: Joining the string slice with a separator
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分隔符连接字符串切片
- en: The recipe, *Breaking the string into words*, led us through the task of splitting
    the single string into substrings, according to defined rules. This recipe, on
    the other hand, describes how to concatenate the multiple strings into a single
    string with a given string as the separator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*将字符串拆分为单词*这个教程引导我们完成了根据定义的规则将单个字符串拆分为子字符串的任务。另一方面，本教程描述了如何使用给定的字符串作为分隔符将多个字符串连接成单个字符串。'
- en: A real use case could be the problem of dynamically building a SQL select statement
    condition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实的用例可能是动态构建SQL选择语句条件的问题。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe03`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe03`。
- en: Navigate to the directory.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `join.go` file with the following content:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`join.go`文件，内容如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code by executing `go run join.go`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run join.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/9a1a1eeb-08a1-483f-a036-383b264ef022.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a1a1eeb-08a1-483f-a036-383b264ef022.png)'
- en: 'Create the `join_manually.go` file with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`join_manually.go`文件，内容如下：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the code by executing `go run join.go`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run join.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/0235e503-6a97-460a-a1cd-f8b35e807aca.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0235e503-6a97-460a-a1cd-f8b35e807aca.png)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For the purpose of joining the string slice into a single string, the `Join`
    function of the `strings` package is there. Simply, you need to provide the slice
    with strings that are needed to be joined. This way you can comfortably join the
    string slices. The use of the `Join` function is shown in steps **1 – 5.**
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将字符串切片连接成单个字符串，`strings`包的`Join`函数就在那里。简单地说，您需要提供需要连接的字符串切片。这样，您可以舒适地连接字符串切片。步骤**1-5**展示了使用`Join`函数的方法。
- en: Naturally, the joining could be implemented manually by iterating over the slice.
    This way you can customize the separator by some more complex logic. The steps
    **6 – 8** just represent how the manual concatenation could be used with more
    complex decision logic, based on the string that is currently processed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以通过迭代切片来手动实现连接。这样，您可以通过一些更复杂的逻辑自定义分隔符。步骤**6-8**只是表示手动连接如何与更复杂的决策逻辑一起使用，基于当前处理的字符串。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Join` function is provided by the `bytes` package, which naturally serves
    to join the slice of bytes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`函数由`bytes`包提供，自然用于连接字节切片。'
- en: Concatenating a string with writer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用写入器连接字符串
- en: Besides the built-in `+` operator, there are more ways to concatenate the string. 
    This recipe will describe the more performant way of concatenating strings with
    the `bytes` package and the built-in `copy` function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的`+`运算符外，还有更多连接字符串的方法。本教程将描述使用`bytes`包和内置的`copy`函数更高效地连接字符串的方法。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe04`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe04`。
- en: Navigate to the directory.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `concat_buffer.go` file with the following content:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`concat_buffer.go`文件，内容如下：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the code by executing `go run concat_buffer.go`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run concat_buffer.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/2f4a68c8-c2d3-4636-8bd8-fff4422c4ee9.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f4a68c8-c2d3-4636-8bd8-fff4422c4ee9.png)'
- en: 'Create the `concat_copy.go` file with the following content:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`concat_copy.go`文件，内容如下：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the code by executing `go run concat_copy.go`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`go run concat_copy.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/c256f79f-54e0-4dc9-b44c-67a3e711a549.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c256f79f-54e0-4dc9-b44c-67a3e711a549.png)'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The steps **1 - 5** cover the use of the `bytes` package `Buffer` as a performance-friendly
    solution to string concatenation. The `Buffer` structure implements the `WriteString`
    method, which could be used to effectively concatenate the strings into an underlying
    byte slice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤**1-5**涵盖了将`bytes`包`Buffer`作为性能友好的字符串连接解决方案的用法。`Buffer`结构实现了`WriteString`方法，可以用于有效地将字符串连接到底层字节切片中。
- en: There is no need to use this improvement in all situations, just think about
    this in cases where the program is going to concatenate a big number of strings
    (for example, in-memory CSV exports and others).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下都不需要使用这种改进，只需要在程序将要连接大量字符串的情况下考虑一下（例如，在内存中的CSV导出和其他情况）。
- en: The built-in `copy` function presented in steps **6 - 8** could be used to accomplish
    the `string` concatenation. This method requires some assumption about the final
    string length, or it could be done on the fly. However, if the capacity of the
    buffer, where the result is written, is smaller than the sum of the already written
    part and the string to be appended, the buffer must be expanded (usually by the
    allocation of a new slice with bigger capacity).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤**6 - 8**中介绍的内置的`copy`函数可以用于完成`string`的连接。这种方法对最终字符串长度有一些假设，或者可以实时完成。然而，如果结果写入的缓冲区的容量小于已写部分和要附加的字符串的总和，缓冲区必须扩展（通常是通过分配具有更大容量的新切片）。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Just for comparison, there is a benchmark code, which compares the performance
    of the built-in `+` operator, `bytes.Buffer`, and built-in `copy`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仅供比较，这里有一个基准代码，比较了内置的`+`运算符、`bytes.Buffer`和内置的`copy`的性能：
- en: 'Create a `bench` folder and file `bench_test.go` in it with the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建一个`bench`文件夹和文件`bench_test.go`，内容如下：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'See the results of the benchmark run:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看基准测试的结果：
- en: '![](img/c17081b7-fea0-4732-8fe6-817dcef5c142.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c17081b7-fea0-4732-8fe6-817dcef5c142.png)'
- en: Aligning text with tabwriter
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tabwriter对齐文本
- en: In certain cases, the output (usually data output) is done via tabbed text,
    which is formatted in well-arranged cells. This format could be achieved with
    the `text/tabwriter` package. The package provides the `Writer` filter, which
    transforms the text with the tab characters into properly formatted output text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，输出（通常是数据输出）是通过制表文本完成的，这些文本以良好排列的单元格格式化。这种格式可以通过`text/tabwriter`包实现。该包提供了`Writer`过滤器，它将带有制表符的文本转换为格式良好的输出文本。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe05`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe05`。
- en: Navigate to the directory.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `tabwriter.go` file with the following content:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`tabwriter.go`文件，内容如下：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the code by executing `go run tabwriter.go`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run tabwriter.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/b82420b6-4610-4dc0-a2c5-c60ce2564e0c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b82420b6-4610-4dc0-a2c5-c60ce2564e0c.png)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `NewWriter` function call creates the `Writer` filter with configured parameters.
    All data written by this `Writer` is formatted according to the parameters. `os.Stdout`
    is used here for demonstration purposes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`NewWriter`函数创建具有配置参数的`Writer`过滤器。由此`Writer`写入的所有数据都根据参数进行格式化。这里使用`os.Stdout`仅用于演示目的。
- en: The `text/tabwriter` package also provides a few more configuration options,
    such as the `flag` parameter.  The most useful is `tabwriter.AlignRight`, which
    configures the writer to align the content to the right in each column.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`text/tabwriter`包还提供了一些更多的配置选项，比如`flag`参数。最有用的是`tabwriter.AlignRight`，它配置了写入器在每一列中将内容对齐到右侧。'
- en: Replacing part of the string
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换字符串的一部分
- en: Another very common task related to string processing is the replacement of
    the substring in a string. Go standard library provide the `Replace` function
    and `Replacer` type for the replacement of multiple strings at once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串处理相关的另一个非常常见的任务是在字符串中替换子字符串。Go标准库提供了`Replace`函数和`Replacer`类型，用于一次替换多个字符串。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe06`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe06`。
- en: Navigate to the directory.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `replace.go` file with the following content:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`replace.go`文件，内容如下：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the code by executing `go run replace.go`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run replace.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/76243f61-3968-4c87-81ef-303c328e2f7e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76243f61-3968-4c87-81ef-303c328e2f7e.png)'
- en: 'Create the `replacer.go` file with the following content:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`replacer.go`文件，内容如下：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the code by executing `go run replacer.go`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run replacer.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/da6e947d-9685-4b0d-871c-d61272db6f04.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da6e947d-9685-4b0d-871c-d61272db6f04.png)'
- en: 'Create the `regexp.go` file with the following content:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`regexp.go`文件，内容如下：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the code by executing `go run regexp.go`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run regexp.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/9aa3b189-d60a-44e3-8e5e-b8dac48d94e0.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aa3b189-d60a-44e3-8e5e-b8dac48d94e0.png)'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Replace` function of a `strings` package is widely used for simple replacement.
    The last integer argument defines how many replacements will be done (in case
    of `-1`, all strings are replaced. See the second use of `Replace`, where only
    the first two occurrences are replaced.) The use of the `Replace` function is
    presented in steps **1 - 5**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`包的`Replace`函数被广泛用于简单的替换。最后一个整数参数定义了将进行多少次替换（在`-1`的情况下，所有字符串都被替换。看到`Replace`的第二个用法，只有前两次出现被替换）。`Replace`函数的用法在步骤**1
    - 5**中呈现。'
- en: Besides the `Replace` function, the `Replacer` structure also has the `WriteString`
    method. This method will write to the given writer with all replacements defined
    in `Replacer`.  The main purpose of this type is its reusability. It can replace
    multiple strings at once and it is safe for concurrent use; see steps **6 - 8**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Replace`函数，`Replacer`结构也有`WriteString`方法。这个方法将使用`Replacer`中定义的所有替换写入给定的写入器。这种类型的主要目的是可重用性。它可以一次替换多个字符串，并且对并发使用是安全的；参见步骤**6
    - 8**。
- en: The more sophisticated method of replacing the substring, or even the matched
    pattern, is naturally the use of the regular expression. The `Regex` type pointer
    method `ReplaceAllString` could be leveraged for this purpose. Steps **9 - 11**
    illustrate the use of the `regexp` package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 替换子字符串，甚至匹配模式的更复杂方法，自然是使用正则表达式。`Regex`类型指针方法`ReplaceAllString`可以用于此目的。步骤**9
    - 11**说明了`regexp`包的用法。
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If more complex logic for the replacement is needed, the `regexp` package is
    probably the one that should be used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更复杂的逻辑来进行替换，那么`regexp`包可能是应该使用的包。
- en: Finding the substring in text by the regex pattern
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过正则表达式模式在文本中查找子字符串
- en: There are always tasks such as validating the input, searching the document
    for any information, or even cleaning up a given string from unwanted escape characters.
    For these cases, regular expressions are usually used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一些任务，比如验证输入、在文档中搜索信息，甚至从给定字符串中清除不需要的转义字符。对于这些情况，通常使用正则表达式。
- en: The Go standard library contains the `regexp` package, which covers the operations
    with regular expressions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库包含`regexp`包，涵盖了正则表达式的操作。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe07`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe07`。
- en: Navigate to the directory.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `regexp.go` file with the following content:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`regexp.go`文件，内容如下：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the code by executing the `go run regexp.go`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run regexp.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/70ccf05e-39f5-4e35-8df8-48c45e48dd9a.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70ccf05e-39f5-4e35-8df8-48c45e48dd9a.png)'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `FindString` or `FindAllString` functions are the simplest ways to find
    the matching pattern in the given string. The only difference is that the `FindString`
    method of `Regexp` will return only the first occurrence. On the other hand, the
    `FindAllString`, as the name suggests, returns a slice of strings with all occurrences.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindString`或`FindAllString`函数是在给定字符串中查找匹配模式的最简单方法。唯一的区别是`Regexp`的`FindString`方法只会返回第一个匹配项。另一方面，`FindAllString`会返回一个包含所有匹配项的字符串切片。'
- en: The `Regexp` type offers a rich set of `FindXXX` methods. This recipe describes
    only the `String` variations that are usually most useful. Note that the preceding
    code uses the `MustCompile` function of the `regexp` package, which panics if
    the compilation of the regular expression fails.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Regexp`类型提供了丰富的`FindXXX`方法。本教程仅描述了通常最有用的`String`变体。请注意，前面的代码使用了`regexp`包的`MustCompile`函数，如果正则表达式的编译失败，它会引发panic。'
- en: See also
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Besides this complex regular expression pattern matching, it is possible to
    match the substring only. This approach is described in the *Finding the substring
    in a string* recipe of this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种复杂的正则表达式模式匹配，还可以仅匹配子字符串。这种方法在本章的*在字符串中查找子字符串*教程中有描述。
- en: Decoding a string from the non-Unicode charset
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从非Unicode字符集解码字符串
- en: A lesser-known fact is that all content in `.go` files is encoded in UTF-8\.
    Believe it or not the Unicode is not, the only charset in the world. For example,
    the Windows-1250 encoding is widely spread across Windows users.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个鲜为人知的事实是，所有`.go`文件中的内容都是用UTF-8编码的。信不信由你，Unicode并不是世界上唯一的字符集。例如，Windows-1250编码在Windows用户中广泛传播。
- en: When working with non-Unicode strings, you need to transcode the content to
    Unicode. This recipe demonstrates how to decode and encode the non-Unicode strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理非Unicode字符串时，需要将内容转换为Unicode。本教程演示了如何解码和编码非Unicode字符串。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe08`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe08`。
- en: Navigate to the directory.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: Create the file `win1250.txt` with content `Gdańsk`. The file must be encoded
    in the windows-1250 charset. If you are not sure how to do that, just jump to
    step 6 and after you complete step 7, which will create the windows-1250 encoded
    file, you can rename the `out.txt` file and go back to step 4.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建内容为`Gdańsk`的文件`win1250.txt`。该文件必须以windows-1250字符集进行编码。如果不确定如何操作，只需跳到第6步，完成第7步后，将创建windows-1250编码的文件，然后可以将`out.txt`文件重命名并返回第4步。
- en: 'Create the `decode.go` file with the following content:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`decode.go`文件，内容如下：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the code by executing `go run decode.go`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run decode.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/9943be1b-4808-496e-9ebe-90d0947094d0.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9943be1b-4808-496e-9ebe-90d0947094d0.png)'
- en: 'Create a file with the name `encode.go` with the following content:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`encode.go`的文件，内容如下：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the code by executing `go run encode.go`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run encode.go`来运行代码。
- en: See the output in the file `out.txt` in Windows-1250 encoding and UTF-8 encoding.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows-1250编码和UTF-8编码的文件`out.txt`中查看输出。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The package `golang.org/x/text/encoding/charmap` contains the `Charset` type
    for simple encoding and decoding. The type implements the `NewDecoder` method
    that creates the `Decoder` structure.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 包`golang.org/x/text/encoding/charmap`包含了简单编码和解码的`Charset`类型。该类型实现了创建`Decoder`结构的`NewDecoder`方法。
- en: Steps **1 – 5** show the use of the decoding `Reader`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤**1-5**展示了解码`Reader`的用法。
- en: The encoding works analogically. The encoding `Writer` is created and then each
    string written by this `Writer` is encoded into Windows-1250 encoding.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 编码工作类似。创建编码`Writer`，然后由该`Writer`写入的每个字符串都会被编码为Windows-1250编码。
- en: Note that the Windows-1250 was chosen as an example. The package, `golang.org/x/text/encoding/charmap`
    contains a lot of other charset options.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Windows-1250被选择作为示例。包`golang.org/x/text/encoding/charmap`包含了许多其他字符集选项。
- en: Controlling case
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制大小写
- en: 'There are a lot of practical tasks where the modification of case is the most
    common approach. Let''s pick a few of these:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实际任务需要修改大小写。让我们挑选其中的一些：
- en: Case-insensitive comparison
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不区分大小写的比较
- en: Beginning the sentence with an automatic first capital
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动首字母大写
- en: Camel-case to snake-case conversion
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驼峰式转蛇式转换
- en: For these purposes, the `strings` package offers functions `ToLower`, `ToUpper`,
    `ToTitle`, and `Title`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，`strings`包提供了`ToLower`、`ToUpper`、`ToTitle`和`Title`函数。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe09`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe09`。
- en: Navigate to the directory.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `case.go` file with the following content:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`case.go`文件，内容如下：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the code by executing `go run case.go`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run case.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/d144e5ad-7430-44e3-82f1-e18202476c4d.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d144e5ad-7430-44e3-82f1-e18202476c4d.png)'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Note that the title-case mapping in Unicode differs from the uppercase mapping.
    The difference is that the number of characters requires special handling. These
    are mainly ligatures and digraphs such as *fl*, *dz*, and *lj*, plus a number
    of polytonic Greek characters. For example, *U+01C7 (LJ)* maps to *U+01C8 (Lj)*
    rather than to *U+01C9 (lj)*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Unicode中的标题大小写映射与大写映射不同。不同之处在于字符数需要特殊处理。这些主要是连字和双字母，如*fl*，*dz*和*lj*，以及一些多音调希腊字符。例如，*U+01C7
    (LJ)*映射到*U+01C8 (Lj)*，而不是*U+01C9 (lj)*。
- en: For proper case-insensitive comparison, the `EqualFold` function from the `strings`
    package should be used. This function uses case folding to normalize the strings
    and compare them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行适当的不区分大小写比较，应该使用`strings`包中的`EqualFold`函数。该函数使用大小写折叠来规范化字符串并进行比较。
- en: Parsing comma-separated data
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析逗号分隔的数据
- en: There are multiple table data formats. **CSV** (**comma-separated values**)
    is one of the most basic formats largely used for data transport and export. There
    is no standard that defines CSV, but the format itself is described in RFC 4180.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种表格数据格式。**CSV**（逗号分隔值）是用于数据传输和导出的最基本格式之一。没有定义CSV的标准，但格式本身在RFC 4180中有描述。
- en: This recipe introduces how to parse CSV-formatted data comfortably.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例介绍了如何舒适地解析CSV格式的数据。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe10`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe10`。
- en: Navigate to the directory.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create a file named `data.csv` with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`data.csv`的文件，其中包含以下内容：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `data.go` file with the following content:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`data.go`的文件，其中包含以下内容：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the code by executing `go run data.go`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run data.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/788beecb-4faf-49b4-b6ca-21710a3aec1d.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/788beecb-4faf-49b4-b6ca-21710a3aec1d.png)'
- en: 'Create a file named `data_uncommon.csv` with the following content:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`data_uncommon.csv`的文件，其中包含以下内容：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file named `data_uncommon.go` with the following content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`data_uncommon.go`的文件，其中包含以下内容：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the code by executing `go run data_uncommon.go`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run data_uncommon.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/f872ac32-9dae-4681-b8a5-7c6fd0f885cb.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f872ac32-9dae-4681-b8a5-7c6fd0f885cb.png)'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instead of simply scanning the input line by line and using `strings.Split`
    and other methods to parse the CSV format, Go offers a better way. The `NewReader` function
    in the `encoding/csv` package returns the `Reader` structure, which provides the
    API to read the CSV file. The `Reader` struct keeps variables to configure the
    `read` parameters, according to your needs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单地逐行扫描输入并使用`strings.Split`和其他方法解析CSV格式不同，Go提供了更好的方法。`encoding/csv`包中的`NewReader`函数返回`Reader`结构，该结构提供了读取CSV文件的API。`Reader`结构保留了变量来配置`read`参数，根据您的需求。
- en: The `FieldsPerRecord`parameter of `Reader` is a significant setting. This way
    the cell count per row could be validated. By default, when set to `0`, it is
    set to the number of records in a first line. If a positive value is set, the
    number of records must match. If a negative value is set, there is no cell count
    validation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`的`FieldsPerRecord`参数是一个重要的设置。这样可以验证每行的单元格数。默认情况下，当设置为`0`时，它设置为第一行中的记录数。如果设置为正值，则记录数必须匹配。如果设置为负值，则不进行单元格计数验证。'
- en: Another interesting configuration is the `Comment` parameter, which allows you
    to define the comment characters in the parsed data. In the example, a whole line
    is ignored this way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的配置是`Comment`参数，它允许您定义解析数据中的注释字符。在示例中，整行都会被忽略。
- en: Go 1.10 now disallows the use of nonsensical comma and comment settings. This
    means null, carriage return, newline, invalid runes, and the Unicode replacement
    character. Also, setting comma and comment equal to each other is forbidden.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.10现在禁止使用荒谬的逗号和注释设置。这意味着空值、回车、换行、无效符文和Unicode替换字符。还禁止将逗号和注释设置为相等。
- en: Managing whitespace in a string
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理字符串中的空白
- en: The string input could contain too much whitespace, too little whitespace, or
    unsuitable whitespace chars. This recipe includes tips on how to manage these
    and format the string to your needs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串输入可能包含过多的空白、过少的空白或不合适的空白字符。本示例包括了如何处理这些并将字符串格式化为所需格式的提示。
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe11`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe11`。
- en: Navigate to the directory.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create a file named `whitespace.go` with the following content:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`whitespace.go`的文件，其中包含以下内容：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the code by executing `go run whitespace.go`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run whitespace.go`来运行代码。
- en: 'See the output:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/35175b6c-1e9b-4ddd-97a9-6c86aa8c379d.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35175b6c-1e9b-4ddd-97a9-6c86aa8c379d.png)'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Trimming the string before it is handled by the code is pretty common practice,
    and as the preceding code demonstrates, it is easily done by the standard Go library.
    The `strings` library also provides more variations of the `TrimXXX` function,
    which also allows the trimming of other chars from the string.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码处理之前修剪字符串是非常常见的做法，正如前面的代码所示，标准的Go库可以轻松完成这项工作。`strings`库还提供了更多`TrimXXX`函数的变体，也允许修剪字符串中的其他字符。
- en: 'To trim the leading and ending whitespace, the `TrimSpace` function of the `strings`
    package can be used. This typifies the following part of a code, which was also
    included in the example earlier:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要修剪前导和结束的空白，可以使用`strings`包的`TrimSpace`函数。这是代码的以下部分的典型示例，这也是之前示例中包含的：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `regex` package is suitable for replacing multiple spaces and tabs, and
    the string can be prepared for further processing this way. Note that, with this
    method, the break lines are replaced with a single space.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex`包适用于替换多个空格和制表符，可以通过这种方式准备字符串以便进一步处理。请注意，使用此方法时，换行符将被替换为一个空格。'
- en: 'This part of the code represents the use of the regular expression to replace
    all multiple whitespaces with a single space:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一部分表示使用正则表达式将所有多个空格替换为单个空格：
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Padding is not an explicit function for the `strings` package, but it can be
    achieved by the `Sprintf` function of the `fmt` package. The `pad` function in
    code uses the formatting pattern `% <+/-padding>s` and some simple math to find
    out the padding. Finally, the minus sign before the padding number works as the
    right pad, and the positive number as the left pad.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 填充不是`strings`包的显式函数，但可以通过`fmt`包的`Sprintf`函数实现。代码中的`pad`函数使用格式化模式`% <+/-padding>s`和一些简单的数学运算来找出填充。最后，填充数字前的减号作为右填充，正数作为左填充。
- en: See also
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more tips on how to work with regex, you can check the recipe, *Finding
    the substring in text by the regex pattern,* in this chapter*.*
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用正则表达式的更多提示，您可以在本章中查看*通过正则表达式模式在文本中查找子字符串*的示例。
- en: Indenting a text document
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对文本文档进行缩进
- en: The previous recipe depicts how to do string padding and whitespace trimming.
    This one will guide you through the indentation and unindentation of a text document.
    Similar principles from the previous recipes will be used.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例描述了如何进行字符串填充和修剪空白。这个示例将指导您如何对文本文档进行缩进和取消缩进。将使用前面示例中的类似原则。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe12`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe12`。
- en: 'Create the file `main.go` with the following content:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`main.go`的文件，并包含以下内容：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the code by executing `go run main.go` in the Terminal.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`go run main.go`来运行代码。
- en: 'See the output:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/30068e99-b616-4c59-9169-7be545936a62.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30068e99-b616-4c59-9169-7be545936a62.png)'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The indentation is as simple as padding. In this case, the same formatting option
    is used. The more readable form of the `indent` implementation could use the `Repeat`
    function of the `strings` package. The `IndentByRune` function in the preceding
    code applies this approach.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进就像填充一样简单。在这种情况下，使用相同的格式选项。`indent`实现的更可读形式可以使用`strings`包的`Repeat`函数。上述代码中的`IndentByRune`函数应用了这种方法。
- en: Unindenting, in this case, means removing the given count of leading spaces.
    The implementation of `Unindent` in the preceding code removes the minimum number
    of leading spaces or given indentation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，取消缩进意味着删除给定数量的前导空格。在上述代码中，`Unindent`的实现会删除最少数量的前导空格或给定的缩进。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Managing whitespace in a string* recipe also works with spaces in a more
    generous way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理字符串中的空白*示例也以更宽松的方式处理空格。'
