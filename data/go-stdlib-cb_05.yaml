- en: In and Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入和退出
- en: 'This chapter contains the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下教程：
- en: Reading standard input
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取标准输入
- en: Writing standard output and error
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入标准输出和错误
- en: Opening a file by name
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称打开文件
- en: Reading the file into a string
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件读入字符串
- en: Reading/writing a different charset
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写不同的字符集
- en: Seeking a position within a file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中寻找位置
- en: Reading and writing binary data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写二进制数据
- en: Writing to multiple writers at once
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时写入多个写入器
- en: Piping between writer and reader
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入和读取之间的管道
- en: Serializing objects to binary format
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象序列化为二进制格式
- en: Reading and writing ZIP files
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写ZIP文件
- en: Parsing a large XML file effectively
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地解析大型XML文件
- en: Extracting data from an incomplete JSON array
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不完整的JSON数组中提取数据
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will go through typical I/O operations and related tasks, as well
    as the writing and reading of various input sources. We will go through XML processing,
    unzipping compressed files, and using the random access file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍典型的I/O操作和相关任务，以及各种输入源的写入和读取。我们将介绍XML处理、解压缩压缩文件以及使用随机访问文件。
- en: Check if Go is properly installed. The *Getting ready* section from *Retrieving
    the Golang version* recipe of [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    with the Environment,* will help you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Go是否已正确安装。[第1章](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)的*准备就绪*部分，*与环境交互*的*检索Golang版本*教程将对您有所帮助。
- en: Reading standard input
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取标准输入
- en: Every process owns its standard input, output, and error file descriptor. The
    `stdin` serves as the input of the process. This recipe describes how to read
    the data from the `stdin`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都拥有自己的标准输入、输出和错误文件描述符。`stdin`作为进程的输入。本教程描述了如何从`stdin`读取数据。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe01`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe01`。
- en: Navigate to the directory.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `fmt.go` file with the following content:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`fmt.go`的文件，内容如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Execute the code with `go run fmt.go`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go run fmt.go`执行代码。
- en: Enter the input `John` and press *Enter*.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`John`并按*Enter*。
- en: Enter the input `40` and press *Enter*.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`40`并按*Enter*。
- en: 'You will see the following output:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](img/532e051a-c31e-40f6-b1ca-34985ad0bad5.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/532e051a-c31e-40f6-b1ca-34985ad0bad5.png)'
- en: 'Create the file `scanner.go` with the following content:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`scanner.go`的文件，内容如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Execute the code with `go run scanner.go`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go run scanner.go`执行代码。
- en: Enter the input `Hello` and press *Enter*.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`Hello`并按*Enter*。
- en: Press *CTRL* + *C* to send `SIGINT`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*CTRL* + *C*发送`SIGINT`。
- en: 'See the output:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/ae3dadf0-5209-47e0-9fcb-8cbfb0c0d3e0.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae3dadf0-5209-47e0-9fcb-8cbfb0c0d3e0.png)'
- en: 'Create the file `reader.go` with the following content:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`reader.go`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Execute the code with the piped input `echo 'Go is awesome!' | go run reader.go`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用管道输入`echo 'Go is awesome!' | go run reader.go`执行代码。
- en: 'See the output:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/0742d0f6-4be5-4905-93f4-f03a22399cb2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0742d0f6-4be5-4905-93f4-f03a22399cb2.png)'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `stdin` of the Go process could be retrieved via the `Stdin` of the `os` package.
    In fact, it is a `File` type which implements the `Reader` interface. Reading
    from the `Reader` is then very easy. The preceding code shows three very common
    ways of how to read from the `Stdin`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go进程的`stdin`可以通过`os`包的`Stdin`获取。实际上，它是一个实现了`Reader`接口的`File`类型。从`Reader`读取非常容易。上述代码展示了从`Stdin`读取的三种常见方式。
- en: The first option illustrates the use of the `fmt` package, which provides the
    functions `Scan`, `Scanf`, and `Scanln`. The `Scanf` function reads the input
    into given variable(s). The advantage of `Scanf` is that you can determine the
    format of the scanned value. The `Scan` function just reads the input into a variable
    (without predefined formatting) and `Scanln,` as its name suggests, reads the
    input ended with the line break.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项演示了`fmt`包的使用，该包提供了`Scan`、`Scanf`和`Scanln`函数。`Scanf`函数将输入读取到给定的变量中。`Scanf`的优点是可以确定扫描值的格式。`Scan`函数只是将输入读取到变量中（没有预定义的格式），而`Scanln`则像其名称一样，读取以换行符结束的输入。
- en: The `Scanner`, which is the second option shown in the sample code, provides
    a convenient way of scanning larger input. The `Scanner` contains the function
    `Split` by which the custom split function could be defined. For example, to scan
    the words from `stdin`, you can use `bufio.ScanWords` predefined `SplitFunc`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`是示例代码中显示的第二个选项，它提供了一种方便的扫描大量输入的方式。`Scanner`包含了`Split`函数，可以定义自定义的分割函数。例如，要从`stdin`扫描单词，可以使用`bufio.ScanWords`预定义的`SplitFunc`。'
- en: The reading via the `Reader` API is the last presented approach. This one provides
    you with more control of  how the input is read.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Reader` API进行读取是最后介绍的方法。这种方法可以更好地控制输入的读取方式。
- en: Writing standard output and error
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入标准输出和错误
- en: As the previous recipe describes, each process has `stdin`, a `stdout` and `stderr` file
    descriptors. The standard approach is the use of `stdout` as a process output
    and `stderr` as process error output. As these are the file descriptors, the destination
    where the data is written could be anything, from the console to the socket. This
    recipe will show you how to write the `stdout` and `stderr`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的教程所述，每个进程都有`stdin`、`stdout`和`stderr`文件描述符。标准方法是使用`stdout`作为进程输出，`stderr`作为进程错误输出。由于这些是文件描述符，数据写入的目标可以是任何东西，从控制台到套接字。本教程将向您展示如何写入`stdout`和`stderr`。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe02`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe02`。
- en: Navigate to the directory.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `stdouterr.go` file with the following content:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`stdouterr.go`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Execute the code with `go run stdouterr.go`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go run stdouterr.go`执行代码。
- en: 'See the output:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/af239952-6510-453a-991a-45c10e728bdd.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af239952-6510-453a-991a-45c10e728bdd.png)'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As with the `Stdin` from the previous recipe, the `Stdout` and `Stderr` are
    the file descriptors. So these are implementing the `Writer` interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面示例中的`Stdin`一样，`Stdout`和`Stderr`是文件描述符。因此，它们实现了`Writer`接口。
- en: The preceding example shows a few ways of how to write into these via the `io.WriteString`
    function, with the use of the `Writer` API and by the `fmt` package and `FprintXX`
    functions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何通过`io.WriteString`函数、`Writer` API的使用以及`fmt`包和`FprintXX`函数来写入这些内容的几种方法。
- en: Opening a file by name
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过名称打开文件
- en: File access is a very common operation used to store or read the data. This
    recipe illustrates how to open a file by its name and path, using the standard
    library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 文件访问是一种非常常见的操作，用于存储或读取数据。本示例说明了如何使用标准库通过文件名和路径打开文件。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe03`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe03`。
- en: Navigate to the directory.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: Create the directory `temp` and create the file `file.txt` in it.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建目录`temp`并在其中创建文件`file.txt`。
- en: Edit the `file.txt` file and write `This file content` into the file.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`file.txt`文件并将`This file content`写入文件。
- en: 'Create the `openfile.go` file with the following content:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`openfile.go`文件：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The file structure should look like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件结构应该如下所示：
- en: '![](img/4c224f1d-45a2-4bbd-9301-f8bffef58e2b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c224f1d-45a2-4bbd-9301-f8bffef58e2b.png)'
- en: Execute the code with `go run openfile.go`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go run openfile.go`执行代码。
- en: 'See the output there should also be a new file, `test.txt`, in the `temp` folder:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出，`temp`文件夹中还应该有一个新文件`test.txt`：
- en: '![](img/f1a5de54-acc5-4330-bb9b-a6716fff71f3.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1a5de54-acc5-4330-bb9b-a6716fff71f3.png)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `os` package offers a simple way of opening the file. The function `Open`
    opens the file by the path, just in read-only mode. Another function, `OpenFile,`
    is the more powerful one and consumes the path to the file, flags, and permissions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包提供了一种简单的打开文件的方式。函数`Open`通过路径打开文件，只以只读模式打开。另一个函数`OpenFile`更强大，需要文件路径、标志和权限。'
- en: The flag constants are defined in the `os` package and you can combine them
    with use of the binary OR operator `|`.  The permissions are set by the `os` package
    constants (for example, `os.ModePerm` ) or by the number notation such as `0777` (permissions: `-rwxrwxrwx`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 标志常量在`os`包中定义，可以使用二进制OR运算符`|`组合它们。权限由`os`包常量（例如`os.ModePerm`）或数字表示法（如`0777`，权限为`-rwxrwxrwx`）设置。
- en: Reading the file into a string
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文件读取为字符串
- en: In the previous recipes, we saw the reading from `Stdin` and the opening of
    the file. In this recipe, we will combine these two a little bit and show how
    to read the file into a string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了从`Stdin`读取和打开文件。在本示例中，我们将稍微结合这两者，并展示如何将文件读取为字符串。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe04`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe04`。
- en: Navigate to the directory.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: Create the directory `temp` and create the file `file.txt` in it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建目录`temp`并在其中创建文件`file.txt`。
- en: Edit the `file.txt` file and write multiple lines into the file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`file.txt`文件并写入多行内容。
- en: 'Create the `readfile.go` file with the following content:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`readfile.go`文件：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execute the code with `go run readfile.go`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go run readfile.go`执行代码。
- en: 'See the output:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/17491f12-c0cc-4f82-9557-3a857bddb2d7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17491f12-c0cc-4f82-9557-3a857bddb2d7.png)'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reading from the file is simple because the `File` type implements both
    the `Reader` and `Writer` interfaces. This way, all functions and approaches applicable
    to the `Reader` interface are applicable to the `File` type. The preceding example
    shows how to read the file with the use of `Scanner` and write the content to
    the bytes buffer (which is more performant than string concatenation). This way,
    you are able to control the volume of content read from a file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取很简单，因为`File`类型实现了`Reader`和`Writer`接口。这样，所有适用于`Reader`接口的函数和方法都适用于`File`类型。前面的示例展示了如何使用`Scanner`读取文件并将内容写入字节缓冲区（这比字符串连接更高效）。这样，您可以控制从文件中读取的内容量。
- en: The second approach with `ioutil.ReadFile` is simpler but should be used carefully,
    because it reads the whole file. Keep in mind that the file could be huge and
    it could threaten the stability of the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法使用`ioutil.ReadFile`更简单，但应谨慎使用，因为它会读取整个文件。请记住，文件可能很大，可能会威胁应用程序的稳定性。
- en: Reading/writing a different charset
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取/写入不同的字符集
- en: It is not an exception that the input from various sources could come in various
    charsets. Note that a lot of systems use the Windows operating system but there
    are others. Go, by default, expects that the strings used in the program are UTF-8
    based. If they are not, then decoding from the given charset must be done to be
    able to work with the string. This recipe will show the reading and writing of
    the file in a charset other than UTF-8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 各种来源的输入可能以各种字符集的形式出现并不是例外。请注意，许多系统使用Windows操作系统，但也有其他系统。Go默认期望程序中使用的字符串是基于UTF-8的。如果不是，则必须从给定的字符集解码以便能够处理该字符串。本示例将展示以UTF-8之外的字符集读取和写入文件。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe05`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe05`。
- en: Navigate to the directory.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `charset.go` file with the following content:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容创建`charset.go`文件：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Execute the code with `go run charset.go`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go run charset.go`执行代码。
- en: 'See the output:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/83161d00-7702-4063-ac5c-b3f274b805b6.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83161d00-7702-4063-ac5c-b3f274b805b6.png)'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `golang.org/x/text/encoding/charmap` package contains the `Charmap` type
    pointer constants that represent the widely used charsets. The `Charmap` type
    provides the methods for creating the encoder and decoder for the given charset.
    The `Encoder` creates the encoding `Writer` which encodes the written bytes into
    the chosen charset. Similarly, the `Decoder` can create the decoding `Reader`,
    which decodes all read data from the chosen charset.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang.org/x/text/encoding/charmap` 包包含代表广泛使用的字符集的 `Charmap` 类型指针常量。`Charmap` 类型提供了为给定字符集创建编码器和解码器的方法。`Encoder` 创建编码 `Writer`，将写入的字节编码为所选字符集。类似地，`Decoder` 可以创建解码 `Reader`，从所选字符集解码所有读取的数据。'
- en: See also
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Chapter 2](f6e11b1c-c7b2-49db-9f21-b6f741edf021.xhtml), *String and Things,* also
    contains the recipe *Decoding a string from the non-Unicode charset* for encoding/decoding
    a string into another charset.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](f6e11b1c-c7b2-49db-9f21-b6f741edf021.xhtml)，*字符串和其他内容*，还包含了编码/解码字符串到另一个字符集的教程*从非Unicode字符集解码字符串*。'
- en: Seeking a position within a file
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中寻找位置
- en: In some cases, you need to read from or write to a particular location in a
    file, such as an indexed file. The recipe will show you how to use the position
    seeking in the context of flat file operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您需要从文件的特定位置读取或写入，例如索引文件。本教程将向您展示如何在平面文件操作的上下文中使用位置寻找。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe06`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹 `chapter05/recipe06`。
- en: Navigate to the directory.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `flatfile.txt` with the following content:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `flatfile.txt` 的文件，并包含以下内容：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the `fileseek.go` file with the following content:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `fileseek.go` 的文件，并包含以下内容：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Execute the code with `go run fileseek.go`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `go run fileseek.go` 执行代码。
- en: 'See the output:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/6601b762-377d-4627-822d-055bcecc676e.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6601b762-377d-4627-822d-055bcecc676e.png)'
- en: Display the file in hex `xxd flatfile.txt`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以十六进制显示文件 `xxd flatfile.txt`。
- en: '![](img/bcd5da38-fab2-4e69-9631-050403bc2387.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcd5da38-fab2-4e69-9631-050403bc2387.png)'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding example uses the `flatfile` as an illustration of how to seek,
    read and write at the position in the file. In general, for moving the position
    of the current pointer in the `File`, the `Seek` method can be used. It takes
    two arguments and these are, position and how to count the position, `0 - relative
    to file origin, 1 - relative to current position, 2 - relative to the end of file`.
    This way you are able to move the cursor within the file. The `Seek` method is
    used in the implementation of the `readLine` function in the preceding code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用 `flatfile` 作为演示如何在文件中寻找、读取和写入的例子。通常，可以使用 `Seek` 方法来移动当前指针在 `File` 中的位置。它接受两个参数，即位置和如何计算位置，`0
    - 相对于文件原点，1 - 相对于当前位置，2 - 相对于文件末尾`。这样，您可以在文件中移动光标。`Seek` 方法在前面代码中的 `readLine` 函数的实现中使用。
- en: 'The `flatfile` is the most basic form of how to store the data. The record
    structure has a fixed length and the same for the record parts. The structure
    of the flat file in the example is: `ID` - 4 chars, `FirstName` - 10 chars, `LastName`
    - 10 chars. The whole record is 24 chars long, ended by a line break which is
    the 25^(th) character.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatfile` 是存储数据的最基本形式。记录结构具有固定长度，记录部分也是如此。示例中的平面文件结构是：`ID` - 4个字符，`FirstName`
    - 10个字符，`LastName` - 10个字符。整个记录长度为24个字符，以换行符结束，即第25个字符。'
- en: The `os.File` also contains the `ReadAt` and `WriteAt` methods. These methods
    consume that the bytes to be written/read and the offset where to start. These
    simplify the writing and reading to a certain position in a file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.File` 还包含 `ReadAt` 和 `WriteAt` 方法。这些方法消耗要写入/读取的字节和开始的偏移量。这简化了在文件中特定位置的写入和读取。'
- en: Note that the example assumes that each rune is only one byte, which does not
    have to be true for special characters, and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，示例假定每个符文只有一个字节，这对于特殊字符等可能并不正确。
- en: Reading and writing binary data
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入二进制数据
- en: This recipe describes how to write and read any type in the binary form.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程描述了如何以二进制形式写入和读取任何类型。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe07`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹 `chapter05/recipe07`。
- en: Navigate to the directory.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `rwbinary.go` file with the following content:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `rwbinary.go` 的文件，并包含以下内容：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Execute the code by `go run rwbinary.go`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `go run rwbinary.go` 执行代码。
- en: 'See the output:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/b458f916-abcd-4d50-9727-088ac0d7f720.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b458f916-abcd-4d50-9727-088ac0d7f720.png)'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The binary data could be written with the use of the `encoding/binary` package.
    The function `Write` consumes the `Writer` where the data should be written, the
    byte order (`BigEndian`/`LittleEndian`) and finally, the value to be written into
    `Writer`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `encoding/binary` 包写入二进制数据。函数 `Write` 消耗应该写入数据的 `Writer`，字节顺序（`BigEndian`/`LittleEndian`），最后是要写入 `Writer` 的值。
- en: To read the binary data analogically, the `Read` function could be used. Note
    that there is no magic in reading the data from the binary source. You need to
    be sure what data you are fetching from the `Reader`. If not, the data could be
    fetched into any type which fits the size.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要类似地读取二进制数据，可以使用 `Read` 函数。请注意，从二进制源读取数据并没有什么神奇之处。您需要确定从 `Reader` 中获取的数据是什么。如果不确定，数据可能会被获取到适合大小的任何类型中。
- en: Writing to multiple writers at once
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同时向多个写入器写入
- en: When you need to write the same output into more than one target, there is a
    helping hand available in the built-in package. This recipe shows how to implement
    writing simultaneously into multiple targets.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要将相同的输出写入多个目标时，内置包中提供了帮助。本教程展示了如何同时实现写入多个目标。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe08`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹 `chapter05/recipe08`。
- en: Navigate to the directory.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `multiwr.go` file with the following content:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `multiwr.go` 的文件，并包含以下内容：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Execute the code by `go run multiwr.go`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `go run multiwr.go` 执行代码。
- en: 'See the output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/d7b4294a-1497-4682-93c1-9cdef3d746ab.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7b4294a-1497-4682-93c1-9cdef3d746ab.png)'
- en: 'Check the content of the created file:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查创建文件的内容：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `io` package contains the `MultiWriter` function with variadic parameters
    of  `Writers`.  When the `Write` method on the `Writer` is called, then the data
    is written to all underlying `Writers`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`io`包含`MultiWriter`函数，带有`Writers`的可变参数。当调用`Writer`上的`Write`方法时，数据将被写入所有底层的`Writers`。'
- en: Piping between writer and reader
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在写入器和读取器之间进行管道传输
- en: The pipes between processes are the easy way to use the output of the first
    process as the input of other processes. The same concept could be done in Go,
    for example, to pipe data from one socket to another socket, to create the tunneled
    connection. This recipe will show you how to create the pipe with use of the Go
    built-in library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 进程之间的管道是使用第一个进程的输出作为其他进程的输入的简单方法。在Go中也可以使用相同的概念，例如，将数据从一个套接字传输到另一个套接字，创建隧道连接。本教程将向您展示如何使用Go内置库创建管道。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: Open the console and create the folder `chapter05/recipe09`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe09`。
- en: Navigate to the directory.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `pipe.go` file with the following content:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`pipe.go`文件，内容如下：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Execute the code by `go run pipe.go`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run pipe.go`执行代码。
- en: 'See the output:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/1fbd9339-5bc4-4ade-988e-637e7f30cc9c.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fbd9339-5bc4-4ade-988e-637e7f30cc9c.png)'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `io.Pipe` function creates the in-memory pipe and returns both ends of the
    pipe, the `PipeReader` on one side and `PipeWriter` on the other side. Each `Write`
    to `PipeWriter` is blocked until it is consumed by `Read` on the other end.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Pipe`函数创建内存管道，并返回管道的两端，一端是`PipeReader`，另一端是`PipeWriter`。对`PipeWriter`的每次`Write`都会被阻塞，直到另一端的`Read`消耗。'
- en: The example shows the piping output from the executed command to the standard
    output of the parent program. By assigning the `pWriter` to `cmd.Stdout`, the
    standard output of the child process is written to the pipe, and the `io.Copy`
    in `goroutine` consumes the written data, by copying the data to `os.Stdout.`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例显示了从执行命令的输出到父程序的标准输出的管道输出。通过将`pWriter`分配给`cmd.Stdout`，子进程的标准输出被写入管道，`goroutine`中的`io.Copy`消耗写入的数据，将数据复制到`os.Stdout`。
- en: Serializing objects to binary format
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象序列化为二进制格式
- en: Besides the well-known JSON and XML, Go also offers the binary format, `gob`.
    This recipe goes through the basic concept of how to use the `gob` package.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了众所周知的JSON和XML之外，Go还提供了二进制格式`gob`。本教程将介绍如何使用`gob`包的基本概念。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: Open the console and create the folder `chapter05/recipe10`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe10`。
- en: Navigate to the directory.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `gob.go` file with the following content:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`gob.go`文件，内容如下：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Execute the code by `go run gob.go`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run gob.go`执行代码。
- en: 'See the output:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/3e247b11-1775-4a73-a368-b5c28527e458.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e247b11-1775-4a73-a368-b5c28527e458.png)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `gob` serialization and deserialization need the Encoder and Decoder. The
    `gob.NewEncoder` function creates the `Encoder` with the underlying `Writer`.
    Each call of the `Encode` method will serialize the object into a `gob` format.
    The gob format itself is the self-describing binary format. This means each serialized
    struct is preceded by its description.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`gob`序列化和反序列化需要编码器和解码器。`gob.NewEncoder`函数创建具有底层`Writer`的`Encoder`。每次调用`Encode`方法都会将对象序列化为`gob`格式。`gob`格式本身是自描述的二进制格式。这意味着每个序列化的结构都以其描述为前缀。'
- en: To decode the data from the serialized form, the `Decoder` must be created by
    calling the `gob.NewDecoder` with the underlying `Reader`. The `Decode` then accepts
    the pointer to the structure where the data should be deserialized.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要从序列化形式解码数据，必须通过调用`gob.NewDecoder`创建`Decoder`，并使用底层的`Reader`。然后，`Decode`接受应将数据反序列化到的结构的指针。
- en: Note that the gob format does not need the source and destination type to match
    exactly. For the rules, refer to the `encoding`/`gob` package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，gob格式不需要源和目标类型完全匹配。有关规则，请参考`encoding`/`gob`包。
- en: Reading and writing ZIP files
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入ZIP文件
- en: ZIP compression is a widely used compression format. It is usual to use the
    ZIP format for an application to upload a file set or, on the other hand, export
    zipped files as output. This recipe will show you how to handle ZIP files programmatically
    with the use of the standard library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP压缩是一种广泛使用的压缩格式。通常使用ZIP格式来上传文件集或者导出压缩文件作为输出。本教程将向您展示如何使用标准库以编程方式处理ZIP文件。
- en: How to do it...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: Open the console and create the folder `chapter05/recipe11`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe11`。
- en: Navigate to the directory.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `zip.go` file with the following content:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`zip.go`文件，内容如下：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Execute the code by `go run zip.go`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run zip.go`执行代码。
- en: 'See the output:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/04dd5561-7394-45e2-a537-63d42ea2003a.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04dd5561-7394-45e2-a537-63d42ea2003a.png)'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The built-in package `zip` contains the `NewWriter` and `NewReader` functions
    to create the `zip.Writer` to compress, and the `zip.Reader` to decompress the
    zipped content.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 内置包`zip`包含`NewWriter`和`NewReader`函数，用于创建`zip.Writer`以进行压缩，以及`zip.Reader`以进行解压缩。
- en: Each record of the ZIP file is created with the `Create` method of the created
    `zip.Writer` . The returned `Writer` is then used to write the content body.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP文件的每个记录都是使用创建的`zip.Writer`的`Create`方法创建的。然后使用返回的`Writer`来写入内容主体。
- en: To decompress the files, the `OpenReader` function is used to create the `ReadCloser` of
    the records in the zipped file. The `File` field of the created `ReaderCloser`
    is the slice of `zip.File` pointers. The content of the file is obtained by calling
    the `Open` method and by reading the returned `ReadCloser`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压文件，使用`OpenReader`函数创建zipped文件中记录的`ReadCloser`。创建的`ReaderCloser`的`File`字段是`zip.File`指针的切片。通过调用`Open`方法并读取返回的`ReadCloser`来获取文件的内容。
- en: The folders could be created by only adding slashes to the name of the file
    in the `Create` method. An example could be  `folder/newfile.txt`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在`Create`方法的文件名中添加斜杠即可创建文件夹。例如`folder/newfile.txt`。
- en: Parsing a large XML file effectively
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效解析大型XML文件
- en: XML is a very common format for data exchange. The Go library contains support
    for parsing XML files the same way as the JSON. Usually, the struct which corresponds
    to the XML scheme is used and with this help, the XML content is parsed at once.
    The problem is when the XML file is too large to fit into memory and so you need
    to parse the file in chunks. This recipe will reveal how to handle a large XML
    file and parse the required information.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: XML是一种非常常见的数据交换格式。Go库包含对解析XML文件的支持，方式与JSON相同。通常，使用与XML方案对应的结构，并借助此帮助一次解析XML内容。问题在于当XML文件太大而无法放入内存时，因此需要分块解析文件。这个示例将揭示如何处理大型XML文件并解析所需的信息。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe11`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe11`。
- en: Navigate to the directory.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `data.xml` file with the following XML content:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`data.xml`文件，内容如下：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the `xml.go` file with the following content:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`xml.go`文件，内容如下：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Execute the code by `go run xml.go`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run xml.go`执行代码。
- en: 'See the output:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/9dec79ca-2012-491d-ba36-30ef711dad80.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dec79ca-2012-491d-ba36-30ef711dad80.png)'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: With the `NewDecoder` function of the `xml` package, the `Decoder` for the XML
    content is created.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`xml`包的`NewDecoder`函数创建XML内容的`Decoder`。
- en: By calling the `Token` method on the `Decoder,` the `xml.Token` is received.
    The `xml.Token` is the interface which holds the token type. The behavior of the
    code can be defined, based on the type. The sample code tests if the parsed `xml.StartElement`
    is one of the `book` elements. Then it partially parses the data into a `Book`
    structure. This way, the position of the pointer in the underlying `Reader` in
    the `Decoder` is shifted by the struct data, and the parsing can continue.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Decoder`上调用`Token`方法，接收`xml.Token`。`xml.Token`是保存令牌类型的接口。可以根据类型定义代码的行为。示例代码测试解析的`xml.StartElement`是否是`book`元素之一。然后将数据部分解析为`Book`结构。这样，底层`Decoder`中的`Reader`中的指针位置将被结构数据移动，解析可以继续进行。
- en: Extracting data from an incomplete JSON array
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从不完整的JSON数组中提取数据
- en: This recipe contains a very specific use case, where your program consumes the
    JSON from an unreliable source and the JSON contains an array of objects which
    has the beginning token `[` but the number of items in the array is very large,
    and the end of the JSON could be corrupted.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例包含一个非常特定的用例，即您的程序从不可靠的来源消耗JSON，而JSON包含一个具有开始标记`[`的对象数组，但数组中的项目数量非常大，而JSON的结尾可能已损坏。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter05/recipe13`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter05/recipe13`。
- en: Navigate to the directory.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `json.go` file with the following content:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`json.go`文件，内容如下：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Execute the code by `go run json.go`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run json.go`执行代码。
- en: 'See the output:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/00a98c28-2459-4493-b61a-5b8799235dd6.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00a98c28-2459-4493-b61a-5b8799235dd6.png)'
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Besides the `Unmarshall` function, the `json` package also contains the `Decoder`
    API. With `NewDecoder`, the `Decoder` could be created. By calling the `Token`
    method on the decoder, the underlying `Reader` is read and returns the `Token`
    interface. This could hold multiple values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Unmarshall`函数外，`json`包还包含`Decoder` API。使用`NewDecoder`可以创建`Decoder`。通过在解码器上调用`Token`方法，可以读取底层`Reader`并返回`Token`接口。这可以保存多个值。
- en: One of these is the `Delim` type, which is a rune containing one of the `{`,
    `[`, `]`, `}` characters. Based on this, the beginning of the JSON array is detected.
    With the `More` method on the decoder, more objects to decode could be detected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是`Delim`类型，它是包含`{`、`[`、`]`、`}`中之一的rune。基于此，检测到JSON数组的开始。通过解码器上的`More`方法，可以检测到更多要解码的对象。
