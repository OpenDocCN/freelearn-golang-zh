- en: Come to the Server Side
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来到服务器端
- en: 'This chapter contains the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下配方：
- en: Creating the TCP server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建TCP服务器
- en: Creating the UDP server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UDP服务器
- en: Handling multiple clients
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个客户端
- en: Creating the HTTP server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建HTTP服务器
- en: Handling HTTP requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: Creating HTTP middleware layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建HTTP中间件层
- en: Serving static files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Serving content generated with templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供使用模板生成的内容
- en: Handling redirects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理重定向
- en: Handling cookies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理cookies
- en: Gracefully shutdown the HTTP server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地关闭HTTP服务器
- en: Serving secured HTTP content
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供安全的HTTP内容
- en: Resolving form variables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析表单变量
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter covers topics from implementing simple TCP and UDP servers to spinning
    the HTTP server. The recipes will lead you from the HTTP request handling, serving
    the static content, to providing the secured HTTP content.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了从实现简单的TCP和UDP服务器到启动HTTP服务器的主题。这些配方将引导您从处理HTTP请求、提供静态内容，到提供安全的HTTP内容。
- en: Check if Go is properly installed. The *Getting ready* section in the *Retrieving
    Golang version* recipe of *[Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)*, *Interacting
    With Environment,* will help you.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Go是否已正确安装。*[第1章](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)*的*准备就绪*部分中的*检索Golang版本*配方将有所帮助。
- en: Make sure the ports `8080` and `7070` are not used by another application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确保端口`8080`和`7070`没有被其他应用程序使用。
- en: Creating the TCP server
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TCP服务器
- en: In the chapter *Connect the Network,* the client side of the TCP connection
    is presented. In this recipe, the server side will be described.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*连接网络*章节中，介绍了TCP连接的客户端部分。在本配方中，将描述服务器端。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe01`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe01`。
- en: Navigate to the directory.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到该目录。
- en: 'Create the `servertcp.go` file with the following content:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`servertcp.go`文件，内容如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the code by `go run servertcp.go`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run servertcp.go`执行代码：
- en: '![](img/8dfefbc6-9c4b-4e14-b076-71fa553960dd.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dfefbc6-9c4b-4e14-b076-71fa553960dd.png)'
- en: Open another Terminal and execute `nc localhost 8080`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端并执行`nc localhost 8080`。
- en: Write any text, for example, `Hello`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入任何文本，例如`Hello`。
- en: 'See the output:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/8ad77c3b-7195-4721-9c59-3c0a7893c688.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ad77c3b-7195-4721-9c59-3c0a7893c688.png)'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The TCP server could be created using the `net` package. The net package contains
    the `Listen` function that creates the `TCPListener`, which can `Accept` the client
    connections. The `Accept` method calls on the `TCPListener` blocks until the client
    connection is received. If the client connection comes, the `Accept` method returns
    the `TCPConn` connection. The `TCPConn` is a connection to the client that serves
    to read and write data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`net`包创建TCP服务器。net包包含`Listen`函数，用于创建`TCPListener`，可以`Accept`客户端连接。`Accept`方法调用`TCPListener`上的方法，直到接收到客户端连接。如果客户端连接成功，`Accept`方法会返回`TCPConn`连接。`TCPConn`是连接到客户端的连接，用于读取和写入数据。
- en: The `TCPConn` implements the `Reader` and `Writer` interfaces. All the approaches
    to write and read the data could be used. Note that there is a delimiter character
    for reading the data, otherwise, the EOF is received if the client forcibly closes
    the connection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPConn`实现了`Reader`和`Writer`接口。可以使用所有写入和读取数据的方法。请注意，读取数据时有一个分隔符字符，否则，如果客户端强制关闭连接，则会收到EOF。'
- en: Note that this implementation handles only one client at a time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此实现一次只能处理一个客户端。
- en: Creating the UDP server
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UDP服务器
- en: The **User Datagram Protocol** (**UDP**) is one of the essential protocols of
    the internet. This recipe will show you how to listen for the UDP packets and
    read the content.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（UDP）是互联网的基本协议之一。本篇将向您展示如何监听UDP数据包并读取内容。'
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe02`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe02`。
- en: Navigate to the directory.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到该目录。
- en: 'Create the `serverudp.go` file with the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`serverudp.go`文件，内容如下：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Start the server by `go run serverudp.go:`
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run serverudp.go`启动服务器：
- en: '![](img/f8f78af0-6fb6-4921-a76c-3bc5e8d5e9a0.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8f78af0-6fb6-4921-a76c-3bc5e8d5e9a0.png)'
- en: Open another Terminal and execute `nc -u localhost 7070`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端并执行`nc -u localhost 7070`。
- en: Write any message to the Terminal, for example, `Hello`, and hit *Enter*.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中写入任何消息，例如`Hello`，然后按*Enter*。
- en: 'See the output:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/fd570795-3779-4f90-ad46-33ad28dbabbe.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd570795-3779-4f90-ad46-33ad28dbabbe.png)'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As with the TCP server, the UDP server can be created with the help of the `net`
    package. With the use of the `ListenPacket` function, the `PacketConn` is created.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP服务器一样，可以使用`net`包创建UDP服务器。使用`ListenPacket`函数创建`PacketConn`。
- en: The `PacketConn` does not implement the `Reader` and `Writer` interface as the
    `TCPConn`. For reading the received packet, the `ReadFrom` method should be used.
    The `ReadFrom` method blocks until the packet is received. After this, the `Addr`
    of the client is returned (remember the UDP is not connection-based ). To respond to
    the client, the `WriteTo` method of `PacketConn` could be used; this consumes
    the message and the `Addr`, which is the client `Addr`, in this case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`PacketConn`不像`TCPConn`那样实现`Reader`和`Writer`接口。要读取接收到的数据包，应该使用`ReadFrom`方法。`ReadFrom`方法会阻塞，直到接收到数据包。然后返回客户端的`Addr`（记住UDP不是基于连接的）。要响应客户端，可以使用`PacketConn`的`WriteTo`方法；这会消耗消息和`Addr`，在这种情况下是客户端的`Addr`。'
- en: Handling multiple clients
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个客户端
- en: The previous recipes show how to create UDP and TCP servers. The sample codes
    are not ready to handle multiple clients simultaneously. In this recipe, we will
    cover how to handle more clients at any given time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配方展示了如何创建UDP和TCP服务器。示例代码尚未准备好同时处理多个客户端。在本配方中，我们将介绍如何同时处理更多客户端。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe03`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe03`。
- en: Navigate to the directory.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到该目录。
- en: 'Create the `multipletcp.go` file with the following content:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`multipletcp.go`文件，内容如下：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Execute the code by `go run multipletcp.go`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run multipletcp.go`执行代码。
- en: Open two another Terminals and execute the `nc localhost 8080`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另外两个终端并执行`nc localhost 8080`。
- en: Write something to both opened Terminals and see the output. The following two
    images are the connected clients.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个打开的终端中写入一些内容并查看输出。以下两个图像是连接的客户端。
- en: 'Terminal 1 connected to `localhost:8080`:'
  id: totrans-62
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端1连接到`localhost:8080`：
- en: '![](img/a3ff1b6b-ae4e-43db-8eda-51970a7c9c7e.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3ff1b6b-ae4e-43db-8eda-51970a7c9c7e.png)'
- en: 'Terminal 2 connected to `localhost:8080`:'
  id: totrans-64
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端2连接到`localhost:8080`：
- en: '![](img/ed6cbf04-737c-4795-8b0d-7121b5c5e134.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed6cbf04-737c-4795-8b0d-7121b5c5e134.png)'
- en: 'The output in the Terminal where the server is running:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行的终端中的输出：
- en: '![](img/9fc41327-6ecb-4dd7-a4b4-d4b109e1d948.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fc41327-6ecb-4dd7-a4b4-d4b109e1d948.png)'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The TCP server implementation works the same as the previous recipe, *Creating
    the TCP server,* from this chapter. The implementation is enhanced, with the ability
    to handle multiple clients simultaneously. Note that we are now handling the accepted
    connection in the separate `goroutine`. This means the server can continue to
    accept the client connections with the `Accept` method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TCP服务器的实现与本章的前一个配方*创建TCP服务器*相同。实现已增强，具有同时处理多个客户端的能力。请注意，我们现在在单独的`goroutine`中处理接受的连接。这意味着服务器可以继续使用`Accept`方法接受客户端连接。
- en: Because the UDP protocol is not stateful and does not keep any connection, the
    handling of multiple clients is moved to application logic and you need to identify
    the clients and packet sequence. Only the writing response to a client could be
    parallelized with the use of goroutines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为UDP协议不是有状态的，也不保持任何连接，所以处理多个客户端的工作被移动到应用程序逻辑中，您需要识别客户端和数据包序列。只有向客户端写入响应才能使用goroutines并行化。
- en: Creating the HTTP Server
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP服务器
- en: The creation of the HTTP server in Go is very easy, and the standard library
    provides more ways of how to do that. Let's look at the very basic one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中创建HTTP服务器非常容易，标准库提供了更多的方法来实现。让我们看看最基本的方法。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe04`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe04`。
- en: Navigate to the directory.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `httpserver.go` file with the following content:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`httpserver.go`文件，内容如下：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Execute the code by `go run httpserver.go`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run httpserver.go`执行代码。
- en: 'See the output:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/d968e06b-4856-4ba6-a454-2da48208c165.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d968e06b-4856-4ba6-a454-2da48208c165.png)'
- en: 'Access the URL `http://localhost:8080` in a browser or use `curl`. The `Hello
    world` content should be displayed:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问URL `http://localhost:8080`，或使用`curl`。应该显示`Hello world`内容：
- en: '![](img/013de77f-87a8-4bd4-91e5-f0dc437e913c.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/013de77f-87a8-4bd4-91e5-f0dc437e913c.png)'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `net/http` package contains a few ways of creating the HTTP server. The
    most simple one is to implement the `Handler` interface from the `net/http` package.
    The `Handler` interface requires the type to implement the `ServeHTTP` method.
    This method handles the request and response.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包包含了几种创建HTTP服务器的方法。最简单的方法是实现`net/http`包中的`Handler`接口。`Handler`接口要求类型实现`ServeHTTP`方法。这个方法处理请求和响应。'
- en: The server itself is created in the form of the `Server` struct from the `net/http`
    package. The `Server` struct requires the `Handler` and `Addr` fields. By calling
    the method, `ListenAndServe`,  the server starts serving the content on the given
    address.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器本身以`net/http`包中的`Server`结构的形式创建。`Server`结构需要`Handler`和`Addr`字段。通过调用`ListenAndServe`方法，服务器开始在给定地址上提供内容。
- en: If the `Serve` method of the `Server` is used, then the `Listener` must be provided.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`Server`的`Serve`方法，则必须提供`Listener`。
- en: The `net/http` package provides also the default server which could be used
    if the `ListenAndServe` is called as a function from the `net/http` package. It
    consumes the `Handler` and `Addr`, the same as the `Server` struct. Internally,
    the `Server` is created.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包还提供了默认服务器，如果从`net/http`包中调用`ListenAndServe`作为函数，则可以使用。它消耗`Handler`和`Addr`，与`Server`结构相同。在内部，创建了`Server`。'
- en: Handling HTTP requests
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理HTTP请求
- en: The applications usually use the URL paths and HTTP methods to define the behavior
    of the application. This recipe will illustrate how to leverage the standard library
    for handling different URLs and methods.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常使用URL路径和HTTP方法来定义应用程序的行为。本配方将说明如何利用标准库来处理不同的URL和方法。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe05`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe05`。
- en: Navigate to the directory.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `handle.go` file with the following content:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`handle.go`文件，内容如下：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute the code by `go run handle.go`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run handle.go`执行代码。
- en: 'Check the following URLs in the browser or via `curl`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中或通过`curl`检查以下URL：
- en: '`http://localhost:8080/user`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/user`'
- en: '`http://localhost:8080/items/clothes`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/items/clothes`'
- en: '`http://localhost:8080/admin/ports`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/admin/ports`'
- en: 'See the output:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/a51caee0-0d11-49f0-8f5f-c947a53ce435.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a51caee0-0d11-49f0-8f5f-c947a53ce435.png)'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `net/http` package contains the `ServeMux` struct, which implements the
    `Handler` interface to be used in a `Server` struct, but also contains the mechanism
    of how to define the handling of different paths. The `ServeMux` pointer contains
    the methods `HandleFunc` and `Handle`, which accept the path, and the `HandlerFunc`
    function handles the request for the given path, or another handler does the same.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包包含`ServeMux`结构，该结构实现了`Handler`接口，可用于`Server`结构，但还包含了如何定义不同路径处理的机制。`ServeMux`指针包含`HandleFunc`和`Handle`方法，接受路径，`HandlerFunc`函数处理给定路径的请求，或者另一个处理程序执行相同的操作。'
- en: See the preceding example for how these could be used. The `Handler` interface
    and `HandlerFunc` require implementing the function with request and response
    arguments. This way you get access to these two structures. The request itself
    gives access to `Headers`, the HTTP method, and other request parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参见前面的示例，了解如何使用这些。`Handler`接口和`HandlerFunc`需要实现带有请求和响应参数的函数。这样你就可以访问这两个结构。请求本身可以访问`Headers`、HTTP方法和其他请求参数。
- en: Creating HTTP middleware layer
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTTP中间件层
- en: Modern applications with web UI or REST API usually use the middleware mechanism
    to log the activity, or guard the security of the given interface. In this recipe,
    the implementation of such a middleware layer will be presented.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 具有Web UI或REST API的现代应用程序通常使用中间件机制来记录活动或保护给定接口的安全性。在本示例中，将介绍实现这种中间件层。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe06`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe06`。
- en: Navigate to the directory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `middleware.go` file with the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的`middleware.go`文件：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Execute the code by `go run middleware.go`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run middleware.go`执行代码。
- en: 'Check the URL `http://localhost:8080/api/users` with use of `curl` by executing
    these two commands (the first without and the second with the `X-Auth` header):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`检查URL`http://localhost:8080/api/users`，通过执行这两个命令（第一个不带`X-Auth`头，第二个带`X-Auth`头）：
- en: '`curl -X GET -I http://localhost:8080/api/users`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl -X GET -I http://localhost:8080/api/users`'
- en: '`curl -X GET -H "X-Auth: authenticated" -I http://localhost:8080/api/users`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curl -X GET -H "X-Auth: authenticated" -I http://localhost:8080/api/users`'
- en: 'See the output:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/4689efc2-a6b0-4f6b-916f-60e382705cad.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4689efc2-a6b0-4f6b-916f-60e382705cad.png)'
- en: Test the URL `http://localhost:8080/api/profile` using the `X-User` header.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`X-User`头测试URL`http://localhost:8080/api/profile`。
- en: 'See the output:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/6508230d-9f72-47ac-8518-6a646364fb91.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6508230d-9f72-47ac-8518-6a646364fb91.png)'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The implementation of middleware in the preceding example leverages the *functions
    as first-class citizens* feature of Golang. The original `HandlerFunc` is wrapped
    into a `HandlerFunc` which checks the `X-Auth` header. The `Secure` function is
    then used to secure the `HandlerFunc`, used in the `HandleFunc` methods of `ServeMux`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，中间件的实现利用了Golang的*函数作为一等公民*功能。原始的`HandlerFunc`被包装成检查`X-Auth`头的`HandlerFunc`。然后使用`Secure`函数来保护`HandlerFunc`，并在`ServeMux`的`HandleFunc`方法中使用。
- en: Note that this is just a simple example, but this way you can implement more
    sophisticated solutions. For example, the user identity could be extracted from
    the `Header` token and subsequently, the new type of handler could be defined
    as `type AuthHandler func(u *User,w http.ResponseWriter, r *http.Request)`. The
    function `WithUser` then creates the `HandlerFunc` for the `ServeMux`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这只是一个简单的示例，但是您可以实现更复杂的解决方案。例如，用户身份可以从`Header`令牌中提取，随后可以定义新类型的处理程序，如`type
    AuthHandler func(u *User,w http.ResponseWriter, r *http.Request)`。然后，`WithUser`函数为`ServeMux`创建`HandlerFunc`。
- en: Serving static files
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Almost any web application needs to serve static files. The serving of JavaScript
    files, static HTML pages, or CSS style sheets could be easily achieved with the
    use of the standard library. This recipe will show how.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何Web应用程序都需要提供静态文件。使用标准库可以轻松实现JavaScript文件、静态HTML页面或CSS样式表的提供。本示例将展示如何实现。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe07`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe07`。
- en: Navigate to the directory.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `welcome.txt` with the following content:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的文件`welcome.txt`：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the folder `html`, navigate to it and create the file `page.html` with
    the following content:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件夹`html`，导航到该文件夹并创建具有以下内容的文件`page.html`：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the `static.go` file with the following content:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的`static.go`文件：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Execute the code by `go run static.go`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run static.go`执行代码。
- en: 'Check the following URLs with the browser or the `curl` utility:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器或`curl`实用程序检查以下URL：
- en: '`http://localhost:8080/html/page.html`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/html/page.html`'
- en: '`http://localhost:8080/welcome`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/welcome`'
- en: 'See the output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/3f559fb9-21e6-4e04-87cb-e8c704091a71.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f559fb9-21e6-4e04-87cb-e8c704091a71.png)'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `net/http` package provides the functions `ServeFile` and `FileServer`,
    which are designed to serve the static files. The `ServeFile` function just consumes
    the `ResponseWriter` and `Request` with the given file path argument and writes
    the content of the file to the response.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包提供了`ServeFile`和`FileServer`函数，用于提供静态文件。`ServeFile`函数只消耗给定文件路径参数的`ResponseWriter`和`Request`，并将文件内容写入响应。'
- en: The `FileServer` function creates the whole `Handler` which consumes the `FileSystem`
    argument. The preceding example uses the `Dir` type, which implements the `FileSystem`
    interface. The `FileSystem` interface requires implementing the `Open` method,
    which consumes string and returns the actual `File` for the given path.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileServer`函数创建整个消耗`FileSystem`参数的`Handler`。前面的示例使用了`Dir`类型，它实现了`FileSystem`接口。`FileSystem`接口需要实现`Open`方法，该方法消耗字符串并返回给定路径的实际`File`。'
- en: Serving content generated with templates
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板生成的内容
- en: For some purposes, it is not necessary to create highly dynamic web UI with
    all the JavaScript, and the static content with generated content could be sufficient.
    The Go standard library provides a way of constructing dynamically generated content.
    This recipe gives a lead into the Go standard library templating.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些目的，不需要使用所有JavaScript创建高度动态的Web UI，生成内容的静态内容可能已经足够。Go标准库提供了一种构建动态生成内容的方法。本示例将引导您进入Go标准库模板化。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe08`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe08`。
- en: Navigate to the directory.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `template.tpl` with the following content:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有以下内容的文件`template.tpl`：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the file `dynamic.go` with the following content:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`dynamic.go`，内容如下：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Execute the code by `go run dynamic.go`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run dynamic.go`执行代码。
- en: 'Check the URL `http://localhost:8080` and see the output:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查URL `http://localhost:8080`并查看输出：
- en: '![](img/7ccdc694-3eb4-4c27-a8a7-fdaa4c8a70b2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ccdc694-3eb4-4c27-a8a7-fdaa4c8a70b2.png)'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Go standard library also contains the package for templating the content.
    The packages `html/template` and `text/template` provide the functions to parse
    the templates and use them to create the output. The parsing is done with the `ParseXXX`
    functions or the methods of the newly-created `Template` struct pointer. The preceding
    example uses the `ParseFiles` function of the `html/template` package.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库还包含用于模板化内容的包。`html/template`和`text/template`包提供了解析模板和使用它们创建输出的函数。解析是使用`ParseXXX`函数或新创建的`Template`结构指针的方法完成的。前面的示例使用了`html/template`包的`ParseFiles`函数。
- en: The templates themselves are text-based documents or pieces of text which contain
    dynamic variables. The use of the template is based on merging the template text
    with the structure that contains the values for the variables present in the template.
    For merging the template with such structures, the `Execute` and `ExecuteTemplate`
    methods are there.  Note that these  consume the writer interface, where the output
    is written; the `ResponseWriter` is used in this case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本身是基于文本的文档或包含动态变量的文本片段。模板的使用基于将模板文本与包含模板中的变量值的结构进行合并。为了将模板与这些结构进行合并，有`Execute`和`ExecuteTemplate`方法。请注意，这些方法使用写入器接口，其中写入输出；在这种情况下使用`ResponseWriter`。
- en: The template syntax and features are explained well in the documentation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 模板语法和特性在文档中有很好的解释。
- en: Handling redirects
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理重定向
- en: Redirects are the usual way of telling the client that the content was moved,
    or there is a needs to look somewhere else to accomplish the request. This recipe
    describes the way to implement redirects with the standard library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向是告诉客户端内容已经移动或需要在其他地方完成请求的常用方式。本教程描述了如何使用标准库实现重定向。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe09`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe09`。
- en: Navigate to the directory.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `redirect.go` with the following content:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`redirect.go`，内容如下：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Execute the code by `go run redirect.go`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run redirect.go`执行代码。
- en: Use `curl -v -L http://localhost:8080/s`
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl -v -L http://localhost:8080/s`
- en: '`ecured/handle` to see if redirect works:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecured/handle`以查看重定向是否有效：'
- en: '![](img/9aea8cdd-df60-4b0a-9a56-93249e28c8bd.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aea8cdd-df60-4b0a-9a56-93249e28c8bd.png)'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `net/http` package contains a simple way of executing the redirect. The
    `RedirectHandler` could be utilized. The function consumes the `URL` where the
    request will be redirected and the `status code` which will be sent to client.
    The function itself sends results to the `Handler`, which could be used in the `Handle`
    method of `ServeMux` (the example uses the default one directly from the package).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包中包含了执行重定向的简单方法。可以利用`RedirectHandler`。该函数接受请求将被重定向的`URL`和将发送给客户端的`状态码`。该函数本身将结果发送给`Handler`，可以在`ServeMux`的`Handle`方法中使用（示例直接使用包中的默认方法）。'
- en: The second approach is the use of the `Redirect` function, which does the redirect
    for you. The function consumes `ResponseWriter`, the request pointer and the same
    as `RequestHandler`, the URL and status code, which will be sent to the client.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用`Redirect`函数，它可以为您执行重定向。该函数接受`ResponseWriter`、请求指针和与`RequestHandler`相同的URL和状态码，这些将发送给客户端。
- en: The redirect could be also done with the help of manually setting the `Location`
    header and writing the proper status code. The Go library only makes this easy
    to use for the developer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向也可以通过手动设置`Location`头并编写适当的状态码来完成。Go库使开发人员能够轻松使用这一功能。
- en: Handling cookies
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理cookies
- en: Cookies provide a way of easily storing data on the client side. This recipe
    illustrates how to set, retrieve and remove the cookies with the help of the standard
    library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies提供了一种在客户端方便地存储数据的方式。本教程演示了如何使用标准库设置、检索和删除cookies。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe10`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe10`。
- en: Navigate to the directory.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `cookies.go` with the following content:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建文件`cookies.go`，内容如下：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Execute the code by `go run cookies.go`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run cookies.go`执行代码。
- en: 'Access the URLs in the following sequence and see:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下顺序访问URL并查看：
- en: 'The response in a browser directed to the URL `http://localhost:8080/set`:'
  id: totrans-184
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中访问URL `http://localhost:8080/set`的响应：
- en: '![](img/94747619-36e0-41ac-80b9-afd0caefacbd.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94747619-36e0-41ac-80b9-afd0caefacbd.png)'
- en: 'The response in a browser directed to the URL `http://localhost:8080/get` (the
    response contains the available cookies):'
  id: totrans-186
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中访问URL `http://localhost:8080/get`的响应（响应包含可用的cookies）：
- en: '![](img/71f9eafc-cbbe-4c49-a539-d31ba6aa96d2.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71f9eafc-cbbe-4c49-a539-d31ba6aa96d2.png)'
- en: 'The response in a browser directed to the URL `http://localhost:8080/remove` (this
    will remove the cookie):'
  id: totrans-188
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中访问URL `http://localhost:8080/remove`的响应（这将删除cookie）：
- en: '![](img/b753a078-b68e-47cf-bb10-7f83a8a5897a.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b753a078-b68e-47cf-bb10-7f83a8a5897a.png)'
- en: 'The response in a browser directed to the URL `http://localhost:8080/get` (proof
    that the cookie `X-Cookie` was removed):'
  id: totrans-190
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中访问URL `http://localhost:8080/get`的响应（证明cookie `X-Cookie`已被移除）：
- en: '![](img/50a7c538-9702-4101-883b-9be3d0f5f1a8.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50a7c538-9702-4101-883b-9be3d0f5f1a8.png)'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `net/http` package also provides the functions and mechanisms to operate
    on cookies. The sample code presents how to set/get and remove the cookies. The
    `SetCookie` function accepts the `Cookie` struct pointer that represents the cookies,
    and naturally the `ResponseWriter`. The `Name`, `Value`, `Domain`, and expiration
    are set directly in the `Cookie` struct. Behind the scenes, the `SetCookie` function
    writes the header to set the cookies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包还提供了操作cookie的函数和机制。示例代码介绍了如何设置/获取和删除cookie。`SetCookie`函数接受代表cookie的`Cookie`结构指针，自然也接受`ResponseWriter`。`Name`、`Value`、`Domain`和过期时间直接在`Cookie`结构中设置。在幕后，`SetCookie`函数写入头文件以设置cookie。'
- en: The cookie values could be retrieved from the `Request` struct. The method `Cookie`
    with the name parameter returns the pointer to the `Cookie`, if the cookie exists
    in the request.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从`Request`结构中检索cookie值。具有名称参数的`Cookie`方法返回指向`Cookie`的指针，如果请求中存在cookie。
- en: To list all cookies within the request, the method `Cookies` could be called.
    This method returns the slice of the `Cookie` structs pointers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出请求中的所有cookie，可以调用`Cookies`方法。此方法返回`Cookie`结构指针的切片。
- en: To let the client know that the cookie should be removed, the `Cookie` with
    the given name could be retrieved and the `MaxAge` field should be set to a negative
    value. Note that this is not a Go feature, but the way the client should work.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端知道应该删除cookie，可以检索具有给定名称的`Cookie`，并将`MaxAge`字段设置为负值。请注意，这不是Go的特性，而是客户端应该工作的方式。
- en: Gracefully shutdown the HTTP server
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅关闭HTTP服务器
- en: In [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting with
    the Environment*, the mechanism of how to implement graceful shutdown was presented.
    In this recipe, we will describe how to shut down the HTTP server and give it
    time to handle the existing clients.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)中，*与环境交互*，介绍了实现优雅关闭的机制。在这个示例中，我们将描述如何关闭HTTP服务器并给予它处理现有客户端的时间。
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Open the console and create the folder `chapter09/recipe11`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe11`。
- en: Navigate to the directory.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `gracefully.go` with the following content:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`gracefully.go`的文件，内容如下：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Execute the code by `go run gracefully.go`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run gracefully.go`执行代码。
- en: 'Wait until the server starts listening:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待服务器开始监听：
- en: '![](img/77347b25-fda9-49ea-b253-64bcb6839553.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77347b25-fda9-49ea-b253-64bcb6839553.png)'
- en: Connect with the browser to `http://localhost:8080`; this will cause the browser
    to wait for a response for 10 seconds.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用浏览器连接到`http://localhost:8080`；这将导致浏览器等待10秒钟的响应。
- en: Within the interval of 10 seconds, press *Ctrl* + *C* to send the `SIGINT` signal.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在10秒的间隔内，按下*Ctrl* + *C*发送`SIGINT`信号。
- en: Try to connect again from another tab (the server should refuse other connections).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试从另一个标签页重新连接（服务器应该拒绝其他连接）。
- en: 'See the output in the Terminal:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/fe6669e0-c15f-4bae-9492-be6c5636a481.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe6669e0-c15f-4bae-9492-be6c5636a481.png)'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Server` from the `net/http` package provides the method to gracefully shutdown
    the connection. The preceding code starts the HTTP server in a separate `goroutine` and
    keeps the reference to the `Server` struct in a variable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包中的`Server`提供了优雅关闭连接的方法。前面的代码在一个单独的`goroutine`中启动HTTP服务器，并在一个变量中保留对`Server`结构的引用。'
- en: By calling the `Shutdown` method, the `Server` starts refusing new connections
    and closes opened listeners and idle connections. Then it waits indefinitely for
    the already pending connections, till these become idle. After all the connections
    are closed, the server shuts down. Note that the `Shutdown` method consumes the
    `Context`. If the provided `Context` expires prior to the shutdown, then the error
    from `Context` is returned and the `Shutdown` does not block anymore.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Shutdown`方法，`Server`开始拒绝新连接并关闭打开的监听器和空闲连接。然后它无限期地等待已经挂起的连接，直到这些连接变为空闲。在所有连接关闭后，服务器关闭。请注意，`Shutdown`方法会消耗`Context`。如果提供的`Context`在关闭之前过期，则会返回来自`Context`的错误，并且`Shutdown`不再阻塞。
- en: Serving secured HTTP content
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供安全的HTTP内容
- en: This recipe describes the simplest way of creating the HTTP server, which serves
    the content via the TLS/SSL layer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例描述了创建HTTP服务器的最简单方式，它通过TLS/SSL层提供内容。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Prepare the private key and self-signed X-509 certificate. For this purpose,
    the OpenSSL utility could be used. By executing the command `openssl genrsa -out
    server.key 2048`, the private key derived with the use of an RSA algorithm is
    generated to the file `server.key`. Based on this private key, the X-509 certificate
    could be generated by calling `openssl req -new -x509 -sha256 -key server.key
    -out server.crt -days 365`. The `server.crt` file is created.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 准备私钥和自签名的X-509证书。为此，可以使用OpenSSL实用程序。通过执行命令`openssl genrsa -out server.key 2048`，使用RSA算法生成私钥到文件`server.key`。基于此私钥，可以通过调用`openssl
    req -new -x509 -sha256 -key server.key -out server.crt -days 365`生成X-509证书。创建`server.crt`文件。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Open the console and create the folder `chapter09/recipe12`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter09/recipe12`。
- en: Navigate to the directory.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: Place the created `server.key` and `server.crt` files in it.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建的`server.key`和`server.crt`文件放入其中。
- en: 'Create the file `servetls.go` with the following content:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`servetls.go`的文件，内容如下：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Execute the server by `go run servetls.go`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run servetls.go`执行服务器。
- en: 'Access the URL `https://localhost:8080` (the HTTPS protocol is used). If using
    the `curl` utility, the `--insecure` flag must be used, as our certificate is
    self-signed and not trusted:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问URL `https://localhost:8080`（使用HTTPS协议）。如果使用`curl`实用程序，则必须使用`--insecure`标志，因为我们的证书是自签名的，不受信任：
- en: '![](img/e896790c-9b63-4b81-905f-5ae525a862a9.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e896790c-9b63-4b81-905f-5ae525a862a9.png)'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Besides the `ListenAndServe` function, within the `net/http` package, the TLS
    variant for serving HTTP via SSL/TLS, exists. With the use of the `ListenAndServeTLS`
    method of the `Server`, the secured HTTP is served. The `ListenAndServeTLS` consumes
    the path to the private key and X-509 certificate. Naturally, the function `ListenAndServeTLS`,
    directly from `net/http` package, could be used.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`net/http`包中的`ListenAndServe`函数之外，还存在用于通过SSL/TLS提供HTTP服务的TLS变体。通过`Server`的`ListenAndServeTLS`方法，可以提供安全的HTTP服务。`ListenAndServeTLS`需要私钥和X-509证书的路径。当然，也可以直接使用`net/http`包中的`ListenAndServeTLS`函数。
- en: Resolving form variables
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析表单变量
- en: The HTTP `POST` form is a very common way of passing the information to the
    server, in a structured way. This recipe shows how to parse and access these on
    the server side.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的`POST`表单是向服务器传递信息的一种常见方式，以结构化的方式。这个示例展示了如何在服务器端解析和访问这些信息。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter09/recipe12`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台，创建文件夹`chapter09/recipe12`。
- en: Navigate to the directory.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the file `form.go` with the following content:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`form.go`的文件，内容如下：
- en: '[PRE15]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Execute the code by `go run form.go`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`go run form.go`执行代码。
- en: 'Open the second Terminal and execute the `POST` using `curl`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个终端，使用`curl`执行`POST`：
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'See the output in the first Terminal, where the server is running:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行服务器的第一个终端中查看输出：
- en: '![](img/dfb65601-5441-4053-b9e5-01235355f3d3.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dfb65601-5441-4053-b9e5-01235355f3d3.png)'
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Request` struct of the `net/http` package contains the `Form` field which
    contains the `POST` form variables and URL query variables merged. The important
    step in the preceding code is the call of the `ParseForm` method on the `Request`
    pointer. This method call causes the parsing of the `POST` form values and query
    values into a `Form` variable. Note that if the `Get` method on the `Form` field
    is used, the `POST` value of the parameter is prioritized. The `Form` and `PostForm`
    fields are, in fact, of type `url.Values`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包的`Request`结构包含`Form`字段，其中包含了`POST`表单变量和URL查询变量的合并。在前面的代码中，重要的一步是在`Request`指针上调用`ParseForm`方法。这个方法调用会将`POST`表单值和查询值解析为一个`Form`变量。请注意，如果在`Form`字段上使用`Get`方法，则会优先考虑参数的`POST`值。`Form`和`PostForm`字段实际上都是`url.Values`类型。'
- en: If only the parameters from the `POST` form need to be accessed, the `PostForm`
    field of the `Request` is provided. This one keeps only those that were part of
    the `POST` body.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要访问`POST`表单中的参数，可以使用`Request`的`PostForm`字段。这个字段只保留了`POST`主体中的参数。
