- en: Writing Programs in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中编写程序
- en: This chapter will talk about many essential, interesting, and handy Go topics
    that will help you be more productive. I think it would be a good idea to start
    this chapter by compiling and running the Go code of the `hw.go` program from
    the previous chapter. Then, you will learn how to deal with the environment variables
    that can be used by Go, how to process the command-line arguments of a Go program,
    and how to print the output on the screen and get input from the user. Finally,
    you will see how to define functions in Go, learn about the extremely important
    `defer` keyword, look at the data structures that come with Go, and learn what
    Go interfaces are before checking out code that generates random numbers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论许多重要、有趣和实用的Go主题，这将帮助您更加高效。我认为从编译和运行上一章的`hw.go`程序的Go代码开始本章是一个不错的主意。然后，您将学习如何处理Go可以使用的环境变量，如何处理Go程序的命令行参数，以及如何在屏幕上打印输出并从用户那里获取输入。最后，您将了解如何在Go中定义函数，学习极其重要的`defer`关键字，查看Go提供的数据结构，并了解Go接口，然后再查看生成随机数的代码。
- en: 'Therefore, in this chapter, you will become familiar with many Go concepts,
    including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，您将熟悉许多Go概念，包括以下内容：
- en: Compiling your Go programs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译您的Go程序
- en: Go environment variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go环境变量
- en: Using the command-line arguments given to a Go program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传递给Go程序的命令行参数
- en: Getting user input and printing the output on your screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户输入并在屏幕上打印输出
- en: Go functions and the `defer` keyword
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go函数和`defer`关键字
- en: Go data structures and interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go数据结构和接口
- en: Creating random numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数
- en: Compiling Go code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译Go代码
- en: Go does not care about the name of the source file of an autonomous program
    as long as the package name is `main` and there is a `main()` function in it.
    This is because the `main()` function is where the program execution begins. This
    also means that you cannot have multiple `main()` functions in the files of a
    single project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 只要包名是`main`并且其中有`main()`函数，Go就不在乎一个独立程序的源文件的名称。这是因为`main()`函数是程序执行的起点。这也意味着在单个项目的文件中不能有多个`main()`函数。
- en: 'There exist two ways to run a Go program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种运行Go程序的方式：
- en: The first one, `go run`, just executes the Go code without generating any new
    files, only some temporary ones that are deleted afterward
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是`go run`，只是执行Go代码而不生成任何新文件，只会生成一些临时文件，之后会被删除
- en: The second way, `go build`, compiles the code, generates an executable file,
    and waits for you to run the executable file
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方式，`go build`，编译代码，生成可执行文件，并等待您运行可执行文件
- en: This book is written on an Apple Mac OS Sierra system using the Homebrew ([https://brew.sh/](https://brew.sh/))
    version of Go. However, you should have no difficulties compiling and running
    the presented Go code on most Linux and FreeBSD systems, provided that you have
    a relatively recent version of Go.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是在使用Homebrew ([https://brew.sh/](https://brew.sh/))版本的Go的Apple Mac OS Sierra系统上编写的。但是，只要您有一个相对较新的Go版本，您应该不会在大多数Linux和FreeBSD系统上编译和运行所提供的Go代码时遇到困难。
- en: 'So, the first way is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一种方式如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The aforementioned way allows Go to be used as a scripting language. The following
    is the second way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方式允许Go用作脚本语言。以下是第二种方式：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The generated executable file is named after the name of the Go source file,
    which is much better than `a.out`, which is the default filename of the executable
    files generated by the C compiler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的可执行文件以Go源文件的名称命名，这比`a.out`要好得多，后者是C编译器生成的可执行文件的默认文件名。
- en: 'If there is an error in your code, such as a misspelled Go package name when
    calling a Go function, you will get the following kind of error message:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码中有错误，比如在调用Go函数时拼错了Go包名，您将会得到以下类型的错误消息：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you accidentally misspell the `main()` function, you will get the following
    error message because the execution of an autonomous Go program begins from the
    `main()` function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您意外地拼错了`main()`函数，您将会得到以下错误消息，因为独立的Go程序的执行是从`main()`函数开始的：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, I want to show you an error message that will give you a good idea
    about a formatting rule of Go:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想向您展示一个错误消息，它将让您对Go的格式规则有一个很好的了解：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous error message shows us that Go prefers putting curly braces in
    a certain way, which is not the case with most programming languages such as Perl,
    C, and C++. This might look frustrating at first, but it saves you from one extra
    line of code and makes your programs more readable. Note that the preceding code
    uses the *Allman formatting style*, which Go does not accept.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误消息告诉我们，Go更喜欢以一种特定的方式放置大括号，这与大多数编程语言（如Perl、C和C++）不同。这一开始可能看起来令人沮丧，但它可以节省您一行额外的代码，并使您的程序更易读。请注意，前面的代码使用了*Allman格式样式*，而Go不接受这种格式。
- en: The official explanation for this error is that Go requires the use of semicolons
    as statement terminators in many contexts, and the compiler automatically inserts
    the required semicolons when it thinks they are necessary, which in this case
    is at the end of a non-blank line. Therefore, putting the opening brace (`{`)
    on its own line will make the Go compiler to put a semicolon at the end of the
    previous line, which produces the error message.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个错误的官方解释是，Go在许多情况下要求使用分号作为语句终止符，并且编译器会在它认为必要时自动插入所需的分号，这种情况是在非空行的末尾。因此，将开括号（`{`）放在自己的一行上会让Go编译器在前一行末尾加上一个分号，从而产生错误消息。
- en: 'If you think that the `gofmt` tool can save you from similar errors, you will
    be disappointed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为`gofmt`工具可以帮您避免类似的错误，您将会感到失望：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Go compiler has another rule, as you can see in the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在以下输出中所看到的，Go编译器还有另一条规则：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This means that you should not import packages without actually using them in
    your programs. Although this could have been a harmless warning message, your
    Go program will not get compiled. Bear in mind that similar warnings and error
    messages are a good indication that you are missing something, and you should
    try to correct them. You will create a higher quality of code if you treat warnings
    and errors the same.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不应该在程序中导入包而不实际使用它们。虽然这可能是一个无害的警告消息，但你的Go程序将无法编译。请记住，类似的警告和错误消息是你遗漏了某些东西的一个很好的指示，你应该尝试纠正它们。如果你对警告和错误采取相同的态度，你将创建更高质量的代码。
- en: Checking the size of the executable file
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可执行文件的大小
- en: 'So, after successfully compiling `hw.go`, you might want to check the size
    of the generated executable file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在成功编译`hw.go`之后，你可能想要检查生成的可执行文件的大小：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compiling the same Go program on a Linux machine will create the following
    file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上编译相同的Go程序将创建以下文件：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To get a better sense of how big the Go executable is, consider that the executable
    for the same program written in C is about 8432 bytes!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解Go可执行文件的大小，考虑一下，同样的程序用C编写的可执行文件大约为8432字节！
- en: 'So, you might ask why such a huge executable file for such a small program?
    The main reason is that Go executable files are statically build, which means
    that they require no external libraries to run. The use of the `strip(1)` command
    can make the generated executable files a little smaller, but do not expect miracles:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会问为什么一个如此小的程序会生成一个如此庞大的可执行文件？主要原因是Go可执行文件是静态构建的，这意味着它们不需要外部库来运行。使用`strip(1)`命令可以使生成的可执行文件稍微变小，但不要期望奇迹发生：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous process has nothing to do with Go itself because `strip(1)` is
    a Unix command that removes or modifies the symbol table of files and therefore
    reduces their size. Go can perform the work of the `strip(1)` command on its own
    and create smaller executable files, but this method does not always work:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的过程与Go本身无关，因为`strip(1)`是一个Unix命令，它删除或修改文件的符号表，从而减小它们的大小。Go可以自行执行`strip(1)`命令的工作并创建更小的可执行文件，但这种方法并不总是有效：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding output is from a Linux machine; when the same compilation command
    is used on a macOS machine, it will make no difference to the size of the executable
    file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出来自Linux机器；当在macOS机器上使用相同的编译命令时，对可执行文件的大小不会有任何影响。
- en: Go environment variables
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go环境变量
- en: The `go tool` can use many Unix shell environment variables dedicated to Go,
    including `GOROOT`, `GOHOME`, `GOBIN`, and `GOPATH`. The most important Go environment
    variable is `GOPATH`, which specifies the location of your workspace. Usually,
    this is the only environment variable that you will need to define when developing
    Go code; it is to do with the way the files of a project will be organized. This
    means that each project will be organized into three main directories, named `src`,
    `pkg`, and `bin`. However, many people, including me, prefer not to use `GOPATH`
    and manually organize their project files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`go tool`可以使用许多专门用于Go的Unix shell环境变量，包括`GOROOT`、`GOHOME`、`GOBIN`和`GOPATH`。最重要的Go环境变量是`GOPATH`，它指定了你的工作空间的位置。通常，这是你在开发Go代码时需要定义的唯一环境变量；它与项目文件的组织方式有关。这意味着每个项目将被组织成三个主要目录，名为`src`、`pkg`和`bin`。然而，包括我在内的许多人更喜欢不使用`GOPATH`，而是手动组织他们的项目文件。'
- en: So, if you are a big fan of shell variables, you can put all these kinds of
    definitions in either `.bashrc` or `.profile`, which means that these environment
    variables will be active every time you log in to your Unix machine. If you are
    not using the Bash shell, which is the default Linux and macOS shell, then you
    might need to use another start up file. Check out the documentation of your favorite
    Unix shell to find out which file to use.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你是shell变量的忠实粉丝，你可以将所有这些定义放在`.bashrc`或`.profile`中，这意味着这些环境变量将在每次登录到Unix机器时都处于活动状态。如果你没有使用Bash
    shell（默认的Linux和macOS shell），那么你可能需要使用另一个启动文件。查看你喜欢的Unix shell的文档，找出要使用哪个文件。
- en: 'The upcoming screenshot shows part of the output of the following command,
    which displays all the environment variables used by Go:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了以下命令的部分输出，该命令显示了Go使用的所有环境变量：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/87508a77-cb59-4e6f-ac23-d4a412f73ebc.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87508a77-cb59-4e6f-ac23-d4a412f73ebc.png)'
- en: The output of the "go help environment" command
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “go help environment”命令的输出
- en: 'You can find additional information about a particular environment variable
    by executing the next command and replacing `NAME` with the environment variable
    that interests you:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行下一个命令并将`NAME`替换为你感兴趣的环境变量来找到关于特定环境变量的额外信息：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All these environment variables have nothing to do with the actual Go code or
    the execution of the program, but they might affect the development environment;
    therefore, if you happen to see any strange behavior while trying to compile a
    Go program, check the environment variables you are using.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些环境变量与实际的Go代码或程序的执行无关，但它们可能会影响开发环境；因此，如果在尝试编译Go程序时遇到任何奇怪的行为，检查你正在使用的环境变量。
- en: Using command-line arguments
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行参数
- en: Command-line arguments allow your programs to get input, such as the names of
    the files you want to process, without having to write a different version of
    the program. Hence, you cannot create any useful systems software if you're unable
    to process the command-line arguments passed to it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数允许你的程序获取输入，比如你想要处理的文件的名称，而不必编写程序的不同版本。因此，如果你无法处理传递给它的命令行参数，你将无法创建任何有用的系统软件。
- en: 'So here is a naive Go program, named `cla.go`, that prints all its command-line
    arguments, including the name of the executable file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个天真的Go程序，名为`cla.go`，它打印出所有的命令行参数，包括可执行文件的名称：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, Go needs an extra package named `os` in order to read the command-line
    arguments of a program that are stored in the `os.Args` array. In case you do
    not like having multiple import statements, you can rewrite the two import statements
    as follows, which I find much easier to read:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Go需要一个名为`os`的额外包，以便读取存储在`os.Args`数组中的程序的命令行参数。如果您不喜欢有多个导入语句，您可以将两个导入语句重写如下，我觉得这样更容易阅读：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `gofmt` utility puts package names in alphabetical order when you are importing
    all your packages using a single import block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用单个导入块导入所有包时，`gofmt`实用程序会按字母顺序排列包名。
- en: The Go code of `cla.go` is simple as it stores all the command-line arguments
    in an array and uses a `for` loop for printing them. As you will see in forthcoming
    chapters, the `os` package can do many more things. If you are familiar with C,
    you should know that in C, command-line arguments are automatically passed to
    programs, and you do not need to include any extra header files in order to read
    them. Go uses a different approach that gives you more control but requires slightly
    more code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`cla.go`的Go代码很简单，它将所有命令行参数存储在一个数组中，并使用`for`循环进行打印。正如您将在接下来的章节中看到的，`os`包可以做更多的事情。如果您熟悉C语言，您应该知道在C中，命令行参数会自动传递给程序，而您无需包含任何额外的头文件来读取它们。Go使用了一种不同的方法，这样可以给您更多的控制，但需要稍微更多的代码。'
- en: 'Executing `cla.go` after building it first will create the following kind of
    output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建后执行`cla.go`将创建以下类型的输出：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finding the sum of the command-line arguments
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到命令行参数的总和
- en: 'Now, let us try something different and tricky: you are going to try to find
    the summary of the command-line arguments given to your Go program. Therefore,
    you are going to consider the command-line arguments as numbers. Although the
    main idea remains the same, the implementation is totally different because you
    will have to convert your command-line arguments into numbers. The name of the
    Go program will be `addCLA.go`, and it can be split into two parts.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些不同和棘手的事情：您将尝试找到给定给Go程序的命令行参数的总和。因此，您将把命令行参数视为数字。尽管主要思想保持不变，但实现完全不同，因为您将不得不将命令行参数转换为数字。Go程序的名称将是`addCLA.go`，它可以分为两部分。
- en: 'The first part is the preamble of the program:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是程序的序言：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You need the `fmt` package for printing your output and the `os` package for
    reading the command-line arguments. As command-line arguments are stored as strings,
    you will also need the `srtconv` package for converting them into integers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要`fmt`包来打印输出和`os`包来读取命令行参数。由于命令行参数存储为字符串，您还需要`srtconv`包将其转换为整数。
- en: 'The second part is the implementation of the `main()` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是`main()`函数的实现：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `strconv.Atoi()` function returns two values: the first one is an integer
    number, provided that the conversion was successful, and the second one is an
    error variable.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv.Atoi()`函数返回两个值：第一个是整数，前提是转换成功，第二个是错误变量。'
- en: Note that most Go functions return an error variable, which should always be
    examined, especially on production software.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数Go函数都会返回一个错误变量，这个错误变量应该始终被检查，特别是在生产软件中。
- en: 'If you do not use the `strconv.Atoi()` function, then you will have two problems:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用`strconv.Atoi()`函数，那么您将会遇到两个问题：
- en: The first one is that the program will try to perform additions, which are mathematical
    operations, using strings
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个问题是程序将尝试使用字符串执行加法，这是数学运算。
- en: The second one is that you will not be able to tell whether a command-line argument
    is a valid integer number or not, which can be done by examining the return value
    of `strconv.Atoi()`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个问题是您将无法判断命令行参数是否是有效的整数，这可以通过检查`strconv.Atoi()`的返回值来完成
- en: So, `strconv.Atoi()` not only does the desired job, but it also tells us whether
    a given argument is a valid integer or not, which is equally important because
    it allows us to process inappropriate arguments differently.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`strconv.Atoi()`不仅可以完成所需的工作，而且还可以告诉我们给定参数是否是有效的整数，这同样重要，因为它允许我们以不同的方式处理不合适的参数。
- en: The other crucial Go code found in `addCLA.go` is the one that ignores the value
    of the error variable from the `strconv.Atoi()` function using pattern matching.
    The `_` character means "match everything" in Go pattern matching terms, but do
    not save it in any variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCLA.go`中的另一个关键的Go代码是忽略`strconv.Atoi()`函数的错误变量的值，使用模式匹配。`_`字符在Go模式匹配术语中表示“匹配所有”，但不要将其保存在任何变量中。'
- en: Go has support for four different sizes of signed and unsigned integers, named
    int8, int16, int32, int64, uint8, uint16, uint32, and uint64, respectively. However,
    Go also has `int` and `uint`, which are the most efficient signed and unsigned
    integers for your current platform. Therefore, when in doubt, use either `int`
    or `uint`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持四种不同大小的有符号和无符号整数，分别命名为int8、int16、int32、int64、uint8、uint16、uint32和uint64。然而，Go还有`int`和`uint`，它们是当前平台上最有效的有符号和无符号整数。因此，当有疑问时，请使用`int`或`uint`。
- en: 'Executing `addCLA.go` with the right kind of command-line arguments creates
    the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确类型的命令行参数执行`addCLA.go`将创建以下输出：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The good thing is that `addCLA.go` does not crash if it gets no arguments,
    without you taking care of it. Nevertheless, it would be more interesting to see
    how the program handles erroneous input because you can never assume that you
    are going to get the right type of input:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCLA.go`的好处是，如果没有参数，它不会崩溃，而无需您担心。然而，看到程序如何处理错误输入会更有趣，因为您永远不能假设会得到正确类型的输入：'
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, if the program gets the wrong type of input, it does not crash
    and does not include the erroneous input in its calculations. What is a major
    issue here is that `addCLA.go` does not print any warning message to let the user
    know that some of their input was ignored. This kind of dangerous code creates
    unstable executables that might generate security issues when given the wrong
    kind of input. So, the general advice here is that you should never expect or
    rely on the Go compiler, or any other compiler or program, to take care of such
    things because this is your job.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果程序得到错误类型的输入，它不会崩溃，并且不会在其计算中包含错误的输入。这里的一个主要问题是`addCLA.go`不会打印任何警告消息，以让用户知道它们的某些输入被忽略。这种危险的代码会创建不稳定的可执行文件，当给出错误类型的输入时可能会产生安全问题。因此，这里的一般建议是，您永远不应该期望或依赖Go编译器，或任何其他编译器或程序，来处理这些事情，因为这是您的工作。
- en: '[Chapter 3](96c36f62-d505-408c-add5-af84cf25454a.xhtml), *Advanced Go Features*,
    will talk about error handling in Go in more detail and will present a better
    and safer version of the previous program. For now, we should all be happy that
    we can prove that our program does not crash with any kind of input.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第3章《高级Go功能》将更详细地讨论Go中的错误处理，并将介绍上一个程序的更好和更安全的版本。目前，我们都应该高兴地证明我们的程序不会因任何输入而崩溃。
- en: Although this is not a perfect situation, it is not that bad if you know that
    your program does not work as expected for some given kinds of input. The bad
    thing is when the developer has no idea that there exist certain kinds of input
    that can make a program fail, because you cannot correct what you do not believe
    or recognize is wrong.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这并不是一个完美的情况，但如果您知道您的程序对某些特定类型的输入不起作用，那也不是那么糟糕。糟糕的是，当开发人员不知道存在某些类型的输入可能会导致程序失败时，因为您无法纠正您不相信或认为是错误的东西。
- en: Although processing command-line arguments looks easy, it might get pretty complex
    if your command-line utility supports a large number of options and parameters.
    [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml), *Files and Directories*,
    will talk more about processing command-line options, arguments, and parameters
    using the `flag` standard Go package.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管处理命令行参数看起来很容易，但如果您的命令行实用程序支持大量选项和参数，它可能会变得非常复杂。第5章《文件和目录》将更多地讨论使用`flag`标准Go包处理命令行选项、参数和参数。
- en: User input and output
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户输入和输出
- en: According to the Unix philosophy, when a program finishes its job successfully,
    it generates no output. However, for a number of reasons, not all programs finish
    successfully and they need to inform the user about their issues by printing appropriate
    messages. Additionally, some system tools need to get input from the user in order
    to decide how to handle a situation that might come up.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Unix哲学，当程序成功完成其工作时，它不会生成任何输出。然而，出于许多原因，并非所有程序都能成功完成，并且它们需要通过打印适当的消息来通知用户其问题。此外，一些系统工具需要从用户那里获取输入，以决定如何处理可能出现的情况。
- en: The hero of Go user input and output is the `fmt` package, and this section
    is going to show you how to perform these two tasks by starting with the simplest
    one.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go用户输入和输出的英雄是`fmt`包，本节将向您展示如何通过从最简单的任务开始来执行这两个任务。
- en: The best place to learn more about the `fmt` package is its documentation page,
    which can be found at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 了解有关`fmt`包的更多信息的最佳位置是其文档页面，该页面可以在[https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/)找到。
- en: Getting user input
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: Apart from using command-line arguments to get user input, which is the preferred
    approach in systems programming, there exist ways to ask the user for input.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用命令行参数来获取用户输入（这是系统编程中的首选方法），还有其他方法可以要求用户输入。
- en: 'Two such examples are the `rm(1)` and `mv(1)` commands when used with the `-i`
    option:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`-i`选项时，两个示例是`rm(1)`和`mv(1)`命令：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, this section will show you how to mimic the previous behavior in your Go
    code by making your program understand the `-i` parameter without actually implementing
    the functionality of either `rm(1)` or `mv(1)`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节将向您展示如何在您的Go代码中模仿先前的行为，使您的程序能够理解`-i`参数，而不实际实现`rm(1)`或`mv(1)`的功能。
- en: The simplest function for getting user input is called `fmt.Scanln()` and reads
    an entire line. Other functions for getting user input include `fmt.Scan()`, `fmt.Scanf()`,
    `fmt.Sscanf()`, `fmt.Sscanln()`, and `fmt.Sscan()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取用户输入的最简单函数称为`fmt.Scanln()`，并读取整行。其他用于获取用户输入的函数包括`fmt.Scan()`、`fmt.Scanf()`、`fmt.Sscanf()`、`fmt.Sscanln()`和`fmt.Sscan()`。
- en: However, there exists a more advanced way to get input from the user in Go;
    it involves the use of the `bufio` package. Nevertheless, using the `bufio` package
    to get a simple response from a user is a bit of an overkill.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Go中存在一种更高级的方式来从用户那里获取输入；它涉及使用`bufio`包。然而，使用`bufio`包从用户那里获取简单的响应有点过度。
- en: 'The Go code of `parameter.go` is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`parameter.go`的Go代码如下：'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The presented code is not particularly clever. It just visits all command-line
    arguments using a `for` loop and checks whether the current argument is equal
    to the `-i` string. Once it finds a match with the help of the `strings.Compare()`
    function, it changes the value of the `minusI` variable from false to true. Then,
    as it does not need to look any further, it exits the `for` loop using a `break`
    statement. In case the `-i` parameter is given, the block with the `if` statement
    asks the user to enter `y` or `n` using the `fmt.Scanln()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的代码并不特别聪明。它只是使用`for`循环访问所有命令行参数，并检查当前参数是否等于`-i`字符串。一旦它通过`strings.Compare()`函数找到匹配，它就会将`minusI`变量的值从false更改为true。然后，因为它不需要再查找，它使用`break`语句退出`for`循环。如果给出了`-i`参数，带有`if`语句的块将要求用户使用`fmt.Scanln()`函数输入`y`或`n`。
- en: Note that the `fmt.Scanln()` function uses a pointer to the `answer` variable.
    Since Go passes its variables by value, we have to use a pointer reference here
    in order to save the user input to the `answer` variable. Generally speaking,
    functions that read data from the user tend to work this way.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`fmt.Scanln()` 函数使用了指向 `answer` 变量的指针。由于 Go 通过值传递变量，我们必须在这里使用指针引用，以便将用户输入保存到
    `answer` 变量中。一般来说，从用户读取数据的函数往往是这样工作的。
- en: 'Executing `parameter.go` creates the following kind of output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `parameter.go` 会产生以下类型的输出：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Printing output
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印输出
- en: The simplest way to print something in Go is using the `fmt.Println()` and `fmt.Printf()`
    functions. The `fmt.Printf()` function has many similarities with the C `printf(3)`
    function. You can also use the `fmt.Print()` function instead of `fmt.Println()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中打印东西的最简单方法是使用 `fmt.Println()` 和 `fmt.Printf()` 函数。`fmt.Printf()` 函数与 C
    的 `printf(3)` 函数有许多相似之处。你也可以使用 `fmt.Print()` 函数来代替 `fmt.Println()`。
- en: The main difference between `fmt.Print()` and `fmt.Println()` is that the latter
    automatically prints a newline character each time you call it. The biggest difference
    between `fmt.Println()` and `fmt.Printf()` is that the latter requires a format
    specifier for everything it will print, just like the C `printf(3)` function.
    This means that you have better control over what you are doing, but you have
    to write more code. Go calls these specifiers **verbs**, and you can find out
    more about supported verbs at [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Print()` 和 `fmt.Println()` 之间的主要区别是，后者每次调用时自动打印一个换行符。`fmt.Println()` 和
    `fmt.Printf()` 之间的最大区别是，后者需要为它将打印的每样东西提供一个格式说明符，就像 C 的 `printf(3)` 函数一样。这意味着你可以更好地控制你在做什么，但你需要写更多的代码。Go
    将这些说明符称为**动词**，你可以在 [https://golang.org/pkg/fmt/](https://golang.org/pkg/fmt/)
    找到更多关于支持的动词的信息。'
- en: Go functions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 函数
- en: Functions are an important element of every programming language because they
    allow you to break big programs into smaller and more manageable parts, but they
    must be as independent of each other as possible and must do one job and only
    one job. So, if you find yourself writing functions that do multiple things, you
    may want to consider writing multiple functions instead. However, Go will not
    refuse to compile functions that are long, complicated, or do multiple things.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是每种编程语言的重要元素，因为它们允许你将大型程序分解为更小更易管理的部分，但它们必须尽可能独立，并且只能完成一项任务。因此，如果你发现自己编写了多个任务的函数，可能需要考虑编写多个函数。然而，Go
    不会拒绝编译长、复杂或者做多个任务的函数。
- en: A safe indication that you need to create a new function is when you find yourself
    using the same Go code multiple times in your program. Similarly, a safe indication
    that you need to put some of your functions in a module is when you find yourself
    using the same functions all the time in most of your programs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个安全的指示，你需要创建一个新函数的时候是，当你发现自己在程序中多次使用相同的 Go 代码。同样，一个安全的指示，你需要将一些函数放在一个模块中的时候是，当你发现自己在大多数程序中一直使用相同的函数。
- en: The single most popular Go function is `main()`, which can be found in every
    autonomous Go program. If you look at the definition of the `main()` function,
    you'll soon realize that function declarations in Go start with the `func` keyword.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的 Go 函数是 `main()`，它可以在每个独立的 Go 程序中找到。如果你看一下 `main()` 函数的定义，你很快就会意识到 Go 中的函数声明以
    `func` 关键字开头。
- en: As a rule of thumb, you must try to write functions that are less than 20-30
    lines of Go code. A good side effect of having smaller functions is that they
    can be optimized more easily because you can clearly find out where the bottleneck
    is.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你必须尽量编写少于 20-30 行 Go 代码的函数。拥有更小的函数的一个好的副作用是，它们可以更容易地进行优化，因为你可以清楚地找出瓶颈在哪里。
- en: Naming the return values of a Go function
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给 Go 函数的返回值命名
- en: Unlike C, Go allows you to name the return values of a Go function. Additionally,
    when such a function has a return statement without any arguments, the function
    automatically returns the current value of each named return value. Note that
    such functions return their values in the order they were declared in the definition
    of the function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 不同，Go 允许你给函数的返回值命名。此外，当这样的函数有一个没有参数的返回语句时，函数会自动返回每个命名返回值的当前值。请注意，这样的函数按照它们在函数定义中声明的顺序返回它们的值。
- en: Naming return values is a very handy Go feature that can save you from various
    types of bugs, so use it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给返回值命名是一个非常方便的 Go 特性，可以帮助你避免各种类型的错误，所以要使用它。
- en: 'My personal advice is this: name the return values of your functions unless
    there is a very good reason not to do so.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我的个人建议是：给你的函数的返回值命名，除非有非常好的理由不这样做。
- en: Anonymous functions
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Anonymous functions can be defined in line, without the need for a name, and
    they are usually used for implementing things that require a small amount of code.
    In Go, a function can return an anonymous function or take an anonymous function
    as one of its arguments. Additionally, anonymous functions can be attached to
    Go variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数可以在一行内定义，无需名称，它们通常用于实现需要少量代码的事物。在 Go 中，一个函数可以返回一个匿名函数，或者将一个匿名函数作为其参数之一。此外，匿名函数可以附加到
    Go 变量上。
- en: It is considered a good practice for anonymous functions to have a small implementation
    and local usage. If an anonymous function does not have local utilization, then
    you might need to consider making it a regular function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匿名函数来说，最好的做法是有一个小的实现和局部使用。如果一个匿名函数没有局部使用，那么你可能需要考虑将其变成一个常规函数。
- en: When an anonymous function is suitable for a job, then it is extremely convenient
    and makes your life easier; just do not use too many anonymous functions in your
    programs without a good reason.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当匿名函数适合一项任务时，它非常方便，可以让你的生活更轻松；只是不要在程序中没有充分理由的情况下使用太多匿名函数。
- en: Illustrating Go functions
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说明 Go 函数
- en: 'This subsection will present examples of the previous types of functions using
    the Go code of the `functions.go` program. The first part of the program contains
    the expected preamble and the implementation of the `unnamedMinMax()` function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将展示使用`functions.go`程序的Go代码来演示前面类型的函数的示例。程序的第一部分包含了预期的序言和`unnamedMinMax()`函数的实现：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `unnamedMinMax()` function is a regular function that gets two integer numbers
    as input, named `x` and `y`, respectively. It returns two integer numbers as output
    using a `return` statement.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`unnamedMinMax()`函数是一个常规函数，它以两个整数作为输入，分别命名为`x`和`y`。它使用`return`语句返回两个整数。'
- en: 'The next part of `functions.go` defines another function but this time with
    named returned values, which are called `min` and `max`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions.go`的下一部分定义了另一个函数，但这次使用了命名返回值，它们被称为`min`和`max`：'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next function is an improved version of `minMax()` because you do not have
    to explicitly define the return variables of the return statement:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`minMax()`的改进版本，因为你不必显式定义返回语句的返回变量：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, you can easily discover which values will be returned by looking at
    the definition of the `namedMinMax()` function. The `namedMinMax()` function will
    return the current values of `min` and `max`, in that order.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过查看`namedMinMax()`函数的定义轻松地发现将返回哪些值。`namedMinMax()`函数将以此顺序返回`min`和`max`的当前值。
- en: 'The next function shows how to sort two integers without having to use a temporary
    variable:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数展示了如何对两个整数进行排序，而不必使用临时变量：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code also shows how handy it is that Go functions can return more
    than one value. The last part of `functions.go` contains the `main()` function;
    this could be explained in two parts.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还展示了Go函数可以返回多个值的便利之处。`functions.go`的最后一部分包含了`main()`函数；这可以分为两部分来解释。
- en: 'The first part is to do with anonymous functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分涉及匿名函数：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, you define two anonymous functions: the first one calculates the square
    of the given integer whereas the second doubles the given integer number. What
    is important here is that both of them are assigned to the same variable, which
    is a totally wrong and is a dangerous practice. Therefore, improper use of anonymous
    functions can create nasty bugs, so take extra care and do not assign the same
    variable to different anonymous functions.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义了两个匿名函数：第一个计算给定整数的平方，而第二个则是给定整数的两倍。重要的是，它们都分配给了同一个变量，这是完全错误的，也是一种危险的做法。因此，不正确使用匿名函数可能会产生严重的错误，所以要格外小心，不要将同一个变量分配给不同的匿名函数。
- en: Note that even if a function is assigned to a variable, it is still considered
    an anonymous function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使将函数分配给变量，它仍然被视为匿名函数。
- en: 'The second part of `main()` uses some of the defined functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`的第二部分使用了一些已定义的函数：'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What is interesting here is that you can get the two returned values of the
    `namedMinMax()` function using two variables, all in one statement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你可以使用两个变量在一个语句中获取`namedMinMax()`函数的两个返回值。
- en: 'Executing `functions.go` generates the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`functions.go`生成以下输出：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The next section shows more examples of anonymous functions combined with the
    `defer` keyword.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分展示了更多匿名函数与`defer`关键字结合的例子。
- en: The defer keyword
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: defer关键字
- en: The `defer` keyword defers the execution of a function until the surrounding
    function returns, and is widely used in file I/O operations. This is because it
    saves you from having to remember when to close an open file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`关键字推迟了函数的执行，直到包围函数返回，并且在文件I/O操作中被广泛使用。这是因为它可以让你不必记住何时关闭打开的文件。'
- en: The file with the Go code that illustrates the use of `defer` is called `defer.go`
    and has four main parts.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 展示`defer`的Go代码文件名为`defer.go`，包含四个主要部分。
- en: 'The first part is the expected preamble as well as the definition of the `a1()`
    function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序言，以及`a1()`函数的定义：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the previous example, the `defer` keyword is used with a simple `fmt.Print()`
    statement.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`defer`关键字与简单的`fmt.Print()`语句一起使用。
- en: 'The second part is the definition of the `a2()` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是`a2()`函数的定义：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After the `defer` keyword, there is an anonymous function that is not attached
    to a variable, which means that after the termination of the `for` loop, the anonymous
    function will automatically disappear. The presented anonymous function takes
    no arguments but uses the `i` local variable in the `fmt.Print()` statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`defer`关键字之后，有一个未附加到变量的匿名函数，这意味着在`for`循环终止后，匿名函数将自动消失。所呈现的匿名函数不带参数，但在`fmt.Print()`语句中使用了`i`局部变量。
- en: 'The next part defines the `a3()` function and has the following Go code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分定义了`a3()`函数，并包含以下Go代码：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, the anonymous function requires an integer parameter that is named
    `n` and takes its value from the `i` variable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，匿名函数需要一个名为`n`的整数参数，并从变量`i`中取其值。
- en: 'The last part of `defer.go` is the implementation of the `main()` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer.go`的最后一部分是`main()`函数的实现：'
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Executing `defer.go` will print the following, which might surprise you at
    first:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`defer.go`将打印以下内容，这可能会让你感到惊讶：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, now it is time to explain the output of `defer.go` by examining the way
    `a1()`, `a2()`, and `a3()` execute their code. The first line of output verifies
    that deferred functions are executed in **Last In First Out** (**LIFO**) order
    after the return of the surrounding function. The `for` loop in `a1()` defers
    a single function call that uses the current value of the `i` variable. As a result,
    all numbers are printed in reverse order because the last used value of `i` is
    `2`. The `a2()` function is a tricky one because due to `defer`, the function
    body is evaluated after the `for` loop ends while it is still referencing the
    local `i` variable, which at that time was equal to `3` for all evaluations of
    the body. As a result, `a2()` prints the number `3` three times. Put simply, you
    have three function calls that use the last value of a variable because this is
    what is passed to the function. However, this is not the case with the `a3()`
    function because the current value of `i` is passed as an argument to the deferred
    function, due to the `(i)` code at the end of the `a3()` function definition.
    So, each time the deferred function is executed, it has a different `i` value
    to process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是时候通过检查`a1()`、`a2()`和`a3()`执行其代码的方式来解释`defer.go`的输出。输出的第一行验证了在包围函数返回后，延迟函数以**后进先出**（**LIFO**）的顺序执行。`a1()`中的`for`循环延迟了一个使用`i`变量当前值的函数调用。结果，所有数字都以相反的顺序打印，因为`i`的最后使用值是`2`。`a2()`函数比较棘手，因为由于`defer`，函数体在`for`循环结束后被评估，而它仍在引用局部`i`变量，这时对于所有评估的函数体来说，`i`变量的值都等于`3`。结果，`a2()`打印数字`3`三次。简而言之，您有三个使用变量的最后值的函数调用，因为这是传递给函数的内容。但是，`a3()`函数不是这种情况，因为`i`的当前值作为参数传递给延迟的函数，这是由`a3()`函数定义末尾的`(i)`代码决定的。因此，每次执行延迟的函数时，它都有一个不同的`i`值要处理。
- en: As using `defer` can be complicated, you should write your own examples and
    try to guess their output before executing the actual Go code to make sure that
    your program behaves as expected. Try to be able to tell when the function arguments
    are evaluated and when the function body is actually executed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`defer`可能会很复杂，您应该编写自己的示例，并在执行实际的Go代码之前尝试猜测它们的输出，以确保您的程序表现如预期。尝试能够判断函数参数何时被评估以及函数体何时实际执行。
- en: You will see the `defer` keyword in action again in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml) *文件输入和输出*中再次看到`defer`关键字的作用。
- en: Using pointer variables in functions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中使用指针变量
- en: '**Pointers** are memory addresses that offer improved speed in exchange for
    difficult-to-debug code and nasty bugs. C programmers know more about this. The
    use of pointer variables in Go functions is illustrated inside the `pointers.go`
    file, which can be divided into two main parts. The first part contains the definition
    of two functions and one new structure named `complex`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针**是内存地址，以提高速度为代价，但代码难以调试且容易出现错误。C程序员对此了解更多。在Go函数中使用指针变量的示例在`pointers.go`文件中进行了说明，可以分为两个主要部分。第一部分包含两个函数的定义和一个名为`complex`的新结构。'
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second part illustrates the use of the previous definitions in the `main()`
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分说明了在`main()`函数中使用先前定义的内容：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As the `withPointer()` function uses a pointer variable, you do not need to
    return any values because any changes to the variable you pass to the function
    are automatically stored in the passed variable. Note that you need to put `&`
    in front of the variable name to pass it as a pointer instead of as a value. The
    `complex` structure has two members, named `x` and `y`, which are both integer
    variables.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`withPointer()`函数使用指针变量，您不需要返回任何值，因为对传递给函数的变量的任何更改都会自动存储在传递的变量中。请注意，您需要在变量名前面加上`&`，以便将其作为指针而不是作为值传递。`complex`结构有两个成员，名为`x`和`y`，它们都是整数变量。
- en: On the other hand, the `newComplex()` function returns a pointer to a `complex`
    structure, previously defined in `pointers.go`, which needs to be stored in a
    variable. In order to print the contents of a complex variable returned by the
    `newComplex()` function, you will need to put a `*` character in front of it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`newComplex()`函数返回了一个指向先前在`pointers.go`中定义的`complex`结构的指针，需要存储在一个变量中。为了打印`newComplex()`函数返回的复杂变量的内容，您需要在其前面加上一个`*`字符。
- en: 'Executing `pointers.go` generates the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`pointers.go`会生成以下输出：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I do not recommend the use of pointers to amateur programmers outside of what
    is required by the libraries you use because they might cause problems. However,
    as you get more experienced, you might want to experiment with pointers and decide
    whether you want to use them or not depending on the problem you are trying to
    solve.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议业余程序员在使用库所需之外使用指针，因为它们可能会引起问题。然而，随着经验的增加，您可能希望尝试使用指针，并根据您尝试解决的问题决定是否使用它们。
- en: Go data structures
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go数据结构
- en: Go comes with many handy **data structures** that can help you store your own
    data, including arrays, slices, and maps. The most important task that you should
    be able to perform on any data structure is accessing all of its elements in some
    way. The second important task is having direct access to a specific element once
    you know its index or key. The last two equally important tasks are inserting
    elements and deleting elements from data structures. Once you know how to perform
    these four tasks, you will have complete control over the data structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Go带有许多方便的**数据结构**，可以帮助您存储自己的数据，包括数组、切片和映射。您应该能够在任何数据结构上执行的最重要的任务是以某种方式访问其所有元素。第二个重要任务是在知道其索引或键后直接访问特定元素。最后两个同样重要的任务是向数据结构中插入元素和删除元素。一旦您知道如何执行这四个任务，您将完全控制数据结构。
- en: Arrays
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Arrays are the most popular data structure due to their speed and are supported
    by almost all programming languages. You can declare an array in Go as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其速度快，并且几乎所有编程语言都支持，数组是最受欢迎的数据结构。您可以在Go中声明数组如下：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Should you wish to declare an array with two or three dimensions, you can use
    the following notation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望声明具有两个或三个维度的数组，可以使用以下表示法：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The index of the first element of each dimension of an array is 0, the index
    of the second element of each dimension is 1, and so on. Accessing, assigning,
    or printing a single element from one of the previous three arrays can also be
    done easily:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 数组每个维度的第一个元素的索引是0，每个维度的第二个元素的索引是1，依此类推。可以轻松地访问、赋值或打印前三个数组中的单个元素。
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The most common way to access all the elements of an array is by finding its
    size using the `len()` function and then using a `for` loop. However, there exist
    cooler ways to visit all the elements of an array that involve the use of the
    `range` keyword inside a `for` loop and allow you to bypass the use of the `len()`
    function, which is pretty handy when you have to deal with arrays with two or
    more dimensions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组所有元素的最常见方法是使用`len()`函数找到其大小，然后使用`for`循环。然而，还有更酷的方法可以访问数组的所有元素，这涉及在`for`循环中使用`range`关键字，并允许您绕过`len()`函数的使用，当您必须处理两个或更多维数组时，这是非常方便的。
- en: 'All of the code in this subsection is saved as `arrays.go`, and you should
    watch it on your own. Running `arrays.go` creates the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节中的所有代码都保存在`arrays.go`中，你应该自己看一下。运行`arrays.go`会生成以下输出：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s try to break things by trying to access some strange array elements,
    such as an element with an index number that does not exist or an element with
    a negative index number, using the following Go program that is named `breakMe.go`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试通过尝试访问一些奇怪的数组元素来破坏事物，比如访问一个不存在的索引号的元素或者访问一个负索引号的元素，使用以下名为`breakMe.go`的Go程序：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Executing `breakMe.go` will generate the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`breakMe.go`将生成以下输出：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Go considers compiler issues that can be detected as compiler errors because
    this helps the development workflow, which is the reason for printing all the
    out of bounds array access errors of `breakMe.go`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Go认为可以检测到的编译器问题是编译器错误，因为这有助于开发工作流程，这就是为什么要打印`breakMe.go`的所有越界数组访问错误的原因。
- en: Trying to break things is an extremely educational process that you should attempt
    all the time. Put simply, knowing when something does not work is equally useful
    to knowing when it works.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试破坏事物是一个非常有教育意义的过程，你应该一直尝试。简而言之，知道某些事情不起作用的时候同样有用，就像知道什么时候起作用一样有用。
- en: 'Despite their simplicity, Go arrays have many and severe shortcomings:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go数组很简单，但存在许多严重的缺点：
- en: First, once you define an array, you cannot change its size, which means that
    Go arrays are not dynamic. Put simply, if you want to include an additional element
    to an existing array that has no space, you will need to create a bigger array
    and copy all the elements from the old array to the new one.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，一旦定义了数组，就不能改变其大小，这意味着Go数组不是动态的。简而言之，如果您想要在没有空间的现有数组中包含额外的元素，您将需要创建一个更大的数组，并将所有元素从旧数组复制到新数组中。
- en: Second, when you pass an array to a function, you actually pass a copy of the
    array, which means that any changes you make to an array inside a function will
    be lost after the function finishes.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，当你将数组传递给函数时，实际上是传递了数组的副本，这意味着你在函数内部对数组所做的任何更改在函数结束后都会丢失。
- en: Last, passing a large array to a function can be pretty slow, mostly because
    Go has to create a second copy of the array. The solution to all these problems
    is to use slices instead.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将大数组传递给函数可能会非常慢，主要是因为Go必须创建数组的第二个副本。解决所有这些问题的方法是使用切片。
- en: Slices
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: You'll not find the concept of **slice** in many programming languages, despite
    the fact that it is both smart and handy. A slice has many similarities with an
    array, and it allows you to overcome the shortcomings of an array.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，你不会找到**切片**的概念，尽管它既聪明又方便。切片与数组有许多相似之处，并且允许您克服数组的缺点。
- en: Slices have a capacity and length property, which are not always the same. The
    length of a slice is the same as the length of an array with the same number of
    elements and can be found using the `len()` function. The capacity of a slice
    is the current room that has been allocated for this particular slice and can
    be found with the `cap()` function. As slices are dynamic in size, if a slice
    runs out of room, Go automatically doubles its current length to make room for
    more elements.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 切片有容量和长度属性，它们并不总是相同的。切片的长度与具有相同数量元素的数组的长度相同，并且可以使用`len()`函数找到。切片的容量是为该特定切片分配的当前空间，并可以使用`cap()`函数找到。由于切片的大小是动态的，如果切片的空间不足，Go会自动将其当前长度加倍以为更多元素腾出空间。
- en: As slices are passed by reference to functions, any modifications you make to
    a slice inside a function will not be lost after the function ends. Additionally,
    passing a big slice to a function is significantly faster than passing the same
    array because Go will not have to make a copy of the slice; it will just pass
    the memory address of the slice variable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 切片作为引用传递给函数，你在函数内部对切片所做的任何修改在函数结束后都不会丢失。此外，将大切片传递给函数比传递相同数组要快得多，因为Go不必复制切片，它只会传递切片变量的内存地址。
- en: The code of this subsection is saved in `slices.go`, and it can be separated
    into three main parts.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节的代码保存在`slices.go`中，可以分为三个主要部分。
- en: 'The first part is the preamble as well as the definition of two functions that
    get `slice` as input:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是序言以及定义两个以`slice`作为输入的函数：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that when you use `range` over a slice, you get a pair of values in its
    iteration. The first one is the index number and the second one is the value of
    the element. When you are only interested in the stored element, you can ignore
    the index number as it happens with the `printSlice()` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您在切片上使用`range`时，您会在其迭代中得到一对值。第一个是索引号，第二个是元素的值。当您只对存储的元素感兴趣时，您可以忽略索引号，就像`printSlice()`函数一样。
- en: The `change()` function just changes the fourth element of the input slice,
    whereas `printSlice()` is a utility function that prints the contents of its slice
    input variable. Here, you can also see the use of the `fmt.Printf()` function
    for printing an integer number.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`change()`函数只更改输入切片的第四个元素，而`printSlice()`是一个实用函数，用于打印其切片输入变量的内容。在这里，您还可以看到使用`fmt.Printf()`函数打印整数。'
- en: 'The second part creates a new slice named `aSlice` and makes a change to it
    with the help of the `change()` function you saw in the first part:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分创建了一个名为`aSlice`的新切片，并使用第一部分中看到的`change()`函数对其进行更改：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although the way you define a populated slice has some similarities with the
    way you define an array, the biggest difference is that you do not have to declare
    the number of elements your slice will have.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您定义填充切片的方式与定义数组的方式有一些相似之处，但最大的区别在于您不必声明切片将具有的元素数量。
- en: 'The last part illustrates the capacity property of a Go slice as well as the
    `make()` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分说明了Go切片的容量属性以及`make()`函数：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `make()` function automatically initializes the elements of a slice to the
    zero value for that type, which can be verified by the output of the `printSlice`
    (`anotherSlice`) statement. Note that you need to specify the number of elements
    of a slice when you create it with the `make()` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`make()`函数会自动将切片的元素初始化为该类型的零值，可以通过`printSlice`（`anotherSlice`）语句的输出进行验证。请注意，使用`make()`函数创建切片时需要指定元素的数量。'
- en: 'Executing `slices.go` generates the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`slices.go`生成以下输出：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see from the third line of the output, the capacity and the length
    of a slice were the same at the time of its definition. However, after adding
    a new element to the slice using `append()`, its length goes from `6` to `7` but
    its capacity doubles and goes from `6` to `12`. The main advantage you get from
    doubling the capacity of a slice is better performance because Go will not have
    to allocate memory space all the time.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的第三行可以看出，切片的容量和长度在定义时是相同的。但是，使用`append()`向切片添加新元素后，其长度从`6`变为`7`，但其容量翻倍，从`6`变为`12`。将切片的容量翻倍的主要优势是性能更好，因为Go不必一直分配内存空间。
- en: You can create a slice from the elements of an existing array, and you can copy
    an existing slice to another one using the `copy()` function. Both operations
    have some tricky points, and you should experiment with them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从现有数组的元素创建一个切片，并使用`copy()`函数将现有切片复制到另一个切片。这两个操作都有一些棘手的地方，您应该进行实验。
- en: '[Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml), *File Input and Output*,
    will talk about a special type of slice, named byte slice, that can be used in
    file I/O operations.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)，*文件输入和输出*，将讨论一种特殊类型的切片，称为字节切片，可用于文件I/O操作。'
- en: Maps
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: The Map data type in Go is equivalent to the well-known hash table found in
    other programming languages. The main advantage of maps is that they can use almost
    any data type as their index, which in this case is called a **key**. For a data
    type to be used as a key, it must be comparable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的Map数据类型等同于其他编程语言中的哈希表。映射的主要优势是它们可以使用几乎任何数据类型作为其索引，这种情况下称为**key**。要将数据类型用作键，它必须是可比较的。
- en: 'So, let''s take a look at an example Go program, named `maps.go`, which we
    will use for illustrative purposes. The first part of `maps.go` contains the preamble
    Go code you would expect:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看一个示例Go程序，名为`maps.go`，我们将用它进行说明。`maps.go`的第一部分包含您期望的Go代码前言：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, you can define a new empty map that has strings as its keys and integer
    numbers as values, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以定义一个新的空映射，其中字符串作为键，整数作为值，如下所示：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Post this, you can add new key and value pairs to the `aMap` map, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以向`aMap`映射添加新的键值对，如下所示：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, you can get the value of an existing key:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以获取现有键的值：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'However, the single most important operation you can perform on an existing
    `map` is illustrated in the following Go code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以对现有`map`执行的最重要的操作在以下Go代码中进行了说明：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What the aforementioned Go code does is use the error-handling capabilities
    of Go in order to verify that a key of a map already exists before you try to
    get its value. This is the proper and safe way of trying to get the value of a
    `map` key because asking for a value for which there is no `key` will result in
    returning zero. This gives you no way of determining whether the result was zero
    because the `key` you requested was not there or because the element with the
    corresponding key actually had the zero value.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Go代码的作用是利用Go的错误处理能力，以验证映射的键在尝试获取其值之前是否已存在。这是尝试获取`map`键的值的正确和安全方式，因为要求一个不存在的`key`的值将导致返回零。这样就无法确定结果是零，是因为您请求的`key`不存在，还是因为相应键的元素实际上具有零值。
- en: 'The following Go code shows how you can iterate over all the keys of an existing
    map:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Go代码显示了如何遍历现有映射的所有键：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you have no interest in visiting the keys and the values of a map and you
    just want to count its pairs, then you can use the next, much simpler variation
    of the previous `for` loop:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对访问映射的键和值没有兴趣，只想计算其对数，那么您可以使用前面`for`循环的下一个更简单的变体：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The last part of the `main()` function contains the following Go code that
    illustrates an alternative way of defining and initializing a map at the same
    time:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的最后一部分包含以下Go代码，用于说明定义和初始化映射的另一种方式：'
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, apart from the different initialization, all the other `map` operations
    work exactly the same. Executing `maps.go` generates the following output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了不同的初始化之外，所有其他`map`操作都完全相同。执行`maps.go`生成以下输出：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Maps are a very handy data structure, and there is a big chance that you are
    going to need them when developing systems software.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是一种非常方便的数据结构，当开发系统软件时，您很有可能会需要它们。
- en: Converting an array into a map
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数组转换为地图
- en: 'This subsection will perform a practical operation, which is converting an
    array into a map without knowing the size of `array` in advance. The Go code of
    `array2map.go` can be divided into three main parts. The first part is the standard
    Go code that includes the required packages and the beginning of the `main()`
    function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节将执行一个实际的操作，即在不提前知道`array`大小的情况下将数组转换为地图。`array2map.go`的Go代码可以分为三个主要部分。第一部分是标准的Go代码，包括所需的包和`main()`函数的开始：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The second part, which implements the core functionality, is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 实现核心功能的第二部分如下：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You first define the `array` variable and the `map` variable you will use. The
    `for` loop is used for visiting all the array elements and adding them to `map`.
    The `strconv.Itoa()` function converts the index number of `array` into a string.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义`array`变量和将要使用的`map`变量。`for`循环用于访问所有数组元素并将它们添加到`map`中。`strconv.Itoa()`函数将`array`的索引号转换为字符串。
- en: Bear in mind that if you know that all the keys of a map will be consecutive
    positive integer numbers, you might consider using an array or a slice instead
    of a map. In fact, even if the keys are not consecutive, arrays and slices are
    cheaper data structures than maps, so you might end up with a sparse matrix.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你知道地图的所有键都将是连续的正整数，你可能会考虑使用数组或切片而不是地图。实际上，即使键不是连续的，数组和切片也比地图更便宜，所以你最终可能会得到一个稀疏矩阵。
- en: 'The last part, which is just for printing the contents of the generated map,
    uses the expected range form of the `for` loop:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分仅用于打印生成的地图的内容，使用了`for`循环的预期范围形式：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can easily guess, developing the inverse operation is not always possible
    because `map` is a richer data structure than `array`. However, the price you
    pay for a more powerful data structure is time because array operations are usually
    faster.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以轻松猜到的那样，开发逆操作并不总是可能的，因为`map`是比`array`更丰富的数据结构。但是，使用更强大的数据结构所付出的代价是时间，因为数组操作通常更快。
- en: Structures
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构
- en: Although arrays, slices, and maps are all very useful, they cannot hold multiple
    values in the same place. When you need to group various types of variables and
    create a new handy type, you can use a structure--the various elements of a structure
    are called fields.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数组、切片和地图都非常有用，但它们不能在同一个位置保存多个值。当您需要对各种类型的变量进行分组并创建一个新的方便类型时，可以使用结构--结构的各个元素称为字段。
- en: 'The code of this subsection is saved as `dataStructures.go` and can be divided
    into three parts. The first part contains the preamble and the definition of a
    new structure named `message`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小节的代码保存为`dataStructures.go`，可以分为三部分。第一部分包含序言和一个名为`message`的新结构的定义：
- en: '[PRE60]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The message structure has three fields, named `X`, `Y`, and `Label`. Note that
    structures are usually defined at the beginning of a program and outside the `main()`
    function.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 消息结构有三个字段，名为`X`、`Y`和`Label`。请注意，结构通常在程序开头和`main()`函数之外定义。
- en: 'The second part uses the message structure to define two new message variables,
    named `p1` and `p2`. Then, it uses reflection to get information about the `p1`
    and `p2` variables of the message structure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分使用消息结构定义了两个名为`p1`和`p2`的新消息变量，然后使用反射获取有关消息结构的`p1`和`p2`变量的信息：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The last part shows how to print all the fields of a structure without knowing
    their names using a `for` loop and the `Type()` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分展示了如何使用`for`循环和`Type()`函数打印结构的所有字段而不知道它们的名称：
- en: '[PRE62]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Running `dataStructures.go` will generate the following kind of output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`dataStructures.go`将生成以下类型的输出：
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If the name of a field of a `struct` definition begins with a lowercase letter
    (`x` instead of `X`), the previous program will fail with the following error
    message:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`struct`定义的字段名称以小写字母开头（`x`而不是`X`），上一个程序将失败，并显示以下错误消息：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This happens because lowercase fields do not get exported; therefore, they cannot
    be used by the `reflect.Value.Interface()` method. You will learn more about `reflection`
    in the next chapter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为小写字段不会被导出；因此，它们不能被`reflect.Value.Interface()`方法使用。您将在下一章中了解更多关于`reflection`的内容。
- en: Interfaces
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are an advanced Go feature, which means that you might not want to
    use them in your programs if you are not feeling very comfortable with Go. However,
    interfaces can be very practical when developing big Go programs, which is the
    main reason for talking about interfaces in this book.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是Go的高级功能，这意味着如果您对Go不太熟悉，可能不希望在程序中使用它们。但是，在开发大型Go程序时，接口可能非常实用，这是本书讨论接口的主要原因。
- en: But first, I will talk about methods, which are functions with a special receiver
    argument. You declare methods as ordinary functions with an additional parameter
    that appears just before the function name. This particular parameter connects
    the function to the type of that extra parameter. As a result, that parameter
    is called the receiver of the method. You will see such functions in a while.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我将讨论方法，这些是带有特殊接收器参数的函数。您将方法声明为普通函数，并在函数名称之前添加一个额外的参数。这个特殊的参数将函数连接到该额外参数的类型。因此，该参数被称为方法的接收器。您一会儿会看到这样的函数。
- en: Put simply, interfaces are abstract types that define a set of functions that
    need to be implemented so that a type can be considered an instance of the interface.
    When this happens, we say that the type satisfies this interface. So, an interface
    is two things--a set of methods and a type--and it is used for defining the behavior
    of a type.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，接口是定义一组需要实现的函数的抽象类型，以便将类型视为接口的实例。当这种情况发生时，我们说该类型满足此接口。因此，接口是两种东西--一组方法和一种类型--它用于定义类型的行为。
- en: Let's describe the main advantage of interfaces with an example. Imagine that
    you have a type named ATYPE and an interface for the ATYPE type. Any function
    that accepts an ATYPE variable can accept any other variable that implements the
    interface of ATYPE.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来描述接口的主要优势。想象一下，你有一个名为ATYPE的类型和一个适用于ATYPE类型的接口。接受一个ATYPE变量的任何函数都可以接受实现了ATYPE接口的任何其他变量。
- en: 'The Go code of `interfaces.go` can be divided into three parts. The first part
    is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`interfaces.go`的Go代码可以分为三部分。第一部分如下所示：'
- en: '[PRE65]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this part, you define an interface called coordinates and a new structure
    called `point2D`. The interface has two functions, named `xaxis()` and `yaxis()`.
    The definition of the coordinates interface says that if you want to convert to
    the coordinates interface, you will have to implement these two functions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，你定义了一个名为coordinates的接口和一个名为`point2D`的新结构。接口有两个函数，名为`xaxis()`和`yaxis()`。坐标接口的定义表示，如果要转换为坐标接口，必须实现这两个函数。
- en: It is important to notice that the interface does not state any other specific
    types apart from the interface itself. On the other hand, the two functions of
    the interface should state the types of their return values.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是注意，接口除了接口本身不声明任何其他特定类型。另一方面，接口的两个函数应声明它们返回值的类型。
- en: 'The second part has the following Go code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the second part, you first implement the two functions of the coordinates
    interface for the `point2D` type. Then you develop a function named `findCoordinates()`
    that accepts a variable that implements the coordinates interface. The `findCoordinates()`
    function just prints the two coordinates of a point using a simple `fmt.Println()`
    function call. Then, you define a new type named coordinate that is used for points
    that belong to the *x*-axis. Last, you implement the coordinates interface for
    the coordinate type.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，首先为`point2D`类型实现坐标接口的两个函数。然后开发一个名为`findCoordinates()`的函数，该函数接受一个实现坐标接口的变量。`findCoordinates()`函数只是使用简单的`fmt.Println()`函数调用打印点的两个坐标。然后，定义一个名为coordinate的新类型，用于属于*x*轴的点。最后，为coordinate类型实现坐标接口。
- en: At the time of writing the code for `interfaces.go`, I believed that the `coordinates`
    and `coordinate` names were fine. After writing the previous paragraph, I realized
    that the `coordinate` type could have been renamed to `xpoint` for better readability.
    I left the names `coordinates` and `coordinate` to point out that everybody makes
    mistakes and that the variable and type names you are using must be chosen wisely.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`interfaces.go`代码时，我认为`coordinates`和`coordinate`这两个名称还不错。在写完上一段之后，我意识到`coordinate`类型本可以改名为`xpoint`以提高可读性。我保留了`coordinates`和`coordinate`这两个名称，以指出每个人都会犯错误，你使用的变量和类型名称必须明智选择。
- en: 'The last part has the following Go code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In this part, you first create a `point2D` variable and print its coordinates
    using the `findCoordinates()` function, then you create a coordinate variable
    named `y` that holds a single coordinate value. Lastly, you print the `y` variable
    using the same `findCoordinates()` function used for printing a `point2D` variable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，首先创建一个`point2D`变量，并使用`findCoordinates()`函数打印其坐标，然后创建一个名为`y`的坐标变量，它保存一个单一的坐标值。最后，使用与打印`point2D`变量相同的`findCoordinates()`函数打印`y`变量。
- en: Although Go is not an object-oriented programming language, I will use some
    object-oriented terminology here. So, in object-oriented terminology, this means
    that both `point2D` and `coordinate` types are coordinate objects. However, none
    of them are *only* a `coordinate` object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go不是一种面向对象的编程语言，但我将在这里使用一些面向对象的术语。因此，在面向对象的术语中，这意味着`point2D`和`coordinate`类型都是坐标对象。但是，它们都不是*只是*`coordinate`对象。
- en: 'Executing `interfaces.go` creates the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`interfaces.go`会创建以下输出：
- en: '[PRE68]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: I believe that Go interfaces are not necessary when developing systems software,
    but they are a handy Go feature that can make the development of a systems application
    more readable and simpler, so do not hesitate to use them.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在开发系统软件时，Go接口并不是必需的，但它们是一个方便的Go特性，可以使系统应用程序的开发更易读和更简单，所以不要犹豫使用它们。
- en: Creating random numbers
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建随机数
- en: As a practical programming example, this section will talk about creating random
    numbers in Go. Random numbers have many uses, including the generation of good
    passwords as well as the creation of files with random data that can be used for
    testing other applications. However, bear in mind that usually programming languages
    generate pseudorandom numbers that approximate the properties of a true random
    number generator.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际的编程示例，本节将讨论在Go中创建随机数。随机数有许多用途，包括生成良好的密码以及创建具有随机数据的文件，这些文件可用于测试其他应用程序。但是，请记住，通常编程语言生成伪随机数，这些数近似于真随机数生成器的属性。
- en: Go uses the `math/rand` package for generating random numbers and needs a seed
    to start producing random numbers. The seed is used for initializing the entire
    process and is extremely important because if you always start with the same seed,
    you will always get the same sequence of random numbers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用`math/rand`包生成随机数，并需要一个种子来开始生成随机数。种子用于初始化整个过程，非常重要，因为如果始终使用相同的种子开始，将始终得到相同的随机数序列。
- en: 'The `random.go` program has three main parts. The first part is the preamble
    of the program:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`random.go`程序有三个主要部分。第一部分是程序的序言：'
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The second part is the definition of the `random()` function that returns a
    random number each time it is called, using the `rand.Intn()` Go function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是定义`random()`函数，每次调用该函数都会返回一个随机数，使用`rand.Intn()` Go函数：
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The two parameters of the `random()` function define the lower and upper limits
    of the generated random number. The last part of `random.go` is the implementation
    of the `main()` function that is mainly used for calling the `random()` function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`random()` 函数的两个参数定义了生成的随机数的下限和上限。`random.go` 的最后部分是 `main()` 函数的实现，主要用于调用
    `random()` 函数：'
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A big part of the `main()` function involves dealing with the reading of command-line
    arguments as integer numbers and printing a descriptive error message in case
    you did not get the correct number of command-line arguments. This is the standard
    practice that we will follow in this book. The `random.go` program uses the Unix
    epoch time as the seed for the random number generator by calling the `time.Now().Unix()`
    function. The important thing to remember is that you do not have to call `rand.Seed()`
    multiple times. Lastly, `random.go` does not examine the error variable returned
    by `strconv.Atoi()` to save book space, not because it is not necessary.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数的一个重要部分涉及处理命令行参数作为整数，并在没有获得正确数量的命令行参数时打印描述性错误消息。这是本书中我们将遵循的标准做法。`random.go`
    程序使用 Unix 纪元时间作为随机数生成器的种子，通过调用 `time.Now().Unix()` 函数。要记住的重要事情是，你不必多次调用 `rand.Seed()`。最后，`random.go`
    不检查 `strconv.Atoi()` 返回的错误变量以节省书本空间，而不是因为它不必要。'
- en: 'Executing `random.go` generates the following kind of output:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `random.go` 会生成以下类型的输出：
- en: '[PRE72]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Should you wish to generate more secure random numbers in Go, you should use
    the `crypto/rand` package, which implements a cryptographically secure pseudorandom
    number generator. You can find more information about the `crypto/rand` package
    by visiting its documentation page at [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在 Go 中生成更安全的随机数，你应该使用 `crypto/rand` 包，它实现了一个密码学安全的伪随机数生成器。你可以通过访问其文档页面
    [https://golang.org/pkg/crypto/rand/](https://golang.org/pkg/crypto/rand/) 获取有关
    `crypto/rand` 包的更多信息。
- en: If you are really into random numbers, then the definitive reference to the
    theory of random numbers is the second volume of *The Art of Computer Programming*
    by Donald Knuth.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的对随机数感兴趣，那么随机数理论的权威参考书是 Donald Knuth 的《计算机编程艺术》第二卷。
- en: Exercises
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Browse the Go documentation site: [https://golang.org/doc/](https://golang.org/doc/).'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览 Go 文档网站：[https://golang.org/doc/](https://golang.org/doc/)。
- en: Write a Go program that keeps reading integers until you give the number 0 as
    input, then it prints the minimum and maximum integer in the input.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 Go 程序，它会一直读取整数，直到你输入数字 0 为止，然后打印输入中的最小和最大整数。
- en: Write the same Go program as before, but this time, you will get your input
    using command-line arguments. Which version do you think is better? Why?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写与之前相同的 Go 程序，但这次，你将使用命令行参数获取输入。你认为哪个版本更好？为什么？
- en: Write a Go program that supports two command-line options (`-i` and `-k`) in
    random order using if statements. Now change your program to support three command-line
    arguments. As you will see, the complexity of the latter program is just too much
    to handle using if statements.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个支持两个命令行选项（`-i` 和 `-k`）的 Go 程序，使用 if 语句可以随机顺序。现在将你的程序更改为支持三个命令行参数。正如你将看到的，后一个程序的复杂性太大，无法使用
    if 语句处理。
- en: If the indices of a map were natural numbers, are there any cases that it would
    be wise and efficient to use a map instead of an array?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果映射的索引是自然数，是否有任何情况下使用映射而不是数组是明智且有效的？
- en: Try to put the functionality of `array2map.go` into a separate function.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将 `array2map.go` 的功能放入一个单独的函数中。
- en: Try to develop your own random number generator in Go that will still use the
    current time as a seed but not the `math/rand` package.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在 Go 中开发自己的随机数生成器，它仍然使用当前时间作为种子，但不使用 `math/rand` 包。
- en: Learn how to create a slice from an existing array. What happens when you make
    changes to the slice?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从现有数组创建切片。当你对切片进行更改时会发生什么？
- en: Use the `copy()` function to make a copy of an existing slice. What happens
    when the destination slice is smaller than the source slice? What happens when
    the destination slice is bigger than the source slice?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `copy()` 函数复制现有切片。当目标切片小于源切片时会发生什么？当目标切片大于源切片时会发生什么？
- en: Try to write an interface for supporting points in 3D space. Then, use this
    interface to support points that reside on the x-axis.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试编写一个支持 3D 空间中的点的接口。然后，使用这个接口来支持位于 x 轴上的点。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You learned many things in this chapter, including getting user input and processing
    command-line arguments. You familiarized yourself with the basic Go structures
    and you created a Go program that generates random numbers. Try to do the offered
    exercises and do not get discouraged if you fail in some of them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了很多东西，包括获取用户输入和处理命令行参数。你熟悉了基本的 Go 结构，并创建了一个生成随机数的 Go 程序。尝试做提供的练习，如果在某些练习中失败，不要灰心。
- en: The next chapter will talk about many advanced Go features, including error
    handling, pattern matching, regular expressions, reflection, unsafe code, calling
    C code from Go, and the `strace(1)` command-line utility. I will compare Go with
    other programming languages and give you practical advice in order to avoid some
    common Go pitfalls.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论许多高级的 Go 特性，包括错误处理、模式匹配、正则表达式、反射、不安全代码、从 Go 调用 C 代码以及 `strace(1)` 命令行实用程序。我将把
    Go 与其他编程语言进行比较，并给出实用建议，以避免一些常见的 Go 陷阱。
