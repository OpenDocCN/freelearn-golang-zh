- en: Advanced Go Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Go特性
- en: In the previous chapter, you learned how to compile Go code, how to get input
    from the user and print the output on the screen, how to create your own Go functions,
    the data structures that Go supports, and how to process command-line arguments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何编译Go代码，如何从用户那里获取输入并在屏幕上打印输出，如何创建自己的Go函数，Go支持的数据结构以及如何处理命令行参数。
- en: This chapter will discuss many fascinating things, so you better prepare yourselves
    for lots of interesting and practical Go code that will help you perform many
    different yet really important tasks, starting with error handling and ending
    with how to avoid some common Go mistakes. If you are familiar with Go, you can
    skip what you already know, but please do not skip the proposed exercises.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论许多有趣的事情，因此您最好为许多有趣且实用的Go代码做好准备，这些代码将帮助您执行许多不同但非常重要的任务，从错误处理开始，以避免一些常见的Go错误结束。如果您熟悉Go，可以跳过您已经知道的内容，但请不要跳过建议的练习。
- en: 'So, this chapter will talk about some advanced Go features, including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将讨论一些高级的Go特性，包括：
- en: Error handling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error logging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误日志记录
- en: Pattern matching and regular expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配和正则表达式
- en: Reflection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: How to use the `strace(1)` and `dtrace(1)` tools to watch the system calls of
    Go executable files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`strace(1)`和`dtrace(1)`工具来监视Go可执行文件的系统调用
- en: How to detect unreachable Go code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测不可达的Go代码
- en: How to avoid various common Go mistakes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免各种常见的Go错误
- en: Error handling in Go
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的错误处理
- en: Errors happen all the time, so it is our job to both catch and handle them,
    especially when writing code that deals with sensitive system information and
    files. The good news is that Go has a special data type called `error` that helps
    signify erroneous states; if an `error` variable has a `nil` value, then there
    is no error situation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 错误经常发生，因此我们的工作是捕捉并处理它们，特别是在编写处理敏感系统信息和文件的代码时。好消息是，Go有一种特殊的数据类型叫做`error`，可以帮助表示错误状态；如果`error`变量的值为`nil`，则没有错误情况。
- en: 'As you saw in the `addCLA.go` program that was developed in the previous chapter,
    you can ignore the `error` variable that is returned by most Go functions using
    the `_` character:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中开发的`addCLA.go`程序中看到的，您可以使用`_`字符忽略大多数Go函数返回的`error`变量：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, this is not considered good practice and should be avoided, especially
    on systems software and other kinds of critical software, such as server processes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不被认为是良好的做法，应该避免，特别是在系统软件和其他类型的关键软件（如服务器进程）上。
- en: 'As you will see in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*, even **End of File** (**EOF**) is a type of error that
    is returned when there is nothing left to read from a file. As `EOF` is defined
    in the `io` package, you can handle it as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)中看到的，*文件输入和输出*，即使是**文件结束**（**EOF**）也是一种错误类型，在从文件中没有剩余内容可读时返回。由于`EOF`在`io`包中定义，您可以按以下方式处理它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, the most important task to learn is how to develop functions that return
    `error` variables and how to handle them, which is explained next.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，学习如何开发返回`error`变量的函数以及如何处理它们是最重要的任务，下面将对此进行解释。
- en: Functions can return error variables
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数可以返回错误变量
- en: Go functions can return `error` variables, which means that an error condition
    can be handled inside a function, outside of a function, or both inside and outside
    the function; the latter situation does not happen very often. So, this subsection
    will develop a function that returns error messages. The relevant Go code can
    be found in `funErr.go` and will be presented in three parts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go函数可以返回`error`变量，这意味着错误条件可以在函数内部、函数外部或者函数内外都可以处理；后一种情况并不经常发生。因此，本小节将开发一个返回错误消息的函数。相关的Go代码可以在`funErr.go`中找到，并将分为三部分呈现。
- en: 'The first part contains the following Go code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含以下Go代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from the expected preamble, the preceding code defines a new function
    named `division()`, which returns an integer and two `error` variables. If you
    remember from your Math classes, when you divide two integer numbers, the division
    operation is not always perfect, which means that you might get a remainder that
    is not zero. The `errors.New()` function from the `errors` Go package that you
    see in `funErr.go` creates a new `error` variable, using the provided string as
    the error message.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预期的前言之外，上述代码定义了一个名为`division()`的新函数，该函数返回一个整数和两个`error`变量。如果您还记得您的数学课，当您除两个整数时，除法运算并不总是完美的，这意味着您可能会得到一个不为零的余数。您在`funErr.go`中看到的`errors`
    Go包中的`errors.New()`函数创建一个新的`error`变量，使用提供的字符串作为错误消息。
- en: 'The second part of `funErr.go` has the following Go code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`funErr.go`的第二部分包含以下Go代码：'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is a very common Go practice to compare an `error` variable with `nil` to
    quickly find out whether there is an error condition or not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将`error`变量与`nil`进行比较是Go中非常常见的做法，可以快速判断是否存在错误条件。
- en: 'The last part of `funErr.go` is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`funErr.go`的最后一部分如下：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This part showcases two erroneous conditions. The first one is an integer division
    that has a remainder, whereas the second one is an invalid division because you
    cannot divide a number by zero. As the name `log.Fatal()` implies, this logging
    function should be used for critical errors only because when called, it automatically
    terminates your program. However, as you will see in the next subsection, there
    exist other, more gentle, ways to log your error messages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分展示了两种错误条件。第一种是具有余数的整数除法，而第二种是无效的除法，因为您不能将一个数除以零。正如名称`log.Fatal()`所暗示的，这个日志函数应该仅用于关键错误，因为当调用时，它会自动终止您的程序。然而，正如您将在下一小节中看到的，存在其他更温和的方式来记录您的错误消息。
- en: 'Executing `funErr.go` generates the next output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`funErr.go`会生成以下输出：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last line is automatically generated by the `log.Fatal()` function, just
    before terminating the program. It is important to understand that any Go code
    after the call to `log.Fatal()` will not be executed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是由`log.Fatal()`函数自动生成的，在终止程序之前。重要的是要理解，在调用`log.Fatal()`之后的任何Go代码都不会被执行。
- en: About error logging
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于错误记录
- en: Go offers functions that can help you log your error messages in various ways.
    You already saw `log.Fatal()` in `funErr.go`, which is a somewhat cruel way to
    deal with simple errors. Put simply, you should have a very good reason to use
    `log.Fatal()` in your code. Generally speaking, `log.Fatal()` should be used instead
    of the `os.Exit()` function because it allows you to print an error message and
    exit your program using just one function call.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了可以帮助您以各种方式记录错误消息的函数。您已经在`funErr.go`中看到了`log.Fatal()`，这是一种处理简单错误的相当残酷的方式。简单地说，您应该有充分的理由在代码中使用`log.Fatal()`。一般来说，应该使用`log.Fatal()`而不是`os.Exit()`函数，因为它允许您使用一个函数调用打印错误消息并退出程序。
- en: Go offers additional error logging functions in the `log` standard package that
    behave more gently depending on the situation, which includes `log.Printf()`,
    `log.Print()`, `log.Println()`, `log.Fatalf()`, `log.Fatalln()`, `log.Panic()`,
    `log.Panicln()`, and `log.Panicf()`. Please note that logging functions can be
    handy for debugging purposes so do not underestimate their power.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go在`log`标准包中提供了更温和地根据情况行为的附加错误记录函数，包括`log.Printf()`、`log.Print()`、`log.Println()`、`log.Fatalf()`、`log.Fatalln()`、`log.Panic()`、`log.Panicln()`和`log.Panicf()`。请注意，记录函数对于调试目的可能会很有用，因此不要低估它们的作用。
- en: 'The `logging.go` program illustrates two of the mentioned logging functions
    using the following Go code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging.go`程序使用以下Go代码说明了所提到的两个记录函数：'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, `logging.go` does not need the `fmt` package because it has
    its own functions for printing the output. Executing `logging.go` will produce
    the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`logging.go`不需要`fmt`包，因为它有自己的函数来打印输出。执行`logging.go`将产生以下输出：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although the `log.Printf()` function works in the same way as `fmt.Printf()`,
    it automatically prints the date and time the log message was printed, just like
    the `log.Fatal()` function did in `funErr.go`. Additionally, the `log.Panicf()`
    function works in a similar way to `log.Fatal()`--they both terminate the current
    program. However, `log.Panicf()` prints some additional information, useful for
    debugging purposes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`log.Printf()`函数的工作方式与`fmt.Printf()`相同，但它会自动打印日志消息打印的日期和时间，就像`funErr.go`中的`log.Fatal()`函数一样。此外，`log.Panicf()`函数的工作方式与`log.Fatal()`类似--它们都会终止当前程序。但是，`log.Panicf()`会打印一些额外的信息，用于调试目的。
- en: Go also offers the `log/syslog` package that is a simple interface to the system
    log service running on your Unix machine. [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml),
    *Working with System Files*, will talk more about the `log/syslog` package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Go还提供了`log/syslog`包，它是Unix机器上运行的系统日志服务的简单接口。[第7章](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)，*使用系统文件*，将更多地讨论`log/syslog`包。
- en: The addCLA.go program revisited
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视addCLA.go程序
- en: 'This subsection will present an improved version of the `addCLA.go` program
    we developed in the previous chapter, to make it able to handle any kind of user
    input. The new program will be called `addCLAImproved.go`, but instead of presenting
    its full Go code, you will only see the differences between `addCLAImproved.go`
    and `addCLA.go` using the `diff(1)` command-line utility:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将介绍在前一章中开发的`addCLA.go`程序的改进版本，以使其能够处理任何类型的用户输入。新程序将被称为`addCLAImproved.go`，但是，您将只看到`addCLAImproved.go`和`addCLA.go`之间的差异，使用`diff(1)`命令行实用程序：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What this output basically tells us is that the last two lines of code, which
    can be found in `addCLA.go` and begin with the `>` character, were replaced by
    the lines of code that begin with the `<` character in `addCLAImproved.go`. The
    remaining code of both files is exactly the same.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出基本上告诉我们的是，在`addCLA.go`中找到的最后两行代码，以`>`字符开头，被`addCLAImproved.go`中以`<`字符开头的代码替换了。两个文件的剩余代码完全相同。
- en: The `diff(1)` utility compares text files line by line and is a handy way of
    spotting code differences between different versions of the same file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff(1)`实用程序逐行比较文本文件，是发现同一文件不同版本之间代码差异的一种方便方法。'
- en: 'Executing `addCLAImproved.go` will generate the following kind of output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`addCLAImproved.go`将生成以下类型的输出：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, the new and improved version works as expected, behaves reliably, and allows
    us to differentiate between valid and invalid input.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新的改进版本按预期工作，表现可靠，并允许我们区分有效和无效的输入。
- en: Pattern matching and regular expressions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配和正则表达式
- en: '**Pattern matching**, which plays a key role in Go, is a technique for searching
    a string for a set of characters based on a specific search pattern that is based
    on **regular expressions**. If pattern matching is successful, it allows you to
    extract the desired data from the string or replace or delete it. **Grammar**
    is a set of production rules for strings in a formal language. The production
    rules describe how to create strings from the alphabet of the language that are
    valid according to the syntax of the language. Grammar does not describe the meaning
    of a string or what can be done with it in whatever context, only its form. What
    is important is to realize that grammar is at the heart of regular expressions
    because without it, you cannot define or use a regular expression.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式匹配**在Go中扮演着关键角色，它是一种基于**正则表达式**的搜索字符串的技术，用于根据特定的搜索模式搜索一组字符。如果模式匹配成功，它允许您从字符串中提取所需的数据，或者替换或删除它。**语法**是形式语言中字符串的一组生成规则。生成规则描述如何根据语言的语法创建有效的字符串。语法不描述字符串的含义或在任何上下文中可以对其进行的操作，只描述其形式。重要的是要意识到语法是正则表达式的核心，因为没有它，您无法定义或使用正则表达式。'
- en: Regular expressions and pattern matching are not a panacea, so you should not
    try to solve every problem using regular expressions since they are not suitable
    for every kind of problem you may come up against. Furthermore, they might introduce
    unnecessary complexity to your software.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式和模式匹配并非万能良药，因此不应尝试使用正则表达式解决每个问题，因为它们并不适用于您可能遇到的每种问题。此外，它们可能会给您的软件引入不必要的复杂性。
- en: The Go package responsible for the pattern matching capabilities of Go is called
    `regexp`, which you can see in action in `regExp.go`. The code of `regExp.go`
    will be presented in four parts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 负责Go模式匹配功能的Go包称为`regexp`，您可以在`regExp.go`中看到其运行情况。`regExp.go`的代码将分为四部分呈现。
- en: 'The first part is the expected preamble:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序言：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second part is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Both calls to `regexp.MatchString()` try to find a static string, which is the
    first parameter, in a given string, which is the second parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp.MatchString()`的两次调用都尝试在给定的字符串（第二个参数）中查找静态字符串（第一个参数）。'
- en: 'The third part contains a single, yet crucial, line of Go code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含一行Go代码，但至关重要：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `regexp.Compile()` function reads the provided regular expression and tries
    to parse it. If the parsing of the regular expressing is successful, then `regexp.Compile()`
    returns a value of the `regexp.Regexp` variable type that you can use afterward.
    The `[Mm]` expression in the `regexp.Compile()` function means that what you are
    looking for can begin with an uppercase `M` or a lowercase `m`. Both `[` and `]`
    are special characters that are not part of the regular expression. So, the provided
    grammar is naive and only matches the words `Mihalis` and `mihalis`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp.Compile()`函数读取提供的正则表达式并尝试解析它。如果成功解析正则表达式，则`regexp.Compile()`返回`regexp.Regexp`变量类型的值，您随后可以使用它。`regexp.Compile()`函数中的`[Mm]`表达式表示您要查找的内容可以以大写`M`或小写`m`开头。`[`和`]`都是特殊字符，不是正则表达式的一部分。因此，提供的语法是天真的，只匹配单词`Mihalis`和`mihalis`。'
- en: 'The last part uses the previous regular expression that is stored in the `parse`
    variable:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分使用存储在`parse`变量中的先前正则表达式：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running `regExp.go` generates the next output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`regExp.go`会生成以下输出：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, the first call to `regexp.MatchString()` was a match, but the second was
    not because pattern matching is case-sensitive and `Tsoukalos` does not match
    `tsoukalos`. The `parse.ReplaceAllString()` function at the end searches the string
    that is given as an input (`"mihalis Mihalis"`) and replaces each match with the
    string that is given as its second parameter (`"MIHALIS"`).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对`regexp.MatchString()`的第一次调用是匹配的，但第二次调用不是，因为模式匹配是区分大小写的，`Tsoukalos`与`tsoukalos`不匹配。最后的`parse.ReplaceAllString()`函数搜索给定的字符串（`"mihalis
    Mihalis"`）并用其第二个参数（`"MIHALIS"`）替换每个匹配项。
- en: The rest of this section will present various examples using static text because
    you do not know how to read text files yet. However, as the static text will be
    stored in an array and processed line by line, the presented code can be easily
    modified to support getting your input from external text files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将使用静态文本呈现各种示例，因为您还不知道如何读取文本文件。但是，由于静态文本将存储在数组中并逐行处理，因此所呈现的代码可以轻松修改以支持从外部文本文件获取输入。
- en: Printing all the values from a given column of a line
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印行的给定列的所有值
- en: This is a very common scenario, as you often will need to get all the data from
    a given column of a structured text file in order to analyze it afterward. The
    code of `readColumn.go`, which prints values in the third column, will be presented
    in two parts.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常常见的情景，因为您经常需要从结构化文本文件的给定列中获取所有数据，以便随后进行分析。将呈现`readColumn.go`的代码，该代码将在两部分中呈现，打印第三列中的值。
- en: 'The first part is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, you import the required Go packages and define a string with three lines
    using an array with three elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您导入所需的Go包并使用包含三个元素的数组定义了一个包含三行的字符串。
- en: 'The second part contains the following Go code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, you define the column that interests you. Then, you start iterating over
    the strings stored in the array. This is similar to reading a text file line by
    line. The Go code inside the `for` loop splits the fields of the input line, stores
    them in the `data` array, verifies that the value from the desired column is present,
    and prints it on your screen. All of the hard work is done by the handy `strings.Fields()`
    function that splits a string based on whitespace characters, as defined in `unicode.IsSpace()`,
    and returns a slice of strings. Although `readColumn.go` does not use the `regexp.Compile()`
    function, the logic behind its implementation with the use of `strings.Fields()`
    is still based on the principles of regular expressions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您定义您感兴趣的列。然后，您开始迭代存储在数组中的字符串。这类似于逐行读取文本文件。`for`循环内的Go代码拆分输入行的字段，将它们存储在`data`数组中，验证所需列的值是否存在，并在屏幕上打印它。所有繁重的工作都由方便的`strings.Fields()`函数完成，该函数根据空格字符拆分字符串，如`unicode.IsSpace()`中定义的，并返回一个字符串切片。虽然`readColumn.go`没有使用`regexp.Compile()`函数，但其实现逻辑仍然基于正则表达式的原则，使用了`strings.Fields()`。
- en: An important thing to remember is that you should never trust your data. Put
    simply, always verify that the data you expect to grab is there.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件重要的事情是，您永远不应信任您的数据。简而言之，始终验证您期望获取的数据是否存在。
- en: 'Executing `readColumn.go` will generate the following kind of output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readColumn.go`将生成以下类型的输出：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml), *File Input and Output*,
    will show an improved version of `readColumn.go` that you can use as a starting
    point in case you want to modify the rest of the examples shown.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)，*文件输入和输出*，将展示`readColumn.go`的改进版本，您可以将其用作起点，以便修改所示示例的其余部分。'
- en: Creating summaries
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建摘要
- en: In this section, we will develop a program that adds all the values of a given
    column of text with multiple lines. To make things even more interesting, the
    column number will be given as a parameter in the program. The main difference
    between the program of this subsection and `readColumn.go` from the previous subsection
    is that you will need to convert each value into an integer number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个程序，它将添加多行文本中给定列的所有值。为了使事情更有趣，列号将作为程序的参数给出。本小节的程序与上一小节的`readColumn.go`的主要区别在于，您需要将每个值转换为整数。
- en: The name of the program that will be developed is `summary.go` and can be divided
    into three parts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将开发的程序的名称是`summary.go`，可以分为三部分。
- en: 'The first part is this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second part has the following Go code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code reads the index of the column that interests you. If you want
    to make `summary.go` even better, you can check for negative values in the `column`
    variable and print the appropriate error message.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码读取您感兴趣的列的索引。如果要使`summary.go`更好，可以检查`column`变量中的负值，并打印适当的错误消息。
- en: 'The last part of `summary.go` is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary.go`的最后一部分如下：'
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, most of the Go code in `summary.go` is about dealing with exceptions
    and potential errors. The core functionality of `summary.go` is implemented in
    a few lines of Go code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`summary.go`中的大部分Go代码都是关于处理异常和潜在错误。`summary.go`的核心功能是用几行Go代码实现的。
- en: 'Executing `summary.go` will give you the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`summary.go`将给出以下输出：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finding the number of occurrences
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找出现次数
- en: A very common programming problem is finding out the number of times an IP address
    appears in a log file. So, the example in this subsection will show you how to
    do this using a handy map structure. The `occurrences.go` program will be presented
    in three parts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的编程问题是找出IP地址在日志文件中出现的次数。因此，本小节中的示例将向您展示如何使用方便的映射结构来做到这一点。`occurrences.go`程序将分为三部分呈现。
- en: 'The first part is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second part is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we use the knowledge from the previous chapter to create a map named `counts`
    and populate it with the desired data using two `for` loops.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用上一章的知识创建了一个名为`counts`的映射，并使用两个`for`循环将所需的数据填充到其中。
- en: 'The last part is pretty small as it just prints the contents of the `counts`
    map:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分非常小，因为它只是打印`counts`映射的内容：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Executing `occurrences.go` and using the `sort(1)` command-line utility to
    sort the output of `occurrences.go` will generate the following kind of output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`occurrences.go`并使用`sort(1)`命令行实用程序对`occurrences.go`的输出进行排序将生成以下类型的输出：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, traditional Unix tools are still useful.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，传统的Unix工具仍然很有用。
- en: Find and replace
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和替换
- en: The example in this subsection will search the provided text for two variations
    of a given string and replace it with another string. The program will be named
    `findReplace.go` and will actually use Go regular expressions. The main reason
    for using the `regexp.Compile()` function, in this case, is that it greatly simplifies
    things and allows you to access your text only once.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节中的示例将搜索提供的文本，查找给定字符串的两种变体，并用另一个字符串替换它。程序将被命名为`findReplace.go`，实际上将使用Go正则表达式。在这种情况下使用`regexp.Compile()`函数的主要原因是它极大地简化了事情，并允许您只访问文本一次。
- en: 'The first part of the `findReplace.go` program is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`findReplace.go`程序的第一部分如下：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next part is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分如下：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The previous Go code will find every occurrence of an uppercase `B` or a lowercase
    `b` (`[bB]`). Note that there is also `regexp.MustCompile()` that works like `regexp.Compile()`.
    However, `regexp.MustCompile()` does not return an `error` variable; it just panics
    if the given expression is erroneous and cannot be parsed. As a result, `regexp.Compile()`
    is a better choice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Go代码将找到大写`B`或小写`b`（`[bB]`）的每个出现。请注意，还有`regexp.MustCompile()`，它的工作方式类似于`regexp.Compile()`。但是，`regexp.MustCompile()`不会返回一个`error`变量；如果给定的表达式错误并且无法解析，它会直接panic。因此，`regexp.Compile()`是一个更好的选择。
- en: 'The last part is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here you replace each match with an uppercase C using `parse.ReplaceAllString()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`parse.ReplaceAllString()`将每个匹配项替换为大写的C。
- en: 'Executing `findReplace.go` generates the expected output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`findReplace.go`将生成预期的输出：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `awk(1)` and `sed(1)` command-line tools can do most of the previous tasks
    more easily, but `sed(1)` and `awk(1)` are not general-purpose programming languages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk(1)`和`sed(1)`命令行工具可以更轻松地完成大部分以前的任务，但`sed(1)`和`awk(1)`不是通用的编程语言。'
- en: Reflection
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: Reflection is an advanced Go feature that allows you to dynamically learn the
    type of an arbitrary object as well as information about its structure. You should
    recall that the `dataStructures.go` program from [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml),
    *Writing Programs in Go*, used reflection to find out the fields of a data structure
    as well as the type of each fields. All of this happened with the help of the
    `reflect` Go package and the `reflect.TypeOf()` function that returns a `Type`
    variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是Go的一个高级特性，它允许您动态了解任意对象的类型以及有关其结构的信息。您应该回忆起[第2章](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)中的`dataStructures.go`程序，*在Go中编写程序*，它使用反射来查找数据结构的字段以及每个字段的类型。所有这些都是在`reflect`
    Go包和`reflect.TypeOf()`函数的帮助下完成的，该函数返回一个`Type`变量。
- en: Reflection is illustrated in the `reflection.go` Go program that will be presented
    in four parts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 反射在`reflection.go` Go程序中得到了展示，将分为四部分呈现。
- en: 'The first one is the preamble of the Go program and has the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是Go程序的序言，代码如下：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second part is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, you create two new types, named `t1` and `t2`, that are both `int` and
    three variables, named `x1`, `x2`, and `x3`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了两种新类型，名为`t1`和`t2`，它们都是`int`，以及三个变量，名为`x1`、`x2`和`x3`。
- en: 'The third part has the following Go code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Go代码：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, you find the type of the `x1`, `x2`, and `x3` variables using `reflect.ValueOf()`
    and `Type()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`reflect.ValueOf()`和`Type()`找到`x1`、`x2`和`x3`变量的类型。
- en: 'The last part of `reflection.go` deals with a `struct` variable:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`reflection.go`的最后一部分涉及`struct`变量：'
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There exist some laws that govern reflection in Go, but talking about them is
    beyond the scope of this book. What you should remember is that your programs
    can examine their own structure using reflection, which is a very powerful capability.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go中存在一些管理反射的规则，但讨论它们超出了本书的范围。您应该记住的是，您的程序可以使用反射来检查自己的结构，这是一种非常强大的能力。
- en: 'Executing `reflection.go` prints the following output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`reflection.go`打印以下输出：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first two lines of the output show that Go does not consider the types `t1`
    and `t2` as equal, even though both `t1` and `t2` are aliases of the `int` type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前两行显示，Go不认为类型`t1`和`t2`相等，尽管`t1`和`t2`都是`int`类型的别名。
- en: Old habits die hard!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 旧习惯难改！
- en: Despite the fact that Go tries to be a safe programming language, sometimes
    it is forced to forget about safety and allows the programmer to do whatever he/she
    wants.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go试图成为一种安全的编程语言，但有时它被迫忘记安全性，并允许程序员做任何他/她想做的事情。
- en: Calling C code from Go
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Go调用C代码
- en: Go allows you to call C code because there are times when the only way to perform
    some tasks, such as communicating with a hardware device or a database server,
    is by using C. Nevertheless, if you find yourself using this capability many times
    in the same project, you might need to reconsider your approach and your choice
    of programming language.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许您调用C代码，因为有时执行某些任务的唯一方法，例如与硬件设备或数据库服务器通信，是使用C。然而，如果您发现自己在同一个项目中多次使用此功能，您可能需要重新考虑您的方法和编程语言的选择。
- en: Talking more about this capability in Go is beyond the scope of this book. What
    you should remember is that most likely, you will never need to call C code from
    your Go program. Nevertheless, should you wish to explore this Go feature, you
    can start by visiting the documentation of the `cgo` tool at [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)
    as well as by looking at the code found at [https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go](https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围之外更多地讨论Go中的这一功能。您应该记住的是，您很可能永远不需要从Go程序中调用C代码。然而，如果您希望探索这一Go功能，可以首先访问[cgo工具的文档](https://golang.org/cmd/cgo/)，并查看[https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go](https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go)中的代码。
- en: Unsafe code
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的代码
- en: Unsafe code is Go code that bypasses the type safety and memory security of
    Go and requires the use of the `unsafe` package. You will most likely never need
    to use unsafe code in your Go programs but if for some strange reason you ever
    need to, it will probably have to do with pointers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不安全的代码是绕过Go的类型安全和内存安全的Go代码，需要使用`unsafe`包。您很可能永远不需要在Go程序中使用不安全的代码，但如果出于某种奇怪的原因您确实需要使用它，那可能与指针有关。
- en: Using unsafe code can be dangerous for your programs, so only use it when it
    is absolutely necessary. If you are not completely sure that you need it, then
    do not use it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的程序来说，使用不安全的代码可能是危险的，因此只有在绝对必要时才使用它。如果您不完全确定需要它，那么就不要使用它。
- en: The example code in this subsection is saved as `unsafe.go` and will be presented
    in two parts.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节中的示例代码保存为`unsafe.go`，将分两部分呈现。
- en: 'The first part is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You first create a new `int64` variable that is named `value`. Then, you create
    a pointer to it named `p1`. Next, you create another pointer that points to `p1`.
    However, the `p2` pointer that points to `p1` is a pointer to an `int32` integer,
    despite the fact that `p1` points to an `int64` variable. Although this is not
    permitted by Go rules, the `unsafe.Pointer()` function makes this possible.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为`value`的新`int64`变量。然后，创建一个指向它的指针命名为`p1`。接下来，创建另一个指针指向`p1`。然而，指向`p1`的`p2`指针是指向`int64`变量的指针，尽管`p1`指向`int64`变量。尽管这违反了Go的规则，但`unsafe.Pointer()`函数使这成为可能。
- en: 'The second part is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Executing `unsafe.go` will create the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`unsafe.go`将创建以下输出：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The output shows how dangerous an unsafe pointer can be. When the value of the
    `value` variable fits into an `int32` memory space (`5` and `31212132`), then
    `p2` works fine and shows the correct result. However, when the `value` variable
    holds a value (`312121321321213212`) that does not fit into an `int32` memory
    space, then `p2` shows an erroneous result (`606940444`), without giving you a
    warning or an error message.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了不安全指针有多危险。当`value`变量的值适合于`int32`内存空间（`5`和`31212132`）时，`p2`运行正常并显示正确的结果。然而，当`value`变量持有一个不适合`int32`内存空间的值（`312121321321213212`）时，`p2`显示了错误的结果（`606940444`），而没有提供警告或错误消息。
- en: Comparing Go to other programming languages
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Go与其他编程语言进行比较
- en: 'Go is not perfect, but neither are the rest of the programming languages. This
    section will briefly discuss other programming languages and compare them to Go
    in order to give you a better understanding of the choices you have. So, the list
    of programming languages that can be compared to Go includes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Go并不完美，但其他编程语言也不完美。本节将简要讨论其他编程语言，并将它们与Go进行比较，以便让您更好地了解您的选择。因此，可以与Go进行比较的编程语言列表包括：
- en: '**C**: C is the most popular programming language for developing systems software
    because the portable part of each Unix operating system is written in C. However,
    it has some critical drawbacks, including the fact that C pointers, which are
    great and fast, can lead to difficult-to-detect bugs and memory leaks. Additionally,
    C does not offer garbage collection; back when C was created, garbage collection
    was a luxury that had the ability slow down computers. However, nowadays computers
    are pretty fast and garbage collection does not slow things down anymore. Moreover,
    C programs require more code for developing a given task than other systems programming
    languages. Lastly, C is an old programming language that does not support modern
    programming paradigms, such as object-oriented and functional programming.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C**：C是开发系统软件最流行的编程语言，因为每个Unix操作系统的可移植部分都是用C编写的。然而，它也有一些关键缺点，包括C指针，它们很棒也很快，但可能导致难以检测的错误和内存泄漏。此外，C不提供垃圾回收；在C创建时，垃圾回收是一种可能会减慢计算机速度的奢侈品。然而，如今的计算机非常快，垃圾回收不再拖慢速度。此外，与其他系统编程语言相比，C程序需要更多的代码来开发给定的任务。最后，C是一种不支持现代编程范式的旧编程语言，比如面向对象和函数式编程。'
- en: '**C++**: As previously mention, I do not like C++ anymore. If you think that
    you should use C++, then you may want to consider using C instead. However, the
    main advantage of C++ over Go is that if needed, C++ can be used as if it were
    C. However, neither C nor C++ have good support for concurrent programming.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++**：如前所述，我不再喜欢C++。如果你认为应该使用C++，那么你可能想考虑使用C。然而，C++相对于Go的主要优势在于，如果需要，C++可以像C一样使用。然而，无论是C还是C++都不支持并发编程。'
- en: '**Rust**: Rust is a new systems programming language that tries to avoid unpleasant
    bugs caused by unsafe code. Currently, the syntax of Rust is changing too fast,
    but this will end in the near feature. If for some reason you do not like Go,
    you should try Rust.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rust**：Rust是一种新的系统编程语言，试图避免由不安全代码引起的不愉快的错误。目前，Rust的语法变化太快，但这将在不久的将来结束。如果出于某种原因你不喜欢Go，你应该尝试Rust。'
- en: '**Swift**: In its current status, Swift is more suitable for developing systems
    software for macOS systems. However, I am sure that in the near feature, Swift
    will be more popular on Linux machines, so you should keep an eye on it.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swift**：在目前的状态下，Swift更适合开发macOS系统的系统软件。然而，我相信在不久的将来，Swift将在Linux机器上更受欢迎，所以你应该留意它。'
- en: '**Python**: Python is a scripting language, which is its main disadvantage.
    This is because usually, you do not want to make the source of your systems software
    available to everyone.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：Python是一种脚本语言，这是它的主要缺点。这是因为通常情况下，你不希望将系统软件的源代码公开给所有人。'
- en: '**Perl**: What was said about Python can be also said about Perl. However,
    both programming languages have a plethora of modules that will make your life
    a lot easier and your code a lot smaller.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Perl**：关于Python所说的也适用于Perl。然而，这两种编程语言都有大量的模块，可以让你的生活变得更轻松，你的代码变得更简洁。'
- en: If you ask my opinion, I think that Go is a modern, portable, mature, and safe
    programming language for writing systems software. You should try Go before looking
    for any alternatives. However, if you are a Go programmer and want to try something
    else, I suggest that you pick Rust or Swift. Yet, if you need to write reliable
    concurrent programs, Go should be your first choice.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我的意见，我认为Go是一种现代、可移植、成熟和安全的编程语言，用于编写系统软件。在寻找其他选择之前，你应该先尝试Go。然而，如果你是一名Go程序员，想尝试其他东西，我建议你选择Rust或Swift。然而，如果你需要编写可靠的并发程序，Go应该是你的首选。
- en: If you cannot choose between Go and Rust, then just try C. Learning the basics
    of systems programming is more important than the programming language you select.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在Go和Rust之间做出选择，那就试试C。学习系统编程的基础知识比你选择的编程语言更重要。
- en: Despite their disadvantages, bear in mind that all scripting programming languages
    are perfect for writing prototypes and have the advantage that they allow you
    to create graphical interfaces for your software. Still, delivering systems software
    in a scripting language is rarely accepted, unless there is a really good reason
    to do so.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们有缺点，但请记住，所有脚本编程语言都非常适合编写原型，并且它们的优势在于可以为软件创建图形界面。然而，使用脚本语言交付系统软件很少被接受，除非有一个真正的好理由这样做。
- en: Analysing software
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析软件
- en: There are times that a program fails for some unknown reason or does not perform
    well, and you want to find out why without having to rewrite your code and add
    a plethora of debugging statements. So, this section will talk about `strace(1)`
    and `dtrace(1)` , which allow you to see what is going on behind the scenes when
    you execute a program on a Unix machine. Although both tools can work with the
    `go run` command, you will get less unrelated output if you first create an executable
    file using `go build` and use this file. This mainly occurs because `go run` makes
    temporary files before actually running your Go code, and you want to debug the
    actual program, not the compiler used to build the program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时程序因某种未知原因失败或性能不佳，你希望找出原因，而不必重写代码并添加大量的调试语句。因此，本节将讨论`strace(1)`和`dtrace(1)`，它们允许你在Unix机器上执行程序时看到幕后发生了什么。虽然这两个工具都可以与`go
    run`命令一起使用，但如果你首先使用`go build`创建可执行文件并使用该文件，你将获得更少的无关输出。这主要是因为`go run`在实际运行Go代码之前会生成临时文件，而你想调试的是实际程序，而不是用于构建程序的编译器。
- en: Remember that although `dtrace(1)` is more powerful than `strace(1)` and has
    its own programming language, `strace(1)` is more versatile for watching the system
    calls a program makes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管`dtrace(1)`比`strace(1)`更强大，并且有自己的编程语言，但`strace(1)`更适用于观察程序所做的系统调用。
- en: Using the strace(1) command-line utility
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用strace(1)命令行实用程序
- en: The `strace(1)` command-line utility allows you to trace system calls and signals.
    As `strace(1)` is not available on Mac machines, this section will use a Linux
    machine to showcase `strace(1)`. However, as you will see in a later, macOS machines
    have the `dtrace(1)` command-line utility that can do many more things.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace(1)`命令行实用程序允许您跟踪系统调用和信号。由于Mac机器上没有`strace(1)`，因此本节将使用Linux机器来展示`strace(1)`。但是，正如您将在稍后看到的那样，macOS机器有`dtrace(1)`命令行实用程序，可以做更多的事情。'
- en: The number after the name of a program refers to the section of the manual its
    page belongs to. Although most of the names can be found only once, which means
    that putting the section number is not necessary, there are names that can be
    located in multiple sections because they have multiple meanings, such as `crontab(1)`
    and `crontab(5)`. Therefore, if you try to retrieve such a page without specifically
    stating the section number, you will get the entry in the section of the manual
    that has the smallest section number.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 程序名称后面的数字指的是其页面所属的手册部分。尽管大多数名称只能找到一次，这意味着不必放置部分编号，但是有些名称可能位于多个部分，因为它们具有多重含义，例如`crontab(1)`和`crontab(5)`。因此，如果尝试检索此类页面而没有明确指定部分编号，将会得到手册中具有最小部分编号的条目。
- en: 'To get a good sense of the output generated by `strace(1)`, look at the following
    figure where `strace(1)` is used to examine the executable of `addCLAImproved.go`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要对`strace(1)`生成的输出有一个良好的感觉，请查看以下图，其中`strace(1)`用于检查`addCLAImproved.go`的可执行文件：
- en: '![](img/6c0c5c81-3946-433a-bc90-4dafd085d3a0.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c0c5c81-3946-433a-bc90-4dafd085d3a0.png)'
- en: Using the strace(1) command on a Linux machine
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上使用strace(1)命令
- en: 'The really interesting part of the `strace(1)` output is the following line,
    which cannot be seen in the preceding figure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace(1)`输出的真正有趣的部分是以下行，这在前面的图中看不到：'
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We used the `grep(1)` command-line utility to extract the lines that contain
    the C system call that interests us, which in this case is `write(2)`. This is
    because we already know that `write(2)` is used for printing output. So, you learned
    that in this case, a single `write(2)` C system call is used for printing all
    of the output on the screen; its first parameter is the file descriptor, and its
    second parameter is the text you want to print.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`grep(1)`命令行实用程序提取包含我们感兴趣的C系统调用的行，这种情况下是`write(2)`。这是因为我们已经知道`write(2)`用于打印输出。因此，您了解到在这种情况下，单个`write(2)`
    C系统调用用于在屏幕上打印所有输出；它的第一个参数是文件描述符，第二个参数是要打印的文本。
- en: Note that you might want to use `strace(1)` with the `-f` option in order to
    also trace any child processes that might get created during the execution of
    a program.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能希望使用`strace(1)`的`-f`选项，以便还跟踪在程序执行期间可能创建的任何子进程。
- en: Bear in mind that there exist two more variations of `write(2)`, named `pwrite(2)`
    and `writev(2)`, which offer the same core functionality as `write(2)` but in
    a slightly different way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，还存在`write(2)`的另外两个变体，名为`pwrite(2)`和`writev(2)`，它们提供与`write(2)`相同的核心功能，但方式略有不同。
- en: 'The following variation of the previous command requires more calls to `write(2)`
    because it generates more output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的以下变体需要更多对`write(2)`的调用，因为它生成更多的输出：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Unix uses file descriptors, which are positive integer values, as an internal
    representation for accessing all its files. By default, all Unix systems support
    three special and standard filenames: `/dev/stdin`, `/dev/stdout`, and `/dev/stderr`.
    They can also be accessed using file descriptors 0, 1, and 2, respectively. These
    three file descriptors are also called standard input, standard output, and standard
    error, respectively. Additionally, the file descriptor 0 can be accessed as `/dev/fd/0`
    on a Mac machine and as `/dev/pts/0` on a Debian Linux machine because everything
    in Unix is a file.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Unix使用文件描述符作为访问其所有文件的内部表示，这些文件描述符是正整数值。默认情况下，所有Unix系统都支持三个特殊和标准的文件名：`/dev/stdin`、`/dev/stdout`和`/dev/stderr`。它们也可以使用文件描述符0、1和2进行访问。这三个文件描述符也分别称为标准输入、标准输出和标准错误。此外，文件描述符0可以在Mac机器上作为`/dev/fd/0`进行访问，在Debian
    Linux机器上可以作为`/dev/pts/0`进行访问，因为Unix中的一切都是文件。
- en: So, the reason for needing to put `2>&1` at the end of the command is to redirect
    all of the output, from standard error (file descriptor 2) to standard output
    (file descriptor 1), in order to be able to search it using the `grep(1)` command,
    which searches standard output only. Note that there exist many variations of
    `grep(1)`, including `zegrep(1)`, `fgrep(1)`, and `fgrep(1)`, that might work
    faster when they have to deal with large or huge text files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要在命令的末尾放置`2>&1`的原因是将所有输出，从标准错误（文件描述符2）重定向到标准输出（文件描述符1），以便能够使用`grep(1)`命令进行搜索，该命令仅搜索标准输出。请注意，存在许多`grep(1)`的变体，包括`zegrep(1)`、`fgrep(1)`和`fgrep(1)`，当它们需要处理大型或巨大的文本文件时，可能会更快地工作。
- en: What you can see here is that even if you are writing in Go, the generated executable
    uses C system calls and functions because apart from using machine language, C
    is the only way to communicate with the Unix kernel.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里看到的是，即使您在Go中编写，生成的可执行文件也使用C系统调用和函数，因为除了使用机器语言外，C是与Unix内核通信的唯一方式。
- en: The DTrace utility
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DTrace实用程序
- en: Although debugging utilities, such as `strace(1)` and `truss(1)`, which work
    on FreeBSD, can trace system calls produced by a process, they can be slow and
    therefore not appropriate for solving performance problems on busy Unix systems.
    Another tool named `dtrace(1)`, which uses the **DTrace** facility, allows you
    to see what happens behind the scenes on a system-wide basis without the need
    to modify or recompile anything. It also allows you to work on production systems
    and watch running programs or server processes dynamically without introducing
    a big overhead.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在FreeBSD上工作的调试实用程序，如`strace(1)`和`truss(1)`，可以跟踪进程产生的系统调用，但它们可能会很慢，因此不适合解决繁忙的Unix系统上的性能问题。另一个名为`dtrace(1)`的工具使用**DTrace**设施，允许您在系统范围内看到幕后发生的事情，而无需修改或重新编译任何内容。它还允许您在生产系统上工作，并动态地观察运行的程序或服务器进程，而不会引入大量开销。
- en: 'This subsection will use the `dtruss(1)` command-line utility, which is just
    a `dtrace(1)` script, that shows the system calls of a process. The output that
    `dtruss(1)` generates when examining the `addCLAImproved.go` executable on a macOS
    machine looks similar to the one that you can see in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将使用`dtruss(1)`命令行实用程序，它只是一个`dtrace(1)`脚本，显示进程的系统调用。当在macOS机器上检查`addCLAImproved.go`可执行文件时，`dtruss(1)`生成的输出看起来与以下截图中看到的类似：
- en: '![](img/f596ddbd-3b87-454d-8eda-478318fd1014.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f596ddbd-3b87-454d-8eda-478318fd1014.png)'
- en: Using the dtruss(1) command on a macOS machine
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS机器上使用dtruss(1)命令
- en: 'Once again, the following part of the output verifies that at the end of the
    day, everything on Unix machines is translated into C system calls and functions
    because this is the only way to communicate with the Unix kernel. You can display
    all the calls to the `write(2)` system call as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，输出的以下部分验证了在Unix机器上，最终一切都被转换成C系统调用和函数，因为这是与Unix内核通信的唯一方式。您可以显示对`write(2)`系统调用的所有调用如下：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, this time you are going to get lots of output because the macOS executable
    uses `write(2)` multiple times instead of just once to print the same output.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次你会得到大量的输出，因为macOS可执行文件多次使用`write(2)`而不是只使用一次来打印相同的输出。
- en: Starting to realize that not all Unix systems work the same way, despite their
    numerous similarities, is marvelous. But this also means that you should not make
    any assumptions about the way a Unix system works behind the scenes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 开始意识到并非所有的Unix系统都以相同的方式工作，尽管它们有许多相似之处，这是很奇妙的。但这也意味着你不应该对Unix系统在幕后的工作方式做任何假设。
- en: 'What is really interesting is the last part of the output of the following
    command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的是以下命令的输出的最后部分：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The reason you get this output is the `-c` option that tells `dtruss(1)` to
    count all system calls and print a summary of them, which in this case shows that
    `write(2)` has been called 83 times and `stat64(2)` 41 times.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到这个输出的原因是`-c`选项告诉`dtruss(1)`统计所有系统调用并打印它们的摘要，这种情况下显示`write(2)`被调用了83次，`stat64(2)`被调用了41次。
- en: The `dtrace(1)` utility is much more powerful than `strace(1)` and has its own
    programming language but is more difficult to learn. Additionally, even though
    there is a Linux version of `dtrace(1)`, `strace(1)` is more mature on Linux systems
    and does the job of tracing system calls in a simpler way.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtrace(1)`实用程序比`strace(1)`更强大，并且有自己的编程语言，但学习起来更困难。此外，尽管有Linux版本的`dtrace(1)`，但在Linux系统上，`strace(1)`更加成熟，以更简单的方式跟踪系统调用。'
- en: 'You can learn more about the `dtrace(1)` utility by reading *DTrace: Dynamic
    Tracing in Oracle Solaris, Mac OS X, and FreeBSD* by Brendan Gregg and Jim Mauro
    and by visiting [http://dtrace.org/](http://dtrace.org/).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过阅读Brendan Gregg和Jim Mauro的*DTrace: Dynamic Tracing in Oracle Solaris,
    Mac OS X, and FreeBSD*以及访问[http://dtrace.org/](http://dtrace.org/)了解更多关于`dtrace(1)`实用程序的信息。'
- en: Disabling System Integrity Protection on macOS
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS上禁用系统完整性保护
- en: 'There is a big chance that you will have trouble running `dtrace(1)` and `dtruss(1)`
    on your Mac OS X machine the first time you try them and get the following error
    message:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试在Mac OS X机器上运行`dtrace(1)`和`dtruss(1)`可能会遇到麻烦，并收到以下错误消息：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this case you might need to disable the DTrace restrictions but still keep
    System Integrity Protection active for everything else. You can learn more about
    System Integrity Protection by visiting [https://support.apple.com/en-us/HT204899](https://support.apple.com/en-us/HT204899).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能需要禁用DTrace的限制，但仍然保持系统完整性保护对其他所有内容有效。您可以通过访问[https://support.apple.com/en-us/HT204899](https://support.apple.com/en-us/HT204899)了解更多关于系统完整性保护的信息。
- en: Unreachable code
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无法到达的代码
- en: Unreachable code is code that can never be executed and is a logical kind of
    error. As the Go compiler itself cannot catch such logical errors, you will need
    to use the `go tool vet` command to help.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 无法到达的代码是永远不会被执行的代码，是一种逻辑错误。由于Go编译器本身无法捕捉这种逻辑错误，因此您需要使用`go tool vet`命令来帮助。
- en: You should not confuse unreachable code with code that never gets executed intentionally,
    such as the code of a function that is not needed and is therefore not called
    in a program.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该将无法到达的代码与从未被有意执行的代码混淆，比如不需要的函数的代码，因此在程序中从未被调用。
- en: The example code in this section is saved as `cannotReach.go` and can be divided
    into two parts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码保存为`cannotReach.go`，可以分为两部分。
- en: 'The first part has the following Go code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含以下Go代码：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second part is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, the unreachable code is in the first part. Both `x()` and `y()`
    functions have unreachable code because their `return` statements were put at
    the wrong place. However, we are not done yet because we will have to let the
    `go tool vet` tool discover the unreachable code. The process is simple and includes
    the execution of the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，无法到达的代码在第一部分。`x()`和`y()`函数都有无法到达的代码，因为它们的`return`语句放错了位置。然而，我们还没有完成，因为我们将让`go
    tool vet`工具发现无法到达的代码。这个过程很简单，包括执行以下命令：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Additionally, you can see that `go tool vet` detects unreachable code even if
    the surrounding function is not going to be executed at all, as happens with `y()`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以看到`go tool vet`即使周围的函数根本不会被执行，也会检测到无法到达的代码，就像`y()`一样。
- en: Avoiding common Go mistakes
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免常见的Go错误
- en: 'This section will briefly talk about some common Go mistakes so that you can
    avoid them in your programs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要讨论一些常见的Go错误，以便您在程序中避免它们：
- en: If you have an error in a Go function, either log it or return it; do not do
    both unless you have a really good reason to do so.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在Go函数中出现错误，要么记录下来，要么返回错误；除非你有一个非常好的理由，否则不要两者都做。
- en: Go interfaces define behaviors, not data and data structures.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go接口定义行为，而不是数据和数据结构。
- en: Use the `io.Reader` and `io.Writer` interfaces because they make your code more
    extensible.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`io.Reader`和`io.Writer`接口，因为它们使您的代码更具可扩展性。
- en: Make sure that you pass a pointer to a variable to a function only when needed.
    The rest of the time, just pass the value of the variable.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保只在需要时将变量的指针传递给函数。其余时间，只传递变量的值。
- en: Error variables are not strings; they are `error` values.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误变量不是字符串；它们是`error`值。
- en: If you are afraid of making mistakes, you will most likely end up doing nothing
    useful. So experiment as much as you can.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你害怕犯错，你很可能最终什么有用的事情都不会做。所以尽量多实验。
- en: 'The following are general pieces of advice that can be applied in every programming
    language:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以应用于每种编程语言的一般建议：
- en: Test your Go code and functions in small and autonomous Go programs to make
    sure that they behave the way you think they should
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在小型和独立的Go程序中测试您的Go代码和函数，以确保它们表现出您认为应该有的行为方式。
- en: If you do not really know a Go feature, test it before using it for the first
    time, especially if you are developing a systems utility
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不太了解Go的某个特性，在第一次使用之前先进行测试，特别是如果你正在开发系统实用程序。
- en: Do not test systems software on production machines
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在生产机器上测试系统软件
- en: When you deploy your systems software on a production machine, do it when the
    production machine is not busy and make sure that you have a backup plan
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将系统软件部署到生产机器上时，要在生产机器不忙的时候进行，并确保您有备份计划
- en: Exercises
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Find and visit the documentation page of the `log` package.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并访问`log`包的文档页面。
- en: Use `strace(1)` to examine `hw.go` from the previous chapter.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`strace(1)`来检查上一章中的`hw.go`。
- en: If you are on a Mac, try to examine the `hw.go` executable using `dtruss(1)`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用Mac，尝试使用`dtruss(1)`检查`hw.go`可执行文件。
- en: Write a program that gets input from the user and examine its executable file
    using either `strace(1)` or `dtruss(1)`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个从用户那里获取输入并使用`strace(1)`或`dtruss(1)`检查其可执行文件的程序。
- en: Visit the website of Rust at [https://www.rust-lang.org/](https://www.rust-lang.org/).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Rust的网站[https://www.rust-lang.org/](https://www.rust-lang.org/)。
- en: Visit the website of Swift at [https://swift.org/](https://swift.org/).
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Swift的网站[https://swift.org/](https://swift.org/)。
- en: Visit the documentation page of the `io` package at [https://golang.org/pkg/io/](https://golang.org/pkg/io/).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`io`包的文档页面[https://golang.org/pkg/io/](https://golang.org/pkg/io/)。
- en: Use the `diff(1)` command-line utility on your own in order to learn how to
    interpret its output better.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自己使用`diff(1)`命令行实用程序，以便更好地学习如何解释其输出。
- en: Visit and read the main page of `write(2)`.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问并阅读`write(2)`的主页。
- en: Visit the main page of `grep(1)`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问`grep(1)`的主页。
- en: Play with reflection on your own by examining your own structures.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查自己的结构来自己玩反射。
- en: Write an improved version of `occurrences.go` that will only display frequencies
    that are above a known numeric threshold, which will be given as a command-line
    argument.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个改进版本的`occurrences.go`，它只会显示高于已知数值阈值的频率，该阈值将作为命令行参数给出。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter taught you some advanced Go features, including error handling,
    pattern matching and regular expressions, reflection, and unsafe code. Also, it
    talked about the `strace(1)` and `dtrace(1)` tools.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教会了您一些高级的Go特性，包括错误处理、模式匹配和正则表达式、反射和不安全的代码。还讨论了`strace(1)`和`dtrace(1)`工具。
- en: The next chapter will cover many interesting things, including the use of the
    new `sort.slice()` Go function, which is available in the latest Go version (1.8),
    as well as the big O notation, sorting algorithms, Go packages, and garbage collection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖许多有趣的内容，包括使用最新Go版本（1.8）中提供的新`sort.slice()` Go函数，以及大O符号、排序算法、Go包和垃圾回收。
