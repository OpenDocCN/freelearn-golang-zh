- en: Files and Directories
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和目录
- en: In the previous chapter, we talked about many important topics including developing
    and using Go packages, Go data structures, algorithms, and GC. However, until
    now, we have not developed any actual system utility. This will change very soon
    because starting from this really important chapter, we will begin developing
    real system utilities in Go by learning how to use Go, to work with the various
    types of files and directories of a filesystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们谈到了许多重要的主题，包括开发和使用Go包，Go数据结构，算法和GC。然而，直到现在，我们还没有开发任何实际的系统实用程序。这很快就会改变，因为从这一非常重要的章节开始，我们将开始学习如何使用Go来开发真正的系统实用程序，以便处理文件系统的各种类型的文件和目录。
- en: You should always have in mind that Unix considers everything a file including
    symbolic links, directories, network devices, network sockets, entire hard drives,
    printers, and plain text files. The purpose of this chapter is to illustrate how
    the Go standard library allows us to understand if a path exists or not, as well
    as how to search directory structures to detect the kind of files we want. Additionally,
    this chapter will prove, using Go code as evidence, that many traditional Unix
    command-line utilities that work with files and directories do not have a difficult
    implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终记住，Unix将一切都视为文件，包括符号链接、目录、网络设备、网络套接字、整个硬盘驱动器、打印机和纯文本文件。本章的目的是说明Go标准库如何允许我们了解路径是否存在，以及如何搜索目录结构以检测我们想要的文件类型。此外，本章将通过Go代码作为证据证明，许多传统的Unix命令行实用程序在处理文件和目录时并不难实现。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: The Go packages that will help you manipulate directories and file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将帮助您操作目录和文件的Go包
- en: Processing command-line arguments and options easily using the `flag` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`flag`包轻松处理命令行参数和选项
- en: Developing a version of the `which(1)` command-line utility in Go
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中开发`which(1)`命令行实用程序的版本
- en: Developing a version of the `pwd(1)` command-line utility in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中开发`pwd(1)`命令行实用程序的版本
- en: Deleting and renaming files and directories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除和重命名文件和目录
- en: Traversing directory trees easily
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松遍历目录树
- en: Writing a version of the `find(1)` utility in Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`find(1)`实用程序的版本
- en: Duplicating a directory structure in another place
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个地方复制目录结构
- en: Useful Go packages
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的Go包
- en: The single most important package that allows you to manipulate files and directories
    as entities is the `os` package, which we will use extensively in this chapter.
    If you consider files as boxes with contents, the `os` package allows you to move
    them, put them into the wastebasket, change their names, visit them, and decide
    which ones you want to use, whereas the `io` package, which will be presented
    in the next chapter, allows you to manipulate the contents of a box without worrying
    too much about the box itself!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您将文件和目录视为实体的最重要的包是`os`包，在本章中我们将广泛使用它。如果您将文件视为带有内容的盒子，`os`包允许您移动它们，将它们放入废纸篓，更改它们的名称，访问它们，并决定您想要使用哪些文件，而`io`包，将在下一章中介绍，允许您操作盒子的内容，而不必太担心盒子本身！
- en: The `flag` package, which you will see in a while, lets you define and process
    your own flags and manipulate the command-line arguments of a Go program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag`包，您将很快看到，让您定义和处理自己的标志，并操作Go程序的命令行参数。'
- en: The `filepath` package is extremely handy as it includes the `filepath.Walk()`
    function that allows you to traverse entire directory structures in an easy way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath`包非常方便，因为它包括`filepath.Walk()`函数，允许您以简单的方式遍历整个目录结构。'
- en: Command-line arguments revisited!
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视命令行参数！
- en: As we saw in [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml), *Writing
    Programs in Go*, you cannot work efficiently with multiple command-line arguments
    and options using `if` statements. The solution to this problem is to use the
    `flag` package, which will be explained here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)中所看到的，*使用Go编写程序*，使用`if`语句无法高效处理多个命令行参数和选项。解决这个问题的方法是使用`flag`包，这将在这里解释。
- en: Remembering that the `flag` package is a standard Go package and that you do
    not have to search for the functionality of a flag elsewhere is extremely important.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`flag`包是一个标准的Go包，您不必在其他地方搜索标志的功能非常重要。
- en: The flag package
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flag包
- en: The `flag` package does the dirty work of parsing command-line arguments and
    options for us; so, there is no need for writing complicated and perplexing Go
    code. Additionally, it supports various types of parameters, including strings,
    integers, and Boolean, which saves you time as you do not have to perform any
    data type conversions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag`包为我们解析命令行参数和选项做了脏活，因此无需编写复杂和令人困惑的Go代码。此外，它支持各种类型的参数，包括字符串、整数和布尔值，这样可以节省时间，因为您不必执行任何数据类型转换。'
- en: 'The `usingFlag.go` program illustrates the use of the `flag` Go package and
    will be presented in three parts. The first part has the following Go code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`usingFlag.go`程序演示了`flag`Go包的使用，并将分为三个部分呈现。第一部分包含以下Go代码：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second part, which has the most important Go code of the program, is as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最重要的Go代码在第二部分中，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this part, you can see how you can define the flags that interest you. Here,
    you defined `-o`, `-c`, and `-k`. Although the first two are Boolean flags, the
    `-k` flag requires an integer value, which can be given as `-k=123`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，您可以看到如何定义您感兴趣的标志。在这里，您定义了`-o`、`-c`和`-k`。虽然前两个是布尔标志，但`-k`标志需要一个整数值，可以写成`-k=123`。
- en: 'The last part comes with the following Go code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this part, you can see how you can read the value of an option, which also
    allows you to tell whether an option has been set or not. Additionally, `flag.Args()`
    allows you to access the unused command-line arguments of the program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，您可以看到如何读取选项的值，这也允许您判断选项是否已设置。另外，`flag.Args()`允许您访问程序未使用的命令行参数。
- en: 'The use and the output of `usingFlag.go` are showcased in the following output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`usingFlag.go`的使用和输出在以下输出中展示：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, if you forget to type the value of a command-line option (`-k`) or
    the provided value is of the wrong type, you will get the following messages and
    the program will terminate:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您忘记输入命令行选项（`-k`）的值，或者提供的值类型错误，您将收到以下消息，并且程序将终止：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you do not want your program to exit when there is a parse error, you can
    use the `ErrorHandling` type provided by the `flag` package, which allows you
    to change the way `flag.Parse()` behaves on errors with the help of the `NewFlagSet()`
    function. However, in systems programming, you usually want your utility to exit
    when there is an error in one or more command-line options.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不希望程序在出现解析错误时退出，可以使用`flag`包提供的`ErrorHandling`类型，它允许您通过`NewFlagSet()`函数更改`flag.Parse()`在错误时的行为。但是，在系统编程中，通常希望在一个或多个命令行选项出现错误时退出实用程序。
- en: Dealing with directories
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理目录
- en: Directories allow you to create a structure and store your files in a way that
    is easy for you to organize and search for them. In reality, directories are entries
    on a filesystem that contain lists of other files and directories. This happens
    with the help of **inodes**, which are data structures that hold information about
    files and directories.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目录允许您创建一个结构，并以便于您组织和搜索文件的方式存储文件。实际上，目录是文件系统上包含其他文件和目录列表的条目。这是通过**inode**的帮助发生的，inode是保存有关文件和目录的信息的数据结构。
- en: 'As you can see in the following figure, directories are implemented as lists
    of names assigned to inodes. As a result, a directory contains an entry for itself,
    its parent directory, and each of its children, which among other things can be
    regular files or other directories:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，目录被实现为分配给inode的名称列表。因此，目录包含对自身、其父目录和其每个子目录的条目，其中其他内容可以是常规文件或其他目录：
- en: What you should remember is that an inode holds metadata about a file, not the
    actual data of a file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住的是，inode保存有关文件的元数据，而不是文件的实际数据。
- en: '![](img/e74853d3-8d25-49c3-a968-dc7713c53a72.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e74853d3-8d25-49c3-a968-dc7713c53a72.png)'
- en: A graphical representation of inodes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: inode的图形表示
- en: About symbolic links
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于符号链接
- en: '**Symbolic links** are pointers to files or directories, which are resolved
    at the time of access. Symbolic links, which are also called **soft links**, are
    not equal to the file or the directory they are pointing to and are allowed to
    point to nowhere, which can sometimes complicate things.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号链接**是指向文件或目录的指针，在访问时解析。符号链接，也称为**软链接**，不等同于它们所指向的文件或目录，并且允许指向无处，这有时可能会使事情复杂化。'
- en: 'The following Go code, saved in `symbLink.go` and presented in two parts, allows
    you to check whether a path or file is a symbolic link or not. The first part
    is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保存在`symbLink.go`中并分为两部分的以下Go代码允许您检查路径或文件是否是符号链接。第一部分如下：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nothing special is happening here: you just need to make sure that you get
    one command-line argument in order to have something to test. The second part
    is the following Go code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有发生什么特别的事情：您只需要确保获得一个命令行参数，以便有东西可以测试。第二部分是以下Go代码：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The aforementioned code of `symbLink.go` is more cryptic than usual because
    it uses lower-level functions. The technique for finding out whether a path is
    a real path or not involves the use of the `os.Lstat()` function that gives you
    information about a file or directory and the use of the `Mode()` function on
    the return value of the `os.Lstat()` call in order to compare the outcome with
    the `os.ModeSymlink` constant, which is the symbolic link bit.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymbLink.go`的前述代码比通常更加神秘，因为它使用了更低级的函数。确定路径是否为真实路径的技术涉及使用`os.Lstat()`函数，该函数提供有关文件或目录的信息，并在`os.Lstat()`调用的返回值上使用`Mode()`函数，以将结果与`os.ModeSymlink`常量进行比较，该常量是符号链接位。'
- en: Additionally, there exists the `filepath.EvalSymlinks()` function that allows
    you to evaluate any symbolic links that exist and return the true path of a file
    or directory, which is also used in `symbLink.go`. This might make you think that
    we are using lots of Go code for such a simple task, which is partially true,
    but when you are developing systems software, you are obliged to consider all
    possibilities and be cautious.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还存在`filepath.EvalSymlinks()`函数，允许您评估任何存在的符号链接并返回文件或目录的真实路径，这也在`symbLink.go`中使用。这可能会让您认为我们在为这样一个简单的任务使用大量的Go代码，这在一定程度上是正确的，但是当您开发系统软件时，您必须考虑所有可能性并保持谨慎。
- en: 'Executing `symbLink.go`, which only takes one command-line argument, generates
    the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`symbLink.go`，它只需要一个命令行参数，会生成以下输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will also see some of the aforementioned Go code as a part of bigger programs
    in the rest of this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，您还将看到一些前面提到的Go代码作为更大程序的一部分。
- en: Implementing the pwd(1) command
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现pwd(1)命令
- en: When I start thinking about how to implement a program, so many ideas come to
    my mind that sometimes it becomes too difficult to decide what to do! The key
    here is to do something instead of waiting because as you write code, you will
    be able to tell whether the approach you are taking is good or not, and whether
    you should try another approach or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始考虑如何实现一个程序时，我的脑海中涌现了很多想法，有时决定要做什么变得太困难了！关键在于做一些事情，而不是等待，因为当您编写代码时，您将能够判断您所采取的方法是好还是不好，以及您是否应该尝试另一种方法。
- en: The `pwd(1)` command-line utility is pretty simplistic, yet it does a pretty
    good job. If you write lots of shell scripts, you should already know about `pwd(1)`
    because it is pretty handy when you want to get the full path of a file or a directory
    that resides in the same directory as the script that is being executed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd(1)`命令行实用程序非常简单，但工作得很好。如果您编写大量shell脚本，您应该已经知道`pwd(1)`，因为当您想要获取与正在执行的脚本位于同一目录中的文件或目录的完整路径时，它非常方便。'
- en: 'The Go code of `pwd.go` will be presented in two parts and will only support
    the `-P` command-line option, which resolves all symbolic links and prints the
    physical current working directory. The first part of `pwd.go` is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd.go`的Go代码将分为两部分，并且只支持`-P`命令行选项，该选项解析所有符号链接并打印物理当前工作目录。`pwd.go`的第一部分如下：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second part is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that if the current directory can be described by multiple paths, which
    can happen if you are using symbolic links, `os.Getwd()` can return any one of
    them. Additionally, you need to reuse some of the Go code found in `symbLink.go`
    to discover the physical current working directory in case the `-P` option is
    given and you are dealing with a directory that is a symbolic link. Also, the
    reason for not using the flag package in `pwd.go` is that I find the code much
    simpler the way it is.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果当前目录可以由多个路径描述，这可能发生在使用符号链接时，`os.Getwd()`可以返回其中任何一个。此外，如果给出了`-P`选项并且正在处理一个目录是符号链接，您需要重用`symbolLink.go`中找到的一些Go代码来发现物理当前工作目录。此外，不在`pwd.go`中使用`flag`包的原因是我发现代码现在的方式更简单。
- en: 'Executing `pwd.go` will generate the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`pwd.go`将生成以下输出：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On macOS machines, the `/tmp` directory is a symbolic link, which can help
    us verify that `pwd.go` works as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS机器上，`/tmp`目录是一个符号链接，这可以帮助我们验证`pwd.go`是否按预期工作：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Developing the which(1) utility in Go
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go开发`which(1)`实用程序
- en: 'The `which(1)` utility searches the value of the `PATH` environment variable
    in order to find out if an executable file can be found in one of the directories
    of the `PATH` variable. The following output shows the way the `which(1)` utility
    works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`which(1)`实用程序搜索`PATH`环境变量的值，以找出可执行文件是否存在于`PATH`变量的一个目录中。以下输出显示了`which(1)`实用程序的工作方式：'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our implementation of the Unix utility will support the two command-line options
    supported by the macOS version of `which(1)`, which are `-a` and `-s` with the
    help of the `flag` package: the Linux version of `which(1)` does not support the
    `-s` option. The `-a` option lists all the instances of the executable instead
    of just the first one while the `-s` returns `0` if the executable was found and
    `1` otherwise: this is not the same as printing `0` or `1` using the `fmt` package.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Unix实用程序的实现将支持macOS版本的`which(1)`支持的两个命令行选项`-a`和`-s`，并借助`flag`包：Linux版本的`which(1)`不支持`-s`选项。`-a`选项列出可执行文件的所有实例，而不仅仅是第一个，而`-s`返回`0`如果找到了可执行文件，否则返回`1`：这与使用`fmt`包打印`0`或`1`不同。
- en: 'In order to check the return value of a Unix command-line utility in the shell,
    you should do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查Unix命令行实用程序在shell中的返回值，您应该执行以下操作：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that `go run` prints out nonzero exit codes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`go run`会打印出非零的退出代码。
- en: 'The Go code for `which(1)` will be saved in `which.go` and will be presented
    in four parts. The first part of `which.go` has the following Go code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`which(1)`的Go代码将保存在`which.go`中，并将分为四个部分呈现。`which.go`的第一部分包含以下Go代码：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `strings` package is needed in order to split the contents of the `PATH`
    variable after you read it. The second part of `which.go` deals with the use of
    the `flag` package:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`strings`包来分割读取`PATH`变量的内容。`which.go`的第二部分处理了`flag`包的使用：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One very important part of `which.go` is the part that reads the `PATH` shell
    environment variable in order to split it and use it, which is presented in the
    third part here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`which.go`的一个非常重要的部分是读取`PATH` shell环境变量以分割并使用它的部分，这在这里的第三部分中呈现：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last statement here constructs the full path of the file we are searching
    for, as if it existed in each separate directory of the `PATH` variable because
    if you have the full path of a file, you do not have to search for it!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一条语句构造了我们正在搜索的文件的完整路径，就好像它存在于`PATH`变量的每个单独目录中，因为如果你有文件的完整路径，你就不必再去搜索它了！
- en: 'The last part of `which.go` is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`which.go`的最后一部分如下：'
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, the call to `os.Stat()` tells whether the file we are looking for actually
    exists or not. In case of success, the `mode.IsRegular()` function checks whether
    the file is a regular file or not because we are not looking for directories or
    symbolic links. However, we are not done yet! The `which.go` program performs
    a test to find out whether the file that was found is indeed an executable file:
    if it is not an executable file, it will not get printed. So, the `if mode&0111
    != 0` statement verifies that the file is actually an executable file using a
    binary operation.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对`os.Stat()`的调用告诉我们正在寻找的文件是否实际存在。在成功的情况下，`mode.IsRegular()`函数检查文件是否是常规文件，因为我们不寻找目录或符号链接。但是，我们还没有完成！`which.go`程序执行了一个测试，以找出找到的文件是否确实是可执行文件：如果不是可执行文件，它将不会被打印。因此，`if
    mode&0111 != 0`语句使用二进制操作验证文件实际上是可执行文件。
- en: Next, if the `-s` flag is set to `*minusS == true`, then the `-a` flag does
    not really matter because the program will terminate as soon as it finds a match.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果`-s`标志设置为`*minusS == true`，那么`-a`标志就不太重要了，因为一旦找到匹配项，程序就会终止。
- en: 'As you can see, there are lots of tests involved in `which.go`, which is not
    rare for systems software. Nevertheless, you should always examine all possibilities
    in order to avoid surprises later. The good thing is that most of these tests
    will be used later on in the Go implementation of the `find(1)` utility: it is
    good practice to test some features by writing small programs before putting them
    all together into bigger programs because by doing so, you learn the technique
    better and you can detect silly bugs more easily.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在`which.go`中涉及许多测试，这对于系统软件来说并不罕见。尽管如此，您应该始终检查所有可能性，以避免以后出现意外。好消息是，这些测试中的大多数将在`find(1)`实用程序的Go实现中稍后使用：通过编写小程序来测试一些功能，然后将它们全部组合成更大的程序，这是一个很好的实践，因为这样做可以更好地学习技术，并且可以更容易地检测愚蠢的错误。
- en: 'Executing `which.go` will produce the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`which.go`将产生以下输出：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Printing the permission bits of a file or directory
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印文件或目录的权限位
- en: 'With the help of the `ls(1)` command, you can find out the permissions of a
    file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 借助`ls(1)`命令，您可以找出文件的权限：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this subsection, we will look at how to print the permissions of a file
    or directory using Go: the Go code will be saved in `permissions.go` and will
    be presented in two parts. The first part is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将展示如何使用Go打印文件或目录的权限：Go代码将保存在`permissions.go`中，并将分为两部分呈现。第一部分如下：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second part contains the important Go code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含重要的Go代码：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once again, most of the Go code is for dealing with the command-line argument
    and making sure that you have one! The Go code that does the actual job is mainly
    the call to the `os.Stat()` function, which returns a `FileInfo` structure that
    describes the file or directory examined by `os.Stat()`. From the `FileInfo` structure,
    you can discover the permissions of a file by calling the `Mode()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，大部分的Go代码用于处理命令行参数并确保您有一个！实际工作的Go代码主要是调用`os.Stat()`函数，该函数返回一个描述`os.Stat()`检查的文件或目录的`FileInfo`结构。通过`FileInfo`结构，您可以调用`Mode()`函数来发现文件的权限。
- en: 'Executing `permissions.go` produces the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`permissions.go`会产生以下输出：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Dealing with files in Go
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中处理文件
- en: An extremely important task of an operating system is working with files because
    all data is stored in files. In this section, we will show you how to delete and
    rename files, and in the next section, *Developing find(1) in Go*, we will teach
    you how to search directory structures in order to find the files you want.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的一个极其重要的任务是处理文件，因为所有数据都存储在文件中。在本节中，我们将向您展示如何删除和重命名文件，在下一节*在Go中开发find(1)*中，我们将教您如何搜索目录结构以找到所需的文件。
- en: Deleting a file
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: In this section, we will illustrate how to delete files and directories using
    the `os.Remove()` Go function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将说明如何使用`os.Remove()` Go函数删除文件和目录。
- en: When testing programs that delete files and directories be extra careful and
    use common sense!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试删除文件和目录的程序时，请格外小心并且要有常识！
- en: 'The `rm.go` file is a Go implementation of the `rm(1)` tool that illustrates
    how you can delete files in Go. Although the core functionality of `rm(1)` is
    there, the options of `rm(1)` are missing: it would be a good exercise to try
    to implement some of them. Just pay extra attention when implementing the `-f`
    and `-R` options.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm.go`文件是`rm(1)`工具的Go实现，说明了您如何在Go中删除文件。尽管`rm(1)`的核心功能已经存在，但缺少`rm(1)`的选项：尝试实现其中一些选项将是一个很好的练习。在实现`-f`和`-R`选项时要特别注意。'
- en: 'The Go code of `rm.go` is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm.go`的Go代码如下：'
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If `rm.go` is executed without any problems, it will create no output according
    to the Unix philosophy. So, what is interesting here is watching the error messages
    you can get when the file you are trying to delete does not exist: both when you
    do not have the necessary permissions to delete it and when a directory is not
    empty:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rm.go`在没有任何问题的情况下执行，将不会产生任何输出，这符合Unix哲学。因此，有趣的是观察当您尝试删除的文件不存在时可以获得的错误消息：当您没有必要的权限删除它时以及当目录不为空时：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Renaming and moving files
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名和移动文件
- en: 'In this subsection, we will show you how to rename and move a file using Go
    code: the Go code will be saved as `rename.go`. Although the same code can be
    used for renaming or moving directories, `rename.go` is only allowed to work with
    files.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将向您展示如何使用Go代码重命名和移动文件：Go代码将保存为`rename.go`。尽管相同的代码可以用于重命名或移动目录，但`rename.go`只允许处理文件。
- en: When performing things that cannot be easily undone, such as overwriting a file,
    you should be extra careful and maybe inform the user that the destination file
    already exists in order to avoid unpleasant surprises. Although the default operation
    of the traditional `mv(1)` utility will automatically overwrite the destination
    file if it exists, I do not think that this is very safe. Therefore, `rename.go`
    will not overwrite destination files by default.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行一些无法轻易撤消的操作时，例如覆盖文件时，您应该格外小心，也许通知用户目标文件已经存在，以避免不愉快的意外。尽管传统的`mv(1)`实用程序的默认操作会自动覆盖目标文件（如果存在），但我认为这并不是很安全。因此，默认情况下，`rename.go`不会覆盖目标文件。
- en: When developing systems software, you have to deal with all the details or the
    details will reveal themselves as bugs when least expected! Extensive testing
    will allow you to find the details you missed and correct them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发系统软件时，您必须处理所有细节，否则这些细节将在最不经意的时候显露为错误！广泛的测试将使您能够找到您错过的细节并加以纠正。
- en: 'The code of `rename.go` will be presented in four parts. The first part includes
    the expected preamble as well as the Go code for dealing with the setup of the
    `flag` package:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename.go`的代码将分为四部分呈现。第一部分包括预期的序言以及处理`flag`包设置的Go代码：'
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second part has the following Go code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This part makes sure the source file exists, is a regular file, and is not a
    directory or something else like a network socket or a pipe. Once again, the trick
    with `os.Stat()` you saw in `which.go` is used here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分确保源文件存在，是一个普通文件，并且不是一个目录或者其他类似网络套接字或管道的东西。再次，你在`which.go`中看到的`os.Stat()`的技巧在这里被使用了。
- en: 'The third part of `rename.go` is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename.go`的第三部分如下：'
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is another tricky point here; you will need to consider the case where
    the source is a plain file and the destination is a directory, which is implemented
    with the help of the `newDestination` variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个棘手的地方；你需要考虑源文件是普通文件而目标是目录的情况，这是通过`newDestination`变量的帮助实现的。
- en: Another special case that you should consider is when the source file is given
    in a format that contains an absolute or relative path in it like `./aDir/aFile`.
    In this case, when the destination is a directory, you should get the basename
    of the path, which is what follows the last `/` character and in this case is
    `aFile`, and add it to the destination directory in order to correctly construct
    the `newDestination` variable. This happens with the help of the `filepath.Base()`
    function, which returns the last element of a path.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该考虑的特殊情况是，当源文件以包含绝对或相对路径的格式给出时，比如`./aDir/aFile`。在这种情况下，当目标是一个目录时，你应该获取路径的基本名称，即跟在最后一个`/`字符后面的内容，在这种情况下是`aFile`，并将其添加到目标目录中，以正确构造`newDestination`变量。这是通过`filepath.Base()`函数的帮助实现的，它返回路径的最后一个元素。
- en: 'Finally, the last part of `rename.go` has the following Go code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`rename.go`的最后部分包含以下Go代码：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The most important Go code of `rename.go` has to do with recognizing whether
    the destination file exists or not. Once again, this is implemented with the support
    of the `os.Stat()` function. If `os.Stat()` returns an error message, this means
    that the destination file does not exist; so, you are free to call `os.Rename()`.
    If `os.Stat()` returns `nil`, this means that the `os.Stat()` call was successful
    and that the destination file exists. In this case, you should check the value
    of the `overwrite` flag to see if you are allowed to overwrite the destination
    file or not.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename.go`最重要的Go代码与识别目标文件是否存在有关。再次，这是通过`os.Stat()`函数的支持实现的。如果`os.Stat()`返回一个错误消息，这意味着目标文件不存在；因此，你可以调用`os.Rename()`。如果`os.Stat()`返回`nil`，这意味着`os.Stat()`调用成功，并且目标文件存在。在这种情况下，你应该检查`overwrite`标志的值，以查看是否允许覆盖目标文件。'
- en: When everything is OK, you are free to call `os.Rename()` and perform the desired
    task!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常时，你可以自由地调用`os.Rename()`并执行所需的任务！
- en: 'If `rename.go` is executed correctly, it will create no output. However, if
    there are problems, `rename.go` will generate some output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rename.go`被正确执行，它将不会产生任何输出。然而，如果有问题，`rename.go`将生成一些输出：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Developing find(1) in Go
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中开发find(1)
- en: This section will teach you the necessary things that you need to know in order
    to develop a simplified version of the `find(1)` command-line utility in Go. The
    developed version will not support all the command-line options supported by `find(1)`,
    but it will have enough options to be truly useful.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将教你开发一个简化版本的`find(1)`命令行实用程序所需的必要知识。开发的版本将不支持`find(1)`支持的所有命令行选项，但它将有足够的选项来真正有用。
- en: What you will see in the following subsections is the entire process in small
    steps. So, the first subsection will show you the Go way for visiting all files
    and directories in a given directory tree.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，你将看到整个过程分为小步骤。因此，第一个子章节将向你展示访问给定目录树中的所有文件和目录的Go方式。
- en: Traversing a directory tree
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历目录树
- en: 'The most important task that `find(1)` needs to support is being able to visit
    all files and sub directories starting from a given directory. So, this section
    will implement this task in Go. The Go code of `traverse.go` will be presented
    in three parts. The first part is the expected preamble:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`find(1)`最重要的任务是能够访问从给定目录开始的所有文件和子目录。因此，这一部分将在Go中实现这个任务。`traverse.go`的Go代码将分为三部分呈现。第一部分是预期的序言：'
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second part is about implementing a function named `walkFunction()` that
    will be used as an argument to a Go function named `filepath.Walk()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是关于实现一个名为`walkFunction()`的函数，该函数将用作Go函数`filepath.Walk()`的参数：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, the `os.Stat()` function is used because a successful `os.Stat()`
    function call means that we are dealing with something (file, directory, pipe,
    and so on) that actually exists!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`os.Stat()`函数被使用是因为成功的`os.Stat()`函数调用意味着我们正在处理实际存在的东西（文件、目录、管道等）！
- en: Do not forget that between the time `filepath.Walk()` is called and the time
    `walkFunction()` is called and executed, many things can happen in an active and
    busy filesystem, which is the main reason for calling `os.Stat()`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，在调用`filepath.Walk()`和调用执行`walkFunction()`之间，活跃和繁忙的文件系统中可能会发生许多事情，这是调用`os.Stat()`的主要原因。
- en: 'The last part of the code is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分如下：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All the dirty jobs here are automatically done by the `filepath.Walk()` function
    with the help of the `walkFunction()` function that was defined previously. The
    `filepath.Walk()` function takes two parameters: the path of a directory and the
    walk function it will use.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些繁琐的工作都是由`filepath.Walk()`函数自动完成的，借助于之前定义的`walkFunction()`函数。`filepath.Walk()`函数接受两个参数：一个目录的路径和它将使用的遍历函数。
- en: 'Executing `traverse.go` will generate the following kind of output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`traverse.go`将生成以下类型的输出：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the code of `traverse.go` is pretty naive, as among other things,
    it cannot differentiate between directories, files, and symbolic links. However,
    it does the pretty tedious job of visiting every file and directory under a given
    directory tree, which is the basic functionality of the `find(1)` utility.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`traverse.go`的代码相当天真，因为它除其他事情外，无法区分目录、文件和符号链接。然而，它完成了访问给定目录树下的每个文件和目录的繁琐工作，这是`find(1)`实用程序的基本功能。
- en: Visiting directories only!
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅访问目录！
- en: 'Although it is good to be able to visit everything, there are times when you
    want to visit only directories and not files. So, in this subsection, we will
    modify `traverse.go` in order to still visit everything but only print the directory
    names. The name of the new program will be `traverseDir.go`. The only part of
    `traverse.go` that needs to change is the definition of the `walkFunction()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够访问所有内容是很好的，但有时您只想访问目录而不是文件。因此，在本小节中，我们将修改`traverse.go`以仍然访问所有内容，但只打印目录名称。新程序的名称将是`traverseDir.go`。需要更改的是`traverse.go`的唯一部分是`walkFunction()`的定义：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, here you need to use the information returned by the `os.Stat()`
    function call in order to check whether you are dealing with a directory or not.
    If you have a directory, then you print its path and you are done.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您需要使用`os.Stat()`函数调用返回的信息来检查您是否正在处理目录。如果您有一个目录，那么打印其路径，您就完成了。
- en: 'Executing `traverseDir.go` will generate the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`traverseDir.go`将生成以下输出：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first version of find(1)
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: find(1)的第一个版本
- en: The Go code in this section is saved as `find.go` and will be presented in three
    parts. As you will see, `find.go` uses a large amount of the code found in `traverse.go`,
    which is the main benefit you get when you are developing a program step by step.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的Go代码保存为`find.go`，将分为三部分呈现。正如您将看到的，`find.go`使用了在`traverse.go`中找到的大量代码，这是您逐步开发程序时获得的主要好处。
- en: 'The first part of `find.go` is the expected preamble:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`find.go`的第一部分是预期的序言：'
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we already know that we will improve `find.go` in the near future, the `flag`
    package is used here even if this is the first version of `find.go` and it does
    not have any flags!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道将来会改进`find.go`，因此即使这是`find.go`的第一个版本并且没有任何标志，这里也使用了`flag`包！
- en: 'The second part of the Go code contains the implementation of the `walkFunction()`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Go代码的第二部分包含了`walkFunction()`的实现：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From the implementation of the `walkFunction()` you can easily understand that
    `find.go` only prints regular files and directories, and nothing else. Is this
    a problem? Not, if this is what you want. Generally speaking, this is not good.
    Nevertheless, having a first version of something that works despite some restrictions
    is a good starting point! The next version, which will be named `improvedFind.go`,
    will improve `find.go` by adding various command-line options to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从`walkFunction()`的实现中，您可以轻松理解`find.go`只打印常规文件和目录，没有其他内容。这是一个问题吗？不是，如果这是您想要的。一般来说，这不是好的。尽管如此，尽管存在一些限制，但拥有一个能够工作的东西的第一个版本是一个很好的起点！下一个版本将被命名为`improvedFind.go`，将通过向其添加各种命令行选项来改进`find.go`。
- en: 'The last part of `find.go` contains the code that implements the `main()` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`find.go`的最后一部分包含实现`main()`函数的代码：'
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Executing `find.go` will create the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`find.go`将创建以下输出：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Adding some command-line options
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些命令行选项
- en: This subsection will try to improve the Go version of `find(1)` that you created
    earlier. Keep in mind that this is the process used for developing real programs
    because you do not implement every possible command-line option in the first version
    of a program.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将尝试改进您之前创建的`find(1)`的Go版本。请记住，这是开发真实程序使用的过程，因为您不会在程序的第一个版本中实现每个可能的命令行选项。
- en: 'The Go code of the new version is going to be saved as `improvedFind.go`. Among
    other things, the new version will be able to ignore symbolic links: symbolic
    links will only be printed when `improvedFind.go` is used with the appropriate
    command-line option. To do this, we will use some of the Go code of `symbLink.go`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的Go代码将保存为`improvedFind.go`。新版本将能够忽略符号链接：只有在使用适当的命令行选项运行`improvedFind.go`时，才会打印符号链接。为此，我们将使用`symbolLink.go`的一些Go代码。
- en: The `improvedFind.go` program is a real system tool that you can use on your
    own Unix machines.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`improvedFind.go`程序是一个真正的系统工具，您可以在自己的Unix机器上使用。'
- en: 'The supported flags will be the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的标志将是以下内容：
- en: '**-s**: This is for printing socket files'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -s：这是用于打印套接字文件的
- en: '**-p**: This is for printing pipes'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -p：这是用于打印管道的
- en: '**-sl**: This is for printing symbolic links'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -sl：这是用于打印符号链接的
- en: '**-d**: This is for printing directories'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -d：这是用于打印目录的
- en: '**-f**: This is for printing files'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -f：这是用于打印文件的
- en: As you will see, most of the new Go code is for supporting the flags added to
    the program. Additionally, by default, `improvedFind.go` prints every type of
    file or directory, and you are allowed to combine any of the preceding flags in
    order to print the types of files you want.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，大部分新的Go代码是为了支持添加到程序中的标志。此外，默认情况下，`improvedFind.go`打印每种类型的文件或目录，并且您可以组合任何前述标志以打印您想要的文件类型。
- en: Apart from the various changes in the implementation of the `main()` function
    in order to support all these flags, most of the remaining changes will take place
    in the code of the `walkFunction()` function. Additionally, the `walkFunction()`
    function will be defined inside the `main()` function, which happens in order
    to avoid the use of global variables.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在实现`main()`函数中进行各种更改以支持所有这些标志之外，大部分其余更改将发生在`walkFunction()`函数的代码中。此外，`walkFunction()`函数将在`main()`函数内部定义，这是为了避免使用全局变量。
- en: 'The first part of `improvedFind.go` is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`improvedFind.go`的第一部分如下：'
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, if all the flags are unset, the program will print everything, which is
    handled by the first `if` statement. Similarly, if all the flags are set, the
    program will also print everything. So, a new Boolean variable named `printAll`
    is needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果所有标志都未设置，程序将打印所有内容，这由第一个`if`语句处理。同样，如果所有标志都设置了，程序也将打印所有内容。因此，需要一个名为`printAll`的新布尔变量。
- en: 'The second part of `improvedFind.go` has the following Go code, which is mainly
    the definition of the `walkFunction` variable, which in reality is a function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`improvedFind.go`的第二部分包含以下Go代码，主要是`walkFunction`变量的定义，实际上是一个函数：'
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, the good thing is that once you find a match and print a file, you do
    not have to visit the rest of the `if` statements, which is the main reason for
    putting the `minusF` check first and the `minusD` check second. The call to `os.Lstat()`
    is used to find out whether we are dealing with a symbolic link or not. This happens
    because `os.Stat()` follows symbolic links and returns information about the file
    the link references, whereas `os.Lstat()` does not do so: the same occurs with
    `stat(2)` and `lstat(2)`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，好处是一旦找到匹配并打印文件，你就不必访问`if`语句的其余部分，这是将`minusF`检查放在第一位，`minusD`检查放在第二位的主要原因。调用`os.Lstat()`用于找出我们是否正在处理符号链接。这是因为`os.Stat()`会跟随符号链接并返回有关链接引用的文件的信息，而`os.Lstat()`不会这样做：`stat(2)`和`lstat(2)`也是如此。
- en: 'You should be pretty familiar with the last part of `improvedFind.go`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对`improvedFind.go`的最后部分非常熟悉：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Executing `improvedFind.go` generates the following output, which is an enriched
    version of the output of `find.go`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`improvedFind.go`生成以下输出，这是`find.go`输出的增强版本：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Excluding filenames from the find output
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从查找输出中排除文件名
- en: There are times when you do not need to display everything from the output of
    `find(1)`. So, in this subsection, you will learn a technique that allows you
    to manually exclude files from the output of `improvedFind.go` based on their
    filenames.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你不需要显示`find(1)`的输出中的所有内容。因此，在这一小节中，你将学习一种技术，允许你根据文件名手动排除`improvedFind.go`的输出中的文件。
- en: Note that this version of the program will not support regular expressions and
    will only exclude filenames that are an exact match.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该程序的这个版本不支持正则表达式，只会排除文件名的精确匹配。
- en: 'So, the improved version of `improvedFind.go` will be named `excludeFind.go`.
    The output of the `diff(1)` utility can reveal the code differences between `improvedFind.go`
    and `excludeFind.go`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`improvedFind.go`的改进版本将被命名为`excludeFind.go`。`diff(1)`实用程序的输出可以揭示`improvedFind.go`和`excludeFind.go`之间的代码差异：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The most significant change is the introduction of a new Go function, named
    `excludeNames()`, that deals with filename exclusion and the addition of the `-x`
    flag, which is used for setting the filename you want to exclude from the output.
    All the job is done by the file path. The `Base()` function finds the last part
    of a path, even if the path is not a file but a directory, and compares it against
    the value of the `-x` flag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的变化是引入了一个名为`excludeNames()`的新的Go函数，处理文件名的排除以及`-x`标志的添加，用于设置要从输出中排除的文件名。所有的工作都由文件路径完成。`Base()`函数找到路径的最后一部分，即使路径不是文件而是目录，也会将其与`-x`标志的值进行比较。
- en: Note that a more appropriate name for the `excludeNames()` function could have
    been `isExcluded()` or something similar because the `-x` option accepts a single
    value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`excludeNames()`函数的更合适的名称可能是`isExcluded()`或类似的，因为`-x`选项接受单个值。
- en: 'Executing `excludeFind.go` with and without the `-x` flag will prove that the
    new Go code actually works:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`excludeFind.go`执行并不带`-x`标志的命令将证明新的Go代码实际上是有效的。
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Excluding a file extension from the find output
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从查找输出中排除文件扩展名
- en: A file extension is the part of a filename after the last dot (`.`) character.
    So, the file extension of the `image.png` file is png, which applies to both files
    and directories.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名是最后一个点（`.`）字符之后的文件名的一部分。因此，`image.png`文件的文件扩展名是png，这适用于文件和目录。
- en: 'Once again, you will need a separate command-line option followed by the file
    extension you want to exclude in order to implement this functionality: the new
    flag will be named `-ext`. This version of the `find(1)` utility will be based
    on the code of `excludeFind.go` and will be named `finalFind.go`. Some of you
    might say that a more appropriate name for this option would have been `-xext`
    and you would be right about that!'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了实现这个功能，你需要一个单独的命令行选项，后面跟着你想要排除的文件扩展名：新的标志将被命名为`-ext`。这个`find(1)`实用程序的版本将基于`excludeFind.go`的代码，并将被命名为`finalFind.go`。你们中的一些人可能会说，这个选项更合适的名称应该是`-xext`，你们是对的！
- en: 'Once again, the `diff(1)` utility will help us spot the code differences between
    `excludeFind.go` and `finalFind.go`: the new functionality is implemented in a
    Go function named `excludeExtensions()`, which makes things easier to understand:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`diff(1)`实用程序将帮助我们发现`excludeFind.go`和`finalFind.go`之间的代码差异：新功能是在名为`excludeExtensions()`的Go函数中实现的，这使得理解更加容易。
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we are looking for the string after the last dot in the path, we use `strings.Split()`
    to split the path based on the dot characters it contains. Then, we take the last
    part of the return value of `strings.Split()` and we compare it against the extension
    that was given with the `-ext` flag. Therefore, nothing special here, just some
    string manipulation code. Once again, a more appropriate name for `excludeExtensions()`
    would have been `isExcludedExtension()`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在寻找路径中最后一个点后的字符串，我们使用`strings.Split()`根据路径中包含的点字符来分割路径。然后，我们取`strings.Split()`的返回值的最后一部分，并将其与使用`-ext`标志给定的扩展名进行比较。因此，这里没有什么特别的，只是一些字符串操作代码。再次强调，`excludeExtensions()`更合适的名称应该是`isExcludedExtension()`。
- en: 'Executing `finalFind.go` will generate the following output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`finalFind.go`将生成以下输出：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using regular expressions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: 'This section will illustrate how to add support for regular expressions in
    `finalFind.go`: the name of the last version of the tool will be `regExpFind.go`.
    The new flag will be called `-re` and it will require a string value: anything
    that matches this string value will be included in the output unless it is excluded
    by another command-line option. Additionally, due to the flexibility that flags
    offer, we do not need to delete any of the previous options in order to add another
    one!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将说明如何在`finalFind.go`中添加对正则表达式的支持：工具的最新版本的名称将是`regExpFind.go`。新的标志将被称为`-re`，它将需要一个字符串值：与此字符串值匹配的任何内容都将包含在输出中，除非它被另一个命令行选项排除。此外，由于标志提供的灵活性，我们不需要删除任何以前的选项来添加另一个选项！
- en: 'Once again, the `diff(1)` command will tell us the code differences between
    `regExpFind.go` and `finalFind.go`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`diff(1)`命令将告诉我们`regExpFind.go`和`finalFind.go`之间的代码差异：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*,* *Working with
    System Files*, we ;will talk more about pattern matching and regular expressions
    in Go: for now, it is enough to understand that `regexp.Compile()` creates a regular
    expression and `MatchString()` tries to do the matching in the `regularExpression()`
    function.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*,* *处理系统文件*中，我们将更多地讨论Go中的模式匹配和正则表达式：现在，理解`regexp.Compile()`创建正则表达式，`MatchString()`尝试在`regularExpression()`函数中进行匹配就足够了。
- en: 'Executing `regExpFind.go` will generate the following output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`regExpFind.go`将生成以下输出：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The previous output can be verified by using the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令验证先前的输出：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Creating a copy of a directory structure
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录结构的副本
- en: 'Armed with the knowledge you gained in the previous sections, we will now develop
    a Go program that creates a copy of a directory structure in another directory:
    this means that any files in the input directory will not be copied to the destination
    directory, only the directories will be copied. This can be handy when you want
    to save useful files from a directory structure somewhere else while keeping the
    same directory structure or when you want to take a backup of a filesystem manually.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借您在前几节中获得的知识，我们现在将开发一个Go程序，该程序在另一个目录中创建目录结构的副本：这意味着输入目录中的任何文件都不会复制到目标目录，只会复制目录。当您想要将有用的文件从一个目录结构保存到其他位置并保持相同的目录结构时，或者当您想要手动备份文件系统时，这可能会很方便。
- en: 'As you are only interested in directories, the code of `cpStructure.go` is
    based on the code of `traverseDir.go` you saw earlier in this chapter: once again,
    a small program that was developed for learning purposes helps you implement a
    bigger program! Additionally, the `test` option will show what the program will
    do without actually creating any directories.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您只对目录感兴趣，因此`cpStructure.go`的代码基于本章前面看到的`traverseDir.go`的代码：再次，为了学习目的而开发的小程序帮助您实现更大的程序！此外，`test`选项将显示程序的操作，而不会实际创建任何目录。
- en: 'The code of `cpStructure.go` will be presented in four parts. The first one
    is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpStructure.go`的代码将分为四部分呈现。第一部分如下：'
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There is nothing special here, just the expected preamble. The second part
    is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的，只是预期的序言。第二部分如下：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `cpStructure.go` program demands that the destination directory does not
    exist in advance in order to avoid unnecessary surprises and errors afterwards.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpStructure.go`程序要求预先不存在目标目录，以避免后续不必要的意外和错误。'
- en: 'The third part contains the code of the `walkFunction` variable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含`walkFunction`变量的代码：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, the first `if` statement makes sure that we will deal with symbolic links
    because symbolic links can be dangerous and create problems: always try to treat
    special situations in order to avoid problems and nasty bugs.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个`if`语句确保我们将处理符号链接，因为符号链接可能很危险并且会造成问题：始终尝试处理特殊情况以避免问题和令人讨厌的错误。
- en: The `os.IsNotExist()` function allows you to make sure that the directory you
    are trying to create is not already there. So, if the directory is not there,
    you create it using ;`os.MkdirAll()`. The `os.MkdirAll()` function creates a directory
    path including all the necessary parents, which makes things simpler for the developer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.IsNotExist()`函数允许您确保您要创建的目录尚不存在。因此，如果目录不存在，您可以使用`os.MkdirAll()`创建它。`os.MkdirAll()`函数创建包括所有必要父目录的目录路径，这对开发人员来说更简单。'
- en: Nevertheless, the trickiest part that the code of the `walkFunction` variable
    has to deal with is removing the unnecessary parts of the source path and constructing
    the new path correctly. The `strings.Replace()` function used in the program replaces
    the occurrences of its second argument (`Path`) that can be found in the first
    argument (`currentPath`) with its third argument (`""`) as many times as its last
    argument (`1`). If the last argument is a negative number, which is not the case
    here, then there will be no limit to the number of replacements. In this case,
    it removes the value of the `Path` variable, which is the source directory, from
    the `currentPath` variable, which is the directory that is being examined.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`walkFunction`变量的代码必须处理的最棘手的部分是删除源路径的不必要部分并正确构造新路径。程序中使用的`strings.Replace()`函数用其第二个参数(`Path`)替换其第一个参数(`currentPath`)中可以找到的出现，用其第三个参数(`""`)替换其最后一个参数(`1`)的次数。如果最后一个参数是负数，这里不是这种情况，那么将没有限制地进行替换。在这种情况下，它会从`currentPath`变量（正在检查的目录）中删除`Path`变量的值，这是源目录。
- en: 'The last part of the program is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分如下：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Executing `cpStructure.go` will generate the following output:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`cpStructure.go`将生成以下输出：
- en: '[PRE55]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following figure shows a graphical representation of the source and destination
    directory structures used in the aforementioned example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前述示例中使用的源目录和目标目录结构的图形表示：
- en: '![](img/ecf2e299-f496-48f4-9622-d1225bd52ad4.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecf2e299-f496-48f4-9622-d1225bd52ad4.png)'
- en: A graphical representation of two directory structures with their files
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 两个目录结构及其文件的图形表示
- en: Exercises
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Read the documentation page of the `os` package at [https://golang.org/pkg/os/](https://golang.org/pkg/os/).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读[https://golang.org/pkg/os/](https://golang.org/pkg/os/)上的`os`包的文档页面。
- en: Visit [https://golang.org/pkg/path/filepath/](https://golang.org/pkg/path/filepath/)
    to learn more about the `filepath.Walk()` function.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://golang.org/pkg/path/filepath/](https://golang.org/pkg/path/filepath/)了解更多关于`filepath.Walk()`函数的信息。
- en: Change the code of `rm.go` in order to support multiple command-line arguments,
    and then try to implement the `-v` command-line option of the `rm(1)` utility.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`rm.go`的代码以支持多个命令行参数，然后尝试实现`rm(1)`实用程序的`-v`命令行选项。
- en: Make the necessary changes to the Go code of `which.go` in order to support
    multiple command-line arguments.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`which.go`的Go代码进行必要的更改，以支持多个命令行参数。
- en: Start implementing a version of the `ls(1)` utility in Go. Do not try to support
    every `ls(1)` option at once.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始在Go中实现`ls(1)`实用程序的版本。不要一次性尝试支持每个`ls(1)`选项。
- en: Change the code of `traverseDir.go` in order to print regular files only.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`traverseDir.go`的代码，以便只打印常规文件。
- en: Check the manual page of `find(1)` and try to add support for some of its options
    in `regExpFind.go`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`find(1)`的手册页面，并尝试在`regExpFind.go`中添加对其某些选项的支持。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about many things including the use of the `flag`
    standard package, Go functions that allow you to work with directories and files,
    and traverse directory structures, and we developed Go versions of various Unix
    command-line utilities including `pwd(1)`, `which(1)`, `rm(1)`, and `find(1)`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多内容，包括使用`flag`标准包，允许您使用目录和文件以及遍历目录结构的Go函数，并且我们开发了各种Unix命令行实用程序的Go版本，包括`pwd(1)`、`which(1)`、`rm(1)`和`find(1)`。
- en: 'In the next chapter, we will continue talking about file operations, but this
    time you will learn how to read files and write to files in Go: as you will see
    there are many ways to do this. Although this gives you versatility, it also demands
    that you should be able to choose the right technique to do your job as efficiently
    as possible! So, you will start by learning more about the `io` package as well
    as the `bufio` package and by the end of the chapter, you will have Go versions
    of the `wc(1)` and `dd(1)` utilities!'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论文件操作，但这次您将学习如何在Go中读取文件和写入文件：正如您将看到的，有许多方法可以做到这一点。虽然这给了您灵活性，但它也要求您能够选择尽可能高效地完成工作的正确技术！因此，您将首先学习更多关于`io`包以及`bufio`包，到本章结束时，您将拥有`wc(1)`和`dd(1)`实用程序的Go版本！
