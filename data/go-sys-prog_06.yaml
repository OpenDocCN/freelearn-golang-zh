- en: File Input and Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入和输出
- en: 'In the previous chapter, we talked about manipulating files and directories
    as entities without looking at their contents. However, in this chapter, we will
    take a different approach and look into the contents of files: you might consider
    this chapter one of the most important chapters in this book because **file input**
    and **file output** are primary tasks of any operating system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们谈到了将文件和目录作为实体进行操作，而不查看其内容。但是，在本章中，我们将采取不同的方法，查看文件的内容：您可能认为本章是本书中最重要的章节之一，因为**文件输入**和**文件输出**是任何操作系统的主要任务。
- en: 'The main purpose of this chapter is to teach how the Go standard library permits
    us to open files, read their contents, process them if we like, create new files,
    and put the desired data into them. There are two main ways to read and write
    files: using the `io` package and using the functions of the `bufio` package.
    However, both packages work in a comparative way.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是教授Go标准库如何允许我们打开文件，读取其内容，如果需要，对其进行处理，创建新文件，并将所需数据放入其中。读取和写入文件的两种主要方法是：使用`io`包和使用`bufio`包的函数。但是，这两个包的工作方式是相似的。
- en: 'This chapter will tell you about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将告诉您以下内容：
- en: Opening files for writing and reading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件进行写入和读取
- en: Using the `io` package for file input and output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`io`包进行文件输入和输出
- en: Using the `io.Writer` and `io.Reader` interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`io.Writer`和`io.Reader`接口
- en: Using the `bufio` package for buffered input and output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bufio`包进行缓冲输入和输出
- en: Copying files in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中复制文件
- en: Implementing a version of the `wc(1)` utility in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中实现`wc(1)`实用程序的版本
- en: Developing a version of the `dd(1)` command in Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中开发`dd(1)`命令的版本
- en: Creating sparse files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建稀疏文件
- en: 'The importance of byte slices in file input and output: byte slices were first
    mentioned in [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml), *Writing
    Programs in Go*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节切片在文件输入和输出中的重要性：字节切片首次在[第2章](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml)中提到，*使用Go编写程序*
- en: Storing structured data in files and reading them afterwards
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结构化数据存储在文件中，并在以后读取它们
- en: Converting tabs into space characters and vice versa
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将制表符转换为空格字符，反之亦然
- en: 'This chapter will not talk about appending data to an existing file: you will
    have to wait until [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml), *Working
    with System Files*, to learn more about putting data at the end of a file without
    destroying its existing data.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会讨论向现有文件追加数据：您将不得不等到[第7章](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)，*使用系统文件*，以了解如何在不破坏现有数据的情况下将数据放在文件末尾。
- en: About file input and output
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于文件输入和输出
- en: File input and output includes everything that has to do with reading the data
    of a file and writing the desired data to a file. There is not a single operating
    system that does not offer support for files and therefore for file input and
    output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件输入和输出包括与读取文件数据和将所需数据写入文件有关的一切。没有一个操作系统不支持文件，因此也不支持文件输入和输出。
- en: As this chapter is pretty big, I will stop talking and start showing you practical
    Go code that will make things clearer. So, the first thing that you will learn
    in this chapter is byte slices, which are very important in applications that
    are concerned with file input and output.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章内容较多，我将停止讲话，开始向您展示将使事情更清晰的实际Go代码。因此，您将在本章中学到的第一件事是字节切片，在涉及文件输入和输出的应用程序中非常重要。
- en: Byte slices
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节切片
- en: '**Byte slices** are a kind of slices used for file reading and writing. Putting
    it simply, they are slices of bytes used as a buffer during file reading and writing
    operations. This section will present a small Go example where a byte slice is
    used for writing to a file and reading from a file. As you will see byte slices
    all over this chapter, make sure that you understand the presented example. The
    related Go code is saved as `byteSlice.go` and will be presented in three parts.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 字节切片是一种用于文件读写的切片。简单来说，它们是用作文件读写操作期间的缓冲区的字节切片。本节将介绍一个小的Go示例，其中使用字节切片进行文件写入和读取。正如您将在本章中看到的字节切片一样，请确保您理解所呈现的示例。相关的Go代码保存为`byteSlice.go`，将分为三个部分。
- en: 'The first part is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second part of `byteSlice.go` is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`byteSlice.go`的第二部分如下：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, you use the `aByteSlice` byte slice to save some text into a file that
    is identified by the `filename` variable. The last part of `byteSlice.go` is the
    following Go code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`aByteSlice`字节切片将一些文本保存到由`filename`变量标识的文件中。`byteSlice.go`的最后一部分是以下Go代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you define another byte slice named `anotherByteSlice` with `100` places
    that will be used for reading from the file you created previously. Note that
    `%s` used in `fmt.Printf()` forces `anotherByteSlice` to be printed as a string:
    using `Println()` would have produced a totally different output.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您定义了另一个名为`anotherByteSlice`的字节切片，其中有`100`个位置，将用于从先前创建的文件中读取。请注意，`fmt.Printf()`中使用的`%s`强制`anotherByteSlice`作为字符串打印：使用`Println()`将产生完全不同的输出。
- en: Note that as the file is smaller, the `f.Read()` call will put less data into
    `anotherByteSlice`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于文件较小，`f.Read()`调用将向`anotherByteSlice`中放入较少的数据。
- en: The size of `anotherByteSlice` denotes the maximum amount of data that can be
    stored into it after a single call to `Read()` or after any other similar operation
    that reads data from a file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`anotherByteSlice`的大小表示在单次调用`Read()`或任何其他类似从文件读取数据的操作之后可以存储在其中的最大数据量。'
- en: 'Executing `byteSlice.go` will generate the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`byteSlice.go`将生成以下输出：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Checking the size of the `usingByteSlices` file will verify that the right
    amount of data was written to it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`usingByteSlices`文件的大小将验证是否已将正确的数据量写入其中：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: About binary files
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于二进制文件
- en: There is no difference between reading and writing binary and plain text files
    in Go. So, when processing a file, Go makes no assumptions about its format. However,
    Go offers a package named binary that allows you to make translations between
    different encodings such as **little endian** and **big endian**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，读取和写入二进制和纯文本文件没有区别。因此，在处理文件时，Go不会对其格式做出任何假设。但是，Go提供了一个名为binary的包，允许您在不同的编码之间进行转换，例如**小端**和**大端**。
- en: 'The `readBinary.go` file briefly illustrates how to convert an integer number
    to a little endian number and to a big endian number, which might be useful when
    the files you want to process contain certain kinds of data; this mainly happens
    when we are dealing with raw devices and raw packet manipulation: remember everything
    is a file! The source code of `readBinary.go` will be presented in two parts.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`readBinary.go`文件简要说明了如何将整数转换为小端数和大端数，当您要处理的文件包含某些类型的数据时可能会有用；这主要发生在处理原始设备和原始数据包操作时：记住一切都是文件！`readBinary.go`的源代码将分两部分呈现。'
- en: 'The first part is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is nothing special in this part of the program. The second part is the
    following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的这一部分没有什么特别之处。第二部分如下：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second part contains all the important Go code: the conversions happen
    with the help of the `binary.Write()` method and the proper write parameter (`binary.LittleEndian`
    or `binary.BigEndian`). The `bytes.Buffer` variable is used for the `io.Reader`
    and `io.Writer` interfaces of the program. Lastly, the `buf.Reset()` statement
    resets the buffer in order to be used afterwards for storing the big endian.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含了所有重要的Go代码：转换是通过`binary.Write()`方法和适当的写入参数（`binary.LittleEndian`或`binary.BigEndian`）进行的。`bytes.Buffer`变量用于程序的`io.Reader`和`io.Writer`接口。最后，`buf.Reset()`语句重置缓冲区，以便之后用于存储大端数。
- en: 'Executing `readBinary.go` will generate the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readBinary.go`将生成以下输出：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can find more information about the binary package by visiting its documentation
    page at [https://golang.org/pkg/encoding/binary/](https://golang.org/pkg/encoding/binary/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问其文档页面[https://golang.org/pkg/encoding/binary/](https://golang.org/pkg/encoding/binary/)找到有关二进制包的更多信息。
- en: Useful I/O packages in Go
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中有用的I/O包
- en: The `io` package is for performing primitive file I/O operations, whereas the
    `bufio` package is for executing buffered I/O.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`io`包用于执行原始文件I/O操作，而`bufio`包用于执行缓冲I/O。'
- en: In buffered I/O, the operating system uses an intermediate buffer during file
    read and write operations in order to reduce the number of filesystem calls. As
    a result, buffered input and output is faster and more efficient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲I/O中，操作系统在文件读写操作期间使用中间缓冲区，以减少文件系统调用的次数。因此，缓冲输入和输出更快更高效。
- en: Additionally, you can use some of the functions of the `fmt` package to write
    text to a file. Note that the `flag` package will be also used in this chapter
    as well as in all the forthcoming ones where the developed utilities need to support
    command-line flags.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用`fmt`包的一些函数将文本写入文件。请注意，`flag`包也将在本章以及所有需要支持命令行标志的后续章节中使用。
- en: The io package
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io包
- en: The `io` package offers functions that allow you to write to or read from files.
    Its use will be illustrated in the `usingIO.go` file, which will be presented
    in three parts. What the program does is read `8` bytes from a file and write
    them in a standard output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`io`包提供了允许您向文件写入或从文件读取的函数。其用法将在`usingIO.go`文件中进行演示，该文件将分三部分呈现。程序的作用是从文件中读取`8`个字节并将它们写入标准输出。'
- en: 'The first part is the preamble of the Go program:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Go程序的序言是第一部分：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The second part is the following Go code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是以下Go代码：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program also uses the handy `defer` command that defers the execution of
    a function until the surrounding function returns. As a result, `defer` is used
    very frequently in file I/O operations because it saves you from having to remember
    to execute the `Close()` call after you are done working with a file or when you
    leave a function in any number of locations using a `return` statement or `os.Exit()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序还使用了方便的`defer`命令，它推迟了函数的执行，直到周围的函数返回。因此，在文件I/O操作中经常使用`defer`，因为它可以让您不必记住在完成文件处理或在使用`return`语句或`os.Exit()`离开函数时执行`Close()`调用。
- en: 'The last part of the program is the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分如下：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `io.ReadFull()` function here reads from the reader of an open file and
    puts the data into a byte slice that has 8 places. You can also see here the use
    of the `io.WriteString()` function for printing data to a standard output (`os.Stdout`)
    that is also a file. However, this is not a very common practice as you can simply
    use `fmt.Println()` instead.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`io.ReadFull()`函数从打开文件的读取器中读取数据，并将数据放入一个有8个位置的字节切片中。您还可以在这里看到使用`io.WriteString()`函数将数据打印到标准输出（`os.Stdout`），这也是一个文件。但是，这不是一个很常见的做法，因为您可以简单地使用`fmt.Println()`。
- en: 'Executing `usingIO.go` generates the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`usingIO.go`会生成以下输出：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The bufio package
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bufio包
- en: The functions of the `bufio` package allow you to perform buffered file operations,
    which means that although its operations look similar to the ones found in `io`,
    they work in a slightly different way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio`包的函数允许您执行缓冲文件操作，这意味着尽管其操作看起来类似于`io`中找到的操作，但它们的工作方式略有不同。'
- en: What `bufio` actually does is to wrap an `io.Reader` or `io.Writer` object into
    a new value that implements the required interface while providing buffering to
    the new value. One of the handy features of the `bufio` package is that it allows
    you to read a text file line by line, word by word, and character by character
    without too much effort.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio`实际上的作用是将`io.Reader`或`io.Writer`对象包装成一个实现所需接口的新值，并为新值提供缓冲。`bufio`包的一个方便功能是它允许您轻松地逐行、逐词和逐字符读取文本文件。'
- en: 'Once again, an example will try to clarify things: the name of the Go file
    that showcases the use of `bufio` is `bufIO.go` and will be presented in four
    parts.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一个示例将尝试澄清事情：展示了`bufio`使用的Go文件的名称是`bufIO.go`，将分为四个部分呈现。
- en: 'The first part is the expected preamble:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序文：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second part is the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是以下内容：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you just try to get the name of the file that you are going to use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需尝试获取要使用的文件的名称。
- en: 'The third part of `bufIO.go` has the following Go code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufIO.go`的第三部分包含以下Go代码：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The default behavior of `bufio.NewScanner` is to read its input line by line,
    which means that each time you call the `Scan()` method that reads the next token,
    a new line will be returned. The last part is where you actually call the `Scan()`
    method in order to read the full contents of the file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio.NewScanner`的默认行为是逐行读取其输入，这意味着每次调用`Scan()`方法读取下一个标记时，都会返回一个新行。最后一部分是你实际调用`Scan()`方法以读取文件的全部内容的地方：'
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Text()` method returns the latest token from the `Scan()` method as a string,
    which in this case will be a line. However, if you ever get strange results while
    trying to read a file line by line, it will most likely be the way your file ends
    a line, which is usually the case with text files coming from Windows machines.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text()`方法将`Scan()`方法的最新标记作为字符串返回，这种情况下将是一行。但是，如果你在尝试逐行读取文件时遇到奇怪的结果，那很可能是你的文件如何结束一行的方式，这通常是来自Windows机器的文本文件的情况。'
- en: 'Executing `bufIO.go` and feeding `wc(1)` with its output can help you verify
    that `bufIO.go` works as expected:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`bufIO.go`并将其输出提供给`wc(1)`可以帮助你验证`bufIO.go`是否按预期工作：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: File I/O operations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O操作
- en: Now that you know the basics of the `io` and `bufio` packages, it is time to
    learn more detailed information about their usage and how they can help you work
    with files. But first, we will talk about the `fmt.Fprintf()` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`io`和`bufio`包的基础知识，是时候学习更详细的关于它们的用法以及它们如何帮助你处理文件的信息了。但首先，我们将讨论`fmt.Fprintf()`函数。
- en: Writing to files using fmt.Fprintf()
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fmt.Fprintf()向文件写入
- en: The use of the `fmt.Fprintf()` function allows you to write formatted text to
    files in a way that is similar to the way the `fmt.Printf()` function works. Note
    that `fmt.Fprintf()` can write to any `io.Writer` interface and that our files
    will satisfy the `io.Writer` interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fmt.Fprintf()`函数允许你以类似于`fmt.Printf()`函数的方式向文件写入格式化文本。请注意，`fmt.Fprintf()`可以写入任何`io.Writer`接口，并且我们的文件将满足`io.Writer`接口。
- en: 'The Go code that illustrates the use of `fmt.Fprintf()` can be found in `fmtF.go`,
    which will be presented in three parts. The first part is the expected preamble:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了`fmt.Fprintf()`的Go代码可以在`fmtF.go`中找到，该文件将分为三个部分呈现。第一部分是预期的序文：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second part has the following Go code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the `os.Create()` function will truncate the file if it already exists.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果文件已经存在，`os.Create()`函数将截断该文件。
- en: 'The last part is the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是以下内容：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you write the desired text data to the file that is identified by the
    destination variable using `fmt.Fprintf()` as if you were using the `fmt.Printf()`
    method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用`fmt.Fprintf()`将所需的文本数据写入由目标变量标识的文件，就像你使用`fmt.Printf()`方法一样。
- en: 'Executing `fmtF.go` will generate the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`fmtF.go`将生成以下输出：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In other words, you can create plain text files using `fmt.Fprintf()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以使用`fmt.Fprintf()`创建纯文本文件。
- en: About io.Writer and io.Reader
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于io.Writer和io.Reader
- en: 'Both `io.Writer` and `io.Reader` are interfaces that embed the `io.Write()`
    and `io.Read()` methods, respectively. The use of `io.Writer` and `io.Reader`
    will be illustrated in `readerWriter.go`, which will be presented in four parts.
    The program computes the characters of its input file and writes the number of
    characters to another file: if you are dealing with Unicode characters that take
    more than one byte per character, you might consider that the program is reading
    bytes. The output filename has the name of the original file plus the `.Count`
    extension.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer`和`io.Reader`都是嵌入`io.Write()`和`io.Read()`方法的接口。`io.Writer`和`io.Reader`的使用将在`readerWriter.go`中进行说明，该文件将分为四个部分呈现。该程序计算其输入文件的字符数，并将字符数写入另一个文件：如果你处理的是每个字符占用多个字节的Unicode字符，你可能会考虑该程序正在读取字节。输出文件名为原始文件名加上`.Count`扩展名。'
- en: 'The first part is the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是以下内容：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second part is the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是以下内容：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once again, a byte slice is used during reading. The `break` statement allows
    you to exit the `for` loop. The third part is the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在读取过程中使用了字节切片。`break`语句允许你退出`for`循环。第三部分是以下代码：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here you can see how you can write a number to a file using `fmt.Fprintf()`:
    I did not manage to do the same using a byte slice! Additionally, note that the
    presented code writes text to a file using an `io.Writer` variable (`w`).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到如何使用`fmt.Fprintf()`向文件写入数字：我没有成功使用字节切片做同样的事情！另外，请注意，所呈现的代码使用`io.Writer`变量(`w`)向文件写入文本。
- en: 'The last part of `readerWriter.go` has the following Go code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`readerWriter.go`的最后一部分包含以下Go代码：'
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The execution of `readerWriter.go` generates no output; so, it is up to you
    to check its correctness, which in this case happens with the help of `wc(1)`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readerWriter.go`不会生成任何输出；因此，你需要检查其正确性，这在本例中是通过`wc(1)`的帮助来实现的：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finding out the third column of a line
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找行的第三列
- en: Now that you know how to read a file, it is time to present a modified version
    of the `readColumn.go` program you saw in [Chapter 3](96c36f62-d505-408c-add5-af84cf25454a.xhtml),
    *Advanced Go Features*. The new version is also named `readColumn.go`, but has
    two major improvements. The first is that you can provide the desired column as
    a command-line argument and the second is that it can read multiple files if it
    gets multiple command-line arguments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道如何读取文件，是时候介绍您在[第3章](96c36f62-d505-408c-add5-af84cf25454a.xhtml)中看到的`readColumn.go`程序的修改版本了，*高级Go功能*。新版本也被命名为`readColumn.go`，但有两个主要改进。第一个是您可以将所需的列作为命令行参数提供，第二个是如果它获得多个命令行参数，它可以读取多个文件。
- en: 'The `readColumn.go` file will be presented in three parts. The first part of
    `readColumn.go` is the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`readColumn.go`文件将分为三部分。`readColumn.go`的第一部分如下：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next part of `readColumn.go` contains the following Go code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`readColumn.go`的下一部分包含以下Go代码：'
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you will understand from the definition of the `minusCOL` variable, if the
    user does not use this flag, the program will print the contents of the first
    column of each file it reads.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从`minusCOL`变量的定义中，您将了解到，如果用户不使用此标志，程序将打印它读取的每个文件的第一列的内容。
- en: 'The last part of `readColumn.go` is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`readColumn.go`的最后部分如下：'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code does not do anything that you have not seen before. The `for`
    loop is used for processing all command-line arguments. However, if a file fails
    to open for some reason, the program will not stop its execution, but it will
    continue processing the rest of the files if they exist. However, the program
    expects that its input files end in a newline and you might see strange results
    if an input file ends differently.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有做任何您以前没有见过的事情。`for`循环用于处理所有命令行参数。但是，如果由于某种原因文件无法打开，程序将不会停止执行，而是会继续处理其余的文件（如果存在）。但是，程序期望其输入文件以换行符结尾，如果输入文件以不同的方式结束，您可能会看到奇怪的结果。
- en: 'Executing `readColumn.go` generates the following output, which is abbreviated
    in order to save some book space:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readColumn.go`会生成以下输出，为了节省一些书籍空间，输出进行了缩写：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, there is no file named `isThereAFile` and the `pF.data` file does
    not have a third column. However, the program did its best and printed what it
    could!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有名为`isThereAFile`的文件，`pF.data`文件也没有第三列。但是，程序尽力打印了它能够打印的内容！
- en: Copying files in Go
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中复制文件
- en: Every operating system allows you to copy files because this is a very important
    and necessary operation. This section will show you how to copy files in Go now
    that you know how to read files!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都允许您复制文件，因为这是非常重要和必要的操作。现在您知道如何读取文件，本节将向您展示如何在Go中复制文件！
- en: There is more than one way to copy a file!
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制文件有多种方法！
- en: Most programming languages offer more than one way to create a copy of a file
    and Go is no exception. It is up to the developer to decide which approach to
    implement.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言提供了多种创建文件副本的方法，Go也不例外。由开发人员决定要实现哪种方法。
- en: The t*here is more than one way to do it* rule applies to almost everything
    implemented in this book, but file copying is the most characteristic example
    of this rule because you can copy a file by reading it line by line, byte by byte,
    or all at once! However, this rule does not apply to the way Go likes to format
    its code!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*有多种方法可以做到*这一规则几乎适用于本书中实现的所有内容，但是文件复制是这一规则的最典型的例子，因为您可以逐行、逐字节或一次性复制文件！但是，这一规则不适用于Go喜欢格式化其代码的方式！'
- en: Copying text files
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制文本文件
- en: There is no point in treating the copying of text files in a special way unless
    you want to inspect or modify their contents. As a result, the three techniques
    presented here will not differentiate between plain text and binary file copying.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本文件的复制没有特殊的意义，除非你想要检查或修改它们的内容。因此，这里介绍的三种技术不会区分纯文本和二进制文件的复制。
- en: '[Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*, Working with System
    Files*, will talk about file permissions because there are times that you want
    to create new files with the file permissions you choose.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*，处理系统文件*，将讨论文件权限，因为有时您希望使用您选择的文件权限创建新文件。'
- en: Using io.Copy
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用io.Copy
- en: This subsection will present a technique for copying files that uses the `io.Copy()`
    function. What is special about the `io.Copy()` function is the fact that is does
    not give you any flexibility in the process. The name of the program will be `notGoodCP.go`
    and will be presented in three parts. Note that a more appropriate filename for
    `notGoodCP.go` would have been `copyEntireFileAtOnce.go` or `copyByReadingInputFileAllAtOnce.go`!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将介绍一种使用`io.Copy()`函数复制文件的技术。`io.Copy()`函数的特殊之处在于它在过程中不提供任何灵活性。程序的名称将是`notGoodCP.go`，将分为三部分呈现。请注意，`notGoodCP.go`的更合适的文件名可能是`copyEntireFileAtOnce.go`或`copyByReadingInputFileAllAtOnce.go`！
- en: 'The first part of the Go code of `notGoodCP.go` is the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`notGoodCP.go`的Go代码的第一部分如下：'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second part is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here we define our own function that uses `io.Copy()` to make a copy of a file.
    The `Copy()` function checks whether the source file is a regular file before
    trying to copy it, which makes perfect sense.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了自己的函数，该函数使用`io.Copy()`来复制文件。`Copy()`函数在尝试复制文件之前会检查源文件是否是常规文件，这是非常合理的。
- en: 'The last part is the implementation of the `main()` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数的最后部分是实现：'
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The best tool for testing whether a file is an exact copy of another file is
    the `diff(1)` utility, which also works with binary files. You can learn more
    about `diff(1)` by reading its main page.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件是否是另一个文件的精确副本的最佳工具是`diff(1)`实用程序，它也适用于二进制文件。您可以通过阅读其主页了解有关`diff(1)`的更多信息。
- en: 'Executing `notGoodCP.go` will generate the following results:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`notGoodCP.go`将生成以下结果：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Reading a file all at once!
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性读取文件！
- en: The technique in this section will use the `ioutil.WriteFile()` and `ioutil.ReadFile()`
    functions. Note that `ioutil.ReadFile()` does not implement the `io.Reader` interface
    and therefore is a little restrictive.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的技术将使用`ioutil.WriteFile()`和`ioutil.ReadFile()`函数。请注意，`ioutil.ReadFile()`没有实现`io.Reader`接口，因此有一定的限制。
- en: The Go code for this section is named `readAll.go` and will be presented in
    three parts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的Go代码名为`readAll.go`，将分为三部分呈现。
- en: 'The first part has the following Go code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含以下Go代码：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second part is the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last part is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the `ioutil.ReadFile()` function reads the entire file, which might
    not be efficient when you want to copy huge files. Similarly, the `ioutil.WriteFile()`
    function writes all the given data to a file that is identified by its first argument.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ioutil.ReadFile()`函数读取整个文件，当你想要复制大文件时可能不是高效的。同样，`ioutil.WriteFile()`函数将所有给定的数据写入由其第一个参数标识的文件。
- en: 'The execution of `readAll.go` generates the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readAll.go`将生成以下输出：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: An even better file copy program
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更好的文件复制程序
- en: This section will present a program that uses a more traditional approach, where
    a buffer is used for reading and copying to the new file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍一个使用更传统方法的程序，其中使用缓冲区进行读取和复制到新文件。
- en: Although traditional Unix command-line utilities are silent when there are no
    errors, it is not bad to print some kind of information, such as the number of
    bytes read, in your own tools. However, the right thing to do is to follow the
    Unix way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管传统的Unix命令行实用程序在没有错误时是静默的，但在自己的工具中打印一些信息，比如读取的字节数，也不是坏事。然而，正确的做法是遵循Unix的方式。
- en: There exist two main reasons that make `cp.go` better than `notGoodCP.go`. The
    first is that the developer has more control over the process in exchange for
    having to write more Go code and the second is that `cp.go` allows you to define
    the size of the buffer, which is the most important parameter in the copy operation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两个主要原因使`cp.go`比`notGoodCP.go`更好。第一个是开发者可以更多地控制这个过程，但需要编写更多的Go代码；第二个是`cp.go`允许你定义缓冲区的大小，这是复制操作中最重要的参数。
- en: 'The code of `cp.go` will be presented in five parts. The first part is the
    expected preamble along with a global variable that holds the size of the read
    buffer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp.go`的代码将分为五部分呈现。第一部分是预期的序文，以及一个保存读取缓冲区大小的全局变量：'
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The second part is the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see here, the size of the buffer is given to the `Copy()` function
    as an argument. The other two command-line arguments are the input filename and
    the output filename.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，缓冲区的大小作为参数传递给了`Copy()`函数。另外两个命令行参数是输入文件名和输出文件名。
- en: 'The third part has the remaining Go code of the `Copy()` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含了`Copy()`函数的剩余Go代码：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There is nothing special here: you just keep calling source, `Read()` until
    you reach the end of the input file. Each time you read something, you call destination.
    `Write()` to save it to the output file. The `buf[:n]` notation allows you to
    read the first `n` characters from the `buf` slice.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：你只需不断调用源文件的`Read()`，直到达到输入文件的末尾。每次读取内容时，你都要调用目标文件的`Write()`来保存到输出文件。`buf[:n]`的表示法允许你从`buf`切片中读取前`n`个字符。
- en: 'The fourth part contains the following Go code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含以下Go代码：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `filepath.Base()` is used for getting the name of the executable file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath.Base()`用于获取可执行文件的名称。'
- en: 'The last part is the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Executing `cp.go` will generate the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`cp.go`将生成以下输出：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If there is a problem with the `copy` operation, you will get a descriptive
    error message.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`copy`操作出现问题，你将得到一个描述性的错误消息。
- en: 'So, if the program cannot find the input file, it will print the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果程序找不到输入文件，它将打印以下内容：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the program cannot read the input file, you will get the following message:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序无法读取输入文件，你将得到以下消息：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If the program cannot create the output file, it will print the following error
    message:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序无法创建输出文件，它将打印以下错误消息：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If the destination file already exists, you will get the following output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标文件已经存在，你将得到以下输出：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Benchmarking file copying operations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件复制操作的基准测试
- en: The size of the buffer you use in file operations is really important and affects
    the performance of your system tools, especially when you are dealing with very
    big files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件操作中使用的缓冲区的大小真的很重要，它会影响你的系统工具的性能，特别是当你处理非常大的文件时。
- en: Although developing reliable software should be your main concern, you should
    not forget to make your systems software fast and efficient!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开发可靠的软件应该是你的主要关注点，但你不应该忘记让你的系统软件快速高效！
- en: So, this section will try to see how the size of the buffer affects the file
    copying operations by executing `cp.go` with various buffer sizes and comparing
    its performance with `readAll.go`, `notGoodCP.go` as well as `cp(1)`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节将尝试通过使用不同的缓冲区大小执行`cp.go`，并将其性能与`readAll.go`、`notGoodCP.go`以及`cp(1)`进行比较，以查看缓冲区大小如何影响文件复制操作。
- en: In the old Unix days when the amount of RAM on Unix machines was too small,
    using a large buffer was not recommended. However, nowadays, using a buffer with
    a size of `100 MB` is not considered bad practice, especially when you know in
    advance that you are going to copy lots of big files such as the data files of
    a database server.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的Unix时代，当Unix机器上的RAM数量太小时，不建议使用大缓冲区。然而，如今，使用大小为`100 MB`的缓冲区并不被认为是不好的做法，特别是当你事先知道你要复制大量的大文件，比如数据库服务器的数据文件。
- en: 'We will use three files with different sizes in our testing: these three files
    will be generated using the `dd(1)` utility, as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试中使用三个不同大小的文件：这三个文件将使用`dd(1)`实用程序生成，如下所示：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first file is `100 MB`, the second is `1 GB`, and the third is `5 GB` in
    size.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件大小为`100 MB`，第二个文件大小为`1 GB`，第三个文件大小为`5 GB`。
- en: 'Now, it is time for the actual testing using the `time(1)` utility. First,
    we will test the performance of `notGoodCP.go` and `readAll.go`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用`time(1)`实用程序进行实际测试了。首先，我们将测试`notGoodCP.go`和`readAll.go`的性能：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, you will see the results from the `cp.go` program using four different
    buffer sizes, `16`, `1024`, `1048576`, and `1073741824`. First, let''s copy the
    `100 MB` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将看到`cp.go`程序使用四种不同的缓冲区大小`16`，`1024`，`1048576`和`1073741824`的结果。首先，让我们复制`100
    MB`文件：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, we will copy the `1 GB` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将复制`1 GB`文件：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we will copy the `5 GB` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将复制`5 GB`文件：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, let''s present the results from the `cp(1)` utility that comes with
    macOS Sierra:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们展示macOS Sierra附带的`cp(1)`实用程序的结果：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following figure shows a graph with the values of the real fields from
    the output of the `time(1)` utility for all the aforementioned results:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了`time(1)`实用程序输出的实际字段值的图表，显示了所有上述结果：
- en: '![](img/a8e66124-879d-4896-b67f-28ae698552a5.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8e66124-879d-4896-b67f-28ae698552a5.png)'
- en: Benchmarking results for the various copy utilities
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 各种复制实用程序的基准测试结果
- en: 'As you can see from the results, the `cp(1)` utility does a pretty good job.
    However, `cp.go` is more versatile because it allows you to define the size of
    the buffer. On the other hand, if you use `cp.go` with a small buffer size (16
    bytes), then the entire process will be totally ruined! Additionally, it is interesting
    that `readAll.go` does a pretty decent job with relatively small files and it
    is slow only when copying the `5 GB` file, which is not bad for such a small program:
    you can consider `readAll.go` as a quick and dirty solution!'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中可以看出，`cp(1)`实用程序表现得相当不错。但是，`cp.go`更加灵活，因为它允许您定义缓冲区的大小。另一方面，如果您使用缓冲区大小较小（16字节）的`cp.go`，那么整个过程将完全失败！此外，有趣的是`readAll.go`在处理相对较小的文件时表现相当不错，只有在复制`5
    GB`文件时才会变慢，对于这样一个小程序来说并不糟糕：您可以将`readAll.go`视为一个快速而粗糙的解决方案！
- en: Developing wc(1) in Go
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中开发wc(1)
- en: The principal idea behind the code of the `wc.go` program is that you can read
    a text file line by line until there is nothing left to read. For each line you
    read, you find out the number of characters and the number of words it has. As
    you need to read your input line by line, the use of `bufio` is preferred instead
    of the plain `io` because it simplifies the code. However, trying to implement
    `wc.go` on your own using `io` would be a very educational exercise.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc.go`程序的代码的主要思想是，您可以逐行读取文本文件，直到没有内容可读为止。对于每行读取的内容，您可以找出它包含的字符数和单词数。由于需要逐行读取输入，因此最好使用`bufio`而不是普通的`io`，因为它可以简化代码。但是，尝试使用`io`自己实现`wc.go`将是一个非常有教育意义的练习。'
- en: 'But first, you will see that the `wc(1)` utility generates the following output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，您将看到`wc(1)`实用程序生成以下输出：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So, if `wc(1)` has to process more than one file, it automatically generates
    summary information.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果`wc(1)`必须处理多个文件，它会自动生成摘要信息。
- en: In [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml), *Goroutines - Basic
    Features*, you will learn how to create a version of `wc.go` using Go routines.
    However, the core functionality of both versions will be exactly the same!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)中，*Goroutines - 基本特性*，您将学习如何使用Go
    routines创建`wc.go`的版本。但是，两个版本的核心功能将完全相同！
- en: Counting words
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算单词
- en: 'The trickiest part of the code implementation is word counting, which is implemented
    using regular expressions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代码实现中最棘手的部分是单词计数，它使用了正则表达式：
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, the provided regular expression separates the words of a line based on
    whitespace characters in order to count them afterwards!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提供的正则表达式根据空白字符分隔行的单词，以便之后对它们进行计数！
- en: The wc.go code!
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: wc.go代码！
- en: 'After this little introduction, it is time to see the Go code of `wc.go`, which
    will be presented in five parts. The first part is the expected preamble:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小介绍之后，是时候看看`wc.go`的Go代码了，它将分为五个部分呈现。第一部分是预期的序言：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The second part is the implementation of the `countLines()` function, which
    includes the core functionality of the program. Note that the name `countLines()`
    may have been a poor choice as `countLines()` also counts the words and the characters
    of a file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是`countLines()`函数的实现，其中包括程序的核心功能。请注意，`countLines()`的命名可能不太合适，因为`countLines()`还会计算文件的单词和字符数：
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Lots of interesting things exist here. First of all, you can see the Go code
    presented in the previous section for counting the words of each line. Counting
    lines is easy because each time the `bufio` reader reads a new line, the value
    of the `numberOfLines` variable is increased by one. The `ReadString()` function
    tells the program to read until the first occurrence of `''\n''` in the input:
    multiple calls to `ReadString()` mean that you are reading a file line by line.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多有趣的事情。首先，您可以看到前一节中呈现的Go代码，用于计算每行的单词。计算行数很容易，因为每次`bufio`读取器读取新行时，`numberOfLines`变量的值就会增加一。`ReadString()`函数告诉程序读取输入直到第一个`'\n'`的出现：多次调用`ReadString()`意味着您正在逐行读取文件。
- en: Next, you can see that the `countLines()` function returns three integer values.
    Lastly, counting characters is implemented with the help of the `len()` function
    that returns the number of characters in a given string, which in this case is
    the line that was read. The `for` loop terminates when you get the `io.EOF` error
    message, which signifies that there is nothing left to read from the input file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以看到`countLines()`函数返回三个整数值。最后，计算字符数是通过`len()`函数实现的，该函数返回给定字符串中的字符数，在这种情况下是读取的行。`for`循环在获得`io.EOF`错误消息时终止，这表示从输入文件中没有剩余内容可读取。
- en: 'The third part of `wc.go` starts with the beginning of the implementation of
    the `main()` function, which also includes the configuration of the `flag` package:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc.go`的第三部分从`main()`函数的实现开始，其中还包括`flag`包的配置：'
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The last `for` statement is for processing all the input files given to the
    program. The `wc.go` program supports three flags: the `-c` flag is for printing
    the character count, the `-w` flag is for printing the word count, and the `-l`
    flag is for printing the line count.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`for`语句用于处理程序给定的所有输入文件。`wc.go`程序支持三个标志：`-c`标志用于打印字符计数，`-w`标志用于打印单词计数，`-l`标志用于打印行计数。
- en: 'The fourth part is the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分是以下内容：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This part deals with printing the information on a per file basis depending
    on the command-line flags. As you can see, most of the Go code here is for handling
    the output according to the command-line flags.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分涉及根据命令行标志在每个文件基础上打印信息。正如您所看到的，这里的大部分Go代码是用于根据命令行标志处理输出。
- en: 'The last part is the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是以下内容：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is where you print the total number of lines, words, and characters read
    according to the flags of the program. Once again, most of the Go code here is
    for modifying the output according to the command-line flags.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您根据程序的标志打印的总行数、单词数和字符数。再次强调，这里的大部分Go代码是用于根据命令行标志修改输出。
- en: 'Executing `wc.go` will generate the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`wc.go`将生成以下输出：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'There is a subtle point here: using Go source files as command-line arguments
    to the `go run wc.go` command will fail. This will happen because the compiler
    will try to compile the Go source files instead of treating them as command-line
    arguments to the `go run wc.go` command. The following output proves this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个微妙的地方：使用Go源文件作为`go run wc.go`命令的命令行参数将失败。这将发生是因为编译器将尝试编译Go源文件，而不是将它们视为`go
    run wc.go`命令的命令行参数。以下输出证明了这一点：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Additionally, trying to execute `wc.go` on a Linux system with Go version 1.3.3
    will fail with the following error message:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尝试在Go版本1.3.3的Linux系统上执行`wc.go`将失败，并显示以下错误消息：
- en: '[PRE63]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Comparing the performance of wc.go and wc(1)
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较`wc.go`和`wc(1)`的性能
- en: 'In this subsection, we will compare the performance of our version of `wc(1)`
    with the `wc(1)` version that comes with macOS Sierra 10.12.6\. First, we will
    execute `wc.go`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们将比较我们版本的`wc(1)`与macOS Sierra 10.12.6自带的`wc(1)`的性能。首先，我们将执行`wc.go`：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, we will execute the macOS version of `wc(1)` to process the same files:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将执行macOS版本的`wc(1)`来处理相同的文件：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Let's look at the good news here first; the two utilities generated exactly
    the same output, which means that our Go version of `wc(1)` works great and can
    process big text files!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看好消息；这两个实用程序生成了完全相同的输出，这意味着我们的`wc(1)`的Go版本效果很好，可以处理大型文本文件！
- en: Now, the bad news; `wc.go` is slow! It took `wc(1)` less than a second to process
    all five files, whereas it took `wc.go` nearly 18 seconds to perform the same
    task!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，坏消息是，`wc.go`很慢！`wc(1)`处理所有五个文件不到一秒，而`wc.go`执行相同的任务几乎需要18秒！
- en: The general idea when developing software of any kind, on any platform, using
    any programming language, is that you should try to have a working version of
    it, which does not contain any bugs before trying to optimize it and not the other
    way round!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何类型的软件时，无论在任何平台上，使用任何编程语言，一般的想法是，您应该在尝试优化之前先尝试拥有一个没有错误的工作版本，而不是反过来！
- en: Reading a text file character by character
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐个字符读取文本文件
- en: Although reading a text file character by character is not needed for the development
    of the `wc(1)` utility, it would be good to know how to implement it in Go. The
    name of the file will be `charByChar.go` and will be presented in four parts.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不需要逐个字符读取文本文件来开发`wc(1)`实用程序，但了解如何在Go中实现它是很好的。文件的名称将是`charByChar.go`，并将分为四部分呈现。
- en: 'The first part is the following Go code:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是以下Go代码：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Although `charByChar.go` does not have many lines of Go code, it needs lots
    of Go standard packages, which is a naive indication that the task it implements
    is not trivial. The second part is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`charByChar.go`的Go代码行数不多，但它需要大量的Go标准包，这是一个天真的迹象，表明它实现的任务并不是微不足道的。第二部分如下：
- en: '[PRE67]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The third part is the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是以下内容：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The last part has the following Go code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, `ScanRunes` is a split function that returns each character (rune) as
    a token. Then, the call to `Scan()` allows us to process each character one by
    one. There also exist `ScanWords` and `ScanLines` for getting words and lines,
    respectively. If you use `fmt.Println(s.Text())` as the last statement in the
    program instead of `fmt.Print(s.Text())`, then each character will be printed
    on its own line and the task of the program will be more obvious.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ScanRunes`是一个分割函数，它将每个字符（rune）作为一个标记返回。然后，调用`Scan()`允许我们逐个处理每个字符。还有`ScanWords`和`ScanLines`用于分别获取单词和行。如果您在程序的最后一条语句中使用`fmt.Println(s.Text())`而不是`fmt.Print(s.Text())`，那么每个字符将被单独打印在自己的行上，程序的任务也将更加明显。
- en: 'Executing `charByChar.go` generates the following output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`charByChar.go`将生成以下输出：
- en: '[PRE70]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `wc(1)` command can verify the correctness of the Go code of `charByChar.go`
    by comparing the input file with the output generated by `charByChar.go`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc(1)`命令可以通过比较输入文件和`charByChar.go`生成的输出来验证`charByChar.go`的Go代码的正确性：'
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Doing some file editing!
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行一些文件编辑！
- en: This section will present a Go program that converts tab characters to space
    characters in files and vice versa! This is the job that is usually done by a
    text editor, but it is good to know how to perform it on your own.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍一个将文件中的制表符转换为空格字符，反之亦然的Go程序！这通常是文本编辑器的工作，但了解如何自行执行此操作也是很好的。
- en: The code will be saved in `tabSpace.go` and will be presented in four parts.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将保存在`tabSpace.go`中，并将分为四部分呈现。
- en: Note that `tabSpace.go` reads text files line by line, but you can also develop
    a version that reads text file character by character.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`tabSpace.go`按行读取文本文件，但您也可以开发一个按字符读取文本文件的版本。
- en: In the current implementation, all the work is done with the help of regular
    expressions, pattern matching, and search and replace operations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的实现中，所有工作都是通过正则表达式、模式匹配和搜索替换操作完成的。
- en: 'The first part is the expected preamble:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是预期的序言：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The second part contains the following Go code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The third part contains the following Go code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Go代码：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The last part is the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This part is where the magic happens using the appropriate `strings.Replace()`
    call. In its current implementation, each tab is replaced by four space characters
    and vice versa, but you can change that by modifying the Go code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是使用适当的`strings.Replace()`调用发生魔术的地方。在当前的实现中，每个制表符都被四个空格字符替换，反之亦然，但您可以通过修改Go代码来更改这一点。
- en: Once again, a big part of `tabSpace.go` relates to error handling because many
    strange things can happen when you try to open a file for reading!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`tabSpace.go`的很大一部分涉及错误处理，因为当您尝试打开文件进行读取时，可能会发生许多奇怪的事情！
- en: 'According to the Unix philosophy, the output of `tabSpace.go` will be printed
    on the screen and will not be saved in a new text file. Using `tabSpace.go` with
    `wc(1)` can prove its correctness:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Unix哲学，`tabSpace.go`的输出将打印在屏幕上，并且不会保存在新的文本文件中。使用`tabSpace.go`与`wc(1)`可以证明其正确性：
- en: '[PRE76]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Interprocess communication
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程间通信
- en: '**Interprocess communication** (**IPC**), putting it simply, is allowing Unix
    processes to talk to each other. Various techniques exist that allow processes
    and programs to talk to each other. The single most popular technique used in
    Unix systems is the pipe, which exists since the early Unix days. [Chapter *8*](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml),
    *Processes and Signals*, will talk more about implementing Unix pipes in Go. Another
    form of IPC is Unix domain sockets, which will also be discussed in [Chapter *8*](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml),
    *Processes and Signals*.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**），简单地说，就是允许Unix进程相互通信。存在各种技术允许进程和程序相互通信。在Unix系统中使用最广泛的技术是管道，自早期Unix以来就存在。[第8章](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)，*进程和信号*，将更多地讨论如何在Go中实现Unix管道。另一种IPC形式是Unix域套接字，也将在[第8章](defd267a-724b-4983-a51f-7cda6bba93aa.xhtml)，*进程和信号*中讨论。'
- en: '[Chapter *12*](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml), *Network Programming*,
    will talk about another form of Interprocess communication, which is network sockets.
    Shared memory also exists, but Go is against the use of shared memory as a means
    of communication. [Chapter *9*](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml), *Goroutines
    - Basic Features*, and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml),
    *Goroutines - Advanced Features*, will show various techniques that allow goroutines
    to communicate with others and share and exchange data.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)，*网络编程*，将讨论另一种进程间通信形式，即网络套接字。共享内存也存在，但Go反对使用共享内存作为通信手段。[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)，*Goroutines
    - 基本特性*，和[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)，*Goroutines - 高级特性*，将展示允许goroutines与其他goroutines通信并共享和交换数据的各种技术。'
- en: Sparse files in Go
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的稀疏文件
- en: Large files that are created with the `os.Seek()` function may have holes in
    them and occupy fewer disk blocks than files with the same size, but without holes
    in them; such files are called sparse files. This section will develop a program
    that creates sparse files.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`os.Seek()`函数创建的大文件可能存在空洞，并且占用的磁盘块比没有空洞的相同大小的文件少；这样的文件称为稀疏文件。本节将开发一个创建稀疏文件的程序。
- en: 'The Go code of `sparse.go` will be presented in three parts. The first part
    is the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse.go`的Go代码将分为三部分呈现。第一部分如下：'
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The second part of `sparse.go` has the following Go code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`sparse.go`的第二部分包含以下Go代码：'
- en: '[PRE78]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `strconv.ParseInt()` function is used for converting the command-line argument
    that defines the size of the sparse file from its string value to its integer
    value. Additionally, the `os.Stat()` call makes sure that you will not accidentally
    overwrite an existing file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`strconv.ParseInt()`函数用于将定义稀疏文件大小的命令行参数从其字符串值转换为其整数值。此外，`os.Stat()`调用确保您不会意外覆盖现有文件。'
- en: 'The last part is where the action takes place:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是发生操作的地方：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: First, you try to create the desired sparse file using `os.Create()`. Then,
    you call `fd.Seek()` in order to make the file bigger without adding actual data.
    Lastly, you write a byte to it using `fd.Write()`. As you do not have anything
    more to do with the file, you call `fd.Close()` and you are done.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您尝试使用`os.Create()`创建所需的稀疏文件。然后，您调用`fd.Seek()`以使文件变大而不添加实际数据。最后，您使用`fd.Write()`向其写入一个字节。由于您没有其他事情要做，因此调用`fd.Close()`，完成操作。
- en: 'Executing `sparse.go` generates the following output:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`sparse.go`会生成以下输出：
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'How can you tell whether a file is a sparse file or not? You will learn this
    in a while, but first, let''s create some files:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何判断文件是否是稀疏文件？您将在一会儿学到这一点，但首先让我们创建一些文件：
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Note that some Unix variants will not create sparse files: the first such Unix
    variant that comes to mind is macOS that uses the HFS filesystem. Therefore, for
    better results, you can execute all these commands on a Linux machine.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些Unix变体将不会创建稀疏文件：我想到的第一个这样的Unix变体是使用HFS文件系统的macOS。因此，为了获得更好的结果，您可以在Linux机器上执行所有这些命令。
- en: 'So, how can you tell if any of these three files is a sparse file or not? The
    `-s` flag of the `ls(1)` utility shows the number of filesystem blocks actually
    used by a file. So, the output of the `ls -ls` command allows you to detect if
    you are dealing with a sparse file or not:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何判断这三个文件中的任何一个是否是稀疏文件？`ls(1)`实用程序的`-s`标志显示文件实际使用的文件系统块数。因此，`ls -ls`命令的输出允许您检测是否正在处理稀疏文件：
- en: '[PRE82]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now look at the first column of the output. The `noSparseDD` file, which was
    generated using the `dd(1)` utility, is not a sparse file. The `sparseDD` file
    is a sparse file generated using the `dd(1)` utility. Lastly, the `testSparse`
    is also a sparse file that was created using `sparse.go`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看输出的第一列。使用`dd(1)`实用程序生成的`noSparseDD`文件不是稀疏文件。`sparseDD`文件是使用`dd(1)`实用程序生成的稀疏文件。最后，`testSparse`也是使用`sparse.go`创建的稀疏文件。
- en: Reading and writing data records
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入数据记录
- en: 'This section will teach you how to deal with writing and reading data records.
    What differentiates a record from other kinds of text data is that a record has
    a given structure with a specific number of fields: think of it as a row from
    a table in a relational database. Actually, records can be very useful for storing
    data in tables in case you want to develop your own database server in Go!'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将教你如何处理写入和读取数据记录。记录与其他类型的文本数据的不同之处在于记录具有特定数量的字段的给定结构：可以将其视为关系数据库中的表中的一行。实际上，如果你想在Go中开发自己的数据库服务器，记录可以非常有用来在表中存储数据！
- en: 'The Go code of `records.go` will save data in the CSV format and will be presented
    in four parts. The first part contains the following Go code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`records.go`的Go代码将以CSV格式保存数据，并将分为四个部分呈现。第一部分包含以下Go代码：'
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So, this is where you have to declare that you are going to read or write data
    in the CSV format. The second part is the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是你必须声明你要以CSV格式读取或写入数据的地方。第二部分如下：
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The third part of the program is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分如下：
- en: '[PRE85]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You should be familiar with the operations in this part; the biggest difference
    from what you have seen so far in this chapter is that the writer is from the
    `csv` package.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉这部分的操作；与本章迄今为止所见的最大不同之处在于写入器来自`csv`包。
- en: 'The last part of `records.go` has the following Go code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`records.go`的最后一部分包含以下Go代码：'
- en: '[PRE86]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `reader` reads the entire file at once to make the whole operation faster.
    However, if you are dealing with huge data files, you might need to read smaller
    parts of the file each time until you have read the complete file. The used `reader`
    is from the `csv` package.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader`一次性读取整个文件，以使整个操作更快。但是，如果你处理大型数据文件，你可能需要每次读取文件的较小部分，直到你读取完整个文件。使用的`reader`来自`csv`包。'
- en: 'Executing `records.go` will create the following output:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`records.go`将创建以下输出：
- en: '[PRE87]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The CSV file, which is named `recordsDataFile`, contains the following data:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`recordsDataFile`的CSV文件包含以下数据：
- en: '[PRE88]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: File locking in Go
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的文件锁定
- en: 'There are times that you do not want any other child of the same process to
    change a file or even access it because you are changing its data and you do not
    want the other processes to read incomplete or inconsistent data. Although you
    will learn more about file locking and go routines in [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml),
    *Goroutines - Basic Features* and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml),
    *Goroutines - Advanced Features*, this chapter will present a small Go example
    without a detailed explanation in order to give you an idea about how things work:
    you should wait until [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml),
    *Goroutines - Basic Features* and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml),
    *Goroutines - Advanced Features*, to learn more.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不希望同一进程的任何其他子进程更改文件甚至访问文件，因为你正在更改其数据，你不希望其他进程读取不完整或不一致的数据。尽管你将在[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)和[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)中学到更多关于文件锁定和go例程的知识，*Goroutines
    - 基本特性*和*Goroutines - 高级特性*，但本章将呈现一个简单的Go示例，没有详细的解释，以便让你了解事情是如何工作的：你应该等到[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)和[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)中学到更多。
- en: The presented technique will use `Mutex`, which is a general synchronization
    mechanism. The `Mutex` lock will allow us to lock a file from within the same
    Go process. As a result, this technique has nothing to do with the use of the
    `flock(2)` system call.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的技术将使用`Mutex`，这是一种通用的同步机制。`Mutex`锁将允许我们从同一Go进程中锁定文件。因此，这种技术与使用`flock(2)`系统调用无关。
- en: Various techniques exist for file locking. One of them is by creating an additional
    file that signifies that another program or process is using a given resource.
    The presented technique is more suitable for programs that use multiple go routines.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 存在各种文件锁定技术。其中之一是通过创建一个额外的文件来表示另一个程序或进程正在使用给定的资源。所呈现的技术更适用于使用多个go例程的程序。
- en: 'The file locking technique for writing will be illustrated in `fileLocking.go`,
    which will be presented in four parts. The first part is the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 写入的文件锁定技术将在`fileLocking.go`中进行演示，该文件将分为四个部分呈现。第一部分如下：
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The second part is the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE90]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The locking of the file is done using the `mu.Lock()` statement and the unlocking
    of the file with the `mu.Unlock()` statement.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mu.Lock()`语句锁定文件，使用`mu.Unlock()`语句解锁文件。
- en: 'The third part is the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分如下：
- en: '[PRE91]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The last part is the following Go code:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是以下Go代码：
- en: '[PRE92]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Executing `fileLocking.go` will create the following output:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`fileLocking.go`将创建以下输出：
- en: '[PRE93]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The correct version of `fileLocking.go` has a call to `mu.Unlock()` at the
    end of the `writeDataToFile()` function, which allows all goroutines to use the
    file. If you remove that call to `mu.Unlock()` from the `writeDataToFile()` function,
    and execute `fileLocking.go`, you will get the following output:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的`fileLocking.go`在`writeDataToFile()`函数的末尾调用了`mu.Unlock()`，这允许所有goroutines使用该文件。如果你从`writeDataToFile()`函数中删除对`mu.Unlock()`的调用，并执行`fileLocking.go`，你将得到以下输出：
- en: '[PRE94]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The reason for getting this output is that apart from the first goroutine that
    will be able to execute the `mu.Lock()` statement, the rest of them cannot get
    `Mutex`. Therefore, they cannot write to the file, which means that they will
    never finish their jobs and wait forever, which is the reason that Go is generating
    the aforementioned error messages.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 得到这个输出的原因是，除了第一个goroutine能够执行`mu.Lock()`语句之外，其他的都无法获得`Mutex`。因此，它们无法写入文件，这意味着它们永远无法完成工作并永远等待，这就是Go生成上述错误消息的原因。
- en: If you do not completely understand this example, you should wait until [Chapter
    9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml), *Goroutines - Basic Features*
    and [Chapter 10](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml), *Goroutines - Advanced
    Features*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这个例子不完全理解，您应该等到[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)，“Goroutines
    - Basic Features”和[第10章](7926b940-94d5-4525-a6be-19e7acc64c05.xhtml)，“Goroutines
    - Advanced Features”。
- en: A simplified Go version of the dd utility
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`dd`实用程序的简化版Go版本'
- en: 'The `dd(1)` tool can do many things, but this section will implement a small
    part of its functionality. Our version of `dd(1)` will include support for two
    command-line flags: one for specifying the block size in bytes (`-bs`) and the
    other for specifying the total number of blocks that will be written (`-count`).
    Multiplying these two values will give you the size of the generated file in bytes.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd(1)`工具可以做很多事情，但本节将实现其功能的一小部分。我们的`dd(1)`版本将包括对两个命令行标志的支持：一个用于指定以字节为单位的块大小（`-bs`），另一个用于指定将要写入的块的总数（`-count`）。将这两个值相乘将给出生成文件的大小（以字节为单位）。'
- en: 'The Go code is saved as `ddGo.go` and will be presented to you in four parts.
    The first part is the expected preamble:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Go代码保存为`ddGo.go`，将分为四部分呈现给您。第一部分是预期的序言：
- en: '[PRE95]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The second part contains the Go code of two functions:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含两个函数的Go代码：
- en: '[PRE96]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The first function is for getting random numbers and the second one is for creating
    a byte slice with the desired size filled with random numbers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数是用于获取随机数的，第二个函数是用于创建一个带有所需大小的随机数填充的字节片。
- en: 'The third part of `ddGo.go` is the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`ddGo.go`的第三部分如下：'
- en: '[PRE97]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, you mainly deal with the command-line arguments of the program.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您主要处理程序的命令行参数。
- en: 'The last part is the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分如下：
- en: '[PRE98]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The reason for emptying the `buf` byte slice each time you want to call `createBytes()`
    is that you do not want the `buf` byte slice to get bigger and bigger each time
    you call the `createBytes()` function. This happens because the `append()` function
    adds data at the end of a slice without touching the existing data.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`createBytes()`时清空`buf`字节片的原因是，您不希望`buf`字节片每次调用`createBytes()`函数时都变得越来越大。这是因为`append()`函数会在不触及现有数据的情况下在切片的末尾添加数据。
- en: In the first version of `ddGo.go` that I wrote, I forgot to empty the `buf`
    byte slice before each call to `createBytes()`. Consequently, the generated files
    were bigger than expected! It took me a while and a couple of `fmt.Println(buf)`
    statements to find out the reason for this unforeseen behavior!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写的`ddGo.go`的第一个版本中，我忘记在每次调用`createBytes()`之前清空`buf`字节片。因此，生成的文件比预期的要大！我花了一段时间和几个`fmt.Println(buf)`语句才找到这种意外行为的原因！
- en: 'The execution of `ddGo.go` will generate the files you want quite fast:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`ddGo.go`将快速生成您想要的文件：
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Additionally, the use of random numbers makes the generated files of the same
    size different from each other:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用随机数使得生成的文件大小彼此不同：
- en: '[PRE100]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Exercises
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Visit the documentation page of the `bufio` package that can be found at [https://golang.org/pkg/bufio/](https://golang.org/pkg/bufio/).
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://golang.org/pkg/bufio/](https://golang.org/pkg/bufio/)上的`bufio`包的文档页面。
- en: Visit the documentation of the `io` package at [https://golang.org/pkg/io/](https://golang.org/pkg/io/).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://golang.org/pkg/io/](https://golang.org/pkg/io/)上的`io`包的文档。
- en: Try to make `wc.go` faster.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使`wc.go`更快。
- en: Implement the functionality of `tabSpace.go`, but try to read your input text
    files character by character instead of line by line.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`tabSpace.go`的功能，但尝试逐个字符而不是逐行读取输入文本文件。
- en: Change the code of `tabSpace.go` in order to be able to get the number of spaces
    that will replace a tab as a command-line argument.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`tabSpace.go`的代码，以便能够将替换制表符的空格数作为命令行参数。
- en: Learn more information about the little endian and the big endian representations.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解有关小端和大端表示的更多信息。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about file input and output in Go. Among other things,
    we developed Go versions of the `wc(1)`, `dd(1)`, and `cp(1)` Unix command-line
    utilities while learning more about the `io` and `bufio` packages of the Go standard
    library, which allow you to read from and write to files.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Go中的文件输入和输出。在其他事情中，我们开发了`wc(1)`，`dd(1)`和`cp(1)` Unix命令行实用程序的Go版本，同时更多地了解了Go标准库的`io`和`bufio`包，它们允许您从文件中读取和写入。
- en: In the next chapter, we will talk about another important subject, which is
    the Go way of working with the system files of a Unix machine. Additionally, you
    will learn how to read and change the Unix file permissions as well as how to
    find the owner and the group of a file. Also, we will talk about log files and
    how you can use pattern matching to acquire the information you want from log
    files.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论另一个重要主题，即Go如何处理Unix机器的系统文件的方式。此外，您将学习如何读取和更改Unix文件权限，以及如何找到文件的所有者和组。此外，我们将讨论日志文件以及如何使用模式匹配从日志文件中获取所需的信息。
