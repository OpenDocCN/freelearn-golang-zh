- en: Processes and Signals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和信号
- en: In the previous chapter, we talked about many interesting topics including working
    with Unix system files, dealing with dates and times in Go, finding information
    about file permissions and users as well as regular expressions and pattern matching.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了许多有趣的主题，包括处理Unix系统文件，处理Go中的日期和时间，查找有关文件权限和用户的信息，以及正则表达式和模式匹配。
- en: The central subject of this chapter is developing Go applications that can handle
    the Unix signals that can be caught and handled. Go offers the `os/signal` package
    for dealing with signals, which uses Go channels. Although channels are fully
    explored in the next chapter, this will not stop you from learning how to work
    with Unix signals in Go programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的核心主题是开发能够处理Unix信号的Go应用程序。Go提供了`os/signal`包来处理信号，它使用Go通道。尽管通道在下一章中得到了充分的探讨，但这并不妨碍你学习如何在Go程序中处理Unix信号。
- en: 'Furthermore, you will learn how to create Go command-line utilities that can
    work with Unix pipes, how to draw bar charts in Go, and how to implement a Go
    version of the `cat(1)` utility. So, in this chapter you will learn about the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你将学习如何创建可以与Unix管道一起工作的Go命令行实用程序，如何在Go中绘制条形图，以及如何实现`cat(1)`实用程序的Go版本。因此，在本章中，你将学习以下主题：
- en: Listing the processes of a Unix machine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出Unix机器的进程
- en: Signal handling in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的信号处理
- en: The signals that a Unix machine supports as well as how to use the `kill(1)`
    command to send these signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix机器支持的信号以及如何使用`kill(1)`命令发送这些信号
- en: Making signals do the work you want
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让信号做你想要的工作
- en: Implementing a simple version of the `cat(1)` utility in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中实现`cat(1)`实用程序的简单版本
- en: Plotting data in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中绘制数据
- en: Using pipes in order to send the output of one program to another
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道将一个程序的输出发送到另一个程序
- en: Converting a big program into two smaller ones that will cooperate with the
    help of Unix pipes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个大程序转换为两个较小的程序，它们将通过Unix管道协作
- en: Creating a client for a Unix socket
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Unix套接字创建一个客户端
- en: About Unix processes and signals
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Unix进程和信号
- en: Strictly speaking, a **process** is an execution environment that contains instructions,
    user-data and system-data parts, and other kinds of resources that are obtained
    during runtime, whereas a **program** is a file that contains instructions and
    data, which are used for initializing the instruction and user-data parts of a
    process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，**进程**是包含指令、用户数据和系统数据部分以及在运行时获得的其他类型资源的执行环境，而**程序**是一个包含指令和数据的文件，用于初始化进程的指令和用户数据部分。
- en: Process management
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程管理
- en: Go is not that good at dealing with processes and process management in general.
    Nevertheless, this section will present a small Go program that lists all the
    processes of a Unix machine by executing a Unix command and getting its output.
    The name of the program will be `listProcess.go`. It works on both Linux and macOS
    systems, and will be presented in three parts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Go在处理进程和进程管理方面并不那么擅长。尽管如此，本节将介绍一个小的Go程序，通过执行Unix命令并获取其输出来列出Unix机器的所有进程。程序的名称将是`listProcess.go`。它适用于Linux和macOS系统，并将分为三个部分。
- en: 'The first part of the program is the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second part of `listProcess.go` has the following Go code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`listProcess.go`的第二部分包含以下Go代码：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, you first need to get the path of the executable file using
    `exec.LookPath()` to make sure that you are not going to accidentally execute
    another binary file and then define the command you want to execute, including
    the parameters of the command, using a slice. Next, you will have to read the
    Unix environment using `os.Environ()`. Also, you execute the desired command using
    `syscall.Exec()`, which will automatically print its output, which is not a very
    elegant way to execute commands because you have no control over the task and
    because you are calling processes at the lowest level instead of using a higher
    level library such as `os/exec`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你首先需要使用`exec.LookPath()`获取可执行文件的路径，以确保你不会意外地执行另一个二进制文件，然后使用切片定义你想要执行的命令，包括命令的参数。接下来，你将需要使用`os.Environ()`读取Unix环境。此外，你可以使用`syscall.Exec()`执行所需的命令，它将自动打印其输出，这并不是一个非常优雅的执行命令的方式，因为你无法控制任务，并且因为你是在最低级别调用进程，而不是使用更高级别的库，比如`os/exec`。
- en: 'The last part of the program is for printing the error message of the previous
    code, in case there is one:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分是用于打印前面代码的错误消息，如果有的话：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Executing `listProcess.go` will generate the following output: the `head(1)`
    utility is used to get a smaller output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`listProcess.go`将生成以下输出：使用`head(1)`实用程序来获取较小的输出：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: About Unix signals
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Unix信号
- en: Have you ever pressed *Ctrl* + *C* in order to stop a program from running?
    If yes, then you are already familiar with signals because *Ctrl* + *C* sends
    the `SIGINT` signal to the program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经按下*Ctrl* + *C*来停止程序运行？如果是的话，那么你已经熟悉信号，因为*Ctrl* + *C*会向程序发送`SIGINT`信号。
- en: Strictly speaking, Unix **signals** are software interrupts that can be accessed
    either by a name or number and offer a way of handling asynchronous events such
    as when a child process exits or a process is told to pause on a Unix system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Unix**信号**是可以通过名称或数字访问的软件中断，提供了处理异步事件的方式，例如当子进程退出或在Unix系统上暂停进程时。
- en: A program cannot handle all signals; some of them are non-catchable and non-ignorable.
    The `SIGKILL` and `SIGSTOP` signals cannot be caught, blocked, or ignored. The
    reason for this is that they provide the kernel and the root user a way of stopping
    any process. The `SIGKILL` signal, which is also known by the number 9, is usually
    called in extreme conditions where you need to act fast; so, it is the only signal
    that is usually called by number because it is quicker to do so. The most important
    thing to remember here is that not all Unix signals can be handled!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 程序无法处理所有信号；其中一些信号是不可捕获和不可忽略的。`SIGKILL`和`SIGSTOP`信号无法被捕获、阻塞或忽略。原因是它们为内核和root用户提供了一种停止任何进程的方式。`SIGKILL`信号，也称为数字9，通常在需要迅速采取行动的极端情况下调用；因此，它通常按数字调用，因为这样做更快。在这里要记住的最重要的事情是，并非所有的Unix信号都可以被处理！
- en: Unix signals in Go
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的Unix信号
- en: Go provides the `os/signal` package to programmers to help them handle incoming
    signals. However, we will start the discussion about handling by presenting the
    `kill(1)` utility.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go为程序员提供了`os/signal`包，以帮助他们处理传入的信号。但是，我们将从介绍`kill（1）`实用程序开始讨论处理。
- en: The kill(1) command
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kill（1）命令
- en: The `kill(1)` command is used for either terminating a process or sending a
    less cruel signal to it. Keep in mind that the fact that you can send a signal
    to a process does not mean that the process can or has code to handle this signal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill（1）`命令用于终止进程或向其发送一个不那么残酷的信号。请记住，您可以向进程发送信号并不意味着该进程可以或者有代码来处理此信号。'
- en: 'By default, `kill(1)` sends the `SIGTERM` signal. If you want to find out all
    the supported signals of your Unix machine, you should execute the `kill -l` command.
    On a macOS Sierra machine, the output of `kill -l` is the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`kill（1）`发送`SIGTERM`信号。如果要查找Unix机器支持的所有信号，应执行`kill -l`命令。在macOS Sierra机器上，`kill
    -l`的输出如下：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you execute the same command on a Debian Linux machine, you will get a more
    enriched output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Debian Linux机器上执行相同的命令，您将获得更丰富的输出：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you try to kill or send another signal to the process of another user without
    having the required permissions, which most likely will happen if you are not
    the *root* user, `kill(1)` will not do the job and you will get an error message
    similar to the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试杀死或向另一个用户的进程发送另一个信号而没有所需的权限，这很可能会发生，如果您不是*root*用户，`kill（1）`将无法完成任务，并且您将收到类似以下的错误消息：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A simple signal handler in Go
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的简单信号处理程序
- en: 'This subsection will present a naive Go program that handles only the `SIGTERM`
    and `SIGINT` signals. The Go code of `h1s.go` will be presented in three parts;
    the first part is the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将介绍一个简单的Go程序，仅处理`SIGTERM`和`SIGINT`信号。`h1s.go`的Go代码将分为三部分呈现；第一部分如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Apart from the preamble of the program, there is also a function named `handleSignal()`
    that will be called when the program receives any of the two supported signals.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了程序的序言之外，还有一个名为`handleSignal（）`的函数，当程序接收到两个支持的信号中的任何一个时，将调用该函数。
- en: 'The second part of `h1s.go` contains the following Go code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`h1s.go`的第二部分包含以下Go代码：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The previous code uses a **goroutine** and a Go **channel**, which are Go features
    that have not been discussed in this book. Unfortunately, you will have to wait
    until [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines -
    Basic Features*, to learn more about both of them. Note that although `os.Interrupt`
    and `syscall.SIGTERM` belong to different Go packages, they are both signals.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码使用了**goroutine**和Go**channel**，这是本书中尚未讨论的Go功能。不幸的是，您必须等到[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*，*
    *Goroutines - Basic Features*，才能了解更多关于它们的信息。请注意，尽管`os.Interrupt`和`syscall.SIGTERM`属于不同的Go包，但它们都是信号。
- en: 'For now, understanding the technique is important; it includes three steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，理解这种技术很重要；它包括三个步骤：
- en: The definition of a channel, which acts as a way of passing data around, that
    is required for the technique (`sigs`).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通道的定义，作为传递数据的方式，对于技术（`sigs`）是必需的。
- en: Calling `signal.Notify()` in order to define the list of signals you want to
    be able to catch.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`signal.Notify（）`以定义您希望能够捕获的信号列表。
- en: The definition of an anonymous function that runs in a goroutine (`go func()`)
    right after `signal.Notify()`, which is used for deciding what you are going to
    do when you get any of the desired signals.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个匿名函数，它在`signal.Notify（）`之后的goroutine（`go func（）`）中运行，用于决定在收到所需信号时要执行的操作。
- en: In this case, the `handleSignal()` function will be called. The `for` loop inside
    the anonymous function is used to make the program to keep handling all signals
    and not stop after receiving its first signal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将调用`handleSignal（）`函数。匿名函数内部的`for`循环用于使程序保持处理所有信号，并在接收到第一个信号后不停止。
- en: 'The last part of `h1s.go` is the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`h1s.go`的最后部分如下：'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is an endless `for` loop that delays the ending of the program forever:
    in its place you would most likely put the actual code of your program. Executing
    `h1s.go` and sending signals to it from another Terminal will make `h1s.go` generate
    the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无限的`for`循环，它永远延迟程序的结束：在其位置上，您很可能会放置程序的实际代码。执行`h1s.go`并从另一个终端向其发送信号将使`h1s.go`生成以下输出：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The bad thing here is that `h1s.go` will stop when it receives the `SIGHUP`
    signal because the default action for `SIGHUP` when it is not being specifically
    handled by a program is to kill the process! The next subsection will show how
    to handle three signals in a better way, and the subsection after that will teach
    you how to handle all signals that can be handled.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的坏处是，当接收到`SIGHUP`信号时，`h1s.go`将停止，因为当程序没有专门处理`SIGHUP`时，默认操作是杀死进程！下一小节将展示如何更好地处理三个信号，之后的小节将教您如何处理所有可处理的信号。
- en: Handling three different signals!
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理三种不同的信号！
- en: 'This subsection will teach you how to create a Go application that can handle
    three different signals: the name of the program will be `h2s.go`, and it will
    handle the `SIGTERM`, `SIGINT`, and `SIGHUP` signals.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节将教您如何创建一个可以处理三种不同信号的Go应用程序：程序的名称将是`h2s.go`，它将处理`SIGTERM`、`SIGINT`和`SIGHUP`信号。
- en: The Go code of `h2s.go` will be presented in four parts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`h2s.go`的Go代码将分为四部分呈现。'
- en: 'The first part of the program contains the expected preamble:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分包含了预期的序言：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second part has the following Go code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含以下Go代码：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the last statement tells you that the program will only handle the `os.Interrupt`,
    `syscall.SIGTERM`, and `syscall.SIGHUP` signals.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最后一句告诉您，程序只会处理`os.Interrupt`、`syscall.SIGTERM`和`syscall.SIGHUP`信号。
- en: 'The third part of `h2s.go` is the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`h2s.go`的第三部分如下：'
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you can see that it is not compulsory to call a separate function when
    a given signal is caught; it is also allowed to handle it inside the `for` loop
    as it happens with `syscall.SIGHUP`. However, I find the use of a named function
    better because it makes the Go code easier to read and modify. The good thing
    is that Go has a central place for handling all signals, which makes it easy to
    find out what is going on with your program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到，当捕获到特定信号时，不一定要调用单独的函数；也可以在`for`循环内处理它，就像`syscall.SIGHUP`一样。但是，我认为使用命名函数更好，因为它使Go代码更易于阅读和修改。好处是Go有一个处理所有信号的中心位置，这使得很容易找出程序的运行情况。
- en: Additionally, `h2s.go` specifically handles the `SIGHUP` signal, although a
    `SIGHUP` signal will still terminate the program; however, this time this is our
    decision.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`h2s.go`专门处理`SIGHUP`信号，尽管`SIGHUP`信号仍将终止程序；但是，这次是我们的决定。
- en: Keep in mind that it is considered good practice to make one of the signal handlers
    to stop the program because otherwise you will have to terminate it by issuing
    a `kill -9` command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常最好让一个信号处理程序来停止程序，否则您将不得不通过发出`kill -9`命令来终止它。
- en: 'The last part of `h2s.go` is the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`h2s.go`的最后一部分如下：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Executing `h2s.go` and sending four signals to it (`SIGINT`, `SIGTERM`, `SIGHUP`,
    and `SIGKILL`) from another shell will generate the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`h2s.go`并从另一个shell发送四个信号（`SIGINT`、`SIGTERM`、`SIGHUP`和`SIGKILL`）给它将生成以下输出：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The reason for building `h2s.go` is that it is easier to find the process ID
    of an autonomous program: the `go run` command builds a temporary executable program
    behind the scenes, which in this case offers less flexibility. If you want to
    improve `h2s.go`, you can make it call `os.Getpid()` in order to print its process
    ID, which will save you from having to find it on your own.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`h2s.go`的原因是更容易找到自主程序的进程ID：`go run`命令在后台构建了一个临时可执行程序，这种情况下提供的灵活性较少。如果要改进`h2s.go`，可以让它调用`os.Getpid()`来打印其进程ID，这样就不必自己查找了。
- en: The program handles three signals before getting a `SIGKILL` that cannot be
    handled and therefore terminates it!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在收到无法处理的`SIGKILL`信号之前处理了三个信号，因此终止了！
- en: Catching every signal that can be handled
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获每个可以处理的信号
- en: 'This subsection will present a simple technique that allows you to catch every
    signal that can be handled: once again, you should keep in mind that you cannot
    handle all signals! The program will stop once it gets a `SIGTERM` signal.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这一小节将介绍一种简单的技术，允许您捕捉每个可以处理的信号：再次强调，您不能处理所有信号！程序将在收到`SIGTERM`信号后停止运行。
- en: The name of the program will be `catchAll.go` and will be presented in three
    parts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的名称将是`catchAll.go`，将分为三部分呈现。
- en: 'The first part is the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second part of the program is the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this case, all the difference is made by the way you call `signal.Notify()`
    in your code. As you do not define any particular signals, the program will be
    able to handle any signal that can be handled. However, the `for` loop inside
    the anonymous function only takes care of three signals while ignoring the remaining
    ones! Note that I believe that this is the best way to handle signals in Go: catch
    everything while processing only the signals that interest you. However, some
    people believe that being explicit about what you handle is a better approach.
    There is no right or wrong here.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用`signal.Notify()`的方式对您的代码产生了影响。如果您没有定义任何特定的信号，程序将能够处理任何可以处理的信号。但是，匿名函数内的`for`循环只处理了三个信号，而忽略了其余的！请注意，我认为这是在Go中处理信号的最佳方式：捕获一切，同时只处理您感兴趣的信号。但是，有些人认为明确处理您处理的内容是更好的方法。这里没有对错之分。
- en: The `catchAll.go` program will not terminate when it gets `SIGHUP` because the
    `default` case of the `switch` block handles it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`catchAll.go`程序在收到`SIGHUP`时不会终止，因为`switch`块的`default`情况处理了它。'
- en: 'The last part is the expected call to the `time.Sleep()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是对`time.Sleep()`函数的预期调用：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Executing `catchAll.go` will create the following output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`catchAll.go`将产生以下输出：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rotating log files revisited!
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视旋转日志文件！
- en: As I told you back in [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*,*
    *Working with System Files*, this chapter will present you with a technique that
    will allow you to end the program and rotate log files in a more conventional
    way with the help of signals and signal handling.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第7章](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)中告诉过您，本章将向您介绍一种技术，可以让您以更常规的方式结束程序并旋转日志文件，这是通过信号和信号处理来实现的。
- en: The name of the new version of `rotateLog.go` will be `rotateSignals.go` and
    will be presented in four parts. Moreover, when the utility receives `os.Interrupt`,
    it will rotate the current log file, whereas when it receives `syscall.SIGTERM`,
    it will terminate its execution. Every other signal that can be handled will create
    a log entry without any other action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotateLog.go`的新版本名称将是`rotateSignals.go`，将分为四个部分呈现。此外，当实用程序接收`os.Interrupt`时，它将旋转当前日志文件，而当它接收`syscall.SIGTERM`时，它将终止执行。可以处理的任何其他信号都将创建一个日志条目，而不会执行其他操作。'
- en: 'The first part of the `rotateSignals.go` is the expected preamble:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotateSignals.go`的第一部分是预期的序言：'
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The second part of `rotateSignals.go` has the following Go code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotateSignals.go`的第二部分包含以下Go代码：'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You have just defined two functions here that perform two tasks. The third
    part of `rotateSignals.go` contains the following Go code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚在这里定义了两个执行两项任务的函数。`rotateSignals.go`的第三部分包含以下Go代码：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once again, all signals will be caught. The last part of `rotateSignals.go`
    is the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，所有信号都将被捕获。`rotateSignals.go`的最后一部分如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, `rotateSignals.go` records information about the signals it
    has received by writing one log entry for each signal. Although presenting the
    entire code of `rotateSignals.go` is good, it would be very educational to see
    the output of the `diff(1)` utility to show the code differences between `rotateLog.go`
    and `rotateSignals.go`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`rotateSignals.go`通过为每个信号编写一个日志条目记录了它接收到的信号的信息。虽然呈现`rotateSignals.go`的整个代码是不错的，但是看到`diff(1)`实用程序的输出以显示`rotateLog.go`和`rotateSignals.go`之间的代码差异将是非常有教育意义的：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The good thing here is that the use of signals in `rotateSignals.go` makes most
    of the global variables used in `rotateLog.go` unnecessary because you can now
    control the utility by sending signals. Additionally, the design and the structure
    of `rotateSignals.go` are simpler than `rotateLog.go` because you only have to
    understand what the anonymous function does.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处是，在`rotateSignals.go`中使用信号使得`rotateLog.go`中使用的大多数全局变量变得不必要，因为现在您可以通过发送信号来控制实用程序。此外，`rotateSignals.go`的设计和结构比`rotateLog.go`更简单，因为您只需要理解匿名函数的功能。
- en: 'After executing `rotateSignals.go` and sending some signals to it, the contents
    of `/tmp/myLog.log` will look like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`rotateSignals.go`并向其发送一些信号后，`/tmp/myLog.log`的内容将如下所示：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Additionally, you will have the following files inside `/tmp`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将在`/tmp`目录下有以下文件：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Improving file copying
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进文件复制
- en: 'The original `cp(1)` utility prints useful information when it receives a `SIGINFO`
    signal, as shown in the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当`cp(1)`实用程序接收`SIGINFO`信号时，它会打印有用的信息，如下所示：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, the rest of this section will implement the same functionality to the Go
    implementation of the `cp(1)` command. The Go code in this section will be based
    on the `cp.go` program because it can be very slow when used with a small buffer
    size giving us time for testing. The name of the new copy utility will be `cpSignal.go`
    and will be presented in four parts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节的其余部分将为`cp(1)`命令的Go实现实现相同的功能。本节中的Go代码将基于`cp.go`程序，因为当使用较小的缓冲区大小时，它可能非常慢，从而为我们提供测试时间。新的复制实用程序的名称将是`cpSignal.go`，将分为四个部分呈现。
- en: The fundamental difference between `cpSignal.go` and `cp.go` is that `cpSignal.go`
    should find the size of the input file and keep the number of bytes that have
    been written at a given point. Apart from those modifications there is nothing
    else that you should worry about because the core functionality of the two versions,
    which is copying a file, is exactly the same.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpSignal.go`和`cp.go`之间的基本区别在于`cpSignal.go`应该找到输入文件的大小，并在给定点保持已写入的字节数。除了这些修改之外，您不必担心其他任何事情，因为两个版本的核心功能，即复制文件，完全相同。'
- en: 'The first part of the program is the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In order to make things simpler for the developer, the program introduces two
    global variables called `FILESIZE` and `BYTESWRITTEN` and these keep the size
    of the input file and the number of bytes that have been written, respectively.
    Both variables are used by the function that handles the `SIGINFO` signal.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使开发人员更容易，程序引入了两个名为`FILESIZE`和`BYTESWRITTEN`的全局变量，它们分别保持输入文件的大小和已写入的字节数。这两个变量都被处理`SIGINFO`信号的函数使用。
- en: 'The second part is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, you use the `sourceFileStat.Size()` function to get the size of the input
    file and set the value of the `FILESIZE` global variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用`sourceFileStat.Size()`函数获取输入文件的大小，并设置`FILESIZE`全局变量的值。
- en: 'The third part is where you define the signal handling:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是您定义信号处理的地方：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, you choose to catch all signals. However, the Go code of the anonymous
    function will only call `progressInfo()` after receiving a `syscall.SIGINFO` signal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您选择捕获所有信号。但是，匿名函数的Go代码只会在接收到`syscall.SIGINFO`信号后调用`progressInfo()`。
- en: 'If you want to have a way of gracefully terminating the program, you might
    want to use the `SIGINT` signal because when capturing all signals, gracefully
    terminating a program is no longer possible: you will need to send a `SIGKILL`
    in order to terminate your program, which is a little cruel.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一种优雅地终止程序的方法，您可能希望使用`SIGINT`信号，因为当捕获所有信号时，优雅地终止程序将不再可能：您将需要发送`SIGKILL`来终止程序，这有点残酷。
- en: 'The last part of `cpSignal.go` is the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpSignal.go`的最后一部分如下：'
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Executing `cpSignal.go` and sending two `SIGINFO` signals to it will generate
    the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`cpSignal.go`并向其发送两个`SIGINFO`信号将生成以下输出：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Plotting data
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制数据
- en: The utility that will be developed in this section will read multiple log files
    and will create a graphical image with as many bars as the number of log files
    read. Each bar will represent the number of times a given IP address has been
    found in a log file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将开发一个实用程序，它将读取多个日志文件，并将创建一个图像，其中每个条将表示在日志文件中找到给定IP地址的次数。
- en: 'However, the Unix philosophy tells us that instead of developing a single utility,
    we should make two distinct utilities: one for processing the log files and creating
    a report and another for plotting the data generated by the first utility: the
    two utilities will communicate using Unix pipes. Although this section will implement
    the first approach, you will see the implementation of the second approach later
    in *The * `plotIP.go` *utility revisited* section of this chapter.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Unix哲学告诉我们，我们应该制作两个不同的实用程序，而不是开发一个单一的实用程序：一个用于处理日志文件并创建报告，另一个用于绘制第一个实用程序生成的数据：这两个实用程序将使用Unix管道进行通信。尽管本节将实现第一种方法，但您将在本章的*The *
    `plotIP.go` *utility revisited*部分中看到第二种方法的实现。
- en: 'The idea for the presented utility came from a tutorial that I wrote for a
    magazine where I developed a small Go program that did some plotting: even small
    and naive programs can inspire you to develop bigger things, so do not underestimate
    their power.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所提供实用程序的想法来自我为一本杂志撰写的教程，我在其中开发了一个小型的Go程序进行绘图：即使是小型和天真的程序也可以激发您开发更大的东西，因此不要低估它们的力量。
- en: 'The name of the utility will be `plotIP.go`, and it will be presented in seven
    parts: the good thing is that `plotIP.go` will reuse some of the code of `countIP.go`
    and `findIP.go`. The only thing that `plotIP.go` does not do is writing text to
    the image, so you can only plot the bars without knowing the actual values or
    the corresponding log file of a particular bar: you can try to add text capabilities
    to the program as an exercise.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的名称将是`plotIP.go`，并且将分为七个部分：好处是`plotIP.go`将重用`countIP.go`和`findIP.go`的一些代码。`plotIP.go`唯一不做的事情就是将文本写入图像，因此您只能绘制条形图，而不知道实际值或特定条形图的相应日志文件：您可以尝试将文本功能添加到程序中作为练习。
- en: 'Also, `plotIP.go` will require at least three parameters, which are the width
    and height of the image and the name of the log file that will be used: in order
    to make `plotIP.go` smaller, `plotIP.go` will not use the `flag` package and assume
    that you will give its parameters in the correct order. If you give it more parameters,
    it will consider them as log files.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`plotIP.go`将需要至少三个参数，即图像的宽度和高度以及将要使用的日志文件的名称：为了使`plotIP.go`更小，`plotIP.go`将不使用`flag`包，并假定您将按正确的顺序提供其参数。如果您提供更多的参数，它将把它们视为日志文件。
- en: 'The first part of `plotIP.go` is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotIP.go`的第一部分如下：'
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These global variables related to the dimensions of the image (`x` and `y`),
    the image as a Go variable (`m`), and the width of one of its bars (`barWidth`)
    that depends on the size of the image and the number of the bars that will be
    plotted. Note that using `x` and `y` as variable names instead of something like
    `IMAGEWIDTH` and `IMAGEHEIGHT` might be a little wrong and dangerous here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些全局变量与图像的尺寸（`x`和`y`）、图像作为Go变量（`m`）以及其中一个条形图的宽度（`barWidth`）有关，该宽度取决于图像的大小和将要绘制的条形图的数量。请注意，在这里使用`x`和`y`作为变量名而不是像`IMAGEWIDTH`和`IMAGEHEIGHT`之类的名称可能有点错误和危险。
- en: 'The second part is the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是以下内容：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, you implement a Go function named `plotBar()` that does the plotting of
    each bar, given its height, its width, and its color of the bar. This function
    is the most challenging part of `plotIP.go`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您实现了一个名为`plotBar()`的Go函数，该函数根据条形图的高度、宽度和颜色进行绘制。这个函数是`plotIP.go`中最具挑战性的部分。
- en: 'The third part has the following Go code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分包含以下Go代码：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This function lets you define the colors that will be present in the output:
    you can change them if you want.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许您定义输出中将出现的颜色：如果需要，可以更改它们。
- en: 'The fourth part contains the following Go code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分包含以下Go代码：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, you read the desired IP address, which is saved in the `WANTED` variable
    and you read the dimensions of the generated PNG image.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以读取所需的IP地址，该地址保存在`WANTED`变量中，并读取生成的PNG图像的尺寸。
- en: 'The fifth part contains the following Go code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第五部分包含以下Go代码：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, you process the input log files one by one and store the values you calculate
    in the `data` slice. Error messages are printed to `os.Stderr`: the main advantage
    you get from printing error messages to `os.Stderr` is that you can easily redirect
    error messages to a file while using data written to `os.Stdout` in a different
    way.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您逐个处理输入的日志文件，并将计算的值存储在`data`切片中。错误消息将打印到`os.Stderr`：从将错误消息打印到`os.Stderr`中获得的主要优势是，您可以轻松地将错误消息重定向到文件，同时以不同的方式使用写入到`os.Stdout`的数据。
- en: 'The sixth part of `plotIP.go` contains the following Go code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotIP.go`的第六部分包含以下Go代码：'
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, you calculate things about the plot and create the output image file using
    `os.OpenFile()`. The PNG file generated by the `plotIP.go` utility is named after
    the given IP address to make things simpler.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以计算有关绘图的事项，并使用`os.OpenFile()`创建输出图像文件。由`plotIP.go`实用程序生成的PNG文件以给定的IP地址命名，以使事情变得更简单。
- en: 'The last part of the Go code of `plotIP.go` is the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotIP.go`的Go代码的最后一部分如下：'
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, you read the values of the `data` slice and create a bar for each one
    of them by calling the `plotBar()` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以读取`data`切片的值，并通过调用`plotBar()`函数为每个值创建一个条形图。
- en: 'Executing `plotIP.go` will generate the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`plotIP.go`将生成以下输出：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, apart from the generated text output, what is important is the produced
    PNG file that can be seen in the following figure:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了生成的文本输出之外，重要的是生成的PNG文件，可以在以下图中看到：
- en: '![](img/0705a55e-044d-4918-bfea-70d6b7d9377e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0705a55e-044d-4918-bfea-70d6b7d9377e.png)'
- en: The output generated by the plotIP.go utility
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由plotIP.go实用程序生成的输出
- en: 'If you want to save the error messages to a different file, you can use a variation
    of the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将错误消息保存到不同的文件中，可以使用以下命令的变体：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following command discards all error messages by sending them to `/dev/null`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令通过将其发送到`/dev/null`来丢弃所有错误消息：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Unix pipes in Go
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中的Unix管道
- en: 'We first talked about pipes in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*. Pipes have two serious limitations: first, they usually
    communicate in one direction, and second, they can only be used between processes
    that have a common ancestor.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*，*文件输入和输出中首次讨论了管道。管道有两个严重的限制：首先，它们通常是单向通信的，其次，它们只能在具有共同祖先的进程之间使用。
- en: The general idea behind pipes is that if you do not have a file to process,
    you should wait to get your input from standard input. Similarly, if you are not
    told to save your output to a file, you should write your output to standard output,
    either for the user to see it or for another program to process it. As a result,
    pipes can be used for streaming data between two processes without creating any
    temporary files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 管道背后的一般思想是，如果您没有要处理的文件，应该等待从标准输入获取输入。同样，如果没有要求将输出保存到文件，应该将输出写入标准输出，供用户查看或供其他程序处理。因此，管道可用于在两个进程之间流式传输数据，而不创建任何临时文件。
- en: This section will present some simple utilities written in Go that use Unix
    pipes for clarity.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将呈现一些使用Unix管道编写的简单实用程序，以增加清晰度。
- en: Reading from standard input
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从标准输入读取
- en: The first thing that you need to know in order to develop Go applications that
    support Unix pipes is how to read from standard input.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发支持Unix管道的Go应用程序，您需要知道如何从标准输入读取。
- en: The developed program is named `readSTDIN.go` and will be presented in three
    parts.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开发的程序名为`readSTDIN.go`，将分为三部分呈现。
- en: 'The first part of the program is the expected preamble:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分是预期的序言：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second part of `readSTDIN.go` has the following Go code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`readSTDIN.go`的第二部分包含以下Go代码：'
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, you resolve whether you have an actual file to process, which can be determined
    by the number of the command-line arguments of your program. If you do not have
    a file to process, you will try to read data from `os.Stdin`. Make sure that you
    understand the presented technique because it will be used many times in this
    chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以确定是否有实际文件要处理，这可以通过程序的命令行参数数量来确定。如果没有要处理的文件，您将尝试从`os.Stdin`读取数据。确保您理解所呈现的技术，因为在本章中将多次使用它。
- en: 'The last part of `readSTDIN.go` is the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`readSTDIN.go`的最后一部分如下：'
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code is the same whether you are processing an actual file or `os.Stdin`,
    which happens because everything in Unix is a file. Note that the program output
    begins with the `>` character.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无论是处理实际文件还是`os.Stdin`都是一样的，这是因为在Unix中一切都是文件。请注意，程序输出以`>`字符开头。
- en: 'Executing `readSTDIN.go` will generate the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`readSTDIN.go`将生成以下输出：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the last case, `readSTDIN.go` echoes each line it reads because the input
    is read line by line: the `cat(1)` utility works the same way.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一种情况下，`readSTDIN.go`会回显它读取的每一行，因为输入是逐行读取的：`cat(1)`实用程序的工作方式相同。
- en: Sending data to standard output
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据发送到标准输出
- en: This subsection will show you how to send data to standard output in a better
    way than just using `fmt.Println()` or any other function from the `fmt` standard
    Go package. The Go program will be named `writeSTDOUT.go` and will be presented
    to you in three parts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将向您展示如何以比仅使用`fmt.Println()`或`fmt`标准Go包中的任何其他函数更好的方式将数据发送到标准输出。Go程序将被命名为`writeSTDOUT.go`，并将分为三部分呈现给您。
- en: 'The first part is the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second part of `writeSTDOUT.go` has the following Go code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeSTDOUT.go`的第二部分包含以下Go代码：'
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last part of `writeSTDOUT.go` is the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeSTDOUT.go`的最后一部分如下：'
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The only subtle thing is that you need to put your text into a slice before
    using `io.WriteString()` to write data to `os.Stdout`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一微妙的是，在使用`io.WriteString()`将数据写入`os.Stdout`之前，您需要将文本放入一个切片中。
- en: 'Executing `writeSTDOUT.go` will generate the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`writeSTDOUT.go`将生成以下输出：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implementing cat(1) in Go
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中实现cat(1)
- en: This subsection will present a Go version of the `cat(1)` command-line utility.
    If you give one or more command-line arguments to `cat(1)`, then `cat(1)` will
    print their contents on the screen. However, if you just type `cat(1)` on your
    Unix shell, then `cat(1)` will wait for your input, which will be terminated when
    you type *Ctrl* + *D*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将呈现`cat(1)`命令行实用程序的Go版本。如果您向`cat(1)`提供一个或多个命令行参数，那么`cat(1)`将在屏幕上打印它们的内容。但是，如果您只在Unix
    shell中键入`cat(1)`，那么`cat(1)`将等待您的输入，当您键入*Ctrl* + *D*时输入将终止。
- en: The name of the Go implementation will be `cat.go` and will be presented in
    three parts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Go实现的名称将是`cat.go`，将分为三部分呈现。
- en: 'The first part of `cat.go` is the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat.go`的第一部分如下：'
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The second part is the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `catFile()` function is called when the `cat.go` utility has to process
    real files. Having a function to do your job makes the design of the program better.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当`cat.go`实用程序需要处理真实文件时，将调用`catFile()`函数。有一个函数来完成您的工作可以使程序设计更好。
- en: 'The last part has the following Go code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, if the program has no arguments, then it assumes that it has to read `os.Stdin`.
    In that case, it just echoes each line you give to it. If the program has arguments,
    then it processes the first argument as a file using the `catFile()` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果程序没有参数，则假定它必须从`os.Stdin`读取。在这种情况下，它只会回显您给它的每一行。如果程序有参数，则它将使用`catFile()`函数处理第一个参数作为文件。
- en: 'Executing `cat.go` will generate the following output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`cat.go`将生成以下输出：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The plotIP.go utility revisited
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视plotIP.go实用程序
- en: As promised in a previous section of this chapter, this section will create
    two separate utilities, which when combined will implement the functionality of
    `plotIP.go`. Personally, I prefer to have two separate utilities and combine them
    when needed than having just one utility that does two or more tasks.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章的前一节所承诺的，本节将创建两个单独的实用程序，结合起来将实现`plotIP.go`的功能。个人而言，我更喜欢有两个单独的实用程序，并在需要时将它们结合起来，而不是只有一个实用程序可以执行两个或更多任务。
- en: The names of the two utilities will be `extractData.go` and `plotData.go`. As
    you can easily understand, only the second utility would have to be able to get
    input from standard input as long as the first utility prints its output on standard
    output either using `os.Stdout`, which is the correct way, or using `fmt.Println()`,
    which usually does the job.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个实用程序的名称将是`extractData.go`和`plotData.go`。正如您可以轻松理解的那样，只有第二个实用程序才能够从标准输入获取输入，只要第一个实用程序将其输出打印在标准输出上，要么使用`os.Stdout`，这是正确的方式，要么使用`fmt.Println()`，通常可以完成任务。
- en: 'I think that I should now tell you my little secret: I created `extractData.go`
    and `plotData.go` first and then developed `plotIP.go` because it is easier to
    develop two separate utilities than a bigger one that does everything! Additionally,
    the use of two different utilities allows you to filter the output of `extractData.go`
    using standard Unix utilities such as `tail(1)`, `sort(1)`, and `head(1)`, which
    means that you can modify your data in different ways without the need for writing
    any extra Go code.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我现在应该告诉您我的小秘密：我首先创建了`extractData.go`和`plotData.go`，然后开发了`plotIP.go`，因为开发两个单独的实用程序比开发一个做所有事情的大型实用程序更容易！此外，使用两个不同的实用程序允许您使用标准Unix实用程序（如`tail(1)`、`sort(1)`和`head(1)`）过滤`extractData.go`的输出，这意味着您可以以不同的方式修改数据，而无需编写任何额外的Go代码。
- en: Taking two command-line utilities and creating one utility that implements the
    functionality of both utilities is easier than taking one big utility and dividing
    its functionality into two or more distinct utilities because the latter usually
    requires more variables and more error checking.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个命令行实用程序并创建一个实用程序来实现这两个实用程序的功能要比将一个大型实用程序分割成两个或更多不同实用程序的功能更容易，因为后者通常需要更多的变量和更多的错误检查。
- en: 'The `extractData.go` utility will be presented in four parts; the first part
    is the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractData.go`实用程序将分为四个部分；第一部分如下：'
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The second part of `extractData.go` has the following Go code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractData.go`的第二部分包含以下Go代码：'
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You should be familiar with the `findIP()` function, which you saw in `findIP.go`
    in [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)*,* *Working with System
    files*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉`findIP()`函数，您在[第7章](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml)中看到了`findIP.go`。
- en: 'The third part of `extractData.go` is the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractData.go`的第三部分如下：'
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The use of the `buf` variable is redundant here because `filename` is a string
    and `io.WriteString()` expects a string: it is just my habit to put the value
    of `filename` into a byte slice. You can remove it if you want.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`buf`变量是多余的，因为`filename`是一个字符串，`io.WriteString()`期望一个字符串：这只是我的习惯，将`filename`的值放入字节片中。如果您愿意，可以将其删除。
- en: 'Once again, most of the Go code is from the `plotIP.go` utility. The last part
    of `extractData.go` is the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，大部分Go代码来自`plotIP.go`实用程序。`extractData.go`的最后一部分如下：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, `extractData.go` writes its output to standard output (`os.Stdout`) instead
    of using the functions of the `fmt` package in order to be more compatible with
    pipes. The `extractData.go` utility requires at least two parameters: an IP address
    and a log file, but it can process as many log files as you wish.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`extractData.go`将其输出写入标准输出（`os.Stdout`），而不是使用`fmt`包的函数，以便更兼容管道。`extractData.go`实用程序至少需要两个参数：IP地址和日志文件，但它可以处理任意数量的日志文件。
- en: You might want to move the printing of the `filename` value from the third part
    here in order to have all printing commands at the same place.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将第三部分中的`filename`值的打印移至此处，以便将所有打印命令放在同一位置。
- en: 'Executing `extractData.go` will generate the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`extractData.go`将生成以下输出：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Although `extractData.go` prints two values in each line, only the second field
    will be used by `plotData.go`. The best way to do that is filter the output of
    `extractData.go` using `awk(1)`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`extractData.go`在每行打印两个值，但`plotData.go`只会使用第二个字段。最好的方法是使用`awk(1)`过滤`extractData.go`的输出：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can understand, `awk(1)` allows you to do many more things with the generated
    values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所理解的，`awk(1)`允许您对生成的值进行更多操作。
- en: 'The `plotData.go` utility will also be presented in six parts; its first part
    is the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotData.go`实用程序也将分为六个部分；它的第一部分如下：'
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once again, the use of global variables is for avoiding the passing of too many
    arguments to some of the functions of the utility.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用全局变量是为了避免向实用程序的某些函数传递太多参数。
- en: 'The second part of `plotData.go` contains the following Go code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotData.go`的第二部分包含以下Go代码：'
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The third part of `plotData.go` has the following Go code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotData.go`的第三部分包含以下Go代码：'
- en: '[PRE63]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The fourth part of `plotData.go` contains the following Go code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotData.go`的第四部分包含以下Go代码：'
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The fifth part of `plotData.go` is the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotData.go`的第五部分如下：'
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last part of `plotData.go` is the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`plotData.go`的最后一部分如下：'
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Although you can use `plotData.go` on its own, using the output of `extractData.go`
    as the input to `plotData.go` is as easy as executing the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以单独使用`plotData.go`，但使用`extractData.go`的输出作为`plotData.go`的输入就像执行以下命令一样简单：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The graphical output from the previous command can be an image like the one
    you can see in the following figure:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令的图形输出可以是一个图像，就像您在以下图中看到的那样：
- en: '![](img/ee09e9bd-e219-47d1-98f4-47de7bc75848.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee09e9bd-e219-47d1-98f4-47de7bc75848.png)'
- en: The output generated by the plotData.go utility
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: plotData.go实用程序生成的输出
- en: Unix sockets in Go
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中使用Unix套接字
- en: 'There exist two kinds of sockets: Unix sockets and network sockets. Network
    sockets will be explained in [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)*,*
    *Network Programming*, whereas Unix sockets will be briefly explained in this
    section. However, as the presented Go functions also work with TCP/IP sockets,
    you will still have to wait till [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml),
    *Network Programming*, in order to fully understand them as they will not be explained
    here. So, this section will just present the Go code of a Unix socket client,
    which is a program that uses a Unix socket, which is a special Unix file, to read
    and write data. The name of the program will be `readUNIX.go` and will be presented
    in three parts.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 存在两种类型的套接字：Unix套接字和网络套接字。网络套接字将在[第12章](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)，*网络编程*中解释，而Unix套接字将在本节中简要解释。然而，由于所呈现的Go函数也适用于TCP/IP套接字，因此您仍需等待[第12章](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)，*网络编程*，以充分理解它们，因为它们在这里不会被解释。因此，本节将仅呈现Unix套接字客户端的Go代码，这是一个使用Unix套接字（一种特殊的Unix文件）来读取和写入数据的程序。该程序的名称将是`readUNIX.go`，将分为三部分呈现。
- en: 'The first part is the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE68]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The second part of `readUNIX.go` is the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`readUNIX.go`的第二部分如下：'
- en: '[PRE69]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The last part contains the following Go code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含以下Go代码：
- en: '[PRE70]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The use of `readUNIX.go` requires the presence of another process that also
    reads and writes to the same socket file (`/tmp/aSocket.sock`).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readUNIX.go`需要另一个进程的存在，该进程也读取和写入同一个套接字文件(`/tmp/aSocket.sock`)。
- en: 'The generated output depends on the implementation of the other part: in this
    case, that output was the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出取决于另一部分的实现：在这种情况下，输出如下：
- en: '[PRE71]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the socket file cannot be found or if no program is watching it, you will
    get the following error message:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到套接字文件或没有程序在监听它，您将收到以下错误消息：
- en: '[PRE72]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: RPC in Go
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的RPC
- en: RPC stands for **Remote Procedure Call** and is a way of executing function
    calls to a remote server and getting the answer back in your clients. Once again,
    you will have to wait until [Chapter 12](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)*,*
    *Network Programming*, in order to learn how to develop an RPC server and an RPC
    client in Go.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: RPC代表**远程过程调用**，是一种执行对远程服务器的函数调用并在客户端获取答案的方式。再次，您将不得不等到[第12章](fe18fc6b-5b18-4a49-ad25-78909d80232f.xhtml)，*网络编程*，以了解如何在Go中开发RPC服务器和RPC客户端。
- en: Programming a Unix shell in Go
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中编程Unix shell
- en: This section will briefly and naively present Go code that can be used as the
    foundation for the development of a Unix shell. Apart from the `exit` command,
    the only other command that the program can recognize is the `version` command
    that just prints the version of the program. All other user input will be echoed
    on the screen.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要而天真地呈现可以用作Unix shell开发基础的Go代码。除了`exit`命令外，程序能识别的唯一其他命令是`version`命令，它只是打印程序的版本。所有其他用户输入都将在屏幕上回显。
- en: 'The Go code of `UNIXshell.go` will be presented in three parts. However, before
    that I will present to you the first version of the shell, which mainly contains
    comments in order to better understand how I usually start the implementation
    of a relatively challenging program:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`UNIXshell.go`的Go代码将分为三部分呈现。然而，在此之前，我将向您展示shell的第一个版本，其中主要包含注释，以更好地理解我通常如何开始实现一个相对具有挑战性的程序：'
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is more or less the algorithm that I would use as a starting point: the
    good thing is that the comments briefly show how the program will operate. Keep
    in mind that the algorithm does not depend on the programming language. After
    that, it is easier to start implementing things because you know what you want
    to do.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这更多或多少是我作为起点使用的算法：好处是注释简要地展示了程序的操作方式。请记住，算法不依赖于编程语言。之后，开始实现事物会更容易，因为你知道你想要做什么。
- en: 'So, the first part of the final version of the shell is the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，shell最终版本的第一部分如下：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The second part is the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, you just read the input from the user line by line and find out the first
    word of the input.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您只需逐行从用户那里读取输入并找出输入的第一个单词。
- en: 'The last part of `UNIXshell.go` is the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`UNIXshell.go`的最后一部分如下：'
- en: '[PRE76]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The aforementioned Go code checks the command that the user gave and acts accordingly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的Go代码检查用户给出的命令并相应地采取行动。
- en: 'Executing `UNIXshell.go` and interacting with it will generate the following
    output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`UNIXshell.go`并与其交互将生成以下输出：
- en: '[PRE77]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Should you wish to learn more about creating your own Unix shell in Go, you
    can visit [https://github.com/elves/elvish](https://github.com/elves/elvish).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何在Go中创建自己的Unix shell，可以访问[https://github.com/elves/elvish](https://github.com/elves/elvish)。
- en: Yet another minor Go update
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一个小的Go更新
- en: 'While I was writing this chapter, Go was updated: this is a minor update, which
    mainly fixes bugs:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这一章时，Go已经更新：这是一个小更新，主要是修复了一些错误：
- en: '[PRE78]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Exercises
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Put the plotting functionality of `plotIP.go` into a Go package and use that
    package to rewrite both `plotIP.go` and `plotData.go`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`plotIP.go`的绘图功能放入一个Go包中，并使用该包重写`plotIP.go`和`plotData.go`。
- en: Review the Go code of `ddGo.go` from [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)*,*
    *File Input and Output*, in order to print information about its progress when
    receiving a `SIGINFO` signal.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看[第6章](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml)的`ddGo.go` Go代码，*文件输入和输出*，以便在接收`SIGINFO`信号时打印有关其进度的信息。
- en: Change the Go code of `cat.go` to add support for multiple input files.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`cat.go`的Go代码以支持多个输入文件。
- en: Change the code of `plotData.go` in order to print gridlines to the generated
    image.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`plotData.go`的代码，以便在生成的图像上打印网格线。
- en: Change the code of `plotData.go` in order to leave a little space between the
    bars of the plot.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`plotData.go`的代码，以便在图表的条之间留出一点空间。
- en: Try to make the `UNIXshell.go` program a little better by adding new features
    to it.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过为其添加新功能使`UNIXshell.go`程序变得更好一点。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about many interesting and handy topics, including
    signal handling and creating graphical images in Go. Additionally, we taught you
    how to add support for Unix pipes in your Go programs.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多有趣和方便的主题，包括信号处理和在Go中创建图形图像。此外，我们还教会了您如何在Go程序中添加对Unix管道的支持。
- en: In the next chapter, we will talk about the most unique feature of Go, which
    is goroutines. You will learn what a goroutine is, how to create and synchronize
    them as well as how to create channels and pipelines. Have in mind that many people
    come to Go in order to learn a modern and safe programming language, but stay
    for its goroutines!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Go最独特的特性，即goroutines。您将学习什么是goroutine，如何创建和同步它们，以及如何创建通道和管道。请记住，许多人来学习现代和安全的编程语言，但留下来是因为它的goroutines！
