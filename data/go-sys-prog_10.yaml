- en: Goroutines - Advanced Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines-高级功能
- en: 'This is the second chapter of this book that deals with goroutines: the most
    important feature of the Go programming language: as well as channels that greatly
    improve what goroutines can do, and we will continue this from where we stopped
    it in [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,* *Goroutines -
    Basic Features*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的第二章，涉及goroutines：Go编程语言的最重要特性，以及大大改进goroutines功能的通道，我们将从[第9章](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml)*,*
    *Goroutines-基本功能*中停止的地方继续进行。
- en: Thus, you will learn how to use various types of channels, including buffered
    channels, signal channels, nil channels, and channels of channels! Additionally,
    you will learn how you can utilize shared memory and mutexes with goroutines as
    well as how to time out a program when it is taking too long to finish.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将学习如何使用各种类型的通道，包括缓冲通道、信号通道、空通道和通道的通道！此外，您还将学习如何在goroutines中利用共享内存和互斥锁，以及如何在程序运行时间过长时设置超时。
- en: 'Specifically, this chapter will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将讨论以下主题：
- en: Buffered channels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: The `select` keyword
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`关键字'
- en: Signal channels
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号通道
- en: Nil channels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空通道
- en: Channel of channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道的通道
- en: Timing out a program and avoiding waiting forever for it to end
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置程序超时并避免无限等待其结束
- en: Shared memory and goroutines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存和goroutines
- en: Using `sync.Mutex` in order to guard shared data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sync.Mutex`来保护共享数据
- en: Using `sync.RWMutex` in order to protect your shared data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sync.RWMutex`来保护您的共享数据
- en: Changing the code of `dWC.go` from [Chapter 9](e9f68321-ac26-49e4-bdae-44b38149afc2.xhtml),
    *Goroutines - Basic Features*, in order to add support for buffered channels and
    mutexes to it
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改`dWC.go`代码，以支持缓冲通道和互斥锁
- en: The Go scheduler
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go调度程序
- en: In the previous chapter, we said that the kernel scheduler is responsible for
    the order your goroutines will be executed in, which is not completely accurate.
    The kernel scheduler is responsible for the execution of the threads your programs
    have. The Go runtime has its own scheduler that is responsible for the execution
    of the goroutines using a technique known as **m:n scheduling**, where *m* goroutines
    are executed using *n* operating system threads using multiplexing. As the Go
    scheduler has to deal with the goroutines of a single program, its operation is
    much cheaper and faster than the operation of the kernel scheduler.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们说内核调度程序负责执行goroutines的顺序，这并不完全准确。内核调度程序负责执行程序的线程。Go运行时有自己的调度程序，负责使用一种称为**m:n调度**的技术执行goroutines，其中*m*个goroutines使用*n*个操作系统线程进行多路复用。由于Go调度程序必须处理单个程序的goroutines，其操作比内核调度程序的操作要便宜和快得多。
- en: The sync Go package
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sync Go包
- en: Once again, we will use functions and data types from the `sync` package in
    this chapter. Particularly, you will learn about the usefulness of the `sync.Mutex`
    and `sync.RWMutex` types and the functions supporting them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次使用`sync`包中的函数和数据类型。特别是，您将了解`sync.Mutex`和`sync.RWMutex`类型及支持它们的函数的用处。
- en: The select keyword
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: select关键字
- en: A `select` statement in Go is like a `switch` statement for channels and allows
    a goroutine to wait on multiple communication operations. Therefore, the main
    advantage you get from using the `select` keyword is that the same function can
    deal with multiple channels using a single `select` statement! Additionally, you
    can have nonblocking operations on channels.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，`select`语句类似于通道的`switch`语句，并允许goroutine等待多个通信操作。因此，使用`select`关键字的主要优势是，同一个函数可以使用单个`select`语句处理多个通道！此外，您可以在通道上进行非阻塞操作。
- en: The name of the program that will be used for illustrating the `select` keyword
    will be `useSelect.go` and will be presented in five parts. The `useSelect.go`
    program allows you to generate the number of random you want, which is defined
    in the first command-line argument, up to a certain limit, which is the second
    command-line argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用于说明`select`关键字的程序的名称将是`useSelect.go`，并将分为五个部分。`useSelect.go`程序允许您生成您想要的随机数，这是在第一个命令行参数中定义的，直到达到某个限制，这是第二个命令行参数。
- en: 'The first part of `useSelect.go` is the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSelect.go`的第一部分如下：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second part of `useSelect.go` is the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSelect.go`的第二部分如下：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, you can see how the `select` keyword allows you to listen to and coordinate
    two channels (`randomNumberChannel` and `finishedChannel`) at the same time. The
    `select` statement waits for a channel to unblock and then executes on that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到`select`关键字如何允许您同时监听和协调两个通道（`randomNumberChannel`和`finishedChannel`）。`select`语句等待通道解除阻塞，然后在该通道上执行。
- en: The `for` loop of the `createNumber()` function will not end on this own. Therefore,
    `createNumber()` will keep generating random numbers for as long as the `randomNumberChannel`
    branch of the `select` statement is used. The `createNumber()` function will exit
    when it gets the Boolean value `true` in the `finishedChannel` channel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`createNumber()`函数的`for`循环将不会自行结束。因此，只要`select`语句的`randomNumberChannel`分支被使用，`createNumber()`将继续生成随机数。当`finishedChannel`通道中获取到布尔值`true`时，`createNumber()`函数将退出。'
- en: A better name for the `finishedChannel` channel would have been `done` or even
    `noMoreData`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`finishedChannel`通道的更好名称可能是`done`甚至是`noMoreData`。'
- en: 'The third part of the program contains the following Go code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分包含以下Go代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is nothing special here: you just read the command-line arguments before
    starting the desired goroutine.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的：你只是在启动所需的goroutine之前读取命令行参数。
- en: 'The fourth part of `useSelect.go` is where you will start the desired goroutine
    and create a `for` loop in order to generate the desired number of random numbers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSelect.go`的第四部分是您将启动所需的goroutine并创建一个`for`循环以生成所需数量的随机数：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, you also send a message to `finishedChannel` and check whether the `randomNumberChannel`
    channel is `open` or `closed` after sending the message to `finishedChannel`.
    As you sent `false` to `finishedChannel`, the `finishedChannel` channel will remain
    `open`. Note that a message sent to a `closed` channel panics, whereas a message
    received from a `closed` channel returns the zero value immediately.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您还可以向`finishedChannel`发送一条消息，并在向`finishedChannel`发送消息后检查`randomNumberChannel`通道是`open`还是`closed`。由于您向`finishedChannel`发送了`false`，因此`finishedChannel`通道将保持`open`。请注意，向`closed`通道发送消息会导致panic，而从`closed`通道接收消息会立即返回零值。
- en: Note that once you close a channel, you cannot write to this channel. However,
    you can still read from that channel!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦关闭通道，就无法向该通道写入。但是，您仍然可以从该通道读取！
- en: 'The last part of `useSelect.go` has the following Go code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSelect.go`的最后一部分包含以下Go代码：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, you sent the `true` value to `finishedChannel`, so your channels will
    close and the `createNumber()` goroutine will exit.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您向`finishedChannel`发送了`true`值，因此您的通道将关闭，`createNumber()` goroutine将退出。
- en: 'Running `useSelect.go` will create the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`useSelect.go`将创建以下输出：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you will see in the `bufChannels.go` program that explains buffered channels,
    the `select` statement can also save you from overflowing a buffered channel.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在解释缓冲通道的`bufChannels.go`程序中看到的，`select`语句也可以防止缓冲通道溢出。
- en: Signal channels
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号通道
- en: 'A **signal channel** is a channel that is used just for signaling. Signal channels
    will be illustrated using the `signalChannel.go` program with a rather unusual
    example that will be presented in five parts. The program executes four goroutines:
    when the first one is finished, it sends a signal to a signal channel by closing
    it, which will unblock the second goroutine. When the second goroutine finishes
    its job, it closes another channel that unblocks the remaining two goroutines.
    Note that signal channels are not the same as channels that carry the `os.Signal`
    values.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号通道**是仅用于发出信号的通道。将使用`signalChannel.go`程序来说明信号通道，该程序将使用一个相当不寻常的示例来呈现五个部分。该程序执行四个goroutines：当第一个完成时，它通过关闭信号通道向信号通道发送信号，这将解除第二个goroutine的阻塞。当第二个goroutine完成其工作时，它关闭另一个通道，解除其余两个goroutine的阻塞。请注意，信号通道与携带`os.Signal`值的通道不同。'
- en: 'The first part of the program is the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `A()` function is blocked by the channel defined in the `a` parameter. This
    means that until this channel is closed, the `A()` function cannot continue its
    execution. The last statement of the function closes the channel that is stored
    in the `b` variable, which will be used for unblocking other goroutines.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`A()`函数被存储在`a`参数中定义的通道阻塞。这意味着在关闭此通道之前，`A()`函数无法继续执行。函数的最后一条语句关闭了存储在`b`变量中的通道，该通道将用于解除其他goroutines的阻塞。'
- en: 'The second part of the program is the implementation of the `B()` function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分是`B()`函数的实现：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Similarly, the `B()` function is blocked by the channel stored in the `b` argument,
    which means that until the `b` channel is closed, the `B()` function will be waiting
    in its first statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`B()`函数被存储在`b`参数中的通道阻塞，这意味着在关闭`b`通道之前，`B()`函数将在其第一条语句中等待。
- en: 'The third part of `signalChannel.go` is the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`signalChannel.go`的第三部分如下：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once again, the `C()` function is blocked by the channel stored in its `a` argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`C()`函数被存储在其`a`参数中的通道阻塞。
- en: 'The fourth part of the program is the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分如下：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Defining a signal channel as an empty `struct` with no fields is a very common
    practice because empty structures take no memory space. In such a case, you could
    have used a `bool` channel instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将信号通道定义为空`struct`而不带任何字段是一种非常常见的做法，因为空结构不占用内存空间。在这种情况下，您可以使用`bool`通道。
- en: 'The last part of `signalChannel.go` has the following Go code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`signalChannel.go`的最后一部分包含以下Go代码：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you start four goroutines. However, until you close the `a` channel, all
    of them will be blocked! Additionally, `A()` will finish first and unblock `B()`
    that will unblock the two `C()` goroutines. So, this technique allows you to define
    the order of execution of your goroutines.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您启动了四个goroutines。但是，在关闭`a`通道之前，它们都将被阻塞！此外，`A()`将首先完成并解除`B()`的阻塞，然后解除两个`C()`
    goroutine的阻塞。因此，这种技术允许您定义goroutines的执行顺序。
- en: 'If you execute `signalChannel.go`, you will get the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行`signalChannel.go`，您将获得以下输出：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the goroutines are being executed in the desired order despite
    the `A()` function taking more time to execute than the others due to the `time.Sleep()`
    function call.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，尽管`A()`函数由于`time.Sleep()`函数调用而花费更多时间来执行，但goroutines正在按预期顺序执行。
- en: Buffered channels
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: '**Buffered channels** allow the Go scheduler to put jobs in the queue quickly
    in order to be able to serve more requests. Moreover, you can use buffered channels
    as **semaphores** in order to limit throughput. The technique works as follows:
    incoming requests are forwarded to a channel, which processes one request at a
    time. When the channel is done, it sends a message to the original caller saying
    that it is ready to process a new request. So, the capacity of the buffer of the
    channel restricts the number of simultaneous requests it can keep and process:
    this can be easily implemented using a `for` loop with a call to `time.Sleep()`
    at its end.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲通道**允许Go调度程序快速将作业放入队列，以便能够处理更多请求。此外，您可以使用缓冲通道作为**信号量**，以限制吞吐量。该技术的工作原理如下：传入的请求被转发到一个通道，该通道一次处理一个请求。当通道完成时，它向原始调用者发送一条消息，表明它已准备好处理新的请求。因此，通道缓冲区的容量限制了它可以保留和处理的同时请求的数量：这可以很容易地使用`for`循环和在其末尾调用`time.Sleep()`来实现。'
- en: Buffered channels will be illustrated in `bufChannels.go`, which will be presented
    in four parts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道将在`bufChannels.go`中进行说明，该程序将分为四个部分。
- en: 'The first part of the program is the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preamble proves that you do not need any extra packages for supporting buffered
    channels in your Go program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 序言证明了您在Go程序中不需要任何额外的包来支持缓冲通道。
- en: 'The second part of the program has the following Go code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分包含以下Go代码：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you create a new channel named `numbers` with `5` places, which is denoted
    by the last parameter of the `make` statement. This means that you can write five
    integers to that channel without having to read any one of them in order to make
    space for the others. However, you cannot put six integers on a channel with five
    integer places!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个名为`numbers`的新通道，它有`5`个位置，这由`make`语句的最后一个参数表示。这意味着您可以向该通道写入五个整数，而无需读取其中任何一个以为其他整数腾出空间。但是，您不能将六个整数放在具有五个整数位置的通道上！
- en: 'The third part of `bufChannels.go` is the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufChannels.go`的第三部分如下：'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, you try to put `10` integers to a buffered channel with `5` places. However,
    the use of the `select` statement allows you to know whether you have enough space
    for storing all the integers or not and act accordingly!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您尝试将`10`个整数放入具有`5`个位置的缓冲通道。但是，使用`select`语句可以让您知道是否有足够的空间来存储所有整数，并相应地采取行动！
- en: 'The last part of `bufChannels.go` is the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufChannels.go`的最后一部分如下：'
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, you also use a `select` statement while trying to read 20 integers from
    a channel. However, as soon as reading from the channel fails, the `for` loop
    exits using a `break` statement. This happens because when there is nothing left
    to read from the `numbers` channel, the `num := <-numbers` statement will block,
    which makes the `case` statement to go to the `default` branch.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您还使用了`select`语句，尝试从一个通道中读取20个整数。但是，一旦从通道中读取失败，`for`循环就会使用`break`语句退出。这是因为当从`numbers`通道中没有剩余内容可读时，`num
    := <-numbers`语句将被阻塞，这使得`case`语句转到`default`分支。
- en: As you can see from the code, there is no goroutine in `bufChannels.go`, which
    means that buffered channels can work on their own.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，`bufChannels.go`中没有goroutine，这意味着缓冲通道可以自行工作。
- en: 'Executing `bufChannels.go` will generate the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`bufChannels.go`将生成以下输出：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: About timeouts
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于超时
- en: Can you imagine waiting forever for something to perform an action? Neither
    can I! So, in this section you will learn how to implement **timeouts** in Go
    with the help of the `select` statement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您能想象永远等待某件事执行动作吗？我也不能！因此，在本节中，您将学习如何使用`select`语句在Go中实现**超时**。
- en: 'The program with the sample code will be named `timeOuts.go` and will be presented
    in four parts; the first part is the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 具有示例代码的程序将被命名为`timeOuts.go`，并将分为四个部分进行介绍；第一部分如下：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second part of `timeOuts.go` is the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeOuts.go`的第二部分如下：'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `time.Sleep()` statement in the goroutine is used for simulating the time
    it will take for the goroutine to do its real job.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: goroutine中的`time.Sleep()`语句用于模拟goroutine执行其真正工作所需的时间。
- en: 'The third part of `timeOuts.go` has the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeOuts.go`的第三部分包含以下代码：'
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time the use of `time.After()` is required for declaring the time you want
    to wait before timing out. The wonderful thing here is that if the time of `time.After()`
    expires without the `select` statement having received any data from the `c1`
    channel, the case branch of `time.After()` will get executed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，使用`time.After()`是为了声明您希望在超时之前等待的时间。这里的奇妙之处在于，如果`time.After()`的时间到期，而`select`语句没有从`c1`通道接收到任何数据，那么`time.After()`的`case`分支将被执行。
- en: 'The last part of the program will have the following Go code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分将包含以下Go代码：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous code, you see an operation that does not time out because it
    is completed within the desired time, which means that the first branch of the
    `select` block will get executed instead of the second one that signifies the
    timeout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您会看到一个操作，它不会超时，因为它在期望的时间内完成了，这意味着`select`块的第一个分支将被执行，而不是表示超时的第二个分支。
- en: 'The execution of `timeOuts.go` will generate the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`timeOuts.go`将生成以下输出：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: An alternative way to implement timeouts
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现超时的另一种方法
- en: The technique of this subsection will let you not wait for any stubborn goroutines
    to finish their jobs. Therefore, this subsection will show you how to time out
    goroutines with the help of the `timeoutWait.go` program that will be presented
    in four parts. Despite the code differences between `timeoutWait.go` and `timeOuts.go`,
    the general idea is exactly the same.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的技术将让您不必等待任何顽固的goroutines完成它们的工作。因此，本小节将向您展示如何通过`timeoutWait.go`程序来设置goroutines的超时，该程序将分为四个部分进行介绍。尽管`timeoutWait.go`和`timeOuts.go`之间存在代码差异，但总体思想是完全相同的。
- en: 'The first part of `timeoutWait.go` contains the expected preamble:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutWait.go`的第一部分包含了预期的序言：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second part of `timeoutWait.go` is the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutWait.go`的第二部分如下：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you declare a function that does the entire job. The core of the function
    is the `select` block that works the same way as in `timeOuts.go`. The anonymous
    function of `timeout()` will successfully end when the `w.Wait()` statement returns,
    which will happen when the appropriate number of `sync.Done()` calls have been
    executed, which means that all goroutines will be finished. In this case, the
    first case of the `select` statement will be executed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您声明了一个执行整个工作的函数。函数的核心是`select`块，其工作方式与`timeOuts.go`中的相同。`timeout()`的匿名函数将在`w.Wait()`语句返回时成功结束，这将在执行适当数量的`sync.Done()`调用时发生，这意味着所有goroutines都将完成。在这种情况下，`select`语句的第一个`case`将被执行。
- en: Note that the `temp` channel is needed in the `select` block and nowhere else.
    Additionally, the element type of the `temp` channel could have been anything,
    including `bool`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`temp`通道在`select`块中是必需的，而在其他地方则不需要。此外，`temp`通道的元素类型可以是任何类型，包括`bool`。
- en: 'The third part of `timeOuts.go` has the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeOuts.go`的第三部分包含以下代码：'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last fragment of the program has the following Go code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一个片段包含以下Go代码：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the anticipated `w.Done()` call has been executed, the `timeout()` function
    will return `true`, which will prevent the timeout from happening.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期的`w.Done（）`调用执行后，`timeout（）`函数将返回`true`，这将防止超时发生。
- en: As mentioned at the beginning of this subsection, `timeoutWait.go` actually
    prevents your program from having to wait indefinitely for one or more goroutines
    to end.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在本小节开头提到的，`timeoutWait.go`实际上可以防止您的程序无限期地等待一个或多个goroutine结束。
- en: 'Executing `timeoutWait.go` will create the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`timeoutWait.go`将生成以下输出：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Channels of channels
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道的通道
- en: 'In this section, we will talk about creating and using a channel of channels.
    Two possible reasons to use such a channel are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论创建和使用通道的通道。使用这样的通道的两个可能原因如下：
- en: For acknowledging that an operation finished its job
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于确认操作已完成其工作
- en: For creating many worker processes that will be controlled by the same channel
    variable
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建许多由相同通道变量控制的工作进程
- en: The name of the naive program that will be developed in this section is `cOfC.go`
    and will be presented in four parts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中将开发的简单程序的名称是`cOfC.go`，将分为四个部分呈现。
- en: 'The first part of the program is the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second part of the program is the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分如下：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `f1()` function returns integer numbers that belong to the `numbers` variable.
    When it is about to end, it also returns the number of integers it has sent back
    to the `caller` function using the `c <- total` statement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1（）`函数返回属于`numbers`变量的整数。当它即将结束时，它还使用`c <- total`语句将发送回到`caller`函数的整数数量。'
- en: As you cannot use a channel of channels directly, you should first read from
    it (`cc <- c`) and get a channel that you can actually use. The handy thing here
    is that although you can close the `c` channel, the channel of channels (`cc`)
    will be still up and running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您不能直接使用通道的通道，因此您应该首先从中读取（`cc <- c`）并获取实际可以使用的通道。这里方便的是，尽管您可以关闭`c`通道，但通道的通道（`cc`）仍将保持运行。
- en: 'The third part of `cOfC.go` is the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cOfC.go`的第三部分如下：'
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this Go code, you can see that you can declare a channel of channels using
    the `chan` keyword two consecutive times.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段Go代码中，您可以看到可以使用`chan`关键字连续两次声明通道的通道。
- en: 'The last part of `cOfC.go` has the following Go code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`cOfC.go`的最后一部分包含以下Go代码：'
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, you limit the number of integers that will be created by closing the `f`
    channel when you have the number of integers you want.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过关闭`f`通道，您限制了将创建的整数数量，当您拥有所需的整数数量时。
- en: 'Executing `cOfC.go` will generate the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`cOfC.go`将生成以下输出：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A channel of channels is an advanced Go feature that you probably will not need
    to use in your system software. However, it is good to know that it exists.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的通道是Go的高级功能，您可能不需要在系统软件中使用。但是，了解其存在是很好的。
- en: Nil channels
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空通道
- en: This section will talk about **nil channels**, which are a special sort of channel
    that will always block. The name of the program will be `nilChannel.go` and will
    be presented in four parts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论**nil通道**，这是一种特殊类型的通道，它将始终阻塞。程序的名称将是`nilChannel.go`，将分为四个部分呈现。
- en: 'The first part of the program contains the expected preamble:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分包含了预期的序言：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The second portion contains the implementation of the `addIntegers()` function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含`addIntegers（）`函数的实现：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `addIntegers()` function stops after the time defined in the `time.NewTimer()`
    function passes and will go to the relevant branch of the `case` statement. There,
    it makes `c` a nil channel, which means that the channel will stop receiving new
    data and that the function will just wait there.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`addIntegers（）`函数在`time.NewTimer（）`函数定义的时间过去后停止，并将转到`case`语句的相关分支。在那里，它将使`c`成为nil通道，这意味着通道将停止接收新数据，并且函数将在那里等待。'
- en: 'The third part of `nilChannel.go` is the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`nilChannel.go`的第三部分如下：'
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the `sendIntegers()` function keeps generating random numbers and sends
    them to the `c` channel as long as the `c` channel is open. However, here you
    also have a goroutine that is never cleaned up.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sendIntegers（）`函数会继续生成随机数并将它们发送到`c`通道，只要`c`通道是打开的。但是，这里还有一个永远不会被清理的goroutine。
- en: 'The last part of the program has the following Go code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后一部分包含以下Go代码：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Executing `nilChannel.go` will generate the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`nilChannel.go`将生成以下输出：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Shared memory
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享内存
- en: Shared memory is the traditional way that threads use for communicating with
    each other. Go comes with built-in synchronization features that allow a single
    goroutine to own a shared piece of data. This means that other goroutines must
    send messages to this single goroutine that owns the shared data, which prevents
    the corruption of the data! Such a goroutine is called a **monitor goroutine**.
    In Go terminology, this is s*haring by communicating instead of communicating
    by sharing*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存是线程之间进行通信的传统方式。Go具有内置的同步功能，允许单个goroutine拥有共享数据的一部分。这意味着其他goroutine必须向拥有共享数据的单个goroutine发送消息，这可以防止数据的损坏！这样的goroutine称为**监视器goroutine**。在Go术语中，这是通过通信进行共享，而不是通过共享进行通信。
- en: 'This technique will be illustrated in the `sharedMem.go` program, which will
    be presented in five parts. The first part of `sharedMem.go` has the following
    Go code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将在`sharedMem.go`程序中进行演示，该程序将分为五个部分呈现。`sharedMem.go`的第一部分包含以下Go代码：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The second part is the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `ReadValue()` function is used for reading the shared variable, whereas
    the `SetValue()` function is used for setting the value of the shared variable.
    Also, the two channels used in the program need to be global variables in order
    to avoid passing them as arguments to all the functions of the program. Note that
    these global variables are usually wrapped up in a Go library or a `struct` with
    methods.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadValue()`函数用于读取共享变量，而`SetValue()`函数用于设置共享变量的值。此外，程序中使用的两个通道需要是全局变量，以避免将它们作为程序所有函数的参数传递。请注意，这些全局变量通常被封装在一个Go库或带有方法的`struct`中。'
- en: 'The third part of `sharedMem.go` is the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`sharedMem.go`的第三部分如下：'
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The logic of `sharedMem.go` can be found in the implementation of the `monitor()`
    function. When you have a read request, the `ReadValue()` function attempts to
    read from the `readValue` channel. Then, the `monitor()` function returns the
    current value that is kept in the `value` parameter. Similarly, when you want
    to change the stored value, you call `SetValue()`, which writes to the `writeValue`
    channel that is also handled by the `select` statement. Once again, the `select`
    block plays a key role because it orchestrates the operations of the `monitor()`
    function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`sharedMem.go`的逻辑可以在`monitor()`函数的实现中找到。当你有一个读取请求时，`ReadValue()`函数尝试从`readValue`通道读取。然后，`monitor()`函数返回`value`参数中保存的当前值。同样，当你想要改变存储的值时，你调用`SetValue()`，它会写入`writeValue`通道，也由`select`语句处理。再次，`select`块起着关键作用，因为它协调了`monitor()`函数的操作。'
- en: 'The fourth portion of the program has the following Go code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分包含以下Go代码：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The last part of the program is the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分如下：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Executing `sharedMem.go` will generate the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`sharedMem.go`将生成以下输出：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you want to share more values, you can define a new structure that will hold
    the desired variables with the data types you prefer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想共享更多的值，你可以定义一个新的结构，用来保存所需的变量和你喜欢的数据类型。
- en: Using sync.Mutex
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sync.Mutex
- en: '**Mutex** is an abbreviation for **mutual exclusion**; the `Mutex` variables
    are mainly used for thread synchronization and for protecting shared data when
    multiple writes can occur at the same time. A mutex works like a buffered channel
    of capacity 1 that allows at most one goroutine to access a shared variable at
    a time. This means that there is no way for two or more goroutines to try to update
    that variable simultaneously. Although this is a perfectly valid technique, the
    general Go community prefers to use the `monitor` goroutine technique presented
    in the previous section.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mutex**是**mutual exclusion**的缩写；`Mutex`变量主要用于线程同步和保护共享数据，当多个写操作可能同时发生时。互斥锁的工作原理类似于容量为1的缓冲通道，最多允许一个goroutine同时访问共享变量。这意味着没有两个或更多的goroutine可以同时尝试更新该变量。虽然这是一种完全有效的技术，但一般的Go社区更倾向于使用前一节介绍的`monitor`
    goroutine技术。'
- en: In order to use `sync.Mutex`, you will have to declare a `sync.Mutex` variable
    first. You can lock that variable using the `Lock` method and release it using
    the `Unlock` method. The `sync.Lock()` method gives you exclusive access over
    the shared variable for a region of code that finishes when you call the `Unlock()`
    method and is called a **critical section**.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`sync.Mutex`，你必须首先声明一个`sync.Mutex`变量。你可以使用`Lock`方法锁定该变量，并使用`Unlock`方法释放它。`sync.Lock()`方法为你提供了对共享变量的独占访问，这段代码区域在调用`Unlock()`方法时结束，被称为**关键部分**。
- en: Each critical section of a program cannot be executed without locking it first
    using `sync.Lock()`. However, if a lock has already been taken, everybody should
    wait for its release first. Although multiple functions might wait to get a lock,
    only one of them will get it when it will be released.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的每个关键部分在使用`sync.Lock()`进行锁定之前都不能执行。然而，如果锁已经被占用，每个人都应该等待其释放。虽然多个函数可能会等待获取锁，但只有当它被释放时，其中一个函数才会获取到它。
- en: You should try to make critical sections as small as possible; in other words,
    do not delay releasing a lock because other goroutines might want to use it. Additionally,
    forgetting to unlock `Mutex` will most likely result in a deadlock.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尽量将关键部分设计得尽可能小；换句话说，不要延迟释放锁，因为其他goroutines可能想要使用它。此外，忘记解锁`Mutex`很可能会导致死锁。
- en: The name of the Go program with the code for illustrating the use of `sync.Mutex`
    will be `mutexSimple.go` and will be presented in five chunks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 用于演示`sync.Mutex`的Go程序的名称将是`mutexSimple.go`，并将以五个部分呈现。
- en: 'The first part of `mutexSimple.go` contains the expected preamble:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutexSimple.go`的第一部分包含了预期的序言：'
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The second part of the program is the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第二部分如下：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that a critical section is not always obvious and you should be very careful
    when specifying it. Also note that a critical section cannot be embedded in another
    critical section when both critical sections use the same `Mutex` variable! Putting
    it simply, avoid, at almost all costs, spreading mutexes across functions because
    that makes really hard to see whether you are embedding or not!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关键部分并不总是显而易见，你在指定时应该非常小心。还要注意，当两个关键部分使用相同的`Mutex`变量时，一个关键部分不能嵌套在另一个关键部分中！简单地说，几乎要以所有的代价避免在函数之间传递互斥锁，因为这样很难看出你是否嵌套了互斥锁！
- en: 'Here, `addDot()` adds a dot character at the end of the `sharedVariable` string.
    However, as the string should be altered simultaneously by multiple goroutines,
    you use a `sync.Mutex` variable to protect it. As the critical section contains
    just one command, the waiting period for getting access to the mutex will be fairly
    small, if not instantaneous. However, in a real-world situation, the waiting period
    might be much longer, especially on software such as database servers where many
    things happen simultaneously by thousands of processes: you can simulate that
    by adding a call to `time.Sleep()` in the critical section.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addDot（）`在`sharedVariable`字符串的末尾添加一个点字符。但是，由于字符串应该同时被多个goroutine改变，所以您使用`sync.Mutex`变量来保护它。由于关键部分只包含一个命令，获取对互斥体的访问的等待时间将非常短，甚至是瞬时的。但是，在现实世界的情况下，等待时间可能会更长，特别是在诸如数据库服务器之类的软件上，成千上万的进程同时发生许多事情：您可以通过在关键部分添加对`time.Sleep（）`的调用来模拟这一点。
- en: Note that it is the responsibility of the developer to associate a mutex with
    one or more shared variables!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将互斥体与一个或多个共享变量相关联是开发人员的责任！
- en: 'The third code segment of `mutexSimple.go` is the implementation of another
    function that uses the mutex:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutexSimple.go`的第三个代码段是另一个使用互斥体的函数的实现：'
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Although locking the shared variable while reading it is not absolutely necessary,
    this kind of locking prevents the shared variable from changing while you are
    reading it. This might look like a small issue here but imagine reading the balance
    of your bank account instead!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在读取共享变量时锁定共享变量并不是绝对必要的，但这种锁定可以防止在读取时共享变量发生更改。在这里可能看起来像一个小问题，但想象一下读取您的银行账户余额！
- en: 'The fourth part is where you define the number of goroutines that you will
    start:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第四部分是您定义要启动的goroutine数量的地方：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The final part of `mutexSimple.go` contains the following Go code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutexSimple.go`的最后一部分包含以下Go代码：'
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, you start the desired number of goroutines. Each goroutine calls the
    `addDot()` function that accesses the shared variable: and you wait for them to
    finish before reading the value of the shared variable using the `read()` function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您启动所需数量的goroutine。每个goroutine调用`addDot（）`函数来访问共享变量：然后等待它们完成，然后使用`read（）`函数读取共享变量的值。
- en: 'The output you will get from executing `mutexSimple.go` will be similar to
    the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`mutexSimple.go`将生成类似以下的输出：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using sync.RWMutex
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sync.RWMutex
- en: Go offers another type of mutex, called `sync.RWMutex`, that allows multiple
    readers to hold the lock but only a single writer - `sync.RWMutex` is an extension
    of `sync.Mutex` that adds two methods named `sync.RLock` and `sync.RUnlock`, which
    are used for locking and unlocking for reading purposes. Locking and unlocking
    a `sync.RWMutex` for exclusive writing should be done with `Lock()` and `Unlock()`,
    respectively.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了另一种类型的互斥体，称为`sync.RWMutex`，它允许多个读取者持有锁，但只允许单个写入者 - `sync.RWMutex`是`sync.Mutex`的扩展，添加了两个名为`sync.RLock`和`sync.RUnlock`的方法，用于读取目的的锁定和解锁。对于独占写入，应分别使用`Lock（）`和`Unlock（）`来锁定和解锁`sync.RWMutex`。
- en: 'This means that either one writer can hold the lock or multiple readers: not
    both! You will most likely use such a mutex when most of the goroutines want to
    read a variable and you do not want goroutines to wait in order to get an exclusive
    lock.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要么一个写入者可以持有锁，要么多个读取者可以持有锁：不能同时两者都有！当大多数goroutine想要读取一个变量而您不希望goroutine等待以获取独占锁时，您很可能会使用这样的互斥体。
- en: 'In order to demystify `sync.RWMutex` a little, you should discover that the
    `sync.RWMutex` type is a Go structure currently defined as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`sync.RWMutex`变得更加透明，您应该发现`sync.RWMutex`类型是一个Go结构，当前定义如下：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: So, there is nothing to be afraid of here! Now, it is time to see a Go program
    that uses `sync.RWMutex`. The program will be named `mutexRW.go` and will be presented
    in five parts.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里没有什么可害怕的！现在，是时候看一个使用`sync.RWMutex`的Go程序了。该程序将被命名为`mutexRW.go`，并将分为五个部分呈现。
- en: 'The first part of `mutexRW.go` contains with the expected preamble as well
    as the definition of a global variable and a new `struct` type:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutexRW.go`的第一部分包含预期的序言以及全局变量和新的`struct`类型的定义：'
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `secret` structure embeds `sync.RWMutex` and therefore it can call all the
    methods of `sync.RWMutex`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret`结构嵌入了`sync.RWMutex`，因此它可以调用`sync.RWMutex`的所有方法。'
- en: 'The second part of `mutexRW.go` has the following Go code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutexRW.go`的第二部分包含以下Go代码：'
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function makes changes to one of its arguments, which means that it requires
    an exclusive lock, hence the use of the `Lock()` and `Unlock()` functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数对其一个参数进行更改，这意味着它需要一个独占锁，因此使用了`Lock（）`和`Unlock（）`函数。
- en: 'The third part of the sample code is the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的第三部分如下：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, you can see the definition of two functions that use an `sync.RWMutex`
    for reading. This means that multiple instances of them can get the `sync.RWMutex`
    lock.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到使用`sync.RWMutex`进行读取的两个函数的定义。这意味着它们的多个实例可以获取`sync.RWMutex`锁。
- en: 'The fourth portion of the program is the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第四部分如下：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, you start five goroutines in order to make things more interesting and
    random.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您启动五个goroutine以使事情更有趣和随机。
- en: 'The last part of `mutexRW.go` is the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutexRW.go`的最后一部分如下：'
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Although shared memory and the use of a mutex are still a valid approach to
    concurrent programming, using goroutines and channels is a more modern way that
    follows the Go philosophy. Therefore, if you can solve a problem using channels
    and pipelines, you should prefer that way instead of using shared variables.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管共享内存和使用互斥体仍然是并发编程的有效方法，但使用goroutine和通道是一种更现代的方式，符合Go的哲学。因此，如果可以使用通道和管道解决问题，您应该优先选择这种方式，而不是使用共享变量。
- en: 'Executing `mutexRW.go` will generate the following output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`mutexRW.go`将生成以下输出：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If the implementation of `Change()` was using a `RLock()` call as well as a
    `RUnlock()` call, which would have been totally wrong, then the output of the
    program would have been the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Change()`的实现也使用了`RLock()`调用以及`RUnlock()`调用，那将是完全错误的，那么程序的输出将如下所示：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Put simply, you should be fully aware of the locking mechanism you are using
    and the way it works. In this case, it is the timing that is deciding what `Counts()`
    will return: the timing depends on the `time.Sleep()` call of the `Change()` function
    that emulates the processing that will happen in a real function. The problem
    is that the use of `RLock()` and `RUnlock()` in `Change()` allows multiple goroutines
    to read the shared variable and therefore get the wrong output from the `Counts()`
    function.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你应该充分了解你正在使用的锁定机制以及它的工作方式。在这种情况下，决定`Counts()`将返回什么的是时间：时间取决于`Change()`函数中的`time.Sleep()`调用，它模拟了实际函数中将发生的处理。问题在于，在`Change()`中使用`RLock()`和`RUnlock()`允许多个goroutine读取共享变量，因此从`Counts()`函数中获得错误的输出。
- en: The dWC.go utility revisited
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视dWC.go实用程序
- en: In this section, we will change the implementation of the `dWC.go` utility developed
    in the previous chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将改变在上一章中开发的`dWC.go`实用程序的实现。
- en: The first version of the program will use a buffered channel whereas the second
    version of the program will use shared memory for keeping the counts for each
    file you process.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一个版本将使用缓冲通道，而程序的第二个版本将使用共享内存来保持你处理的每个文件的计数。
- en: Using a buffered channel
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓冲通道
- en: The name of this implementation will be `WCbuffered.go` and will be presented
    in five parts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的名称将是`WCbuffered.go`，并将分为五个部分呈现。
- en: 'The first part of the utility is the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的第一部分如下：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `File` structure will keep the counts for each input file. The second chunk
    of `WCbuffered.go` has the following Go code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`结构将为每个输入文件保留计数。`WCbuffered.go`的第二部分包含以下Go代码：'
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `monitor()` function collects all the information and prints it. The `for`
    loop inside `monitor()` makes sure that it will collect the right amount of data.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`monitor()`函数收集所有信息并打印出来。`monitor()`内部的`for`循环确保它将收集到正确数量的数据。'
- en: 'The third part of the program contains the implementation of the `count()`
    function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第三部分包含了`count()`函数的实现：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When the `count()` function is done, it sends the information to the buffered
    channel, so there is nothing special here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当`count()`函数完成时，它会将信息发送到缓冲通道，因此这里没有什么特别的。
- en: 'The fourth portion of `WCbuffered.go` is the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`WCbuffered.go`的第四部分如下：'
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, you create a buffered channel named `values` with as many places as the
    number of files you will process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个名为`values`的缓冲通道，其位置数与你将处理的文件数相同。
- en: 'The last portion of the utility is the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的最后一部分如下：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using shared memory
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享内存
- en: The good thing with shared memory and mutexes is that, in theory, they usually
    take a very small amount of the code, which means that the rest of the code can
    work concurrently without any other delays. However, only after you have implemented
    something can you see what really happens!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存和互斥锁的好处在于，理论上它们通常只占用很小一部分代码，这意味着其余的代码可以在没有其他延迟的情况下并发工作。然而，只有在你实现了某些东西之后，你才能看到真正发生了什么！
- en: 'The name of this implementation will be `WCshared.go` and will be presented
    in five parts: the first part of the utility is the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的名称将是`WCshared.go`，并将分为五个部分：实用程序的第一部分如下：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `values` slice will be the shared variable of the program whereas the name
    of the mutex variable will be `aM`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`切片将是程序的共享变量，而互斥变量的名称将是`aM`。'
- en: 'The second chunk of `WCshared.go` has the following Go code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`WCshared.go`的第二部分包含以下Go代码：'
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: So, just before the `count()` function exits, it adds an element to the values
    slice using a critical section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`count()`函数退出之前，它会使用临界区向`values`切片添加一个元素。
- en: 'The third part of `WCshared.go` is the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`WCshared.go`的第三部分如下：'
- en: '[PRE64]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, you just deal with the command-line arguments of the utility.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需要处理实用程序的命令行参数。
- en: 'The fourth part of `WCshared.go` contains the following Go code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`WCshared.go`的第四部分包含以下Go代码：'
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, you just start the desired number of goroutines and wait for them to finish
    their jobs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需启动所需数量的goroutine，并等待它们完成工作。
- en: 'The last code slice of the utility is the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实用程序的最后一部分如下：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When all goroutines are done, it is time to process the contents of the shared
    variable, calculate totals, and print the desired output. Note that in this case,
    there is no shared variable of any kind and therefore there is no need for a mutex:
    you just wait to gather all results and print them.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有goroutine都完成时，就该处理共享变量的内容，计算总数，并打印所需的输出。请注意，在这种情况下，没有任何类型的共享变量，因此不需要互斥锁：你只需等待收集所有结果并打印它们。
- en: More benchmarking
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的基准测试
- en: 'This section will measure the performance of `WCbuffered.go` and `WCshared.go`
    using the handy `time(1)` utility. However, this time, instead of presenting a
    graph, I will give you the actual output of the `time(1)` utility:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将使用方便的`time(1)`实用程序来测量`WCbuffered.go`和`WCshared.go`的性能。然而，这一次，我不会呈现图表，而是会给你`time(1)`实用程序的实际输出：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, both utilities performed equally well, or equally badly if you
    prefer! However, apart from the speed of a program, what also matters is the clarity
    of its design and how easy it is to make code changes to it! Additionally, the
    presented way also times the compile times of both utilities, which might make
    the results less accurate.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这两个实用程序的性能都很好，或者如果你愿意的话，也可以说都很糟糕！然而，除了程序的速度之外，还有其设计的清晰度以及对其进行代码更改的易用性也很重要！此外，所呈现的方式还会计算这两个实用程序的编译时间，这可能会使结果不太准确。
- en: The reason that both programs can easily generate totals is that they both have
    a control point. For the `WCshared.go` utility, the control point is the shared
    variable, whereas for `WCbuffered.go`, the control point is the buffered channel
    that collects the desired information inside the `monitor()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个程序之所以能够轻松生成总数，是因为它们都有一个控制点。对于`WCshared.go`实用程序，控制点是共享变量，而对于`WCbuffered.go`，控制点是在`monitor()`函数内收集所需信息的缓冲通道。
- en: Detecting race conditions
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测竞争条件
- en: If you use the `-race` flag when running or building a Go program, you will
    turn on the Go **race detector**, which makes the compiler create a modified version
    of the typical executable file. This modified version can record the accesses
    to shared variables as well as all synchronization events that take place, including
    calls to `sync.Mutex`, `sync.WaitGroup`, and so on. After doing some analysis
    of the events, the race detector prints a report that can help you identify potential
    problems so that you can correct them.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行或构建Go程序时使用`-race`标志，将启用Go **竞争检测器**，这将使编译器创建典型可执行文件的修改版本。这个修改版本可以记录对共享变量的访问以及发生的所有同步事件，包括对`sync.Mutex`、`sync.WaitGroup`等的调用。在对事件进行一些分析后，竞争检测器会打印一个报告，可以帮助您识别潜在问题，以便您可以纠正它们。
- en: In order to showcase the operation of the race detector, we will use the code
    of the `rd.go` program, which will be presented in four parts. For this particular
    program, the **data race** will happen because two or more goroutines access the
    same variable concurrently and at least one of them changes the value of the variable
    in some way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示竞争检测器的操作，我们将使用`rd.go`程序的代码，它将分为四个部分呈现。对于这个特定的程序，**数据竞争**将会发生，因为两个或更多的goroutine同时访问同一个变量，并且其中至少一个以某种方式改变了变量的值。
- en: Note that the `main()` program is also a goroutine in Go!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`main()`程序在Go中也是一个goroutine！
- en: 'The first part of the program is the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一部分如下：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Nothing special here, so if there is a problem with the program, it is not in
    the preamble.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的，所以如果程序有问题，那就不是在前言中。
- en: 'The second part of `rd.go` is the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`rd.go`的第二部分如下：'
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Once again, there is no problem in this particular code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的代码中，没有任何问题。
- en: 'The third segment of `rd.go` has the following Go code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`rd.go`的第三部分具有以下Go代码：'
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This code is very suspicious because you try to print the value of a variable
    that keeps changing all the time because of the `for` loop.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常可疑，因为您试图打印一个由于`for`循环而不断变化的变量的值。
- en: 'The last part of `rd.go` is the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`rd.go`的最后一部分如下：'
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There is nothing special in the last chunk of code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分代码中没有什么特别的。
- en: 'Enabling the Go race detector for `rd.go` will generate the following output:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为`rd.go`启用Go竞争检测器将生成以下输出：
- en: '[PRE72]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, the race detector found two data races. The first one happens when number
    `1` was not printed at all and the second when number `4` was printed two times.
    Additionally, number `0` was not printed despite being the initial value of `i`.
    Last, you should not get number `10` in the output but you did get it because
    the last value of `i` is indeed `10`. Note that the `main.main.func1()` notation
    found in the preceding output means that Go talks about an anonymous function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，竞争检测器发现了两个数据竞争。第一个发生在数字`1`根本没有被打印出来时，第二个发生在数字`4`被打印两次时。此外，尽管`i`的初始值是数字`0`，但数字`0`并没有被打印出来。最后，你不应该在输出中得到数字`10`，但你确实得到了，因为`i`的最后一个值确实是`10`。请注意，在前面的输出中找到的`main.main.func1()`表示Go谈论的是一个匿名函数。
- en: Put simply, what the previous two messages tell you is that there is something
    wrong with the `i` variable because it keeps changing while the goroutines of
    the program try to read it. Additionally, you cannot deterministically tell what
    will happen first.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，前两条消息告诉您的是，`i`变量有问题，因为当程序的goroutine尝试读取它时，它一直在变化。此外，您无法确定地告诉会先发生什么。
- en: 'Running the same program without the race detector will generate the following
    output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有竞争检测器的情况下运行相同的程序将生成以下输出：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The problem with `rd.go` can be found in the anonymous function. As the anonymous
    function takes no arguments, it uses the current value of `i`, which cannot be
    determined with any certainty as it depends on the operating system and the Go
    scheduler: this is where the race situation happens! So, have in mind that one
    of the easiest places to have a race condition is inside a goroutine spawned from
    an anonymous function! As a result, if you have to solve such as situation, start
    by converting the anonymous function into regular functions with defined arguments!'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`rd.go`中的问题可以在匿名函数中找到。由于匿名函数不带参数，它使用`i`的当前值，这个值无法确定，因为它取决于操作系统和Go调度程序：这就是竞争情况发生的地方！因此，请记住，最容易出现竞争条件的地方之一是在从匿名函数生成的goroutine内部！因此，如果您必须解决这种情况，请首先将匿名函数转换为具有定义参数的常规函数！'
- en: Programs that use the race detector are slower and need more RAM than the same
    programs without the race detector. Last, if the race detector has nothing to
    report, it will generate no output.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用竞争检测器的程序比没有竞争检测器的程序更慢，需要更多的RAM。最后，如果竞争检测器没有任何报告，它将不会生成任何输出。
- en: About GOMAXPROCS
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于GOMAXPROCS
- en: The `GOMAXPROCS` environment variable (and Go function) allows you to limit
    the number of operating system threads that can execute user-level Go code simultaneously.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOMAXPROCS`环境变量（和Go函数）允许您限制可以同时执行用户级Go代码的操作系统线程的数量。'
- en: Starting with Go version 1.5, the default value of `GOMAXPROCS` should be the
    number of cores available on your Unix system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从Go版本1.5开始，默认值`GOMAXPROCS`应该是您的Unix系统上可用的核心数。
- en: Although using a `GOMAXPROCS` value that is smaller than the number of the cores
    a Unix machine has might affect the performance of a program, specifying a `GOMAXPROCS`
    value that is bigger than the number of the available cores will not make your
    program run faster!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Unix机器上使用小于核心数的`GOMAXPROCS`值可能会影响程序的性能，但指定大于可用核心数的`GOMAXPROCS`值不会使程序运行更快！
- en: The code of `goMaxProcs.go` allows you to determine the value of the `GOMAXPROCS`
    - it will be presented in two parts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`goMaxProcs.go`的代码允许您确定`GOMAXPROCS`的值-它将分为两部分呈现。'
- en: 'The first part is the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分如下：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The second part is the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分如下：
- en: '[PRE75]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Executing `goMaxProcs.go` on an Intel i7 machine with hyper threading support
    and the latest Go version gives the following output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持超线程的Intel i7机器上执行`goMaxProcs.go`并使用最新的Go版本会得到以下输出：
- en: '[PRE76]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'However, if you execute `goMaxProcs.go` on a Debian Linux machine that runs
    an older Go version and has an older processor, it will generate the following
    output:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您在运行旧版Go的Debian Linux机器上执行`goMaxProcs.go`并且有一个旧处理器，它将生成以下输出：
- en: '[PRE77]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The way to change the value of `GOMAXPROCS` on the fly is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 动态更改`GOMAXPROCS`的值的方法如下：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'However, putting a value bigger than `256` will not work:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，设置大于`256`的值将不起作用：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Last, have in mind that if you are running a concurrent program such as `dWC.go`
    using a single core, the concurrent version of the program might not be faster
    than the version of the program without goroutines! In some situations, this happens
    because the use of goroutines as well as the various calls to the `sync.Add`,
    `sync.Wait`, and `sync.Done` functions slows down the performance of a program.
    This can be verified by the following output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，如果您使用单个核心运行诸如`dWC.go`之类的并发程序，则并发版本的程序可能不会比没有goroutines的程序版本运行得更快！在某些情况下，这是因为goroutines的使用以及对`sync.Add`、`sync.Wait`和`sync.Done`函数的各种调用会减慢程序的性能。可以通过以下输出来验证：
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Exercises
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Read carefully the documentation page of the `sync` package that can be found
    at [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/).
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细阅读可以在[https://golang.org/pkg/sync/](https://golang.org/pkg/sync/)找到的`sync`包的文档页面。
- en: Try to implement `dWC.go` using a different shared memory technique than the
    one used in this chapter.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用与本章节中使用的不同的共享内存技术来实现`dWC.go`。
- en: Implement a `struct` data type that holds your account balance and make functions
    that read the amount of money you have and make changes to the money. Create an
    implementation that uses `sync.RWMutex` and another one that uses `sync.Mutex`.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`struct`数据类型，它保存您的账户余额，并创建读取您拥有的金额并对金额进行更改的函数。创建一个使用`sync.RWMutex`和另一个使用`sync.Mutex`的实现。
- en: What would happen to `mutexRW.go` if you used `Lock()` and `Unlock()` everywhere
    instead of `RLock()` and `RUnlock()`?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在`mutexRW.go`中到处使用`Lock()`和`Unlock()`而不是`RLock()`和`RUnlock()`，会发生什么？
- en: Try to implement `traverse.go` from [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)*,*
    *Files and Directories* using goroutines.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用goroutines从[第5章](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)*,* *文件和目录*中实现`traverse.go`。
- en: Try to create an implementation of `improvedFind.go` from [Chapter 5](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)*,*
    *Files and Directories* using goroutines.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用goroutines从[第5章](543026ff-1c69-45b5-ae56-68b1fe41bc83.xhtml)*,* *文件和目录*中创建`improvedFind.go`的实现。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter talked about some advanced Go features related to goroutines, channels,
    and concurrent programming. However, the moral of this chapter is that channels
    can do many things and can be used in many situations, which means that the developer
    must be able to choose the appropriate technique to implement a task based on
    their experience.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了与goroutines、通道和并发编程相关的一些高级Go特性。然而，本章的教训是通道可以做很多事情，并且可以在许多情况下使用，这意味着开发人员必须能够根据自己的经验选择适当的技术来实现任务。
- en: The subject of the next chapter will be web development in Go and it will contain
    very interesting material, including sending and receiving JSON data, developing
    web servers and web clients, as well as talking to a MongoDB database from your
    Go code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章的主题将是Go中的Web开发，其中将包含非常有趣的材料，包括发送和接收JSON数据，开发Web服务器和Web客户端，以及从您的Go代码与MongoDB数据库交互。
