- en: Creating Your First Server in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中创建你的第一个服务器
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating a simple HTTP server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的HTTP服务器
- en: Implementing basic authentication on a simple HTTP server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个简单的HTTP服务器上实现基本身份验证
- en: Optimizing HTTP server responses with GZIP compression
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GZIP压缩优化HTTP服务器响应
- en: Creating a simple TCP server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的TCP服务器
- en: Reading data from a TCP connection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从TCP连接读取数据
- en: Writing data to a TCP connection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向TCP连接写入数据
- en: Implementing HTTP request routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现HTTP请求路由
- en: Implementing HTTP request routing using Gorilla Mux
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux实现HTTP请求路由
- en: Logging HTTP requests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录HTTP请求
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Go was created to solve the problems that came with the new architecture of
    multi-core processors, creating high-performance networks that serve millions
    of requests and compute-intensive jobs. The idea behind Go was to increase productivity
    by enabling rapid prototyping, decreasing compile and build time, and enabling
    better dependency management.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go是为了解决多核处理器的新架构带来的问题而创建的，它创建了高性能网络，可以处理数百万个请求和计算密集型任务。Go的理念是通过实现快速原型设计、减少编译和构建时间以及实现更好的依赖管理来提高生产力。
- en: Unlike most other programming languages, Go provides the `net/http` package,
    which is sufficient when creating HTTP clients and servers. This chapter will
    cover the creation of HTTP and TCP servers in Go.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他编程语言不同，Go提供了`net/http`包，用于创建HTTP客户端和服务器。本章将介绍在Go中创建HTTP和TCP服务器。
- en: We will start with some simple recipes to create an HTTP and TCP server and
    will gradually move to recipes that are more complex, where we implement basic
    authentication, optimize server responses, define multiple routes, and log HTTP
    requests. We will also cover concepts and keywords such as Go Handlers, Goroutines,
    and Gorilla – a web toolkit for Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些简单的示例开始，创建一个HTTP和TCP服务器，并逐渐转向更复杂的示例，其中我们实现基本身份验证、优化服务器响应、定义多个路由和记录HTTP请求。我们还将涵盖Go处理程序、Goroutines和Gorilla等概念和关键字-Go的Web工具包。
- en: Creating a simple HTTP server
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的HTTP服务器
- en: As a programmer, if you have to create a simple HTTP server then you can easily
    write it using Go's `net/http` package, which we will be covering in this recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，如果你需要创建一个简单的HTTP服务器，那么你可以很容易地使用Go的`net/http`包来编写，我们将在这个示例中介绍。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to create a simple HTTP server that will render
    Hello World! when we browse `http://localhost:8080` or execute `curl` `http://localhost:8080`
    from the command line. Perform the following steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个简单的HTTP服务器，当我们在浏览器中浏览`http://localhost:8080`或在命令行中执行`curl` `http://localhost:8080`时，它将呈现Hello
    World！执行以下步骤：
- en: 'Create `http-server.go` and copy the following content:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-server.go`并复制以下内容：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the program with the following command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Once we run the program, an HTTP server will start locally listening on port
    `8080`. Opening `http://localhost:8080` in a browser will display Hello World!
    from the server, as shown in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，一个HTTP服务器将在本地监听端口`8080`。在浏览器中打开`http://localhost:8080`将显示来自服务器的Hello
    World！，如下面的屏幕截图所示：
- en: '![](img/2cff40e1-a56f-4dbf-bbbd-a61b57ab4600.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cff40e1-a56f-4dbf-bbbd-a61b57ab4600.png)'
- en: Hello World!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'Let’s understand what each line in the program means:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解程序中每一行的含义：
- en: '`package main`: This defines the package name of the program.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package main`: 这定义了程序的包名称。'
- en: '`import ( "fmt" "log" "net/http" )`: This is a preprocessor command that tells
    the Go compiler to include all files from `fmt`, `log`, and the `net/http` package.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import ( "fmt" "log" "net/http" )`: 这是一个预处理命令，告诉Go编译器包括`fmt`、`log`和`net/http`包中的所有文件。'
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" )`: We declare constants
    in the Go program using the `const` keyword. Here we declared two constants—one
    is `CONN_HOST` with localhost as a value and another one is `CONN_PORT` with `8080`
    as a value.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" )`: 我们使用`const`关键字在Go程序中声明常量。这里我们声明了两个常量-一个是`CONN_HOST`，值为localhost，另一个是`CONN_PORT`，值为`8080`。'
- en: '`func helloWorld(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello
    World!") }`: This is a Go function that takes `ResponseWriter` and `Request` as
    an input and writes `Hello World!` on an HTTP response stream.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func helloWorld(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello
    World!") }`: 这是一个Go函数，它以`ResponseWriter`和`Request`作为输入，并在HTTP响应流上写入`Hello World!`。'
- en: 'Next, we declared the `main()` method from where the program execution begins,
    as this method does a lot of things. Let’s understand it line by line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了`main()`方法，程序执行从这里开始，因为这个方法做了很多事情。让我们逐行理解它：
- en: '`http.HandleFunc("/", helloWorld)`: Here, we are registering the `helloWorld`
    function with the `/` URL pattern using `HandleFunc` of the `net/http` package,
    which means `helloWorld` gets executed, passing `(http.ResponseWriter`, `*http.Request)`
    as a parameter to it whenever we access the HTTP URL with pattern `/`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.HandleFunc("/", helloWorld)`: 在这里，我们使用`net/http`包的`HandleFunc`注册了`helloWorld`函数与`/`URL模式，这意味着每当我们访问具有模式`/`的HTTP
    URL时，`helloWorld`会被执行，并将`(http.ResponseWriter`, `*http.Request)`作为参数传递给它。'
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here, we are calling
    `http.ListenAndServe` to serve HTTP requests that handle each incoming connection
    in a separate Goroutine. `ListenAndServe` accepts two parameters—server address
    and handler. Here, we are passing the server address as `localhost:8080` and handler
    as `nil`, which means we are asking the server to use `DefaultServeMux` as a handler.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: 在这里，我们调用`http.ListenAndServe`来处理每个传入连接的HTTP请求，每个连接在一个单独的Goroutine中处理。`ListenAndServe`接受两个参数-服务器地址和处理程序。在这里，我们将服务器地址传递为`localhost:8080`，处理程序为`nil`，这意味着我们要求服务器使用`DefaultServeMux`作为处理程序。'
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here, we check whether there is a problem starting the server. If there is, then
    log the error and exit with a status code of `1`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Fatal("error starting http server : ", err) return}`：在这里，我们检查是否有问题启动服务器。如果有问题，那么记录错误并以状态码`1`退出。'
- en: Implementing basic authentication on a simple HTTP server
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在简单的HTTP服务器上实现基本身份验证
- en: Once you have created the HTTP server then you probably want to restrict resources
    from being accessed by a specific user, such as the administrator of an application.
    If so, then you can implement basic authentication on an HTTP server, which we
    will be covering in this recipe.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了HTTP服务器，您可能希望限制特定用户访问资源，例如应用程序的管理员。如果是这样，那么您可以在HTTP服务器上实现基本身份验证，我们将在这个配方中介绍。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we have already created an HTTP server in our previous recipe, we will just
    extend it to incorporate basic authentication.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一个配方中创建了一个HTTP服务器，我们只需扩展它以包含基本身份验证。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to update the HTTP server we created in the previous
    recipe by adding a `BasicAuth` function and modifying the `HandleFunc` to call
    it. Perform the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过添加`BasicAuth`函数并修改`HandleFunc`来调用它来更新我们在上一个配方中创建的HTTP服务器。执行以下步骤：
- en: 'Create `http-server-basic-authentication.go` and copy the following content:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-server-basic-authentication.go`并复制以下内容：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the program with the following command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`上启动。
- en: Once the server starts, accessing `http://localhost:8080` in a browser will
    prompt you to enter a username and password. Providing it as `admin`, `admin`
    respectively will render Hello World! on the screen, and for every other combination
    of username and password it will render You are Unauthorized to access the application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，在浏览器中访问`http://localhost:8080`将提示您输入用户名和密码。提供`admin`，`admin`将在屏幕上呈现Hello
    World！对于其他用户名和密码的组合，它将呈现您未经授权访问应用程序。
- en: 'To access the server from the command line we have to provide the `--user`
    flag as part of the `curl` command, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行访问服务器，我们必须在`curl`命令中提供`--user`标志，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also access the server using a `base64` encoded token of `username:password`,
    which we can get from any website, such as `https://www.base64encode.org/`, and
    pass it as an authorization header in the `curl` command, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`base64`编码的`username:password`令牌访问服务器，我们可以从任何网站（例如`https://www.base64encode.org/`）获取，并将其作为`curl`命令中的授权标头传递，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s understand the change we introduced as part of this recipe:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们引入的更改作为这个配方的一部分：
- en: The `import` function adds an additional package, `crypto/subtle`, which we
    will use to compare the username and password from the user's entered credentials.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import`函数添加了一个额外的包，`crypto/subtle`，我们将使用它来比较用户输入凭据中的用户名和密码。'
- en: Using the `const` function we defined two additional constants, `ADMIN_USER`
    and `ADMIN_PASSWORD`, which we will use while authenticating the user.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`const`函数，我们定义了两个额外的常量，`ADMIN_USER`和`ADMIN_PASSWORD`，我们将在验证用户时使用它们。
- en: 'Next, we declared a `BasicAuth()` method, which accepts two input parameters—a
    handler, which executes after the user is successfully authenticated, and realm,
    which returns `HandlerFunc`, as follows:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们声明了一个`BasicAuth()`方法，它接受两个输入参数——一个处理程序，在用户成功验证后执行，和一个领域，返回`HandlerFunc`，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding handler, we first get the username and password provided in
    the request's authorization header using `r.BasicAuth()` then compare it to the
    constants declared in the program. If credentials match, then it returns the handler,
    otherwise it sets `WWW-Authenticate` along with a status code of `401` and writes
    `You are Unauthorized to access the application` on an HTTP response stream.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的处理程序中，我们首先使用`r.BasicAuth()`获取请求的授权标头中提供的用户名和密码，然后将其与程序中声明的常量进行比较。如果凭据匹配，则返回处理程序，否则设置`WWW-Authenticate`以及状态码`401`，并在HTTP响应流上写入`You
    are Unauthorized to access the application`。
- en: 'Finally, we introduced a change in the `main()` method to call `BasicAuth`
    from `HandleFunc`, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`main()`方法中引入了一个更改，以从`HandleFunc`中调用`BasicAuth`，如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We just pass a `BasicAuth` handler instead of `nil` or `DefaultServeMux` for
    handling all incoming requests with the URL pattern as `/`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需传递一个`BasicAuth`处理程序，而不是`nil`或`DefaultServeMux`来处理所有带有URL模式为`/`的传入请求。
- en: Optimizing HTTP server responses with GZIP compression
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GZIP压缩优化HTTP服务器响应
- en: GZIP compression means sending the response to the client from the server in
    a `.gzip` format rather than sending a plain response and it’s always a good practice
    to send compressed responses if a client/browser supports it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: GZIP压缩意味着从服务器以`.gzip`格式向客户端发送响应，而不是发送纯文本响应，如果客户端/浏览器支持的话，发送压缩响应总是一个好习惯。
- en: 'By sending a compressed response we save network bandwidth and download time
    eventually rendering the page faster. What happens in GZIP compression is the
    browser sends a request header telling the server it accepts compressed content
    (`.gzip` and `.deflate`) and if the server has the capability to send the response
    in compressed form then sends it. If the server supports compression then it sets
    `Content-Encoding: gzip` as a response header, otherwise it sends a plain response
    back to the client, which clearly means asking for a compressed response is only
    a request by the browser and not a demand. We will be using Gorilla’s handlers
    package to implement it in this recipe.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '通过发送压缩响应，我们节省了网络带宽和下载时间，最终使页面加载更快。 GZIP压缩的原理是浏览器发送一个请求标头，告诉服务器它接受压缩内容（`.gzip`和`.deflate`），如果服务器有能力以压缩形式发送响应，则发送压缩形式的响应。如果服务器支持压缩，则它将设置`Content-Encoding:
    gzip`作为响应标头，否则它将向客户端发送一个纯文本响应，这清楚地表示要求压缩响应只是浏览器的请求，而不是要求。我们将使用Gorilla的handlers包在这个配方中实现它。'
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to create an HTTP server with a single handler,
    which will write Hello World! on an HTTP response stream and use a Gorilla `CompressHandler`
    to send all the responses back to the client in the `.gzip` format. Perform the
    following steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个带有单个处理程序的HTTP服务器，该处理程序将在HTTP响应流上写入Hello World！并使用Gorilla `CompressHandler`以`.gzip`格式将所有响应发送回客户端。执行以下步骤：
- en: 'To use Gorilla handlers, first we need to install the package using the `go
    get` command or copy it manually to `$GOPATH/src` or `$GOPATH`, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大猩猩处理程序，首先我们需要使用`go get`命令安装包，或者手动将其复制到`$GOPATH/src`或`$GOPATH`，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create `http-server-mux.go` and copy the following content:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-server-mux.go`并复制以下内容：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the program with the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，HTTP服务器将在本地监听端口`8080`。
- en: 'Opening `http://localhost:8080` in a browser will display Hello World! from
    the server with the Content-Encoding response header value gzip, as shown in the
    following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:8080`将显示来自服务器的Hello World！并显示Content-Encoding响应头值gzip，如下面的屏幕截图所示：
- en: '![](img/7dc5f016-1d66-4503-bdeb-752523842b72.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dc5f016-1d66-4503-bdeb-752523842b72.png)'
- en: Hello World!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'Let’s understand what each line in the program means:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解程序中每一行的含义：
- en: '`package main`: This defines the package name of the program.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package main`：这定义了程序的包名称。'
- en: '`import ( "io" "net/http" "github.com/gorilla/handlers" )`: This is a preprocessor
    command that tells the Go compiler to include all files from `io`, `net/http`,
    and the `github.com/gorilla/handlers` package.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import ( "io" "net/http" "github.com/gorilla/handlers" )`: 这是一个预处理命令，告诉Go编译器包括来自`io`、`net/http`和`github.com/gorilla/handlers`包的所有文件。'
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" )`: We declare constants
    in a Go program using the const keyword. Here, we declared two constants—one is
    `CONN_HOST` with a value of localhost and another is `CONN_PORT` with a value
    of 8080.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" )`: 我们使用const关键字在Go程序中声明常量。在这里，我们声明了两个常量，一个是值为localhost的`CONN_HOST`，另一个是值为8080的`CONN_PORT`。'
- en: '`func helloWorld(w http.ResponseWriter, r *http.Request) { io.WriteString(w,
    "Hello World!")}`: This is a Go function that takes `ResponseWriter` and `Request`
    as input parameters and writes `Hello World!` on the HTTP response stream.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func helloWorld(w http.ResponseWriter, r *http.Request) { io.WriteString(w,
    "Hello World!")}`: 这是一个接受`ResponseWriter`和`Request`作为输入参数并在HTTP响应流上写入`Hello World!`的Go函数。'
- en: 'Next, we declared the `main()` method from where the program execution begins.
    As this method does a lot of things, let’s understand it line by line:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明了`main()`方法，程序的执行从这里开始。由于这个方法做了很多事情，让我们逐行理解它：
- en: '`mux := http.NewServeMux()`: This allocates and returns a new HTTP request
    multiplexer (`ServeMux`), which matches the URL of each incoming request against
    a list of registered patterns and calls the handler for the pattern that most
    closely matches the URL. One of the benefits of using it is that the program has
    complete control over the handlers used with the server, although any handlers
    registered with the `DefaultServeMux` are ignored.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mux := http.NewServeMux()`: 这将分配并返回一个新的HTTP请求多路复用器（`ServeMux`），它将匹配每个传入请求的URL与已注册模式列表，并调用最接近URL的模式的处理程序。使用它的好处之一是程序完全控制与服务器一起使用的处理程序，尽管任何使用`DefaultServeMux`注册的处理程序都将被忽略。'
- en: '`http.HandleFunc("/", helloWorld)`: Here, we are registering the `helloWorld`
    function with the `/` URL pattern using `HandleFunc` of the `net/http` package,
    which means `helloWorld` gets executed, passing `(http.ResponseWriter`, `*http.Request)`
    as a parameter to it whenever we access the HTTP URL with the `/` pattern.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.HandleFunc("/", helloWorld)`: 在这里，我们使用`net/http`包的`HandleFunc`将`helloWorld`函数注册到`/`URL模式，这意味着每当我们访问具有`/`模式的HTTP
    URL时，`helloWorld`将被执行，并将`(http.ResponseWriter`, `*http.Request)`作为参数传递给它。'
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, handlers.CompressHandler(mux))`:
    Here, we are calling `http.ListenAndServe` to serve HTTP requests that handle
    each incoming connection in a separate Goroutine for us. `ListenAndServe` accepts
    two parameters—server address and handler. Here, we are passing the server address
    as `localhost:8080` and handler as `CompressHandler`, which wraps our server with
    a `.gzip` handler to compress all responses in a `.gzip` format.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, handlers.CompressHandler(mux))`:
    在这里，我们调用`http.ListenAndServe`来为我们处理每个传入连接的HTTP请求。`ListenAndServe`接受两个参数——服务器地址和处理程序。在这里，我们将服务器地址传递为`localhost:8080`，处理程序为`CompressHandler`，它用`.gzip`处理程序包装我们的服务器以将所有响应压缩为`.gzip`格式。'
- en: '`if err != nil { log.Fatal("error starting http server: ", err) return}`: Here,
    we check whether there is any problem in starting the server. If there is, then
    log the error and exit with a status code of 1.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Fatal("error starting http server: ", err) return}`: 在这里，我们检查是否有任何启动服务器的问题。如果有问题，记录错误并以状态码1退出。'
- en: Creating a simple TCP server
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的TCP服务器
- en: Whenever you have to build high performance oriented systems then writing a
    TCP server is always the best choice over an HTTP server, as TCP sockets are less
    hefty than HTTP. Go supports and provides a convenient way of writing TCP servers
    using a `net` package, which we will be covering in this recipe.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要构建高性能导向系统时，编写TCP服务器总是优于HTTP服务器的最佳选择，因为TCP套接字比HTTP更轻。Go支持并提供了一种方便的方法来编写使用`net`包的TCP服务器，我们将在本教程中介绍。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to create a simple TCP server that will accept
    a connection on `localhost:8080`. Perform the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个简单的TCP服务器，它将在`localhost:8080`上接受连接。执行以下步骤：
- en: 'Create `tcp-server.go` and copy the following content:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`tcp-server.go`并复制以下内容：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the program with the following command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the TCP server will start locally listening on port
    `8080`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，TCP服务器将在本地监听端口`8080`。
- en: 'Let’s understand what each line in the program means:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解程序中每一行的含义：
- en: '`package main`: This defines the package name of the program.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package main`: 这定义了程序的包名称。'
- en: '`import ( "log" "net")`: This is a preprocessor command that tells the Go compiler
    to include all files from the `log` and `net` package.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import ( "log" "net")`: 这是一个预处理命令，告诉Go编译器包括`log`和`net`包中的所有文件。'
- en: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" CONN_TYPE = "tcp" )`: We
    declare constants in a Go program using the const keyword. Here, we declare three
    constants—one is `CONN_HOST` with a value of `localhost`, another one is `CONN_PORT`
    with a value as `8080`, and lastly `CONN_TYPE` with a value as `tcp`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const ( CONN_HOST = "localhost" CONN_PORT = "8080" CONN_TYPE = "tcp" )`: 我们使用const关键字在Go程序中声明常量。在这里，我们声明了三个常量——一个是`CONN_HOST`，值为`localhost`，另一个是`CONN_PORT`，值为`8080`，最后一个是`CONN_TYPE`，值为`tcp`。'
- en: 'Next, we declared the `main()` method from where the program execution begins.
    As this method does a lot of things, let’s understand it line by line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从`main()`方法中声明了`main()`方法，程序执行从这里开始。由于这个方法做了很多事情，让我们逐行理解它：
- en: '`listener, err := net.Listen(CONN_TYPE, CONN_HOST+":"+CONN_PORT)`: This creates
    a TCP server running on localhost at port `8080`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listener, err := net.Listen(CONN_TYPE, CONN_HOST+":"+CONN_PORT)`: 这将在本地端口`8080`上创建一个TCP服务器。'
- en: '`if err != nil { log.Fatal("Error starting tcp server: ", err) }`: Here, we
    check if there is any problem in starting the TCP server. If there is, then log
    the error and exit with a status code of 1.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Fatal("Error starting tcp server: ", err) }`: 在这里，我们检查是否有问题启动TCP服务器。如果有问题，就记录错误并以状态码1退出。'
- en: '`defer listener.Close()`: This defer statement closes a TCP socket listener
    when the application closes.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer listener.Close()`: 这个延迟语句在应用程序关闭时关闭TCP套接字监听器。'
- en: 'Next, we accept the incoming request to the TCP server in a constant loop,
    and if there are any errors in accepting the request, then we log it and exit;
    otherwise, we simply print the connection object on the server console, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在一个常量循环中接受TCP服务器的传入请求，如果在接受请求时出现任何错误，我们将记录并退出；否则，我们只是在服务器控制台上打印连接对象，如下所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Reading data from a TCP connection
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从TCP连接读取数据
- en: One of the most common scenarios in any application is the client interacting
    with the server. TCP is one of the most widely used protocols for this interaction.
    Go provides a convenient way to read incoming connection data through `bufio`
    implementing buffered `Input/Output`, which we will be covering in this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中最常见的情况之一是客户端与服务器进行交互。TCP是这种交互中最广泛使用的协议之一。Go提供了一种方便的方式通过实现缓冲的`Input/Output`来读取传入连接数据，我们将在这个示例中介绍。
- en: Getting ready…
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: As we have already created a TCP server in our previous recipe, we will update
    it to read data from incoming connections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的示例中创建了一个TCP服务器，我们将更新它以从传入连接中读取数据。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to update the `main()` method to call a `handleRequest`
    method passing the connection object to read and print data on the server console.
    Perform the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将更新`main()`方法，调用`handleRequest`方法并传递连接对象以读取和打印服务器控制台上的数据。执行以下步骤：
- en: 'Create `tcp-server-read-data.go` and copy the following content:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`tcp-server-read-data.go`并复制以下内容：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the program with the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Once we run the program, the TCP server will start locally listening on port
    `8080`. Executing an `echo` command from the command line as follows will send
    a message to the TCP server:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，TCP服务器将在本地端口`8080`上开始监听。从命令行执行`echo`命令将向TCP服务器发送消息：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This apparently logs it to a server console, as shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然会将其记录到服务器控制台，如下面的屏幕截图所示：
- en: '![](img/e852ce37-88a6-4c6a-97c9-e00988ec7752.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e852ce37-88a6-4c6a-97c9-e00988ec7752.png)'
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解这个示例中引入的变化：
- en: 'First, we called `handleRequest` from the `main()` method using the `go` keyword,
    which means we are invoking a function in a Goroutine, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`go`关键字从`main()`方法中调用`handleRequest`，这意味着我们在Goroutine中调用函数，如下所示：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we defined the `handleRequest` function, which reads an incoming connection
    into the buffer until the first occurrence of `\n` and prints the message on the
    console. If there are any errors in reading the message then it prints the error
    message along with the error object and finally closes the connection, as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`handleRequest`函数，它将传入的连接读入缓冲区，直到第一个`\n`出现，并在控制台上打印消息。如果在读取消息时出现任何错误，则打印错误消息以及错误对象，最后关闭连接，如下所示：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Writing data to a TCP connection
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向TCP连接写入数据
- en: Another common, as well as important, scenario in any web application is to
    send the data back to the client or responding to the client. Go provides a convenient
    way to write a message on a connection as bytes, which we will be covering in
    this recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中，另一个常见且重要的情况是向客户端发送数据或响应客户端。Go提供了一种方便的方式，以字节的形式在连接上写入消息，我们将在这个示例中介绍。
- en: Getting ready…
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: As we have already created a TCP server that reads incoming connection data
    in the previous recipe, we will just update it to write the message back to the
    client.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的示例中创建了一个TCP服务器，用于读取传入连接的数据，所以我们只需更新它以将消息写回客户端。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to update the `handleRequest` method in the program
    to write data back to the client. Perform the following steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将更新程序中的`handleRequest`方法，以便向客户端写入数据。执行以下步骤：
- en: 'Create `tcp-server-write-data.go` and copy the following content:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`tcp-server-write-data.go`并复制以下内容：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the program with the following command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Once we run the program, the TCP server will start locally listening on port
    `8080`. Execute an `echo` command from the command line, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，TCP服务器将在本地端口`8080`上开始监听。从命令行执行`echo`命令，如下所示：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will give us the following response from the server:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供来自服务器的以下响应：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s look at the changes we introduced in this recipe to write data to the
    client. Everything in `handleRequest` is exactly the same as in the previous recipe
    except we introduced a new line that writes data as a byte array to the connection,
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这个示例中引入的更改，以便向客户端写入数据。`handleRequest`中的一切都与上一个示例中完全相同，只是我们引入了一行新的代码，将数据作为字节数组写入连接，如下所示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing HTTP request routing
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HTTP请求路由
- en: Most of the time, you have to define more than one URL route in a web application,
    which involves mapping the URL path to the handlers or resources. In this recipe,
    we will learn how we can implement it in Go.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您必须在Web应用程序中定义多个URL路由，这涉及将URL路径映射到处理程序或资源。在这个示例中，我们将学习如何在Go中实现它。
- en: How to do it…
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will define three routes, such as `/`, `/login`, and `/logout`
    along with their handlers. Perform the following steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将定义三个路由，如`/`、`/login`和`/logout`，以及它们的处理程序。执行以下步骤：
- en: 'Create `http-server-basic-routing.go` and copy the following content:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-server-basic-routing.go`并复制以下内容：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the program with the following command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080` and accessing `http://localhost:8080/`, `http://localhost:8080/login`,
    and `http://localhost:8080/logout` from a browser or command line will render
    the message defined in the corresponding handler definition. For example, execute
    `http://localhost:8080/` from the command line, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`，并且从浏览器或命令行访问`http://localhost:8080/`、`http://localhost:8080/login`和`http://localhost:8080/logout`将呈现相应处理程序定义中的消息。例如，从命令行执行`http://localhost:8080/`，如下所示：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will give us the following response from the server:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供来自服务器的以下响应：
- en: '![](img/37497746-7f2d-4fe2-89ce-b9fcba58982c.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37497746-7f2d-4fe2-89ce-b9fcba58982c.png)'
- en: 'We could also execute `http://localhost:8080/login` from the command line as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从命令行执行`http://localhost:8080/login`，如下所示：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will give us the following response from the server:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供来自服务器的以下响应：
- en: '![](img/3278b2fb-4f05-4654-9b24-3df2751d2d03.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3278b2fb-4f05-4654-9b24-3df2751d2d03.png)'
- en: 'Let''s understand the program we have written:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序：
- en: 'We started with defining three handlers or web resources, such as the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义了三个处理程序或Web资源，如下所示：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the `helloWorld` handler writes `Hello World!` on an HTTP response stream.
    In a similar way, login and logout handlers write `Login Page!` and `Logout Page!`
    on an HTTP response stream.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`helloWorld`处理程序在HTTP响应流上写入`Hello World!`。类似地，登录和注销处理程序在HTTP响应流上写入`Login
    Page!`和`Logout Page!`。
- en: 'Next, we registered three URL paths—`/`, `/login`, and `/logout` with `DefaultServeMux`
    using `http.HandleFunc()` . If an incoming request URL pattern matches one of
    the registered paths, then the corresponding handler is called passing `(http.ResponseWriter`,
    `*http.Request)` as a parameter to it, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`http.HandleFunc()`在`DefaultServeMux`上注册了三个URL路径——`/`、`/login`和`/logout`。如果传入的请求URL模式与注册的路径之一匹配，那么相应的处理程序将被调用，并将`(http.ResponseWriter`、`*http.Request)`作为参数传递给它，如下所示：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing HTTP request routing using Gorilla Mux
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux实现HTTP请求路由
- en: Go’s `net/http` package offers a lot of functionalities for URL routing of the
    HTTP requests. One thing it doesn’t do very well is dynamic URL routing. Fortunately,
    we can achieve this with the `gorilla/mux` package, which we will be covering
    in this recipe.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`net/http`包为HTTP请求的URL路由提供了许多功能。它做得不太好的一件事是动态URL路由。幸运的是，我们可以通过`gorilla/mux`包实现这一点，我们将在这个示例中介绍。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will use `gorilla/mux` to define a few routes, like we did
    in our previous recipe, along with their handlers or resources. As we have already
    seen in one of our previous recipes, to use external packages, first we have to
    install the package using the `go get` command or we have to copy it manually
    to `$GOPATH/src` or `$GOPATH`. We will do the same in the recipe as well. Perform
    the following steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`gorilla/mux`来定义一些路由，就像我们在之前的示例中所做的那样，以及它们的处理程序或资源。正如我们在之前的示例中已经看到的，要使用外部包，首先我们必须使用`go
    get`命令安装包，或者我们必须手动将其复制到`$GOPATH/src`或`$GOPATH`。我们在这个示例中也会这样做。执行以下步骤：
- en: 'Install `github.com/gorilla/mux` using the `go get` command, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`，如下所示：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create `http-server-gorilla-mux-routing.go` and copy the following content:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-server-gorilla-mux-routing.go`并复制以下内容：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the program with the following command:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作…
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`, and accessing `http://localhost:8080/`, `http://localhost:8080/post`,
    and `http://localhost:8080/hello/foo` from a browser or command line will produce
    the message defined in the corresponding handler definition. For example, execute
    `http://localhost:8080/` from the command line, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`，并且从浏览器或命令行访问`http://localhost:8080/`、`http://localhost:8080/post`和`http://localhost:8080/hello/foo`将产生相应处理程序定义中的消息。例如，从命令行执行`http://localhost:8080/`，如下所示：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will give us the following response from the server:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供来自服务器的以下响应：
- en: '![](img/5dbedcdd-3be8-4718-af12-a6d8afb02094.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dbedcdd-3be8-4718-af12-a6d8afb02094.png)'
- en: 'We could also execute `http://localhost:8080/hello/foo` from the command line,
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从命令行执行`http://localhost:8080/hello/foo`，如下所示：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will give us the following response from the server:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供来自服务器的以下响应：
- en: '![](img/783a091d-58e2-406d-b4ac-18bb23bc2aed.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/783a091d-58e2-406d-b4ac-18bb23bc2aed.png)'
- en: 'Let''s understand the code changes we made in this recipe:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在这个示例中所做的代码更改：
- en: 'First, we defined `GetRequestHandler` and `PostRequestHandler`, which simply
    write a message on an HTTP response stream, as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义了`GetRequestHandler`和`PostRequestHandler`，它们只是在HTTP响应流上写入一条消息，如下所示：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we defined `PathVariableHandler`, which extracts request path variables,
    gets the value, and writes it to an HTTP response stream, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`PathVariableHandler`，它提取请求路径变量，获取值，并将其写入HTTP响应流，如下所示：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we registered all these handlers with the `gorilla/mux` router and instantiated
    it, calling the `NewRouter()` handler of the mux router, as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将所有这些处理程序注册到`gorilla/mux`路由器中，并对其进行实例化，调用mux路由器的`NewRouter()`处理程序，如下所示：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Logging HTTP requests
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录HTTP请求
- en: Logging HTTP requests is always useful when troubleshooting a web application,
    so it’s a good idea to log a request/response with a proper message and logging
    level. Go provides the `log` package, which can help us to implement logging in
    an application. However, in this recipe we will be using Gorilla logging handlers
    to implement it because the library offers more features such as logging in Apache
    Combined Log Format and Apache Common Log Format, which are not yet supported
    by the Go `log` package.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障排除Web应用程序时，记录HTTP请求总是很有用，因此记录具有适当消息和记录级别的请求/响应是一个好主意。Go提供了`log`包，可以帮助我们在应用程序中实现日志记录。然而，在这个示例中，我们将使用Gorilla日志处理程序来实现它，因为该库提供了更多功能，比如记录Apache
    Combined日志格式和Apache Common日志格式，这些功能目前还不受Go `log`包支持。
- en: Getting Ready…
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: As we have already created an HTTP server and defined routes using Gorilla Mux
    in our previous recipe, we will update it to incorporate Gorilla logging handlers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的示例中创建了一个HTTP服务器并使用Gorilla Mux定义了路由，我们将更新它以整合Gorilla日志处理程序。
- en: How to do it…
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s implement logging using Gorilla handlers. Perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Gorilla处理程序实现日志记录。执行以下步骤：
- en: 'Install the `github.com/gorilla/handler` and `github.com/gorilla/mux` packages
    using the `go get` command, as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/handler`和`github.com/gorilla/mux`包，如下所示：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create `http-server-request-logging.go` and copy the following content:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-server-request-logging.go`并复制以下内容：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the program, using the following command:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，使用以下命令：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Execute a `GET` request from the command line, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行`GET`请求，如下所示：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will log the request details in the server log in the Apache Common Log
    Format, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Apache Common日志格式中记录请求的详细信息，如下面的屏幕截图所示：
- en: '![](img/d0cddd33-c7b7-4425-b8b9-54c3b29abae8.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0cddd33-c7b7-4425-b8b9-54c3b29abae8.png)'
- en: 'We could also execute `http://localhost:8080/hello/foo` from the command line,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从命令行执行`http://localhost:8080/hello/foo`，如下所示：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will log the request details in the `server.log` in the Apache Combined
    Log Format, as shown in the following screenshot:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`server.log`中以Apache Combined日志格式记录请求的详细信息，如下面的屏幕截图所示：
- en: '![](img/3221304b-510c-4324-98ba-8cda9f8ac737.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3221304b-510c-4324-98ba-8cda9f8ac737.png)'
- en: 'Let''s understand what we have done in this recipe:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下在这个示例中我们做了什么：
- en: 'Firstly, we imported two additional packages, one is `os`, which we use to
    open a file. The other one is `github.com/gorilla/handlers`, which we use to import
    logging handlers for logging HTTP requests, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入了两个额外的包，一个是`os`，我们用它来打开一个文件。另一个是`github.com/gorilla/handlers`，我们用它来导入用于记录HTTP请求的日志处理程序，如下所示：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, we modified the `main()` method. Using `router.Handle("/", handlers.LoggingHandler(os.Stdout,`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改了`main()`方法。使用`router.Handle("/", handlers.LoggingHandler(os.Stdout,`
- en: '`http.HandlerFunc(GetRequestHandler))).Methods("GET")`, we wrapped `GetRequestHandler`
    with a Gorilla logging handler, and passed a standard output stream as a writer
    to it, which means we are simply asking to log every request with the URL path
    `/` on the console in Apache Common Log Format.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.HandlerFunc(GetRequestHandler))).Methods("GET")`，我们用Gorilla日志处理程序包装了`GetRequestHandler`，并将标准输出流作为写入器传递给它，这意味着我们只是要求在控制台上以Apache
    Common日志格式记录每个URL路径为`/`的请求。'
- en: 'Next, we create a new file named `server.log` in write-only mode, or we open
    it, if it already exists. If there is any error, then log it and exit with a status
    code of 1, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们以只写模式创建一个名为`server.log`的新文件，或者如果它已经存在，则打开它。如果有任何错误，那么记录下来并以状态码1退出，如下所示：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using `router.Handle("/post", handlers.LoggingHandler(logFile, PostRequestHandler)).Methods("POST")`,
    we wrapped `GetRequestHandler` with a Gorilla logging handler and passed the file
    as a writer to it, which means we are simply asking to log every request with
    the URL path `/post` in a file named `/hello/{name}` in Apache Common Log Format.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`router.Handle("/post", handlers.LoggingHandler(logFile, PostRequestHandler)).Methods("POST")`，我们用Gorilla日志处理程序包装了`GetRequestHandler`，并将文件作为写入器传递给它，这意味着我们只是要求在名为`/hello/{name}`的文件中以Apache
    Common日志格式记录每个URL路径为`/post`的请求。
- en: Using `router.Handle("/hello/{name}", handlers.CombinedLoggingHandler(logFile,
    PathVariableHandler)).Methods("GET")`, we wrapped `GetRequestHandler` with a Gorilla
    logging handler and passed the file as a writer to it, which means we are simply
    asking to log every request with the URL path `/hello/{name}` in a file named
    `server.log` in Apache Combined Log Format.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`router.Handle("/hello/{name}", handlers.CombinedLoggingHandler(logFile, PathVariableHandler)).Methods("GET")`，我们用Gorilla日志处理程序包装了`GetRequestHandler`，并将文件作为写入器传递给它，这意味着我们只是要求在名为`server.log`的文件中以Apache
    Combined日志格式记录每个URL路径为`/hello/{name}`的请求。
