- en: Working with Templates, Static Files, and HTML Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板、静态文件和HTML表单
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Creating your first template
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个模板
- en: Serving static files over HTTP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP提供静态文件
- en: Serving static files over HTTP using Gorilla Mux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux通过HTTP提供静态文件
- en: Creating your first HTML form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个HTML表单
- en: Reading your first HTML form
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读您的第一个HTML表单
- en: Validating your first HTML form
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证您的第一个HTML表单
- en: Uploading your first file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传您的第一个文件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Quite often, we would like to create HTML forms to get the information from
    a client in a specified format, upload files or folders to the server, and generate
    generic HTML templates, rather than repeating the same static text. With the knowledge
    of the concepts covered in this chapter, we will be able to implement all these
    functionalities efficiently in Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常希望创建HTML表单，以便以指定的格式从客户端获取信息，将文件或文件夹上传到服务器，并生成通用的HTML模板，而不是重复相同的静态文本。有了本章涵盖的概念知识，我们将能够在Go中高效地实现所有这些功能。
- en: In this chapter, we will start with creating a basic template and then move
    on to serve static files, such as `.js`, `.css`, and `images` from a filesystem,
    and eventually create, read, and validate HTML forms and upload a file to the
    server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从创建基本模板开始，然后继续从文件系统中提供静态文件，如`.js`、`.css`和`images`，最终创建、读取和验证HTML表单，并将文件上传到服务器。
- en: Creating your first template
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个模板
- en: Templates allow us to define placeholders for dynamic content that can be replaced
    with the values at runtime by a template engine. They can then be transformed
    into an HTML file and sent to the client. Creating templates in Go is fairly easy
    using Go's `html/template` package, which we will be covering in this recipe.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许我们定义动态内容的占位符，可以由模板引擎在运行时替换为值。然后可以将它们转换为HTML文件并发送到客户端。在Go中创建模板非常容易，使用Go的`html/template`包，我们将在本示例中介绍。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to create a `first-template.html` with a couple
    of placeholders whose value will be injected by the template engine at runtime.
    Perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个`first-template.html`，其中包含一些占位符，其值将在运行时由模板引擎注入。执行以下步骤：
- en: 'Create `first-template.html` inside the `templates` directory by executing
    the following Unix command:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下Unix命令在`templates`目录中创建`first-template.html`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Copy the following content to `first-template.html`:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`first-template.html`中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding template has two placeholders, `{{.Name}}` and `{{.Id}}`, whose
    values will be substituted or injected by the template engine at runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板有两个占位符，`{{.Name}}`和`{{.Id}}`，它们的值将由模板引擎在运行时替换或注入。
- en: 'Create `first-template.go`, where we will populate the values for the placeholders,
    generate an HTML as an output, and write it to the client, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`first-template.go`，在其中我们将为占位符填充值，生成HTML输出，并将其写入客户端，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应如下所示：
- en: '![](img/ab60eb27-0295-4b8a-9c7b-9d85f6c65b55.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/ab60eb27-0295-4b8a-9c7b-9d85f6c65b55.png)
- en: 'Run the program with the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`上启动。
- en: 'Browsing `http://localhost:8080` will show us the Hello Foo! served by the
    template engine, as shown in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览`http://localhost:8080`将显示模板引擎提供的Hello Foo！，如下截图所示：
- en: '![](img/f54a702f-1181-404b-8c55-f0502b2365fb.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f54a702f-1181-404b-8c55-f0502b2365fb.png)
- en: 'Execute `curl -X GET http://localhost:8080` from the command line as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行`curl -X GET http://localhost:8080`如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in the following response from the server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致服务器返回以下响应：
- en: '![](img/5125ff70-60b0-4b27-a291-1fd30a424f85.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/5125ff70-60b0-4b27-a291-1fd30a424f85.png)
- en: 'Let''s understand the Go program we have written:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的Go程序：
- en: '`type Person struct { Id string Name string }`: Here we define a `person` struct
    type that has `Id` and `Name` fields.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type Person struct { Id string Name string }`: 在这里，我们定义了一个`person`结构类型，具有`Id`和`Name`字段。'
- en: The field name should begin with a capital letter in the type definition; otherwise, it
    will result in errors and will not be replaced in the template.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类型定义中的字段名称应以大写字母开头；否则，将导致错误并且不会在模板中被替换。
- en: Next, we defined a `renderTemplate()` handler, which does a lot of things.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`renderTemplate()`处理程序，它执行了许多操作。
- en: '`person := Person{Id: "1", Name: "Foo"}`: Here we are initializing a `person`
    struct type with `Id` as `1` and `Name` as `Foo`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person := Person{Id: "1", Name: "Foo"}`: 在这里，我们初始化了一个`person`结构类型，其中`Id`为`1`，`Name`为`Foo`。'
- en: '`parsedTemplate, _ := template.ParseFiles("templates/first-template.html")`: Here
    we are calling `ParseFiles` of the `html/template` package, which creates a new
    template and parses the filename we pass as an input, which is `first-template.html
    ,`in a templates directory. The resulting template will have the name and contents
    of the input file.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parsedTemplate, _ := template.ParseFiles("templates/first-template.html")`:
    在这里，我们调用`html/template`包的`ParseFiles`，它创建一个新模板并解析我们传入的文件名，即`templates`目录中的`first-template.html`。生成的模板将具有输入文件的名称和内容。'
- en: '`err := parsedTemplate.Execute(w, person)`: Here we are calling an `Execute`
    handler on a parsed template, which injects `person` data into the template, generates
    an HTML output, and writes it onto an HTTP response stream.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err := parsedTemplate.Execute(w, person)`: 在这里，我们在解析的模板上调用`Execute`处理程序，它将`person`数据注入模板，生成HTML输出，并将其写入HTTP响应流。'
- en: '`if err != nil {log.Printf("Error occurred while executing the template or
    writing its output : ", err) return }`: Here we check whether there are any problems
    while executing the template or writing its output on the response stream. If
    there are, then we log the error and exit with a status code of 1.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil {log.Printf("Error occurred while executing the template or
    writing its output : ", err) return }`: 在这里，我们检查执行模板或将其输出写入响应流时是否出现任何问题。如果有问题，我们将记录错误并以状态码1退出。'
- en: Serving static files over HTTP
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP提供静态文件
- en: While designing web applications, it’s always a best practice to serve static
    resources, such as `.js`, `.css`, and `images` from the filesystem, or any **content
    delivery network** (**CDN**), such as Akamai or Amazon CloudFront, rather than
    serving it from the web server. This is because all these types of files are static
    and do not need to be processed; so why should we put extra load on the server?
    Moreover, it helps to boost application performance, as all the requests for the
    static files will be served from external sources and therefore reduce the load
    on the server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Web应用程序时，最好的做法是从文件系统或任何**内容传递网络**（**CDN**）（如Akamai或Amazon CloudFront）提供静态资源，例如`.js`、`.css`和`images`，而不是从Web服务器提供。这是因为所有这些类型的文件都是静态的，不需要处理；那么为什么我们要给服务器增加额外的负载呢？此外，它有助于提高应用程序的性能，因为所有对静态文件的请求都将从外部来源提供，并因此减少了对服务器的负载。
- en: Go's `net/http` package is sufficient enough for serving static resources from
    the filesystem through `FileServer`, which we will be covering in this recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`net/http`包足以通过`FileServer`从文件系统中提供静态资源，我们将在本教程中介绍。
- en: Getting ready…
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: As we have already created a template in our previous recipe, we will just extend
    it to serve a static `.css` file from the `static/css` directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一个教程中创建了一个模板，我们将扩展它以从`static/css`目录中提供静态`.css`文件。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to create a file server that will serve static
    resources from the filesystem. Perform the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个文件服务器，它将从文件系统中提供静态资源。执行以下步骤：
- en: 'Create `main.css` inside a `static/css` directory, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`static/css`目录中创建`main.css`，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Copy the following content to `main.css`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`main.css`中：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create `serve-static-files.go`, where we will create `FileServer`, which will
    serve resources from the `static/css` directory present on the filesystem for
    all URL patterns with  `/static`, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`serve-static-files.go`，在那里我们将创建`FileServer`，它将为所有带有`/static`的URL模式从文件系统中的`static/css`目录提供资源，如下所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Update `first-template.html` (created in our previous recipe) to include `main.css`
    from the `static/css` directory:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`first-template.html`（在我们的上一个教程中创建）以包含来自文件系统中的`static/css`目录的`main.css`：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应如下所示：
- en: '![](img/94798377-1729-4559-9e5c-6c4ca2fa2f59.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94798377-1729-4559-9e5c-6c4ca2fa2f59.png)'
- en: 'Run the program with the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us the same output we saw in
    our previous recipe, but this time the text color has changed from the default
    **black** to **blue**, as shown in the following image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。浏览`http://localhost:8080`将显示与上一个教程中相同的输出，但是这次文本颜色已从默认的**黑色**更改为**蓝色**，如下图所示：
- en: '![](img/07fd3f5a-f8c5-4976-98b3-5527c8372755.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07fd3f5a-f8c5-4976-98b3-5527c8372755.png)'
- en: If we look at the Network tab of Chrome DevTools, we can see `main.css`, which
    has been loaded from the `static/css` directory present on the filesystem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看Chrome DevTools的网络选项卡，我们可以看到`main.css`是从文件系统中的`static/css`目录加载的。
- en: 'Let''s understand the changes we introduced in the `main()` method as part
    of this recipe:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在本教程的`main()`方法中引入的更改：
- en: '`fileServer := http.FileServer(http.Dir("static"))`: Here, we created a file
    server using the `FileServer` handler of the `net/http` package, which serves
    HTTP requests from the `static` directory present on the filesystem.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileServer := http.FileServer(http.Dir("static"))`：在这里，我们使用`net/http`包的`FileServer`处理程序创建了一个文件服务器，它从文件系统中的`static`目录提供HTTP请求。'
- en: '`http.Handle("/static/", http.StripPrefix("/static/", fileServer))`: Here,
    we are registering the `http.StripPrefix("/static/", fileServer)` handler with
    the `/static` URL pattern using `HandleFunc` of the `net/http` package, which
    means  `http.StripPrefix("/static/", fileServer)` gets executed and passes `(http.ResponseWriter,
    *http.Request)` as a parameter to it whenever we access the HTTP URL with the `/static` pattern.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Handle("/static/", http.StripPrefix("/static/", fileServer))`：在这里，我们使用`net/http`包的`HandleFunc`将`http.StripPrefix("/static/",
    fileServer)`处理程序注册到`/static`URL模式，这意味着每当我们访问带有`/static`模式的HTTP URL时，`http.StripPrefix("/static/",
    fileServer)`将被执行，并将`(http.ResponseWriter, *http.Request)`作为参数传递给它。'
- en: '`http.StripPrefix("/static/", fileServer)`: This returns a handler that serves
    HTTP requests by removing `/static` from the request URL''s path and invokes the
    file server. `StripPrefix` handles a request for a path that doesn''t begin with
    a prefix by replying with an HTTP 404.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.StripPrefix("/static/", fileServer)`：这将返回一个处理程序，通过从请求URL的路径中删除`/static`来提供HTTP请求，并调用文件服务器。`StripPrefix`通过用HTTP
    404回复处理不以前缀开头的路径的请求。'
- en: Serving static files over HTTP using Gorilla Mux
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux通过HTTP提供静态文件
- en: In the previous recipe, we served `static` resources through Go's HTTP file
    server. In this recipe, we will look at how we can serve it through the Gorilla
    Mux router, which is also one of the most common ways of creating an HTTP router.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们通过Go的HTTP文件服务器提供了`static`资源。在本教程中，我们将看看如何通过Gorilla Mux路由器提供它，这也是创建HTTP路由器的最常见方式之一。
- en: Getting ready…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪…
- en: As we have already created a template which serves `main.css` from the `static/css`
    directory present on the filesystem in our previous recipe, we will just update
    it to use the Gorilla Mux router.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一个教程中创建了一个模板，该模板从文件系统中的`static/css`目录中提供`main.css`，因此我们将更新它以使用Gorilla
    Mux路由器。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create `serve-static-files-gorilla-mux.go`, where we will create a Gorilla
    Mux router instead of an HTTP `FileServer`, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`serve-static-files-gorilla-mux.go`，在那里我们将创建一个Gorilla Mux路由器，而不是HTTP`FileServer`，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the program with the following command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`上启动。
- en: 'Browsing `http://localhost:8080` will show us the same output we saw in our
    previous recipe, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览`http://localhost:8080`将显示与我们上一个示例中看到的相同的输出，如下屏幕截图所示：
- en: '![](img/f2ba4915-2e5d-4d3e-a893-eab0364df5d8.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2ba4915-2e5d-4d3e-a893-eab0364df5d8.png)'
- en: 'Let''s understand the changes we introduced in the `main()` method as part
    of this recipe:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在本示例的`main()`方法中引入的更改：
- en: '`router :=mux.NewRouter()`: Here we instantiated the `gorilla/mux` router calling
    the `NewRouter()` handler of the mux router.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router :=mux.NewRouter()：在这里，我们调用`mux`路由器的`NewRouter()`处理程序实例化了`gorilla/mux`路由器。'
- en: '`router.HandleFunc("/",renderTemplate).Methods("GET")`: Here we registered
    the `/` URL pattern with the `renderTemplate` handler. This means `renderTemplate` will
    execute for every request with the URL pattern `/`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.HandleFunc("/",renderTemplate).Methods("GET")：在这里，我们使用`renderTemplate`处理程序注册了`/`
    URL模式。这意味着`renderTemplate`将对每个URL模式为`/`的请求执行。'
- en: '`router.PathPrefix("/").Handler(http.StripPrefix("/static", http.FileServer(http.Dir("static/"))))`:
    Here we are registering `/` as a new route along with setting the handler to be
    executed once it is called.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.PathPrefix("/").Handler(http.StripPrefix("/static", http.FileServer(http.Dir("static/")))：在这里，我们将`/`注册为一个新的路由，并设置处理程序在调用时执行。'
- en: '`http.StripPrefix("/static", http.FileServer(http.Dir("static/")))`: This returns
    a handler that serves HTTP requests by removing `/static` from the request URL''s
    path and invoking the file server. `StripPrefix` handles a request for a path
    that doesn''t begin with a prefix by replying with an HTTP 404.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.StripPrefix("/static", http.FileServer(http.Dir("static/")))：这返回一个处理程序，通过从请求URL的路径中删除`/static`并调用文件服务器来提供HTTP请求。`StripPrefix`通过回复HTTP
    404来处理不以前缀开头的路径的请求。'
- en: Creating your first HTML form
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个HTML表单
- en: Whenever we want to collect the data from the client and send it to the server
    for processing, implementing an HTML form is the best choice. We will be covering
    this in this recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要从客户端收集数据并将其发送到服务器进行处理时，实现HTML表单是最佳选择。我们将在本示例中介绍这个。
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will create a simple HTML form that has two input fields
    and a button to submit the form. Perform the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将创建一个简单的HTML表单，其中包含两个输入字段和一个提交表单的按钮。执行以下步骤：
- en: 'Create `login-form.html` inside the `templates` directory, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`目录中创建`login-form.html`，如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Copy the following content to `login-form.html`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`login-form.html`中：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding template has two textboxes—`username` and `password`—along with
    a Login button.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模板有两个文本框——`用户名`和`密码`——以及一个登录按钮。
- en: On clicking the Login button, the client will make a `POST` call to an action
    defined in an HTML form, which is `/login` in our case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 单击登录按钮后，客户端将对在HTML表单中定义的操作进行`POST`调用，我们的情况下是`/login`。
- en: 'Create `html-form.go`, where we will parse the form template and write it onto
    an HTTP response stream, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`html-form.go`，在那里我们将解析表单模板并将其写入HTTP响应流，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应如下所示：
- en: '![](img/b9fbfd8c-a74f-4b47-a3b3-4ac7c8ebacf3.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9fbfd8c-a74f-4b47-a3b3-4ac7c8ebacf3.png)'
- en: 'Run the program with the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`上启动。浏览`http://localhost:8080`将显示一个HTML表单，如下屏幕截图所示：
- en: '![](img/7d973921-5f28-483f-b58d-77ac105575c0.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d973921-5f28-483f-b58d-77ac105575c0.png)'
- en: 'Let’s understand the program we have written:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序：
- en: '`func login(w http.ResponseWriter, r *http.Request) { parsedTemplate, _ :=
    template.ParseFiles("templates/login-form.html") parsedTemplate.Execute(w, nil)
    }`: This is a Go function that accepts `ResponseWriter` and `Request` as input
    parameters, parses `login-form.html`, and returns a new template.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func login(w http.ResponseWriter, r *http.Request) { parsedTemplate, _ :=
    template.ParseFiles("templates/login-form.html") parsedTemplate.Execute(w, nil)
    }：这是一个接受`ResponseWriter`和`Request`作为输入参数的Go函数，解析`login-form.html`并返回一个新模板。'
- en: '`http.HandleFunc("/", login)`: Here we are registering a login function with
    the `/` URL pattern using `HandleFunc` of the `net/http` package, which means the login
    function gets executed every time we access the HTTP URL with the `/` pattern
    passing `ResponseWriter` and  `Request` as the parameters to it.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.HandleFunc("/", login)：在这里，我们使用`net/http`包的`HandleFunc`将登录函数注册到`/` URL模式，这意味着每次访问`/`模式的HTTP
    URL时，登录函数都会被执行，传递`ResponseWriter`和`Request`作为参数。'
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here we are calling `http.ListenAndServe` to
    serve HTTP requests that handle each incoming connection in a separate Goroutine.
    `ListenAndServe` accepts two parameters—the server address and the handler—where
    the server address is `localhost:8080` and the handler is `nil`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)：在这里，我们调用`http.ListenAndServe`来提供处理每个传入连接的HTTP请求的服务。`ListenAndServe`接受两个参数——服务器地址和处理程序——其中服务器地址为`localhost:8080`，处理程序为`nil`。'
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here we check if there is a problem with starting the server. If there is, then
    log the error and exit with a status code of `1`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Fatal("error starting http server : ", err) return}：在这里，我们检查是否启动服务器时出现问题。如果有问题，记录错误并以状态码`1`退出。'
- en: Reading your first HTML form
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读您的第一个HTML表单
- en: Once an HTML form is submitted, we have to read the client data on the server
    side to take an appropriate action. We will be covering this in this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦提交HTML表单，我们必须在服务器端读取客户端数据以采取适当的操作。我们将在本示例中介绍这个。
- en: Getting ready…
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好...
- en: Since we have already created an HTML form in our previous recipe, we will just
    extend the recipe to read its field values.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一个示例中创建了一个HTML表单，我们只需扩展该示例以读取其字段值。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install the `github.com/gorilla/schema` package using the `go get` command,
    as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`github.com/gorilla/schema`包：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create `html-form-read.go`, where we will read an HTML form field after decoding
    it using the `github.com/gorilla/schema` package and write Hello followed by the
    username to an HTTP response stream, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`html-form-read.go`，在这里我们将使用`github.com/gorilla/schema`包解码HTML表单字段，并在HTTP响应流中写入Hello，后跟用户名。
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the program with the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。浏览`http://localhost:8080`将显示一个HTML表单，如下面的屏幕截图所示：
- en: '![](img/b576b702-a85a-4b85-8f84-6107c72022bb.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b576b702-a85a-4b85-8f84-6107c72022bb.png)'
- en: 'Once we enter the username and password and click on the Login button, we will
    see Hello followed by the username as the response from the server, as shown in
    the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入用户名和密码并单击登录按钮，我们将在服务器的响应中看到Hello，后跟用户名，如下面的屏幕截图所示：
- en: '![](img/f0373bdf-58fd-4108-8adf-24e204ff3006.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0373bdf-58fd-4108-8adf-24e204ff3006.png)'
- en: 'Let’s  understand the changes we introduced as part of this recipe:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下我们在这个配方中引入的更改：
- en: Using `import ( "fmt" "html/template" "log" "net/http" "github.com/gorilla/schema")`,
    we imported two additional packages—`fmt` and `github.com/gorilla/schema`—which
    help to convert `structs` to and from `Form` values.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("fmt" "html/template" "log" "net/http" "github.com/gorilla/schema")`，我们导入了两个额外的包——`fmt`和`github.com/gorilla/schema`——它们有助于将`structs`与`Form`值相互转换。
- en: 'Next, we defined the `User struct` type, which has `Username` and `Password`
    fields, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`User struct`类型，它具有`Username`和`Password`字段，如下所示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we defined the `readForm` handler, which takes `HTTP Request` as an input
    parameter and returns `User`, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`readForm`处理程序，它以`HTTP请求`作为输入参数，并返回`User`，如下所示：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s understand this Go function in detail:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解一下这个Go函数：
- en: '`r.ParseForm()`: Here we parse the request body as a form and put the results
    into both `r.PostForm` and `r.Form`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r.ParseForm()`: 在这里，我们将请求体解析为一个表单，并将结果放入`r.PostForm`和`r.Form`中。'
- en: '`user := new(User)`: Here we create a new `User struct` type.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user := new(User)`: 在这里，我们创建了一个新的`User struct`类型。'
- en: '`decoder := schema.NewDecoder()`: Here we are creating a decoder, which we
    will be using to fill a user `struct` with `Form` values.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decoder := schema.NewDecoder()`: 在这里，我们正在创建一个解码器，我们将使用它来用`Form`值填充一个用户`struct`。'
- en: '`decodeErr := decoder.Decode(user, r.PostForm)`: Here we decode parsed form
    data from `POST` body parameters to a user `struct`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decodeErr := decoder.Decode(user, r.PostForm)`: 在这里，我们将从`POST`体参数中解码解析的表单数据到一个用户`struct`中。'
- en: '`r.PostForm` is only available after `ParseForm` is called.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`r.PostForm`只有在调用`ParseForm`之后才可用。'
- en: '`if decodeErr != nil { log.Printf("error mapping parsed form data to struct
    : ", decodeErr) }`: Here we check whether there is any problem with mapping form
    data to a struct. If there is, then log it.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if decodeErr != nil { log.Printf("error mapping parsed form data to struct
    : ", decodeErr) }`: 在这里，我们检查是否有任何将表单数据映射到结构体的问题。如果有，就记录下来。'
- en: 'Then, we defined a `login` handler, which checks if the HTTP request calling
    the handler is a `GET` request and then parses `login-form.html` from the templates
    directory and writes it to an HTTP response stream; otherwise, it calls the `readForm`
    handler, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`login`处理程序，它检查调用处理程序的HTTP请求是否是`GET`请求，然后从模板目录中解析`login-form.html`并将其写入HTTP响应流；否则，它调用`readForm`处理程序，如下所示：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Validating your first HTML form
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证您的第一个HTML表单
- en: Most of the time, we have to validate a client's input before processing it,
    which can be achieved through the number of external packages in Go, such as `gopkg.in/go-playground/validator.v9`, `gopkg.in/validator.v2`,
    and `github.com/asaskevich/govalidator`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们在处理客户端输入之前必须对其进行验证，这可以通过Go中的许多外部包来实现，例如`gopkg.in/go-playground/validator.v9`、`gopkg.in/validator.v2`和`github.com/asaskevich/govalidator`。
- en: In this recipe, we will be working with the most famous and commonly used validator, 
     `github.com/asaskevich/govalidator`, to validate our HTML form.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用最著名和常用的验证器`github.com/asaskevich/govalidator`来验证我们的HTML表单。
- en: Getting ready…
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作...
- en: As we have already created and read an HTML form in our previous recipe, we
    will just extend it to validate its field values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一个配方中创建并读取了一个HTML表单，我们只需扩展它以验证其字段值。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install `github.com/asaskevich/govalidator` and the `github.com/gorilla/schema`
    package using the `go get` command, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`github.com/asaskevich/govalidator`和`github.com/gorilla/schema`包：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create `html-form-validation.go`, where we will read an HTML form, decode it
    using `github.com/gorilla/schema`, and validate each field of it against a tag
    defined in the `User struct` using `github.com/asaskevich/govalidator`, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`html-form-validation.go`，在这里我们将读取一个HTML表单，使用`github.com/gorilla/schema`对其进行解码，并使用`github.com/asaskevich/govalidator`对其每个字段进行验证，验证标签定义在`User
    struct`中。
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the program with the following command:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us an HTML form, as shown in
    the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。浏览`http://localhost:8080`将显示一个HTML表单，如下面的屏幕截图所示：
- en: '![](img/348772a2-efa6-4d10-85b0-7c8862333408.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/348772a2-efa6-4d10-85b0-7c8862333408.png)'
- en: 'Then submit the form with the valid values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后提交具有有效值的表单：
- en: '![](img/86cba772-9979-4efc-ace2-bae92d5497be.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86cba772-9979-4efc-ace2-bae92d5497be.png)'
- en: 'It will show us the Hello followed by the username on a browser screen, as
    shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在浏览器屏幕上显示Hello，后跟用户名，如下面的屏幕截图所示：
- en: '![](img/12b1c3c6-f8d8-412e-96a3-b29e20e7d229.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12b1c3c6-f8d8-412e-96a3-b29e20e7d229.png)'
- en: 'Submitting the form with the value as non-alpha in any of the fields will show
    us the error message. For example, submitting the form with the Username value
    as `1234`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何字段中提交值为非字母的表单将显示错误消息。例如，提交用户名值为`1234`的表单：
- en: '![](img/11bbc899-37d9-4d63-8edf-d38a2a63de20.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11bbc899-37d9-4d63-8edf-d38a2a63de20.png)'
- en: 'It will show us an error message on the browser, as shown in the following
    screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在浏览器上显示错误消息，如下面的屏幕截图所示：
- en: '![](img/2e669f3e-942c-42e1-9c2c-d7ee4b674cf6.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e669f3e-942c-42e1-9c2c-d7ee4b674cf6.png)'
- en: 'Moreover, we can submit an HTML form from the command line as:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以从命令行提交HTML表单，如下所示：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will give us the same output that we get in the browser:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们在浏览器中得到的相同输出：
- en: '![](img/2ad63a7c-1b4b-468d-9dea-3fa04157ba04.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ad63a7c-1b4b-468d-9dea-3fa04157ba04.png)'
- en: 'Let’s understand the change we introduced in this recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下我们在这个示例中引入的更改：
- en: Using `import ("fmt", "html/template", "log", "net/http" "github.com/asaskevich/govalidator"
    "github.com/gorilla/schema" )`, we imported an additional package—`github.com/asaskevich/govalidator`,
    which helps us to validate structs.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import ("fmt", "html/template", "log", "net/http" "github.com/asaskevich/govalidator"
    "github.com/gorilla/schema" )`，我们导入了一个额外的包——`github.com/asaskevich/govalidator`，它可以帮助我们验证结构。
- en: 'Next, we updated the `User struct` type to include a string literal tag with
    the `key` as `valid` and `value` as `alpha, required`, as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新了`User struct`类型，包括一个字符串字面标签，`key`为`valid`，`value`为`alpha, required`，如下所示：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we defined a `validateUser` handler, which takes `ResponseWriter`, `Request`, and
    `User` as inputs and returns a `bool` and `string`, which are the struct valid
    status and validation error message respectively. In this handler, we validated
    struct tags calling the `ValidateStruct` handler from `govalidator`. If there
    is an error in validating the field, then we fetch the error calling the `ErrorByField` handler
    from `govalidator` and return the result along with the validation error message.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`validateUser`处理程序，它接受`ResponseWriter`、`Request`和`User`作为输入，并返回`bool`和`string`，分别是结构的有效状态和验证错误消息。在这个处理程序中，我们调用`govalidator`的`ValidateStruct`处理程序来验证结构标签。如果在验证字段时出现错误，我们将调用`govalidator`的`ErrorByField`处理程序来获取错误，并将结果与验证错误消息一起返回。
- en: Next, we updated the `login` handler to call `validateUser` passing `(w http.ResponseWriter,
    r *http.Request, user *User)` as input parameters to it and check for any validation
    errors. If there are errors, then we write an error message to an HTTP response
    stream and return it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新了`login`处理程序，调用`validateUser`并将`(w http.ResponseWriter, r *http.Request,
    user *User)`作为输入参数传递给它，并检查是否有任何验证错误。如果有错误，我们将在HTTP响应流中写入错误消息并返回它。
- en: Uploading your first file
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传您的第一个文件
- en: One of the most common scenarios in any web application is uploading a file
    or a folder to the server. For example, if we are developing a job portal, then
    we may have to provide an option where the applicant can upload their profile/resume,
    or, let's say, we have to develop an e-commerce website with a feature where the
    customer can upload their orders in bulk using a file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中，最常见的情景之一就是上传文件或文件夹到服务器。例如，如果我们正在开发一个求职门户网站，那么我们可能需要提供一个选项，申请人可以上传他们的个人资料/简历，或者，比如说，我们需要开发一个电子商务网站，其中客户可以使用文件批量上传他们的订单。
- en: Achieving the functionality to upload a file in Go is quite easy using its built-in
    packages, which we will be covering in this recipe.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中实现上传文件的功能非常容易，使用其内置的包，我们将在本示例中进行介绍。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we are going to create an HTML form with a field of type `file`, which
    lets the user pick one or more files to upload to a server via a form submission.
    Perform the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个带有`file`类型字段的HTML表单，允许用户选择一个或多个文件通过表单提交上传到服务器。执行以下步骤：
- en: 'Create `upload-file.html` inside the `templates` directory, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`目录中创建`upload-file.html`，如下所示：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Copy the following content to `upload-file.html`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`upload-file.html`中：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding template, we defined a field of type `file` along with a `Submit`
    button.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们定义了一个`file`类型的字段，以及一个`Submit`按钮。
- en: On clicking the Submit button, the client encodes the data that forms the body
    of the request and makes a `POST` call to the form action, which is `/upload`
    in our case.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“提交”按钮后，客户端将对请求的主体进行编码，并对表单操作进行`POST`调用，这在我们的情况下是`/upload`。
- en: 'Create `upload-file.go`, where we will define handlers to render the file upload
    template, get the file from the request, process it, and write the response to
    an HTTP response stream, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`upload-file.go`，在其中我们将定义处理程序来渲染文件上传模板，从请求中获取文件，处理它，并将响应写入HTTP响应流，如下所示：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应该如下所示：
- en: '![](img/670f25ff-f46e-4aec-b0b4-c150b76ba734.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/670f25ff-f46e-4aec-b0b4-c150b76ba734.png)'
- en: 'Run the program with the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Once we run the program, the HTTP server will start locally listening on port
    `8080`. Browsing `http://localhost:8080` will show us the File Upload Form, as
    shown in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。浏览`http://localhost:8080`将会显示文件上传表单，如下面的屏幕截图所示：
- en: '![](img/db929449-393f-4fa5-92ff-368b6c2f5de0.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db929449-393f-4fa5-92ff-368b6c2f5de0.png)'
- en: 'Pressing the Submit button after choosing a file will result in the creation of
    a file on the server with the name as `uploadedFile` inside the `/tmp` directory.
    You can see this by executing the following commands:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择文件后按下“提交”按钮将会在服务器上创建一个名为`uploadedFile`的文件，位于`/tmp`目录中。您可以通过执行以下命令来查看：
- en: '**![](img/438fac80-0552-4137-b28f-d6efe696fbfe.png)**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/438fac80-0552-4137-b28f-d6efe696fbfe.png)**'
- en: 'Also, the successful upload will display the message on the browser, as shown
    in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，成功上传将在浏览器上显示消息，如下面的屏幕截图所示：
- en: '![](img/d430fc2d-02ab-4941-86c2-52dccd992090.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d430fc2d-02ab-4941-86c2-52dccd992090.png)'
- en: 'Let''s understand the Go program we have written:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下我们编写的Go程序：
- en: 'We defined the `fileHandler()` handler, which gets the file from the request,
    reads its content, and eventually writes it onto a file on a server. As this handler
    does a lot of things, let’s go through it in detail:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`fileHandler()`处理程序，它从请求中获取文件，读取其内容，最终将其写入服务器上的文件。由于这个处理程序做了很多事情，让我们逐步详细介绍一下：
- en: '`file, header, err := r.FormFile("file")`: Here we call the `FormFile` handler
    on the HTTP request to get the file for the provided form key.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file, header, err := r.FormFile("file")`: 在这里，我们调用HTTP请求的`FormFile`处理程序，以获取提供的表单键对应的文件。'
- en: '`if err != nil { log.Printf("error getting a file for the provided form key
    : ", err) return }`: Here we check whether there is any problem while getting
    the file from the request. If there is, then log the error and exit with a status
    code of `1`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Printf("error getting a file for the provided form key
    : ", err) return }`: 在这里，我们检查是否在从请求中获取文件时出现了任何问题。如果有问题，记录错误并以状态码`1`退出。'
- en: '`defer file.Close()`: The `defer` statement closes the `file` once we return
    from the function.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer file.Close()`: `defer`语句会在函数返回时关闭`file`。'
- en: '`out, pathError := os.Create("/tmp/uploadedFile")`: Here we are creating a
    file named `uploadedFile` inside a `/tmp` directory with mode `666`, which means
    the client can read and write but cannot execute the file.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out, pathError := os.Create("/tmp/uploadedFile")`: 在这里，我们创建了一个名为`uploadedFile`的文件，放在`/tmp`目录下，权限为`666`，这意味着客户端可以读写但不能执行该文件。'
- en: '`if pathError != nil { log.Printf("error creating a file for writing : ", pathError)
    return }`: Here we check whether there are any problems with creating a file on
    the server. If there are, then log the error and exit with a status code of `1`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if pathError != nil { log.Printf("error creating a file for writing : ", pathError)
    return }`: 在这里，我们检查在服务器上创建文件时是否出现了任何问题。如果有问题，记录错误并以状态码`1`退出。'
- en: '`_, copyFileError := io.Copy(out, file)`: Here we copy content from the file
    we received to the file we created inside the `/tmp` directory.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_, copyFileError := io.Copy(out, file)`: 在这里，我们将从接收到的文件中的内容复制到`/tmp`目录下创建的文件中。'
- en: '`fmt.Fprintf(w, "File uploaded successfully : "+header.Filename)`: Here we
    write a message along with a filename to an HTTP response stream.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Fprintf(w, "File uploaded successfully : "+header.Filename)`: 在这里，我们向HTTP响应流写入一条消息和文件名。'
