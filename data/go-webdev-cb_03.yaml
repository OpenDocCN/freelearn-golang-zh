- en: Working with Sessions, Error Handling, and Caching in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中处理会话、错误和缓存
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Creating your first HTTP session
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP会话
- en: Managing your HTTP session using Redis
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis管理你的HTTP会话
- en: Creating your first HTTP cookie
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP cookie
- en: Implementing caching in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中实现缓存
- en: Implementing HTTP error handling in Go
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Go中实现HTTP错误处理
- en: Implementing login and logout in a web application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web应用程序中实现登录和注销
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Sometimes, we would like to persist information such as user data at an application
    level rather than persisting it in a database, which can be easily achieved using
    sessions and cookies. The difference between the two is that sessions are stored
    on the server side, whereas cookies are stored on the client side. We may also
    need to cache static data to avoid unnecessary calls to a database or a web service,
    and implement error handling while developing a web application. With knowledge
    of the concepts covered in this chapter, we will be able to implement all these
    functionalities in a fairly easy way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在应用程序级别持久保存用户数据等信息，而不是将其持久保存在数据库中，这可以很容易地通过会话和cookies来实现。两者之间的区别在于，会话存储在服务器端，而cookies存储在客户端。我们还可能需要缓存静态数据，以避免不必要地调用数据库或Web服务，并在开发Web应用程序时实现错误处理。通过掌握本章涵盖的概念，我们将能够以相当简单的方式实现所有这些功能。
- en: In this chapter, we will start with creating an HTTP session, then we will learn
    how we can manage it using Redis, creating cookies, caching HTTP responses, implementing
    error handling, and eventually end with implementing login and logout mechanisms
    in Go.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从创建一个HTTP会话开始，然后学习如何使用Redis进行管理，创建cookies，缓存HTTP响应，实现错误处理，最终以在Go中实现登录和注销机制结束。
- en: Creating your first HTTP session
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP会话
- en: HTTP is a stateless protocol, which means each time a client retrieves a web
    page, the client opens a separate connection to the server and the server responds
    to it without keeping any record of the previous client request. So, if we want
    to implement a mechanism where the server knows about a request that the client
    has sent to it, then we can implement it using a session.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一个无状态协议，这意味着每次客户端检索网页时，客户端都会打开一个独立的连接到服务器，服务器会对其进行响应，而不保留任何关于先前客户端请求的记录。因此，如果我们想要实现一个机制，让服务器知道客户端发送给它的请求，那么我们可以使用会话来实现。
- en: 'When we are working with sessions, clients just need to send an ID and the
    data is loaded from the server for the corresponding ID. There are three ways
    that we can implement this in a web application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用会话时，客户端只需要发送一个ID，数据就会从服务器加载出来。我们可以在Web应用程序中实现这三种方式：
- en: Cookies
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cookies
- en: Hidden form fields
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏表单字段
- en: URL rewriting
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL重写
- en: In this recipe, we will implement a session using HTTP cookies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用HTTP cookies来实现一个会话。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `github.com/gorilla/sessions` package using the `go get` command,
    as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/sessions`包，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create `http-session.go` where we will create a Gorilla cookie store to save
    and retrieve session information defining three handlers—`/login`, `/home`, and
    `/logout`—where we will be creating a valid session cookie, writing a response
    to an HTTP response stream, and invalidating a session cookie respectively, as
    follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-session.go`，在其中我们将创建一个Gorilla cookie存储来保存和检索会话信息，定义三个处理程序—`/login`、`/home`和`/logout`—在这里我们将创建一个有效的会话cookie，向HTTP响应流写入响应，以及分别使会话cookie失效，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the program with the following command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start listening locally on port
    `8080`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: Next, we will execute a couple of commands to see how the session works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行一些命令来看会话是如何工作的。
- en: 'First, we will access `/home` by executing the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过执行以下命令访问`/home`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will result in an unauthorized access message from the server as shown
    in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致服务器显示未经授权的访问消息，如下面的屏幕截图所示：
- en: '![](img/90912e34-54a2-44dc-9576-f61fb35e2e58.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90912e34-54a2-44dc-9576-f61fb35e2e58.png)'
- en: 'This is because we first have to log in to an application, which will create
    a session ID that the server will validate before providing access to any web
    page. So, let''s log in to the application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们首先必须登录到一个应用程序，这将创建一个服务器将在提供对任何网页的访问之前验证的会话ID。所以，让我们登录到应用程序：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Executing the previous command will give us the `Cookie`, which has to be set
    as a request header to access any web page:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令将给我们一个`Cookie`，它必须被设置为一个请求头来访问任何网页：
- en: '![](img/70bc5c54-9374-4701-880e-88cc2d0eb939.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70bc5c54-9374-4701-880e-88cc2d0eb939.png)'
- en: 'Next, we will use this provided `Cookie` to access `/home`, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用提供的`Cookie`来访问`/home`，如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This results in the home page as a response from the server:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致服务器作为响应的主页：
- en: '![](img/6c042535-965d-417c-910b-2f9b3014aa3b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c042535-965d-417c-910b-2f9b3014aa3b.png)'
- en: 'Let''s understand the Go program we have written:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的Go程序：
- en: Using `var store *sessions.CookieStore`, we declared a private cookie store
    to store sessions using secure cookies.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`var store *sessions.CookieStore`，我们声明了一个私有的cookie存储，用来使用安全的cookies来存储会话。
- en: Using `func init() { store = sessions.NewCookieStore([]byte("secret-key")) }`,
    we defined an `init()` function that runs before `main()` to create a new cookie
    store and assign it to the `store`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`func init() { store = sessions.NewCookieStore([]byte("secret-key")) }`，我们定义了一个在`main()`之前运行的`init()`函数，用来创建一个新的cookie存储并将其分配给`store`。
- en: '`init()` is always called, regardless of whether there''s a main function or
    not, so if you import a package that has an `init` function, it will be executed.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数总是被调用，无论是否有主函数，所以如果你导入一个包含`init`函数的包，它将被执行。'
- en: Next, we defined a `home` handler where we get a session from the cookie store
    for the given name after adding it to the registry using `store.Get` and fetch
    the value of the `authenticated` key from the cache. If it is true, then we write
    `Home Page` to an HTTP response stream; otherwise, we write a You are unauthorized
    to view the page. message along with a `403` HTTP code.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`home`处理程序，在那里我们从cookie存储中获取一个会话，将其添加到注册表中并使用`store.Get`获取`authenticated`键的值。如果为true，则我们将`Home
    Page`写入HTTP响应流；否则，我们将写入一个`403`HTTP代码以及消息You are unauthorized to view the page.。
- en: Next, we defined a `login` handler where we again get a session, set the `authenticated`
    key with a value of `true`, save it, and finally write You have successfully logged
    in. to an HTTP response stream.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`login`处理程序，在那里我们再次获取一个会话，将`authenticated`键设置为`true`，保存它，最后将You have
    successfully logged in.写入HTTP响应流。
- en: Next, we defined a `logout` handler where we get a session, set an `authenticated`
    key with the value of `false`, save it, and finally write You have successfully
    logged out. to an HTTP response stream.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`logout`处理程序，在那里我们获取一个会话，将一个`authenticated`键设置为`false`，保存它，最后将You
    have successfully logged out.写入HTTP响应流。
- en: Finally, we defined `main()` where we mapped all handlers, `home`, `login`,
    and `logout`, to `/home`, `/login`, and `/logout` respectively, and start the
    HTTP server on `localhost:8080`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`main()`，在那里我们将所有处理程序`home`，`login`和`logout`映射到`/home`，`/login`和`/logout`，并在`localhost:8080`上启动HTTP服务器。
- en: Managing your HTTP session using Redis
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis管理您的HTTP会话
- en: While working with the distributed applications, we probably have to implement stateless
    load balancing for frontend users. This is so we can persist session information
    in a database or a filesystem so that we can identify the user and retrieve their
    information if a server gets shut down or restarted.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理分布式应用程序时，我们可能需要为前端用户实现无状态负载平衡。这样我们就可以将会话信息持久化存储在数据库或文件系统中，以便在服务器关闭或重新启动时识别用户并检索他们的信息。
- en: We will be solving this problem as part of the recipe using Redis as the persistent
    store to save a session.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个配方的一部分中使用Redis作为持久存储来解决这个问题。
- en: Getting ready…
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: As we have already created a session variable in our previous recipe using the
    Gorilla cookie store, we will just extend this recipe to save session information
    in Redis rather than maintaining it on the server.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在上一个配方中使用Gorilla cookie存储创建了一个会话变量，因此我们只需扩展此配方以将会话信息保存在Redis中，而不是在服务器上维护它。
- en: There are multiple implementations of the Gorilla session store, which you can
    find at `https://github.com/gorilla/sessions#store-implementations`. As we are
    using Redis as our backend store, we will be using `https://github.com/boj/redistore`,
    which depends on the Redigo Redis library to store a session.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla会话存储有多种实现，您可以在`https://github.com/gorilla/sessions#store-implementations`找到。由于我们使用Redis作为后端存储，我们将使用`https://github.com/boj/redistore`，它依赖于Redigo
    Redis库来存储会话。
- en: This recipe assumes you have Redis and Redis Browser installed and running locally on
    ports `6379` and `4567` respectively.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方假设您已经在本地端口`6379`和`4567`上安装并运行了Redis和Redis浏览器。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Install  `gopkg.in/boj/redistore.v1` and `github.com/gorilla/sessions` using
    the `go get` command, as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`gopkg.in/boj/redistore.v1`和`github.com/gorilla/sessions`，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create `http-session-redis.go`, where we will create a `RedisStore` to store
    and retrieve session variables, as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-session-redis.go`，在那里我们将创建一个`RedisStore`来存储和检索会话变量，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the program with the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，HTTP服务器将在本地端口`8080`上开始监听。
- en: Next, we will execute a couple of commands to see how the session works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行一些命令来看看会话是如何工作的。
- en: 'First, we will access `/home` by executing the following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过执行以下命令访问`/home`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will result in an unauthorized access message from the server as shown
    in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致服务器显示未经授权的访问消息，如下面的屏幕截图所示：
- en: '![](img/060b9289-61e3-4786-bab8-6be435d42f95.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/060b9289-61e3-4786-bab8-6be435d42f95.png)'
- en: 'This is because we first have to log in to an application, which will create
    a **session ID** that the server will validate before providing access to any
    web page. So, let''s log in to the application:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们首先必须登录到一个应用程序，这将创建一个服务器将在提供对任何网页的访问之前验证的**会话ID**。所以，让我们登录到应用程序：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Executing the previous command will give us the `Cookie`, which has to be set
    as a request header to access any web page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上一个命令将给我们一个`Cookie`，必须将其设置为请求头以访问任何网页：
- en: '![](img/75be8a84-1ba2-404b-abb1-3c64d109b0ad.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75be8a84-1ba2-404b-abb1-3c64d109b0ad.png)'
- en: 'Once the previous command is executed, a `Cookie` will be created and saved
    in Redis, which you can see by executing the command from `redis-cli` or in the
    Redis Browser, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了上一个命令，将会创建一个`Cookie`并保存在Redis中，您可以通过从`redis-cli`执行命令或在Redis浏览器中查看，如下面的屏幕截图所示：
- en: '![](img/13be0e7f-26c1-42c3-94db-70ae68aa1b54.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13be0e7f-26c1-42c3-94db-70ae68aa1b54.png)'
- en: 'Next, we will use the `Cookie` provided to access `/home`, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用提供的`Cookie`来访问`/home`，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the Home Page as a response from the server:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致服务器作为响应的主页：
- en: '![](img/d723b277-e3d6-463e-95f9-6c8ca2e20624.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d723b277-e3d6-463e-95f9-6c8ca2e20624.png)'
- en: 'Let''s understand the changes we introduced in this recipe:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在这个配方中引入的更改：
- en: Using `var store *redisStore.RediStore`, we declared a private `RediStore` to
    store sessions in Redis.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`var store *redisStore.RediStore`，我们声明了一个私有的`RediStore`来在Redis中存储会话。
- en: Next, we updated the `init()` function to create `NewRediStore` with a size
    and maximum number of idle connections as `10`, and assigned it to the store.
    If there is an error while creating a store, then we log the error and exit with
    a status code of `1`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新了`init()`函数，使用大小和最大空闲连接数为`10`创建`NewRediStore`，并将其分配给存储。如果在创建存储时出现错误，我们将记录错误并以状态码`1`退出。
- en: Finally, we updated `main()` to introduce the `defer store.Close()` statement,
    which closes the Redis store once we return from the function.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们更新了`main()`，引入了`defer store.Close()`语句，一旦我们从函数返回，就会关闭Redis存储。
- en: Creating your first HTTP cookie
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个HTTP cookie
- en: Cookies play an important role when storing information on the client side and
    we can use their values to identify a user. Basically, cookies were invented to
    solve the problem of remembering information about the user or persistent-login
    authentication, which refers to websites being able to remember the identity of
    a principal between sessions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端存储信息时，cookie扮演着重要的角色，我们可以使用它们的值来识别用户。基本上，cookie是为了解决记住用户信息或持久登录身份验证的问题而发明的，这指的是网站能够在会话之间记住主体的身份。
- en: Cookies are simple text files that web browsers create when you visit websites
    on the internet. Your device stores the text files locally, allowing your browser
    to access the cookie and pass data back to the original website, and are saved
    in name-value pairs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie是在互联网上访问网站时Web浏览器创建的简单文本文件。您的设备会在本地存储这些文本文件，允许您的浏览器访问cookie并将数据传递回原始网站，并以名称-值对的形式保存。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Install the `github.com/gorilla/securecookie` package using the `go get` command,
    as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/securecookie`包，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create `http-cookie.go`, where we will create a Gorilla secure cookie to store
    and retrieve cookies, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-cookie.go`，在其中我们将创建一个Gorilla安全cookie来存储和检索cookie，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the program with the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Browsing `http://localhost:8080/read` will display Hello in the browser, as
    you can see in the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览`http://localhost:8080/read`将在浏览器中显示Hello，如下面的屏幕截图所示：
- en: '![](img/fa64f000-0212-46be-9698-9aae55c3c804.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa64f000-0212-46be-9698-9aae55c3c804.png)'
- en: 'Next, we will access `http://localhost:8080/create`, which will create a cookie
    with the name first-cookie and display the Cookie created message in the browser:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将访问`http://localhost:8080/create`，这将创建一个名为first-cookie的cookie，并在浏览器中显示Cookie
    created消息：
- en: '![](img/4f5ab86f-a1ce-4842-b86c-2c57d1906282.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f5ab86f-a1ce-4842-b86c-2c57d1906282.png)'
- en: 'Now, subsequent access to `http://localhost:8080/read` will use first-cookie to
    display Hello, followed by the value of first-cookie, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随后访问`http://localhost:8080/read`将使用`first-cookie`来显示Hello，然后是`first-cookie`的值，如下所示：
- en: '![](img/56a72dba-36a7-48b2-9d0f-bb4f6531db2d.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56a72dba-36a7-48b2-9d0f-bb4f6531db2d.png)'
- en: 'Let''s understand the program we have written:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序：
- en: Using `import ("fmt" "log" "net/http" "github.com/gorilla
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import ("fmt" "log" "net/http" "github.com/gorilla
- en: /securecookie")`, we introduced an additional package—`github.com/gorilla/securecookie`,
    which we will use to encode and decode authenticated and encrypted cookie values.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: /securecookie")`，我们引入了一个额外的包—`github.com/gorilla/securecookie`，我们将使用它来对经过身份验证和加密的cookie值进行编码和解码。
- en: Using `var cookieHandler *securecookie.SecureCookie`, we declared a private
    secure cookie.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`var cookieHandler *securecookie.SecureCookie`，我们声明了一个私有的安全cookie。
- en: Next, we updated the `init()` function to create `SecureCookie` passing a 64-byte
    hash key, which is used to authenticate values using HMAC and a 32-byte block
    key, which is used to encrypt values.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们更新了`init()`函数，创建了一个`SecureCookie`，传递了一个64字节的哈希密钥，用于使用HMAC对值进行身份验证，以及一个32字节的块密钥，用于加密值。
- en: Next, we defined a `createCookie` handler where we create a `Base64` encoded
    cookie with the key as `username` and the value as `Foo` using an `Encode` handler
    of `gorilla/securecookie`. Then, we add a `Set-Cookie` header to the provided
    `ResponseWriter` headers and write a `Cookie created.` message to an HTTP response.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`createCookie`处理程序，在其中使用`gorilla/securecookie`的`Encode`处理程序创建一个以`username`为键，`Foo`为值的`Base64`编码的cookie。然后，我们向提供的`ResponseWriter`头部添加一个`Set-Cookie`头，并向HTTP响应中写入一个`Cookie
    created.`的消息。
- en: Next, we defined a `readCookie` handler, where we retrieve a cookie from the
    request, which is `first-cookie` in our code, get a value for it, and write it
    to an HTTP response.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`readCookie`处理程序，在其中我们从请求中检索一个cookie，这在我们的代码中是`first-cookie`，为其获取一个值，并将其写入HTTP响应。
- en: Finally, we defined `main()` where we mapped all handlers—`createCookie` and
    `readCookie`—to `/create` and `/read` respectively, and started the HTTP server
    on `localhost:8080`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`main()`，在其中将所有处理程序—`createCookie`和`readCookie`—映射到`/create`和`/read`，并在`localhost:8080`上启动了HTTP服务器。
- en: Implementing caching in Go
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中实现缓存
- en: Caching data in a web application is sometimes necessary to avoid requesting
    static data from a database or external service again and again. Go does not provide
    any built-in package to cache responses, but it does support it through external
    packages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中缓存数据有时是必要的，以避免反复从数据库或外部服务请求静态数据。Go没有提供任何内置的包来缓存响应，但它通过外部包支持缓存。
- en: There are a number of packages, such as `https://github.com/coocood/freecache`
    and `https://github.com/patrickmn/go-cache`, which can help in implementing caching
    and, in this recipe, we will be using the `https://github.com/patrickmn/go-cache` to
    implement it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多包，例如`https://github.com/coocood/freecache`和`https://github.com/patrickmn/go-cache`，可以帮助实现缓存，在本教程中，我们将使用`https://github.com/patrickmn/go-cache`来实现它。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Install the `github.com/patrickmn/go-cache` package using the `go get` command,
    as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/patrickmn/go-cache`包，如下所示：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create `http-caching.go`, where we will create a cache and populate it with
    data on server boot up, as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-caching.go`，在其中我们将在服务器启动时创建一个缓存并填充数据，如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the program with the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: On startup, the key with the name `foo` with a value as `bar` will be added
    to the cache.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，具有名称`foo`和值为`bar`的键将被添加到缓存中。
- en: 'Browsing `http://localhost:8080/` will read a key value from the cache and
    append it to Hello as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览`http://localhost:8080/`将从缓存中读取一个键值，并将其附加到Hello，如下截图所示：
- en: '![](img/42c7eeff-5a4e-4c2a-bc9a-d125b604ae54.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42c7eeff-5a4e-4c2a-bc9a-d125b604ae54.png)'
- en: 'We have specified the cache data expiration time in our program as five minutes,
    which meansthe key that we have created in the cache at server startup will not
    be there after five minutes. So, accessing the same URL again after five minutes
    will return Key Not Found in the Cache from the server, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中指定了缓存数据的过期时间为五分钟，这意味着我们在服务器启动时在缓存中创建的键在五分钟后将不再存在。因此，五分钟后再次访问相同的URL将从服务器返回缓存中找不到键的消息，如下所示：
- en: '![](img/ced8f589-c0f6-4016-b5a6-0d7e80003110.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ced8f589-c0f6-4016-b5a6-0d7e80003110.png)'
- en: 'Let''s understand the program we have written:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解我们编写的程序：
- en: Using `var newCache *cache.Cache`, we declared a private cache.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`var newCache *cache.Cache`，我们声明了一个私有缓存。
- en: Next, we updated the `init()` function where we create a cache with five minutes
    of expiration time and 10 minutes of cleanup interval, and add an item to the
    cache with a key as `foo` with its value as `bar` and its expiration value as `0`,
    which means we want to use the cache's default expiration time.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新了`init()`函数，在其中创建了一个具有五分钟过期时间和十分钟清理间隔的缓存，并向缓存中添加了一个键为`foo`，值为`bar`，过期值为`0`的项目，这意味着我们要使用缓存的默认过期时间。
- en: If the expiration duration is less than one (or `NoExpiration`), the items in
    the cache never expire (by default) and must be deleted manually. If the cleanup
    interval is less than one, expired items are not deleted from the cache before
    calling `c.DeleteExpired()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过期持续时间小于一（或`NoExpiration`），则缓存中的项目永远不会过期（默认情况下），必须手动删除。如果清理间隔小于一，则在调用`c.DeleteExpired()`之前不会从缓存中删除过期的项目。
- en: Next, we defined the `getFromCache` handler where we retrieve the value for
    a key from the cache. If found, we write it to an HTTP response; otherwise, we
    write the `Key Not Found in Cache` message to an HTTP response.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`getFromCache`处理程序，从缓存中检索键的值。如果找到，我们将其写入HTTP响应；否则，我们将`Key Not Found
    in Cache`的消息写入HTTP响应。
- en: Implementing HTTP error handling in Go
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中实现HTTP错误处理
- en: Implementing error handling in any web application is one of the main aspects
    because it helps in troubleshooting and fixing bugs faster. Error handling means
    whenever an error occurs in an application, it should be logged somewhere, either
    in a file or in a database with the proper error message, along with the stack
    trace.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何Web应用程序中实现错误处理是主要方面之一，因为它有助于更快地进行故障排除和修复错误。错误处理意味着每当应用程序发生错误时，应该将其记录在某个地方，无论是在文件中还是在数据库中，都应该有适当的错误消息以及堆栈跟踪。
- en: In Go, it can be implemented in multiple ways. One way is to write custom handlers,
    which we will be covering in this recipe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，可以以多种方式实现。一种方法是编写自定义处理程序，我们将在本教程中介绍。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install the `github.com/gorilla/mux` package using the `go get` command, as
    follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`包，如下所示：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create `http-error-handling.go`, where we will create a custom handler that
    acts as a wrapper to handle all the HTTP requests, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`http-error-handling.go`，在其中我们将创建一个自定义处理程序，作为处理所有HTTP请求的包装器，如下所示：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the program with the following command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Once we run the program, the HTTP server will start locally listening on port
    `8080`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地监听端口`8080`。
- en: 'Next, browsing `http://localhost:8080/employee/get/foo` will give us the Hello,
    followed by the employee name with the status code as `200`, as a response in
    the browser:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，浏览`http://localhost:8080/employee/get/foo`将在浏览器中作为响应给我们Hello，后跟员工姓名和状态码为`200`：
- en: '![](img/35f4f25b-54f5-4ab0-9c0f-a4103482a04d.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35f4f25b-54f5-4ab0-9c0f-a4103482a04d.png)'
- en: 'On the other hand, accessing `http://localhost:8080/employee/get/bar` will
    return us an HTTP error with the message Name Not Found and an error code of `500`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，访问`http://localhost:8080/employee/get/bar`将返回一个带有消息Name Not Found和错误代码`500`的HTTP错误：
- en: '![](img/84a2f72f-5760-4af1-bd09-675a3cc4206b.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84a2f72f-5760-4af1-bd09-675a3cc4206b.png)'
- en: 'Let''s understand the program we have written:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解我们编写的程序：
- en: 'We defined a `NameNotFoundError` struct with two fields—`Code` of type `int`
    and `Err` of type `error`, which represents an error with an associated HTTP status
    code, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`NameNotFoundError`结构，它有两个字段——类型为`int`的`Code`和类型为`error`的`Err`，它表示一个带有关联HTTP状态码的错误，如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we allowed `NameNotFoundError` to satisfy the error interface, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们允许`NameNotFoundError`满足错误接口，如下所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we defined a user-defined type `WrapperHandler`, which is a Go function
    that accepts any handler that accepts `func(http.ResponseWriter, *http.Request)`
    as input parameters and returns an error.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个用户定义类型`WrapperHandler`，它是一个接受任何接受`func(http.ResponseWriter, *http.Request)`作为输入参数并返回错误的处理程序的Go函数。
- en: 'Then, we defined a `ServeHTTP` handler, which calls a handler we pass to `WrapperHandler` passing
    `(http.ResponseWriter, *http.Request)` as parameters to it and checks if there
    are any errors returned by the handler. If there are, then it handles them appropriately
    using the switch case, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`ServeHTTP`处理程序，它调用我们传递给`WrapperHandler`的处理程序，将`(http.ResponseWriter,
    *http.Request)`作为参数传递给它，并检查处理程序是否返回任何错误。如果有错误，则使用switch case适当处理它们，如下所示：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, we defined a `getName` handler, which extracts request path variables,
    gets the value of the `name` variable, and checks if the name matches `foo`. If
    so, then it writes Hello, followed by the name, to an HTTP response; otherwise,
    it returns a `NameNotFoundError` struct with a `Code` field value of `500` and
    an `err` field value of an `error` with the text `Name Not Found`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`getName`处理程序，它提取请求路径变量，获取`name`变量的值，并检查名称是否匹配`foo`。如果是，则将Hello，后跟名称，写入HTTP响应；否则，它将返回一个`Code`字段值为`500`的`NameNotFoundError`结构和一个`err`字段值为`error`的文本`Name
    Not Found`。
- en: Finally, we defined `main()`, where we registered `WrapperHandler` as a handler
    to be called for the URL pattern as `/get/{name}`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了`main()`，在其中将`WrapperHandler`注册为URL模式`/get/{name}`的处理程序。
- en: Implementing login and logout in web application
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web应用程序中实现登录和注销
- en: Whenever we want an application to be accessed by registered users, we have
    to implement a mechanism that asks for the user's credentials before allowing
    them to view any web pages, which we will be covering in this recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们希望应用程序只能被注册用户访问时，我们都必须实现一个机制，在允许他们查看任何网页之前要求用户提供凭据，这将在本示例中进行介绍。
- en: Getting ready…
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作…
- en: As we have already created an HTML form in one of our previous recipes, we will
    just update it to implement login and logout mechanisms using the `gorilla/securecookie`
    package.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的示例中创建了一个HTML表单，我们只需更新它以使用`gorilla/securecookie`包实现登录和注销机制。
- en: See the *Implementing login and logout in web application* recipe in [Chapter
    2](14068271-ad23-4956-960d-ec6d01e52494.xhtml), *Working with Templates, Static
    Files, and HTML Forms*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](14068271-ad23-4956-960d-ec6d01e52494.xhtml)的*使用模板、静态文件和HTML表单*中查看*在Web应用程序中实现登录和注销*的示例。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install `github.com/gorilla/mux` and `github.com/gorilla/securecookie` using
    the `go get` command, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go get`命令安装`github.com/gorilla/mux`和`github.com/gorilla/securecookie`，如下所示：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create `home.html` inside the `templates` directory, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`templates`目录中创建`home.html`，如下所示：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Copy the following content to `home.html`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容复制到`home.html`：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding template, we defined a placeholder, `{{.userName}}`, whose
    values will be substituted by the template engine at runtime and a Logout button.
    By clicking the Logout button, the client will make a `POST` call to a form action,
    which is `/logout` in our case.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述模板中，我们定义了一个占位符`{{.userName}}`，其值将在运行时由模板引擎替换，以及一个注销按钮。点击注销按钮后，客户端将对表单动作进行`POST`调用，这在我们的例子中是`/logout`。
- en: 'Create `html-form-login-logout.go`, where we will parse the login form, read
    the username field, and set a session cookie when a user clicks the Login button.
    We also clear the session once a user clicks the Logout button, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`html-form-login-logout.go`，在这里我们将解析登录表单，读取用户名字段，并在用户点击登录按钮时设置会话cookie。用户点击注销按钮后，我们也会清除会话，如下所示：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With everything in place, the directory structure should look like the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪后，目录结构应如下所示：
- en: '![](img/ae457fe4-65c1-46ed-ab4e-3998905c80b1.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae457fe4-65c1-46ed-ab4e-3998905c80b1.png)'
- en: 'Run the program with the following command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Once we run the program, the HTTP server will start listening locally on port `8080`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行程序，HTTP服务器将在本地的8080端口上开始监听。
- en: 'Next, browsing `http://localhost:8080` will show us the login form, as shown
    in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，浏览`http://localhost:8080`将显示我们的登录表单，如下截图所示：
- en: '![](img/d3e86f3e-8cee-4306-a391-29d2e021ccfe.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3e86f3e-8cee-4306-a391-29d2e021ccfe.png)'
- en: 'Submitting the form after entering the username `Foo` and a random password
    will render the Welcome Foo! message in the browser and create a cookie with the
    name session, which manages the user login/logout state:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入用户名`Foo`和随机密码后提交表单将在浏览器中显示欢迎Foo!消息，并创建一个名为session的cookie，用于管理用户的登录/注销状态：
- en: '![](img/bdf572bb-d0f3-49b5-95c7-b5cc9f0f43af.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdf572bb-d0f3-49b5-95c7-b5cc9f0f43af.png)'
- en: Now, every subsequent request to `http://localhost:8080/home` will display the
    Welcome Foo! message in the browser until the cookie with the name session exists.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，直到名为session的cookie存在，对`http://localhost:8080/home`的每个后续请求都将在浏览器中显示欢迎Foo!消息。
- en: 'Next, accessing `http://localhost:8080/home` after clearing the cookie will
    redirect us to `http://localhost:8080/` and show us the login form:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，清除cookie后访问`http://localhost:8080/home`将重定向我们到`http://localhost:8080/`并显示登录表单：
- en: '![](img/9bb677a6-44ea-4603-a5a6-28590d64ed97.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9bb677a6-44ea-4603-a5a6-28590d64ed97.png)'
- en: Let's understand the program we have written.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们编写的程序。
- en: Using `var cookieHandler = securecookie.New(securecookie.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`var cookieHandler = securecookie.New(securecookie.
- en: GenerateRandomKey(64), securecookie.GenerateRandomKey(32))`, we are creating
    a secure cookie, passing a hash key as the first argument, and a block key as the
    second argument. The hash key is used to authenticate values using HMAC and the
    block key is used to encrypt values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GenerateRandomKey(64), securecookie.GenerateRandomKey(32))`，我们创建了一个安全cookie，将哈希密钥作为第一个参数，块密钥作为第二个参数。哈希密钥用于使用HMAC对值进行身份验证，块密钥用于加密值。
- en: Next, we defined a `getUserName` handler, where we get a cookie from the HTTP
    request, initialize a `cookieValue` map of string `keys` to string `values`, decode
    a cookie, and get a value for the username and return.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`getUserName`处理程序，从HTTP请求中获取一个cookie，初始化一个字符串`键`到字符串`值`的`cookieValue`映射，解码一个cookie，并获取用户名的值并返回。
- en: Next, we defined a `setSession` handler, where we create and initialize a map
    with the `key` and `value` as `username`,serialize it, sign it with a message
    authentication code, encode it using a `cookieHandler.Encode` handler, create
    a new HTTP cookie, and write it to an HTTP response stream.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`setSession`处理程序，其中我们创建并初始化一个带有`key`和`value`的映射，将其序列化，使用消息认证码对其进行签名，使用`cookieHandler.Encode`处理程序对其进行编码，创建一个新的HTTP
    cookie，并将其写入HTTP响应流。
- en: Next, we defined `clearSession`, which basically sets the value of the cookie
    as empty and writes it to an HTTP response stream.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`clearSession`，它基本上将cookie的值设置为空，并将其写入HTTP响应流。
- en: Next, we defined a `login` handler, where we get a username and password from
    an HTTP form, check if both are not empty, then call a `setSession` handler and
    redirect to `/home`, otherwise, redirect to the root URL `/`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`login`处理程序，在这里，我们从HTTP表单中获取用户名和密码，检查两者是否都不为空，然后调用`setSession`处理程序并重定向到`/home`，否则重定向到根URL`/`。
- en: Next, we defined a `logout` handler, where we clear the session values calling
    the `clearSession` handler and redirect to the root URL.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`logout`处理程序，在这里，我们调用`clearSession`处理程序清除会话值，并重定向到根URL。
- en: Next, we defined a `loginPage` handler, where we parse `login-form.html`, return
    a new template with the name and its content, call the `Execute` handler on a
    parsed template, which generates HTML output, and write it to an HTTP response
    stream.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`loginPage`处理程序，在这里，我们解析`login-form.html`，返回一个具有名称和内容的新模板，调用已解析模板上的`Execute`处理程序，生成HTML输出，并将其写入HTTP响应流。
- en: Next, we defined a `homePage` handler, which gets the username from the HTTP
    request calling the `getUserName` handler. Then, we check whether it is not empty
    or whether there is a cookie value present. If the username is not blank, we parse
    `home.html`, inject the username as a data map, generate HTML output, and write
    it to an HTTP response stream; otherwise, we redirect it to the root URL `/`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个`homePage`处理程序，该处理程序从调用`getUserName`处理程序的HTTP请求中获取用户名。然后，我们检查它是否不为空或是否存在cookie值。如果用户名不为空，我们解析`home.html`，将用户名注入数据映射，生成HTML输出，并将其写入HTTP响应流；否则，我们将其重定向到根URL`/`。
- en: 'Finally, we defined the `main()` method, where we start the program execution.
    As this method does a lot of things, let''s look at it line by line:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`main()`方法，我们在这里启动程序执行。由于这个方法做了很多事情，让我们逐行查看它：
- en: '`var router = mux.NewRouter()`: Here, we create a new router instance.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var router = mux.NewRouter()`: 在这里，我们创建了一个新的路由器实例。'
- en: '`router.HandleFunc("/", loginPage)`: Here, we are registering the `loginPageHandler`
    handler with the `/` URL pattern using `HandleFunc` of the `gorilla/mux` package,
    which means the `loginPage` handler gets executed by passing `(http.ResponseWriter,
    *http.Request)` as parameters to it whenever we access the HTTP URL with the `/`
    pattern.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.HandleFunc("/", loginPage)`: 在这里，我们使用`gorilla/mux`包的`HandleFunc`注册了`loginPageHandler`处理程序，并使用`/`
    URL模式，这意味着每当我们访问具有`/`模式的HTTP URL时，`loginPage`处理程序将通过传递`(http.ResponseWriter, *http.Request)`作为参数来执行。'
- en: '`router.HandleFunc("/home", homePage)`: Here, we are registering the `homePageHandler`
    handler with the `/home` URL pattern using the `HandleFunc` of the `gorilla/mux`
    package, which means the `homePage` handler gets executed by passing `(http.ResponseWriter,
    *http.Request)` as parameters to it whenever we access the HTTP URL with the `/home`
    pattern.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.HandleFunc("/home", homePage)`: 在这里，我们使用`gorilla/mux`包的`HandleFunc`注册了`homePageHandler`处理程序，并使用`/home`
    URL模式，这意味着每当我们访问具有`/home`模式的HTTP URL时，`homePage`处理程序将通过传递`(http.ResponseWriter,
    *http.Request)`作为参数来执行。'
- en: '`router.HandleFunc("/login", login).Methods("POST")`: Here, we are registering
    the `loginHandler` handler with the `/login` URL pattern using the `HandleFunc`
    of the `gorilla/mux` package, which means the `login` handler gets executed by
    passing `(http.ResponseWriter, *http.Request)` as parameters to it whenever we
    access the HTTP URL with the `/login` pattern.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.HandleFunc("/login", login).Methods("POST")`: 在这里，我们使用`gorilla/mux`包的`HandleFunc`注册了`loginHandler`处理程序，并使用`/login`
    URL模式，这意味着每当我们访问具有`/login`模式的HTTP URL时，`login`处理程序将通过传递`(http.ResponseWriter,
    *http.Request)`作为参数来执行。'
- en: '`router.HandleFunc("/logout", logout).Methods("POST")`: Here, we are registering
    the `logoutHandler` handler with the `/logout` URL pattern using the `HandleFunc`
    of the `gorilla/mux` package, which means the `logout` handler gets executed by
    passing `(http.ResponseWriter, *http.Request)` as parameters to it whenever we
    access the HTTP URL with the `/logout` pattern.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router.HandleFunc("/logout", logout).Methods("POST")`: 在这里，我们使用`gorilla/mux`包的`HandleFunc`注册了`logoutHandler`处理程序，并使用`/logout`
    URL模式，这意味着每当我们访问具有`/logout`模式的HTTP URL时，`logout`处理程序将通过传递`(http.ResponseWriter,
    *http.Request)`作为参数来执行。'
- en: '`http.Handle("/", router)`: Here, we are registering the router for the `/` URL pattern
    using `HandleFunc` of the `net/http` package, which means all requests with the
    `/` URL pattern are handled by the router handler.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Handle("/", router)`: 在这里，我们使用`net/http`包的`HandleFunc`为`/` URL模式注册了路由器，这意味着所有具有`/`
    URL模式的请求都由路由器处理。'
- en: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: Here, we are calling
    `http.ListenAndServe` to serve HTTP requests that handle each incoming connection
    in a separate Goroutine. `ListenAndServe` accepts two parameters—server address
    and handler, where the server address is `localhost:8080` and the handler is `nil`,
    which means we are asking the server to use `DefaultServeMux` as a handler.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err := http.ListenAndServe(CONN_HOST+":"+CONN_PORT, nil)`: 在这里，我们调用`http.ListenAndServe`来提供处理每个传入连接的HTTP请求的请求。`ListenAndServe`接受两个参数——服务器地址和处理程序，其中服务器地址为`localhost:8080`，处理程序为`nil`，这意味着我们要求服务器使用`DefaultServeMux`作为处理程序。'
- en: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    Here, we check if there are any problems with starting the server. If there are, then
    log the error and exit with a status code of `1`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if err != nil { log.Fatal("error starting http server : ", err) return}`:
    在这里，我们检查是否有任何启动服务器的问题。如果有，记录错误并以状态码`1`退出。'
