- en: 2\. Logic and Loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 逻辑和循环
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we'll use branching logic and loops to demonstrate how logic
    can be controlled and selectively run. With these tools, you'll have control of
    what you do and don't want to run based on the values of variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用分支逻辑和循环来展示如何控制逻辑并选择性运行。有了这些工具，你可以根据变量的值来控制你想运行或不运行的逻辑。
- en: By the end of this chapter, you will be able to implement branching logic using
    `if`, `else`, and `else if`; use `switch` statements to simplify complex branching
    logic; create looping logic using a `for` loop; loop over complex data collections
    using `range`; and use `continue` and `break` to take control of the flow of loops.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用`if`、`else`和`else if`实现分支逻辑；使用`switch`语句简化复杂的分支逻辑；使用`for`循环创建循环逻辑；使用`range`遍历复杂的数据集合；以及使用`continue`和`break`来控制循环的流程。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at variables and values and how we can temporarily
    store data in a variable and make changes to that data. We're now going to look
    at how we can use that data to run logic, or not, selectively. This logic allows
    you to control how data flows through your software. You can react to and perform
    different operations based on the values in your variables.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了变量和值，以及我们如何可以在变量中临时存储数据并对该数据进行更改。现在，我们将探讨如何使用这些数据来选择性运行逻辑。这种逻辑允许你控制数据在你的软件中的流动。你可以根据变量中的值来响应并执行不同的操作。
- en: The logic could be for validating your user's inputs. If we were writing code
    to manage a bank account, and the user asked to withdraw some money, we could
    check that they asked for a valid amount of money. We would check that they had
    enough money in their account. If the validation was successful, we would use
    logic to update their balance, transfer the money, and show a success message.
    If the validation failed, we'd show a message explaining what went wrong.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑可以用于验证用户的输入。如果我们正在编写管理银行账户的代码，并且用户要求提取一些钱，我们可以检查他们是否请求了有效的金额。我们会检查他们账户中是否有足够的钱。如果验证成功，我们会使用逻辑来更新他们的余额，转账并显示成功消息。如果验证失败，我们会显示一条解释出错原因的消息。
- en: If your software is a virtual world, then logic is the physical law of that
    world. Like the physical laws of our world, those laws must be followed and can't
    be broken. If you create a law with a flaw in it, then your virtual world won't
    run smoothly and could even explode.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的软件是一个虚拟世界，那么逻辑就是这个世界的物理定律。就像我们世界的物理定律一样，这些定律必须遵循，不能被打破。如果你在一条定律中存在缺陷，那么你的虚拟世界将无法顺利运行，甚至可能发生爆炸。
- en: Another form of logic is a loop; using loops allows you to execute the same
    logic multiple times. A common way to use loops is to iterate over a collection
    of data. For our imaginary banking software, we would use a loop to step over
    a user's transactions to display them to the user on request.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种逻辑形式是循环；使用循环可以让你多次执行相同的逻辑。使用循环的一种常见方式是遍历数据集合。对于我们的虚拟银行软件，我们会使用循环来遍历用户的交易，以便在用户请求时显示它们。
- en: Loops and logic allow the software to have complex behavior that responds to
    changing and dynamic data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 循环和逻辑使软件能够具有复杂的行为，能够对变化和动态数据做出响应。
- en: if Statements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句
- en: 'An `if` statement is the most basic form of logic in Go. An `if` statement
    either will or won''t run a block of logic based on a Boolean expression. The
    notation looks like this: `if <boolean expression> { <code block> }`.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是Go中最基本的逻辑形式。`if`语句会根据布尔表达式运行或不运行一个逻辑块。其表示法如下：`if <布尔表达式> { <代码块> }`。'
- en: The Boolean expression can be a simple code that results in a Boolean value.
    The code block can be any logic that you could also put in a function. The code
    block runs when the Boolean expression is true. You can only use `if` statements
    in the function scope.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式可以是一个简单的代码，其结果为布尔值。代码块可以是任何你也能放入函数中的逻辑。当布尔表达式为真时，代码块会运行。你只能在函数作用域中使用`if`语句。
- en: 'Exercise 2.01: A Simple if Statement'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：一个简单的if语句
- en: 'In this exercise, we''ll use an `if` statement to control whether logic will
    or won''t run. We''ll define an `int` value to check it''s hardcoded, but in a
    real-world application, this could be user input. We''ll then check whether the
    value is an odd or even number using `%` operator, also known as a modulus expression
    on the variable. The modulus gives you the amount remaining after division. We''ll
    use the modulus to get the remainder after dividing by 2\. If we get a remainder
    of 0, we know the number is even. If the remainder is 1, we know the number is
    odd. The modulus results in an `int`, so we use `==` to get a Boolean value:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用if语句来控制逻辑是否运行。我们将定义一个`int`值来检查它是否是硬编码的，但在实际应用中，这可能是用户输入。然后我们将使用`%`运算符（也称为变量上的取模表达式）检查该值是奇数还是偶数。取模运算给出除法后的剩余量。我们将使用取模运算来获取除以2后的余数。如果我们得到余数为0，我们知道这个数字是偶数。如果余数是1，我们知道这个数字是奇数。取模运算的结果是`int`类型，所以我们使用`==`来获取布尔值：
- en: Create a new folder and add a `main.go` file.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the `main` function:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main`函数：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define an `int` variable with an initial value. We are setting it to 5 here,
    which is an odd number but we could also set it to 6, which is an even number:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个带有初始值的`int`变量。这里我们将其设置为5，这是一个奇数，但也可以设置为6，这是一个偶数：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create an `if` statement that uses a modulus expression; then, check whether
    the result is equal to 0:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用取模表达式的`if`语句；然后，检查结果是否等于0：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the Boolean expression results in `true`, that means the number is even.
    We then print that it''s even to the console using the format package:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当布尔表达式结果为`true`时，这意味着数字是偶数。然后我们使用格式包将“偶数”打印到控制台：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Close the code block:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭代码块：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now do the same for odd numbers:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为奇数做同样的操作：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Close `main`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main`：
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，在新的文件夹中，`运行`以下代码片段：
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the expected output:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE9]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this exercise, we used logic to run code selectively. Using logic to control
    what code runs, let's you create flows through your code. This allows you to have
    code that reacts to its data. These flows allow you to be able to reason about
    what the code is doing with your data, making it easier to understand and maintain.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了逻辑来选择性运行代码。使用逻辑来控制代码的运行，让你能够在代码中创建流程。这允许你拥有能够对其数据进行反应的代码。这些流程允许你能够对你的代码如何处理数据进行推理，使其更容易理解和维护。
- en: Try changing the value of the input to 6 to see how the even block gets executed
    instead of the odd block.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将输入的值改为6，看看偶数块是如何被执行而不是奇数块的。
- en: In the next topic, we'll explore how we can improve this code and make it more
    efficient.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将探讨如何改进这段代码并使其更高效。
- en: if else Statements
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if else语句
- en: In the previous exercise, we did two evaluations. One evaluation was to check
    whether the number was even and the other was to see whether it was odd. As we
    know, a number can only ever be odd or even. With this knowledge, we can use deduction
    to know that if a number is not even, then it must be odd.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们进行了两次评估。一次评估是检查数字是否为偶数，另一次是检查它是否为奇数。正如我们所知，一个数字只能是奇数或偶数。有了这个知识，我们可以使用演绎法知道如果一个数字不是偶数，那么它一定是奇数。
- en: Using deductive logic like this is common in programming in order to make programs
    more efficient by not having to do unnecessary work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种演绎逻辑在编程中很常见，目的是通过避免做不必要的工作来提高程序的效率。
- en: 'We can represent this kind of logic using an `if` `else` statement. The notation
    looks like this: `if <boolean expression> { <code block> } else { <code block>
    }`. The `if` `else` statement builds on the `if` statement and gives us a second
    block. The second block only runs if the first block doesn''t run; both blocks
    can''t run.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用if else语句来表示这种逻辑。表示法如下：`if <布尔表达式> { <代码块> } else { <代码块> }`。if else语句建立在if语句的基础上，并给我们第二个块。第二个块只有在第一个块不运行时才会运行；两个块不能同时运行。
- en: 'Exercise 2.02: Using an if else Statement'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：使用if else语句
- en: 'In this exercise, we''ll update our previous exercise to use an `if` `else`
    statement:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新之前的练习，使用if else语句：
- en: Create a new folder and add a `main.go` file.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add `package` and `import`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加`package`和`import`：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create the `main` function:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main`函数：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define an `int` variable with an initial value, and we''ll give it a different
    value this time:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个带有初始值的`int`变量，这次我们将给它赋予不同的值：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create an `if` statement that uses a modulus expression, and then check whether
    the result is equal to 0:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用取模表达式的 `if` 语句，然后检查结果是否等于 0：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This time, we are not closing the code block but starting a new `else` code
    block:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们不是关闭代码块，而是开始一个新的 `else` 代码块：
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Close `main`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `main`：
- en: '[PRE15]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，在新的文件夹中，`运行`以下代码片段：
- en: '[PRE16]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the expected output:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this exercise, we were able to simplify our previous code by using an `if`
    `else` statement. As well as making the code more efficient, it also makes the
    code easier to understand and maintain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够通过使用 `if` `else` 语句简化之前的代码。这不仅使代码更高效，还使代码更容易理解和维护。
- en: In the next topic, we'll demonstrate how we can add as many code blocks as you
    want while still only letting one execute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将演示如何添加尽可能多的代码块，同时仍然只允许一个执行。
- en: else if Statements
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`else if` 语句'
- en: The `if` `else` solves the problem of running code for only one or two possible
    logical outcomes. With that covered, what if our preceding exercise's code was
    intended to only work for non-negative numbers? We need something that can evaluate
    more than one Boolean expression but only execute one of the code blocks, that
    is, the code block for negative numbers, even numbers, or odd numbers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` `else` 语句解决了仅针对一个或两个可能的逻辑结果运行代码的问题。这个问题解决之后，如果我们之前的练习代码只打算对非负数有效，那会怎样呢？我们需要某种能够评估多个布尔表达式但只执行一个代码块（即负数、偶数或奇数的代码块）的东西。'
- en: 'In that case, we can''t use an `if` `else` statement on its own; however, we
    could cover it with another extension to `if` statements. In this extension, you
    can give the `else` statement its own Boolean expression. This is how the notation
    looks: `if <boolean expression> { <code block> } else if <boolean expression>
    { <code block> }`. You can also combine it with a final `else` statement at the
    end, which would look like this: `if <boolean expression> { <code block> } else
    if <boolean expression> { <code block> } else { <code block> }`. After the initial
    `if` statement, you can have as many `else` `if` statements as you need. Go evaluates
    the Boolean expressions from the top of the statements and works its way through
    each Boolean expression until one results in `true` or finds an `else`. If there
    is no `else` and none of the Boolean expressions results in true, then no block
    is executed and Go moves on. When Go gets a Boolean true result, it executes the
    code block for that statement only and it then stops evaluating any Boolean expressions
    of the `if` statement.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，我们不能单独使用 `if` `else` 语句；然而，我们可以通过扩展 `if` 语句来覆盖它。在这个扩展中，你可以给 `else` 语句自己的布尔表达式。这个表示法看起来是这样的：`if
    <布尔表达式> { <代码块> } else if <布尔表达式> { <代码块> }`。你还可以将它与最后的 `else` 语句结合起来，这看起来是这样的：`if
    <布尔表达式> { <代码块> } else if <布尔表达式> { <代码块> } else { <代码块> }`。在初始的 `if` 语句之后，你可以有尽可能多的
    `else if` 语句。Go 从语句的顶部评估布尔表达式，并逐个评估每个布尔表达式，直到其中一个结果为 `true` 或找到 `else`。如果没有 `else`
    并且没有布尔表达式结果为 `true`，则不执行任何代码块，Go 继续执行。当 Go 获取布尔 `true` 结果时，它只执行该语句的代码块，然后停止评估
    `if` 语句的任何布尔表达式。
- en: 'Exercise 2.03: Using an else if Statement'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.03：使用 `else if` 语句
- en: 'In this exercise, we''ll update our previous exercise. We''re going to add
    a check for negative numbers. This check must run before the even and odd checks,
    as only one of the code blocks can run:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新之前的练习。我们将添加对负数的检查。这个检查必须在偶数和奇数检查之前运行，因为只有一个代码块可以运行：
- en: Create a new folder and add a `main.go` file.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'In `main.go`, add `package` and `import`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加 `package` 和 `import`：
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create the `main` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main` 函数：
- en: '[PRE19]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define an `int` variable with an initial value, and we''ll give it a negative
    value:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个带有初始值的 `int` 变量，我们将给它一个负值：
- en: '[PRE20]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our first Boolean expression is to check for negative numbers. If we find a
    negative number, we''ll print a message saying that they are not allowed:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个布尔表达式是检查负数。如果我们找到一个负数，我们将打印一条消息说它们是不允许的：
- en: '[PRE21]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We need to move our even check to an `else` `if` statement:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将我们的偶数检查移动到 `else if` 语句中：
- en: '[PRE22]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `else` statement stays the same, and we then close `main`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`else` 语句保持不变，然后我们关闭 `main`：'
- en: '[PRE23]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，在新的文件夹中，`运行`以下代码片段：
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the expected output:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '[PRE25]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this exercise, we added even more complex logic to our `if` statement. We
    added an `else` `if` statement to it, which allowed complex evaluation. This addition
    took what is usually a simple fork in the road that gives you many roads to go
    down but still with the restriction of only going down one of them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在`if`语句中添加了更复杂的逻辑。我们添加了一个`else if`语句，这使得复杂的评估成为可能。这个添加将通常是一个简单的分叉路口，它提供了许多道路可以选择，但仍然受到只能选择其中一条的限制。
- en: In the next topic, we'll use a subtle but powerful feature of `if` statements
    that lets you keep your code nice and tidy.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将使用`if`语句的一个微妙但强大的功能，它让你保持代码整洁。
- en: The Initial if Statement
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始`if`语句
- en: It's common to need to call a function but not care too much about the returned
    value. Often, you'll want to check that it executed correctly and then discard
    the returned value. For example, sending an email, writing to a file, or inserting
    data into a database; most of the time, if these types of operations execute successfully,
    you don't need to worry about the variables they return. Unfortunately, the variables
    don't go anywhere as they are still in scope.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要调用一个函数，但并不太关心返回的值。通常，你只想检查它是否正确执行，然后丢弃返回的值。例如，发送电子邮件、写入文件或将数据插入数据库；大多数情况下，如果这些类型的操作执行成功，你不需要担心它们返回的变量。不幸的是，变量并没有消失，因为它们仍然在作用域内。
- en: 'To stop these unwanted variables from hanging around, we can use what we know
    about scope rules to get rid of them. The best way to check for errors is to use
    "initial" statements on `if` statements. The notation looks like this: `if <initial
    statement>; <boolean expression> { <code block> }`. The initial statement is in
    the same section as the Boolean expression, with `;` to divide them.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止这些不想要的变量徘徊，我们可以利用我们对作用域规则的了解来消除它们。检查错误最好的方法是使用`if`语句上的“初始”语句。表示法如下：`if <initial
    statement>; <boolean expression> { <code block> }`。初始语句与布尔表达式位于同一部分，用`;`分隔它们。
- en: 'Go only allows what it calls simple statements in the initial statement section,
    including:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Go只允许在初始语句部分使用它所称为的简单语句，包括：
- en: 'Assignment and short variable assignments:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值和短变量赋值：
- en: '[PRE26]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Expressions such as math or logic expressions:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如数学或逻辑表达式之类的表达式：
- en: '[PRE27]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sending statements for working with channels, which we'll cover later.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送用于处理通道的语句，我们将在后面介绍。
- en: 'Increment and decrement expressions:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量和减量表达式：
- en: '[PRE28]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A common mistake is trying to define a variable using `var`. That's not allowed;
    you can use the short assignment in its place.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是尝试使用`var`定义变量。这是不允许的；你可以用短赋值来代替。
- en: 'Exercise 2.04: Implementing the Initial if Statements'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：实现初始`if`语句
- en: 'In this exercise, we''re going to continue to build on our previous exercises.
    We''re going to add even more rules about what numbers can be checked as to whether
    they are odd or even. With so many rules, putting them all in a single Boolean
    expression is hard to understand. We''ll move all the validation logic to a function
    that returns an `error`. This is a built-in Go type used for errors. It the value
    of the error is `nil`, then everything is okay. If not, you have an error, and
    you need to deal with it. We''ll call the function in our initial statement and
    then check for errors:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将继续构建我们之前的练习。我们将添加更多关于哪些数字可以检查为奇数或偶数的规则。由于规则众多，将它们全部放入一个布尔表达式中很难理解。我们将把所有的验证逻辑移动到一个返回`error`的函数中。这是一个用于错误的内置Go类型。如果错误的值为`nil`，则一切正常。如果不为`nil`，则表示有错误，你需要处理它。我们将在初始语句中调用该函数，然后检查错误：
- en: Create a new folder and add a `main.go` file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add `package` and `import`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加`package`和`import`：
- en: '[PRE29]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a function to do the validation. This function takes a single integer
    and returns `error`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于验证的函数。这个函数接受一个整数并返回`error`：
- en: '[PRE30]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We define some rules, and if any are true, we return a new `error` using the
    `New` function in the `errors` package:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一些规则，如果其中任何一个是真的，我们就使用`errors`包中的`New`函数返回一个新的`error`：
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the input passes all the checks, return `nil`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入通过了所有的检查，返回`nil`：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create our `main` function:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`main`函数：
- en: '[PRE33]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define a variable with a value of `21`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个值为`21`的变量：
- en: '[PRE34]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Call the function using the initial statement; use the short variable assignment
    to capture the returned error. In the Boolean expression, check that the error
    is not equal to `nil` using `!=`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用初始语句调用函数；使用短变量赋值来捕获返回的错误。在布尔表达式中，使用`!=`检查错误是否不等于`nil`：
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The rest is the same as before:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的与之前相同：
- en: '[PRE36]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在新建的文件夹中，`运行`以下代码片段：
- en: '[PRE37]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the expected output which displays an error statement:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期的输出，显示错误语句：
- en: '[PRE38]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this exercise, we used an initial statement to define and initialize a variable.
    That variable can be used in the Boolean expression and the related code block.
    Once the `if` statement completes, the variable goes out of scope and is reclaimed
    by Go's memory management system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用初始语句来定义和初始化一个变量。该变量可以在布尔表达式中使用，并在相关的代码块中使用。一旦`if`语句完成，该变量就会超出作用域，并由Go的内存管理系统回收。
- en: 'Activity 2.01: Implementing FizzBuzz'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.01：实现FizzBuzz
- en: When interviewing for a programming job, you'll be asked to do some coding exercises.
    These questions have you writing something from scratch and will have several
    rules to follow. To give you an idea of what that looks like, we'll run you through
    a classic one, "FizzBuzz."
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当面试编程工作时，你将被要求做一些编码练习。这些问题要求你从头开始编写，并将遵循多个规则。为了给你一个概念，我们将带你通过一个经典的问题，“FizzBuzz”。
- en: 'The rules are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是这样的：
- en: Write a program that prints out the numbers from 1 to 100.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序，打印出从1到100的数字。
- en: If the number is a multiple of 3, print "Fizz."
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是3的倍数，打印 "Fizz."
- en: If the number is a multiple of 5, print "Buzz."
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是5的倍数，打印 "Buzz."
- en: If the number is a multiple of 3 and 5, print "FizzBuzz."
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是3和5的倍数，打印 "FizzBuzz."
- en: 'Here are some tips:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示：
- en: You can convert a number to a string using `strconv.Itoa()`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`strconv.Itoa()`函数将数字转换为字符串。
- en: The first number to evaluate must be 1 and the last number to evaluate must
    be 100.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要评估的第一个数字必须是1，最后一个数字必须是100。
- en: 'These steps will help you to complete the activity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助你完成活动：
- en: Create a loop that does 100 iterations.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，进行100次迭代。
- en: Have a variable that keeps count of the number of loops so far.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个变量用来记录到目前为止的循环次数。
- en: In the loop, use that count and check whether it's divisible by 3 or 5 using
    `%`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中，使用该计数并检查它是否能被3或5整除，使用`%`运算符。
- en: Think carefully about how you'll deal with the "FizzBuzz" case.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细思考你将如何处理"FizzBuzz"的情况。
- en: 'The following screenshot shows the expected output:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了预期的输出：
- en: Note
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Considering that the output is too big to be displayed here, only a part of
    it will be visible in *Figure 2.01*.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到输出太大无法在此显示，只有其中一部分将在*图2.01*中可见。
- en: '![Figure 2.01: The FizzBuzz output'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.01：FizzBuzz输出'
- en: '](img/B14177_02_01.jpg)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_02_01.jpg)'
- en: 'Figure 2.01: The FizzBuzz output'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.01：FizzBuzz输出
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 686.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第686页找到。
- en: In the next topic, we'll see how we can tame `if` `else` statements that start
    to get too big.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将看到如何驯服开始变得太大的`if else`语句。
- en: Expression switch Statements
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式switch语句
- en: While it's possible to add as many `else` `if` statements to an `if` as you
    want, at some point, it'll get hard to read.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在`if`中添加任意多的`else if`语句，但最终会变得难以阅读。
- en: 'When this happens, you can use Go''s logic alternative: `switch`. For situations
    where you would need a big `if` statement, `switch` can be a more compact alternative.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，你可以使用Go的逻辑替代方案：`switch`。对于需要大`if`语句的情况，`switch`可以是一个更紧凑的替代方案。
- en: 'The notation for `switch` is shown in the following code snippet:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`的表示法在以下代码片段中显示：'
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The "initial" statement works the same in `switch` as it does in the preceding
    `if` statements. The expression is not the same because the `if` is a Boolean
    expression. You can have more than just a Boolean in this expression. The cases
    are where you check to see whether the statements get executed. Statements are
    like code blocks in `if` statements, but with no need for the curly brackets here.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '"初始"语句在`switch`中的作用与在先前的`if`语句中相同。表达式并不相同，因为`if`是布尔表达式。在这个表达式中，你可以有不仅仅是布尔值。cases是检查语句是否被执行的地方。语句类似于`if`语句中的代码块，但这里不需要花括号。'
- en: 'Both the initial statement and expression are optional. To have just the expression,
    it would look like this: `switch <expresion> {…`. To have only the initial statement,
    you would write `switch <initial statment>; {…`. You can leave them both off,
    and you''ll end up with `switch {…`. When the expression is missing, it''s as
    if you put the value of `true` there.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 初始语句和表达式都是可选的。要只有表达式，它看起来像这样：`switch <expression> {…}`。要只有初始语句，您将写`switch <initial
    statement>; {…}`。您可以同时省略它们，最终结果是`switch {…}`。当表达式缺失时，它就像在那里放置了`true`的值。
- en: There are two main ways of using case expressions. They can be used just like
    `if` statements or Boolean expressions where you use logic to control whether
    the statements get executed. The alternative is to put a literal value there.
    In this case, the value is compared to the value in the `switch` expression. If
    they match, then the statements run. You can have as many case expressions as
    you want by separating them with a`,`. The case expressions get checked from the
    top case and then from left to right if a case has multiple expressions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用情况表达式有两种主要方式。它们可以像`if`语句或布尔表达式一样使用，其中您使用逻辑来控制语句是否执行。另一种选择是在那里放置一个字面值。在这种情况下，该值与`switch`表达式的值进行比较。如果它们匹配，则执行语句。您可以通过逗号分隔来拥有任意数量的情况表达式。如果情况有多个表达式，则从顶部情况开始检查，然后从左到右。
- en: When a case matches, only its statements are run, which is different from many
    other languages. To get the fallthrough behavior found in those languages, a `fallthrough`
    statement must be added to the end of each case where you want that behavior.
    If you call `fallthrough` before the end of the case, it will fall through at
    that moment and move on to the next case.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个情况匹配时，只有其语句会被执行，这与许多其他语言不同。要获得那些语言中找到的穿透行为，必须在想要该行为的每个情况的末尾添加一个`fallthrough`语句。如果在情况末尾之前调用`fallthrough`，它将在那一刻穿透并继续到下一个情况。
- en: An optional `default` case can be added anywhere in the `switch` statement,
    but it's best practice to add it to the end. The `default` case works just like
    using an `else` statement in an `if` statement.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`switch`语句的任何地方添加一个可选的`default`情况，但最佳实践是在末尾添加。`default`情况的工作方式与在`if`语句中使用`else`语句相同。
- en: This form of switch statement is called an "expression `switch`" statement.
    There is also another form of `switch` statement, called a "type `switch`" statement,
    which we'll look at in a later chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的`switch`语句称为“表达式`switch`”语句。还有一种`switch`语句的形式，称为“类型`switch`”语句，我们将在后面的章节中探讨。
- en: 'Exercise 2.05: Using a switch Statement'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.05：使用`switch`语句
- en: 'In this exercise, we need to create a program that prints a particular message
    based on the day someone was born. We are using the `time` package for the set
    of days of the week constants. We''ll use a `switch` statement to make a more
    compact logic structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们需要创建一个程序，根据某人出生的日期打印特定的消息。我们使用`time`包中的星期几常量集。我们将使用`switch`语句来创建一个更紧凑的逻辑结构：
- en: 'Load the `main` package:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`main`包：
- en: '[PRE40]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Import the `fmt` and `time` packages:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`fmt`和`time`包：
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define the `main` function:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数：
- en: '[PRE42]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define a variable that is the day of the week someone was born. Use the constants
    from the `time` package to do it. We''ll set it to Monday, but it could be any
    day:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个变量，表示某人出生的星期几。使用`time`包中的常量来完成这个操作。我们将它设置为星期一，但可以是任何一天：
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `switch` statement that uses the variable as it''s expression:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用变量作为表达式的`switch`语句：
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Each `case` will try to match its expression value against the switch expression
    value:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个`case`将尝试将其表达式值与`switch`表达式值匹配：
- en: '[PRE45]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''ll use the `default` case here as a form of validation:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里使用`default`情况作为一种验证形式：
- en: '[PRE46]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Close the `main` function:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main`函数：
- en: '[PRE47]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在新的文件夹中`运行`以下代码片段：
- en: '[PRE48]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the expected output:'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是预期的输出：
- en: '[PRE49]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this exercise, we used `switch` to create a compact logic structure that
    matches lots of different possible values to give a specific message to our users.
    It's quite common to see `switch` statements used with a constant as we did here,
    using the day of the week constants from the `time` package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`switch`创建了一个紧凑的逻辑结构，将许多不同的可能值匹配给我们的用户特定的消息。在像这里一样使用常量时，使用`time`包中的星期几常量，看到`switch`语句的使用相当常见。
- en: Next, we'll use the `case` feature that let's us match multiple values.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用允许我们匹配多个值的`case`功能。
- en: 'Exercise 2.06: switch Statements and Multiple case Values'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.06：`switch`语句和多个`case`值
- en: 'In this exercise, we''re going to print out a message that tells us whether
    the day someone was born was a weekday or the weekend. We only need two cases
    as each case can support checking multiple values:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将打印出一条消息，告诉我们某人出生的那天是工作日还是周末。我们只需要两个`case`，因为每个`case`可以支持检查多个值：
- en: 'Load the `main` package:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`main`包：
- en: '[PRE50]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Import the `fmt` and `time` packages:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`fmt`和`time`包：
- en: '[PRE51]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define the `main` function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数：
- en: '[PRE52]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define our `dayBorn` variable using one of the `time` package''s constants:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`time`包的一个常量定义我们的`dayBorn`变量：
- en: '[PRE53]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`switch` starts the same by using the variable as the expression:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`通过使用变量作为表达式开始：'
- en: '[PRE54]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This time, for `case`, we have weekday constants. Go checks each one against
    the `switch` expression, starting from the left, and sweeps through each one by
    one. Once Go gets a match, it stops evaluating and runs the statements for that
    case only:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，对于`case`，我们有星期几的常量。Go从左到右逐个检查每个常量与`switch`表达式的匹配，逐个进行扫描。一旦Go找到匹配项，它就会停止评估并只运行该`case`的语句：
- en: '[PRE55]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, it does the same for weekend days:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它对周末的日子也做了同样的处理：
- en: '[PRE56]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We use `default` for validation again and close out the `switch` statement:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次使用`default`进行验证并关闭`switch`语句：
- en: '[PRE57]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Close the `main` function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main`函数：
- en: '[PRE58]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在新的文件夹中`运行`以下代码片段：
- en: '[PRE59]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following is the expected output:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '[PRE60]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this exercise, we used cases with multiple values. This allowed a very compact
    logic structure that could evaluate 7 days of the week with validation checking
    in a few lines of code. It makes the intention of the logic clear, which, in turn,
    makes it easier to change and maintain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了具有多个值的`case`。这允许我们构建一个非常紧凑的逻辑结构，用几行代码就能评估一周中的7天，并进行验证检查。这使得逻辑意图清晰，反过来也使得更改和维护变得更加容易。
- en: Next, we'll look at using more complex logic in `case` expressions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在`case`表达式中使用更复杂的逻辑。
- en: Sometimes, you'll see code that doesn't evaluate anything in the `switch` statement
    but does checks in the `case` expression.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会看到代码在`switch`语句中没有进行任何评估，但在`case`表达式中进行了检查。
- en: 'Exercise 2.07: Expressionless switch Statements'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.07：无表达式的`switch`语句
- en: It's not always possible to be able to match values using the value of the `switch`
    expression. Sometimes, you'll need to match on multiple variables. Sometimes,
    you'll need to match on something more complicated than an equality check. For
    example, you may need to check whether a number is in a specific range. In these
    cases, `switch` is still helpful in building compact logic statements, as `case`
    allows the same range of expressions that you have in `if` Boolean expressions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是能够通过`switch`表达式的值来匹配值。有时，你需要匹配多个变量。有时，你需要匹配比相等检查更复杂的东西。例如，你可能需要检查一个数字是否在特定的范围内。在这些情况下，`switch`仍然有助于构建紧凑的逻辑语句，因为`case`允许与`if`布尔表达式相同的表达式范围。
- en: 'In this exercise, let''s build a simple `switch` expression that checks whether
    a day is a weekend to show what can be done in `case`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，让我们构建一个简单的`switch`表达式，检查一天是否为周末，以展示在`case`中可以做什么：
- en: 'Load the `main` package:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`main`包：
- en: '[PRE61]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Import the `fmt` and `time` packages:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`fmt`和`time`包：
- en: '[PRE62]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the `main` function:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main`函数：
- en: '[PRE63]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Our `switch` expression is using the initial statement to define our variable.
    The expression is left empty as we''ll not be using it:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`switch`表达式使用初始语句来定义我们的变量。表达式留空，因为我们不会使用它：
- en: '[PRE64]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`case` is using some complex logic to check whether the day is at the weekend:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`case`正在使用一些复杂的逻辑来检查这一天是否在周末：'
- en: '[PRE65]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add a `default` statement and close the `switch` expression:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`default`语句并关闭`switch`表达式：
- en: '[PRE66]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Close the `main` function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main`函数：
- en: '[PRE67]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在新的文件夹中`运行`以下代码片段：
- en: '[PRE68]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following screenshot shows the expected output:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了预期的输出：
- en: '[PRE69]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this exercise, we learned that you can use complex logic in the `case` expression
    when a simple `switch` statement match is not enough. This still offers a more
    compact and easier way to manage a logic statement than `if`, if you have more
    than a couple of cases.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们了解到，当简单的`switch`语句匹配不足时，你可以在`case`表达式中使用复杂的逻辑。如果你有超过几个`case`，这仍然比`if`提供了更紧凑、更易于管理逻辑语句的方法。
- en: Next, we'll leave logic structures behind and start to look at ways in which
    we can run the same statements multiple times to make processing data easier.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将放下逻辑结构，开始探讨我们可以多次运行相同语句的方法，以简化数据处理。
- en: Loops
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: In real-world applications, you're often going to need to run the same logic
    repeatedly. It's common to have to deal with multiple inputs and give multiple
    outputs. Loops are the simplest way of repeating your logic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用中，您通常会需要重复运行相同的逻辑。通常需要处理多个输入并给出多个输出。循环是重复您逻辑的最简单方式。
- en: 'Go only has one looping statement, `for`, but it''s a flexible one. There are
    two distinct forms: the first is used a lot for ordered collections such as arrays
    and slices, which we''ll cover more later. The sort of loop used for ordered collections
    looks as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Go 只有一个循环语句，即`for`，但它非常灵活。有两种不同的形式：第一种常用于有序集合，如数组和切片，我们将在后面详细讨论。用于有序集合的循环形式如下所示：
- en: '[PRE70]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `initial` statement is just like the one found in `if` and `switch` statements.
    `initial` statement runs before everything else and allows the same simple statements
    that we defined before. The condition is checked before each loop to see whether
    the statements should be run or whether the loop should stop. Like `initial` statement,
    `condition` also allows simple statements. The `post` statement is run after the
    statements are run at the end of each loop and allow you to run simple statements.
    The `post` statement is mostly used for incrementing things such as loop counters,
    which get evaluated on the next loop by `condition`. The statements are any Go
    code you want to run as part of the loop.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial`语句与`if`和`switch`语句中的语句类似。`initial`语句在执行其他任何操作之前运行，并允许执行之前定义的简单语句。在每次循环之前检查条件，以确定是否应该运行语句或是否应该停止循环。与`initial`语句类似，`condition`也允许简单语句。`post`语句在每次循环结束时运行，允许执行简单语句。`post`语句主要用于递增诸如循环计数器之类的项目，这些项目将在下一次循环的`condition`中评估。语句可以是您想要作为循环一部分运行的任何Go代码。'
- en: 'The `initial`, `condition`, and `post` statements are all optional, and it''s
    possible to write a `for` loop like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial`、`condition`和`post`语句都是可选的，可以编写如下形式的`for`循环：'
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This form would result in a loop that would run forever, also known as an infinite
    loop, unless the `break` statement is used to stop the loop manually. In addition
    to `break`, there is also a `continue` statement that can be used to skip the
    remainder of an individual run of a loop but doesn't stop the whole loop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式会导致一个无限循环，除非使用`break`语句手动停止循环。除了`break`之外，还有一个`continue`语句，可以用来跳过循环的单个运行的剩余部分，但不会停止整个循环。
- en: 'Another form the `for` loop can take is when reading from a source of data
    that returns a Boolean when there is more data to read. Examples of this include
    when reading from databases, files, command-line inputs, and network sockets.
    This form looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的另一种形式是在从返回布尔值以指示是否有更多数据可读的数据源中读取时。这种形式的例子包括从数据库、文件、命令行输入和网络套接字中读取。这种形式看起来是这样的：'
- en: '[PRE72]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This form is just a simplified version of the form used to read from an ordered
    list but without the logic needed to control the loop yourself, as the source
    you're using is built to work easily in `for` loops.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式只是从有序列表中读取时使用的形式的简化版本，但没有控制循环所需的逻辑，因为您使用的数据源已经构建得可以在`for`循环中轻松工作。
- en: 'The other form that the `for` loop takes is when looping over unordered data
    collections such as maps. We''ll cover what maps are in more detail in a later
    chapter. When looping over these, you''ll use the `range` statement in your loop.
    With maps, the form looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的另一种形式是在遍历无序数据集合时，例如映射。我们将在后面的章节中更详细地介绍映射。在遍历这些时，您将在循环中使用`range`语句。对于映射，形式如下所示：'
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Exercise 2.08: Using the for i Loop'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.08：使用`for i`循环
- en: 'In this exercise, we''ll use the three parts of the `for` loop to create a
    variable and use a variable in the loop. We''ll be able to see how the variable
    changes after each iteration of the loop by printing out its value to the console:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`for`循环的三个部分来创建一个变量并在循环中使用该变量。通过将变量的值打印到控制台，我们将能够看到每次迭代后变量的变化：
- en: 'Define `package` as `main` and add imports:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`package`定义为`main`并添加导入：
- en: '[PRE74]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create the `main` function:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main`函数：
- en: '[PRE75]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Define a `for` loop that defines the `i` variable with an initial value of
    `0` in the `initial` statement section. In the clause, check that `i` is less
    than `5`. In for the post statement, increment `i` by `1`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`for`循环，在`initial`语句部分将`i`变量定义为初始值为`0`。在子句中检查`i`是否小于`5`。在`post`语句中，将`i`增加`1`：
- en: '[PRE76]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In the body of the loop, print out the value of `i`:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环体中，打印出`i`的值：
- en: '[PRE77]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Close the loop:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭循环：
- en: '[PRE78]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Close `main`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main`：
- en: '[PRE79]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在新文件夹中`运行`以下代码片段：
- en: '[PRE80]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following is the expected output:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE81]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this exercise, we used a variable that only exists in the `for` loop. We
    set up the variable, checked its value, modified it, and output it. Using a loop
    like this is very common when working with ordered, numerically indexed collections
    such as arrays and slices. In this instance, we hardcoded the value for when to
    stop looping; however, when looking over arrays and slices, that value would be
    determined dynamically from the size of the collection.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了仅在`for`循环中存在的变量。我们设置了变量，检查了它的值，修改了它，并输出了它。使用这样的循环在处理有序、数值索引的集合（如数组和切片）时非常常见。在这种情况下，我们硬编码了停止循环的值；然而，当查看数组和切片时，该值将根据集合的大小动态确定。
- en: Next, we'll use a `for i` loop to work with a slice.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`for i`循环来处理切片。
- en: 'Exercise 2.09: Looping Over Arrays and Slices'
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.09：遍历数组和切片
- en: In this exercise, we'll loop over a collection of strings. We'll be using a
    slice, but the loop logic will also be the same set of arrays. We'll define the
    collection; we'll then create a loop that uses the collection to control when
    to stop looping and a variable to keep track of where we are in the collection.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将遍历一个字符串集合。我们将使用切片，但循环逻辑也将是相同的一组数组。我们将定义集合；然后创建一个循环，使用集合来控制何时停止循环，并使用一个变量来跟踪我们在集合中的位置。
- en: 'The way the index of arrays and slices works means that there are never any
    gaps in the number, and the first number is always 0\. The built-in function,
    `len`, is used to get the length of any collection. We''ll use it as part of the
    condition to check when we''ve reached the end of the collection:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和切片的索引工作方式意味着数字之间永远不会出现空隙，第一个数字始终是0。内置函数`len`用于获取任何集合的长度。我们将将其用作条件的一部分，以检查何时到达集合的末尾：
- en: Create a new folder and add a `main.go` file.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add `package` and `import`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加`package`和`import`：
- en: '[PRE82]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create the `main` function:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main`函数：
- en: '[PRE83]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Define a variable which is a slice of "strings" and initialize it with data:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个变量，它是一个“字符串”切片，并用数据初始化它：
- en: '[PRE84]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We will cover `collection` and `string` in more detail in the next chapter.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地介绍`collection`和`string`。
- en: 'The `initial` and `post` statements for the loop are the same as before; the
    difference is in the `condition`, where we use `len` to check whether we are at
    the end of the collection:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环的`initial`和`post`语句与之前相同；不同之处在于`condition`，我们使用`len`来检查我们是否到达了集合的末尾：
- en: '[PRE85]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The rest is the same as before:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余与之前相同：
- en: '[PRE86]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在新文件夹中`运行`以下代码片段：
- en: '[PRE87]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following is the expected output:'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE88]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The range Loop
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环范围
- en: The `array` and `slice` types always have the number of an index, and that number
    always starts at `0`. The `for i` loop we've seen so far is the most common choice
    you'll see in real-world code for these types.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`和`slice`类型始终有索引号，并且这个数字始终从`0`开始。我们之前看到的`for i`循环是您在现实世界的代码中看到的最常见的这些类型的选择。'
- en: The other collection type, `map`, doesn't give the same guarantee. That means
    you need to use `range`. You'll use `range` instead of the `condition` of a `for`
    loop, and, on each loop, `range` yields both a key and a value of an element in
    the collection, then, moves on to the next element.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种集合类型`map`不提供相同的保证。这意味着您需要使用`range`。您将使用`range`而不是`for`循环的条件，并且，在每次循环中，`range`都会提供一个集合中元素的键和值，然后移动到下一个元素。
- en: With a `range` loop, you don't need to define a condition to stop the loop as
    `range` takes care of that for us.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range`循环时，您不需要定义停止循环的条件，因为`range`会为我们处理这个问题。
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Callout map Order**: The order of items is randomized to stop developers
    relying on the order of the elements in a map, which means you can use it as a
    form of pseudo data randomization if needed.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用map顺序**：项目的顺序是随机的，以防止开发者依赖于map中元素的顺序，这意味着如果需要，你可以将其用作伪数据随机化的形式。'
- en: 'Exercise 2.10: Looping Over a Map'
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.10：遍历Map
- en: 'In this exercise, we''re going to create a `map` that has a string for its
    key and a string for the values. We''ll cover `map` types in more detail in a
    later chapter, so don''t worry if you don''t quite get what `map` types are yet.
    We''ll then use `range` in the `for` loop to iterate over the map. We''ll then
    write out the key and value data to the console:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个`map`，其键和值都是字符串。我们将在后面的章节中更详细地介绍`map`类型，所以如果你现在还不完全理解`map`类型，请不要担心。然后我们将使用`range`在`for`循环中遍历`map`。然后我们将键和值数据写入控制台：
- en: Create a new folder and add a `main.go` file.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the `package` and `import`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加`package`和`import`：
- en: '[PRE89]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create the `main` function:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main`函数：
- en: '[PRE90]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Define a `map` with a `string` key and a `string` value of strings variable
    and initialize it with the data:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有`string`键和字符串值`strings`变量的`map`，并用以下数据初始化它：
- en: '[PRE91]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Use `range` to get the `key` and `value` for an array element and assign them
    to variables:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`range`获取数组元素的`key`和`value`并将它们赋值给变量：
- en: '[PRE92]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Print out the `key` and `value` variables:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出`key`和`value`变量：
- en: '[PRE93]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Close the loop and `main`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭循环和`main`：
- en: '[PRE94]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，在新文件夹中`运行`以下代码片段：
- en: '[PRE95]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following is the expected output displaying a map that has a string for
    its key and a string for the values:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的预期输出显示了一个键和值都是字符串的`map`：
- en: '[PRE96]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In this exercise, we used `range` in a `for` loop to allow us to read out all
    the data from a `map` collection. Even though we used an integer for the `map`
    variable's key, `map` types don't give guarantees like arrays and slices do about
    starting at zero and having no gaps. `range` also controls when to stop the loop.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`range`在`for`循环中，以便能够从`map`集合中读取所有数据。尽管我们使用了整数作为`map`变量键，但`map`类型不像数组和切片那样提供关于从零开始和没有间隙的保证。`range`还控制何时停止循环。
- en: If you don't need the `key` or the `value` variable, you can use `_` as the
    variable name to tell the compiler you don't want it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要`key`或`value`变量，你可以使用`_`作为变量名来告诉编译器你不需要它。
- en: 'Activity 2.02: Looping Over Map Data Using range'
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.02：使用range遍历Map数据
- en: 'Suppose you have been provided with the data in the following table. You have
    to find the word with the maximum count and print the word and its count using
    the following data:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被提供了以下表中的数据。你必须找到具有最大计数的单词，并使用以下数据打印出单词及其计数：
- en: '![Figure 2.02: Word and count data to perform the activity'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.02：执行活动的单词和计数数据'
- en: '](img/B14177_02_02.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.02：执行活动的单词和计数数据](img/B14177_02_02.jpg)'
- en: 'Figure 2.02: Word and count data to perform the activity'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.02：执行活动的单词和计数数据
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding words are from the song *Never Gonna Give You Up*, sung by *Rick
    Astley*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的单词来自由*Rick Astley*演唱的歌曲*Never Gonna Give You Up*。
- en: 'The steps to solve the activity are as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个活动的步骤如下：
- en: 'Put the words into a map like this:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单词放入类似这样的`map`中：
- en: '[PRE97]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Create a loop and use `range` to capture the word and the count.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环并使用`range`来捕获单词和计数。
- en: Keep track of the word with the highest count using a variable for what the
    highest count is and its associated word.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一个变量来跟踪具有最高计数的单词以及与其关联的最高计数。
- en: Print the variables out.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出变量。
- en: 'The following is the expected output displaying the most popular word with
    its count value:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的预期输出显示了最受欢迎的单词及其计数值：
- en: '[PRE98]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 688.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第688页找到。
- en: Next, we'll look at how we can take manual control of the loop by skipping iterations
    or stopping the loop.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看我们如何通过跳过迭代或停止循环来手动控制循环。
- en: break and continue
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break`和`continue`'
- en: There are going to be times when you need to skip a single loop or stop the
    loop from running altogether. It's possible to do this with variables and `if`
    statements, but there is an easier way.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要跳过单个循环或完全停止循环的运行。可以使用变量和`if`语句来实现这一点，但有一个更简单的方法。
- en: The `continue` keyword stops the execution of the current loop and starts a
    new loop. The `post` loop logic runs, and the loop `condition` gets evaluated.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`关键字停止当前循环的执行并开始新的循环。`post`循环逻辑运行，循环`条件`被评估。'
- en: The `break` keyword also stops the execution of the current loop and it stops
    any new loops from running.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 关键字也停止当前循环的执行，并阻止任何新的循环运行。'
- en: Use `continue` when you want to skip a single item in a collection; for instance,
    perhaps it's okay if one of the items in a collection is invalid, but the rest
    may be okay to process. Use `break` when you need to stop processing when there
    are any errors in the data and there's no value in processing the rest of the
    collection.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想跳过集合中的一个项目时使用 `continue`；例如，如果集合中的一个项目无效，但其余项目可以处理，这可能没关系。当数据中存在错误且处理集合的其余部分没有价值时，使用
    `break` 停止处理。
- en: Here, we have an example that generates a random number between `0` and `8`.
    The loop skips on a number divisible by `3` and stops on a number divisible by
    `2`. It also prints out the `i` variable for each loop to help us see that `continue`
    and `break` are stopping the execution of the rest of the loop.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，它生成一个介于 `0` 和 `8` 之间的随机数。循环会跳过能被 `3` 整除的数字，并在能被 `2` 整除的数字上停止。它还会打印出每个循环的
    `i` 变量，以帮助我们看到 `continue` 和 `break` 是如何停止循环的其余部分执行的。
- en: 'Exercise 2.11: Using break and continue to Control Loops'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.11：使用 break 和 continue 控制循环
- en: 'In this exercise, we''ll use `continue` and `break` in a loop to show you how
    you can take control of it. We''re going to create a loop that keeps going forever.
    This means we have to stop it with `break` manually. We''ll also randomly skip
    loops with `continue`. We''ll do this skipping by generating a random number,
    and if that number is divisible by 3, we''ll skip the rest of the loop:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `continue` 和 `break` 在循环中，以展示你如何控制它。我们将创建一个永远继续的循环。这意味着我们必须手动使用
    `break` 来停止它。我们还将随机使用 `continue` 跳过循环。我们将通过生成一个随机数来实现这一点，如果这个数能被 `3` 整除，我们将跳过循环的其余部分：
- en: Create a new folder and add a `main.go` file.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'In `main.go`, add `package` and `import`:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加 `package` 和 `import`：
- en: '[PRE99]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Create the `main` function:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main` 函数：
- en: '[PRE100]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Create an empty `for` loop. This will loop forever if you don''t stop it:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 `for` 循环。如果你不停止它，它将永远循环：
- en: '[PRE101]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Use `Intn` from the `rand` package to pick a random number between 0 and 8:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `rand` 包中的 `Intn` 来选择一个介于 0 和 8 之间的随机数：
- en: '[PRE102]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'If the random number is divisible by 3, print `"Skip"` and skip the rest of
    the loop using `continue`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果随机数能被3整除，打印 `"Skip"` 并使用 `continue` 跳过循环的剩余部分：
- en: '[PRE103]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If the random number is divisible by 2, then print `"Stop"` and stop the loop
    using `break`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果随机数能被2整除，那么打印 `"Stop"` 并使用 `break` 停止循环：
- en: '[PRE104]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If the number is neither of those things, then print the number:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字既不是那些东西，那么打印该数字：
- en: '[PRE105]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Close the loop and `main`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭循环和 `main`：
- en: '[PRE106]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Save the file, and, in the new folder, `run` the following code snippet:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在新文件夹中 `运行` 以下代码片段：
- en: '[PRE107]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The following is the expected output displaying random numbers, `Skip`, and
    `Stop`:'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是将显示随机数、`Skip` 和 `Stop` 的预期输出：
- en: '[PRE108]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In this exercise, we created a `for` loop that would loop forever, and we then
    used `continue` and `break` to override normal loop behavior to take control of
    it ourselves. The ability to do this can allow us to reduce the number of nested
    `if` statements and variables needed to prevent logic from running when it shouldn't.
    Using `break` and `continue` help to clean up your code and make it easier to
    work on.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个将永远循环的 `for` 循环，然后我们使用 `continue` 和 `break` 来覆盖正常的循环行为，以我们自己控制它。这种能力可以让我们减少所需的嵌套
    `if` 语句和变量数量，以防止逻辑在不应该运行时运行。使用 `break` 和 `continue` 有助于清理代码并使其更容易工作。
- en: If you use an empty `for` loop like this, the loop continues forever, and you
    must use `break` to prevent an infinite loop. An infinite loop is a loop in your
    code that never stops. Once you get an infinite loop, you'll need a way to kill
    your application; how you do that will depend on your operating system. If you
    are running your app in a terminal, closing the terminal normally does the trick.
    Don't panic – it happens to us all – your system may slow down, but it won't do
    it any harm.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这样的空 `for` 循环，循环将永远继续，你必须使用 `break` 来防止无限循环。无限循环是代码中永远不会停止的循环。一旦你遇到无限循环，你需要一种方法来终止你的应用程序；你如何做将取决于你的操作系统。如果你在终端中运行你的应用程序，正常关闭终端就可以做到这一点。不要慌张——这发生在我们所有人身上——你的系统可能会变慢，但不会造成任何伤害。
- en: Next, we'll work on some activities to test out all your new knowledge about
    logic and loops.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进行一些活动来测试你对逻辑和循环的新知识。
- en: 'Activity 2.03: Bubble Sort'
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.03：冒泡排序
- en: In this activity, we'll sort a given slice of numbers by swapping the values.
    This technique of sorting is known as the `sort` package but I don't want you
    to use them; we want you to use the logic and loops you've just learned.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将通过交换值来对给定的数字切片进行排序。这种排序技术被称为`sort`包，但我不想让你使用它们；我们希望你能使用你刚刚学到的逻辑和循环。
- en: 'Steps:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤：
- en: Define a slice with unsorted numbers in it.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含未排序数字的切片。
- en: Print this slice to the console.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个切片打印到控制台。
- en: Sort the values using swapping.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用交换值来排序数值。
- en: Once done, print the now sorted numbers to the console.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将现在排序好的数字打印到控制台。
- en: 'Tips:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: 'You can do an in-place swap in Go using:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下方式在Go中进行原地交换：
- en: '[PRE109]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'You can create a new slice using:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下方式创建一个新的切片：
- en: '[PRE110]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You can add to the end of a slice using:'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下方式向切片末尾添加内容：
- en: '[PRE111]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The following is the expected output:'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期的输出：
- en: '[PRE112]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 690.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第690页找到。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed logic and loops. These are the foundational building
    blocks to build complex software. They allow you to have data flow through your
    code. They let you deal with collections of data by letting you execute the same
    logic on every element of the data.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了逻辑和循环。这些是构建复杂软件的基础构建块。它们允许数据通过你的代码流动。它们让你能够通过在数据的每个元素上执行相同的逻辑来处理数据集合。
- en: Being able to define the rules and laws of your code are the starting points
    of codifying the real world in software. If you are creating banking software
    and the bank has rules about what you can and can't do with money, then you can
    also define those rules in your code.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 能够定义你代码的规则和法律是你在软件中编码现实世界的起点。如果你正在创建银行软件，并且银行有关于你可以和不可以如何使用金钱的规则，那么你也可以在你的代码中定义这些规则。
- en: Logic and loops are the essential tools that you'll use to build all your software.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑和循环是你构建所有软件的基本工具。
- en: In the next chapter, we'll look at Go's type system and the core types it has
    available.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Go的类型系统和它所提供的核心类型。
