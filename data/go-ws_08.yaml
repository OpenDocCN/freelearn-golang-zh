- en: 8\. Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 包
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to demonstrate the importance of the use of packages in our
    Go programs. We will discuss how packages can be used to assist our code in being
    more maintainable, reusable, and modular. In this chapter, you will see how they
    can be used to bring structure and organization to our code. This will also be
    seen in our exercises, activities, and some examples from the Go standard library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在展示在Go程序中使用包的重要性。我们将讨论如何使用包来帮助我们的代码更易于维护、重用和模块化。在本章中，您将看到它们如何为我们的代码带来结构和组织。这将在我们的练习、活动和Go标准库的一些示例中体现出来。
- en: By the end of the chapter, you will be able to describe a package and its structure
    and declare a package. You will learn to evaluate exported and unexported names
    in a package, create your own package and import your custom package. You will
    also be able to distinguish between an executable package and non-executable packages,
    and create an alias of a package.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够描述一个包及其结构，并声明一个包。您将学习如何在一个包中评估导出和非导出名称，创建自己的包并导入自定义包。您还将能够区分可执行包和非可执行包，并创建一个包的别名。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at interfaces. We saw how we can use interfaces
    to describe the behavior of a type. We also discovered that we can pass different
    types to functions that accept an interface, as long as the type satisfies the
    interface's method sets. We also saw how we can achieve polymorphism using interfaces.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了接口。我们看到了如何使用接口来描述类型的行怍。我们还发现，只要类型满足接口的方法集，我们就可以将不同类型传递给接受接口的函数。我们还看到了如何使用接口实现多态。
- en: In this chapter, we will look at how Go organizes its code into packages. We
    will see how we can hide or expose different Go constructs such as structs, interfaces,
    functions, and more, using packages. Our programs have been rather small in the
    number lines of code and in complexity to a certain extent. Most of our programs
    have been contained in a single code file, often named `main.go`, and inside a
    single package named `main`. Later in this chapter, we will explore the significance
    of `package main`, so do not be worried at this juncture if you do not understand
    it. This will not always be the case when you are working on a development team.
    Often, your code base can become rather large, with multiple files, multiple libraries,
    and multiple members of the team. It would be rather restrictive if we could not
    break our code into smaller, manageable parts. The Go programming language solves
    the complexity of managing large codebases with the ability to modularize similar
    concepts into packages. The creators of Go use packages for their own standard
    libraries to tackle this problem. In this book, you have been working with many
    Go packages, such as `fmt`, `string`, `os`, `ioutil`, and so on.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Go如何将代码组织成包。我们将看到如何使用包来隐藏或暴露不同的Go结构，如结构体、接口、函数等。我们的程序在代码行数和复杂度上相对较小，大多数程序都包含在一个名为`main.go`的单个代码文件中，并在名为`main`的单个包内。在本章的后面部分，我们将探讨`package
    main`的重要性，所以如果您目前不理解它，请不要担心。在您作为开发团队成员工作时，情况并不总是如此。通常，您的代码库可以变得相当庞大，包含多个文件、多个库和多个团队成员。如果我们不能将代码分解成更小的、可管理的部分，这将相当受限。Go编程语言通过将类似的概念模块化到包中来解决管理大型代码库的复杂性。Go的创造者使用包来解决他们自己的标准库中的这个问题。在本书中，您已经使用了许多Go包，例如`fmt`、`string`、`os`、`ioutil`等。
- en: Let's look at an example of a package structure from the Go standard library.
    The Go `strings` package encapsulates string functions that manipulate strings.
    By keeping the `strings` package focused on only the functions that manipulate
    strings, we, as Go developers, know that this function should contain all that
    we need for string manipulation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Go标准库中的一个包结构的例子。Go的`strings`包封装了操作字符串的函数。通过使`strings`包只关注操作字符串的函数，我们作为Go开发者知道，这个函数应该包含我们进行字符串操作所需的所有内容。
- en: 'The Go package for strings is structured as follows ([https://packt.live/35jueEu](https://packt.live/35jueEu)):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go的字符串包结构如下（[https://packt.live/35jueEu](https://packt.live/35jueEu)）：
- en: '![Figure 8.1: The strings package along with the files contained within it'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：strings包及其包含的文件](img/B14177_08_01.jpg)'
- en: '](img/B14177_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_01.jpg)'
- en: 'Figure 8.1: The strings package along with the files contained within it'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：strings包及其包含的文件](img/B14177_08_01.jpg)
- en: The preceding diagram shows the `strings` package and the files that are in
    the package. Each file in the `strings` package is named after the functionality
    it is supporting. The logical organization of the code goes from package to file.
    We can easily conclude that the `strings` package contains code for manipulating
    strings. We can then further conclude that the `replace.go` file contains functions
    for replacing strings. You can already see that the conceptual structure of packages
    can organize your code into modular chunks. You start with code that is working
    together to serve a purpose, string manipulation, and it gets stored in a package
    called `string`. You can then further organize the code into `.go` files and name
    them according to their purpose. The next step is keeping functions in there that
    perform a single purpose that reflects the name of the file and the name of the
    package. We will discuss these conceptual ideas later in the chapter when we discuss
    structuring code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了`strings`包及其中的文件。`strings`包中的每个文件都是以它所支持的功能命名的。代码的逻辑组织从包到文件。我们可以很容易地得出结论，`strings`包包含用于操作字符串的代码。然后我们可以进一步得出结论，`replace.go`文件包含用于替换字符串的函数。您已经可以看到，包的概念结构可以将您的代码组织成模块化的块。您从一起工作以实现某个目的的代码开始，即字符串操作，并将其存储在名为`string`的包中。然后您可以将代码进一步组织到`.go`文件中，并根据其目的命名它们。下一步是将执行单一目的的函数放入其中，该目的反映了文件名和包名。我们将在本章讨论结构化代码时进一步讨论这些概念思想。
- en: It is important to develop software that is maintainable, reusable, and modular.
    Let's briefly discuss each of these core components of software development.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 开发可维护、可重用和模块化的软件非常重要。让我们简要讨论软件开发的核心组件中的每个这些。
- en: Maintainable
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可维护性
- en: For code to be maintainable, it must be easy to change, and any changes must
    have a low risk of having an adverse impact on the program. Maintainable code
    is easy to modify and extend and is readable. As code progresses through the different
    stages of the software development life cycle, the cost of changes to the code
    increases. These changes can be due to bugs, enhancements, or a change in requirements.
    Costs also increase when code is not easily maintainable. Another reason that
    code needs to be maintainable is the need to be competitive in the industry. If
    your code is not easily maintainable, it may be hard to react to a competitor
    who is releasing a software feature that could be used to outsell your application.
    These are just some of the reasons for code needing to be maintainable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码可维护，它必须易于更改，并且任何更改都必须具有低风险，不会对程序产生不利影响。可维护的代码易于修改和扩展，并且易于阅读。随着代码在软件开发生命周期的不同阶段中进展，对代码的更改成本会增加。这些更改可能是由错误、增强或需求变更引起的。当代码不易维护时，成本也会增加。代码需要可维护的另一个原因是需要在行业中保持竞争力。如果你的代码不易维护，可能很难对竞争对手做出反应，竞争对手正在发布一个软件功能，该功能可能被用来超出你的应用程序销售。这只是代码需要可维护的一些原因。
- en: Reusable
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重用性
- en: Reusable code is code that can be used in new software. For example, I have
    code in my existing application that has a function that returns an address for
    my mailing application; that function may be used in a new piece of software.
    That function that returns the address could be used in my new software that returns
    a customer address for an order the customer has placed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用代码是指可以在新软件中使用的代码。例如，我在现有的应用程序中有一段代码，该代码有一个函数可以返回我的邮件应用程序的地址；这个函数可能被用于新的软件中。这个返回地址的函数可以用于我新的软件中，该软件可以返回客户已下单的订单的地址。
- en: 'The advantages of having reusable code are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有可重用代码的优势如下：
- en: It decreases future project costs by using existing packages.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用现有包来降低未来项目的成本。
- en: It decreases the time it takes to deliver an application, due to not having
    to reinvent the wheel.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于无需重新发明轮子，它减少了交付应用程序所需的时间。
- en: The quality of the program will increase through increased testing and more
    usage.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加测试和更多使用，程序的质量将得到提高。
- en: More time can be spent on other areas of innovation during the development cycle.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发周期中可以花更多的时间在其他创新领域。
- en: As your packages grow, it becomes easier to lay the foundations for future projects
    in a timely manner.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着您的包增长，及时为未来项目打下基础变得更加容易。
- en: Modular
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化
- en: Modular and reusable code is related to a certain extent, in the sense that
    having modular code makes it more likely that it will be reusable. One of the
    prominent problems when developing code is the organization of the code. Finding
    the code that performs a certain function in a large program that is unorganized
    would be near to impossible, and even finding out whether there is code that performs
    a certain task would be difficult to ascertain without some code organization.
    Modularization aids in that area. The idea is that each discrete task that your
    code performs has its own section of code located in a specific spot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化和可重用代码在一定程度上是相关的，从某种意义上说，拥有模块化代码使得它更有可能被重用。在开发代码时，代码的组织是一个突出的问题。在一个未组织的大型程序中找到执行特定功能的代码几乎是不可能的，甚至在不知道是否有执行特定任务的代码的情况下，确定这一点也是困难的，除非有一些代码组织。模块化有助于这个领域。想法是，你的代码执行的每个离散任务都有其自己的代码部分，位于特定的位置。
- en: 'Go encourages you to develop maintainable, reusable, and modular code by using
    packages. It was designed to encourage good software practices. We will be diving
    into how Go utilizes packages to accomplish those tasks:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言鼓励你通过使用包来开发可维护、可重用和模块化的代码。它旨在鼓励良好的软件开发实践。我们将深入了解Go如何利用包来完成这些任务：
- en: '![Figure 8.2: The types of code packages can provide'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：代码包可以提供的数据类型'
- en: '](img/B14177_08_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_02.jpg)'
- en: 'Figure 8.2: The types of code packages can provide'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：代码包可以提供的数据类型
- en: In the next topic, we are going to discuss what a package is and what the components
    that make up a package are.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将讨论什么是包以及构成包的组件。
- en: What Is a Package?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是包？
- en: 'Go follows the **Don''t Repeat Yourself** (**DRY**) principle. This means that
    you should not write the same code twice. Refactoring your code into functions
    is the first step of the DRY principle. What if you had hundreds or even thousands
    of functions that you used regularly? How would you keep track of all those functions?
    Some of those functions might even have common characteristics. You could have
    a group of functions that perform math operations, string manipulations, printing,
    or file-based operations. You may be thinking of breaking them up into individual
    files:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言遵循**不要重复自己**（**DRY**）原则。这意味着你不应该重复编写相同的代码。将你的代码重构为函数是DRY原则的第一步。假设你拥有数百甚至数千个你经常使用的函数，你将如何跟踪所有这些函数呢？其中一些函数可能具有共同的特征。你可能有一组执行数学运算、字符串操作、打印或基于文件的操作的函数。你可能正在考虑将它们拆分成单独的文件：
- en: '![Figure 8.3: Group functions by files'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：按文件分组函数'
- en: '](img/B14177_08_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_03.jpg)'
- en: 'Figure 8.3: Group functions by files'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：按文件分组函数
- en: 'That could alleviate some of the issues. However, what if your string''s functionality
    started to grow further? You would then have a ton of string functions in one
    file or even multiple files. Every program you build would also have to include
    all of the code for `string`, `math`, and `io`. You would be copying code to every
    application that you built. Bugs in one code base would have to be fixed in multiple
    programs. That kind of code structure is not maintainable, nor does it encourage
    code reusability. The packages in Go are the next step to organizing your code
    in a way that makes it easy to reuse the components of your code. The following
    diagram shows the progression of organizing code from functions to source files
    to packages:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有助于缓解一些问题。然而，如果你的字符串功能开始进一步增长呢？那么你将在一个文件或多个文件中拥有大量的字符串函数。你构建的每个程序也将不得不包含`string`、`math`和`io`的所有代码。你将不得不将代码复制到你所构建的每个应用程序中。一个代码库中的错误将需要在多个程序中修复。这种代码结构既不可维护，也不鼓励代码重用。Go
    语言中的包是组织你的代码的下一步，以便于重用代码的组件。以下图表显示了从函数到源文件再到包的代码组织进展：
- en: '![Figure 8.4: Code progression organization'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：代码进度组织'
- en: '](img/B14177_08_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_04.jpg)'
- en: 'Figure 8.4: Code progression organization'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：代码进度组织
- en: Go organizes its code for reusability into directories called packages. A package
    is essentially a directory inside your workspace that contains one or more Go
    source files, which is used for grouping code that performs a task. It exposes
    only the necessary parts in order for those using your package to get a job done.
    The package concept is akin to using directories to organize files on a computer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go将代码组织到称为包的目录中以实现可重用性。包本质上是你工作区内的一个目录，包含一个或多个Go源文件，用于对执行任务的代码进行分组。它仅暴露必要的部分，以便使用你的包的人能够完成任务。包的概念类似于在计算机上使用目录来组织文件。
- en: Package Structure
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包结构
- en: 'It does not matter to Go how many different files are in a package. You should
    separate code into as many files as makes sense for readability and logic grouping.
    However, all the files that are in a package must live in the same directory.
    The source files should contain code that is related, meaning that if the package
    is for configuration parsing, you should not have code in there for connecting
    to a database. The basic structure of a package consists of a directory and contains
    one or more Go files and related code. The following diagram summarizes the core
    components of a package structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go来说，一个包中有多少不同的文件并不重要。你应该根据可读性和逻辑分组将代码分成尽可能多的文件。然而，包中的所有文件必须位于同一目录下。源文件应包含相关的代码，这意味着如果包是用于配置解析，那么其中不应该包含连接到数据库的代码。包的基本结构由一个目录组成，包含一个或多个Go文件和相关代码。以下图表总结了包结构的核心组件：
- en: '![Figure 8.5: Package structure'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：包结构'
- en: '](img/B14177_08_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_05.jpg)'
- en: 'Figure 8.5: Package structure'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：包结构
- en: 'One of the commonly used packages in Go is the `strings` package. It contains
    several Go files that are referred to in the Go documentation as package files.
    Package files are `.go` source files that are part of the package, for example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中常用包之一是`strings`包。它包含几个Go文件，在Go文档中被称为包文件。包文件是包的一部分的`.go`源文件，例如：
- en: '`builder.go`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder.go`'
- en: '`compare.go`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare.go`'
- en: '`reader.go`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reader.go`'
- en: '`replace.go`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace.go`'
- en: '`search.go`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search.go`'
- en: '`strings.go`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings.go`'
- en: Package Naming
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包命名
- en: 'Before we discuss how to declare a package, we need to discuss proper Go naming
    conventions for a package. The name of your package is significant. It represents
    what your package contains and identifies its purpose. You can think of a package
    name as self-documentation. Careful consideration needs to go into naming a package.
    The name of the package should be short and concise. It should not be verbose.
    Simple nouns are often chosen for a package name. The following would be poor
    names for a package:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何声明一个包之前，我们需要讨论合适的Go包命名约定。包名对你的包非常重要。它代表了包的内容，并确定了其目的。你可以将包名视为自文档。在命名包时需要仔细考虑。包名应该简短且简洁。它不应该冗长。通常选择简单名词作为包名。以下是一些不适合作为包名的例子：
- en: '`stringconversion`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringconversion`'
- en: '`synchronizationprimitives`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronizationprimitives`'
- en: '`measuringtime`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`measuringtime`'
- en: 'Better alternatives would be the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择可能是以下这些：
- en: '`strconv`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strconv`'
- en: '`sync`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync`'
- en: '`time`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time`'
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`strconv`, `sync`, and `time` are actual Go packages found in the standard
    library.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`strconv`、`sync`和`time`是标准库中实际存在的Go包。'
- en: 'Also, the styling of a package is something to take into consideration. The
    following would be poor style choices for a Go package name:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，包的样式也是需要考虑的因素。以下是一些不适合Go包命名的样式选择：
- en: '`StringConversion`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringConversion`'
- en: '`synchronization_primitives`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronization_primitives`'
- en: '`measuringTime`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`measuringTime`'
- en: In Go, package names should be all lowercase with no underscores. Don't use
    camel case or snake case styling. There are multiple packages with pluralized
    names.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，包名应该全部小写，不使用下划线。不要使用驼峰式或蛇形式命名风格。存在多个复数命名的包。
- en: 'Abbreviations are encouraged, just as long as they are familiar or common in
    the programming community. The user of the package should easily understand what
    the package is used for just from its name, for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励使用缩写，只要它们在编程社区中熟悉或常见。包的使用者应该能够仅从其名称中轻易理解包的用途，例如：
- en: '`strconv` (string conversion)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strconv` (字符串转换)'
- en: '`regexp` (regular expression search)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` (正则表达式搜索)'
- en: '`sync` (synchronization)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync` (同步)'
- en: '`os` (operating system)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os` (操作系统)'
- en: 'Avoid package names such as `misc`, `util`, `common`, or `data`. These package
    names make it harder for the user of your package to understand its purpose. In
    some cases, there is a deviation from these guidelines, but for the most part,
    it is something we should strive for:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`misc`、`util`、`common`或`data`等包名。这些包名使得用户难以理解你的包的目的。在某些情况下，可能会有一些偏离这些指南的情况，但大部分情况下，这是我们应努力追求的：
- en: '![Figure 8.6: Package naming conventions'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6：包命名约定'
- en: '](img/B14177_08_06.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_06.jpg)'
- en: 'Figure 8.6: Package naming conventions'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：包命名约定
- en: Package Declarations
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包声明
- en: 'Every Go file starts with a package declaration. The package declaration is
    the name of the package. The first line of executable code must be the package
    declaration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Go文件都以包声明开始。包声明是包的名称。可执行代码的第一行必须是包声明：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Recall that the `strings` package from the standard library has the following
    Go source files:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，标准库中的`strings`包包含以下Go源文件：
- en: 'Each one of those files starts with the package declaration, even though they
    are all separate files. We will look at an example from the Go standard library.
    In the Go standard library, there is a package called `strings` ([https://packt.live/35jueEu](https://packt.live/35jueEu)).
    It is made up of multiple files. We will only be looking at a snippet of code
    from the files in the package: `builder.go`, `compare.go`, and `replace.go`. We
    have removed comments and some code just to demonstrate that the package files
    start with the package name. There will be no output from the code snippet. This
    is an example of how Go organizes code into multiple files but in the same package:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件中的每一个都是以包声明开始的，尽管它们都是独立的文件。我们将从Go标准库中查看一个示例。在Go标准库中，有一个名为`strings`的包([https://packt.live/35jueEu](https://packt.live/35jueEu))。它由多个文件组成。我们只将查看包中的代码片段：`builder.go`、`compare.go`和`replace.go`。我们已删除注释和一些代码，仅为了展示包文件是以包名开始的。代码片段将不会有输出。这是一个Go如何将代码组织到多个文件但仍在同一包中的示例：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the functions, types, and variables that are defined in the Go source file
    are accessible within that package. Though your package could spread across multiple
    files, it is all part of the same package. Internally, all code is accessible
    across the files. Simply stated, code is visible within the package. Notice that
    not all of the code is visible outside of the package. The preceding snippet is
    from the official Go libraries. For a further explanation of the code, visit the
    links in the preceding Go snippets.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go源文件中定义的所有函数、类型和变量都可以在该包内访问。尽管你的包可能分布在多个文件中，但它仍然是同一个包的一部分。内部，所有代码都可以跨文件访问。简单来说，代码在包内是可见的。请注意，并非所有代码在包外都是可见的。前面的代码片段来自官方Go库。要进一步了解代码，请访问前面的Go代码片段中的链接。
- en: Exported and Unexported Code
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和非导出代码
- en: Go has a very simple way to determine whether code is exported or unexported.
    Exported means that variables, types, functions, and so on are visible from outside
    of the package. Unexported means it is only visible from inside the package. If
    a function, type, variable, and so on starts with an uppercase letter, it is exportable;
    if it starts with a lowercase letter, it is unexportable. There are no access
    modifiers to be concerned with in `Go`. If the function name is capitalized, then
    it is exported, and if it is lowercase, then it is unexported.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个非常简单的方式来确定代码是导出还是非导出。导出意味着变量、类型、函数等在包外是可见的。非导出意味着它只对包内可见。如果一个函数、类型、变量等以大写字母开头，它是可导出的；如果以小写字母开头，它是不可导出的。在`Go`中不需要担心访问修饰符。如果函数名称是首字母大写的，那么它是导出的，如果是小写，则是非导出的。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice to only expose code that we want other packages to see.
    We should hide everything else that is not needed by external packages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 只暴露我们希望其他包看到的代码是一种良好的实践。我们应该隐藏所有其他外部包不需要的内容。
- en: 'Let''s look at the following code snippet:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code snippet uses the `strings` package. We are calling a `strings` function
    called `Contains`. The `stings.Contains` function searchs the `str` variable to
    see whether it has the value "`found`" within in it. If "found" is within the
    `str` variable, the `strings.Constains` will return `true`; if "`found`" is not
    within the `str` variable, the `strings.Contains` function will return `false`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段使用了`strings`包。我们正在调用一个名为`Contains`的`strings`函数。`strings.Contains`函数搜索`str`变量，看它是否包含值"`found`"。如果`found`在`str`变量中，`strings.Contains`将返回`true`；如果"`found`"不在`str`变量中，`strings.Contains`函数将返回`false`：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To call the function, we prefix it with the package name, then the function
    name.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用该函数，我们需要在它前面加上包名，然后是函数名。
- en: This function is exportable, thus is accessible to others outside of the `strings`
    package. We know it is an exported function because the first letter of the function
    is capitalized.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是可导出的，因此对`strings`包外的其他人也是可访问的。我们知道它是一个导出函数，因为函数的第一个字母是大写的。
- en: When you import a package, you only have access to the exported names.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个包时，你只能访问导出的名称。
- en: 'We can validate whether the function exists in the `strings` package by looking
    at the `strings.go` file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看`strings.go`文件来验证函数是否存在于`strings`包中：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next code snippet will attempt to access an unexported function in the
    `strings` package:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段将尝试访问`strings`包中的未导出函数：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function is unexported because it starts with a lowercase letter. Only code
    within the package can access the function; it is not visible outside of the package.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是未导出的，因为它以小写字母开头。只有包内的代码可以访问该函数；它对包外不可见。
- en: 'The code is attempting to call an unexported function in the `strings.go` package
    file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尝试调用`strings.go`包文件中的未导出函数：
- en: '![Figure 8.7: Program output'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：程序输出'
- en: '](img/B14177_08_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_08_07.jpg)'
- en: 'Figure 8.7: Program output'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：程序输出
- en: 'The following code snippet is from the Go standard library `strings` package
    and from the `strings.go` file inside of that package ([https://packt.live/2RMxXqh](https://packt.live/2RMxXqh)).
    You can see that the `explode` function is unexportable because the function name
    starts with a lowercase letter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自Go标准库`strings`包以及该包内的`strings.go`文件（[https://packt.live/2RMxXqh](https://packt.live/2RMxXqh)）。你可以看到`explode`函数是不可导出的，因为函数名以小写字母开头：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: GOROOT and GOPATH
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GOROOT和GOPATH
- en: We have looked at what a package is and its purpose. We have a basic understanding
    that multiple files can be part of a package construct. We have discussed the
    idiomatic Go way of naming packages. We have seen all these fundamental concepts
    being utilized in the Go standard library. We have one more concept to go over
    before we begin creating our own packages. It is important to understand how the
    Go compiler looks for the locations of the packages that are used in our applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了包是什么以及它的用途。我们有一个基本理解，多个文件可以是一个包结构的一部分。我们已经讨论了Go语言中命名包的惯用方法。我们已经看到所有这些基本概念在Go标准库中的应用。在我们开始创建自己的包之前，还有一个概念需要了解。理解Go编译器如何查找我们应用程序中使用的包的位置是很重要的。
- en: The Go compiler needs a way to know how to find our source files (packages)
    so that the compiler can build and install them. The compiler utilizes two environmental
    variables for this job. `$GOROOT` and `$GOPATH` tell the Go compiler where to
    search for the locations of the Go packages listed by the `import` statement.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Go编译器需要一种方法来知道如何找到我们的源文件（包），以便编译器可以构建和安装它们。编译器利用两个环境变量来完成这项工作。`$GOROOT`和`$GOPATH`告诉Go编译器在哪里搜索由`import`语句列出的Go包的位置。
- en: '`$GOROOT` is used to tell the Go compiler the location of the Go standard library
    packages. `$GOROOT` is specific to the Go standard library. It is what Go uses
    to determine where its standard library packages and tools are located.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GOROOT`用于告诉Go编译器Go标准库包的位置。`$GOROOT`是针对Go标准库的。这是Go用来确定其标准库包和工具位置的方法。'
- en: '`$GOPATH` is the location for packages we create and third-party packages that
    we may have imported. At the command line, type the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GOPATH`是我们创建的包以及我们可能导入的第三方包的位置。在命令行中，输入以下代码：'
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `$GOPATH` file structure, there are three directories: `bin`, `pkg`,
    and `src`. The `bin` directory is the easiest to understand. This is where Go
    places the binaries or executables when you run the `go install` command. One
    of the main uses of the `pkg` directory is used by the compiler to store object
    files for the packages the Go compiler builds. This is to help with speeding up
    the compiling of programs. The `src` directory is the one we are most interested
    in understanding as it is the directory where we place our packages. This is the
    directory where we place files with the `.go` extension.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$GOPATH` 文件结构内部，有三个目录：`bin`、`pkg` 和 `src`。`bin` 目录是最容易理解的。这是 Go 在运行 `go install`
    命令时放置二进制文件或可执行文件的地方。`pkg` 目录的主要用途是编译器用来存储 Go 编译器构建的包的对象文件，这是为了帮助加快程序的编译速度。`src`
    目录是我们最感兴趣的，因为我们把我们的包放在这个目录中。这是放置具有 `.go` 扩展名的文件的目录。
- en: 'For example, if we have a package located at `$GOPATH/src/person/address/`
    and we want to use the address packages, we would need the following `import`
    statement:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个位于 `$GOPATH/src/person/address/` 的包，并且我们想使用地址包，我们需要以下 `import` 语句：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another example would be if we have a package at `$GOPATH/src/company/employee`.
    If we were interested in using the `employee` package, the `import` statement
    would be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，如果我们有一个位于 `$GOPATH/src/company/employee` 的包。如果我们对使用 `employee` 包感兴趣，则
    `import` 语句如下：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Packages that are located in a source code repository would follow a similar
    pattern. If we wanted to import source code from [https://packt.live/2EKp357](https://packt.live/2EKp357),
    the location in the filesystem would be `$GOPATH/src/github.com/PacktWorkshops/The-Go-Workshop/Chapter08/Exercise8.01`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 位于源代码仓库中的包将遵循类似的模式。如果我们想从 [https://packt.live/2EKp357](https://packt.live/2EKp357)
    导入源代码，则在文件系统中的位置将是 `$GOPATH/src/github.com/PacktWorkshops/The-Go-Workshop/Chapter08/Exercise8.01`。
- en: 'The import would be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 导入方式如下：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is a diagram showing the differences between `$GOROOT` and `$GOPATH`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 `$GOROOT` 和 `$GOPATH` 之间的差异：
- en: '![Figure 8.8: GOROOT and GOPATH comparisons'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8：GOROOT 和 GOPATH 比较'
- en: '](img/B14177_08_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_08.jpg)'
- en: 'Figure 8.8: GOROOT and GOPATH comparisons'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：GOROOT 和 GOPATH 比较
- en: 'We are going to create a simple package called `msg`. The location of this
    file is within `$GOPATH` `$GOPATH/msg/msg.go`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将创建一个名为 `msg` 的简单包。此文件的位于 `$GOPATH` `$GOPATH/msg/msg.go`:'
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The package is named `msg`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 包的名称是 `msg`。
- en: It has one exported function. The function takes a string and prints `"Greeting"`
    to the argument passed to the function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个导出的函数。该函数接收一个字符串并将 `"Greeting"` 打印到传递给函数的参数上。
- en: To be able to use Go packages and our custom packages, we must import them.
    The `import` declaration contains the path location and the name of the package.
    The name of the package is the last directory that contains the package files.
    For example, if we have a directory structure in the `$GOPATH` location, `packt/chpkg/test/mpeg`,
    the package name would be `mpeg`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Go 包和我们的自定义包，我们必须导入它们。`import` 声明包含路径位置和包的名称。包的名称是包含包文件的最后一个目录。例如，如果我们有位于
    `$GOPATH` 位置的目录结构，`packt/chpkg/test/mpeg`，则包名将是 `mpeg`。
- en: 'The following code snippet is the `main` package file. It is in the following
    directory structure inside `$GOPATH`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段是 `main` 包文件。它位于 `$GOPATH` 内的以下目录结构中：
- en: '`$GOPATH/demoimport/demoimport.go`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`$GOPATH/demoimport/demoimport.go`:'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This basic program imports the `msg` package. Since we have imported the `msg`
    package, we can then call any exportable function in the package by preferencing
    it with `"msg.<functionName>"`. We know that our `msg` package has an exportable
    function called `Greeting`. We call the exportable `Greeting` function from our
    `msg` package and get the output in the preceding figure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本程序导入了 `msg` 包。由于我们已经导入了 `msg` 包，因此我们可以通过使用 `"msg.<functionName>"` 优先级来调用包中的任何可导出函数。我们知道我们的
    `msg` 包有一个名为 `Greeting` 的可导出函数。我们从 `msg` 包中调用可导出的 `Greeting` 函数，并在前面的图中获得输出。
- en: 'When creating a package, it can contain multiple files within the same directory.
    We need to make sure that each of those files in that directory belongs to the
    same package. If you have a `shape` package and, in that directory, you have two
    files, but each has a different package declaration, the Go compiler will return
    an error:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个包时，它可以在同一目录下包含多个文件。我们需要确保该目录中的每个文件都属于同一个包。如果你有一个名为 `shape` 的包，在该目录下你有两个文件，但每个文件都有不同的包声明，Go
    编译器将返回一个错误：
- en: '`shape.go`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape.go`'
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`junk.go`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`junk.go`'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you attempted to perform a build, you would get the following error:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试进行构建，你会得到以下错误：
- en: '![Figure 8.9: Program output'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.9：程序输出'
- en: '](img/B14177_08_09.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_08_09.jpg)'
- en: 'Figure 8.9: Program output'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：程序输出
- en: Package Alias
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包别名
- en: 'Go also has the ability to alias package names. There a few reasons that you
    may want to use alias names:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Go 也有能力别名包名。你可能想使用别名名的原因有几个：
- en: The package name may not make it easy to understand its purpose. For the purpose
    of clarity, it might be better to alias a different name for the package.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名可能不容易让人理解其目的。为了清晰起见，可能最好为包别名为不同的名称。
- en: The package name might be too long. In this case, you want the alias to be more
    concise and less verbose.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名可能太长。在这种情况下，你希望别名更加简洁，不那么冗长。
- en: There could be scenarios where the package path is unique but both package names
    are the same. You would need to then use aliasing to differentiate between the
    two packages.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在包路径唯一但包名相同的情况。这时，你需要使用别名来区分这两个包。
- en: 'The package aliasing syntax is very simple. You place the alias name before
    the `import` package path:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 包别名的语法非常简单。你将别名名放在 `import` 包路径之前：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a simple example showing how to use package aliasing:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单示例，展示了如何使用包别名：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are aliasing the `fmt` package as `f`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将 `fmt` 包别名为 `f`：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `main()` function, we are now able to call the `Println()` function using
    the `f` alias.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们现在能够使用 `f` 别名调用 `Println()` 函数。
- en: Main Package
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主包
- en: 'The main package is a special package. There are two basic types of packages
    in Go: executable and non-executable. The main package is an executable package
    in Go. The main package requires there to be a `main()` function in its package.
    The `main()` function is the entry point for a Go executable. When you perform
    `go build` on the main package, it will compile the package and create a binary.
    The binary is created inside of the directory where the main package is located.
    The name of the binary will be the name of the folder it resides in:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 主包是一个特殊的包。Go 中有两种基本的包类型：可执行包和非可执行包。主包是 Go 中的可执行包。主包需要在其包中有一个 `main()` 函数。`main()`
    函数是 Go 可执行程序的入口点。当你对主包执行 `go build` 时，它将编译包并创建一个二进制文件。二进制文件将创建在主包所在的目录中。二进制文件的名字将是它所在的文件夹名：
- en: '![Figure 8.10: Main package functionality'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.10：主包功能'
- en: '](img/B14177_08_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_08_10.jpg)'
- en: 'Figure 8.10: Main package functionality'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10：主包功能
- en: 'Here''s a simple example of the main package code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个主包代码的简单示例：
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The expected output is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Exercise 8.01: Creating a Package to Calculate Areas of Various Shapes'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.01：创建一个包来计算各种形状的面积
- en: In *Chapter 7*, *Interfaces*, we implemented code to calculate areas of different
    shapes. In this exercise, we will move all the code about shapes into a package
    called `shape`. We will then update the code in the package shape to be exportable.
    Then, we will update `main` to import our new `shape` package. However, we want
    it to still perform the same functionality in the `main()` function of the main
    package.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 7 章*，*接口* 中，我们实现了计算不同形状面积的代码。在这个练习中，我们将所有关于形状的代码移动到一个名为 `shape` 的包中。然后，我们将更新
    `shape` 包中的代码以使其可导出。然后，我们将更新 `main` 以导入我们新的 `shape` 包。然而，我们希望它在主包的 `main()` 函数中仍然执行相同的功能。
- en: 'Here is the code that we will be converting into packages:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要转换为包的代码：
- en: '[https://packt.live/36zt6gv](https://packt.live/36zt6gv).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/36zt6gv](https://packt.live/36zt6gv).'
- en: 'You should have a directory structure within your `$GOPATH` and files in those
    appropriate directories, as displayed in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 `$GOPATH` 内有一个目录结构，并在相应的目录中有文件，如下面的截图所示：
- en: '![Figure 8.11: Program directory structure'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11：程序目录结构'
- en: '](img/B14177_08_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_08_11.jpg)'
- en: 'Figure 8.11: Program directory structure'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11：程序目录结构
- en: 'The `shape.go` file should contain the entire code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`shape.go`文件应包含整个代码：'
- en: '[https://packt.live/2PFsWNx](https://packt.live/2PFsWNx).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/2PFsWNx](https://packt.live/2PFsWNx)。'
- en: 'We will only be going over the changes that are relevant to making this code
    a package, and for details on the parts of the code that we have gone over in
    a previous chapter, please see *Chapter 7*, *Interfaces*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只介绍与将此代码作为包进行构建相关的更改，有关我们已在上一章中介绍过的代码部分的详细信息，请参阅*第7章*，*接口*：
- en: Create a directory called `Exercise8.01` inside `Chapter08`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter08`目录下创建一个名为`Exercise8.01`的目录。
- en: Create two more directories called `area` and `shape` inside the `Exercise8.01`
    directory.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise8.01`目录下再创建两个名为`area`和`shape`的目录。
- en: Create a file called `main.go` inside the `Exercise8.01/area` directory.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise8.01/area`目录下创建一个名为`main.go`的文件。
- en: Create a file called `shape.go` inside the `Exercise8.01/shape` directory.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exercise8.01/shape`目录下创建一个名为`shape.go`的文件。
- en: Open the `Exercise8.01/shape.go` file.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Exercise8.01/shape.go`文件。
- en: 'Add the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE21]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first line of code in this file tells us this is a non-executable package
    called `shape`. A non-executable package, when compiled, does not result in binary
    or executable code. Recall that a `main` package is a package that is executable.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件的第一行代码告诉我们这是一个名为`shape`的非可执行包。非可执行包在编译时不会产生二进制或可执行代码。回想一下，`main`包是一个可执行的包。
- en: 'Next, we need to make the types exportable. For each `struct` type, we have
    to capitalize on the type name and its fields to make it exportable. Exportable
    means that it is visible outside of this package:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要使类型可导出。对于每个`struct`类型，我们必须利用类型名及其字段来使其可导出。可导出意味着它可以在包外部可见：
- en: '[PRE22]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also have to make the methods non-exportable, by changing the method name
    to lowercase. There is no need at the moment to make those methods visible outside
    of the package:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须通过将方法名改为小写来使方法不可导出。目前没有必要使那些方法在包外部可见：
- en: '[PRE23]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `PrintShapeDetails` function also needs to be capitalized:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PrintShapeDetails`函数也需要大写首字母：'
- en: '[PRE24]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Perform a build to ensure that there are no compile errors:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行构建以确保没有编译错误：
- en: '[PRE25]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is the listing for the `main.go` file. By having a package as `main`,
    we know that this is executable:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是`main.go`文件的列表。通过将包作为`main`，我们知道这是一个可执行的：
- en: '[PRE26]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `import` declaration only has one import. It is the `shape` package. The
    path location is `$GOPATH` plus the `import` path declaration. We can see the
    name of the package is `shape` since it is the last directory name in the path
    declaration. The `$GOPATH` mentioned here may differ from yours:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`import`声明只有一个导入。它是`shape`包。路径位置是`$GOPATH`加上`import`路径声明。我们可以看到包名为`shape`，因为它是路径声明中的最后一个目录名。这里提到的`$GOPATH`可能与你的不同：'
- en: '[PRE27]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `main()` function, we are initializing the `shape` package''s exportable
    types:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们正在初始化`shape`包的可导出类型：
- en: '[PRE28]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then call the `shape()` function, `PrintShapeDetails`, to get the area of
    each shape:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`shape()`函数，`PrintShapeDetails`，以获取每个形状的面积：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At the command line, go to the `\Exercise8.01\area` directory structure.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，进入`\Exercise8.01\area`目录结构。
- en: 'At the command line, type the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE30]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `go build` command will compile your program and create an executable named
    after the `dir` area.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go build`命令将编译你的程序并创建一个以`dir`区域命名的可执行文件。'
- en: 'Type the executable name and hit *Enter*:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入可执行文件名并按*Enter*键：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The expected output is as follows:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now have the functionality that we previously had in the interface chapter's
    implementation of `shape`. We have the `shape` functionality now encapsulated
    in the `shape` package. We exposed or made visible only the functions or methods
    that are needed to maintain the previous implementation. The `main` package has
    less clutter and imports the `shape` package to provide the functionality that
    was in the previous implementation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了在接口章节实现中之前拥有的功能。我们现在将`shape`功能封装在`shape`包中。我们只公开或使需要维护先前实现的函数或方法可见。`main`包更加简洁，并导入`shape`包以提供先前实现中的功能。
- en: The init() Function
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`init()`函数'
- en: 'As we have discussed, every Go program (executable) starts in the `main` package
    and the entry point is the `main` function. There is another special function
    that we should be aware of, called `init()`. Each source file can have an `init()`
    function, but for now, we will look at the `init` function in the context of the
    `main` package. When you start writing packages, you might need to provide some
    initialization (the `init()` function) for the package. The `init()` function
    is used to set up states or values. The `init()` function adds initialization
    logic for your package. Here are some examples of uses of the `init()` function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，每个Go程序（可执行文件）都是从`main`包开始的，入口点是`main`函数。我们还应该注意另一个特殊函数，称为`init()`。每个源文件都可以有一个`init()`函数，但到目前为止，我们将从`main`包的角度来看`init`函数。当你开始编写包时，你可能需要为包提供一些初始化（`init()`函数）。`init()`函数用于设置状态或值。`init()`函数为你的包添加初始化逻辑。以下是一些`init()`函数的用法示例：
- en: Setting database objects and connections
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库对象和连接
- en: The initialization of package variables
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包变量的初始化
- en: Creating files
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件
- en: Loading configuration data
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载配置数据
- en: Verifying or repairing the program state
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证或修复程序状态
- en: 'The `init()` function requires the following pattern to be called:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数需要以下模式来调用：'
- en: Imported packages are initialized first.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入的包首先被初始化。
- en: Package-level variables are initialized.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包级别的变量被初始化。
- en: The package's `init()` function is called.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用包的`init()`函数。
- en: '`main` is executed.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`被执行。'
- en: 'The following diagram shows the execution order that a typical Go program follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了典型Go程序遵循的执行顺序：
- en: '![Figure 8.12: Order of execution'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：执行顺序'
- en: '](img/B14177_08_12.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_08_12.jpg](img/B14177_08_12.jpg)'
- en: 'Figure 8.12: Order of execution'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：执行顺序
- en: 'Here is a simple example that demonstrates the `package main` order of execution:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，演示了`package main`的执行顺序：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the code is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s understand the code in parts:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分理解这段代码：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Based on the output of the code, the package level variable declaration got
    executed first. We know this because the `name` variable is printed in the `init()`
    function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码的输出，包级别的变量声明首先被执行。我们知道这一点是因为`name`变量在`init()`函数中被打印出来：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `init()` function then gets called and prints out `"Hello, Gopher"`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`init()`函数被调用并打印出`"Hello, Gopher"`：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, the `main()` function is executed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行`main()`函数：
- en: '![Figure 8.13: Execution flow of the code snippet'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13：代码片段的执行流程'
- en: '](img/B14177_08_13.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_08_13.jpg](img/B14177_08_13.jpg)'
- en: 'Figure 8.13: Execution flow of the code snippet'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：代码片段的执行流程
- en: 'The `init()` function cannot have any arguments or return values:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`函数不能有任何参数或返回值：'
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running this code snippet will result in the following error:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码片段将导致以下错误：
- en: '![Figure 8.14: Program output'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：程序输出'
- en: '](img/B14177_08_14.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_08_14.jpg](img/B14177_08_14.jpg)'
- en: 'Figure 8.14: Program output'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：程序输出
- en: 'Exercise 8.02: Loading Budget Categories'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.02：加载预算类别
- en: 'Write a program that will load budget categories into a global map, before
    the `main` function runs. The `main` function should then print out the data on
    the map:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，在`main`函数运行之前将预算类别加载到全局映射中。然后`main`函数应该打印映射上的数据：
- en: Create a `main.go` file.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件。
- en: 'The code file will belong to `package main` and will need to import the `fmt`
    package:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码文件将属于`package main`，并且需要导入`fmt`包：
- en: '[PRE39]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a global variable that will contain a map of budget categories with
    a key of `int` and a value of `string`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个全局变量，它将包含一个键为`int`、值为`string`的预算类别映射：
- en: '[PRE40]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will need to use an `init()` function to load our budget categories before
    `main` runs:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`main`运行之前使用一个`init()`函数来加载我们的预算类别：
- en: '[PRE41]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since our budget categories have been loaded, we can now iterate over the map
    and print them:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的预算类别已经被加载，我们现在可以遍历这个映射并打印它们：
- en: '[PRE42]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will get the following output:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE43]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The aim here was to demonstrate how the `init()` function can be used to perform
    data initialization and loading before the `main` function executes. Data that
    generally needs to be loaded before `main` runs is static data, such as picklist
    values or some sort of configuration. As demonstrated, after the data gets loaded
    through the `init` function, it can be used by the `main` function. In the next
    topic, we will see how multiple `init` functions get executed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目的是演示如何使用 `init()` 函数在 `main` 函数执行之前执行数据初始化和加载。通常需要在 `main` 运行之前加载的数据是静态数据，例如下拉列表值或某种配置。如所示，数据通过
    `init` 函数加载后，可以被 `main` 函数使用。在下一个主题中，我们将看到多个 `init` 函数是如何执行的。
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output may differ in terms of the order displayed; Go maps do not guarantee
    the order of data.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出顺序可能不同；Go maps 不保证数据的顺序。
- en: Executing Multiple init() Functions
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行多个 init() 函数
- en: 'There can be more than one `init()` function in a package. This enables you
    to modularize your initialization for better code maintenance. For example, suppose
    you need to set up various files and database connections and repair the state
    of the environment that your program will be executed in. Doing all that in one
    `init()` function would make it complicated for maintaining and debugging. The
    order of execution of multiple `init()` functions is the order in which the functions
    are placed in the code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包中可以有多个 `init()` 函数。这使您能够模块化初始化，以更好地维护代码。例如，假设您需要设置各种文件和数据库连接，并修复程序执行的环境状态。在一个
    `init()` 函数中完成所有这些会使维护和调试变得复杂。多个 `init()` 函数的执行顺序是函数在代码中放置的顺序：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s break the code into parts and evaluate it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将代码分解成部分并评估它：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Go initializes the `name` variable first, before the `init` function gets executed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在执行 `init` 函数之前首先初始化 `name` 变量：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This prints out first since it is the first `init` in the function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先打印出来，因为它是在函数中的第一个 `init`：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding gets printed out second since it is the second `init` in the
    function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容由于是函数中的第二个 `init` 而排在第二位打印出来：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding gets printed out third since it is the third `init` in the function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容由于是函数中的第三个 `init` 而排在第三位打印出来：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Finally, the `main()` function gets executed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，执行 `main()` 函数。
- en: 'The results would be as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Exercise 8.03: Assigning Payees to Budget Categories'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.03：将收款人分配到预算类别
- en: 'We are going to expand our program from *Exercise 8.02*, *Loading Budget Categories*,
    to now assign payees to budget categories. This is similar to many budgeting applications
    that try to match payees to commonly used categories. We will then print the mapping
    of a payee to a category:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的程序，从 *练习8.02*，*加载预算类别*，现在将收款人分配到预算类别。这类似于许多预算应用程序，试图将收款人与常用类别匹配。然后我们将打印收款人与类别的映射：
- en: Create the `main.go` file.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main.go` 文件。
- en: Copy the code from *Exercise 8.02*, *Load Budget Categories*, [https://github.com/PacktWorkshops/The-Go-Workshop/blob/master/Chapter08/Exercise8.02/main.go](https://github.com/PacktWorkshops/The-Go-Workshop/blob/master/Chapter08/Exercise8.02/main.go)
    into the `main.go` file.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *练习8.02*，*加载预算类别*，[https://github.com/PacktWorkshops/The-Go-Workshop/blob/master/Chapter08/Exercise8.02/main.go](https://github.com/PacktWorkshops/The-Go-Workshop/blob/master/Chapter08/Exercise8.02/main.go)
    中的代码复制到 `main.go` 文件中。
- en: 'Add a `payeeToCategory` map after `budgetCategories`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `budgetCategories` 后添加一个 `payeeToCategory` 映射：
- en: '[PRE51]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add another `init()` function. This `init()` function will be used to populate
    our new `payeeToCategory` map. We will assign payees to the key value of the categories:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个 `init()` 函数。这个 `init()` 函数将用于填充我们的新 `payeeToCategory` 映射。我们将收款人分配到类别的键值：
- en: '[PRE52]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `main()` function, we will print out the payees to categories. We iterate
    over the `payeeToCategory` map, printing the key (`payee`). We print the category
    by passing the value of the `payeeToCategory` map as a key to the `budgetCategories`
    map:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将打印出收款人到类别。我们遍历 `payeeToCategory` 映射，打印键（`收款人`）。我们通过将 `payeeToCategory`
    映射的值作为键传递给 `budgetCategories` 映射来打印类别：
- en: '[PRE53]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here''s the expected output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的输出：
- en: '![Figure 8.15: Assign a payee to budget categories'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：将收款人分配到预算类别'
- en: '](img/B14177_08_15.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_08_15.jpg)'
- en: 'Figure 8.15: Assign a payee to budget categories'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：将收款人分配到预算类别
- en: You have now created a program that executes multiple `init()` functions before
    the execution of the `main` function. Each of the `init()` functions loaded data
    into our global map variables. We have determined the order of `init` functions
    executing because of the `print` statements that get displayed. This demonstrates
    that the `init()` functions print in the order they are present in the code. It
    is important to be aware of the order of your `init` functions as you may have
    unforeseen results based on the order of the code execution.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在创建了一个程序，在执行`main`函数之前，先执行多个`init()`函数。每个`init()`函数都将数据加载到我们的全局映射变量中。我们确定了`init`函数执行的顺序，因为显示的`print`语句。这表明`init()`函数按照它们在代码中出现的顺序打印。了解你的`init`函数的顺序很重要，因为你可能会根据代码执行的顺序得到不可预见的结果。
- en: In the upcoming activity, we will be using all these concepts that we have looked
    at with packages and see how they all work together.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的活动中，我们将使用我们查看的所有关于包的概念，并看看它们是如何一起工作的。
- en: 'Activity 8.01: Creating a Function to Calculate Payroll and Performance Review'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动八.01：创建计算薪酬和绩效评估的函数
- en: 'In this activity, we are going to take *Activity 7.01*, *Calculating Pay and
    Performance Review*, and modularize it using packages. We will be refactoring
    the code from [https://packt.live/2YNnfS6](https://packt.live/2YNnfS6):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将采取*活动7.01*，*计算薪酬和绩效评估*，并使用包进行模块化。我们将重构来自[https://packt.live/2YNnfS6](https://packt.live/2YNnfS6)的代码：
- en: Move the types and methods of `Developer`, `Employee`, and `Manager` into their
    own package. Types, methods, and functions must be properly exported or unexported.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Developer`、`Employee`和`Manager`的类型和方法移动到它们自己的包中。类型、方法和函数必须正确导出或未导出。
- en: Name the package `payroll`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包命名为`payroll`。
- en: Logically separate the types and their methods into different package files.
    Recall that good code organization involves separating similar functionality into
    separate files.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型及其方法逻辑上分离到不同的包文件中。回想一下，良好的代码组织涉及将类似功能分离到单独的文件中。
- en: Create the `main()` function as an alias to the `payroll` package.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数作为`payroll`包的别名。
- en: Introduce the two `init()` functions in the `main` package. The first `init()`
    function should simply print a greeting message to `stdout`. The second `init()`
    should initialize/set up the key-value pairs.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`包中引入两个`init()`函数。第一个`init()`函数应该简单地打印一条问候消息到`stdout`。第二个`init()`应该初始化/设置键值对。
- en: 'The expected output would be as follows:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE54]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this activity, we have seen how to use packages to separate our code and
    then to logically separate the code into individual files. We can see that each
    of those files make up a package. Each file of the package has internal access
    to the other files regardless of the fact that they are in separate files. This
    activity demonstrates how to create a package with multiple files and how those
    separate files can be used to further organize our code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们看到了如何使用包来分离我们的代码，然后将代码逻辑上分离成单独的文件。我们可以看到，每个文件都构成了一个包。包中的每个文件都可以访问其他文件，无论它们是否在单独的文件中。这个活动演示了如何创建包含多个文件的包，以及如何使用这些单独的文件进一步组织我们的代码。
- en: Note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 720.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第720页找到。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We looked at the importance of developing software that is maintainable, reusable,
    and modular. We discovered how Go's packages play an important part in meeting
    those criteria for developing software. We looked at the overall structure of
    a package. It is made up of a directory, can contain one or more files, and it
    has code that is related. A package is essentially a directory inside of your
    workspace that contains one or more files that are used for grouping code that
    is to perform a task. It exposes only the necessary parts to those using your
    package to get a job done. We discussed the importance of naming packages properly.
    We also learned how to name a package, that is, concisely, in lowercase, descriptively,
    using non-plural names, and avoiding generic names. Packages can be executable
    or non-executable. If a package is the main package, then it is an executable
    package. The main package must have a main function and that is where the entry
    point is for our package.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了开发可维护、可重用和模块化软件的重要性。我们发现Go的包在满足这些软件开发标准方面发挥着重要作用。我们研究了包的整体结构。它由一个目录组成，可以包含一个或多个文件，并且包含相关的代码。一个包本质上是你工作空间中的一个目录，其中包含一个或多个用于分组执行任务的代码文件。它只向使用你的包的人暴露必要的部分以完成任务。我们讨论了正确命名包的重要性。我们还学习了如何命名一个包，即简洁、小写、描述性、使用非复数名称，并避免使用通用名称。包可以是可执行的或不可执行的。如果一个包是主包，那么它就是一个可执行包。主包必须有一个主函数，这是我们的包的入口点。
- en: 'We also talked about what is exportable and unexportable code. When we capitalize
    the name of a function, type, or method, it is visible to others using our package.
    Lowercasing a function, type, or method makes it not visible to other users from
    outside our package. When creating a package, we realized that `GOROOT` and `GOPATH`
    are important to know – they determine where Go looks for a package. We learned
    that `init` functions can perform the following duties: initializing variables,
    loading configuration data, setting database connections, or verifying that our
    program state is ready for execution. The `init()` function has certain rules
    when it gets executed and on how to utilize it. This chapter will help you to
    write highly manageable, reusable, and modular code.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了可导出和不可导出代码的概念。当我们将函数、类型或方法的名称大写时，它对使用我们的包的其他人是可见的。将函数、类型或方法小写化使其对包外部的其他用户不可见。在创建包时，我们意识到`GOROOT`和`GOPATH`是重要的，因为它们决定了Go在哪里查找包。我们了解到`init`函数可以执行以下任务：初始化变量、加载配置数据、设置数据库连接或验证我们的程序状态是否已准备好执行。`init()`函数在执行时有一定的规则，以及如何利用它。本章将帮助你编写高度可管理、可重用和模块化的代码。
- en: In the next chapter, we will be studying basic debugging. We will look at various
    techniques that help us to locate bugs in our programs. We will also discuss ways
    to minimize the difficulty of locating bugs and how to increase the chances of
    locating a bug after making a modification to the codebase.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究基本的调试技术。我们将探讨各种帮助我们定位程序中错误的技术。我们还将讨论减少定位错误难度的方法以及如何在修改代码库后增加定位错误的机会。
