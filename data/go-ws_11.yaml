- en: 11\. Encoding and Decoding (JSON)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 编码和解码（JSON）
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to acquaint you with the fundamentals of JavaScript Object
    Notation (JSON). You will learn how to use Go to parse JSON, and then gain the
    ability to convert JSON to a struct and back to JSON.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在使您熟悉JavaScript对象表示法（JSON）的基础知识。您将学习如何使用Go解析JSON，然后获得将JSON转换为结构体并将其转换回JSON的能力。
- en: Here, you will learn to describe JSON and unmarshal JSON to a struct. You will
    also learn to marshal a struct to JSON and set the JSON key name to something
    different than the struct field name. By the end of the chapter, you will be able
    to use various JSON tag attributes to control what gets converted to JSON, unmarshal
    an unknown JSON structure, and use encoding for data transmission.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将学习如何描述JSON并将JSON反序列化为结构体。您还将学习如何将结构体序列化为JSON并将JSON键名设置为与结构体字段名不同的名称。到本章结束时，您将能够使用各种JSON标签属性来控制要转换为JSON的内容，反序列化未知的JSON结构，并使用编码进行数据传输。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: In the previous chapter, we looked at errors in Go and discovered that, in Go,
    errors are values, which allows us to pass errors around as arguments to functions
    and methods. We also saw that Go functions can return multiple values, one of
    which is often an error. We learned that a good practice is to check for the value
    of an error returned by a function. By not ignoring the error, it prevents unexpected
    behavior in our program. In Go, we saw that you can create your own custom error
    types. Finally, we looked at panics and learned how to recover from them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Go中的错误，并发现Go中的错误是值，这使得我们可以将错误作为函数和方法的参数传递。我们还看到Go函数可以返回多个值，其中一个通常是错误。我们了解到检查函数返回的错误值是一个好的实践。通过不忽略错误，它可以防止程序中出现意外的行为。在Go中，我们看到了可以创建自己的自定义错误类型。最后，我们探讨了恐慌并学习了如何从中恢复。
- en: In this chapter, we will be working with JSON by using only the standard library
    of Go. Before we start looking at using JSON in Go code, let's have a brief introduction
    to JSON.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将仅使用Go的标准库来处理JSON。在我们开始查看如何在Go代码中使用JSON之前，让我们简要介绍一下JSON。
- en: JSON
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JSON** stands for **JavaScript Object Notation**. It is widely used in many
    programming languages for transferring and storing data. Often, this is done by
    transferring data from a web server to a client. JSON is transferred in web applications
    and is even used to store data in a file for later processing. We will look at
    various examples of where this is done in this chapter. JSON is minimal; it is
    not as verbose as XML. It is self-describing; this increases its readability and
    the ease of writing it. JSON is a text format that is language-independent:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**。它在许多编程语言中广泛用于传输和存储数据。通常，这是通过将数据从网络服务器传输到客户端来完成的。JSON在Web应用程序中传输，甚至用于将数据存储在文件中以供后续处理。在本章中，我们将探讨这种操作的各种示例。JSON是最简的；它不像XML那样冗长。它是自我描述的；这增加了其可读性和编写它的便捷性。JSON是一种语言无关的文本格式：'
- en: '![Figure 11.1: Describing JSON'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1：描述JSON'
- en: '](img/B14177_11_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B14177_11_01.jpg]'
- en: 'Figure 11.1: Describing JSON'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：描述JSON
- en: 'JSON is widely used as a data format for exchanging data between web applications
    and for various server-to-server communications. A common API that is used in
    applications is the REST API. JSON is frequently used in applications that utilize
    the REST API. One of the reasons that JSON is used in the REST API instead of
    XML is because it is less verbose than XML, more lightweight, and easier to read.
    Looking at the following JSON and XML, respectively, we can see that JSON is less
    verbose, easier to read, and more lightweight:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JSON广泛用作在Web应用程序之间交换数据以及各种服务器到服务器通信的数据格式。在应用程序中使用的常见API是REST API。JSON经常用于使用REST
    API的应用程序中。JSON在REST API中使用而不是XML的原因之一是它比XML更简洁、更轻量级且更易于阅读。查看以下JSON和XML，我们可以看到JSON更简洁、更易于阅读且更轻量级：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Most modern databases also now store JSON as a data type in a field. Static
    web applications sometimes use JSON for rendering their web pages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代数据库现在也将JSON作为字段中的数据类型存储。静态Web应用程序有时使用JSON来渲染其网页。
- en: 'The JSON format is very structured. The primary parts that make up the JSON
    format consists of a collection of key-value pairs, as shown in the following
    figure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式非常结构化。构成JSON格式的核心部分是一系列键值对，如下图所示：
- en: '![Figure 11.2: JSON key-value pairs'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2：JSON键值对'
- en: '](img/B14177_11_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片B14177_11_02.jpg]'
- en: 'Figure 11.2: JSON key-value pairs'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：JSON键值对
- en: The key is always a string enclosed in quotation marks, whereas the value can
    encompass a multitude of data types. A key-value pair in JSON is a `key` name
    followed by a colon, followed by a `value`. If there are additional key-value
    pairs, they will be separated with a comma.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 键始终是一个用引号括起来的字符串，而值可以包含多种数据类型。JSON 中的键值对是一个`key`名称后跟一个冒号，然后是一个`value`。如果有更多的键值对，它们将用逗号分隔。
- en: In *Figure 11.2*, there are two key-value pairs. The `firstname` key and its
    value of `Captain` is one. The other set is `lastname` and `Marvel`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 11.2*中，有两个键值对。`firstname`键及其值为`Captain`的一个。另一组是`lastname`和`Marvel`。
- en: 'JSON can contain arrays. The values are within a set of brackets. In *Figure
    11.3*, lines *3* and *4* are the values of the `phonenumbers` key:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 可以包含数组。值位于一组括号内。在*图 11.3*中，第*3*行和第*4*行是`phonenumbers`键的值：
- en: '![Figure 11.3: JSON array'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3：JSON 数组'
- en: '](img/B14177_11_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_11_03.jpg](img/B14177_11_03.jpg)'
- en: 'Figure 11.3: JSON array'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：JSON 数组
- en: 'Now that we''ve seen key-value pairs, let''s look at JSON data types. The JSON
    object supports many different data types; the following diagram shows those data
    types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了键值对，让我们看看 JSON 数据类型。JSON 对象支持许多不同的数据类型；以下图表显示了这些数据类型：
- en: '![Figure 11.4: JSON data types'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4：JSON 数据类型'
- en: '](img/B14177_11_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_11_04.jpg](img/B14177_11_04.jpg)'
- en: 'Figure 11.4: JSON data types'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：JSON 数据类型
- en: 'Here are a few examples:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: 'String:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Number: This can be a float or an integer:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：这可以是浮点数或整数：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Array:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Boolean: Can only be `true` or `false`:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：只能是`true`或`false`：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Null:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Object:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象：
- en: 'JSON objects are like structs in Go. The following example shows a Go struct
    and a JSON object:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JSON 对象类似于 Go 中的结构体。以下示例展示了 Go 结构体和 JSON 对象：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this section, we provided a brief introduction to JSON. In the following
    sections, we will look at how Go can decode and encode JSON.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了 JSON。在接下来的章节中，我们将探讨 Go 如何解码和编码 JSON。
- en: Decoding JSON
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析 JSON
- en: When we talk about decoding JSON, what we are stating is that we are taking
    a JSON data structure and converting it into a Go data structure. Converting the
    JSON into a Go data structure gives us the benefit of working with the data natively.
    For example, if the JSON data has a field that is an array in Go, that would get
    decoded to a slice. We will then be able to treat that slice as we would any other
    slice, meaning we can iterate over the slice using a `range` clause, we can get
    the length of the slice, append to the slice, and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论解析 JSON 时，我们所说的就是我们将一个 JSON 数据结构转换为一个 Go 数据结构。将 JSON 转换为 Go 数据结构的好处是能够以原生方式处理数据。例如，如果
    JSON 数据有一个字段是 Go 中的数组，那么它会被解码为一个切片。然后我们就可以像处理任何其他切片一样处理这个切片，这意味着我们可以使用`range`子句遍历切片，我们可以获取切片的长度，向切片中追加元素，等等。
- en: 'If we know what our JSON looks like ahead of time, we can use structs when
    parsing the JSON. Using Go terms, we need to be able to `unmarshal` the JSON-encoded
    data and store the results in the struct. To be able to do this, we will need
    to import the `encoding/json` package. We will be using the JSON `Unmarshal` function.
    Unmarshaling is the process of parsing JSON to a data structure. Often, you will
    hear unmarshaling and decoding used interchangeably:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们事先知道我们的 JSON 的样子，我们可以在解析 JSON 时使用结构体。使用 Go 术语，我们需要能够`unmarshal` JSON 编码的数据并将结果存储在结构体中。为了能够做到这一点，我们需要导入`encoding/json`包。我们将使用
    JSON 的`Unmarshal`函数。反序列化是将 JSON 解析到数据结构的过程。通常，你会听到反序列化和解码被互换使用：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, the variable data is defined as a slice of bytes. The
    `v` variable is a pointer to a struct. The `Unmarshal` function takes the slice
    of bytes of JSON data and stores the results in the value pointed to by `v`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量`data`被定义为字节数组。变量`v`是一个结构体的指针。`Unmarshal`函数接受 JSON 数据的字节数组并将结果存储在`v`指向的值中。
- en: 'The argument for `v` must be a pointer and must not be `nil`. If either of
    those requirements are not met, then an error will be returned as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`v`的参数必须是一个指针，并且不能为`nil`。如果这两个要求中的任何一个没有得到满足，那么将返回以下错误：'
- en: '![Figure 11.5: Unmarshal error for a non-pointer passed as an argument'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5：非指针作为参数传递时的 Unmarshal 错误'
- en: '](img/B14177_11_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_11_05.jpg](img/B14177_11_05.jpg)'
- en: 'Figure 11.5: Unmarshal error for a non-pointer passed as an argument'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：非指针作为参数传递时的 Unmarshal 错误
- en: 'Let''s look at the following code as a simple example of unmarshaling data.
    We will describe each portion of the code in detail to get a better understanding
    of the program:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码作为反序列化数据的简单示例。我们将详细描述代码的每一部分，以便更好地理解程序：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The greeting struct has an exportable field called `Message` of the `string`
    type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 问候结构体有一个名为 `Message` 的可导出字段，其类型为 `string`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `` ` `` symbol is a backtick and not a single quote. It is used for string
    literals.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`` ` `` 符号是反引号，而不是单引号。它用于字符串字面量。'
- en: 'The `json.Unmarshal` struct requires that the JSON encoded data must be a byte
    of slices:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Unmarshal` 结构体要求 JSON 编码的数据必须是字节切片：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are declaring `g` to be of the greeting type:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明 `g` 为问候类型：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Unmarshal()` function takes the slice of bytes of JSON data and stores
    the results in the value pointed to by `v`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unmarshal()` 函数接收 JSON 数据的字节切片，并将结果存储在由 `v` 指向的值中。'
- en: The `v` variable is pointing to our greeting struct.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`v` 变量指向我们的问候结构体。'
- en: 'It unmarshals the JSON to a greeting instance, as depicted in the following
    diagram:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它将 JSON 解析到问候实例中，如下所示：
- en: '![Figure 11.6: Unmarshaling JSON to a Go struct'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6：将 JSON 解析到 Go 结构体'
- en: '](img/B14177_11_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_11_06.jpg)'
- en: 'Figure 11.6: Unmarshaling JSON to a Go struct'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：将 JSON 解析到 Go 结构体
- en: 'Now, let''s see the output after unmarshaling:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看解析后的输出：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It should look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像这样：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In our previous example, the JSON marshaler matched our field name, `Message`,
    to the JSON key, `message`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，JSON 序列化器将我们的字段名 `Message` 与 JSON 键 `message` 匹配。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To be able to unmarshal into a struct, the struct field must be exportable.
    The struct's field name must be capitalized. Only fields that are exportable are
    visible externally, including the JSON unmarshaler. Only the exported fields will
    be in the JSON output; other fields are ignored.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够将数据解析到结构体中，结构体字段必须是可导出的。结构体的字段名必须大写。只有可导出的字段才能在外部可见，包括 JSON 解析器。只有导出字段才会出现在
    JSON 输出中；其他字段将被忽略。
- en: Struct Tags
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体标签
- en: 'We can use struct tags to provide transformation information on how the struct
    field is unmarshaled or marshaled. Tags follow the format of `` `key: `` `` "value"`
    ``. The tag begins and ends with a backtick (`` ` ``).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用结构体标签来提供有关结构体字段如何解析或序列化的转换信息。标签遵循 `` `key: `` `` "value"` `` 的格式。标签以反引号（``
    ` ``）开始和结束。'
- en: 'Consider the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using tags gives us more control. We can now name our struct field name anything
    as long as it is exportable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签给我们更多的控制。现在我们可以将结构体字段命名为任何内容，只要它是可导出的。
- en: The `json` field that will be unmarshaled in this example is `lname`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中将被反序列化的 `json` 字段是 `lname`。
- en: 'Once you use tags for JSON unmarshaling and marshaling, it will not compile
    if the struct field is not exportable. The Go compiler is smart enough to realize
    that since there is a JSON tag associated with the struct field, it must be exportable
    to be used in the JSON marshaling and unmarshaling process. See the following
    example of the error you will get when `lastname` is lowercase:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你为 JSON 解析和序列化使用了标签，如果结构体字段不可导出，则无法编译。Go 编译器足够智能，能够意识到由于与结构体字段关联了 JSON 标签，因此它必须是可导出的才能用于
    JSON 序列化和反序列化过程。以下是一个示例，当 `lastname` 小写时，你会得到以下错误：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the error message for unexported JSON struct fields:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是未导出 JSON 结构体字段的错误信息：
- en: '![Figure 11.7: Error for unexported JSON struct fields'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.7：未导出 JSON 结构体字段的错误'
- en: '](img/B14177_11_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_11_07.jpg)'
- en: 'Figure 11.7: Error for unexported JSON struct fields'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：未导出 JSON 结构体字段的错误
- en: 'We have already seen this code before and we know how to unmarshal JSON. However,
    there is one small change that we will be making, and that is adding a `struct`
    tag to our code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到过这段代码，并且我们知道如何解析 JSON。然而，我们将进行一个小小的更改，那就是在我们的代码中添加一个 `struct` 标签：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We changed our `greeting` struct to use a different exportable field name than
    what is in JSON.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `greeting` 结构体更改为使用与 JSON 中不同的可导出字段名。
- en: 'The `` `json:"message"` `` tag states that this exportable field corresponds
    to the `message` key in the JSON data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `json:"message"` `` 标签表示这个可导出字段对应于 JSON 数据中的 `message` 键：'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the data gets unmarshaled, the JSON message value will be placed in the
    `SomeMessage` struct field.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被解析时，JSON 消息值将被放置在 `SomeMessage` 结构体字段中。
- en: 'We will get the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The Go JSON `unmarshaller` follows a process of determining which struct field
    to map the JSON data when decoding it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Go JSON `unmarshaller` 在解码时遵循确定哪个结构体字段映射 JSON 数据的过程：
- en: An exported field with a tag.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有标签的导出字段。
- en: An exported field name whose case matches the JSON key name.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个导出字段名与JSON键名大小写匹配。
- en: An exported field name with a case-insensitive match.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个导出字段名与JSON键名大小写不敏感匹配。
- en: We could also verify whether the JSON that we are going to unmarshal is valid.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以验证我们即将反序列化的JSON是否有效。
- en: 'The following is the code to perform the unmarshaling:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将反序列化执行的代码：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Valid()` function takes as an argument slice of bytes and will return a
    Bool that indicates whether the JSON is valid. It will display `True` for valid
    JSON and `False` for invalid JSON.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Valid()` 函数接受一个字节数组切片作为参数，并将返回一个布尔值，指示JSON是否有效。对于有效的JSON，它将显示 `True`，对于无效的JSON，它将显示
    `False`。'
- en: This can be useful for checking our JSON before we try to unmarshal it into
    a struct.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们尝试将JSON反序列化到结构体之前检查我们的JSON可能很有用。
- en: What structs do you think you would need for the following JSON? Let's take
    a look.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你需要哪些结构体来处理以下JSON？让我们看看。
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding JSON has an embedded object called `address`. As you may recall
    from the introduction of this chapter, objects are one of the types that JSON
    supports. The Go representation of an object type in JSON is structs. Our `parent`
    struct would need to have an embedded struct called `address`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON有一个嵌套的对象称为 `address`。如您从本章的介绍中回忆的那样，对象是JSON支持的类型之一。JSON中对象类型的Go表示是结构体。我们的
    `parent` 结构体需要有一个嵌套的结构体称为 `address`。
- en: 'The following code snippet is an example of unmarshaling more than one JSON
    object into Go structs:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是反序列化多个JSON对象到Go结构体的示例：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s break the code down for better understanding:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `person` struct has an embedded struct called `Address`. It is represented
    in the JSON as an object called `address`. The fields in the `address` struct
    will have the JSON values unmarshaled to them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`person` 结构体有一个嵌套的结构体，称为 `Address`。它在JSON中表示为名为 `address` 的对象。`address` 结构体中的字段将具有反序列化到它们的JSON值：'
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `address` in JSON is an object that will get unmarshaled into our `person
    struct''s address` field:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: JSON中的 `address` 是一个对象，它将被反序列化到我们的 `person` 结构体的 `address` 字段：
- en: '![Figure 11.8: Unmarshaled JSON address to person.address'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8：未展开的JSON地址到person.address]'
- en: '](img/B14177_11_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_11_08.jpg](img/B14177_11_08.jpg)'
- en: 'Figure 11.8: Unmarshaled JSON address to person.address'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：反序列化的JSON地址到person.address
- en: 'The `Unmarshal()` function decodes the JSON-encoded `data` into the pointer
    `p`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unmarshal()` 函数将JSON编码的 `data` 解码到指针 `p`：'
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The results are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 11.9: The person struct after decoding JSON'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9：解码JSON后的person结构体]'
- en: '](img/B14177_11_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_11_09.jpg](img/B14177_11_09.jpg)'
- en: 'Figure 11.9: The person struct after decoding JSON'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：解码JSON后的person结构体
- en: We will be using these concepts that we have learned thus far in the next exercise.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中使用我们迄今为止学到的这些概念。
- en: 'Exercise 11.01: Unmarshaling Student Courses'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.01：反序列化学生课程
- en: 'In this exercise, we will be writing a program that takes a JSON from a web
    request for college class enrollment. Our program needs to unmarshal the JSON
    data into a Go struct. The JSON will contain data about a student and the courses
    that they are taking. After we have unmarshaled the JSON, we will print the struct
    for verification purposes. The output should be as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个程序，该程序从网络请求中获取大学课程注册的JSON。我们的程序需要将JSON数据反序列化到Go结构体中。JSON将包含有关学生和他们所修课程的数据。在我们反序列化JSON之后，我们将打印结构体以进行验证。输出应如下所示：
- en: '![Figure 11.10: Printing the student courses struct'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10：打印学生课程结构]'
- en: '](img/B14177_11_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_11_10.jpg](img/B14177_11_10.jpg)'
- en: 'Figure 11.10: Printing the student courses struct'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：打印学生课程结构
- en: 'All directories and files created need to be created within your `$GOPATH`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建的目录和文件都需要在 `$GOPATH` 内创建：
- en: Create a directory called `Exercise11.01` within a directory called `Chapter11`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `Chapter11` 的目录中创建一个名为 `Exercise11.01` 的目录。
- en: Create a file called `main.go` inside of `Chapter11/Exercise11.01`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter11/Exercise11.01` 内创建一个名为 `main.go` 的文件。
- en: Using Visual Studio Code, open the newly created `main.go` file.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code打开新创建的 `main.go` 文件。
- en: 'Add the following package name and import statements:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下包名和导入语句：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will need to create a `student` struct. The `student` struct will need for
    all its fields to be exported so that we can unmarshal the JSON data to them.
    Each struct field will need to have a JSON tag that will be the name of the JSON
    data fields:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个 `student` 结构体。`student` 结构体的所有字段都需要是导出的，这样我们才能将JSON数据反序列化到它们。每个结构体字段都需要一个JSON标签，该标签将是JSON数据字段的名称：
- en: '[PRE28]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will need to create a `course` struct. The `course` struct will need all
    its fields to be exported so that we can unmarshal the JSON data to them. Each
    struct field will need to have a JSON tag that will be the name of the JSON data
    fields:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个 `course` 结构体。`course` 结构体需要所有字段都是可导出的，这样我们才能将 JSON 数据解析到它们中。每个结构体字段都需要一个
    JSON 标签，该标签将是 JSON 数据字段的名称：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add a `main()` function:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `main()` 函数：
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `main()` function, add the JSON data that we will be unmarshaling into
    our structs (`student` and `course`):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，添加我们将要解析到我们的结构体（`student` 和 `course`）中的 JSON 数据：
- en: '[PRE31]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Declare a variable of the `student` type:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `student` 类型的变量：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will unmarshal the JSON into our `student` struct. We will also handle
    any errors that get returned from the `json.Unmarshal()` method:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将 JSON 解析到我们的 `student` 结构体中。我们还将处理 `json.Unmarshal()` 方法返回的任何错误：
- en: '[PRE33]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will print the `student` struct so that we can see that all the data from
    the JSON is present:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将打印 `student` 结构体，以便我们可以看到 JSON 中的所有数据：
- en: '[PRE34]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Build the program by running `go build` in the command line:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行中运行 `go build` 来构建程序：
- en: '[PRE35]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Correct any errors that are returned and ensure your code matches the code snippet
    here.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修正返回的错误，并确保你的代码与这里的代码片段匹配。
- en: Run the executable by typing in the name of the executable and then hit *Enter*
    to run it.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入可执行文件名并按 *Enter* 键来运行可执行文件。
- en: 'The output is as follows:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 11.11: Printing the student courses struct'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.11：打印学生课程结构体]'
- en: '](img/B14177_11_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_11_10.jpg]'
- en: 'Figure 11.11: Printing the student courses struct'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：打印学生课程结构体
- en: This exercise demonstrated how to unmarshal JSON data into a Go struct successfully.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了如何成功地将 JSON 数据解析到 Go 结构体中。
- en: Encoding JSON
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON 编码
- en: 'We have studied how to unmarshal JSON into a struct. We will now do the opposite:
    marshal a struct into JSON. When we talk about encoding JSON, what we mean is
    we are taking a Go struct and converting it to a JSON data structure. The typical
    scenario in which this is done is when you have a service that is responding to
    an HTTP request from a client. The client wants the data in a certain format,
    and this is frequently JSON. Another situation is that the data is stored in a
    NoSQL database and it requires JSON as the format, or even a traditional database
    that has a column with a data type of JSON.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了如何将 JSON 解析到结构体中。现在我们将做相反的操作：将结构体序列化为 JSON。当我们谈论编码 JSON 时，我们的意思是将一个 Go
    结构体转换为 JSON 数据结构。这种操作通常发生在你有一个服务正在响应来自客户端的 HTTP 请求时。客户端希望数据以某种格式呈现，这通常是 JSON。另一种情况是数据存储在
    NoSQL 数据库中，它需要 JSON 格式，或者甚至是一个具有 JSON 数据类型的列的传统数据库。
- en: 'We need to be able to `Marshal` the Go struct into a JSON-encoded structure.
    To be able to do this, we will need to import the `encoding/json` package. We
    will be using the `json.Marshal` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够将 Go 结构体 `Marshal` 到一个 JSON 编码的结构体中。为了做到这一点，我们需要导入 `encoding/json` 包。我们将使用
    `json.Marshal` 函数：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `v` becomes encoded as JSON. Typically, `v` is a `struct`. The `Marshal()`
    function returns the JSON encoding as a slice of bytes and an error. It is always
    a good idea to check whether there was an error during the process of encoding
    `v`. Let''s look at a simple example to further explain the marshaling of Go structs
    to JSON:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`v` 被编码为 JSON。通常，`v` 是一个 `struct`。`Marshal()` 函数返回一个字节切片和错误。在编码 `v` 的过程中检查是否有错误总是一个好的做法。让我们通过一个简单的例子来进一步解释
    Go 结构体到 JSON 的序列化：'
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We have a struct with one exportable field. Notice there are no JSON tags.
    You should be able to guess what the field will be in the JSON data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个只有一个可导出字段的 `struct`。注意没有 JSON 标签。你应该能够猜出该字段在 JSON 数据中是什么：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following diagram shows how the `greeting` struct gets marshaled into JSON
    using the `json.Marshal` method. The `v` interface argument in the `marshal` method
    is the `greeting` struct. The `marshal` method will encode the `greeting` field,
    `SomeMessage`, into JSON. The following diagram shows the process:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了如何使用 `json.Marshal` 方法将 `greeting` 结构体序列化为 JSON。`marshal` 方法中的 `v` 接口参数是
    `greeting` 结构体。`marshal` 方法将 `greeting` 字段 `SomeMessage` 编码为 JSON。以下图示显示了该过程：
- en: '![Figure 11.12: Marshaling a Go struct to JSON'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.12：将 Go 结构体序列化为 JSON]'
- en: '](img/B14177_11_12.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_11_12.jpg]'
- en: 'Figure 11.12: Marshaling a Go struct to JSON'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：将 Go 结构体序列化为 JSON
- en: When we call the `Marshal` function, we are passing it a struct. The function
    will return back an error and the JSON encoding of `g`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Marshal`函数时，我们传递给它一个结构体。该函数将返回一个错误和`g`的JSON编码。
- en: 'The results of the print statement are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打印语句的结果如下：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since we did not provide the JSON tag for the struct greeting, `SomeMessage`,
    the Go `Marshal` encodes the exportable fields and its values. The Go `Marshal`
    uses the name of the field, `SomeMessage` ,as the name of the `key` field in the
    JSON data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为结构体`greeting`提供JSON标签，Go `Marshal`将编码可导出字段及其值。Go `Marshal`使用字段名`SomeMessage`作为JSON数据中`key`字段的名称。
- en: The following code produces a result that is not desirable. Examine the following
    code and notice the result of struct fields that are not set. Pay close attention
    to the fields that are not being set in the `main()` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码产生了一个不理想的结果。检查以下代码并注意未设置的结构体字段的结果。请特别注意在`main()`函数中未设置的字段。
- en: 'Consider the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Marshaling struct data when the field value is not set gives you the following
    output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段值未设置时，序列化结构体数据将给出以下输出：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are times that we might not want our struct fields to be marshaled to
    JSON when the fields are not set. Our `CoAuthor` field and `YearPublished` were
    not set, and thus the JSON values were an empty string and zero, respectively.
    There is a JSON tag attribute that we can utilize called `omitempty`. It will
    omit the struct field from the JSON if it is empty:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能不希望当字段未设置时将结构体字段序列化为JSON。我们的`CoAuthor`字段和`YearPublished`未设置，因此JSON值分别为空字符串和零。有一个我们可以利用的JSON标签属性，称为`omitempty`。如果它为空，它将省略结构体字段：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The two `book` fields'' JSON tags use the `omitempty` attribute. If these fields
    are not set, they will not appear in the JSON. The result is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`book`字段的JSON标签使用`omitempty`属性。如果这些字段未设置，它们将不会出现在JSON中。结果如下：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When using the JSON tags, you will need to be careful not to have any spaces
    in the values. Using our previous example, let''s change our `YearPublished` JSON
    tag to this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSON标签时，你需要小心不要在值中有任何空格。使用我们之前的示例，让我们将我们的`YearPublished` JSON标签更改为以下内容：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice the space between the comma and `omitempty`. This would result in the
    following error if you use `go vet`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意逗号和`omitempty`之间的空格。如果你使用`go vet`，这将导致以下错误：
- en: '![Figure 11.13: Go vet error'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13：Go vet错误'
- en: '](img/B14177_11_13.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B14177_11_13.jpg](img/B14177_11_13.jpg)'
- en: 'Figure 11.13: Go vet error'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：Go vet错误
- en: 'Another thing to keep in mind is that if you do not properly handle errors,
    you will get some erroneous results:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，如果你没有正确处理错误，你将得到一些错误的结果：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Even though the `json.Marshal(b)` function errored, it still marshaled the struct
    to JSON. The `yearpub` value was set to zero. That is one of the reasons it is
    important to handle our errors.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`json.Marshal(b)`函数出错，它仍然将结构体转换为JSON。`yearpub`值被设置为零。这就是为什么处理我们的错误很重要的原因之一。
- en: 'There are other JSON tags that we will look at briefly in the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将简要查看其他一些JSON标签：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the above code, `` `json:",omitempty"` `` does not have a value for a field.
    Notice the JSON tag value starts with a comma.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的代码中，`` `json:",omitempty"` ``没有字段的值。注意JSON标签值以逗号开头。
- en: '`` `json:",omitempty"` `` will have the field in the JSON if there is a value
    for the key. If `Author` has a value set, it will appear in the JSON as the `"Author"
    :"somevalue"` key:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `json:",omitempty"` ``如果键有值，则该字段将出现在JSON中。如果`Author`设置了值，它将作为`"Author" :"somevalue"`键出现在JSON中：'
- en: '[PRE50]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The dash is used to ignore the field. The field will not be marshaled to JSON.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破折号用于忽略字段。该字段将不会被序列化为JSON。
- en: 'The result is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following diagram summarizes the different JSON tag attributes that we
    have used with our structs when we marshal the struct to JSON:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了我们在将结构体序列化为JSON时与我们的结构体一起使用的不同JSON标签属性：
- en: '![Figure 11.14: JSON tag field descriptions'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14：JSON标签字段描述'
- en: '](img/B14177_11_14.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图B14177_11_14.jpg](img/B14177_11_14.jpg)'
- en: 'Figure 11.14: JSON tag field descriptions'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：JSON标签字段描述
- en: 'Having the JSON output as a one-liner is not very readable, especially when
    you start working with larger JSON structures. The Go JSON package provides a
    way to format the JSON output. The `MarshalIndent()` function provides the same
    functionality as the `Marshal` function. In addition to encoding JSON, the `MarshalIndent()`
    function can format the JSON make it easy to read. This is often referred to as
    "pretty printing." The following code shows an example code for the `MarshalIndent()`
    function:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON输出作为一行并不是很易读，尤其是当你开始处理更大的JSON结构时。Go JSON包提供了一个格式化JSON输出的方法。`MarshalIndent()`函数提供了与`Marshal`函数相同的功能。除了编码JSON之外，`MarshalIndent()`函数还可以格式化JSON，使其易于阅读。这通常被称为“美化打印”。以下代码展示了`MarshalIndent()`函数的示例代码：
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will not be using a prefix in our examples. It just applies a string before
    our indent string. Each element will begin on a new line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们不会使用前缀。它只是在我们的缩进字符串之前应用一个字符串。每个元素都将开始在新的一行上：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以更好地理解：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We have two structs: a `person` struct and an `address` struct. The `address`
    struct is embedded inside the `person` struct. Both structs have the JSON key
    names defined in the JSON tags. The `address` struct will be a separate object
    inside the JSON:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个结构体：一个`person`结构体和一个`address`结构体。`address`结构体嵌入在`person`结构体中。两个结构体都在JSON标签中定义了JSON键名。`address`结构体将在JSON中作为一个单独的对象：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We initialize the `person` struct and set the values for the `person.Address`
    fields. Every field has a value set, so there will be no empty strings or zero
    values set in our JSON:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化`person`结构体并设置`person.Address`字段的值。每个字段都设置了值，因此在我们的JSON中不会有空字符串或零值：
- en: '[PRE56]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `noPrettyPrint` variable is the JSON encoding of `p`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`noPrettyPrint`变量是`p`的JSON编码。'
- en: 'We, of course, check for any errors returned from the `json.Marshal()` function:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然会检查`json.Marshal()`函数返回的任何错误：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `prettyPrint` variable is the JSON encoding of `p`, by using `json.MarshalIndent()`.
    We set the prefix argument to an empty string and the indent argument to four
    spaces.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`prettyPrint`变量是使用`json.MarshalIndent()`对`p`进行JSON编码的结果。我们将前缀参数设置为空字符串，将缩进参数设置为四个空格。'
- en: 'As with the `json.Marshal()` function, we also check for any errors returned
    from the `json.MarshalIndent()` function. We can see these various steps using
    the `json.MarshalIndent()` method depicted in the following diagram:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与`json.Marshal()`函数一样，我们也检查`json.MarshalIndent()`函数返回的任何错误。我们可以使用以下图中的`json.MarshalIndent()`方法来查看这些各种步骤：
- en: '![Figure 11.15: The json.MarshalIndent() method'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.15：json.MarshalIndent()方法'
- en: '](img/B14177_11_15.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_11_15.jpg)'
- en: 'Figure 11.15: The json.MarshalIndent() method'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：json.MarshalIndent()方法
- en: 'We then print the results of the JSON encoding using the `json.Marshal()` function:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`json.Marshal()`函数打印JSON编码的结果：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the readability of the JSON is slightly challenging.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，JSON的可读性略有挑战。
- en: 'JSON marshaling without `MarshalIndent` looks as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`MarshalIndent`的JSON序列化如下所示：
- en: '[PRE59]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We also print the results of the JSON encoding using the `json.MarshalIndent()`
    function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`json.MarshalIndent()`函数打印了JSON编码的结果：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The results are less of a challenge to read using the `json.MarshalIndent()`
    function. You can clearly read the output more easily than the previous results
    that were printed:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`json.MarshalIndent()`函数的结果更容易阅读。你可以比之前打印的结果更容易地阅读输出：
- en: '![Figure 11.16: Using the MarshalIndent JSON result'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16：使用MarshalIndent JSON结果'
- en: '](img/B14177_11_16.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_11_16.jpg)'
- en: 'Figure 11.16: Using the MarshalIndent JSON result'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：使用MarshalIndent JSON结果
- en: 'Exercise 11.02: Marshaling Student Courses'
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：序列化学生课程
- en: 'In this exercise, we are going to do the opposite to what we did in *Exercise
    11.01*, *Unmarshaling Student Courses*. We will marshal from a struct into JSON.
    This is the previous struct:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将做与*练习11.01*，*反序列化学生课程*相反的事情。我们将从结构体到JSON进行序列化。这是之前的结构体：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We are going to make some changes to the JSON tags.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对JSON标签进行一些修改。
- en: 'All directories and files created need to be created within your `$GOPATH`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建的目录和文件都需要在您的`$GOPATH`内创建：
- en: Create a file called `main.go`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件。
- en: 'Add the following package name and import statements:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下包名和导入语句：
- en: '[PRE62]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create a `student` struct. All fields will be exportable. The following fields''
    JSON tags will need the following functionality when they get marshaled:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`student`结构体。所有字段都将可导出。以下字段的JSON标签在它们被序列化时需要以下功能：
- en: '`MiddleInitial` should be omitted if a value is not set; `IsMarried` should
    not appear in the JSON; and `IsEnrolled` should be the field name and omitted
    if not set:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果未设置值，则应省略 `MiddleInitial`；`IsMarried` 不应出现在 JSON 中；`IsEnrolled` 应为字段名，如果未设置则省略：
- en: '[PRE63]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a `course` struct:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `course` 结构体：
- en: '[PRE64]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create a function called `newStudent()`. This function will return a `student`
    struct:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `newStudent()` 的函数。此函数将返回一个 `student` 结构体：
- en: '[PRE65]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the `main()` function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `main()` 函数：
- en: '[PRE66]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the `main()` function, use the `newStudent()` function to create a `student`
    struct and assign the result of the function to a variable, `s`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，使用 `newStudent()` 函数创建一个 `student` 结构体，并将函数的结果赋值给变量 `s`：
- en: '[PRE67]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, marshal `s` to JSON. We want the indenting of the JSON to be four spaces
    for each field for ease of readability:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `s` 序列化为 JSON。我们希望 JSON 的缩进为每个字段四个空格，以便于阅读：
- en: '[PRE68]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Print `student1`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `student1`：
- en: '[PRE69]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create another `student` using the `newStudent()` function:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `newStudent()` 函数创建另一个 `student`：
- en: '[PRE70]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will now add various courses to `s2`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将为 `s2` 添加各种课程：
- en: '[PRE71]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, marshal `s2` to JSON. We want the indenting of the JSON to be four spaces
    for each field for ease of readability:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `s2` 序列化为 JSON。我们希望 JSON 的缩进为每个字段四个空格，以便于阅读：
- en: '[PRE72]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Print `student2`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `student2`：
- en: '[PRE73]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The result of the `student1` print statement is as follows:'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`student1` 打印语句的结果如下：'
- en: '[PRE74]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The result of the `student2` print statement is as follows:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`student2` 打印语句的结果如下：'
- en: '[PRE75]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The aim of this exercise was to demonstrate how to encode JSON. We took a struct
    and encoded it into JSON. We were able to change the encoding to make it easier
    to read by indenting the fields. We also saw how to change some of the behavior
    of how fields are encoded to JSON. We saw that we can omit fields from getting
    encoded to JSON if the struct field does not have any data. We demonstrated that
    we can use JSON tags to name the fields in the JSON data differently than the
    field names in the struct. We also saw how we can even ignore fields in the struct
    so that they will not appear in the JSON when we marshal it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是演示如何编码 JSON。我们从一个结构体开始，将其编码为 JSON。我们能够通过缩进字段来改变编码，使其更容易阅读。我们还看到了如何改变字段编码到
    JSON 的行为。我们看到，如果结构体字段没有数据，我们可以省略字段以避免将其编码到 JSON 中。我们展示了我们可以使用 JSON 标签以与结构体中字段名不同的名称命名
    JSON 数据中的字段。我们还看到了我们甚至可以忽略结构体中的字段，这样在序列化时它们就不会出现在 JSON 中。
- en: So far, we have dealt with knowing the structure of the JSON beforehand and
    that it is not changing. In the next section, we are going to discuss how to handle
    situations when you get a JSON structure, but that structure can change and is
    not stable.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了在事先知道 JSON 结构且该结构不会改变的情况。在下一节中，我们将讨论如何处理当你得到一个 JSON 结构，但该结构可能会改变且不稳定的情况。
- en: Unknown JSON Structures
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未知 JSON 结构
- en: When we know the JSON structure beforehand, it allows us the flexibility to
    design our structs to match the expected JSON. As we have seen, we can unmarshal
    our JSON values into the destination struct types. Go offers support for encoding
    (marshaling) and decoding (unmarshaling) to and from struct types.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们事先知道 JSON 结构时，这允许我们灵活地设计我们的结构体以匹配预期的 JSON。正如我们所见，我们可以将我们的 JSON 值反序列化到目标结构体类型中。Go
    提供了对结构体类型进行编码（序列化）和解码（反序列化）的支持。
- en: There are situations in which you may not know the JSON structure. For example,
    you may be interacting with a third-party tool that posts metrics for a streaming
    service. This metric is in the format of JSON; however, it is very dynamic and
    serves various customers. They frequently add new metrics for their various clients.
    You want to subscribe to this service and report on these various metrics. The
    problem is that the producer of these metrics changes the JSON data frequently.
    They change it so often, they do not provide the changes, and not on any prescribed
    schedule. You need to be able to perform the analysis on new metrics and old ones,
    and you cannot afford to take your service down to add the new fields from the
    JSON into your struct. You need the ability to continuously report on their metrics
    with minimal interruption to the service.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能不知道JSON的结构。例如，你可能在与一个为流媒体服务发布指标的第三方工具交互。这个指标是以JSON格式存在的；然而，它非常动态，服务于各种客户。他们经常为他们的各种客户添加新的指标。你想要订阅这个服务并报告这些不同的指标。问题是这些指标的提供者经常更改JSON数据。他们更改得如此频繁，以至于他们不提供更改，也没有任何规定的日程。你需要能够对新指标和旧指标进行分析，而且你不能因为要将JSON中的新字段添加到你的结构中而中断你的服务。你需要有能力以最小的服务中断连续报告他们的指标。
- en: If your JSON is dynamic, it will not work decoding it to a struct. So, what
    do you do when you do not know the JSON structure or when it changes frequently?
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的JSON是动态的，将其解码到结构体中就不会起作用。那么，当你不知道JSON结构或者它频繁变化时，你该怎么办？
- en: 'In these cases, we can use `map[string]interface{}`. The keys of the JSON data
    will be the string key of the map. The `empty interface{}` will be the values
    of those JSON keys. Every type implements the empty interface:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们可以使用`map[string]interface{}`。JSON数据的键将是映射的字符串键。`empty interface{}`将是那些JSON键的值。每个类型都实现了空接口：
- en: '![Figure 11.17: Mapping of JSON to a map data type'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17：JSON到映射数据类型的映射'
- en: '](img/B14177_11_17.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_11_17.jpg)'
- en: 'Figure 11.17: Mapping of JSON to a map data type'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：JSON到映射数据类型的映射
- en: The `json.Unmarshal` function will decode the unknown JSON structure into the
    map whose keys are strings and whose values will be empty interfaces. This works
    out well because JSON keys have to be strings.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Unmarshal`函数会将未知的JSON结构解码成键为字符串、值为空接口的映射。这很好，因为JSON键必须是字符串。'
- en: 'Consider the following example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE76]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s break down the code for better understanding:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码以便更好地理解：
- en: '[PRE77]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`jsonData` represents the JSON that we are given but do not know the structure
    of:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonData`代表我们给出的JSON，但我们不知道其结构：'
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Even though we do not know the JSON structure, we can unmarshal it into an interface.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不知道JSON结构，但我们仍然可以将其反序列化到接口中。
- en: The `jsonData` gets unmarshaled into `v`, the empty interface, which will be
    a map.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonData`被反序列化到空接口`v`，它将是一个映射。'
- en: 'The map keys are the strings and the values are empty interfaces. The result
    of printing out `v` is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 映射键是字符串，值是空接口。打印出`v`的结果如下：
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The printing of `map[string]interface{}` does not match the order the data is
    stored. That is because maps are unordered, so their order is not guaranteed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`map[string]interface{}`的打印顺序与数据存储的顺序不匹配。这是因为映射是无序的，所以它们的顺序不能保证。'
- en: 'The Go representation of `v` is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`v`的Go表示如下：'
- en: '[PRE80]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Remember the keys are strings and the values are interfaces. Even when there
    are slices in the JSON, the values become a slice of `interfaces{}`, represented
    as `[]interface{}`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 记住键是字符串，值是接口。即使JSON中有切片，值也会变成`interface{}`的切片，表示为`[]interface{}`。
- en: We learned in the *Chapter 7*, *Interfaces*, that we have the ability to access
    the concrete types. We can do type assertion to access the underlying concrete
    type of `map[string]interface{}`. Let's look at another example where we have
    a variety of data types to work with.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第7章*，*接口*中了解到，我们有访问具体类型的能力。我们可以进行类型断言来访问`map[string]interface{}`的底层具体类型。让我们看看另一个例子，其中我们有许多数据类型可以处理。
- en: 'Exercise 11.03: Analyzing College Class JSON'
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.03：分析大学课程JSON
- en: In this exercise, we are going to analyze data from a college administration
    office and see whether we can replace the current college course grade submission
    application. The problem is that the old system's JSON data is not well documented.
    The data types in the JSON are not known, nor is the structure. In some instances,
    the JSON structure is different. We need to write a program that can analyze an
    unknown JSON structure and, for each field in the structure, print the data type
    and the JSON key-value pair.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将分析来自大学管理办公室的数据，看看我们是否可以替换当前的大学课程成绩提交应用程序。问题是旧系统的 JSON 数据没有很好地记录。JSON
    中的数据类型和结构都不清楚。在某些情况下，JSON 结构是不同的。我们需要编写一个程序，可以分析未知的 JSON 结构，并且对于结构中的每个字段，打印出数据类型和
    JSON 键值对。
- en: 'All directories and files created need to be created within your `$GOPATH`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 所有创建的目录和文件都需要在 `$GOPATH` 内创建：
- en: Create a directory called `Exercise11.03` within a directory called `Chapter11`.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `Chapter11` 的目录下创建一个名为 `Exercise11.03` 的目录。
- en: Create a file called `main.go` inside of `Chapter11/Exercise11.03`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter11/Exercise11.03` 内创建一个名为 `main.go` 的文件。
- en: Using Visual Studio Code, open the newly created `main.go` file.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 打开新创建的 `main.go` 文件。
- en: 'Add the following `package` name and `import` statements:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `package` 名称和 `import` 语句：
- en: '[PRE81]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Create a `main()` function and then assign `jsonData` to a `[]byte` that will
    represent the `JSON` from the college grade submission program:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main()` 函数，然后将 `jsonData` 赋值给一个 `[]byte`，该 `[]byte` 将代表来自大学成绩提交程序的 `JSON`：
- en: '[PRE82]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Check whether the `jsonData` is valid `JSON`. If it is not, print an error
    message and exit the application:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `jsonData` 是否是有效的 `JSON`。如果不是，打印错误消息并退出应用程序：
- en: '[PRE83]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Declare an empty `interface` variable:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个空的 `interface` 变量：
- en: '[PRE84]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Unmarshal `jsonData` into an empty interface. Check for any errors. If there
    is an error, print the error and exit the application:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `jsonData` 解码到空的 `interface` 中。检查是否有任何错误。如果有错误，打印错误并退出应用程序：
- en: '[PRE85]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Perform type switching on each value in the map. Have a case statement for
    `string`, `float64`, `bool`, `[]interface`, and `default` to capture the unknown
    type of a value. Each of the `case` statements should print the data type, the
    key, and the value. Our switch type assertion flow should work as shown in the
    following diagram:![Figure 11.18: Switch type assertion flow'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对映射中的每个值执行类型切换。为 `string`、`float64`、`bool`、`[]interface` 和 `default` 准备一个情况语句来捕获值的未知类型。每个
    `case` 语句应打印数据类型、键和值。我们的类型断言流程应如图所示：![图 11.18：类型断言流程
- en: '](img/B14177_11_18.jpg)'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_11_18.jpg)'
- en: '[PRE86]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Build the program by running `go build` on the command line:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行上运行 `go build` 来构建程序：
- en: '[PRE87]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Correct any errors that are returned and ensure your code matches the code snippet
    at [https://packt.live/2Qr4dNx](https://packt.live/2Qr4dNx).
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修正返回的错误，并确保你的代码与代码片段 [https://packt.live/2Qr4dNx](https://packt.live/2Qr4dNx)
    相匹配。
- en: Run the executable by typing the name of the executable and then hit *Enter*.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过键入可执行文件名然后按 *Enter* 键来运行可执行文件。
- en: 'The output from the type `switch` statement should be as follows:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型 `switch` 语句的输出应如下所示：
- en: '![Figure 11.19: Output of the college class JSON'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.19：大学班级 JSON 的输出'
- en: '](img/B14177_11_19.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_11_19.jpg)'
- en: 'Figure 11.19: Output of the college class JSON'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19：大学班级 JSON 的输出
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output from the map could differ from the preceding example because iterating
    over a map with a range loop is not a sure thing from one iteration to the next.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的输出可能与前面的示例不同，因为使用范围循环迭代映射并不是每次迭代都确定的。
- en: In this exercise, we saw how to parse a JSON structure even if we did not know
    its content. We learned that by unmarshaling the JSON into an empty interface,
    we get the structure of `map[string]interface{}`. The key of the map is the field
    of the JSON and the `interface{}` of the map is the JSON value. We were then able
    to iterate over the map and perform a switch type statement to get the map value's
    type and data, and also the key name.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了即使不知道其内容，如何解析 JSON 结构。我们了解到通过将 JSON 解码到空的 `interface` 中，我们得到 `map[string]interface{}`
    的结构。映射的键是 JSON 的字段，映射的 `interface{}` 是 JSON 的值。然后我们能够遍历映射并执行类型断言语句来获取映射值的类型和数据，以及键名。
- en: 'GOB: Go''s Own Encoding'
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GOB：Go 的自有编码
- en: Go has its own special data encoding protocol called `gob`. You can only use
    `gob` when the encoding and decoding are happening in Go. Being limited to Go
    is only a deal-breaker if you need to communicate with software written in other
    languages. It's common with software written to be used internally in an organization
    for both the encoding and decoding software to be written in the same language.
    As such, it's not a problem in most cases.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有其特有的数据编码协议，称为 `gob`。只有在编码和解码操作发生在 Go 语言环境中时，你才能使用 `gob`。如果需要与其他语言编写的软件进行通信，仅限于
    Go 语言可能成为一项无法逾越的限制。对于组织内部使用的软件，编码和解码软件通常都使用相同的语言编写，因此这种情况并不常见。
- en: If you can use it, gob gives you exceptionally high performance and efficiency.
    For example, JSON is a string-based protocol that needs to be useable in any programming
    language. This limits what's possible with JSON and protocols like it. `Gob`,
    on the other hand, is a binary-based protocol, and gob only needs to work for
    Go users. This frees gob to become a space- and processing-efficient encoding
    protocol while still being easy to use.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以使用 `gob`，它将为你提供异常高的性能和效率。例如，JSON 是一种基于字符串的协议，它需要在任何编程语言中都是可用的。这限制了 JSON
    和类似协议所能实现的功能。另一方面，`Gob` 是一种基于二进制的协议，并且 `gob` 只需要为 Go 用户工作。这使得 `gob` 成为一个空间和处理器效率高的编码协议，同时仍然易于使用。
- en: Gob doesn't require any configuration or setup to use. Also, gob doesn't require
    the sender and receiver's data model to match exactly. So not only is it efficient
    and quick, it's also easy to use.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gob` 不需要任何配置或设置即可使用。此外，`gob` 不要求发送者和接收者的数据模型完全匹配。因此，它不仅高效快捷，而且易于使用。'
- en: While Go is strict when it comes to types, gob is not. Gob treats all numbers
    the same be they `int` or `float`. You can use pointers with gob and when encoding,
    gob will pull the value from the pointer for you. Gob will also happily set values
    to pointer or value types regardless of whether the value was encoded from a pointer
    or a value.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 在类型方面非常严格，但 `gob` 则不然。`gob` 将所有数字视为相同，无论是 `int` 还是 `float`。你可以使用指针与 `gob`
    一起使用，并且在编码时，`gob` 将为你从指针中提取值。`gob` 还会愉快地将值设置为指针或值类型，无论值是从指针还是值编码而来。
- en: Gob can encode complex types such as structs. Gob's flexibility continues because
    it doesn't require that the properties on the structs match. If there is a matching
    property on the struct it's decoding to, it'll use it; if not, then it'll discard
    the value. This fact gives the added benefit that you can add new properties without
    worrying about it breaking your legacy services.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gob` 可以编码复杂类型，如结构体。`Gob` 的灵活性继续存在，因为它不要求结构体上的属性匹配。如果结构体上存在要解码的匹配属性，它将使用它；如果没有，则它将丢弃该值。这一事实还带来了额外的好处，即你可以添加新的属性，而无需担心它会破坏你的旧服务。'
- en: When using gob for communication between Go web services, it's common practice
    to use Go's `rpc` package to handle the networking aspects of the communication
    between the services. The `rpc` package provides a simple way to make calls to
    other Go web services, and, by default, the `rpc` package uses gob to handle encoding
    duties. This means you'll get all the benefits of using gob without having to
    do any extra work.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Go 网络服务之间使用 `gob` 进行通信时，通常的做法是使用 Go 的 `rpc` 包来处理服务之间的网络通信方面。`rpc` 包提供了一种简单的方式来调用其他
    Go 网络服务，并且默认情况下，`rpc` 包使用 `gob` 来处理编码任务。这意味着你将获得使用 `gob` 的所有好处，而无需进行任何额外的工作。
- en: Using `gob` for `rpc` service-to-service communication will result in lower
    latency communications. Low latency communications are what allows for modern
    software architecture designs, such as microservices.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gob` 进行服务间通信的 `rpc` 服务将导致通信延迟降低。低延迟通信是现代软件架构设计，如微服务，得以实现的关键。
- en: To encode data using the gob protocol in Go directly, you use Go's `gob` package.
    The package is Go's implementation of the gob protocol. When encoding data using
    this package, it'll return a `byte` slice. These byte slices are common in code
    for when dealing with files and networks. This means there are already a great
    number of helper functions for you to take advantage of.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Go 中直接使用 `gob` 协议进行数据编码，你使用 Go 的 `gob` 包。该包是 Go 对 `gob` 协议的实现。当使用此包进行编码时，它将返回一个
    `byte` 切片。这些字节切片在处理文件和网络时在代码中很常见。这意味着已经有许多辅助函数供你利用。
- en: Gob is not limited to use only in networked solutions. You can also use gob
    to store data in files. A common use case for writing Go data to files is for
    making data resilient to server restarts. In modern cloud server deployments,
    if a server is starting to have problems, it gets killed, and your application
    is started up again on a new server. If you have any important data that's only
    in memory, it'll be lost. Prevent this loss by writing that data to a mounted
    filesystem attached to the server. When the replacement server starts, it attaches
    to the same filesystem, and on startup, your application recovers the data from
    the filesystem.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Gob不仅限于在网络解决方案中使用。你还可以使用gob将数据存储在文件中。将Go数据写入文件的一个常见用例是使数据对服务器重启具有容错性。在现代云服务器部署中，如果服务器开始出现问题，它会被杀死，你的应用程序会在新的服务器上重新启动。如果你有任何仅在内存中的重要数据，它将会丢失。通过将数据写入附加到服务器的挂载文件系统来防止这种损失。当替换服务器启动时，它会连接到相同的文件系统，在启动时，你的应用程序将从文件系统恢复数据。
- en: One example of using files for data resilience is in transaction-based workloads.
    In a transaction-based workload, losing a single transaction can be a big problem.
    To prevent this from happening, a backup of the transaction is written to disk
    while your application is processing it. If a restart were to happen, your application
    would check these backups to ensure everything's in order. Using gob to encode
    this data would ensure it's written to the filesystem as soon as possible, minimizing
    the chance of data loss.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件进行数据容错的一个例子是在基于事务的工作负载中。在基于事务的工作负载中，丢失单个事务可能是一个大问题。为了防止这种情况发生，在应用程序处理事务的同时，将事务的备份写入磁盘。如果发生重启，应用程序会检查这些备份以确保一切正常。使用gob来编码这些数据将确保它们尽快写入文件系统，从而最大限度地减少数据丢失的可能性。
- en: Another use case is cold-start cache priming. When using a cache for performance
    reasons, you need to store it in memory. It's not uncommon for the size of this
    cache to grow to be gigabytes in size. A server restart means this cache is lost
    and needs reloading from the database. If a lot of servers get restarted all at
    once, it causes a cache stampede, which could crash the database. A way to avoid
    this overload situation is to make a copy of the cache and write it to a mounted
    filesystem. Then, when your application starts up, it would prime its cache from
    the files and not the database. Using gob to encode this data would allow much
    more efficient use of disk space, which, in turn, allows faster reading and more
    efficient decoding. This also means your server gets back online sooner.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是冷启动缓存预填充。当出于性能原因使用缓存时，你需要将其存储在内存中。这个缓存的规模增长到几GB大小并不罕见。服务器重启意味着这个缓存丢失，需要从数据库重新加载。如果很多服务器同时重启，会导致缓存踩踏，这可能会使数据库崩溃。避免这种过载情况的一种方法是将缓存的一个副本写入挂载文件系统。然后，当你的应用程序启动时，它会从文件而不是数据库中预填充其缓存。使用gob来编码这些数据将允许更有效地使用磁盘空间，从而反过来允许更快的读取和更有效的解码。这也意味着你的服务器可以更快地恢复在线状态。
- en: 'Exercise 11.04: Using gob to Encode Data'
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.04：使用gob编码数据
- en: In this exercise, we're going to encode and transmit, then decode a transaction
    using gob. We're going to send a banking transaction from a client to a server
    using a dummy network. The transaction is a struct that also has an embedded user
    struct. This shows that complex data can be easily encoded.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用gob编码和传输一个事务，然后解码。我们将使用一个虚拟网络将一个银行事务从客户端发送到服务器。这个事务是一个结构体，它还包含一个嵌入的用户结构体。这表明复杂的数据可以很容易地编码。
- en: To show the flexibility of the `gob` protocol, the client and server structs
    don't match in several ways. For example, the client's user is a pointer, but
    the server's user is not. The amounts are of different float types, and the client
    is a `float64` while the server is a `*float32`. Some of the fields are missing
    in the server types that are present in the client types.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`gob`协议的灵活性，客户端和服务器结构体在几个方面不匹配。例如，客户端的用户是一个指针，而服务器的用户不是。金额是不同的浮点类型，客户端是`float64`，而服务器是`*float32`。一些字段在服务器类型中缺失，而在客户端类型中存在。
- en: We'll be using the `bytes` package to store our encoded data. This shows that
    once encoded, you can use the standard library to work with the gob binary data.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`bytes`包来存储我们的编码数据。这表明一旦编码，你可以使用标准库来处理gob二进制数据。
- en: '**Steps:**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤：**'
- en: Define `client` structs.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`client`结构体。
- en: Define `server` structs that differ in a number of ways.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义具有多种不同方式的`server`结构体。
- en: Create a byte buffer to act as a dummy network.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个字节数组缓冲区作为虚拟网络。
- en: Create a client value with some dummy data.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含一些模拟数据的客户端值。
- en: Encode the client value.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码客户端值。
- en: Write the encoded data to the dummy network.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编码后的数据写入模拟网络。
- en: Create a function that acts as the server.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个充当服务器的函数。
- en: Read the data from the dummy network.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模拟网络中读取数据。
- en: Decode the data.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码数据。
- en: Print the decoded data to the console.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解码后的数据打印到控制台。
- en: 'Let''s get started with the exercise:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始这个练习：
- en: Create a directory called *Exercise11.04* within a directory called `Chapter11`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`Chapter11`的目录中创建一个名为*Exercise11.04*的目录。
- en: Create a file called `main.go` inside of *Chapter11/Exercise11.04*.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*Chapter11/Exercise11.04*中创建一个名为`main.go`的文件。
- en: Using Visual Studio Code, open the newly created `main.go` file.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio Code打开新创建的`main.go`文件。
- en: 'Add the following package name and import statements:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下包名和导入语句：
- en: '[PRE88]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a `struct` to be our client-side user model:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示客户端用户模型的`struct`：
- en: '[PRE89]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a `struct` to be our client-side transaction. `Tx` is a common shorthand
    for transaction:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示客户端事务的`struct`。`Tx`是事务的常用缩写：
- en: '[PRE90]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a `struct` to be our server-side user model. This model doesn''t match
    the client model because it doesn''t have the `Name` property:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示服务器端用户模型的`struct`。这个模型与客户端模型不匹配，因为它没有`Name`属性：
- en: '[PRE91]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a `struct` to be our server-side transaction. Here, the user is not
    a pointer. The amount is a pointer, however, and the pointer is for a `float32`,
    not a `float64`:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示服务器端事务的`struct`。在这里，用户不是一个指针。金额是一个指针，但这个指针是指向`float32`的，而不是`float64`：
- en: '[PRE92]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create the `main()` function:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE93]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create the dummy network, which is a buffer from the `bytes` package:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模拟网络，它是一个来自`bytes`包的缓冲区：
- en: '[PRE94]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create the dummy data using the client-side structs:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用客户端`struct`创建模拟数据：
- en: '[PRE95]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Encode the data. The target for the encoded data is our dummy network:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码数据。编码数据的目标是我们的模拟网络：
- en: '[PRE96]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Check for errors and exit if any are found:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查错误，如果发现任何错误则退出：
- en: '[PRE97]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Send the data to the server:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据发送到服务器：
- en: '[PRE98]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Check for errors and exit if any are found:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查错误，如果发现任何错误则退出：
- en: '[PRE99]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Print the decoded data to the console:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解码后的数据打印到控制台：
- en: '[PRE100]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Close the `main()` function:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE101]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Create our `sendToServer` function. This function takes a single `io.Reader`
    interface and returns a server-side transaction and an `error`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`sendToServer`函数。这个函数接受一个单一的`io.Reader`接口，并返回一个服务器端事务和一个`error`：
- en: '[PRE102]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a variable to be the target for decoding:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量作为解码的目标：
- en: '[PRE103]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Create a decoder with the network as the source:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络作为源创建一个解码器：
- en: '[PRE104]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Decode and capture any errors:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码并捕获任何错误：
- en: '[PRE105]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Return the decoded data and any errors captured:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回解码后的数据和捕获到的任何错误：
- en: '[PRE106]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Close the function:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE107]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Build the program by running `go build` at the command line:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行中运行`go build`来构建程序：
- en: '[PRE108]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Run the executable by typing the name of the executable and hitting *Enter*.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入可执行文件名并按*Enter*键来运行可执行文件。
- en: 'The output from the type switch statement should be as follows:'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型切换语句的输出应该如下所示：
- en: '![Figure 11.20: Gob output'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20：Gob输出]'
- en: '](img/B14177_11_20.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_11_20.jpg](img/B14177_11_20.jpg)'
- en: 'Figure 11.20: Gob output'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：Gob输出
- en: In this exercise, we encoded the data using the client types, `sent` it to the
    server, and dumped out what the server decoded. In what we get back from the server,
    we can see it's using different types, that the user has an ID but no name, and
    that `Amount` is a 32-bit float pointer type.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用客户端类型编码了数据，将其`sent`到服务器，并输出了服务器解码的内容。从服务器返回的内容中，我们可以看到它使用了不同的类型，用户有一个ID但没有名字，并且`Amount`是一个32位的浮点指针类型。
- en: We can see how easy and flexible gob can be to work with. Gob is also a great
    choice for performance when you need to communicate between servers, but both
    servers will need to be written in Go to be able to take advantage of these features.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到gob多么容易和灵活，可以用来工作。当需要在服务器之间进行通信时，gob也是一个很好的性能选择，但两个服务器都需要用Go编写才能利用这些功能。
- en: In the next activity, we're going to test what we've learned so far with JSON.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将使用JSON测试我们迄今为止学到的内容。
- en: 'Activity 11.01: Mimicking a Customer Order Using JSON'
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动内容11.01：使用JSON模拟客户订单
- en: In this activity, we are going to mimic a customer order. An online e-commerce
    portal needs to accept customer orders over its web application. As the customer
    browses through the site, the customer will add items to their order. This web
    application will need to be able to take the JSON and add orders to the JSON.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将模拟客户订单。一个在线电子商务门户需要通过其Web应用程序接受客户订单。当客户浏览网站时，客户将向订单添加商品。这个Web应用程序需要能够将JSON添加到JSON中。
- en: '**Steps:**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤：**'
- en: Create an `address` `struct` with all the exportable fields (the `Street` string,
    the `City` string, the `State` string, and the `Zipcode` int).
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有可导出字段的`address`结构体（`Street`字符串、`City`字符串、`State`字符串和`Zipcode`整数）。
- en: Create an `item` `struct` with all its exportable fields (the `Name` string,
    the `Description` string, the `Quantity` int, and the `Price` int). The description
    field should not show up in the JSON if it has no data.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有可导出字段的`item`结构体（`Name`字符串、`Description`字符串、`Quantity`整数和`Price`整数）。如果描述字段没有数据，则不应在JSON中显示。
- en: Create an `order` `struct` with all its exportable fields (the `TotalPrice`
    int, the `IsPaid` bool, the `Fragile` bool, and `OrderDetail []item`). The `Fragile`
    field should not show up in the JSON if it has no data.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有可导出字段的`order`结构体（`TotalPrice`整数、`IsPaid`布尔值、`Fragile`布尔值和`OrderDetail
    []item`）。如果`Fragile`字段没有数据，则不应在JSON中显示。
- en: Create a `customer` `struct` with all its the `UserName` string, the `Password`
    string, the `Token` string, the `ShipTo` address, and the `PurchaseOrder` order).
    The `Password` and `Token` fields should never appear in the JSON.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有字段的`customer`结构体（`UserName`字符串、`Password`字符串、`Token`字符串、`ShipTo`地址和`PurchaseOrder`订单）。`Password`和`Token`字段永远不会出现在JSON中。
- en: 'The application should check that `jsonData` is valid JSON. The following code
    snippet is some example JSON to use for a customer order for our application:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序应检查`jsonData`是否是有效的JSON。以下代码片段是我们应用程序客户订单的一些示例JSON：
- en: '[PRE109]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The application should decode the `jsonData` into the customer struct.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序应将`jsonData`解码到客户结构体中。
- en: Add two additional items to the order include the `TotalPrice` for all the items
    in the order, whether the order has any fragile items, and whether the items are
    all paid for in full.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在订单中添加两个额外的项目，包括订单中所有项目的`TotalPrice`，订单是否有易碎物品，以及所有物品是否已全额支付。
- en: Print the customer order so that it is easily readable.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印客户订单，使其易于阅读。
- en: 'The expected output from the application is as follows:'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序预期的输出如下：
- en: '![Figure 11.21: Customer order printout'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.21：客户订单打印输出'
- en: '](img/B14177_11_21.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_11_21.jpg)'
- en: 'Figure 11.21: Customer order printout'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：客户订单打印输出
- en: We have seen how to encode and decode complex types such as slices in JSON.
    We have checked whether the JSON was valid JSON. We also have seen how to control
    which fields in the struct are displayed, and whether the fields that do not have
    data were able to omit them from the JSON. When we printed out the JSON, we were
    able to print it in a format that is easy to read.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将复杂数据类型如切片编码和解码到JSON中。我们已经检查了JSON是否是有效的JSON。我们还看到了如何控制结构体中显示的字段，以及是否能够从JSON中省略没有数据的字段。当我们打印JSON时，我们能够以易于阅读的格式打印它。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 732.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第732页找到。
- en: Summary
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we studied what JSON is and how we can use Go to store JSON
    in our structs.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们研究了JSON是什么以及我们如何使用Go将JSON存储在我们的结构体中。
- en: 'JSON is used by many programming languages including Go. JSON is made up of
    key-value pairs. These key-value pairs can be any of the following types: string,
    number, object, array, Boolean, or null.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: JSON被许多编程语言包括Go使用。JSON由键值对组成。这些键值对可以是以下任何一种类型：字符串、数字、对象、数组、布尔值或null。
- en: Go's standard library provides many capabilities that make working with JSON
    easy. This includes the ability to decode JSON data into structs. It also has
    the ability to encode structs into JSON.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Go的标准库提供了许多使处理JSON变得容易的功能。这包括将JSON数据解码到结构体的能力。它还具有将结构体编码到JSON的能力。
- en: We have seen that, through the use of JSON tags, we have greater flexibility
    and control over how the encoding and decoding of JSON occurs. These tags give
    us the ability to name the JSON key name, ignore fields and not encode them into
    JSON, and omit fields when they are empty.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过使用JSON标签，我们在JSON的编码和解码方面有了更大的灵活性和控制权。这些标签使我们能够命名JSON键名，忽略字段并且不将其编码到JSON中，以及当字段为空时省略字段。
- en: The Go standard library gives us the ability to determine how to print in an
    easy to read format by using the `json.MarshalIndent()` function. We have also
    seen how to decode JSON structures when we do not know the format of the JSON
    ahead of time. All of these features and many others demonstrate the powerful
    functionality that comes in the Go standard library.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库通过使用`json.MarshalIndent()`函数，为我们提供了以易于阅读的格式打印的能力。我们同时也看到了在事先不知道JSON格式的情况下如何解码JSON结构。所有这些特性和许多其他特性都展示了Go标准库强大的功能。
- en: In the next chapter, we will be looking at files and systems. The chapter will
    go over how to interact with the filesystem, including creating and modifying
    files. You will also learn about file permissions and creating a command-line
    application that uses various flags and arguments. We will also look at another
    format for storing data called CSV. All of this and more in the following chapter.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨文件和系统。这一章将介绍如何与文件系统交互，包括创建和修改文件。你还将了解文件权限以及创建使用各种标志和参数的命令行应用程序。我们还将探讨另一种存储数据格式的CSV。下一章将包含所有这些内容以及更多。
