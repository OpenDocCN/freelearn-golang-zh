- en: 15\. HTTP Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. HTTP 服务器
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to different ways of creating an HTTP server in
    order to accept requests from the internet. You will be able to understand how
    a website can be accessed and how it can respond to a form. You will also learn
    how to respond to requests from another software program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍创建 HTTP 服务器以接受来自互联网的请求的不同方法。您将能够理解网站是如何被访问的，以及它如何响应一个表单。您还将学习如何响应来自另一个软件程序的请求。
- en: You'll be able to create an HTTP server rendering a simple message. You will
    learn how to create an HTTP server rendering complex data structures which serves
    local static files. Further you will create an HTTP server rendering dynamic pages
    and work with different ways of routing. By the end of this chapter you will also
    learn to create a REST service, accept data through a form, and accept JSON data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够创建一个渲染简单消息的 HTTP 服务器。您将学习如何创建一个渲染复杂数据结构并服务于本地静态文件的 HTTP 服务器。进一步，您将创建一个渲染动态页面并处理不同路由方式的
    HTTP 服务器。到本章结束时，您还将学习如何创建 REST 服务，通过表单接收数据，以及接收 JSON 数据。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how to contact a remote server in order to obtain
    some information, but now we will dig into how the remote server is created, so
    if you already know how to request information, now you will see how to reply
    to these requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何联系远程服务器以获取一些信息，但现在我们将深入了解远程服务器是如何创建的，所以如果你已经知道如何请求信息，现在你将看到如何回复这些请求。
- en: A web server is a program that uses the HTTP protocol, hence, the HTTP server,
    to accept requests from any HTTP client (web browser, another program, and so
    on) and respond to them with an appropriate message. When we browse the internet
    with our browser, it will be an HTTP server that will send an HTML page to our
    browser and we will be able to see it. In some other cases, a server will not
    return an HTML page but a different message, appropriate to the client.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器是一个使用 HTTP 协议的程序，因此，HTTP 服务器用于接受来自任何 HTTP 客户端（网页浏览器、另一个程序等）的请求，并以适当的消息响应它们。当我们用浏览器浏览互联网时，它将是一个
    HTTP 服务器，它会向我们的浏览器发送一个 HTML 页面，我们就能看到它。在某些其他情况下，服务器不会返回一个 HTML 页面，而是返回一个适合客户端的不同消息。
- en: Some HTTP servers provide an API that can be consumed by another program. Think
    of when you want to register with a website, and you are asked if you want to
    sign up through Facebook or Google. This means that the website you want to register
    with will consume a Google or Facebook API to get your details. These APIs generally
    respond with a structured text, which is a text representing a complex data structure.
    The way these servers expect the requests can be different. Some expect the same
    type of structured messages they return, while some provide what is called a REST
    API, which is quite strict with the HTTP methods used and expects inputs in the
    form of URL parameters or values, like the ones in a web form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HTTP 服务器提供了一个可以被另一个程序使用的 API。想想当你想要注册一个网站时，你会被问是否想要通过 Facebook 或 Google 注册。这意味着你想要注册的网站将消耗一个
    Google 或 Facebook API 来获取你的详细信息。这些 API 通常会以结构化文本的形式响应，这是一种表示复杂数据结构的文本。这些服务器期望请求的方式可能不同。有些期望返回相同类型的结构化消息，而有些提供所谓的
    REST API，它对使用的 HTTP 方法非常严格，并期望以 URL 参数或值的形式输入，就像网页表单中的那些。
- en: How to Build a Basic Server
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何构建基本服务器
- en: The simplest HTTP server that we can create is a Hello World server. This is
    a server that will return a simple message "Hello World" and will not do anything
    else. It is not very useful, but it is a starting point to see what Go default
    packages give us and is the basis for any other more complex server. The aim is
    to have a server that runs on a specific port on your machine's localhost and
    accepts any path under it. Accepting any path means that when you test the server
    with your browser, it will always return the "Hello World" message and a status
    code of 200\. Of course, we could return any other message, but, for historical
    reasons, the simplest project you learn when you study programming is always some
    sort of software returning the message "Hello World". In this case, we will see
    how this can be done and then visualized in a normal browser, before perhaps being
    put on the internet and shared with billions of users, although users may, in
    practice, prefer a more useful server. Let's say this is the most basic HTTP server
    you can create.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建的最简单的HTTP服务器就是一个Hello World服务器。这是一个将返回简单消息“Hello World”且不会做其他任何事情的服务器。它并不非常实用，但它是了解Go默认包提供的内容的起点，也是任何更复杂服务器的基石。目标是创建一个在您的机器的localhost上的特定端口运行的服务器，并接受其下的任何路径。接受任何路径意味着当您用浏览器测试服务器时，它总是会返回“Hello
    World”消息和状态码200。当然，我们可以返回任何其他消息，但出于历史原因，您在学习编程时学习的最简单的项目总是某种返回“Hello World”消息的软件。在这种情况下，我们将看到如何实现并在普通浏览器中可视化，然后可能将其放在互联网上并与数十亿用户分享，尽管在实践中，用户可能更喜欢一个更有用的服务器。让我们说这是您可以创建的最基本的HTTP服务器。
- en: HTTP Handler
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP处理器
- en: 'In order to react to an HTTP request, we need to write something that, we usually
    say, handles the request; hence, we call this something a handler. In Go, we have
    several ways to do that, and one is to implement the handler interface of the
    http package. This interface has one method that is pretty self-explanatory, and
    this is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应HTTP请求，我们需要编写一些通常所说的处理请求的内容；因此，我们称这个内容为处理器。在Go语言中，我们有几种实现处理器接口的方法，其中之一是实现http包的处理器接口。这个接口有一个相当直观的方法，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, whenever we need to create a handler for HTTP requests, we can create a
    struct including this method and we can use it to handle an HTTP request. For
    example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们需要为HTTP请求创建一个处理器时，我们都可以创建一个包含此方法的struct，并可以使用它来处理HTTP请求。例如：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is a valid HTTP handler and you can use it this way:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的HTTP处理器，您可以使用它这样：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `ListenAndServe()` is a function that will use our handler to serve the
    requests; any struct implementing the handler interface will be fine. However,
    we need to let our server do something.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ListenAndServe()`是一个函数，它将使用我们的处理器来处理请求；任何实现了处理器接口的结构体都是可以的。然而，我们需要让我们的服务器做些事情。
- en: 'As you can see, the `ServeHTTP` method accepts a `ResponseWriter` and a `Request`
    object. You can actually use them in order to capture parameters from the request
    and write messages to the response. The simplest thing, for example, is to let
    our server return a message:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ServeHTTP`方法接受一个`ResponseWriter`和一个`Request`对象。您实际上可以使用它们来从请求中捕获参数并将消息写入响应。例如，最简单的事情就是让我们的服务器返回一条消息：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ListenAndServe` method might return an error. If this happens, we most
    likely would like the execution of our program to halt, so one common practice
    is to wrap this function call with a fatal log:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenAndServe`方法可能会返回一个错误。如果发生这种情况，我们很可能希望程序执行停止，因此一个常见的做法是将这个函数调用用致命日志包装起来：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will halt the execution and print the error message returned by the `ListenAndServe`
    function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使执行停止并打印出`ListenAndServe`函数返回的错误信息。
- en: 'Exercise 15.01: Creating a Hello World Server'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.01：创建一个Hello World服务器
- en: Let's start building a simple Hello World HTTP server on the basis of what you've
    learned in the previous block.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前的学习内容出发，开始构建一个简单的Hello World HTTP服务器。
- en: 'The first thing to do is to create a folder called `hello-world-server`. You
    can do this via the command line or you can create it with your favorite editor.
    Inside the folder, create a file called `main.go`. We will not use any external
    library here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个名为`hello-world-server`的文件夹。您可以通过命令行或使用您喜欢的编辑器创建它。在文件夹内，创建一个名为`main.go`的文件。在这里，我们不会使用任何外部库：
- en: 'Add the package name:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包名：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tells the compiler that this file is an entry point for a program that
    can be executed.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉编译器该文件是一个程序的入口点，可以执行。
- en: 'Import the necessary packages:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的包：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, create a `handler`, the struct that will handle the requests:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`handler`，这个结构将处理请求：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have our handler, create the `main()` function, which will start
    the server and produce a web page with our message:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`handler`，创建`main()`函数，它将启动服务器并生成带有我们消息的网页：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The entire file should look like this:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个文件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you now go to your Terminal, inside your `hello-world-server` folder, and
    type in the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在进入你的终端，在你的`hello-world-server`文件夹内，并输入以下命令：
- en: '[PRE10]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should just see nothing; the program has started.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该什么也看不到；程序已经开始运行。
- en: 'If you now open your browser at the following address:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在在以下地址打开你的浏览器：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a page with a big message:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个带有大消息的页面：
- en: '![Figure 15.01: Hello world server'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.01：Hello world服务器'
- en: '](img/B14177_15_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_01.jpg)'
- en: 'Figure 15.01: Hello world server'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.01：Hello world服务器
- en: 'If you now try to change path and go to */page1*, you will again see the following
    message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试更改路径并访问*/page1*，你将再次看到以下信息：
- en: '![Figure 15.02: Hello world server sub-pages'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.02：Hello world服务器子页面'
- en: '](img/B14177_15_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_02.jpg)'
- en: 'Figure 15.02: Hello world server sub-pages'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.02：Hello world服务器子页面
- en: Congratulations! This is your first HTTP server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是你的第一个HTTP服务器。
- en: In this exercise, we have created a basic hello world server, which returns
    the message "Hello World" in response to any request on any sub-address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个基本的hello world服务器，它对任何子地址上的任何请求都返回“Hello World”消息。
- en: Simple Routing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单路由
- en: 'The server built just now in the previous exercise does not do much. It just
    responds with a message and we cannot ask anything else. Before we can make our
    server more dynamic, let''s imagine we want to create an online book and we want
    to be able to select a chapter just changing the URL. At the moment, if we browse
    the following pages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中刚刚构建的服务器并不做什么。它只是响应一条消息，我们无法询问其他任何内容。在我们能够使我们的服务器更加动态之前，让我们想象我们想要创建一个在线书籍，并且我们想要能够通过更改URL来选择章节。目前，如果我们浏览以下页面：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We always see the same message, but we now want to associate different messages
    with these different paths on our server. We will do this by introducing some
    simple routing to our server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是看到相同的信息，但现在我们想要将不同的消息与服务器上的不同路径关联起来。我们将通过向服务器引入一些简单的路由来实现这一点。
- en: 'A path is what you see after the `8080` in the URL; it can be one number, a
    word, a set of numbers or character groups separated by a "/". In order to do
    this, we will use another function of the net/http package, which is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是你看到URL中的`8080`之后的内容；它可以是单个数字、一个单词、一组由斜杠分隔的数字或字符组。为了做到这一点，我们将使用net/http包的另一个函数，它是：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the pattern is the path we want to be served by the `handler` function.
    Note how the `handler` function signature has the exact same parameters as the
    `ServeHTTP` method, which you added to the `hello` struct in the previous exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，模式是我们想要由`handler`函数服务的路径。注意`handler`函数签名与你在上一个练习中添加到`hello`结构中的`ServeHTTP`方法具有完全相同的参数。
- en: As an example, the server built in *Exercise 15.01* is not very useful, but
    we can transform it into something much more useful with the addition of pages
    other than the `hello world` one, and, in order to do so, we need to do some basic
    routing. The aim here is to write a book, and the book must have a welcome page
    with the title, and a first chapter. The book title is `hello world`, so we can
    keep what we did before. The first chapter will have a heading stating `Chapter
    1`. The book is a work in progress, so it does not matter that the content is
    still poor; what we require is the ability to select the chapter, and we will
    then add the content later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*练习15.01*中构建的服务器并不很有用，但我们可以通过添加除了`hello world`之外的其他页面来将其转变为更有用的东西，为了做到这一点，我们需要做一些基本的路由。这里的目的是写一本书，这本书必须有一个带有标题的欢迎页面，以及第一章。书名是`hello
    world`，所以我们可以保留之前所做的工作。第一章将有一个标题声明`第一章`。这本书还在进行中，所以内容仍然很贫乏并不重要；我们需要的是能够选择章节的能力，然后我们将在稍后添加内容。
- en: 'Exercise 15.02: Routing Our Server'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.02：路由我们的服务器
- en: 'We are now going to modify the code in *Exercise 15.01* to support different
    paths. If you haven''t gone through the previous exercise, do it now so that you''ll
    have a basic framework for this exercise:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改*练习15.01*中的代码以支持不同的路径。如果你还没有完成前面的练习，现在就做，这样你将有一个这个练习的基本框架：
- en: 'Create a new folder and a `main.go` file and add the code from the previous
    exercise to the definition of the `main` function:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个 `main.go` 文件并将之前练习中的代码添加到 `main` 函数的定义中：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `main()` function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, use `handle` to route "`/chapter1`" through a `handlefunc()` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `handle` 将 "`/chapter1`" 通过一个 `handlefunc()` 函数路由：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that we associate the path, `/chapter1`, with a function that returns
    a specific message.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们将路径 `/chapter1` 与返回特定信息的函数关联起来。
- en: 'Finally, set the server to listen to a port and to run the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将服务器设置为监听端口并运行以下命令：
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, save your file and run the server again with:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存您的文件并再次使用以下命令运行服务器：
- en: '[PRE18]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, go to your browser and load the following URLs:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到您的浏览器并加载以下URL：
- en: '`http://localhost:8080`'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8080`'
- en: '`http://localhost:8080/chapter1`'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/chapter1`'
- en: 'The output for the home page is shown in the following screenshot:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了主页的输出：
- en: '![Figure 15.03: Multi-page server – home page'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.03：多页服务器 – 主页'
- en: '](img/B14177_15_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_03.jpg)'
- en: 'Figure 15.03: Multi-page server – home page'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.03：多页服务器 – 主页
- en: 'And the output for page 1 is shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 页面1的输出如下截图所示：
- en: '![Figure 15.04: Multi-page server – chapter 1'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.04：多页服务器 – 第1章'
- en: '](img/B14177_15_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_04.jpg)'
- en: 'Figure 15.04: Multi-page server – chapter 1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.04：多页服务器 – 第1章
- en: 'Note that they both still display the same message. This happens because we
    are setting our `hello` as the handler for our server, and this overrides our
    specific path. We can modify our code to look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们仍然显示相同的信息。这是因为我们将我们的 `hello` 设置为服务器的处理器，这覆盖了我们的特定路径。我们可以修改我们的代码如下：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What happened here is that you removed the `hello` handler from being the main
    handler for our server and you associated this handler with the main `/` path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这里的是，您从我们的服务器的主要处理器中移除了 `hello` 处理器，并将其与主要的 `/` 路径关联起来：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, you associated a `handler` function with the specific `/chapter1` path:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将一个 `handler` 函数与特定的 `/chapter1` 路径关联：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if you stop and then run our server again, you will see that the `/chapter1`
    path now returns the new message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您停止并再次运行我们的服务器，您将看到 `/chapter1` 路径现在返回新的信息：
- en: '![Figure 15.05: Multi-page server repeated – chapter 1'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.05：多页服务器重复 – 第1章'
- en: '](img/B14177_15_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_05.jpg)'
- en: 'Figure 15.05: Multi-page server repeated – chapter 1'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.05：多页服务器重复 – 第1章
- en: In the meantime, all the other paths return the old `Hello World` message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，所有其他路径都返回旧的 `Hello World` 信息。
- en: '![Figure 15.06: Multi-page server – base page'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.06：多页服务器 – 基础页面'
- en: '](img/B14177_15_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_06.jpg)'
- en: 'Figure 15.06: Multi-page server – base page'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.06：多页服务器 – 基础页面
- en: '![Figure 15.07: The page that is not set returns the default setting'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.07：未设置的页面返回默认设置'
- en: '](img/B14177_15_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_07.jpg)'
- en: 'Figure 15.07: The page that is not set returns the default setting'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.07：未设置的页面返回默认设置
- en: Handler versus Handler Function
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器与处理器函数
- en: As you may have noticed, we used two different functions before, `http.Handle`
    and `http.HandleFunc` , both of which have a path as their first parameter, but
    which differ in terms of the second parameter. These two functions both ensure
    that a specific path is handled by a function. `http.Handle`, however, expects
    `http.Handler` to handle the path, while `http.HandleFunc` expects a function
    to do the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到的，我们之前使用了两个不同的函数，`http.Handle` 和 `http.HandleFunc`，这两个函数都以路径作为它们的第一个参数，但在第二个参数方面有所不同。这两个函数都确保特定的路径由一个函数处理。然而，`http.Handle`
    期望 `http.Handler` 处理路径，而 `http.HandleFunc` 期望一个函数来做同样的事情。
- en: 'As we''ve seen before, `http.Handler` is any struct having a method with this
    signature:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`http.Handler` 是任何具有此签名的结构体：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, in both cases, there will always be a function with `http.ResponseWriter`
    and `*http.Request` as parameters that will handle the path. As to when one or
    the other might be chosen may just be a matter of personal preference in many
    cases, but it might be important, when creating a complex project, for example,
    to choose the right method. Doing so will ensure that the structure of the project
    is optimal. Different routes may appear better organized if handled by handlers
    belonging to different packages, or might have to perform very few actions, as
    in our previous case; and a simple function might prove to be the ideal choice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在两种情况下，都始终会有一个以 `http.ResponseWriter` 和 `*http.Request` 为参数的函数来处理路径。至于何时选择其中一个，在很多情况下可能只是个人偏好的问题，但在创建复杂项目时，例如，选择正确的方法可能很重要。这样做将确保项目的结构是最优的。不同的路由如果由属于不同包的处理程序处理，可能会显得更有组织，或者可能需要执行非常少的操作，就像我们之前的例子一样；而一个简单的函数可能就是理想的选择。
- en: In general, for simple projects where you have a handful of simple pages, you
    may opt for `HandleFunc`. For example, let's say you want to have static pages
    and there is no complex behavior in each page. In this case, it would be an overkill
    to use an empty struct just for returning a static text. The handler is more appropriate
    whenever you need to set some parameters, or if you want to keep track of something.
    As a general rule, let's say that if you have a counter, a `Handler` is the best
    choice because you can initialize a `struct` with a count of 0 and then increment
    it, but we will see this in *Activity 15.01*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于只有几个简单页面的简单项目，你可以选择 `HandleFunc`。例如，假设你想要有静态页面，并且每个页面没有复杂的行为。在这种情况下，仅仅为了返回静态文本而使用一个空的空结构体将是过度设计。当需要设置一些参数或想要跟踪某些内容时，处理程序更为合适。作为一个一般规则，如果我们说，如果你有一个计数器，`Handler`
    是最佳选择，因为你可以用一个计数为 0 的 `struct` 来初始化，然后增加它，但我们将这在 *活动 15.01* 中看到。
- en: 'Activity 15.01: Adding a Page Counter to an HTML Page'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.01：向 HTML 页面添加页面计数器
- en: Imagine that you own a website with, say, three pages, where you are writing
    your book. You earn money depending on how many visits your website receives.
    In order to understand how popular your website is, and how much money you are
    earning, you need to keep track of the visits.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你拥有一个网站，比如有三个页面，你在上面写你的书。你的收入取决于你的网站访问量。为了了解你的网站有多受欢迎，以及你赚了多少钱，你需要跟踪访问量。
- en: In this activity, you will build an HTTP server with three pages, containing
    some content, and display, in each page, how many visits that page has had so
    far. You will use the `http.Handler` method, which, in this case, will help you
    to generalize your counter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个包含三个页面、一些内容的 HTTP 服务器，并在每个页面上显示该页面迄今为止的访问次数。你将使用 `http.Handler`
    方法，在这种情况下，这将帮助你泛化计数器。
- en: In order to display the dynamic value, you can use the `fmt.Sprintf` function
    in the `fmt` package, which prints and formats a message to a string. With this
    function, you can build a string containing characters and numbers. You can find
    all the information about this method online in the Go documentation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示动态值，你可以使用 `fmt` 包中的 `fmt.Sprintf` 函数，该函数将打印并格式化一条消息到字符串中。使用此函数，你可以构建包含字符和数字的字符串。你可以在
    Go 文档中找到有关此方法的所有信息。
- en: You will use everything you've learned so far, including how a struct is instantiated,
    how to set attributes of a struct, pointers, how to increase an integer, and,
    of course, everything you have learned about HTTP servers hitherto.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用迄今为止所学的一切，包括如何实例化结构体、如何设置结构体的属性、指针、如何增加一个整数，以及当然，你迄今为止所学的关于 HTTP 服务器的所有内容。
- en: 'Observing the following steps will provide an elegant and effective solution:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下步骤将提供一种优雅而有效的解决方案：
- en: Create a folder called `page-counter`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `page-counter` 的文件夹。
- en: Create a file called `main.go`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件。
- en: Add the necessary imports to the `http` and `fmt` packages.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `http` 和 `fmt` 包添加必要的导入。
- en: Define a struct called `PageWithCounter` with a `counter` as an integer attribute,
    a `content`, and a `heading` as a text attribute.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `PageWithCounter` 的结构体，其中包含一个整型属性 `counter`，一个 `content`，以及一个文本属性 `heading`。
- en: Add a `ServeHTTP` method to the struct, capable of displaying the content, the
    heading, and a message with the total number of views.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向结构体添加一个 `ServeHTTP` 方法，能够显示内容、标题以及总访问次数的消息。
- en: 'Create your `main` function and, inside, implement the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的 `main` 函数，并在其中实现以下内容：
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化三个`PageWithCounter`类型的处理器，分别带有`Hello World`、`Chapter 1`和`Chapter 2`的标题和一些内容。
- en: Add the three handlers to the routes `/`, `/chapter1`, and `/chapter2`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个处理器添加到路由`/`、`/chapter1`和`/chapter2`。
- en: Run the server on port `8080`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口`8080`上运行服务器。
- en: 'When you run the server, you should see the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行服务器时，你应该看到以下内容：
- en: '![Figure 15.08: Output on the browser when you run the server for the first
    time'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.08：第一次运行服务器时的浏览器输出'
- en: '](img/B14177_15_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_08.jpg)'
- en: 'Figure 15.08: Output on the browser when you run the server for the first time'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.08：第一次运行服务器时的浏览器输出
- en: 'If you refresh the page, you should see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新页面，你应该看到以下内容：
- en: '![Figure 15.09: Output on the browser when you run the server for the second
    time'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.09：第二次运行服务器时的浏览器输出'
- en: '](img/B14177_15_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_09.jpg)'
- en: 'Figure 15.09: Output on the browser when you run the server for the second
    time'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.09：第二次运行服务器时的浏览器输出
- en: 'Next, navigate to Chapter 1 by typing `localhost:8080/chapter1` in the address
    bar. You should be able to see something along the lines of the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在地址栏中输入`localhost:8080/chapter1`以导航到第1章。你应该能看到以下类似的内容：
- en: '![Figure 15.10: Output on the browser when you visit the chapter1 page for
    the first time'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10：第一次访问chapter1页面时的浏览器输出'
- en: '](img/B14177_15_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_10.jpg)'
- en: 'Figure 15.10: Output on the browser when you visit the chapter1 page for the
    first time'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：第一次访问chapter1页面时的浏览器输出
- en: 'Similarly, navigate to Chapter 2, and you should be able to see the following
    increment in terms of the number of views:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，导航到第2章，你应该能看到以下查看次数的增加：
- en: '![Figure 15.11: Output on the browser when you visit the chapter2 page for
    the first time'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11：第一次访问chapter2页面时的浏览器输出'
- en: '](img/B14177_15_11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_11.jpg)'
- en: 'Figure 15.11: Output on the browser when you visit the chapter2 page for the
    first time'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：第一次访问chapter2页面时的浏览器输出
- en: 'When you revisit Chapter 1, you should see an increase in the number of views
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次访问第1章时，你应该看到如下所示的查看次数增加：
- en: '![Figure 15.12: Output on the browser when you visit the chapter1 page for
    the second time'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.12：第二次访问chapter1页面时的浏览器输出'
- en: '](img/B14177_15_12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_12.jpg)'
- en: 'Figure 15.12: Output on the browser when you visit the chapter1 page for the
    second time'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：第二次访问chapter1页面时的浏览器输出
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 757
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第757页找到
- en: In this activity, you learned how to create a server that responds to different
    requests on different pages with a specific static text, along with a counter
    on each page, with each counter independent from the others.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何创建一个服务器，该服务器能够对不同页面上的不同请求做出特定静态文本的响应，并在每个页面上都有一个计数器，每个计数器与其他计数器独立。
- en: Returning Complex Structures
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回复杂数据结构
- en: What we've seen hitherto is useful when building a website, even though, for
    this purpose, we still need to see how to better render HTML pages. You might
    want to use a framework such as **revel** or **gin** for this purpose, although
    plain Go with a few libraries is more than enough for a production-grade website.
    You will find, however, that HTTP servers are used not only for building websites,
    but also for building web services, and especially, nowadays, microservices. Although
    how to build a web service-based project is beyond the scope of this chapter and
    book, it is important for you to know how to let your HTTP server serve something
    that will not be consumed by a human through a browser, but by another program.
    You may already know what a web service is, but even if you do not, you might
    have to work on an existing project where you have to modify a web service. There
    are several ways to present a message to another program, which will be referred
    to as a client, but, in general, they will all involve some sort of structured
    texts, which can be parsed easily. The format could be an XML string, but the
    most common and lightweight format now used is JSON. In the next exercise, we
    will see how to build a data structure and send it to the client (aq browser or
    another program) in the form of a JSON string.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的内容在构建网站时是有用的，尽管，为了这个目的，我们仍然需要了解如何更好地渲染HTML页面。你可能想使用像 **revel** 或
    **gin** 这样的框架来完成这个任务，尽管纯Go加上几个库对于生产级别的网站来说已经足够了。然而，你会发现HTTP服务器不仅用于构建网站，还用于构建网络服务，尤其是现在，微服务。尽管如何构建基于网络服务的项目超出了本章和本书的范围，但了解如何让你的HTTP服务器为不会通过浏览器由人类消费，而是由另一个程序消费的内容提供服务是很重要的。你可能已经知道什么是网络服务，即使你不知道，你也可能需要在需要修改网络服务的现有项目上工作。有几种方式可以向另一个程序（称为客户端）传递消息，但通常，它们都将涉及某种形式的结构化文本，这些文本可以很容易地被解析。格式可以是XML字符串，但现在最常见且轻量级的格式是JSON。在下一个练习中，我们将看到如何构建一个数据结构并将其以JSON字符串的形式发送给客户端（无论是浏览器还是另一个程序）。
- en: 'Activity 15.02: Serving a Request with a JSON Payload'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.02：使用JSON有效负载处理请求
- en: 'In this activity, you will create a data structure and you will serve it through
    an HTTP server. You will make use of what you have already learned about JSON
    and the encoding/decoding of structs, and you will combine it with what you''ve
    learned about HTTP servers. You might have guessed already, but in this exercise,
    you already have all the knowledge required and you should be able to complete
    it on your own. Let''s now build another book. The title and the chapters are
    the same, but this time we want to make it accessible to a program that will consume
    the pages on the server as JSON documents. The document will also include the
    number of views per chapter, so the code can make use of the one generated in
    *Activity 15.01*. The steps are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建一个数据结构，并通过HTTP服务器提供服务。你将利用你已经学到的关于JSON和结构体的编码/解码的知识，并将其与关于HTTP服务器的知识结合起来。你可能已经猜到了，但在这个练习中，你已经拥有了完成它所需的所有知识，你应该能够独立完成它。现在让我们再建一本书。标题和章节都是相同的，但这次我们希望让它能够被一个程序访问，该程序将作为JSON文档消费服务器上的页面。该文档还将包括每个章节的查看次数，以便代码可以利用在
    *活动15.01* 中生成的代码。步骤如下：
- en: Create a new folder called `book-api`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹名为 `book-api`。
- en: Create a file called `main.go` in that folder.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建一个名为 `main.go` 的文件。
- en: Add the required imports.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的导入。
- en: Create a struct called `PageWithCounter` representing a book with a title, content,
    and a counter, with appropriate JSON tags, if necessary.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PageWithCounter` 的结构体，表示一个具有标题、内容和计数器的书籍，如果需要，可以添加适当的JSON标签。
- en: Add a `ServeHTTP` method to the struct, capable of displaying the content, the
    heading, and a message with the total number of views as a JSON document.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向结构体添加一个 `ServeHTTP` 方法，能够以JSON文档的形式显示内容、标题以及包含总查看次数的消息。
- en: Create the `main()` function.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数。
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化三个 `PageWithCounter` 类型的处理器，标题分别为 `Hello World`、`Chapter 1` 和 `Chapter 2`，并包含一些内容。
- en: Add the three handlers to the routes `/`, `/chapter1`, and `/chapter2`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个处理器添加到路由 `/`、`/chapter1` 和 `/chapter2`。
- en: Run the server on port `8080`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 `8080` 上运行服务器。
- en: 'Running your server, you should see the following for the assigned routes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的服务器，你应该能看到分配的以下路由：
- en: '![Figure 15.13: Expected output when the handler is /'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.13：当处理器为/时的预期输出](img/B14177_15_13.jpg)'
- en: '](img/B14177_15_13.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'Figure 15.13: Expected output when the handler is /'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：当处理器为 / 时的预期输出
- en: '![Figure 15.14: Expected output when the handler is /chapter1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.14：当处理器为 /chapter1 时的预期输出'
- en: '](img/B14177_15_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_14.jpg)'
- en: 'Figure 15.14: Expected output when the handler is /chapter1'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：当处理器为 /chapter1 时的预期输出
- en: '![Figure 15.15: Expected output when the handler is /chapter2'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.15：当处理器为 /chapter2 时的预期输出'
- en: '](img/B14177_15_15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_15.jpg)'
- en: 'Figure 15.15: Expected output when the handler is /chapter2'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：当处理器为 /chapter2 时的预期输出
- en: In this activity, you've learned how to return complex structures through an
    HTTP server. Any kind of complex data structure can be served this way, using
    a standard format such as JSON.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何通过HTTP服务器返回复杂结构。任何类型的复杂数据结构都可以通过这种方式提供，使用标准的格式，如JSON。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 761
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第761页找到
- en: Dynamic Content
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内容
- en: 'A server that serves only static content is useful, but there is much more
    that can be done. An HTTP server can deliver content depending on a more granular
    request, which is done by passing some parameters to the server. There are many
    ways to do so, but one simple way is to pass parameters to a `querystring`. If
    the URL of the server is:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仅提供静态内容的服务器是有用的，但可以做更多的事情。HTTP服务器可以根据更细粒度的请求提供内容，这是通过向服务器传递一些参数来完成的。有很多种方法可以做到这一点，但一种简单的方法是将参数传递给
    `querystring`。如果服务器的URL是：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then add something like:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加如下内容：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the part `?name=john` is called a `querystring` as it is a string representing
    a query. In this case, this `querystring` sets a variable called `name` with a
    value of `john`. This way of passing parameters is generally used with `GET` requests,
    while a `POST` request will generally make use of the body of the request in order
    to send parameters. This does not mean that a `GET` request does not have a body
    but is not the standard way to pass parameters to a `GET` request. We will begin
    by looking at how to accept parameters for a `GET` request, as this request is
    made by simply opening your browser on a specific address. We will see later how
    to handle a `POST` request through a form.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`?name=john` 这部分被称为 `querystring`，因为它是一个表示查询的字符串。在这种情况下，这个 `querystring`
    设置了一个名为 `name` 的变量，其值为 `john`。这种方式通常用于 `GET` 请求中传递参数，而 `POST` 请求通常使用请求体来发送参数。这并不意味着
    `GET` 请求没有请求体，但不是向 `GET` 请求传递参数的标准方式。我们将首先查看如何接受 `GET` 请求的参数，因为这种请求只需在特定地址上打开浏览器即可完成。我们将在稍后看到如何通过表单处理
    `POST` 请求。
- en: In the next exercise, you will be able to return different texts as responses
    to HTTP requests, where the text depends on what values the user puts in the `querystring`
    in the address bar.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将能够返回不同的文本作为对HTTP请求的响应，其中文本取决于用户在地址栏中的 `querystring` 中输入的值。
- en: 'Exercise 15.03: Personalized Welcome'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.03：个性化欢迎
- en: 'In this exercise, we will again create an HTTP server that is able to cheer
    us, but instead of a general "`hello world`" message, we will provide a message
    depending on our name. The idea is that, by opening the browser on the server''s
    URL and adding a parameter called `name`, the server will welcome us with the
    message "`hello` ", followed by the value of the `name` parameter. The server
    is very simple and does not have sub-pages, but contains this dynamic element
    that constitutes a starting point for more complex situations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将再次创建一个HTTP服务器，它能够为我们欢呼，但与一般的 "`hello world`" 消息不同，我们将提供一个根据我们的名字的消息。想法是，通过在服务器的URL上打开浏览器并添加一个名为
    `name` 的参数，服务器将用消息 "`hello` " 欢迎我们，后面跟着 `name` 参数的值。服务器非常简单，没有子页面，但包含这个动态元素，它是更复杂情况的一个起点：
- en: 'Create a new folder called `personalised-welcome` and, inside the folder, create
    a file called `main.go`. Inside the file, add the package name:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `personalised-welcome` 的新文件夹中创建一个名为 `main.go` 的文件。在文件中，添加包名：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add the required imports:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加所需的导入：
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: They are all the same imports used in the previous exercises and activities,
    no there is nothing new. We will not use handlers in this exercise as it is much
    smaller, but we will make use of the `http.handleFunc` function.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们都是之前练习和活动中使用的相同导入，没有新的内容。在这个练习中，我们不会使用处理器，因为它很小，但我们将使用 `http.handleFunc` 函数。
- en: 'Now, add the following code after the imports:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在导入之后添加以下代码：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the definition of a function that can be used as a handling function
    for an HTTP path.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是定义一个可以作为HTTP路径处理函数使用的函数。
- en: 'Now, save the query to a variable using the `Query` method URL from the request:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用请求的`Query`方法将查询保存到一个变量中：
- en: '[PRE28]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Query` method on the `URL` object of the request returns a `map[string][]string`
    with all the parameters sent through the `querystring` in the URL. We then assign
    this map to a variable, `vl`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求对象的`URL`上的`Query`方法返回一个`map[string][]string`类型的映射，其中包含通过URL中的`querystring`发送的所有参数。然后我们将这个映射赋值给一个变量，`vl`。
- en: 'At this point, we need to get the value of a specific parameter called `name`,
    so we get the value from the `name` parameter:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要获取一个名为`name`的特定参数的值，因此我们从`name`参数中获取值：
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we have an assignment to two variables, but only one value comes
    from `vl["name"]`. The second variable, `ok`, is a Boolean that tells us whether
    the "`name`" key exists.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个变量的赋值，但只有一个值来自`vl["name"]`。第二个变量`ok`是一个布尔值，它告诉我们`"name"`键是否存在。
- en: 'If the `name` parameter has not been passed and we want an error message to
    appear, add it if the variable is not found, in other words, if the `ok` variable
    is false:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有传递`name`参数，并且我们希望在变量未找到时显示错误消息，则如果变量不存在，即如果`ok`变量为假，则添加它：
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The conditional code gets called if the key does not exist in the slice, and
    it writes a `400` code (bad request) to the header, as well as a message to the
    response writer stating that the name has not been sent as a parameter. We stop
    the execution with a `return` statement to prevent further actions.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果切片中不存在键，则会调用条件代码，并将`400`代码（错误请求）写入头部，同时向响应写入器发送一条消息，说明名称尚未作为参数发送。我们使用`return`语句停止执行以防止进一步的操作。
- en: 'At this point, write the valid message to the response writer:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，将有效的消息写入响应写入器：
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code formats a string and injects the name into it. The `fmt.Sprintf` function
    is used to format, while `strings.Join` is used in order to transform the `name`
    slice into a string. Notice that the `name` variable is set to the value of `vl["name"]`,
    but `vl` is a `map[string][]string`, which means that it is a map with string
    keys whose values are slices of strings; hence, `vl["name"]` is a slice of strings
    and needs to be transformed into a single string. The `strings.Join` function
    takes all the elements of the slice and builds a single string using `","` as
    a separator. Other characters could also have been used as separators.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码格式化一个字符串并将名称注入其中。使用`fmt.Sprintf`函数进行格式化，而使用`strings.Join`将`name`切片转换为字符串。请注意，`name`变量被设置为`vl["name"]`的值，但`vl`是一个`map[string][]string`类型的映射，这意味着它是一个键为字符串的映射，其值为字符串切片；因此，`vl["name"]`是一个字符串切片，需要转换为单个字符串。`strings.Join`函数接受切片的所有元素，并使用`","`作为分隔符构建一个单独的字符串。也可以使用其他字符作为分隔符。
- en: 'The last part of the file you have to write is:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须编写的文件的最后一部分是：
- en: '[PRE32]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As always, a `main()` function is created, and then the `Hello` function is
    associated with the path `"/"` and the server started. Here is the output of three
    different URLs, two valid ones, and one with a missing parameter:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，创建了一个`main()`函数，然后将`Hello`函数关联到路径`"/"`，并启动了服务器。以下是三个不同URL的输出，其中两个是有效的，一个是缺少参数的：
- en: '![Figure 15.16: Server output when requesting the page with the name john'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.16：请求带有名称“john”的页面时的服务器输出]'
- en: '](img/B14177_15_16.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_16.jpg]'
- en: 'Figure 15.16: Server output when requesting the page with the name john'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16：请求带有名称“john”的页面时的服务器输出
- en: '![Figure 15.17: Server output when requesting the page with the name will'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.17：请求带有名称的页面时的服务器输出]'
- en: '](img/B14177_15_17.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_17.jpg]'
- en: 'Figure 15.17: Server output when requesting the page with the name will'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17：请求带有名称的页面时的服务器输出
- en: '![Figure 15.18: Server outputting an error message when requesting a page without
    a name'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.18：请求不带名称的页面时服务器输出的错误消息]'
- en: '](img/B14177_15_18.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_18.jpg]'
- en: 'Figure 15.18: Server outputting an error message when requesting a page without
    a name'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18：请求不带名称的页面时服务器输出的错误消息
- en: Templating
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化
- en: 'Although JSON can be the best choice when complex data structures have to be
    shared across software programs, this is not the case, in general, when the HTTP
    server is supposed to be consumed by humans. In the previous exercises and activities,
    the chosen way to format a text has been the `fmt.Sprintf` function, which is
    good for formatting texts, but is simply insufficient when a more dynamic and
    complex text is required. As you will have noticed in the previous exercise, the
    message returned in case a name was passed as a parameter to the URL observed
    a specific pattern, and this is where a new concept comes in – the template. A
    template is a skeleton from which complex entities can be developed. Essentially,
    a template is like a text with some blanks, and a template engine will take some
    values and fill the blanks, as you can see in the following diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当需要在软件程序之间共享复杂数据结构时，JSON 可能是最佳选择，但在一般情况下，当 HTTP 服务器打算由人类消费时，情况并非如此。在之前的练习和活动中，选择格式化文本的方式是
    `fmt.Sprintf` 函数，这对于格式化文本是好的，但在需要更动态和复杂的文本时，它就远远不够了。正如您在之前的练习中已经注意到的，当将名称作为参数传递给观察到的
    URL 时，返回的消息遵循特定的模式，这就是新概念出现的地方——模板。本质上，模板就像是一个带有一些空白的文本，模板引擎将取一些值并填充这些空白，正如您在以下图中可以看到的那样：
- en: '![Figure 15.19: Templating example'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.19：模板示例](img/B14177_15_19.jpg)'
- en: '](img/B14177_15_19.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_19.jpg](img/B14177_15_19.jpg)'
- en: 'Figure 15.19: Templating example'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.19：模板示例
- en: As you can see, `{{name}}` is a placeholder and, when a value is passed through
    to the engine, the placeholder is modified with that value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`{{name}}` 是一个占位符，当值传递给引擎时，占位符会与该值一起修改。
- en: We see templates everywhere. We have templates for Word documents, where we
    just fill in what is missing to produce new documents that all differ from one
    another. A teacher might have some templates for their lessons and will develop
    different lessons from that same template. Go provides two different templating
    packages, one for texts and one for HTML. As we are working with HTTP servers
    and we want to produce a web page, we will use the HTML templating package, but
    the interface is the same for the text template library. Although the templating
    packages are good enough for any real-world application, there are also several
    other external packages that can be used in order to improve performance. One
    of these is the `hero` template engine, which is much faster than the standard
    Go templating package.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无处不在都能看到模板。我们有用于 Word 文档的模板，我们只需填写缺失的内容，就可以生成彼此不同的新文档。一位教师可能有一些用于他们课程的模板，并会从这个相同的模板中开发出不同的课程。Go
    提供了两个不同的模板包，一个用于文本，一个用于 HTML。由于我们正在处理 HTTP 服务器，并且我们想要生成网页，我们将使用 HTML 模板包，但接口与文本模板库相同。尽管模板包对于任何实际应用都足够好，但还有几个其他外部包可以用来提高性能。其中之一是
    `hero` 模板引擎，它比标准的 Go 模板包要快得多。
- en: 'The Go templating package provides a placeholder language where we can use
    things such as:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模板包提供了一种占位符语言，我们可以使用如下内容：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A simple search and replace block, but more complex situations can be handled
    via conditionals:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的搜索和替换块，但更复杂的情况可以通过条件语句来处理：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, if an `age` parameter is not null, the template will have `Hello`; otherwise
    it has `bye`. Each conditional needs an `{{end}}` placeholder to determine its
    ending.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果 `age` 参数不为空，模板将显示 `Hello`；否则显示 `bye`。每个条件都需要一个 `{{end}}` 占位符来确定其结束。
- en: 'Variables in a template, however, do not need to be simple numbers or strings;
    they can be objects. In this case, if we have a struct with a field called `ID`,
    we can reference this field in the template this way:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模板中的变量不需要是简单的数字或字符串；它们可以是对象。在这种情况下，如果我们有一个名为 `ID` 的字段的结构体，我们可以在模板中以这种方式引用该字段：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is very handy, meaning that we can pass a struct to the template instead
    of many single parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，意味着我们可以将结构体传递给模板，而不是传递许多单个参数。
- en: In the next exercise, you will see how to use the basic templating functionalities
    of Go to create pages with custom messages, like you've done before, but just
    in a more elegant way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将看到如何使用 Go 的基本模板功能来创建带有自定义消息的页面，就像您之前所做的那样，但方式更加优雅。
- en: 'Exercise 15.04: Templating Our Pages'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.04：模板化我们的页面
- en: 'The aim of this exercise is to build a more structured web page, use a template,
    and fill it with parameters from the URL''s `querystring`. In this scenario, we
    want to display basic information for a customer and hide some information when
    the data is missing. A customer has an `id`, `name`, `surname`, and `age` and
    if any of these items of data are missing, they will not be displayed. Unless
    the data is the `id`, as in this case, an error message will be displayed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是构建一个更结构化的网页，使用模板，并用URL的`querystring`中的参数填充它。在这种情况下，我们想显示客户的基本信息，并在数据缺失时隐藏一些信息。一个客户有一个`id`、`name`、`surname`和`age`，如果这些数据项中的任何一个缺失，则不会显示。除非数据是`id`，就像这个例子一样，将显示错误消息：
- en: 'Begin by creating a `server-template` folder with a `main.go` file as usual,
    and then add the usual package and some imports:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个`server-template`文件夹，并添加一个`main.go`文件，就像通常一样，然后添加通常的包和一些导入：
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we use two new imports, "`html/template`" for our templating, and "`strconv`"
    to convert strings into numbers (this package could also work the other way around,
    but there are better solutions for formatting text).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两个新的导入，"`html/template`"用于我们的模板，以及"`strconv`"将字符串转换为数字（这个包也可以反过来工作，但还有更好的解决方案来格式化文本）。
- en: 'Now, write the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写以下内容：
- en: '[PRE37]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a raw string that contains some HTML and templating code, which is wrapped
    by `{{}}` and which we will analyze now.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个包含一些HTML和模板代码的原始字符串，这些代码被`{{}}`包裹，我们现在将对其进行分析。
- en: '`{{.ID}}` is essentially a placeholder that tells the template engine that
    wherever this code is found, it will be substituted by a struct''s attribute called
    `ID`. The Go templating engine works with structs, so essentially, a struct will
    be passed to the engine and its attributes'' values will be used to fill the placeholders.
    `{{if .ID}}` is a conditional that tells the template that what happens next will
    depend on the value of `ID`. In this case, if `ID` is not an empty string, the
    template will display the customer''s details, otherwise it will display the message
    `<p>Data not available</p>`, which is wrapped between the placeholders `{{else}}`
    and `{{end}}`. As you can see, there are many more conditionals nested inside
    the first one. At each list item, there is a `<li>` tag, which is wrapped, for
    example, by `{{if .Name}}` and terminated with `{{end}}`.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{{.ID}}`基本上是一个占位符，告诉模板引擎，无论在哪里找到这段代码，它将被替换为名为`ID`的struct属性。Go模板引擎与struct一起工作，所以基本上，一个struct将被传递到引擎，其属性的值将用于填充占位符。`{{if
    .ID}}`是一个条件，告诉模板接下来发生的事情将取决于`ID`的值。在这种情况下，如果`ID`不是一个空字符串，模板将显示客户的详细信息，否则它将显示消息`<p>Data
    not available</p>`，该消息被`{{else}}`和`{{end}}`占位符包裹。如您所见，第一个条件中嵌套了许多其他条件。在每个列表项中，都有一个`<li>`标签，例如，被`{{if
    .Name}}`包裹，并以`{{end}}`结束。'
- en: 'Now that we have a string template, let''s create a struct with the correct
    attributes. To fill in the template, write the following:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个字符串模板，让我们创建一个具有正确属性的struct。为了填充模板，请编写以下内容：
- en: '[PRE38]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This struct is self-explanatory. It contains all the attributes needed by the
    template.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个结构体是自我解释的。它包含模板所需的所有属性。
- en: 'Define the handler function and set a variable to the map of values in the
    `querystring`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义处理函数并设置一个变量到`querystring`中的值映射：
- en: '[PRE39]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instantiate a `cust` variable of the `Customer` type:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`cust`变量为`Customer`类型：
- en: '[PRE40]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The variable now has all its attributes set to the default values, and we need
    to grab the passed values from the URL. In order to do so, write:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这个变量已经将其所有属性设置为默认值，我们需要从URL中获取传递的值。为了做到这一点，请编写以下内容：
- en: '[PRE41]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the parameters are taken as they are from the values map, and
    if they exist, they are used to set the value of the related `cust` attribute.
    In order to check whether these parameters exist, we again used the `ok` variable,
    which is set to a Boolean with a value of `true` in case the map contains the
    requested key. The last attribute, `Age`, is handled slightly differently:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，参数直接从值映射中获取，如果它们存在，则用于设置相关`cust`属性的值。为了检查这些参数是否存在，我们再次使用了`ok`变量，该变量被设置为具有值为`true`的布尔值，如果映射包含请求的键。最后一个属性`Age`的处理方式略有不同：
- en: '[PRE42]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is because `strconv.Atoi` returns an error in case the parameter passed
    is not really a number. In general, we should handle the errors but, in this case,
    we just ignore it and we won't display any age-related information if the age
    provided is not a number.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为`strconv.Atoi`在传入的参数实际上不是数字时会返回一个错误。一般来说，我们应该处理错误，但在这个例子中，我们只是忽略它，如果提供的年龄不是数字，我们不会显示任何与年龄相关的信息。
- en: 'Next, write:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写：
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This creates a template object with the name "`test`" and with the content of
    the string that you created at the outset. We again ignore the error as we are
    sure that the template we've written is a valid one. In production, however, all
    the errors should be dealt with.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这创建了一个名为"`test`"的模板对象，其内容是你最初创建的字符串。我们再次忽略错误，因为我们确信我们编写的模板是有效的。然而，在生产环境中，所有错误都应该被处理。
- en: 'You can now finish writing the function with:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以完成函数的编写：
- en: '[PRE44]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the template is actually executed using the `cust` struct and the content
    is sent directly to `w` `ResponseWriter` without needing to call the `Write` method
    manually.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，模板实际上是通过使用`cust`结构体来执行的，内容直接发送到`w` `ResponseWriter`，而不需要手动调用`Write`方法。
- en: 'What is missing now is the `main` method, which is fairly simple. Write the
    following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在缺少的是`main`方法，它相当简单。编写以下内容：
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, simply speaking, the main path is associated with the `Hello` function
    and the server is then started.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单来说，主路径与`Hello`函数相关联，然后启动服务器。
- en: The performance of this code is not very high as we create a template in every
    request. The template could be created in the `main` and then passed to a handler,
    which could have a `ServeHTTP` method like the `Hello` function you've just written.
    The code has been kept simple here in order to focus on templating.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码的性能并不高，因为我们每次请求都会创建一个模板。模板可以在`main`中创建，然后传递给一个处理程序，该处理程序可以有一个类似于你刚刚编写的`Hello`函数的`ServeHTTP`方法。这里代码被保持简单，以便专注于模板。
- en: 'If you now start the server and visit the following pages, you should see some
    output similar to the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在启动服务器并访问以下页面，你应该会看到以下类似的输出：
- en: '![Figure 15.20: Templated response with blank parameters'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.20：带有空参数的模板响应'
- en: '](img/B14177_15_20.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_20.jpg)'
- en: 'Figure 15.20: Templated response with blank parameters'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.20：带有空参数的模板响应
- en: 'Now, you can add a query parameter called `id` and put it equal to `1` in the
    URL visiting this address: `localhost:8080/?id=1`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在URL中添加一个名为`id`的查询参数，并将其设置为`1`：`localhost:8080/?id=1`：
- en: '![Figure 15.21: Templated response with just the ID specified'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.21：仅指定ID的模板响应'
- en: '](img/B14177_15_21.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_21.jpg)'
- en: 'Figure 15.21: Templated response with just the ID specified'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.21：仅指定ID的模板响应
- en: 'Then, you can also add a value for the name parameter going to the address
    `localhost:8080/?id=1&name=John`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你还可以通过访问地址`localhost:8080/?id=1&name=John`为名称参数添加一个值：
- en: '![Figure 15.22: Templated response with the ID and name specified'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.22：指定ID和名称的模板响应'
- en: '](img/B14177_15_22.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_22.jpg)'
- en: 'Figure 15.22: Templated response with the ID and name specified'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.22：指定ID和名称的模板响应
- en: 'And finally, you can also add an age going to the address `localhost:8080/?id=1&name=John&age=40`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以通过访问地址`localhost:8080/?id=1&name=John&age=40`添加一个年龄：
- en: '![Figure 15.23: Templated response with the ID, name, and age specified'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.23：指定ID、名称和年龄的模板响应'
- en: '](img/B14177_15_23.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_23.jpg)'
- en: 'Figure 15.23: Templated response with the ID, name, and age specified'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.23：指定ID、名称和年龄的模板响应
- en: Here, each parameter in the `querystring` is displayed, if valid, in the web
    application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果有效，`querystring`中的每个参数都会在Web应用程序中显示。
- en: Static Resources
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态资源
- en: Everything you've learned so far in this book, up to the last exercise, is sufficient
    in order to build web applications and dynamic websites; you just need to put
    all the pieces together. What you've been doing in this chapter is returning messages
    that are different in nature, but that are all hardcoded as strings. Even dynamic
    messages have been based on templates hardcoded in the source file of the exercises
    and activities. Let's now consider something. In the case of the first "`hello
    world`" server, the message never changed. If we wanted to modify the message
    and return a "`Hello galaxy`" message, we would have to change the text in the
    code and then recompile and/or run the server again. What if you wanted to sell
    your simple "hello" server and give the option to everybody to specify a custom
    message? Of course, you should give the source code to everybody so that they
    could recompile and run the server. Although you might want to embrace open source
    code, this might not be the ideal way to distribute an application, and we need
    to find a better way to separate the message from the server. A solution to that
    is to serve static files, which are files loaded by your program as external resources.
    These files do not change and do not get compiled but are loaded and manipulated
    by your program. One such example may be templates, as seen before, because they
    are just text and you can use template files instead of adding the templates as
    text to your code. Another simple example of static resources are images that
    you want to include in your web page, or styling files such as CSS. You will see
    in the following exercises and activities how to do that. You'll be able to serve
    a specific file or a specific folder, and then you'll see how to serve dynamic
    files with a static template.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你到目前为止所学的所有内容，直到最后一个练习，都足以构建网络应用程序和动态网站；你只需要将所有这些部分组合在一起。在本章中，你所做的是返回不同性质的消息，但这些消息都是作为字符串硬编码的。即使是动态消息，也基于在练习和活动源文件中硬编码的模板。现在让我们考虑一下。在第一个"`hello
    world`"服务器的例子中，消息从未改变。如果我们想修改消息并返回一个"`Hello galaxy`"的消息，我们就必须更改代码中的文本，然后重新编译和/或再次运行服务器。如果你想要出售你的简单"hello"服务器并给每个人指定一个自定义消息的选项呢？当然，你应该把源代码给每个人，这样他们就可以重新编译和运行服务器。虽然你可能想要拥抱开源代码，但这可能不是分发应用程序的理想方式，我们需要找到一种更好的方法来将消息与服务器分离。一个解决方案是提供静态文件，这些文件是由你的程序作为外部资源加载的。这些文件不会改变，也不会被编译，但会被你的程序加载和处理。一个这样的例子可能是模板，就像之前看到的，因为它们只是文本，你可以使用模板文件而不是将模板作为文本添加到你的代码中。另一个静态资源的简单例子是你想要包含在网页中的图像，或者CSS样式文件。你将在接下来的练习和活动中看到如何做到这一点。你将能够提供特定的文件或特定的文件夹，然后你会看到如何使用静态模板提供动态文件。
- en: 'Exercise 15.05: Creating a Hello World Server Using a Static File'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.05：使用静态文件创建Hello World服务器
- en: 'In this exercise, you will again create your hello world server but with the
    use of a static HTML file. What we want is to have a simple server with one handler
    function that looks for a specific file with a specific name, which will be served
    as the output for every path. In this case, you will need to create multiple files
    in your project:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将再次创建你的hello world服务器，但这次使用静态HTML文件。我们想要的是一个简单的服务器，它有一个处理函数，该函数查找具有特定名称的特定文件，该文件将作为每个路径的输出提供。在这种情况下，你需要在你的项目中创建多个文件：
- en: 'Create a folder called `static-file` and, inside it, create a file called `index.html`.
    Then, insert inside this file the following code for a pretty simple HTML file
    with a title and an `h1` tag with our welcome message:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`static-file`的文件夹，并在其中创建一个名为`index.html`的文件。然后，在这个文件中插入以下代码，这是一个非常简单的HTML文件，包含一个标题和一个`h1`标签，其中包含我们的欢迎信息：
- en: '[PRE46]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, create a file called `main.go` and start writing the necessary imports:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`main.go`的文件，并开始编写必要的导入：
- en: '[PRE47]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, write the `main` function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写`main`函数：
- en: '[PRE48]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, write the `handler` function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写`handler`函数：
- en: '[PRE49]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is where the magic happens. You can see a normal `http.HandleFunc` called
    with a `"/"` path as the first parameter, and then a handler function is passed,
    which contains a single instruction:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方。你可以看到一个正常的`http.HandleFunc`被调用，其第一个参数是`"/"`路径，然后传递了一个处理函数，该函数包含一条单独的指令：
- en: '[PRE50]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This essentially sends to `ResponseWriter` the content of the "`index.html`"
    file.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这实际上是将"`index.html`"文件的内容发送到`ResponseWriter`。
- en: 'Now, write the last part:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写最后一部分：
- en: '[PRE51]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As is always the case, this starts the server, logs in case of an error, and
    exits the program.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常一样，这启动了服务器，在出错时记录，然后退出程序。
- en: 'If you now save the file and you run the program with:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在保存文件，并且用以下方式运行程序：
- en: '[PRE52]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And then you open your browser on the `localhost:8080` page, you should see
    the following:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后你打开浏览器在`localhost:8080`页面上，你应该看到以下内容：
- en: '![Figure 15.24: Hello world with a static template file'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.24：带有静态模板文件的Hello world]'
- en: '](img/B14177_15_24.jpg)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_24.jpg)'
- en: 'Figure 15.24: Hello world with a static template file'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.24：带有静态模板文件的Hello world]'
- en: 'But now, without stopping your server, just change the HTML file, `index.html`,
    and modify line `8` where you see:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但现在，不需要停止你的服务器，只需更改HTML文件，`index.html`，并修改第`8`行，你看到：
- en: '[PRE53]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Change the text in the `<h1>` tag:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`<h1>`标签中的文本：
- en: '[PRE54]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the `index.html` file and, without touching the terminal and without restarting
    your server, just refresh your browser on the same page, and you should now see
    the following:![Figure 15.25: Hello world server with the static template file
    modified'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存`index.html`文件，并且不要触摸终端，也不要重新启动你的服务器，只需在同一个页面上刷新你的浏览器，你现在应该看到以下内容：![图15.25：修改后的静态模板文件的Hello
    world服务器]
- en: '](img/B14177_15_25.jpg)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_25.jpg)'
- en: 'Figure 15.25: Hello world server with the static template file modified'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.25：修改后的静态模板文件的Hello world服务器
- en: So, even if the server is running, it will pick up the new version of the file.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，即使服务器正在运行，它也会选择文件的新版本。
- en: In this exercise, you've seen how to use a static HTML file to serve a web page,
    and how detaching the static resources from your application makes you able to
    change your served page without restarting your application.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何使用静态HTML文件来服务一个网页，以及如何将静态资源从你的应用程序中分离出来，使你能够在不重新启动应用程序的情况下更改你提供的服务页面。
- en: Getting Some Style
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取一些样式
- en: Up to now, you've seen how to serve one static page and you might consider serving
    a few pages with the same method, maybe creating a handler struct with the name
    of the file to serve as an attribute. This might be impractical for large numbers
    of pages, although, in some cases, it is necessary. A web page, however, does
    not include just HTML code, but also images and styles, and some frontend code.
    It is not within the scope of this book to teach how to build HTML pages, and
    even less how to write JavaScript code or CSS style sheets, but you need to know
    how to serve these documents as we use a small CSS file to build our example.
    Serving static files and putting templates in different files, or generally using
    external resources, is a good way to separate concerns on our projects, and makes
    our projects more manageable and maintainable, so you should try to follow this
    approach in all your projects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何服务一个静态页面，你可能考虑使用相同的方法服务几个页面，也许创建一个具有要服务文件名称的handler struct作为属性。对于大量页面来说，这可能不太实用，尽管在某些情况下这是必要的。然而，一个网页不仅仅包括HTML代码，还包括图片和样式，以及一些前端代码。本书的范围并不包括如何构建HTML页面，甚至更少涉及如何编写JavaScript代码或CSS样式表，但你需要知道如何作为我们使用一个小CSS文件来构建我们的示例来服务这些文档。服务静态文件和将模板放在不同的文件中，或者一般使用外部资源，是我们项目中分离关注点的好方法，使我们的项目更易于管理和维护，因此你应该尝试在所有项目中遵循这种方法。
- en: 'In order to add a style sheet to your HTML pages, you need to add a tag like
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将样式表添加到您的HTML页面中，您需要添加一个如下所示的标签：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This injects the CSS file into the page as a "stylesheet", but this is reported
    here just by way of an example, in case you are interested in learning how to
    write HTML.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将CSS文件注入页面作为“样式表”，但这在这里只是作为一个例子，以防你对学习如何编写HTML感兴趣。
- en: 'You have also seen that we have served files, reading them from the filesystem
    one by one, but Go provides us with an easy function to do the job for us:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了我们是如何逐个从文件系统中读取文件来服务的，但Go为我们提供了一个简单的函数来完成这项工作：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Essentially, `http.FileServer` creates what the name says: a server serving
    external files, and it takes them from the directory defined in `http.Dir`. Whatever
    file we put inside the "`./public`" directory will be automatically accessible,
    adding in the address bar:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`http.FileServer`创建的就是它名字所描述的：一个服务外部文件的服务器，它从`http.Dir`中定义的目录中获取文件。无论我们在"`./public`"目录中放置什么文件，都将自动可访问，并在地址栏中添加：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This seems good enough. However, in a real-world scenario, you do not want
    to expose your folder names and you want to specify a different name for your
    static resources. This is achieved as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来已经足够好了。然而，在现实世界的场景中，你不想暴露你的文件夹名称，并且你想为你的静态资源指定一个不同的名称。这是通过以下方式实现的：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You may notice that the `http.FileServer` function is wrapped by an `http.StripPrefix`
    function that we use in order to associate the requested path with the correct
    files on the filesystem. Essentially, we want a path of the `/statics` form to
    be available and to bind it to the content of the `public` folder. The `StripePrefix`
    function will remove the `"/statics/"` prefix from the request and will pass it
    to the file server, which will just get the name of the file to serve and will
    search for it in the `public` folder. It is not necessary, if you do not want
    to change the name of the path and folder, to use these wrappers, but this solution
    is general and works everywhere, so you can utilize it in other projects without
    having to worry.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 `http.FileServer` 函数被一个 `http.StripPrefix` 函数包装，我们使用它来将请求的路径与文件系统上的正确文件关联起来。本质上，我们希望一个
    `/statics` 形式的路径可用，并将其绑定到 `public` 文件夹的内容。`StripePrefix` 函数将从请求中移除 `"/statics/"`
    前缀，并将其传递给文件服务器，文件服务器将只获取要服务的文件名，并在 `public` 文件夹中搜索它。如果你不想更改路径和文件夹的名称，不需要使用这些包装器，但这个解决方案是通用的，并且适用于任何地方，所以你可以在其他项目中使用它而不用担心。
- en: 'Exercise 15.06: A Stylish Welcome'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.06：风格化欢迎
- en: 'The aim of this exercise is to display a welcome page, making use of some external
    static resources. We will adopt the same approach as in *Exercise 15.05*, but
    we will add some extra files and code. We will place some stylesheets in a `static`
    folder, and we will serve them so that they can be used by other pages served
    by the same server:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目的是显示一个欢迎页面，利用一些外部静态资源。我们将采用与 *练习 15.05* 相同的方法，但我们将添加一些额外的文件和代码。我们将一些样式表放在一个
    `static` 文件夹中，并且我们将提供它们，以便它们可以被同一服务器提供的其他页面使用：
- en: 'By way of a first step, create a folder called `stylish-welcome` and, inside
    this folder, add a file called `index.html` and incorporate the following content:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，创建一个名为 `stylish-welcome` 的文件夹，并在该文件夹内添加一个名为 `index.html` 的文件，并包含以下内容：
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, there are few differences compared with the previous HTML; we
    have a paragraph with some more text, wrapped by the `<p>` tag, and, inside the
    `<head>` tag, we include three links to external resources.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，与之前的 HTML 相比，有一些细微的差别；我们有一个包含更多文本的段落，被 `<p>` 标签包裹，并且在 `<head>` 标签内，我们包含了三个指向外部资源的链接。
- en: 'Now, create a folder called `public` inside your `stylish-welcome` folder and
    create three files therein with these names and content:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的 `stylish-welcome` 文件夹内创建一个名为 `public` 的文件夹，并在其中创建三个文件，文件名和内容如下：
- en: '`header.css`'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`header.css`'
- en: '[PRE60]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`body.css`'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`body.css`'
- en: '[PRE61]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`text.css`'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`text.css`'
- en: '[PRE62]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, go back to your main project folder, `stylish-welcome`, and create the
    `main.go` file. The content at the start corresponds exactly to that in one of
    the previous exercises:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到你的主项目文件夹 `stylish-welcome`，并创建 `main.go` 文件。文件开头的内容与之前的练习中的内容完全相同：
- en: '[PRE63]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, add the following code to handle the static files:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下代码来处理静态文件：
- en: '[PRE64]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code adds a handler to the "`/statics/`" path and it does so through an
    `http.FileServer` function, which returns a static file handler.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码向 "`/statics/`" 路径添加了一个处理程序，它是通过一个 `http.FileServer` 函数实现的，该函数返回一个静态文件处理程序。
- en: 'This function requires a directory to scrape, and we pass one to it as a parameter:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数需要一个用于抓取的目录，我们传递一个给它作为参数：
- en: '[PRE65]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This reads the local "`public`" folder that you created previously.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这读取你之前创建的本地 "`public`" 文件夹。
- en: 'Now, add this final part to the file:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下内容添加到文件中：
- en: '[PRE66]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here again, the server gets created and the `main()` function is closed. If
    you now run your server, again with:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，服务器再次创建，`main()` 函数被关闭。如果你现在再次运行你的服务器，使用：
- en: '[PRE67]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You will now see the following:![Figure 15.26: Styled home page'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在会看到以下内容：![图 15.26：样式化主页
- en: '](img/B14177_15_26.jpg)'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_26.jpg]'
- en: 'Figure 15.26: Styled home page'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.26：样式化主页
- en: So somehow, the HTML file is now getting the style from the style sheets you
    created at the beginning.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，HTML 文件现在正在从你最初创建的样式表中获取样式。
- en: 'Let''s now examine how the files are injected. If you look back at the `index.html`
    file, you will see these lines:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来检查文件是如何注入的。如果你回顾一下 `index.html` 文件，你会看到这些行：
- en: '[PRE68]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So essentially, we are looking for files under the path `"/statics/"`. Hence,
    you can go to these addresses and you will see:![Figure 15.27: body CSS file'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，本质上，我们正在寻找路径 `"/statics/"` 下的文件。因此，你可以访问这些地址，你会看到：![图 15.27：body CSS 文件
- en: '](img/B14177_15_27.jpg)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_27.jpg]'
- en: 'Figure 15.27: body CSS file'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.27：body CSS 文件
- en: '![Figure 15.28: header CSS file'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 15.28：header CSS 文件]'
- en: '](img/B14177_15_28.jpg)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14177_15_28.jpg]'
- en: 'Figure 15.28: header CSS file'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 15.28：header CSS 文件
- en: '![Figure 15.29: text CSS file'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图15.29：text CSS文件'
- en: '](img/B14177_15_29.jpg)'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_15_29.jpg)'
- en: 'Figure 15.29: text CSS file'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.29：text CSS文件
- en: 'So, all the style sheets are served. Furthermore, you can even go here:![Figure
    15.30: Static folder content visible in the browser'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，所有样式表都已被提供。此外，你甚至可以在这里查看：![图15.30：在浏览器中可见的静态文件夹内容
- en: '](img/B14177_15_30.jpg)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_15_30.jpg)'
- en: 'Figure 15.30: Static folder content visible in the browser'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.30：在浏览器中可见的静态文件夹内容
- en: And see all the files inside the `public` folder, served under the `/statics/`
    path. You can see that if you are looking for a simple static files server, Go
    allows you, with the help of a few lines of code, to create one, and, with a few
    more lines, you can make it production-ready.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且查看`public`文件夹中的所有文件，这些文件在`/statics/`路径下提供服务。你可以看到，如果你需要一个简单的静态文件服务器，Go允许你通过几行代码创建一个，并且通过更多的代码，你可以使其适用于生产环境。
- en: 'If you use Chrome, you can inspect with your mouse by right-clicking, or with
    any browser if you have a developer tool, and you will see something similar to
    this:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用Chrome浏览器，你可以通过右键点击来检查，或者如果你有开发者工具，也可以在任何浏览器中检查，你将看到类似以下内容：
- en: '![Figure 15.31: Developer tools showing loaded scripts'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.31：开发者工具显示加载的脚本'
- en: '](img/B14177_15_31.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_31.jpg)'
- en: 'Figure 15.31: Developer tools showing loaded scripts'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.31：开发者工具显示加载的脚本
- en: You can see that the files have been loaded and that the styles are shown as
    computed from the stylesheet on the right.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到文件已经被加载，并且样式显示为从右侧的样式表中计算得出的。
- en: Getting Dynamic
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态获取
- en: Static assets are generally served as they are, but when you want to create
    a dynamic page, you might want to make use of an external template, which you
    can use on the fly, so that you can change the template without having to restart
    your server, or that you can load on startup, which means you will have to restart
    your server following any change (this is not strictly true, but we need some
    concepts of concurrent programming in order to make it happen). Loading a file
    at startup is executed simply for performance reasons. Filesystem operations are
    always the slowest, and even if Go is a fairly fast language, you might want to
    take performance into account when you want to serve your pages, especially if
    you have many requests from multiple clients.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 静态资源通常以原样提供服务，但当你想要创建一个动态页面时，你可能想使用外部模板，这样你就可以即时使用它，这样你就可以在不重新启动服务器的情况下更改模板，或者你可以在启动时加载，这意味着你将不得不在更改后重新启动服务器（这并不完全正确，但我们需要一些并发编程的概念来实现这一点）。在启动时加载文件是为了性能原因。文件系统操作总是最慢的，即使Go是一种相当快的语言，你可能在想要提供页面时考虑性能，尤其是如果你有来自多个客户端的大量请求。
- en: 'As you will recall from a previous topic, we used the standard Go templates
    to make dynamic pages. Now, we can use the template as an external resource and
    put our template code in an HTML file and load it. The template engine can parse
    it and then fill the blanks with the passed parameters. To do this, we can use
    the `html/template` function:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的，从前一个主题中，我们使用了标准的Go模板来制作动态页面。现在，我们可以将模板作为一个外部资源，并将我们的模板代码放入HTML文件中并加载它。模板引擎可以解析它，然后用传递的参数填充空白。为此，我们可以使用`html/template`函数：
- en: '[PRE69]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This can be called, for example, with:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式调用：
- en: '[PRE70]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In addition, the template is loaded in memory and is ready to be used.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模板被加载到内存中，并准备好使用。
- en: Up to this point, you have been the sole user of your HTTP servers, but in an
    actual scenario, that is certainly not the case. In the following examples, we
    will look at performance and will use a resource loaded at startup.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直是你的HTTP服务器的唯一用户，但在实际场景中，情况肯定不是这样。在接下来的示例中，我们将查看性能，并使用启动时加载的资源。
- en: 'Activity 15.03: External Template'
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十五.03：外部模板
- en: In this activity, you will create a welcome server, like the ones you created
    before, and you will have to use the template package, as you've done before.
    In this activity, however, we do not want you to create your template from a hardcoded
    string but from an HTML file, which will contain all the template placeholders.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建一个欢迎服务器，就像你之前创建的那样，并且你必须使用模板包，就像你之前做的那样。然而，在这个活动中，我们不想让你从硬编码的字符串中创建模板，而是从一个包含所有模板占位符的HTML文件中创建模板。
- en: You should be able to complete this activity, making use of what you've learned
    so far in this chapter and in the previous one.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够完成这个活动，利用你在本章和上一章中学到的知识。
- en: This activity returns a pointer to a `template` and an error from a list of
    filenames. The error gets returned if any of the files do not exist or if the
    format of the template is wrong. In any case, do not concern yourself with the
    possibility of adding multiple files. Stick with one.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动返回一个指向`template`的指针和一个错误列表。如果任何文件不存在或模板格式错误，则返回错误。在任何情况下，不要担心添加多个文件的可能性。坚持使用一个。
- en: 'Here are the steps to complete the activity:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Create a folder for your project.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的项目创建一个文件夹。
- en: Create a template with a name such as `index.html` and fill it with standard
    HTML code, with a welcome message and a placeholder for the name. Make sure that
    if the name is empty, the message inserts the word `visitor` where the name is
    supposed to be.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`等名称的模板，并用标准的HTML代码填充，包括欢迎信息和名称占位符。确保如果名称为空，信息将把“访客”这个词插入到名称应该出现的位置。
- en: Create your `main.go` file and add to it the right package and imports.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的`main.go`文件，并向其中添加正确的包和导入。
- en: In the `main.go` file, create a `struct` holding a name that can be passed to
    a template.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，创建一个包含名称的`struct`，该名称可以传递给一个模板。
- en: Create a template from a file using your `index.html` file.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的`index.html`文件创建一个模板。
- en: Create something that's able to handle the HTTP requests and use the `querystring`
    to receive parameters and display the data through the template created previously.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个能够处理HTTP请求并使用`querystring`接收参数，并通过之前创建的模板显示数据的程序。
- en: Set all the paths to the server to use the function or handler created in the
    previous step and then create the server.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有路径设置为服务器使用之前步骤中创建的函数或处理程序，然后创建服务器。
- en: Run the server and check the result.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器并检查结果。
- en: 'The output will be as follows:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 15.32: Anonymous visitor page'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.32：匿名访客页面'
- en: '](img/B14177_15_32.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_15_32.jpg](img/B14177_15_32.jpg)'
- en: 'Figure 15.32: Anonymous visitor page'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.32：匿名访客页面
- en: 'And the visitor page including the name will look something like the following
    screenshot:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 包含名称的访客页面看起来可能如下截图所示：
- en: '![Figure 15.33: Visitor page with the name "Will"'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.33：名为“Will”的访客页面'
- en: '](img/B14177_15_33.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_15_33.jpg](img/B14177_15_33.jpg)'
- en: 'Figure 15.33: Visitor page with the name "Will"'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.33：名为“Will”的访客页面
- en: Note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 763
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第763页找到
- en: In this activity, you learned how to create a templated HTTP handler as a struct
    that can be initialized with any external template. You can now create multiple
    pages, instantiating the same struct with different templates of your choice.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何创建一个模板化的HTTP处理程序作为结构体，它可以初始化为任何外部模板。你现在可以创建多个页面，使用不同的模板实例化相同的结构体。
- en: HTTP Methods
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法
- en: Up to this point, you've checked the results of your exercises and activities
    through your web browser, just visiting an address, your localhost, and getting
    some results back in the form of a web page. This way of consuming an HTTP server
    utilizes what is known as the `GET` method. You have seen the methods when you
    worked with the HTTP clients, which are the only way to use anything other than
    `GET` or `POST`. Through your web browser, however, you can also use the `POST`
    method, which is often used in order to send form data. It is possible to send
    form data through `GET`, but this method pollutes the URL with parameters and
    has some limitations in terms of the size of the data that can be sent.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你通过网页浏览器检查了你的练习和活动的结果，只需访问一个地址，即你的localhost，并得到一些以网页形式返回的结果。这种方式消费HTTP服务器使用的是所谓的`GET`方法。你在使用HTTP客户端时已经看到了这些方法，它们是除了`GET`或`POST`之外唯一可以使用的途径。然而，通过你的网页浏览器，你也可以使用`POST`方法，这种方法通常用于发送表单数据。虽然可以通过`GET`方法发送表单数据，但这种方法会将参数污染URL，并且在可以发送的数据大小方面有一些限制。
- en: There are other methods that are often used, these being `PUT` and `DELETE`,
    but you need a specific client to utilize them. That is why a set of these four
    methods is used in order to build what is called a `REST` API. There are other
    methods, but it is beyond the scope of this book to dig into all the HTTP methods,
    focusing instead on the ones that are most commonly used. A `REST` API is essentially
    a set of *paths* and methods that respond to specific requests. An HTTP server
    exposing a `REST` API is called a `REST server`. In order to understand why different
    methods are available, you need to understand how are they used. If you need to
    request some data, you are trying to get this data back, hence, the `GET` method
    is the most appropriate. If, instead, you want to modify a resource you are already
    familiar with, you want to put some specific values in a known location, you will
    use the `PUT` method, which essentially changes the state of the server in a known
    place. If you need to somehow modify the state of the server, you need to search
    for the resources to modify. For example, if you do not know their IDs, you will
    use the `POST` method. This is why you will often find online that the most common
    explanation for when to use `POST` and `PUT` is that the former is used to add
    resources, while the latter is used to update resources. Although this is most
    often true, it is not always the case, as you may also perform updates with the
    `POST` method.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他常用的方法，这些是 `PUT` 和 `DELETE`，但您需要特定的客户端来使用它们。这就是为什么使用这四种方法来构建所谓的 `REST` API。还有其他方法，但本书的范围不涉及所有
    HTTP 方法，而是专注于最常用的方法。`REST` API 实质上是一组 *路径* 和方法，它们响应特定的请求。公开 `REST` API 的 HTTP
    服务器称为 `REST` 服务器。为了理解为什么有不同方法可用，您需要了解它们是如何使用的。如果您需要请求一些数据，您正在尝试获取这些数据，因此，`GET`
    方法是最合适的。如果您相反，想要修改您已经熟悉的一个资源，您想在已知位置放置一些特定的值，您将使用 `PUT` 方法，这本质上会在已知位置更改服务器的状态。如果您需要以某种方式修改服务器的状态，您需要查找要修改的资源。例如，如果您不知道它们的
    ID，您将使用 `POST` 方法。这就是为什么您经常在网上看到，关于何时使用 `POST` 和 `PUT` 的最常见解释是，前者用于添加资源，而后者用于更新资源。尽管这通常是真的，但并不总是如此，因为您也可能使用
    `POST` 方法执行更新。
- en: In the next exercise, you will see how to use the different methods, `GET` and
    `POST`, to do different things with the same function. Note that in general, you
    might use more sophisticated external libraries to have more elegant code, but
    here, we are looking at how to do the basics and show how the standard Go library
    already offers us much in terms of helping us to do our work.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将看到如何使用不同的方法，`GET` 和 `POST`，以相同的函数完成不同的事情。请注意，通常，您可能会使用更复杂的第三方库来编写更优雅的代码，但在这里，我们关注的是如何做基础，并展示标准
    Go 库已经为我们提供了很多帮助来完成我们的工作。
- en: 'Exercise 15.07: Completing a Questionnaire'
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 15.07：完成问卷
- en: In this exercise, you will build a form and you will send the data to another
    page. The form will contain questions such as your name, surname, and age, and
    this data will be sent to another page, which will display them. You will make
    use of what you've already learned, plus you'll see how to grab `posted` parameters
    from your `HTTP` request.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将构建一个表单，并将数据发送到另一个页面。表单将包含诸如您的姓名、姓氏和年龄等问题，这些数据将被发送到另一个页面，该页面将显示它们。您将利用您已经学到的知识，同时您还将了解如何从您的
    `HTTP` 请求中获取 `posted` 参数。
- en: 'First of all, create a folder called `questionnaire` and, inside this folder,
    incorporate a file called `index.html` with the following content:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `questionnaire` 的文件夹，并在该文件夹内包含一个名为 `index.html` 的文件，其内容如下：
- en: '[PRE71]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is a normal template displaying items of personal information. If any data
    is missing, we simply display it as empty strings without hiding them.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个显示个人信息项的正常模板。如果任何数据缺失，我们简单地将其显示为空字符串，而不是隐藏它们。
- en: 'Now, create a file called `form.html` and add the following content:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `form.html` 的文件，并添加以下内容：
- en: '[PRE72]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is another page inside a form, with three text inputs and a button. The
    input fields represent the details we want to send. Note that the form has the
    action set to `"/",` which means that when clicking the button, the page gets
    redirected to the main path, but will transport the dataset in the form. The method
    attribute is set to `post,` which is the HTTP method discussed earlier.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是在表单内部的一个另一页，包含三个文本输入和一个按钮。输入字段代表我们想要发送的详细信息。请注意，表单的动作设置为`"/"`，这意味着当点击按钮时，页面会被重定向到主路径，但会携带表单中的数据集。方法属性设置为`post`，这是我们之前讨论过的HTTP方法。
- en: 'You now have to create the actual server in Go. Create a `main.go` file and
    add the following:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你必须创建实际的Go服务器。创建一个`main.go`文件并添加以下内容：
- en: '[PRE73]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, create the struct for the template:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为模板创建结构体：
- en: '[PRE74]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This holds all the attributes required for the template.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这包含了模板所需的全部属性。
- en: 'Then, execute the following command:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，执行以下命令：
- en: '[PRE75]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This holds the template, as seen previously.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这包含了之前看到的模板。
- en: 'At this point, you need to create the `handler` function for the handler, so
    add the following:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你需要为处理程序创建`handler`函数，所以添加以下内容：
- en: '[PRE76]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, a new empty visitor is created.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，创建了一个新的空访客。
- en: 'Check whether the request is a `Post` request, so you need to add:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查请求是否为`Post`请求，因此你需要添加：
- en: '[PRE77]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This checks the method against a constant provided by the Go `http` package.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这检查方法与Go `http`包提供的常量是否匹配。
- en: 'Parse the form:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析表单：
- en: '[PRE78]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If an error occurs when parsing the form, we return with a `400` code, which
    is a bad request.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果解析表单时发生错误，我们返回`400`代码，这是一个错误请求。
- en: 'If the form gets parsed correctly, we can proceed, so add the following:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果表单解析正确，我们可以继续，所以添加以下内容：
- en: '[PRE79]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, all the parameters from the form get assigned to the visitor's attribute.
    We then close the `if` statement and go to the common part of the handler function.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，表单中的所有参数都被分配给访客的属性。然后我们关闭`if`语句，转到处理程序函数的公共部分。
- en: 'As we have a visitor, empty or not depending on whether the form has been posted
    and with what values, we can finally return the page, so write:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们有访客，无论表单是否已提交以及提交了什么值，我们最终可以返回页面，所以编写：
- en: '[PRE80]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We need to have a way to create the handler, so, as you''ve done before, add
    the following function:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要有一种方法来创建处理程序，所以，就像你之前做的那样，添加以下函数：
- en: '[PRE81]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'At this point, you can write the `main()` function, which creates the handler,
    assigns it to the main path, and then assigns the static `form.html` file to the
    `/form` path:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你可以编写`main()`函数，它创建处理程序，将其分配给主路径，然后将静态`form.html`文件分配给`/form`路径：
- en: '[PRE82]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run your server, you will see the following by going to the main page:![Figure
    15.34: Empty details page'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的服务器，你将看到以下内容，当你访问主页时：![图15.34：空详情页面
- en: '](img/B14177_15_34.jpg)'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_15_34.jpg)'
- en: 'Figure 15.34: Empty details page'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.34：空详情页面
- en: 'If you go to the `/form` path, you''ll see:![Figure 15.35: Empty form page'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你访问`/form`路径，你会看到：![图15.35：空表单页面
- en: '](img/B14177_15_35.jpg)'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_15_35.jpg)'
- en: 'Figure 15.35: Empty form page'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.35：空表单页面
- en: 'And if you fill the data:![Figure 15.36: Filled form page'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你填写了数据：![图15.36：已填写表单页面
- en: '](img/B14177_15_36.jpg)'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_15_36.jpg)'
- en: 'Figure 15.36: Filled form page'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图15.36：已填写表单页面
- en: 'And then press the `send` button, you will be redirected to this page:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按下`send`按钮，你将被重定向到这个页面：
- en: '![Figure 15.37: Page with details added'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.37：添加了详情的页面'
- en: '](img/B14177_15_37.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_37.jpg)'
- en: 'Figure 15.37: Page with details added'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.37：添加了详情的页面
- en: This, again, is the main page with the details set via the parameters you put
    into the form.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这，同样，是设置了通过表单中输入的参数的详情的主页面。
- en: JSON loads
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON加载
- en: Not all HTTP servers are meant to be used by a browser and a human user. Very
    often, we have different software programs communicating with each other. These
    programs need to send messages to one another through a commonly accepted format,
    one of these being JSON. This stands for JavaScript Object Notation, which essentially
    means that it mimics how objects are created directly in JavaScript (another programming
    language). It is a simple format, not particularly verbose, and is easy to parse
    by a piece of software and easy to read for a human. As a user, however, you can
    use any one of the many tools to send and receive JSON payloads, two of the most
    common ones being **Insomnia** and **Postman**, which you can easily find online
    at [https://packt.live/2RY13Dt](https://packt.live/2RY13Dt) and [https://packt.live/2RY13Dt](https://packt.live/2RY13Dt).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有HTTP服务器都是为了被浏览器和人类用户使用。很多时候，我们有不同的软件程序在相互通信。这些程序需要通过一个共同接受的格式相互发送消息，其中之一就是JSON。这代表JavaScript对象表示法，本质上意味着它模仿了在JavaScript（另一种编程语言）中直接创建对象的方式。它是一个简单的格式，不是特别冗长，并且易于软件解析和人类阅读。然而，作为用户，你可以使用许多工具中的任何一个来发送和接收JSON有效负载，其中最常见的是**Insomnia**和**Postman**，你可以在网上轻松找到它们，网址分别是[https://packt.live/2RY13Dt](https://packt.live/2RY13Dt)和[https://packt.live/2RY13Dt](https://packt.live/2RY13Dt)。
- en: They are both free and available for different platforms. You could also use
    `curl` as a command-line tool, but this becomes more complicated.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是免费的，并且适用于不同的平台。你也可以使用`curl`作为命令行工具，但这会变得复杂一些。
- en: 'Exercise 15.08: Building a Server That Accepts JSON Requests'
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.08：构建接受JSON请求的服务器
- en: 'In this exercise, you will build a server that accepts a JSON message and will
    respond with another JSON message. You will not be able to use your browser to
    test it, but you can do it with a client such as **Insomnia** or **Postman**.
    The example screenshots will be provided using **Insomnia**, so it would be good
    for you to use the same. The server you will build accepts a message with a name
    and surname, and returns a message with some personalized greetings:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将构建一个接受JSON消息的服务器，并以另一个JSON消息作为响应。你将无法使用浏览器来测试它，但你可以使用像**Insomnia**或**Postman**这样的客户端来测试。示例截图将使用**Insomnia**提供，所以最好你也使用相同的工具。你将构建的服务器接受包含名字和姓氏的消息，并返回包含一些个性化问候的消息：
- en: 'Create a folder called `json-server` and add a file to it called `main.go`.
    Start adding packages and imports to the file:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`json-server`的文件夹，并在其中添加一个名为`main.go`的文件。开始向文件中添加包和导入：
- en: '[PRE83]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, the packages imported are customary for HTTP programming, for logging,
    for formatting strings, and, of course, for JSON encoding.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，导入的包是HTTP编程、日志记录、字符串格式化和当然，JSON编码的常规包。
- en: 'After this, you need to create models for the incoming and outcoming messages,
    so write the following:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，你需要为传入和传出的消息创建模型，所以编写以下内容：
- en: '[PRE84]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These are pretty straightforward structs, including only what we need.
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些结构体相当简单，只包含我们所需要的部分。
- en: 'Now, add the `main` function:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`main`函数：
- en: '[PRE85]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And now set the function to handle the JSON messages:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将函数设置为处理JSON消息：
- en: '[PRE86]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, the first thing inside the function is to create a JSON decoder,
    which will decode the request's body.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，函数内部的第一件事是创建一个JSON解码器，它将解码请求的主体。
- en: 'As a next step, write the following:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为下一步，编写以下内容：
- en: '[PRE87]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we define a data variable of the `Request` type and we decode the body
    of the HTTP request into it. In case of any error, we return a `400` code for
    a bad request.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`Request`类型的数据变量，并将HTTP请求的主体解码到它里面。如果发生任何错误，我们返回一个`400`错误代码表示请求无效。
- en: 'Once the data has been decoded correctly, you can now use this data to create
    the response:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据被正确解码，你现在可以使用这些数据来创建响应：
- en: '[PRE88]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, the name and surname from the request are combined in a personalized greeting
    message.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，请求中的名字和姓氏被合并成一个个性化的问候信息。
- en: 'All that is now left is to send the message back to the requester:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在剩下的就是将信息发送回请求者：
- en: '[PRE89]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here, the response is encoded into a JSON string and is sent, writing it as
    a slice of bytes into the response writer. You can now run the server and open
    `Insomnia`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，响应被编码成一个JSON字符串并发送，将其作为字节数组写入响应写入器。现在你可以运行服务器并打开`Insomnia`：
- en: 'Now, create the `main()` function to serve the pages:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`main()`函数来提供页面服务：
- en: '[PRE90]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 15.38: Insomnia response'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.38：Insomnia响应]'
- en: '](img/B14177_15_38.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_15_38.jpg]'
- en: 'Figure 15.38: Insomnia response'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.38：Insomnia响应
- en: As you can see, you can make a `post` request with Insomnia and send a JSON
    string to your server. On the right, you will see the response as a JSON document.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以使用 Insomnia 发送 `post` 请求并将 JSON 字符串发送到您的服务器。在右侧，您将看到作为 JSON 文档的响应。
- en: Summary
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you''ve been introduced to the server side of web programming.
    You''ve learned how to accept requests from HTTP clients and respond in an appropriate
    manner. You''ve learned how to separate the possible requests into different areas
    of an HTTP server via paths and sub-paths. For this, you used a simple routing
    mechanism with the standard `Go HTTP` package. You''ve seen how to return your
    response in order to suit different consumers: JSON responses for synthetic clients,
    and HTML pages for human access. You''ve seen how to use templates in order to
    format your plain text and HTML messages, using the standard templating package.
    You''ve learned how to serve and use static resources, serving them directly through
    a default file server or through a template object. You''ve also learned what
    a `REST` service is, and although we have not built one together, you have all
    the knowledge necessary to create one, provided you follow the description you''ve
    been given. At this stage, you know all the basics for building production-grade
    HTTP servers, although you might want to use some external libraries to facilitate
    your hello world example, facilitating better routing by using something such
    as `gorilla mux` or, generally, the entire `gorilla` package, which is a low-level
    abstraction on top of the `http` package. You could use `hero` as a template engine
    to make your page rendering faster. One thing to mention is that you can make
    pretty much stateless services with what you''ve learned in this chapter, but
    you cannot create a production-grade stateful server at the moment as you do not
    know how to handle concurrent requests. This means that our `views counter` is
    not suitable for a production server yet, but this will be the subject of another
    chapter.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了网络编程的服务器端。您学习了如何接受来自 HTTP 客户端的请求并以适当的方式响应。您学习了如何通过路径和子路径将可能的请求分离到
    HTTP 服务器的不同区域。为此，您使用了一个简单的路由机制和标准的 `Go HTTP` 包。您看到了如何返回响应以适应不同的消费者：为合成客户端返回 JSON
    响应，为人类访问返回 HTML 页面。您还看到了如何使用模板来格式化您的纯文本和 HTML 消息，使用标准的模板包。您学习了如何提供和使用静态资源，直接通过默认文件服务器或通过模板对象提供。您还学习了什么是
    `REST` 服务，尽管我们还没有一起构建一个，但您已经拥有了创建一个所需的所有知识，只要您遵循您所得到的描述。在这个阶段，您已经了解了构建生产级 HTTP
    服务器的所有基础知识，尽管您可能想要使用一些外部库来简化您的 hello world 示例，通过使用像 `gorilla mux` 或通常的整个 `gorilla`
    包来更好地实现路由，这是一个在 `http` 包之上的低级抽象。您可以使用 `hero` 作为模板引擎来加快页面渲染速度。有一点需要提及的是，您可以使用本章中学到的知识创建几乎无状态的服务，但您目前无法创建一个生产级的有状态服务器，因为您不知道如何处理并发请求。这意味着我们的
    `视图计数器` 还不适合生产服务器，但这将是下一章的主题。
- en: In the next chapter, you will see how Go leverages the system of Goroutines
    to handle multiple work at the same time. This feature is very important, and
    you can apply it to HTTP servers and other types of projects where you have many
    concurrent users or whenever you want to do a lot of things at the same time.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将看到 Go 如何利用 Goroutines 系统同时处理多个任务。这个特性非常重要，您可以将它应用到 HTTP 服务器和其他类型的项目中，在这些项目中您有很多并发用户或您想要同时做很多事情。
