- en: 18\. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18. 安全
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to equip you with the basic skills to protect your code from
    attacks and vulnerabilities. You will be able to evaluate the workings of major
    attack vectors, implement crypto libraries for the encryption and decryption of
    data and implement communication security by using TLS certificates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为你提供保护代码免受攻击和漏洞的基本技能。你将能够评估主要攻击向量的工作原理，实现用于数据加密和解密的加密库，并通过使用TLS证书实现通信安全。
- en: By the end of the chapter, you will be equipped to identify common issues with
    code that could lead to security loopholes, and refactor code to make it more
    secure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够识别可能导致安全漏洞的常见代码问题，并重构代码以提高其安全性。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about Go tools such as `fmt`, `vet`, and
    `race`, which are designed to help you with your code development. Let's now look
    at how to secure your code by looking at examples of common vulnerabilities. We'll
    also look at the packages in the standard library that can help you to store your
    data securely.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Go工具，如`fmt`、`vet`和`race`，这些工具旨在帮助你进行代码开发。现在，让我们看看如何通过查看常见漏洞的示例来保护你的代码。我们还将查看标准库中的包，这些包可以帮助你安全地存储数据。
- en: Security cannot be an afterthought. It should be part of your code kata, something
    that you practice every day. Most vulnerabilities in applications stem from the
    developer not knowing about potential security attacks and from not having a security
    review of the application before it gets deployed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性不能是事后考虑的事情。它应该是你代码练习的一部分，是你每天都要练习的东西。应用程序中的大多数漏洞都源于开发者不了解潜在的安全攻击，以及没有在应用程序部署前对其进行安全审查。
- en: If you look at any websites dealing with sensitive data, for example, banking
    websites, they will have basic security in place, such as the use of a signed
    SSL certificate. It is always better to design your application with security
    in mind than to add security layers later, so as to avoid refactoring or redesigning
    your application. In this chapter, we will cover some major attack vectors and
    best practices that will guide you in securing your application. The following
    basic sanity checks in your code will guarantee that you are protected by default
    from most vulnerabilities and attacks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看任何处理敏感数据的网站，例如，银行网站，它们将具备基本的安全措施，例如使用已签名的SSL证书。在设计应用程序时始终考虑安全性，而不是事后添加安全层，这样可以避免重构或重新设计应用程序，这总是更好的。在本章中，我们将介绍一些主要的攻击向量以及最佳实践，这些将指导你保护你的应用程序。以下代码中的基本合理性检查将确保你默认受到大多数漏洞和攻击的保护。
- en: Application Security
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序安全
- en: During the development of your application, you will not be able to anticipate
    all the possible ways in which it could be compromised. However, you can always
    try to safeguard the application by following safe coding practices, such as the
    encryption of data in transit and at rest. It is a well-known fact that if we
    protect an application from well-known attack vectors such as SQL injection, we
    will be able to ward off most attacks. We will cover topics such as the use of
    digital certificates and hashing sensitive data to protect it from attackers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序开发过程中，你将无法预测它可能被攻击的所有可能方式。然而，你始终可以通过遵循安全的编码实践来尝试保护应用程序，例如在传输和静止状态下加密数据。众所周知，如果我们保护应用程序免受SQL注入等已知攻击向量的攻击，我们就能抵御大多数攻击。我们将讨论使用数字证书和散列敏感数据以保护其免受攻击者侵害的话题。
- en: One of the major attack vectors of a software application is the command or
    SQL injection, in which malicious user input can change the behavior of a command
    or query. This can happen with poorly constructed queries in SQL, HTTP URLs, or
    in OS commands.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序的主要攻击向量之一是命令或SQL注入，恶意用户输入可以改变命令或查询的行为。这可能在SQL查询、HTTP URL或操作系统命令中的构建不良查询时发生。
- en: Let's look at SQL injection and command injection in detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看SQL注入和命令注入。
- en: SQL Injection
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL注入
- en: If you are working on an application that needs to store data, you will most
    likely be using a database.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发需要存储数据的应用程序，你很可能会使用数据库。
- en: SQL injection is a way of injecting malicious code into your database query.
    Although unintentional, this could have a drastic impact on your application,
    such as the loss of data or the leaking of sensitive information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SQL注入是一种将恶意代码注入到你的数据库查询中的方法。尽管这是无意的，但这可能对你的应用程序产生重大影响，例如数据丢失或敏感信息泄露。
- en: Let's look at some examples to understand what exactly the SQL injection is
    and how it works.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例，以了解SQL注入的确切内容和它是如何工作的。
- en: 'The following function takes a `userID` parameter and uses it to query the
    database to return the card number that belongs to the user:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受一个`userID`参数，并使用它来查询数据库以返回属于用户的卡号：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the user input is `795001`, the query string will resolve to:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入是`795001`，查询字符串将解析为：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, it is possible for a malicious user to construct an input string that
    will cause the function to retrieve information that does not belong to the user.
    For example, they could pass in the following input to the function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，恶意用户可以构造一个输入字符串，导致函数检索不属于用户的信息。例如，他们可以向函数传递以下输入：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This user input would generate a query that would return the `CARD_NUMBER`
    of all users:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户输入将生成一个查询，该查询将返回所有用户的`CARD_NUMBER`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, it is very easy to make a mistake when defining a database query.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在定义数据库查询时很容易出错。
- en: Along with getting unauthorized access to data, SQL injection can also be used
    to corrupt or even delete data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取未经授权的数据访问外，SQL注入还可以用于破坏或甚至删除数据。
- en: 'So, what is the idiomatic way of defining a query? We should never construct
    a query by concatenating user input to form a query string. Instead, use a prepared
    statement to define a query, in which a placeholder is used to pass the user parameter,
    as shown in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，定义查询的惯用方法是什么？我们绝对不应该通过将用户输入连接成查询字符串来构造查询。相反，使用预处理语句来定义查询，其中使用占位符传递用户参数，如下例所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using placeholders for the user input, we have mitigated potential SQL injection
    attacks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用用户输入的占位符，我们已经减轻了潜在的SQL注入攻击。
- en: Command Injection
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令注入
- en: Command injection is another possible injection attack vector that you should
    be aware of. The injection aims to execute OS commands on the application server,
    which could allow the attacker to get sensitive data, delete files, or even execute
    malicious scripts on the server. This type of attack can happen when the user
    input is not sanitized.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 命令注入是另一种应警惕的注入攻击向量。注入的目的是在应用程序服务器上执行OS命令，这可能允许攻击者获取敏感数据、删除文件，甚至在服务器上执行恶意脚本。这种攻击可能发生在用户输入未经过滤的情况下。
- en: 'We will see how this works by looking at the following example. Consider this
    function, which takes a string as input and uses it to list files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下示例了解它是如何工作的。考虑这个函数，它接受一个字符串作为输入并使用它来列出文件：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few things wrong here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个问题：
- en: The user input is not sanitized.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入未经过滤。
- en: The user could pass in any string as a path.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以传递任何字符串作为路径。
- en: Along with `path string`, the user could add other commands that could run on
    the server.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了`path string`之外，用户还可以添加其他可以在服务器上运行的命令。
- en: 'Let''s test this by running a unit test on the function. The following test
    run should prove all the issues previously listed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过对这个函数运行单元测试来测试这一点。以下测试运行应该证明之前列出的所有问题：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should get the following output when you run the test using the preceding
    command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用前面的命令运行测试时，应该得到以下输出：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Figure 19.1: Expected output'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.1：预期输出'
- en: '](img/B14177_18_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.1：预期输出](img/B14177_18_01.jpg)'
- en: 'Figure 18.1: Expected output'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：预期输出
- en: As you can see, instead of passing a valid filename, the user passed a string
    that made the function return the files in the directory as well as reading the
    `/etc/hosts` file on the server.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用户没有传递有效的文件名，而是传递了一个使函数返回目录中的文件以及读取服务器上的`/etc/hosts`文件的字符串。
- en: 'Exercise 18.01: Handling SQL Injection'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.01：处理SQL注入
- en: In this exercise, we will be enabling a function to prevent an SQL injection
    attack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将启用一个功能来防止SQL注入攻击。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this exercise, we will be using a lightweight database called `Sqlite`, which
    can run in-memory on your local machine. To use the database, we will need to
    import a third-party Go library that uses `cgo` under the hood.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个轻量级的数据库`Sqlite`，它可以在您的本地机器上内存中运行。要使用数据库，我们需要导入一个使用`cgo`的第三方Go库。
- en: '[https://packt.live/38Bjl3a](https://packt.live/38Bjl3a)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/38Bjl3a](https://packt.live/38Bjl3a)'
- en: 'If you are on a Windows machine, you will need to have GCC installed and included
    in your path. You can use the instructions on this website to install GCC for
    windows: https://packt.live/38Bjl3a.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows机器，您需要安装GCC并将其包含在您的路径中。您可以使用此网站上的说明为Windows安装GCC：https://packt.live/38Bjl3a。
- en: 'The following steps will help you with the solution:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你解决问题：
- en: 'Create `injection.go` and import the following packages:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`injection.go`并导入以下包：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a function, `UpdatePhone()`, that takes a `sql.DB` object and some user
    information such as an ID and a phone number as a `string`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`UpdatePhone()`的函数，该函数接受一个`sql.DB`对象和一些用户信息，如ID和电话号码（作为字符串）：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `UpdatePhone()` function inserts a user ID and a phone number into the table
    by concatenating the data from the input parameters.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UpdatePhone()`函数通过拼接输入参数中的数据将用户ID和电话号码插入到表中。'
- en: 'The query string in the `UpdatePhone()` function is vulnerable to SQL injection.
    For example, if an input is passed with the following values:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UpdatePhone()`函数中的查询字符串容易受到SQL注入的影响。例如，如果传递以下值的输入：'
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will update the record not only for user ID `"19853011"`, but also for
    `"1007007"`. This is a simple example. However, there could be worse things that
    could happen, such as dropping tables in the database.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将不仅更新用户ID为`"19853011"`的记录，还会更新`"1007007"`的记录。这是一个简单的例子。然而，可能会发生更糟糕的事情，比如在数据库中删除表。
- en: 'Create another function called `UpdatePhoneSecure()`, which will update the
    user details securely. Instead of concatenating inputs to form the query, use
    placeholders for the parameters to pass into the query:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`UpdatePhoneSecure()`的函数，该函数将安全地更新用户详细信息。而不是将输入拼接成查询，使用占位符传递参数到查询中：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define a helper function called `initializeDB()` to set up the database and
    load some test data:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`initializeDB()`的辅助函数，用于设置数据库并加载一些测试数据：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice to clean up after every test.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每次测试后进行清理是一个好习惯。
- en: 'Define a function called `tearDownDB()` to help you clear the database:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`tearDownDB()`的函数，帮助你清理数据库：
- en: '[PRE13]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will also need a function to help with the setting up of the database connection.
    Define a function called `getConnection()`, which returns a `*sql.DB` object:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来帮助设置数据库连接。定义一个名为`getConnection()`的函数，它返回一个`*sql.DB`对象：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define a `TestMain()` function that executes the setup of the test data and
    then runs the test. This function will also need to call the `tearDownDB()` function
    to clean up the test data:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`TestMain()`函数，该函数执行测试数据的设置，然后运行测试。此函数还需要调用`tearDownDB()`函数来清理测试数据：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, define the `TestUpdatePhoneSecure()` function to help you run a test
    against the `UpdatePhoneSecure()` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，定义`TestUpdatePhoneSecure()`函数，帮助你运行针对`UpdatePhoneSecure()`函数的测试：
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the test using the following command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试：
- en: '[PRE17]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should get the following output:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 19.2: Expected output'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.2：预期输出'
- en: '](img/B14177_18_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_18_02.jpg)'
- en: 'Figure 18.2: Expected output'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2：预期输出
- en: SQL and command injection can occur when user input is not correctly sanitized.
    Generally, we should avoid passing user input directly into SQL or OS commands.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入未正确清理时，可能会发生SQL和命令注入。通常，我们应该避免直接将用户输入传递到SQL或操作系统命令中。
- en: In this exercise, we have learned how to securely code SQL code to protect an
    application from SQL injection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何安全地编写SQL代码以保护应用程序免受SQL注入的攻击。
- en: Cross-Site Scripting
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: Cross-Site Scripting, or XSS, is another major attack type that is frequently
    listed in the OWASP (**Open Web Application Security Project**) of top ten application
    vulnerabilities. Similar to SQL injection, this vulnerability is also caused by
    non-sanitized user input, but in this case, rather than modifying the behavior
    of a database, it injects scripts into a web page.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击（XSS）是另一种常见的攻击类型，经常被列入OWASP（**开放网络应用安全项目**）的前十种应用程序漏洞。与SQL注入类似，这种漏洞也是由未清理的用户输入引起的，但在这个情况下，它不是修改数据库的行为，而是将脚本注入到网页中。
- en: 'Web pages are constructed using html tags. Every html page contains some content
    bracketed by the html tag, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 网页使用HTML标签构建。每个HTML页面都包含一些由HTML标签括起来的内容，如下所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One such html tag is the `<script>` tag, which is used to embed executable content
    – usually, JavaScript code. This tag is used to run client-side code execution
    on the browser, for example, to generate dynamic content or manipulate data and
    images.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个HTML标签是`<script>`标签，用于嵌入可执行内容——通常是JavaScript代码。此标签用于在浏览器上执行客户端代码执行，例如，生成动态内容或操作数据和图像。
- en: The code inside the `<script>` tag is not visible on the web page and, as such,
    it generally goes unnoticed. This feature of the `<script>` tag can be manipulated
    by attackers to run malicious scripts to steal sensitive data, monitor activity,
    or perform other unauthorized actions. So, how does the malicious script get injected
    in the first place? If user data entered through a browser is not sanitized, an
    attacker can input/inject a malicious script to the web server, which can then
    be stored on the database.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`<script>` 标签内的代码在网页上不可见，因此通常不会被注意到。这个 `<script>` 标签的特性可以被攻击者利用来运行恶意脚本，窃取敏感数据，监控活动或执行其他未经授权的操作。那么，恶意脚本最初是如何注入的呢？如果通过浏览器输入的用户数据没有经过清理，攻击者可以向Web服务器输入/注入恶意脚本，然后它可以存储在数据库中。'
- en: When a victim visits the page, the script gets loaded onto their browser.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当受害者访问页面时，脚本会被加载到他们的浏览器中。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'OWASP is an organization that provides useful information to secure your application.
    They provide rankings for the common application security vulnerabilities such
    as the OWASP top 10:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP是一个提供有用信息以保护应用程序的组织。他们为常见的应用程序安全漏洞提供排名，如OWASP前10名：
- en: '[https://packt.live/36t6RbU](https://packt.live/36t6RbU)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/36t6RbU](https://packt.live/36t6RbU)'
- en: 'You can find more information about OWASP here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在OWASP这里找到更多信息：
- en: '[https://packt.live/34ioCsZ](https://packt.live/34ioCsZ)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/34ioCsZ](https://packt.live/34ioCsZ)'
- en: 'Exercise 18.02: Handling XSS Attacks'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.02：处理XSS攻击
- en: 'In this exercise, we will see how an XSS attack can be carried out on a web
    page, and then we will fix the issue with the code to make it safe from this type
    of attack:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何在网页上执行XSS攻击，然后我们将用代码修复这个问题，使其免受此类攻击：
- en: 'Create a `main.go` file and import the following packages:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并导入以下包：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Define a sample HTML template that can be used to load a web page. For multiline
    text assignment to a variable, you can use the string enclosed by backticks(``
    ` ``):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个可以用来加载网页的示例HTML模板。对于多行文本赋值给变量，可以使用反引号（`` ` ``）包围的字符串：
- en: '[PRE20]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a `struct` called `input`, which contains a field called `Comment` as
    a `string` value. This `struct` will be used to wrap a user comment:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `input` 的 `struct`，其中包含一个名为 `Comment` 的 `string` 类型的字段。这个 `struct` 将被用来包装用户评论：
- en: '[PRE21]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a `handler()` function to return the response of an HTTP request:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `handler()` 函数以返回HTTP请求的响应：
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the `main()` function to run an HTTP server:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main()` 函数以运行HTTP服务器：
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码：
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open `http://localhost:8080` on the browser. You should be able to see the
    following page:![Figure 19.3: HTTP server landing page'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://localhost:8080`。你应该能看到以下页面：![图19.3：HTTP服务器登录页面
- en: '](img/B14177_18_03.jpg)'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_18_03.jpg)'
- en: '[PRE25]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is what you will see:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是你将看到的内容：
- en: '![Figure 19.4: XSS execution'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图19.4：XSS执行'
- en: '](img/B14177_18_04.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_18_04.jpg)'
- en: 'Figure 18.4: XSS execution'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图18.4：XSS执行
- en: 'Let''s fix our web application to make it safe from XXS attacks. In this case,
    the solution is as simple as updating from `text/template` to use the `html/template`
    package:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修复我们的Web应用程序，使其免受XXS攻击。在这种情况下，解决方案就像从 `text/template` 更新到使用 `html/template`
    包一样简单：
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the server again and then submit the same input, your output will
    be escaped by the `html/template` library and, thus, will not be treated as a
    script:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你再次运行服务器并提交相同的输入，你的输出将被 `html/template` 库转义，因此不会被当作脚本处理：
- en: '![Figure 19.5: XSS escaped output'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.5：XSS转义输出'
- en: '](img/B14177_18_05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_18_05.jpg)'
- en: 'Figure 18.5: XSS escaped output'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5：XSS转义输出
- en: In this exercise, we learned about the proper use of templating in code to protect
    an application from cross-site scripting attacks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了在代码中正确使用模板化以保护应用程序免受跨站脚本攻击的方法。
- en: Cryptography
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: Go has a very comprehensive crypto library included as part of the standard
    library, which covers hashing algorithms, PKI certificates, and symmetric and
    asymmetric encryption algorithms.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Go的标准库中包含了一个非常全面的加密库，涵盖了哈希算法、PKI证书以及对称和非对称加密算法。
- en: While it is convenient to have a collection of different ciphers' encryption
    and hashing libraries available for us to use, it is important for us to be aware
    of vulnerabilities in these algorithms, so we can choose the most appropriate
    algorithm for our use case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有不同加密和哈希库的集合供我们使用很方便，但我们还需要意识到这些算法中的漏洞，以便我们可以为我们的用例选择最合适的算法。
- en: For example, the MD5 and SHA-1 hashing algorithms are not considered safe to
    use for encrypting data, as they are easily brute-forced. However, they are commonly
    used by file servers to provide file checksums for error checking.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MD5和SHA-1哈希算法被认为不安全用于加密数据，因为它们很容易被暴力破解。然而，它们通常被文件服务器用于提供文件校验和以进行错误检查。
- en: Hashing Libraries
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希库
- en: Hashing is the process of converting plaintext data into an encrypted format
    by implementing an algorithm to produce the encrypted text. The output of such
    a process is supposed to be unique and the probability of a hash collision, which
    is two different inputs producing the same output, is extremely unlikely. Hashing
    functions are routinely used in databases and in the secure transmission of messages.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是将明文数据转换为加密格式的过程，通过实现一个生成加密文本的算法。这个过程的结果应该是唯一的，并且哈希碰撞的概率，即两个不同的输入产生相同的输出，极不可能。哈希函数在数据库和消息的安全传输中经常被使用。
- en: 'We can use the checksum functions to produce a one-way hash. For example, to
    produce an MD5 checksum, we can use the `Sum()` function, which takes in a `byte`
    array and returns a `byte` array:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用校验和函数来生成单向哈希。例如，要生成MD5校验和，我们可以使用`Sum()`函数，它接受一个`byte`数组并返回一个`byte`数组：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For SHA256, the checksum function definition is very similar:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SHA256，校验和函数的定义非常相似：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Apart from MD5, the standard library for Go contains implementations for SHA1,
    SHA256, and SHA512\. We will see how to use them in the upcoming exercise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了MD5之外，Go的标准库包含SHA1、SHA256和SHA512的实现。我们将在接下来的练习中看到如何使用它们。
- en: 'Exercise 18.03: Using Different Hashing Libraries'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.03：使用不同的哈希库
- en: 'In this exercise, we will learn how to use different hashing libraries in Go:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何在Go中使用不同的哈希库：
- en: 'Create a `main.go` file and import the following crypto hashing libraries:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件并导入以下加密哈希库：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a utility function called `getHash()` that takes in an input string
    to be hashed and the type of hash library to use. Define a `switch` statement
    that uses the `hashType` input string to decide which type of hashing library
    to use:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`getHash()`的实用函数，它接受要哈希的输入字符串和要使用的哈希库类型。定义一个使用`hashType`输入字符串来决定使用哪种哈希库的`switch`语句：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Inside the `switch` statement, add cases for using MD5, SHA256, SHA512, and
    SHA3_512\. The `switch` cases should return the hash of the input string using
    the corresponding hashing libraries:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`switch`语句中，添加使用MD5、SHA256、SHA512和SHA3_512的情况。`switch`情况应该使用相应的哈希库返回输入字符串的哈希值：
- en: '[PRE31]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add some other hashing libraries that are not available in the standard library:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些标准库中没有的哈希库：
- en: '[PRE32]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Apart from the `blake` libraries mentioned, you can also find packages for MD4
    and SHA3 under [https://packt.live/2PiwlmH](https://packt.live/2PiwlmH).
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了提到的`blake`库之外，您还可以在[https://packt.live/2PiwlmH](https://packt.live/2PiwlmH)下找到MD4和SHA3的包。
- en: 'Define the `main()` function and call the `getHashutility()` function defined
    previously:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`main()`函数并调用之前定义的`getHashutility()`函数：
- en: '[PRE33]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the program:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE34]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should get the following output:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 19.6: Expected output'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.6：预期输出'
- en: '](img/B14177_18_06.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_18_06.jpg)'
- en: 'Figure 18.6: Expected output'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6：预期输出
- en: In this exercise, we have learned how to generate ciphertext using different
    hashing packages available in Go.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用Go中可用的不同哈希包生成密文。
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding example, we imported some hashing libraries, such as [https://packt.live/2ryy9Ps](https://packt.live/2ryy9Ps).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们导入了某些哈希库，例如[https://packt.live/2ryy9Ps](https://packt.live/2ryy9Ps)。
- en: The packages under `golang.org/x/` are still developed as part of the Go project.
    However, they remain outside of the main installation, so you will have to run
    `go get` to install them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`golang.org/x/`下的包仍然是Go项目的一部分。然而，它们仍然位于主安装之外，因此您必须运行`go get`来安装它们。'
- en: 'You can find a list of these packages here: [https://packt.live/2tbThv7](https://packt.live/2tbThv7).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到这些包的列表：[https://packt.live/2tbThv7](https://packt.live/2tbThv7)。
- en: Encryption
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密
- en: Encryption is the process of converting data into a format in which it cannot
    be read by an unintended recipient.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是将数据转换为一种格式的过程，这样它就不能被未授权的接收者读取。
- en: When dealing with sensitive data, it is always best practice to encrypt it.
    The nature of the data will determine the sensitivity. For example, credit card
    information from your customers can be considered as highly sensitive data, whereas
    the item being bought could be considered as not very sensitive.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理敏感数据时，始终加密它是最佳实践。数据的性质将决定其敏感性。例如，客户的信用卡信息可以被认为是高度敏感数据，而购买的商品可能被认为不是非常敏感。
- en: You will probably come across the terms encryption at rest and encryption in
    transit, referring to how data should be encrypted before being stored (for example,
    in a database) or transmitted (for example, over a network). We will touch on
    encryption in transit in a later topic (HTTP/TLS).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到“静态加密”和“传输中加密”这两个术语，它们指的是在存储（例如，在数据库中）或传输（例如，通过网络）之前应该如何加密数据。我们将在后续主题（HTTP/TLS）中涉及传输中加密。
- en: In this topic, we will focus on the underlying encryption mechanisms.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将关注底层加密机制。
- en: Since (good) encryption algorithms are complicated by nature, the general advice
    is to always use existing encryption algorithms and not invent your own. The strength
    of an encryption algorithm should lie in the mathematical complexity of the problem,
    rather than in the secrecy of how the encryption algorithm works. As such, 'safe'
    encryption algorithms are all public.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于（好的）加密算法本质上很复杂，一般建议始终使用现有的加密算法，而不是发明自己的。加密算法的强度应在于问题的数学复杂性，而不是加密算法工作方式的保密性。因此，“安全”的加密算法都是公开的。
- en: Go provides both symmetric and asymmetric encryption libraries. Let's look at
    the example implementations of both these encryption types.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了对称加密和非对称加密库。让我们看看这两种加密类型的示例实现。
- en: Symmetric Encryption
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称加密
- en: With symmetric encryption, the same key is used for encryption and decryption.
    The Go standard library has implementations of common symmetric encryption algorithms
    such as AES and DES under `crypto/aes` and `crypto/des`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在对称加密中，相同的密钥用于加密和解密。Go 标准库在 `crypto/aes` 和 `crypto/des` 下提供了常见对称加密算法的实现，如 AES
    和 DES。
- en: 'The basic steps to encrypt an input byte array using a string key (for example,
    a password) are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串密钥（例如，密码）加密输入字节数组的基本步骤如下：
- en: 'To create the ciphertext in Go, we can use the `Seal()` function. We also use
    a `nonce`, which is a single-use random sequence. The `dst` input variable here
    is a byte array used to store the encrypted data:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建密文，我们可以使用 `Seal()` 函数。我们同样使用一个 `nonce`，它是一个一次性随机序列。这里的 `dst` 输入变量是一个字节数组，用于存储加密数据：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To decrypt the ciphertext, we need to again use the `crypto/cipher` library
    to make use of the GCM wrappers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文，我们需要再次使用 `crypto/cipher` 库来利用 GCM 包装器：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Exercise 18.04: Symmetric Encryption and Decryption'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.04：对称加密和解密
- en: 'In this exercise, we are going to make use of the Go crypto libraries for symmetric
    encryption and learn how to encrypt and decrypt data:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将利用 Go 的加密库进行对称加密，并学习如何加密和解密数据：
- en: 'Create a `main.go` file and import the following package:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并导入以下包：
- en: '`crypto/cipher`: For block cipher implementation.'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/cipher`：用于块加密实现。'
- en: '`crypto/aes`: AES is an encryption specification, and `crypto/aes` is the Go
    implementation.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/aes`：AES 是一种加密规范，`crypto/aes` 是 Go 的实现。'
- en: '`crypto/rand`: Used for random number generation.'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/rand`：用于随机数生成。'
- en: '[PRE37]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define a function to encrypt data using the `crypto/aes` and `crypto/cipher`
    libraries. The following function accepts input data in the form of a byte array
    and a key string, which is typically a secret passphrase. It returns the encrypted
    data:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，使用 `crypto/aes` 和 `crypto/cipher` 库加密数据。以下函数接受以字节数组形式输入的数据和一个密钥字符串，该字符串通常是秘密密码。它返回加密数据：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The nonce needs to be stored for decryption. There are many ways of doing this.
    In the preceding implementation, we do this by passing in the nonce in the first
    input to the `Seal()` function, which is a byte array, `dst`. Since the `Seal()`
    function appends the encrypted data to the input byte array, the resulting ciphertext
    will be appended to the nonce and returned as a one-byte array. If you pass in
    additional data, the value must match when you decrypt the resulting ciphertext.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要存储nonce以进行解密。有许多方法可以做到这一点。在前面的实现中，我们通过将nonce传递给 `Seal()` 函数的第一个输入来实现，这是一个字节数组，`dst`。由于
    `Seal()` 函数将加密数据追加到输入的字节数组中，因此生成的密文将追加到nonce上，并作为一个字节数组返回。如果您传递额外的数据，解密生成的密文时值必须匹配。
- en: 'Define a function to decrypt data. It should accept the encrypted data in the
    form of a byte array and the passphrase as a string. It should return the decrypted
    data:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个解密数据的函数。它应该接受以字节数组形式提供的加密数据和一个字符串形式的密码短语。它应该返回解密后的数据：
- en: '[PRE39]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the `main()` function to test the `encrypt` and `decrypt` functions:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main()` 函数以测试 `encrypt` 和 `decrypt` 函数：
- en: '[PRE40]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the program by using the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE41]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You should get the following output.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出。
- en: '![Figure 19.7: Expected output'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.7：预期输出'
- en: '](img/B14177_18_07.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_18_07.jpg]'
- en: 'Figure 18.7: Expected output'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.7：预期输出
- en: In this exercise, we have learned how to perform symmetric encryption and decryption.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何执行对称加密和解密。
- en: Asymmetric Encryption
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Asymmetric encryption is also known as public-key cryptography. This encryption
    mechanism makes use of a pair of keys, a public key and a private key. The public
    key can be freely distributed to other partners who are willing to exchange data
    with you. If a partner wants to send encrypted data, they will use your public
    key to encrypt their data. This encrypted data can be decrypted by you using your
    private key.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密也称为公钥加密。这种加密机制使用一对密钥，一个公钥和一个私钥。公钥可以自由地分发给愿意与您交换数据的其他合作伙伴。如果合作伙伴想要发送加密数据，他们将使用您的公钥来加密他们的数据。这些加密数据可以通过您的私钥由您解密。
- en: The Go standard library has support for common asymmetric encryption algorithms
    such as RSA and DSA.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库支持常见的非对称加密算法，如 RSA 和 DSA。
- en: 'For example, the `rsa.EncryptOAEP()` function is used to encrypt data using
    the public key:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `rsa.EncryptOAEP()` 函数通过公钥加密数据：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `rsa.DecryptOAEP()` function is used to decrypt the ciphertext using the
    private key:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rsa.DecryptOAEP()` 函数通过私钥解密密文：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The encryption operation takes in `rsa.PublicKey`, and the decryption operation
    takes `rsa.PrivateKey`. The key pair can be generated using the `rsa.GenerateKey()`
    function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加密操作接受 `rsa.PublicKey`，解密操作接受 `rsa.PrivateKey`。密钥对可以使用 `rsa.GenerateKey()` 函数生成：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Exercise 18.05: Asymmetric Encryption and Decryption'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.05：非对称加密和解密
- en: 'In this exercise, we will see the encrypt and decrypt operations in action:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到加密和解密操作的实际应用：
- en: 'Create a `main.go` file and import the following packages:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并导入以下包：
- en: '`crypto/rand`: The `rand.Reader` from this package will be used to seed the
    generation of the `rsa.PrivateKey`.'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/rand`：此包中的 `rand.Reader` 将用于生成 `rsa.PrivateKey` 的种子。'
- en: '`crypto/rsa`: This package is required to generate the private key and for
    the `encrypt/decrypt` operation.'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/rsa`：此包是生成私钥和进行 `encrypt/decrypt` 操作所必需的。'
- en: '`crypto/sha256`: The symmetric hash function will be used to seed the generation
    of the `rsa.PrivateKey`.'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/sha256`：对称哈希函数将被用于生成 `rsa.PrivateKey` 的种子。'
- en: '[PRE45]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define the `main()` function and generate an `rsa` key pair:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main()` 函数并生成一个 `rsa` 密钥对：
- en: '[PRE46]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Encrypt the data using `publicKey`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `publicKey` 加密数据：
- en: '[PRE47]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use `privateKey` to decrypt the ciphertext from *step 3*:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `privateKey` 解密第 *3* 步的密文：
- en: '[PRE48]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the program using the following command:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE49]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You should get the following output:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 19.8: Expected output'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.8：预期输出'
- en: '](img/B14177_18_08.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_18_08.jpg]'
- en: 'Figure 18.8: Expected output'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.8：预期输出
- en: We have now learned how to create an RSA public key and use it to encrypt and
    decrypt data.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何创建RSA公钥并使用它来加密和解密数据。
- en: Random Generators
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机生成器
- en: The Go standard library provides utility libraries to create random number generators.
    The implementations are provided in the `crypto/rand` and `math/rand` packages.
    The `math/rand` library can be used to generate random integers; however, randomness
    cannot be guaranteed. Therefore, this library should only be used in cases where
    the number can be generally random and is not security-sensitive.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了用于创建随机数生成器的实用库。实现提供在 `crypto/rand` 和 `math/rand` 包中。`math/rand` 库可以用来生成随机整数；然而，随机性无法保证。因此，这个库只应在数字可以一般随机且不涉及安全敏感的情况下使用。
- en: Otherwise, you should always use `crypto/rand`. As a side note, the `crypto/rand`
    package relies on OS randomness – for example, on Linux it uses `/dev/urandom`.
    Therefore, it is generally slower than the math library implementation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你应该始终使用 `crypto/rand`。作为旁注，`crypto/rand` 包依赖于操作系统随机性——例如，在 Linux 上它使用 `/dev/urandom`。因此，它通常比数学库实现慢。
- en: 'To produce a random integer between 0 and a user-defined number using the `crypto/rand`
    library, we can use the following function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `crypto/rand` 库生成一个介于 0 和用户定义数字之间的随机整数，我们可以使用以下函数：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There are many scenarios where we might want to generate a secure random number,
    for example, when generating unique session IDs. It is important that random numbers
    used in these scenarios are genuinely random, and do not follow a pattern that
    can be inferred. For example, if an attacker can infer the next `sessionID` by
    looking at the last few session IDs, they could potentially gain unauthenticated
    access to that session.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，我们可能需要生成一个安全的随机数，例如，在生成唯一的会话 ID 时。在这些场景中使用随机数必须是真正随机的，并且不遵循可以被推断出的模式。例如，如果攻击者可以通过查看最后几个会话
    ID 来推断下一个 `sessionID`，他们可能获得对该会话的非认证访问。
- en: Let's learn how to generate random numbers using both the `crypto/rand` and
    `math/rand` libraries.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用 `crypto/rand` 和 `math/rand` 库生成随机数。
- en: 'Exercise 18.06: Random Generators'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.06：随机生成器
- en: 'Random number generation is a common activity when trying to introduce some
    entropy to encrypt data. In this exercise, we will see how random numbers can
    be generated using the `math/rand` and `crypto/rand` packages:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成是在尝试向数据引入一些熵时的一种常见活动。在这个练习中，我们将看到如何使用 `math/rand` 和 `crypto/rand` 包生成随机数：
- en: 'Create a `main.go` file and import the following packages:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并导入以下包：
- en: '[PRE51]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`math "math/rand"`: We add the `math` namespace to differentiate it from the
    `crypto/rand` package.'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`math "math/rand"`：我们添加 `math` 命名空间来区分它与 `crypto/rand` 包。'
- en: 'In the `main()` function, create a `for` loop that runs 10 times and prints
    a random integer between 0 and 1000, generated using the `rand.Int()` function
    of the `crypto/rand` library:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，创建一个运行 10 次的 `for` 循环，并打印使用 `crypto/rand` 库的 `rand.Int()` 函数生成的介于
    0 和 1000 之间的随机整数：
- en: '[PRE52]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create another similar `for` loop using the `math/rand` package:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `math/rand` 包创建另一个类似的 `for` 循环：
- en: '[PRE53]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Run the program using the following command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE54]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You should get the following output:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 19.9: Expected output'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.9：预期输出'
- en: '](img/B14177_18_09.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_18_09.jpg)'
- en: 'Figure 18.9: Expected output'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.9：预期输出
- en: While the outputs for the two implementations may appear similar, the underlying
    mechanism of number generation is important when using random numbers for security
    purposes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两个实现的输出可能看起来相似，但在使用随机数进行安全目的时，数字生成的底层机制很重要。
- en: In this exercise, we have seen how to generate random numbers using the `math/rand`
    and `crypto/rand` packages.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用 `math/rand` 和 `crypto/rand` 包生成随机数。
- en: HTTPS/TLS
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS/TLS
- en: 'When you are developing a web application, it is important to know how to secure
    your information in transit. This is achieved by using a `crypto/tls` package.
    The TLS protocol ensures:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发一个网络应用程序时，了解如何确保信息在传输过程中的安全是非常重要的。这可以通过使用 `crypto/tls` 包来实现。TLS 协议确保：
- en: '**Identity**: Provides both client and server identification using digital
    certificates.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份**：使用数字证书提供客户端和服务器身份验证。'
- en: '**Integrity**: Makes sure that data is not tampered with in transit by calculating
    a message digest.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整性**：通过计算消息摘要确保数据在传输过程中未被篡改。'
- en: '**Authentication**: Both client and server can be required to be authenticated
    using Public-Key Cryptography.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**：客户端和服务器都可以要求使用公钥密码学进行认证。'
- en: '**Confidentiality**: The message is encrypted during transit, thus protecting
    it from any unintended recipient.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**机密性**：消息在传输过程中被加密，从而保护它免受任何未授权接收者的侵害。'
- en: In the following topic, we'll see how to use certificates to encrypt traffic
    between a client and a server.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下主题中，我们将看到如何使用证书加密客户端和服务器之间的流量。
- en: The first step to encrypting traffic between a client and a server is to generate
    a digital certificate.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间加密流量第一步是生成一个数字证书。
- en: In the next exercise, we will generate a self-signed x509 certificate and a
    matching RSA private key. This certificate can be used as either a client or server
    certificate.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将生成一个自签名的 x509 证书和匹配的 RSA 私钥。此证书可以用作客户端或服务器证书。
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You might come across the term CA, which stands for Certificate Authority. The
    CA is the one who signs certificates and distributes them to users who require
    a signed certificate.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到 CA 这个术语，它代表证书授权机构。CA 是签发证书并将其分发给需要签发证书的用户的一方。
- en: 'Exercise 18.07: Generating a Certificate and Private Key'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.07：生成证书和私钥
- en: 'In this exercise, we will learn how to generate a self-signed certificate and
    a matching private key for the certificate, which can be used in client-server
    communication:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何生成一个自签名的证书及其匹配的私钥，这些证书可用于客户端-服务器通信：
- en: 'Create a `main.go` file and import the following packages:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并导入以下包：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The crypto packages will be used to generate x509 certificates.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将使用加密包生成 x509 证书。
- en: 'To generate the certificate, we first create a template. In the template, we
    can define criteria for the certificate; for example, the expiry of the certificate
    is set to a year. The template needs a random seed, which can be generated using
    the `rand.Int()` function:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成证书，我们首先创建一个模板。在模板中，我们可以定义证书的标准；例如，证书的过期时间设置为一年。模板需要一个随机种子，可以使用 `rand.Int()`
    函数生成：
- en: '[PRE56]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create `privateKey`, which will be used to sign the certificate:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `privateKey`，它将被用来签名证书：
- en: '[PRE57]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a self-signed `DER` (binary encrypted) certificate:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自签名的 `DER`（二进制加密）证书：
- en: '[PRE58]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Convert the binary encoded `DER` cert to an ASCII encoded PEM cert. PEM (**Privacy
    Enhanced Mail**) is a digital certificate format:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制编码的 `DER` 证书转换为 ASCII 编码的 PEM 证书。PEM（**增强隐私邮件**）是一种数字证书格式：
- en: '[PRE59]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define the `main()` function to call the `generate` function and print the
    output:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main()` 函数以调用 `generate` 函数并打印输出：
- en: '[PRE60]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should get an output similar to the following:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下类似的输出：
- en: '![Figure 19.10: Expected output'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.10：预期输出'
- en: '](img/B14177_18_10.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_18_10.jpg)'
- en: 'Figure 18.10: Expected output'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.10：预期输出
- en: Thus, we have successfully generated a self-signed certificate and a private
    key for the application. In the output above, the "Server Certificate" is the
    public certificate, and the "Server Key" is the private key. This can be used
    to encrypt data between the client and the server. They are particularly useful
    when there is sensitive data in transit, such as on a banking website.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经成功生成了一个自签名证书和用于应用程序的私钥。在上面的输出中，“服务器证书”是公开证书，“服务器密钥”是私钥。这可以用于加密客户端和服务器之间的数据。当传输过程中有敏感数据时，它们尤其有用，例如在银行网站上。
- en: 'Exercise 18.08: Running an HTTPS Server'
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.08：运行 HTTPS 服务器
- en: In the following exercise, we'll learn how to use certificates to encrypt traffic
    between a client and server.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将学习如何使用证书加密客户端和服务器之间的流量。
- en: 'We will learn how to create a public-key certificate. The certificate will
    be used to encode data between a client and a server:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建公钥证书。该证书将被用来在客户端和服务器之间编码数据：
- en: 'Create a `main.go` file and import the following packages:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并导入以下包：
- en: '`crypto/rand`: For random number generation.'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/rand`：用于随机数生成。'
- en: '`crypto/rsa`: Provides a wrapper for RSA certificates.'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/rsa`：为 RSA 证书提供包装。'
- en: '`crypto/tls`: Provides a wrapper for Transport Layer Security (TLS) protocol.'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/tls`：为传输层安全性（TLS）协议提供包装。'
- en: '`crypto.x509`: Provides a wrapper for X509 digital certificates.'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`crypto/x509`：为 X509 数字证书提供包装。'
- en: '[PRE61]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Define a function called `runServer()` to run an HTTP server with a TLS configuration.
    The function should take in the paths of the certificate file, a private key file,
    and a PEM encoded client certificate. In our TLS configuration, we require both
    server and client certificates. The server certificate is used by the client to
    validate the authenticity of the server. The client certificate is verified by
    the server to validate the client:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `runServer()` 的函数，用于运行具有 TLS 配置的 HTTP 服务器。该函数应接受证书文件路径、私钥文件路径和 PEM 编码的客户证书。在我们的
    TLS 配置中，我们要求服务器和客户证书。服务器证书由客户端用于验证服务器的真实性。客户端证书由服务器验证以验证客户端：
- en: '[PRE62]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Define the `hello()` function, which is passed as a handler function when we
    start the HTTP server. This function will respond with some text whenever the
    server receives a request:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `hello()` 函数，当启动 HTTP 服务器时，将其作为处理函数传递。每当服务器收到请求时，该函数将响应一些文本：
- en: '[PRE63]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that the server side is done, let''s implement the client side:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在服务器端已完成，让我们实现客户端：
- en: '[PRE64]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This defines an HTTP client using the TLS implementation. It takes in the certificate
    of the CA as a parameter to verify the authenticity of the server. In our case,
    we used a self-signed certificate, so the server certificate will serve the purpose
    of a CA certificate. The function would also take the client's certificate so
    that the client can authenticate with the server.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这定义了一个使用 TLS 实现的 HTTP 客户端。它接受 CA 证书作为参数以验证服务器的真实性。在我们的情况下，我们使用了一个自签名证书，因此服务器证书将充当
    CA 证书。该函数还会接受客户的证书，以便客户端可以与服务器进行身份验证。
- en: Let's now tie these functions and run a client and server handshake.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在将这些函数结合起来，运行客户端和服务器握手。
- en: 'First, we generate certificates and keys for both the client and the server.
    The server is started using a `goroutine` and waits for a request from the client.
    The client is also started in a `goroutine` and calls the server every 3 seconds:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们为客户端和服务器生成证书和密钥。服务器使用 `goroutine` 启动并等待来自客户端的请求。客户端也在 `goroutine` 中启动，每
    3 秒调用一次服务器：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now run the `main()` function. You should see the following output in
    your console:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行 `main()` 函数。你应该在你的控制台看到以下输出：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this exercise, we demonstrated how a client and server communication could
    be secured using the TLS protocol. We have learned how to generate digital certificates
    and used them in the TLS configuration for the client and server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们展示了如何使用 TLS 协议来确保客户端和服务器之间的通信。我们学习了如何生成数字证书，并在客户端和服务器 TLS 配置中使用它们。
- en: Password Management
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码管理
- en: If you are managing user accounts on your website, one common way of verifying
    user identity is through a combination of usernames and passwords. This authentication
    mechanism has the risk that, if not properly managed, user credentials can be
    leaked. This has happened to many of the major websites around the world and remains
    a surprisingly common security incident.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在管理网站上的用户账户，验证用户身份的一种常见方式是通过用户名和密码的组合。这种认证机制的风险是，如果管理不当，用户凭证可能会泄露。这已经发生在世界上的许多主要网站上，并且仍然是一个令人惊讶的常见安全事件。
- en: The main rule of thumb regarding password management is to never store passwords
    in plaintext (either in memory or in a database). Instead, implement an approved
    hash algorithm to create a one-way hash of the password so that you can confirm
    the identity through the hash. However, it is not possible to retrieve the password
    from the hash. We can see this in action with an example.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 关于密码管理的首要规则是永远不要以明文形式存储密码（无论是在内存中还是在数据库中）。相反，实现一个经过批准的哈希算法来创建密码的单向哈希，以便你可以通过哈希来确认身份。然而，从哈希中无法检索密码。我们可以通过一个示例来观察这一过程。
- en: 'The following code shows how to create a one-way hash from a plaintext string.
    We are using the `bcrypt` package to generate the hash. We then perform a comparison
    of the password with the hash to verify the match:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何从明文字符串创建单向哈希。我们使用 `bcrypt` 包来生成哈希。然后我们执行密码与哈希的比较以验证匹配：
- en: '[PRE67]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following is the expected output:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '![Figure 19.11: Expected output'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.11：预期输出'
- en: '](img/B14177_18_11.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_18_11.jpg)'
- en: 'Figure 18.11: Expected output'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.11：预期输出
- en: Note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Elliptic Curve Digital Signature Algorithm** (ECDSA) is a cryptographic algorithm
    that is used to verify the authenticity of data by providing a mechanism to sign
    and verify data using a public and private key pair.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭圆曲线数字签名算法** (ECDSA) 是一种加密算法，它通过提供使用公钥和私钥对签名和验证数据的机制来验证数据的真实性。'
- en: 'Activity 18.01: Authenticating Users on the Application Using Hashed Passwords'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动18.01：使用哈希密码在应用程序中验证用户
- en: You are working on a web application and you need to authenticate users by using
    hashed passwords.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在开发一个Web应用程序，你需要使用哈希密码来验证用户。
- en: Create a database with user passwords that are stored as a hash. Define a function
    to take in a user password as an input and authenticate the user using the stored
    password in the database. Make sure the SQL query defined to query the database
    is safe from SQL injection. You can follow these steps to get the desired output.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个存储为哈希的用户密码数据库。定义一个函数，接受用户密码作为输入，并使用数据库中存储的密码验证用户。确保查询数据库的SQL查询不受SQL注入攻击。你可以按照以下步骤获取所需的输出。
- en: Create a function to load data into the database.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数将数据加载到数据库中。
- en: Create a function to update a password in the database. Use the `crypto/sha512`
    library to encrypt the input password before updating the database.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来更新数据库中的密码。在更新数据库之前，使用`crypto/sha512`库加密输入密码。
- en: Create a function to retrieve the password from the database and confirm whether
    it matches the hash.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数从数据库中检索密码并确认它是否与哈希匹配。
- en: In the main function of the program, initialize the database with some test
    data.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序的主函数中，使用一些测试数据初始化数据库。
- en: Perform the update of the user password using the function defined in *step
    2*.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用定义在第2步中的函数更新用户密码。
- en: 'You should get the following output:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 19.12: Expected output'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.12：预期输出'
- en: '](img/B14177_18_12.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_18_12.jpg)'
- en: 'Figure 18.12: Expected output'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12：预期输出
- en: Here, we securely store user passwords in a database using a hashing library
    and then verify a user's identity using a hashed password. You can use this in
    scenarios where there is sensitive data that needs to be stored.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用哈希库在数据库中安全地存储用户密码，然后使用哈希密码验证用户的身份。你可以在需要存储敏感数据的场景中使用此方法。
- en: Note
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 777.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第777页找到。
- en: 'Activity 18.02: Creating CA Signed Certificates Using Crypto Libraries'
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动18.02：使用加密库创建CA签名的证书
- en: A Certificate Authority(CA) needs to be created to sign certificates. When a
    new leaf certificate is created, it should be signed using the CA certificate
    and private key. You will need to define a function to generate ECDSA-encrypted
    keys using the `crypto/ecdsa` library. The function needs to support the creation
    of CA certificates as well as leaf certificates. Finally, you will need to verify
    the newly created leaf certificate.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构(CA)需要创建来签署证书。当创建新的叶证书时，应使用CA证书和私钥进行签名。你需要定义一个函数，使用`crypto/ecdsa`库生成ECDSA加密密钥。该函数需要支持创建CA证书以及叶证书。最后，你需要验证新创建的叶证书。
- en: 'The aim here is to generate x509 certificates. You can follow these steps to
    get the desired output:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是生成x509证书。你可以按照以下步骤获取所需的输出：
- en: Create a `generateCert()` function to generate an ECDSA certificate and private
    key using the `crypto/ecdsa` library. It should take in a common name string,
    a CA certificate, and a CA private key.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`generateCert()`函数，使用`crypto/ecdsa`库生成ECDSA证书和私钥。它应该接受一个通用名称字符串、CA证书和CA私钥。
- en: 'The function should have the following definition:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数应具有以下定义：
- en: '[PRE68]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Create an ECDSA key using the `ecdsa.GenerateKey()` function.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ecdsa.GenerateKey()`函数创建一个ECDSA密钥。
- en: Use the key to generate an x509 certificate.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该密钥生成一个x509证书。
- en: Return the generated certificate and private key.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回生成的证书和私钥。
- en: In the `main()` function, generate a CA certificate and private key, as well
    as a leaf certificate and private key.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，生成CA证书和私钥，以及叶证书和私钥。
- en: Verify the leaf certificate generated.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证生成的叶证书。
- en: 'The output should appear as follows:'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE69]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we generate x509 public key certificates. We also saw how using a root
    certificate to generate a leaf certificate can be handy when you are trying to
    implement your own PKI server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成x509公钥证书。我们还看到了如何使用根证书生成叶证书，在尝试实现自己的PKI服务器时非常有用。
- en: Note
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 780.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第780页找到。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at several types of attacks that could be used
    to compromise an application. We have also covered strategies to mitigate those
    issues, along with worked examples.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了可能被用来破坏应用程序的几种攻击类型。我们还介绍了缓解这些问题的策略，并提供了实际操作的示例。
- en: We have presented the use of crypto libraries for the encryption and decryption
    of data, both at rest and in transit. We have covered hashing libraries, and how
    they can be used to securely store user credentials. We have also shown how TLS
    configuration can be used to secure communication between clients and servers.
    With these tools in mind, you can now start writing secure applications.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了加密库的使用，用于数据的加密和解密，无论是静态存储还是传输过程中的数据。我们还涵盖了哈希库的使用，以及如何使用它们来安全地存储用户凭证。此外，我们还展示了如何使用TLS配置来确保客户端和服务器之间的通信安全。有了这些工具，你现在可以开始编写安全的应用程序了。
- en: In the next chapter, we will be learning about some lesser-known packages in
    Go, such as reflection and unsafe.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习Go语言中一些不太为人所知的包，例如反射和unsafe。
