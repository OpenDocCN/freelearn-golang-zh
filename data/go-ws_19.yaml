- en: 19\. Special Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19. 特殊特性
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at some special features in Go that can be helpful
    during your application development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些在应用程序开发过程中可能非常有用的 Go 特性。
- en: This chapter will first introduce you to use build constraints, to write programs
    that work on multiple operating systems and architecture and also use command-line
    options to build Go programs. You will use reflection to inspect objects at runtime.
    By the end of the chapter you will be able to define build-time behavior for your
    application and use the `unsafe` package to access runtime memory in Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先将介绍如何使用构建约束，编写适用于多个操作系统和架构的程序，并使用命令行选项构建 Go 程序。你将使用反射来检查运行时对象。到本章结束时，你将能够为你的应用程序定义构建时行为，并使用
    `unsafe` 包在 Go 中访问运行时内存。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about vulnerabilities that could affect
    your application and how to mitigate them. We learned how to secure communication
    and safely store data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了可能影响你的应用程序的漏洞以及如何减轻它们。我们学习了如何确保通信安全以及安全地存储数据。
- en: We will now learn some features in Go that are not obvious and can be hard to
    find out about. You might come across these features if you are going through
    the standard library. Knowing about these features will help you to understand
    what is going on during the execution, as some of these properties are implicitly
    embedded into the language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将学习一些在 Go 语言中不太明显且难以发现的特性。如果你正在浏览标准库，可能会遇到这些特性。了解这些特性将有助于你理解执行过程中的情况，因为这些特性中的一些是隐式嵌入到语言中的。
- en: As Go is portable across multiple **operating systems** (**OSes**) and CPU architectures,
    Go supports configuring these parameters to build the application. Using these
    build parameters, you will be able to do things such as cross-compilation, which
    is very rare in other programming languages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 语言可以在多个 **操作系统**（**OSes**）和 CPU 架构上运行，因此 Go 支持配置这些参数以构建应用程序。使用这些构建参数，你将能够执行诸如交叉编译等操作，这在其他编程语言中是非常罕见的。
- en: Concepts such as memory management are hard to master, so the Go runtime manages
    all memory allocation and deallocation, relieving the coder of the overhead of
    managing the memory footprint of the application. For rare cases where the coder
    does need to access memory, Go provides some flexibility by providing a package
    called `unsafe`, which we will learn about in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如内存管理之类的概念很难掌握，因此 Go 运行时管理所有内存分配和释放，减轻了程序员管理应用程序内存足迹的负担。对于程序员偶尔需要访问内存的情况，Go
    通过提供一个名为 `unsafe` 的包提供了一些灵活性，我们将在本章中学习它。
- en: Build Constraints
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建约束
- en: Go programs can run on different OSes and different CPU architectures. When
    you build a Go program, the compilation of your program is done for your current
    machine's OS and architecture. By using the build constraints, you can set conditions
    on which a file will be considered for compilation. If you have a function that
    needs to be overridden for different OSes, you can use build constraints to have
    multiple definitions of the same function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go 程序可以在不同的 OS 和不同的 CPU 架构上运行。当你构建一个 Go 程序时，你的程序的编译是在当前机器的 OS 和架构上完成的。通过使用构建约束，你可以设置条件，确定哪些文件将被考虑进行编译。如果你有一个需要针对不同
    OS 进行覆盖的函数，你可以使用构建约束来有多个相同函数的定义。
- en: You can see lots of examples of this happening in the Go standard library.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Go 标准库中看到很多这样的例子。
- en: 'The following links are implementations of the same function in darwin and
    on Linux from the `os` package in the standard library:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接展示了标准库中 `os` 包在 darwin 和 Linux 上实现相同功能的示例：
- en: '[https://packt.live/2RKfydP](https://packt.live/2RKfydP)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://packt.live/2RKfydP](https://packt.live/2RKfydP)'
- en: '[https://packt.live/2PJN957](https://packt.live/2PJN957)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://packt.live/2PJN957](https://packt.live/2PJN957)'
- en: If you happen to come across a similar requirement, the Go language provides
    build constraints that can be used to define build conditions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好遇到类似的需求，Go 语言提供了构建约束，可以用来定义构建条件。
- en: Build Tags
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建标签
- en: There are two ways to use build constraints. The first method is to define build
    tags and the second method is to use filename suffixes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建约束有两种方法。第一种方法是定义构建标签，第二种方法是使用文件名后缀。
- en: Build tags should appear before the package clause in your source file. These
    tags are analyzed at build time and decide whether or not the file is included
    for the compilation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建标签应出现在您的源文件中的包声明之前。这些标签在构建时进行分析，并决定是否将文件包含在编译中。
- en: 'Let''s take a look at how the tags are evaluated. The following tag means that
    the source file will only be considered for `build` on Linux machines. So, this
    file will not be compiled on a Windows machine:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何评估这些标签。以下标签意味着源文件将仅在 Linux 机器上考虑 `build`。因此，此文件不会在 Windows 机器上编译：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can have multiple build constraints defined using build tags:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用构建标签定义多个构建约束：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This evaluates to the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in the preceding example, we also use negation to avoid certain conditions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的例子中，我们也使用了否定来避免某些条件。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that there is an empty line between the build constraints and the
    start of the code, which is the package name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在构建约束和代码开始（即包名）之间有一个空行。
- en: At build time, Go compares the build tags with the Go environment variables
    and decides what to do with the tags.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时，Go 将构建标签与环境变量进行比较，并决定如何处理这些标签。
- en: 'By default, Go will read specific environment variables to set the build and
    runtime behavior. You can see what these variables are by running the following
    command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Go 将读取特定的环境变量来设置构建和运行时行为。您可以通过运行以下命令来查看这些变量：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Figure 20.1: The go env output'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 20.1：go env 输出'
- en: '](img/B14177_19_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_19_01.jpg)'
- en: 'Figure 19.1: The go env output'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1：go env 输出
- en: The most commonly used variables are `GOOS`, which is the variable for the OS,
    and `GOARCH`, which is the variable for the CPU architecture. You can cross-compile
    your application by setting your `GOOS` variable to something other than your
    current OS. Example values of the `GOOS` variable are Windows, darwin, and Linux.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的变量是 `GOOS`，它是操作系统变量，以及 `GOARCH`，它是CPU架构变量。您可以通过将 `GOOS` 变量设置为除当前操作系统之外的其他值来交叉编译您的应用程序。`GOOS`
    变量的示例值包括 Windows、darwin 和 Linux。
- en: 'Let''s look at a simple hello world program and use the build tags in action.
    The following program has a `build` tag that makes the `go build` command ignore
    the file:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 hello world 程序，并使用构建标签的实际操作。以下程序有一个 `build` 标签，使得 `go build` 命令忽略该文件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run `go build` in the current directory, you will see the following
    error output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在当前目录下运行 `go build`，您将看到以下错误输出：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you remove the `build` tag from the file and then run `build` again, it
    should produce a binary without any errors, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从文件中移除 `build` 标签然后再次运行 `build`，它应该生成一个没有错误的二进制文件，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's look at another example of the `build` tag using the `GOOS` variable.
    We will demonstrate how a combination of `build` tags and environment variables
    can affect the compilation of your application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `GOOS` 变量的 `build` 标签的另一个示例。我们将演示 `build` 标签和环境变量的组合如何影响您的应用程序的编译。
- en: My current operating `GOOS` variable is `darwin`. Replace `darwin` with your
    own `GOOS` value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我当前的操作系统 `GOOS` 变量是 `darwin`。将 `darwin` 替换为您自己的 `GOOS` 值。
- en: 'To get your current `GOOS` variable, run the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前的 `GOOS` 变量，请运行以下命令：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we `build` this file, it should produce an executable binary as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们 `build` 此文件，它应该生成以下可执行二进制文件：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, set your `GOOS` variable to another value other than your own; the build
    should fail:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将您的 `GOOS` 变量设置为除您自己的以外的其他值；构建应该失败：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we learned how to use `GOOS` values as build constraints.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们学习了如何使用 `GOOS` 值作为构建约束。
- en: Filenames
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件名
- en: As mentioned earlier, the second method to use build constraints is to use suffixes
    in the filename to define the constraints.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用构建约束的第二种方法是使用文件名后缀来定义约束。
- en: Using this method, you could define constraints on the OS or CPU architecture
    or both.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，您可以在操作系统或CPU架构或两者上定义约束。
- en: 'For example, the following files are from the `syscall` package in the standard
    library. You can see constraints defined on the OS:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下文件来自标准库中的 `syscall` 包。您可以看到定义在操作系统上的约束：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another example of using both the OS and CPU architecture can be found in the
    runtime package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时包中也可以找到同时使用操作系统和CPU架构的另一个示例：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To utilize this method, the suffixes have to be of the following form:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用此方法，后缀必须具有以下形式：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can find examples of this naming scheme in the standard library as well:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在标准库中找到此命名方案的示例：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's look at an example of using filenames to define build constraints. We
    will define build constraints by CPU architecture. We will use this with the `GOARCH`
    environment variable to control the build.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用文件名来定义构建约束的例子。我们将通过 CPU 架构来定义构建约束。我们将使用 `GOARCH` 环境变量来控制构建。
- en: 'We have a file with a suffix of the current `GOARCH`. My current `GOARCH` is
    `amd64`, so the filename will be `main_amd64.go`. Replace this value for your
    filename. To get your current `GOARCH`, run the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个以当前 `GOARCH` 为后缀的文件。我的当前 `GOARCH` 是 `amd64`，所以文件名将是 `main_amd64.go`。请将此值替换为你的文件名。要获取你的当前
    `GOARCH`，请运行以下命令：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will display the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示以下内容：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The filename on my machine will be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，文件名将是如下所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside the file, we will define a simple `"Hello World"` program:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，我们将定义一个简单的 `"Hello World"` 程序：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output will be as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To confirm that the constraint works, we can use another `GOARCH` value to
    try and check whether the build fails:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认约束是否起作用，我们可以使用另一个 `GOARCH` 值来尝试检查构建是否失败：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we learned how to use CPU architecture as a build
    constraint to restrict building files on specific CPU architecture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们学习了如何使用 CPU 架构作为构建约束来限制在特定 CPU 架构上构建文件。
- en: Reflection
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: Reflection is the mechanism of inspecting code at runtime. Reflection is useful
    when you do not know or cannot guarantee the type of input for a function. In
    cases such as this, reflection can be used to inspect the type of the object and
    manipulate values of objects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是检查运行时代码的机制。当你不知道或不能保证函数的输入类型时，反射非常有用。在这种情况下，反射可以用来检查对象的类型并操作对象的值。
- en: The Go `reflect` package gives you features to inspect and manipulate an object
    at runtime. It can be used not only for basic types such as `int` and `string`,
    but for inspecting slices, arrays, and structs as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `reflect` 包为你提供了在运行时检查和操作对象的功能。它不仅可以用于基本类型，如 `int` 和 `string`，还可以用于检查切片、数组和结构体。
- en: 'Let''s create a simple `print()` function to demonstrate how we can use reflection.
    We define a utility print function called `MyPrint()` that can print different
    types of objects. This is done by having an interface as an input to the function.
    Then, inside the function, we make use of the `reflect` package to alter the behavior
    according to the type of the input. Consider the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的 `print()` 函数来演示我们如何使用反射。我们定义了一个名为 `MyPrint()` 的实用打印函数，它可以打印不同类型的对象。这是通过将接口作为函数的输入来实现的。然后，在函数内部，我们使用
    `reflect` 包根据输入的类型来改变行为。考虑以下代码：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the preceding program, we get the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序，我们得到以下输出：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can find examples of reflection being used in packages such as `encoding/json`
    and `fmt`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `encoding/json` 和 `fmt` 等包中找到反射使用的示例。
- en: Let's look at how to use reflection using some common utility functions in the
    `reflect` package.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `reflect` 包中的某些常见实用函数来使用反射。
- en: TypeOf and ValueOf
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeOf 和 ValueOf
- en: 'To use reflection, you will need to get familiar with two types defined in
    the `reflect` package:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用反射，你需要熟悉在 `reflect` 包中定义的两个类型：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both of these types provide utility functions that give you access to the dynamic
    runtime information of the object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型都提供了实用函数，可以让你访问对象的动态运行时信息。
- en: 'These two functions give you a handle on the `Type` and `Value` of the object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数为你提供了对对象的 `Type` 和 `Value` 的控制：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following program uses the two functions to print the `Type` and `Value`
    of the object being passed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用这两个函数来打印传递给对象的 `Type` 和 `Value`：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding program should print the `Type` of `x`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序的输出应该打印 `x` 的 `Type`：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we observed how two functions are used to print the `Type`
    and `Value` of the object passed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们观察了如何使用两个函数来打印传递给对象的 `Type` 和 `Value`。
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to make sure that you use the reflection package carefully.
    Using the type conversion incorrectly or calling a method on an object that does
    not support the method will cause the program to panic.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你谨慎地使用反射包非常重要。使用类型转换错误或调用不支持该方法的对象上的方法将导致程序崩溃。
- en: 'Exercise 19.01: Using Reflection'
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 19.01：使用反射
- en: 'In this exercise, we will use the reflection package to inspect objects at
    runtime:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用反射包来检查运行时的对象：
- en: Create a file named `main.go`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件。
- en: 'Import the following packages:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下包：
- en: '[PRE27]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define a `struct` called `circle` with the `radius` as one of its fields:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`circle`的`struct`，其中`radius`是其字段之一：
- en: '[PRE28]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define another `struct` called `rectangle` with `length` and `breadth` as its
    fields:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个名为`rectangle`的`struct`，其字段为`length`和`breadth`：
- en: '[PRE29]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define a function called `area()` that can calculate the area of different
    shapes. It should take `interface` as its input:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`area()`的函数，它可以计算不同形状的面积。它应该接受`interface`作为其输入：
- en: '[PRE30]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this function, we use `reflect.TypeOf()` to get a `reflect.Type` object from
    the input. We then use the `Type.Name()` function to get the name of the `struct`,
    which, in our case, could be either a circle or a rectangle.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用`reflect.TypeOf()`从输入中获取一个`reflect.Type`对象。然后我们使用`Type.Name()`函数来获取`struct`的名称，在我们的例子中，它可以是圆或矩形。
- en: To retrieve the value of the fields in the struct, we first use the `reflect.ValueOf()`
    function to get a `reflect.Value` object. Then we use `Val.FieldByName()` to get
    the field value.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要检索结构体字段中的值，我们首先使用`reflect.ValueOf()`函数获取一个`reflect.Value`对象。然后我们使用`Val.FieldByName()`来获取字段值。
- en: 'Define a `main()` function and call the `area()` function:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`main()`函数并调用`area()`函数：
- en: '[PRE31]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the program using the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should get the following output when you run the program:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行程序时，你应该得到以下输出：
- en: '[PRE33]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this exercise, we learned how to use reflection to define the different implementations
    of a function, in this case, by inspecting the input object to determine what
    object is being passed in.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用反射来定义函数的不同实现，在这种情况下，通过检查输入对象来确定传递的是什么对象。
- en: 'Activity 19.01: Defining Build Constraints Using Filenames'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第19.01节：使用文件名定义构建约束
- en: You have to define a function that behaves differently depending on the OS and
    CPU architecture. Use build constraints on a filename to achieve this behavior.
    One file should be set with the OS constraint set to `darwin` and another with
    the CPU architecture set to `386`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须定义一个根据操作系统和CPU架构表现不同的函数。使用文件名上的构建约束来实现这种行为。一个文件应该设置操作系统约束为`darwin`，另一个设置CPU架构约束为`386`。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Substitute `darwin` with your current OS and `386` with another architecture
    that is not your current machine's architecture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将`darwin`替换为你的当前操作系统，将`386`替换为你当前机器架构之外的另一个架构。
- en: 'Perform the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a package called `custom`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`custom`的包。
- en: 'Create a `print_darwin.go` file and define a function called `Print()` inside
    the package. It should print the following text: `I am running on a darwin machine`.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`print_darwin.go`的文件，并在包内定义一个名为`Print()`的函数。它应该打印以下文本：`I am running on
    a darwin machine`。
- en: 'Create another file in the same package called `print_386.go` and define a
    function called `Print()` that prints the following text: `Hello I am running
    on a 386 machine`.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包中创建另一个名为`print_386.go`的文件，并定义一个名为`Print()`的函数，该函数打印以下文本：`Hello I am running
    on a 386 machine`。
- en: Define a `main()` function and import the `custom` package. Call the `Print()`
    function from the custom package in the `main()` function.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`main()`函数并导入`custom`包。在`main()`函数中调用`custom`包中的`Print()`函数。
- en: 'By the end of the activity, you should see the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到活动结束时，你应该看到以下输出：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this activity, we implemented overriding a function using build constraints
    with filenames. You should be able to see a similar implementation in the Go standard
    library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们使用文件名构建约束来实现函数重载。你应该能够在Go标准库中看到类似的实现。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 782.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第782页找到。
- en: DeepEqual
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeepEqual
- en: The `reflect.DeepEqual()` requires a mention if we are talking about the `reflect`
    package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在谈论`reflect`包，则`reflect.DeepEqual()`需要提及。
- en: Basic data types in Go can be compared using the `==` or `!=` operator, but
    slices and maps are not comparable using this method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Go的基本数据类型可以使用`==`或`!=`运算符进行比较，但切片和映射不能使用这种方法进行比较。
- en: 'The `reflect.DeepEqual()` function can be used in scenarios when the types
    are incomparable. For example, it can be used for comparing slices and maps. Here
    is an example that compares maps and slices using `DeepEqual`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型不可比较时，可以使用`reflect.DeepEqual()`函数。例如，它可以用于比较切片和映射。以下是一个使用`DeepEqual`比较映射和切片的示例：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, we compare different data types using `reflect.DeepEqual()`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`reflect.DeepEqual()`比较不同的数据类型。
- en: 'The following are the comparisons done:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比较操作：
- en: Two nil objects.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个nil对象。
- en: Two empty slices with the same size. The size is important here.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个大小相同的空切片。在这里，大小很重要。
- en: Two slices with the same data in the same order. Values in a different order
    will give a different output.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个顺序相同的包含相同数据的切片。顺序不同的值将给出不同的输出。
- en: Two maps with the same data. The order of keys does not matter here as maps
    are always unordered.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个包含相同数据的映射。在这里，键的顺序并不重要，因为映射总是无序的。
- en: 'If you run the program, you should get the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行程序，您应该得到以下输出：
- en: '![Figure 20.2: DeepEqual output'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图20.2：DeepEqual输出'
- en: '](img/B14177_19_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_19_02.jpg)'
- en: 'Figure 19.2: DeepEqual output'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2：DeepEqual输出
- en: Wildcard Pattern
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通配符模式
- en: The `go` tool has a number of commands to help you with your code development.
    For example, the `go list` command helps you list Go files in your current directory,
    and the `go test` command helps you run test files in your current directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`go`工具有一系列命令可以帮助您进行代码开发。例如，`go list`命令可以帮助您列出当前目录中的Go文件，而`go test`命令可以帮助您运行当前目录中的测试文件。'
- en: Your project may be structured in multiple subdirectories to help organize your
    code logically. If you wanted to use the `go` tool to run commands over your whole
    codebase at once, it supports a wildcard pattern that helps you do just that.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目可能被组织在多个子目录中，以帮助您逻辑上组织代码。如果您想使用`go`工具一次性运行整个代码库中的命令，它支持通配符模式，这可以帮助您做到这一点。
- en: 'To list all the `.go` files in your current directory and its subdirectories,
    you can use the following relative pattern:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前目录及其子目录中的所有`.go`文件，您可以使用以下相对模式：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Similarly, if you wanted to run all the tests in your current directory and
    subdirectories, the same pattern can be used:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果您想运行当前目录及其子目录中的所有测试，可以使用相同的模式：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you are still using vendor directories, the good thing is that this pattern
    will ignore the `./vendor` directories.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍在使用供应商目录，好消息是这个模式将忽略`./vendor`目录。
- en: Let's try the wildcard patterns on the Go workshop repository.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Go工作坊仓库上尝试通配符模式。
- en: 'To list all the `.go` files in the project, you can run the `list` command
    with the wildcard:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出项目中的所有`.go`文件，您可以使用通配符运行`list`命令：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should get an output similar to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到类似于以下输出的结果：
- en: '![Figure 20.3: Wildcard pattern'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图20.3：通配符模式'
- en: '](img/B14177_19_03.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_19_03.jpg)'
- en: 'Figure 19.3: Wildcard pattern'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3：通配符模式
- en: The unsafe Package
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的包
- en: Go is a statically typed language, and it has its own runtime that does memory
    allocation and garbage collection. So, unlike C, all the work related to memory
    management is taken care of by the runtime. Unless you have some special requirements,
    you would never have to deal with memory directly in your code. When there is
    a requirement, though, the `unsafe` package in the standard library gives you
    features to let you peek into the memory of an object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种静态类型语言，它有自己的运行时，负责内存分配和垃圾回收。因此，与C不同，所有与内存管理相关的任务都由运行时处理。除非您有一些特殊要求，否则您永远不需要在代码中直接处理内存。尽管如此，当有需求时，标准库中的`unsafe`包提供了让您可以窥视对象内存的功能。
- en: As the name suggests, it is normally not considered safe to use this package
    in your code. Another thing to note is that the `unsafe` package does not come
    with Go 1 compatibility guidelines, which means that functionalities could stop
    working in future versions of Go.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，通常不认为在您的代码中使用此包是安全的。另一个需要注意的事项是，`unsafe`包没有Go 1兼容性指南，这意味着功能可能在Go的后续版本中停止工作。
- en: 'The simplest example you can find of using the `unsafe` package can be found
    in the `math` package:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unsafe`包的最简单例子可以在`math`包中找到：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This takes a `float32` as input and returns `uint32`. The `float32` number is
    converted to an `unsafe.Pointer` object and then dereferenced to convert it to
    a `uint32`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个`float32`作为输入并返回`uint32`。`float32`数字被转换为`unsafe.Pointer`对象，然后解引用以转换为`uint32`。
- en: 'The reverse conversion on the preceding function can also be found in the `math`
    package:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中也可以找到反向转换，在`math`包中：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Another example of using the `unsafe` package, which you can find in the standard
    library is when calling C programs from your Go code. This is formally known as
    `cgo`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unsafe`包的另一个例子，您可以在标准库中找到，是在从Go代码调用C程序时。这正式称为`cgo`。
- en: Note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To get `cgo` to work on Windows, you need to have the `gcc` compiler installed
    on your machine. You can use 'Minimalist GNU for Windows' ([https://packt.live/2EbOKuZ](https://packt.live/2EbOKuZ)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上使 `cgo` 生效，你需要在你的机器上安装 `gcc` 编译器。你可以使用 'Minimalist GNU for Windows'
    ([https://packt.live/2EbOKuZ](https://packt.live/2EbOKuZ))。
- en: 'There are some special functions provided in the pseudo C package that convert
    Go data types to C data or vice versa, for example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪 C 包中提供了一些特殊函数，可以将 Go 数据类型转换为 C 数据或反之，例如：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can write your program as normal Go code and call functions written in
    C, as shown in the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像以下示例那样编写正常的 Go 代码并调用 C 代码编写的函数：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can define functions in C in the following format. To use functions in
    the standard library, the `import` statement is preceded by a comment, which is
    treated as the header section of your C code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以下面的格式定义 C 中的函数。要使用标准库中的函数，`import` 语句前面有一个注释，该注释被视为你的 C 代码的头部部分：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding function prints the input to the console. To be able to use the
    C code, we need to import the pseudo package called `C`. In the `main` function,
    we can call the `myprint()` function using the C package.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数将输入打印到控制台。为了能够使用 C 代码，我们需要导入名为 `C` 的伪包。在 `main` 函数中，我们可以使用 C 包调用 `myprint()`
    函数：
- en: 'Running this program should get you the following output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序应该得到以下输出：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Exercise 19.02: Using cgo with unsafe'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 19.02：使用 cgo 和 unsafe
- en: 'In this exercise, we will learn how to use the `unsafe` package to get hold
    of the underlying memory of a string:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习如何使用 `unsafe` 包获取字符串的底层内存：
- en: 'Create a `main.go` file and make the following imports. The C pseudo-package
    is needed to use the C libraries:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main.go` 文件并执行以下导入。C 伪包需要使用 C 库：
- en: '[PRE45]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define a `main()` function and declare a `C` string:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `main()` 函数并声明一个 `C` 字符串：
- en: '[PRE46]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Set the value of the `cString` variable with the text `Hello World!\n`. It
    is always a good practice to clean up allocated memory when dealing with `C`,
    so add the `C.free()` function call to perform the cleanup:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `cString` 变量的值设置为文本 `Hello World!\n`。处理 `C` 时，始终是一个好习惯清理分配的内存，因此添加 `C.free()`
    函数调用来执行清理：
- en: '[PRE47]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Declare a variable, `b`, as a byte array to store the output of converting
    the `CString` into a Go `byte` array:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量 `b`，作为字节数组以存储将 `CString` 转换为 Go `byte` 数组后的输出：
- en: '[PRE48]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `C.GoBytes()` function converts an `unsafe`.`Pointer` object into a Go `byte`
    array.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`C.GoBytes()` 函数将 `unsafe.Pointer` 对象转换为 Go `byte` 数组。'
- en: 'Print the `byte` array to the console:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `byte` 数组打印到控制台：
- en: '[PRE49]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the program using the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序：
- en: '[PRE50]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You should get the following output:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE51]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this exercise, we learned how to use `Cgo` and create C objects in Go. We
    then used the `unsafe` package to convert a `CString` object into an `unsafe.Pointer`,
    which maps directly to the memory of the `CString`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 `Cgo` 并在 Go 中创建 C 对象。然后我们使用 `unsafe` 包将 `CString` 对象转换为 `unsafe.Pointer`，它直接映射到
    `CString` 的内存。
- en: 'Activity 19.02: Using Wildcard with Go Test'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 19.02：使用 Go Test 的通配符
- en: You have a project with multiple test files and multiple test cases defined
    inside them. Create multiple packages and define tests inside them. Using the
    wildcard pattern, run all test cases in the project with a single command. Make
    sure that all the unit tests are being run using the command.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个包含多个测试文件和其中定义的多个测试用例的项目。创建多个包并在其中定义测试。使用通配符模式，使用单个命令运行项目中的所有测试用例。确保所有单元测试都使用该命令运行。
- en: 'Perform the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a package called `package1`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `package1` 的包。
- en: Create a file called `run_test.go` and define a unit test called `TestPackage1`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `run_test.go` 的文件，并定义一个单元测试 `TestPackage1`。
- en: Create a package called `package2`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `package2` 的包。
- en: Create a file called `run_test.go` and define a unit test called `TestPackage2`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `run_test.go` 的文件，并定义一个单元测试 `TestPackage2`。
- en: 'Print the results of `TestPackage1` and `TestPackage2` using the wildcard pattern:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通配符模式打印 `TestPackage1` 和 `TestPackage2` 的结果：
- en: '![Figure 20.4: Recursive test with wildcard'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 20.4：使用通配符的递归测试'
- en: '](img/B14177_19_04.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_19_04.jpg](img/B14177_19_04.jpg)'
- en: 'Figure 19.4: Recursive test with wildcard'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.4：使用通配符的递归测试
- en: In this activity, we have learned how to use the wildcard pattern to recursively
    run tests on all test files inside a project. This will come in handy when you
    want to automate running tests in your continuous integration pipeline.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们学习了如何使用通配符模式递归地在项目中的所有测试文件上运行测试。当你想要在持续集成管道中自动化运行测试时，这将非常有用。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 782.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第782页找到。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the special features in Go that are not so
    obvious.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Go语言中一些不那么明显的特殊功能。
- en: We covered the use of build constraints and how they can be used to control
    the behavior of your application build. Build constraints can be used to perform
    conditional compilation using the `GOOS` and `GOARCH` variables. They can also
    be used to ignore a file during compilation. Another common use of `build` tags
    is to add tags to files that contain integration tests.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了构建约束的使用方法以及如何使用`GOOS`和`GOARCH`变量进行条件编译来控制应用程序构建的行为。构建约束还可以用于在编译时忽略文件。`build`标签的另一个常见用途是为包含集成测试的文件添加标签。
- en: We have seen use cases for the `reflect` package and the functions that can
    be used to access the type and value of objects at runtime. Reflection is a good
    way to solve scenarios where we can only determine the data type of a variable
    at runtime.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`reflect`包及其在运行时访问对象类型和值的函数的使用案例。反射是一种解决我们只能在运行时确定变量数据类型场景的好方法。
- en: We also demonstrated how wildcards can be used to perform lists and tests on
    multiple packages in your project. We also learned the use of the `unsafe` package
    to access runtime memory in Go. The `unsafe` package is commonly used when using
    C libraries.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还演示了如何使用通配符在项目中的多个包上执行列表和测试。我们还学习了使用`unsafe`包在Go语言中访问运行时内存。`unsafe`包在使用C库时常用。
- en: Over the course of the book, we have covered the basics of Go with variables
    and various type declarations. We have seen the special behavior of interfaces
    and errors in Go. The book also covered chapters focused on application development.
    Handling files and JSON data is very common in any application's development,
    especially web applications. The chapters on databases and HTTP servers delve
    into how you can manage the communication and storage of data. We also looked
    at how to easily perform concurrent operations using goroutines. Finally, in the
    last topic of the book, we covered how to improve your code quality by focusing
    on testing and securing your application. Last but not least, we explored special
    features in Go such as build constraints and the use of the `unsafe` package.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们已经介绍了Go语言的基础，包括变量和各种类型声明。我们看到了Go语言中接口和错误的特殊行为。本书还涵盖了专注于应用程序开发的章节。处理文件和JSON数据在任何应用程序的开发中都非常常见，尤其是在Web应用程序中。关于数据库和HTTP服务器的章节深入探讨了如何管理数据的通信和存储。我们还探讨了如何使用goroutines轻松执行并发操作。最后，在本书的最后一个主题中，我们介绍了如何通过关注测试和确保应用程序的安全性来提高代码质量。最后但同样重要的是，我们探讨了Go语言中的特殊功能，如构建约束和`unsafe`包的使用。
