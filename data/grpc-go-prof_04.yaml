- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Setting Up a Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: As the chapter title suggests, we are going to set up a gRPC project from scratch.
    We are first going to create our Protobuf schema as we are doing schema-driven
    development. Once the schema is created, we will generate Go code. Finally, we
    are going to write the templates for the server and client so that we can reuse
    them later in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如章节标题所暗示的，我们将从头开始搭建一个gRPC项目。我们首先将创建我们的Protobuf模式，因为我们正在进行模式驱动开发。一旦模式创建完成，我们将生成Go代码。最后，我们将编写服务器和客户端的模板，以便我们可以在本书的后续部分重用它们。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Common gRPC project architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的gRPC项目架构
- en: Generating Go code out of a schema
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模式生成Go代码
- en: Writing reusable server/client templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可重用的服务器/客户端模板
- en: Prerequisites
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: I assume that you already have protoc installed from the last chapter. If you
    do not, this is the right time to install it because without it, you will not
    benefit as much from this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经从上一章安装了protoc。如果没有，现在是安装它的正确时机，因为没有它，你将无法从本章中获得太多好处。
- en: 'In this chapter, I will show common ways of setting up a gRPC project. I will
    use protoc, Buf, and Bazel. Thus, depending on the one(s) you are interested in,
    you will have to download the tool(s). Buf is an abstraction over protoc that
    lets us run protoc commands more easily. On top of that, it provides features
    such as linting and detecting breaking changes. You can download Buf from here:
    [https://docs.buf.build/installation](https://docs.buf.build/installation). I
    will also use Bazel to automatically generate Go code from Protobuf and the binary
    of our server and client. If you are interested in using it, you can check the
    installation documentation ([https://github.com/bazelbuild/bazelisk#installation](https://github.com/bazelbuild/bazelisk#installation)).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将展示设置gRPC项目的常见方法。我将使用protoc、Buf和Bazel。因此，根据你感兴趣的，你可能需要下载相应的工具。Buf是protoc的一个抽象层，使我们能够更容易地运行protoc命令。在此基础上，它还提供了诸如linting和检测破坏性更改等功能。你可以从这里下载Buf：[https://docs.buf.build/installation](https://docs.buf.build/installation)。我还会使用Bazel来自动从Protobuf生成Go代码以及服务器和客户端的二进制文件。如果你有兴趣使用它，你可以查看安装文档（[https://github.com/bazelbuild/bazelisk#installation](https://github.com/bazelbuild/bazelisk#installation)）。
- en: Finally, you can find the code for this chapter under the `chapter4` folder
    in the accompanying GitHub repository ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在配套GitHub仓库的`chapter4`文件夹中找到本章的代码（[https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4)）。
- en: Creating a .proto file definition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建.proto文件定义
- en: Since the goal of this chapter is to write a template that we can use for later
    projects, we are going to create a dummy proto file that will let us test whether
    our build system is working properly or not. This dummy proto file will contain
    both a message and a service because we want to test code generation for both
    Protobuf and gRPC.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的目标是编写一个可以用于后续项目的模板，我们将创建一个虚拟的proto文件，这样我们可以测试我们的构建系统是否正常工作。这个虚拟的proto文件将包含一个消息和一个服务，因为我们想测试Protobuf和gRPC的代码生成。
- en: 'The message, called `DummyMessage`, will be defined as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`DummyMessage`的消息将定义如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The service, called `DummyService`, will be defined as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为`DummyService`的服务将定义如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, because we are planning to generate Golang code, we still need to define
    an option called `go_package` and set its value to the name of the Go module concatenated
    with the name of the subfolder containing the proto files. This option is important
    because it lets us define the package in which the generated code should be. In
    our case, the project architecture is the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们计划生成Golang代码，我们仍然需要定义一个名为`go_package`的选项，并将其值设置为Go模块名称与包含proto文件的子文件夹名称的连接。这个选项很重要，因为它允许我们定义生成代码应该所在的包。在我们的情况下，项目架构如下：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have a monorepo (Go workspace) with three submodules: `client`, `proto`,
    and `server`. We create each submodule by going into each folder and running the
    following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个monorepo（Go工作空间），包含三个子模块：`client`、`proto`和`server`。我们通过进入每个文件夹并运行以下命令来创建每个子模块：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`$FOLDER_NAME` should be replaced with the name of the folder you are currently
    in (`client`, `proto`, or `server`).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`$FOLDER_NAME`应替换为你当前所在的文件夹名称（`client`、`proto`或`server`）。'
- en: 'To make the process a little bit quicker, we can create a command that will
    list the folder in the `root` directory and execute the `go` command. To do so,
    you can use the following UNIX (Linux/macOS) command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使过程更快一些，我们可以创建一个命令，该命令将列出 `root` 目录中的文件夹并执行 `go` 命令。为此，您可以使用以下 UNIX（Linux/macOS）命令：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are on Windows, you can use PowerShell to run the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows，您可以使用 PowerShell 运行以下命令：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After that, we can create the workspace file. We do so by going to the root
    of the project (`chapter4`) and running the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以创建工作空间文件。我们这样做是通过进入项目的根目录（`chapter4`）并运行以下命令：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now have the following `go.work`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有以下 `go.work`：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each submodule has the following `go.mod`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子模块都有以下 `go.mod`：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we’ll replace `$MODULE_NAME` with a URL such as `github.com/PacktPublishing/gRPC-Go-for-Professionals`
    and `$SUBMODULE_NAME`, with the respective name of the folder containing the file.
    In the case of `go.mod` in the client, we will have the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将用 URL 替换 `$MODULE_NAME`，例如 `github.com/PacktPublishing/gRPC-Go-for-Professionals`，并用文件夹包含文件的相应名称替换
    `$SUBMODULE_NAME`。在客户端的 `go.mod` 的情况下，我们将有如下内容：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we can complete `dummy.proto` by adding the following line to our
    file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在我们的文件中添加以下行来完成 `dummy.proto`：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now have the following `dummy.proto`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有以下 `dummy.proto`：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That is all we need to test the code generation out of our `dummy.proto`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们测试从 `dummy.proto` 生成代码所需的所有内容。
- en: Generating Go code
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成 Go 代码
- en: To stay impartial in terms of the tools you need to generate code, I will present
    three different tools from the lowest level to the highest. We are going to start
    by seeing how to manually generate code with protoc. Then, because we do not want
    to write lengthy command lines all the time, we are going to see how to make this
    generation easier with Buf. Finally, we are going to see how to use Bazel to integrate
    the code generation as part of our build.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在生成代码所需的工具方面保持公正，我将从底层到高层介绍三种不同的工具。我们将首先看看如何使用 protoc 手动生成代码。然后，因为我们不想总是编写冗长的命令行，我们将看看如何使用
    Buf 使这一生成过程变得更简单。最后，我们将看看如何使用 Bazel 将代码生成集成到我们的构建过程中。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In this section, I’m going to show basic ways of compiling your proto files.
    Most of the time, these commands will get you by, but sometimes you might have
    to check each tool’s documentation. For protoc, you can run `protoc --help` and
    get a list of the options. For Buf, you can go to the online documentation: [https://docs.buf.build/installation](https://docs.buf.build/installation).
    For Bazel, you also have online documentation at [https://bazel.build/reference/be/protocol-buffer](https://bazel.build/reference/be/protocol-buffer).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将展示编译您的 proto 文件的基本方法。大多数情况下，这些命令可以满足您的需求，但有时您可能需要查看每个工具的文档。对于 protoc，您可以通过运行
    `protoc --help` 来获取选项列表。对于 Buf，您可以访问在线文档：[https://docs.buf.build/installation](https://docs.buf.build/installation)。对于
    Bazel，您也可以在[https://bazel.build/reference/be/protocol-buffer](https://bazel.build/reference/be/protocol-buffer)找到在线文档。
- en: Protoc
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protoc
- en: Using protoc is the manual way of generating code out of proto files. This technique
    might be fine if you are only dealing with a few proto files and you do not have
    a lot of dependencies between files (imports). Otherwise, this will be quite painful,
    as we will see.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 protoc 是从 proto 文件中手动生成代码的方法。如果您只处理几个 proto 文件且文件之间（导入）没有很多依赖关系，这种方法可能很合适。否则，正如我们将看到的，这将会相当痛苦。
- en: However, I still believe that we should learn the protoc command a bit so that
    we get a sense of what we can do with it. Also, higher-level tools are based on
    protoc, so this will help us understand its different features.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我仍然认为我们应该稍微学习一下 protoc 命令，以便我们了解我们可以用它做什么。此外，高级工具基于 protoc，这将帮助我们理解其不同的功能。
- en: 'With our `dummy.proto` file from the previous section, we can run protoc in
    the root folder (`chapter4`) like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们上一节中的 `dummy.proto` 文件，我们可以在根目录（`chapter4`）中运行 protoc，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, this might look a bit scary and, in fact, is not the shortest command that
    you could write to do this. I am going to show you a more compact one when we
    talk about Buf. But first, let us dissect the preceding command into parts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可能会看起来有点吓人，实际上，这不是您能写的最短的命令之一。当我们谈到 Buf 时，我会向您展示一个更紧凑的命令。但首先，让我们将前面的命令分解成几个部分。
- en: 'Before discussing `--go_out` and `--go-grpc_out`, let us look at `--go_opt=module`
    and `--go-grpc_opt=module`. These options are telling protoc about the common
    module to be stripped out by the value passed for the `go_package` option in our
    `proto` file. Say we have the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论`--go_out`和`--go-grpc_out`之前，让我们看看`--go_opt=module`和`--go-grpc_opt=module`。这些选项在告诉protoc关于要被`proto`文件中`go_package`选项传递的值移除的公共模块。假设我们有以下内容：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, -`-go_opt=module=github.com/PacktPublishing/gRPC-Go-for-Professionals`
    will strip the value after `module=` from our `go_package`, so now we only have
    `/proto/dummy/v1`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`-` `-go_opt=module=github.com/PacktPublishing/gRPC-Go-for-Professionals`将会从我们的`go_package`中移除`module=`后面的值，因此现在我们只有`/proto/dummy/v1`。
- en: Now that we understand this, we can get to `--go_out` and `--go-grpc_out`. These
    two options tell protoc where to generate the Go code. In our case, it seems that
    we are telling protoc to generate our code at the root level, but in fact, because
    it is combined with the two previous options, it will generate the code right
    next to the proto file. This is due to the stripping of the package, which leads
    protoc to generate the code in the folder `/``proto/dummy/v1` package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了这一点，我们可以进入`--go_out`和`--go-grpc_out`。这两个选项告诉protoc在哪里生成Go代码。在我们的例子中，看起来我们正在告诉protoc在根级别生成我们的代码，但实际上，因为它与前面两个选项结合在一起，它将在proto文件旁边生成代码。这是由于包的移除，导致protoc在`/``proto/dummy/v1`包中生成代码。
- en: Now, you can see how painful it might be to write that kind of command all the
    time. Most people do not do that. They either write a script to do it automatically
    or use other tools, such as Buf.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到一直编写这种命令可能会多么痛苦。大多数人不会这样做。他们要么编写一个脚本来自动完成这项工作，要么使用其他工具，例如Buf。
- en: Buf
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buf
- en: 'For Buf, we have a little bit more setup to do to generate code. At the root
    of the project (`chapter4`), we are going to create a Buf module. To do that,
    we can simply run the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Buf，我们需要进行一些额外的设置来生成代码。在项目的根目录（`chapter4`）中，我们将创建一个Buf模块。为了做到这一点，我们可以简单地运行以下命令：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a file called `buf.yaml`. This file is where you can set project-level
    options such as linting or even tracking breaking changes. These are beyond the
    scope of this book, but if you are interested in this tool, check out the documentation
    ([https://buf.build/docs/tutorials/getting-started-with-buf-cli/](https://buf.build/docs/tutorials/getting-started-with-buf-cli/)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`buf.yaml`的文件。这个文件是设置项目级别选项的地方，例如代码检查或跟踪破坏性更改。这些内容超出了本书的范围，但如果你对这个工具感兴趣，可以查看其文档（[https://buf.build/docs/tutorials/getting-started-with-buf-cli/](https://buf.build/docs/tutorials/getting-started-with-buf-cli/))）。
- en: 'Once we have that, we need to write the configuration for generation. In a
    file called `buf.gen.yaml`, we will have the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些，我们需要编写生成配置。在一个名为`buf.gen.yaml`的文件中，我们将有如下内容：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are defining the use of the Go plugin for Protobuf and gRPC. For each,
    we are saying that we want to generate the code in the `proto` directory, and
    we are using another `--go_opt` and `--go-grpc_opt` for protoc, which is `paths=source_relative`.
    When this is set, the generated code is placed in the same directory as the input
    file (`dummy.proto`). So, in the end, Buf is running something like what we did
    in the protoc section. It is running the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义Go插件在Protobuf和gRPC中的使用。对于每一个，我们都在说我们希望生成代码在`proto`目录下，并且我们使用另一个`--go_opt`和`--go-grpc_opt`选项来配置protoc，其值为`paths=source_relative`。当这个设置被启用时，生成的代码将被放置在输入文件（`dummy.proto`）相同的目录中。因此，最终，Buf正在运行类似于我们在protoc部分所做的事情。它正在运行以下命令：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to run generation using Buf, we simply need to run the following command
    (in chapter4):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Buf运行生成，我们只需要运行以下命令（在`chapter4`目录下）：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using Buf is pretty common for mid-size or large projects. It helps with automation
    of code generation and is easy to get started with. However, you might have noticed
    that you need to generate the code in one step and then build your Go application.
    Bazel will help us consolidate everything in one step.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Buf在中型或大型项目中相当普遍。它有助于自动化代码生成，并且易于开始使用。然而，你可能已经注意到你需要分步生成代码然后构建你的Go应用程序。Bazel将帮助我们一步完成所有这些。
- en: Bazel
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this section, I will be using variables called `GO_VERSION`, `RULES_GO_VERSION`,
    `RULES_GO_SHA256`, `GAZELLE_VERSION`, `GAZELLE_SHA256`, and `PROTO_VERSION`. We
    have not included these variables in this section to ensure that the book remains
    easily updated. You can find the versions in the `versions.bzl` file in the `chapter4`
    folder ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4](https://github.com/PacktPublishing/Implementing-gRPC-in-Golang-Microservice/tree/main/chapter4)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将使用名为 `GO_VERSION`、`RULES_GO_VERSION`、`RULES_GO_SHA256`、`GAZELLE_VERSION`、`GAZELLE_SHA256`
    和 `PROTO_VERSION` 的变量。我们没有在本节中包含这些变量，以确保书籍易于更新。您可以在 `chapter4` 文件夹中的 `versions.bzl`
    文件中找到这些版本（[https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter4](https://github.com/PacktPublishing/Implementing-gRPC-in-Golang-Microservice/tree/main/chapter4)）。
- en: Bazel is a little bit trickier to set up, but it is worth the effort. Once you
    have your build system up and running, you will be able to build the whole application
    (generation and build) and/or run it in one command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Bazel 的设置稍微复杂一些，但值得付出努力。一旦您的构建系统启动并运行，您将能够通过一条命令构建整个应用程序（生成和构建）以及/或运行它。
- en: In Bazel, we start by defining a file called `WORKSPACE.bazel` at the root level.
    In this file, we define all the dependencies for our project. In our case, we
    have dependencies on Protobuf and Go. On top of that, we are also going to add
    a dependency to Gazelle, which will help us create the `BUILD.bazel` file needed
    to generate our code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bazel 中，我们首先在根级别定义一个名为 `WORKSPACE.bazel` 的文件。在这个文件中，我们定义了我们项目的所有依赖项。在我们的例子中，我们依赖于
    Protobuf 和 Go。除此之外，我们还将添加一个对 Gazelle 的依赖，这将帮助我们创建生成代码所需的 `BUILD.bazel` 文件。
- en: 'So, in `WORKSPACE.bazel`, before anything else, we are going to define our
    workspace name, import our version variables, and import some utilities to clone
    Git repositories and download archives:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 `WORKSPACE.bazel` 中，在定义其他任何内容之前，我们将定义我们的工作区名称，导入我们的版本变量，并导入一些用于克隆 Git 仓库和下载存档的实用工具：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, we are going to define the dependency for Gazelle:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义 Gazelle 的依赖项：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we need to pull the dependency for building Go binaries, applications,
    and so on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们需要拉取构建 Go 二进制文件、应用程序等的依赖项：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have that, we can pull the dependencies of `rules_go`, set the
    toolchain for building the Go project, and tell Gazelle where to find our `WORKSPACE.bazel`
    file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们可以拉取 `rules_go` 的依赖项，设置构建 Go 项目的工具链，并告诉 Gazelle 我们 `WORKSPACE.bazel`
    文件的位置：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we pull the dependency for Protobuf and load its dependencies:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们拉取 Protobuf 的依赖并加载其依赖项：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our `WORKSPACE.bazel` is complete.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `WORKSPACE.bazel` 文件已经完成。
- en: 'Let us now move to `BUILD.bazel` at the root level. In this file, we are going
    to define the command to run Gazelle, and we are going to let Gazelle know the
    Go module name and that we want it to not consider the Go files in the `proto`
    directory. We do so because otherwise, Gazelle would think that the Go file in
    the `proto` directory should also have its own Bazel target file and this might
    create problems down the road:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到根级别的 `BUILD.bazel` 文件。在这个文件中，我们将定义运行 Gazelle 的命令，并将让 Gazelle 知道 Go 模块名称，以及我们希望它不要考虑
    `proto` 目录中的 Go 文件。我们这样做是因为否则，Gazelle 会认为 `proto` 目录中的 Go 文件也应该有自己的 Bazel 目标文件，这可能会在以后造成问题：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'With that, we can now run the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们现在可以运行以下命令：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you have installed Bazel through Bazelisk, Bazel will try to get its newest
    version each time you run a bazel command. In order to avoid this, you can create
    a file called .bazelversion containing the version of bazel you currently have
    installed. You can find the version by typing
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过 Bazelisk 安装了 Bazel，每次您运行 bazel 命令时，Bazel 都会尝试获取其最新版本。为了避免这种情况，您可以创建一个名为
    .bazelversion 的文件，包含您当前安装的 bazel 版本。您可以通过输入以下命令找到版本：
- en: '**bazel --version**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**bazel --version**'
- en: An example can be found in the chapter4 folder.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以在 chapter4 文件夹中找到。
- en: 'After the dependencies are pulled up and compiled, you should be able to see
    a `BUILD.bazel` file generated in the `proto/dummy/v1` directory. The most important
    part of this file is the following `go_library`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉取依赖并编译完成后，您应该能够在 `proto/dummy/v1` 目录中看到一个生成的 `BUILD.bazel` 文件。此文件最重要的部分是以下
    `go_library`：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Later, we will use this library and link it to our binary. It contains all the
    generated code that we need to get started.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用这个库并将其链接到我们的二进制文件中。它包含我们开始所需的全部生成代码。
- en: Server boilerplate
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器模板
- en: 'Our build system is ready. We can now focus on the code. But before going into
    that, let us define what we want. In this section, we want to build a template
    for the gRPC server that we can reuse for later chapters and even later projects
    outside of the book. To do that, there are a few things that we want to avoid:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建设系统已经准备好了。现在我们可以专注于代码。但在进入之前，让我们定义我们想要的东西。在本节中，我们想要构建一个gRPC服务器的模板，我们可以将其用于后续章节，甚至用于书外的后续项目。为此，有一些事情我们想要避免：
- en: Implementation details such as service implementation
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现细节，如服务实现
- en: Specific connection options
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的连接选项
- en: Setting an IP address as constant
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将IP地址设置为常量
- en: We can solve these by not caring about the generated code anymore. It was just
    for testing our build system. Then, we will default to an insecure connection
    for testing. Finally, we will take the IP address as an argument for our program.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不再关心生成的代码来解决这些问题。它只是为了测试我们的构建系统。然后，我们将默认使用不安全的连接进行测试。最后，我们将IP地址作为程序的参数：
- en: 'Let us do that step by step:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来做：
- en: 'We are first going to need to add the gRPC dependency to `server/go.mod`. So,
    in the `server` directory, we can type the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要将gRPC依赖项添加到`server/go.mod`中。因此，在`server`目录中，我们可以输入以下命令：
- en: '[PRE26]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we are going to take the first argument passed to the program and return
    a usage message if no argument is passed:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将获取程序传递的第一个参数，如果没有传递参数，则返回一个用法信息：
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After that, we need to listen for the incoming connection. We can do that with
    the `net.Listen` provided in Go. This listener will need to be closed at the end
    of the program. This might be when a user kills it or if the server fails. And
    obviously, if we get an error during the construction of that listener, we just
    want the program to fail and let the user know:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要监听传入的连接。我们可以使用Go提供的`net.Listen`来实现。这个监听器在程序结束时需要被关闭。这可能是当用户终止它或服务器失败时。显然，如果在构造监听器期间发生错误，我们只想让程序失败并通知用户：
- en: '[PRE32]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, with all of this, we can start creating a `grpc.Server`. We first need
    to define some connection options. As this is a template for future projects,
    we are going to keep the options empty. With this array of `grpc.ServerOption`
    objects, we can create a new gRPC server. This is the server that we will use
    later to register endpoints. After that, we will need to close the server at some
    point, so we use a `defer` statement for that. Finally, we call a function called
    `Serve` on the `grpc.Server` that we created. This takes the listener as a parameter.
    It can fail, so if there is an error, we return that to the client:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有了所有这些，我们可以开始创建一个`grpc.Server`。我们首先需要定义一些连接选项。由于这是一个未来项目的模板，我们将保持选项为空。有了这个`grpc.ServerOption`对象数组，我们可以创建一个新的gRPC服务器。这是我们稍后用于注册端点的服务器。之后，我们将在某个时候关闭服务器，因此我们使用`defer`语句来实现。最后，我们在创建的`grpc.Server`上调用名为`Serve`的函数。它接受监听器作为参数。它可能会失败，所以如果有错误，我们将将其返回给客户端：
- en: '[PRE42]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the end, we have the following `main` function (`server`/`main.go`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有以下`main`函数（`server`/`main.go`）：
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are now able to run our server by running the `go run` command on our `server/main.go`.
    We can terminate the execution by using *Ctrl* + *C*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`server/main.go`上运行`go run`命令来运行我们的服务器。我们可以使用*Ctrl* + *C*来终止执行：
- en: '[PRE50]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Bazel
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'If you want to use Bazel, you will need a couple of extra steps. The first
    step is to update the `BUILD.bazel` in our root directory. In there, we are going
    to use a Gazelle command that will detect all the dependencies needed for our
    project and dump them in a file called `deps.bzl`. So, after the `gazelle` command,
    we can just add the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Bazel，您需要几个额外的步骤。第一步是更新根目录中的`BUILD.bazel`。在那里，我们将使用一个Gazelle命令来检测我们项目所需的所有依赖项，并将它们放入一个名为`deps.bzl`的文件中。因此，在`gazelle`命令之后，我们只需添加以下内容：
- en: '[PRE51]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can run the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下命令：
- en: '[PRE52]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After it has finished detecting all the dependencies of the `server` module,
    it will create a `deps.bzl` file and link it inside our `WORKSPACE.bazel`. You
    should have the following line in the workspace file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测完`server`模块的所有依赖项后，它将创建一个`deps.bzl`文件并将其链接到我们的`WORKSPACE.bazel`中。您应该在工作空间文件中包含以下行：
- en: '[PRE53]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we can rerun our `gazelle` command to make sure it creates the `BUILD.bazel`
    file for our server. We run the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以重新运行`gazelle`命令以确保它为我们的服务器创建`BUILD.bazel`文件。我们运行以下命令：
- en: '[PRE54]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We then get our `BUILD.bazel` in the `server` directory. The most important
    thing to note is that in this file, we can see Bazel linked gRPC to `server_lib`.
    We should have something like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`server`目录中获取我们的`BUILD.bazel`文件。需要注意的是，在这个文件中，我们可以看到Bazel将gRPC链接到了`server_lib`。我们应该有类似以下的内容：
- en: '[PRE55]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can now run our server in an equivalent way as the `go` `run` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用与`go` `run`命令相同的方式运行我们的服务器：
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This command will pull Protobuf and build it. Recent Protobuf version require
    to be built with C++14 or newer. You can tell bazel to automatically specify the
    C++ version to build Protobuf with in a file called .bazelrc. In order to keep
    this chapter version-independent, we recommend you to check the .bazelrc file
    in the chapter4 of the Github repository. You can copy paste the file in your
    project folder.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将拉取Protobuf并构建它。最近的Protobuf版本需要用C++14或更高版本构建。你可以告诉bazel在名为`.bazelrc`的文件中自动指定构建Protobuf的C++版本。为了保持本章的版本独立性，我们建议你检查GitHub仓库中的chapter4目录下的`.bazelrc`文件。你可以将文件复制粘贴到你的项目文件夹中。
- en: '[PRE56]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And so, we are done with the server. This is a simple template that will let
    us create new servers pretty easily in the next chapters. It is listening on a
    given port and waiting for some requests. Now, in order to make it easy to carry
    out such requests, let us create a template for the client.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，服务器部分我们已经完成。这是一个简单的模板，将使我们能够在下一章中轻松地创建新的服务器。它正在监听指定的端口并等待一些请求。现在，为了使执行此类请求变得容易，让我们为客户端创建一个模板。
- en: Client boilerplate
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端模板
- en: Let us now write the client boilerplate. This will be very similar to writing
    the server boilerplate but instead of creating a listener on an IP and port, we
    are going to call the `grpc.Dial` function and pass the connection options to
    it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来编写客户端模板。这将会非常类似于编写服务器模板，但不同的是，我们不是在IP和端口上创建监听器，而是要调用`grpc.Dial`函数，并将连接选项传递给它。
- en: 'Once again, we are not going to hardcode the address we are going to connect
    to. We are going to take that as a parameter:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们不会硬编码要连接的地址。我们将将其作为一个参数来处理：
- en: '[PRE57]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After that, we are going to create an instance of `DialOption`, and to keep
    this boilerplate generic, we are going to make an insecure connection to the server
    with the `insecure.NewCredentials()` function. Do not worry though; we will discuss
    how to make secure connections later:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建一个`DialOption`实例，为了使这个模板通用，我们将使用`insecure.NewCredentials()`函数与服务器建立一个不安全的连接。不过，不用担心；我们稍后会讨论如何建立安全连接：
- en: '[PRE58]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we can just call for the `grpc.Dial` function to create a `grpc.ClientConn`
    object. This is the object that we are going to need later to call the API endpoints.
    Lastly, this is a connection object, so at the end of our client’s lifetime, we
    are going to close it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需调用`grpc.Dial`函数来创建一个`grpc.ClientConn`对象。这是我们稍后需要用来调用API端点的对象。最后，这是一个连接对象，所以在我们客户端的生命周期结束时，我们将关闭它：
- en: '[PRE59]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'That is pretty much it for the client. The complete code is the following (`client/main.go`):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端来说，这就差不多了。完整的代码如下（`client/main.go`）：
- en: '[PRE60]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Clearly, right now, it is not doing anything; however, we can test it by running
    our server first:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，目前它什么都没做；然而，我们可以通过先运行我们的服务器来测试它：
- en: '[PRE61]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we run our client:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行我们的客户端：
- en: '[PRE62]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The server should wait infinitely and the client should be returning without
    any error on the terminal. If this is the case, you are ready to write some gRPC
    API endpoints.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应该无限期地等待，而客户端应该在终端上无错误地返回。如果是这种情况，你就准备好编写一些gRPC API端点。
- en: Bazel
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'This time, Bazel’s setup will not be as long as for the server. This is mostly
    because we already have the `deps.bzl` file and we can reuse it for the client.
    All we need to do is use Gazelle to generate our `BUILD.bazel` and we are done:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Bazel的设置不会像服务器那样长。这主要是因为我们已经有了一个`deps.bzl`文件，我们可以为客户端重用它。我们只需要使用Gazelle生成我们的`BUILD.bazel`文件，然后我们就完成了：
- en: '[PRE63]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We should now have a `BUILD.bazel` in the `client` directory. The most important
    thing to note is that in this file, we can see Bazel linked gRPC to the `client_lib`.
    We should have something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该在`client`目录中有一个`BUILD.bazel`文件。需要注意的是，在这个文件中，我们可以看到Bazel将gRPC链接到了`client_lib`。我们应该有类似以下的内容：
- en: '[PRE64]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can now run our client in an equivalent way as the `go` `run` command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用与`go` `run`命令相同的方式运行我们的客户端：
- en: '[PRE65]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We now have both our server and client. As of now, they do not do anything,
    but this is the intended purpose. Later in this book, by just copying them, we
    will be able to focus only on what matters, which is the API. Before doing any
    of that though, let us have a quick look at some of the most important options
    for the server and client setup.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了服务器和客户端。到目前为止，它们什么也不做，但这正是预期的目的。在这本书的稍后部分，通过简单地复制它们，我们就能专注于最重要的部分，即
    API。但在做任何那之前，让我们快速看一下服务器和客户端设置的一些最重要的选项。
- en: Server and Dial options
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器和拨号选项
- en: We touched upon `ServerOption` and `DialOption` briefly with the `grpc.ServerOption`
    object and the `grpc.WithTransportCredentials` function. However, there are a
    lot of other options you can choose from. For readability’s sake, I will not go
    into detail about every one of them, but I want to present some major options
    that you will probably use. All `ServerOptions` can be found at the root of the
    `grpc-go` repository in the file called `server.go` ([https://github.com/grpc/grpc-go/blob/master/server.go](https://github.com/grpc/grpc-go/blob/master/server.go))
    and the `DialOptions` in the file called `dialoptions.go` ([https://github.com/grpc/grpc-go/blob/master/dialoptions.go](https://github.com/grpc/grpc-go/blob/master/dialoptions.go)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到了 `ServerOption` 和 `DialOption`，使用了 `grpc.ServerOption` 对象和 `grpc.WithTransportCredentials`
    函数。然而，还有很多其他选项可以选择。为了可读性，我不会详细介绍每一个，但我想要展示一些你可能需要使用的主要选项。所有 `ServerOptions` 都可以在
    `grpc-go` 仓库的 `server.go` 文件中找到（[https://github.com/grpc/grpc-go/blob/master/server.go](https://github.com/grpc/grpc-go/blob/master/server.go)），而
    `DialOptions` 在 `dialoptions.go` 文件中（[https://github.com/grpc/grpc-go/blob/master/dialoptions.go](https://github.com/grpc/grpc-go/blob/master/dialoptions.go)）。
- en: grpc.Creds
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: grpc.Creds
- en: This is an option, on both the server and client sides, that we will use when
    we talk about securing APIs. For now, we saw that we can call `grpc.WithTransportCredentials`
    with an `insecure.NewCredentials` result, and this gives us an insecure connection.
    This means that none of the requests and responses are encrypted; anyone could
    intercept these messages and read them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个选项，在服务器和客户端双方，当我们谈论保护 API 时都会使用。目前，我们看到我们可以使用 `grpc.WithTransportCredentials`
    与 `insecure.NewCredentials` 的结果一起调用，这给我们提供了一个不安全的连接。这意味着请求和响应都没有加密；任何人都可以拦截这些消息并读取它们。
- en: '`grpc.Creds` lets us provide a `TransportCredentials` object instance, which
    is a common interface for all the supported transport security protocols, such
    as TLS and SSL. If we had a certificate file called `server.crt` and a key file
    called `server.pem`, we could create the following `ServerOption`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`grpc.Creds` 允许我们提供一个 `TransportCredentials` 对象实例，这是一个适用于所有受支持传输安全协议的通用接口，例如
    TLS 和 SSL。如果我们有一个名为 `server.crt` 的证书文件和一个名为 `server.pem` 的密钥文件，我们可以创建以下 `ServerOption`：'
- en: '[PRE66]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Similarly, on the client side, we would have a `DialOptions` to be able to
    communicate with the server:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在客户端，我们会有一个 `DialOptions` 来与服务器通信：
- en: '[PRE67]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As of now, you do not worry too much about that. As I mentioned, we will use
    this later and see how to get the certificates.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你不必太担心这一点。正如我提到的，我们稍后会使用它，并看到如何获取证书。
- en: grpc.*Interceptor
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: grpc.*Interceptor
- en: If you are not familiar with interceptors, these are pieces of code that are
    called before or after handling a request (server side) or sending a request (client
    side). The goal is generally to enrich the request with some extra information,
    but it can also be used to log requests or deny certain requests if they do not
    have the right headers, for example.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉拦截器，这些是在处理请求（服务器端）之前或之后（客户端）调用的代码片段。通常的目标是向请求添加一些额外信息，但它也可以用来记录请求或拒绝某些请求，例如，如果它们没有正确的头信息。
- en: 'We will see later how to define interceptors, but imagine that we have a piece
    of code logging our requests and another one checking that the authorization header
    is set. We could chain these interceptors on the server side like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后看到如何定义拦截器，但想象一下，我们有一段代码记录我们的请求，另一段代码检查授权头是否已设置。我们可以在服务器端像这样链式调用这些拦截器：
- en: '[PRE68]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that the order of these interceptors is important because they will be
    called in the order provided in the `grpc.ChainUnaryInterceptor` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些拦截器的顺序很重要，因为它们将按照 `grpc.ChainUnaryInterceptor` 函数中提供的顺序被调用。
- en: 'For the client side, we could have the same kind of log interceptor and another
    one adding the authorization header with a cached value of the token needed for
    authentication with the server. This would give something like the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，我们可以有相同类型的日志拦截器，以及另一个添加带有缓存令牌值的授权头部的拦截器。这将给出以下内容：
- en: '[PRE69]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, note that you can use other functions to add these interceptors. Here
    are the other ones:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，你可以使用其他函数来添加这些拦截器。以下是一些其他函数：
- en: '`WithUnaryInterceptor` to set one unary RPC interceptor'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WithUnaryInterceptor` 来设置一个单一 RPC 拦截器
- en: '`WithStreamInterceptor` to set one stream RPC interceptor'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WithStreamInterceptor` 来设置一个流 RPC 拦截器
- en: '`WithChainStreamInterceptor` to chain multiple stream RPC interceptors'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `WithChainStreamInterceptor` 来链式连接多个流 RPC 拦截器
- en: We saw two important options that are configurable on both the server and client
    sides. By using credentials, we can secure our communication between the communication
    actors, and by using interceptors, we can run arbitrary code before sending or
    receiving requests. Obviously, we just saw two options and there are many more
    on both sides. If you are interested in checking out all of them, I invite you
    to go to the GitHub repository linked at the beginning of this section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了两个重要的选项，这两个选项可以在服务器和客户端两侧进行配置。通过使用凭证，我们可以保护通信参与者之间的通信安全，通过使用拦截器，我们可以在发送或接收请求之前运行任意代码。显然，我们只看到了两个选项，而每一侧都有更多选项。如果你对查看所有这些选项感兴趣，我邀请你访问本节开头链接的
    GitHub 仓库。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created templates for our future servers and clients. The
    goal was to write the boilerplate code and set up our build so that we can generate
    code and run our Go applications.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为未来的服务器和客户端创建了模板。目标是编写样板代码并设置我们的构建，以便我们可以生成代码并运行我们的 Go 应用程序。
- en: We saw that we can use protoc manually to generate Go code and use it with our
    application. We then saw that we can make the process a little bit smoother by
    using Buf to generate the code for us. Finally, we saw that we can use Bazel to
    both generate our code and run our application in a single step.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以手动使用 protoc 生成 Go 代码并将其与我们的应用程序一起使用。然后我们看到我们可以通过使用 Buf 生成代码来使这个过程更加顺畅。最后，我们看到我们可以使用
    Bazel 在单步中生成我们的代码并运行我们的应用程序。
- en: Finally, we saw that we can use multiple `ServerOptions` and `DialOptions` to
    tweak the server and client. We mostly looked at `grpc.Creds` and interceptors,
    but there are a lot more options that we can check in the `grpc-go` repository.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了我们可以使用多个 `ServerOptions` 和 `DialOptions` 来调整服务器和客户端。我们主要看了 `grpc.Creds`
    和拦截器，但还有更多选项可以在 `grpc-go` 仓库中检查。
- en: In the next chapter, we will see how to write each type of API provided in gRPC.
    We will start with unary APIs, then check server and client streaming APIs, and
    finally, see how to write bidirectional streaming endpoints.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何编写 gRPC 提供的每种类型的 API。我们将从单一 API 开始，然后检查服务器和客户端流 API，最后，我们将了解如何编写双向流端点。
- en: Quiz
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: What is the advantage of using protoc manually?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动使用 protoc 的优势是什么？
- en: No setup needed; you only need to install protoc.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需设置；你只需要安装 protoc。
- en: Shorter generation commands.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更短的生成命令。
- en: We can both generate Go code and run the application.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以同时生成 Go 代码并运行应用程序。
- en: What is the advantage of using Buf?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Buf 的优势是什么？
- en: No setup needed; you only need to install protoc.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需设置；你只需要安装 protoc。
- en: Shorter generation commands.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更短的生成命令。
- en: We can both generate Go code and run the application.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以同时生成 Go 代码并运行应用程序。
- en: What is the advantage of using Bazel?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Bazel 的优势是什么？
- en: No setup needed; you only need to install protoc.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无需设置；你只需要安装 protoc。
- en: Shorter generation commands.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更短的生成命令。
- en: We can both generate Go code and run the application.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以同时生成 Go 代码并运行应用程序。
- en: What is an interceptor?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是拦截器？
- en: An external piece of code that intercepts the payload of the communication
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一段外部代码，它拦截通信的有效负载
- en: A piece of code that runs in the server handler
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器处理程序中运行的代码片段
- en: A piece of code that runs before or after handling or sending a request
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理或发送请求之前或之后运行的代码片段
- en: Answers
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: C
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: C
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
