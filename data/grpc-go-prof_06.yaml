- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Designing Effective APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计有效的API
- en: While gRPC is performant, it is easy to make mistakes that will cost you in
    the long term or at scale. In this chapter, we are going to see the considerations
    that are important in order to design efficient APIs in gRPC. Since we are talking
    about API design, the considerations are going to be linked to Protobuf because,
    as you know by now, we define our types and endpoints in Protobuf.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 gRPC 性能良好，但很容易犯错误，这些错误在长期或大规模上可能会给你带来损失。在本章中，我们将探讨设计高效 gRPC API 的重要考虑因素。由于我们正在讨论API设计，这些考虑因素将与Protobuf相关联，因为正如你所知，我们在Protobuf中定义我们的类型和端点。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to choose the right integer type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择正确的整数类型
- en: Understanding the impact of field tags on the size of serialized data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解字段标签对序列化数据大小的影响
- en: How to use field masks to solve the over-fetching problem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用字段掩码解决过度获取问题
- en: Understanding how repeated fields can lead to a bigger payload than expected
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解重复字段如何导致比预期更大的有效负载
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will find the relevant code in the folder called `chapter6`
    in the accompanying GitHub repository ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter6](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter6)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你可以在附带的GitHub仓库中找到相关代码，该仓库位于名为`chapter6`的文件夹中（[https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter6](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter6)）。
- en: Choosing the right integer type
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的整数类型
- en: Protobuf is mostly performant because of its binary format and because of its
    representation of integers. While some types such as strings are serialized “as
    is” and prepended with the field tag, type, and length, numbers – especially integers
    – are generally serialized in way fewer bits than how they are laid out in your
    computer memory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf由于它的二进制格式以及它对整数的表示而性能优越。虽然某些类型，如字符串，是“原样”序列化并附加字段标签、类型和长度，但数字——尤其是整数——通常以比在计算机内存中布局的方式更少的位进行序列化。
- en: However, you might have noticed that I said “generally serialized.” This is
    because if you chose the wrong integer type for your data, the `varint` encoding
    algorithm might encode an `int32` into 5 bytes or more, whereas, in memory, it
    is 4 bytes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经注意到我说了“通常序列化”。这是因为如果你为你的数据选择了错误的整数类型，`varint`编码算法可能会将`int32`编码成5个字节或更多，而在内存中它只有4个字节。
- en: Let us see an example of a bad choice of integer type. Let us say that we want
    to encode the value 268,435,456\. We can check how this value would be serialized
    in memory and with Protobuf by using the `unsafe.Sizeof` function from the Go
    standard library and the `proto.Marshal` function provided by Protobuf. And finally,
    we are also going to use the well-known `Int32Value` type to wrap the value and
    be able to serialize it with Protobuf.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个错误的整数类型选择的例子。假设我们想要编码值268,435,456。我们可以通过使用Go标准库中的`unsafe.Sizeof`函数和由Protobuf提供的`proto.Marshal`函数来检查这个值在内存中和使用Protobuf序列化时的样子。最后，我们还将使用已知的`Int32Value`类型来包装该值，以便能够使用Protobuf进行序列化。
- en: Before writing the main function, let us try to make a generic function called
    `serializedSize`, which will return the size of an integer in memory and the size
    of the same integer being serialized with Protobuf.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写主函数之前，让我们尝试创建一个名为`serializedSize`的泛型函数，该函数将返回整数在内存中的大小以及使用Protobuf序列化的相同整数的大小。
- en: Important note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code presented here is present in the accompanying GitHub repository under
    the `helpers` directory. We thought it would not make sense to mix the TODO API
    and this kind of code so we separated it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码位于附带的GitHub仓库的`helpers`目录下。我们认为将TODO API和这类代码混合在一起没有意义，所以我们将其分开。
- en: 'Let us first add the dependencies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加依赖项：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first one is to have access to the well-known `Int32Value` type and the
    second one is to have access to predefined type constraints for generics.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一是能够访问已知的`Int32Value`类型，第二是能够访问预定义的类型约束以用于泛型。
- en: 'We are going to use generics to accept any kind of integer as data and let
    us specify a wrapper message to be able to serialize the data with Protobuf. We
    will have the following function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用泛型来接受任何类型的整数作为数据，并让我们指定一个包装消息，以便能够使用Protobuf序列化数据。我们将有以下函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we can simply use the `proto.Marshal` function from the Protobuf library
    to serialize the wrapper and return both the result of `unsafe.Sizeof` and the
    length of the serialized data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以简单地使用 Protobuf 库中的 `proto.Marshal` 函数来序列化包装器，并返回 `unsafe.Sizeof` 的结果和序列化数据的长度：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, it is simple. We can just call that function from our `main` with
    a variable containing the value `268,435,456` and an instance of `Int32Value`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，就简单了。我们只需从我们的 `main` 函数中调用该函数，传递一个包含值 `268,435,456` 的变量和一个 `Int32Value` 实例：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we run this, we should get the following result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们应该得到以下结果：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, if you looked carefully at the code, you might be thinking that the `–1`
    after `len(out)` is cheating. With Protobuf, `Int32Value` is serialized into 6
    bytes. While you are right about the fact that the real serialization size is
    6 bytes, the first bytes represent the type and field tag. So, to keep the comparison
    of the serialized data fair, we remove the metadata and only compare the number
    itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你仔细看了代码，你可能会认为 `len(out)` 后面的 `–1` 是在作弊。在 Protobuf 中，`Int32Value` 被序列化为
    6 个字节。虽然你关于实际序列化大小是 6 个字节的事实是正确的，但前几个字节代表类型和字段标签。因此，为了使序列化数据的比较公平，我们移除了元数据，只比较数字本身。
- en: 'You may be thinking that our current TODO API, which uses `uint64` for IDs,
    also has this problem, and you would be totally right. You can easily see that
    by switching `int32` to `uint64`, `Int32Value` to `UInt64Value`, and setting our
    data to be equal to 72,057,594,037,927,936:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，我们当前的 TODO API，它使用 `uint64` 作为 ID，也存在这个问题，你完全正确。你可以很容易地看到，通过将 `int32`
    改为 `uint64`，将 `Int32Value` 改为 `UInt64Value`，并将我们的数据设置为 72,057,594,037,927,936：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the preceding code, we would get the following result:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们会得到以下结果：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This means that after approximately 72 quadrillion tasks are registered, we
    will have this problem. Obviously, for our use case, we are safe using `uint64`
    as `id` because to have such a problem we would need every person on the planet
    to create 9 million tasks (72 quadrillion / 8 billion). But this might problem
    might be more significant in other use cases, and we need to be aware of the limitations
    of our API.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在注册了大约 72 万亿个任务之后，我们会遇到这个问题。显然，对于我们的用例，我们使用 `uint64` 作为 `id` 是安全的，因为要出现这样的问题，我们需要地球上每个人创建
    9000 万个任务（72 万亿 / 80 亿）。但这个问题在其他用例中可能更为严重，我们需要意识到我们 API 的局限性。
- en: An alternative to using integers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用整数的替代方案
- en: An alternative that is often cited and even recommended by Google is to use
    strings for IDs. They mention that 2^64 (`int64`) is not “as big as it used to
    be.” In the context of the company, this is understandable. They must deal with
    a lot of data and with bigger numbers than a lot of us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经常被引用，甚至被 Google 推荐的替代方案是使用字符串作为 ID。他们提到 2^64 (`int64`) 已经“不像以前那么大了。”在公司的背景下，这是可以理解的。他们必须处理大量的数据，以及比我们大多数人更大的数字。
- en: However, this is not the only advantage that a string has over a number type.
    The biggest advantage is probably the evolution of your API. If, at some point,
    you need to store bigger numbers, the only alternative you have is to switch to
    the string type. But the problem is that there is no backward and forward compatibility
    between the number type you used previously and a string. Thus, you will have
    to add a new field to your schema, clutter the message definition, and make the
    developers check whether the ID is set as a string or as a number in case of communication
    with older/newer versions of an application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，字符串相对于数字类型的优势不仅仅如此。最大的优势可能是你的 API 的演变。如果在某个时刻你需要存储更大的数字，你唯一的替代方案就是切换到字符串类型。但问题是，你之前使用的数字类型和字符串之间没有前后兼容性。因此，你将不得不在你的模式中添加一个新字段，使消息定义变得杂乱，并让开发者检查在与旧版/新版应用程序通信时
    ID 是否被设置为字符串或数字。
- en: Strings also provide safety in the fact that these cannot be used for arithmetic
    operations. This limits smart developers, in a good way, to not being able to
    pull smart tricks with IDs and end up making the numbers overflow. IDs are effectively
    treated as globs that nobody should manually handle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串还提供了安全性，因为这些不能用于算术运算。这在一定程度上限制了聪明开发者，但也是一种好的限制，使他们不能对 ID 进行一些聪明的操作，最终导致数字溢出。ID
    被有效地视为全局变量，不应该有人手动处理。
- en: In conclusion, for some use cases, it might be a good idea to start directly
    with strings for IDs. If you expect to scale or simply deal with numbers that
    are bigger than the integer limits, a string is the solution. However, in a lot
    of cases, you will probably only need `uint64`. Just be aware of your needs and
    plan for the future.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，对于某些用例，直接从字符串开始为 ID 编写可能是个好主意。如果你预计要扩展或简单地处理比整数限制更大的数字，字符串是解决方案。然而，在许多情况下，你可能只需要
    `uint64`。只需了解你的需求并规划未来即可。
- en: Choosing the right field tag
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的字段标签
- en: As you know, field tags are serialized together with the actual data to let
    Protobuf know into which field to deserialize the data. And as these tags are
    encoded as `varint`, the bigger the tag, the bigger the impact on your serialized
    data size. In this section, let us talk about the two considerations that you
    must make to not let these tags affect your payload too much.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，字段标签与实际数据一起序列化，以便 Protobuf 知道将数据反序列化到哪个字段。由于这些标签以 `varint` 编码，标签越大，对序列化数据大小的冲击就越大。在本节中，让我们讨论你必须考虑的两个因素，以防止这些标签过多地影响你的有效载荷。
- en: Required/optional
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必需/可选
- en: Having big field tags might be fine if you are aware of the trade-off. One common
    way of treating big tags is to see them as being used for optional fields. An
    optional field means that it is less often populated with data and because Protobuf
    does not serialize fields that are not populated, the tag itself is not serialized.
    However, we will occasionally populate this field and we will incur costs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你意识到权衡，大字段标签可能没问题。处理大标签的一种常见方式是将它们视为用于可选字段。可选字段意味着它不太常填充数据，由于 Protobuf 不序列化未填充的字段，因此标签本身不会被序列化。然而，我们偶尔会填充这个字段，这将产生成本。
- en: One advantage of such a design is keeping relevant information together without
    having to create loads of messages to keep the field tags small. It will make
    the code easier to read and make the reader aware of the possible fields that
    they can populate.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的优点是，在不创建大量消息以保持字段标签较小的情况下，将相关信息保持在一起。这将使代码更容易阅读，并让读者了解他们可以填充的可能字段。
- en: The downside though is that if you are creating an API that is user-facing,
    you might incur costs too often. This might be because the user does not understand
    how to use your API properly or simply because the user has specific needs. This
    might also happen in a company setting, but it can be mitigated by senior software
    engineers or internal documentation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缺点是，如果你正在创建一个面向用户的 API，你可能会经常产生成本。这可能是由于用户不理解如何正确使用你的 API，或者简单地因为用户有特定的需求。这种情况也可能在公司环境中发生，但可以通过高级软件工程师或内部文档来缓解。
- en: 'Let us see an example of the downside that big tags bring. For the sake of
    an example, let us say that we have the following message (`helpers/tags.proto`):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看大标签带来的负面影响的例子。为了举例，让我们假设我们有以下消息（`helpers/tags.proto`）：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that these numbers are not random. If you remember, during the Protobuf
    primer, I explained that tags are encoded as `varints`. These numbers are the
    thresholds for which it takes one more byte to serialize the tag alone.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些数字并非随机。如果你还记得，在 Protobuf 入门介绍中，我解释过标签是以 `varints` 编码的。这些数字是标签单独序列化所需额外一个字节的阈值。
- en: Now, with that, we are going to calculate the size of the message into which
    we incrementally set the value for fields. We are going to start with an empty
    object, then we are going to set `tag`, then `tag2`, and so on. Note also that
    we are going to set the same value for all the fields (1). This will show us the
    overhead that it takes to simply serialize the tag.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个，我们将计算消息的大小，我们将逐步设置字段的值。我们将从一个空对象开始，然后设置 `tag`，然后 `tag2`，依此类推。请注意，我们将为所有字段设置相同的值（1）。这将显示仅序列化标签所需的额外开销。
- en: 'In `helpers/tags.go`, we have the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `helpers/tags.go` 中，我们有以下内容：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We repurposed the `serializedSize` we saw earlier. We set the field by dereferencing
    the pointer to the field, we calculate the size of the `Tag` message with the
    new field set, and we print the result. This result is a little bit manipulated
    to show us only the bytes for the tag. We subtract i+1 from the size because i
    is zero-indexed (so `+1`). So, effectively, we subtract the number of fields already
    set from the size, which is also the size it takes to serialize the data without
    the tag (1 byte for value 1).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新使用了之前看到的`serializedSize`。我们通过取消对字段指针的引用来设置字段，我们使用新设置的字段计算`Tag`消息的大小，并打印结果。这个结果经过一点处理，只显示标签的字节。我们从大小中减去i+1，因为i是零索引的（所以`+1`）。因此，实际上，我们从大小中减去了已设置的字段数量，这也是不包含标签序列化数据所需的大小（值为1的字节）。
- en: 'In the end, if we run this, we have the following (beautified):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们运行这个，我们将得到以下结果（美化后的）：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tells us that each time we pass a threshold, we get one more byte overhead
    in our serialized data. At first, we have an empty message, so we get 0 bytes,
    then we have a tag of 1, which is serialized into 1 byte, after that a tag of
    2 serialized into 2 bytes, and so on. We can look at the difference between two
    lines to get the overhead. The overhead of setting `value` to a field with tag
    `2048` instead of setting it to a field with tag `16` is 3 bytes (6 – 3 bytes).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，每次我们通过一个阈值，我们的序列化数据就会多出一个字节的开销。一开始，我们有一个空消息，所以得到0字节，然后我们有一个标签1，它序列化为1字节，之后标签2序列化为2字节，以此类推。我们可以查看两行之间的差异来得到开销。将`value`设置为标签为`2048`的字段而不是标签为`16`的字段的开销是3字节（6
    - 3字节）。
- en: In conclusion, we need to keep the smaller field tags available for the fields
    that are the most populated or required. This is because these tags will almost
    always be serialized, and we want to minimize the impact of the tag serialization.
    For optional fields, we might use bigger tags to keep the related fields together,
    and with that, we should incur non-recurrent payload increases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们需要保留较小的字段标签，用于最常使用或必需的字段。这是因为这些标签几乎总是会被序列化，而我们希望最小化标签序列化的影响。对于可选字段，我们可能会使用较大的标签来将相关字段放在一起，并且因此，我们可能会产生非重复的数据负载增加。
- en: Splitting messages
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割消息
- en: In general, we prefer to split messages to keep smaller objects and have fewer
    fields, and thus smaller tags. This lets us arrange information into entities
    and understand what the given information is representing. Our `Task` message
    is an example of that. It groups information and we can reuse that entity in,
    for example, `UpdateTasksRequest` to accept a fully featured `Task` as a request.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们更喜欢分割消息以保持较小的对象和较少的字段，从而有较小的标签。这让我们能够将信息安排成实体，并理解给定信息所代表的内容。我们的`Task`消息就是一个例子。它将信息分组，我们可以在例如`UpdateTasksRequest`中重用这个实体，以接受一个功能齐全的`Task`作为请求。
- en: 'However, while it is interesting to be able to separate information into entities,
    this does not come for free. Your payload gets affected by the use of a user-defined
    type. Let us see an example of splitting a message and how it can affect the size
    of serialized data. This example shows that there is a size overhead when splitting
    messages. To show that, we are going to create a message that contains a name
    and a wrapper around a name. This first time we check the size, we will only set
    the string, and the second time we will only set the wrapper. Here is what I mean
    by such a message:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然能够将信息分离成实体很有趣，但这并不是免费的。你的负载会受到用户定义类型的使用的影響。让我们看看分割消息的例子以及它如何影响序列化数据的大小。这个例子表明，在分割消息时会有大小开销。为了展示这一点，我们将创建一个包含名称和一个名称包装器的消息。第一次检查大小，我们只会设置字符串，第二次我们只会设置包装器。这就是我所说的这样的消息：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Right now, let us not worry about the usefulness of this example. We are just
    trying to prove that splitting a message has an overhead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不必担心这个示例的有用性。我们只是在尝试证明分割消息会有额外的开销。
- en: 'Then, we will write a `main` function that simply sets the value to `name`
    first, then calculates the size and prints it. And then, we will clear the name,
    set the `ComplexName.name` field, calculate the size, and print it. If there is
    an overhead, the sizes should be different. In `helpers/split.go`, we have the
    following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个`main`函数，该函数简单地首先设置`name`的值，然后计算大小并打印它。然后，我们将清除名称，设置`ComplexName.name`字段，计算大小并打印它。如果有开销，大小应该不同。在`helpers/split.go`中，我们有以下内容：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we run that, we should get:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们应该得到：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Effectively, these two sizes are different. But what is the difference? The
    difference is that user-defined types are serialized as length-delimited types.
    In our case, the simple name would be serialized as 0a 05 50 61 63 6b 74\. 0a
    is the wire type for Length-Delimited + tag 1 and the rest are the characters.
    But for the complex type, we have 12 07 0a 05 50 61 63 6b 74\. We recognize the
    last 7 bytes but there are two more in front. 12 is the `Length-Delimited wire
    type + tag 2` and 07 is the length of the following bytes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个大小是不同的。但区别在哪里呢？区别在于用户定义的类型被序列化为长度限定类型。在我们的例子中，简单的名称会被序列化为0a 05 50 61
    63 6b 74。0a是长度限定+标签1的线类型，其余的是字符。但对于复杂类型，我们有12 07 0a 05 50 61 63 6b 74。我们识别了最后的7个字节，但前面还有两个字节。12是`长度限定线类型+标签2`，07是后续字节的长度。
- en: In conclusion, we once again have a trade-off. The more tags we have in messages,
    the more possibility there is for us to incur costs in terms of payload size.
    However, the more we try to split messages to keep the tags small, the more we
    will also incur costs because the data will be serialized as length-delimited
    data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们再次面临权衡。消息中的标签越多，我们在有效载荷大小方面承担成本的可能性就越大。然而，我们越试图分割消息以保持标签小，我们也将承担更多的成本，因为数据将被序列化为长度限定数据。
- en: Improving UpdateTasksRequest
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进`UpdateTasksRequest`
- en: To reflect on what we have learned in the last section, we are going to improve
    the serialized size of `UpdateTasksRequest`. This is important because of the
    context in which this message is used. This is a message that is sent 0 or more
    times by the client since it is used in a client streaming RPC endpoint. It means
    that any overhead in serialized data size will be multiplied by the number of
    times that we send this message over the wire.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了反思我们在上一节中学到的内容，我们将改进`UpdateTasksRequest`的序列化大小。这很重要，因为消息的使用上下文。这是一个客户端可能会发送0次或多次的消息，因为它用于客户端流式RPC端点。这意味着序列化数据中的任何开销都将乘以我们在线发送此消息的次数。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The following code is present in the accompanying GitHub repository. You will
    find the new Protobuf code in the `proto/todo/v2` folder and the server/client
    code for `UpdateTasks` will be updated to reflect the change. Finally, one thing
    to notice is that we do not provide backward and forward compatibility. A server
    in `chapter6` cannot receive a request from a client in `chapter5`. More work
    is needed to make that possible.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码位于附带的GitHub仓库中。你将在`proto/todo/v2`文件夹中找到新的Protobuf代码，并且`UpdateTasks`的服务器/客户端代码将被更新以反映这一变化。最后，需要注意的一点是我们不提供前后兼容性。`chapter6`中的服务器不能接收来自`chapter5`中的客户端的请求。需要更多的工作来实现这一点。
- en: 'If we look at the current message, we have the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看当前的消息，我们有以下内容：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is describing exactly what we want, but now we know that some extra bytes
    will be serialized because of the sub-message. To solve this problem, we can simply
    copy the fields that we let the user change and the ID that describes which task
    to update. This will give us the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要描述的内容，但现在我们知道由于子消息的存在，将序列化一些额外的字节。为了解决这个问题，我们可以简单地复制我们允许用户更改的字段以及描述要更新哪个任务的ID。这将给我们以下结果：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the same definition as the `Task` message.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`Task`消息的定义相同。
- en: 'Now, you might be thinking that we are repeating ourselves and that it is a
    waste to do so. However, there are two important benefits to doing that:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能认为我们在重复自己，这样做是浪费的。然而，这样做有两个重要的好处：
- en: We no longer need to incur overhead for the serialization of the user-defined
    type. On each request, we save 2 bytes (tag + type and length).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再需要为用户定义类型的序列化承担开销。在每次请求中，我们节省2个字节（标签+类型和长度）。
- en: We now have more control over the fields that a user might update. If we did
    not want the user to change `due_date` anymore, we would simply remove that from
    the `UpdateTaskRequest` message and reserve the tag 4.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们对用户可能更新的字段有了更多的控制。如果我们不想让用户再更改`due_date`，我们只需将其从`UpdateTaskRequest`消息中删除并保留标签4。
- en: To prove that this is more efficient in terms of serialized data size, we can
    temporarily modify the `UpdateTasks` function in `server/impl.go` a little bit
    for both `chapter5` and `chapter6`. To count the size of the payload, we can use
    the `proto.Marshal` that we used earlier and sum up the total serialized size.
    In the end, we can just print the result on the terminal when we receive an EOF.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这在序列化数据大小方面更有效，我们可以暂时修改`server/impl.go`中的`UpdateTasks`函数，以`chapter5`和`chapter6`为例。为了计算有效负载的大小，我们可以使用我们之前使用的`proto.Marshal`并汇总总序列化大小。最后，我们可以在接收到EOF时在终端上打印结果。
- en: 'Here is what it looks like in `chapter6`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter6`中，它看起来是这样的：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For `chapter5`, this leads to 56 bytes being sent over the network as requests,
    and for `chapter6`, we only send 50 bytes. Once again, this looks negligible because
    we are doing that at a small scale, but once we receive traffic, it will quickly
    pile up and impact our costs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`chapter5`，这导致网络中发送了56字节的请求，而对于`chapter6`，我们只发送了50字节。再次强调，这看起来微不足道，因为我们是在小规模上做的，但一旦我们收到流量，它将迅速累积并影响我们的成本。
- en: Adopting FieldMasks to reduce the payload
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用FieldMasks以减少有效负载
- en: After improving our `UpdateTasksRequest` message, we can now start looking at
    `FieldMasks` to further reduce the payload size, but this time we are going to
    focus on `ListTasksResponse`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进我们的`UpdateTasksRequest`消息之后，我们现在可以开始查看`FieldMasks`以进一步减少有效负载大小，但这次我们将专注于`ListTasksResponse`。
- en: 'First, let us understand what `FieldMasks` is. It refers to objects containing
    a list of paths telling Protobuf which fields to include and telling it implicitly
    which should not be included. An example of that could be the following. Saywe
    had a message such as `Task`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解什么是`FieldMasks`。它指的是包含一系列路径的对象，告诉Protobuf包含哪些字段，并隐式地告诉它哪些不应该包含。以下是一个例子。假设我们有一个`Task`这样的消息：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And we wanted to select only `id` and `done` fields, we could have a simple
    `FieldMask` like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想选择`id`和`done`字段，我们可以有一个简单的`FieldMask`，如下所示：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We could then apply that mask on an instance of `Task` and it would keep only
    the mentioned fields’ value. This is interesting when we are doing the equivalent
    of `GET` and we do not want to fetch too much unnecessary data (over-fetching).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这个掩码应用于`Task`的一个实例，并且它将只保留提到的字段的值。当我们进行类似于`GET`的操作，并且不想获取太多不必要的数据（过度获取）时，这很有趣。
- en: 'Our TODO API contains one such use case: `ListTasks`. Why? Because if a user
    wanted to fetch only part of the information, they would not be able to do so.
    Selecting part of the data might be useful for features such as synchronizing
    tasks from local storage to a backend. If the backend has IDs 1, 2, and 3 and
    the local has 1, 2, 3, 4, and 5, we want to be able to calculate the delta of
    the tasks that we need to upload. To do this, we would need to list only the IDs
    as fetching the description, done date, and `due_date` value would be wasteful.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的TODO API包含一个这样的用例：`ListTasks`。为什么？因为如果用户只想获取部分信息，他们将无法做到。选择部分数据可能对同步本地存储到后端等特性很有用。如果后端有ID
    1、2和3，而本地有1、2、3、4和5，我们希望能够计算出需要上传的任务的增量。为此，我们只需要列出ID，获取描述、完成日期和`due_date`值将是浪费的。
- en: Improving ListTasksRequest
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进ListTasksRequest
- en: '`ListTasksResponse` is a server-streaming kind of API. We send one request
    and we get 0 or more responses. This is important to mention because sending a
    `FieldMask` does not come for free. We still need to carry bytes on the wire.
    In our case, though, it is interesting to use masks because we can send it once
    and it will be applied to all the elements returned by the server.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListTasksResponse`是一种服务器端流式API。我们发送一个请求，然后得到0个或多个响应。这一点很重要，因为发送`FieldMask`并不是免费的。我们仍然需要在网络中传输字节。然而，在我们的情况下，使用掩码很有趣，因为我们只需发送一次，它就会应用于服务器返回的所有元素。'
- en: 'The first thing that we need to do is to declare such a `FieldMask`. To do
    that, we import `field_mask.proto` and add a field to `ListTasksRequest`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是声明这样的`FieldMask`。为此，我们导入`field_mask.proto`并在`ListTasksRequest`中添加一个字段：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can go to the server side and apply that mask to all the responses
    that we send. This is done with reflection and a little bit of boilerplate. The
    first thing that we need to do is to add a dependency in the server to work with
    slices and specifically access the `Contains` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以转到服务器端并将该掩码应用于我们发送的所有响应。这是通过反射和一些样板代码完成的。我们需要做的第一件事是在服务器中添加一个依赖项，以处理切片并特别访问`Contains`函数：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we can work with reflection. We are going to go over all the fields
    that a given message has and if its name is not present in the mask’s paths, we
    are going to remove its value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用反射。我们将遍历给定消息的所有字段，如果其名称不在掩码路径中，我们将移除其值：
- en: Important note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The following code is a simplistic implementation to filter fields in a message,
    but this is sufficient for our use case. In reality, there are more powerful features
    of `FieldMasks` such as filtering maps, lists, and sub-messages. Unfortunately,
    the Go implementation of Protobuf does not provide such utilities as the other
    implementations do, so we need to rely on writing our own code or using community
    projects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个简单的实现，用于在消息中过滤字段，但这对于我们的用例来说已经足够了。在现实中，`FieldMasks` 有更多强大的功能，如过滤映射、列表和子消息。不幸的是，Protobuf
    的 Go 实现没有提供像其他实现那样的此类实用工具，因此我们需要依赖编写自己的代码或使用社区项目。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With that, we can now basically use `Filter` in our `ListTasks` implementation
    to filter the `Task` object that will be sent in `ListTasksResponse`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在基本上可以在 `ListTasks` 实现中使用 `Filter` 来过滤将在 `ListTasksResponse` 中发送的 `Task`
    对象：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that `Filter` is called before calculating `Overdue`. This is because
    if we do not include `due_date` in `FieldMask`, we assume that the user does not
    care about the overdue. In the end, the overdue will be false, not serialized,
    and thus not sent over the wire.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Filter` 在计算 `Overdue` 之前被调用。这是因为如果我们没有在 `FieldMask` 中包含 `due_date`，我们假设用户不关心逾期。最终，逾期将是
    `false`，未序列化，因此不会通过网络发送。
- en: 'Then, we need to see how to use that on the client side. In this example, `printTasks`
    is going to print only IDs. We are going to receive `FieldMask` as a parameter
    of `printTasks` and add it to `ListTasksRequest`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要看看如何在客户端使用它。在这个例子中，`printTasks` 将只打印 ID。我们将接收 `FieldMask` 作为 `printTasks`
    的参数，并将其添加到 `ListTasksRequest` 中：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And finally, with `fieldmaskpb.New`, we first create a `FieldMask` with the
    path `id`. This function will check that `id` is a valid path in the message that
    we provide as the first argument. If there is no error, we can set the `Mask`
    field in our `ListTasksRequest` instance:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `fieldmaskpb.New`，我们首先使用路径 `id` 创建一个 `FieldMask`。这个函数将检查 `id` 是否是我们提供的第一个参数中的消息中的有效路径。如果没有错误，我们可以在我们的
    `ListTasksRequest` 实例中设置 `Mask` 字段：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we run that, we should have the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们应该得到以下输出：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that `overdue` is still printed as `false`, but in our case, it can be
    overlooked because we print overdue in the `printTasks` function and the default
    value of overdue (bool) is false..
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`overdue` 仍然被打印为 `false`，但在这个例子中，我们可以忽略它，因为我们已经在 `printTasks` 函数中打印了逾期，逾期（bool）的默认值是
    `false`。
- en: Beware the unpacked repeated field
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨防解压缩重复字段
- en: The last consideration is not helpful for our TODO API but is worth mentioning.
    In Protobuf, we have different ways of encoding repeated fields. We have packed
    and unpacked repeated fields.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个考虑因素对我们 TODO API 没有帮助，但值得一提。在 Protobuf 中，我们有不同的方式来编码重复字段。我们有两种重复字段的压缩和解压缩方式。
- en: Packed repeated fields
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩重复字段
- en: 'To understand, let us see an example of a packed repeated field. Let us say
    that we have the following message:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解，让我们看看一个压缩重复字段的例子。假设我们有以下消息：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is a simple list of the `uint32` scalar type. If we serialized this with
    the values 1, 2, and 3, we would get the following result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 `uint32` 标量类型的列表。如果我们使用值 1、2 和 3 进行序列化，我们会得到以下结果：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`repeated_scalar.txt` from the preceding command contains the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令中的 `repeated_scalar.txt` 包含以下内容：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is an example of a packed repeated field because of how the field wraps
    multiple values. You might think that this is normal since this is a list, but
    we are going to see later that this is not always true.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个压缩重复字段的例子，因为它如何包装多个值。你可能会认为这是正常的，因为这是一个列表，但我们将稍后看到这并不总是正确的。
- en: 'To understand what “wraps multiple values” means, we need to take a closer
    look at the hexadecimal presented by `hexdump`. We have 5 bytes: 0a 03 01 02 03\.
    As we know, a repeated field is serialized as a length-delimited type. So 0a is
    the combination of the type (`varint`) and field tag (1), 03 means that we have
    three elements in the list, and the rest are the actual values.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解“包装多个值”的含义，我们需要仔细看看 `hexdump` 展示的十六进制数。我们有 5 个字节：0a 03 01 02 03。正如我们所知，重复字段被序列化为长度限定类型。所以
    0a 是类型（`varint`）和字段标签（1）的组合，03 表示列表中有三个元素，其余的是实际值。
- en: Unpacked repeated fields
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解压缩重复字段
- en: 'However, serialized data for repeated fields is not always that compact. Let
    us look at an example of an unpacked repeated field. Let us say that we add the
    `packed` option with the value `false` for the field called `values`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重复字段的序列化数据并不总是那么紧凑。让我们看看一个未展开的重复字段的例子。假设我们为名为`values`的字段添加了`packed`选项，并将其值设置为`false`：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, if we run the same command with the same values, we should have the following
    result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用相同的值运行相同的命令，我们应该得到以下结果：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can see that we have a totally different way of serializing the data. This
    time, we repeatedly serialize `uint32`. Here, 08 stands for the type (`varint`)
    and tag (1), and you can see that it is present three times as we have three values.
    If we have more than two values in the repeated field, this is effectively adding
    a byte per value. In our case, we serialize the whole as 6 bytes instead of the
    5 previously.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们有了完全不同的数据序列化方式。这次，我们反复序列化`uint32`。在这里，08代表类型（`varint`）和标签（1），你可以看到它出现了三次，因为我们有三个值。如果我们重复字段中有超过两个值，这实际上会为每个值添加一个字节。在我们的例子中，我们序列化整个为6字节，而不是之前的5字节。
- en: Now, you might be thinking that you will just not use the `packed` option and
    you should always have a `packed` field. You would be right for repeated fields
    acting on scalars but not on more complex types. For example, strings, bytes,
    and user-defined types will always be serialized as unpacked and there is no way
    to avoid that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能认为你将不会使用`packed`选项，并且你应该始终有一个`packed`字段。对于作用于标量的重复字段来说，你会是对的，但对于更复杂的类型来说则不然。例如，字符串、字节和用户定义的类型将始终以未打包的形式序列化，而且无法避免这一点。
- en: 'Let us take an example with a user-defined type. Say we have the following
    Protobuf code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个用户定义的类型为例。假设我们有以下Protobuf代码：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now try to run the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试运行以下命令：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`repeated_ud.txt` from the preceding command contains the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令中的`repeated_ud.txt`包含以下内容：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can see that we now have a combination of both the overhead that we had with
    sub-messages earlier in the chapter and on top of that our repeated field is unpacked.
    We have 0a and 02, which correspond to the sub-message itself, and the 08 + value,
    which corresponds to the field called `value`. As you can see, this is now wasting
    much more bytes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们现在有了本章早期与子消息相关的开销，以及我们的重复字段现在是未打包的。我们有0a和02，它们对应于子消息本身，以及08 + value，它对应于名为`value`的字段。正如你所看到的，这现在浪费了更多的字节。
- en: Now, as this is impossible to avoid on complex types, it is incorrect to say
    that we should never use repeated fields on such types. This is a very useful
    concept, and it should be used with care, and we should be aware of its cost.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于在复杂类型上这是不可避免的，所以说我们不应该在这样类型上使用重复字段是不正确的。这是一个非常有用的概念，应该谨慎使用，并且我们应该意识到它的成本。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw the main considerations that we need to take into account
    when we design our APIs. Most of them were related to Protobuf since it is the
    interface of our API, and it handles serialization/deserialization. We saw that
    choosing the right integer type is important and can lead to problems in terms
    of payload size but also when we want to evolve our API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了在设计我们的API时需要考虑的主要因素。其中大部分与Protobuf有关，因为它是我们API的接口，并且负责序列化和反序列化。我们了解到选择正确的整数类型很重要，这可能会导致有效载荷大小的问题，而且在我们想要演进我们的API时也会引发问题。
- en: After that, we saw that choosing the right field tag is also important. This
    is due to the fact that tags are serialized along with the data and that they
    are serialized as `varints`. So the bigger the tag, the bigger our payload.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到了选择正确的字段标签也很重要。这是因为标签会与数据一起序列化，并且它们被序列化为`varints`。所以标签越大，我们的有效载荷就越大。
- en: Then, we saw how we can leverage `FieldMasks` to select the data that we need
    and avoid the over-fetching problem. While this is a concept that is not that
    developed in gRPC Go, other implementations use that extensively. This significantly
    reduces the payload that we send across the wire.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了如何利用`FieldMasks`来选择我们所需的数据，并避免过度获取问题。虽然这个概念在gRPC Go中并不是非常发达，但其他实现广泛使用了它。这显著减少了我们在网络中发送的有效载荷。
- en: And finally, we saw that we need to be careful when using repeated fields in
    Protobuf. This is because if we use them on a complex type, we will waste some
    bytes. However, repeated fields should not be avoided because of that. Sometimes
    they are the right data structure. In the next chapter, we are going to cover
    how to make API calls efficient and secure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了在使用 Protobuf 中的重复字段时需要小心。这是因为如果我们在一个复杂类型上使用它们，我们会浪费一些字节。然而，不应该因为这一点而避免使用重复字段。有时它们是正确的数据结构。在下一章中，我们将介绍如何使
    API 调用既高效又安全。
- en: Quiz
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: Why is it not always more optimal to use `varint` for integer types?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么对于整数类型来说，并不总是使用 `varint` 编码更优？
- en: No reason, they are always more optimal than fixed integers
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有理由，它们总是比固定整数更优
- en: '`varint` encoding serializes bigger numbers into a bigger amount of bytes'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`varint` 编码将更大的数字序列化成更多的字节'
- en: '`varint` encoding serializes smaller numbers into a bigger amount of bytes'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`varint` 编码将较小的数字序列化成更多的字节'
- en: How can we get the number of bytes a message will be serialized into?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何得到消息序列化后的字节数？
- en: '`proto.Marshal +` `len`'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`proto.Marshal +` `len`'
- en: '`proto.UnMarshal +` `len`'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`proto.Unmarshal +` `len`'
- en: '`len`'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`len`'
- en: What kind of tag should we give to fields that are often populated?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该给经常填充的字段分配什么样的标签？
- en: Bigger tags
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更大的标签
- en: Smaller tags
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 较小的标签
- en: What is the main problem of splitting messages to use smaller tags?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息拆分以使用较小的标签的主要问题是什么？
- en: We have overhead because sub-messages are serialized as length-delimited types
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有开销，因为子消息被序列化为长度分隔类型
- en: No problem – this is the way to go
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没问题——这就是正确的方法
- en: What is `FieldMask`?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `FieldMask`？
- en: A collection of fields’ paths telling us what data to exclude
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组字段路径，告诉我们需要排除哪些数据
- en: A collection of fields’ paths telling us what data to include
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组字段路径，告诉我们需要包含哪些数据
- en: When is a repeated field serialized as unpacked?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时重复字段以未打包的形式序列化？
- en: When repeated fields are acting on scalar types
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当重复字段作用于标量类型时
- en: Only when we use the packed option with the value `false`
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当我们使用带有值 `false` 的打包选项时
- en: When repeated fields are acting on complex types
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当重复字段作用于复杂类型时
- en: Answers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: B
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: C
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
