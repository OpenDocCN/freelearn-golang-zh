- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: More Essential Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多重要功能
- en: We saw previously that gRPC gives us a lot of important out-of-the-box features
    that make our job simpler. In this chapter, we are going to delve deeper into
    some of the important features that are not included in gRPC but are provided
    by the community. They generally build on top of the gRPC features to provide
    more convenience. They also provide a way to implement the most common practices
    to protect and optimize your APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到gRPC为我们提供了许多重要的开箱即用的功能，使我们的工作变得更简单。在本章中，我们将深入了解一些gRPC未提供但由社区提供的功能。它们通常建立在gRPC功能之上，以提供更多便利。它们还提供了一种实现最常见实践的方法，以保护和优化您的API。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Validating request messages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证请求消息
- en: Creating a middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建中间件
- en: Authenticating requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证请求
- en: Tracing API calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪API调用
- en: Applying rate limiting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用速率限制
- en: Retrying on error
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误重试
- en: By the end of the chapter, we will have learned what middleware are and what
    they are used for. And we are going to do that by learning more about the awesome
    community projects called `protoc-gen-validate` and `go-grpc-middleware`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将了解中间件是什么以及它们的作用。我们将通过学习名为`protoc-gen-validate`和`go-grpc-middleware`的出色社区项目来实现这一点。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will find the relevant code in the folder called `chapter8`
    in the accompanying GitHub repository ([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您可以在附带的GitHub仓库中找到相关代码，文件夹名为`chapter8`([https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8](https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter8))。
- en: Validating requests
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证请求
- en: The first thing that we are going to do is reduce the code that checks some
    properties of the request messages. We are going to use the `protoc-gen-validate`
    plugin for `protoc`, which helps us generate validation code for certain messages.
    This can be useful for the use case when we check the description length and the
    due date of a task. We will just call a generated `Validate()` function and it
    will tell us whether the requirements for the request message are fulfilled.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是减少检查请求消息某些属性的代码。我们将使用`protoc`的`protoc-gen-validate`插件，该插件帮助我们为某些消息生成验证代码。这对于检查任务描述长度和截止日期的使用场景非常有用。我们只需调用生成的`Validate()`函数，它就会告诉我们请求消息的要求是否得到满足。
- en: 'The first thing that we are going to do to generate this code is to install
    the plugin. This is a plugin maintained by Buf and you can get it like so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要生成此代码的第一件事是安装插件。这是一个由Buf维护的插件，您可以这样获取它：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once we have that, we are now able to use the `--validate_out` option from protoc.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们现在就可以使用protoc的`--validate_out`选项了。
- en: 'Now, whether we are using protoc manually or with the Buf CLI, we will need
    to copy the `validate.proto` file from the GitHub repository. This file can be
    found here: [https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto](https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto).
    We will copy it into our `proto` folder under the `validate` directory:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论我们是手动使用protoc还是使用Buf CLI，我们都需要从GitHub仓库复制`validate.proto`文件。此文件可以在以下位置找到：[https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto](https://github.com/bufbuild/protoc-gen-validate/blob/main/validate/validate.proto)。我们将将其复制到`validate`目录下的`proto`文件夹中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And now, we can import that file into other proto files and use the validation
    rules provided as field options.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将此文件导入其他proto文件，并使用提供的验证规则作为字段选项。
- en: 'Let us work with `AddTaskRequest` in `proto/todo/v2/todo.proto`. Right now,
    we have the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`proto/todo/v2/todo.proto`中的`AddTaskRequest`为例。目前，我们有以下内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we know, each time we try to add a `Task`, on the server side, we will check
    whether the description is empty or not and whether `due_date` is greater than
    `time.Now()` or not.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，每次我们尝试在服务器端添加一个`任务`时，我们都会检查描述是否为空，以及`due_date`是否大于`time.Now()`。
- en: 'We are now going to encode this logic into our `proto` file. The first thing
    that we need to do is import the `validate.proto` file. Then, we will have access
    to the `validate.rules` field option, which contains a set of rules for multiple
    types. We are going to work on `string` and `Timestamp` and we are going to use
    the `min_len` and `gt_now` fields. The first one describes the minimum length
    that the string should have when we call `Validate` and the second one tells us
    that the `Timestamp` provided should be in the future:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将把这个逻辑编码到我们的 `proto` 文件中。首先，我们需要做的是导入 `validate.proto` 文件。然后，我们将能够访问 `validate.rules`
    字段选项，它包含多个类型的规则集。我们将处理 `string` 和 `Timestamp`，我们将使用 `min_len` 和 `gt_now` 字段。第一个描述了在调用
    `Validate` 时字符串应该具有的最小长度，第二个告诉我们提供的 `Timestamp` 应该在未来：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have described this logic, we will need to generate code that checks
    that logic. Otherwise, these options are worthless. To generate this code, we
    are going to do it manually with protoc and then I will show you how to do it
    with Buf and Bazel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经描述了这个逻辑，我们需要生成检查这个逻辑的代码。否则，这些选项毫无价值。为了生成此代码，我们将手动使用 protoc，然后我会向你展示如何使用
    Buf 和 Bazel 来完成：
- en: 'As mentioned, with the plugin we can use the `--validate_out` option in `protoc`.
    This looks like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以使用插件在 `protoc` 中使用 `--validate_out` 选项。它看起来如下所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the command is similar to what we ran in the past. We simply added
    the new option and told it to work on Go code and to generate code based on the
    proto files in the `v2` folder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到命令与我们过去运行的类似。我们只是添加了新的选项，并告诉它处理 Go 代码，并基于 `v2` 文件夹中的 proto 文件生成代码。
- en: 'And now, on top of the Protobuf and gRPC generated code, you should also have
    a `.pb.validate.go` file in the `v2` folder. This should look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Protobuf 和 gRPC 生成的代码之上，你应该在 `v2` 文件夹中有一个 `.pb.validate.go` 文件。它应该看起来像这样：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside the generated file, you should be able to see the following function
    (among others):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的文件中，你应该能够看到以下函数（以及其他函数）：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is the function that we are now going to use in our `AddTask` endpoint
    on the server side. Right now, we have the following checks:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要在服务器端的 `AddTask` 端点使用的函数。目前，我们有以下检查：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let us replace that with the `Validate` function. We are simply going to call
    the function on the `in` parameter and if it returns any error, we will return
    the error from the function, otherwise, we will simply continue with our execution:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `Validate` 函数来替换它。我们只是简单地在 `in` 参数上调用该函数，如果它返回任何错误，我们将从函数返回错误，否则，我们将简单地继续我们的执行：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is as simple as that, and we saved ourselves from writing all the checks
    manually and trying to keep our error messages consistent across the different
    endpoints.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，我们就避免了手动编写所有检查并尝试在不同端点保持错误信息一致。
- en: 'We can now go to the `main` client and uncomment the functions, one by one,
    in the error section:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以进入 `main` 客户端，并逐个取消错误部分中的函数注释：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should get the following error for the first `addTask`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该为第一个 `addTask` 获得以下错误：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And this one for the second `addTask`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为第二个 `addTask` 添加的：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that the code error is `Unknown`. As of the time of writing this book,
    `protoc-gen-validate` does not appear to have a custom error code. This might
    appear in `v2` of the plugin. However, it provides us with a simple validation
    code and clean error messages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到代码错误是 `Unknown`。截至本书编写时，`protoc-gen-validate` 似乎没有自定义错误代码。这可能在插件的 `v2` 版本中出现。然而，它为我们提供了一个简单的验证代码和清晰的错误信息。
- en: Buf
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buf
- en: 'Using `protoc-gen-validate` with the Buf CLI is simple. We will add some configuration
    in our YAML files in order to generate the code. The first thing that we need
    to add is the dependency on `protoc-gen-validate` in our `buf.yaml` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Buf CLI 的 `protoc-gen-validate` 非常简单。我们将在我们的 YAML 文件中添加一些配置以生成代码。首先，我们需要在我们的
    `buf.yaml` 文件中添加对 `protoc-gen-validate` 的依赖：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This tells Buf that we need `protoc-gen-validate` during the generation process.
    It will later figure out how to pull the dependency by itself.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Buf 在生成过程中需要 `protoc-gen-validate`。它将稍后自己找出如何拉取依赖。
- en: 'And after that, we need to configure the plugin in the `buf.gen.yaml` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要在 `buf.gen.yaml` 文件中配置插件：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These options are the same as we typed manually earlier. Now, we can generate
    as usual by typing the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项与我们之前手动输入的相同。现在，我们可以通过输入以下命令来常规生成：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should now have the same three generated files that we obtained with the
    `protoc` command: `todo.pb.validate.go`, `todo_grpc.pb.go`, and `todo.pb.go`.
    Note that, in this case, we also generated code for `v1` and the `validate.proto`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该拥有与使用 `protoc` 命令获得相同的三个生成文件：`todo.pb.validate.go`、`todo_grpc.pb.go` 和
    `todo.pb.go`。注意，在这种情况下，我们还为 `v1` 和 `validate.proto` 生成了代码。
- en: Bazel
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'As always, the first thing we need to do is define the dependency in our `WORKSPACE.bazel`
    file. We are going to fetch the `protoc-gen-validate` project from GitHub and
    load its relevant dependencies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先需要在 `WORKSPACE.bazel` 文件中定义依赖项。我们将从 GitHub 获取 `protoc-gen-validate`
    项目并加载其相关依赖项：
- en: Important note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code that follows references a variable called `PROTOC_GEN_VALIDATE_VERSION`.
    This variable is defined in the `versions.bzl` file in the `chapter8` folder.
    We do not include it here to keep the code independent of versions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码引用了一个名为 `PROTOC_GEN_VALIDATE_VERSION` 的变量。这个变量在 `chapter8` 文件夹中的 `versions.bzl`
    文件中定义。我们在这里不包括它，以保持代码与版本无关。
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that, we now need to update our dependencies in the `deps.bzl` file. We
    can do that by typing the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在需要更新 `deps.bzl` 文件中的依赖项。我们可以通过输入以下命令来完成：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And finally, we need to generate the code and link it to our existing `todo
    go_library` in `proto/todo/v2/BUILD.bazel`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要生成代码并将其链接到我们现有的 `proto/todo/v2/BUILD.bazel` 中的 `todo go_library`。
- en: 'The first thing to add is the dependency on `protoc-gen-validate` `validate.proto`
    in `v2_proto proto_library`. This will allow `todo.proto` to import it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要添加对 `v2_proto proto_library` 中 `protoc-gen-validate` `validate.proto` 的依赖。这将允许
    `todo.proto` 导入它：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will replace `v2_go_proto go_proto_library` with `pgv_go_proto_library`
    (`protoc-gen-validate` library so that the generated code accesses any of the
    `protoc-gen-validate` internal code needed to compile:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将用 `pgv_go_proto_library` 替换 `v2_go_proto go_proto_library` (`protoc-gen-validate`
    库，以便生成的代码可以访问编译所需的任何 `protoc-gen-validate` 内部代码：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And finally, in order to avoid ambiguous imports for `validate/validate.proto`
    the next time we run Gazelle, we are going to map the `validate/validate.proto`
    import (in `proto/todo/v2/todo.proto`) to `@com_envoyproxy_protoc_gen_validate//validate:validate_proto`
    (defined in `protoc-gen-validate`). At the top of the `proto/todo/v2/BUILD.bazel`
    file, we can add the following `Gazelle` directive:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了避免在下次运行 Gazelle 时对 `validate/validate.proto` 的模糊导入，我们将 `validate/validate.proto`
    的导入（在 `proto/todo/v2/todo.proto` 中）映射到 `@com_envoyproxy_protoc_gen_validate//validate:validate_proto`（在
    `protoc-gen-validate` 中定义）。在 `proto/todo/v2/BUILD.bazel` 文件顶部，我们可以添加以下 `Gazelle`
    指令：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we have replaced our old `v2_go_proto` with the new one using `pgv_go_proto_library`,
    the code depending on this library will automatically get access to the generated
    `Validate` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用 `pgv_go_proto_library` 替换了旧的 `v2_go_proto`，依赖于这个库的代码将自动获得对生成的 `Validate`
    函数的访问。
- en: 'We can try running the server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试运行服务器：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And run the client with the error section code uncommented:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行带有取消注释的错误部分代码的客户端：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To conclude, we saw that we can encode validation logic in our proto files and
    generate validation code automatically with `protoc-gen-validate`. This declutters
    our code and provides consistent error messages across our API endpoints.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们看到了我们可以在 proto 文件中编码验证逻辑，并使用 `protoc-gen-validate` 自动生成验证代码。这简化了我们的代码，并在我们的
    API 端点提供了一致的错误消息。
- en: Middleware = interceptor
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件 = 拦截器
- en: In the context of gRPC, a middleware is an interceptor. It lies between the
    code registered by the developers and the actual gRPC framework. When gRPC receives
    some data from the wire, it will pass this data through the middleware first,
    and then if it is allowed to go through, the data will arrive in the actual endpoint
    handler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 gRPC 的上下文中，一个中间件是一个拦截器。它位于开发人员注册的代码和实际的 gRPC 框架之间。当 gRPC 从线路上接收到一些数据时，它首先将数据通过中间件传递，然后如果允许通过，数据将到达实际的端点处理器。
- en: These middleware are generally used in order to secure the endpoints against
    malicious actors or enforce certain prerequisites. An example of securing the
    API is rate-limiting clients. This is a limit on the number of requests that a
    client can make in a given timeframe and this is important because it prevents
    a lot of attacks, such as brute force attacks, DoS and DDoS, and web-scraping.
    And to enforce a certain prerequisite, we already saw an example where the client
    needs to be authenticated before being able to call an endpoint.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中间件通常用于保护端点免受恶意行为者的攻击或强制执行某些先决条件。一个保护API的例子是限制客户端的速率。这是在给定时间段内客户端可以发出的请求数量的限制，这是很重要的，因为它可以防止许多攻击，如暴力攻击、DoS和DDoS攻击，以及网页抓取。为了强制执行某些先决条件，我们已经看到了一个例子，其中客户端在能够调用端点之前需要被认证。
- en: 'Before going to see some of the middleware provided by the community, I want
    to remind you that we already created middleware in [*Chapter 7*](B19664_07.xhtml#_idTextAnchor423).
    We simply never referred to them as middleware. In fact, we created two and they
    are the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看社区提供的中间件之前，我想提醒你，我们已经在[*第7章*](B19664_07.xhtml#_idTextAnchor423)中创建了中间件。我们只是从未把它们称为中间件。实际上，我们创建了两个，如下所示：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you remember, these middleware will first check that there is an `auth_token`
    header that exists and that its value is `authd`. And then, if it is the case,
    it will log the API call on the terminal and continue with the execution of the
    code we wrote for the API endpoint.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，这些中间件首先会检查是否存在一个值为`authd`的`auth_token`头，并且该头存在。然后，如果情况如此，它将在终端上记录API调用并继续执行我们为API端点编写的代码。
- en: So, to summarize, a middleware is an interceptor that can cut the execution
    short depending on some conditions and is there to secure the API endpoints.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，中间件是一个可以根据某些条件中断执行的拦截器，它的作用是保护API端点。
- en: Authenticating requests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证请求
- en: In this section and the following, we are going to simplify the middleware that
    we currently have. First, we are going to start by simplifying the authentication
    process. We saw in the previous chapter that we can easily create an interceptor
    for checking an authentication token in headers. In this section, we are going
    to take a step further and make it even simpler.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节和接下来的内容中，我们将简化我们目前拥有的中间件。首先，我们将从简化认证过程开始。我们在上一章中看到，我们可以轻松地创建一个检查头中认证令牌的拦截器。在本节中，我们将更进一步，使其更加简单。
- en: Important note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'gRPC supports retrying authentication of requests through an RBAC policy without
    a third-party library. However, the configuration is quite verbose and not very
    well documented. If you are interested in trying it, you can check the following
    example: [https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md](https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC支持通过RBAC策略重试请求的认证，而不需要第三方库。然而，配置相当冗长，并且没有很好的文档记录。如果你有兴趣尝试，可以查看以下示例：[https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md](https://github.com/grpc/grpc-go/blob/master/examples/features/authz/README.md)。
- en: 'Previously, when we wrote our interceptors, we needed to create the following
    function for a unary interceptor:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前编写拦截器时，我们需要为单一拦截器创建以下函数：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And another one like the following for the stream interceptor:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下类似的流拦截器：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While this gives us a lot of information on the calls, the context, and so on,
    this also makes our code terse, and we need to think about how to share the common
    business logic between the stream and unary interceptors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这为我们提供了关于调用、上下文等信息，但也使得我们的代码变得简短，我们需要考虑如何在流拦截器和单一拦截器之间共享常见的业务逻辑。
- en: With the middleware that we are going to add, we will simply focus on our logic,
    and we will be able to register the interceptor as easily as before in our gRPC
    server. This middleware is the auth middleware in the GitHub repository called
    `go-grpc-middleware` ([https://github.com/grpc-ecosystem/go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)).
    It will let us get rid of the complicated authenticator function definitions that
    we add for the interceptors and will let us register directly using our `validateAuthToken`
    function in a predefined interceptor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们将要添加的中间件，我们将专注于我们的逻辑，并且我们将在我们的 gRPC 服务器中像以前一样轻松地注册拦截器。这个中间件是 GitHub 仓库中名为
    `go-grpc-middleware` 的认证中间件（[https://github.com/grpc-ecosystem/go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)）。它将使我们摆脱为拦截器添加的复杂认证函数定义，并允许我们直接使用预定义的拦截器中的
    `validateAuthToken` 函数进行注册。
- en: 'To get started, we are going to fetch the dependency in our `server` folder:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将从我们的 `server` 文件夹中获取依赖项：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Then, we are going to remove the `unaryAuthInterceptor` and `streamAuthInterceptor`
    in the `server/interceptors.go` file. We do not need them anymore since the new
    auth middleware will take care of everything for us.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从 `server/interceptors.go` 文件中移除 `unaryAuthInterceptor` 和 `streamAuthInterceptor`。由于新的认证中间件将为我们处理一切，所以我们不再需要它们。
- en: And finally, we are going to go to the `server/main.go`, where we are going
    to replace the old interceptor with `auth.UnaryServerInterceptor` and `auth.StreamServerInterceptor`.
    These two interceptors take an `AuthFunc`, which basically represents the authentication
    logic. In our case, we will pass to them our `validateAuthToken`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将前往 `server/main.go`，在那里我们将用 `auth.UnaryServerInterceptor` 和 `auth.StreamServerInterceptor`
    替换旧的拦截器。这两个拦截器接受一个 `AuthFunc`，它基本上代表了认证逻辑。在我们的情况下，我们将传递我们的 `validateAuthToken`。
- en: 'The `AuthFunc` type looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthFunc` 类型看起来是这样的：'
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, we need to change the `validateAuthToken` a little bit to return a context
    and/or an error. Our new function will look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要稍微修改 `validateAuthToken` 以返回一个上下文和/或一个错误。我们新的函数将如下所示：
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This lets us register the `validateAuthToken` in the gRPC server. Our new main
    function will now be like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在 gRPC 服务器中注册 `validateAuthToken`。我们新的主函数现在将如下所示：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we should be able to run the server:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够运行服务器：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also run the client:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还运行了客户端：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We don’t get any errors and it works similarly to before. However, to test
    that the middleware is working properly, we can temporarily modify our interceptor
    on the client side to add a wrong authentication header (`client/interceptors.go`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有收到任何错误，并且它的工作方式与之前相似。然而，为了测试中间件是否正常工作，我们可以临时修改客户端的拦截器以添加错误的认证头（`client/interceptors.go`）：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And if we rerun the client, we should get the following error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行客户端，我们应该得到以下错误：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This proves that our middleware is working as expected and that we can rely
    on only `validAuthToken` to do the authentication checking.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了我们的中间件按预期工作，并且我们可以仅依靠 `validAuthToken` 来进行认证检查。
- en: Bazel
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'In order to run that with Bazel, we will need to update our dependencies and
    link the new dependency to the `server_lib` target in `server/BUILD.bazel`. So,
    we first run the `gazelle-update-repos` command, which will fetch the `go-grpc-middeware`
    dependency:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Bazel 运行它，我们需要更新我们的依赖项并将新的依赖项链接到 `server/BUILD.bazel` 中的 `server_lib` 目标。因此，我们首先运行
    `gazelle-update-repos` 命令，这将获取 `go-grpc-middleware` 依赖项：
- en: '[PRE33]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And once we have that, we can now let the `gazelle` command include the `go-grpc-middleware`
    dependency to the target:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们现在可以让 `gazelle` 命令将 `go-grpc-middleware` 依赖项包含到目标中：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we will be able to run our server:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将能够运行我们的服务器：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the client with the wrong `auth` token should give the following message:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 并且带有错误 `auth` 令牌的客户端应该给出以下信息：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To conclude, in this section, we saw that we can simplify the authenticator
    interceptors by using the `go-grpc-middleware` package. It lets us focus on the
    actual logic and not on how to write an interceptor that can be registered with
    gRPC.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们看到了我们可以通过使用 `go-grpc-middleware` 包来简化认证拦截器。它让我们专注于实际的逻辑，而不是如何编写可以注册到
    gRPC 的拦截器。
- en: Logging API calls
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录 API 调用
- en: 'In this section, let us simplify the log interceptor. This will be like what
    we did in the previous section, but we are going to use another middleware: the
    logging middleware.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们简化日志拦截器。这就像我们在上一节中所做的那样，但我们将使用另一个中间件：日志中间件。
- en: While this middleware integrates with a lot of different loggers, we are going
    to use it with the default `log` package in Golang. It will then appear easy to
    integrate with your favorite logger.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个中间件与许多不同的日志记录器集成，但我们将使用它与 Golang 的默认 `log` 包。这样，集成您喜欢的日志记录器将变得容易。
- en: Important note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The next command is only needed if you did not get the previous dependency on
    `go-grpc-middleware`. If you followed section by section, you should not need
    it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令仅在您没有获取 `go-grpc-middleware` 的上一个依赖项时才需要。如果您是按章节顺序阅读的，那么您应该不需要它。
- en: 'To get started, let us get the dependency on the middleware. In the `server`
    folder, we are going to run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们获取中间件的依赖项。在 `server` 文件夹中，我们将运行以下命令：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can start creating our logger. We are going to create it by defining
    a function that returns a `loggerFunc`. This is a function that has the following
    signature:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建我们的日志记录器。我们将通过定义一个返回 `loggerFunc` 的函数来创建它。这是一个具有以下签名的函数：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We already know what the context is, but all the rest is specific to the logger.
    The level is a logging level such as `Debug`, `Info`, `Warning`, or `Error`. This
    is generally used in order to filter the logs depending on the level of severity.
    Then, the message is simply a message generated by the logger middleware such
    as `":started call"` or `":finished call"`. This helps us understand the context
    of the log. And finally, the fields are all the other information that we need
    to print a useful log. In our case, we are going to use the service name and the
    method name. This will let us create logs like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道上下文是什么，但所有其余的都是针对日志记录器的。级别是一个日志级别，如 `Debug`、`Info`、`Warning` 或 `Error`。这通常用于根据严重程度过滤日志。然后，消息只是一个由日志中间件生成的消息，如
    `":started call"` 或 `":finished call"`。这有助于我们理解日志的上下文。最后，字段是我们需要打印有用日志的所有其他信息。在我们的情况下，我们将使用服务名称和方法名称。这将使我们能够创建如下日志：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A thing that is not easy to wrap your mind around is the `fields` parameter.
    This is because this is presented as a `vararg` of `any`. In reality, we can transform
    that into a map in order to get a specific field name such as `grpc.service`,
    `grpc.method`, … To do that, we can simply write the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一件难以理解的事情是 `fields` 参数。这是因为它被表示为 `any` 的 `vararg`。实际上，我们可以将其转换为映射，以获取特定的字段名称，如
    `grpc.service`、`grpc.method` 等。为此，我们可以简单地编写以下代码：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice that we are creating a map of `length len(fields)/2`. This is because
    in the `fields` parameter, the name of the fields and their value are interleaved.
    An example is the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在创建一个长度为 `len(fields)/2` 的映射。这是因为 `fields` 参数中字段名称和它们的值是交错排列的。以下是一个例子：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can print the fields and see the whole thing yourself by expanding the
    `vararg`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过展开 `vararg` 来打印字段并亲自查看整个内容：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have this knowledge, we can proceed to write the logger. We will
    create a function called `logCalls`, which takes a `log.Logger` (from the `golang`
    standard library) as a param and will return a `logging.Logger` (from the logging
    middleware). The logic of the logger will be to check the log level, prepend the
    level of the message to it, and then we will append the service name and method
    name to the whole message:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个知识，我们可以继续编写日志记录器。我们将创建一个名为 `logCalls` 的函数，它接受一个 `log.Logger`（来自 `golang`
    标准库）作为参数，并返回一个 `logging.Logger`（来自日志中间件）。日志记录器的逻辑将是检查日志级别，将消息的级别添加到前面，然后我们将服务名称和方法名称添加到整个消息中：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, while this method will always be accurate because we can retrieve the keys
    in the map that was built, this means that we need to build a map each time this
    interceptor is called. This is not really efficient. I wanted to show you the
    full-blown example before showing you the efficient one so that you understand
    how to use the `fields` parameter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然这个方法总是准确的，因为我们可以在构建的映射中检索键，但这意味着每次调用这个拦截器时，我们都需要构建一个映射。这并不真的高效。我想在你看到高效的例子之前先展示完整的例子，这样你就能理解如何使用
    `fields` 参数。
- en: 'To be more efficient, we can take advantage of the fact that our service and
    method are always situated at index 5 and 7, respectively. So, we are going to
    remove the map creation part, we are going to replace `grpcService` and `grpcMethod`
    with `5` and `7`, and we are going to access the 5th and 7th element of fields:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，我们可以利用我们的服务和方法是始终位于索引 5 和 7 的这一事实。因此，我们将移除映射创建部分，我们将用 `5` 和 `7` 替换 `grpcService`
    和 `grpcMethod`，并将访问 `fields` 的第 5 和第 7 个元素：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is much more efficient. Now, one thing that is worth mentioning is that
    this is less safe. We are assuming that all the fields that we receive will always
    contain the `service` and `method` at the same index and that our `fields` array
    is large enough. We can safely assume that now, at the time of writing, because
    these are common fields that are added in this order all the time. However, if
    the library changes, you might try to do an out-of-bounds access or get a different
    piece of information. Be aware of that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这要高效得多。现在，有一点需要提及的是，这不太安全。我们假设我们接收到的所有字段都将始终包含在相同索引处的`service`和`method`，并且我们的`fields`数组足够大。我们可以安全地假设，在撰写本文时，因为这些是始终按此顺序添加的常见字段。然而，如果库发生变化，你可能会尝试进行越界访问或获取不同的信息。请注意这一点。
- en: 'The last thing that we need to do is register the interceptor. This is similar
    to what we did with the authentication interceptor, but the main difference is
    that now we need to create a logger and pass it to the `logCalls` function. We
    are going to use a golang `log.Logger`, which prints the date and time before
    the message. And finally, we are going to pass the result of `logCalls` to `logging.UnaryServerInterceptor`
    and `logging.StreamServerInterceptor`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件我们需要做的事情是注册拦截器。这与我们之前所做的身份验证拦截器类似，但主要区别在于现在我们需要创建一个记录器并将其传递给`logCalls`函数。我们将使用golang的`log.Logger`，它在消息之前打印日期和时间。最后，我们将`logCalls`的结果传递给`logging.UnaryServerInterceptor`和`logging.StreamServerInterceptor`：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After that, we can now run our server:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们现在可以运行我们的服务器：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before running the client make sure that you replaced the value of `authTokenValue`
    to `authd` in the `client/interceptors.go` file
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行客户端之前，请确保将`client/interceptors.go`文件中`authTokenValue`的值替换为`authd`。
- en: 'And then run our client:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行我们的客户端：
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And if we check the terminal in which the server is running, we should have
    a bunch of messages like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查服务器正在运行的终端，我们应该会看到一些类似以下的消息：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To conclude, we saw that, similarly to the authentication middleware, we can
    simply add a logger to our gRPC server. We also saw that we can access more information
    than just the service name and method name by transforming the `fields varargs`
    into a map. And finally, we saw that some of the fields are always at the same
    place in `vararg`, so instead of generating the map for each call, we can directly
    access the information by index.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们看到了，与身份验证中间件类似，我们只需在我们的gRPC服务器中添加一个记录器即可。我们还看到，通过将`fields varargs`转换为映射，我们可以访问比服务名和方法名更多的信息。最后，我们看到了一些字段在`vararg`中始终位于相同的位置，因此，我们不必为每个调用生成映射，可以直接通过索引访问信息。
- en: Tracing API calls
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪API调用
- en: On top of logging, which simply describes the events in a developer-friendly
    manner, you might need to get metrics that can get aggregated by dashboard tools.
    These metrics might include requests per second, distribution of status (`Ok`,
    `Internal`, and so on), and many others. In this section, we are going to instrument
    our code with OpenTelemetry and Prometheus so that tools such as Grafana can be
    used to create dashboards.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录的基础上，它以开发者友好的方式简单地描述事件之外，你可能还需要获取可以被仪表板工具聚合的指标。这些指标可能包括每秒请求数、状态分布（`Ok`、`Internal`等），以及其他许多指标。在本节中，我们将使用OpenTelemetry和Prometheus对我们的代码进行仪表化，以便可以使用Grafana等工具创建仪表板。
- en: The first thing to understand is that we are going to run an HTTP server for
    Prometheus metrics. Prometheus exposes the metrics to external tools on the `/metrics`
    route so that the tools wanting to query the data get a sense of all the kinds
    of metrics available.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要理解的是，我们将运行一个用于Prometheus指标的HTTP服务器。Prometheus通过`/metrics`路由将指标暴露给外部工具，以便想要查询数据的工具可以了解所有可用的指标类型。
- en: 'So, to create such a server, we are going to get a dependency on Prometheus’
    Go library. We are going to do that by getting the dependency on the `go-grpc-middleware/providers/prometheus`.
    The `Prometheus Go` library is a transitive dependency of this one and we still
    need to be able to register some more interceptors that are defined in the `Prometheus`
    provider:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了创建这样的服务器，我们将获取Prometheus的Go库的依赖项。我们将通过获取对`go-grpc-middleware/providers/prometheus`的依赖来实现这一点。`Prometheus
    Go`库是这个库的传递依赖，我们仍然需要能够注册在`Prometheus`提供程序中定义的一些更多拦截器：
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we can create an HTTP server that will later be used to expose the `/metrics`
    route. We are going to create a function called `newMetricsServer`, which takes
    the address of where the server is running:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个HTTP服务器，稍后它将被用来公开`/metrics`路由。我们将创建一个名为`newMetricsServer`的函数，它接受服务器运行地址：
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code that follows explains every part of the `server/main.go` file. Displaying
    the full file here would be overwhelming. Thus, we will walk through all of its
    code and you will be able to see the imports and the overall structure in the
    `main.go`. Note that, in order to better explain, We are only adding certain elements
    later in the section. If you see a part of the code that is not presented yet,
    read on and you will get an explanation for the piece of code you are looking
    at.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码解释了`server/main.go`文件中的每个部分。在这里显示整个文件可能会让人感到不知所措。因此，我们将遍历所有代码，你将能够在`main.go`中看到导入和整体结构。请注意，为了更好地解释，我们将在本节后面添加某些元素。如果你看到尚未展示的代码部分，请继续阅读，你将得到你所查看代码的解释。
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now that we have our HTTP server, we will refactor our main and separate the
    creation of the gRPC server into another function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了HTTP服务器，我们将重构`main`函数，并将gRPC服务器的创建分离到另一个函数中：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Nothing really changed; we only separated the creation into a function so that
    we can run two servers in parallel later. Before working on that though, our `main`
    should also include two addresses as parameters. The first one is for the gRPC
    server and the other is for the HTTP server:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上没有发生任何变化；我们只是将创建过程分离成一个函数，以便我们可以在以后并行运行两个服务器。不过，在着手做那之前，我们的`main`函数也应该包含两个地址作为参数。第一个是为gRPC服务器准备的，另一个是为HTTP服务器准备的：
- en: '[PRE52]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we can deal with running two servers at once. We are going to use the `errgroup`
    ([https://pkg.go.dev/golang.org/x/sync/errgroup](https://pkg.go.dev/golang.org/x/sync/errgroup))
    package. It lets us add multiple goroutines to a group and wait on them.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理同时运行两个服务器。我们将使用`errgroup`（[https://pkg.go.dev/golang.org/x/sync/errgroup](https://pkg.go.dev/golang.org/x/sync/errgroup)）包。它允许我们将多个goroutines添加到组中并等待它们。
- en: 'The first thing that we need is to create a context for the group. We are going
    to create a cancellable one so that later we can release the servers’ resources:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要为组创建一个上下文。我们将创建一个可取消的上下文，以便稍后我们可以释放服务器的资源：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we can start handling the `SIGTERM` signal. This is because when we want
    to exit both servers, we will press *Ctrl* + *C*. This will send the `SIGTERM`
    signal, and we expect the servers to be closed gracefully. To handle that, we
    are going to make a channel that will be released when the `SIGTERM` signal is
    received:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始处理`SIGTERM`信号。这是因为当我们想要退出两个服务器时，我们将按*Ctrl* + *C*。这将发送`SIGTERM`信号，我们期望服务器能够优雅地关闭。为了处理这一点，我们将创建一个通道，当接收到`SIGTERM`信号时，该通道将被释放：
- en: '[PRE54]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After that, we can now create our group of two servers. We will first create
    the group from the cancellable context that we created. And then, we will use
    the `Go(func() error)` function to add goroutines to that group. The first goroutine
    will handle the serving of the gRPC server and the second goroutine will handle
    the HTTP one:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们现在可以创建我们的两个服务器的组。我们首先将从我们创建的可取消上下文中创建组。然后，我们将使用`Go(func() error)`函数将goroutines添加到该组中。第一个goroutine将处理gRPC服务器的服务，第二个goroutine将处理HTTP服务器：
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that we have our group, we can wait on the context to be done or on the
    `quit` channel to receive an event:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了组，我们可以等待上下文完成或等待`quit`通道接收事件：
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Once one of these events is received, we are going to initiate the release
    of resources by making sure that the context is finished (call the `cancel` function),
    and finally, we can wait on the group to finish all the goroutines that we registered:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到这些事件之一，我们将通过确保上下文完成（调用`cancel`函数）来启动资源的释放，最后，我们可以等待组完成我们注册的所有goroutines：
- en: '[PRE57]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, as this is the ultimate goal of this section, we need to add tracing
    capabilities. The metrics server will expose the metrics route and the gRPC server
    will collect the metrics and add them to the Prometheus registry. This registry
    is a collection of collectors. We register one or more collectors to it, then
    the registry will collect the different metrics available, and finally, it will
    expose these metrics.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为本节最终目标，我们需要添加跟踪功能。度量服务器将公开度量路由，而gRPC服务器将收集度量并将它们添加到Prometheus注册表中。这个注册表是一个收集器的集合。我们将一个或多个收集器注册到其中，然后注册表将收集不同的度量，最后，它将公开这些度量。
- en: 'Before creating the registry, we will first create a collector with the `NewServerMetrics`
    function provided in the `go-grpc-middleware/providers/prometheus` package. Then,
    we are going to actually create the registry. And finally, we are going to register
    the collector:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建注册表之前，我们首先使用`go-grpc-middleware/providers/prometheus`包中提供的`NewServerMetrics`函数创建一个收集器。然后，我们将实际创建注册表。最后，我们将注册收集器：
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Notice that we passed an option to the `NewServerMetrics`. This option will
    let us get buckets into which the calls will be placed depending on their latency.
    This basically tells us how many requests were served in under 0.001 seconds,
    0.01 seconds, and so on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们向`NewServerMetrics`传递了一个选项。这个选项将使我们能够根据调用延迟将调用放入不同的桶中。这基本上告诉我们有多少请求在0.001秒内被服务，0.01秒，等等。
- en: 'Finally, we are going to pass the registry to the HTTP server so that it knows
    what metrics are available, and we are going to pass the collector to our gRPC
    server so that it can push metrics to it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将把注册表传递给HTTP服务器，以便它知道有哪些度量标准可用，并且我们将把收集器传递给我们的gRPC服务器，以便它可以将其推送到它：
- en: '[PRE59]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice that we are now using `opentelemetry` (`otelgrpc`). This is a tool that
    lets us generate all the metrics from our gRPC server automatically. Then, Prometheus
    will pick those with the collector (`srvMetrics`). And finally, the HTTP server
    will be able to expose these metrics.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在正在使用`opentelemetry`（`otelgrpc`）。这是一个工具，它允许我们自动从我们的gRPC服务器生成所有指标。然后，Prometheus将选择那些由收集器（`srvMetrics`）选择的指标。最后，HTTP服务器将能够公开这些指标。
- en: 'To get OpenTelemetry for gRPC, we simply need to get the dependency:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要为gRPC获取OpenTelemetry，我们只需要获取依赖项：
- en: '[PRE60]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We should now be able to run our server:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够运行我们的服务器：
- en: '[PRE61]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we can run our client against the `0.0.0.0:50051` address:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以针对`0.0.0.0:50051`地址运行我们的客户端：
- en: '[PRE62]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And after the client calls are all served, we can look at the metrics like
    so:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端调用全部服务后，我们可以查看如下指标：
- en: '[PRE63]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You should now have logs that look like this (simplified to only show `AddTask`):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该有如下所示的日志（简化以仅显示`AddTask`）：
- en: '[PRE64]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'These metrics mean that the server received three `AddTask`, handled them all
    in under 0.001 seconds (total: 0.000119291), and returned three responses to the
    client.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指标意味着服务器接收了三个`AddTask`请求，在0.001秒内处理了它们（总计：0.000119291），并向客户端返回了三个响应。
- en: There is obviously a lot more to do with these metrics. However, that would
    probably be a book in itself. If you are interested in this area, I would encourage
    you to look at how to integrate Prometheus with a tool such as Grafana to create
    dashboards representing these metrics in a more human-readable manner.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有更多的事情要做来处理这些指标。然而，这可能需要一本书来详细说明。如果你对这个领域感兴趣，我鼓励你查看如何将Prometheus与Grafana等工具集成，以创建以更易于阅读的方式表示这些指标的仪表板。
- en: Bazel
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'We need to update the dependencies in order to get Prometheus and OpenTelemetry
    to work. To do that, we are going to run `gazelle-update-repos`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新依赖项，以便Prometheus和OpenTelemetry能够正常工作。为此，我们将运行`gazelle-update-repos`：
- en: '[PRE65]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And then, we are going to run `gazelle` in order to automatically link the
    dependencies to our code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将运行`gazelle`以自动将依赖项链接到我们的代码：
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we can now run our server:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在可以运行我们的服务器：
- en: '[PRE67]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And then run our client:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行我们的客户端：
- en: '[PRE68]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In conclusion, we saw how we can get metrics out of our gRPC server by using
    OpenTelemetry and Prometheus. We did that by creating a second server exporting
    metrics on the `/metrics` route, and through the use of a Prometheus registry
    and collector, we exchanged metrics from the gRPC server to the HTTP server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们看到了如何通过使用OpenTelemetry和Prometheus从我们的gRPC服务器中获取指标。我们通过创建一个在`/metrics`路由上导出指标的第二个服务器，并通过使用Prometheus注册表和收集器，将gRPC服务器的指标交换到HTTP服务器中来实现这一点。
- en: Securing APIs with rate limiting
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用速率限制来保护API
- en: For the last interceptor we are going to add to the server, we are going to
    use a rate limiter. More precisely, we are going to use the implementation of
    a token bucket rate limiter, which is provided by the `golang.org/x/time/rate`
    package. In this section, we are not going to delve deeply into what rate limiters
    are or how to build one – that is out of the scope of this book, however, you
    will see how you can use a rate limiter (a readily implemented or custom one)
    in the context of gRPC.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们将要添加到服务器的最后一个拦截器，我们将使用一个速率限制器。更确切地说，我们将使用由`golang.org/x/time/rate`包提供的令牌桶速率限制器的实现。在本节中，我们不会深入探讨速率限制器是什么或如何构建一个——这超出了本书的范围，然而，你将看到如何在gRPC的上下文中使用一个速率限制器（一个现成的或自定义的）。
- en: 'The first thing that we need to do is get the dependency on the rate limiter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取速率限制器的依赖项：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Important note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The next command is only needed if you did not get the previous dependency on
    `go-grpc-middleware`. If you followed section by section, you should not need
    it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令仅在您没有获取到 `go-grpc-middleware` 的上一个依赖项时才需要。如果您是按章节顺序进行的，那么您应该不需要它。
- en: 'The we get the dependency for the interceptor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取拦截器的依赖项：
- en: '[PRE70]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we are going to create a file called `limit.go`, which will contain our
    logic and the wrapper around `rate.Limiter`. We create such a wrapper because
    the interceptor that we are going to use later requires the limiter to implement
    a function called `Limit`, taking a context as a parameter and `rate.Limiter`
    does not have such a function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为 `limit.go` 的文件，其中将包含我们的逻辑和 `rate.Limiter` 的包装器。我们创建这样的包装器是因为我们稍后将要使用的拦截器需要限流器实现一个名为
    `Limit` 的函数，该函数接受一个上下文作为参数，而 `rate.Limiter` 没有这样的函数：
- en: '[PRE71]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice that we simply check that the rate limiter allows (or not) the call to
    pass. If it does not, we return an error, otherwise, we return `nil`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们只是检查速率限制器是否允许（或不允许）调用通过。如果不允许，我们返回一个错误，否则返回 `nil`。
- en: 'The last thing to do is to register `simpleLimiter` in an interceptor. We are
    going to create an instance of type `rate.Limiter` with 2 tokens per second (referred
    to as `r`) and a burst size of 4 (referred to as `b`). If you are unclear on what
    those parameters are, we recommend you read the documentation for Limiter ([https://pkg.go.dev/golang.org/x/time/rate#Limiter](https://pkg.go.dev/golang.org/x/time/rate#Limiter)):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是在拦截器中注册 `simpleLimiter`。我们将创建一个类型为 `rate.Limiter` 的实例，每秒2个令牌（称为 `r`），突发大小为4（称为
    `b`）。如果您对这些参数不清楚，我们建议您阅读关于限流器的文档（[https://pkg.go.dev/golang.org/x/time/rate#Limiter](https://pkg.go.dev/golang.org/x/time/rate#Limiter)）：
- en: '[PRE72]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'That is all. We now have rate limiting enabled for our API. We can now run
    our server:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。现在我们已经为我们的 API 启用了速率限制。我们现在可以运行我们的服务器：
- en: '[PRE73]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And then we can try to execute more than two calls per second. This should
    not be hard. In fact, you normally can run your client once and it should fail.
    But in order to be sure that it fails, run the client multiple times. On Linux
    and Mac, you can run the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试每秒执行超过两个调用。这不应该很难。事实上，您通常可以运行一次客户端，它应该会失败。但为了确保它失败，请多次运行客户端。在 Linux
    和 Mac 上，您可以运行以下命令：
- en: '[PRE74]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And on Windows (PowerShell), you can run this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows（PowerShell）上，您可以运行以下命令：
- en: '[PRE75]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You should see some queries returning responses and then, quickly, you should
    be able to see the following message:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一些查询返回响应，然后，您应该能够很快看到以下消息：
- en: '[PRE76]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Obviously, our rate is very low, and it is not practical in production. We chose
    such a low rate in order to show you how to rate limit. In production, you will
    have business-specific requirements that need to be followed. You will have to
    adapt the code we have shown to match these requirements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的速率非常低，这在生产中并不实用。我们选择这么低的速率是为了向您展示如何进行速率限制。在生产中，您将会有特定的业务需求需要遵循。您将不得不调整我们展示的代码以匹配这些需求。
- en: Bazel
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'In order to run this example with Bazel, we will need to update the repos and
    run Gazelle to import the new dependency (`golang.org/x/time/rate`) to our library:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Bazel 运行此示例，我们需要更新仓库并运行 Gazelle 以将新的依赖项 (`golang.org/x/time/rate`) 导入到我们的库中：
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After that, you should be able to run the server like so:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该能够像这样运行服务器：
- en: '[PRE78]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To conclude, we saw that we can integrate a rate limiter in our gRPC server.
    The `go-grpc-middleware` interceptor for rate limiting makes it easy to add a
    readily available implementation or a custom one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们看到了我们可以在我们的 gRPC 服务器中集成速率限制器。`go-grpc-middleware` 的速率限制拦截器使得添加现成的实现或自定义实现变得容易。
- en: Retrying calls
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试调用
- en: As of now, we have worked only on the server side. Let us now see an important
    feature on the client side. This feature is the retrying of calls that failed
    depending on the status code. This might be interesting for use cases where the
    network is unreliable. If we get an `Unavailable` error code, we will retry with
    an exponentially bigger wait time. This is because we do not want to retry too
    often and overload the network.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只专注于服务器端。现在让我们看看客户端的一个重要特性。这个特性是根据状态码重试失败的调用。这可能对网络不可靠的使用场景很有趣。如果我们得到一个
    `Unavailable` 错误代码，我们将以指数级增加的等待时间进行重试。这是因为我们不希望过于频繁地重试并超载网络。
- en: Important note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'gRPC supports retries without the need for a third-party library. However,
    the configuration is quite verbose and not very well documented. If you are interested
    in trying it, you can check the following example: [https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md](https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC支持无需第三方库的重试。然而，配置相当冗长，并且文档不是很好。如果您有兴趣尝试，可以查看以下示例：[https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md](https://github.com/grpc/grpc-go/blob/master/examples/features/retry/README.md)。
- en: 'Let us get the dependency that we need (`client` folder):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取我们需要的依赖项（`client`文件夹）：
- en: '[PRE79]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Then, we can define some options for the retry. We will define how many times
    and on which error code we want to retry. We want to retry 3 times, with exponential
    backoff (starting at 100 ms), with the error code being `Unavailable`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为重试定义一些选项。我们将定义重试的次数和错误代码。我们希望重试3次，使用指数退避（从100毫秒开始），错误代码为`Unavailable`：
- en: '[PRE80]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And then, we simply pass these options to the interceptors provided by the
    `retry` package:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需将这些选项传递给`retry`包提供的拦截器：
- en: '[PRE81]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Important note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Retrying is not available for client streaming. If you attempt to retry on
    such an RPC endpoint, you will get the following error: `rpc error: code = Unimplemented
    desc = grpc_retry: cannot retry on ClientStreams, set grpc_retry.Disable()`. As
    such, it is a bit risky to add the `retry.StreamClientInterceptor` as presented.
    We just wanted to show you that some streaming could also be retried.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '对于客户端流，无法进行重试。如果您尝试在这样一个RPC端点上进行重试，您将收到以下错误：`rpc error: code = Unimplemented
    desc = grpc_retry: cannot retry on ClientStreams, set grpc_retry.Disable()`。因此，添加`retry.StreamClientInterceptor`有一定的风险。我们只是想向您展示一些流也可以进行重试。'
- en: 'Once we have that, we now have a problem. Our API is running locally and there
    is little chance that we will get an `Unavailable` error. So, for the sake of
    testing and demonstration, we are going to make our `AddTask` directly return
    such an error temporarily. In `server/impl.go`, we can comment on the rest of
    the function and add the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们现在就遇到了一个问题。我们的API在本地运行，我们几乎不可能得到一个`Unavailable`错误。所以，为了测试和演示，我们将暂时让我们的`AddTask`直接返回这样的错误。在`server/impl.go`中，我们可以注释掉函数的其余部分，并添加以下内容：
- en: '[PRE82]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And now, we run our server:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们运行我们的服务器：
- en: '[PRE83]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And then run our client:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行我们的客户端：
- en: '[PRE84]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We get one error. While this looks like it only did one query, if you look
    back at your server, you should be able to see the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个错误。虽然这看起来只执行了一个查询，但如果您回顾您的服务器，您应该能够看到以下内容：
- en: '[PRE85]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: That is effectively three requests that were made.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是三个请求。
- en: Bazel
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bazel
- en: 'As always, you will need to run `gazelle-update-repos` and `gazelle` in order
    to get the new dependencies and link them to your library:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，您需要运行`gazelle-update-repos`和`gazelle`以获取新的依赖项并将它们链接到您的库：
- en: '[PRE86]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And now you should be able to run your client correctly:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够正确运行您的客户端：
- en: '[PRE87]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: To conclude, we saw in this section that we can retry depending on some conditions,
    with exponential backoff, and for a certain amount of time. Retry is an important
    feature since the network is often unreliable and we do not want to make the user
    retry manually each time there is a problem.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本节中，我们看到了可以根据某些条件进行重试，使用指数退避，并且持续一定时间。重试是一个重要的功能，因为网络通常不可靠，我们不希望用户每次出现问题都要手动重试。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the key features that we can get by using community
    projects such as `protoc-gen-validate` or `go-grpc-middleware`. We saw that we
    can encode request validation logic in our proto files. This makes our code less
    bloated and provides error message consistency across all the endpoints of our
    API.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了通过使用社区项目，如`protoc-gen-validate`或`go-grpc-middleware`，我们可以获得的关键功能。我们看到了我们可以在我们的proto文件中编码请求验证逻辑。这使得我们的代码更精简，并且在整个API端点之间提供错误消息的一致性。
- en: Then, we looked at what middleware are and how to create one. We started with
    refactoring our authentication and logging interceptors. We saw that by using
    `go-grpc-middleware`, we can focus only on the actual logic of the interceptor
    and have less boilerplate to deal with.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了中间件是什么以及如何创建一个。我们从重构我们的身份验证和日志拦截器开始。我们看到了通过使用`go-grpc-middleware`，我们可以专注于拦截器的实际逻辑，并且有更少的样板代码要处理。
- en: After that, we saw that we can expose tracing data from our API. We used OpenTelemetry
    and Prometheus to gather the data from the gRPC API and expose it through an HTTP
    server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到我们可以从我们的API中公开跟踪数据。我们使用了OpenTelemetry和Prometheus从gRPC API收集数据，并通过HTTP服务器公开它。
- en: We then learned how to apply rate limiting on our APIs. This is helpful to prevent
    fraudulent actors or defective clients from overloading our server. We used the
    Token Bucket algorithm and an already existing implementation of a rate limiter
    to apply limiting to our API.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们学习了如何在我们的API上应用速率限制。这有助于防止欺诈行为者或缺陷客户端过载我们的服务器。我们使用了令牌桶算法和一个现成的速率限制器实现来对我们的API应用限制。
- en: And finally, we also saw that we can use interceptors on the client side by
    working with retry middleware. This lets us retry a call depending on an error
    code, with a maximum number of retries, and optionally with exponential backoff.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还看到我们可以通过与重试中间件一起工作在客户端使用拦截器。这让我们可以根据错误代码重试调用，最多重试次数，并且可选地使用指数退避。
- en: In the next chapter, we will go over the development lifecycle for gRPC APIs,
    how we can ensure their correctness, how we can debug them, and how we can deploy
    them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论gRPC API的开发生命周期，如何确保它们的正确性，如何调试它们，以及如何部署它们。
- en: Quiz
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: What is the purpose of the protoc-gen-validate plugin?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: protoc-gen-validate插件的目的是什么？
- en: Providing checking logic in a `.``proto` file
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.proto`文件中提供检查逻辑
- en: Generating validation code
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成验证代码
- en: Both of them
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者都是
- en: What is `go-grpc-middleware` used for?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go-grpc-middleware`用于什么？'
- en: Providing commonly used interceptors
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供常用的拦截器
- en: Generating validation code
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成验证代码
- en: Which middleware is used for displaying events as human-readable text?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个中间件用于将事件显示为可读文本？
- en: '`tracing`'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tracing`'
- en: '`auth`'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`auth`'
- en: '`logging`'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`logging`'
- en: Which middleware is used to constrain the number of requests made per second?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个中间件用于限制每秒请求的数量？
- en: '`tracing`'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tracing`'
- en: '`ratelimit`'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ratelimit`'
- en: '`auth`'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`auth`'
- en: Answers
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: C
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: B
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: Challenges
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: Simplify the client logger you created in the last chapter by using the logging
    middleware.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用日志中间件简化你在上一章中创建的客户端日志记录器。
- en: Check the `protoc-gen-validate` rules ([https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md](https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md))
    and simplify the error handling that you added in the last chapter’s challenges.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`protoc-gen-validate`规则([https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md](https://github.com/bufbuild/protoc-gen-validate/blob/main/README.md))，并简化你在上一章挑战中添加的错误处理。
- en: Check the other middleware available in [https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2)
    and try to implement one. An example could be the selector middleware.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查[https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2](https://github.com/grpc-ecosystem/go-grpc-middleware/tree/v2)中可用的其他中间件，并尝试实现一个。一个例子可以是选择器中间件。
- en: Create a simple Grafana dashboard based on the metrics the server is exposing.
    An example could be a dashboard that displays the percentage of requests that
    succeeded.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于服务器公开的指标创建一个简单的Grafana仪表板。一个例子可以是显示成功请求百分比的仪表板。
