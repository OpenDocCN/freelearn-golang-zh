- en: Never Stop Aiming for Better
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远不要停止追求更好
- en: Do you want code that is easier to maintain? How about easier to test? Easier
    to extend? **Dependency Injection** (**DI**) might be just the tool you need.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要更容易维护的代码吗？更容易测试吗？更容易扩展吗？**依赖注入**（**DI**）可能正是你需要的工具。
- en: In this chapter, we will define DI, perhaps in a somewhat atypical way, and
    explore the code smells that could indicate you need DI. We will also talk briefly
    about Go and how I would like you to approach the ideas presented in this book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以一种有点非典型的方式定义DI，并探讨可能表明你需要DI的代码异味。我们还将简要讨论Go以及我希望你如何对待本书中提出的想法。
- en: Are you ready to join me on a journey to better Go code?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好和我一起踏上更好的Go代码之旅了吗？
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Why does DI matter?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI为什么重要？
- en: What is DI?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是DI？
- en: When should I apply DI?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时应用DI？
- en: How can I improve as a Go programmer?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何作为Go程序员改进？
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Hopefully, you will have Go installed. It is downloadable from [https://golang.org/](https://golang.org/) or
    your preferred package manager.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经安装了Go。它可以从[https://golang.org/](https://golang.org/) 或你喜欢的软件包管理器下载。
- en: All code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch01](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch01](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch01)找到。
- en: Why does DI matter?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI为什么重要？
- en: As professionals, we should never stop learning. Learning is the one true way
    to ensure we stay in demand and continue delivering value to our customers. Doctors,
    lawyers, and scientists are all highly respected professionals and all focus on
    continuously learning. Why should programmers be different?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为专业人士，我们永远不应该停止学习。学习是确保我们保持需求并继续为客户提供价值的唯一真正途径。医生、律师和科学家都是备受尊敬的专业人士，他们都专注于不断学习。为什么程序员应该有所不同呢？
- en: In this book, we will take a journey that will start with some code that *gets
    the job done* and, by selectively applying various DI methods available in Go,
    together, we will transform it into something a hell of a lot easier to maintain,
    test, and extend.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将开始一段旅程，从一些*完成工作*的代码开始，然后通过有选择地应用Go中可用的各种DI方法，我们将把它转变成更容易维护、测试和扩展的东西。
- en: Not everything in this book is *traditional* or perhaps even *idiomatic*, but
    I would ask you to *try it before you deny it*. If you like it, fantastic. If
    not, at least you learned what you don't want to do.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中并非所有内容都是*传统*的，甚至可能不是*惯用*的，但我希望你在否定之前*尝试一下*。如果你喜欢，太棒了。如果不喜欢，至少你学到了你不想做什么。
- en: So, how do I define DI?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，我如何定义DI？
- en: DI is *coding in such a way that those resources (that is, functions or structs)
    that we depend on are abstractions*. Because these dependencies are abstract,
    changes to them do not necessitate changes to our code. The fancy word for this
    is **decoupling**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DI是*以这样的方式编码，使得我们依赖的资源（即函数或结构）是抽象的*。因为这些依赖是抽象的，对它们的更改不需要更改我们的代码。这个花哨的词是**解耦**。
- en: The use of the word abstraction here may be a little misleading. I do not mean
    an abstract class like you find in Java; Go does not have that. Go does, however,
    have interfaces and function literals (also known as **closures**).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的抽象一词可能有点误导。我不是指像Java中那样的抽象类；Go没有那个。不过，Go确实有接口和函数文字（也称为**闭包**）。
- en: 'Consider the following example of an interface and the `SavePerson()` function
    that uses it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下接口的例子和使用它的`SavePerson()`函数：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, what does `Saver` do? It saves some `bytes` somewhere.
    How does it do this? We don't know and, while working on the `SavePerson` function,
    we don't care.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Saver`是做什么的？它在某个地方保存一些`bytes`。它是如何做到的？我们不知道，在编写`SavePerson`函数时，我们也不关心。
- en: Let's look at another example that uses a function literal**:**
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个使用函数文字的例子**：**
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What does `decodePerson` do? It converts the `bytes` into a person. How? We
    don't need to know to right now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodePerson`是做什么的？它将`bytes`转换为一个人。怎么做？我们现在不需要知道。'
- en: 'This is the first advantage of DI that I would highlight to you:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我要向你强调的DI的第一个优点：
- en: '**DI reduces the knowledge required when working on a piece of code, by expressing
    dependencies in an abstract or generic manner**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI通过以抽象或通用的方式表达依赖关系，减少了在处理一段代码时所需的知识**'
- en: Now, let's say that the preceding code came from a system that stored data in
    a **Network File Share** (**NFS**). How would we write unit tests for that? Having
    access to an NFS at all times would be a pain. Any such tests would also fail
    more often than they should due to entirely unrelated issues, such as network
    connectivity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设前面的代码来自一个将数据存储在**网络文件共享**（**NFS**）中的系统。我们如何为此编写单元测试？始终访问NFS将是一种痛苦。由于完全不相关的问题，例如网络连接问题，任何此类测试也会比应该更频繁地失败。
- en: 'On the other hand, by relying on an abstraction, we could swap out the code
    that saves to the NFS with fake code. This way, we are only testing our code in
    isolation from the NFS, as shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，通过依赖于抽象，我们可以用虚假代码替换保存到NFS的代码。这样，我们只测试我们的代码与NFS隔离的情况，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't worry if the preceding code looks unfamiliar; we will examine all of the
    parts in depth later in this book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心前面的代码看起来陌生；我们将在本书的后面深入研究所有部分。
- en: 'Which brings us to the second advantage of DI:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到DI的第二个优点：
- en: '**DI enables us to test our code in isolation of our dependencies**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI使我们能够在不依赖于我们的依赖关系的情况下测试我们的代码**'
- en: Considering the earlier example, how could we test our error-handling code?
    We could shut down the NFS through some external script every time we run the
    tests, but this would likely be slow and would definitely annoy anyone else that
    depended on it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的例子，我们如何测试我们的错误处理代码？我们可以通过一些外部脚本关闭NFS，每次运行测试时，但这可能会很慢，肯定会惹恼依赖它的其他人。
- en: 'On the other hand, we could quickly make a fake `Saver` that always failed,
    as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以快速制作一个总是失败的假“Saver”，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above test is fast, predictable, and reliable. Everything we could want
    from tests!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的测试快速、可预测、可靠。这是我们测试中想要的一切！
- en: 'This gives us the third advantage of DI:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们DI的第三个优势：
- en: '**DI enables us to quickly and reliably test situations that are otherwise
    difficult or impossible**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI使我们能够快速、可靠地测试其他情况**'
- en: 'Let''s not forget about the traditional sales pitch for DI. Tomorrow, if we
    decided to save to a NoSQL database instead of our NFS, how would our `SavePerson` code
    have to change?  Not one bit. We would only need to write a new `Saver` implementation,
    giving us the fourth advantage of DI:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记DI的传统销售点。如果明天我们决定将保存到NoSQL数据库而不是我们的NFS，我们的`SavePerson`代码将如何改变？一点也不。我们只需要编写一个新的`Saver`实现，这给了我们DI的第四个优势：
- en: '**DI reduces the impact of extensions or changes**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI减少了扩展或更改的影响**'
- en: At the end of the day, DI is a tool—a handy tool, but no magic bullet. It's
    a tool that can make code easier to understand, test, extend, and reuse—a tool
    that can also help reduce the likelihood of circular dependency issues that commonly
    plague new Go developers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，DI是一个工具——一个方便的工具，但不是魔法子弹。它是一个可以使代码更容易理解、测试、扩展和重用的工具，也可以帮助减少常常困扰新Go开发人员的循环依赖问题。
- en: Code smells that indicate you might need DI
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表明您可能需要DI的代码气味
- en: The saying *to a man with only a hammer, every problem looks like a nail* is
    old and yet is never truer than in programming. As professionals, we should be
    continually striving to acquire more tools to be better equipped for whatever
    our job throws at us. DI, while a highly useful tool, is useful only for particular
    nails. In our case, these nails are **code smells**. Code smells are indications
    in the code of a potentially deeper problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说“对于只有一把锤子的人来说，每个问题都像一颗钉子”，这句话虽然古老，但在编程中却从未比现在更真实。作为专业人士，我们应该不断努力获取更多的工具，以便更好地应对工作中遇到的任何问题。DI虽然是一个非常有用的工具，但只对特定的问题有效。在我们的情况下，这些问题是**代码气味**。代码气味是代码中潜在更深层问题的指示。
- en: There are many different types of code smell; in this section, we will examine
    only those that can be alleviated by DI. In later chapters, we will reference
    these smells as we attempt to remove them from our code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的代码气味；在本节中，我们将仅讨论那些可以通过DI缓解的气味。在后面的章节中，我们将在试图从我们的代码中消除它们时引用这些气味。
- en: 'Code smells generally fall into four different categories:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码气味通常可以分为四个不同的类别：
- en: Code bloat
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码膨胀
- en: Resistance to change
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对变化的抵抗
- en: Wasted effort
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 徒劳的努力
- en: Tight coupling
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧耦合
- en: Code bloat
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码膨胀
- en: Code bloat smells are cases where unwieldy slabs of code have been added to
    structs or functions so that they have become hard to understand, maintain, and
    test. Frequently found in older code, they are often the result of a gradual degradation
    and lack of maintenance rather than intentional choices.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码膨胀的气味是指已经添加到结构体或函数中的笨重代码块，使得它们变得难以理解、维护和测试。在旧代码中经常发现，它们往往是逐渐恶化和缺乏维护的结果，而不是有意的选择。
- en: They can be found with a visual scan of the source code or by employing a cyclomatic
    complexity checker (a software metric that indicates the complexity of a piece
    of code) such as gocyclo ([https://github.com/fzipp/gocyclo](https://github.com/fzipp/gocyclo)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过对源代码进行视觉扫描或使用循环复杂度检查器（指示代码复杂性的软件度量标准）来发现，例如gocyclo（[https://github.com/fzipp/gocyclo](https://github.com/fzipp/gocyclo)）。
- en: 'These smells include the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些气味包括以下内容：
- en: '**Long methods**: While the code is run on computers, it is written for humans.
    Any method of more than about 30 lines should be split into smaller chunks. While
    it makes no difference to the computer, it makes it easier for us humans to understand.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长方法**：虽然代码是在计算机上运行的，但是它是为人类编写的。任何超过30行的方法都应该分成更小的块。虽然对计算机没有影响，但对我们人类来说更容易理解。'
- en: '**Long structs**: Similar to long methods, the longer a struct, the harder
    it is to understand and therefore maintain. Long structs typically also indicate
    the struct is doing too much. Splitting one struct into several smaller ones is
    also a great way to increase the reusability potential of the code.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长结构体**：与长方法类似，结构体越长，就越难理解，因此也更难维护。长结构体通常也表明结构体做得太多。将一个结构体分成几个较小的结构体也是增加代码可重用性潜力的好方法。'
- en: '**Long parameter lists**: Long parameter lists also indicate that the method
    is likely doing more than it should. When adding new features, it is tempting
    to add a new parameter to an existing function to account for the new use case.
    This is a slippery slope. This new parameter is either optional/unnecessary for
    the existing use cases or is an indication of a significant increase in complexity
    in the method.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长参数列表**：长参数列表也表明该方法可能做了太多的事情。在添加新功能时，很容易向现有函数添加新参数，以适应新的用例。这是一个很危险的斜坡。这个新参数要么对现有用例是可选的/不必要的，要么表明方法的复杂性显著增加。'
- en: '**Long conditional blocks**: Switch statements are amazing. The problem is
    they are very easy to abuse and tend to multiply like proverbial rabbits. Perhaps
    the most significant problem, however, is their effect on the readability of the
    code. Long conditional blocks take up a lot of space and interrupt the readability
    of the function. Consider the following code:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长条件块**：Switch语句很棒。问题在于它们很容易被滥用，而且往往像谚语中的兔子一样繁殖。然而，最重要的问题可能是它们对代码的可读性的影响。长条件块占用大量空间，打断了函数的可读性。考虑以下代码：'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By taking `interface{}` as input, anywhere we wish to use it, we are almost
    forced to have a switch like this one. We would be better off changing from `interface{}`
    to an interface and then adding the necessary operations to the interface. This
    approach is better illustrated by the `json.Marshaller` and `driver.Valuer` interfaces
    in the standard library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`interface{}`作为输入，我们几乎被迫使用类似这样的开关。我们最好改为从`interface{}`改为接口，然后向接口添加必要的操作。这种方法在标准库中的`json.Marshaller`和`driver.Valuer`接口中得到了很好的说明。
- en: Applying DI to these smells will typically reduce the complexity of individual
    pieces of code by breaking them into smaller, separate pieces, which in turn makes
    them easier to understand, maintain, and test.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将DI应用于这些问题通常会通过将其分解为更小的、独立的部分来减少代码的复杂性，从而使其更易于理解、维护和测试。
- en: Resistance to change
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对变化的抵抗
- en: These are cases where it is difficult and/or slow to add new features. Similarly,
    tests are often harder to write, especially tests for failure conditions. Similar
    to code bloat, these smells can be the result of a gradual degradation and lack
    of maintenance, but they can also be caused by a lack of up-front planning or
    poor API design.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况下很难和/或缓慢地添加新功能。同样，测试通常更难编写，特别是对于失败条件的测试。与代码膨胀类似，这些问题可能是逐渐恶化和缺乏维护的结果，但也可能是由于缺乏前期规划或糟糕的API设计引起的。
- en: They can be found by examining the pull request log or commit history and, in
    particular, determining if new features require many small changes in different
    parts of the code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过检查拉取请求日志或提交历史来找到，特别是确定新功能是否需要在代码的不同部分进行许多小的更改。
- en: If your team tracks feature velocity and you notice it is declining, this is
    also a likely cause.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的团队跟踪功能速度，并且您注意到它在下降，这也可能是一个原因。
- en: 'These smells include the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题包括以下内容：
- en: '**Shotgun surgery**: This is when small changes made to one struct necessitate
    changes in other structs. These changes imply that the organisation or abstraction
    used was incorrect. Typically, all of these changes should be in one class.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**散弹手术**：这是指对一个结构体进行的小改动需要改变其他结构体。这些变化意味着使用的组织或抽象是不正确的。通常，所有这些更改应该在一个类中。'
- en: 'In the following example, you can see how adding an email field to the person
    data would result in changing all three structs (`Presenter`, `Validator`, and
    `Saver`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，您可以看到向人员数据添加电子邮件字段将导致更改所有三个结构体（`Presenter`、`Validator`和`Saver`）：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Leaking implementation details**: One of the more popular idioms in the Go
    community is *accept interfaces, return structs*. It''s a catchy turn of phrase,
    but its simplicity masks its cleverness. When a function accepts a struct, it
    ties the user to a particular implementation—a strict relationship that makes
    future changes or additional usage difficult. By extension, if that implementation
    detail were to change, the API changes and forces changes on its users.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泄漏实现细节**：Go社区中更受欢迎的习语之一是*接受接口，返回结构体*。这是一个引人注目的短语，但它的简单性掩盖了它的巧妙之处。当一个函数接受一个结构体时，它将用户与特定的实现联系在一起，这种严格的关系使得未来的更改或附加使用变得困难。此外，如果实现细节发生变化，API也会发生变化，并迫使用户进行更改。'
- en: Applying DI to these smells is typically a good investment in the future. While
    not fixing them is not fatal, the code will progressively degrade until you are
    dealing with the proverbial *big ball of mud*. You know the type—a package that
    no-one understands, no-one trusts, and only the brave or stupid are willing to
    make changes to. DI enables you to decouple from the implementation choices, thereby
    making it easier to refactor, test, and maintain small chunks of code in isolation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将DI应用于这些问题通常是对未来的良好投资。虽然不修复它们不会致命，但代码将逐渐恶化，直到你处理谚语中的*大泥球*。你知道这种类型——一个没有人理解、没有人信任的包，只有勇敢或愚蠢的人愿意进行更改。DI使您能够脱离实现选择，从而更容易地重构、测试和维护代码的小块。
- en: Wasted effort
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浪费的努力
- en: These smells are cases where the cost to maintain the code is higher than it
    needs to be. They are typically caused by laziness or lack of experience. It's
    always easier to copy/paste code than to carefully refactor it. The problem is,
    coding like this is like eating unhealthy snacks. It feels great in the moment,
    but the long-term consequences suck.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是代码维护成本高于必要成本的情况。它们通常是由懒惰或缺乏经验引起的。复制/粘贴代码总是比仔细重构代码更容易。问题是，像这样编码就像吃不健康的零食。在当时感觉很棒，但长期后果很糟糕。
- en: They can be found by taking a critical look at the source code and asking yourself
    *do I really need this code?* Or, *can I make this easier to understand?*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过对源代码进行批判性审视并问自己*我真的需要这段代码吗？*或者*我能让这更容易理解吗？*来找到。
- en: Using tools such as dupl ([https://github.com/mibk/dupl](https://github.com/mibk/dupl)) or
    PMD ([https://pmd.github.io/](https://pmd.github.io/)) will also help you identify
    areas of the code to investigate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如dupl ([https://github.com/mibk/dupl](https://github.com/mibk/dupl))或PMD
    ([https://pmd.github.io/](https://pmd.github.io/))之类的工具也将帮助您识别需要调查的代码区域。
- en: 'These smells include the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题包括以下内容：
- en: '**Excessive duplicated code**: Firstly, please, please do not become a zealot
    about this one. While in most cases, duplicated code is a bad thing, sometimes
    copying code can result in a system that is easier to maintain and can evolve.
    We will deal with a common source of this smell in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过多的重复代码**：首先，请不要对此变得过分狂热。虽然在大多数情况下，重复的代码是一件坏事，但有时复制代码可以导致一个更容易维护和发展的系统。我们将在[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml)中处理这种问题的常见来源，*通过配置进行依赖注入*。'
- en: '**Excessive comments**: Leaving a note for those that come after you, even
    it is only you 6 months from now, is a friendly and professional thing to do.
    But when that note becomes an essay, then it''s time to refactor:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过多的注释**：为后来的人留下一条便签，即使只有6个月后的自己，也是一件友好和专业的事情。但当这个注释变成一篇文章时，就是重构的时候了。'
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Overly complicated code**: The harder code is for other people to understand,
    the worse it is. Typically, this is the result of someone trying to be too fancy
    or not putting enough effort into structure or naming. Taking a more selfish view,
    if you are the only one who understands a piece of code, you are the only one
    that can work on it. Meaning, you are doomed to maintain it forever. What does
    the following code do:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过于复杂的代码**：代码越难让其他人理解，它就越糟糕。通常，这是某人试图过于花哨或者没有花足够的精力在结构或命名上的结果。从更自私的角度来看，如果只有你一个人能理解一段代码，那么只有你能够处理它。也就是说，你注定要永远维护它。以下代码是做什么的：'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**DRY/WET code**: The **Don''t Repeat Yourself** (**DRY**) principle is aimed
    at reducing duplicated efforts by grouping responsibilities together and providing
    clean abstractions. By contrast, in WET code, sometimes called **Waste Everyone''s
    Time** code, you will find the same responsibility in many places. This smell
    often appears in formatting or conversion code. This sort of code should exist
    at the system boundaries, that is, converting user input or formatting output.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRY/WET代码**：**不要重复自己**（DRY）原则旨在通过将责任分组并提供清晰的抽象来减少重复的工作。相比之下，在WET代码中，有时也被称为**浪费每个人的时间**代码，你会发现同样的责任出现在许多地方。这种气味通常出现在格式化或转换代码中。这种代码应该存在于系统边界，也就是说，转换用户输入或格式化输出。'
- en: While many of these smells can be fixed without DI, DI provides an easier way
    to *lift and shift* the duplication into an abstraction that can then be used
    to reduce the duplication and improve the readability and maintainability of the
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多这些气味可以在没有依赖注入的情况下修复，但依赖注入提供了一种更容易的方式来将重复的工作转移到一个抽象中，然后可以用来减少重复和提高代码的可读性和可维护性。
- en: Tight coupling
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧耦合
- en: For people, tight coupling might be a good thing. For Go code, it's really not.
    Coupling is a measure of how objects relate to or depend on each other. When the tight
    coupling is present, this interdependence forces the objects or packages to evolve
    together, adding complexity and maintenance costs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人来说，紧耦合可能是一件好事。但对于Go代码来说，真的不是。耦合是衡量对象之间关系或依赖程度的指标。当存在紧耦合时，这种相互依赖会迫使对象或包一起发展，增加了复杂性和维护成本。
- en: Coupling-related smells are perhaps the most insidious and obstinate but by
    far the most rewarding when dealt with. They are often the result of a lack of
    object-oriented design or insufficient use of interfaces.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合相关的气味可能是最隐匿和顽固的，但处理起来也是最有回报的。它们通常是由于缺乏面向对象设计或接口使用不足造成的。
- en: Sadly, I don't have a handy tool to help you find these smells but I am confident
    that, by the end of this book, you will have no trouble spotting and dealing with
    them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我没有一个方便的工具来帮助你找到这些气味，但我相信，在本书结束时，你将毫无困难地发现并处理它们。
- en: Frequently, I find it useful to implement a feature in a tightly coupled form
    first and then work backward to decouple and thoroughly unit test my code before
    submitting it. For me, it is especially helpful in cases where the correct abstractions
    are not obvious.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，我发现先以紧密耦合的形式实现一个功能，然后逐步解耦并彻底单元测试我的代码，然后再提交，这对我来说是特别有帮助的，尤其是在正确的抽象不明显的情况下。
- en: 'These smells include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些气味包括以下内容：
- en: '**Dependence on God objects**: These are large objects that *know too much* or
    *do too much*. While this is a general code smell and something that should be
    avoided like the plague, the problem from a DI perspective is that too much of
    the code is dependent on this one object. When they exist and we are not careful,
    it won''t be long before Go will be refusing to compile due to a circular dependency.
    Interestingly, Go considers dependencies and imports not at an object level but
    at a package level. So we have to avoid God packages as well.  We will address
    a very common God object problem in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖于上帝对象**：这些是*知道太多*或*做太多*的大对象。虽然这是一种普遍的代码气味，应该像瘟疫一样避免，但从依赖注入的角度来看，问题在于太多的代码依赖于这个对象。当它们存在并且我们不小心时，很快Go就会因为循环依赖而拒绝编译。有趣的是，Go认为依赖和导入不是在对象级别，而是在包级别。因此，我们也必须避免上帝包。我们将在[第8章](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml)中解决一个非常常见的上帝对象问题，*通过配置进行依赖注入*。'
- en: '**Circular dependencies**: These are where package A depends on package B,
    and package B depends on package A. This is an easy mistake to make and sometimes
    a hard one to get rid of.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环依赖**：这是指包A依赖于包B，包B又依赖于包A。这是一个容易犯的错误，有时很难摆脱。'
- en: 'In the following example, while the config is arguably a `God` object and therefore
    a code smell, I am hard pressed to find a better way to import the config from
    a single JSON file. Instead, I would argue that the problem to be solved is the
    use of the `config` package by `orders` package. A typical config God object follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，虽然配置可以说是一个`上帝`对象，因此是一种代码气味，但我很难找到更好的方法来从一个单独的JSON文件中导入配置。相反，我会认为需要解决的问题是`orders`包对`config`包的使用。一个典型的上帝配置对象如下：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the attempted usage of the `config` package, you can see that the `Currency`
    type belongs to the `Package` package and so including it in `config`, as shown
    in the preceding example, causes a circular dependency:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`config`包的尝试使用中，你可以看到`Currency`类型属于`Package`包，因此在`config`中包含它，如前面的例子所示，会导致循环依赖：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**Object orgy**: These occur when an object has too much knowledge of and/or
    access to the internals of another or, to put it another way, *insufficient encapsulation
    between objects*. Because the objects are *joined at the hip*, they will frequently
    have to evolve together, increasing the cost of understanding the code and maintaining
    it. Consider the following code:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象混乱**：当一个对象对另一个对象的内部知识和/或访问过多时，或者换句话说，*对象之间的封装不足*。因为这些对象*紧密耦合*，它们经常需要一起发展，增加了理解代码和维护代码的成本。考虑以下代码：'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, `PageLoader` repeatably calls the member variable of the `Fetcher`.
    So much so that, if the implementation of `Fetcher` changed, it's highly likely
    that `PageLoader` would be affected. In this case, these two objects should be
    merged together as `PageLoader` has no extra functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`PageLoader`重复调用`Fetcher`的成员变量。以至于，如果`Fetcher`的实现发生了变化，`PageLoader`很可能会受到影响。在这种情况下，这两个对象应该合并在一起，因为`PageLoader`没有额外的功能。
- en: '**Yo-yo problem**: The standard definition of this smell is *when the inheritance
    graph is so long and complicated that the programmer has to keep flipping through
    the code to understand it*. Given that Go doesn''t have inheritance, you would
    think we would be safe from this problem. However, it is possible if you try hard
    enough, with excessive composition. To address this issue, it''s better to keep
    relationships as shallow and abstract as possible. In this way, we can concentrate
    on a much smaller scope when making changes and compose many small objects into
    a larger system.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yo-yo problem**：这种情况的标准定义是*当继承图如此漫长和复杂以至于程序员不得不不断地翻阅代码才能理解它*。鉴于Go没有继承，你可能会认为我们不会遇到这个问题。然而，如果你努力尝试，通过过度的组合是可能的。为了解决这个问题，最好保持关系尽可能浅和抽象。这样，我们在进行更改时可以集中在一个更小的范围内，并将许多小对象组合成一个更大的系统。'
- en: '**Feature envy**: When a function makes extensive use of another object, it
    is envious of it. Typically, an indication that the function should be moved away
    from the object it is envious of. DI may not be the solution to this, but this
    smell does indicate high coupling and, therefore, is an indicator to consider
    applying DI techniques:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Feature envy**：当一个函数广泛使用另一个对象时，它就是嫉妒它。通常，这表明该函数应该从它所嫉妒的对象中移开。DI可能不是解决这个问题的方法，但这种情况表明高耦合，因此是考虑应用DI技术的指标：'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As your code becomes less coupled, you will find the individual parts (packages,
    interfaces, and structs) will become more focused. This is referred to as having
    **high cohesion**. Both low coupling and high cohesion are desirable as they make
    the code easier to understand and work with.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码变得不那么耦合时，你会发现各个部分（包、接口和结构）会变得更加专注。这被称为**高内聚**。低耦合和高内聚都是可取的，因为它们使代码更容易理解和处理。
- en: Healthy skepticism
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康的怀疑。
- en: 'As we journey through this book, you will look at some fantastic coding techniques
    and some not so great. I would ask you to spend some time pondering which is which. Continuous
    learning should be tempered with a healthy dose of skepticism. For each technique,
    I will lay out the pros and cons, but I would ask you to dig deeper. Ask yourself
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们阅读本书时，你将看到一些很棒的编码技巧，也会看到一些不太好的。我希望你花一些时间思考哪些是好的，哪些是不好的。持续学习应该与健康的怀疑相结合。对于每种技术，我会列出其利弊，但我希望你能深入思考。问问自己以下问题：
- en: What is this technique trying to achieve?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术试图实现什么？
- en: What would my code look like after I apply this technique?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应用这种技术后，我的代码会是什么样子？
- en: Do I really need it?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我真的需要它吗？
- en: Are there any downsides to using this method?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这种方法有什么不利之处吗？
- en: Even when your inner skeptic dismisses the technique, you've at least learned
    to identify something you don't like and don't want to use, and learning is always
    a win.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你内心的怀疑者否定了这种技术，你至少学会了识别自己不喜欢并且不想使用的东西，而学习总是一种胜利。
- en: A quick word about idiomatic Go
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于符合Go的惯例的简短说明
- en: Personally, I try to avoid using the term **idiomatic Go** but a Go book is
    arguably not complete without addressing it in some form. I avoid it because I
    have seen it too often used as a stick to beat people. Essentially, *this is not
    idiomatic, therefore it's wrong* and, by extension, *I am idiomatic and therefore
    better than you*. I believe that programming is a craft and, while a craft should
    have some form of consistency in its application, it should, as with all crafts,
    be flexible. After all, innovation is often found by bending or breaking the rules.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人尽量避免使用术语**符合Go的惯例**，但是一本Go书在某种程度上没有涉及它是不完整的。我避免使用它，因为我经常看到它被用来打击人。基本上，*这不是符合惯例的，因此是错误的*，并且由此推论，*我是符合惯例的，因此比你更好*。我相信编程是一门手艺，虽然手艺在应用中应该有一定的一致性，但是，就像所有手艺一样，它应该是灵活的。毕竟，创新通常是通过弯曲或打破规则来实现的。
- en: So what does idiomatic Go mean to me?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 那么对我来说，符合Go的惯例意味着什么？
- en: 'I''ll define it as loosely as I can:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我会尽量宽泛地定义它：
- en: '**Format your code with** `gofmt`: Truly one less thing for us programmers
    to argue about. It''s the official style, supported with official tools. Let''s
    find something more substantive to argue about.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用`gofmt`格式化你的代码**：对我们程序员来说，真的少了一件要争论的事情。这是官方的风格，由官方工具支持。让我们找一些更实质性的事情来争论。'
- en: '**Read, apply, and regularly revisit the ideas in *Effective Go* ([https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)) and
    *Code Review Comments* ([https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments))**: There
    is a huge amount of wisdom in these pages, so much so that it''s perhaps impossible
    to glean it all from just one reading.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读，应用，并定期回顾《Effective Go》（[https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)）和《Code
    Review Comments》（[https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)）中的想法：这些页面中包含了大量的智慧，以至于可能不可能仅通过一次阅读就能全部领会。
- en: '**Aggressively apply the *Unix philosophy***: It state that we should *design
    code that does a single thing, but to does it well and works well together well
    with other code**.*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积极应用*Unix哲学***：它规定我们应该*设计代码只做一件事，但要做得很好，并且与其他代码很好地协同工作**。*'
- en: 'While these three things are the minimum for me, there are a couple of other
    ideas that resonate:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对我来说，这三件事是最低限度的，但还有一些其他的想法也很有共鸣：
- en: '**Accepting interfaces and returning structs**: While accepting interfaces
    leads to nicely decoupled code, the returning structs might strike you as a contradiction.
    I know they did with me at first. While outputting an interface might feel like
    it''s more loosely coupled, it''s not. Output can only be one thing—whatever you
    code it to be. Returning an interface is fine if that''s what you need, but forcing
    yourself to do so just ends up with you writing more code.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受接口并返回结构体**：虽然接受接口会导致代码解耦，但返回结构体可能会让你感到矛盾。我知道一开始我也是这样认为的。虽然输出接口可能会让你感觉它更松散耦合，但实际上并不是。输出只能是一种东西——无论你编码成什么样。如果需要，返回接口是可以的，但强迫自己这样做最终只会让你写更多的代码。'
- en: '**Reasonable defaults**: Since switching to Go, I''ve found many cases where
    I want to offer my user the ability to configure the module but such configuration
    is frequently not used. In other languages, this could lead to multiple constructors
    or seldom used parameters, but by applying this pattern we end up with a much
    cleaner API and less code to maintain.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合理的默认值**：自从转向Go以来，我发现许多情况下我想要为用户提供配置模块的能力，但这样的配置通常不被使用。在其他语言中，这可能会导致多个构造函数或很少使用的参数，但通过应用这种模式，我们最终得到了一个更清晰的API和更少的代码来维护。'
- en: Leave your baggage at the door
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把你的包袱留在门口
- en: If you were to ask me *what is the most frequent mistake new Go programmers
    make*?, I would not hesitate to tell you that it's bringing other language patterns
    into Go. I know this was my biggest early mistake. My first Go service looked
    like a Java app written in Go. Not only was the result subpar but it was rather
    painful, particularly while I was trying to achieve things such as inheritance.
    I've had a similar experience programming Go in a functional style, as you might
    see in `Node.js`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我*新手Go程序员最常犯的错误是什么*？我会毫不犹豫地告诉你，那就是将其他语言的模式带入Go中。我知道这是我最初的最大错误。我的第一个Go服务看起来像是用Go编写的Java应用程序。结果不仅是次等的，而且相当痛苦，特别是当我试图实现诸如继承之类的东西时。我在使用`Node.js`中以函数式风格编程Go时也有类似的经历。
- en: In short, please don't do it. Re-read *Effective Go* and Go blogs as often as
    you need to until you find yourself using small interfaces, firing off Go routines
    without reservation, loving channels, and wondering why you ever needed more than
    composition to achieve nice polymorphism.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，请不要这样做。重新阅读*Effective Go*和Go博客，直到您发现自己使用小接口、毫不犹豫地启动Go例程、喜欢通道，并想知道为什么您需要的不仅仅是组合来实现良好的多态性。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started a journey—a journey that will lead to code that
    is easier to maintain, extend, and test.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了一段旅程——这段旅程将导致更容易维护、扩展和测试的代码。
- en: We started by defining DI and examining some of the benefits it can bring us.
    With the help of a few examples, we saw how this might look in Go.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了DI，并检查了它可以给我们带来的一些好处。通过一些例子的帮助，我们看到了这在Go中可能是什么样子。
- en: After that, we started identifying code smells to look out for and that could
    be addressed or alleviated by applying DI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们开始识别需要注意的代码异味，并通过应用DI来解决或减轻这些问题。
- en: Finally, we examined what I believe Go code looks like, and I challenged you
    to be skeptical and apply a critical eye to techniques presented in this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了我认为Go代码是什么样子的，并向您提出质疑，对本书中提出的技术持怀疑态度。
- en: Questions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is DI?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是DI？
- en: What are the four highlighted advantages of DI?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DI的四个突出优势是什么？
- en: What sorts of issues does it address?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它解决了哪些问题？
- en: Why is it important to be skeptical?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么持怀疑态度很重要？
- en: What does idiomatic Go mean to you?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对你来说，惯用的Go是什么意思？
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has many other great resources for learning about DI and Go:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Packt还有许多其他关于DI和Go的学习资源。
- en: '[https://www.packtpub.com/application-development/java-9-dependency-injection](https://www.packtpub.com/application-development/java-9-dependency-injection)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/java-9-dependency-injection](https://www.packtpub.com/application-development/java-9-dependency-injection)'
- en: '[https://www.packtpub.com/application-development/dependency-injection-net-core-20](https://www.packtpub.com/application-development/dependency-injection-net-core-20)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/dependency-injection-net-core-20](https://www.packtpub.com/application-development/dependency-injection-net-core-20)'
- en: '[https://www.packtpub.com/networking-and-servers/mastering-go](https://www.packtpub.com/networking-and-servers/mastering-go)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/networking-and-servers/mastering-go](https://www.packtpub.com/networking-and-servers/mastering-go)'
