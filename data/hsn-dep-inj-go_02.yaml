- en: SOLID Design Principles for Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go的SOLID设计原则
- en: In 2002, *Robert "Uncle Bob" Martin* published the book *Agile Software Development,
    Principles, Patterns, and Practices* in which he defined the five principles of
    reusable programs, which he called SOLID principles. While it might seem strange
    to include these principles in a book about a programming language invented 10
    years later, these principles are still relevant today.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2002年，*Robert "Uncle Bob" Martin*出版了《敏捷软件开发，原则，模式和实践》一书，其中他定义了可重用程序的五个原则，他称之为SOLID原则。虽然在一个10年后发明的编程语言的书中包含这些原则似乎有些奇怪，但这些原则今天仍然是相关的。
- en: 'In this chapter, we will briefly examine each of these principles, how they
    relate to **dependency injection** (**DI**) and what that means for Go. SOLID
    is an acronym for five popular object-oriented software design principles:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论这些原则，它们与**依赖注入**（DI）的关系以及对Go意味着什么。SOLID是五个流行的面向对象软件设计原则的首字母缩写：
- en: Single responsibility principle
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: Open/closed principle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution principle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: Interface segregation principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The only requirement for this chapter is a basic understanding of objects and
    interfaces and an open mind.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的唯一要求是对对象和接口有基本的了解，并持开放的态度。
- en: All code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch02](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch02](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch02)找到。
- en: You will find links to additional information and other references mentioned
    in this chapter in the *Further reading* section at the end of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章结束时的*进一步阅读*部分中找到本章中提到的其他信息和参考链接。
- en: Single responsibility principle (SRP)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则（SRP）
- en: '"A class should have one, and only one, reason to change."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该有一个，且仅有一个，变化的原因。”
- en: –Robert C. Martin
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: –Robert C. Martin
- en: Go doesn't have classes, but if we squint a little and replace the word *class* with
    *objects* (structs, functions, interfaces or packages), then the concept still
    applies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有类，但如果我们稍微闭上眼睛，将*类*替换为*对象*（结构，函数，接口或包），那么这个概念仍然适用。
- en: 'Why do we want our objects to do only one thing? Let''s look at a couple of
    objects that do one thing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么希望我们的对象只做一件事？让我们看看一些只做一件事的对象：
- en: '![](img/e11113bc-3419-40f2-a79b-fe55cdf8a914.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e11113bc-3419-40f2-a79b-fe55cdf8a914.png)'
- en: These objects are simple and easy to use, and have a wide range of uses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象简单易用，用途广泛。
- en: 'Designing objects so that they all do only one thing sounds okay in the abstract.
    But you are probably thinking that doing so for an entire system would add a lot
    more code. Yes, it will. However, what it doesn''t do is add complexity; in fact,
    it significantly reduces it. Each piece of code would be smaller and easier to
    understand, and therefore easier to test. This fact gives us the first advantage
    of SRP:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 设计对象，使它们只做一件事，在抽象层面上听起来还不错。但你可能会认为为整个系统这样做会增加更多的代码。是的，会增加。但它不会增加复杂性；事实上，它会显著减少复杂性。每段代码会更小，更容易理解，因此更容易测试。这一事实给我们带来了SRP的第一个优势：
- en: '**SRP reduces the complexity by decomposing code into smaller, more concise
    pieces**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRP通过将代码分解为更小，更简洁的部分来减少复杂性**'
- en: 'With a name like single responsibility principle, it would be safe to assume
    that it is all about responsibility, but so far, all we have talked about is change.
    Why is this? Let''s look at an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以单一责任原则这样的名字，可以安全地假设它完全是关于责任的，但到目前为止，我们谈论的都是变化。为什么？让我们看一个例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code looks reasonable—one member variable and two methods. It does not,
    however, conform to SRP. Let''s assume that the app was successful, and we decided
    that we also needed to output the results to CSV. We could add a method to do
    that, as shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来合理——一个成员变量和两个方法。但它并不符合SRP。假设应用程序很成功，我们决定还需要将结果输出到CSV。我们可以添加一个方法来做到这一点，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have changed the struct and added another `Output()` method. We have added
    more responsibilities to the struct and, in doing so, we have added complexity.
    In this simple example, our changes are confined to one method, so there's no
    risk that we broke the previous code. However, as the struct gets bigger and more
    complicated, our changes are unlikely to be so clean.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改变了结构并添加了另一个`Output()`方法。我们为结构添加了更多的责任，在这样做的过程中，我们增加了复杂性。在这个简单的例子中，我们的更改局限于一个方法，因此没有风险破坏以前的代码。然而，随着结构变得越来越大和更加复杂，我们的更改不太可能如此干净。
- en: Conversely, if we were to break the responsibilities into `Calculate` and `Output`,
    then adding more outputs would mere define new structs. Additionally, should we
    decide that we don't like the default output format, we could change it separately
    from other parts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果我们将责任分解为`Calculate`和`Output`，那么添加更多的输出只是定义新的结构。此外，如果我们决定不喜欢默认的输出格式，我们可以单独更改它。
- en: 'Let''s try a different implementation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试不同的实现：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Do you notice anything significant about the printers? They have no connection
    at all to the calculation. They could be used for any data in the same format.
    This leads to the second advantage of SRP:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到打印机有什么显著的地方？它们与计算完全没有任何连接。它们可以用于相同格式的任何数据。这导致了SRP的第二个优势：
- en: '**SRP increases the potential reusability of code**.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRP增加了代码的潜在可重用性**。'
- en: 'In the first implementation of our coverage calculator, to test the `Output()`
    method we would be first call the `Calculate()` method. This approach increases
    the complexity of our tests by coupling the calculation with the output. Consider
    the following scenarios:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的覆盖率计算器的第一个实现中，要测试`Output()`方法，我们首先要调用`Calculate()`方法。这种方法通过将计算与输出耦合，增加了我们测试的复杂性。考虑以下情景：
- en: How do we test for no results?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何测试没有结果？
- en: How do we test edge conditions, such as 0% or 100% coverage?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何测试边缘条件，比如0%或100%的覆盖率？
- en: 'After decoupling these responsibilities, we should encourage ourselves to consider
    the inputs and outputs of each part in a less interdependent manner, hence making
    the tests easier to write and maintain. This leads to the third advantage of SRP:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在解耦这些职责之后，我们应该鼓励自己以更少的相互依赖方式考虑每个部分的输入和输出，从而使得测试更容易编写和维护。这导致了SRP的第三个优势：
- en: '**SRP makes tests simpler to write and maintain**.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**SRP使测试更简单，更易于维护**。'
- en: 'SRP is also an excellent way to improve general code readability. Take a look
    at this next example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SRP也是提高代码可读性的绝佳方式。看下面的例子：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I'd bet that took more than five seconds to understand. How about this code?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你花了超过五秒钟才理解。那么这段代码呢？
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By applying SRP at the function level, we have reduced the function's bloat
    and increased its readability. The function's single responsibility is now to
    coordinate the calls to the other functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数级别应用SRP，我们减少了函数的膨胀并增加了其可读性。函数的单一责任现在是协调对其他函数的调用。
- en: How does this relate to DI?
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与DI有什么关系？
- en: When applying DI to our code, we are unsurprisingly injecting our dependencies,
    typically in the form of a function parameter. If you see a function with many
    injected dependencies, this is a likely sign that the method is doing too much.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在对我们的代码应用DI时，我们不奇怪地注入我们的依赖，通常以函数参数的形式。如果你看到一个函数有很多注入的依赖，这很可能是该方法做了太多事情的迹象。
- en: Additionally, applying SRP will inform our object design. As such, this helps
    us identify when and where to use DI.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应用SRP将指导我们的对象设计。因此，这有助于我们确定何时以及在哪里使用DI。
- en: What does this mean for Go?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这对Go意味着什么？
- en: In [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never Stop Aiming
    for Better*, we mentioned Go's relationship with the Unix philosophy, which states
    that we should *design code that does a single thing, but to does it well and
    works well together well with other code*. After applying SRP, our objects will
    be perfectly in line with this principle.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml)中，*永远不要停止追求更好*，我们提到了Go与Unix哲学的关系，即我们应该*设计代码只做一件事，但要做得很好，并且与其他代码很好地协同工作*。应用SRP后，我们的对象将完全符合这一原则。
- en: Go interfaces, structs, and functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go接口、结构和函数
- en: At the interface and struct level, applying SRP results in many small interfaces.
    A function that complies with the SRP has few inputs and is quite short (that
    is, it has less than one screen of code). Both of these features inherently address
    the code bloat smells we mentioned in [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml),
    *Never Stop Aiming for Better*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口和结构级别应用SRP会产生许多小接口。符合SRP的函数输入少，代码相当短（即不到一屏的代码）。这两个特点本质上解决了我们在[第1章](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml)中提到的代码膨胀问题。
- en: By addressing the code bloat, we find that one of the less-advertised advantages
    of SRP is that it makes code easier to understand. Simply put, when a piece of
    code does one thing, its purpose is clearer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解决代码膨胀问题，我们发现SRP的一个不太被宣传的优势是它使代码更容易理解。简而言之，当一段代码只做一件事时，它的目的更加清晰。
- en: When applying SRP to existing code, you will often break the code into smaller
    pieces. You may experience a natural aversion to this, due to the feeling that
    you might also then have to write more tests. In cases where you are splitting
    a struct or interface into multiple parts, this may be true. However, if the code
    you are refactoring has high unit-test coverage, then you probably already have
    many of the tests you need. They just need to be moved around a little bit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在对现有代码应用SRP时，通常会将代码分解为更小的部分。由于你可能觉得自己可能需要编写更多的测试，因此你可能会自然而然地对此产生厌恶。在将结构或接口拆分为多个部分的情况下，这可能是真的。然而，如果你正在重构的代码具有高单元测试覆盖率，那么你可能已经拥有许多你需要的测试。它们只需要稍微移动一下。
- en: 'On the other hand, when applying SRP to a function to reduce bloat, no new
    tests are required; the tests for the original function are perfectly acceptable.
    Let''s look at an example of a test for our `loadUserHandler()`, which was shown
    in the preceding example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当将SRP应用于函数以减少膨胀时，不需要新的测试；原始函数的测试是完全可以接受的。让我们看一个对我们的`loadUserHandler()`的测试的例子，这在前面的例子中已经展示过了：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test can be applied to either form of our function and will achieve the
    same thing. In this case, we were refactoring for readability, and we don't want
    anything to discourage us from that. Additionally, testing from the API (either
    a public method or a function called by others) is more stable, as the API contract
    is less likely to change than the internal implementation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试可以应用于我们函数的任何形式，并且会达到相同的效果。在这种情况下，我们正在重构以提高可读性，我们不希望有任何事情阻止我们这样做。此外，从API（公共方法或其他函数调用的函数）进行测试更加稳定，因为API合同不太可能改变，而内部实现可能会改变。
- en: Go packages
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go包
- en: 'Applying SRP at the package level is perhaps harder to do. Systems are often
    designed in layers. For example, it''s common to see an HTTP REST service with
    layers arranged in the following manner:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在包级别应用SRP可能更难。系统通常是分层设计的。例如，通常会看到一个按以下方式排列层的HTTP REST服务：
- en: '![](img/528ec62c-ccb2-464d-bc13-926017793262.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/528ec62c-ccb2-464d-bc13-926017793262.png)'
- en: These abstractions are nice and clear; however, problems start to appear when
    our service has more than a few endpoints. We very quickly end up with monster
    packages full of entirely unrelated logic. Good packages, on the other hand, are
    small, concise, and clear of purpose.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象很好而且清晰；然而，当我们的服务有多个端点时，问题开始出现。我们很快就会得到充满完全无关逻辑的庞大包。另一方面，良好的包应该是小巧、简洁且目的明确的。
- en: 'It can be hard to find the right abstraction. Often, when I am in need of inspiration,
    I turn to the experts and examine the standard Go libraries. For example, let''s
    take a look at the `encoding` package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 找到正确的抽象可能很困难。通常，当我需要灵感时，我会求助于专家，并检查标准的Go库。例如，让我们来看看`encoding`包：
- en: '![](img/2b144d17-587f-4b9d-9245-dae8f9d9d965.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b144d17-587f-4b9d-9245-dae8f9d9d965.png)'
- en: 'As you can see, each different type is neatly organized in its own package,
    but all of the packages are still grouped logically by the parent directory. Our
    REST service would break it down as shown in the following figure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每种不同类型都整齐地组织在自己的包中，但所有的包仍然按父目录逻辑分组。我们的REST服务将按照下图所示进行拆分：
- en: '![](img/29ac7f3f-93ef-48ec-a808-627f86f2abb6.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29ac7f3f-93ef-48ec-a808-627f86f2abb6.png)'
- en: Our initial abstractions are on the right track, only from too high a level.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初的抽象是正确的，只是从太高的层次开始。
- en: Another aspect of the `encoding` package that is not immediately apparent is
    that the shared code is in the parent package. When working on a feature, it's
    common for programmers to think *I need that code I wrote earlier*, and for them
    to be tempted to extract the code to a `commons` or `utils` package. Please resist
    this temptation—reusing the code is absolutely correct, but you should resist
    the allure of the general package name. Such packages inherently violate SRP by
    having no clear-cut purpose.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoding`包的另一个不明显的方面是共享代码位于父包中。在开发功能时，程序员通常会想到*我需要我之前写的那段代码*，并且会被诱惑将代码提取到`commons`或`utils`包中。请抵制这种诱惑——重用代码是绝对正确的，但您应该抵制通用包名称的诱惑。这样的包本质上违反了SRP，因为它们没有明确的目的。'
- en: Another common temptation is to add the new code next to the existing code.
    Let's imagine that we were writing the `encoding` package mentioned previously
    and the first encoder we made was the JSON one. Next, we add the GobEncoder, and
    things are going great. Add a few more encoders, and suddenly we have a substantial
    package with lots of code and a large exported API. At some point, the documentation
    for our little `encoding` package becomes so long that it will be hard for users
    to follow. Similarly, we have so much code in the package that our extension and
    debugging work slows down because it's hard to find things.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的诱惑是将新代码添加到现有代码旁边。让我们想象一下，我们正在编写先前提到的`encoding`包，我们制作的第一个编码器是JSON编码器。接下来，我们添加了GobEncoder，一切都进行得很顺利。再添加几个编码器，突然间我们有了一个大量代码和大量导出API的实质性包。在某个时候，我们的`encoding`包的文档变得如此之长，以至于用户很难跟踪。同样地，我们的包中有如此多的代码，以至于我们的扩展和调试工作变慢，因为很难找到东西。
- en: SRP helps us identify reasons to change; multiple reasons to change indicate
    multiple responsibilities. Decoupling these responsibilities enables us to develop
    better abstractions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SRP帮助我们确定更改的原因；多个更改原因表示多个责任。解耦这些责任使我们能够开发更好的抽象。
- en: If you have the time or the inclination to do it right from the start, fantastic.
    However, applying SRP and finding the correct abstractions from the beginning
    is difficult. You can counter this by breaking the rules first and then using
    subsequent changes to discover how the software wants to evolve, using the forces
    of evolution as the basis for refactoring.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有时间或意愿从一开始就做正确，那太棒了。然而，从一开始应用SRP并找到正确的抽象是困难的。您可以通过首先打破规则，然后使用后续更改来发现软件希望如何发展，以此作为重构的基础。
- en: Open/closed principle (OCP)
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则（OCP）
- en: '"Software entities (classes, modules, functions, etc.) should be open for extension,
    but closed for modification."'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。"'
- en: '- Bertrand Meyer'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '- Bertrand Meyer'
- en: The terms *open* and *closed* are not something I often hear when discussing
    software engineering, so perhaps they could do with a little explanation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*开放*和*封闭*在讨论软件工程时并不是我经常听到的，所以也许需要做一些解释。
- en: Open means that we should be able to extend or adapt code by adding new behaviors
    and features. Closed means that we should avoid making changes to existing code,
    changes that could result in bugs or other kinds of regression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 开放意味着我们应该能够通过添加新的行为和功能来扩展或调整代码。封闭意味着我们应该避免对现有代码进行更改，这些更改可能导致错误或其他类型的退化。
- en: These two characteristics might seem contradictory, but the missing piece of
    the puzzle is the scope. When talking about being open, we are talking about the
    design or structure of the software. From this perspective, being open means that
    it is easy to add new packages, new interfaces, or new implementations of an existing
    interface.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特征可能看起来矛盾，但缺失的是范围。当谈论开放时，我们指的是软件的设计或结构。从这个角度来看，开放意味着很容易添加新的包、新的接口或现有接口的新实现。
- en: 'When we talk about being closed, we are talking about existing code and minimizing
    the changes we make to it, particularly the APIs that are used by others. This
    brings us to the first advantage of OCP:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论封闭时，我们指的是现有的代码，以及最小化我们对其进行的更改，特别是被他人使用的API。这带我们来到OCP的第一个优势：
- en: '**OCP helps reduce the risk of additions and extensions**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**OCP有助于减少增加和扩展的风险**'
- en: You can think of OCP as a risk-mitigation strategy. Modifying existing code
    always has some risk involved, and changes to the code used by others especially
    so. While we can and should be protecting ourselves from this risk with unit tests,
    these are restricted to scenarios that we intend and misuses that we can imagine;
    they will not cover everything our users can come up with.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将OCP视为一种风险缓解策略。修改现有代码总是存在一定的风险，尤其是对他人使用的代码进行更改。虽然我们可以通过单元测试来保护自己免受这种风险，但这些测试仅限于我们打算的场景和我们可以想象到的误用；它们不会涵盖我们的用户可能想出的一切。
- en: 'The following code does not follow the OCP:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码不遵循OCP：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first hint that something is amiss is the `switch` statement. It is not
    hard to imagine a situation where requirements change, and where we might need
    to add or even remove an output format.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提示出现在`switch`语句中。很容易想象情况会发生变化，我们可能需要添加或甚至删除输出格式。
- en: 'Just how much would have to change if we needed to add another format? See
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要添加另一个格式，需要改变多少？请看下面：
- en: '**We would need to add another case condition to the switch**: This method
    is already 18 lines long; how many more formats do we need to add before we cannot
    see it all on one screen? In how many other places does this `switch` statement
    exist? Will they need to be updated too?'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们需要在`switch`中添加另一个case条件**：这个方法已经有18行长了；在我们无法在一个屏幕上看到所有内容之前，我们需要添加多少个格式？这个`switch`语句还存在于多少其他地方？它们也需要更新吗？'
- en: '**We would need to write another formatting function**: This is one of three
    changes that are unavoidable'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们需要编写另一个格式化函数**：这是三个不可避免的变化之一'
- en: '**The caller of the method would have to be updated to use the new format**:
    This is the other unavoidable change'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法的调用者必须更新以使用新格式**：这是另一个不可避免的变化'
- en: '**We would have to add another set of test scenarios to match the new formatting**:
    This is also unavoidable; however, the tests here will likely be longer than just
    testing the formatting in isolation'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们需要添加另一组测试场景以匹配新的格式**：这也是不可避免的；然而，这里的测试可能会比仅测试独立格式化要长'
- en: What started as a *small and simple change* is beginning to feel more arduous
    and risky than we intended.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开始作为*一个小而简单的改变*，现在开始感觉比我们预期的更艰难和风险。
- en: 'Let''s replace the format input parameter and the `switch` statement with an
    abstraction, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个抽象替换格式输入参数和`switch`语句，如下所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'How many changes was it this time? Let''s see:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这次有多少变化？让我们看看：
- en: We need to define another implementation of the `PersonFormatter` interface
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要定义`PersonFormatter`接口的另一个实现
- en: The caller of the method has to be updated to use the new format
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的调用者必须更新以使用新格式
- en: We have to write test scenarios for the new `PersonFormatter`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须为新的`PersonFormatter`编写测试场景
- en: 'That''s much better: we are down to only the three unavoidable changes and
    *we changed nothing in the primary function at all*. This shows us the second
    advantage of OCP:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了：我们只剩下三个不可避免的变化，*而主要函数根本没有改变*。这向我们展示了OCP的第二个优势：
- en: '**OCP can help reduce the number of changes needed to add or remove a feature**.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**OCP可以帮助减少添加或删除功能所需的更改数量**。'
- en: 'Also, if there happens to be a bug in our new structure after adding the new
    formatter, it can only be in one place—the new code. This is the third advantage
    of OCP:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在添加新格式化程序后，新结构中出现了错误，那么错误只会出现在一个地方——新代码中。这是OCP的第三个优势：
- en: '**OCP narrows the locality of bugs to only the new code and its usage**.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**OCP将错误的局部性缩小到仅限于新代码及其使用**。'
- en: 'Let''s look at another example, where we don''t end up applying DI:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，我们不会应用DI：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, both our HTTP handlers are pulling the data from the form and
    then converting it into a number. One day, we decide to tighten our input validation
    and ensure that the number is positive. The likely result? Some pretty nasty shotgun
    surgery. In this case, however, there is no way around. We made the mess; now
    we need to clean it up. The fix is hopefully pretty obvious—extracting the repeated
    logic to one place and then adding the new validation there, as shown in the following
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的HTTP处理程序都是从表单中提取数据，然后将其转换为数字。有一天，我们决定加强输入验证，并确保数字是正数。可能的结果？一些相当恶劣的霰弹手术。然而，在这种情况下，没有其他办法。我们搞砸了；现在我们需要清理。修复方法显而易见——将重复的逻辑提取到一个地方，然后在那里添加新的验证，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sadly, the original code has not reduced, but it's definitely easier to read.
    Beyond that, we have future-proofed ourselves against any further changes to the
    validation of the `UserID` field.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，原始代码并没有减少，但肯定更容易阅读。除此之外，我们已经未来证明了对`UserID`字段验证的任何进一步更改。
- en: For both our examples, the key to meeting OCP was to find the correct abstraction.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的两个例子，满足OCP的关键是找到正确的抽象。
- en: How does this relate to DI?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与DI有什么关系？
- en: In [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never Stop Aiming
    for Better,* we defined DI as *coding in such a way that those resources that
    we depend on are abstractions*. By using OCP, we can discover cleaner and more
    durable abstractions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml)中，*永远不要停止追求更好*，我们将DI定义为*以依赖于抽象的方式编码*。通过使用OCP，我们可以发现更清晰和更持久的抽象。
- en: What does this mean for Go?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这对Go意味着什么？
- en: Typically, when discussing OCP, the examples are littered with abstract classes,
    inheritance, virtual functions, and all kinds of things that Go doesn't have.
    Or does it?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在讨论OCP时，示例中充斥着抽象类、继承、虚函数和Go没有的各种东西。还是有吗？
- en: What is an abstract class really? What is it actually trying to achieve?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类到底是什么？它实际上试图实现什么？
- en: 'It''s trying to provide a place for code that is shared between several implementations.
    We can do that in Go—it''s called **composition**. You can see it at work in the
    following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它试图提供一个用于多个实现之间共享代码的地方。我们可以在Go中做到这一点——这就是**组合**。您可以在下面的代码中看到它的工作：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we have extracted some of the shared logic into a
    `rowConverter` struct. Then, by embedding that struct in the other structs, we
    can use it without any changes. We have achieved the goals of the abstract class
    and OCP. Our code is open; we can embed wherever we like but closed. The embedded
    class has no knowledge of the fact that it was embedded, nor did it require any
    changes to be used.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将一些共享逻辑提取到`rowConverter`结构中。然后，通过将该结构嵌入其他结构中，我们可以在不进行任何更改的情况下使用它。我们已经实现了抽象类和OCP的目标。我们的代码是开放的；我们可以随意嵌入，但是封闭的。嵌入的类不知道自己被嵌入，也不需要进行任何更改就可以使用。
- en: Earlier, we defined *closed* as remaining unchanged, but restricted the scope
    to only the parts of the API that were exported or used by others. It is not reasonable
    to expect that internal implementation details, including private member variables,
    should never change. The best way to achieve this is to hide those implementation
    details. This is called **encapsulation**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们将*封闭*定义为保持不变，但范围仅限于API的部分被导出或被他人使用。我们不能期望内部实现细节，包括私有成员变量，永远不会改变。实现这一点的最佳方法是隐藏这些实现细节。这就是**封装**。
- en: 'At the package level, encapsulation is simple: we make it private. A good rule
    of thumb here is to make everything private and only make things public when you
    really have to. Again, my justification is risk and work avoidance. The moment
    you export something is the moment that someone could rely on it. Once they rely
    on it, it should become closed; you have to maintain it, and any changes have
    a higher risk of breaking something. With proper encapsulation, changes within
    a package should be invisible to existing users.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在包级别上，封装很简单：我们将其设为私有。在这里的一个很好的经验法则是，将所有东西都设为私有，只有在真正需要时才将其设为公共。再次，我的理由是风险和工作的避免。一旦你导出了某些东西，就意味着有人可能依赖它。一旦他们依赖它，它就应该变成封闭的；你必须维护它，任何更改都有更高的风险会破坏某些东西。通过适当的封装，包内的更改应该对现有用户是不可见的。
- en: At the object level, private doesn't mean what it does in other languages, so
    we have to learn to behave ourselves. Accessing private member variables leaves
    the objects tightly coupled, a decision that will come back to bite us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象级别上，私有并不意味着在其他语言中的意思，所以我们必须学会自律。访问私有成员变量会使对象紧密耦合，这个决定将会给我们带来麻烦。
- en: 'One of my favorite features of Go''s type system is the ability to attach methods
    to just about anything. Let''s say you are writing an HTTP handler for a health
    check. It does nothing more than return the status `204` (No Content). The interface
    we need to satisfy is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢Go类型系统的一个特性是能够将方法附加到几乎任何东西上。比如说，你正在为健康检查编写一个HTTP处理程序。它只是返回状态`204`（无内容）。我们需要满足的接口如下：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A simple implementation might look as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现可能如下所示的代码：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could create a new struct to implement an interface, but that''s going to
    be at least five lines. We can reduce it to three, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的结构来实现一个接口，但这至少需要五行。我们可以将其减少到三行，如下所示的代码：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The secret sauce, in this case, is hidden in the standard library. We are casting
    our function into the `http.HandlerFunc` type, which has a `ServeHTTP` method
    attached to it. This nifty little trick makes it easy for us to satisfy the `http.Handler`
    interface. As we have already seen in this chapter, moving towards interfaces
    leads us to less coupled code that is easier to maintain and extend.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，秘密酱汁隐藏在标准库中。我们将我们的函数转换为`http.HandlerFunc`类型，它附加了一个`ServeHTTP`方法。这个巧妙的小技巧使我们很容易满足`http.Handler`接口。正如我们在本章中已经看到的，朝着接口的方向前进会使我们的代码更少耦合，更容易维护和扩展。
- en: Liskov substitution principle (LSP)
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则（LSP）
- en: '"If for each object o1 of type S there is an object o2 of type T such that
    for all programs P defined in terms of T, the behavior of P is unchanged when
    o1 is substituted for o2 then S is a subtype of T."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “如果对于类型为S的每个对象o1，都有类型为T的对象o2，使得对于所有以T定义的程序P，当o1替换o2时，P的行为不变，则S是T的子类型。”
- en: -Barbara Liskov
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: -芭芭拉·里斯科夫
- en: 'After reading that three times, I am still not sure I have got it straight.
    Thankfully, Robert C. Martin made it easier on us and summarized it as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 读了三遍之后，我仍然不确定我是否理解正确。幸运的是，罗伯特C.马丁为我们总结了如下：
- en: '"Subtypes must be substitutable for their base types."'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “子类型必须可以替换其基类型。”
- en: -Robert C. Martin
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: -罗伯特C.马丁
- en: That I can follow. However, isn't he talking about abstract classes again? Probably.
    As we saw in the section on OCP, while Go doesn't have abstract classes or inheritance,
    it does have a composition and interface implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我能理解这一点。然而，他是不是又在谈论抽象类了？可能是。正如我们在OCP部分看到的，虽然Go没有抽象类或继承，但它确实有组合和接口实现。
- en: Let's step back for a minute and look at the motivation of this principle. LSP
    requires that *subtypes are substitutable for each other*. We can use Go interfaces,
    and this will always hold true.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退后一步，看看这个原则的动机。LSP要求*子类型可以相互替换*。我们可以使用Go接口，这将始终成立。
- en: 'But hang on, what about this code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，这段代码怎么样：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It uses an interface, but it clearly violates LSP. We could fix this by adding
    more interfaces, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了一个接口，但显然违反了LSP。我们可以通过添加更多接口来修复这个问题，如下所示的代码：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, this isn''t better. The fact that this code still smells indicates
    that we are probably using the wrong abstraction or the wrong composition. Let''s
    try the refactor again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是更好的。这段代码仍然有异味，这表明我们可能使用了错误的抽象或错误的组合。让我们再试一次重构：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s much better. The `Buggy` phrase is not forced to implement methods
    that make no sense, nor does it contain any logic it doesn''t need, and the usage
    of both vehicle types is nice and clean. This demonstrates a key point about LSP:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样好多了。`Buggy`短语不再被迫实现毫无意义的方法，也不包含任何它不需要的逻辑，两种车辆类型的使用都很干净。这展示了LSP的一个关键点：
- en: '**LSP refers to behavior and not implementation**.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**LSP指的是行为而不是实现**。'
- en: 'An object can implement any interface that it likes, but that doesn''t make
    it behaviorally consistent with other implementations of the same interface. Look
    at the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以实现任何它喜欢的接口，但这并不意味着它在行为上与同一接口的其他实现是一致的。看看下面的代码：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we met (as in delivered) the API contract by implementing
    all of the methods, but we turned the method we didn't need into a NO-OP. By having
    our `ReadOnlyCollection` implement the `Add()` method, it satisfies the interface
    but introduces the potential for confusion. What happens when you have a function
    that accepts a `Collection`? When you call `Add()`, what would you expect to happen?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们通过实现所有方法来满足API合同，但我们将不需要的方法转换为NO-OP。通过让我们的`ReadOnlyCollection`实现`Add()`方法，它满足了接口，但引入了混乱的可能性。当你有一个接受`Collection`的函数时会发生什么？当你调用`Add()`时，你会期望发生什么？
- en: 'The fix, in this case, might surprise you. Instead of making an `ImmutableCollection`
    out of a `MutableCollection`, we can flip the relation over, as shown in the following
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，修复方法可能会让你感到惊讶。我们可以将关系反转，而不是将`MutableCollection`转换为`ImmutableCollection`，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A bonus of this new structure is that we can now let the compiler ensure that
    we don't use `ImmutableCollection` where we need `MutableCollection`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新结构的一个好处是，我们现在可以让编译器确保我们不会在需要`MutableCollection`的地方使用`ImmutableCollection`。
- en: How does this relate to DI?
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与DI有什么关系？
- en: By following LSP, our code performs consistently regardless of the dependencies
    we are injecting. Violating LSP, on the other hand, leads us to violate OCP. These
    violations cause our code to have too much knowledge of the implementations, which
    in turn breaks the abstraction of the injected dependencies.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循LSP，我们的代码在注入的依赖关系不同的情况下表现一致。另一方面，违反LSP会导致我们违反OCP。这些违规行为使我们的代码对实现有太多的了解，从而打破了注入依赖的抽象。
- en: What does this mean for Go?
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这对Go有什么意义？
- en: When using composition—particularly the unnamed variable form—to satisfy interfaces,
    LSP applies just as it would in object-oriented languages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用组合，特别是未命名变量形式来满足接口时，LSP的应用方式与面向对象语言中的应用方式一样。
- en: When implementing interfaces, we can use LSP's focus on *consistent *behavior as
    a way of detecting code smells related to incorrect abstractions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现接口时，我们可以利用LSP对*一致的*行为的关注，作为检测与不正确的抽象相关的代码异味的一种方式。
- en: Interface segregation principle (ISP)
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）
- en: '"Clients should not be forced to depend on methods they do not use."'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “客户端不应被强迫依赖他们不使用的方法。”
- en: –Robert C. Martin
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: –Robert C. Martin
- en: Personally, I prefer a much more direct definition—*interfaces should be reduced
    to the minimum possible size*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我更喜欢一个更直接的定义——*接口应该被减少到可能的最小尺寸*。
- en: Let's first discuss why fat interfaces might be a bad thing. Fat interfaces
    have more methods and are therefore likely to be harder to understand. They also
    require more work to use, whether this be through implementing, mocking, or stubbing
    them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论为什么臃肿的接口可能是一件坏事。臃肿的接口有更多的方法，因此可能更难理解。它们也需要更多的工作来使用，无论是通过实现、模拟还是存根。
- en: 'Fat interfaces indicate more responsibility and, as we saw with the SRP, the
    more responsibility an object has, the more likely it will want to change. If
    the interface changes, it causes a ripple effect through all its users, violating
    OCP and causing a massive amount of shotgun surgery. This is the first advantage
    of ISP:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 臃肿的接口表明更多的责任，正如我们在SRP中看到的，一个对象承担的责任越多，它就越有可能想要改变。如果接口发生变化，它会通过所有的用户产生连锁反应，违反OCP并引起大量的散弹手术。这是ISP的第一个优势：
- en: '**ISP requires us to define thin interfaces**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISP要求我们定义薄接口**'
- en: 'For many programmers, their natural tendency is to add to the existing interface
    rather than define a new one, thereby creating a fat interface. This leads to
    a situation where the, sometimes singular, implementation becomes tightly coupled
    with the users of the interface. This coupling then makes the interface, their
    implementations, and users all the more resistant to change. Consider the following
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多程序员来说，他们的自然倾向是向现有接口添加内容，而不是定义一个新的接口，从而创建一个臃肿的接口。这导致了一种情况，即有时候，实现变得与接口的用户紧密耦合。这种耦合使得接口、它们的实现和用户更加抵制变化。考虑以下例子：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It''s not hard to imagine all of these methods belonging to one struct. Method
    pairs such as `GetItem()` and `GetItemWithContext()` are quite likely to share
    much, if not almost all, of the same code. On the other hand, a user of `GetItem()`
    is not likely to also use `GetItemWithContext()`. For this particular use case,
    a more appropriate interface would be the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想象所有这些方法都属于一个结构。例如`GetItem()`和`GetItemWithContext()`这样的方法对很可能共享大部分，如果不是全部相同的代码。另一方面，使用`GetItem()`的用户不太可能也会使用`GetItemWithContext()`。对于这种特定的用例，一个更合适的接口应该是以下这样的：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Leveraging this new, thin interface makes the function signature far more explicit
    and flexible. This leads us to the second advantage of ISP:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个新的薄接口，使函数签名更加明确和灵活。这带来了ISP的第二个优势：
- en: '**ISP leads to explicit inputs**.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISP导致明确的输入**。'
- en: A thin interface is also more straightforward to more fully implement, keeping
    us away from any potential problems with LSP.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 薄接口也更容易更完全地实现，使我们远离与LSP相关的潜在问题。
- en: 'In cases where we are using an interface as an input and the interface needs
    to be fat, this is a powerful indication that the method is violating SRP. Consider
    the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用接口作为输入并且接口需要臃肿的情况下，这是方法违反SRP的一个有力指示。考虑以下代码：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Do you see the issue? We are using the `context` interface, which is fantastic
    and highly recommended, but we are violating ISP. Being pragmatic programmers,
    we can argue that this interface is widely used and understood, and the value
    of defining our own interface to reduce it to the two methods that we need is
    unnecessary. In most cases, I would agree, but in this particular case, we should
    reconsider. We are using the `context` interface for two entirely separate purposes.
    The first is a control channel to allow us to stop short or timeout the task,
    and the second is to provide a value. In effect, our usage of `context` here is
    violating SRP and, as such, risks potential confusion and results in a greater
    resistance to change.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到问题了吗？我们正在使用`context`接口，这是很棒并且强烈推荐的，但我们正在违反ISP。作为务实的程序员，我们可以争辩说这个接口被广泛使用和理解，定义我们自己的接口来将其减少到我们需要的两种方法是不必要的。在大多数情况下，我会同意，但在这种特殊情况下，我们应该重新考虑。我们在这里使用`context`接口有两个完全不同的目的。第一个是控制通道，允许我们提前停止或超时任务，第二个是提供一个值。实际上，我们在这里使用`context`违反了SRP，并且因此存在潜在的混淆风险，并且导致更大的变更阻力。
- en: 'What happens if we decide to use the stop channel pattern not on a request
    level, but at the application level? What happens if the key value is not in the
    `context`, but from some other source? By applying the ISP, we can separate the
    concerns into two interfaces, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定不在请求级别上使用停止通道模式，而是在应用级别上使用，会发生什么？如果键值不在`context`中，而是来自其他来源会发生什么？通过应用ISP，我们可以将关注点分离为两个接口，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our function now complies with the ISP, and both inputs are free to evolve
    separately. But what happens to the users of this function? Must they stop using
    `context`? Absolutely not. The method can be called as shown in the following
    code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数现在符合ISP，并且两个输入可以分别自由演化。但是这个函数的用户会发生什么？他们必须停止使用`context`吗？绝对不是。该方法可以如下所示调用：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The repeated use of `context` as a parameter likely feels a little weird but,
    as you can see, it''s for a good cause. This leads us to our final advantage of
    the ISP:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用`context`作为参数可能会感觉有点奇怪，但正如你所看到的，这是有充分理由的。这将我们带到了ISP的最后一个优势：
- en: '**ISP helps to decouple the inputs from their concrete implementation, enabling
    them to evolve separately**.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**ISP有助于将输入与其具体实现解耦，使它们能够分别演化**。'
- en: How does this relate to DI?
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与DI有什么关系？
- en: As we have seen, the ISP helps us to break down interfaces to logically separate
    parts, with each part providing a particular feature—a concept sometimes referred
    to as a role interface. By leveraging these role interfaces in our DI, our code
    becomes decoupled from the concrete implementation of the inputs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，ISP帮助我们将接口分解为逻辑上的独立部分，每个部分提供特定的功能——有时被称为角色接口的概念。通过在我们的DI中利用这些角色接口，我们的代码与输入的具体实现解耦。
- en: 'Not only does this decoupling allow parts of the code to evolve separately,
    but it also tends to make it easier to identify test vectors. In the previous
    example, it''s easier to scan through the inputs one at a time and consider their
    possible values and states. This process might result in a list of vectors like
    the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解耦不仅允许代码的各个部分分别演化，而且往往更容易识别测试向量。在前面的例子中，逐个扫描输入并考虑它们可能的值和状态更容易。这个过程可能会导致一个类似下面的向量列表：
- en: '**Test vectors for the *value* input include**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '** *value* 输入的测试向量包括**：'
- en: '**Happy path**: Returns a valid value'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常路径**：返回一个有效值'
- en: '**Error path**: Returns an empty value'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误路径**：返回一个空值'
- en: '**Test vectors for the *monitor* input include**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '** *monitor* 输入的测试向量包括**：'
- en: '**Happy path**: Does not return a done signal'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常路径**：不返回完成信号'
- en: '**Error path**: Immediately returns a done signal'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误路径**：立即返回完成信号'
- en: What does this mean for Go?
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这对Go意味着什么？
- en: In [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never Stop Aiming
    for Better,* we mentioned the popular Go idiom coined by *Jack Lindamood*—*accept
    interfaces, return structs*. Combine this idea with the ISP and things start to
    take off. The resultant functions are very concise about their requirements and,
    at the same time, they are quite explicit regarding their outputs. In other languages,
    we might have to define the outputs in the form of an abstraction or create adapter
    classes to decouple our function from our users entirely. However, given Go's
    support for implicit interfaces, there is no need for this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml)中，我们提到了由*Jack Lindamood*创造的流行Go成语——*接受接口，返回结构体*。将这个想法与ISP结合起来，事情就开始起飞了。由此产生的函数对其需求非常简洁，同时对其输出也非常明确。在其他语言中，我们可能需要以抽象的形式定义输出，或者创建适配器类来完全解耦我们的函数和用户。然而，由于Go支持隐式接口，这是不需要的。
- en: 'Implicit interfaces are a language feature whereby the implementor (that is,
    the struct) does not need to define the interfaces that it implements, but rather
    only needs to define the appropriate methods to satisfy the interface, as shown
    in the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式接口是一种语言特性，实现者（即结构体）不需要定义它实现的接口，而只需要定义适当的方法来满足接口，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This might seem like a neat trick to cut down on typing, and it is. However,
    that is not the only reason to use it. When using explicit interfaces, the implementing
    object becomes somewhat coupled with its dependents as there is a rather explicit
    link between them. However, perhaps the most significant reason is simplicity.
    Let''s look at one of the most popular interfaces in Go that you''ve probably
    never heard of:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像一个简洁的技巧，而且确实是。但这并不是使用它的唯一原因。当使用显式接口时，实现对象与其依赖对象之间存在一定的耦合，因为它们之间有一个相当明确的链接。然而，也许最重要的原因是简单性。让我们来看一下Go中最流行的接口之一，你可能从未听说过的：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This interface might not look impressive, but the fact that the `fmt` package
    supports this interface allows you to do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口可能看起来并不令人印象深刻，但`fmt`包支持这个接口的事实使你能够做到以下几点：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we had explicit interfaces, imagine how many times we would have to declare
    that we implement `Stringer`. Perhaps where implicit interfaces give us the most
    significant advantage in Go is when they are combined with the ISP and DI. The
    combination of the three allows us to define input interfaces that are thin, specific
    to the particular use case, and decoupled from everything else, as we saw with
    the `Stringer` interface.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有显式接口，想象一下我们将不得不声明我们实现`Stringer`多少次。也许在Go中，隐式接口给我们带来的最大优势是当它们与ISP和DI结合使用时。这三者的结合允许我们定义输入接口，这些接口很薄，特定于特定用例，并且与其他所有内容解耦，就像我们在`Stringer`接口中看到的那样。
- en: Furthermore, defining interfaces in the package in which they are used narrows
    the scope of knowledge required to work on a piece of code, which in turn makes
    it much easier to understand and test.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在使用的包中定义接口会缩小对工作在一段代码上所需的知识范围，从而使理解和测试变得更加容易。
- en: Dependency inversion principle (DIP)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转原则（DIP）
- en: '"High level modules should not depend on low level modules. Both should depend
    on abstractions. Abstractions should not depend upon details. Details should depend
    on abstractions"'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: “高级模块不应依赖于低级模块。两者都应依赖于抽象。抽象不应依赖于细节。细节应依赖于抽象”
- en: –Robert C. Martin
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: -罗伯特C.马丁
- en: 'Have you ever found yourself standing in a shoe store wondering if you should
    get the brown or the black pair, only to get home and regret your choice? Sadly,
    once you''ve bought them, they''re yours. Programming against concrete implementations
    is the same thing: once you choose, you are stuck with it, refunds and refactoring
    notwithstanding. But why choose when you don''t have to? Look at the relationship
    shown in the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有发现自己站在鞋店里犹豫是买棕色还是黑色的鞋子，然后回家后后悔自己的选择？不幸的是，一旦你买了它们，它们就是你的了。针对具体实现进行编程也是一样的：一旦你选择了，你就被困住了，退款和重构都不管用。但为什么要选择，当你不必选择？看看下图中显示的关系：
- en: '![](img/d884c295-071e-4718-94e8-a3147c61a713.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d884c295-071e-4718-94e8-a3147c61a713.png)'
- en: 'Not very flexible, is it?  Let''s convert the relationship into an abstraction:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不太灵活，是吧？让我们将关系转换为抽象：
- en: '![](img/51c1018c-2c1f-4f10-a286-eff0cf163de8.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51c1018c-2c1f-4f10-a286-eff0cf163de8.png)'
- en: That's much better. Everything relies only on nice clean abstractions, satisfying
    both LSP and ISP. The packages are concise and clear, happily satisfying the SRP.
    The code even *seems* to satisfy *Robert C*. *Martin*'*s* description of the DIP,
    but sadly, it doesn't. It's that pesky word in the middle, inversion.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了。一切都只依赖于干净的抽象，满足LSP和ISP。这些包简洁明了，愉快地满足SRP。代码甚至*似乎*满足*Robert C*. *Martin*对DIP的描述，但遗憾的是，它并没有。中间那个讨厌的词，反转。
- en: In our example, the `Shoes` package owns the `Shoe` interface, which is entirely
    logical. However, problems arise when the requirements change. Changes to the
    `Shoes` package are likely to cause the `Shoe` interface to want to change. This
    will, in turn, require the `Person` object to change. Any new features that we
    add to the `Shoe` interface may be not be needed or relevant to the `Person` object.
    Therefore, the `Person` object is still coupled to the `Shoe` package.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Shoes`包拥有`Shoe`接口，这是完全合理的。然而，当需求发生变化时就会出现问题。对`Shoes`包的更改可能会导致`Shoe`接口发生变化。这将进而要求`Person`对象发生变化。我们添加到`Shoe`接口的任何新功能可能不需要或与`Person`对象无关。因此，`Person`对象仍然与`Shoe`包耦合。
- en: 'In order to entirely break this coupling, we need to change the relationship
    from **Person ** uses Shoe to **Person ** requires **Footwear**, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全打破这种耦合，我们需要将关系从**Person**使用Shoe更改为**Person**需要**Footwear**，就像这样：
- en: '![](img/fbac05cb-978c-49ef-b58d-d2dead2306d0.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbac05cb-978c-49ef-b58d-d2dead2306d0.png)'
- en: There are two key points here. Firstly, the DIP forces us to focus on the ownership
    of the abstractions. In our example, that means moving the interface into the
    package where it was used and changing the relationship from *uses* to *requires*;
    it's a subtle difference, but an important one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个关键点。首先，DIP迫使我们专注于抽象的所有权。在我们的例子中，这意味着将接口移动到使用它的包中，并将关系从*uses*更改为*requires*；这是一个微妙的区别，但很重要。
- en: Secondly, the DIP encourages us to decouple usage requirements from implementations.
    In our example, our `Brown Shoes` object implements `Footwear`, but it's not hard
    to imagine a lot more implementations and some might not even be shoes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，DIP鼓励我们将使用要求与实现解耦。在我们的例子中，我们的`Brown Shoes`对象实现了`Footwear`，但很容易想象有更多的实现，有些甚至可能不是鞋子。
- en: How does this relate to DI?
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这与DI有什么关系？
- en: Dependency inversion is very easy to mistake for dependency injection, and many,
    including me for a long time, assume that they are equivalent. But as we have
    seen, dependency inversion focuses on the ownership of the dependencies' abstract
    definition, and DI is focused on using those abstractions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖反转很容易被误解为依赖注入，包括我在内的许多人长期以来都认为它们是等价的。但正如我们所见，依赖反转关注的是依赖项的抽象定义的所有权，而DI则专注于使用这些抽象。
- en: By applying DIP with DI, we end up with very well-decoupled packages that are
    incredibly easy to understand, easy to extend, and simple to test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将DIP与DI结合应用，我们最终得到了非常良好解耦的包，这些包非常容易理解、易于扩展和简单测试。
- en: What does this mean for Go?
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这对Go意味着什么？
- en: We have talked before about Go's support for implicit interfaces and how we
    can leverage that to define our dependencies as interfaces in the same package,
    rather than importing an interface from another package. This approach is DIP.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过Go对隐式接口的支持，以及我们如何利用它在同一个包中将我们的依赖项定义为接口，而不是从另一个包导入接口。这种方法就是DIP。
- en: Perhaps your inner skeptic is going crazy, yelling, *but this would mean I would
    have to define interfaces everywhere!* Yes, that might be true. It could even
    result in a small amount of duplication. You will find, however, that the interfaces
    you would have defined without dependency inversion would have been fatter and
    more unwieldy, a fact that would have cost you more to work with in the future.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你内心的怀疑者正在疯狂地大喊，“但这意味着我到处都要定义接口！”是的，这可能是真的。这甚至可能导致一些重复。然而，你会发现，没有依赖倒置的情况下你定义的接口会更加臃肿和难以控制，这个事实将会在未来给你带来更多的工作成本。
- en: After applying DIP, you are unlikely to have any circular dependency issues.
    In fact, you will almost certainly find that the number of imports in your code
    drops significantly and your dependency graph becomes rather flat. In fact, many
    packages will only be imported by the `main` package.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 应用DIP后，你不太可能遇到任何循环依赖的问题。事实上，你几乎肯定会发现你的代码中导入的数量显著减少，你的依赖图变得相当扁平。事实上，许多包只会被`main`包导入。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this brief introduction of SOLID design principles, we learned how they apply
    not only to DI, but also to Go. During our examination of the various DI methods
    in the second section of this book, we will frequently reference these principles.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对SOLID设计原则的简要介绍中，我们了解到它们不仅适用于DI，还适用于Go。在本书第二部分对各种DI方法的讨论中，我们将经常引用这些原则。
- en: In the next chapter, we will continue to examine the aspects of coding that
    should be at the forefront of your mind when studying and experimenting with new
    techniques. I will also introduce you to a few handy tools that will make your
    coding life a little easier.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续研究应该在你学习和尝试新技术时放在首要位置的编码方面。我还会向你介绍一些方便的工具，让你的编码生活变得更加轻松。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does the single responsibility principle improve Go code?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一职责原则如何改进Go代码？
- en: How does the open/closed principle improve Go code?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开闭原则如何改进Go代码？
- en: How does the liskov substitution principle improve Go code?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则如何改进Go代码？
- en: How does the interface segregation principle improve Go code?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口隔离原则如何改进Go代码？
- en: How does the dependency inversion principle improve Go code?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖倒置原则如何改进Go代码？
- en: How is dependency inversion different from dependency injection?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖倒置与依赖注入有何不同？
- en: Further reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Packt has many other great resources for learning about SOLID principles:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Packt还有许多其他关于学习SOLID原则的优秀资源：
- en: '[https://www.packtpub.com/mapt/book/application_development/9781787121300/1](https://www.packtpub.com/mapt/book/application_development/9781787121300/1)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/mapt/book/application_development/9781787121300/1](https://www.packtpub.com/mapt/book/application_development/9781787121300/1)'
- en: '[https://www.packtpub.com/mapt/book/application_development/9781785884375/10/ch10lvl1sec50/the-solid-principles](https://www.packtpub.com/mapt/book/application_development/9781785884375/10/ch10lvl1sec50/the-solid-principles)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/mapt/book/application_development/9781785884375/10/ch10lvl1sec50/the-solid-principles](https://www.packtpub.com/mapt/book/application_development/9781785884375/10/ch10lvl1sec50/the-solid-principles)'
- en: '[https://www.packtpub.com/mapt/book/application_development/9781785280832/8](https://www.packtpub.com/mapt/book/application_development/9781785280832/8)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/mapt/book/application_development/9781785280832/8](https://www.packtpub.com/mapt/book/application_development/9781785280832/8)'
