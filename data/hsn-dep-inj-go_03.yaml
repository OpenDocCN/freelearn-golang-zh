- en: Coding for User Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为用户体验编码
- en: In this chapter, we will examine several often overlooked, but valuable, aspects
    of programming, chiefly testing, user experience, and dependency graphs. While
    these topics might not feel like they have anything to do with; **Dependency Injection**
    (**DI**), they have been included to give you a solid but pragmatic foundation
    from which you can evaluate the techniques in the second part of this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究编程中经常被忽视但有价值的几个方面，主要是测试、用户体验和依赖图。虽然这些主题可能看起来与**依赖注入**（DI）没有任何关系，但它们被包含在内是为了给你一个坚实但务实的基础，以便你可以评估本书第二部分的技术。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Optimizing for humans
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为人类进行优化
- en: A security blanket named *unit tests*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为*单元测试*的安全保障。
- en: Test-induced damage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试诱发的损害
- en: Visualizing your package dependencies with Godepgraph
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Godepgraph可视化您的包依赖关系
- en: Discovering a good user experience
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现良好的用户体验
- en: A good user experience does not need to be divined. It does not need to be handed
    down from some experienced guru either. In fact, the problem with experience is
    that what is easy, simple, and obvious to you today is vastly different from what
    it was last month, last year, or when you were starting out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的用户体验不需要被推测。它也不需要从一些有经验的大师那里传授。事实上，经验的问题在于，今天对你来说容易、简单和明显的东西与上个月、去年或你刚开始时大不相同。
- en: A good UX can be discovered through logic, persistence, and practice. To find
    out what a good UX looks like for your user, you can apply my UX discovery survey.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逻辑、坚持和实践可以发现良好的UX。要找出对于你的用户来说良好的UX是什么样的，你可以应用我的UX发现调查。
- en: 'Ask yourself the following four questions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问问自己以下四个问题：
- en: Who is the user?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁是用户？
- en: What are your users capable of?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的用户有什么能力？
- en: Why do users want to use your code?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户为什么想要使用你的代码？
- en: How do your users expect to use it?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的用户希望如何使用它？
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need a basic understanding of Go.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要对Go有基本的了解。
- en: All code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch03](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch03](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch03)找到。
- en: Optimizing for humans
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为人类进行优化
- en: In recent years, we have seen the rise of the term UX, which stands for user
    experience. At its core, UX is about usability—understanding the user and crafting
    interactions and interfaces to be more intuitive or more natural for them to use.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，我们看到了UX这个术语的兴起，它代表用户体验。在其核心，UX是关于可用性的——理解用户并设计交互和界面，使其对他们更直观或更自然。
- en: UX typically refers to customers, which makes sense—that is, after all, where
    the money is. However, we programmers are missing out on something rather significant.
    Let me ask you, who are the users of the code you write? Not the customers that
    use the software itself. The users of the code are your colleagues and the future
    version of you. Would you like to make their life easier? Put in a different way,
    would you rather spend your future trying to figure out the purpose of a piece
    of code or extending the system? That is where the money is. As programmers, we
    get paid to deliver features rather than beautiful code, and code with good UX
    enables the faster delivery of features, and with less risk.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UX通常指的是客户，这是有道理的，毕竟那里有钱。然而，我们程序员错过了一些相当重要的东西。让我问你，你写的代码的用户是谁？不是使用软件本身的客户。代码的用户是你的同事和未来的你。你想让他们的生活更轻松吗？换句话说，你宁愿花时间去弄清楚一段代码的目的，还是扩展系统？那里才有钱。作为程序员，我们得到的报酬是交付功能，而不是美丽的代码，而具有良好UX的代码可以更快地交付功能，并且风险更小。
- en: What does user experience mean for Go code?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于Go代码，用户体验意味着什么？
- en: What does UX mean for Go code? The short version is, *we should write code whose
    general intent is understood after a quick first read by any competent programmer*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go代码，UX意味着什么？简而言之，*我们应该编写代码，任何有能力的程序员在第一次阅读后就能理解其一般意图*。
- en: Did that sound a bit like hand waving? Yeah, it might be hand waving. It's a
    standard problem with solving problems in any creative endeavor; you know it when
    you see it, and you feel it when it doesn't exist. Perhaps the main reason it
    is so hard to define is that the definition of *competence *varies significantly
    based on the members of the team and the environment. Similarly, the reason it
    is often hard to achieve is due to the fact that code inherently makes more sense
    to the author than anyone else.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点像挥手吗？是的，可能是挥手。这是解决任何创造性努力中的问题的标准问题；当你看到它时，你知道它，当它不存在时，你会感觉到它。也许定义*能力*的问题主要是因为团队成员和环境的定义差异很大。同样，很难实现的原因也在于代码本身对作者来说比其他人更容易理解。
- en: But first, let's look at some simple principles to start off in the right direction.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看一些简单的原则，以便朝着正确的方向开始。
- en: Start with simple – get complicated only when you must
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单开始——只有在必要时才变得复杂
- en: 'As programmers, we should always strive to keep things simple, and resort to
    complexity when there is no other way. Let''s see this principle in action. Try
    to determine what this next example does in three seconds or less:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们应该始终努力保持简单，并在没有其他办法时才求助于复杂。让我们看看这个原则是如何实施的。试着在三秒钟内确定下一个示例的作用：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'How about this one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个怎么样：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Applying the approach embodied in the first code to an entire system will almost
    certainly make it run faster, but not only did it likely take longer to code,
    but it's also harder to read and therefore maintain and extend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个代码中体现的方法应用到整个系统几乎肯定会使其运行更快，但不仅编码可能需要更长时间，而且阅读起来也更困难，因此维护和扩展也更困难。
- en: There will be times when you need to extract extreme performance from your code,
    but it's far better to wait until it cannot be avoided before burdening yourself
    with the extra complexity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要从代码中提取极端的性能，但最好等到无法避免时再增加额外的复杂性。
- en: Apply just enough abstraction
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只应用足够的抽象
- en: 'Excessive abstraction leads to an excessive mental burden and excessive typing.
    While some may argue that any code fragment that could be swapped out or extended
    later deserves an abstraction, I would argue for a more pragmatic approach. Implement
    enough to deliver the business value we are tasked with and then refactor as needed.
    Look at the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 过度的抽象会导致过度的心理负担和过度的打字。虽然有人可能会认为任何可以在以后交换或扩展的代码片段都应该有一个抽象，但我会主张更加务实的方法。实现足够的内容以交付我们所负责的业务价值，然后根据需要进行重构。看看以下代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compare the previous code to the following usage of the commonly understood
    concept:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码与以下常见概念的使用进行比较：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Follow industry, team, and language conventions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循行业、团队和语言约定
- en: Concepts, variables, and function names all *just make sense *when they follow
    conventions. Ask yourself, if you are working on a system about cars, what would
    you expect a variable called `flower` to be?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当概念、变量和函数名称遵循约定时，它们都*很容易理解*。问问自己，如果你在一个关于汽车的系统上工作，你会期望一个名为`flower`的变量是什么？
- en: Coding style is arguably something that Go got right. For many years, I was
    part of the *bracket placement *and the *tab versus spaces *wars, but when switching
    to Go, all of that changed. There is a fixed, documented, and easily reproducible
    style—run `gofmt`, problem solved. There are still some places where you can hurt
    yourself. Coming from a language with unchecked exceptions, you might be tempted
    to use Go's `panic()` phrase; while possible, it is one of several conventions
    explicitly discouraged in the official Code Review Comments wiki ([https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编码风格可以说是Go做对的事情。多年来，我一直参与*括号放置*和*制表符与空格*之争，但转到Go后，一切都改变了。有一个固定的、有文档的、易于重现的风格——运行`gofmt`，问题解决了。仍然有一些地方你可能会伤害到自己。从一个没有检查异常的语言转过来，你可能会想要使用Go的`panic()`短语；虽然可能，但这是官方代码审查评论维基明确不鼓励的约定之一（[https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments)）。
- en: Team conventions are a little bit harder to define, and perhaps sometimes to
    follow. Should a variable of the `channel` type be called `result`, `resultCh`,
    or `resultChan`? I have seen, and probably written, all three.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 团队约定有点难以定义，有时也难以遵循。`channel`类型的变量应该叫做`result`、`resultCh`还是`resultChan`？我见过，也可能写过，这三种情况都有。
- en: How about error logging? Some teams like to log errors at the point at which
    they are triggered, and others prefer to do so at the top of the call stack. I
    have a preference, as I am sure you do, but I have yet to see an overwhelmingly
    compelling argument for either.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 错误日志记录呢？有些团队喜欢在触发错误的地方记录错误，而其他人更喜欢在调用堆栈的顶部这样做。我有自己的偏好，我相信你也有，但我还没有看到一个非常有说服力的论点支持其中任何一种。
- en: Export only what you must
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只导出必要的内容
- en: 'When you are careful and stingy about your exported API, many good things happen.
    Chiefly, it becomes easier for others to understand; when a method has fewer parameters,
    it is naturally easier to understand. Look at the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对你的导出API小心谨慎时，会发生很多好事。主要的是，它变得更容易让其他人理解；当一个方法有更少的参数时，它自然更容易理解。看看以下代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What does `true` mean? It''s hard to tell without opening the function or the
    documentation. However, what if we do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`是什么意思？不打开函数或文档很难说。但是，如果我们这样做呢：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the purpose is clear, mistakes are unlikely and, as a bonus, encapsulation
    is improved.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，目的是明确的，错误不太可能发生，而且封装性得到了改善。
- en: 'Similarly, interfaces and structs with fewer methods and packages with objects
    are all easier to understand, and are more likely to have a more definite purpose.
    Let''s look at another example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，具有较少方法和对象的接口和结构以及包更容易理解，更有明确的目的。让我们看另一个例子：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compare the preceding code to the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码与以下进行比较：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Yes, in both of these cases, the result was more code. More straightforward
    code, but more code nonetheless. Providing a better UX for users will frequently
    incur a little bit more cost, but the productivity gains for the users are multiplicative.
    Considering the fact that, in many cases, one of the users of the code that you
    write is future you, you could say that a bit of extra work now saves you lots
    of work in the future.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，在这两种情况下，结果都是更多的代码。更直接的代码，但无论如何都更多的代码。为用户提供更好的用户体验通常会带来一些额外的成本，但用户的生产力收益是成倍增加的。考虑到，在许多情况下，你编写的代码的用户之一是未来的你，你可以说现在多做一点额外的工作会为你节省大量的未来工作。
- en: Continuing along the line of looking out for *future me*, the second advantage
    this approach offers is it makes it easier to change your mind. Once a function
    or type is exported, it can be used; once used, it has to be maintained and takes
    much more effort to change. This approach makes such changes easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 继续关注*未来的我*，这种方法提供的第二个优势是更容易改变主意。一旦一个函数或类型被导出，它就可以被使用；一旦被使用，就必须被维护，并且更改需要付出更多的努力。这种方法使这些更改变得更容易。
- en: Aggressively apply the single responsibility principle
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积极应用单一职责原则
- en: As we saw in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, applying the **single responsibility principle** (**SRP**)
    encourages objects to be more concise and more coherent and therefore easier to
    understand.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中看到的，*Go的SOLID设计原则*，应用**单一职责原则**（**SRP**）鼓励对象更简洁、更连贯，因此更容易理解。
- en: Who is the user?
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁是用户？
- en: Much of the time, the answer will be *future me *and my colleagues. Your *future
    me *will be a better, smarter, and more handsome version of who you are now. Your
    colleagues, on the other hand, are harder to predict. If it helps, we can avoid
    considering the smart, fantastic ones; hopefully, whatever we do, they will understand.
    An intern, on the other hand, will be harder to predict. Chances are that if we
    can make our code make sense to them, then it will be just fine for everyone else.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间，答案将是“未来的我”和我的同事。你的“未来的我”将会是一个更好、更聪明、更英俊的版本。另一方面，你的同事则更难预测。如果有帮助的话，我们可以避免考虑那些聪明、了不起的人；希望无论我们做什么，他们都能理解。然而，实习生则更难预测。如果我们的代码能让他们理解，那么对其他人来说也就没问题了。
- en: If you ever have the chance to write software libraries for company-wide or
    general use, then this answer becomes a whole lot harder. In general, you want
    to aim low and only depart from a standard and straightforward format when there
    is no other choice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有机会为公司范围或一般用途编写软件库，那么这个问题就会变得更加困难。一般来说，你希望目标低，只有在没有其他选择时才离开标准和简单的格式。
- en: What are your users capable of?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的用户有什么能力？
- en: 'Now that we are clear on who the users are, we can develop a better understanding
    of their worldview. There is likely a massive disparity between the skills, experience,
    and domain knowledge between you and your users, and even between you and future
    you. This where most technical tools and software libraries fail. Think back to
    when you just started with Go. What did your code look like? Were there any language
    features in Go that you weren''t using yet? Personally, I come from a Java background
    and, because of this, I entered the field with some preconceived ideas:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们清楚了用户是谁，我们就可以更好地理解他们的世界观。你和你的用户之间，甚至你和未来的你之间的技能、经验和领域知识可能存在巨大的差异。这就是大多数技术工具和软件库失败的地方。回想一下你刚开始使用Go的时候。你的代码是什么样子的？在Go中有没有一些语言特性是你还没有使用过的？就我个人而言，我来自Java背景，因此我带着一些先入为主的观念进入这个领域：
- en: I thought that threads were expensive (and that goroutines were threads)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我以为线程很昂贵（而goroutine就是线程）
- en: I thought that everything had to be in a struct
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我以为一切都必须在一个结构体中
- en: Being used to explicit interfaces meant that I was not as enthusiastic about
    using the **interface segregation principle** (**ISP**) or the **dependency inversion
    principle** (**DSP**) as I am now
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 习惯于显式接口意味着我对使用**接口隔离原则**（**ISP**）或**依赖反转原则**（**DSP**）的热情不如现在
- en: I didn't understand the power of channels
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我不理解通道的威力
- en: Passing lambdas around blew my mind
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递lambda让我大开眼界
- en: 'Over time, I have seen these sorts of things pop up over and over, particularly
    in code-review comments. There is quite an effective way of answering the question: *What
    are the users capable of? *Write an example and ask your colleagues the following
    questions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我看到这些事情一次又一次地出现，特别是在代码审查的评论中。回答问题“你的用户有什么能力？”有一种非常有效的方法：写一个例子，然后问你的同事以下问题：
- en: What does this do?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是做什么的？
- en: How would you have done it?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会怎么做？
- en: What do you expect this function to do?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你期望这个函数做什么？
- en: If you don't have any users that you can quiz, another option is to ask yourself,
    *What else exists that is similar?* I am not suggesting that you follow other
    people's mistakes. The basic theory here is that if something else exists, and
    your users are comfortable with it then, if yours is similar, they will not have
    to learn to use it. This was perhaps best illustrated to me when using lambdas.
    Colleagues from a functional background were happy with it, but those from an
    object-oriented background found it either somewhat confounding or just not intuitive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有任何可以询问的用户，另一个选择是问自己，“还有什么类似的东西存在？”我并不是建议你跟随别人的错误。基本理论是，如果其他类似的东西存在，而你的用户对它感到舒适，那么如果你的东西类似的话，他们就不必学习如何使用。这在我使用lambda时给我留下了深刻的印象。来自函数式背景的同事对此很满意，但来自面向对象背景的同事则觉得有些困惑或者不直观。
- en: Why do users want to use your code?
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户为什么想要使用你的代码？
- en: The answer to the question of why your users would want to use your code could
    be long and varied. If it is, you might want to go back and re-read the *SRP*
    section. Beyond being able to split the code into smaller, more concise chunks,
    we need to make a list. We will apply the 80/20 rule to this list. Typically,
    80% of usage comes from 20% of the use cases. Let me put this into perspective
    with an example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回答为什么你的用户想要使用你的代码的问题可能是长而多样的。如果是这样，你可能需要回去重新阅读*SRP*部分。除了能够将代码分割成更小、更简洁的块之外，我们还需要列出一个清单。我们将这个清单应用到80/20法则上。通常，80%的使用来自20%的用例。让我用一个例子来解释一下。
- en: 'Consider an **automated teller machine** (**ATM**). A list of its use cases
    might look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个**自动取款机**（**ATM**）。它的用例列表可能如下所示：
- en: Withdraw money
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取款
- en: Deposit money
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存款
- en: Check balance
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询余额
- en: Change PIN code
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改PIN码
- en: Transfer money
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转账
- en: Deposit check
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存款支票
- en: I reckon that on at least 80% of the occasions that a person uses an ATM, their
    purpose is to withdraw money. So what can we do with this information? We can
    optimize the interface to make the most common use cases as convenient as possible.
    In the case of the ATM, it could be as simple as putting the withdraw function
    on the first screen at the top so that users don't have to search for it. Now
    that we understand what our users are trying to achieve, we can build on this
    and consider how they expect to use it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我估计一个人使用自动取款机的至少80%的目的是取钱。那么我们可以怎么利用这个信息呢？我们可以优化界面，使最常见的用例尽可能方便。对于自动取款机来说，可能只需要在第一个屏幕的顶部放置取款功能，这样用户就不必搜索了。既然我们了解了用户想要实现什么，我们可以在此基础上继续思考他们期望如何使用它。
- en: How do they expect to use it?
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 他们期望如何使用它？
- en: 'While the ATM example was clear, it was a system, and so you may be wondering
    how that could possibly apply to low-level concepts, such as functions. Let''s
    look at an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 ATM 的例子很清楚，但它是一个系统，所以你可能会想知道它如何可能适用于诸如函数之类的低级概念。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That probably looks OK, right? The problem is that most of the usage looks
    like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能还不错，对吧？问题是大多数使用看起来像下面这样：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, most of the time we don't need all of those return values, and
    many of the inputs are ignored.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，大多数情况下我们并不需要所有这些返回值，而且许多输入都被忽略了。
- en: The first step to addressing this sort of situation is to look at the under-used
    parts of the code and ask yourself, do we really need them? If they exist only
    for testing, then it means they are *test-induced damage*, which we will look
    at later in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种情况的第一步是查看代码中未被充分利用的部分，并问自己，我们真的需要它们吗？如果它们只存在于测试中，那么它们就是“测试诱导的破坏”，我们将在本章后面讨论。
- en: If they exist for some infrequently used but compelling use case, then we can
    address it another way. The first option would be to split the function into multiple
    parts; this would allow users to adopt only the complexity they need. The second
    option is to merge the configuration into an object, allowing users to ignore
    the parts they don't use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们存在于一些不经常使用但引人注目的用例中，那么我们可以用另一种方式来解决。第一种选择是将函数分成多个部分；这将允许用户只采用他们需要的复杂性。第二个选择是将配置合并到一个对象中，允许用户忽略他们不使用的部分。
- en: In both approaches, we are providing *reasonable defaults*, reducing the mental
    burden of the function by allowing users to only worry about what they need.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，我们提供“合理的默认值”，通过允许用户只关注他们需要的内容来减少函数的心理负担。
- en: When to compromise
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时妥协
- en: Having a great user experience is a desirable goal, but is not a necessity.
    There are always going to be situations where the UX needs to be compromised.
    The first and perhaps most common situation is team evolution.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有出色的用户体验是一个值得追求的目标，但并非必需。总会有一些情况下需要牺牲用户体验。第一个，也许是最常见的情况是团队的发展。
- en: As the team evolves and becomes more experienced with Go, it will inevitably
    find that some early software patterns no longer seem as effective. These might
    include things such as the use of global, panic, and loading configurations from
    environment variables, or even when to use functions rather than objects. As the
    team evolves, so does their definition of both good software and what is standard
    or intuitive.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着团队的发展和对 Go 的经验增加，他们将不可避免地发现一些早期的软件模式不再那么有效。这些可能包括全局变量的使用、panic、从环境变量加载配置，甚至何时使用函数而不是对象。随着团队的发展，他们对良好软件的定义以及标准或直观的定义也在发生变化。
- en: The second, and in many cases, an overused excuse for poor UX, is performance.
    As we saw in an early example in this chapter, it's often possible to write faster
    code, but the faster code is often harder to understand. The best option here
    is to optimize it for humans first and then, only when the system has proven to
    not be quick enough, optimize it for speed. Even then, these optimizations should
    be selectively applied to those parts of the system that are shown, by measurement,
    to be worth the effort to refactor and the long-term cost of less-than-ideal UX.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，而且在许多情况下，是对糟糕用户体验的过度使用的借口，是性能。正如我们在本章的早期例子中看到的，通常可以编写更快的代码，但更快的代码通常更难理解。这里的最佳选择是首先为人类优化，然后，只有当系统被证明不够快时，才为速度进行优化。即使在这种情况下，这些优化也应该有选择地应用于系统中那些经过测量证明值得重构和长期成本低于理想用户体验的部分。
- en: The last situation is visibility; sometimes, you just can't see what a good
    UX might be. In these cases, the more effective option is to implement and then
    iteratively refactor based on usage and any inconveniences that arise.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是可见性；有时，你就是看不到一个好的用户体验可能是什么。在这些情况下，更有效的选择是实施，然后根据使用和出现的任何不便逐步进行重构。
- en: Final thoughts on coding for user experience
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于为用户体验编码的最后思考
- en: 'Programmer time, your time, is expensive; you should conserve it in preference
    of CPU time. The user experience for developers is challenging because of our
    inherent need to solve problems and deliver useful software. However, it is possible
    to conserve programmer time. Try to remember the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的时间，你的时间，是昂贵的；你应该节约它以优先考虑 CPU 时间。开发人员的用户体验是具有挑战性的，因为我们天生就有解决问题和交付有用软件的需求。然而，节约程序员的时间是可能的。试着记住以下几点：
- en: Making something more configurable doesn't make it more usable—it makes it more
    confusing to use
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使某物更具配置性并不会使其更易用，而是使其更令人困惑
- en: Designing for all use cases makes the code inconvenient for everyone
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有用例设计会使代码对每个人都不方便
- en: User competence and expectations play a prominent role in how your code is perceived,
    and in its adoption
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的能力和期望在你的代码被感知以及被采用方面起着重要作用
- en: Perhaps most pertinent—it is always better and easier to change the UX to match
    the user than the other way around.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要的是，改变用户体验以适应用户总是更好、更容易，而不是相反。
- en: A security blanket named unit tests
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个名为单元测试的安全保障。
- en: Many folks will tell you, *you must write unit tests for your code; they make
    sure you have no bugs*. They really don't do that at all. Nor do I write unit
    tests because someone tells me I must. I write unit tests for what they do for
    me. Unit tests are empowering. They actually reduce the amount of work I have
    to do. Perhaps these are not justifications you have heard before. Let's explore
    them in a little more detail.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人会告诉你，“你必须为你的代码编写单元测试；它们可以确保你没有错误”。它们实际上根本不这样做。我写单元测试不是因为有人告诉我必须这样做，而是因为它们对我有用。单元测试是有力的。它们实际上减少了我需要做的工作量。也许这些不是你以前听过的理由。让我们更详细地探讨一下。
- en: '**Unit tests give you the freedom and confidence to refactor**: I love to refactor,
    perhaps a little too much, but that''s a different topic. Refactoring allows me
    to experiment with varying styles of code, implementations, and UX. By having
    unit tests in place, I can be adventurous and confident that I don''t unintentionally
    break anything along the way. They can also give you the courage to try new technologies,
    libraries, or coding techniques.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试给您重构的自由和信心：我喜欢重构，也许有点过分，但这是另一个话题。重构让我可以尝试不同风格的代码、实现和UX。通过进行单元测试，我可以大胆尝试，并且有信心不会无意中破坏任何东西。它们还可以让您有勇气尝试新技术、库或编码技术。
- en: '**Existing unit tests make adding new features easier**: As we have mentioned
    before, adding new features does incur some risk—risk that we might break something.
    Having the tests in place provides a safety net that allows us to be less mindful
    of what already exists and focus more on adding the new feature. It might seem
    counterintuitive, but unit tests actually make you move faster. As the system
    expands, having a safety blanket of unit tests allows you to proceed with confidence
    and not to have to worry about the things you might break.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的单元测试使添加新功能变得更容易：正如我们之前提到的，添加新功能确实会带来一些风险——我们可能会破坏某些东西。有了测试，就提供了一个安全网，让我们不那么在意已经存在的东西，更专注于添加新功能。这可能看起来有些反直觉，但单元测试实际上让您更快地前进。随着系统的扩展，有了单元测试的安全保障，您可以自信地继续前进，而不必担心可能会破坏的东西。
- en: '**Unit tests prevent repeated regression**: There is no way around it—regression
    sucks. It makes you look bad and it causes you extra work, but it''s going to
    happen. The best we can hope for is to not repeatedly fix the same bug. While
    tests do prevent some regression, they cannot stop it all. By writing a test that
    fails because of the bug and then fixing the bug, we achieve two things. First,
    we know when the bug is fixed because the test passes. Second, the bug does not
    happen again.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以防止重复的回归：无论如何，回归都很糟糕。它会让你看起来很糟糕，还会让你额外工作，但它是会发生的。我们最希望的是不要反复修复同一个错误。虽然测试确实可以防止一些回归，但它们无法完全阻止。通过编写一个由于错误而失败的测试，然后修复错误，我们实现了两件事。首先，我们知道错误何时被修复，因为测试通过了。其次，错误不会再次发生。
- en: '**Unit tests document your intent**: While I am not trying to suggest that
    tests can replace documentation, they are explicit, executable expressions of
    what you intended when you wrote the code. This is an exceptionally desirable
    quality when working in a team. It allows you to work on any part of the system
    without worrying about breaking code written by others or even perhaps fully understanding
    it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试记录了您的意图：虽然我并不是在暗示测试可以取代文档，但它们是您编写代码时所期望的明确、可执行的表达。这在团队中工作时是一个非常可取的品质。它允许您在系统的任何部分工作，而不必担心破坏他人编写的代码，甚至可能完全理解它。
- en: '**Unit tests document your requirements from a dependency**: In the second
    section of this book, we will work through some examples of applying DI to an
    existing code base. A significant part of this process will include grouping and
    extracting functionality into abstractions. These abstractions naturally become
    *units of work*. Each unit is then tested individually and in isolation. These
    tests are consequently more focused, and are easier to write and maintain.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试记录了您对依赖项的需求：在本书的第二部分中，我们将通过一些示例来应用DI到现有的代码库中。这个过程的一个重要部分将包括将功能分组并提取到抽象中。这些抽象自然成为*工作单元*。然后分别对每个单元进行测试并隔离。因此，这些测试更加专注，更容易编写和维护。
- en: 'Additionally, the tests on code that uses DI will often focus on how that function
    uses and reacts to the dependency. These tests effectively define the requirements
    contract for the dependency and help to prevent regression. Let''s look at an
    example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对使用DI的代码进行测试通常会关注该函数如何使用和对依赖项做出反应。这些测试有效地定义了依赖项的需求合同，并有助于防止回归。让我们看一个例子：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this code expects the dependency to behave in a certain way.
    While the tests do not enforce this behavior from the dependency, they do serve
    to define this code's requirements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这段代码期望依赖项以某种方式运行。虽然测试不会强制执行依赖项的行为，但它们确实有助于定义代码的需求。
- en: '**Unit tests can help restore confidence and increase understanding**: Do you
    have code in your system that you don''t dare to change because if you do, something
    will break? How about code where you are really not sure what it does? Unit tests
    are fantastic for both of these situations. Writing tests against this code is
    an unobtrusive way to both learn what it does and validate that it does what you
    think it does. These tests have the added bonus that they can also be used as
    regression prevention for any future changes and to teach others what this code
    does.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以帮助恢复信心并增加理解：您的系统中是否有您不敢更改的代码，因为如果更改，会有东西会出错？您是否有一些代码，您真的不确定它是做什么的？单元测试对这两种情况都非常棒。针对这些代码编写测试是一种不显眼的方式，既可以了解它的功能，又可以验证它是否符合您的预期。这些测试的额外好处是它们还可以用作未来任何更改的回归预防，并且可以教给其他人这段代码的功能。
- en: So why do I write unit tests?
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么我为什么要写单元测试？
- en: For me, the most compelling reason to write unit tests is that it makes me feels
    good. It feels great to go home at the end of the day or week and know that everything
    is working as intended and that the tests are making sure of it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，写单元测试最具说服力的原因是它让我感觉良好。在一天或一周结束时，知道一切都按预期工作，并且测试正在确保这一点，感觉真好。
- en: This is not to say that there are no bugs, but there are definitely fewer. Once
    fixed, bugs don't come back, saving me from embarrassment and saving me time.
    And, perhaps most importantly, fixing bugs means fewer support calls at nights
    and weekends because something is broken.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说没有错误，但肯定会更少。一旦修复，错误就不会再次出现，这让我免于尴尬，也节省了时间。也许最重要的是，修复错误意味着晚上和周末的支持电话更少，因为某些东西出了问题。
- en: What should I test?
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我应该测试什么？
- en: 'I wish I had a clear, quantifiable metric to give you as to what you should
    and should not test, but it''s just not that clear. The first rule is definitely
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望能给你一个清晰、可量化的度量标准，告诉你应该测试什么，不应该测试什么，但事情并不那么清楚。第一个规则肯定如下：
- en: '*Don''t test co**de that is too simple break.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要测试太简单的代码。*'
- en: 'This includes language features, such as those shown in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括语言特性，比如以下代码中显示的那些：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This also includes simple functions, as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这也包括简单的函数，就像以下代码中显示的那样：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After that, be pragmatic. We get paid to write code that works; tests are only
    a tool to ensure that it does and continues to do so. It is entirely possible
    to test too much. Excessive tests will not only lead to a lot of extra work, but
    will also cause tests to become brittle and frequently break during refactoring
    or extension.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，要实事求是。我们得到报酬是为了编写能够工作的代码；测试只是确保它确实如此并持续如此的工具。测试过多是完全可能的。过多的测试不仅会导致大量额外的工作，还会导致测试变得脆弱，并在重构或扩展过程中经常出现故障。
- en: 'For this reason, I recommend testing from a slightly higher and more *black-box *level.
    Take a look at the struct in this example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议从稍高且更*黑盒*的层次进行测试。看一下这个例子中的结构：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we were to write tests for each method of this struct, then we will be discouraged
    from refactoring these methods or even extracting them from `Save() `in the first
    place, as we would have to refactor the corresponding tests as well. However,
    if we test the `Save()` method only, which is the only method that is used by
    others, then we can refactor the rest with far less hassle.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为这个结构的每个方法编写测试，那么我们将被阻止重构这些方法，甚至从`Save()`中提取它们，因为我们还需要重构相应的测试。然而，如果我们只测试`Save()`方法，这是其他方法使用的唯一方法，那么我们可以更轻松地重构其余部分。
- en: 'The types of tests are also important. Typically, we should test the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的类型也很重要。通常，我们应该测试以下内容：
- en: '**Happy path**: This is when everything goes as expected. These tests also
    tend to document how to use the code.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快乐路径**：这是一切都如预期那样进行时。这些测试也倾向于记录如何使用代码。'
- en: '**Input errors**: Incorrect and unexpected inputs can often cause the code
    to behave in strange ways. These tests ensure that our code handles these issues
    in a predictable way.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入错误**：不正确和意外的输入通常会导致代码以奇怪的方式运行。这些测试确保我们的代码以可预测的方式处理这些问题。'
- en: '**Dependency issues**: The other common cause of failure is when a dependency
    fails to perform as we need it to, either through coder error (such as regression)
    or environmental issues (such as a missing file or a failed call to a database).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖问题**：另一个常见的失败原因是依赖项未能按我们需要的方式执行，要么是通过编码错误（如回归），要么是通过环境问题（如丢失文件或对数据库的调用失败）。'
- en: Hopefully, by now you are sold on unit tests and are excited by what they can
    do for you. Another often neglected aspect of tests is their quality. By this,
    I'm not talking about use case coverage or code coverage percentage, but the raw
    code quality. It's sadly commonplace to write tests in a manner that we wouldn't
    allow ourselves to write for production code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，你已经对单元测试感到满意，并对它们能为你做些什么感到兴奋。测试经常被忽视的另一个方面是它们的质量。我说的不是用例覆盖率或代码覆盖率百分比，而是原始代码质量。遗憾的是，通常会以一种我们不允许自己用于生产代码的方式编写测试。
- en: 'Duplication, poor readability, and lack of structure are all frequent mistakes.
    Thankfully, these issues can be easily addressed. The first step is just being
    mindful of the problem and applying the same level of effort and skill as we do
    with production code. The second requires breaking out some test-specific techniques;
    there are many but, in this chapter, I will introduce only three. These are as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重复、可读性差和缺乏结构都是常见的错误。幸运的是，这些问题可以很容易地解决。第一步只是注意到这个问题，并且应用与生产代码一样的努力和技能。第二步需要使用一些特定于测试的技术；有很多，但在本章中，我只会介绍三种。它们如下：
- en: Table-driven tests
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表驱动测试
- en: Stubs
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存根
- en: Mocks
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟
- en: Table-driven tests
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表驱动测试
- en: 'Often, while writing tests, you will find that multiple tests for the same
    method result in a lot of duplication. Take this example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在编写测试时，你会发现对同一个方法的多个测试会导致大量的重复。看这个例子：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is nothing surprising, nor wrong with the intent here. Table-driven tests
    acknowledge the need for duplication and extract the variations into a *table*.
    It is this table that then drives a single copy of the code that would otherwise
    have been duplicated. Let''s convert our tests in to table-driven tests:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么令人惊讶的，也没有什么错误的意图。表驱动测试承认了重复的需要，并将变化提取到一个*表*中。正是这个表驱动了原本需要重复的代码的单个副本。让我们将我们的测试转换成表驱动测试：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our tests are now guaranteed to be consistent across all of the scenarios for
    this method, which in turn makes them more effective. If we had to change the
    function signature or call pattern, we have only one place in which to do so,
    resulting in less maintenance cost. Finally, reducing the inputs and outputs to
    a table makes it cheap to add new test scenarios, and helps to identify test scenarios
    by encouraging us to focus on the inputs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试保证在这个方法的所有场景中都是一致的，这反过来使它们更有效。如果我们必须更改函数签名或调用模式，我们只需要在一个地方进行，从而减少维护成本。最后，将输入和输出减少到一个表格中，可以廉价地添加新的测试场景，并通过鼓励我们专注于输入来帮助识别测试场景。
- en: Stubs
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根
- en: Sometimes referred to as *test doubles*, stubs are fake implementations of a
    dependency (that is, an interface) that provides a predictable, usually fixed
    result. Stubs are also used to help exercise code paths, such as errors, that
    otherwise might be very difficult or impossible to trigger.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时被称为*测试替身*，存根是依赖项（即接口）的虚假实现，它提供可预测的、通常是固定的结果。存根也用于帮助执行代码路径，比如错误，否则可能会非常困难或不可能触发。
- en: 'Let''s look at an example interface:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个接口的例子：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s imagine that the production implementation of the fetcher interface
    actually calls an upstream REST service. Using our previous *types of tests *list,
    we want to test for the following scenarios:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设获取器接口的生产实现实际上调用上游REST服务。使用我们之前的*测试类型*列表，我们想测试以下场景：
- en: '**Happy path**: The fetcher returns data'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常路径：获取器返回数据
- en: '**Input error: **The fetcher fails to find the `Person` we requested'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入错误：获取器未能找到我们请求的“人员”
- en: '**System error**: The upstream service is down'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统错误：上游服务宕机
- en: There are more possible tests that we could implement, but this is enough for
    our purposes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现更多可能的测试，但这已经足够满足我们的目的了。
- en: 'Let''s think about how we would have to test without using a stub:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想如果不使用存根，我们将如何进行测试：
- en: '**Happy path**: The upstream service has to be up and working correctly, and
    we would have to make sure we had a valid ID to request at all times.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常路径：上游服务必须正常运行，并且我们必须确保我们随时都有一个有效的ID来请求。
- en: '**Input error**: The upstream service has to be up and working correctly, but
    in this case, we would have to have an ID that was guaranteed to be invalid; otherwise,
    this test would be flaky.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入错误：上游服务必须正常运行，但在这种情况下，我们必须有一个保证无效的ID；否则，这个测试将是不稳定的。
- en: '**System error**: The service would have to be down? If we assume that the
    upstream service belongs to another team or has users other than us, I don''t
    think they would appreciate us shutting down the service every time we needed
    to test. We could configure an incorrect URL for the service, but then we would
    be running different configurations for our different test scenarios.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统错误：服务必须宕机？如果我们假设上游服务属于另一个团队或者有其他用户，我认为他们不会欣赏我们每次需要测试时都关闭服务。我们可以为服务配置一个不正确的URL，但那么我们将为不同的测试场景运行不同的配置。
- en: 'There are a lot of nonprogramming issues with the preceding scenarios. Let''s
    see if a little code can solve the problem:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的场景存在很多非编程问题。让我们看看一点代码是否可以解决问题：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the preceding stub implementation, we can now create one stub instance
    per scenario with a table-driven test, as shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的存根实现，我们现在可以使用表驱动测试为每个场景创建一个存根实例，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, our tests now cannot fail because of the dependency; they no
    longer require anything external to the project itself, and they probably even
    run faster. If you find writing stubs burdensome, I would recommend two things.
    Firstly, check the previous [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go,* on the ISP and see if you can break the interface into
    something smaller. Secondly, check out one of the many fantastic tools in the
    Go community; you are sure to find one that suits your needs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的测试现在不会因为依赖而失败；它们不再需要项目本身之外的任何东西，而且它们可能运行得更快。如果你觉得编写存根很繁琐，我建议两件事。首先，查看之前的[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)，*Go的SOLID设计原则*，看看你是否可以将接口分解成更小的部分。其次，查看Go社区中的众多优秀工具之一；你肯定会找到一个适合你需求的工具。
- en: Excessive test coverage
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度的测试覆盖
- en: 'Another problem that could arise is excessive test coverage. Yes, you read
    that right. Writing too many tests is possible. Programmers, being the technically
    minded folks that we are, love metrics. Unit-test coverage is one such metric.
    While it is possible to achieve 100% test coverage, realizing this goal is a huge
    time sink, and the resulting code can be rather terrible. Consider the following
    code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能出现的问题是过度的测试覆盖。是的，你没看错。写太多的测试是可能的。作为技术思维的程序员，我们喜欢度量。单元测试覆盖率就是这样一种度量。虽然可能实现100%的测试覆盖率，但实现这个目标是一个巨大的时间浪费，而且结果可能相当糟糕。考虑以下代码：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To achieve 100% coverage, we would have to write a test where the `destination.Close()`
    call fails. We can totally do this, but what would it achieve? What would we be
    testing? It would give us another test to write and maintain. If this line of
    code doesn''t work, would you even notice? How about this example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现100%的覆盖率，我们需要编写一个测试，其中“destination.Close（）”调用失败。我们完全可以做到这一点，但这会实现什么？我们将测试什么？这将给我们另一个需要编写和维护的测试。如果这行代码不起作用，你会注意到吗？比如这个例子：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, we can totally test for that. But would we really be testing? In this
    case, we'd be testing that the JSON package in the Go standard library works as
    it's supposed to. External SDKs and packages should have their own tests so that
    we can just trust that they do what they claim. If this is not the case, we can
    always write tests for them and send them back to the project. That way, the entire
    community benefits.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们完全可以测试这一点。但我们真的在测试什么？在这种情况下，我们将测试Go标准库中的JSON包是否按预期工作。外部SDK和包应该有它们自己的测试，这样我们就可以相信它们会按照它们声称的那样工作。如果情况不是这样，我们可以随时为它们编写测试并将它们发送回项目。这样整个社区都会受益。
- en: Mocks
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Mocks are very much like stubs, but they have one fundamental difference. Mocks
    have expectations. When we used stubs, our tests did nothing to validate our usage
    of the dependency; with mocks, they will. Which you use depends very much on the
    type of test and the dependency itself. For example, you might want to use a stub
    for a logging dependency, unless you are writing a test that ensures the code
    logs in a specific situation. However, you will often need a mock for a database
    dependency. Let''s change our previous tests from stubs to mocks to ensure that
    we make those calls:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟非常像存根，但它们有一个根本的区别。模拟有期望。当我们使用存根时，我们的测试对我们对依赖的使用没有任何验证；而使用模拟，它们会有。你使用哪种取决于测试的类型和依赖本身。例如，你可能想为日志依赖使用存根，除非你正在编写一个确保代码在特定情况下记录日志的测试。然而，你通常需要为数据库依赖使用模拟。让我们将之前的测试从存根更改为模拟，以确保我们进行这些调用：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we are validating that the appropriate calls are made
    and that the inputs are as we expect. Given that mock-based tests are more explicit,
    they are often more brittle and verbose than their stub-based equivalents. The
    best advice I can give you about this is to choose the option that best fits the
    test you are trying to write and, if the amount of setup seems excessive, consider
    what this implies about the code you are testing. You could have issues with feature
    envy or an inefficient abstraction. Refactoring for the DIP or SRP might help.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们正在验证是否进行了适当的调用，并且输入是否符合我们的预期。鉴于基于模拟的测试更加明确，它们通常比基于存根的测试更脆弱和冗长。我可以给你的最好建议是选择最适合你要编写的测试的选项，如果设置量似乎过多，请考虑这对你正在测试的代码意味着什么。您可能会遇到特性嫉妒或低效的抽象。重构以符合DIP或SRP可能会有所帮助。
- en: Just as there are with stubs, there are many great tools in the community for
    generating mocks. I have personally used mockery ([https://github.com/vektra/mockery](https://github.com/vektra/mockery))
    by Vektra.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与存根一样，社区中有许多用于生成模拟的优秀工具。我个人使用过Vektra的mockery ([https://github.com/vektra/mockery](https://github.com/vektra/mockery))。
- en: 'You can install mockery with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装mockery：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once installed, we can generate a mock for our test interface using mockery
    from the command line, or by using the `go generate`tool provided with the Go
    SDK by merely adding a comment to our source code, as shown in the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以使用命令行中的mockery为我们的测试接口生成模拟，或者通过在源代码中添加注释来使用Go SDK提供的`go generate`工具，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once this is done, we then run the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们运行以下命令：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The resulting mocks can then be used as we did in the previous example. We will
    be using mockery and the mocks it generates a great deal in the second section
    of this book. If you wish to download mockery, you will find a link to their GitHub
    project at the end of this chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后生成的模拟可以像前面的示例中那样使用。在本书的第二部分中，我们将大量使用mockery和它生成的模拟。如果您希望下载mockery，您将在本章末尾找到指向他们GitHub项目的链接。
- en: Test-induced damage
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试引起的损害
- en: In a 2014 blog post, *David Heinemeier Hansson* expressed that changes to a
    system for the sole purpose of making tests easier or faster resulted in test-induced
    damage. While I agree with David's intent, I am not sure we agree on the details.
    He coined this term in response to what he felt was excessive application DI and
    **test-driven development** (**TDD**).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在2014年的一篇博客文章中，*David Heinemeier Hansson*表示，为了使测试更容易或更快而对系统进行更改会导致测试引起的损害。虽然我同意David的意图，但我不确定我们在细节上是否一致。他创造了这个术语，以回应他认为过度应用DI和**测试驱动开发**（**TDD**）。
- en: Personally, I take a pragmatic approach to both. They are tools. Please try
    them out. If they work for you, fantastic. If not, that's fine too. I have never
    been able to get TDD to be as productive for me as other methods. Generally, I
    will write my function, at least the happy path, and then apply my tests. Then
    I refactor and clean.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我对两者都采取务实的态度。它们只是工具。请尝试它们。如果它们对你有用，那太棒了。如果不行，也没关系。我从来没有能够像其他方法那样高效地使用TDD。通常，我会先编写我的函数，至少是正常路径，然后应用我的测试。然后我进行重构和清理。
- en: Warning signs of test-induced damage
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试引起的损害的警告信号
- en: While there are many ways in which testing could cause damage to your software
    design, the following are some of the more common kinds of damage.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试可能会对软件设计造成许多损害，但以下是一些更常见的损害类型。
- en: Parameters, config options, or outputs that only exist because of tests
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅因测试而存在的参数、配置选项或输出
- en: While an individual instance of this might not feel like it has a huge impact,
    the cost does eventually add up. Remember that each parameter, option, and output
    is something that a user has to understand. Similarly, each parameter, option,
    and output has to be tested, documented, and otherwise maintained.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个实例可能并不会产生巨大影响，但成本最终会累积起来。请记住，每个参数、选项和输出都是用户必须理解的内容。同样，每个参数、选项和输出都必须经过测试、记录和其他维护。
- en: Parameters that cause or are caused by leaky abstractions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导致或由不完全抽象引起的参数
- en: It's common to see a database connection string or URL passed into the business-logic
    layer for the sole purpose of passing it down to the data layer (the database
    or HTTP client). Typically, the motivation is to pass the config through the layers
    so that we can swap out the live config for something friendlier for testing.
    This sounds good, but it breaks the encapsulation of the data layer. Perhaps more
    concerning is that if we were to change the data-layer implementation to something
    else, we would likely have extensive shotgun surgery on our hands. The actual
    problem here is not the testing, but how we have chosen to *swap out *the data
    layer. Using the DIP, we could define our requirements as an interface in the
    business-logic layer and then mock or stub it. This would completely decouple
    the business-logic layer from the data layer and remove the need to pass the test
    configuration.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会看到数据库连接字符串或URL被传递到业务逻辑层，唯一目的是将其传递到数据层（数据库或HTTP客户端）。通常的动机是通过层传递配置，以便我们可以将实际配置替换为更友好的测试。这听起来不错，但它破坏了数据层的封装。也许更令人担忧的是，如果我们将数据层实现更改为其他内容，我们可能会有大量的重构工作。这里的实际问题不是测试，而是我们选择如何*替换数据层。使用DIP，我们可以在业务逻辑层中将我们的需求定义为接口，然后进行模拟或存根。这将完全将业务逻辑层与数据层解耦，并消除了传递测试配置的需要。
- en: Publishing mocks in production code
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产代码中发布模拟
- en: Mocks and stubs are tools for testing; as such, they should only ever exist
    in test code. In Go, this means an `_test.go` file. I have seen many well-meaning
    folks publish interfaces and their mocks in production code. The first problem
    with this is that it introduces a possibility, however remote, of this code ending
    up in production. Depending on where in the system this mistake was located, the
    results could be disastrous.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和存根是测试工具；因此，它们应该只存在于测试代码中。在Go中，这意味着一个`_test.go`文件。我见过许多好心的人在生产代码中发布接口及其模拟。这样做的第一个问题是，它引入了一个可能性，无论多么微小，这段代码最终会进入生产环境。根据此错误在系统中的位置，结果可能是灾难性的。
- en: The second problem is a little more subtle. When publishing the interface and
    mock, the intent is to reduce duplication, which is fantastic. However, this also
    increases dependence and resistance to change. Once this code is published and
    adopted by others, modifying it will require changing all usage of it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题有点微妙。在发布接口和模拟时，意图是减少重复，这是很棒的。然而，这也增加了依赖性和抵抗变化。一旦这段代码被发布并被其他人采用，修改它将需要改变它的所有用法。
- en: Visualizing your package dependencies with Godepgraph
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Godepgraph可视化您的软件包依赖关系
- en: 'In a book about DI, you can expect us to spend a lot of time talking about
    dependencies. Dependencies at the lowest level, functions, structs, and interfaces
    are easy to visualize; we can just read the code or, if we want a pretty picture,
    we can make a class diagram like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本关于DI的书中，您可以期待我们花费大量时间讨论依赖关系。在最低级别的依赖关系，函数、结构和接口很容易可视化；我们可以只需阅读代码，或者如果我们想要一个漂亮的图片，我们可以制作一个类图，就像下面的例子一样：
- en: '![](img/782bf8ac-65ed-4f92-b38d-9cc09cc1c450.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/782bf8ac-65ed-4f92-b38d-9cc09cc1c450.png)'
- en: If we zoom out to the package level and try to map the dependencies between
    packages, then life gets a lot more difficult. This is where we rely again on
    the open source community's wealth of open-source tools. This time, we will need
    two tools called **godepgraph** and **Graphviz** ([http://www.graphviz.org/](http://www.graphviz.org/)).
    Godepgraph is a program for generating a dependency graph of Go packages, and
    Graphviz is a source graph-visualization software.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大到软件包级别并尝试映射软件包之间的依赖关系，那么生活就会变得更加困难。这就是我们再次依赖开源社区丰富的开源工具的地方。这一次，我们将需要两个名为**godepgraph**和**Graphviz**（[http://www.graphviz.org/](http://www.graphviz.org/)）的工具。Godepgraph是一个用于生成Go软件包依赖关系图的程序，而Graphviz是一个源图可视化软件。
- en: Installing the tools
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装工具
- en: 'A simple `go get` will install `godepgraph`, as shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`go get`将安装`godepgraph`，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How you install Graphviz depends on your operating system. You can use Windows
    binaries, Linux packages, and both MacPorts and HomeBrew for OSX.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如何安装Graphviz取决于您的操作系统。您可以使用Windows二进制文件，Linux软件包，以及MacPorts和HomeBrew用于OSX。
- en: Generating a dependency graph
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成依赖图
- en: 'Once everything is installed, the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切都安装好了，使用以下命令：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Will produce the following pretty picture for you:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将为您生成以下漂亮的图片：
- en: '![](img/7dd06d05-ed7a-4466-8d2b-72813417f6ff.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dd06d05-ed7a-4466-8d2b-72813417f6ff.png)'
- en: As you can see, the dependency graph for `godepgraph` is nice and flat, and
    only relies on packages from the standard library (the green circles).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`godepgraph`的依赖图很好而且平坦，只依赖于标准库的软件包（绿色圆圈）。
- en: 'Let''s try something a little more complicated: let''s generate the dependency
    graph for the code we are going to use in the second part of this book:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些更复杂的东西：让我们为我们将在本书第二部分中使用的代码生成依赖图：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This gives us an incredibly complicated graph that will never fit on the page.
    Please take a look at `ch03/04_visualizing_dependencies/acme-graph-v1.png` if
    you want to see just how complicated it is. Don't worry too much about trying
    to make out the details; it's not in a super useful form right now.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个非常复杂的图表，永远不会适合在页面上。如果您想看看它有多复杂，请查看`ch03/04_visualizing_dependencies/acme-graph-v1.png`。不要太担心试图弄清楚细节；它现在不是一个非常有用的形式。
- en: 'The first thing we can do to fix this is remove the standard library imports
    (which have the `-s` flag), as shown in the following code. We can assume that
    using the standard library is acceptable, and is not something we need to turn
    into an abstraction or use DI on:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是删除标准库导入（使用`-s`标志），如下面的代码所示。我们可以假设使用标准库是可以接受的，并且不是我们需要转换为抽象或使用DI的东西：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We could use this graph, but it''s still too complicated for me. Assuming we
    don''t recklessly adopt external dependencies, we can treat them like the standard
    library and hide them from the graph (with the `-o` flag), as shown in the following
    code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个图，但对我来说还是太复杂了。假设我们不会鲁莽地采用外部依赖项，我们可以像标准库一样对待它们，并将它们从图表中隐藏（使用`-o`标志），如下面的代码所示：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This gives us the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下内容：
- en: '![](img/fb1d7fc1-69ba-4873-a931-80a20e0ae5a4.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb1d7fc1-69ba-4873-a931-80a20e0ae5a4.png)'
- en: With all of the external packages removed, we can see how our packages relate
    and depend on each other.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 删除所有外部软件包后，我们可以看到我们的软件包之间的关系和依赖关系。
- en: If you are using OSX or Linux, I have included a Bash script called `depgraph.sh`
    that I use to generate these graphs in the source code for this chapter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用OSX或Linux，我在本章的源代码中包含了一个名为`depgraph.sh`的Bash脚本，我用它来生成这些图表。
- en: Interpreting the dependency graph
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释依赖图
- en: Like a lot of things in the programming world, what a dependency graph says
    is very much open to interpretation. I use the graph to discover potential problems
    that I can then go searching for in the code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像编程世界中的许多事物一样，依赖图所表达的意思在很大程度上是开放的。我使用图表来发现我可以在代码中搜索的潜在问题。
- en: So, what would a *perfect *graph look like? If there were one, it would be very
    flat, with pretty much everything hanging from the main package. In such a system,
    all of the packages would be completely decoupled from each other and would have
    no dependencies beyond their external dependencies and the standard library.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*完美*的图表会是什么样子？如果有一个，它将非常平坦，几乎所有的东西都悬挂在主包下。在这样的系统中，所有的包都将完全解耦，并且除了它们的外部依赖和标准库之外，不会有任何依赖。
- en: This is really not feasible. As you will see with the various DI methods in
    the second part of this book, the goal is frequently to decouple the layers so
    that dependencies flow only in one direction—from the top down.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是不可行的。正如您将在本书的第二部分中看到的各种DI方法，目标通常是解耦层，以便依赖关系只能单向流动-从上到下。
- en: 'From an abstract perspective, this looks something like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象的角度来看，这看起来有点像下面这样：
- en: '![](img/e0d5132d-0e6a-431d-a581-2ffccc2079ee.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0d5132d-0e6a-431d-a581-2ffccc2079ee.png)'
- en: With this in mind, what potential issues do we see with our graph?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们在图表中看到了哪些潜在问题？
- en: The first thing to consider when looking at any package is how many arrows are
    pointing into or out of it. This is a fundamental measure of coupling. Every arrow
    pointing into a package indicates a user of this package. Therefore, every arrow
    pointing inward means that the package may have to change if we make changes to
    the current package. The same can be said in reverse—the more packages the current
    package depends on, the more likely it will be to have to change as a result of
    them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 查看任何包时要考虑的第一件事是有多少箭头指向它或指向外部。这是耦合的基本度量。指向包的每个箭头表示该包的用户。因此，每个指向内部的箭头意味着如果我们对当前包进行更改，该包可能必须更改。反之亦然-当前包依赖的包越多，它可能因它们的更改而需要更改。
- en: Considering the DIP, while adopting an interface from another package is the
    quick and easy thing to do, defining our own interface allows us to depend on
    ourselves, and reducing the likelihood of change.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到DIP，虽然从另一个包采用接口是快速简便的方法，但定义我们自己的接口允许我们依赖于自己，并减少更改的可能性。
- en: The next thing that jumps out is the config package. Just about every package
    depends on it. As we have seen, with this amount of responsibility, making changes
    to that package is potentially tricky. Not far behind in terms of trickiness is
    the logging package. Perhaps what is most concerning is that the config package
    depends on the logging package. This means that we are one bad import away from
    circular dependency problems. These are both issues that we will need to leverage
    DI to deal with in later chapters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来引人注目的是config包。几乎每个包都依赖于它。正如我们所见，承担这么多责任，对该包进行更改可能会有些棘手。在棘手程度方面，日志包也不甘落后。也许最令人担忧的是config包依赖于日志包。这意味着我们离循环依赖问题只差一个糟糕的导入。这些都是我们需要在后面的章节中利用DI来处理的问题。
- en: Otherwise, the graph is pretty good; it flows out like a pyramid from the main
    package, and almost all of the dependencies are in one direction. The next time
    you are looking for ways to improve your code base or are experiencing a circular
    dependency problem, why don't you fire up `godepgraph` and see what it says about
    your system. The dependency graph will not tell you exactly where there is a problem
    or where there isn't a problem, but it will give you hints as to where to start
    looking.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，图表看起来很好；它从主包像金字塔一样流出，几乎所有的依赖关系都是单向的。下次您寻找改进代码库的方法或遇到循环依赖问题时，为什么不启动`godepgraph`并查看它对您的系统的说法。依赖图不会准确告诉您问题所在或问题所在，但它会给您一些提示从哪里开始查找。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! We made it to the end of the first section! Hopefully, at this
    point, you've discovered a few new things, or perhaps have been reminded of some
    software design concepts that you had forgotten.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经到达了第一部分的结尾！希望在这一点上，您已经发现了一些新东西，或者可能已经想起了一些您已经忘记的软件设计概念。
- en: Programming, like any professional endeavor, deserves constant discussion, learning,
    and a healthy dose of skepticism.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编程，就像任何专业努力一样，都需要不断讨论、学习和健康的怀疑态度。
- en: In the second section, you will find several very different techniques for DI,
    some that you might like, some that you might not. Armed with everything we have
    examined so far, you will have no trouble in determining how and when each technique
    could work for you.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，您将找到几种非常不同的DI技术，有些您可能会喜欢，有些您可能不会。有了我们迄今为止所检查的一切，您将毫无困难地确定每种技术何时以及如何适合您。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is the usability of code important?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么代码的可用性很重要？
- en: Who benefits the most from code with great UX?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁最能从具有良好用户体验的代码中受益？
- en: How do you construct a good UX?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何构建良好的用户体验？
- en: What can unit testing do for you?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试对您有什么作用？
- en: What kind of test scenarios should you consider?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该考虑哪些测试场景？
- en: How do table-driven tests help?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表驱动测试如何帮助？
- en: How can testing damage your software design?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试如何损害您的软件设计？
