- en: Dependency Injection with Constructor Injection
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入的依赖注入
- en: After examining one of the most unique forms of **dependency injection** (**DI**),
    monkey patching, in this chapter, we take it to the other extreme and look at
    perhaps the most *normal* or traditional, constructor injection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究**依赖注入**（**DI**）最独特的形式之一，即猴子补丁，然后将其推向另一个极端，看看可能是最*正常*或传统的构造函数注入。
- en: While constructor injection is so ubiquitous that you may even have used it
    without realizing it, it has many subtleties, particularly concerning advantages
    and disadvantages, that bear examination.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然构造函数注入是如此普遍，以至于您甚至可能在不知不觉中使用它，但它有许多微妙之处，特别是关于优缺点的考虑。
- en: Similar to the previous chapter, we will apply this technique to our sample
    service, where we will reap significant improvements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，我们将把这种技术应用到我们的示例服务中，从而获得显著的改进。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Constructor injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: Advantages of constructor injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入的优点
- en: Applying constructor injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用构造函数注入
- en: Disadvantages of constructor injection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入的缺点
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service that we
    introduced in [Chapter 4,](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml) *Introduction
    to the ACME Registration Service* .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的服务代码将是有益的，*ACME注册服务简介*。
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本很有用，这些代码可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06)上找到。
- en: Instructions to obtain the code and configure the sample service are available
    in the README here [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明可在此处的README中找到[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)。
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch06/acme`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch06/acme`中找到我们的服务代码，并已应用了本章的更改。
- en: Constructor injection
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入
- en: When an object requires a dependency to work, the easiest way to ensure that
    dependency is always available is to require all users to supply it as a parameter
    to the object's constructor. This is known as **constructor injection**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象需要一个依赖项来工作时，确保该依赖项始终可用的最简单方法是要求所有用户将其作为对象构造函数的参数提供。这被称为**构造函数注入**。
- en: 'Let''s work through an example where we will extract a dependency, generalize
    it, and achieve constructor injection. Say we are we are building a website for
    an online community. For this site, we wish to send an email to new users when
    they sign up. The code for this could be like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来解释，我们将提取一个依赖项，将其概括，并实现构造函数注入。假设我们正在为一个在线社区构建网站。对于这个网站，我们希望在用户注册时向新用户发送电子邮件。这段代码可能是这样的：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve made the `*Mailer` private to ensure proper encapsulation of the internals
    of the class. We can inject the `*Mailer` dependency by defining it as a parameter
    to our constructor, as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`*Mailer`设为私有，以确保类的内部封装。我们可以通过将其定义为构造函数的参数来注入`*Mailer`依赖项，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous example, we have included a guard clause. The purpose of this
    is to ensure that the supplied dependency is not `nil`. This is not necessary,
    and whether or not it is included depends mainly on personal style; it''s perfectly
    acceptable to do this instead:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们包含了一个守卫子句。其目的是确保提供的依赖项不是`nil`。这并非必需，是否包含取决于个人风格；这样做是完全可以接受的：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might be tempted to think that we are done. After all, we are injecting
    the dependency, `Mailer`, into `WelcomeSender`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为我们已经完成了。毕竟，我们正在将依赖项`Mailer`注入`WelcomeSender`。
- en: Sadly, we are not quite there yet. In fact, we are missing the real purpose
    of DI. No, it's not testing, although we will get to that. The real purpose of
    DI is decoupling.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我们还没有完全达到目标。事实上，我们错过了DI的真正目的。不，这不是测试，尽管我们会做到这一点。DI的真正目的是解耦。
- en: At this point, our `WelcomeSender` cannot work without an instance of `Mailer`.
    They are tightly coupled. So, let's decouple them by applying the *Dependency
    Inversion Principle* section from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml),
    *SOLID Design Principles for Go*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的`WelcomeSender`没有`Mailer`实例就无法工作。它们之间耦合度很高。因此，让我们通过应用[第2章](53a15217-38a7-4622-9242-a57fe46335ec.xhtml)中的*依赖反转原则*部分来解耦它们，*Go的SOLID设计原则*。
- en: 'First, let''s look at the `Mailer` struct:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`Mailer`结构：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can introduce an abstraction by converting this into an interface based
    on the method signatures:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过基于方法签名的接口将其转换为抽象：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Hang on, we only need to send emails. Let''s apply the *interface segregation
    principle* and reduce the interface to only the methods we use and update our
    constructor. Now, we have this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，我们只需要发送电子邮件。让我们应用*接口隔离原则*，将接口减少到我们使用的方法，并更新我们的构造函数。现在，我们有这样的代码：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this one small change, a few handy things have happened. Firstly, our code
    is now entirely self-contained. This means any bugs, extensions, tests, or other
    changes will only involve this package. Second, we can use mocks or stubs to test
    our code, stopping us from spamming ourselves with emails and requiring a working
    email server for our tests to pass. Lastly, we are no longer tied to the `Mailer`
    class. If we wanted to change from a welcome email to an SMS or tweet, we could
    change our input parameter to a different `Sender` and be done.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一个小改变，发生了一些方便的事情。首先，我们的代码现在完全自包含。这意味着任何错误、扩展、测试或其他更改只涉及这个包。其次，我们可以使用模拟或存根来测试我们的代码，阻止我们用电子邮件轰炸自己，并要求一个工作的电子邮件服务器来通过我们的测试。最后，我们不再受限于`Mailer`类。如果我们想要从欢迎电子邮件更改为短信或推特，我们可以将我们的输入参数更改为不同的`Sender`并完成。
- en: By defining our dependency as an abstraction (as a local interface) and passing
    that dependency into our constructor, we have explicitly defined our requirements
    and given us greater freedom in our testing and extensions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的依赖项定义为一个抽象（作为一个本地接口）并将该依赖项传递到我们的构造函数中，我们已经明确地定义了我们的要求，并在测试和扩展中给了我们更大的自由度。
- en: Addressing the duck in the room
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决房间里的鸭子
- en: Before we dive too deep into constructor injection, we should spend a moment
    to talk about duck typing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究构造函数注入之前，我们应该花一点时间来谈谈鸭子类型。
- en: 'We have previously mentioned Go''s support for implicit interfaces and how
    we can leverage it to perform dependency inversion and decouple objects. To those
    of you familiar with Python or Ruby, this may have felt like duck typing. For
    everyone else, what is duck typing? It''s described as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过Go对隐式接口的支持，以及我们如何利用它来执行依赖反转和解耦对象。对于熟悉Python或Ruby的人来说，这可能感觉像鸭子类型。对于其他人来说，什么是鸭子类型？它被描述如下：
- en: '**If it looks like a duck, and it quacks like a duck, then it is a duck**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果它看起来像一只鸭子，它叫起来像一只鸭子，那么它就是一只鸭子**'
- en: 'Or, put more technically:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更加技术性地说：
- en: '**At runtime, dynamically determine an object''s suitability based only on
    the parts of that object that are accessed**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**在运行时，仅根据访问的对象部分动态确定对象的适用性**'
- en: 'Let''s look at a Go example to see if it supports duck typing:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个Go的例子，看看它是否支持鸭子类型：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, our `Dog` type does not declare that it implements the `Talker`
    interface, as we might expect from Java or C#, and yet we are able to use it as
    a `Talker`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的`Dog`类型并没有声明它实现了`Talker`接口，正如我们可能从Java或C#中期望的那样，但我们仍然能够将它用作`Talker`。
- en: 'From our example, it looks like Go might support duck typing, but there are
    a couple of problems:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的例子来看，Go可能支持鸭子类型，但存在一些问题：
- en: In duck typing, compatibility is determined at runtime; Go will check our `Dog`
    type implements `Talker` at compile time.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在鸭子类型中，兼容性是在运行时确定的；Go将在编译时检查我们的`Dog`类型是否实现了`Talker`。
- en: In duck typing, suitability is only based on the parts of the object accessed.
    In the previous example, only the `Speak()` method is actually used. However,
    if our `Dog` type did not implement the `Shout()` method, then it would fail to
    compile.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在鸭子类型中，适用性仅基于访问的对象部分。在前面的例子中，只有`Speak()`方法被实际使用。然而，如果我们的`Dog`类型没有实现`Shout()`方法，那么它将无法编译通过。
- en: So if it's not duck typing, what is it? Something somewhat similar called **structural
    typing**. Structural typing is a static typing system that determines suitability
    at compile time based on the type's structure. Don't let the less fancy name fool
    you; structural typing is immensely powerful and extremely useful. Go provides
    the safety of compile-time checking without the enforced formality of explicitly
    having to state the interfaces implemented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果它不是鸭子类型，那它是什么？有点类似的东西叫做**结构类型**。结构类型是一种静态类型系统，它根据类型的结构在编译时确定适用性。不要让这个不太花哨的名字愚弄你；结构类型是非常强大和极其有用的。Go提供了编译时检查的安全性，而不需要明确声明实现的接口的强制形式。
- en: Advantages of constructor injection
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入的优势
- en: For many programmers and programming languages, constructor injection is their
    default method for DI. It is perhaps no surprise therefore that it has numerous
    advantages.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多程序员和编程语言，构造函数注入是它们的默认DI方法。因此，它具有许多优势也许并不奇怪。
- en: '**Separation from the dependency life cycle**—Constructor injection, like most
    DI methods, separates the life cycle management of the dependency from the object
    that it''s being injected into. By doing this, the object becomes more straightforward
    and easier to understand.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**与依赖项生命周期的分离**-构造函数注入，像大多数DI方法一样，将依赖项的生命周期管理与被注入的对象分开。通过这样做，对象变得更加简单和易于理解。'
- en: '**Easy to implement**—As we saw in our previous examples, it''s easy to take
    this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**易于实现**-正如我们在之前的例子中看到的，将这个变得很容易：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And change it to this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其更改为：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Predictable and concise**—By moving the assignment of the dependency to the
    constructor, we are not only being explicit about our requirements, but we are
    also ensuring that the dependency is set and available to our methods. This is
    particularly true if we include a guard clause in the constructor. Without the
    constructor, each method might have to include a guard clause (as shown in the
    following example) or risk throwing a nil pointer exception:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**可预测且简洁**-通过将依赖项的赋值移动到构造函数，我们不仅明确了我们的要求，而且还确保依赖项被设置并可用于我们的方法。如果在构造函数中包含了一个守卫子句，这一点尤其正确。没有构造函数，每个方法可能都必须包含一个守卫子句（如下例所示），否则可能会出现nil指针异常：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of the following, which is much more concise:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是更简洁的以下内容：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By extension, methods can also assume that our dependency is in a good, ready
    state when accessing the dependency, thus removing the need to handle initialization
    delays or configuration issues anywhere outside the constructor. Additionally,
    there are no data races associated with accessing the dependency. It is set during
    construction and never changed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展，方法还可以假定我们的依赖在访问依赖时处于良好的准备状态，因此无需在构造函数之外的任何地方处理初始化延迟或配置问题。此外，访问依赖时没有与数据竞争相关的问题。它在构造过程中设置，永远不会改变。
- en: '**Encapsulation**—Constructor injection provides a high degree of encapsulation
    regarding how the object uses the dependency. Consider what happens if we extend
    our previous `Car` example by adding a `FillPetrolTank()` method, as shown in
    the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装** - 构造函数注入提供了关于对象如何使用依赖的高度封装。考虑一下，如果我们通过添加`FillPetrolTank()`方法来扩展我们之前的`Car`示例，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What happens to the previous code if we assumed that *filling the petrol tank* had
    nothing to do with the `Engine` and didn't populate one before calling this method?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设*加油*与`Engine`无关，并且在调用此方法之前没有填充`Engine`，那么原来的代码会发生什么？
- en: 'Without constructor injection ensuring that we supply an `Engine`, this method
    would crash will a nil pointer exception. Alternatively, this method could have
    been written without constructor injection, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有构造函数注入来确保我们提供了`Engine`，这个方法将会崩溃并引发空指针异常。或者，这个方法也可以不使用构造函数注入来编写，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, this version now leaks the implementation detail that the method requires
    `Engine` to work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个版本现在泄漏了方法需要`Engine`来工作的实现细节。
- en: '**Helps to uncover code smells**—It''s an easy trap to add *just one more* feature
    to an existing struct or interface. As we saw during our earlier discussions of
    the *single responsibility principle*, we should resist this urge and keep our
    objects and interfaces as small as possible. One easy way to spot when an object
    has too many responsibilities is to count its dependencies. Typically, the more
    responsibilities an object has, the more dependencies it will accumulate. Therefore
    with all the dependencies clearly listed in one place, the constructor, it''s
    easy to get a whiff that something might not be quite right.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**帮助发现代码异味** - 向现有结构或接口添加*只是一个*功能是一个容易陷阱。正如我们在*单一职责原则*的早期讨论中所看到的，我们应该抵制这种冲动，尽可能保持我们的对象和接口尽可能小。发现对象承担太多责任的一个简单方法是计算其依赖关系。通常，对象承担的责任越多，它积累的依赖关系就越多。因此，通过将所有依赖关系清楚地列在一个地方，即构造函数中，很容易就能察觉到可能有些不对劲。'
- en: Improving test scenario coverage
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进测试场景覆盖率
- en: 'The first thing we will do is break the dependence on the upstream currency
    service in the test. Then, we will proceed to add tests to cover additional scenarios
    that we couldn''t cover before. This is what our test currently looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是在测试中消除对上游货币服务的依赖。然后，我们将继续添加测试来覆盖以前无法覆盖的其他场景。我们当前的测试看起来是这样的：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are currently starting our entire HTTP server; this seems excessive, so let's
    reduce the test scope to just `RegisterHandler`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前正在启动整个HTTP服务器；这似乎有些过分，所以让我们将测试范围缩小到只有`RegisterHandler`。
- en: This reduction in test scope will also improve the tests by eliminating other
    peripheral concerns, such as the HTTP router.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试范围的缩减还将通过消除其他外围问题来改进测试，比如HTTP路由。
- en: 'As we know that we are going to have multiple similar scenarios to test, let''s
    start by adding a skeleton for a table-driven test:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道我们将有多个类似的场景需要测试，让我们从添加表驱动测试的框架开始：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the original test, we can see that our inputs are an `*http.Request` and
    `*MockRegisterModel`. Both are a little complicated to create and configure, so
    we have chosen to build them with a function. Also, from the original test, we
    can see that the outputs of the test are an HTTP response code and the `Location`
    header.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始测试中，我们可以看到我们的输入是`*http.Request`和`*MockRegisterModel`。两者都有点复杂，需要创建和配置，所以我们选择用一个函数来构建它们。同样，从原始测试中，我们可以看到测试的输出是HTTP响应代码和`Location`头部。
- en: These four objects, `*http.Request`, `*MockRegistrationModel`, the HTTP status
    code, and the `Location` header, will make up the configuration for our test scenarios,
    as seen in the previous code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个对象，`*http.Request`，`*MockRegistrationModel`，HTTP状态码和`Location`头部，将构成我们测试场景的配置，如前面的代码所示。
- en: 'To complete our table-driven test, we copy the contents of the original test
    into the test loop and replace the inputs and outputs, as shown in the following
    code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的表驱动测试，我们将原始测试的内容复制到测试循环中，并替换输入和输出，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have all of the pieces in place, we write our tests scenarios,
    starting with the happy path:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有的部分都准备好了，我们开始编写我们的测试场景，从正常情况开始：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we need to test whether our code handles errors well. So what kinds of
    errors can we expect? We could examine the code and look for code that looks like `if
    err != nil`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要测试我们的代码是否能很好地处理错误。那么我们可以期望出现什么样的错误？我们可以检查代码，寻找类似`if err != nil`的代码。
- en: That might feel like a useful shortcut, but consider this. If our tests mirror
    the current implementation, what happens when the implementation changes?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉像一个有用的快捷方式，但请考虑一下。如果我们的测试反映了当前的实现，当实现发生变化时会发生什么？
- en: A better angle is to consider not the implementation but the feature itself
    and the situation or use of it. There are two answers that almost always apply.
    *User errors*, such as incorrect inputs, and *errors returned from dependencies*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的角度是考虑的不是实现，而是功能本身以及其情况或使用。几乎总是有两个答案适用。*用户错误*，如不正确的输入，以及*从依赖项返回的错误*。
- en: 'Our *user error* scenario looks as shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*用户错误*场景如下所示：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And our *errors returned from dependencies* is shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从依赖项返回的*错误*如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With those three tests in place we have reasonable test scenario coverage, but
    we have stumbled over a problem. Our *errors returned from dependencies* scenario
    results in an HTTP status code of `400` (Bad Request) instead of the expected
    HTTP `500` (Internal Server Error). After looking into the implementation of the
    model layer, it becomes evident that the `400` error is intentional and is supposed
    to indicate that the request was incomplete and therefore failed validation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个测试，我们有了合理的测试场景覆盖，但我们遇到了一个问题。我们的*从依赖项返回的错误*场景导致HTTP状态码为`400`（错误请求），而不是预期的HTTP`500`（内部服务器错误）。在查看模型层的实现后，显然`400`错误是有意的，并且应该表明请求不完整，因此验证失败。
- en: 'Our first instinct is likely to want to move the validation into the HTTP layer.
    But consider this: what happens if we add another server type, such as gRPC? This
    validation would still need to be performed. So how can we separate user errors
    from system errors?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一反应很可能是希望将验证移到HTTP层。但请考虑：如果我们添加另一种服务器类型，例如gRPC，会发生什么？这种验证仍然需要执行。那么我们如何将用户错误与系统错误分开呢？
- en: Another option would be to return a named error from the model for validation
    errors and a different one for other errors. It would be easy to detect and handle
    the responses separately. This would, however, cause our code to remain tightly
    coupled with the `model` package.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是从模型返回命名错误以进行验证错误，另一个选择是其他错误。很容易检测和分别处理响应。然而，这将导致我们的代码与`model`包保持紧密耦合。
- en: Another option is to split our call to the model package into two calls, perhaps
    `Validate()` and `Do()`,  but this detracts from the UX of our `model` package.
    I will leave it to you to decide whether these or another option works for you.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将我们对模型包的调用分成两个调用，也许是`Validate()`和`Do()`，但这会减少我们的`model`包的用户体验。我将留给您决定这些或其他选项是否适合您。
- en: After making these changes to `RegisterHandler` and the other handlers in this
    package, we can use Go's test coverage tool to see if we missed any obvious scenarios.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`RegisterHandler`和此包中的其他处理程序进行这些更改后，我们可以使用Go的测试覆盖工具来查看是否错过了任何明显的场景。
- en: For Unix/Linux users, I have included the script in the source code for this
    chapter that I use to generate the coverage in HTML. The steps should be similar
    to other platforms. The script can be found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/blob/master/ch06/pcov-html](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/blob/master/ch06/pcov-html).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Unix/Linux用户，我在本章的源代码中包含了一个用于生成HTML覆盖率的脚本，步骤应该类似于其他平台。该脚本可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/blob/master/ch06/pcov-html](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/blob/master/ch06/pcov-html)找到。
- en: Please note, the test coverage percentage is not significant here. The critical
    thing to look at is what code has not been executed by any tests and decide whether
    that indicates an error that could reasonably occur and therefore a scenario that
    we need to add.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的测试覆盖百分比并不重要。重要的是要查看哪些代码没有被任何测试执行，并决定是否表明可能发生错误，因此我们需要添加的场景。
- en: Now that our `RegisterHandler` is in much better shape, we can apply constructor
    injection in the same way to the other handlers in the `REST` package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`RegisterHandler`的形式好多了，我们可以以同样的方式将构造函数注入到`REST`包中的其他处理程序中。
- en: The results of these changes can be seen in the source code for this chapter
    at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06/acme/internal/rest](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06/acme/internal/rest).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果可以在本章的源代码中看到[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06/acme/internal/rest](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06/acme/internal/rest)。
- en: Applying constructor injection
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用构造函数注入
- en: Let's apply constructor injection to our ACME registration service. This time
    we will be refactoring the REST package, starting with the `Register` endpoint.
    You may remember that `Register` is one of three endpoints in our service, the
    others being `Get` and `List`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将构造函数注入到我们的ACME注册服务中。这次我们将重构REST包，从`Register`端点开始。您可能还记得`Register`是我们服务中的三个端点之一，其他端点是`Get`和`List`。
- en: 'The `Register` endpoint has three responsibilities:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`端点有三个责任：'
- en: Validate the registration is complete and valid
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证注册是否完成并有效
- en: Call the currency conversion service to convert the registration price to the
    currency requested in the registration
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用货币转换服务将注册价格转换为注册时请求的货币
- en: Save the registration and the converted registration price into the database
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存注册和转换后的注册价格到数据库中
- en: 'The code for our `Register` endpoint currently looks as shown in the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Register`端点的代码目前如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Disappointingly, we currently only have one test on this function, and it breaks
    way too easily. It requires both the database and our downstream exchange rate
    service to be accessible and configured.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 令人失望的是，我们目前只对此函数进行了一个测试，并且它很容易出错。它需要数据库和我们的下游汇率服务都可访问和配置。
- en: While we can ensure our that local database is working, and any changes to it
    do not affect anyone but us, the downstream exchange rate service is on the internet
    and is rate limited. We have no control over it or when it works.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以确保我们的本地数据库正在工作，并且对其进行的任何更改不会影响除我们之外的任何人，但下游汇率服务在互联网上并且受到速率限制。我们无法控制它或它何时工作。
- en: This means that even though we only have one test, that test has a high potential
    to be annoying to run and maintain because it can break at any time for reasons
    outside our control.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使我们只有一个测试，该测试也有很高的潜力会因为我们无法控制的原因而变得烦人并且难以维护。
- en: Fortunately, we can not only remove these dependencies but also use mocks to
    create situations that we could not otherwise. For example, with mocks, we can
    test our error handling code for when the exchange rate service is down or out
    of quota.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不仅可以消除这些依赖，还可以使用模拟来创建我们无法实现的情况。例如，通过模拟，我们可以测试当汇率服务停机或配额用完时的错误处理代码。
- en: Decoupling from the dependency
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与依赖的解耦
- en: The first step is to identify the dependency we wish to inject. For our handler,
    this is not the database or the exchange rate call. We wish to inject the next
    software layer, which in this case is the model layer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定我们希望注入的依赖项。对于我们的处理程序来说，这不是数据库或汇率调用。我们希望注入下一个软件层，也就是模型层。
- en: 'Specifically, we want to inject this line from our `register` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们想要从我们的`register`方法中注入这一行：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Following the same process we used easier, we first promote the object to a
    member variable, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们使用更容易的相同过程，我们首先将对象提升为成员变量，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As this does nothing to decouple our code from the dependency, we then define
    our requirements as a local interface and update the member variable, as shown
    in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这对我们的代码与依赖的解耦没有任何作用，我们随后将我们的要求定义为一个本地接口，并更新成员变量，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Building the constructor
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建构造函数
- en: 'Now that `RegisterHandler` requires an abstract dependency, we need to ensure
    that the dependency has been set by applying constructor injection, as shown in
    the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`RegisterHandler`需要一个抽象依赖项，我们需要确保通过应用构造函数注入来设置依赖项，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With constructor injection applied, our `RegisterHandler` is less coupled to
    the model layer and our external resources (database and upstream service). We
    can leverage this looser coupling to improve and extend the test of our `RegisterHandler`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 应用构造函数注入后，我们的`RegisterHandler`与模型层和外部资源（数据库和上游服务）的耦合性较小。我们可以利用这种较松散的耦合来改进和扩展我们的`RegisterHandler`的测试。
- en: Validating our improvements with the dependency graph
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖图验证我们的改进
- en: Before we wrap up our work on the `REST` package, let's take stock of where
    we started, and where we are now. When we started, our handlers were tightly coupled
    with their matching `model` packages and poorly tested. Both of these problems
    have been resolved.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对`REST`包的工作之前，让我们回顾一下我们的起点和现在的位置。当我们开始时，我们的处理程序与它们匹配的`model`包紧密耦合，并且测试不足。这两个问题都已得到解决。
- en: 'Let''s see whether our dependency graph is showing any signs of improvement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的依赖图是否显示出任何改善的迹象：
- en: '![](img/4f8296e8-5655-44e8-9d61-3feda4dd019f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f8296e8-5655-44e8-9d61-3feda4dd019f.png)'
- en: 'Sadly, it still looks the same as before. After digging into the code, we find
    the culprit:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，它看起来仍然和以前一样。在深入代码后，我们找到了罪魁祸首：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are instantiating our model layer objects inside the constructor for our
    `Server` (part of the `REST` package). The fix is easy and hopefully obvious.
    We push the dependencies up one level, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Server`（`REST`包的一部分）的构造函数中实例化了我们的模型层对象。修复很容易，也很明显。我们将依赖项上推一级，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Checking our dependency graph again, it finally now shows some improvement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查我们的依赖图，现在终于显示了一些改进：
- en: '![](img/ebcea76d-8a3c-4d4a-bd7b-c33d36ca6ff7.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebcea76d-8a3c-4d4a-bd7b-c33d36ca6ff7.png)'
- en: As you can see, it's flatter; the `REST` package has no dependence on the module
    layer (the `list`, `get`, and `register` packages).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它更加平坦；`REST`包不依赖于模块层（`list`、`get`和`register`包）。
- en: There is still way too much dependence on the `data` and the `config` packages,
    but we will deal with that in later chapters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对`data`和`config`包的依赖仍然太多，但我们将在后面的章节中处理这个问题。
- en: Disadvantages of constructor injection
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数注入的缺点
- en: When it comes to DI, sadly there is no silver bullet. Despite the utility of
    constructor injection, it cannot be used in all cases. This section covers the
    disadvantages and limitations of constructor injection.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，对于DI来说，没有银弹。尽管构造函数注入的效用很大，但并非所有情况都适用。本节介绍了构造函数注入的缺点和限制。
- en: '**Can cause lots of changes**—When applying constructor injection to existing
    code, it can result in a lot of changes. This is particularly true if the code
    was initially written as functions.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能导致大量更改**-将构造函数注入应用于现有代码时，可能会导致大量更改。如果代码最初是以函数形式编写的，这一点尤其真实。'
- en: 'Consider the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we saw in the previous section, to convert this to use constructor injection,
    we will have to do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，要将其转换为使用构造函数注入，我们需要执行以下操作：
- en: Convert from a function to a struct
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数转换为结构体
- en: Convert the dependency on `*myShuffler` to something abstract by defining an
    interface
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义接口将对`*myShuffler`的依赖转换为抽象的
- en: Create a constructor
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个构造函数
- en: Update all current usage of the function to use the constructor and to inject
    the dependency
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新所有当前使用该函数的地方，使用构造函数注入依赖
- en: Of all the changes, the one that is most concerning is the last. Changes that
    occur locally, that is, in the same package, are easier to make and therefore
    less risky, but alterations to external packages, especially code that belongs
    to another team, are significantly more dangerous.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的变化中，最令人担忧的是最后一个。在同一包中发生的更改，也就是说，在同一个包中更容易进行，因此风险更小，但对外部包的更改，特别是属于另一个团队的代码，风险显著更大。
- en: Other than being very careful, the best way to mitigate the risk is with tests.
    If the code has very little or no tests before the refactoring, it is beneficial
    to create some first before starting any refactoring.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非常小心外，减轻风险的最佳方法是进行测试。如果重构之前的代码几乎没有测试或没有测试，那么在开始任何重构之前首先创建一些测试是有益的。
- en: DI with monkey patching might be an attractive candidate to swap out any dependencies
    in those tests. Yes, these tests will need to be refactored or removed after changing
    to constructor injection, but there is nothing wrong with that. Having tests will
    ensure that the code is working before the refactor, and those tests will continue
    to be informative during the refactoring. Or to put it a different way, the tests
    will help make the refactoring safer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用猴子补丁的 DI 可能是一个吸引人的选择，可以在这些测试中替换任何依赖关系。是的，这些测试在切换到构造函数注入后需要重构或删除，但这并没有什么不对。有了测试，可以确保在重构之前代码是有效的，并且这些测试在重构过程中仍然具有信息性。换句话说，测试将有助于使重构更加安全。
- en: '**Can cause initialization issues**—When discussing the advantages of constructor
    injection, we mentioned separating the object from the life cycle of its dependencies.
    This code and the complexity still exist, they''ve just been pushed higher up
    the call graph. While being able to work on these concerns separately is definitely
    an advantage, it does create a secondary problem: object initialization order.
    Consider our ACME registration service. It has three layers, presentation, model,
    and data.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**可能引起初始化问题**——在讨论构造函数注入的优势时，我们提到了将对象与其依赖的生命周期分离。这段代码和复杂性仍然存在，只是被推到了调用图的更高层。虽然能够分别处理这些问题显然是一个优势，但它也带来了一个次要问题：对象初始化顺序。考虑我们的
    ACME 注册服务。它有三层，呈现层、模型层和数据层。'
- en: Before the presentation layer can work, we need to have a working model layer.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在呈现层能够工作之前，我们需要有一个可用的模型层。
- en: Before the model layer can work, we need to have a working data layer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型层能够工作之前，我们需要有一个可用的数据层。
- en: Before the data layer can work properly, we must create a pool of database connections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据层能够正常工作之前，我们必须创建一个数据库连接池。
- en: For a simple service, this has already become somewhat complicated. This complexity
    has led to the creation of many a DI framework, and we will investigate one such
    framework, Google's Wire, in [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml),
    *Off-the-Shelf Injection*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的服务来说，这已经变得有些复杂了。这种复杂性导致了许多 DI 框架的产生，我们将在第 10 章《现成的注入》中调查其中一个框架，谷歌的 Wire。
- en: Another potential issue here is the sheer volume of objects that will be created
    at application start. While this does result in a slightly slower app start, once
    that initial *cost* has been paid, the application will no longer be delayed by
    dependency creation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能存在的另一个问题是在应用程序启动时将创建大量对象。虽然这会导致应用程序启动稍微变慢，但一旦支付了这个初始的“成本”，应用程序就不再会因为依赖关系的创建而延迟。
- en: The last initialization issue to consider here is debugging.  When the creation
    of a dependency and its users are in the same part of the code, it is easier to
    understand and debug their life cycles and relationships.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的最后一个初始化问题是调试。当依赖关系的创建和使用在代码的同一部分时，更容易理解和调试它们的生命周期和关系。
- en: '**The dangers of overuse**—Given that this technique is so easy to understand
    and use, it is also very easy to overuse. The most obvious sign of overuse is
    excessive constructor parameters. Excessive constructor parameters can indicate
    that the object has too many responsibilities, but it can also be a symptom of
    extracting and abstracting too many dependencies.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**滥用的危险**——鉴于这种技术如此易于理解和使用，滥用也是非常容易的。滥用的最明显迹象是构造函数参数过多。过多的构造函数参数可能表明对象承担了太多的责任，但也可能是提取和抽象了太多的依赖的症状。'
- en: Before extracting a dependency, think about encapsulation. What information
    do users of this object need to be aware of? The more information related to the
    implementation we can hide, the greater the flexibility we have to refactor.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取依赖之前，考虑封装。这个对象的用户需要了解哪些信息？我们能够隐藏与实现相关的信息越多，我们就越有灵活性进行重构。
- en: 'Another aspect to consider is this: does the dependency need to be extracted,
    or can we leave it to configuration? Consider the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的方面是：依赖关系是否需要被提取，还是可以留给配置？考虑以下代码：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is possible to abstract and inject `*http.Client`, but is that really necessary?
    In fact, the only aspect that really needs to change is the base URI. We will
    explore this approach further in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以对 `*http.Client` 进行抽象和注入，但这真的有必要吗？事实上，唯一需要改变的方面是基本 URI。我们将在第 8 章《配置注入》中进一步探讨这种方法。
- en: '**Non-obvious requirement**—The use of a constructor in Go is not a required
    pattern. In some teams, it''s not even a standard pattern. As such, users might
    not even realize that the constructor exists and that they must use it. Given
    the code will likely crash rather spectacularly without the dependencies injected,
    this is unlikely to cause production issues, but it can be somewhat annoying.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**不明显的要求**——在 Go 中使用构造函数不是一个必需的模式。在一些团队中，甚至不是一个标准模式。因此，用户可能甚至没有意识到构造函数的存在以及他们必须使用它。鉴于没有注入依赖关系，代码很可能会崩溃，这不太可能导致生产问题，但可能会有些烦人。'
- en: 'Some teams have attempted to solve this problem by making the object private
    and only exporting the constructor and an interface, as shown in the following
    code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队尝试通过将对象设为私有，只导出构造函数和接口来解决这个问题，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This approach does ensure that the constructor is used, but it does have some
    costs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确保了构造函数的使用，但也有一些成本。
- en: Firstly, we now have to keep the interface and the struct in sync. Not hard,
    but it is extra work and can get annoying.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们现在必须保持接口和结构同步。这并不难，但这是额外的工作，可能会变得烦人。
- en: Secondly, some users are tempted to use the interface rather than defining their
    own locally. This results in tight coupling between the user and the exported
    interface. This coupling can make it more difficult to make additions to the exported
    API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一些用户倾向于使用接口而不是在本地定义自己的接口。这会导致用户和导出接口之间的紧密耦合。这种耦合会使得向导出 API 添加内容变得更加困难。
- en: 'Consider using the previous example in another package, as shown in the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在另一个包中使用前面的示例，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, if we add another method to the `Client` interface, the aforementioned
    code will be broken.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们向`Client`接口添加另一个方法，上述的代码将会失效。
- en: '**Constructors are not inherited**—Unlike methods and *method injection*, which
    we will examine in the next chapter, constructors are not included when performing
    the composition; instead, we are required to remember the constructor exists and
    to use them.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**构造函数不会被继承** - 与我们将在下一章中研究的方法和*方法注入*不同，构造函数在进行组合时不会被包括；相反，我们需要记住构造函数的存在并使用它们。'
- en: 'Another factor to consider when performing composition is that any parameter
    to the inner struct''s constructor will have to be added to the outer struct''s
    constructor, as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行组合时需要考虑的另一个因素是，内部结构的构造函数的任何参数都必须添加到外部结构的构造函数中，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A relationship like the preceding one would severely discourage us from changing
    `InnerService` because we would be forced to make matching changes to `OuterService`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的关系会严重阻碍我们改变`InnerService`，因为我们将被迫对`OuterService`进行匹配的更改。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have examined DI with constructor injection. We have seen
    how easy it is to understand and apply. This is why it is the default choice for
    many programmers and in many situations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经研究了构造函数注入的DI。我们已经看到了它是多么容易理解和应用。这就是为什么它是许多程序员和许多情况下的默认选择。
- en: We have seen how constructor injection brings a level of predictability to the
    relationship between an object and its dependencies, especially when we use guard
    clauses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到构造函数注入如何为对象和其依赖之间的关系带来了一定程度的可预测性，特别是当我们使用守卫子句时。
- en: By applying constructor injection to our `REST` package, we were left with a
    collection of loosely coupled and easy-to-follow objects. Because of this, we
    were able to extend our test scenario coverage easily. We can also expect that
    any subsequent changes to the model layer are now unlikely to unduly affect our
    `REST` package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将构造函数注入应用于我们的`REST`包，我们得到了一组松散耦合且易于遵循的对象。因此，我们能够轻松扩展我们的测试场景覆盖范围。我们还可以期望，对模型层的任何后续更改现在不太可能会不适当地影响我们的`REST`包。
- en: In the next chapter, we will introduce DI with method injection, which (among
    other things) is a very convenient way to handle optional dependencies.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍DI的方法注入，这是处理可选依赖项的一种非常方便的方式。
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the steps we used to adopt constructor injection?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们采用了哪些步骤来采用构造函数注入？
- en: What is a guard clause and when would you use it?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是守卫子句，何时使用它？
- en: How does constructor injection affect the life cycle of the dependency?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数注入如何影响依赖项的生命周期？
- en: What are the ideal use cases for constructor injection?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数注入的理想用例是什么？
