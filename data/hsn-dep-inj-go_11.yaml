- en: Curb Your Enthusiasm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制你的热情
- en: In this chapter, we will examine some of the ways **dependency injection** (**DI**)
    can go wrong.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究**依赖注入**（**DI**）可能出错的一些方式。
- en: As programmers, our enthusiasm towards a new tool or technique can sometimes
    get the better of us. Hopefully, this chapter will help to ground us and keep
    us out of trouble.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们对新工具或技术的热情有时会让我们失去理智。希望本章能帮助我们保持理智，避免麻烦。
- en: It's important to remember that DI is a tool and, as such, it should be applied
    selectively, when it's convenient, and when it's the right tool for the job.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，DI是一种工具，因此应该在方便和适合的时候进行选择性应用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: DI induced damage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI引起的损害
- en: Premature future-proofing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过早的未来保护
- en: Mocking HTTP requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟HTTP请求
- en: Unnecessary injection?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不必要的注入？
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch11](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch11).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本很有用，这些代码可以在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch11](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch11)上找到。
- en: DI induced damage
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DI引起的损害
- en: DI induced damage results from situations where the use of DI makes the code
    harder to understand, maintain, or otherwise use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DI引起的损害是指使用DI使代码更难理解、维护或以其他方式使用的情况。
- en: A long constructor parameter list
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长构造函数参数列表
- en: A long constructor parameter list is perhaps the most common and most often
    complained about code damage caused by DI. While DI is not the root cause of code
    damage, it certainly doesn't help.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 长构造函数参数列表可能是由DI引起的代码损害中最常见和最经常抱怨的。虽然DI并非代码损害的根本原因，但它确实没有帮助。
- en: 'Consider the following example, which uses constructor injection:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它使用构造函数注入：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The constructor simply has too many parameters. This makes it unwieldy to use,
    test, and maintain. So, what is the cause of the problem here? There are actually
    three different issues.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数参数太多了。这使得使用、测试和维护都变得困难。那么问题的原因是什么呢？实际上有三个不同的问题。
- en: 'The first and, perhaps, most common when adopting DI for the first time is
    incorrect abstractions. Consider the last two parameters of the constructor are
    `Cache` and `Datastore`. Assuming that the `cache` is used in front of the `datastore`
    and not to cache the output of `MyHandler`, then these should be combined into
    a different abstraction. The `MyHandler` code does not need to be intimately aware 
    of where and how the data is stored; it only needs to be prescriptive about what
    it needs. We should replace these two input values with a more generic abstraction,
    as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，也许是最常见的，当第一次采用DI时，出现错误的抽象。考虑构造函数的最后两个参数是`Cache`和`Datastore`。假设`cache`用于`datastore`的前端，而不是用于缓存`MyHandler`的输出，那么这些应该合并为不同的抽象。`MyHandler`代码不需要深入了解数据存储的位置和方式；它只需要对它需要的内容进行规定。我们应该用更通用的抽象替换这两个输入值，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Incidentally, this would also be a great place for another package/layer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这也是另一个包/层的绝佳位置。
- en: The second issue is similar to the first, a single responsibility principle
    violation. Our `MyHandler` has taken on too much responsibility. It is currently
    decoding the request, loading the data from the datastore and/or cache, and then
    rendering the response. The best way to address this is to think about the software's
    layers. The is the top layer, our HTTP handler; it is required to understand and
    speak HTTP. We, therefore, should look for ways to have that as its primary (and
    perhaps only) responsibility.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题与第一个类似，违反了单一责任原则。我们的`MyHandler`承担了太多责任。它目前正在解码请求，从数据存储和/或缓存加载数据，然后呈现响应。解决这个问题的最佳方法是考虑软件的层次结构。这是顶层，我们的HTTP处理程序；它需要理解和使用HTTP。因此，我们应该寻找方法让它成为其主要（也许是唯一）责任。
- en: The third problem are the cross-cutting concerns. Our parameters include logging
    and instrumentation dependencies, which are likely to be used by most of our code
    and seldom changed outside of a few tests. We have a few options to deal with
    this; we could apply config injection, thereby collapsing them into one dependency
    and merging them with any config we might have. Or we could use **just-in-time**
    (**JIT**) injection to access global singletons.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题是横切关注点。我们的参数包括日志记录和仪表盘依赖项，这些依赖项可能会被大多数代码使用，并且很少在少数测试之外进行更改。我们有几种处理这个问题的选择；我们可以应用配置注入，从而将它们合并为一个依赖项，并将它们与我们可能拥有的任何配置合并。或者我们可以使用**即时**（**JIT**）注入来访问全局单例。
- en: 'In this case, we have decided to go with config injection. After applying it,
    we are left with the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们决定使用配置注入。应用后，我们得到以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are still left with five parameters, which is far better than what we started
    with, but still rather a lot.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有五个参数，这比我们开始时要好得多，但仍然相当多。
- en: 'We can reduce this even further using composition. Firstly, let''s look at
    our previous example''s constructor, which is demonstrated in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合进一步减少这个问题。首先，让我们看看我们之前示例的构造函数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Starting with `MyHandler` as a *base handler*, we can define a new handler
    that wraps our base handler, as shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从`MyHandler`作为*基本处理程序*开始，我们可以定义一个包装我们基本处理程序的新处理程序，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can define a new constructor for our `FancyFormatHandler` in the following
    way:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按以下方式为我们的`FancyFormatHandler`定义一个新的构造函数：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And just like that, we have one parameter fewer. The real source of magic here
    is the anonymous composition; because of that, any calls to `FancyFormatHandler.ServeHTTP()`
    will actually call `MyHandler.ServeHTTP()`. In this case, we're adding a little
    bit of code, to improve the UX of the handlers for our users.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像那样，我们少了一个参数。这里真正的魔力在于匿名组合；因为这样，对`FancyFormatHandler.ServeHTTP()`的任何调用实际上都会调用`MyHandler.ServeHTTP()`。在这种情况下，我们添加了一点代码，以改进我们用户的处理程序的用户体验。
- en: Injecting an object when config would do
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入一个对象时，配置就可以了
- en: Often times, your first instinct will be to inject a dependency so that you
    can test your code in isolation. However, to do so, you are forced to introduce
    so much abstraction and indirection that the amount of code and complexity increases
    exponentially.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你的第一反应是注入一个依赖，这样你就可以在隔离环境中测试你的代码。然而，为了这样做，你不得不引入如此多的抽象和间接性，以至于代码量和复杂性呈指数增长。
- en: 'One widespread occurrence of this is using the common library for accessing
    external resources, such as network resources, files, or databases. Let''s use
    our sample service''s `data` package, for example. If we wanted to abstract our
    usage of the `sql` package, we would likely start by defining an interface, as
    shown in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个普遍发生是使用通用库来访问外部资源，比如网络资源、文件或数据库。例如，让我们使用我们样本服务的`data`包。如果我们想要抽象出对`sql`包的使用，我们可能会从定义一个接口开始，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then we realize that `QueryRowContext()` and `QueryContext()` return `*sql.Row`
    and `*sql.Rows` respectively. Digging into these structs, we find that there is
    no way for us to populate their internal state from outside of the `sql` package.
    To get around this, we have to define our own `Row` and `Rows` interfaces, as
    shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们意识到`QueryRowContext()`和`QueryContext()`分别返回`*sql.Row`和`*sql.Rows`。深入研究这些结构，我们发现没有办法从`sql`包的外部填充它们的内部状态。为了解决这个问题，我们不得不定义我们自己的`Row`和`Rows`接口，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are now fully decoupled from the `sql` package and are able to mock it in
    our tests.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完全与`sql`包解耦，并且能够在我们的测试中模拟它。
- en: 'But let''s stop for a minute and consider where we''re at:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们停下来一分钟，考虑一下我们所处的位置：
- en: We've introduced about 60 lines of code, which we haven't yet written any tests
    for
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们引入了大约60行代码，但我们还没有为它们编写任何测试
- en: We cannot test the new code without using an actual database,  which means we'll
    never be fully decoupled from the database
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法在不使用实际数据库的情况下测试新代码，这意味着我们永远无法完全与数据库解耦
- en: We've added another layer of abstraction and a small amount of complexity along
    with it
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们增加了另一层抽象和一些复杂性
- en: Now, compare this with installing a database locally and ensuring it's in a
    good state. There is complexity here too, but, arguably, an insignificant once-off
    cost, especially when spread across all of the projects we work on. We would also
    have to create and maintain the tables in the database. The easiest option for
    this is an `SQL` script—a script that could also be used to support the live systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这与本地安装数据库并确保其处于良好状态进行比较。这里也有复杂性，但可以说是一个微不足道的一次性成本，特别是当分摊到我们所工作的所有项目时。我们还必须创建和维护数据库中的表。这个最简单的选择是一个`SQL`脚本——一个也可以用来支持实时系统的脚本。
- en: For our sample service, we decided to maintain an `SQL` file and a locally installed
    database. As a result of this decision, we do not need to mock calls to the database
    but instead only need to pass in the database configuration to our local database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的样本服务，我们决定维护一个`SQL`文件和一个本地安装的数据库。由于这个决定，我们不需要模拟对数据库的调用，而只需要将数据库配置传递给我们的本地数据库。
- en: This kind of situation appears a lot, especially with low-level packages from
    trusted sources, such as the standard library. The key to addressing this is to
    be pragmatic. Ask yourself, do I really need to mock this? Is there some configuration
    I can pass in that will result in less work?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况经常出现，特别是在来自可信来源的低级包中，比如标准库。解决这个问题的关键是要实事求是。问问自己，我真的需要模拟这个吗？有没有一些配置我可以传递进去，从而减少工作量？
- en: At the end of the day, we have to make sure we are getting enough return from
    the extra work, code, and complexity to justify the effort.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们必须确保我们从额外的工作、代码和复杂性中获得足够的回报来证明这种努力是值得的。
- en: Needless indirection
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的间接性
- en: Another way the DI can be misapplied is by introducing abstractions that have
    limited (or no) purpose. Similar to our earlier discussion on injecting config
    instead of objects, this extra level of indirection leads to additional work,
    code, and complexity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: DI被误用的另一种方式是引入有限（或没有）目的的抽象。类似于我们之前讨论的注入配置而不是对象，这种额外的间接性导致了额外的工作、代码和复杂性。
- en: Let's look at an example of a case where you could introduce an abstraction
    to help with testing, but there is really no need.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，你可以引入一个抽象来帮助测试，但实际上并不需要。
- en: 'In the standard HTTP library, there is a struct called `http.ServeMux`. `ServeMux`
    is used to build an HTTP router, which is a mapping between URLs and HTTP handlers.
    Once `ServeMux` is configured, it is then passed into the HTTP server, as shown
    in the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的HTTP库中，有一个名为`http.ServeMux`的结构体。`ServeMux`用于构建HTTP路由器，即URL和HTTP处理程序之间的映射。一旦`ServeMux`配置好了，它就会被传递到HTTP服务器中，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As our service expands, we need to be sure to add more endpoints. To prevent
    API regression, we''ve decided to add some tests to ensure our router is configured
    correctly. Because of our familiarity with DI, we can jump right in and introduce
    an abstraction of `ServerMux` so that we can add a mock implementation. This is
    shown in the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的服务扩展，我们需要确保添加更多的端点。为了防止API回归，我们决定添加一些测试来确保我们的路由器配置正确。由于我们熟悉DI，我们可以立即介绍一个`ServerMux`的抽象，以便我们可以添加一个模拟实现。这在下面的例子中显示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With our abstraction in place, we can define a mock implementation, `MyMux`,
    and write ourselves a test, as shown in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的抽象，我们可以定义一个模拟实现`MyMux`，并编写一个测试，如下面的例子所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This all looks pretty good. The problem, however, is that it wasn't necessary.
    Our goal was to protect ourselves from accidental API regression by testing the
    mapping between the endpoints and URLs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切看起来都很好。然而，问题在于这是不必要的。我们的目标是通过测试端点和URL之间的映射来防止意外的API回归。
- en: 'Our goal can be achieved without mocking the `ServeMux`. First, let''s go back
    to our original function before we introduced the `MyMux` interface, as shown
    in the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标可以在不模拟`ServeMux`的情况下实现。首先，让我们回到我们引入`MyMux`接口之前的原始函数，就像下面的例子所示：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Digging a little deeper into `ServeMux`, we can see that, if we call the `Handler(req
    *http.Request)` method, it will return the `http.Handler` configured to that URL.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解`ServeMux`，我们可以看到，如果我们调用`Handler(req *http.Request)`方法，它将返回配置到该URL的`http.Handler`。
- en: 'Because we know that we are going to do this once for every endpoint, we should
    define a function to do just that, as shown in the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道我们将为每个端点执行一次，所以我们应该定义一个函数来做到这一点，就像下面的例子中所示：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With our function in place, we can now build a test that validates the expected
    handler is returned from for each URL, as shown in the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的函数，我们现在可以构建一个测试，验证每个URL返回预期的处理程序，就像下面的例子中所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous example, you'll also have noticed that our `buildRouter()` function
    and our tests are awfully similar. This leaves us to wonder about the efficacy
    of the tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您可能还注意到我们的`buildRouter()`函数和我们的测试非常相似。这让我们对测试的效果产生了疑问。
- en: In this case, it would be more effective to ensure we have API regression tests
    that validate not only the router's configuration but also the input and output
    formats, just as we did at the end of [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml),
    *Off-the-Shelf Injection*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，更有效的做法是确保我们有API回归测试，验证不仅路由器的配置，还有输入和输出格式，就像我们在[第10章](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml)的结尾所做的那样，*现成的注入*。
- en: Service locator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务定位器
- en: First, a definition—Service locator is a software design pattern that revolves
    around an object that acts as a central repository of all dependencies and is
    able to return them by name. You'll find this pattern in use in many languages
    and at the heart of some DI frameworks and containers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一下——服务定位器是围绕一个对象的软件设计模式，该对象充当所有依赖项的中央存储库，并能够按名称返回它们。您会发现这种模式在许多语言中使用，并且是一些DI框架和容器的核心。
- en: 'Before we dig into why this is DI induced damage, let''s look at an example
    of an overly simplified service locator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨为什么这是DI引起的损害之前，让我们看一个过于简化的服务定位器的例子：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to use our service locator, we first have to create it and map our
    dependencies with their names, as shown in the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的服务定位器，我们首先必须创建它，并将我们的依赖项与它们的名称进行映射，就像下面的例子所示：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With our service locator built and dependencies set, we can now pass it around
    and extract dependencies as needed, as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们构建的服务定位器和设置的依赖项，我们现在可以传递它并根据需要提取依赖项，就像下面的代码所示：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, if we wanted to *swap out* the logger for a mock one during testing, then
    we would only have to construct a new service locator with the mock logger and
    pass it into our function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想在测试期间*替换*日志记录器，那么我们只需要构建一个带有模拟日志记录器的新服务定位器，并将其传递给我们的函数。
- en: So what is wrong with that? Firstly, our service locator is now a God object
    (as mentioned in [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never
    Stop Aiming for Better*) that we would likely end up passing around all over the
    place. It might sound like a good thing to only have to pass one object into every
    function but it leads to the second issue.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那有什么问题呢？首先，我们的服务定位器现在是一个上帝对象（如[第1章](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml)中提到的*永远不要停止追求更好*），我们可能最终会在各个地方传递它。只需要将一个对象传递到每个函数中听起来可能是一件好事，但这会导致第二个问题。
- en: The relationship between an object and the dependencies it uses is now completely
    hidden from the outside. We are no longer able to look at a function or struct
    definition and immediately know what dependencies are required.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和它使用的依赖之间的关系现在完全对外部隐藏了。我们不再能够查看函数或结构定义并立即知道需要哪些依赖。
- en: 'And lastly, we are operating without the protection of Go''s type system and
    compiler. In the previous example, the following line might have caught your attention:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在没有Go类型系统和编译器保护的情况下操作。在前面的例子中，下面的这行可能引起了你的注意：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because the service locator accepts and returns `interface{}`, every time we
    need to access a dependency, we are required to cast into the appropriate type.
    This casting not only makes the code messier, it can cause runtime crash if the
    value is missing or of the wrong type. We can account for these issues with yet
    more code, as shown in the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为服务定位器接受并返回`interface{}`，每次我们需要访问一个依赖项，我们都需要转换为适当的类型。这种转换不仅使代码变得混乱，还可能在值缺失或类型错误时导致运行时崩溃。我们可以通过更多的代码解决这些问题，就像下面的例子所示：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the previous approach, our application will no longer crash, but it's getting
    rather messy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 采用先前的方法，我们的应用程序将不再崩溃，但变得非常混乱。
- en: Premature future-proofing
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过早的未来保护
- en: Sometimes, the application of DI is not wrong, but just unnecessary. A common
    manifestation of this is premature future-proofing. Premature future-proofing
    occurs when we add features to software that we don't yet need, based on the assumption
    that we might need it one day. As you might expect, this results in unnecessary
    work and complexity.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，DI的应用并不是错误的，而只是不必要的。这种常见的表现形式是过早的未来保护。过早的未来保护是指我们根据可能有一天会需要它的假设，向软件添加我们目前不需要的功能。正如你所期望的那样，这会导致不必要的工作和复杂性。
- en: 'Let''s look at an example by borrowing from our example service. Currently,
    we have a Get endpoint, as shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借鉴我们的服务的例子来看一个例子。目前，我们有一个Get端点，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s a simple REST endpoint that returns JSON. If we decided that, one day,
    we might want to output in a different format, we could move the encoding to a
    dependency, as shown in the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的REST端点，返回JSON。如果我们决定，有一天，我们可能想以不同的格式输出，我们可以将编码移到一个依赖项中，如下面的示例所示：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That code looks reasonable. So, where is the problem? Simply put, it's work
    we didn't need to do.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码看起来合理。那么问题出在哪里呢？简单地说，这是我们不需要做的工作。
- en: By extension, it's code that we didn't need to write or maintain. In this simple
    example, our changes only added a small amount of extra complexity and this is
    relatively common. This small amount of additional complexity multiplied across
    the entire system would slow us down.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们不需要编写或维护的代码。在这个简单的例子中，我们的更改只增加了一点额外的复杂性，这是相对常见的。这种少量的额外复杂性在整个系统中的扩散会减慢我们的速度。
- en: If this should ever become an actual requirement, then this is absolutely the
    right way to deliver the feature, but at that point, it's a feature and therefore
    a burden that we must have.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这真的成为一个实际要求，那么这绝对是交付功能的正确方式，但在那时，它是一个功能，因此是我们必须承担的负担。
- en: Mocking HTTP requests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟HTTP请求
- en: Earlier in this chapter, we talked about how the injection is not the answer
    to all problems and, in some cases, passing in configuration is far more efficient
    and a whole lot less code. A frequently occurring example of this occurs when
    we deal with external services, particularly HTTP services such as the upstream
    currency conversion service in our sample service.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们谈到了注入并不是所有问题的答案，在某些情况下，传递配置要高效得多，而且代码要少得多。这种情况经常发生在处理外部服务时，特别是在处理HTTP服务时，比如我们示例服务中的上游货币转换服务。
- en: It is possible to mock an HTTP request to the external service and use the mock
    to thoroughly test calls to an external service, but it's just not necessary.
    Let's look at a side-by-side comparison of mocking versus config by using code
    from our sample service.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以模拟对外部服务的HTTP请求并使用模拟来彻底测试对外部服务的调用，但这并不是必要的。让我们通过使用我们示例服务的代码来比较模拟和配置的差异。
- en: 'The following is the code from our sample service, which calls to the external
    currency conversion service:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们示例服务的代码，调用外部货币转换服务：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before we embark on writing the tests, we should first ask ourselves, what
    do we want to test? Here are the typical test scenarios:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们着手撰写测试之前，我们应该首先问自己，我们想要测试什么？以下是典型的测试场景：
- en: '**Happy path**: The external server returns the data, and we extract it successfully'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常路径**：外部服务器返回数据，我们成功提取数据'
- en: '**Failed/slow request**: The external server returns an error or does not answer
    in time'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败/慢请求**：外部服务器返回错误或在时间上没有响应'
- en: '**Error response**: The external server returns an invalid HTTP response code
    to indicate it''s having issues'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误响应**：外部服务器返回无效的HTTP响应代码，表示它有问题'
- en: '**Invalid response**: The external server returns a payload in a format that
    we don''t expect'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无效响应**：外部服务器返回我们不期望的格式的有效负载'
- en: We will start our comparison by mocking the HTTP request.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过模拟HTTP请求来开始我们的比较。
- en: Mocking an HTTP request with DI
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DI模拟HTTP请求
- en: If we are going to use DI and mocks, then the cleanest option is to mock the
    HTTP request so that we can make it return whatever response we need.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用DI和模拟，那么最干净的选项是模拟HTTP请求，以便我们可以使其返回我们需要的任何响应。
- en: 'To achieve this, the first thing we need to do is abstract building and sending
    of HTTP requests, as shown in the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要做的第一件事是抽象构建和发送HTTP请求，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see we have also included a *go generate* comment that will create the
    mock implementation for us.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们还包括了一个*go generate*注释，它将为我们创建模拟实现。
- en: 'We can then update our `Converter` to use the `Requester` abstraction, as shown
    in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以更新我们的`Converter`以使用`Requester`抽象，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the `requester` abstraction in place, we can use the mock implementation
    to test, as shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`requester`抽象，我们可以使用模拟实现进行测试，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous example, our mock requester returns an invalid response instead
    of calling to the external service. With this, we can ensure that our code behaves
    appropriately when this happens.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们的模拟请求者返回了一个无效的响应，而不是调用外部服务。通过这样做，我们可以确保我们的代码在发生这种情况时表现得恰当。
- en: In order to cover the other typical test scenarios, we would only need to copy
    this test and change the response from the mock and the expectations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了覆盖其他典型的测试场景，我们只需要复制这个测试，并更改模拟的响应和期望。
- en: Now let's compare our mock based tests with the config-based equivalent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将基于模拟的测试与基于配置的等效测试进行比较。
- en: Mocking HTTP requests with config
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置模拟HTTP请求
- en: 'We can test `Converter` without making any code changes at all. The first step
    is to define an HTTP server that returns the response we need. In the following
    example, the server is returning the same as the mock in the previous section:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在不进行任何代码更改的情况下测试`Converter`。第一步是定义一个返回我们需要的响应的HTTP服务器。在下面的示例中，服务器返回的与前一节中的模拟相同：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we take the URL from the test server and pass it in as a config to `Converter`, 
    as shown in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从测试服务器获取URL，并将其作为配置传递给`Converter`，如下面的示例所示：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And now, the following example shows how we can perform the HTTP call and validate
    the response, as we did in the mock version:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下面的示例显示了我们如何执行HTTP调用并验证响应，就像我们在模拟版本中所做的那样：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this approach, we can achieve the same level of test scenario coverage
    as the mock-based version, but with far less code and complexity. Perhaps, more
    importantly, we do not incur the test-induced damage of an additional constructor
    parameter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以实现与基于模拟的版本相同的测试场景覆盖率，但代码和复杂性要少得多。或许更重要的是，我们不会因为额外的构造函数参数而导致测试引起的损害。
- en: Unnecessary injection
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不必要的注入
- en: By now, you are probably thinking, *there are times when using DI is not the
    best option, but how do I know when?* For this, I would like to offer you another
    self-survey.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能会想，“有时使用DI并不是最佳选择，但我怎么知道呢？”为此，我想再给您提供一个自我调查。
- en: 'When you are unsure how to proceed, or before you embark on a potentially big
    refactor, first take a quick run through my DI Survey:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不确定如何继续，或者在进行潜在的大规模重构之前，首先快速浏览一下我的DI调查：
- en: '**Is the dependency an environmental concern (such as logging)?**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖是否是环境问题（比如日志记录）？
- en: Environmental dependencies are necessary but have a tendency to pollute the
    UX of the function, particularly a constructor. Injecting them is appropriate,
    but you should prefer a less obtrusive DI method such as JIT injection or config
    injection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 环境依赖是必要的，但往往会污染函数的用户体验，特别是构造函数。注入它们是合适的，但您应该更倾向于使用较不显眼的DI方法，比如即时注入或配置注入。
- en: '**Are there tests in place to protect us during refactoring?**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重构期间是否有测试来保护我们？
- en: When applying DI to existing code that has low test coverage, adding some monkey
    patching will be the smallest change you can make and therefore the one that poses
    the least risk. Once tests are in place, it will be protected for future changes;
    even if those changes mean the removal of monkey patching.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在对测试覆盖率较低的现有代码应用DI时，添加一些猴子补丁将是您可以进行的最小更改，因此也是风险最小的更改。一旦测试就位，它将受到保护，即使这些更改意味着删除猴子补丁。
- en: '**Is the dependency''s existence informative?**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖的存在是否具有信息性？
- en: What does the existence of the dependency tell the user about the struct? If
    the answer is not much or nothing, then the dependency can be merged into any
    config injection. Similarly, if the dependency does not exist outside the scope
    of this struct, then you can manage it with JIT injection.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖的存在告诉用户有关结构体的什么？如果答案不多或没有，那么依赖可以合并到任何配置注入中。同样，如果依赖在这个结构体的范围之外不存在，那么您可以使用即时注入来管理它。
- en: '**How many implementations of the dependency are you going to have?**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将有多少个依赖的实现？
- en: If the answer is more than one, then injecting the dependency is the right option.
    If the answer is one, then you need to dig a little deeper. Does the dependency
    ever change? If it has never changed, then injecting it is a waste of effort,
    and, likely, adds unnecessary complexity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是多于一个，那么注入依赖是正确的选择。如果答案是一个，那么您需要深入一点。依赖是否会发生变化？如果它从未发生过变化，那么注入它就是一种浪费，而且很可能增加了不必要的复杂性。
- en: '**Is the dependency ever changed outside the tests?**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖是否在测试之外发生过变化？
- en: If it's only changed during testing, then this is a great candidate for JIT
    injection, after all, we want to avoid test-induced damage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它只在测试期间更改，那么这是一个很好的即时注入的候选项，毕竟，我们希望避免测试引起的损害。
- en: '**Does the dependency need to change for each execution?**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖是否需要在每次执行时更改？
- en: If the answer is yes, then you should use method injection. Whenever possible,
    try to avoid adding any logic to your struct that determines which dependency
    you are going to use (for example, `switch` statements). Instead, ensure that
    you either inject the dependency and use it, or inject a factory or locator object
    that includes the logic for deciding the dependency. This will ensure that your
    struct stays clear of any single responsibility related issues. It also helps
    us to avoid making shotgun surgery type changes when we add a new implementation
    of the dependency.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是肯定的，那么你应该使用方法注入。在可能的情况下，尽量避免向结构体添加任何决定要使用哪个依赖的逻辑（例如`switch`语句）。相反，确保您要么注入依赖并使用它，要么注入一个包含决定依赖的逻辑的工厂或定位器对象。这将确保您的结构体不会受到任何与单一职责相关的问题的影响。它还有助于我们避免在添加新的依赖实现时进行大规模的手术式变更。
- en: '**Is the dependency stable?**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖是否稳定？
- en: A stable dependency is something that already exists, is unlikely to change
    (or change in a backward compatible way) and is unlikely to be replaced. Good
    examples of this are the standard library and well managed, infrequently changed
    public packages. If the dependency is stable, then injecting it for the purposes
    of decoupling has less value as the code has not changed and can be trusted.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定的依赖是已经存在的，不太可能改变（或以向后兼容的方式改变），并且不太可能被替换的东西。这方面的很好的例子是标准库和良好管理、很少更改的公共包。如果依赖是稳定的，那么为了解耦而注入它的价值就不那么大，因为代码没有改变，可以信任。
- en: You may wish to inject a stable dependency to be able to test how you are using
    it, as we saw earlier with the SQL package and HTTP client examples. However,
    to avoid test-induced damage and unnecessary complexity, we should either be adopting
    JIT injection, to avoid polluting the UX, or avoiding the injection altogether.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望注入一个稳定的依赖，以便测试您如何使用它，就像我们之前看到的SQL包和HTTP客户端的例子一样。然而，为了避免测试引起的损害和不必要的复杂性，我们应该要么采用即时注入，以避免污染用户体验，要么完全避免注入。
- en: '**Is this struct going to have one or multiple usages?**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个结构体将有一个还是多个用途？
- en: If the struct has only a single use, then pressures on that code to be flexible
    and extendable are low. We can, therefore, favor less injection and more specificity
    in our implementation; at least until our situation changes. On the other hand,
    code that is used in many places will have far more considerable pressure to change
    and, arguably, want to have greater flexibility, to be more useful in more cases.
    In these cases, you will want to favor injection more to give the users more flexibility.
    Just be careful not to have so much injection that the UX of the function is terrible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体只有一个用途，那么对于代码的灵活性和可扩展性的压力就很低。因此，我们可以更倾向于少注入，更具体地实现；至少在我们的情况发生变化之前是这样。另一方面，在许多地方使用的代码将承受更大的变化压力，并且可以说更希望具有更大的灵活性，以便在更多情况下更有用。在这些情况下，您将希望更倾向于注入，以给用户更多的灵活性。只是要小心，不要注入太多，以至于函数的用户体验变得糟糕。
- en: With shared code, you should also spend more effort decoupling your code from
    as many external (non-stable) dependencies as possible. When users adopt your
    code, they may not want to adopt all of your dependencies.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享代码，您还应该更加努力地将代码与尽可能多的外部（不稳定的）依赖解耦。当用户采用您的代码时，他们可能不想采用您的所有依赖项。
- en: '**Is this code wrapping the dependency?**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**这段代码是否包装了依赖项？**'
- en: If we are wrapping a package to make its UX more convenient to insulate us from
    changes in that package, then injecting that package is unnecessary. The code
    we are writing is tightly coupled with the code it is wrapping, so introducing
    an abstraction does not achieve anything significant.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包装一个包以使其用户体验更方便，以隔离我们免受该包中的更改影响，那么注入该包是不必要的。我们编写的代码与其包装的代码紧密耦合，因此引入抽象并没有取得显著成效。
- en: '**Does applying DI make the code better?**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用DI会让代码变得更好吗？**'
- en: This is, of course, extraordinarily subjective but perhaps also the most crucial
    question. Abstraction is useful, but it also adds indirection and complication.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是非常主观的，但也可能是最关键的问题。抽象是有用的，但它也增加了间接性和复杂性。
- en: Decoupling is important but not always necessary. Decoupling between packages
    and layers is more important than decoupling between objects within a package.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 解耦很重要，但并非总是必要的。包和层之间的解耦比包内对象之间的解耦更重要。
- en: With experience and repetition, you'll find that many of these questions will
    become second nature as you develop an intuitive sense of when to apply DI and
    which method to use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过经验和重复，您会发现许多这些问题会变得自然而然，因为您会在何时应用DI以及使用哪种方法方面形成直觉。
- en: 'In the meantime, the following table might help:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，以下表格可能会有所帮助：
- en: '| **  Method** | **  Ideal for:** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| ** 方法** | ** 理想用于：** |'
- en: '| Monkey patching |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Monkey patching |'
- en: Code that relies on a singleton
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于单例的代码
- en: Code that currently has no tests or existing dependency injection
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前没有测试或现有依赖注入的代码
- en: Decoupling packages without making any changes to the dependent package
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦包而不对依赖包做任何更改
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Constructor injection |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数注入 |'
- en: Dependencies that are required
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要的依赖
- en: Dependencies that must be ready before any methods are called
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在调用任何方法之前准备好的依赖项
- en: Dependencies that are used by most or all of the methods of an object
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被对象的大多数或所有方法使用的依赖
- en: Dependencies that don't change between requests
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求之间不会改变的依赖
- en: Dependencies that have multiple implementations
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多个实现的依赖项
- en: '|'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Method injection |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 方法注入 |'
- en: Used with functions, frameworks and shared libraries
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与函数、框架和共享库一起使用
- en: Request-scoped dependencies
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求范围的依赖
- en: Stateless objects
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态对象
- en: Dependencies that provide context or data in the request, and, as such, are
    expected to vary between calls
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求中提供上下文或数据的依赖，因此预计在调用之间会有所变化
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Config injection |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 配置注入 |'
- en: Replacing constructor or method injection to improve the UX of the code
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换构造函数或方法注入以改善代码的用户体验
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| JIT injection |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| JIT注入 |'
- en: Replacing a dependency that would otherwise have been injected into the constructor
    and of which there is only one production implementation
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换本来应该注入到构造函数中的依赖项，并且只有一个生产实现。
- en: Providing a layer of indirection or abstraction between an object and a global
    singleton or environmental dependency. Particularly when we want to swap out the
    global singleton during testing
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象和全局单例或环境依赖之间提供一层间接或抽象。特别是当我们想在测试期间替换全局单例时
- en: Allowing dependencies to be optionally provided by the user
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户可选地提供依赖项
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Off-the-shelf injection |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 现成的注入 |'
- en: Reducing the cost of adopting constructor injection
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少采用构造函数注入的成本
- en: Reducing the complexity of maintaining the order in which dependencies are created
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少创建依赖项顺序的复杂性
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined the effects of applying DI unnecessarily or incorrectly.
    We also discussed some situations where employing DI is not the best tool for
    the job.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了不必要或不正确地应用DI的影响。我们还讨论了一些情况，在这些情况下，采用DI并不是最佳选择。
- en: We then wrapped up the chapter with a list of 10 questions that you can ask
    yourself to determine whether DI is appropriate for your current use case.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用列出了10个问题来帮助您确定DI是否适用于您当前的用例。
- en: In the next chapter, we'll wrap up our examination of DI with a review of everything
    we've discussed throughout this book. In particular, we'll contrast the state
    of our sample service now with its original state. We'll also take a quick look
    at how to start a new service with DI.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结我们对DI的研究，回顾我们在整本书中讨论过的所有内容。特别是，我们将对比我们样本服务的当前状态和原始状态。我们还将简要介绍如何使用DI启动新服务。
- en: Questions
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What form of DI induced damage do you see most often?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你最常见到的DI引起的损害形式是什么？
- en: Why is it important not to blindly apply DI all of the time?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么重要的是不要盲目地一直应用DI？
- en: Does adopting a framework, such as Google Wire, eliminate all forms of DI induced
    damage?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采用Google Wire等框架是否可以消除DI引起的所有损害形式？
