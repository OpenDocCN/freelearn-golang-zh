- en: Building Blocks of the Go Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 语言的基本构建块
- en: Welcome to the first chapter of our journey, where we will learn about full
    stack development in Go. This chapter is dedicated to readers who are not yet
    familiar with Go. If you are already proficient in the Go language, you can skip
    this chapter. We'll cover the basic building blocks that form the foundation of
    the Go language, which will be covered in a brief but practical manner. Then,
    we'll show you the Go syntax for basic programming constructs like functions and
    loops. We'll also cover some concepts that are specific to Go like slice, `panic`,
    and `defer`. This chapter assumes that you have some familiarity with programming
    concepts in general (like variables, functions, loops, and conditional statements).
    This chapter also assumes that you have some familiarity with Terminals, and command
    lines, as well as the concept of environmental variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们旅程的第一章，我们将学习 Go 语言的完整栈开发。本章是为那些还不熟悉 Go 语言的读者准备的。如果你已经精通 Go 语言，你可以跳过这一章。我们将简要但实用地介绍构成
    Go 语言基础的基本构建块。然后，我们将向你展示 Go 语言的函数和循环等基本编程结构的语法。我们还将涵盖一些 Go 语言特有的概念，如切片、`panic`
    和 `defer`。本章假设你对编程概念（如变量、函数、循环和条件语句）有一定的了解。本章还假设你对终端、命令行以及环境变量的概念有一定的了解。
- en: A very good resource to learn about the Go language from scratch can be found
    at [tour.golang.org](http://tour.golang.org).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从零开始学习 Go 语言的极好资源可以在 [tour.golang.org](http://tour.golang.org) 找到。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic concepts—packages, variables, data types, and pointers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本概念——包、变量、数据类型和指针
- en: Functions and closures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和闭包
- en: Conditional statements and loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句和循环
- en: '`panic`, `recover`, and `defer`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panic`、`recover` 和 `defer`'
- en: Go data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 数据结构
- en: Go interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 接口
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you can do either of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的内容，你可以执行以下操作之一：
- en: Go to [play.golang.org](http://play.golang.org), which will allow you to run
    or test your code online
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前往 [play.golang.org](http://play.golang.org)，这将允许你在网上运行或测试你的代码。
- en: Download the Go programming language, along with a compatible IDE
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载 Go 编程语言，以及兼容的集成开发环境（IDE）
- en: If you haven't downloaded Go yet, you can download the Go language by going
    to [https://golang.org/dl/](https://golang.org/dl/), downloading the Go flavor
    for your operating system, and then installing it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有下载 Go，你可以通过访问 [https://golang.org/dl/](https://golang.org/dl/) 下载 Go 语言，下载适合你操作系统的
    Go 版本，然后进行安装。
- en: For the local IDE, I prefer Visual Studio Code ([https://code.visualstudio.com](https://code.visualstudio.com)),
    along with its popular Go plugin ([https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地 IDE，我更喜欢 Visual Studio Code ([https://code.visualstudio.com](https://code.visualstudio.com))，以及其流行的
    Go 插件 ([https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go))。
- en: Go's playground
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 的游乐场
- en: The Go playground is a fairly popular website, which allows the Go community
    to test Go code samples online. The website can be found at [play.golang.org](http://play.golang.org).
    Whenever you would like to quickly test a simple piece of Go code, visit the website
    and run your code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编程语言的游乐场是一个相当受欢迎的网站，它允许 Go 社区在线测试 Go 代码示例。该网站可在 [play.golang.org](http://play.golang.org)
    找到。无论何时你想快速测试一段简单的 Go 代码，请访问该网站并运行你的代码。
- en: Setting up Go's workspace
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Go 的工作空间
- en: 'For you to write Go code on your computer, you need to set up a Go workspace.
    A Go workspace is a folder where you will write your Go code. Setting up a Go
    workspace is relatively simple. Here is what you will need to do:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你的计算机上编写 Go 代码，你需要设置一个 Go 工作空间。Go 工作空间是一个文件夹，你将在其中编写 Go 代码。设置 Go 工作空间相对简单。以下是你需要做的事情：
- en: First, make sure that you have Go installed. As we mentioned earlier, you can
    download and install Go by going to [https://golang.org/dl/](https://golang.org/dl/).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请确保你已经安装了 Go。正如我们之前提到的，你可以通过访问 [https://golang.org/dl/](https://golang.org/dl/)
    下载并安装 Go。
- en: After installing Go, create a new folder in your computer for Go's workspace.
    Mine is called `GoProjects`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Go 后，在你的计算机中为 Go 工作空间创建一个新的文件夹。我的文件夹名为 `GoProjects`。
- en: 'Inside your Go workspace folder, you will have to create three main folders:
    `src`, `pkg`, and `bin`. It is very important to create folders with these exact
    names inside your Go workspace folder. Here is why these three folders are important:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Go 工作空间文件夹内，您必须创建三个主要文件夹：`src`、`pkg` 和 `bin`。在您的 Go 工作空间文件夹内创建具有这些确切名称的文件夹非常重要。以下是这三个文件夹为什么重要的原因：
- en: The `src` folder will host all of your code files. Whenever you decide to start
    a new program, you will simply go to the `src` folder and create a new folder
    with your new program name.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src` 文件夹将托管所有您的代码文件。每次您决定开始一个新的程序时，您只需前往 `src` 文件夹并创建一个以您新程序名称命名的新文件夹。'
- en: The `pkg` folder typically hosts the compiled package files of your code.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg` 文件夹通常托管您的代码的编译包文件。'
- en: The `bin` folder typically hosts the binary files that are produced by your
    Go programs.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin` 文件夹通常托管由您的 Go 程序生成的二进制文件。'
- en: 'You will need to set two environmental variables:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要设置两个环境变量：
- en: The first environmental variable is called `GoRoot`, and will include the path
    to your Go install. `GoRoot` should typically be taken care of by the Go installer.
    However, if it's missing, or you would like to move your Go installation to a
    different place, then you need to set `GoRoot`.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个环境变量被称为 `GoRoot`，它将包含您的 Go 安装路径。通常，`GoRoot` 应由 Go 安装程序处理。但是，如果它缺失，或者您想将您的
    Go 安装移动到不同的位置，那么您需要设置 `GoRoot`。
- en: The second environmental variable is called `GoPath`. `GoPath` includes the
    path to your Go workspace folder. By default, if not set, `GoPath` is assumed
    to either to be at `$HOME/go` on Unix systems or `%USERPROFILE%\go` on Windows.
    There is an entire GitHub page which covers setting up `GoPath` in different operating
    systems, which can be found at [https://github.com/golang/go/wiki/SettingGOPATH](https://github.com/golang/go/wiki/SettingGOPATH).
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个环境变量被称为 `GoPath`。`GoPath` 包含了您 Go 的工作空间文件夹的路径。默认情况下，如果没有设置，`GoPath` 在 Unix
    系统上假定是 `$HOME/go`，在 Windows 系统上假定是 `%USERPROFILE%\go`。有一个整个 GitHub 页面涵盖了在不同操作系统上设置
    `GoPath` 的方法，可以在 [https://github.com/golang/go/wiki/SettingGOPATH](https://github.com/golang/go/wiki/SettingGOPATH)
    找到。
- en: Once your Go environment is set up, you can use the Go tool, which is installed
    alongside the Go language so that you can compile and run your Go programs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的 Go 环境设置完成，您就可以使用 Go 工具，该工具与 Go 语言一起安装，以便您编译和运行您的 Go 程序。
- en: We'll take a look at some of the basic building blocks of the Go language in
    the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看 Go 语言的一些基本构建块。
- en: Packages, variables, data types, and pointers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包、变量、数据类型和指针
- en: Packages, variables, data types, and pointers represent the most basic building
    blocks of the Go language. In this section, we'll cover them one by one from a
    practical point of view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 包、变量、数据类型和指针代表了 Go 语言最基本的构建块。在本节中，我们将从实际的角度逐一介绍它们。
- en: Packages
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: Any Go program consists of one or more packages. Each package is basically a
    folder, which contains one or more Go files. Every single Go code file you write
    must belong to a package. Package folders are found inside the `src` folder of
    your Go workspace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Go 程序都由一个或多个包组成。每个包基本上是一个文件夹，其中包含一个或多个 Go 文件。您所写的每个 Go 代码文件都必须属于一个包。包文件夹位于您的
    Go 工作空间文件夹的 `src` 文件夹内。
- en: 'When you write Go code, you declare your package name at the very top of your
    Go file. Here is what this looks like in code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写 Go 代码时，您需要在您的 Go 文件顶部声明您的包名。以下是代码中的样子：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `mypackage` is the name of the package that my Go file belongs to. It's
    idiomatic in Go to have your package name in lower case letters. It is usually
    preferable to name your package folder the same as your package name. So, when
    you create a new package, simply create a new folder with your package name, and
    then create your package files inside that folder.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mypackage` 是我的 Go 文件所属的包的名称。在 Go 中，使用小写字母的包名是惯例。通常，将包文件夹的名称与包名称相同是首选的做法。因此，当您创建一个新的包时，只需创建一个以您的包名称命名的新文件夹，然后在那个文件夹内创建您的包文件。
- en: 'To import an external package and use it in your own package, you need to use
    the `import` keyword. For example, a popular package in Go''s standard library
    is the `fmt` package, which allows you to write data to the standard output (that
    is, write to your console screen). Let''s assume we want to use the `fmt` package
    from within our package. Here is what the code would look like:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入外部包并在自己的包中使用它，你需要使用`import`关键字。例如，Go标准库中的一个流行包是`fmt`包，它允许你将数据写入标准输出（即写入你的控制台屏幕）。假设我们想在我们的包中使用`fmt`包。代码将如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some package folders can exist inside folders of other packages. For example,
    the folder that contains the `rand` package in Go, which is used to generate random
    numbers, exists inside the folder that contains the `math` package in Go. To import
    a package like that, you need to use the following syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包文件夹可以存在于其他包的文件夹中。例如，Go中包含`rand`包的文件夹，该包用于生成随机数，存在于包含`math`包的文件夹中。要导入这样的包，你需要使用以下语法：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, what if we would like to import multiple packages at once? It''s easy—the
    syntax will end up looking like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想一次性导入多个包，这很简单——语法将看起来像这样：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Go does not allow you to import a package and then not use it to ensure that
    your code is clean and concise. However, there are some cases (which we''ll cover
    later in this book) where you will want to load a package, but not use it directly.
    This can be accomplished by appending an underscore before the package name in
    the import statement. Here is what this would look like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go不允许你导入一个包然后不使用它，以确保你的代码干净简洁。然而，有一些情况（我们将在本书的后面部分讨论）你可能想要加载一个包，但又不直接使用它。这可以通过在导入语句中包名前添加一个下划线来实现。这将如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most famous package name is `main`. Your main package is the first package
    that runs in your Go program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的包名是`main`。你的主包是运行在Go程序中的第一个包。
- en: 'To compile a Go program, you will need to navigate to the folder where your
    `main` package lives in the console, and then type the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译Go程序，你需要在控制台中导航到你的`main`包所在的文件夹，然后输入以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will compile your Go program and then place the resulting binary
    in the `bin` folder of your workspace.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将编译你的Go程序，并将生成的二进制文件放置在你的工作区的`bin`文件夹中。
- en: 'Alternatively, you can run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以运行以下命令：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command will compile and then deploy the resulting binary in the current
    folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将编译并部署生成的二进制文件到当前文件夹。
- en: 'If you would like to specify an output path and a filename, you can run the
    following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要指定输出路径和文件名，你可以运行以下命令：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will compile your code and then package it in an executable called `myexecutable.exe`
    at the specified output folder. If your operating system is not Windows, you can
    ignore the `exe` extension in the preceding example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译你的代码，然后在指定的输出文件夹中打包成一个名为`myexecutable.exe`的可执行文件。如果你的操作系统不是Windows，你可以忽略前面的例子中的`exe`扩展名。
- en: Variables and data types
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和数据类型
- en: 'A variable is another basic building block of the Go language. In Go, to declare
    a variable, you can simply use the `var` keyword. Here is what this looks like:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是Go语言的基本构建块之一。在Go中，要声明变量，你可以简单地使用`var`关键字。这看起来是这样的：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Obviously, `string` is the data type. Let''s say we would like to declare more
    than one variable of type string on the same statement. Here is what this would
    look like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`string`是数据类型。假设我们想在同一个语句中声明多个字符串类型的变量。这看起来是这样的：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To initialize a variable with an initial value, Go offers a number of options.
    One option is to initialize the variable while also specifying the variable type.
    Here is what this looks like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用初始值初始化变量，Go提供了一些选项。一个选项是在指定变量类型的同时初始化变量。这看起来是这样的：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another option is to initialize the variables without specifying the data type.
    Here is what this would look like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是不指定数据类型来初始化变量。这看起来是这样的：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then mix data types with the following syntax:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法混合数据类型：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A popular way to declare and initialize multiple variables at once is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同时声明和初始化多个变量的流行方式如下：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you are declaring and initializing your variable inside a function, you
    don''t need to even use the `var` keyword. Instead, you can use `:=`. This is
    called **type inference**, since you infer the variable type from the provided
    value. Here is how we would declare and initialize the `s`, `i`, and `f` variables
    with type inference:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个函数内部声明和初始化变量，甚至不需要使用 `var` 关键字。相反，你可以使用 `:=`。这被称为 **类型推断**，因为你可以从提供的值中推断变量类型。以下是使用类型推断声明和初始化
    `s`、`i` 和 `f` 变量的方法：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `var` keyword, however, gives you more control since it allows you to explicitly
    specify the data type you would like to use for your variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`var` 关键字提供了更多的控制，因为它允许你显式指定你想要为变量使用的数据类型。
- en: 'Now, let''s discuss data types. Go has a standard set of data types that are
    very similar to data types you''d find in any other statically typed programming
    language. Here is a summary of Go''s standard data types:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来讨论数据类型。Go 语言有一组标准的数据类型，这些数据类型与任何其他静态类型编程语言中的数据类型非常相似。以下是 Go 语言标准数据类型的总结：
- en: '| **Data type(s)** | **Description** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **描述** |'
- en: '| `bool` | A Boolean (either true or false). |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔值（要么是 true，要么是 false）。|'
- en: '| `string` | A `string` is a collection of `byte` and can hold any characters.
    Strings are read only (immutable), so whenever you need to add or remove characters
    from a string, you are in effect creating a new string. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `string` 是 `byte` 的集合，可以存储任何字符。字符串是只读的（不可变），所以每次你需要向字符串中添加或删除字符时，实际上是在创建一个新的字符串。|'
- en: '| `int`, `int8`, `int16`, `int32`, and `int64` | Signed integer types. They
    represent non-decimal numbers that can be either positive or negative. As you
    can probably tell from the type names, you can explicitly specify the number of
    bits that it can allow. If you go with the `int` type, it will pick the number
    of bits that correspond to your environment. For most modern CPU architectures,
    it will pick 64 bits, unless you are working with a smaller CPU or older environment.
    For smaller CPUs or older environments, the choice becomes 32 bits. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `int`、`int8`、`int16`、`int32` 和 `int64` | 有符号整数类型。它们表示非十进制数，可以是正数或负数。从类型名称中你可能已经猜到，你可以显式指定它可以允许的位数。如果你选择
    `int` 类型，它将选择与你的环境相对应的位数。对于大多数现代 CPU 架构，它将选择 64 位，除非你正在使用较小的 CPU 或较旧的环境。对于较小的
    CPU 或较旧的环境，选择变为 32 位。|'
- en: '| `uint`, `uint8`, `uint16`, `uint32`, `uint64`, and `uintptr` | Unsigned integer
    types. They represent non-decimal numbers, which can only be positive. Except
    for the signage, they are similar to their signed brethren. The `uintptr` type
    is an unsigned integer type that is large enough to hold a memory address. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `uint`、`uint8`、`uint16`、`uint32`、`uint64` 和 `uintptr` | 无符号整数类型。它们表示非十进制数，只能为正数。除了符号外，它们与它们的带符号兄弟相似。`uintptr`
    类型是一个足够大的无符号整数类型，可以存储内存地址。|'
- en: '| `byte` | An alias for `uint8`, it holds 8 bits, which basically represents
    a byte of memory. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `uint8` 的别名，它包含 8 位，基本上代表一个字节的内存。|'
- en: '| `rune` | An alias for `int32`, it is typically used to represent a Unicode
    character. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `rune` | `int32` 的别名，通常用于表示 Unicode 字符。|'
- en: '| `float32` and `float64` | Simply decimal numbers. For smaller decimal numbers,
    use the `float32` type, as it only allows 32 bits of data. For larger decimal
    numbers, use the `float64` type, as it only allows 64 bits of data. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `float32` 和 `float64` | 简单的十进制数。对于较小的十进制数，使用 `float32` 类型，因为它只允许 32 位的数据。对于较大的十进制数，使用
    `float64` 类型，因为它只允许 64 位的数据。|'
- en: '| `complex64` and `complex128` | Complex numbers. Those data types are useful
    for programs where serious math is needed. The first type, `complex64`, is a complex
    number where the real part is a 32-bit float, and the imaginary part is a 32-bit
    float. The second type, `complex128`, is a complex number where the real part
    is a 64-bit float, while the imaginary part is a 64-bit float. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` 和 `complex128` | 复数。这些数据类型在需要严肃数学的程序中非常有用。第一种类型 `complex64` 是一个复数，其实部是一个
    32 位浮点数，虚部也是一个 32 位浮点数。第二种类型 `complex128` 是一个复数，其实部是一个 64 位浮点数，而虚部也是一个 64 位浮点数。|'
- en: 'Variables that are declared without an explicit initial values get assigned
    what is known as **zero values**. Here is a table for zero values:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显式初始值的变量会被分配所谓的 **零值**。以下是零值的表格：
- en: '| **Type(s)** | **Zero value** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **零值** |'
- en: '| Numeric types | `0` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 数值类型 | `0` |'
- en: '| Boolean types | `false` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 布尔类型 | `false` |'
- en: '| String type | `""` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 字符串类型 | `""` |'
- en: '| Pointers | `nil` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 指针 | `nil` |'
- en: Pointers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针
- en: The concept of pointers is simple—a **pointer** is a language type that represents
    the memory locations of your values. Pointers in Go are used everywhere, and that's
    because they give the programmer a lot of power over the code. For example, having
    access to your value in memory allows you to change the original value from different
    parts of your code without the need to copy your value around.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的概念很简单——**指针**是一种语言类型，它表示您的值的内存位置。Go 中的指针无处不在，这是因为它们给程序员提供了很多对代码的控制权。例如，访问内存中的值允许您从代码的不同部分更改原始值，而无需复制您的值。
- en: 'In Go, to create a pointer, you just append `*` in front of the data type of
    your value. For example, here is a pointer to an `int` value:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，要创建一个指针，只需在您的值的数据类型前添加 `*` 即可。例如，这里是一个指向 `int` 值的指针：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we mentioned in the previous section, the zero value of a pointer is `nil`.
    The behavior of `nil` is similar to `null` in languages like Java, that is, if
    you try to use a `nil` pointer, an error will get thrown.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，指针的零值是 `nil`。`nil` 的行为类似于 Java 等语言中的 `null`，也就是说，如果您尝试使用 `nil`
    指针，将会抛出一个错误。
- en: 'Now, let''s assume we have a value of type `int` called `x`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个名为 `x` 的 `int` 类型的值：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also want a pointer to point to the address of `x` for later use:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要一个指针指向 `x` 的地址，以供以后使用：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `&` operand here means that we want the address of `x`. Whenever you append
    the `&` operand before a variable, it basically means that we want to the address
    of that variable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `&` 运算符意味着我们想要 `x` 的地址。每次在变量前添加 `&` 运算符时，它基本上意味着我们想要该变量的地址。
- en: 'What if we have a pointer, and we want to retrieve the value that it points
    to? This operation is called **de-referencing**, and here is how we can do it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个指针，并且我们想要检索它指向的值呢？这个操作称为 **解引用**，下面是如何进行操作的示例：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we de-referenced the pointer `xptr` to obtain the value
    that it points to, and then we stored a copy of the value in a new variable called
    `y`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们解引用了指针 `xptr` 来获取它指向的值，然后我们将值的副本存储在一个名为 `y` 的新变量中。
- en: 'What if we want to change the value that the pointer points to? We can still
    use de-referencing for that, and here is what this would look like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更改指针指向的值呢？我们仍然可以使用解引用来做到这一点，下面是这个操作的示例：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Perfect! With this, you should have enough knowledge to use Go pointers in your
    code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！有了这些，您应该具备足够的知识来在代码中使用 Go 指针。
- en: If you already have experience in pointers from a different programming language
    like C or C++, you are probably familiar with the concept of pointer arithmetic.
    This is when you perform arithmetic operations (like addition or subtraction)
    on pointers to go to different memory addresses. By default, Go does not support
    pointer arithmetic on vanilla pointers like the ones we described in this section.
    However, there is a package called `unsafe` that allows you to do so. The `unsafe`
    package is only there to give you the power, should you need it. However, it is
    highly recommended that you don't use it unless you absolutely have to.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经从 C 或 C++ 等不同的编程语言中获得了指针的经验，您可能熟悉指针算术的概念。这是指在指针上进行算术运算（如加法或减法），以到达不同的内存地址。默认情况下，Go
    不支持我们对本节中描述的纯指针进行指针算术。然而，有一个名为 `unsafe` 的包允许您这样做。`unsafe` 包仅存在于为您提供权力的目的，如果您确实需要，但强烈建议除非绝对必要，否则不要使用它。
- en: Now, let's explore functions and closures in Go.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索 Go 中的函数和闭包。
- en: Functions and closures
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和闭包
- en: It's time to talk about functions and closures, so sit tight and enjoy the journey.
    Functions are considered one of the key building blocks in any programming language,
    as they allow you to define actions in your code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论函数和闭包了，所以请坐稳并享受这段旅程。函数被认为是任何编程语言中的关键构建块之一，因为它们允许您在代码中定义操作。
- en: Let's discuss the basics of functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论函数的基础知识。
- en: Functions – the basics
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数 – 基础
- en: 'Here is how you write a function in Go:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在 Go 中编写函数的示例：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `main` function is almost always the first function that gets executed in
    your Go program. The `main` function needs to live inside the `main` package,
    since `main` is the entry point package for your Go program.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数几乎总是您 Go 程序中首先执行的功能。`main` 函数需要位于 `main` 包中，因为 `main` 是您 Go 程序的入口点包。'
- en: 'Here is what a function with arguments would look like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个带有参数的函数的示例：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the `a` and `b` arguments from the preceding code are of the same type,
    we can also do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码中的 `a` 和 `b` 参数类型相同，我们也可以这样做：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s say we want to return a value from our function. Here is what this
    would look like:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想从我们的函数中返回一个值。这看起来会是这样：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Go also allows multiple returns, so you can do this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言还允许多重返回，所以你可以这样做：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In Go, there is a concept known as *named returns*, which basically means that
    you can name your return values in the function header. Here is what this looks
    like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，有一个称为 *named returns* 的概念，这基本上意味着你可以在函数头部命名你的返回值。这看起来是这样的：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Functions are also first-class citizens in the Go language, which means that
    you can assign a function to a variable and use it as a value. Here is an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，函数也是一等公民，这意味着你可以将一个函数赋值给一个变量，并使用它作为值。以下是一个示例：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because of this, you can also pass functions as arguments to other functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，你还可以将函数作为参数传递给其他函数：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is an example of us making use of the `execute` function we defined previously:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示了我们如何使用之前定义的 `execute` 函数：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Go also supports the concept of variadic functions. A **variadic function**
    is a function that can take an unspecified number of arguments. Here is an example
    of an `adder` function that takes an unspecified number of `int` arguments and
    then adds them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言还支持可变参数函数的概念。一个 **可变参数函数** 是一个可以接受任意数量参数的函数。以下是一个 `adder` 函数的示例，它接受任意数量的
    `int` 参数并将它们相加：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding function takes any number of `int` arguments and then sums them
    all. We''ll cover the `for..range` syntax here later in this chapter, under the
    *Conditional statements and loops* section. We can then call our new function
    using the following syntax:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数接受任意数量的 `int` 参数，然后将它们全部相加。我们将在本章的 *条件语句和循环* 部分稍后介绍 `for..range` 语法。然后我们可以使用以下语法调用我们的新函数：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll look at how functions can be accessed from other packages in the next
    section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何从其他包中访问函数。
- en: Functions – accessing functions from other packages
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数 – 从其他包访问函数
- en: Earlier in this chapter, we covered the concept of packages, and the fact that
    a Go program is composed of a number of connected packages. So, how do we really
    connect packages? We connect packages by having the ability to call functions
    and retrieve types from other packages. But then comes the question, how do we
    expose a function to other packages?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们介绍了包的概念，以及一个 Go 程序由多个连接的包组成的事实。那么，我们究竟是如何连接包的呢？我们通过能够从其他包中调用函数和检索类型来连接包。但随之而来的问题是，我们如何将一个函数暴露给其他包？
- en: In Go, there are no `private` or `public` keywords like in most other statically
    typed programming languages. If you want your function to be `public`, all you
    need to do is start your function name with an upper case letter. In Go, that
    is known as making your function **exported**. If, on the other hand, your function
    starts with a lower case letter, then your function is considered **unexpected**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，没有像大多数其他静态类型编程语言那样的 `private` 或 `public` 关键字。如果你想使你的函数 `public`，你只需要将函数名以大写字母开头。在
    Go 语言中，这被称为使你的函数 **exported**。相反，如果你的函数以小写字母开头，那么你的函数被认为是 **unexpected**。
- en: 'To absorb the preceding two paragraphs, let''s go through some code. Here is
    a package called `adder`, which contains a single function called `Add`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解前面的两段内容，让我们通过一些代码来实践。这里有一个名为 `adder` 的包，它包含一个名为 `Add` 的单个函数：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s say we want to call `Add` from a different package. Here is what
    we''d do:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想从一个不同的包中调用 `Add`。以下是我们会做的事情：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we called the exported function `Add` from our main
    package, at our `main` function. We did two things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在主包的 `main` 函数中调用了导出的函数 `Add`。我们做了两件事：
- en: Used the `import` keyword to load the `adder` package
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `import` 关键字加载 `adder` 包
- en: In the main function, we called `adder.Add(..)`
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主函数中，我们调用了 `adder.Add(..)`
- en: 'As demoed, to call an exported function, you need to use the following syntax:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如演示所示，要调用导出的函数，你需要使用以下语法：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If in the `adder` package we had named our function `add` instead of `Add`,
    the preceding code would not have worked. This is because when the function starts
    with a lower case letter it would be considered unexpected, which in effect means
    that it will be invisible to other packages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `adder` 包中我们将函数命名为 `add` 而不是 `Add`，那么前面的代码将不会工作。这是因为当函数以小写字母开头时，它会被认为是意外的，这实际上意味着它对其他包是不可见的。
- en: Let's see a couple of examples from Go's standard package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Go标准包中的几个例子。
- en: 'A very popular package from the Go standard packages is the `fmt` package.
    The `fmt` package can write to the standard output of your environment. It can
    also format strings and scan data from the standard input, among other things.
    Here is a simple but very commonly used code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准包中的一个非常流行的包是`fmt`包。`fmt`包可以写入你的环境的标准输出。它还可以格式化字符串并从标准输入扫描数据，等等。以下是一个简单但非常常用的代码片段：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we called a function called `Println`, which lives inside
    the `fmt` package. The `Println` function will take your string message and print
    it on the standard output. The output of the preceding program is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们调用了一个名为`Println`的函数，该函数位于`fmt`包中。`Println`函数将接受你的字符串消息并将其打印到标准输出。前面程序的输出如下：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another popular package in the world of Go is `math/rand`, which we can use
    to generate random numbers. As we mentioned in the *Packages *section, earlier
    in this chapter, the reason why the package name is not just `rand` is simply
    because the `rand` package folder exists underneath the folder of the `math` package.
    So, even though `rand` is more of a sub-package, we just use the package name
    when we need to call exported functions that belong to it. Here is a simple example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的世界中，另一个流行的包是`math/rand`，我们可以用它来生成随机数。正如我们在本章前面的*包*部分提到的，包名不是`rand`而是`math/rand`，这仅仅是因为`rand`包文件夹位于`math`包文件夹之下。所以，尽管`rand`更像是子包，但我们只需要在需要调用属于它的导出函数时使用包名。以下是一个简单的例子：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we imported two packages—the `fmt` package and the `math/rand`
    package. We then invoked two functions from each of the packages. We first invoked
    the `Println` function, which belongs to the `fmt` package, to output a string
    to the standard output. Then, we invoked the `Intn` function, which belongs to
    the `math/rand` package, to generate a random number between zero and nine.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了两个包——`fmt`包和`math/rand`包。然后，我们从每个包中调用了两个函数。我们首先调用了属于`fmt`包的`Println`函数，将其输出到标准输出。然后，我们调用了属于`math/rand`包的`Intn`函数，以生成介于零和九之间的随机数。
- en: Now, let's take a look at what constitutes closures.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看闭包的构成。
- en: Closures
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'A function can also be a closure. A **closure** is a function value that''s
    bound to variables outside its body. This means that a closure can access and
    change values on those variables. It is hard to understand closures without an
    example. Here is another flavor of the adder function, which returns a closure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以是闭包。闭包是一个与外部变量绑定的函数值。这意味着闭包可以访问和改变这些变量的值。没有例子很难理解闭包。以下是对加法函数的另一种风格的示例，它返回一个闭包：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The closure in the preceding example has access to the `sum` variable, which
    means that it will remember the current value of the `sum` variable, and will
    also be able to change the value of the `sum` variable. Again, this is best explained
    with another example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，闭包可以访问`sum`变量，这意味着它会记住`sum`变量的当前值，并且还能改变`sum`变量的值。再次强调，这最好通过另一个例子来解释：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We have covered the basics of Go. In the following section, we'll move on and
    discuss Go data structures.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Go的基础知识。在下一节中，我们将继续讨论Go数据结构。
- en: Go data structures
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go数据结构
- en: In this section, we'll discuss more key concepts of the Go language. It's time
    to explore the foundational data structures that we need to build non-trivial
    programs in the Go language.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Go语言的一些关键概念。现在是时候探索构建Go语言非平凡程序所需的基础数据结构了。
- en: In the following sections, we'll discuss the various Go data structures, including
    arrays, slices, maps, Go structs, and methods.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论Go的各种数据结构，包括数组、切片、映射、Go结构和方法。
- en: Arrays
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a common data structure that exists in any programming language.
    In Go, an array is a collection of values with the same data type, and a pre-defined
    size.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是任何编程语言中都存在的常见数据结构。在Go中，数组是具有相同数据类型和预定义大小的值的集合。
- en: 'Here is how to declare an array in Go:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在Go中声明数组的示例：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding array is of type `int` and of size `3`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数组是`int`类型，大小为`3`。
- en: 'We can then initialize the array like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样初始化数组：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or, we can do this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样做：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, similarly to other variables, we can declare and initialize
    the array on the same line, like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，类似于其他变量，我们可以在同一行声明和初始化数组，如下所示：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or, if we are declaring and initializing the array inside a function, we can
    use the `:=` notation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们是在函数内部声明和初始化数组，我们可以使用`:=`符号：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Go provides a built-in function called `len()`, which returns the size/length
    of your array. For example, let''s say we run the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个名为`len()`的内置函数，它返回数组的大小/长度。例如，假设我们运行以下代码：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The output will simply be `3`, since the size of `myarray` is `3`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将简单地是`3`，因为`myarray`的大小是`3`。
- en: 'Go also allows you to capture subarrays of your main array. To do that, you
    need to follow the following syntax:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Go还允许你捕获主数组中的子数组。要做到这一点，你需要遵循以下语法：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For example, let''s say I declare a new array that looks like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我声明了一个看起来像这样的新数组：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I can obtain a subarray from index two of my array till index three using the
    following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用以下语法从我的数组索引二到索引三获取一个子数组：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The two indexes that were passed to the preceding syntax were `2` to indicate
    that we would like to start from index two, and then `4` to indicate that we would
    like to stop at index four (*3+1=4*).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给前面语法的两个索引是`2`，表示我们想要从索引二开始，然后是`4`，表示我们想要在索引四停止（*3+1=4*）。
- en: 'Inside the square brackets of the preceding syntax, you can also leave either
    side empty. Let''s say you leave the left-hand side empty, like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语法中，方括号内你也可以留空任意一边。比如说，你让左边留空，就像这样：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This indicates that you want a subarray from index zero until index three.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示你想要从索引零到索引三的子数组。
- en: 'However, let''s say you leave the right-hand side empty, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设你让右边留空，就像这样：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This indicates that the subarray will start from index two until the end of
    your original array.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示子数组将从索引二开始，直到你的原始数组末尾。
- en: 'Let''s say you do something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你做了类似这样的事情：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`mySubArray` is not merely a copy of a subpart of `myarray`. In fact, both
    arrays will point to the same memory. Let''s elaborate by using an example. Here
    is a simple program:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`mySubArray`不仅仅是`myarray`子部分的副本。实际上，这两个数组将指向相同的内存。让我们通过一个例子来详细说明。以下是一个简单的程序：'
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This program output `myarray`, but it does so after we change a value in `mySubArray`.
    As you can see in the preceding code, the original values in `myarray` were `1`,
    `2`, `3`, `4`, and `5`. However, because we changed the value at index `0` of
    `mySubArray`, which is index `2` of `myarray`, the output will end up being as
    follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序输出`myarray`，但它是在我们更改`mySubArray`中的值之后输出的。正如你在前面的代码中所看到的，`myarray`中的原始值是`1`、`2`、`3`、`4`和`5`。然而，因为我们更改了`mySubArray`中索引`0`的值，也就是`myarray`中索引`2`的值，所以输出最终会变成以下这样：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Perfect! We now have a solid idea about how to make use of arrays in Go. Let's
    move on to slices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们现在对如何在Go中使用数组有了清晰的认识。让我们继续学习切片。
- en: Slices
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: There is a very obvious limitation in Go's array data structure—you must specify
    the size whenever you declare a new array. In real life, there are numerous scenarios
    where we will not know the number of elements to expect beforehand. Almost every
    modern programming language comes with its own data structure to address this
    requirement. In Go, this special data structure is called a **slice**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Go的数组数据结构有一个非常明显的限制——你必须在声明新数组时指定大小。在现实生活中，有许多场景我们事先不知道期望的元素数量。几乎每种现代编程语言都有自己的数据结构来满足这一需求。在Go中，这个特殊的数据结构被称为**切片**。
- en: 'From a practical point of view, you can think of slices as simply dynamic arrays.
    From a syntax point of view, slices look very similar to arrays, except that you
    don''t need to specify the size. Here is an example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，你可以把切片简单地看作是动态数组。从语法的角度来看，切片看起来与数组非常相似，只是你不需要指定大小。以下是一个例子：
- en: '[PRE54]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As you can see, slice declarations are very similar to array declarations, except
    for the fact that you don't need to specify the number of elements on a slice.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，切片声明与数组声明非常相似，只是切片不需要指定元素数量。
- en: 'Here is us initializing the preceding slide with some initial values:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们用一些初始值初始化前面幻灯片的例子：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s declare and then initialize this with some initial values in one go:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次性声明并初始化这个数组的一些初始值：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since slices can grow in size, we are also allowed to initialize an empty slice:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片可以增长大小，我们也可以初始化一个空的切片：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you would like to set an initial number of elements in your slice without
    having to write the initial values by hand, you can utilize a built-in function
    called `make`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在切片中设置初始元素数量而不必手动编写初始值，你可以利用一个名为 `make` 的内置函数：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding code will declare and initialize an `int` slice with an initial
    length of `5` elements.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将声明并初始化一个初始长度为 `5` 个元素的 `int` 切片。
- en: To write efficient Go code that can benefit from slices, you need to first understand
    how slices work internally.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写高效的 Go 代码并从切片中受益，你首先需要了解切片是如何在内部工作的。
- en: 'A slice can simply be considered as a pointer to a part of an array. A slice
    holds three main pieces of information:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简单地将切片视为指向数组一部分的指针。切片包含三个主要信息：
- en: A pointer to the first element of the subarray that the slice points to.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向切片指向的子数组第一个元素的指针。
- en: The length of the subarray that's exposed to the slice.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片暴露的子数组的长度。
- en: The capacity, which is the remaining number of items available in the original
    array. The capacity is always either equal to the length or greater.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量，即原始数组中剩余的项目数量。容量始终等于长度或更大。
- en: This sounds too theoretical, so let's utilize the power of code and some visualization
    to provide a practical explanation about how slices really work.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来太理论化了，所以让我们利用代码和一些可视化来提供一个关于切片实际工作方式的实际解释。
- en: 'Let''s assume we created a new slice:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建了一个新的切片：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Internally, the new slice we created points to an array with the `5` initial
    values that we set:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们内部创建的新切片指向一个包含我们设置的 `5` 个初始值的数组：
- en: '![](img/0e483bc4-58e4-4123-bc9d-a01fc27008ff.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e483bc4-58e4-4123-bc9d-a01fc27008ff.jpg)'
- en: 'As you can see from the preceding diagram, `mySlice` held three pieces of information:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`mySlice` 包含了三个信息：
- en: The first is a pointer to the array underneath, which holds the data
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是数组底部的指针，它包含数据
- en: The second is the length of the slice, which is `5` in this case
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是切片的长度，在这个例子中是 `5`
- en: The third is the full capacity of the slice, which is also `5` in this case
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个是切片的完整容量，在这个例子中也是 `5`
- en: The preceding diagram, however, doesn't really clarify how the capacity of the
    slice can be different from its length. To uncover the practical differences between
    length and capacity, we'll need to dig a bit deeper.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前图并没有真正阐明切片的容量如何与长度不同。为了揭示长度和容量之间的实际差异，我们需要深入挖掘。
- en: 'Let''s say we decided to extract a subslice from the original slice:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定从原始切片中提取一个子切片：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Reslicing `mySlice` will not produce a new, smaller copy of the array underneath.
    Instead, the preceding line of code will produce the following slice:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 重新切片 `mySlice` 不会产生数组底下的新、更小的副本。相反，前面的代码行将产生以下切片：
- en: '![](img/7baa87c2-4aad-4fc8-b066-00dbc46c87b8.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7baa87c2-4aad-4fc8-b066-00dbc46c87b8.jpg)'
- en: Since `subSlice` includes the elements at index two and index three of `mySlice`,
    the length of `subSlice` is two (remember that an array index starts at zero,
    which is why index two is the third element and not the second). The capacity
    is different, however, and that is because the original array has three elements
    left, starting from index two, so the capacity is three and not two, even though
    the length is two.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `subSlice` 包含 `mySlice` 的索引二和索引三的元素，因此 `subSlice` 的长度是两个（记住数组索引从零开始，这就是为什么索引二是第三个元素而不是第二个）。然而，容量不同，这是因为原始数组从索引二开始还剩下三个元素，所以容量是三个，而不是两个，尽管长度是两个。
- en: So, in other words, the length of `subSlice` is two because `subSlice` only
    cares about two elements. However, the capacity is three because there are three
    elements left in the original array, starting from index two, which is the index
    that the `subSlice` array pointer points to.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，换句话说，`subSlice` 的长度是两个，因为 `subSlice` 只关心两个元素。然而，容量是三个，因为从索引二开始，原始数组中还有三个元素，这是
    `subSlice` 数组指针指向的索引。
- en: 'There is a built-in function called `cap`, which we can use to get the capacity
    of a slice:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `cap` 的内置函数，我们可以用它来获取切片的容量：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The built-in function called `len` that we use for arrays works with slices
    as well, since it will give you the length of the slice:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于数组的内置函数 `len` 也可以用于切片，因为它会给你切片的长度：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You might be wondering by now, why should I care about the differences between
    length and capacity? I can just use the length and ignore the capacity altogether,
    since the capacity only gives you information about a hidden internal array.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能想知道，为什么我应该关心长度和容量的区别？我只需要使用长度，完全忽略容量即可，因为容量只提供了关于隐藏内部数组的信息。
- en: The answer is very simple—**memory utilization**. What if `mySlice` had 100,000
    elements instead of just five? This means that the internal array would have had
    100,000 elements as well. This huge internal array will exist in our program's
    memory as long as we use any sub-slices extracted from `mySlice`, even if the
    sub-slices we use only care about two elements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 答案非常简单——**内存利用率**。如果`mySlice`有100,000个元素而不是仅仅五个呢？这意味着内部数组也将有100,000个元素。这个巨大的内部数组将存在于我们程序的内存中，只要我们使用从`mySlice`提取的任何子切片，即使我们使用的子切片只关心两个元素。
- en: To avoid that kind of memory bloat, we need to explicitly copy the fewer elements
    we care about into a new slice. By doing this, once we stop using the original
    large slice, Go's garbage collector will realize that the huge array is not needed
    anymore and will clean it up.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种内存膨胀，我们需要明确地将我们关心的较少元素复制到一个新的切片中。通过这样做，一旦我们停止使用原始的大切片，Go的垃圾回收器就会意识到巨大的数组不再需要，并将其清理掉。
- en: 'So, how do we achieve that? This can be done through a built-in function called
    `copy`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现这一点呢？这可以通过一个内置函数`copy`来完成：
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Perfect! With this, you should have a fairly practical understanding about slice
    internals and how to avoid memory bloats in slices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！有了这个，你应该对切片的内部结构和如何在切片中避免内存膨胀有了相当实际的理解。
- en: 'We keep saying that slices are like dynamic arrays, but we haven''t seen how
    to actually grow the slice yet. Go offers a simple built-in function called `append`,
    which is used to add values to a slice. If you reach the end of your slice capacity,
    the `append` function will create a new slice with a bigger internal array to
    hold your expanding data. `append` is a variadic function, so it can take any
    number of arguments. Here is what this looks like:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直说切片就像动态数组，但我们还没有看到如何实际扩展切片。Go提供了一个简单的内置函数`append`，用于向切片中添加值。如果你达到了切片容量的极限，`append`函数将创建一个新的切片，其中包含更大的内部数组来存储你正在扩展的数据。`append`是一个可变参数函数，因此它可以接受任意数量的参数。下面是这个过程的示例：
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'One last important thing to mention is the built-in function called `make`.
    We already covered the `make` function earlier and how it can be used to initialize
    a slice:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的一个重要的事情是内置函数`make`。我们之前已经介绍了`make`函数以及它是如何用来初始化切片的：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The argument `3` in the preceding code represents the slice''s length. What
    we haven''t mentioned yet though is the fact that `make` can also be used to specify
    the capacity of the slice. This can be achieved by using the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的参数`3`代表切片的长度。但我们还没有提到的是，`make`也可以用来指定切片的容量。这可以通过以下代码实现：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we don''t provide the capacity to the `make()` function, the length argument
    value becomes the capacity as well, so in other words, we get the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不向`make()`函数提供容量，长度参数的值也将成为容量，换句话说，我们得到以下结果：
- en: '[PRE67]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, it's time to talk about maps.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候讨论map了。
- en: Maps
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maps
- en: HashMaps are very popular, and extremely important data structures in any programming
    language. A **map** is a collection of key value pairs, where you use the key
    to obtain the value that corresponds to it. Using maps greatly speeds up your
    software due to the fact that with a map, retrieving a value through a key is
    a very quick operation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: HashMaps在任何编程语言中都是非常流行且极其重要的数据结构。一个**map**是一个键值对的集合，你使用键来获取与之对应的值。使用map可以大大加快你的软件速度，因为使用map通过键获取值是一个非常快速的操作。
- en: 'In Go, you can declare a map like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你可以这样声明一个map：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding code declares a map where the keys are of type `int`, and the
    values are of type `string`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明了一个map，其中键的类型为`int`，值类型为`string`。
- en: 'You can initialize a map using the `make` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`make`函数来初始化一个map：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can''t use a map before you initialize it, otherwise an error will be thrown.
    Here is another way to initialize a map:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化之前你不能使用map，否则会抛出错误。这里还有另一种初始化map的方法：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'What if you want to initialize the map with some values? You can do this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用一些值初始化map，你可以这样做：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To add values to an existing map, you can do this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要向现有的map中添加值，你可以这样做：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To obtain a value from a map, you can do the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个map中获取值，你可以这样做：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can also check if a key exists in a map by using the following syntax,
    assuming that your code is inside a function block:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下语法检查映射中是否存在键，假设你的代码在一个函数块中：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can delete a value from a map by using the built-in `delete` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用内置的 `delete` 函数从映射中删除值：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Struct
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: 'A struct in Go is a data structure that is composed of fields, where each field
    has a type. Here is what a Go struct looks like:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，`struct` 是一种由字段组成的数据结构，其中每个字段都有一个类型。下面是一个 Go `struct` 的样子：
- en: '[PRE76]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding code creates a `struct` type that is called `myStruct`, which
    contains three fields:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码创建了一个名为 `myStruct` 的 `struct` 类型，它包含三个字段：
- en: '`intField` of type `int`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intField` 类型为 `int`'
- en: '`stringField` of type `string`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stringField` 类型为 `string`'
- en: '`sliceField` of type `[]int`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sliceField` 类型为 `[]int`'
- en: 'You can then initialize and use that `struct` type in your code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在你的代码中初始化和使用该 `struct` 类型：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The preceding method of initialization is also known as **struct literals**.
    There is a shorter version of it that looks like this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述初始化方法也被称为 **结构字面量**。它有一个更简短的版本，如下所示：
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can also use what is known as *dot notation*, which looks as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用所谓的 *点符号*，如下所示：
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can obtain a pointer to a `struct` by doing this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式获得 `struct` 的指针：
- en: '[PRE80]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'A dot notation can be used with a Go struct pointer, since Go will understand
    what needs to be done without the need to do any pointer de-referencing:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用点符号与 Go `struct` 指针一起使用，因为 Go 会理解需要做什么，而无需进行任何指针解引用：
- en: '[PRE81]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If the Go struct field names start with lower case letters, they will not be
    visible to external packages. If you want your struct or its fields to be visible
    to other packages, start the struct and/or field name with upper case letters.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Go `struct` 字段名以小写字母开头，它们将对外部包不可见。如果你想让你的 `struct` 或其字段对其他包可见，请以大写字母开头命名
    `struct` 和/或字段。
- en: Now, let's talk about Go methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈 Go 中的方法。
- en: Methods
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'A method is basically a function that you attach to a type. For example, let''s
    assume we have a `struct` type called `Person`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 方法基本上是一个附加到类型的函数。例如，假设我们有一个名为 `Person` 的 `struct` 类型：
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Go allows us to attach a method to that type like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许我们以这种方式给该类型附加一个方法：
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The part between the `func` keyword and the function name, `GetName()`, is known
    as the **receiver** of the method.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `func` 和函数名 `GetName()` 之间的部分被称为 **方法接收者**。
- en: 'Let''s say we declare a value of type `Person`, like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们声明一个 `Person` 类型的值，如下所示：
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we can invoke the `GetName` method of value `p`, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下方式调用值 `p` 的 `GetName` 方法：
- en: '[PRE85]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s create another method called `GetAge()`, which returns the `age` of
    the attached `person`. Here is the code to do so:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为 `GetAge()` 的方法，它返回附加的 `person` 的 `age`。以下是实现此功能的代码：
- en: '[PRE86]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now, we'll see what type embedding is.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到类型嵌入是什么。
- en: Type embedding
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型嵌入
- en: 'But what if you would like a struct to inherit the methods of another struct?
    The closest feature that the Go language offers to the concept of inheritance
    is known as *type embedding*. This feature is best explained through an example.
    Let''s go back to the `Person` `struct` type:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想让一个 `struct` 继承另一个 `struct` 的方法，Go 语言提供的最接近继承概念的功能被称为 *类型嵌入*。这个特性最好通过一个例子来解释。让我们回到
    `Person` `struct` 类型：
- en: '[PRE87]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, let''s say that we would like to create a new `struct` type called `Student`,
    which has all the properties and methods of `Person`, plus some more:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要创建一个新的名为 `Student` 的 `struct` 类型，它具有 `Person` 类型所有的属性和方法，还有一些额外的功能：
- en: '[PRE88]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Notice that in the preceding code, we included the type `Person` inside the
    struct definition of type `Student`, without specifying a field name. This will
    effectively make the `Student` type inherit all the exported methods and fields
    of the `Person` `struct` type. In other words, we can access the methods and fields
    of `Person` directly from an object of type `Student`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上一段代码中，我们在 `Student` 类型的结构定义中包含了 `Person` 类型，但没有指定字段名。这将有效地使 `Student` 类型继承
    `Person` `struct` 类型的所有导出方法和字段。换句话说，我们可以直接从 `Student` 类型的对象中访问 `Person` 的方法和字段：
- en: '[PRE89]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In Go, when a type gets embedded inside another type, the exported methods and
    fields of the embedded type are said to be *promoted* to the parent or embedding
    type.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，当一个类型被嵌入到另一个类型中时，嵌入类型的导出方法和字段被称为被 *提升* 到父或嵌入类型。
- en: Let's explore how to build interfaces in Go in the next section.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在 Go 中构建接口。
- en: Interfaces
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: After covering methods, we must cover interfaces, which make use of methods
    to produce efficient and scalable code in the Go language.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了方法之后，我们必须介绍接口，接口在Go语言中通过方法产生高效和可扩展的代码。
- en: An interface can be very simply described as a Go type that hosts a collection
    of methods.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口可以非常简单地描述为Go语言中包含一组方法的类型。
- en: 'Here is a simple example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE90]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The preceding interface defines two methods—`GetName()` and `GetAge()`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的接口定义了两个方法——`GetName()`和`GetAge()`。
- en: 'Earlier, we attached two methods with the same signature to a type called `Person`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们将两个具有相同签名的函数附加到了名为`Person`的类型上：
- en: '[PRE91]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In Go, an interface can be implemented by other types, like Go structs. When
    a Go type implements an interface, a value of the interface type can then hold
    that Go type data. We'll see what that means very shortly.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，接口可以被其他类型实现，例如Go结构体。当一个Go类型实现接口时，接口类型的值可以包含该Go类型的数据。我们很快就会看到这意味着什么。
- en: A very special feature in Go is the fact that for a type to implement or *inherit*
    an interface, the type only needs to implement the methods of said interface.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的一个非常特殊的功能是，为了实现或*继承*接口，类型只需要实现该接口的方法。
- en: In other words, the `Person` struct type from the preceding piece of code implements
    the `myInterface` interface type. This is due to the fact that the `Person` type
    implements `GetName()` and `GetAge()`, which are the same methods that were defined
    by `myInterface`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，前面代码中的`Person`结构体类型实现了`myInterface`接口类型。这是因为`Person`类型实现了`GetName()`和`GetAge()`，这些方法与`myInterface`中定义的方法相同。
- en: So, what does it mean when `Person` implements `MyInterface`?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当`Person`实现`MyInterface`时，它意味着什么呢？
- en: 'It means that we can do something like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以这样做：
- en: '[PRE92]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can also do this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样做：
- en: '[PRE93]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Interfaces are used quite a bit in APIs and in scalable software. They allow
    you to build software with flexible functionality. Here is a trivial example of
    how it helps you build flexible software.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在API和可扩展软件中得到了广泛的应用。它们允许你构建具有灵活功能的软件。这里有一个如何帮助构建灵活软件的简单例子。
- en: 'Let''s say we want to create a new person type that appends a title to the
    name:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个新的`person`类型，该类型将头衔追加到名字中：
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The preceding type also implements `MyInterface`, which means we can do this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类型也实现了`MyInterface`，这意味着我们可以这样做：
- en: '[PRE95]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `PrintNameAndAge()` function signature will not need to change, since it
    relies on the interface instead of the concrete type. However, the behavior will
    differ a bit since we changed the concrete `struct` type from `Person` to `PersonWithTitle`.
    This ability allows you to write flexible APIs and packages that don't need to
    change whenever you need to add more concrete types to your code.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintNameAndAge()`函数签名不需要改变，因为它依赖于接口而不是具体类型。然而，由于我们将具体的`struct`类型从`Person`改为`PersonWithTitle`，行为会有所不同。这种能力允许你编写灵活的API和包，无需在代码中添加更多具体类型时进行更改。'
- en: 'There are cases where you might want to get back the concrete type value from
    an interface value. Go includes a feature called **type assertion** that can be
    used for just that. Here is the most useful form of type assertion:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想从一个接口值中获取具体的类型值。Go语言包含一个名为**类型断言**的功能，可以用于此目的。以下是类型断言最有用的形式：
- en: '[PRE96]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The preceding code assumes that we are inside a function block. If `myInterfaceValue`
    does not hold a value of type `Person`, the preceding code will return an empty
    struct for the first return, and false for the second return. Therefore, `ok`
    will be false, whereas `Person` will be empty.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码假设我们处于函数块内部。如果`myInterfaceValue`不包含`Person`类型的值，前面的代码将返回第一个返回值为空的结构体，第二个返回值为false。因此，`ok`将为false，而`Person`将为空。
- en: On the other hand, if `myInterfaceValue` holds a value of type `Person`, then
    `ok` will become true, and the `Person` variable will hold the data that's retrieved
    from `myInterfaceValue`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果`myInterfaceValue`包含`Person`类型的值，那么`ok`将变为true，`Person`变量将包含从`myInterfaceValue`检索到的数据。
- en: Now, let's explore how to add logic to our code, by covering conditional statements
    and loops.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过介绍条件语句和循环来探索如何给我们的代码添加逻辑。
- en: Conditional statements and loops
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句和循环
- en: In Go, there are two keywords for conditional statements—`if`, and `switch`.
    Let's take a practical look at each one of them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，有两个关键字用于条件语句——`if`和`switch`。让我们逐一实际看看它们。
- en: The if statement
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果语句
- en: 'The `if` statement looks like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句看起来像这样：'
- en: '[PRE97]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'So, let''s assume we want to compare whether a value, `x`, is equal to `10`.
    Here is what the syntax would look like:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设我们想要比较一个值，`x`，是否等于`10`。下面是这个语法的样子：
- en: '[PRE98]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In Go, you can also execute some initialization in your `if` statement. Here
    is what this syntax would look like:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，你还可以在`if`语句中执行一些初始化。下面是这个语法的样子：
- en: '[PRE99]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Like other programming languages, an `if` statement is never complete without
    an `else` clause. Here is what an `if else` looks like in Go:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他编程语言一样，一个`if`语句如果没有`else`子句就不完整。下面是Go语言中`if else`的样子：
- en: '[PRE100]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How about an `else` clause with a condition?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 那么一个带有条件的`else`子句呢？
- en: '[PRE101]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The switch statement
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: 'Now, let''s look at the `switch` statement. Here is what it looks like:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`switch`语句。下面是这个样子：
- en: '[PRE102]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: If you haven't noticed already, there is no `break` keyword. In Go, each case
    breaks automatically, and doesn't need to be told to do so.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有注意到，没有`break`关键字。在Go语言中，每个case会自动跳出，不需要明确告诉它这样做。
- en: 'Similar to `if` statements, you can do an initialization in your `switch` statement:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 和`if`语句类似，你可以在`switch`语句中进行初始化：
- en: '[PRE103]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In Go, a `switch` statement can act like a group of `if else`. This gives you
    the ability to write long `if else` chains with much nicer code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，一个`switch`语句可以像一组`if else`一样工作。这让你能够用更简洁的代码编写长的`if else`链：
- en: '[PRE104]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In some scenarios, you want your switch cases not to break automatically, and
    instead fall through to the next case. For this, you can use the `fallthrough`
    keyword:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想让`switch`的case不自动跳出，而是继续到下一个case。为此，你可以使用`fallthrough`关键字：
- en: '[PRE105]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Following conditional statements, let's take a look at loops.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句之后，让我们看看循环。
- en: Loops
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: In Go, there is a single keyword that you can use when you want to write a loop—`for`.
    There are no other keywords to indicate a loop in Go.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，当你想要写一个循环时，你可以使用一个单独的关键字——`for`。在Go语言中没有其他关键字来表示循环。
- en: 'Let''s look at the following code. Let''s say we want to loop from `1` to `10`;
    here is how this is done:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的代码。假设我们想要从`1`循环到`10`；下面是如何做到这一点的方法：
- en: '[PRE106]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'As in other languages, your `for` statement needs to include the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他语言一样，你的`for`语句需要包含以下内容：
- en: An initial value (`i:=1`) in your code—this is optional
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码中的初始值（`i:=1`）——这是可选的
- en: A condition to indicate whether to keep iterating or not (`i<=10`)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条件来指示是否继续迭代（`i<=10`）
- en: The value of the next iteration (`i++`)
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个迭代的值（`i++`）
- en: 'What if we have a slice or an array and we want to iterate over it in a loop?
    Go comes to the rescue with the concept of `for .. range`. Let''s assume we have
    a slice called `myslice` and that we want to iterate over it. Here is what the
    code would look like:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个切片或数组，并且我们想要在循环中遍历它，Go语言通过`for .. range`的概念来提供帮助。假设我们有一个名为`myslice`的切片，并且我们想要遍历它。下面是这个代码的样子：
- en: '[PRE107]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In the preceding piece of code, `i` represents the index of the current iteration.
    For example, if we are at the second item of `myslice`, then the value of `i`
    will be equal to 1 (because the index starts at 0). The `item` variable, on the
    other hand, represents the value of the slice item at the current iteration. For
    example, if we are at the third item of the slice, then we are at item value `three`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`i`代表当前迭代的索引。例如，如果我们处于`myslice`的第二项，那么`i`的值将是1（因为索引从0开始）。另一方面，`item`变量代表当前迭代切片项的值。例如，如果我们处于切片的第三项，那么我们处于项值`three`。
- en: 'There are cases where we don''t care about the index. For this, we can use
    the following syntax:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们并不关心索引。为此，我们可以使用以下语法：
- en: '[PRE108]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'What about if we only care about the index? For that, we can do this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只关心索引怎么办？为此，我们可以这样做：
- en: '[PRE109]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Someone might ask, why would I need only the index and not the items of the
    slice themselves? The answer is simple—when you obtain the item from the `for..range`
    statement, you only obtain a copy of the item, which means that you won''t be
    able to change the original item that lives in the slice should the need arise.
    However, when you obtain the index, this gives you the power to change the item
    inside the slice. There are cases where you would need to change the values inside
    a slice while you are iterating over it. This is when you use the index. Here
    is a trivial example:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会问，为什么我只需要索引而不是切片本身的项目？答案是简单的——当你从`for..range`语句中获取项目时，你只获取了一个项目的副本，这意味着如果你需要的话，你将无法改变切片中存在的原始项目。然而，当你获取索引时，这给了你改变切片中项目的权力。在某些情况下，当你迭代切片时，你可能需要更改切片中的值。这就是你使用索引的时候。以下是一个简单的例子：
- en: '[PRE110]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'But what about the `while` loop? If you come from any programming language
    other than Go, you must be fully aware of the concept of the `while` loop. As
    we mentioned earlier, in Go, all loops make use of the `for` keyword, so in other
    words, `for` is Go''s `while` as well. Here is an example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于`while`循环呢？如果你来自除了Go以外的任何编程语言，你肯定完全了解`while`循环的概念。正如我们之前提到的，在Go中，所有循环都使用`for`关键字，所以换句话说，`for`也是Go中的`while`。以下是一个例子：
- en: '[PRE111]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As in other programming languages, Go supports the `break` and `continue` keywords.
    The `break` keyword inside a loop would cause the loop to break, even if it is
    not done. The `continue` keyword, on the other hand, will force a loop to jump
    to the next iteration.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其他编程语言一样，Go支持`break`和`continue`关键字。在循环内部的`break`关键字会导致循环中断，即使它还没有完成。另一方面，`continue`关键字会强制循环跳到下一个迭代。
- en: Now, we'll talk about  `panic`, `recover`, and `defer`
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论`panic`、`recover`和`defer`
- en: Panics, recovers, and defers
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`panic`、`recover`和`defer`'
- en: 'In Go, there is a special built-in function called `panic`. When you invoke
    `panic` in your code, your program is interrupted, and a panic message is returned.
    If a `panic` gets triggered and you don''t capture it in time, your program will
    stop execution and will exit, so be very careful when you use a `panic`. Here
    is a code example:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，有一个特殊的内置函数叫做`panic`。当你调用`panic`时，你的程序会被中断，并返回一个`panic`消息。如果`panic`被触发而你又没有及时捕捉到，你的程序将停止执行并退出，所以当你使用`panic`时要非常小心。以下是一个代码示例：
- en: '[PRE112]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the preceding example, we wrote a function that checks a flag, `p`. If `p`
    is true, then we throw a panic. The argument to the `panic` function is the message
    that wants the panic to return. Here is a more complete program that you can run
    in Go''s playground ([http://play.golang.org](http://play.golang.org)):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们编写了一个检查标志`p`的函数。如果`p`为真，那么我们就抛出一个`panic`。`panic`函数的参数是希望`panic`返回的消息。以下是一个更完整的程序，你可以在Go的playground中运行（[http://play.golang.org](http://play.golang.org)）：
- en: '[PRE113]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When I executed that code from the main function in Go''s playground ([http://play.golang.org](http://play.golang.org)),
    I got the following error:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在Go的playground（[http://play.golang.org](http://play.golang.org)）中的主函数中执行那段代码时，我得到了以下错误：
- en: '[PRE114]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The panic caused the program to be terminated, which is why `hello world` was
    never printed. Instead, we got the panic message.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`panic`导致程序终止，这就是为什么`hello world`从未被打印出来。相反，我们得到了`panic`信息。
- en: So, now that we understand how panics work, an obvious question arises—how do
    we capture a `panic` and prevent it from killing our program?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经了解了恐慌是如何工作的，一个显而易见的问题就出现了——我们如何捕捉一个`panic`并防止它杀死我们的程序？
- en: 'Before we answer that question, we first need to introduce the concept of `defer`.
    The `defer` keyword can be used to indicate that a piece of code must only be
    executed after the surrounding function returns. As always, this will make much
    more sense after we look at a code example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，我们首先需要介绍`defer`的概念。`defer`关键字可以用来表示一段代码必须在周围函数返回后才能执行。和往常一样，在查看代码示例之后，这会更容易理解：
- en: '[PRE115]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the preceding code, when we made use of `defer`, we effectively asked for
    the `printEnding()` function to be executed right after  `doSomething()` finishes
    its execution.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当我们使用`defer`时，我们实际上要求`printEnding()`函数在`doSomething()`执行完毕后立即执行。
- en: The `defer` statement basically pushes a function call to a list, and the list
    of saved calls is executed after the surrounding function returns. `Defer` is
    most commonly used to clean up resources, like closing a file handler, for example.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`语句基本上是将一个函数调用推送到一个列表中，并且当周围函数返回后，这个保存的调用列表会被执行。`defer`最常用于清理资源，比如关闭文件处理器等。'
- en: 'Here is the full version of the preceding program:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面程序的完整版本：
- en: '[PRE116]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'And here is the output of that program:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个程序的输出：
- en: '[PRE117]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Now, what if we put `defer` multiple times in our function?
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们多次在函数中使用 `defer` 呢？
- en: '[PRE118]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `defer` statements typically enter a stack data structure, which means
    they execute based on the first-in-last-out rule. So, this basically means that
    the first `defer` statement in the code will execute last, while the next one
    will execute right before it and so on. To paint a clearer picture, let''s look
    at the program''s output:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 语句通常进入一个栈数据结构，这意味着它们根据先进后出的规则执行。所以，这基本上意味着代码中的第一个 `defer` 语句将最后执行，而下一个将直接在其之前执行，依此类推。为了更清晰地说明，让我们看看程序的输出：'
- en: '[PRE119]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Perfect! We are now ready to answer our earlier question—how can we capture
    and handle a `panic` before it terminates our program? We now know about `defer`
    and how it ensures that a piece of code of our choosing gets executed right after
    the surrounding function exits. So, defers can definitely be used to insert a
    piece of code after a `panic` occurs, but are defers enough? The answer is no—there
    is a built-in function known as `recover()` that we can use to capture a `panic`
    and return the panic's message.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们现在可以回答我们之前的问题——如何在程序终止之前捕获和处理 `panic`？我们现在知道了 `defer` 以及它是如何确保我们选择的代码块在周围函数退出后立即执行的。所以，defers
    可以用来在 `panic` 发生后插入代码，但 defers 足够吗？答案是：不够——有一个内置的函数叫做 `recover()`，我们可以用它来捕获 `panic`
    并返回 `panic` 的消息。
- en: 'Again, a code snippet is worth a thousand words:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一个代码片段胜过千言万语：
- en: '[PRE120]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The preceding code will produce the following output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE121]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: As you can see, we utilized a combination of `defer` and the `recover()` function
    to capture the `panic` to prevent it from terminating our program. If no `panic`
    occurred, the `recover()` function will return `nil`. Otherwise, the `recover()`
    function will return the error value of the `panic`. If we use `recover()` alone,
    it won't be effective without being combined with `defer`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们利用了 `defer` 和 `recover()` 函数的组合来捕获 `panic`，以防止它终止我们的程序。如果没有发生 `panic`，`recover()`
    函数将返回 `nil`。否则，`recover()` 函数将返回 `panic` 的错误值。如果我们单独使用 `recover()`，它不会有效，除非与 `defer`
    结合使用。
- en: Summary
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took you on a practical learning journey of the building blocks
    of the Go language. We covered all of the fundamental features of Go that you
    are likely to see in any Go program. As we progress, you will see the building
    blocks that we covered in this chapter being utilized again and again.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带你踏上了 Go 语言构建块的实际学习之旅。我们涵盖了你在任何 Go 程序中可能看到的所有 Go 的基本特性。随着我们的进展，你将看到我们在本章中涵盖的构建块被反复利用。
- en: In the next chapter, we'll cover one of the most beloved features of the Go
    language by diving into how to handle concurrency in Go.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过深入了解如何在 Go 中处理并发来介绍 Go 语言最受欢迎的特性之一。
- en: Questions
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is `GoPath` used for?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GoPath` 是用来做什么的？'
- en: How do you write a `while` loop in Go?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Go 中编写 `while` 循环？
- en: What are named results?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是命名结果？
- en: What is the difference between a function and a method?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数和方法之间的区别是什么？
- en: What is type assertion?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是类型断言？
- en: What is `defer` used for?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defer` 是用来做什么的？'
- en: What is a `panic` in Go?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go 中的 `panic` 是什么？
- en: How do we recover from a `panic`?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从 `panic` 中恢复？
- en: What is the difference between an array and a slice in Go?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go 中数组和切片的区别是什么？
- en: What is an interface?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 interface？
- en: What is a struct?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 struct？
- en: What is a map?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 map？
- en: Further reading
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on what was covered in this chapter you can go through
    the following links:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章所涵盖的内容的更多信息，你可以查看以下链接：
- en: '**Go website**: [golang.org](http://golang.org)'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go 网站**: [golang.org](http://golang.org)'
- en: '**Installing Go**: [https://golang.org/doc/install](https://golang.org/doc/install)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装 Go**: [https://golang.org/doc/install](https://golang.org/doc/install)'
- en: '**Go standard packages**: [https://golang.org/pkg/](https://golang.org/pkg/)'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go 标准包**: [https://golang.org/pkg/](https://golang.org/pkg/)'
- en: '**How to Write Go Code**: [https://golang.org/doc/code.html](https://golang.org/doc/code.html)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如何编写 Go 代码**: [https://golang.org/doc/code.html](https://golang.org/doc/code.html)'
- en: '**Go tour**: [tour.golang.org](http://tour.golang.org)'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go 导航**: [tour.golang.org](http://tour.golang.org)'
- en: '**Slices internals**: [https://blog.golang.org/go-slices-usage-and-internals](https://blog.golang.org/go-slices-usage-and-internals)'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切片内部结构**: [https://blog.golang.org/go-slices-usage-and-internals](https://blog.golang.org/go-slices-usage-and-internals)'
- en: '**Effective Go**: [https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效的 Go**：[https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)'
- en: '**Composition with Go**: [https://www.ardanlabs.com/blog/2015/09/composition-with-go.html](https://www.ardanlabs.com/blog/2015/09/composition-with-go.html)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 Go 进行组合**：[https://www.ardanlabs.com/blog/2015/09/composition-with-go.html](https://www.ardanlabs.com/blog/2015/09/composition-with-go.html)'
