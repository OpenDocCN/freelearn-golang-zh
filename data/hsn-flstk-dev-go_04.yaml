- en: Go Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 并发
- en: Welcome to the second chapter of our journey to learn about full stack development
    in Go. In this chapter, we'll continue on our path to understanding the foundations
    of the Go language, by covering the important topic of **concurrency** in the
    Go language. Go arguably possesses one of the most effective and easy-to-use concurrency
    features of the languages in its class. Many developers who switch to Go do so
    because of Go's concurrency. This chapter assumes some basic knowledge of programming and
    the concept of threads. In a similar way to the previous chapter, we'll mainly
    focus on the most important and foundational concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们学习 Go 全栈开发的旅程的第二章。在本章中，我们将继续探讨 Go 语言的基石，通过涵盖 Go 语言中的重要主题 **并发** 来实现。Go
    语言的并发特性可能是同类语言中最有效且易于使用的。许多转向 Go 的开发者正是因为 Go 的并发特性。本章假设你对编程和线程的概念有一些基本了解。与上一章类似，我们将主要关注最重要的和基础的概念。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is concurrency?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: Goroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Goroutines
- en: Go channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 通道
- en: '`select` statements'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select` 语句'
- en: The `sync` package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync` 包'
- en: What is concurrency?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: So, what is concurrency? The term is used quite a bit in the software industry,
    even though not all developers understand its meaning. In this section, we'll
    attempt to uncover the practical meaning of concurrency from the point of view
    of the Go language, and why it is useful to you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是并发？这个术语在软件行业中使用得很频繁，尽管并不是所有开发者都理解其含义。在本节中，我们将尝试从 Go 语言的视角揭示并发的实际含义，以及为什么它对你来说是有用的。
- en: In Go, **concurrency** means the ability of your program to cut itself into
    smaller pieces, then the ability to run the different independent pieces at different
    times, with the goal of executing all the tasks as quickly as possible based on
    the amount of resources available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，**并发**意味着你的程序能够将自己分割成更小的部分，然后能够在不同的时间运行不同的独立部分，目标是根据可用的资源量尽可能快地执行所有任务。
- en: The preceding definition might appear (for some people) as though we are defining
    threads. However, the concept of concurrency is more general than the concept
    of threads. Let's first briefly define threads if you are not very familiar with
    the concept.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义可能（对某些人来说）看起来像是在定义线程。然而，并发的概念比线程的概念更广泛。如果你对线程的概念不太熟悉，让我们首先简要地定义一下线程。
- en: 'A thread is a feature that the OS gives you that allows you to run pieces of
    your program in parallel. Let''s say that your program is composed of two main
    parts, **Part 1** and **Part 2**, and you write your code such that **Part 1**
    runs on **Thread One**, and **Part 2** runs on **Thread Two**. In this case, both
    parts of your program will run parallel to each other at the same time; the following
    diagram illustrates how this will look:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是操作系统提供的一个功能，它允许你并行运行程序的一部分。假设你的程序由两个主要部分组成，**第一部分**和**第二部分**，你编写代码使得**第一部分**在**线程一**上运行，而**第二部分**在**线程二**上运行。在这种情况下，你的程序的两个部分将同时并行运行；以下图表说明了这将如何看起来：
- en: '![](img/114aae99-ca1b-4dff-b569-5ef8128f1cb8.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/114aae99-ca1b-4dff-b569-5ef8128f1cb8.png)'
- en: That all sounds good; however, there is a gap in modern software between the
    number of truly independent threads and the number of concurrent pieces of software
    that your program needs to execute. In modern pieces of software, you might need
    thousands of pieces of your program to run independently at the same time, even
    though your OS might be supplying only four threads!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都听起来很好；然而，在现代软件中，真正独立的线程数量与你的程序需要执行的同时并发部分数量之间存在差距。在现代软件中，你可能需要数千个程序部分同时独立运行，尽管你的操作系统可能只提供了四个线程！
- en: Concurrency is very important in modern software, due to the need to execute
    independent pieces of code as fast as possible without disturbing the overall
    flow of the program. Let's take the simple example of a web server; a web server
    typically accepts requests from a web client, such as a web browser. Let's say
    that a request is accepted from Jack, who lives somewhere in Europe, while another
    request comes at the same time to the web server from Chin, who lives in Asia.
    You wouldn't want your program to delay Chin's request because of the fact that
    Jack's request arrived at the same time. Their requests should be processed at
    the same time and as independently as possible. This is simply why concurrency
    is an indispensable feature in modern production software.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并发在现代软件中非常重要，因为需要尽可能快地执行独立的代码片段，而不干扰程序的总体流程。让我们以一个简单的Web服务器为例；Web服务器通常接受来自Web客户端的请求，例如Web浏览器。假设一个请求来自住在欧洲的Jack，同时另一个请求来自住在亚洲的Chin，这个请求同时到达Web服务器。你不希望因为Jack的请求同时到达而延迟Chin的请求。他们的请求应该尽可能同时且独立地处理。这正是为什么并发在现代生产软件中是一个不可或缺的功能。
- en: In Go and other modern programming languages, this gap is addressed by essentially
    cutting your program into numerous small and independent pieces, and then *multiplexing*
    those pieces among the available threads. This becomes much clearer with a visual
    representation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go和其他现代编程语言中，这个问题通过将程序切割成许多小而独立的片段，并在可用的线程之间*复用*这些片段来解决。通过视觉表示，这一点会更加清晰。
- en: 'Let''s say we have a piece of software that is composed of 10 different pieces
    that we would like to run concurrently, even though we only have two real OS threads.
    Go has the ability to take those 10 different pieces, schedule when will be the
    best time to run each piece, and then distribute them among the available threads
    based on some very clever algorithms. Here''s a simple view of how this can look:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个由10个不同部分组成的软件，我们希望它们并发运行，尽管我们只有两个真实的操作系统线程。Go有将这10个不同的部分取出来，安排每个部分的最佳运行时间，然后根据一些非常聪明的算法将它们分配到可用线程的能力。以下是这种做法的一个简单视图：
- en: '![](img/4d304ce4-7941-4501-9595-5a517ab65c61.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d304ce4-7941-4501-9595-5a517ab65c61.png)'
- en: The 10 pieces of your program will feel like they are running at the same time,
    even though, in reality, they were cleverly distributed to make them finish their
    tasks as soon as possible based on the available resources. Go takes care of all
    the complexity of scheduling and distributing the 10 pieces of code on the available
    threads, while providing you with a very clean API that hides away all the complexities
    of the algorithms involved. This allows you to focus on writing powerful software
    to serve your needs, without worrying about the low-level concepts such as managing
    threads, low-level resource allocation, and scheduling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序中的10个部分将感觉像是在同时运行，尽管实际上，它们被巧妙地分配，以便根据可用资源尽快完成任务。Go负责所有关于在可用线程上调度和分配这10段代码的复杂性，同时为你提供一个非常干净的API，隐藏了所有算法的复杂性。这使得你可以专注于编写满足你需求的强大软件，而不必担心诸如线程管理、低级资源分配和调度等底层概念。
- en: Let's take a look at goroutines in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看goroutines。
- en: Goroutines
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: It's now time to dig deeper into the clean API that Go provides in order to
    write concurrent software with ease.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入挖掘Go提供的干净API，以便轻松编写并发软件了。
- en: A goroutine is simply defined as a *light-weight thread *that you can use in
    your program; it's not a real thread. In Go, when you define a piece of code as
    a new goroutine, you basically tell the Go runtime that you would like this piece
    of code to run concurrently with other goroutines.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: goroutine可以简单地定义为程序中可以使用的*轻量级线程*；它不是一个真正的线程。在Go语言中，当你将一段代码定义为新的goroutine时，你实际上是在告诉Go运行时，你希望这段代码与其他goroutine并发运行。
- en: Every function in Go lives in some goroutine. For example, the main function
    that we discussed in the previous chapter, which is usually the entry point function
    for your program, runs on what is known as the **main goroutine**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，每个函数都存在于某个goroutine中。例如，我们在上一章中讨论的main函数，通常是程序的入口点函数，它在所谓的**main goroutine**上运行。
- en: 'So, how do you create a new goroutine? You just append the `go` keyword before
    the function that you would like to run concurrently. The syntax is quite simple:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何创建一个新的goroutine呢？你只需在你希望并发运行的函数之前添加`go`关键字。语法相当简单：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `somefunction()` is the piece of code that you would like to run concurrently.
    Whenever you create a new goroutine, it will get scheduled to run concurrently,
    and will not block your current goroutine.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`somefunction()` 是你希望并发运行的代码片段。每次你创建一个新的 goroutine，它都会被调度以并发运行，并且不会阻塞当前的
    goroutine。
- en: 'Here is a trivial, but more complete piece of code to help us understand the
    concept of goroutines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一段简单但更完整的代码片段，帮助我们理解 goroutine 的概念：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is a simple program that runs a function called `runSomeLoop()`
    on a new goroutine. This means that `runSomeLoop()` will run concurrently to the
    `main()` function. In the program, we made use of a function called `Sleep()`,
    which exists in the `time` package. This function will block the main goroutine
    in order to give `runSomeLoop()` a chance to run and finish. If we don't block
    the main goroutine in this example, the main goroutine will likely finish, and
    then exit the program before `runSomeLoop()` gets a chance to fully run. There
    are cases when This is a byproduct of the fact that goroutines are concurrent,
    which is why invoking a new goroutine does not block your current goroutine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个简单的程序，它在新的 goroutine 上运行一个名为 `runSomeLoop()` 的函数。这意味着 `runSomeLoop()`
    将与 `main()` 函数并发运行。在程序中，我们使用了 `time` 包中的一个名为 `Sleep()` 的函数。这个函数会阻塞主 goroutine，以便给
    `runSomeLoop()` 运行并完成的机会。如果我们在这个例子中不阻塞主 goroutine，主 goroutine 很可能先完成，然后程序在 `runSomeLoop()`
    完全运行之前退出。在某些情况下，这是由于 goroutines 并发的事实所导致的副作用，这就是为什么调用新的 goroutine 不会阻塞当前 goroutine。
- en: 'Here''s how the output of the program will look:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows us that the `runSomeLoop()` goroutine managed to run at the same
    time when the main goroutine was sleeping. When the main goroutine woke up, it
    printed `Hello, playground` before it exited.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `runSomeLoop()` goroutine 在主 goroutine 睡眠时成功并发运行。当主 goroutine 唤醒时，它在退出之前打印了
    `Hello, playground`。
- en: 'So, what if we removed the `time.Sleep()` function that blocked the main goroutine?
    Take a look at the following code block:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们移除了阻塞主 goroutine 的 `time.Sleep()` 函数会怎样？看看下面的代码块：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will get the following result:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下结果：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that `runSomeLoop()` didn't get the chance to run before the main
    goroutine exited.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在主 goroutine 退出之前，`runSomeLoop()` 没有机会运行。
- en: Goroutines are very light from a memory and resources point of view; a production
    Go program will typically run hundreds and thousands of goroutines. The ability
    to produce goroutines with such simple API is arguably one of the most powerful
    features of the Go language, according to many of Go's users.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存和资源的角度来看，goroutines 非常轻量；一个生产级的 Go 程序通常会运行数百甚至数千个 goroutines。据许多 Go 用户所说，能够通过如此简单的
    API 产生 goroutines 是 Go 语言最强大的特性之一。
- en: Let's take a look at Go channels in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看 Go channels。
- en: Go channels
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go channels
- en: An important question can now be addressed; what if we need to share a piece
    of data between two different goroutines?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以解决一个重要的问题；如果我们需要在两个不同的 goroutine 之间共享一些数据怎么办？
- en: 'In programs that make use of multiple threads, the common approach to share
    data between different threads is to lockthe variables that are shared between
    the threads. This is typically known as the **sharing memory** **approach***. *The
    following diagram demonstrates how two threads will share memory, by sharing a
    variable called **X**:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多个线程的程序中，不同线程之间共享数据的常见方法是将共享的变量进行锁定。这通常被称为**共享内存****方法**。*以下图示展示了两个线程如何通过共享一个名为**X**的变量来共享内存：
- en: '![](img/524ce7ed-936e-4d65-8c8b-eccea56bf082.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/524ce7ed-936e-4d65-8c8b-eccea56bf082.png)'
- en: 'In Go, there is a very popular motto:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，有一个非常流行的格言：
- en: '"Do not communicate by sharing memory; instead, share memory by communicating."'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: “不要通过共享内存来通信；相反，通过通信来共享内存。”
- en: 'What does that mean? It simply means that Go does not typically prefer sharing
    memory (there are exceptions, however) between threads through the lock approach.
    Instead, Go prefers to communicatethe data from one goroutine to another. This
    *communicate *part is achieved through the Go channels. The following diagram
    demonstrates how this looks visually:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思呢？这仅仅意味着 Go 通常不倾向于通过锁定方法在线程之间共享内存（尽管有例外）。相反，Go 更倾向于通过 Go channels 在一个
    goroutine 和另一个 goroutine 之间通信。这个 *通信* 部分是通过 Go channels 实现的。以下图示展示了这种视觉上的效果：
- en: '![](img/656112ab-0e58-4b26-8b6d-a7bc5d7180ca.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/656112ab-0e58-4b26-8b6d-a7bc5d7180ca.png)'
- en: Let's take a look at regular and buffered channels in the next sections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的常规和缓冲通道。
- en: Regular channels
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常规通道
- en: 'To declare a channel in Go, you simply use the `make` keyword, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中声明通道，你只需使用`make`关键字，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we created and initialized a channel called `myChannel` that
    can hold `int` values. This channel can then be used to send an `int` value from
    one goroutine to another.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建并初始化了一个名为`myChannel`的通道，它可以存储`int`类型的值。然后，这个通道可以被用来从一个goroutine向另一个goroutine发送`int`类型的值。
- en: 'Here is how to receive a value from a channel:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从通道接收值的步骤：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is how to send a value to a channel:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向通道发送值的步骤：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Whenever you execute a send or a receive operation on a regular Go channel,
    your goroutine will block until the value is fully sent or received. This simply
    means that if you send a value via a channel but there is no other goroutine waiting
    for it on the other end, your goroutine will block. On the other hand, if you
    are attempting to receive a value via a channel but there is no other goroutine
    sending it on the other end, your goroutine will block. This behavior ensures
    that your code is synchronized, your values are fresh and up to date, and avoids
    the numerous problems that you can typically face in other programming languages
    when you use locks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你在常规Go通道上执行发送或接收操作，你的goroutine都会阻塞，直到值完全发送或接收。这简单意味着，如果你通过通道发送一个值，但没有其他goroutine在另一端等待它，你的goroutine将会阻塞。另一方面，如果你尝试通过通道接收一个值，但没有其他goroutine在另一端发送它，你的goroutine也会阻塞。这种行为确保了你的代码是同步的，你的值是新鲜且最新的，并且避免了在其他编程语言中使用锁时可能遇到的许多问题。
- en: 'Let''s take a look at a complete program showcasing two goroutines communicating,
    in order to learn more about Go channels:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下展示两个goroutine通信的完整程序，以便更多地了解Go通道：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we created a channel called `myChannel`, which we then
    pass to two goroutines: `runLoopSend()` and `runLoopReceive()`. The `runLoopSend()`
    function will keep sending values to this channel, whereas the `runLoopReceive()`
    function will keep receiving values from this channel.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为`myChannel`的通道，然后将其传递给两个goroutine：`runLoopSend()`和`runLoopReceive()`。`runLoopSend()`函数将不断向这个通道发送值，而`runLoopReceive()`函数将不断从这个通道接收值。
- en: 'The preceding code will provide the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将提供以下输出：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s first focus on `runLoopSend()` because there is a new concept that we
    are showcasing here. Take a look at the following code line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先关注`runLoopSend()`，因为在这里我们展示了一个新的概念。看看以下代码行：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This syntax can be used to close a channel. Once a channel is closed, you cannot
    send data to it anymore, otherwise, a panic will occur.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法可以用来关闭通道。一旦通道被关闭，就不能再向它发送数据，否则将发生panic。
- en: 'Now, let''s take a look at `runLoopReceive`, particularly at this following
    line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`runLoopReceive`，特别是以下这一行：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding line is a special syntax to inspect whether a channel is closed.
    If the channel is not closed, the value of `ok` will be true, while `i` will get
    the value getting sent via the channel. On the other hand, if the channel is closed,
    `ok` will be false. In the `runLoopReceive` goroutine, we break out of the `for`
    loop if `ok` is false.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行是一个特殊的语法，用于检查通道是否已关闭。如果通道未关闭，`ok`的值将为true，而`i`将获取通过通道发送的值。另一方面，如果通道已关闭，`ok`将为false。在`runLoopReceive`
    goroutine中，如果`ok`为false，我们将跳出`for`循环。
- en: 'There is actually another, more elegant way to write this `for` loop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有另一种更优雅的方式来编写这个`for`循环：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can replace the preceding code with the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码替换前面的代码：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `for..range` syntax is allowed on channels as it allows you to keep receiving
    data from a channel until the channel gets closed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`for..range`语法在通道上是允许的，因为它允许你从通道接收数据，直到通道被关闭。'
- en: 'The output of the program will simply be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将简单地如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Buffered channels
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'A buffered channel is a special type of channel that holds a buffer that contains
    a number of items. Unlike a regular channel, a buffered channel doesn''t block
    unless the following takes place:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道是一种特殊的通道类型，它包含一个缓冲区，可以存储多个项目。与普通通道不同，缓冲通道只有在以下情况下才会阻塞：
- en: Its buffer is empty and we are trying to receive a value from the channel.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道的缓冲区为空，我们正在尝试从通道接收一个值。
- en: Its buffer is full and we are trying to send a value to the channel.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道的缓冲区已满，我们正在尝试向通道发送一个值。
- en: 'To declare a buffered channel, we use the following syntax:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个缓冲通道，我们使用以下语法：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding syntax creates a buffered channel that can hold 10 `int` values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的语法创建了一个可以容纳10个`int`值的缓冲通道。
- en: 'To send a value to the buffered channel, we use the same syntax as with regular
    channels. Each send operation adds one item to the buffer, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要向缓冲通道发送一个值，我们使用与常规通道相同的语法。每次发送操作都将一个项目添加到缓冲区中，如下所示：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To receive a value from a buffered channel, we utilize the same syntax as well.
    Each receive operation removes one item from the buffer, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要从缓冲通道接收一个值，我们也使用相同的语法。每次接收操作都将从缓冲区中移除一个项目，如下所示：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's take a look at the `select` statement construct in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中查看`select`语句结构。
- en: The select statement
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`select`语句'
- en: The `select` statement is an important construct in Go. It allows you to control
    multiple channels at the same time. With `select`, you can send or receive values
    to different channels, and then execute code based on the channel that unblocks
    the first.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句是Go语言中的一个重要结构。它允许你同时控制多个通道。使用`select`，你可以向不同的通道发送或接收值，然后根据第一个解除阻塞的通道执行代码。'
- en: 'This will be best explained by an example; let''s take a look at the following
    piece of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过一个示例来最好地解释；让我们看一下以下代码片段：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we utilized the `select` statement to exercise control
    over two different channels. The first channel is called `ch`, which we attempted
    to receive a value from. In comparison, the second channel is produced from the
    `time.After()` function. The `time.After()` function is very popular in Go, and
    especially in `select` statements. The function generates a channel that only
    receives a value after the specified timeout, in effect producing a blocking channel
    for a predefined period of time. You can use `time.After()` in your code with
    the `select` statement in cases where you would want to timeout a receive or a
    send operation on another channel.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`select`语句来控制两个不同的通道。第一个通道被称为`ch`，我们尝试从中接收一个值。相比之下，第二个通道是由`time.After()`函数产生的。`time.After()`函数在Go语言中非常流行，尤其是在`select`语句中。该函数生成一个通道，仅在指定超时后接收值，实际上产生了一个预定时间段的阻塞通道。你可以在代码中使用`time.After()`与`select`语句结合，在你想超时另一个通道的接收或发送操作时。
- en: 'Here is another example of sending a `select` statement with a timeout channel,
    but this time it''s a combination of receive and send operations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个发送带有超时通道的`select`语句的示例，但这次是接收和发送操作的组合：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code will synchronize between three channels: `ch1`, `ch2`, and
    the `time.After()` channel.  The `select` statement will wait on those three channels and
    then, depending on whichever channel finishes first, the appropriate `select`
    case will be executed.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在三个通道之间进行同步：`ch1`、`ch2`和`time.After()`通道。`select`语句将等待这三个通道，然后根据哪个通道先完成，执行相应的`select`情况。
- en: 'The `select` statement also supports the `default` case. The `default` case
    will execute immediately if none of the channels are ready; here is an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句还支持`default`情况。如果没有通道准备好，`default`情况将立即执行；以下是一个示例：'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, if both `ch1` and `ch2` are blocked by `time`, the `select`
    statement is executed, and then the `default` case will trigger.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果`ch1`和`ch2`都因`time`而阻塞，则执行`select`语句，然后触发`default`情况。
- en: If multiple channels finish at the same time while being controlled by a `select`
    statement, the channel case to be executed is picked at random.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`select`语句的控制下多个通道同时完成，则随机选择要执行的通道情况。
- en: Let's take a look at the sync package in the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中查看`sync`包。
- en: The sync package
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sync`包'
- en: The last topic we will cover in this chapter is the `sync` package. The `sync`
    package is what you will use when you absolutely need to create a lock-in Go.
    Even though we mentioned that Go prefers the use of channels to communicate data
    between goroutines, there are cases where a lock or a **mutual exclusion object**
    (**mutex**) is unavoidable. An example of a scenario where locks are utilized
    in Go's standard package is the `http` package, where a lock is used to protect
    the set of listeners to a particular `http` server object. This set of listeners
    can be accessed from numerous goroutines so that they get protected by a mutex.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要讨论的最后一个主题是`sync`包。当你绝对需要在Go中创建互斥锁时，你会使用`sync`包。尽管我们提到Go更倾向于使用通道在goroutines之间通信数据，但在某些情况下，锁或**互斥对象**（**mutex**）是不可避免的。一个在Go标准包中使用锁的例子是`http`包，其中使用锁来保护特定`http`服务器对象的监听器集合。这个监听器集合可以从多个goroutines中访问，因此它们被互斥锁保护。
- en: The word *mutex,* in the world of computer programming, refers to an object
    that allows multiple threads to access the same resource (such as shared memory).
    Mutex is so named because it allows only one thread to access data at one time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程的世界里，单词*mutex*指的是一个允许多个线程访问相同资源（如共享内存）的对象。互斥锁之所以这样命名，是因为它允许一次只有一个线程访问数据。
- en: 'The workflow of a mutex in a piece of software typically works as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁在软件中的工作流程通常如下：
- en: A thread acquires the mutex
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线程获取互斥锁
- en: No other threads can acquire the mutex as long as one thread has it
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要有一个线程拥有互斥锁，其他线程就不能获取互斥锁
- en: The thread that acquired the mutex can access some resources without any disturbance
    from the other threads
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取互斥锁的线程可以无干扰地访问一些资源，而其他线程不会干扰
- en: When its tasks are done, the thread that acquired the mutex releases the mutex
    so that other threads can compete for it again
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当其任务完成时，获取互斥锁的线程会释放互斥锁，以便其他线程可以再次竞争它
- en: In Go, you make use of goroutines and not full threads. So, when you use mutexes
    in Go, they will manage the resource access between goroutines.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，你使用goroutines而不是完整的线程。所以，当你使用Go中的互斥锁时，它们将管理goroutines之间的资源访问。
- en: Let's take a look at the simple mutex, read-write mutex and wait groups in the
    next sections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的简单互斥锁、读写互斥锁和等待组。
- en: The simple mutex
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单互斥锁
- en: 'In Go, a simple lock is a pointer to a mutex `struct` type, which belongs to
    the `sync` package. We can create a mutex as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，一个简单的锁是互斥锁`struct`类型的指针，它属于`sync`包。我们可以创建一个互斥锁如下：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s assume that we have a map called `myMap` of the `map[int]int` type that
    we''d like to protect from the concurrent access of multiple goroutines:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`myMap`的`map[int]int`类型的map，我们希望保护它免受多个goroutines的并发访问：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we ensure that all goroutines that need to edit `myMap` have access to `myMutex`,
    we can protect `myMap` against multiple goroutines changing it at the same time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确保所有需要编辑`myMap`的goroutines都能访问`myMutex`，我们就可以保护`myMap`免受多个goroutines同时更改的影响。
- en: The read-write mutex
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写互斥锁
- en: 'Go also supports a read-write lock. A read-write lock differentiates between
    read and write operations. So, whenever you only perform concurrent read operations,
    the goroutines won''t block. However, whenever you perform a write operation,
    all other reads and writes get blocked until the write lock is released. As always,
    this is best explained with an example, such as the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持读写锁。读写锁区分读和写操作。所以，当你只执行并发读操作时，goroutines不会阻塞。然而，当你执行写操作时，所有其他读和写都会阻塞，直到写锁释放。像往常一样，以下是一个示例，可以最好地解释这一点：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A read-write lock in Go is represented by a pointer to a Go struct of the `sync.RWMutex` type,
    which is what we initialized in the preceding code snippet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的读写锁由指向`sync.RWMutex`类型Go结构的指针表示，这是我们之前代码片段中初始化的。
- en: 'To perform a read operation, we make use of the `RLock()` and `RUnlock()` methods
    of the Go struct:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行读操作，我们使用Go结构体的`RLock()`和`RUnlock()`方法：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To perform a write operation, we make use of the `Lock()` and `Unlock()` methods:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行写操作，我们使用`Lock()`和`Unlock()`方法：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `*sync.RWMutex` type can be found all over the place in Go's standard package.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`*sync.RWMutex`类型在Go的标准包中到处都可以找到。'
- en: Wait groups
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待组
- en: The concept of wait groups is very important for building production level software
    in Go; it allows you to wait for multiple goroutines to finish before you proceed
    with the rest of your code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 等待组的概念对于在Go中构建生产级软件非常重要；它允许你在继续编写其余代码之前等待多个goroutine完成。
- en: 'To fully grasp the benefit of wait groups, let''s go back to an earlier code
    sample:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全掌握等待组的优势，让我们回到一个早期的代码示例：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, we had to make the main goroutine sleep for two seconds
    in order to wait for the other two goroutines to finish. However, what if the
    other goroutines took more than two seconds? It was never guaranteed that this
    simple sleep would produce the result that we are seeking. Instead, we could have
    done the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们必须让主goroutine休眠两秒钟，以便等待其他两个goroutine完成。然而，如果其他goroutine耗时超过两秒呢？这种简单的休眠方式并不能保证产生我们寻求的结果。相反，我们可以这样做：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A `WaitGroup` `struct` type in Go is a type that keeps an internal counter;
    as long as the internal counter is not `0`, the wait group will block your goroutine.
    In the preceding code, we created a global pointer variable to `WaitGroup`; we
    called it `wg`. This variable will be visible to all of our functions in this
    simple program. Before we triggered the two goroutines, we incremented the wait
    group internal counter by `2` using the `wg.Add(2)` method. After that, we proceeded
    to create our two goroutines. For each of the goroutines we added the following
    code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的`WaitGroup`结构体类型是一种包含内部计数器的类型；只要内部计数器不为`0`，等待组就会阻塞您的goroutine。在前面的代码中，我们创建了一个指向`WaitGroup`的全局指针变量，我们称之为`wg`。这个变量将在这个简单的程序中的所有函数中可见。在我们触发两个goroutine之前，我们使用`wg.Add(2)`方法将等待组内部计数器增加`2`。之后，我们继续创建我们的两个goroutine。对于每个添加的goroutine，我们添加以下代码：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This uses a combination of `defer` and the `wg.Done()` method in order to ensure
    that whenever the goroutine function finishes execution, `wg.Done()` gets called.
    The `wg.Done()` method will decrement the internal wait group counter by one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了`defer`和`wg.Done()`方法的组合，以确保每当goroutine函数执行完毕时，`wg.Done()`都会被调用。`wg.Done()`方法将内部等待组计数器减一。
- en: Finally, at the end of our main goroutine, we call `wg.Wait()`, which will block
    the current goroutine until the internal counter of the wait group is zero. This
    will, in turn, force the main goroutine to wait until all the goroutines in our
    program finish executing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的主goroutine结束时，我们调用`wg.Wait()`，这将阻塞当前goroutine，直到等待组的内部计数器为零。这将反过来迫使主goroutine等待直到我们程序中的所有goroutine完成执行。
- en: 'The final output to the preceding code is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的最终输出如下：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some key concepts in the world of production-level
    Go programming. We covered concurrency from a practical point of view, then we
    dove into some of the APIs that Go provides to allow you to write efficient concurrent
    software with minimal complexity.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了生产级Go编程世界中的关键概念。我们从实用的角度讲解了并发，然后深入探讨了Go提供的API，以允许您以最小的复杂性编写高效的并发软件。
- en: In the next chapter, we'll start switch topics from Go to frontend programming
    by covering the building blocks of the popular React framework.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从Go编程切换到前端编程，通过介绍流行的React框架的构建块来开始新的主题。
- en: Questions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is concurrency?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是并发？
- en: What is a thread?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是线程？
- en: How is the concept of concurrency different from parallel threading?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发的概念与并行线程的概念有何不同？
- en: What is a goroutine?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是goroutine？
- en: What does *share memory by communicating* mean?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “通过通信共享内存”是什么意思？
- en: What is a Go channel?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Go通道？
- en: What is the difference between a regular Go channel and a buffered Go channel?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正规的Go通道和带缓冲的Go通道之间的区别是什么？
- en: When should you use a `select` statement?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么情况下使用`select`语句？
- en: What is the difference between `sync.Mutex` and `sync.RWMutex`?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sync.Mutex`和`sync.RWMutex`之间的区别是什么？'
- en: When should you use wait groups?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在什么情况下使用等待组？
- en: Further reading
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can go through the following links:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，您可以查看以下链接：
- en: '**Concurrency in Golang**: [http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/](http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Golang中的并发**：[http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/](http://www.minaandrawos.com/2015/12/06/concurrency-in-golang/)'
- en: '**Concurrency is not parallelism**: [https://blog.golang.org/concurrency-is-not-parallelism](https://blog.golang.org/concurrency-is-not-parallelism)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发不是并行**：[https://blog.golang.org/concurrency-is-not-parallelism](https://blog.golang.org/concurrency-is-not-parallelism)'
- en: '**Package** `sync`: [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包** `sync`: [https://golang.org/pkg/sync/](https://golang.org/pkg/sync/)'
