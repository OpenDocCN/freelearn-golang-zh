- en: Building a Frontend for GoMusic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建GoMusic的前端
- en: 'It''s now time to build the first major piece of the project of this book.
    As mentioned in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, we''ll be building an online store for musical instruments, which
    we will name GoMusic. In this chapter, we''ll build most of the frontend of the
    online store by utilizing the impressive power of the React framework. Our GoMusic
    store will support the fundamental features of any online store:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建本书项目的第一个主要部分了。如[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js的前端*所述，我们将构建一个在线乐器商店，我们将称之为GoMusic。在本章中，我们将利用React框架的强大功能构建在线商店的大部分前端。我们的GoMusic商店将支持任何在线商店的基本功能：
- en: Users should be able to buy any product they like.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够购买他们喜欢的任何产品。
- en: Users should have access to a promotional page, which provides current sales
    and promotions.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够访问一个促销页面，该页面提供当前的销售和促销信息。
- en: Users should be able to create their own accounts, and sign into them for a
    more personalized experience.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够创建自己的账户，并登录以获得更个性化的体验。
- en: 'The following are the three main components of our frontend that we will be
    learning about in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将学习的我们前端的主要三个组件：
- en: Main pages, which all users of our web application should see
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页面，所有我们的网络应用程序的用户都应该看到
- en: Modal dialog windows, which help with buying products, accounts creation, and
    signing in
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态对话框窗口，有助于购买产品、创建账户和登录
- en: User pages, which show a personalized page for the logged-in user
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户页面，显示登录用户的个性化页面
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing non-trivial React applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写非平凡的React应用程序
- en: Integrating credit card services with our frontend with Stripe
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Stripe将信用卡服务集成到我们的前端中
- en: Writing modal windows in our code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的代码中编写模态窗口
- en: Designing routes in our code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的代码中设计路由
- en: Prerequisites and technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前置条件和技术要求
- en: In [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with React.js*,
    we covered the foundations of how to build a React.js application, so read it
    before attempting to follow along with this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js的前端*，我们介绍了如何构建React.js应用程序的基础知识，所以在尝试跟随本章内容之前请先阅读它。
- en: 'The requirements are the same for this chapter. Here is a quick recap of the
    required knowledge and tools:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与之前相同。以下是所需知识和工具的快速回顾：
- en: npm.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm.
- en: The React framework.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React框架。
- en: 'The Create React App tool, which you can simply install using the following
    command:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令简单地安装Create React App工具：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Bootstrap framework.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bootstrap框架。
- en: Knowledge of ES6, HTML, and CSS. In this chapter, we will use HTML forms in
    more than one component.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉ES6、HTML和CSS。在本章中，我们将使用HTML表单在多个组件中。
- en: The code and files for this chapter can be found in GitHub: [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和文件可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05).
- en: Building GoMusic
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建GoMusic
- en: 'Now it''s time to build our online store. Our first step is to use the Create
    React App tool to create a new React application. Open your Terminal, navigate
    to the folder where you would like the GoMusic application to live, then run the
    following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建我们的在线商店了。我们的第一步是使用Create React App工具创建一个新的React应用程序。打开你的终端，导航到你希望GoMusic应用程序存在的文件夹，然后运行以下命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will create a new folder, called `gomusic`, which will contain
    a skeleton React application waiting to be constructed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个新的文件夹，命名为`gomusic`，其中将包含一个等待构建的React应用程序骨架。
- en: 'Now navigate to your `gomusic` folder using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过以下命令导航到你的`gomusic`文件夹：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside, you''ll find three folders: `node_modules`, `public`, and `src`. Before
    we start writing our application, we''ll need to remove some files from the `src`
    folder.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，你可以找到三个文件夹：`node_modules`、`public`和`src`。在我们开始编写应用程序之前，我们需要从`src`文件夹中删除一些文件。
- en: 'Delete the following files from the `src` folder:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从`src`文件夹中删除以下文件：
- en: '`app.css`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.css`'
- en: '`index.css`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.css`'
- en: '`logo.svg`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logo.svg`'
- en: Next, we'll need to go the `public` folder. To make things simpler, replace
    the contents of your `public` folder with those found at our project's GitHub
    page: [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05/public](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05/public).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要进入`public`文件夹。为了简化事情，用我们项目GitHub页面上的内容替换您的`public`文件夹内容：[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05/public](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter05/public)。
- en: The contents of the GitHub page contain images that we'll be using in our project,
    the JSON files that will describe our data, as well as the modified HTML file,
    which will include support for jQuery and the Bootstrap frameworks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub页面包含的内容包含我们将在项目中使用的图像，描述我们数据的JSON文件，以及包含对jQuery和Bootstrap框架支持的修改后的HTML文件。
- en: In the next section, we'll take a look at the main pages in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看应用中的主要页面。
- en: Main pages
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要页面
- en: 'The main pages of our GoMusic application are the pages that all users should
    see, whether they are logged into their GoMusic accounts or not. There are three
    main pages:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GoMusic应用的主要页面是所有用户都应该看到的页面，无论他们是否登录了GoMusic账户。有三个主要页面：
- en: The products page, which is our Home page
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品页面，也就是我们的主页
- en: The Promotions page
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促销页面
- en: The About page
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于页面
- en: 'The first page is the products page. Here is how it looks:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第一页是产品页面。以下是它的样子：
- en: '![](img/fb61c556-8d60-44ee-8a41-d2795df9169f.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb61c556-8d60-44ee-8a41-d2795df9169f.png)'
- en: As shown in the preceding screenshot, we will support a navigational menu that
    will allow us to navigate between the three main pages. The Home option will host
    the products page, which all users should see.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前截图所示，我们将支持一个导航菜单，允许我们在三个主要页面之间导航。主页选项将托管产品页面，所有用户都应该看到。
- en: 'The second page is our Promotions page, which should look very similar to the
    Home page, except that it will show less products with lower prices. The prices
    in this page should show up in red to emphasize the sale:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二页是我们的促销页面，它应该看起来与主页非常相似，除了它将展示更少的产品和更低的价格。这个页面中的价格应该以红色显示，以强调促销：
- en: '![](img/6e20430b-b2e4-4116-bf7a-8b7bf3f1a330.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e20430b-b2e4-4116-bf7a-8b7bf3f1a330.png)'
- en: 'The third page is our About page, which should just show some information about
    the GoMusic store:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第三页是我们的关于页面，它应该只显示一些关于GoMusic商店的信息：
- en: '![](img/a4c77508-5609-4b60-8292-8a46ff6ff9b7.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4c77508-5609-4b60-8292-8a46ff6ff9b7.png)'
- en: You probably also noticed the Sign in option at the rightmost edge of our navigational
    menu; this option will open up a modal dialog window, which will allow our users
    to create accounts and sign in. We'll be covering the modal dialog windows in
    the *Modal dialog windows and handling credit cards* section. For each of our
    main pages, we'll create a React component to represent it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了导航菜单最右边的登录选项；这个选项将打开一个模态对话框窗口，允许我们的用户创建账户并登录。我们将在“*模态对话框窗口和信用卡处理*”部分中介绍模态对话框窗口。对于我们的每个主要页面，我们将创建一个React组件来表示它。
- en: 'Create the following files in the `src` folder:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建以下文件：
- en: '`Navigations.js`: This file will host the code for the navigational menu component.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Navigations.js`：这个文件将包含导航菜单组件的代码。'
- en: '`ProductCards.js`: This file will host the code for the Home and Promotions
    page components.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductCards.js`：这个文件将包含主页和促销页面组件的代码。'
- en: '`About.js`: This file will host the code for the About page component.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`About.js`：这个文件将包含关于页面组件的代码。'
- en: Now, let's start with the navigational menu component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从导航菜单组件开始。
- en: The navigational menu
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航菜单
- en: 'The first component that we need to build to connect all our main pages together
    would be the navigational menu:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的第一个组件是将所有主要页面连接在一起，这个组件将是导航菜单：
- en: '![](img/4508412b-cda0-4f01-ae30-ff0e00e0766d.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4508412b-cda0-4f01-ae30-ff0e00e0766d.png)'
- en: 'In the React framework, in order to build a functioning navigational menu with
    ease, we need to make use of the power of a package called `react-router-dom`.
    To install this package, open your Terminal, then run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在React框架中，为了轻松构建一个功能齐全的导航菜单，我们需要利用一个名为`react-router-dom`的包的强大功能。要安装此包，打开您的终端，然后运行以下命令：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the package is installed, we can make use of it in our code. Now, let's
    open up the `Navigation.js` file and start writing some code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了此包，我们就可以在我们的代码中使用它。现在，让我们打开`Navigation.js`文件并开始编写一些代码。
- en: 'The first thing we need to do is to import the packages that we need to build
    our menu. We''ll utilize two packages:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是导入我们构建菜单所需的包。我们将利用两个包：
- en: The `react` package
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react`包'
- en: The `react-router-dom` package
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-router-dom`包'
- en: 'We will need to export a class called `NavLink` from `react-router-dom`. The `NavLink` class
    is a React component that we can use in our code in order to create links that
    can navigate to other React components:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从`react-router-dom`导出一个名为`NavLink`的类。`NavLink`类是一个React组件，我们可以在代码中使用它来创建可以导航到其他React组件的链接：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we need to create a new React component called `Navigation`. Here''s
    how it looks:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的React组件，名为`Navigation`。它的样子如下：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside our new component, we''ll need to override the `render()` method, as
    mentioned in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, in order to write the view of the component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新组件内部，我们需要覆盖`render()`方法，正如[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)中提到的，*使用React.js的前端*，以便编写组件的视图：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside our `render()` method, we''ll make use of the Bootstrap framework in
    combination with the `NavLink` component that we imported, in order to build our
    navigational menu. Here is how the code inside the `render()` method should look:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`render()`方法内部，我们将结合使用Bootstrap框架和导入的`NavLink`组件来构建我们的导航菜单。以下是`render()`方法内部的代码应该看起来像这样：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code makes use of the Bootstrap framework to style and build the navigation
    bar. Also, when the **Sign in** button gets clicked, we invoke a function called
    `showModalWindow()`, which is expected to get passed to us as a React prop. The
    job of this function is to show the Sign in modal window:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用Bootstrap框架来设置和构建导航栏。此外，当**登录**按钮被点击时，我们调用一个名为`showModalWindow()`的函数，该函数预期作为React属性传递给我们。这个函数的职责是显示登录模态窗口：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Perfect: with the preceding code out of the way, we now have a functional component
    that can be utilized to show the navigational menu.  We will explore this function
    in the *The user page navigational menu* section.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完美：在上述代码之外，我们现在有一个可以用来显示导航菜单的功能组件。我们将在*用户页面导航菜单*部分探讨这个函数。
- en: Let's take a look at the Products and Promotions page in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中查看产品和促销页面。
- en: The Products and Promotions pages
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品和促销页面
- en: 'Now let''s move to writing the product''s page component. The code is similar
    to the products page that we wrote in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*. Let''s open the `ProductsCards.js` file, then write the following
    code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向编写产品的页面组件。代码与我们在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)中编写的产品页面类似，*使用React.js的前端*。让我们打开`ProductsCards.js`文件，然后编写以下代码：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code represents a single product card component. It makes use
    of Bootstrap to style our card.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码代表一个单独的产品卡片组件。它使用Bootstrap来设置我们的卡片样式。
- en: 'The code is almost the same as the product cards we built in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, except for few differences:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码几乎与我们在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)中构建的产品卡片相同，*使用React.js的前端*，除了少数几个差异：
- en: We changed the Buy button color to green by making use of Bootstrap's `.btn-success`
    class.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用Bootstrap的`.btn-success`类将购买按钮的颜色更改为绿色。
- en: We added an option to change the Price color through a variable called `priceColor`; the
    variable looks at a prop called `promo`. If `promo` is true, we'll use a red color;
    if the `promo` prop is false, we'll use the black color.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个通过名为`priceColor`的变量来更改价格颜色的选项；该变量查看一个名为`promo`的属性。如果`promo`为真，我们将使用红色；如果`promo`属性为假，我们将使用黑色。
- en: The Buy button here opens up a modal window by calling the `showBuyModal()`
    function. We will discuss the modal windows in more detail in the *Modal dialog
    windows and handling credit cards* section.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的购买按钮通过调用`showBuyModal()`函数打开一个模态窗口。我们将在*模态对话框窗口和信用卡处理*部分更详细地讨论模态窗口。
- en: 'The code will produce two flavors of a product card based on the value of the `promo` prop.
    If the `promo` prop is false, the product card will look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`promo`属性的值，代码将产生两种产品卡片风格。如果`promo`属性为假，产品卡片将看起来像这样：
- en: '![](img/4cdf3f6f-514c-4f0b-88ed-66ddf67c6dc5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4cdf3f6f-514c-4f0b-88ed-66ddf67c6dc5.png)'
- en: 'If the `promo` prop is true, the product card will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`promo`属性为真，产品卡片将看起来像这样：
- en: '![](img/e85115e3-357f-40f8-9cf1-f2123ce54c91.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e85115e3-357f-40f8-9cf1-f2123ce54c91.png)'
- en: 'The next thing we need to write in the `ProductsCards.js` file is the `CardContainer`
    component. This component will be responsible for showing the product cards together
    in one page. Here is our card container in action:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `ProductsCards.js` 文件中编写的下一件事是 `CardContainer` 组件。这个组件将负责在一个页面上一起显示产品卡片。以下是我们的卡片容器在行动中的样子：
- en: '![](img/64afa655-7a21-4362-b87a-36f8f5f0f608.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64afa655-7a21-4362-b87a-36f8f5f0f608.png)'
- en: 'Let''s create the component:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这个组件：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The component should look very similar to the one we wrote in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*. The next step is to write the constructor of our component. This
    component will rely on a `state` object where the card''s information is stored.
    Here is how the constructor should look:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的外观应该与我们之前在 [第 4 章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用 React.js
    的前端* 中编写的组件非常相似。下一步是编写我们组件的构造函数。这个组件将依赖于一个存储卡片信息的 `state` 对象。以下是构造函数的示例：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As per [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with
    React.js*, we put the card''s information in a file called `cards.json`, which
    should now exist in our `public` folder. The file contains a JSON array of objects,
    where each object contains data about one card, such as ID, image, description,
    prices, and product name. Here is sample data from the file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 [第 4 章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用 React.js 的前端*，我们将卡片信息放在一个名为
    `cards.json` 的文件中，该文件现在应该存在于我们的 `public` 文件夹中。该文件包含一个包含对象的 JSON 数组，其中每个对象包含有关一张卡片的数据，例如
    ID、图片、描述、价格和产品名称。以下是文件中的示例数据：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `public` folder of GoMusic, we also added a file called `promos.json`,
    which hosts data about sales and promotions. The data in `promos.json` is in the
    same data format as `cards.json`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GoMusic 的 `public` 文件夹中，我们还添加了一个名为 `promos.json` 的文件，该文件包含有关销售和促销的数据。`promos.json`
    中的数据与 `cards.json` 的数据格式相同。
- en: 'Now, with the `CardContainer` constructor out of the way, we need to override
    the `componentDidMount()` method, in order to write the code to obtain the card
    data from either `cards.json`, or `promos.json`. When showing the main products
    page, we''ll obtain our product card''s data from `cards.json`. Whereas, when
    showing the promos and sales page, we''ll obtain our product card''s data from
    `promos.json`. Since the source of the card data is not unique, we''ll use a prop
    for this purpose. Let''s call the prop `location`. Here is how the code will look:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着 `CardContainer` 构造函数的完成，我们需要重写 `componentDidMount()` 方法，以便编写从 `cards.json`
    或 `promos.json` 获取卡片数据的代码。当显示主产品页面时，我们将从 `cards.json` 获取我们的产品卡片数据。而当我们显示促销和销售页面时，我们将从
    `promos.json` 获取我们的产品卡片数据。由于卡片数据的来源不是唯一的，我们将使用一个 prop 来实现这个目的。让我们称这个 prop 为 `location`。以下是代码的示例：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we utilized the popular `fetch()` method to retrieve
    data from the address stored in `this.props.location`. If we are viewing the main
    products page, the value of location will be `cards.json`. If we are viewing the
    Promotions page, the value of location will be `promos.json`. Once we retrieve
    the card data, we'll store it in the `state` object of our `CardContainer` component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了流行的 `fetch()` 方法从存储在 `this.props.location` 中的地址检索数据。如果我们正在查看主产品页面，location
    的值将是 `cards.json`。如果我们正在查看促销页面，location 的值将是 `promos.json`。一旦我们检索到卡片数据，我们就会将其存储在我们的
    `CardContainer` 组件的 `state` 对象中。
- en: 'Finally, let''s write the `render()` method of our `CardContainer` method.
    We will get the product cards from our component''s `state` object, then feed
    the product cards'' data as props to our `Card` components. Here is how the code
    will look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编写 `CardContainer` 组件的 `render()` 方法。我们将从组件的 `state` 对象中获取产品卡片，然后将产品卡片的数据作为
    props 传递给我们的 `Card` 组件。以下是代码的示例：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We also pass the `showBuyModal` prop to the card component; this prop represents
    the function that we will implement in the *Creating a parent StripeProvider component*
    section to open the buy modal window. The `showBuyModal` function will be expected
    to take the product ID represented as the card, as well as the selling price of
    the product, as input.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向卡片组件传递了 `showBuyModal` prop；这个 prop 代表我们在 *创建父 StripeProvider 组件* 部分中将要实现的函数，用于打开购买模态窗口。`showBuyModal`
    函数将期望接收以卡片形式表示的产品 ID 以及产品的销售价格作为输入。
- en: The preceding code is very similar to the `CardContainer` code we wrote in [Chapter
    4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend with React.js*. The
    only addition is that we now also pass a `promo` prop to the `Card` component.
    The `promo` prop lets us know whether the product card in question is a promotion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，“使用React.js的前端”中编写的`CardContainer`代码非常相似。唯一的区别是我们现在还向`Card`组件传递了一个`promo`属性。`promo`属性让我们知道相关的产品卡片是否是促销。
- en: Let's take a look at the About page in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的`About`页面。
- en: The About page
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于页面
- en: 'Now let''s add an About page. Here''s how it will look:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个关于页面。以下是它的样子：
- en: '![](img/94e17a90-408f-4205-85a1-e1aa85de6785.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94e17a90-408f-4205-85a1-e1aa85de6785.png)'
- en: 'Let''s navigate to the `src` folder in our project. Create a new file called
    `About.js`. We''ll start by importing the `react` package:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的项目中导航到`src`文件夹。创建一个名为`About.js`的新文件。我们将首先导入`react`包：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we need to write a React component. Typically, we'd create a new class
    that would inherit from `React.Component`. However, we'll explore a different
    coding style that would be better suited to the About page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个React组件。通常，我们会创建一个新的类，该类将继承自`React.Component`。然而，我们将探索一种更适合关于页面的不同编码风格。
- en: 'For simpler components, where a full class is not needed, we simply use what
    is known as *functional components*.  Here is how the `About` component would
    look when written as a functional component:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的组件，不需要完整类的情况下，我们简单地使用所谓的*功能组件*。以下是将`About`组件编写为功能组件时的样子：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A functional component is just a function that takes a props object as an argument.
    The function returns a JSX object that represents the view that we would like
    the component to show. The preceding code is equivalent to writing a class that
    inherits from `React.Component`, then overriding the `render()` method to return
    our view.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 功能组件只是一个接受props对象作为参数的函数。该函数返回一个JSX对象，代表我们希望组件显示的视图。前面的代码等同于编写一个继承自`React.Component`的类，然后重写`render()`方法以返回我们的视图。
- en: 'In more recent versions of React, a functional component can support a `state`
    object, through a feature known as React *Hooks*. A React Hook gives you the ability
    to initialize and utilize a state in a functional component. Here is a simple
    example of a `state` counter from the React documentation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在React的较新版本中，功能组件可以通过名为React *Hooks*的功能支持`state`对象。React Hook让你能够在功能组件中初始化和使用状态。以下是从React文档中摘取的一个简单的`state`计数器示例：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We do not use React Hooks in our code here. However, if you are curious about
    the feature, you can explore it by visiting [https://reactjs.org/docs/hooks-intro.html](https://reactjs.org/docs/hooks-intro.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的代码中不使用React Hooks。然而，如果你对这个功能感兴趣，你可以通过访问[https://reactjs.org/docs/hooks-intro.html](https://reactjs.org/docs/hooks-intro.html)来探索它。
- en: Before we move to the next section, it's worth mentioning that the `Card` component
    could have been written as a functional component as well, since it was relatively
    simple, and didn't need a constructor or any special logic beyond the `render()`
    method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，值得提一下，`Card`组件也可以被编写为一个功能组件，因为它相对简单，不需要构造函数或任何超出`render()`方法的特殊逻辑。
- en: Now, let's talk about how to build dialog windows in our React app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈如何在我们的React应用程序中构建对话框窗口。
- en: Modal dialog windows and handling credit cards
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态对话框和信用卡处理
- en: 'Now it''s time to cover the modal windows in our website. A modal window is
    a small temporary window that is overlaid on your main website. There are two
    main modal windows that we need to build:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍我们网站中的模态窗口了。模态窗口是一个覆盖在您主网站上的小临时窗口。我们需要构建两个主要的模态窗口：
- en: The Buy Item modal window
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买物品模态窗口
- en: The Sign in modal window
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录模态窗口
- en: The Buy Item modal window outline
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购买物品模态窗口概要
- en: 'Let''s start with the Buy Item modal window. This modal window should show
    up when a user clicks on the Buy button of a product card; in other words, when
    you click on the Buybutton:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从购买物品的模态窗口开始。当用户点击产品卡上的购买按钮时，这个模态窗口应该出现；换句话说，当你点击购买按钮时：
- en: '![](img/6cb99759-1151-4091-a709-4d76298a110d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cb99759-1151-4091-a709-4d76298a110d.png)'
- en: 'Once the Buy button is clicked, the following modal window should appear:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击购买按钮，以下模态窗口应该出现：
- en: '![](img/00abbfb0-a09d-4210-860b-a2e95e38c0c6.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00abbfb0-a09d-4210-860b-a2e95e38c0c6.png)'
- en: As you can see, the modal is basically a smaller window that showed up over
    our main website. It allows the user to input some important data before going
    back to the main website. Modal windows are very powerful tools in any modern
    website, so let's start writing one. The modal window we are building today needs
    to be capable of taking credit card information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，模态窗口基本上是一个出现在我们主网站上的小窗口。它允许用户在返回主网站之前输入一些重要数据。模态窗口是任何现代网站中非常强大的工具，所以让我们开始编写一个。我们今天构建的模态窗口需要能够处理信用卡信息。
- en: 'Before we start writing code, we''ll need to install an important package called
    `reactstrap`. This package exposes features offered by the bootstrap framework
    through React components; it has a very handy `Modal` component that we can use
    to build reactive modal windows. Let''s run the following command from our favorite
    Terminal. The command can be executed from the project''s main folder:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要安装一个名为 `reactstrap` 的重要包。这个包通过 React 组件暴露了 Bootstrap 框架提供的功能；它有一个非常实用的
    `Modal` 组件，我们可以用它来构建响应式的模态窗口。让我们从我们最喜欢的终端运行以下命令。该命令可以从项目的主文件夹中执行：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first step is to go to the `src` folder, then create a new file called `modalwindows.js`.
    This file is where we will write all of our modal windows. Next, let''s import
    the React library:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是进入 `src` 文件夹，然后创建一个名为 `modalwindows.js` 的新文件。这个文件是我们将编写所有模态窗口的地方。接下来，让我们导入
    React 库：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then import the modal-related components from the `reactstrap` package:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从 `reactstrap` 包中导入与模态相关的组件：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since we are starting with the Buy Item modal window, let''s write a React
    component called `BuyModalWindow`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从“购买项目”模态窗口开始的，让我们编写一个名为 `BuyModalWindow` 的 React 组件：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We use the `export` keyword here, because this class will need to be exported
    to other files. Again, we will make use of the power of the Bootstrap frontend
    framework to build our modal window. When we wrote our `Card` component, we designed
    our `Buy` button to open a modal window with the `#buy` ID. So, here is our `#buy`
    modal window:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `export` 关键字，因为这个类需要导出到其他文件。再次，我们将利用 Bootstrap 前端框架的力量来构建我们的模态窗口。当我们编写我们的
    `Card` 组件时，我们设计了“购买”按钮，使其通过 `#buy` ID 打开一个模态窗口。所以，这就是我们的 `#buy` 模态窗口：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we built a React component that encapsulates a nice modal
    window with a green header, a Close button, and an empty body. The `Credit card
    form` code is not included yet; we'll get to that in the *Credit card handling
    with React and Stripe* section. The code makes use of the `Modal` component, which
    is provided by the `reactstrap` package. The `reactstrap` package also provides
    a `ModalHeader` component for us to specify how the modal header will look, as
    well as a `ModalBody` component to define the body of our modal window.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了一个封装了绿色标题、关闭按钮和空体的漂亮模态窗口的 React 组件。`信用卡表单` 代码尚未包含；我们将在 `*使用 React
    和 Stripe 处理信用卡*` 部分中介绍。该代码使用了由 `reactstrap` 包提供的 `Modal` 组件。`reactstrap` 包还提供了一个
    `ModalHeader` 组件，让我们指定模态窗口的标题外观，以及一个 `ModalBody` 组件来定义模态窗口的内容。
- en: 'The `Modal` component hosts two very important React props that we need to
    address:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modal` 组件包含两个我们需要处理的非常重要的 React 属性：'
- en: '**The** `isOpen` **prop**: A Boolean that needs to be set to true when we need
    the modal to show up, otherwise the value is false'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`isOpen` 属性**：一个布尔值，当需要模态窗口显示时需要设置为 true，否则值为 false'
- en: '**The** `toggle` **prop**: A callback function that is used to toggle the value
    of `isOpen` when needed'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`toggle` 属性**：一个回调函数，当需要时用于切换 `isOpen` 的值'
- en: 'Let''s do a quick tweak to our code first. Since the `BuyModalWindow` component
    doesn''t include any other methods besides the `render()` method, we can write
    it as a functional component:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先对我们的代码进行快速调整。由于 `BuyModalWindow` 组件除了 `render()` 方法外不包含任何其他方法，我们可以将其编写为一个函数式组件：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Perfect, now let's fill the empty body of our modal window. We need to write
    a `Credit card form` to be the body of our modal window.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在让我们填充模态窗口的空体。我们需要编写一个 `信用卡表单` 作为模态窗口的体。
- en: In the next section we'll take a look at credit card handling for our application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看我们应用程序的信用卡处理。
- en: Credit card handling with React and Stripe
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 和 Stripe 处理信用卡
- en: The idea of building a form that just takes credit card information might sound
    simple at first. However, the process involves more than just building a bunch
    of text boxes. In production environments, we need to be able to validate the
    information being entered to the credit card, and we need to figure out a secure
    way to handle credit card data. Since credit card information is extremely sensitive,
    we cannot treat it simply like any other piece of data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个仅接受信用卡信息的表单的想法可能一开始看起来很简单。然而，这个过程不仅仅涉及构建一些文本框。在生产环境中，我们需要能够验证输入到信用卡的信息，并需要找出一种安全的方式来处理信用卡数据。由于信用卡信息极其敏感，我们不能像对待其他任何数据一样处理它。
- en: Luckily, there are several services out there that you can use to handle credit
    cards in your frontend code. In this chapter, we'll make use of Stripe ([https://stripe.com/](https://stripe.com/)),
    which is one of the most popular services for handling payments with credit cards.
    Like almost any other web service in a production environment, you would need
    to visit its website, create an account, and get an API key to use in your product
    code. With Stripe, the registration also involves providing your business bank
    account so that they can deposit money into your account.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有几种服务可供您在前端代码中处理信用卡。在本章中，我们将使用 Stripe ([https://stripe.com/](https://stripe.com/))，这是处理信用卡支付最受欢迎的服务之一。就像生产环境中的几乎所有其他网络服务一样，您需要访问其网站，创建一个账户，并获取用于产品代码的
    API 密钥。使用 Stripe，注册还涉及提供您的企业银行账户，以便他们可以将钱存入您的账户。
- en: However, they also provide some test API keys that we can utilize for development
    and initial testing, which is what we'll be utilizing today.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，他们也提供了一些测试 API 密钥，我们可以利用这些密钥进行开发和初步测试，这正是我们今天将要使用的。
- en: Stripe helps with every step involved in charging credit cards in your application.
    Stripe validates credit cards, charges them with the approved amounts you provide,
    and then puts that money in your business bank account.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Stripe 帮助您在应用程序中处理信用卡收费的每个步骤。Stripe 验证信用卡，按照您提供的批准金额进行收费，然后将这笔钱存入您的企业银行账户。
- en: In order to fully integrate Stripe or almost any other payment service with
    your code, you need to write code at the frontend and the backend. In this chapter,
    we'll be covering most of the code needed at the frontend. We'll be visiting this
    topic again at a later chapter when working on the backend, in order to write
    the full integration. Let's get started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全集成 Stripe 或几乎任何其他支付服务与您的代码，您需要在前端和后端编写代码。在本章中，我们将介绍前端所需的大部分代码。我们将在稍后的章节中再次讨论此主题，当时我们将处理后端，以编写完整的集成。让我们开始吧。
- en: Due to the huge popularity of the React frontend framework, Stripe provides
    special React libraries and APIs that we can use to design visual elements that
    can take credit card data. These visual elements are known as React Stripe elements
    ([https://github.com/stripe/react-stripe-elements](https://github.com/stripe/react-stripe-elements)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 前端框架的巨大流行，Stripe 提供了特殊的 React 库和 API，我们可以使用它们来设计可以接受信用卡数据的视觉元素。这些视觉元素被称为
    React Stripe 元素 ([https://github.com/stripe/react-stripe-elements](https://github.com/stripe/react-stripe-elements))。
- en: 'React Stripe elements provide the following functionalities:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: React Stripe 元素提供以下功能：
- en: They provide some UI elements that can take credit card data, such as credit
    card numbers, expiry dates, CVC numbers, and ZIP codes.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们提供了一些可以接受信用卡数据的 UI 元素，例如信用卡号码、到期日期、CVC 码和 ZIP 码。
- en: They can do advanced validation on the data entered. For example, for credit
    card fields, they can tell whether a Master Card or Visa is being entered.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以对输入的数据进行高级验证。例如，对于信用卡字段，他们可以判断是否正在输入 MasterCard 或 Visa。
- en: After Stripe elements accept the data provided to them, they give you a token
    ID that represents the credit card in question and you can then enter this token
    ID in the backend to use the card in your application.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Stripe 元素接受它们提供的数据后，它们会为您提供代表相关信用卡的令牌 ID，然后您可以在后端输入此令牌 ID 以在您的应用程序中使用这张卡。
- en: Perfect. So, now that we have enough background about Stripe, let's start writing
    some code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。既然我们已经对 Stripe 有足够的了解，让我们开始编写一些代码。
- en: 'There are a number of steps that you must cover in your code in order to properly
    integrate credit card handling with your frontend code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在代码中涵盖一系列步骤，以正确地将信用卡处理与前端代码集成：
- en: Create a React component to host your `Credit card form` code. Let's call it
    the `child`React component; you'll see very shortly why it's a `child` component.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 React 组件来承载您的 `Credit card form` 代码。让我们称它为 `child` React 组件；您很快就会看到为什么它是一个
    `child` 组件。
- en: Inside that component, make use of the Stripe elements, which are just some
    React components provided by Stripe in order to build the credit card input fields.
    These fields are simply the text boxes that take credit card information, such
    as the credit card number and expiry date.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该组件内部，使用 Stripe 元素，这些元素是 Stripe 提供的一些 React 组件，用于构建信用卡输入字段。这些字段只是接受信用卡信息的文本框，例如信用卡号码和到期日期。
- en: Inside this `child` component, write the code to submit the validated credit
    card token to the backend.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `child` 组件内部，编写代码以将验证过的信用卡令牌提交到后端。
- en: 'Create another React component. This component will act as a parent to the
    React component that hosted the Stripe elements. The parent React component will
    need to do the following:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个 React 组件。这个组件将作为承载 Stripe 元素的 React 组件的父组件。父 React 组件需要执行以下操作：
- en: Host a stripe component that processes Stripe's API key, also known as `StripeProvider`.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 承载处理 Stripe API 密钥的 stripe 组件，也称为 `StripeProvider`。
- en: Inside the `StripeProvider` component, you need to host the `child` React component.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `StripeProvider` 组件内部，您需要承载 `child` React 组件。
- en: Before you can host the `child` React component, you need to inject itwith special
    Stripe code that wraps it with Stripe props and functions. The method to inject
    a component with Stripe code is called `injectStripe`.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您能够承载 `child` React 组件之前，您需要使用特殊的 Stripe 代码将其注入，该代码将 Stripe 属性和函数包裹在组件周围。将组件注入
    Stripe 代码的方法称为 `injectStripe`。
- en: Let's implement the preceding steps one by one.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地实现前面的步骤。
- en: Creating a child React component to host Stripe elements
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个承载 Stripe 元素的子 React 组件
- en: 'First, we need to install the Stripe react packages. In the Terminal, we need
    to navigate to our `gomusic` project folder, then run the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 Stripe react 包。在终端中，我们需要导航到我们的 `gomusic` 项目文件夹，然后运行以下命令：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, let's visit the `index.html` file located at `frontend/public/index.html`.
    Then, right before the HTML closing tag, which is the line right before `</head>`,
    type `<script src="img/"></script>`. This will ensure the Stripe code will be
    loaded when the end user loads our GoMusic application in their browser.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们访问位于 `frontend/public/index.html` 的 `index.html` 文件。然后，在 HTML 结束标签之前，也就是在
    `</head>` 之前的一行，输入 `<script src="img/"></script>`。这将确保当最终用户在浏览器中加载我们的 GoMusic
    应用程序时，Stripe 代码将被加载。
- en: 'Now let''s write some code. Inside our `src` folder, let''s create new file
    called `CreditCards.js`. We start by importing the packages that we need for our
    incoming code to work:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些代码。在我们的 `src` 文件夹中，让我们创建一个名为 `CreditCards.js` 的新文件。我们首先导入我们需要的包，以便我们的代码能够正常工作：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Time to write our `child` React component, which will host our credit card
    form:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写我们的 `child` React 组件了，它将承载我们的信用卡表单：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In order for our code to be as realistic as possible, we need to adhere to
    the three states associated with processing a credit card:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码尽可能真实，我们需要遵循与处理信用卡相关的三种状态：
- en: '**Initial status**: No cards have been processed yet.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**初始状态**：尚未处理任何卡。'
- en: '**Success status**: Card has been processed and succeeded.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功状态**：卡已处理并成功。'
- en: '**Failed status**: Card has been processed but failed.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败状态**：卡已处理但失败。'
- en: 'Here is the code to represent these three states:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是表示这三种状态的代码：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let''s write three methods to represent the three states:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写三个方法来表示三种状态：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These three methods will be called based on our current status. We need to
    save our current state in our React `state` object so that we can retrieve it
    at any time inside our component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方法将根据我们的当前状态被调用。我们需要在我们的 React `state` 对象中保存我们的当前状态，这样我们就可以在任何时候在组件内部检索它：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The status will change based on the success or failure of the credit card transaction.
    It''s time to write the `render()` method of our React component. Our `render()`
    method will simply look at our current status by inspecting `this.state.status`,
    then based on the status, it will render the appropriate view:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 状态将根据信用卡交易的成功或失败而改变。现在是时候编写我们的 React 组件的 `render()` 方法了。我们的 `render()` 方法将简单地通过检查
    `this.state.status` 来查看当前状态，然后根据状态，渲染相应的视图：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What''s left is to write the code for the three render methods. Let''s start
    with the most complex, which is `renderCreditCardInformation()`. This is where
    we''ll use the Stripe element components. Here is the view that this method needs
    to produce:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是编写三个渲染方法的代码了。让我们从最复杂的开始，即`renderCreditCardInformation()`方法。这里我们将使用Stripe元素组件。以下是该方法需要生成的视图：
- en: '![](img/d3426980-6d5b-4a93-b980-63684bfd9f9b.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3426980-6d5b-4a93-b980-63684bfd9f9b.png)'
- en: 'We''ll start by writing the JSX elements that represent the **Use Saved Card?** button
    at the beginning as well as the **Remember Card?** checkbox close to the end.
    We''ll write those elements separately because later we''ll need to hide them
    from users who are not logged in:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写代表**使用已保存卡**按钮的JSX元素，它在开始处，以及接近结尾处的**记住卡**复选框。我们将单独编写这些元素，因为稍后我们需要隐藏它们，不让未登录的用户看到：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we again used the Bootstrap framework to design the button
    and the checkbox.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们再次使用了Bootstrap框架来设计按钮和复选框。
- en: Making use of Stripe elements to handle credit card information
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Stripe元素处理信用卡信息
- en: 'Now it''s time to design the user interface for the credit card payment information.
    Here is the piece that we need to build:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候设计信用卡支付信息的用户界面了。这是我们需要构建的部分：
- en: '![](img/1501a47b-6104-4012-ab65-a2d5ccd7c68d.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1501a47b-6104-4012-ab65-a2d5ccd7c68d.png)'
- en: 'The most interesting part is the Card Information field:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是卡信息字段：
- en: '![](img/4fd4e940-f530-4ad4-8d1b-d760a3aa288d.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fd4e940-f530-4ad4-8d1b-d760a3aa288d.png)'
- en: 'This is where we''ll make use of the Stripe elements components, in order to
    integrate Stripe''s UI and validation with our user interface. If you recall,
    there is a package called `CardElement` that we imported at the beginning of our
    `CreditCards.js` file. `CardElement` is nothing but a React component that is
    provided by Stripe in order to build credit card field UIs in your React applications.
    This is our Stripe element that we''ll be using in our code. We can simply utilize
    it through JSX like any other component:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将使用Stripe元素组件的地方，以便将Stripe的UI和验证集成到我们的用户界面中。如果你还记得，我们在`CreditCards.js`文件的开始处导入了一个名为`CardElement`的包。`CardElement`只是一个由Stripe提供的React组件，用于在React应用程序中构建信用卡字段UI。这是我们将在代码中使用的Stripe元素。我们可以像使用任何其他组件一样简单地利用它：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Stripe elements components support a prop called `style`, which allows you
    to define how the style of the element should look. The `style` prop takes a JavaScript
    object that defines how the style should look for the Stripe element. The following
    code shows a `style` object that looks right at home with the Bootstrap framework
    visually:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Stripe元素组件支持一个名为`style`的属性，它允许你定义元素的外观样式。`style`属性接受一个JavaScript对象，该对象定义了Stripe元素的外观样式。以下代码显示了一个看起来与Bootstrap框架视觉上相得益彰的`style`对象：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For our card''s Stripe element to take the preceding `style` object, we just
    need to do this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的卡片Stripe元素接受前面的`style`对象，我们只需要这样做：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Perfect. Now let''s build the rest of our `renderCreditCardInformation()` method.
    With the Stripe card element out of the way, we need to build the HTML form that
    will host the Stripe card element along with the Name On Card field in our credit
    card pay modal window. Here is the JSX code for the UI:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。现在让我们构建`renderCreditCardInformation()`方法的其余部分。随着Stripe卡片元素的解决，我们需要构建一个HTML表单，该表单将托管Stripe卡片元素以及信用卡支付模态窗口中的“卡上姓名”字段。以下是UI的JSX代码：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code only shows an HTML form that hosts the Name On Card as well
    as the card element visual component. We also made use of a method called `handleInputChange()`,
    which triggers when we input the Name On Card field. This method changes the `state`
    object of our component based on the new Name On Card value of our HTML form.
    This is the recommended React way to handle forms—create state to correspond to
    your HTML form values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码只显示了一个托管“卡上姓名”以及卡片元素视觉组件的HTML表单。我们还使用了一个名为`handleInputChange()`的方法，该方法在输入“卡上姓名”字段时触发。该方法根据HTML表单的新“卡上姓名”值更改我们组件的`state`对象。这是推荐的React处理表单的方式——创建状态以对应HTML表单的值：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s time to write the full code for the credit card information window, including
    the **Remember Card?** and **Use Saved Card?** options. Here''s how the full `renderCreditCardInformation()`
    method should look:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写信用卡信息窗口的完整代码了，包括**记住卡**和**使用已保存卡**选项。下面是完整的`renderCreditCardInformation()`方法应该看起来像什么：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code makes use of our `remembercardcheck` and `usersavedcard` elements.
    We also assume that there is a method called `handleSubmit`, which will get triggered
    when our HTML form gets submitted. The `handleSubmit` method will be discussed
    in the *Submitting a credit card token to the backend* section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了我们的`remembercardcheck`和`usersavedcard`元素。我们还假设存在一个名为`handleSubmit`的方法，该方法将在我们的HTML表单提交时触发。`handleSubmit`方法将在*提交信用卡令牌到后端*部分进行讨论。
- en: 'Perfect. Now let''s write up the remaining methods in our `CreditCardForm`
    component: `renderSuccess()` and `renderFailure()`. We''ll start with `renderSuccess()`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。现在让我们编写`CreditCardForm`组件中剩余的方法：`renderSuccess()`和`renderFailure()`。我们首先从`renderSuccess()`开始：
- en: '![](img/34404de7-ddde-47be-81c1-2f6c07ae7e22.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34404de7-ddde-47be-81c1-2f6c07ae7e22.png)'
- en: 'The code is simple:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code is linked to the Buy modal window through the `toggle` method,
    which will get passed to our component here as a prop. As mentioned, the `toggle`
    method can be used to open or close a modal window. Since the modal window will
    be open when this code gets executed, the modal window will close once the **Ok**
    button is pressed. The full syntax for the `toggle` method will be defined later
    in our code, specifically when we cover the main code in the `App.js` file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过`toggle`方法与购买模态窗口相关联，该`toggle`方法将作为prop传递给我们的组件。如前所述，`toggle`方法可以用来打开或关闭模态窗口。由于当此代码执行时模态窗口将打开，因此当按下**确定**按钮时，模态窗口将关闭。`toggle`方法的完整语法将在我们代码的后续部分定义，具体来说，当我们在`App.js`文件中介绍主要代码时。
- en: 'Here''s how the `renderFailure()` method looks:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何查看`renderFailure()`方法的：
- en: '![](img/a1b2f258-b9f6-4ef1-b8ed-2118438c0208.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1b2f258-b9f6-4ef1-b8ed-2118438c0208.png)'
- en: 'The code for the preceding UI looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述UI的代码如下所示：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Submitting a credit card token to the backend
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将信用卡令牌提交到后端
- en: Now let's go back to the `handleSubmit()` method, which should trigger whenever
    the credit card HTML form submits. When you make use of a Stripe element component,
    it not only validates the credit card information, but it also returns a `token`
    object that represents the credit card entered. This `token` object is what you'll
    use in the backend to charge this card.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到`handleSubmit()`方法，它应该在信用卡HTML表单提交时触发。当你使用Stripe元素组件时，它不仅验证信用卡信息，还返回一个代表输入的信用卡的`token`对象。这个`token`对象是你将在后端用来扣款的。
- en: 'The `handleSubmit()` method code needs to take care of a number of things:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleSubmit()`方法代码需要处理许多事情：'
- en: Retrieve the token that corresponds to the credit card entered
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取与输入的信用卡对应的令牌
- en: Send the token to our backend server
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将令牌发送到我们的后端服务器
- en: Render a success or a failure state based on the outcome
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据结果渲染成功或失败状态
- en: 'Here''s how the code will look:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的样式：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you look closely at the preceding code, you will notice that we made use
    of a method called `this.props.stripe.createToken()`, which we assumed is embedded
    in our props, in order to retrieve the credit card token:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看前面的代码，你会注意到我们使用了名为`this.props.stripe.createToken()`的方法，我们假设它是嵌入在我们的props中的，以便检索信用卡令牌：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The method is called `createToken()`. We passed the Name On Card value as an
    argument (which was stored in our `state` object). The `createToken()` method
    can only be available if we inject our React component with Stripe code. We will
    see how to do that in the next section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法被命名为`createToken()`。我们传递了卡上姓名值作为参数（该值存储在我们的`state`对象中）。只有当我们用Stripe代码注入我们的React组件时，`createToken()`方法才可用。我们将在下一节中看到如何做到这一点。
- en: We also made use of JavaScript's `fetch()` method, in order to send an HTTP `POST`
    request to relative URL. The `POST` request will include our Stripe token ID as
    well as the type of operation of the request. We pass an operation type here because
    I would like to use this request in the future to either take money from a card
    or save a card for later use. We'll be talking more about the other end of the
    `POST` request when it's time to cover the backend code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了JavaScript的`fetch()`方法，以便向相对URL发送HTTP `POST`请求。`POST`请求将包括我们的Stripe令牌ID以及请求的操作类型。我们传递一个操作类型是因为我想将来使用这个请求要么从卡上取钱，要么保存卡以供以后使用。当涉及到后端代码时，我们将在适当的时候更多地讨论`POST`请求的另一端。
- en: Creating a parent StripeProvider component
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个父StripeProvider组件
- en: 'The next step is to create a parent component to host our `CreditCardForm`
    component.  Here is what we need to do:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个父组件来托管我们的`CreditCardForm`组件。以下是我们需要做的事情：
- en: Inject our `CreditCardForm` component with the Stripe API code. This is done
    using the `injectStripe()`method.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `injectStripe()` 方法将 Stripe API 代码注入到 `CreditCardForm` 组件中。
- en: Provide our Stripe API key to our component. This is done using the `StripeProvider`
    React component, which is provided by Stripe.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 Stripe API 密钥提供给组件。这是通过 Stripe 提供的 `StripeProvider` React 组件完成的。
- en: Host the `CreditCardForm` component inside our parent component. This is done
    using the `Elements` component.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Elements` 组件在我们的父组件中托管 `CreditCardForm` 组件。这是通过 `injectStripe()` 方法完成的。
- en: 'This will make much more sense when we see the code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到代码时，这会更有意义：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The preceding code should exist in our `CreditCards.js` file, which also contained
    our `CreditCardForm` component code. We also passed the operation as a prop, which
    we then later used when we submitted the credit card request to our backend. Also
    notice `export default` at the beginning of our `CreditCardInformation` component
    definition. This is because we will be importing and using this component in other
    files.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应存在于我们的 `CreditCards.js` 文件中，该文件还包含了我们的 `CreditCardForm` 组件代码。我们还传递了一个操作作为属性，后来我们用它提交了信用卡请求到我们的后端。注意
    `export default` 出现在我们的 `CreditCardInformation` 组件定义的开始处。这是因为我们将在其他文件中导入和使用此组件。
- en: 'Now that we''ve followed all the steps to write a credit card form that can
    integrate with Stripe, it''s time to go back to our buy modal window to embed
    the credit card form in it. Our buy modal window existed in the `modalwindows.js`
    file. As a reminder, here is the code that we covered earlier for the buy modal
    window:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经遵循了所有步骤来编写一个可以与 Stripe 集成的信用卡表单，现在是时候回到我们的购买模式窗口，将其嵌入信用卡表单中。我们的购买模式窗口存在于
    `modalwindows.js` 文件中。作为提醒，以下是之前我们覆盖的购买模式窗口的代码：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First we need to import the `CreditCardInformation` component to our `modalwindows.js`.
    So, we need to add this line to the file:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将 `CreditCardInformation` 组件导入到 `modalwindows.js` 文件中。因此，我们需要在文件中添加此行：
- en: '[PRE44]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'All that we need to do now is to embed our `CreditCardInformation` component
    in the modal body:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的就是将 `CreditCardInformation` 组件嵌入到模式体中：
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And with that, we are done with the Buy modal window. Now let's move to the
    Sign in window.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了购买模式窗口。现在让我们转到登录窗口。
- en: The Sign in and Register modal windows
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录和注册模式窗口
- en: 'Before we jump into the code, let''s first explore how the Sign in and Register
    modal windows should look. Click on the Sign in button in our navigation bar:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入代码之前，让我们首先探索登录和注册模式窗口应该如何看起来。点击导航栏中的登录按钮：
- en: '![](img/7d54c8e8-b16c-4608-8d7a-99789cee34bf.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d54c8e8-b16c-4608-8d7a-99789cee34bf.png)'
- en: 'The following modal window should appear:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 应该出现以下模式窗口：
- en: '![](img/4b24d1a4-8e05-477c-9980-a887c6689b72.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b24d1a4-8e05-477c-9980-a887c6689b72.png)'
- en: 'If we click on the **New User? Register** link, the modal window should expand
    to show the registration form for new users:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击 **新用户？注册** 链接，模式窗口应该展开以显示新用户的注册表单：
- en: '![](img/e291409c-aadb-47df-8973-3e5b5a8e081c.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e291409c-aadb-47df-8973-3e5b5a8e081c.png)'
- en: In order to build those modal windows correctly, we need to cover how to properly
    handle forms with multiple inputs in the React framework.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确构建那些模式窗口，我们需要了解如何在 React 框架中正确处理具有多个输入的表单。
- en: Handling forms in the React framework
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 框架中处理表单
- en: Since the React framework relies on being in control of your frontend state,
    forms represent a challenge to this vision. This is because, in HTML forms, each
    input field handles its own state based on the user input. Let's say we have a
    text box and the user makes some changes to it; the text box will change its state
    based on what the user enters. In React however, it is preferred that any state
    change should be handled in the `state` object using the `setState()` method.
    There are multiple ways to handle forms in React.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 框架依赖于控制你的前端状态，因此表单代表了这一愿景的挑战。这是因为，在 HTML 表单中，每个输入字段根据用户输入处理自己的状态。假设我们有一个文本框，用户对其进行了更改；文本框将根据用户输入更改其状态。然而，在
    React 中，更倾向于使用 `setState()` 方法在 `state` 对象中处理任何状态变化。在 React 中处理表单有多种方法。
- en: We'll make use of various ways of handling HTML forms. React encourages what
    is known as the *controlled components* approach, which simply means that you
    design your component in a way such that your `state` object becomes the single
    source of truth.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用各种处理 HTML 表单的方法。React 鼓励所谓的 *受控组件* 方法，这仅仅意味着你以这种方式设计你的组件，即你的 `state` 对象成为唯一的真相来源。
- en: 'But how? The answer is simple:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何实现呢？答案是简单的：
- en: You monitor your HTML form input fields inside your component.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在组件内部监控您的HTML表单输入字段。
- en: Whenever a form input field changes, you change your `state` object to hold
    the new value of the form input field.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当表单输入字段更改时，您将更改您的`state`对象以保存表单输入字段的新值。
- en: Your `state` object now will hold the latest values of your form input.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`state`对象现在将保存您表单输入的最新值。
- en: The Sign in page
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录页面
- en: 'Let''s start with the Sign in page. As a reminder, here''s how it looks:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从登录页面开始。作为提醒，它看起来是这样的：
- en: '![](img/17659113-d417-44df-b35f-ddbf96456bf6.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17659113-d417-44df-b35f-ddbf96456bf6.png)'
- en: 'This is basically a form with two text input fields, a button, a link, and
    some labels. The first step is to create a React component to host the Sign in
    form. In the `modalwindows.js` file, let''s create a new component called `SignInForm`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个包含两个文本输入字段、一个按钮、一个链接和一些标签的表单。第一步是创建一个React组件来托管登录表单。在`modalwindows.js`文件中，让我们创建一个新的组件，命名为`SignInForm`：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we need to create a `state` object in our component:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的组件中创建一个`state`对象：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Our `state` object currently hosts a single field called `errormessage`. Whenever
    the sign-in process fails, we'll fill up the `errormessage` field with the error
    message that occurred.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`state`对象包含一个名为`errormessage`的单个字段。每当登录过程失败时，我们将错误信息填充到`errormessage`字段中。
- en: 'After that, we need to bind two methods: one to handle form submission and
    one to handle form input change:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要绑定两个方法：一个用于处理表单提交，另一个用于处理表单输入更改：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now it''s time to write our `render()` method. The `render()` method will need
    to perform the following tasks:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写我们的`render()`方法了。`render()`方法需要执行以下任务：
- en: Show the Sign in form, collect the user input, then submit the form
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以表单形式显示标志，收集用户输入，然后提交表单
- en: Show an error message if the sign in failed, then enable the user to sign in
    again
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果登录失败，显示错误消息，然后允许用户再次登录
- en: 'Here is how the code will look:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的样式：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There are some important points that we need to cover from the preceding code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们需要讨论一些重要点：
- en: For each input element, there is an attribute called `name`. This attribute
    is used to identify each input element. This is important because when we set
    our `state` object to reflect the value on each input, we need to identify the
    input name.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个输入元素，都有一个名为`name`的属性。这个属性用于标识每个输入元素。这很重要，因为当我们设置我们的`state`对象以反映每个输入的值时，我们需要识别输入名称。
- en: Also for each input element, there is an attribute called `onChange`. This attribute
    is how we call our `handleChange()` method whenever a user inputs data on our
    HTML form.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个输入元素，还有一个名为`onChange`的属性。这个属性是我们如何调用我们的`handleChange()`方法，每当用户在我们的HTML表单中输入数据时。
- en: At the end of our form, if the user decides to click on the New user? Register link,
    we call a method called `handleNewUser()`, which is passed to us by the component
    props. We'll cover this method in the next section.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的表单末尾，如果用户决定点击“新用户？注册”链接，我们将调用一个名为`handleNewUser()`的方法，该方法通过组件属性传递给我们。我们将在下一节中介绍此方法。
- en: 'Let''s talk about the `handleChange()` method, which will populate our `state`
    object with the data that the user inputs into the HTML Sign in form. For that,
    we''ll use a modern JavaScript feature called *computed property name*. Here is
    how the code looks:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈`handleChange()`方法，它将使用户输入到HTML登录表单中的数据填充我们的`state`对象。为此，我们将使用一个现代JavaScript特性，称为*计算属性名称*。以下是代码的样式：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding code, we made use of the `name` property of the event target,
    which corresponds to the name attributes that we assigned in the HTML form. After
    the user inputs the username and the password, our `state` object will end up
    looking like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了事件目标的`name`属性，这对应于我们在HTML表单中分配的名称属性。在用户输入用户名和密码后，我们的`state`对象最终将看起来像这样：
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The last piece in our `SignInForm` would be the `handleSubmit()` method. We''ll
    cover this method in more detail when it''s time to cover the backend in [Chapter
    6](d2dd4c31-a063-4318-bf78-9657870c6582.xhtml), *RESTful Web APIs in Go with the
    Gin Framework*. So, for now, here''s a filler for the `handleSubmit()` method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`SignInForm`的最后一部分将是`handleSubmit()`方法。我们将在第6章中详细介绍此方法，即使用Gin框架的Go语言中的RESTful
    Web APIs。因此，现在这里是一个`handleSubmit()`方法的占位符：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The Registration form
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册表单
- en: 'The next form we need to cover is the Registration form. As a reminder, here
    is how it looks:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的下一个表单是注册表单。作为提醒，它看起来是这样的：
- en: '![](img/d343d0df-f59f-47a5-84d4-9edbd66f584c.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d343d0df-f59f-47a5-84d4-9edbd66f584c.png)'
- en: 'This form will be in the same file as the Sign in form, which was `modalwindows.js`.
    The code for the Registration form will be very similar to the code we just covered
    for the Sign in form. The difference is that the form for Registration has some
    more fields than the Sign In form, otherwise the code is very similar. Here is
    the code for the Registration form:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单将与登录表单位于同一文件中，即`modalwindows.js`。注册表单的代码将与我们刚才覆盖的登录表单的代码非常相似。区别在于注册表单比登录表单有更多字段，否则代码非常相似。以下是注册表单的代码：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Perfect! With this out of the way, we have finished the Sign in form as well
    as the Registration form. We just need to write the containing modal window code
    that will host either the Sign in form or the Registration form. The modal window
    will need to achieve the following tasks:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！这样一来，我们已经完成了登录表单和注册表单。我们只需要编写包含模态窗口代码，该代码将托管登录表单或注册表单。模态窗口需要完成以下任务：
- en: Show the Sign in form
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示登录表单
- en: If the user clicks on the New User? Register option, the Registration form should
    appear
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户点击“新用户？注册”选项，则应显示注册表单
- en: 'Let''s create a new React component in the `modalwindows.js` file and call
    it `SignInModalWindow`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`modalwindows.js`文件中创建一个新的React组件，并命名为`SignInModalWindow`：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To design this component properly, we need to think about the fact that this
    component has two modes—specifically, whether it should show the Sign in page
    for existing users, or show the new Registration page for new users. In the world
    of React, we need to make use of our `state` object, in order to keep track of
    whether we are showing the Sign in page or the Registration page. The initial
    state would be to show the Sign in page, then if the user clicks on the New User?
    Register link, we change our state to the Registration page:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确设计这个组件，我们需要考虑这样一个事实，即这个组件有两种模式——具体来说，它应该为现有用户显示登录页面，还是为新用户显示新的注册页面。在React的世界里，我们需要利用我们的`state`对象，以跟踪我们是否显示登录页面或注册页面。初始状态是显示登录页面，然后如果用户点击“新用户？注册”链接，我们改变我们的状态到注册页面：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the preceding code, besides initializing our `state` object, we also bounded
    a method called `handleNewUser()`. This method is what we''ll call when a user
    clicks on the New User? Register link to load the Registration form instead of
    the Sign in page. This method should change the value of our `state` object to
    reflect the fact that we need to now load the Registration form:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，除了初始化我们的`state`对象外，我们还绑定了一个名为`handleNewUser()`的方法。这个方法是我们当用户点击“新用户？注册”链接以加载注册表单而不是登录页面时调用的。这个方法应该改变我们`state`对象的值，以反映我们现在需要加载注册表单的事实：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This sounds good. However, the New User? Register link existed in the `SignInForm`
    React component, so how do we call the `handleNewUser()` method here from our
    `SignInForm` component?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不错。然而，“新用户？注册”链接存在于`SignInForm` React组件中，那么我们如何在`SignInForm`组件中调用`handleNewUser()`方法呢？
- en: 'The answer is simple: we pass the method as a prop to `SignInForm`, and then
    `SignInForm` calls the method whenever the New User? Register link is clicked.
    If you go back a few pages, you will find that we did indeed link the New User?
    Register link in the `SignInForm` React component to a function prop called `handleNewUser()`,
    which gets called whenever the link is clicked. At the time, we said that we''ll
    cover this prop in a little bit, and here we are.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：我们将方法作为属性传递给`SignInForm`，然后`SignInForm`在点击“新用户？注册”链接时调用该方法。如果你回顾几页之前的代码，你会发现我们确实在`SignInForm`
    React组件中将“新用户？注册”链接链接到了一个名为`handleNewUser()`的函数属性上，该属性在点击链接时被调用。当时我们说我们会稍后介绍这个属性，现在我们就在这里。
- en: 'Now the remaining piece of the `SignInModalWindow` component is the required
    `render()` method, which will sum up what we need to do. Here is what the `render()`
    method needs to do:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的`SignInModalWindow`组件部分是必需的`render()`方法，它将总结我们需要做什么。以下是`render()`方法需要执行的操作：
- en: Check the `state` object. If it shows that we need to show the Registration
    form, load the Registration form component, `RegistrationForm`, otherwise keep `SignInForm`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`state`对象。如果它显示我们需要显示注册表单，则加载`RegistrationForm`组件，否则保持`SignInForm`。
- en: For the `SignInForm`, pass the `handleNewUser()` method as a prop. This is a
    common design pattern in the React world.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`SignInForm`，将`handleNewUser()`方法作为属性传递。这是React世界中的一个常见设计模式。
- en: Load the modal window code. As usual, we'll make use of the powerful Bootstrap
    framework to style our form.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载模态窗口代码。像往常一样，我们将利用强大的Bootstrap框架来美化我们的表单。
- en: 'Include either `SignInForm` or `RegistrationForm` in the modal window, based
    on what our `state` object dictates:'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们的 `state` 对象指示，在模态窗口中包含 `SignInForm` 或 `RegistrationForm`：
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the next section, we'll take a look at the user pages in our application.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看我们应用程序中的用户页面。
- en: User pages
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户页面
- en: 'It''s now time to discuss the user page—what should the user see once they
    sign into our application? Here is what they should see:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论用户页面了——用户登录我们的应用程序后应该看到什么？以下是他们应该看到的内容：
- en: Their name in the navigation menu, with an option to Sign out
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的名字在导航菜单中，有一个登出选项
- en: A list of their existing orders
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们现有的订单列表
- en: Let's explore how this looks.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何呈现的。
- en: 'The navigation menu should change to look like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 导航菜单应更改为如下所示：
- en: '![](img/719e047f-ed89-4239-90e0-23152f243adc.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](img/719e047f-ed89-4239-90e0-23152f243adc.png)'
- en: 'It now allows to navigate to a page called My Orders, which will show the user''s
    previous orders. The other difference is that instead of a Sign In button, we
    now see a Welcome <username> drop-down button. When you click on it, the following
    option should appear:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它允许导航到一个名为“我的订单”的页面，该页面将显示用户的先前订单。另一个不同之处在于，我们不再看到“登录”按钮，而是看到一个欢迎 <username>
    下拉按钮。当你点击它时，以下选项应该出现：
- en: '![](img/32e2bae0-adc6-4bb4-92a4-5c66f2a8c691.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32e2bae0-adc6-4bb4-92a4-5c66f2a8c691.png)'
- en: This is the Sign Out button, which the user will need to click on to sign out
    of their session.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是登出按钮，用户需要点击它来退出会话。
- en: 'Next, let''s have a look at the My Orders page:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看“我的订单”页面：
- en: '![](img/a09e6c10-70e1-4a3f-8c54-37d621e7cb11.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a09e6c10-70e1-4a3f-8c54-37d621e7cb11.png)'
- en: It's a relatively simple page that shows a list of the user's existing orders.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的页面，显示用户现有的订单列表。
- en: Now, let's write some code for the orders page.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为订单页面编写一些代码。
- en: The orders page
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单页面
- en: 'Let''s start with writing the React component that represent the My Orders page.
    There are two components involved with the My Orders page:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写代表“我的订单”页面的React组件开始。与“我的订单”页面相关的有两个组件：
- en: A single order card component
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个订单卡片组件
- en: A parent container component that hosts all the order card components
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个父容器组件，它托管所有的订单卡片组件
- en: 'Let''s begin with the single order card component. Here is how it looks:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单个订单卡片组件开始。这是它的样子：
- en: '![](img/661e5576-7fa9-4548-90e1-69390398b78c.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/661e5576-7fa9-4548-90e1-69390398b78c.png)'
- en: 'Create a new file called `orders.js` inside the `src` folder. In there, we''ll
    write our new components. At the top of the file, we need to import React:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 文件夹内创建一个名为 `orders.js` 的新文件。在那里，我们将编写我们的新组件。在文件的顶部，我们需要导入React：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For the single order card component, let''s call it simply `Order`. This component
    will be simple. Since it will be contained within a parent container component,
    we can assume that all the order information is passed as props. Also, since we
    don''t need to create any special methods, let''s make it a functional component:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个订单卡片组件，我们可以简单地称之为 `Order`。这个组件将会很简单。因为它将被包含在一个父容器组件中，我们可以假设所有的订单信息都作为props传递。另外，由于我们不需要创建任何特殊的方法，让我们将其制作成一个函数式组件：
- en: '[PRE59]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As always, the Bootstrap framework makes styling our component a breeze.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，Bootstrap框架使得对我们的组件进行样式设计变得轻而易举。
- en: 'Now let''s move to the orders container parent component. This one will be
    a bit more complex because we need to store our orders in the `state` object of
    the component:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向订单容器父组件。这个组件将会更复杂一些，因为我们需要在组件的 `state` 对象中存储我们的订单：
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The orders list needs to come from the backend part of our application. Because
    of that, the `state` object should change based on the interaction with the backend
    of our application. Let''s not worry about that part for now because we''ll have
    to cover it when designing the backend of our application in [Chapter 6](d2dd4c31-a063-4318-bf78-9657870c6582.xhtml),
    *RESTful Web APIs in Go with the Gin Framework*. For now, let''s jump into the
    `render()` method:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 订单列表需要从我们应用程序的后端部分获取。正因为如此，`state` 对象应根据与我们的应用程序后端的交互而改变。现在我们先不考虑这部分，因为当我们在[第6章](d2dd4c31-a063-4318-bf78-9657870c6582.xhtml)“使用Gin框架的Go语言RESTful
    Web APIs”设计应用程序的后端时，我们还需要涉及这部分。现在，让我们跳转到 `render()` 方法：
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code is simple. We go through the orders in our `state` object,
    then load an `Order` component for each order object that we have. Remember here
    that when we are dealing with lists, we should use the `key` prop for the React
    framework to properly handle changes in the list, as mentioned in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml),
    *Frontend with React.js*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很简单。我们遍历我们的`state`对象中的订单，然后为每个订单对象加载一个`Order`组件。记住，当我们处理列表时，我们应该使用React框架的`key`属性来正确处理列表的变化，如[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)，*使用React.js的前端开发*中提到的。
- en: If you look at the GitHub code for this chapter, you'll notice that I actually
    fetch the orders data from a static file, in order to update the `orders` list
    in the `state` object. This is temporary, since I need some data to show how the
    visuals will look.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看本章的GitHub代码，你会注意到我实际上是从一个静态文件中获取订单数据，以便更新`state`对象中的`orders`列表。这是临时的，因为我需要一些数据来展示视觉效果。
- en: The user page navigational menu
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户页面导航菜单
- en: Let's go back to the `navigation.js` file that was in our `src` folder. We already
    wrote a `Navigation` React component there in the *The navigational menu* section,
    which included the default navigation menu if the user is not logged in. We now
    need to add the pieces that should show up when a user is logged in. The first
    step is to write a new method, called `buildLoggedInMenu()`, which will show the
    Welcome <user> drop-down button, as well as the sign out option.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到位于我们的`src`文件夹中的`navigation.js`文件。我们在*导航菜单*部分已经写了一个`Navigation` React组件，其中包含了如果用户未登录时的默认导航菜单。我们现在需要添加当用户登录时应显示的部分。第一步是编写一个新的方法，命名为`buildLoggedInMenu()`，它将显示欢迎
    <用户> 下拉按钮，以及注销选项。
- en: 'Inside the `Navigation` React component, let''s add the new method:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Navigation` React组件内部，让我们添加一个新的方法：
- en: '[PRE62]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The method makes use of JSX with Bootstrap in order to build our drop-down button
    and sign out option. We assume that the username is passed to us as a prop.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用Bootstrap和JSX来构建我们的下拉按钮和注销选项。我们假设用户名作为属性传递给我们。
- en: 'Now, we''ll need to modify the `render()` method in order to change the navigation
    menu when a user is logged in. We''ll assume a prop is passed to us that specifies
    whether the user is logged in. The modified `render()` method also needs a new
    navigational link to point to the My Orders page:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要修改`render()`方法，以便在用户登录时更改导航菜单。我们假设一个属性被传递给我们，指定用户是否已登录。修改后的`render()`方法还需要一个新的导航链接指向我的订单页面：
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the preceding code, we assumed a prop had been passed to us that tells us
    whether the user is logged in (`this.props.user.loggedin`). If the user is logged
    in, we do two things:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们假设已经传给我们一个属性，告诉我们用户是否已登录（`this.props.user.loggedin`）。如果用户已登录，我们做两件事：
- en: Call the `buildLoggedInMenu()` method to load the user drop-down button at the
    end of the navigation menu.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`buildLoggedInMenu()`方法在导航菜单的末尾加载用户下拉按钮。
- en: Add a link to a path called `/myorders`. This link will connect to the `OrderContainer`
    component. We'll cover how to connect this link to a React component in the next
    section.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个指向`/myorders`路径的链接。这个链接将连接到`OrderContainer`组件。我们将在下一节中介绍如何将此链接连接到React组件。
- en: Putting it all together – routes
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合 – 路由
- en: 'We now need to write the React component that connects all the preceding components
    together. You are probably thinking that we already wrote the navigation menu—shouldn''t
    that link everything together? The simple answer is: not yet. In the navigation
    menu component, we made use of links to point to other pages. However, we did
    not connect those links to actual react components; the `/about` link needs to
    connect to the `About` React component, the `/myorders` link needs to connect
    to the `OrderContainer` React component, and so on.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要编写一个React组件，将所有前面的组件连接在一起。你可能认为我们已经编写了导航菜单——难道不应该将所有东西都链接起来吗？简单的答案是：还不行。在导航菜单组件中，我们使用了链接指向其他页面。然而，我们没有将这些链接连接到实际的React组件；`/about`链接需要连接到`About`
    React组件，`/myorders`链接需要连接到`OrderContainer` React组件，等等。
- en: We used a React component called `NavLink` in order to create our links. `NavLink`
    was obtained from the `react-router-dom` package, which we installed in the *The
    navigational menu* section. The `NavLink` component is the first step to connect
    links to React components, while the second step is another type called `BrowserRouter`.
    Let's see that in action.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个名为`NavLink`的React组件来创建我们的链接。`NavLink`是从`react-router-dom`包中获得的，我们在*导航菜单*部分安装了它。`NavLink`组件是将链接连接到React组件的第一步，而第二步是另一种类型，称为`BrowserRouter`。让我们看看它是如何工作的。
- en: 'Create a new file called `App.js`; it should exist in our `src` folder. This
    file will host a component that will act as the entry point for all our other
    components. Because of that, we need to import all the major components that we
    have created so far in here:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`App.js`的新文件；它应该存在于我们的`src`文件夹中。这个文件将托管一个组件，它将作为所有其他组件的入口点。因此，我们需要在这里导入我们迄今为止创建的所有主要组件：
- en: '[PRE64]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we need to import a few components from the `react-router-dom` package:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要从`react-router-dom`包中导入一些组件：
- en: '[PRE65]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now let''s write our new component:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写我们的新组件：
- en: '[PRE66]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Since this component will have access to all the other components, we need
    to store global information here. One of the most important pieces of information
    for our application is whether the user is signed in, because this effects how
    our application pages look. Because of that, the `state` object of this component
    needs to reflect whether a user is logged in:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个组件将能够访问所有其他组件，我们需要在这里存储全局信息。对于我们应用程序来说，最重要的信息之一是用户是否已登录，因为这会影响我们的应用程序页面的外观。因此，这个组件的`state`对象需要反映用户是否已登录：
- en: '[PRE67]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's not worry about how this state is populated for now, because this will
    need to be covered when we write the backend part of our application. For the
    time being, let's focus on how to connect each `NavLink` to a React component.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们不要担心这个状态是如何填充的，因为这将需要在编写应用程序的后端部分时解决。目前，让我们专注于如何将每个`NavLink`连接到React组件。
- en: 'There are three steps involved:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到三个步骤：
- en: Add a component of the `BrowserRouter` type. In our case, we just named it `Router`
    for simplicity.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`BrowserRouter`类型的组件。在我们的例子中，我们只是简单地将其命名为`Router`以简化。
- en: Inside `BrowserRouter`, put all the instances `NavLink`. In our case, all of
    our `NavLink` instances are in the `Navigation` component; we imported the `Navigation`
    component here as `Nav` for simplicity.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BrowserRouter`内部放置所有实例`NavLink`。在我们的例子中，所有的`NavLink`实例都在`Navigation`组件中；我们在这里将`Navigation`组件导入为`Nav`以简化。
- en: Inside `BrowserRouter`, use the `Route` component that we imported from the
    `react-router-dom` package to link a URL path to the React component. Each URL
    path will correspond to a `NavLink` path.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BrowserRouter`内部，使用我们从`react-router-dom`包中导入的`Route`组件将URL路径链接到React组件。每个URL路径将对应一个`NavLink`路径。
- en: 'The preceding steps can be hosted in our `render()` method. Here is how this
    code looks:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤可以在我们的`render()`方法中实现。以下是代码的样式：
- en: '[PRE68]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding code implements the three steps that we covered earlier. It also
    includes `SignInModalWindow` and `BuyModalWindow`. Either modal window will only
    show up if the user activates them.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实现了我们之前提到的三个步骤。它还包括`SignInModalWindow`和`BuyModalWindow`。任一模态窗口只有在用户激活它们时才会显示。
- en: 'We used two different ways to connect a `NavLink` instance to a React component:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种不同的方式将`NavLink`实例连接到React组件：
- en: 'If a component needs a prop as an input, we use `render`:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个组件需要一个属性作为输入，我们使用`render`：
- en: '[PRE69]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If a component does not need a prop as an input, we can use the `Route` component:'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个组件不需要属性作为输入，我们可以使用`Route`组件：
- en: '[PRE70]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In order for the routing concepts to sync, let''s look at what happened with
    the `About` React component:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使路由概念同步，让我们看看`About`React组件发生了什么：
- en: In our navigational menu component (`Navigation` at `Navigation.js`), we used
    the `NavLink` type that we obtained from `react-router-dom` to create a path called
    `/about:<NavLink className="nav-item nav-link" to="/about">About</NavLink>`.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的导航菜单组件（`Navigation`在`Navigation.js`中），我们使用了从`react-router-dom`获得的`NavLink`类型来创建一个名为`/about:<NavLink
    className="nav-item nav-link" to="/about">About</NavLink>`的路径。
- en: 'In our `App` component, we linked the `/about` path to the `About` React component:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`App`组件中，我们将`/about`路径链接到`About`React组件：
- en: '[PRE71]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now, we need to define the `toggle` methods and show methods for the buy and
    the sign-in modal windows. The `show` methods are basically the methods to call
    in order to show the buy or sign-in modal windows. The most straightforward way
    to do this is to use a `state` object of our component to specify whether the
    modal windows should be on or off. Our application is designed so that only one
    modal window should be open at a time, which is why we'll control their open/closed
    state from our `App` component.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义购买和登录模态窗口的`toggle`方法和`show`方法。`show`方法基本上是调用以显示购买或登录模态窗口的方法。最直接的方法是使用我们组件的`state`对象来指定模态窗口应该开启还是关闭。我们的应用程序设计为一次只能打开一个模态窗口，这就是为什么我们将从`App`组件控制它们的开启/关闭状态。
- en: 'Let''s start by exploring the `show` methods for the buy and sign-in modal
    windows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探索购买和登录模态窗口的`show`方法：
- en: '[PRE72]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The code, in both cases, will clone our `state` object, while adding and setting
    a Boolean field that indicates that the target modal window should be on. In case
    of the sign-in modal window, the Boolean field will be called `showSignInModal`,
    whereas, in the case of the buy modal window, the Boolean field will be called
    `showBuyModal`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，代码都会克隆我们的`state`对象，同时添加并设置一个布尔字段，表示目标模态窗口应该开启。在登录模态窗口的情况下，布尔字段将被称为`showSignInModal`，而在购买模态窗口的情况下，布尔字段将被称为`showBuyModal`。
- en: 'Now, let''s look at the `toggle` methods for the sign in and the buy modal
    windows. As mentioned, the `toggle` method is used to toggle the state of the
    modal window. In our case, we just need to reverse the value of the `state` Boolean
    fields that represent whether our modal windows are open:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看登录和购买模态窗口的`toggle`方法。如前所述，`toggle`方法用于切换模态窗口的状态。在我们的案例中，我们只需要反转表示我们的模态窗口是否打开的`state`布尔字段：
- en: '[PRE73]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The constructor for our `App` component needs to bind the new methods that
    we added for them to be used in our code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`App`组件的构造函数需要绑定我们添加的新方法，以便在代码中使用：
- en: '[PRE74]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Next, we need to pass the new methods to the components that need them as prop
    objects. We also need to pass the `state.showSignInModal` and `state.showBuyModal`
    flags, because that''s how our modal window components will know whether a modal
    window should be visible:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将新方法作为prop对象传递给需要它们的组件。我们还需要传递`state.showSignInModal`和`state.showBuyModal`标志，因为这是我们的模态窗口组件知道模态窗口是否应该可见的方式：
- en: '[PRE75]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: There are two remaining code pieces to be covered in this chapter.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中还有两个代码片段需要介绍。
- en: 'The first piece is to make the `App` component exportable because this component
    will become the entry point for all our other components. At the end of the `App.js`
    file, let''s add this line:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是使`App`组件可导出，因为该组件将成为我们其他组件的入口点。在`App.js`文件的末尾，让我们添加以下行：
- en: '[PRE76]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The second piece of code we need to write is to link the `App` React component
    to the `root` element of our template HTML code. Create a file called `index.js`,
    where we add this code:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写的第二段代码是将`App`React组件链接到我们的模板HTML代码的`root`元素。创建一个名为`index.js`的文件，在其中添加以下代码：
- en: '[PRE77]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This code makes use of the tools that are loaded with the Create React App tool.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了与Create React App工具一起加载的工具。
- en: Perfect! With this last piece of code out of the way, our chapter is done.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！随着最后一段代码的完成，我们的章节就结束了。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter took a practical deep dive into how to build a proper frontend
    application using the React framework. We covered several topics as we built our
    application, such as routing, handling credit cards and forms, and typical React
    framework design approaches. You should have enough knowledge at this point to
    build non-trivial applications in the React framework.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了如何使用React框架构建合适的前端应用程序。我们在构建应用程序的过程中涵盖了多个主题，例如路由、处理信用卡和表单以及典型的React框架设计方法。到这一点，你应该有足够的知识来在React框架中构建非平凡的应用程序。
- en: In the next chapter, we'll switch topics and revisit Go. We'll start to cover
    how to build the backend for our GoMusic application, by introducing the Go open
    source framework, Gin.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转换主题，重新回顾Go。我们将开始介绍如何使用Go开源框架Gin构建我们的GoMusic应用程序的后端。
- en: Questions
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is `react-router-dom`?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`react-router-dom`？
- en: What is `NavLink`?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`NavLink`？
- en: What is Stripe?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Stripe？
- en: How do we handle credit cards in React?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在React中处理信用卡？
- en: What is a controlled component?
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是受控组件？
- en: What is `BrowserRouter`?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`BrowserRouter`？
- en: What are Stripe elements?
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Stripe元素是什么？
- en: What is the `injectStripe()` method?
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`injectStripe()` 方法是什么？'
- en: How do we handle routing in React?
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 React 中处理路由？
- en: Further reading
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, check out the following
    links:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的主题的更多信息，请查看以下链接：
- en: '**React router package**: [https://reacttraining.com/react-router/ ](https://reacttraining.com/react-router/)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 路由包**: [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/)'
- en: '**Stripe**: [https://stripe.com/](https://stripe.com/)'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stripe**: [https://stripe.com/](https://stripe.com/)'
- en: '**Stripe React elements**: [https://stripe.com/docs/recipes/elements-react](https://stripe.com/docs/recipes/elements-react)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stripe React 元素**: [https://stripe.com/docs/recipes/elements-react](https://stripe.com/docs/recipes/elements-react)'
- en: '**Handling forms in React**: [https://reactjs.org/docs/forms.html](https://reactjs.org/docs/forms.html)'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 React 中处理表单**: [https://reactjs.org/docs/forms.html](https://reactjs.org/docs/forms.html)'
