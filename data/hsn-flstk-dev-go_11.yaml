- en: Testing and Benchmarking Your Web API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和基准测试你的Web API
- en: Testing is of vital importance in production software environments. Applications
    not only need to be tested for functionality, but they also need to be benchmarked
    and profiled so that we can examine the performance of our applications. This
    chapter will provide a wide and practical exposure about how to properly test
    and benchmark your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产软件环境中，测试至关重要。应用程序不仅需要测试功能，还需要进行基准测试和性能分析，以便我们可以检查应用程序的性能。本章将提供广泛的实用信息，介绍如何正确测试和基准测试你的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Mocking types in Go
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言中的模拟类型
- en: Unit testing in Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言中的单元测试
- en: Benchmarking in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go语言中的基准测试
- en: The code for this chapter can be found in this book's GitHub repository at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter08).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go/tree/master/Chapter08)。
- en: Testing in Go
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言中的测试
- en: One of the building blocks of the testing process in any piece of software is
    known as **unit testing**. Unit testing is a very popular concept in virtually
    any programming language, and there are numerous software frameworks and language
    extensions that allow you to perform unit testing as efficiently as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件测试过程中的一个构建块被称为**单元测试**。单元测试在几乎任何编程语言中都是一个非常流行的概念，并且有众多的软件框架和语言扩展，允许你尽可能高效地执行单元测试。
- en: The idea of unit testing is to test each unit or component of your software
    separately. A unit can simply be defined as the smallest testable piece of your
    software.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的想法是单独测试你的软件中的每个单元或组件。单元可以简单地定义为你的软件中最小的可测试部分。
- en: The Go language comes equipped with a testing package, as well as some Go commands
    to make the process of unit testing easier. The package can be found at [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言配备了测试包，以及一些Go命令，使单元测试过程更加容易。该包可以在[https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)找到。
- en: In this section, we'll dive a bit deeper into how to build unit tests in the
    Go language. However, before we start writing unit tests in Go, we first need
    to cover the concept of mocking.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨如何在Go语言中构建单元测试。然而，在我们开始编写Go语言的单元测试之前，我们首先需要了解模拟的概念。
- en: Mocking
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟
- en: 'The concept of mocking is very popular in the field of unit testing software.
    It''s best described via an example. Let''s say we would like to unit test one
    of the HTTP handler functions of the GoMusic application. The `GetProducts()`
    method is a good method to showcase our example, since the purpose of this method
    was to return a list of all of the products that are available for sale in our
    GoMusic store. Here is what the code for `GetProducts()` looked like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的概念在单元测试软件领域非常流行。它最好通过一个例子来描述。假设我们想要对GoMusic应用程序的HTTP处理函数之一进行单元测试。`GetProducts()`方法是一个展示我们例子的好方法，因为该方法的目的就是返回GoMusic商店中所有可销售产品的列表。以下是`GetProducts()`方法的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method simply retrieves all of the products from our database and then
    returns the results as a HTTP response. This method utilized the `h.db.GetAllProducts()`
    method to retrieve the data from our database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法只是从我们的数据库中检索所有产品，然后以HTTP响应的形式返回结果。此方法使用了`h.db.GetAllProducts()`方法从我们的数据库中检索数据。
- en: So, when it's time to perform a unit test for `GetProducts()`, we should be
    able to test the functionality of the method without needing a real database.
    Furthermore, we should also be able to inject some error scenarios, where we make
    `h.db.GetAllProducts()` fail, and then ensure that `GetProducts()` reacts as expected.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当需要对`GetProducts()`进行单元测试时，我们应该能够测试该方法的功能，而无需实际数据库。此外，我们还应该能够注入一些错误场景，例如让`h.db.GetAllProducts()`失败，并确保`GetProducts()`按预期反应。
- en: You might be wondering, why is it important to be able to test a method such
    as `GetProducts()` without needing a real database? The answer is simple—unit
    testing is only concerned with the unit you are currently testing, which is the
    `GetProducts()` method, not your database connection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么能够在不需要真实数据库的情况下测试像`GetProducts()`这样的方法很重要？答案是简单的——单元测试只关注你当前正在测试的单元，即`GetProducts()`方法，而不是你的数据库连接。
- en: Mock object types can be defined as object types that you can use to *mock*
    or fake a certain behavior. In other words, in the case of the `h.db.GetAllProducts()`
    method, instead of using an object type that connects to a real database, we can
    use a mock type that does not connect to a real database but can give us the results
    we need to perform the unit testing of the `GetProducts()` method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象类型可以被定义为对象类型，你可以使用它来模拟或伪造某种行为。换句话说，在`h.db.GetAllProducts()`方法的例子中，我们不是使用连接到真实数据库的对象类型，而是可以使用一个不连接到真实数据库但可以给我们提供所需结果的模拟类型，以执行`GetProducts()`方法的单元测试。
- en: Let's go back down memory lane and remember how `h.db.GetAllProducts()` was
    built. The database part of this piece of code was simply an interface called
    `DBLayer`, which we used to describe all the behavior we would need from a database
    layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到记忆的深处，回忆一下`h.db.GetAllProducts()`是如何构建的。这段代码的数据库部分只是一个名为`DBLayer`的接口，我们用它来描述我们需要从数据库层获取的所有行为。
- en: 'Here is what the `DBLayer` interface looked like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`DBLayer`接口的样子：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To create a mock type for our database layer, we just need to create a concrete
    type that will implement `DBLayer` but won't connect to a real database.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的数据库层创建一个模拟类型，我们只需要创建一个具体的类型，该类型将实现`DBLayer`接口，但不会连接到真实的数据库。
- en: The mock object will need to return some simulated data, which we use for our
    testing. We can simply store this data in slices or maps inside our mock object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象需要返回一些模拟数据，这些数据我们用于我们的测试。我们可以简单地在这个模拟对象内部存储这些数据，以切片或映射的形式。
- en: Now that we know what mocking is, let's create our mock db type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了什么是模拟，让我们创建我们的模拟数据库类型。
- en: Creating a mock db type
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模拟数据库类型
- en: 'Inside our `backend/src/dblayer` folder, let''s add a new file called `mockdblayer.go`.
    Inside this new file, let''s create a type called `MockDBLayer`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`backend/src/dblayer`文件夹中，让我们添加一个名为`mockdblayer.go`的新文件。在这个新文件中，让我们创建一个名为`MockDBLayer`的类型：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `MockDBLayer` type hosts four types:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`MockDBLayer`类型包含四种类型：'
- en: '`err`: This is an error type that we can set at will whenever we need to simulate
    an error scenario. We''ll look at how to use it when it''s time to write our unit
    tests.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err`：这是一个错误类型，我们可以在需要模拟错误场景时随意设置。我们将在编写单元测试时查看如何使用它。'
- en: '`products`: This is where we store our mock list of products.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`products`：这是我们存储模拟产品列表的地方。'
- en: '`customers`: This is where we store our mock list of customers.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customers`：这是我们存储模拟客户列表的地方。'
- en: '`orders`: This is where we store our mock list of orders.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orders`：这是我们存储模拟订单列表的地方。'
- en: 'Next, let''s write a constructor for our mock type:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的模拟类型编写一个构造函数：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The constructor takes three arguments: a list of `products`, a list of `customers`,
    and a list of `orders`. This gives other developers the opportunity to define
    their own data for testing, which is good for flexibility. However, other developers
    should be able to initialize the `MockDBLayer` type with some mock data pre-loaded:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受三个参数：一个`products`列表、一个`customers`列表和一个`orders`列表。这给其他开发者提供了定义他们自己的测试数据的机会，这对于灵活性来说是个好事情。然而，其他开发者应该能够使用一些预加载的模拟数据来初始化`MockDBLayer`类型：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding function has some data hardcoded inside it, which then gets fed
    to the `MockDBLayer` constructor. This allows developers to make use of the `MockDBLayer`
    type so that they can use it right away without first needing to come up with
    data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数内部有一些硬编码的数据，这些数据随后被传递给`MockDBLayer`构造函数。这允许开发者使用`MockDBLayer`类型，这样他们就可以立即使用它，而无需首先想出数据。
- en: 'Next, we need to offer methods to expose the data that''s being used by the
    `MockDBLayer` type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供方法来暴露`MockDBLayer`类型正在使用的数据：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need a method that will allow us to be in full control of the errors
    that are returned by the methods of `MockDBLayer`. This is important because during
    our unit tests, it''s likely we''ll need to test how the code will behave if an
    error occurs. We''ll revisit this concept when we work on our unit test. For now,
    let''s write a method that allows us to set errors that are returned by our mock
    type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个方法，使我们能够完全控制`MockDBLayer`方法返回的错误。这很重要，因为在我们的单元测试中，我们很可能会需要测试如果发生错误，代码将如何表现。当我们开始编写单元测试时，我们将重新审视这个概念。现在，让我们编写一个方法，使我们能够设置由我们的模拟类型返回的错误：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, it''s time to implement the `DBLayer` interface methods. Let''s start
    with the `GetAllProducts()` method. This is what it will look like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现`DBLayer`接口的方法了。让我们从`GetAllProducts()`方法开始。它将看起来像这样：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing we need to check is whether the `MockDBLayer` type returns an
    error or not. If it needs to return an error, then we just return the error. Otherwise,
    we return the list of products we saved in our mock type.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要检查的是`MockDBLayer`类型是否返回错误。如果需要返回错误，我们就直接返回错误。否则，我们返回我们保存在模拟类型中的产品列表。
- en: 'Next, let''s take a look at the `GetPromos()` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`GetPromos()`方法：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we first checked whether we should return an error, like
    we did previously. We then looped through the list of products and picked the
    products that have promotions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先检查是否应该返回错误，就像我们之前做的那样。然后我们遍历产品列表，选择具有促销的产品。
- en: 'Next, let''s explore the `GetProduct(id)` method. This method should be able
    to retrieve a product based on the `id` that''s provided. This is what it looks
    like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索`GetProduct(id)`方法。此方法应该能够根据提供的`id`检索产品。它看起来是这样的：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with the other methods, we first need to check whether we need to return
    an error, and if so, we return the error and exit the method. Otherwise, we retrieve
    the piece of data that's being queried by this method. In the case of `GetProduct(id)`,
    we loop through the products list and then return the product with the requested
    `id`. This loop could have been replaced by a simple map retrieval if we were
    to store our products in a map instead of a list. In a production environment,
    you will need to decide how you would like your data to be represented in your
    mock objects (maps and/or slices). In this case, I decided to go with a slice
    for simplicity. In a more complex mock object, you might want to store data in
    slices for methods that return all the data, as well as in maps for methods that
    return specific items.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他方法一样，我们首先需要检查是否需要返回错误，如果是的话，我们就返回错误并退出方法。否则，我们检索此方法查询的数据。在`GetProduct(id)`的情况下，我们遍历产品列表，然后返回具有请求`id`的产品。如果我们把产品存储在列表中而不是映射中，这个循环可以被简单的映射检索所替代。在生产环境中，您需要决定您希望在模拟对象（映射和/或切片）中如何表示您的数据。在这种情况下，我决定为了简单起见使用切片。在更复杂的模拟对象中，您可能希望对于返回所有数据的函数存储数据在切片中，而对于返回特定项的函数存储数据在映射中。
- en: The rest of the code for the mock object will continue to implement the `DBLayer`
    interface methods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象的其余代码将继续实现`DBLayer`接口方法。
- en: 'Here is the method to get a customer by name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是按名称获取客户的代码：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the method to get a customer by their ID:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是按ID获取客户的代码：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is the code to add a user:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加用户的代码：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the code to sign in a user:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是登录用户的代码：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is the code to sign out a user by ID:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是按ID注销用户的代码：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the code to get customer orders by ID:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是按ID获取客户订单的代码：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the code to add an order:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是添加订单的代码：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, the following methods are just place holders for the credit card handling
    logic. The unit tests that we''ll explore in this chapter won''t cover credit
    card handling, so to simplify things; let''s just leave them as place holders
    for now:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下方法只是信用卡处理逻辑的占位符。在本章中我们将探讨的单元测试不会覆盖信用卡处理，为了简化问题；让我们现在就先将其作为占位符：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is worth mentioning that there are some third-party open source projects
    in the Go language that can help with the creation and utilization of mock objects.
    However, in this chapter, we have built our own.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在Go语言中存在一些第三方开源项目，可以帮助创建和使用模拟对象。然而，在本章中，我们已经构建了自己的。
- en: Now that we have created a mock db type, let's cover unit testing in Go.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个模拟数据库类型，让我们来谈谈Go语言中的单元测试。
- en: Unit testing in Go
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言中的单元测试
- en: It's now time to explore unit testing in Go and make use of the `MockDBLayer`
    type that we built in the previous section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索Go语言中的单元测试并利用我们在上一节中构建的`MockDBLayer`类型了。
- en: The first step for writing unit tests in Go is to create a new file in the same
    folder as the package you would like to test. The filename has to end with `_test.go`.
    In our case, since we seek to test the `GetProducts()` method in the `rest` package,
    we'll create a new file in the same folder and call it `handler_test.go`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中编写单元测试的第一步是在您想要测试的包所在的同一文件夹中创建一个新文件。文件名必须以`_test.go`结尾。在我们的例子中，由于我们想要测试`rest`包中的`GetProducts()`方法，我们将在同一文件夹中创建一个新文件，并将其命名为`handler_test.go`。
- en: This file will only build and execute when you run unit tests, but not during
    regular builds. You may be wondering, how would I run unit tests in Go? The answer
    is simple—you utilize the `go test` command! Whenever you run `go test`, only
    the files that end with `_test.go` will build and run.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件仅在运行单元测试时构建和执行，而在常规构建期间不会执行。你可能想知道，我如何在Go中运行单元测试？答案是简单的——你使用`go test`命令！每次你运行`go
    test`时，只有以`_test.go`结尾的文件才会构建和运行。
- en: 'If you are running the `go test` command from a different folder than the folder
    of the package that you would like to test, then you can just point to the package
    that you would like to test:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从不同于你想要测试的包的文件夹运行`go test`命令，那么你只需指向你想要测试的包：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For example, if we want to run the unit tests for our `rest` package, the command
    will look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想运行`rest`包的单元测试，命令将看起来像这样：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s dive further into the `handler_test.go` file. The first thing we
    need to do is declare the package:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步深入到`handler_test.go`文件。我们需要做的第一件事是声明包：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we need to write a function that will represent our unit test. In Go,
    you need to follow some specific rules to ensure that your function gets executed
    as part of the unit testing that''s produced by the `go test` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个表示我们的单元测试的函数。在Go中，你需要遵循一些特定的规则来确保你的函数作为`go test`命令产生的单元测试的一部分执行：
- en: Your function has to start with the word `Test`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的函数必须以单词`Test`开头
- en: The first letter after `Test` has to be in upper case
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Test`之后的首字母必须大写
- en: The function needs to take the `*testing.T` type as an argument
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数需要以`*testing.T`类型作为参数
- en: The `*testing.T` type provides some important methods that will help us signify
    whether a test has failed or passed. The type also provides some logging features
    that we can use. We'll see the `*testing.T` type in action shortly, when we start
    writing our test code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`*testing.T`类型提供了一些重要的方法，将帮助我们表明测试是否失败或通过。该类型还提供了一些我们可以使用的日志功能。当我们开始编写测试代码时，我们将很快看到`*testing.T`类型的实际应用。'
- en: 'So, by following the preceding three rules, we''ll create a new function called `TestHandler_GetProducts` to
    host the unit testing code for the `GetProducts()` method in our HTTP handler. Here
    is what the function will look like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，遵循前面的三个规则，我们将创建一个名为`TestHandler_GetProducts`的新函数，用于托管我们HTTP处理器中`GetProducts()`方法的单元测试代码。这个函数将看起来像这样：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first thing we need to do is enable the test mode of the Gin framework.
    The testing mode of the Gin framework prevents too much logging:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是启用Gin框架的测试模式。Gin框架的测试模式可以防止过多的日志记录：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, let''s initialize our `mockdbLayer` type. We will use the constructor
    that included some hardcoded data:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们初始化我们的`mockdbLayer`类型。我们将使用包含一些硬编码数据的构造函数：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `GetProducts()` method we are seeking to test in this section is an HTTP
    handler function, which is expected to return a list of products that are available
    from the GoMusic store. As we covered in the previous chapters, an HTTP handler
    function can be defined as an action that gets executed when an HTTP request is
    sent to a specific relative URL. The HTTP handler will process the HTTP request
    and return a response via HTTP as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中寻求测试的`GetProducts()`方法是一个HTTP处理器函数，它预期返回GoMusic商店可用的产品列表。正如我们在前面的章节中所述，HTTP处理器函数可以定义为当向特定的相对URL发送HTTP请求时执行的操作。HTTP处理器将处理HTTP请求并通过HTTP返回响应。
- en: In our unit test, we'll need to test not only the functionality of `GetProducts()`
    as a method, but also how it reacts to HTTP requests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试中，我们需要测试`GetProducts()`作为方法的功能，以及它对HTTP请求的反应。
- en: 'We''ll need to define the relative URL that will activate the HTTP handler
    function for that. Let''s call it `/products` and make it a constant:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个相对URL，该URL将激活该HTTP处理器函数。让我们称它为`/products`并将其设为一个常量：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We'll see how we can make use of that constant in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中看到如何利用这个常数。
- en: In the next section we'll cover an important concept known as table-drive development.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一个称为表驱动开发的重要概念。
- en: Table-driven development
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表驱动开发
- en: In a typical practical unit test, we seek to test a certain function or method
    to see how it will react to certain inputs and error conditions. This means that
    the code of the unit test would need to call the function or method we are trying
    to test multiple times, and with different inputs and error conditions. Instead
    of writing large interconnection `if` statements to make the calls with different
    inputs, we can instead follow a very popular design pattern known as **table-driven
    development**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的实际单元测试中，我们试图测试某个函数或方法，看看它将如何响应某些输入和错误条件。这意味着单元测试的代码需要多次调用我们试图测试的函数或方法，并使用不同的输入和错误条件。而不是编写大量的大规模`if`语句来使用不同的输入进行调用，我们可以遵循一个非常流行的设计模式，称为**表驱动开发**。
- en: The idea behind test-driven development is simple—we will use an array of Go
    structs or a map to represent our tests. The struct array or map will contain
    information about the inputs and error conditions that we want to pass to the
    function/method being tested. We will then loop through the array of Go structs
    and call the method/function to be tested with the current inputs and error conditions.
    This approach will produce a number of sub-tests under the main unit test.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发背后的思想很简单——我们将使用Go结构体的数组或映射来表示我们的测试。结构体数组或映射将包含我们想要传递给正在测试的函数/方法的输入和错误条件的信息。然后我们将遍历Go结构体数组并调用当前输入和错误条件下的待测试方法/函数。这种方法将在主单元测试下产生多个子测试。
- en: 'In our unit test, we''ll use an array of Go structs to represent our different
    subtests. Here is what the array will look like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试中，我们将使用Go结构体的数组来表示我们的不同子测试。以下是数组的结构：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s call the preceding code our `test` table. Here is what the Go struct
    fields will represent:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把前面的代码称为我们的`test`表。以下是Go结构字段将表示的内容：
- en: '`name`: This is the name of the subtest.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是子测试的名称。'
- en: '`inErr`: This is the input error. We will inject this error into the mock db
    layer type and monitor how the `GetProducts()` method will behave.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inErr`: 这是输入错误。我们将把这个错误注入到模拟数据库层类型中，并监控`GetProducts()`方法的行为。'
- en: '`outStatusCode`: This is the expected HTTP status code that is produced from
    calling the `GetProducts()` HTTP handler. If the HTTP status code that''s returned
    from calling `GetProducts()` as an HTTP handler does not match this value, then
    the unit test fails.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outStatusCode`: 这是调用`GetProducts()` HTTP处理器产生的预期HTTP状态码。如果从调用`GetProducts()`作为HTTP处理器返回的HTTP状态码不匹配此值，则单元测试失败。'
- en: '`expectedRespBody`: This is the expected HTTP response body that''s returned
    from calling the `GetProducts()` HTTP handler. If the returned HTTP body does
    not match this value, then the unit test fails. This field is of the `interface{}` type
    because it can either be a slice of products or an error message. The `interface{}`
    type in Go can represent any other data type.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expectedRespBody`: 这是从调用`GetProducts()` HTTP处理器返回的预期HTTP响应体。如果返回的HTTP体不匹配此值，则单元测试失败。该字段是`interface{}`类型，因为它可以是产品切片或错误消息。Go语言中的`interface{}`类型可以表示任何其他数据类型。'
- en: The beauty of the table-driven testing design pattern is the fact that it's
    very flexible; you can simply add more fields to test more conditions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表驱动测试设计模式的美丽之处在于它的灵活性；你可以简单地添加更多字段来测试更多条件。
- en: There are two expected HTTP response bodies that can be produced from the `GetProducts()`
    HTTP handler—we either get some list of products, or we get an error message.
    The error message takes the following format: `{error:"the error message"}`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从`GetProducts()` HTTP处理器可以产生两个预期的HTTP响应体——我们要么得到一些产品列表，要么得到一个错误消息。错误消息采用以下格式：`{error:"the
    error message"}`。
- en: 'Before we start running our subtests from our test table, let''s define a `struct`
    type to represent the error message so that we can use it in our testing:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从测试表中开始运行子测试之前，让我们定义一个`struct`类型来表示错误消息，这样我们就可以在测试中使用它：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we need to define our list of subtests. For simplicity, we''ll pick two
    different scenarios to test:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们的子测试列表。为了简单起见，我们将选择两种不同的场景进行测试：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding code, we defined two different subtests:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个不同的子测试：
- en: The first one is called `getproductsnoerrors`. It represents a straight execution
    scenario where no errors occurred and everything worked fine. We inject no errors
    to the mock db layer type, so we expect no errors to return from the `GetProducts()`
    method. We expect an HTTP response status of `OK`, and we expect to get a list
    of the product data that's stored in mock db layer as the HTTP response body.
    The reason why we expect to get a list of the product data stored in the mock
    db layer as our output is because of the fact that the mock db type will be the
    database layer for our `GetProducts()` method.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个方法称为`getproductsnoerrors`。它代表一个直接执行场景，其中没有发生错误，一切正常。我们没有向模拟数据库层类型注入任何错误，因此我们预期`GetProducts()`方法不会返回任何错误。我们预期HTTP响应状态为`OK`，并且我们预期将获得存储在模拟数据库层中的产品数据列表作为HTTP响应体。我们之所以预期获得存储在模拟数据库层中的产品数据列表作为我们的输出，是因为模拟数据库类型将是我们的`GetProducts()`方法的数据库层。
- en: The second one is called `getproductswitherror`. It represents an execution
    scenario where an error has occurred. We inject an error called `"get products
    error"` into the mock db layer type. This error will be expected to be returned
    as the HTTP response body of the `GetProducts()` handler function call. The HTTP
    status code that's expected will be `StatusInternalServerError`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个方法称为`getproductswitherror`。它代表一个发生错误的执行场景。我们将一个名为`"get products error"`的错误注入到模拟数据库层类型中。这个错误预期将作为`GetProducts()`处理函数调用的HTTP响应体返回。预期的HTTP状态码将是`StatusInternalServerError`。
- en: The remainder of our unit test code will loop through the test table and execute
    our tests. The `*testing.T` type, which got passed as an argument to our unit
    test function, provides methods that we can use to define subtests within our
    unit test, which we can then run in parallel.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们单元测试代码的其余部分将遍历测试表并执行我们的测试。`*testing.T`类型，它作为参数传递给我们的单元测试函数，提供了我们可以用来在单元测试中定义子测试的方法，然后我们可以并行运行这些子测试。
- en: 'First, to define a subtest within our unit test, we must utilize the following
    method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在我们的单元测试中定义一个子测试，我们必须使用以下方法：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The first argument is the name of the subtest, whereas the second argument
    is a function that represents the subtest we would like to run. In our case, we''ll
    need to loop through our `test` table and call `t.Run()` for each subtest. Here
    is what this will look like:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是子测试的名称，而第二个参数是一个表示我们想要运行的子测试的函数。在我们的情况下，我们需要遍历我们的`test`表并对每个子测试调用`t.Run()`。下面是这个过程的示例：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s focus on the code to run for our subtests. The first thing we need
    to do is inject an error into the mock type:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于运行子测试的代码。我们首先需要做的是将一个错误注入到模拟类型中：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to create a test HTTP request to represent the HTTP request which
    will be received by our `GetProducts()` HTTP handler. Again, Go comes to the rescue
    with a standard package called `httptest`. This package empowers you to create
    special data types that allow you to test HTTP-related functionality. One of the
    functions provided by `httptest` is a function called `NewRequest()`, which returns
    an HTTP request type that we can use for our testing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个测试HTTP请求来表示将被我们的`GetProducts()` HTTP处理程序接收到的HTTP请求。同样，Go通过一个名为`httptest`的标准包来提供帮助。这个包使你能够创建特殊的数据类型，允许你测试与HTTP相关的功能。`httptest`提供的一个函数是名为`NewRequest()`的函数，它返回一个我们可以用于测试的HTTP请求类型：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The function takes three arguments: the type of HTTP method, the relative URL
    where the HTTP request is expected to get sent, and the body of the request, if
    any.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受三个参数：HTTP方法的类型、预期发送HTTP请求的相对URL，以及请求体（如果有）。
- en: In the case of the `GetProducts()` HTTP `handler` method, it's expecting an
    HTTP `GET` request that targets the `/products` relative URL. We have already
    stored the `/products` value in the `productsURL` constant.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetProducts()` HTTP `handler`方法的案例中，它期望一个针对`/products`相对URL的HTTP `GET`请求。我们已经在`productsURL`常量中存储了`/products`值。
- en: 'The `httptest` package also provides a data type called `ResponseRecorder`,
    which can be used to capture the HTTP response of an HTTP handler function call.
    The `ResponseRecorder` data type implements Go''s `http.ResponseWriter` interface,
    which enables the `ResponseRecorder` to be injected in any code that makes use
    of `http.ResponseWriter`. We''ll need to obtain a value of this data type so that
    we can use it in our testing:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`httptest` 包还提供了一个名为 `ResponseRecorder` 的数据类型，可以用来捕获 HTTP 处理函数调用的 HTTP 响应。`ResponseRecorder`
    数据类型实现了 Go 的 `http.ResponseWriter` 接口，这使得 `ResponseRecorder` 可以注入到任何使用 `http.ResponseWriter`
    的代码中。我们需要获取这个数据类型的一个值，以便在测试中使用它：'
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we''ll need to create an instance of the Gin framework engine to use
    it in our test. This is because the `GetProducts()` method that we are trying
    to test is an HTTP handler function for a Gin engine router, so it needs a `*gin.Context`
    type as its input. Here is what the function signature looks like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 Gin 框架引擎的一个实例，以便在我们的测试中使用。这是因为我们试图测试的 `GetProducts()` 方法是一个 Gin 引擎路由器的
    HTTP 处理函数，所以它需要一个 `*gin.Context` 类型的输入。下面是这个函数签名的样子：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Luckily, the Gin framework comes prepared with a function called `CreateTestContext()`
    for the exact purpose of creating an instance of a Gin context and an instance
    of a Gin engine to use for testing. The `CreateTestContext()` function takes an
    `http.ResponseWriter` interface as input, which means that we can pass our `httptest.ResponseRecorder`
    as the input, since it implements the `http.ResponseWriter` interface as input.
    Here is what the code will look like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Gin 框架已经为我们准备了一个名为 `CreateTestContext()` 的函数，专门用于创建 Gin 上下文实例和 Gin 引擎实例，以便在测试中使用。`CreateTestContext()`
    函数接受一个 `http.ResponseWriter` 接口作为输入，这意味着我们可以传递我们的 `httptest.ResponseRecorder`
    作为输入，因为它实现了 `http.ResponseWriter` 接口。下面是代码的示例：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we mentioned earlier, the `CreateTestContext()` function returns two values:
    a Gin context instance and a Gin engine instance. In our case, we will not make
    use of the Gin context instance, which is why we didn''t receive the value for
    it in the preceding code. The reason why we won''t make use of the Gin context
    instance is because I prefer to use the Gin engine instance for my testing, as
    it allows me to test the full workflow of an HTTP request being served.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`CreateTestContext()` 函数返回两个值：一个 Gin 上下文实例和一个 Gin 引擎实例。在我们的情况下，我们不会使用
    Gin 上下文实例，这就是为什么在之前的代码中没有接收到它的值。我们不使用 Gin 上下文实例的原因是我更喜欢使用 Gin 引擎实例进行测试，因为它允许我测试
    HTTP 请求被完全处理的工作流程。
- en: 'Next, we''ll make use of the Gin engine instance to map our `GetProducts()`
    method to the `productsURL` relative URL address via an HTTP `GET` request. Here
    is what this looks like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Gin 引擎实例将我们的 `GetProducts()` 方法映射到 `productsURL` 相对 URL 地址，通过一个 HTTP
    `GET` 请求。下面是这个过程的示例：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, it''s time to get our Gin engine to serve the HTTP request, and then pass
    the HTTP response to our `ResponseRecorder`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候让我们的 Gin 引擎处理 HTTP 请求，并将 HTTP 响应传递给我们的 `ResponseRecorder`：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will, in effect, send our test HTTP request to the `GetProducts()` handler
    method, since the test request targets `productsURL`. The `GetProducts()` handler
    method will then process the request and send an HTTP response via `w`, which
    is our `ResponseRecorder`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会将我们的测试 HTTP 请求发送到 `GetProducts()` 处理方法，因为测试请求的目标是 `productsURL`。然后，`GetProducts()`
    处理方法将处理请求并通过 `w`（我们的 `ResponseRecorder`）发送 HTTP 响应。
- en: 'It''s now time to test how `GetProducts()` processed the HTTP request. The
    first thing we need to do is extract the HTTP response from `w`. This is done
    via the `Result()` method in the `ResponseRecorder` object type:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试 `GetProducts()` 如何处理 HTTP 请求了。我们首先需要做的是从 `w` 中提取 HTTP 响应。这是通过 `ResponseRecorder`
    对象类型的 `Result()` 方法完成的：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we need to test the HTTP status code of the result. If it''s not equal
    to the expected HTTP status code, then we fail the test case and we log why:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要测试结果的 HTTP 状态码。如果它不等于预期的 HTTP 状态码，那么我们将失败测试用例，并记录失败的原因：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As shown in the preceding code, the `*testing.T` type comes equipped with a
    method called `Errorf`, which can be used to log a message and then fail the test.
    If we wanted to log a message without failing the test, we can use a method called
    `Logf`. If we want to fail a test right away, we can call a method called `Fail`.
    The `t.Errorf` method is the combination of `t.Logf`, followed by `t.Fail`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`*testing.T`类型自带一个名为`Errorf`的方法，可以用来记录消息然后失败测试。如果我们想要记录消息而不失败测试，我们可以使用名为`Logf`的方法。如果我们想要立即失败测试，我们可以调用名为`Fail`的方法。`t.Errorf`方法是`t.Logf`和`t.Fail`的组合。
- en: 'Next, we need to capture the HTTP body of the response so that we''re able
    to compare it to the expected HTTP response body for this subtest. There are two
    scenarios to consider: either an error was injected into our subtest, which means
    an error message is expected as the result, or there was no error injected, which
    means a list of products is the expected HTTP response body:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要捕获响应的HTTP正文，以便我们能够将其与预期此子测试的HTTP响应正文进行比较。有两种情况需要考虑：要么在我们的子测试中注入了错误，这意味着预期结果是错误消息，要么没有注入错误，这意味着预期HTTP响应正文是一个产品列表：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last thing we need to do is compare the expected HTTP response body with
    the actual HTTP response body that we received. To do the comparison, we need
    to make use of a very handy function that is present in Go''s `reflect` package.
    This function is called `reflect.DeepEqual()`, and it helps us to fully compare
    two values and identify whether they are clones of each other. If the two values
    are not equal, then we log an error and fail the test. Here is what the code will
    look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的事情是将预期的HTTP响应正文与实际收到的HTTP响应正文进行比较。要进行比较，我们需要利用Go的`reflect`包中的一个非常有用的函数。这个函数叫做`reflect.DeepEqual()`，它帮助我们完全比较两个值并确定它们是否是彼此的副本。如果两个值不相等，那么我们将记录一个错误并失败测试。以下是代码的样子：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With this, our unit test is completed! Let''s have a look at what the overall
    testing code will look like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的单元测试就完成了！让我们看看整体测试代码将是什么样子：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It''s worth mentioning that Go gives you the power to run your subtests in
    parallel to each other. You can invoke this behavior by calling `t.Parallel()`
    inside your subtests. Here is what this will look like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Go给你提供了运行你的子测试相互并行的能力。你可以在子测试中调用`t.Parallel()`来触发这种行为。以下是它的样子：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, when you run concurrent subtests, you must make sure that any data
    types they share won't change state or behavior in parallel, otherwise your test
    results will not be reliable. For example, in our code, we use a single mock db
    layer type object, which was initialized outside of the subtests. This means that
    whenever we change the error state of the mock db layer inside a subtest, it might
    have affected other subtests running in parallel and made use of the mock db layer
    object at the same time.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你运行并发子测试时，你必须确保它们共享的任何数据类型在并行时不会改变状态或行为，否则你的测试结果将不可靠。例如，在我们的代码中，我们使用了一个单独的模拟数据库层类型对象，该对象是在子测试外部初始化的。这意味着每次我们在子测试中更改模拟数据库层的错误状态时，它可能会影响同时运行的其它子测试，并使用相同的模拟数据库层对象。
- en: 'What remains in this section is to run our unit test and witness the results.
    As we mentioned earlier, you can either run the `go test` command from inside
    the folder that hosts the package you seek to test, or you can use the `go test
    <your_package_path>` command from outside your package folder. If the unit test
    passes, you will see an output that looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余的任务是运行我们的单元测试并见证结果。正如我们之前提到的，你可以从包含你想要测试的包的文件夹内部运行`go test`命令，或者你可以从你的包文件夹外部使用`go
    test <your_package_path>`命令。如果单元测试通过，你将看到类似以下的输出：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The default output shows you the full name of the package that was tested and
    the time it took to run the test(s).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输出显示了被测试的包的完整名称以及运行测试所需的时间。
- en: 'If you want to see more information, you can run `go test -v`. This is what
    this command will return:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到更多信息，你可以运行`go test -v`。这个命令将返回以下内容：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `-v` flag shows verbose output—it will show you the name of the unit test
    being run, as well as the names of the subtests within the unit test as they run.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`标志显示详细输出——它会显示正在运行的单元测试的名称，以及单元测试中正在运行的子测试的名称。'
- en: Let's take a look at benchmarking in the next section
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节的基准测试。
- en: Benchmarking
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: Another key topic in the world of testing software is benchmarking. **Benchmarking**
    is the practice of measuring the performance of your code. The Go `testing` package
    offers you the ability to perform strong benchmarking on your code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试软件的世界中，另一个关键主题是基准测试。**基准测试**是衡量你代码性能的实践。Go 的 `testing` 包为你提供了执行强大基准测试的能力。
- en: 'Let''s start by targeting a piece of code and showcase how to benchmark it
    using Go. A good function to benchmark is the `hashpassword()` function, which
    is utilized by our database layer. This function can be found in the `backend/src/dblayer/orm.go`
    file. It takes a reference to a string as an argument, and then it uses a `bcrypt`
    hash to hash the string. Here is the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先针对一段代码，展示如何使用 Go 进行基准测试。一个很好的基准测试函数是 `hashpassword()` 函数，它被我们的数据库层使用。这个函数可以在
    `backend/src/dblayer/orm.go` 文件中找到。它接受一个字符串的引用作为参数，然后使用 `bcrypt` 散列来散列字符串。以下是代码：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Let's say that we would like to test the performance of this function. How do
    we begin?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试这个函数的性能。我们应该如何开始？
- en: The first step is to create a new file. The filename should end with `_test.go`.
    The file needs to exist in the same folder as the `dblayer` package, which hosts
    the function we seek to test. Let's call the file `orm_test.go`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新文件。文件名应以 `_test.go` 结尾。该文件需要存在于与 `dblayer` 包相同的文件夹中，该包是我们想要测试的函数所在的位置。让我们称这个文件为
    `orm_test.go`。
- en: As we mentioned earlier, files whose names end with `_test.go` will not be part
    of the regular build process. Instead, they activate when we run tests via the
    `go test` command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，以 `_test.go` 结尾的文件将不会成为常规构建过程的一部分。相反，它们会在我们通过 `go test` 命令运行测试时激活。
- en: 'Next, inside the file, we''ll start by declaring the Go package that the file
    belongs to, which is `dblayer`. Then, we need to import the testing package that
    we will use in our code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在文件内部，我们首先声明该文件所属的 Go 包，即 `dblayer`。然后，我们需要导入我们将在代码中使用的测试包：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, it''s time to write the code to benchmark the `hashpassword()` function.
    To write benchmark functions in Go, we need to follow these rules:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写基准测试 `hashpassword()` 函数的代码了。要在 Go 中编写基准函数，我们需要遵循以下规则：
- en: The function name has to start with the word `Benchmark`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名必须以单词 `Benchmark` 开头。
- en: The first letter after the word `Benchmark` needs to be in upper case.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单词 `Benchmark` 之后的第一封信需要大写。
- en: The function takes `*testing.B` as an argument. The `*testing.B` type provides
    methods that facilitate benchmarking our code.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数接受 `*testing.B` 作为参数。`*testing.B` 类型提供了便于基准测试我们代码的方法。
- en: 'As we follow those three rules, we''ll build our benchmark function with the
    following signature:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这三个规则，我们将使用以下签名构建基准函数：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we''ll initialize a string to be hashed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将初始化一个要散列的字符串：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To utilize an object of type `*testing.B` to benchmark a piece of code, we
    need to run the targeted piece of code `b.N` times. `N` is simply a field in the
    `*testing.B` type, which adjusts its value until the targeted code can be reliably
    measured. This is what the code will look like:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用类型为 `*testing.B` 的对象来基准测试一段代码，我们需要运行目标代码 `b.N` 次。`N` 是 `*testing.B` 类型中的一个字段，它会调整其值，直到目标代码可以被可靠地测量。代码将如下所示：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code will run `hashPassword()` as many times as it takes to benchmark
    it. To run the benchmark, we can use the `go test` command in combination with
    a `-bench` flag:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将运行 `hashPassword()`，直到它被基准测试。要运行基准测试，我们可以使用带有 `-bench` 标志的 `go test` 命令：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `-bench` flag needs to be provided as a regex expression to indicate the
    benchmark functions that we would like to run. If we would like to run everything
    that''s available, we can use `.` to indicate all. Otherwise, if we only want
    to run benchmarks that include the term `HashPassword`, we can modify the command,
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`-bench` 标志需要提供一个正则表达式，以指示我们想要运行的基准函数。如果我们想运行所有可用的内容，我们可以使用 `.` 来表示所有。否则，如果我们只想运行包含
    `HashPassword` 术语的基准测试，我们可以修改命令，如下所示：'
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output will look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output simply states that the `hashPassword` function was run 20 times,
    and that it had a speed of about 69,609,530 nanoseconds per loop.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出简单地说明 `hashPassword` 函数运行了 20 次，并且它的速度大约是每循环 69,609,530 纳秒。
- en: 'In our case, we only initialized a string right before running our benchmark,
    which is a very straightforward and easy operation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们在运行基准测试之前只初始化了一个字符串，这是一个非常直接且简单的操作：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'However, if your initialization is much more complex and takes some time to
    complete, it''s advised that you run `b.ResetTimer()` after you finish your initialization
    and before you perform your benchmarking. Here is an example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的初始化非常复杂并且需要一些时间来完成，建议你在完成初始化后、进行基准测试之前运行 `b.ResetTimer()`。以下是一个示例：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `*testing.B` type also comes with an extra method called `RunParallel()`,
    which can test performance in a parallel setting. This works in concert with a
    flag known as `go test -cpu`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`*testing.B` 类型还附带一个名为 `RunParallel()` 的额外方法，可以在并行设置中测试性能。这与一个名为 `go test -cpu`
    的标志协同工作：'
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered a key skill that any software developer should have, which
    is proper software testing in production. We focused on the features that are
    offered by the Go language to enable the testing of Go code.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了任何软件开发者都应该具备的关键技能，即在生产中进行适当的软件测试。我们关注了 Go 语言提供的功能，以支持 Go 代码的测试。
- en: We started by covering how to build mock types and why they are important when
    it comes to software testing. We then covered how to perform unit testing in Go
    and how to benchmark your software.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了如何构建模拟类型以及为什么它们在软件测试中很重要。然后我们介绍了如何在 Go 中进行单元测试以及如何对你的软件进行基准测试。
- en: In the next chapter, we'll explore the concept of Isomorphic Go programming,
    by covering the GopherJS framework.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍 GopherJS 框架来探索同构 Go 编程的概念。
- en: Questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the definition of a mock type? Why is it useful?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟类型的定义是什么？为什么它对软件测试有用？
- en: What is the testing package in Go?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go 中的测试包是什么？
- en: What is the `*testing.T` type used for?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*testing.T` 类型用于什么？'
- en: What is the `*testing.B` type used for?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*testing.B` 类型用于什么？'
- en: What is the `*testing.T.Run()` method used for?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*testing.T.Run()` 方法用于什么？'
- en: What is the `*testing.T.Parallel()` method used for?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*testing.T.Parallel()` 方法用于什么？'
- en: What is meant by benchmarking?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基准测试是什么意思？
- en: What is the `*testing.B.ResetTimer()` method used for?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*testing.B.ResetTimer()` 方法用于什么？'
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can go through the following links:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，您可以查阅以下链接：
- en: '**The Go testing package**: [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go 测试包**：[https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)'
