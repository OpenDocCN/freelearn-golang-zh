- en: Introduction to Isomorphic Go with GopherJS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS同构Go入门
- en: 'So far, we have covered how to write our frontend using JavaScript. However,
    if you prefer to use Go in the frontend, there is an option for that. This option
    is known as GopherJS, which is a popular Go package combined with a set of commands
    with only one purpose: to compile (also known as **transpiling**) Go code to JavaScript.
    Once Go code is compiled to JavaScript, the code could be utilized in the frontend
    component similarly to JavaScript. An application that relies on the same programming
    language for the frontend and the backend is known as an **isomorphic application**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何使用JavaScript编写我们的前端。然而，如果你想在前端使用Go，有一个选择。这个选择被称为GopherJS，这是一个流行的Go包，结合了一套只有一个目的的命令：将Go代码编译成JavaScript（也称为**转译**）。一旦Go代码被编译成JavaScript，代码就可以在前端组件中像JavaScript一样使用。依赖于相同编程语言的前端和后端的应用程序称为**同构应用程序**。
- en: Like any other software-design approach, writing isomorphic applications has
    its own pros and cons. The chief advantage is the convenience and speed of development
    that comes with using a single programming language that you are really good at
    for most of your code. The main disadvantage is the difficulty of troubleshooting
    non-trivial issues, since you will have to dive into the generated JavaScript
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他软件开发方法一样，编写同构应用有其自身的优缺点。主要优点是使用你非常擅长的单一编程语言进行大部分代码编写所带来的便利性和开发速度。主要缺点是调试非平凡问题比较困难，因为你将不得不深入到生成的JavaScript代码中。
- en: This chapter is an introduction to isomorphic web development. We will cover
    some of the key building blocks of GopherJS, and how you can make use of it to
    write code that can interact with both web browsers and Node.js modules. We will
    also cover how to write a simple React application powered by GopherJS, and some
    open source projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是同构Web开发的入门介绍。我们将介绍GopherJS的一些关键构建块，以及如何利用它编写可以与Web浏览器和Node.js模块交互的代码。我们还将介绍如何使用GopherJS编写一个简单的React应用程序，以及一些开源项目。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: GopherJS fundamentals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GopherJS基础
- en: GopherJS with React
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GopherJS与React
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with this chapter, you will need the following tools:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要以下工具：
- en: The Go language installed ([https://golang.org/doc/install](https://golang.org/doc/install))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Go语言([https://golang.org/doc/install](https://golang.org/doc/install))
- en: Node.js and npm ([https://nodejs.org/en/](https://nodejs.org/en/))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js和npm ([https://nodejs.org/en/](https://nodejs.org/en/))
- en: A code editor, such as VS Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码编辑器，例如VS Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
- en: The chapter assumes familiarity with JavaScript, HTML, React, and Go.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设读者熟悉JavaScript、HTML、React和Go。
- en: If you are not yet familiar with React, please have a look at [Chapter 3](72d04e99-a5af-4af9-b51a-54c4c750871f.xhtml), *Go
    Concurrency,* and [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉React，请参阅第3章*Go并发*和第4章*使用React.js的前端*。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go](https://github.com/PacktPublishing/Hands-On-Full-Stack-Development-with-Go)找到。
- en: GopherJS fundamentals
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS基础
- en: GopherJS is a set of tools, data types, and Go packages that allows you to compile
    Go code to JavaScript. Compiling the code of one programming language to another
    is also known as **transpiling**. GopherJS is very useful for Go developers who
    are not very proficient in JavaScript, because it allows you to write code in
    Go that can be integrated with JavaScript modules. This means that you can write
    code in Go that empowers the frontend of your application, or can be integrated
    with Node.js modules, offering you the flexibility of JavaScript combined with
    the power of Go.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS是一套工具、数据类型和Go包，它允许你将Go代码编译成JavaScript。将一种编程语言的代码编译成另一种语言也称为**转译**。GopherJS对于不太擅长JavaScript的Go开发者非常有用，因为它允许你用Go编写可以与JavaScript模块集成的代码。这意味着你可以用Go编写增强应用程序前端的代码，或者可以与Node.js模块集成，提供JavaScript的灵活性与Go的强大功能。
- en: 'GopherJS is a very a powerful piece of software that is used in numerous applications.
    However, in order to effectively utilize GopherJS, you need to understand its
    building blocks. The first step is to retrieve the package using the `go get` command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS是一个非常强大的软件，被广泛应用于众多应用中。然而，为了有效地利用GopherJS，你需要了解其构建模块。第一步是使用`go get`命令检索包：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, to be able to run some of GopherJS commands, we need to install the `source-map-support`
    node module:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了能够运行一些GopherJS命令，我们需要安装`source-map-support`节点模块：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This allows you to debug your code from Go when the need arises. This is very
    useful when writing non-trivial applications in GopherJS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在需要时从Go代码中调试你的代码。这在编写GopherJS中的非平凡应用时非常有用。
- en: Great, now we are ready to explore the package a bit more. GopherJS provides
    a playground where you can test your GopherJS code at [https://gopherjs.github.io/playground/](https://gopherjs.github.io/playground/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们准备好更深入地探索这个包了。GopherJS提供了一个游乐场，你可以在其中测试你的GopherJS代码[https://gopherjs.github.io/playground/](https://gopherjs.github.io/playground/)。
- en: Now that our GopherJS is set up, let's take a look at the GopherJS types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了GopherJS，让我们来看看GopherJS的类型。
- en: GopherJS types
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS类型
- en: GopherJS includes a sub-package called `js`. This package provides the functionalities
    needed to bridge between Go and JavaScript. The package can be found at [https://godoc.org/github.com/gopherjs/gopherjs/js](https://godoc.org/github.com/gopherjs/gopherjs/js).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS包含一个名为`js`的子包。此包提供了在Go和JavaScript之间桥接所需的功能。该包可以在[https://godoc.org/github.com/gopherjs/gopherjs/js](https://godoc.org/github.com/gopherjs/gopherjs/js)找到。
- en: The key feature provided by the `js` package is the ability to transform Go
    types into JavaScript types, and vice versa.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`js`包提供的关键功能是将Go类型转换为JavaScript类型，反之亦然。'
- en: 'When we consider data types, there are two main categories that need to be
    supported: basic types (`int`, `float`, and `string`) and constructed types (structs
    and interfaces). The following table shows the type mappings between Go basic
    types and JavaScript types, as supported by GopherJS:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑数据类型时，需要支持两大类：基本类型（`int`、`float`和`string`）和构造类型（结构体和接口）。以下表格显示了GopherJS支持的基本类型和JavaScript类型之间的类型映射：
- en: '| **Go type** | **JavaScript type** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **Go类型** | **JavaScript类型** |'
- en: '| `bool` | `Boolean` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `Boolean` |'
- en: '| `int` and `float` | `Number` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `int`和`float` | `Number` |'
- en: '| `string` | `String` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `String` |'
- en: '| `[]int8` | `Int8Array` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `[]int8` | `Int8Array` |'
- en: '| `[]int16` | `Int16Array` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `[]int16` | `Int16Array` |'
- en: '| `[]int32`, `[]int` | `Int32Array` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `[]int32`, `[]int` | `Int32Array` |'
- en: '| `[]uint8` | `Uint8Array` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `[]uint8` | `Uint8Array` |'
- en: '| `[]uint16` | `Uint16Array` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `[]uint16` | `Uint16Array` |'
- en: '| `[]uint32`, `[]uint` | `Uint32Array` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `[]uint32`, `[]uint` | `Uint32Array` |'
- en: '| `[]float32` | `Float32Array` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `[]float32` | `Float32Array` |'
- en: '| `[]float64` | `Float64Array` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `[]float64` | `Float64Array` |'
- en: For example, if you utilize GopherJS to compile a piece of code that includes
    a Go `int` type into JavaScript, the `int` type will become a JavaScript `Number` type.
    It is recommended that you stick with the `int` type, instead of the `uint8`/`uint16`/`uint32`/`uint64`
    types, to improve performance of your transpiled code. It is also recommended
    to use `float64` over `float32`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用GopherJS编译包含Go `int`类型的代码片段，则`int`类型将变为JavaScript的`Number`类型。建议你坚持使用`int`类型，而不是`uint8`/`uint16`/`uint32`/`uint64`类型，以提高转换代码的性能。还建议使用`float64`而不是`float32`。
- en: Now that we know the different GopherJS types, let's move on to object types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了不同的GopherJS类型，让我们继续到对象类型。
- en: Object types
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类型
- en: Basic types are good; however, they are just a simple component of any real
    piece of code. What about Go structs, interfaces, methods, functions, and goroutines?
    The `js` package gives you the power to convert those types to JavaScript.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基本类型很好；然而，它们只是任何真实代码片段的简单组件。那么Go的结构体、接口、方法、函数和goroutine呢？`js`包让你有能力将这些类型转换为JavaScript。
- en: One of the key building blocks provided by the `js` package is the `*js.Object`
    type. This type is simply a container for a native JavaScript object. Most of
    GopherJS's code involves converting Go objects to `*js.Object` or vice versa.
    JavaScript modules are exposed as `*js.Object` in our Go code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`js`包提供的一个关键构建模块是`*js.Object`类型。这种类型只是一个本地JavaScript对象的容器。GopherJS的大部分代码都涉及将Go对象转换为`*js.Object`或反之亦然。JavaScript模块在我们的Go代码中作为`*js.Object`暴露。'
- en: Now, let's explore how to call JavaScript functions from our Go code in the
    next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节中探讨如何从我们的Go代码中调用JavaScript函数。
- en: Calling JavaScript functions from your Go code
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从你的Go代码中调用JavaScript函数
- en: Typically, JavaScript code runs either on Node.js or in the browser. Any code
    that runs on Node.js should have access to what is known as *Node.js* g*lobal
    objects* ([https://nodejs.org/api/globals.html](https://nodejs.org/api/globals.html)).
    If your code ends up running on a Node.js environment, GopherJS gives you access
    to the global objects using the `js.Global` variable, which returns a `*js.Object`
    that hosts your global variables. You can then access a specific object using
    a method called `Get`, then call the object methods using a method called `Call`.
    Let's see an example to better explain this paragraph.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JavaScript代码要么在Node.js上运行，要么在浏览器中运行。在Node.js上运行的任何代码都应该能够访问被称为*Node.js全局对象*的内容（[https://nodejs.org/api/globals.html](https://nodejs.org/api/globals.html)）。如果你的代码最终在Node.js环境中运行，GopherJS通过`js.Global`变量为你提供了访问全局对象的方式，该变量返回一个`*js.Object`，它承载着你的全局变量。然后你可以使用名为`Get`的方法访问特定的对象，然后使用名为`Call`的方法调用对象方法。让我们通过一个例子来更好地解释这一段落。
- en: 'Run the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will be the equivalent of writing a piece of Node.js JavaScript code that
    looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将等同于编写一段类似以下样式的Node.js JavaScript代码：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `js.Global` object opens up very interesting possibilities, as it allows
    you to access Node.js modules and use them in your Go code. For example, let''s
    assume we imported a Node.js module called `prettyjson` to our node project, and
    we would like to use it in our Go code. `prettyjson` is a real package, it has
    a method called `render()`, which converts objects to beautiful-looking JSON.
    This is shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`js.Global`对象开启了非常有趣的可能性，因为它允许你访问Node.js模块并在你的Go代码中使用它们。例如，假设我们向我们的node项目中导入了一个名为`prettyjson`的Node.js模块，并且我们想在Go代码中使用它。`prettyjson`是一个真正的包，它有一个名为`render()`的方法，可以将对象转换为美观的JSON。这在上面的代码中有所展示：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As mentioned, JavaScript code can also run on a browser. The globals available
    to the browser are different. For example, the following piece of code will run
    fine on a browser, but won''t be happy if you try to run it with Node.js:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript代码也可以在浏览器上运行。浏览器可用的全局对象不同。例如，以下代码在浏览器上可以正常运行，但如果尝试在Node.js上运行，则不会高兴：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That is because `"document"` is a global object available for almost all browsers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`"document"`是一个几乎在所有浏览器中都可用的全局对象。
- en: In the next section, we will take a look at the GopherJS commands.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看GopherJS命令。
- en: GopherJS commands
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS命令
- en: 'We now have enough knowledge to start exploring the commands provided by GopherJS
    in order to compile Go code into JavaScript. For any GopherJS command you run,
    make sure the `GOOS` flag is set to either `darwin` or `linux`. If you are running
    on Windows, you''ll need to run the following command from the Terminal session
    expected to run GopherJS''s commands:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了足够的知识来开始探索GopherJS提供的命令，以便将Go代码编译成JavaScript。对于你运行的任何GopherJS命令，确保`GOOS`标志设置为`darwin`或`linux`。如果你在Windows上运行，你需要从终端会话中运行以下命令：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here is what we need to do next—let's start by getting an environment ready.
    After installing GopherJS and the `source-map-support` module, as covered earlier
    in *GopherJS fundamentals* section, create a new folder inside your Go `src` folder
    that is in your `GOPATH`. Let's name the new folder `9-Isomorphic-GO`. Inside
    the new folder, create another folder called `node`. This is where we'll write
    our code that is expecting to interface with node packages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是——让我们首先准备一个环境。在安装了GopherJS和`source-map-support`模块之后，如之前在*GopherJS基础知识*部分所述，在你的`GOPATH`中的Go`src`文件夹内创建一个新的文件夹。让我们将这个新文件夹命名为`9-Isomorphic-GO`。在这个新文件夹内，创建另一个名为`node`的文件夹。这是我们编写预期与node包交互的代码的地方。
- en: 'Now create a file called `main.go` inside the `node` folder. Then type the
    following code into the file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`node`文件夹内创建一个名为`main.go`的文件。然后，将以下代码输入到文件中：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next step is to use the power of GopherJS to convert the preceding code
    into JavaScript. This can simply be done using the `gopherjs build` command. So
    in the console, navigate to the `node` folder, then type the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是利用GopherJS的强大功能将前面的代码转换为JavaScript。这可以通过使用`gopherjs build`命令简单地完成。所以，在控制台中，导航到`node`文件夹，然后输入以下内容：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will create a new file called `main.js`, which will host your converted
    JavaScript code. You will notice that the `main.js` file has a lot of JavaScript
    code. This is because GopherJS re-implements key pieces of Go runtime in the generated
    JavaScript file, in order to be able to support a large number of Go apps and
    packages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`main.js`的新文件，该文件将包含您的转换后的JavaScript代码。您会注意到`main.js`文件中有大量的JavaScript代码。这是因为GopherJS在生成的JavaScript文件中重新实现了Go运行时的关键部分，以便能够支持大量的Go应用程序和包。
- en: 'Like any other Node.js file, you can simply run JavaScript code in the new
    file by typing the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他Node.js文件一样，您只需在新的文件中输入以下命令来运行JavaScript代码：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'GopherJS also supports the `install` command. Run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS还支持`install`命令。运行以下命令：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Doing so will produce a JavaScript file in your `bin` folder. This is similar
    to what the `go install` command would do, except that the result in this case
    is a JavaScript file, not an executable file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将在您的`bin`文件夹中生成一个JavaScript文件。这类似于`go install`命令所做的工作，只不过在这种情况下结果是JavaScript文件，而不是可执行文件。
- en: The GopherJS commands support a flag that allows us to output minified JavaScript,
    this flag is `-m`. Minifying JavaScript involves removing all unnecessary characters,
    such as white spaces, new line characters, and comments.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS命令支持一个标志，允许我们输出压缩后的JavaScript，这个标志是`-m`。压缩JavaScript涉及删除所有不必要的字符，例如空白、换行符和注释。
- en: 'If you would like to run the code directly, and you already have Node.js''s `source-map-support` module
    installed, you can simply use the `gopherjs run` command, so it would look like
    this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想直接运行代码，并且已经安装了Node.js的`source-map-support`模块，您可以直接使用`gopherjs run`命令，它看起来是这样的：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What if we want to try some browser code?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想尝试一些浏览器代码呢？
- en: 'Let''s go back to the parent folder we created, it was called `9-Isomorphic-GO`.
    Under that folder, create a new folder called `browser`, then underneath, create
    a new file called `main.go`. Inside the `main.go` file, write the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们创建的父文件夹，它被称为`9-Isomorphic-GO`。在该文件夹下，创建一个名为`browser`的新文件夹，然后在下面创建一个名为`main.go`的新文件。在`main.go`文件中，编写以下代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is obviously expected to run on the browser, since it makes
    use of the `document` object. We can still utilize `gopherjs build` here in order
    to convert it into JavaScript. However, we have another option.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显然预期在浏览器上运行，因为它使用了`document`对象。我们仍然可以使用`gopherjs build`命令在这里将其转换为JavaScript。然而，我们还有另一个选择。
- en: 'Run the following command at the `browser` folder:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`browser`文件夹中运行以下命令：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A web server will be started, which, by default, will serve your generated files
    at the `localhost:8080` address. Any changes you make to the `main.go` file will
    be reflected in the web-served page; however, you will probably need to refresh
    the web page to see changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将启动一个网络服务器，默认情况下，它将在`localhost:8080`地址上提供服务。您对`main.go`文件所做的任何更改都将反映在提供的网页上；然而，您可能需要刷新网页才能看到更改。
- en: If your Go code exists in a subfolder from where you run the `gopherjs serve`
    command, your page will get served at `localhost:8080/your/sub/folder`, where
    `your/sub/folder` refers to the folder path to your `main.go` file. So for example,
    if your code is at `/test/main.go`, your page will get served at `localhost:8080/test`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Go代码位于运行`gopherjs serve`命令的子文件夹中，您的页面将在`localhost:8080/your/sub/folder`上提供服务，其中`your/sub/folder`指的是`main.go`文件的文件夹路径。例如，如果您的代码位于`/test/main.go`，您的页面将在`localhost:8080/test`上提供服务。
- en: Now, let's discover the bindings between Go and JavaScript that GopherJS provides
    to us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索GopherJS为我们提供的Go和JavaScript之间的绑定。
- en: Go bindings
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go绑定
- en: So far, we've looked at how to embed JavaScript packages into our Go code through
    GopherJS. However, that can get tedious, especially since there are lots of shared
    functionalities between JavaScript and Go packages. Luckily, GopherJS supports
    the conversion of most of Go's standard packages into JavaScript. The list of
    compatible Go packages can be found at [https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md](https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何通过GopherJS将JavaScript包嵌入到我们的Go代码中。然而，这可能会变得繁琐，尤其是由于JavaScript和Go包之间存在许多共享功能。幸运的是，GopherJS支持将Go的大部分标准包转换为JavaScript。兼容的Go包列表可以在[https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md](https://github.com/gopherjs/gopherjs/blob/master/doc/packages.md)找到。
- en: Some of the packages, such as the `os` package, are only supported in Node.js
    environments. This is because most of the package operations are not meant for
    the browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包，如 `os` 包，仅在 Node.js 环境中受支持。这是因为大多数包操作都不适用于浏览器。
- en: 'For example, if you look at the list of compatible Go packages, you''ll find
    the `encoding/csv`, `fmt`, and `string` packages as some of the supported packages.
    Let''s write the following program in Go:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你查看兼容的 Go 包列表，你会发现 `encoding/csv`、`fmt` 和 `string` 包是一些受支持的包。让我们用 Go 编写以下程序：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code will produce the following output:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the code is compiled with GopherJS, it will generate a JavaScript file that
    will produce the same result. This is a very powerful feature in GopherJS, as
    we didn't even need to import GopherJS packages in this project to make it compatible
    with JavaScript.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码用 GopherJS 编译，它将生成一个 JavaScript 文件，该文件将产生相同的结果。这是 GopherJS 中一个非常强大的功能，因为我们甚至不需要在这个项目中导入
    GopherJS 包来使其与 JavaScript 兼容。
- en: Let's see how to export JavaScript modules from Go code in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在下一节中从 Go 代码中导出 JavaScript 模块。
- en: Exporting code
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出代码
- en: When working with GopherJS, an interesting use case is writing code modules
    in Go that are then expected to be used by JavaScript module.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 GopherJS 时，一个有趣的用例是编写 Go 代码模块，然后期望这些模块被 JavaScript 模块使用。
- en: Before we explore how to export JavaScript modules that originated from Go code,
    let's go through some vanilla JavaScript code in order to gain a simple understanding
    of how module exporting works in the language.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索如何导出从 Go 代码生成的 JavaScript 模块之前，让我们先通过一些纯 JavaScript 代码来了解该语言中模块导出是如何工作的。
- en: Inside our `node` folder, create a new folder called `calc`. In that folder,
    we'll write a simple JavaScript module that will allow us to add and/or subtract
    some numbers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `node` 文件夹内，创建一个名为 `calc` 的新文件夹。在那个文件夹中，我们将编写一个简单的 JavaScript 模块，它将允许我们添加和/或减去一些数字。
- en: 'Inside the `calc` folder, create a file called `addsub.js`. There, we''ll create
    two functions, `add()` and `sub()`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `calc` 文件夹内，创建一个名为 `addsub.js` 的文件。在那里，我们将创建两个函数，`add()` 和 `sub()`：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step needed is to export these two functions so that other JavaScript
    modules can make calls to them. This is done by assigning the two functions to
    `modules.exports`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步需要做的是将这些两个函数导出，以便其他 JavaScript 模块可以调用它们。这是通过将两个函数赋值给 `module.exports` 来实现的：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code will expose the two functions as `Add()` and `Sub()`, so
    that they can be imported and called by other JavaScript files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将暴露两个函数为 `Add()` 和 `Sub()`，这样它们就可以被其他 JavaScript 文件导入和调用。
- en: 'Let''s create a new file called `calc.js`. This is where we''ll call the exported
    functions from the `addsub.js` file. To access the exported functions from `addsub.js`,
    we just need to execute the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `calc.js` 的新文件。这就是我们将从 `addsub.js` 文件中调用导出函数的地方。要访问 `addsub.js` 中的导出函数，我们只需执行以下代码：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can then very simply execute our exported functions like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以非常简单地执行我们的导出函数，如下所示：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then print the output like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像这样打印输出：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, how can we write an equivalent code to the `addsub.js` module in Go?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何在 Go 中编写与 `addsub.js` 模块等效的代码？
- en: 'It''s simple—we start by writing our functions in Go. Let''s create a new file
    called `addsubgo.go`, and in there, write the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单——我们首先在 Go 中编写我们的函数。让我们创建一个名为 `addsubgo.go` 的新文件，并在其中编写以下代码：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, in Go''s main function, we''ll utilize a variable provided by GopherJS,
    which is called `js.Module`. This variable gives you access to the `module` variable
    set by Node.js. Let''s type the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Go 的主函数中，我们将利用 GopherJS 提供的一个变量，该变量被称为 `js.Module`。这个变量让你可以访问由 Node.js
    设置的 `module` 变量。让我们输入以下代码：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It will be equivalent to `module.exports` in the JavaScript code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 JavaScript 代码中相当于 `module.exports`。
- en: 'As with most of GopherJS''s variables, `js.Module` is of the `*js.Object` type,
    which basically means that we can call `Get` or `Set` on it to get or set objects.
    Consider the following code in Go:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与 GopherJS 的大多数变量一样，`js.Module` 是 `*js.Object` 类型，这意味着我们可以调用 `Get` 或 `Set` 来获取或设置对象。考虑以下
    Go 代码：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is equivalent to the following code in JavaScript:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 JavaScript 中相当于以下代码：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And that is the key piece of knowledge you need to write exportable JavaScript
    code in Go through GopherJS. Here is how the whole Go file would look:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要知道的关键知识，以便通过 GopherJS 在 Go 中编写可导出的 JavaScript 代码。整个 Go 文件将看起来像这样：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We then need to build the preceding code through GopherJS in order to compile
    it into JavaScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过 GopherJS 构建前面的代码，以便将其编译成 JavaScript：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will generate a new file called `addsubgo.js`, which we can now import
    or use with other JavaScript files. If we go back to `calc.js`, we can change
    it a bit to look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `addsubgo.js` 的新文件，我们现在可以将其导入或与其他 JavaScript 文件一起使用。如果我们回到 `calc.js`，我们可以稍作修改，使其看起来像这样：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code will produce the same result we expect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生我们预期的相同结果。
- en: 'What if we want to write a function that expects an object or a number of objects
    as arguments? Take this one, for example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编写一个期望对象或多个对象作为参数的函数呢？例如，看看这个：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is a very simple function that takes an object as an argument. It then
    returns a `string`, which includes the object fields. The object expects to contain
    two fields: `first` and `second`. When this function gets called, we will need
    to pass an object as an argument to it. Here is how calling the function looks:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的函数，它接受一个对象作为参数。然后它返回一个包含对象字段的 `string`。该对象预期包含两个字段：`first` 和 `second`。当这个函数被调用时，我们需要传递一个对象作为参数给它。以下是调用函数的样子：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Writing the equivalent code in Go is very easy, thanks to GopherJS.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GopherJS 在 Go 中编写等效代码非常容易，多亏了它。
- en: 'Since Go is a statically-typed programming language, first we need to define
    the data type of our object argument. Let''s continue to write code in the `addsubgo.go`
    file. Here is how this looks in Go:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 是一种静态类型编程语言，我们首先需要定义我们的对象参数的数据类型。让我们继续在 `addsubgo.go` 文件中编写代码。以下是它在 Go
    中的样子：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `struct` type was built with two rules in mind:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 类型是按照两个规则构建的：'
- en: Embed the `*js.Object` type in the Go struct
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go struct 中嵌入 `*js.Object` 类型
- en: Assign the `js` struct tag for any field name expected to be converted to JavaScript
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任何预期将被转换为 JavaScript 的字段名分配 `js` struct 标签
- en: 'Perfect—the next step is to write our function in Go:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 完美——下一步是在 Go 中编写我们的函数：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function will be capable of translating to JavaScript using GopherJS, thanks
    to the fact that we followed the two rules when creating the `Obj` type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将能够通过 GopherJS 转换为 JavaScript，因为我们创建 `Obj` 类型时遵循了这两个规则。
- en: 'Next, we export the `FormatNumbers()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导出 `FormatNumbers()` 函数：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once we build this code using the `gopherjs build addsubgo.go` command, our
    new function will callable from JavaScript modules.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用 `gopherjs build addsubgo.go` 命令构建了这段代码，我们的新函数就可以从 JavaScript 模块中调用了。
- en: Now that we know how to export our code, let's take a look at Go methods and
    goroutines in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何导出我们的代码，让我们在下一节中看看 Go 方法和 goroutines。
- en: Go Methods
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 方法
- en: What if we want to expose a Go type with methods to JavaScript?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将一个带有方法的 Go 类型暴露给 JavaScript 呢？
- en: 'Let''s explore a Go type. The following code has a `struct` type that represents
    a musical instrument, and has some `getter` and `setter` methods:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一个 Go 类型。以下代码有一个 `struct` 类型，它代表一种乐器，并有一些 `getter` 和 `setter` 方法：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let's say we want this type to be accessible to JavaScript code. GopherJS comes
    to the rescue with a function called `js.MakeWrapper()`. This function can take
    a Go type as an argument, and it then returns a `*js.Object` that represents the
    Go type with all its exportable methods.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让这个类型对 JavaScript 代码可访问。GopherJS 通过一个名为 `js.MakeWrapper()` 的函数来提供帮助。这个函数可以接受一个
    Go 类型作为参数，然后返回一个 `*js.Object`，它代表了具有所有可导出方法的 Go 类型。
- en: 'Create a constructor for our `MI` `struct` type. It will look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的 `MI` `struct` 类型创建一个构造函数。它看起来像这样：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In our `main` function, we can make this constructor available to JavaScript
    by adding it to the `Global` object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main` 函数中，我们可以通过将其添加到 `Global` 对象中来使这个构造函数对 JavaScript 可用：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code will create a JavaScript function called `New()`, under a
    namespace called `musicalInstruments`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建一个名为 `New()` 的 JavaScript 函数，位于名为 `musicalInstruments` 的命名空间下。
- en: We could have made the `New()` constructor available through a module export,
    through the `js.Module` variable. But for simplicity, it's added to the `Global`
    object for now.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过模块导出或通过 `js.Module` 变量来使 `New()` 构造函数可用。但为了简单起见，目前我们将其添加到 `Global` 对象中。
- en: 'Let''s assume that the filename where this code is hosted is called `mi.go`.
    The GopherJS command to compile this code to JavaScript will look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个代码所在的文件名为 `mi.go`。将此代码编译成 JavaScript 的 GopherJS 命令看起来像这样：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A new file called `mi.js` will get generated, JavaScript can simply access
    the `MI` `struct` type by importing the file, then call the `New()` function from
    the `musicalinstruments` namespace:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成一个名为`mi.js`的新文件，JavaScript可以通过导入该文件简单地访问`MI` `struct`类型，然后从`musicalinstruments`命名空间调用`New()`函数：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will create a new musical instrument object. We can then set its age. Finally,
    we get the age and log it to the standard output.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的乐器对象。然后我们可以设置它的年龄。最后，我们获取年龄并将其记录到标准输出。
- en: Goroutines
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: GopherJS supports goroutines, so you can use goroutines in your Go code, and
    GopherJS will take care of the rest.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: GopherJS支持goroutines，因此你可以在Go代码中使用goroutines，GopherJS将处理其余部分。
- en: One important requirement is that goroutines must be used if you need to call
    some blocking code from an external JavaScript.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要求是，如果你需要从外部JavaScript调用一些阻塞代码，必须使用goroutines。
- en: 'For example, consider the following JavaScript code running in the browser:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下在浏览器中运行的JavaScript代码：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code defines a callback function that is expected to execute when
    a button is clicked.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个回调函数，该函数在按钮被点击时执行。
- en: 'Here is how this should be handled in Go with the help of GopherJS:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在Go的帮助下使用GopherJS来处理这种情况：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As shown in the preceding code snippet, we had to use a goroutine inside the
    event listener callback code, because it was expected to run some blocking code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们必须在事件监听器回调代码中使用goroutine，因为它预期要运行一些阻塞代码。
- en: Now that we know the fundamentals of GopherJS, let's use GopherJS with React.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GopherJS的基础知识，让我们使用GopherJS与React一起工作。
- en: GopherJS with React
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GopherJS与React
- en: Previously in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js*, we covered the powerful and popular React.js framework. Due to
    the power of GopherJS, there are now several open source projects that allow you
    to write React applications in Go. In this chapter, we'll cover one of these open
    source projects with the aid of an example, to offer us an idea about how to build
    a practical React application using Go.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml)中，我们介绍了流行的React.js框架，*React.js前端*。由于GopherJS的力量，现在有几个开源项目允许你用Go编写React应用程序。在本章中，我们将通过一个示例来介绍这些开源项目之一，以提供关于如何使用Go构建实际React应用程序的想法。
- en: The project
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: 'In this chapter, we''ll build a very simple interactive web app using React.
    The app contains an input text and a button:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用React构建一个非常简单的交互式Web应用程序。该应用程序包含一个输入文本和一个按钮：
- en: '![](img/00d4d58b-f10f-4e03-8da2-06db08a5db26.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00d4d58b-f10f-4e03-8da2-06db08a5db26.png)'
- en: 'Whenever we type a name and then hit Submit, it gets added to a list on the
    screen, with the word Hello next to it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们输入一个名字然后点击提交，它就会被添加到屏幕上的一个列表中，旁边是单词Hello：
- en: '![](img/11a98fe7-b9f0-4f1b-8d88-81ed0e6660c9.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11a98fe7-b9f0-4f1b-8d88-81ed0e6660c9.png)'
- en: The text input is interactive. So, as you type text, it will display on the
    screen in real time. This is the kind of reactivity that React is known for.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入是交互式的。因此，当你输入文本时，它将实时显示在屏幕上。这就是React所知名的这种反应性。
- en: Let's take a look at the project architecture in the next section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的项目架构。
- en: The project application's architecture
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目申请的架构
- en: 'The React application we are about to implement is simple, so we will not need
    more than one component. Our single component will include the input text, the
    Submit button, the interactive text, and the list of names. Here is our component:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将实现的React应用程序很简单，所以我们不需要超过一个组件。我们的单个组件将包括输入文本、提交按钮、交互式文本和名字列表。以下是我们的组件：
- en: '![](img/820e90a8-325d-4c39-b750-f860dfd1e5d3.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/820e90a8-325d-4c39-b750-f860dfd1e5d3.png)'
- en: In order to cover all the key React concepts in this section, our component
    will make use of React elements, state, props, and forms.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本节中涵盖所有关键React概念，我们的组件将使用React元素、状态、属性和表单。
- en: 'The form will consist of the input text and the Submit button:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该表单将包括输入文本和提交按钮：
- en: '![](img/b60bdfcc-5421-4f9b-9a34-de2240eec749.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b60bdfcc-5421-4f9b-9a34-de2240eec749.png)'
- en: 'Our React `state` object will host two values:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的React `state`对象将包含两个值：
- en: The current name being written
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前正在写入的名字
- en: 'The list of names:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字列表：
- en: '![](img/28060daf-4b2e-43b9-b777-f7e390c16613.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28060daf-4b2e-43b9-b777-f7e390c16613.png)'
- en: 'The prop value for our component will be the generic message that shows up
    next to the displayed name. In other words, our prop is the word Hello:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件的prop值将是显示的名字旁边的通用消息。换句话说，我们的prop是单词Hello：
- en: '![](img/baded1ec-7703-4562-91c0-b83211c1f730.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baded1ec-7703-4562-91c0-b83211c1f730.png)'
- en: Let's go ahead and build this React application in Go in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在下一节中构建这个 Go 中的 React 应用程序。
- en: Building the React application in Go
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中构建 React 应用程序
- en: Now it's time to start writing our React application in Go. We will make use
    of a popular package known as `myitcv.io/react`. This package offers some GopherJS
    bindings for the React framework. The package documentation can be found at [https://github.com/myitcv/x/tree/master/react](https://github.com/myitcv/x/tree/master/react).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始用 Go 编写我们的 React 应用程序了。我们将使用一个名为 `myitcv.io/react` 的流行包。这个包为 React 框架提供了一些
    GopherJS 绑定。该包的文档可以在 [https://github.com/myitcv/x/tree/master/react](https://github.com/myitcv/x/tree/master/react)
    找到。
- en: 'The first thing we need to do is retrieve the `myitcv.io/react` package, in
    order to use it in our code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取 `myitcv.io/react` 包，以便在我们的代码中使用它：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Retrieve a tool called `reactGen`, this tool facilitates building React applications
    in Go. It can be used to auto-build skeleton applications that act as building
    blocks for more complex applications:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个名为 `reactGen` 的工具，这个工具可以简化在 Go 中构建 React 应用程序。它可以用来自动构建骨架应用程序，这些应用程序可以作为更复杂应用程序的构建块：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Open a Terminal window, then navigate to the `reactGen` folder:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，然后导航到 `reactGen` 文件夹：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Type the `go install` command. This should compile and deploy the `reactGen`
    tool to the `%GOPATH%\bin` folder. Make sure that path is present in your `PATH`
    environmental variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `go install` 命令。这应该将 `reactGen` 工具编译并部署到 `%GOPATH%\bin` 文件夹。请确保该路径存在于您的 `PATH`
    环境变量中。
- en: 'Type the following command to inspect whether `reactGen` is installed yet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令来检查是否已安装 `reactGen`：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once `reactGen` is installed, we are ready to write our application. Go to
    the `9-Isomorphic-Go` folder. Inside, we''ll create a new folder called `reactproject`.
    In the Terminal, navigate to the `reactproject` folder, then type the following
    command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `reactGen`，我们就可以开始编写我们的应用程序了。前往 `9-Isomorphic-Go` 文件夹。在里面，我们将创建一个名为 `reactproject`
    的新文件夹。在终端中，导航到 `reactproject` 文件夹，然后输入以下命令：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will create a skeleton for our React application. Let''s explore the generated
    app—there are four files inside:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们的 React 应用程序创建一个骨架。让我们探索生成的应用程序——里面有四个文件：
- en: '`main.go`: The entry point for our app.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.go`：我们的应用程序的入口点。'
- en: '`index.html`: The entry HTML file for our app.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index.html`：我们的应用程序的入口 HTML 文件。'
- en: '`app.go`: The `App` component of our React application—this will be the first
    component to get rendered in our application.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.go`：我们的 React 应用程序的 `App` 组件——这将是第一个在我们的应用程序中渲染的组件。'
- en: '`gen_App_reactGen.go`: This file is auto-generated from `app.go`. For any component
    we write, some auto-generated code will get created afterward, which will contain
    all the plumbing code needed to make our component work. This code generation
    allows us to focus only on building the important pieces in our React components,
    such as props, states, and elements.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gen_App_reactGen.go`：此文件是从 `app.go` 自动生成的。对于任何我们编写的组件，之后都会生成一些自动生成的代码，这些代码将包含使我们的组件正常工作所需的所有管道代码。这种代码生成使我们能够专注于构建
    React 组件中的重要部分，如 props、states 和 elements。'
- en: 'Before we start writing our React component, let''s explore the `App` component
    that we created in the `app.go` file, with the `reactGen` tool:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写我们的 React 组件之前，让我们探索使用 `reactGen` 工具在 `app.go` 文件中创建的 `App` 组件：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code creates a Go struct called `AppDef`, which acts as a React
    component. In order for a Go `struct` type to qualify as a React component, it
    needs to satisfy three requirements:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为 `AppDef` 的 Go 结构体，它充当 React 组件。为了使 Go `struct` 类型符合 React 组件的要求，它需要满足三个条件：
- en: The Go struct name must have the `Def` suffix.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 结构体的名称必须以 `Def` 后缀结尾。
- en: The Go struct has to embed the `react.ComponentDef` type.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 结构体必须嵌入 `react.ComponentDef` 类型。
- en: The `struct` type must implement the `Render()` method, which acts as the equivalent
    of the React's `render()` method.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct` 类型必须实现 `Render()` 方法，这相当于 React 的 `render()` 方法。'
- en: 'Similar to React.js, the `Render()` method has to return React elements. The `myitcv.io/react`
    framework offers methods that correspond to React elements. From the preceding
    code, we see that `Render()` returns the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与 React.js 类似，`Render()` 方法必须返回 React 元素。`myitcv.io/react` 框架提供了与 React 元素相对应的方法。从前面的代码中，我们看到
    `Render()` 返回以下内容：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code corresponds to the following React JSX:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对应以下 React JSX：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Each one of the JSX elements corresponds to a `react.<element type>` function
    in Go. There were a total of three elements. The first is the `<div>` element,
    which hosted the other two elements. In Go, this translated to `react.Div(nil,...other_elements)`.
    The first argument is our element''s props. Since we didn''t include any props,
    the first argument ended up being `nil`. If we needed to add a React prop—let''s
    say, the `className` prop—it can simply be done like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 JSX 元素都对应于 Go 中的 `react.<element type>` 函数。总共有三个元素。第一个是 `<div>` 元素，它托管了其他两个元素。在
    Go 中，这翻译为 `react.Div(nil,...other_elements)`。第一个参数是我们的元素 props。由于我们没有包含任何 props，第一个参数最终变成了
    `nil`。如果我们需要添加一个 React prop——比如说，`className` prop——可以简单地这样做：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The second element is the `h1` element. In Go, we represented it as `react.H1(nil,react.S("Hello
    World"))`. The first argument represents props passed to the element. The `react.S("")`
    function simply represents a string.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个元素是 `h1` 元素。在 Go 中，我们将其表示为 `react.H1(nil,react.S("Hello World"))`。第一个参数表示传递给元素的
    props。`react.S("")` 函数简单地表示一个字符串。
- en: 'The third element is the `P` element. In Go, it looked like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个元素是 `P` 元素。在 Go 中，它看起来是这样的：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s see this code in action. Set the `GOOS` environmental variable
    to `linux` if you''re using Windows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这段代码的实际效果。如果你使用的是 Windows，请将 `GOOS` 环境变量设置为 `linux`：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'From our `reactproject` folder, run the following command in the Terminal:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 `reactproject` 文件夹中，在终端中运行以下命令：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will serve our React application on port `8080`. If we open a web browser
    and visit `localhost:8080/<the Go project folder from src>`, we''ll be greeted
    with this simple application:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口 `8080` 上为我们提供 React 应用程序。如果我们打开一个网页浏览器并访问 `localhost:8080/<src 中的 Go 项目文件夹>`，我们将看到这个简单应用程序：
- en: '![](img/6704b900-8cee-410a-8926-a8cd8e7894ea.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6704b900-8cee-410a-8926-a8cd8e7894ea.png)'
- en: Now, we are ready to build our custom component, which we will do in the next
    section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备构建我们的自定义组件，我们将在下一节中完成。
- en: Building a custom component
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义组件
- en: 'Under the `reactproject` folder, create a new folder called `hello_message`.
    Inside the folder, we''ll create a new file called `hello_message.go`. In the
    file, we will call the `hellomessage` package:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `reactproject` 文件夹下，创建一个名为 `hello_message` 的新文件夹。在文件夹内，我们将创建一个名为 `hello_message.go`
    的新文件。在文件中，我们将调用 `hellomessage` 包：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We then create a Go struct to represent our React component:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后创建一个 Go 结构体来表示我们的 React 组件：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, it''s time to define our props. This can simply be done by a `struct`
    type that contains our expected props. As mentioned, our prop is the message string:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候定义我们的 props 了。这可以通过包含我们期望的 props 的 `struct` 类型来完成。如前所述，我们的 prop 是消息字符串：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Defining a `state` object is very similar to props. A `struct` type needs to
    be created with the expected React `state` object fields. Our `state` object fields
    are the current name being written to the text input, as well as the list of names
    written so far:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `state` 对象与 props 非常相似。需要创建一个 `struct` 类型，其中包含预期的 React `state` 对象字段。我们的
    `state` 对象字段是当前写入文本输入框的名称，以及迄今为止写入的名称列表：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As mentioned in [Chapter 4](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml), *Frontend
    with React.js,* the React framework makes a decision to re-render your component
    whenever React detects that the `state` object has changed. Since our `state`
    object here contains a Go slice, future and current states cannot simply be compared
    using an `==` operator. In this case, it''s strongly recommended to provide React
    with a way to decide whether the React object has changed. This is done using
    the `Equals` method, which is implemented by the `state` Go struct. Here is how
    this looks:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 4 章](e875a3eb-c517-4246-8233-cc681f6c3356.xhtml) 中所述，*使用 React.js 的前端*，React
    框架会在 React 检测到 `state` 对象已更改时决定重新渲染你的组件。由于我们这里的 `state` 对象包含一个 Go 切片，未来的状态和当前状态不能简单地使用
    `==` 操作符进行比较。在这种情况下，强烈建议为 React 提供一种方式来决定 React 对象是否已更改。这是通过 `Equals` 方法实现的，该方法由
    `state` Go 结构体实现。以下是它的样子：
- en: '[PRE56]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: At this point, we need to run the `go generate` command from the Terminal to
    generate some helper code that we can use to write the rest of our component.
    After you run the `go generate` command, you will notice that a new file, called
    `gen_HelloMessage_reactGen.go`, was generated for us. Do not edit this file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要在终端中运行 `go generate` 命令来生成一些辅助代码，我们可以使用这些代码来编写组件的其余部分。运行 `go generate`
    命令后，你会注意到为我们生成了一个新文件，名为 `gen_HelloMessage_reactGen.go`。不要编辑此文件。
- en: 'The generated file will provide a new data type for you to use: `*HelloMessageElem`.
    This type represents our component''s React element.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件将为你提供一个新数据类型来使用：`*HelloMessageElem`。此类型代表我们的组件的 React 元素。
- en: 'Let''s go back to our code inside `hello_message.go`, the next step is to write
    a constructor for our new React component. The constructor will need to take props
    as an argument, and returns the React element as a result. Here is how this will
    look:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `hello_message.go` 中的代码，下一步是编写我们新 React 组件的构造函数。构造函数需要接受属性作为参数，并返回 React
    元素作为结果。以下是它的样子：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Since our code gets compiled to JavaScript through GopherJS, the `fmt.Println()`
    function will get translated to `console.log()`, as covered in the *Go bindings*
    section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码通过 GopherJS 编译成 JavaScript，`fmt.Println()` 函数将被翻译为 `console.log()`，这在
    *Go 绑定* 部分已有说明。
- en: 'Next, we need to define the `Render()` method of our component. The `Render()`
    method needs to be defined in a non-pointer type of our component Go struct. Here
    is an empty `Render()` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们组件的 `Render()` 方法。`Render()` 方法需要在我们的组件 Go 结构的非指针类型中定义。以下是一个空的 `Render()`
    方法：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We now have to fill up the `Render()` method with the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须用以下内容填充 `Render()` 方法：
- en: A form that includes an input text box, and a Submit button
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个输入文本框和一个提交按钮的表单
- en: A string to host the name currently being written
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串用于存储当前正在写入的名字
- en: A list of strings to represent a history of the names entered
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列字符串，代表输入的名字的历史记录
- en: 'As a refresher, have a look at the following diagram:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，请查看以下图表：
- en: '![](img/b4b82c02-079f-416a-9664-d2aac373cc8f.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4b82c02-079f-416a-9664-d2aac373cc8f.png)'
- en: The red rectangles represent our React states, the green rectangles represent
    our props, and the blue rectangle represents our entire React component.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 红色矩形代表我们的 React 状态，绿色矩形代表我们的属性，蓝色矩形代表我们的整个 React 组件。
- en: 'Going back to our `Render()` method, first, we need to write the text input
    element. It''s an HTML form input element of the `"text"` type. Here is how this
    looks:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `Render()` 方法，首先，我们需要编写文本输入元素。它是一个 `"text"` 类型的 HTML 表单输入元素。以下是它的样子：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code represents a React `input` element, courtesy of the `myitcv.io/react`
    package.  The first argument is the props for the input element; the second argument
    is `nil`, because we don''t need any children for this element. The input props
    are the same as the ones we used in the JSX format. There are two notable props
    that we used here:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码代表一个 React `input` 元素，由 `myitcv.io/react` 包提供。第一个参数是输入元素的属性；第二个参数是 `nil`，因为我们不需要为这个元素提供任何子元素。输入属性与我们在
    JSX 格式中使用的属性相同。这里有两个值得注意的属性，我们在这里使用了：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `Value` prop is the current value of the input text. By assigning the `State`
    object of the `CurrName` field to the input text `Value` field, we've guaranteed
    that the input text will change based on the name you enter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value` 属性是输入文本的当前值。通过将 `CurrName` 字段的 `State` 对象分配给输入文本的 `Value` 字段，我们确保输入文本将根据你输入的名字而改变。'
- en: 'The `OnChange` prop represents the action taken whenever a change happens to
    our input text. The prop must point to a type that implements the `OnChange(event)`
    method. Since we assign `r` to it, we must implement `OnChange`. Here is how this
    will look:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnChange` 属性代表每当我们的输入文本发生变化时采取的动作。该属性必须指向实现 `OnChange(event)` 方法的类型。由于我们将其分配给
    `r`，我们必须实现 `OnChange`。以下是它的样子：'
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding code is self-explanatory:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是自解释的：
- en: The Go React framework provides a type called `*react.SyntheticEvent`, which
    represents the event getting passed to the `OnChange` method.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go React 框架提供了一个名为 `*react.SyntheticEvent` 的类型，它代表传递给 `OnChange` 方法的事件。
- en: We retrieve the value of the text being written to the input text.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检索正在写入输入文本的值。
- en: We retrieve our current React state. This is done using the `State()` method.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检索当前的 React 状态。这是通过使用 `State()` 方法完成的。
- en: We change our React state to represent the new name. This is done using the
    `SetState()` method.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `SetState()` 方法更改我们的 React 状态以表示新的名字。
- en: 'Now, let''s go back to our `Render()` method. The next step is to write the
    Submit button component. It is also an HTML form input element, but it''s of the `"Submit"` type.
    An HTML form input element of the `"Submit"` type is a button. Whenever the Submit
    button gets pressed, the form will get submitted:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的 `Render()` 方法。下一步是编写提交按钮组件。它也是一个 HTML 表单输入元素，但它是 `"Submit"` 类型。一个
    `"Submit"` 类型的 HTML 表单输入元素是一个按钮。每当提交按钮被按下时，表单将被提交：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Next, we need to write our React form. The form element will act as a parent
    element for both the text and the button elements. Our form element will also
    host a `"Name:"` string.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写我们的React表单。表单元素将作为文本和按钮元素的父元素。我们的表单元素还将包含一个`"Name:"`字符串。
- en: As mentioned earlier, whenever the Submit button gets pressed, the form will
    be submitted. Typically, when an HTML form gets submitted, its input data is sent
    to the server, where the form's input data gets processed. In our case, we want
    to capture the submission event, and then instead of the form submission's default
    behavior, we want to change our `state` object to add the new input name to our
    `state.Names` list.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每当提交按钮被按下时，表单将被提交。通常，当HTML表单被提交时，其输入数据会被发送到服务器，在那里表单的输入数据会被处理。在我们的情况下，我们想要捕获提交事件，然后而不是表单提交的默认行为，我们想要改变我们的`state`对象，将新的输入名称添加到我们的`state.Names`列表中。
- en: 'Before we delve more into how to define the actions taken on form submission,
    let''s go back to the `render` method, and define our form:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何定义表单提交时采取的操作之前，让我们回到`render`方法，并定义我们的表单：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Notice that we defined an `OnSubmit` React form prop. This is how we define
    the actions taken on form submission in our Go code. The data type we pass to
    the `OnSubmit` prop must implement a method with the `OnSubmit(*react.SyntheticEvent)` signature. Let''s
    implement this method in our code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义了一个`OnSubmit` React表单属性。这是我们如何在Go代码中定义表单提交时采取的操作。传递给`OnSubmit`属性的我们必须实现一个具有`OnSubmit(*react.SyntheticEvent)`签名的`OnSubmit`方法。让我们在我们的代码中实现这个方法：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Perfect—now we just need to finish the `Render()` method. Here are the remaining
    tasks for our custom form''s `Render()` method:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 完美——现在我们只需要完成`Render()`方法。以下是我们的自定义表单的`Render()`方法剩余任务：
- en: Get the list of saved names in our `state` object.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的`state`对象中获取已保存的名称列表。
- en: For each saved name in the list, convert it to an `Li` element. This is a form
    list element.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表中每个已保存的名称，将其转换为`Li`元素。这是一个表单列表元素。
- en: 'Return a `Div` object, which contains the following:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个包含以下内容的`Div`对象：
- en: The defined form
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义好的表单
- en: A  string with the prop message, combined with the current name saved in the
    `state` object
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含属性消息的字符串，与`state`对象中当前保存的名称结合
- en: The list of existing names
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有名称列表
- en: 'Here is how the rest of the code will look:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是其余代码的样式：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And here is the entire `Render()` method:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是整个`Render()`方法：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now, we can run `go generate`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`go generate`。
- en: 'Our component is done; however, there is still some work left. We need to call
    our newly-created component from the `App` component, located in the `app.go`
    file. This will be done using the `HelloMessage(p HelloMessageProps) *HelloMessageElem` constructor,
    which we created before. The constructor takes the props as an argument and returns
    our custom component React element. The code we need to modify is under the `Render()`
    method of our `App` component. The prop object contains a field called `Message`.
    The value of the message we would like to pass is simply `"Hello"`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组件已完成；然而，还有一些工作要做。我们需要从位于`app.go`文件中的`App`组件调用我们新创建的组件。这将通过我们之前创建的`HelloMessage(p
    HelloMessageProps) *HelloMessageElem`构造函数来完成。构造函数接受props作为参数，并返回我们的自定义React元素。我们需要修改的代码位于我们的`App`组件的`Render()`方法下。属性对象中有一个名为`Message`的字段。我们想要传递的消息值仅仅是`"Hello"`：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: That's it for our code. If you run the `gopherjs serve` command from your Terminal
    at the `reactproject` folder, the project will be accessible in the browser at
    the `localhost:8080/<your project folder from src>` address.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的代码。如果你从`reactproject`文件夹的终端运行`gopherjs serve`命令，项目将在浏览器中的`localhost:8080/<your
    project folder from src>`地址下可访问。
- en: When you are ready to transpile your React project to JavaScript, simply run
    the `gopherjs build` command from the `reactproject` folder. This will generate
    a `reactproject.js` file that can be used from the `index.html` file in your project
    folder. If you look at the `index.html` file in your project folder, you will
    find that it references a script called `reactproject.js`. If you open `index.html`
    from a browser after performing the build step, you will find your application
    working as expected.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好将你的React项目转换为JavaScript时，只需从`reactproject`文件夹中运行`gopherjs build`命令。这将生成一个`reactproject.js`文件，该文件可以从项目文件夹中的`index.html`文件中使用。如果你查看项目文件夹中的`index.html`文件，你会找到一个名为`reactproject.js`的脚本。如果你在执行构建步骤后从浏览器打开`index.html`，你会发现你的应用程序按预期工作。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on building isomorphic applications using Go. We
    covered some key topics regarding converting Go code into JavaScript code. We
    dove into Go bindings in GopherJS, and considered how it can empower us to bridge
    the two languages.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于使用Go构建同构应用。我们涵盖了将Go代码转换为JavaScript代码的一些关键主题。我们深入探讨了GopherJS中的Go绑定，并考虑了它如何帮助我们连接这两种语言。
- en: We also made use of the GopherJS framework to build Go applications that integrate
    with JavaScript, whether at the frontend or on the server side. We explored important
    topics, such as concurrency and methods.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用GopherJS框架构建了与JavaScript集成的Go应用程序，无论是在前端还是服务器端。我们探讨了重要的话题，例如并发性和方法。
- en: We also covered the Go React framework, and went through the process of building
    a simple React application in Go.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了Go React框架，并介绍了在Go中构建简单React应用程序的过程。
- en: In the next chapter, we'll cover topics such as cloud-native applications and
    the React Native framework so that you can further hone your skills.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖诸如云原生应用和React Native框架等主题，以便您可以进一步磨练您的技能。
- en: Questions
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does transpling mean?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是transpling？
- en: What is GopherJS?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是GopherJS？
- en: What is the `*js.Object` type?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*js.Object`类型是什么？'
- en: What is the `js.Global` variable?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`js.Global`变量是什么？'
- en: What is the `js.Module` variable?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`js.Module`变量是什么？'
- en: What does the `js.MakeWrapper()` function do?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`js.MakeWrapper()`函数的作用是什么？'
- en: What does the `js` Go struct tag do?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`js` Go结构标签的作用是什么？'
- en: What are the main steps to build a React component in Go?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建React组件在Go中的主要步骤是什么？
- en: Further reading
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, check out the following links:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请查看以下链接：
- en: '**GopherJS**: [https://github.com/gopherjs/gopherjs](https://github.com/gopherjs/gopherjs)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GopherJS**: [https://github.com/gopherjs/gopherjs](https://github.com/gopherjs/gopherjs)'
- en: '**GopherJS with React**: [https://github.com/myitcv/x/tree/master/react/_doc](https://github.com/myitcv/x/tree/master/react/_doc)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GopherJS与React**: [https://github.com/myitcv/x/tree/master/react/_doc](https://github.com/myitcv/x/tree/master/react/_doc)'
- en: '**Creating a GopherJS React app**: [https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md](https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建GopherJS React应用**: [https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md](https://github.com/myitcv/x/blob/master/react/_doc/creating_app.md)'
- en: '**GopherJS React examples**: [https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/](https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GopherJS React示例**: [https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/](https://blog.myitcv.io/gopherjs_examples_sites/examplesshowcase/)'
