- en: Walk - Building Graphical Windows Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Walk - 构建图形窗口应用程序
- en: Walk is a Windows GUI toolkit for the Go programming language—its purpose is
    to enable us to build native desktop GUI applications for Windows using Go. It's
    built on top of the win package by the same authors, which is a direct Go binding
    of the Windows API. The main API is designed to make working with the **Windows
    API** (**WinAPI**) both easier and more in keeping with Go design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Walk是Go编程语言的Windows GUI工具包——它的目的是使我们能够使用Go构建Windows的原生桌面GUI应用程序。它是基于同一作者编写的win包构建的，该包是Windows
    API的直接Go绑定。主要的API设计旨在使与**Windows API**（**WinAPI**）的工作既容易又符合Go设计原则。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Background and aims
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景 和 目标
- en: Get started with Walk
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Walk
- en: Benefits of a declarative API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式API的好处
- en: Building a user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Walk in a cross-platform application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在跨平台应用程序中使用Walk
- en: Let's get started exploring the background of the Walk project and its solution
    for Go apps developed for the Windows platform.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索Walk项目及其为Windows平台开发的Go应用程序的解决方案的背景。
- en: Background and aims
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景 和 目标
- en: The Walk project is one of the oldest GUI toolkits for Go, having been started
    in September of 2010\. The name stands for **Windows Application Library Kit**,
    which reflects its purpose to support building GUI apps for the Microsoft platform.
    Its project home is on GitHub, where you can check out the latest developments
    and discussions: [https://github.com/lxn/walk](https://github.com/lxn/walk).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Walk项目是Go最古老的GUI工具包之一，始于2010年9月。这个名字代表**Windows应用程序库套件**，反映了其支持为Microsoft平台构建GUI应用程序的目的。其项目主页在GitHub上，您可以查看最新的发展和讨论：[https://github.com/lxn/walk](https://github.com/lxn/walk)。
- en: The project API was inspired by the Qt Widgets module for the Qt framework (which
    will be covered in [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt
    - Multiple Platforms with QT*). Qt Widgets is a selection of standard user interface
    features for creating graphical applications with a familiar look and feel. By
    matching the Qt design closely, it's possible to use some of the Qt tools, such
    as UI designer, when preparing a Walk-based user interface for your application.
    Walk currently supports the most commonly-utilized widgets, which means it may
    not be suitable for every application. At the time of writing, the **Multi Document Interface**
    (**MDI**) and dockable tool windows described in [Chapter 2](d5375343-5332-4374-9297-dfbb256a5d91.xhtml),
    *Graphical User Interface Challenges* are not supported—though the author notes
    that it is an open source project and contributions are welcome.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 项目API受到了Qt框架的Qt Widgets模块的启发（将在[第7章](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)，*Go-Qt
    - 多平台与QT*中介绍）。Qt Widgets是一组标准用户界面特性，用于创建具有熟悉外观和感觉的图形应用程序。通过紧密匹配Qt设计，可以在准备基于Walk的用户界面时使用一些Qt工具，例如UI设计器。Walk目前支持最常用的控件，这意味着它可能不适合每个应用程序。在撰写本文时，[第2章](d5375343-5332-4374-9297-dfbb256a5d91.xhtml)，*图形用户界面挑战*中描述的**多文档界面**（**MDI**）和可停靠的工具窗口不支持——尽管作者指出这是一个开源项目，欢迎贡献。
- en: Walk offers a great API for building applications for the Windows desktop. Although
    it doesn't provide the choice of themes or presentation styles that some toolkits
    offer, applications that use it look exactly like other Windows apps. One of the
    project aims is for it to work without any additional dependencies or complicated
    setup, which means that it's a great place to get started—as you'll see in the
    next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Walk为构建Windows桌面应用程序提供了一个出色的API。尽管它不提供某些工具包提供的主题或呈现样式选择，但使用它的应用程序看起来与其它Windows应用程序完全一样。项目的一个目标是在没有任何额外依赖或复杂的设置的情况下工作，这意味着它是一个很好的起点——您将在下一节中看到。
- en: Get started with walk
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Walk
- en: Now that we've learned a bit about the Walk library, let's see it in action.
    The steps that follow aim to create a trivial application using the Walk API,
    which will verify everything is working. If you have any problems with these steps,
    consider looking at the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation
    Details,* and work through the *Microsoft Windows* section within *Installing
    Go*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Walk库有了一些了解，让我们看看它的实际应用。以下步骤旨在使用Walk API创建一个简单的应用程序，以验证一切是否正常工作。如果您在这些步骤中遇到任何问题，请考虑查看[附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml)，*安装细节*，并在*安装Go*中的*Microsoft
    Windows*部分进行操作。
- en: Setup
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: Before we can start writing a GUI with Walk, we need to install the library—this
    means that Go will be able to compile the code we write, and also that any development
    environments installed will be able to offer suggestions when writing the code.
    Simply execute `go get github.com/lxn/walk` from the Command Prompt. This command
    will download and install the Walk library to `%GOPATH%/src` so it can be used
    in your applications. If you have not set the `GOPATH` environment variable manually,
    don't worry, as the Go installer will have set up a default for you (normally `%HOMEDRIVE%%HOMEPATH%/go`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Walk 编写 GUI 之前，我们需要安装库——这意味着 Go 将能够编译我们编写的代码，并且任何已安装的开发环境在编写代码时都将能够提供建议。只需在命令提示符中执行
    `go get github.com/lxn/walk` 即可。此命令将从 `%GOPATH%/src` 下载并安装 Walk 库，以便在应用程序中使用。如果你没有手动设置
    `GOPATH` 环境变量，不要担心，因为 Go 安装程序已经为你设置了一个默认值（通常是 `%HOMEDRIVE%%HOMEPATH%/go`）。
- en: Code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'Now let''s write some code! First of all, create a new directory to put this
    code into—due to the way that Walk binaries are created (see the following code),
    we need to build at a directory level, rather with than single files, so it''s
    good to have a clean workspace. Copy the following code into a file named `hello.go`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一些代码！首先，创建一个新的目录来存放这段代码——由于 Walk 二进制文件的创建方式（参见以下代码），我们需要在目录级别进行构建，而不是单个文件，因此拥有一个干净的工作空间是很好的。将以下代码复制到一个名为
    `hello.go` 的文件中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, you can see two different imports for Walk—we will talk
    about that more later. Inside the `main()` function, we set up a simple window
    with two items in a `VBox` layout: one `Label`, and one `PushButton` that will
    exit the app when clicked. Next, we need to create an additional file, named `hello.exe.manifest`,
    with the following contents (this manifest file is needed in the build process):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到两个不同的 Walk 导入——我们稍后会详细讨论这个问题。在 `main()` 函数中，我们设置了一个简单的窗口，其中包含一个
    `VBox` 布局中的两个项目：一个 `Label` 和一个 `PushButton`，当点击时会退出应用程序。接下来，我们需要创建一个额外的文件，名为 `hello.exe.manifest`，内容如下（此清单文件在构建过程中是必需的）：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This manifest file is required to tell Windows runtime that we are using the
    Common Controls framework version 6.0.0.0 (or newer), which is required by the
    Walk APIs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单文件是必需的，用于告知 Windows 运行时我们正在使用 Common Controls 框架版本 6.0.0.0（或更高版本），这是 Walk
    API 所必需的。
- en: Build
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'Once you have saved the two files, you can build the application. Due to the
    nature of a Walk application (specifically, the Windows APIs that are described
    in the manifest file), there is an additional step to prepare the directory. The
    walk applications require a manifest file that will be embedded in the executable
    we are building. To do this, we need to download the rsrc tool from `github.com/akavel/rsrc`, which
    will embed the required metadata. We then run the `rsrc.exe` command with the
    `-manifest` parameter to generate the embedded file, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这两个文件后，你可以构建应用程序。由于 Walk 应用程序的性质（特别是清单文件中描述的 Windows API），需要额外一步来准备目录。Walk
    应用程序需要一个将嵌入我们构建的可执行文件的清单文件。为此，我们需要从 `github.com/akavel/rsrc` 下载 rsrc 工具，该工具将嵌入所需的元数据。然后，我们使用
    `-manifest` 参数运行 `rsrc.exe` 命令以生成嵌入文件，如下所示：
- en: '![](img/806392a6-6529-45bb-8b61-9a363c7024c3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/806392a6-6529-45bb-8b61-9a363c7024c3.png)'
- en: The rsrc tool generates the .syso file to embed
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: rsrc 工具生成 .syso 文件以嵌入
- en: 'That step will create a `.syso` file, which will automatically get included
    in the next step. Now we can actually run the go build. On the command line, we
    add an extra `ldflag` parameter, set to `"-H windowsgui"`, which tells the compiler
    to output a GUI app, rather than a command-line app. While it would work OK without
    this parameter, your application would show a command-line window behind it when
    launched from a regular icon-click:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该步骤将创建一个 `.syso` 文件，该文件将自动包含在下一步中。现在我们可以实际运行 go build 命令。在命令行中，我们添加一个额外的 `ldflag`
    参数，设置为 `"-H windowsgui"`，这告诉编译器输出一个 GUI 应用程序，而不是命令行应用程序。虽然没有这个参数也可以正常工作，但当你从常规图标点击启动应用程序时，你的应用程序后面会显示一个命令行窗口：
- en: '![](img/9f8d266b-e4cc-467c-b5c5-015777942b80.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9f8d266b-e4cc-467c-b5c5-015777942b80.png)'
- en: Running go build again will embed the `.syso` file
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 go build 将嵌入 `.syso` 文件
- en: Run
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'The hello world app that was built in the last step can be executed in two
    ways: either by running it from the command line, or by clicking the icon from
    the file manager:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一步构建的 hello world 应用程序可以通过两种方式执行：要么从命令行运行，要么通过文件管理器中的图标点击：
- en: '![](img/3f5b6e49-6443-4f2e-bf62-e9f5016fed5c.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f5b6e49-6443-4f2e-bf62-e9f5016fed5c.png)'
- en: The hello app icon
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: hello 应用程序图标
- en: 'You should see an icon like the preceding one in your file manager in the current
    directory. Alternatively, return to the command prompt and simply enter the `hello.exe` command
    from the project directory. Using either method, you should now see this app running
    on your desktop (you may need to hunt as it''s a very small window):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录下，你应该在你的文件管理器中看到一个类似于前面的图标。或者，返回到命令提示符，并简单地从项目目录中输入`hello.exe`命令。使用任何一种方法，你现在都应该能在你的桌面上看到这个应用程序正在运行（你可能需要寻找，因为它是一个非常小的窗口）：
- en: '![](img/88337cd0-9fa8-46a9-8086-574e4c6f633f.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88337cd0-9fa8-46a9-8086-574e4c6f633f.png)'
- en: A Walk-based Hello World
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Walk的Hello World
- en: Benefits of a declarative API
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式API的好处
- en: 'As illustrated in the code example, the Walk API is split in to two notable
    packages: `github.com/lxn/walk` and `github.com/lxn/walk/declarative`. The declarative
    API is the preferred approach for developing application GUIs using Walk, as it
    offers a better abstraction to work with and is more idiomatic. The implementation
    of the declarative API also provides various standard metrics and default values
    that help to create a standard user interface with minimal code. The package is
    typically imported using the `.` prefix, so that GUI code can avoid repeatedly
    using the `declarative.` prefix.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码示例所示，Walk API分为两个显著的包：`github.com/lxn/walk`和`github.com/lxn/walk/declarative`。声明式API是使用Walk开发应用程序GUI的首选方法，因为它提供了更好的抽象层，并且更符合习惯用法。声明式API的实现还提供了各种标准指标和默认值，有助于用最少的代码创建标准用户界面。该包通常使用`.`前缀导入，这样GUI代码就可以避免重复使用`declarative.`前缀。
- en: Compared with the native API
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与原生API相比
- en: 'Using the native API, (Go bindings of the native winAPI) is possible, but in
    most cases this is more verbose, as you are working directly with a low-level
    API. Coding in this way can''t make use of standard metrics or configurations
    that are handled by the higher-level declarative API, designed to better suit
    a modern programming language. To illustrate the difference, here is what the
    preceding example would look like if we only used the native API:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生API（原生winAPI的Go绑定）是可能的，但在大多数情况下，这会更冗长，因为你是在直接与低级API工作。以这种方式编码无法利用由高级声明式API处理的标准化指标或配置，该API旨在更好地适应现代编程语言。为了说明这种差异，以下是在我们仅使用原生API时前面示例的样子：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code can be compiled in the same way as the previous example, and when
    run, it will look exactly the same. Clearly, this is a lot more code to obtain
    the same result and it is a lot harder to read with no particular gain. The error
    handling that clutters this alternative example is handled implicitly when using
    the declarative API. Putting aside the differences in the Go syntax, it should
    be clear that the native API calls used in this example are directly manipulating
    widgets from the WinAPI. In fact, each of the objects created (through `NewLabel()`,
    `NewPushButton()`, and `NewMainWindowWithName()`) is a lightweight wrapper for
    Go the bindings of the WinAPI (provided by `github.com/lxn/win`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以像前面的示例一样编译，运行时看起来完全一样。显然，为了获得相同的结果，需要更多的代码，而且阅读起来也更困难，而且没有特别的收益。在使用声明式API时，这种替代示例中的错误处理是隐式处理的。抛开Go语法的差异，应该很明显，这个例子中使用的原生API调用是直接操作WinAPI中的小部件。实际上，通过`NewLabel()`、`NewPushButton()`和`NewMainWindowWithName()`创建的每个对象都是WinAPI（由`github.com/lxn/win`提供）的Go绑定的轻量级包装器。
- en: There are many times where usage of this native API can be useful; most commonly,
    when you need control of fine details or are dealing with changes to existing
    widgets, for example within event-handling code. The declarative API is designed
    for easy definition of an application user interface, but it isn't normally enough
    to manage the workflow of a complex GUI. Therefore, it's common to use both of
    these APIs together—using the power of each at the right time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多情况下使用这种原生API是有用的；最常见的是，当你需要控制细节或处理现有小部件的更改时，例如在事件处理代码中。声明式API旨在轻松定义应用程序用户界面，但它通常不足以管理复杂GUI的工作流程。因此，通常会将这两个API一起使用——在适当的时候使用每个API的力量。
- en: Using both APIs for flexibility
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用两种API以获得灵活性
- en: 'It''s important to understand the difference between the declarative and native
    APIs, as any application will probably require the use of both. Using the declarative
    syntax is great for a concise description of the user interface, but runtime manipulation
    of the graphical elements will require a reference to one of the native widgets
    that this code wraps. To make this connection, each of the declarative types has
    an `AssignTo` field, which is typically passed a pointer to a `var`, which itself
    is a pointer to an object that represents a native type. This means that, during
    the user-interface-construction phase, the declarative API parser can create native
    widgets and set the pointer within your code for later use. Let''s look at this
    feature in action:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 理解声明式API和本地API之间的区别非常重要，因为任何应用程序都可能需要同时使用这两种API。使用声明式语法非常适合简洁地描述用户界面，但要对图形元素进行运行时操作，则需要引用代码包装的本地小部件之一。为了建立这种联系，每个声明式类型都有一个`AssignTo`字段，它通常传递一个指向`var`的指针，而`var`本身是一个指向表示本地类型的对象的指针。这意味着在用户界面构建阶段，声明式API解析器可以创建本地小部件，并在您的代码中设置指针以供以后使用。让我们看看这个功能在实际中的应用：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code can be compiled exactly as the previous *hello world* examples
    (don''t forget to include and process a manifest if you have created a new project
    for this sample). When running this example, you should see the following interface
    with an additional text input field. When you type into the input box, the welcome
    message will change, for example `John Doe` was entered for this screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以像之前的*hello world*示例一样编译（如果您为这个示例创建了一个新项目，别忘了包含和处理清单）。当运行此示例时，您应该看到以下界面，并额外有一个文本输入字段。当您在输入框中键入时，欢迎信息将改变，例如，在这个截图中输入了`John
    Doe`：
- en: '![](img/316b3d6d-9e48-4ad9-88c5-7a9f81bbe9cf.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/316b3d6d-9e48-4ad9-88c5-7a9f81bbe9cf.png)'
- en: The hello world with name entry
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 带有姓名输入的hello world
- en: You will notice that the `message` and `userName` variables are not initialized
    directly by the application code, but by the time the function assigned to `OnTextChanged` is
    called, they hold valid references to instantiated widgets. Using this approach,
    we can get the type of access that the native API wrappers provide while also
    writing an easy-to-read UI definition provided by the declarative API.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`message`和`userName`变量不是由应用程序代码直接初始化的，而是在分配给`OnTextChanged`函数的函数被调用时，它们持有对已实例化小部件的有效引用。使用这种方法，我们可以在使用声明式API提供的易于阅读的UI定义的同时，获得本地API包装器提供的访问类型。
- en: Building a user interface
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Armed with the knowledge of how the Walk API is designed and utilized, let's
    move on to a real-world example. In this book, we will be building the same user
    interface for each toolkit explored (in Chapters [4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    [5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml), [6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml),
    [7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), [8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml),
    [9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml), and [10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)),
    which will be a simple email application named GoMail. Due to the close relationship
    between Walk and Qt widgets, we can quickly get started designing the user interface
    using the UI Builder included in Qt Creator (documentation is available at [http://doc.qt.io/qtcreator/creator-using-qt-designer.html](http://doc.qt.io/qtcreator/creator-using-qt-designer.html)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Walk API的设计和利用方法之后，让我们继续探讨一个现实世界的例子。在这本书中，我们将为每个探索的工具包（在第[4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)、[5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)、[6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml)、[7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)、[8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)、[9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml)、[10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)章）构建相同的用户界面，这将是一个名为GoMail的简单电子邮件应用程序。由于Walk和Qt小部件之间的紧密关系，我们可以快速开始使用Qt
    Creator中包含的UI Builder设计用户界面（文档可在[http://doc.qt.io/qtcreator/creator-using-qt-designer.html](http://doc.qt.io/qtcreator/creator-using-qt-designer.html)找到）。
- en: 'The basic application will be formed of two windows: the main email browser
    and a secondary window for composing new emails. The main window will contain
    a list or tree view that shows the emails we have received, a larger panel to
    display the content of the currently-selected email, and a menu and toolbar for
    accessing the various features of our email application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 基本应用程序将由两个窗口组成：主电子邮件浏览器和一个用于编写新电子邮件的辅助窗口。主窗口将包含一个列表或树视图，显示我们收到的电子邮件，一个较大的面板用于显示当前选定的电子邮件内容，以及一个菜单和工具栏，用于访问电子邮件应用程序的各种功能：
- en: '![](img/4a56d7ac-9caa-43f3-a214-08c19f1ffa2b.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a56d7ac-9caa-43f3-a214-08c19f1ffa2b.png)'
- en: The main email window within Qt Designer
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 中的主要电子邮件窗口
- en: 'To compose new emails, we will show a secondary window that will ask for the
    various details for the email being sent. Opening a new window will allow the
    user to continue reading emails while they compose new emails to be sent. The
    compose window will also have buttons to send or discard the email being written:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要撰写新电子邮件，我们将显示一个次要窗口，该窗口将要求输入发送电子邮件的各种详细信息。打开新窗口将允许用户在撰写新要发送的电子邮件的同时继续阅读电子邮件。撰写窗口还将有发送或丢弃正在编写的电子邮件的按钮：
- en: '![](img/6d06edc7-b37e-4aa0-91b2-1d56d4b81f16.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d06edc7-b37e-4aa0-91b2-1d56d4b81f16.png)'
- en: The additional compose window being designed
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正在设计的附加撰写窗口
- en: Style
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: Applications built using Walk are composed of native Windows components, and,
    as such, the style is set by the implementation provided by Microsoft (this is
    provided by Common Controls, part of `ComCtl32.dll`). The version required by
    Walk (version 6.0) adds support for visual styles; this is the system that provides
    the ability for applications to use the correct visual style for the version of
    the Windows desktop that is currently running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Walk 构建的应用程序由原生 Windows 组件组成，因此样式由微软提供的实现设置（这是由 Common Controls 部分提供的 `ComCtl32.dll`）。Walk
    所需的版本（版本 6.0）增加了对视觉样式的支持；这是提供应用程序使用当前运行的 Windows 桌面版本的正确视觉样式的系统。
- en: 'This functionality is available as far back as Windows XP, but comes as standard
    from Vista onward:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能从 Windows XP 开始可用，但从 Vista 开始成为标准功能：
- en: '![](img/314919e2-6f34-4990-8ed3-843a13378f2b.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/314919e2-6f34-4990-8ed3-843a13378f2b.png)'
- en: Windows 7 default theme (Aero –used with permission from Microsoft)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 7 默认主题（Aero – 经微软许可使用）
- en: '![](img/92e81544-3c7f-40bd-81ad-145cd166d9bc.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92e81544-3c7f-40bd-81ad-145cd166d9bc.png)'
- en: Windows 8 default theme (called Windows used with permission from Microsoft)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8 默认主题（称为 Windows，经微软许可使用）
- en: The preceding images show how a simple application will adapt to the theme on
    different versions of Windows. These illustrations are using the default theme,
    but the user may apply additional customizations on their desktop, which will
    also apply to any applications built with Walk.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图片展示了简单应用程序如何适应不同版本的 Windows 主题。这些插图使用的是默认主题，但用户可以在他们的桌面上应用额外的自定义设置，这些设置也将适用于使用
    Walk 构建的应用程序。
- en: Layout
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'Walk layouts (like those Qt Widget layouts they were inspired by) are based
    on a limited number of grid-based variants. The list of implemented layouts includes
    the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Walk 布局（如它们所受启发的 Qt Widget 布局）基于有限的基于网格的变体。已实现的布局列表包括以下内容：
- en: '`GridLayout`: Items are laid out in a regular grid'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridLayout`: 元素以常规网格布局'
- en: '`VBoxLayout`: Items are placed in a single column'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VBoxLayout`: 元素被放置在单列中'
- en: '`HBoxLayout`: Items are aligned in a single row'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HBoxLayout`: 元素在一行中对齐'
- en: If you have explored the Qt UI Builder or are familiar with Qt, you may be expecting
    a fourth layout, `FormLayout`, which is not currently present in Walk. This can
    be simulated, however, using a two-column `GridLayout` and applying alignment
    properties as required.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经探索了 Qt UI Builder 或熟悉 Qt，你可能期望有一个第四个布局 `FormLayout`，但目前 Walk 中没有这个布局。然而，可以通过使用两列
    `GridLayout` 并应用所需的对齐属性来模拟它。
- en: 'In addition to the standard layouts, there are various widgets (some of which
    are invisible in the final interface) that help group UI elements and provide
    a more satisfying layout. The most commonly used of these are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准布局外，还有各种控件（其中一些在最终界面中不可见），有助于分组 UI 元素并提供更满意的布局。以下是最常用的这些控件：
- en: '`Splitter`: Places a draggable split bar between two child widgets'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Splitter`: 在两个子控件之间放置一个可拖动的分隔条'
- en: '`Spacer`: Used to create visual padding so items can shrink instead of filling
    space'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spacer`: 用于创建视觉填充，以便项目可以收缩而不是填充空间'
- en: '`Separator`: Provides a visual separation between widgets, such as in a toolbar
    or menu'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分隔符`: 在工具栏或菜单等界面元素之间提供视觉分隔'
- en: '`ScrollView`: A standard widget for providing scrollable content'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`: 提供可滚动内容的标准控件'
- en: '`GroupBox`: A visual widget container with a border and optional title'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupBox`: 带有边框和可选标题的视觉控件容器'
- en: '`Composite`: A widget container used to logically group items'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Composite`: 用于逻辑分组项的控件容器'
- en: 'Let''s get started implementing our email app user interface by creating some
    Go code using the declarative API. We start with a `MainWindow` that has a suitable
    `MinSize` set and an `HSplitter` that will hold our content. `TreeView` is used
    for listing emails on the left of the splitter (as the first item in the `Children`
    list), and on the right (item two in the list) is a `Composite` set to use a `Grid` layout—the
    closest we have to the form layout designed. Within the group, we add many instances
    of the child `Label` where we will show email details (that will be updated in
    *Communicating with the GUI* section):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始通过创建一些使用声明式API的Go代码来实现我们的电子邮件应用用户界面。我们从一个设置了合适的`MinSize`的`MainWindow`开始，并添加一个`HSplitter`来存放我们的内容。`TreeView`用于在分割器的左侧列出电子邮件（作为`Children`列表中的第一个项目），在右侧（列表中的第二个项目）是一个设置为使用`Grid`布局的`Composite`——这是最接近我们设计的表单布局。在组内，我们添加了许多子`Label`实例，我们将在这里显示电子邮件详情（将在“与GUI通信”部分更新）：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code can be run by replacing the `MainWindow` in the previous
    *hello world* example, recompiling, and then running the example again. If you
    set up a new project, remember to include the manifest file and run `rsrc` again!
    When run, it should look like the following screenshot, taken on Windows 10:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以通过替换上一个“hello world”示例中的`MainWindow`，重新编译，然后再次运行来执行。如果你设置了一个新项目，请记住包括清单文件，并再次运行`rsrc`！运行时，它应该看起来像以下截图，在Windows
    10上拍摄：
- en: '![](img/1d169ecc-273f-4863-9dc5-a58073df514c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d169ecc-273f-4863-9dc5-a58073df514c.png)'
- en: The basic email interface using Walk's declarative API
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Walk的声明式API的基本电子邮件界面
- en: 'Next, we will make a `Dialog` with a similar layout that replaces the instances
    of `Label` with `LineEdit` or `TextEdit` for entering details of a new email.
    Last, we add another `Composite` with an `HBox` layout that contains the instances
    of `PushButton` for `Cancel` and `Send`, along with an `HSpacer` to complete the
    layout:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个具有类似布局的`Dialog`，用`LineEdit`或`TextEdit`替换`Label`实例，以输入新电子邮件的详细信息。最后，我们添加另一个具有`HBox`布局的`Composite`，其中包含用于`Cancel`和`Send`的`PushButton`实例，以及一个`HSpacer`来完成布局：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you want to test this code, the easiest approach is to replace `Dialog` with
    `MainWindow` and run it like the main layout (don't forget to change it back before
    moving on).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试这段代码，最简单的方法是将`Dialog`替换为`MainWindow`，然后像主布局一样运行它（别忘了在继续之前将其改回）。
- en: 'Once we have some event-handling, this will open like a dialog box, which is
    why it''s not a `MainWindow` in the preceding listing. Running the code should
    produce the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了事件处理，它就会像对话框一样打开，这就是为什么在先前的列表中它不是一个`MainWindow`。运行代码应该产生以下截图：
- en: '![](img/113d56b1-49c2-425f-9af6-9cf2a935bc33.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/113d56b1-49c2-425f-9af6-9cf2a935bc33.png)'
- en: The compose email view using Walk's declarative API
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Walk的声明式API创建撰写电子邮件视图
- en: That's all that's required to complete the layout code of the main interface
    features. Next, let's add the menu, toolbar, and set up actions for the buttons
    we have defined.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成主界面功能布局代码所需的所有内容就是这些。接下来，让我们添加菜单、工具栏，并为已定义的按钮设置操作。
- en: Toolbar and menu
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏和菜单
- en: Adding menus and toolbars with the declarative API is very straightforward.
    The `MainWindow` struct has the `Menu` field (which is a slice of `MenuItem`)
    and the `ToolBar` field (which takes a `ToolBar` struct that contains an `Items`
    field for the `MenuItem` list). Each item in the list is either an `Action`, a
    `Separator`, or another `Menu` that mirrors the designs we created earlier.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明式API添加菜单和工具栏非常简单。`MainWindow`结构体有一个`Menu`字段（它是一个`MenuItem`切片）和一个`ToolBar`字段（它接受一个包含`Items`字段的`ToolBar`结构体，该字段用于`MenuItem`列表）。列表中的每个项目都是一个`Action`、一个`Separator`或另一个与我们在早期创建的设计相匹配的`Menu`。
- en: Each `Action` in the declarative API expects a `Text` string that is used for
    the display in menus. Toolbars also use this content for tooltips, and for display
    if the style is set to `ToolBarButtonTextOnly`. An `Image` field allows you to
    set an icon for the toolbars if you want to reference installed images or icons
    distributed with your app. Most important is the `OnTriggered` field, which should
    be set to a `func()` that will be executed when the button or menu item is clicked.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式API中的每个`Action`都期望一个用于菜单显示的`Text`字符串。工具栏也使用此内容作为工具提示，并在样式设置为`ToolBarButtonTextOnly`时用于显示。一个`Image`字段允许你设置工具栏的图标，如果你想要引用安装的图像或与你的应用一起分发的图标。最重要的是`OnTriggered`字段，它应该设置为在按钮或菜单项被点击时执行的`func()`。
- en: 'The following code is used set up the menu on the `MainWindow` we created in
    the *Layout* section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于设置我们在*布局*部分创建的`MainWindow`上的菜单：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code for the toolbar is almost identical and so the details have been omitted,
    but you can add it to the `MainWindow` using the `ToolBar` field, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏的代码几乎完全相同，因此省略了细节，但您可以通过`ToolBar`字段将其添加到`MainWindow`中，如下所示：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The result of the code added should be a window like that in the following
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码的结果应该是一个类似于以下截图的窗口：
- en: '![](img/a0b8777c-59a4-47a7-8e09-d54caa1692af.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/a0b8777c-59a4-47a7-8e09-d54caa1692af.png)'
- en: The main email interface with the menu and toolbar added
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了菜单和工具栏的主要电子邮件界面
- en: 'Don''t worry if the code for the new button didn''t work for you—the completed
    application source code is available to download at [https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go](https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go). Before
    the user interface code is completed, we should add some code that will help us
    to navigate the app. The simplest is the quit item from the file menu. Just add
    the following code to the preceding `Quit` action:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新按钮的代码没有为您工作，请不要担心——完整的应用程序源代码可在[https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go](https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go)下载。在用户界面代码完成之前，我们应该添加一些代码，这将帮助我们导航应用程序。最简单的是文件菜单中的退出项。只需将以下代码添加到前面的`Quit`操作中：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The opening of our compose dialog is a little more complicated because a dialog
    needs to know which parent it''s loading from. To do this, create a local variable,
    called `window`, of the `*walk.MainWindow` type and assign it to the `MainWindow` declarative
    API using the following line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编辑对话框的打开稍微复杂一些，因为对话框需要知道它从哪个父窗口加载。为此，创建一个名为`window`的本地变量，其类型为`*walk.MainWindow`，并使用以下行将其分配给`MainWindow`声明性API：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can then be referenced in your `New` action handler, where `NewCompose`
    is a function that creates the email compose window:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在`New`操作处理程序中引用它，其中`NewCompose`是一个创建电子邮件编辑窗口的函数：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we should set up default behavior for the buttons on our compose dialog.
    To do this, we need to declare two `*walk.PushButton` variables that are assigned
    to the `Cancel` and `Send` buttons, respectively. By then passing these to the
    dialog definition using the `CancelButton` and `DefaultButton` fields, we get
    the appropriate behavior:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该为我们的编辑对话框中的按钮设置默认行为。为此，我们需要声明两个`*walk.PushButton`变量，分别分配给`Cancel`和`Send`按钮。然后通过`CancelButton`和`DefaultButton`字段将这些变量传递给对话框定义，我们就能获得适当的行为：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s set the cancel button to close the dialog—you will need to create
    a `walk.Dialog` variable to `AssignTo` the declarative API as with the main window.
    With these steps complete, either clicking the cancel button or pressing the *Esc*
    key should dismiss the compose window:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将取消按钮设置为关闭对话框——您需要创建一个`walk.Dialog`变量来`AssignTo`声明性API，就像主窗口一样。完成这些步骤后，无论是点击取消按钮还是按*Esc*键，都应该关闭编辑窗口：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Communicating with the GUI
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GUI通信
- en: 'To populate the user interface, we need to define a data model and load some
    test data. Within the code for this book, there is a client package that contains
    a data model and some test data to simulate an email server. We will use that
    package by importing it into the Go files for this project using the `github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client` package.
    We won''t cover the details of the package in this chapter, but we will reference
    its defined `client.EmailServer` and `client.EmailMessage` types. The email message
    definition is as follows—the field names will be useful when loading email details
    in the UI:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充用户界面，我们需要定义一个数据模型并加载一些测试数据。在本书的代码中，有一个客户端包包含一个数据模型和一些测试数据，用于模拟电子邮件服务器。我们将通过将`github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client`包导入到本项目的Go文件中来使用该包。我们不会在本章中详细介绍该包的细节，但我们将引用其定义的`client.EmailServer`和`client.EmailMessage`类型。电子邮件消息的定义如下——字段名称在加载UI中的电子邮件详细信息时将很有用：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: View model
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图模型
- en: To communicate with the Walk user interface, we need to define another data
    model. This view model is designed to communicate information in a way that the
    declarative API understands. We will create a type named `EmailClientModel`, which
    will handle translating data from our client code to our user interface definition.
    Create a new file, `model.go`, where you can start to define these models. The
    first section of the code allows an email server to be set causing the email list
    to update accordingly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与Walk用户界面通信，我们需要定义另一个数据模型。这个视图模型旨在以声明性API能够理解的方式传递信息。我们将创建一个名为`EmailClientModel`的类型，它将处理将我们的客户端代码中的数据转换为我们的用户界面定义。创建一个新文件`model.go`，在那里你可以开始定义这些模型。代码的第一部分允许设置电子邮件服务器，从而使电子邮件列表相应更新。
- en: 'For brevity, the trivial methods for `walk.TreeModel` have been left out—you
    can find them in the full code listing for this book:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，省略了`walk.TreeModel`的琐碎方法——你可以在本书的完整代码列表中找到它们：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The email list for this model needs to represent our email list as items in
    a tree, rather than a simple list as returned by the client code. To support this
    we need another type, `EmailModel`, that implements the `walk.TreeItem` interface.
    Here, again, we have omitted the trivial details—each email item will never contain
    child elements and so we can ignore this complexity:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型的电子邮件列表需要将我们的电子邮件列表作为树中的项目来表示，而不是客户端代码返回的简单列表。为了支持这一点，我们需要另一个类型，`EmailModel`，它实现了`walk.TreeItem`接口。在这里，我们又省略了琐碎的细节——每个电子邮件项目永远不会包含子元素，因此我们可以忽略这种复杂性：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We want to group our emails under an `Inbox` heading, so we need to build the
    root node and then populate the email list within it. For this, we define one
    more type, `InboxList`, which also implements `walk.TreeItem`, but this time it
    will allow access to the child list (emails) it holds. We will also need to write
    a method for building the inbox list from a list of messages (which we would be
    provided by the client code). See how the final method in this code snippet creates
    instances of `EmailModel` for each message and adds them to the inbox list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的电子邮件分组在`Inbox`标题下，因此我们需要构建根节点，然后在其内部填充电子邮件列表。为此，我们定义了一个额外的类型`InboxList`，它也实现了`walk.TreeItem`接口，但这次它将允许访问它所持有的子列表（电子邮件）。我们还需要编写一个方法，用于从消息列表（客户端代码将提供给我们）构建收件箱列表。看看这个代码片段中的最终方法是如何为每条消息创建`EmailModel`实例并将它们添加到收件箱列表中的：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Detail view
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细视图
- en: 'Now that we have a data model built, let''s display the data that''s loaded.
    Starting with the email detail view, we will make use of Walk''s declarative API, `DataBinder`.
    This allows us to avoid having to manually set the data on each label every time
    a new message is loaded. To work correctly, we also need to create a `walk.DataBinder`
    to assign to—this will handle the actual bindings:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了数据模型，让我们显示加载的数据。从电子邮件详细视图开始，我们将使用Walk的声明性API，`DataBinder`。这允许我们避免在每次加载新消息时手动设置每个标签上的数据。为了正确工作，我们还需要创建一个`walk.DataBinder`来分配——这将处理实际的绑定：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we can update the `Composite` widget that displays the email information to
    use this data binding. Let''s also set the default content through the `DataSource`
    field. This information will come from the model, which we will initialize shortly:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新显示电子邮件信息的`Composite`小部件，以使用这种数据绑定。让我们也通过`DataSource`字段设置默认内容。这些信息将来自模型，我们将在稍后初始化它：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, each item simply has its static `Text` field changed to an appropriate `Bind()`
    call; the parameter will be the name of the field on an `client.EmailMessage`
    type described in the *View model* section:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个项目只需将其静态`Text`字段更改为适当的`Bind()`调用；参数将是*视图模型*部分中描述的`client.EmailMessage`类型上的字段名称：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the `Date` field, we can''t directly bind a `time.Time` type, so use the
    `DateString()` helper instead:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Date`字段，我们无法直接绑定`time.Time`类型，因此使用`DateString()`辅助函数代替：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And finally, let''s create a helper method that will allow us to update the
    email message that is currently bound:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个辅助方法，允许我们更新当前绑定的电子邮件消息：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: List view
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表视图
- en: 'Most of the work for our email list was done in the preceding model code—now
    we need to connect it to the user interface. The following code sets up a `walk.TreeView`
    class that we use to keep track of the current item and assigns it to the declarative
    `TreeView`. After that, the model is set and then we pass a function that will
    be informed when the current item changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们电子邮件列表的大部分工作是在前面的模型代码中完成的——现在我们需要将其连接到用户界面。以下代码设置了一个`walk.TreeView`类，我们用它来跟踪当前项，并将其分配给声明性的`TreeView`。之后，设置模型，然后传递一个函数，当当前项发生变化时会通知我们：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With all that in place, the application will load the email details from the
    current email message using `model.Server.CurrentMessage()` via the default `DataSource` of
    the `DataBinder`. When the main list is clicked, the function passed to `OnCurrentItemChanged`
    checks that the item is an `EmailModel` and, if so, updates the detail view. Finally,
    we need to set up the model that will be used in the preceding code, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些准备就绪后，应用程序将使用`model.Server.CurrentMessage()`通过`DataBinder`的默认`DataSource`从当前电子邮件消息加载电子邮件详情。当点击主列表时，传递给`OnCurrentItemChanged`的函数会检查该项是否为`EmailModel`，如果是，则更新详细视图。最后，我们需要设置前面代码中使用的模型，如下所示：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This model is used to set the list content and also to set the default content
    of the detail view. When built and run, the application should now look like a
    complete, albeit basic, email client:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型用于设置列表内容，也用于设置详细视图的默认内容。构建并运行后，应用程序现在应该看起来像一个完整（尽管是基本的）的电子邮件客户端：
- en: '![](img/e9a2ab00-3882-451f-b633-103bca097548.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9a2ab00-3882-451f-b633-103bca097548.png)'
- en: Our email interface with some test data loaded
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 加载了一些测试数据的我们的电子邮件界面
- en: Background processing
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景处理
- en: All user interface code with Walk must run on the main thread; this is a constraint
    of the winAPI that handles the widgets. This means that any work in the background
    must change threads before running any UI code. This is done using the `Synchronize()`
    function on `walk.Window`. It takes a single function as a parameter and ensures
    that the code it contains will be run appropriately.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所有使用Walk的用户界面代码都必须在主线程上运行；这是处理小部件的winAPI的限制。这意味着任何在后台的工作必须在运行任何UI代码之前更改线程。这是通过在`walk.Window`上使用`Synchronize()`函数来完成的。它接受一个函数作为参数，并确保包含的代码将被适当地运行。
- en: 'To handle the updating when an incoming email arrives, we create a new function,
    `incomingEmail()`, that will update our email list model. This function will cause
    an email to be added to the model, which will happen on the main thread so that
    the user interface can be updated to reflect the new data:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理当新电子邮件到达时的更新，我们创建了一个新的函数`incomingEmail()`，该函数将更新我们的电子邮件列表模型。此函数将导致将电子邮件添加到模型中，这将发生在主线程上，以便用户界面可以更新以反映新数据：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To support this change, we need to update `EmailClientModel` to add this new
    `AddEmail()` function. The function will add an item to the list and publish the
    data-reset event:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持此更改，我们需要更新`EmailClientModel`以添加此新的`AddEmail()`函数。该函数将向列表添加一个项并发布数据重置事件：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This, in turn, needs an `Add()` function in the `InboxList` type that we created
    to provide data to the model:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来需要一个在`InboxList`类型中的`Add()`函数，我们创建它以向模型提供数据：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we need to listen to the `Incoming()` server channel, which will deliver
    each new email to our application. As this channel read will block until an email
    is received, this must run in a separate goroutine—hence the background processing.
    When an email arrives, we simply call the function we just created, passing the
    new `email` and a reference to the `model` which we should refresh:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要监听`Incoming()`服务器通道，它将每个新电子邮件传递到我们的应用程序。由于此通道读取将阻塞，直到收到电子邮件，因此必须在单独的goroutine中运行——这就是为什么需要背景处理。当电子邮件到达时，我们只需调用我们刚刚创建的函数，传递新的`email`和一个对`model`的引用，我们应该刷新它：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this code in place, you will see the email list update when a new email
    arrives. The email can then be clicked to see the details.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，您将看到当新电子邮件到达时电子邮件列表更新。然后可以点击电子邮件以查看详情。
- en: Walk in a cross-platform application
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在跨平台应用程序中漫步
- en: Walk is clearly a library aimed at creating graphical user interfaces for the
    Microsoft Windows platform—but this doesn't mean that building your application
    with Walk limits you to Windows only. Using the techniques explored in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*, we can set
    the code for Windows to be conditionally included when building for the platform,
    and introduce other files that could provide a user interface for other platforms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Walk 显然是一个针对 Microsoft Windows 平台创建图形用户界面的库——但这并不意味着使用 Walk 构建你的应用程序会限制你只能在
    Windows 上使用。通过在[第 3 章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)中探索的技术，“Go to
    the Rescue!”，我们可以设置 Windows 的代码在为该平台构建时条件性地包含，并引入其他可能为其他平台提供用户界面的文件。
- en: 'The first step is to update the files we have built so far to only build on
    Windows. We do this using the build constraints comment format (you could also
    use file naming for this step if you wish):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是更新我们迄今为止构建的文件，以便仅在 Windows 上构建。我们使用构建约束注释格式来完成此操作（如果你愿意，你也可以在这一步使用文件命名）：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then introduce a new file that will handle the fallback case when we''re
    on a different platform. For this simple project we will call it `nonwindows.go` as
    the content will run for any computer not running Windows. In this file, we place
    a small amount of code that will print a failure message and quit if the application
    is launched on any unsupported platform. Note that the build constraint here is
    set to compile on any non-Windows platform; this too would be updated to match
    any fallback cases your project may have:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们引入了一个新的文件，用于处理我们在不同平台上的回退情况。对于这个简单的项目，我们将它称为 `nonwindows.go`，因为其内容将在任何非
    Windows 计算机上运行。在这个文件中，我们放置了一小段代码，如果应用程序在任何不受支持的平台上启动，它将打印失败消息并退出。请注意，这里的构建约束被设置为在任何非
    Windows 平台上编译；这也将更新以匹配你的项目可能有的任何回退情况：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note the `NewMailUIBrowse()` function name—this is our generic method name
    for loading and running the main GoMail browse interface. You probably need to
    update the name of the method that was previously used to run the application.
    Most likely, you used `main()`, but we will need to provide a new `main.go` with
    that method. This new file is the only file in the project with no build constraints.
    It will compile for any platform and, when running, it will execute whichever
    `NewMailUIBrowse()` method was compiled in for the target platform:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `NewMailUIBrowse()` 函数的名称——这是我们用于加载和运行主 GoMail 浏览界面的通用方法名。你可能需要更新之前用于运行应用程序的方法的名称。最可能的是，你使用了
    `main()`，但我们需要提供一个包含该方法的新的 `main.go` 文件。这个新文件是项目中唯一没有构建约束的文件。它将编译为任何平台，并且在运行时，它将执行为目标平台编译的
    `NewMailUIBrowse()` 方法：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we switch to another operating system, say macOS, and compile the code now,
    there should be no compile errors. Running the application will yield a simple
    error message and it will immediately quit. Clearly this code could do something
    more meaningful than just exiting with an error message:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到另一个操作系统，比如 macOS，并现在编译代码，应该没有编译错误。运行应用程序将显示一个简单的错误消息，并立即退出。显然，这段代码可以比仅仅显示错误消息做更多有意义的事情：
- en: '![](img/a1ee956a-b0c8-41e8-8c67-4178b61a6ff1.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1ee956a-b0c8-41e8-8c67-4178b61a6ff1.png)'
- en: And so you see how we can use Walk to develop a Windows-specific user interface.
    As part of a multi-platform strategy, this could help ensure greater platform
    integration for your audience on Windows, or you may wish to provide certain sections
    of your application with platform-specific implementations. Whatever the reason,
    you can see how easy it is to include multiple platform-specific alternatives
    within a cross-platform application build with Go.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到我们如何使用 Walk 开发特定于 Windows 的用户界面。作为多平台策略的一部分，这可以帮助确保你的受众在 Windows 上的平台集成度更高，或者你可能希望为你的应用程序的某些部分提供特定于平台的实现。无论原因如何，你可以看到在用
    Go 进行跨平台应用程序构建时包含多个平台特定替代方案是多么容易。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started the exploration of GUI toolkits by first looking
    at the Walk API for Windows' graphical application development. We looked at how
    to get a Go-based Windows application running, and learned how the Walk project
    is structured into separate declarative and native APIs. We also saw how each
    of these APIs provides different benefits and how they are best combined to create
    a simple application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先通过查看 Windows 图形应用程序开发的 Walk API 来开始对 GUI 工具包的探索。我们了解了如何运行基于 Go 的 Windows
    应用程序，并学习了 Walk 项目是如何构建为独立的声明性 API 和本地 API 的。我们还看到了每个 API 提供的不同好处以及它们如何最佳地组合以创建一个简单的应用程序。
- en: As the Walk design was heavily inspired by the Qt project (which we will return
    to in [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt - Multiple
    Platforms with Qt*), we were able to use the interface-designer features of Qt
    Creator to mock up a basic email application that we then built out using the
    declarative API. This email application is a design that can be reused for each
    of the toolkit-exploration chapters. To support the example applications, we imported
    another package that is provided in this book's source code, which provides some
    data models and test data. By combining our UI code, the email client library,
    and the data binding capabilities of the Walk toolkit, we were able to create
    a simple email application that would run natively on the Windows platform using
    the system-provided widgets. Through some small alterations, it was shown that
    this could be part of a wider cross-platform strategy where each platform's graphical
    presentation is provided by different toolkits.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Walk设计深受Qt项目（我们将在[第7章](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)，*Go-Qt
    - 多平台与Qt*）的启发，我们得以利用Qt Creator的界面设计功能来模拟一个基本的电子邮件应用程序，然后使用声明性API构建它。这个电子邮件应用程序是一个设计，可以用于每个工具包探索章节。为了支持示例应用程序，我们导入了这个书中源代码提供的另一个包，它提供了一些数据模型和测试数据。通过结合我们的UI代码、电子邮件客户端库以及Walk工具包的数据绑定功能，我们能够创建一个简单的电子邮件应用程序，该程序可以在Windows平台上使用系统提供的控件原生运行。通过一些小的调整，展示了这可以成为更广泛的跨平台策略的一部分，其中每个平台的图形表示由不同的工具包提供。
- en: In the next chapter, we will move our focus to code that provides a native look
    and feel across multiple platforms. We will be looking specifically at andlabs
    UI—a GUI toolkit that aims to provide a look and feel that matches the current
    operating system. If used on Windows, this will be similar to Walk, but it also
    adapts to different desktop platforms while only needing to write the user-interface
    code once.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点转移到提供跨多个平台原生外观和感觉的代码。我们将特别关注andlabs UI——一个旨在提供与当前操作系统相匹配的外观和感觉的GUI工具包。如果用于Windows，它将与Walk相似，但它也可以适应不同的桌面平台，而只需编写一次用户界面代码。
