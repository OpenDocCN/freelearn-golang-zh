- en: andlabs UI - Cross-platform Native UIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: andlabs UI - 跨平台原生UI
- en: Like the Walk API we explored in the previous chapter, andlabs UI aims to create
    a Go API on top of operating system native widgets, but, unlike Walk, andlabs
    UI project supports multiple operating systems with a single API. This means that
    graphical applications created using the API can be compiled and run on Windows,
    macOS, and Linux using the same source code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一章中探索的Walk API一样，andlabs UI旨在在操作系统原生小部件之上创建Go API，但与Walk不同，andlabs UI项目支持单个API的多个操作系统。这意味着使用该API创建的图形应用程序可以使用相同的源代码在Windows、macOS和Linux上编译和运行。
- en: 'In this chapter, we will explore cross-platform native applications that match
    the operating system''s look and feel. In particular, we will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与操作系统外观和感觉相匹配的跨平台原生应用程序。特别是，我们将涵盖以下主题：
- en: Background and history
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景和历史
- en: Getting started with andlabs UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用andlabs UI
- en: Generic API for multiple platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多平台通用的API
- en: Building a user interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Challenges with multiple native GUIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个原生GUI的挑战
- en: Before we get started with the benefits and complexities of a cross-platform
    API using native widget toolkits, let's look more at the background of the project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探讨使用原生小部件工具包的跨平台API的益处和复杂性之前，让我们更深入地了解一下项目的背景。
- en: Background and history
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景和历史
- en: The andlabs UI project was created to provide a simple-to-use way to create
    native graphical applications using Go. The API is minimal as it aims to provide
    only what is necessary to create GUI programs. The core is a C library, which
    hides the platform-specific APIs, allowing the main library to manage the idiomatic
    considerations for a Go GUI API. Recently, the C library (libui) was moved to
    a separate project, which is included in the Go project for developers' convenience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI项目是为了提供一个简单易用的方法来使用Go创建原生图形应用程序。API是最小化的，因为它旨在只提供创建GUI程序所必需的内容。核心是一个C库，它隐藏了平台特定的API，允许主库管理Go
    GUI API的惯用考虑因素。最近，这个C库（libui）被移动到一个单独的项目中，为了方便开发者，它被包含在Go项目中。
- en: 'There is a demonstration of the widgets available included in the project—when
    run on a Linux computer, it will look like the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中包含的可用小部件的演示——当在Linux计算机上运行时，它将看起来像以下截图：
- en: '![](img/d518b369-6ae8-4ce1-aca3-21d7b12c60a0.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d518b369-6ae8-4ce1-aca3-21d7b12c60a0.png)'
- en: The widget demo from andlabs UI
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI的小部件演示
- en: As a platform-native implementation, the widgets in andlabs UI will look different
    on each operating system. On Windows and macOS, the library uses the native widget
    set, and on Linux it uses the GTK+ library. This approach creates applications
    that are consistent with other software on the current computer and so should
    be simple for users to understand. This approach is powerful and has substantial
    benefits, but can add complications for application developers. We will explore
    the benefits and challenges of such an approach within this chapter, but first
    let's get running with a simple *hello world* application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为平台原生实现，andlabs UI中的小部件在每个操作系统上看起来都不同。在Windows和macOS上，库使用原生小部件集，而在Linux上则使用GTK+库。这种方法创建的应用程序与当前计算机上的其他软件保持一致，因此应该对用户来说很容易理解。这种方法功能强大，具有实质性的好处，但可能给应用程序开发者带来复杂性。我们将在本章中探讨这种方法的益处和挑战，但首先让我们从一个简单的*hello
    world*应用程序开始运行。
- en: Getting started with andlabs UI
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用andlabs UI
- en: Andlabs UI is easy to get started with on most platforms, but the details vary
    from system to system. Due to the nature of linking to many different operating
    systems' native widget toolkits, there can be some hidden complexities, especially
    when developing Linux-based applications. Before we can build our first andlabs-based
    application GUI, there is some setup required. We need to prepare the current
    development environment to work with native widgets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI在大多数平台上都很容易开始使用，但具体细节因系统而异。由于链接到许多不同的操作系统的原生小部件工具包，可能会有一些隐藏的复杂性，尤其是在开发基于Linux的应用程序时。在我们能够构建第一个基于andlabs的应用程序GUI之前，有一些设置是必需的。我们需要准备当前的开发环境以与原生小部件一起工作。
- en: Prerequisites
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: As an API that utilizes the native widgets for each platform, the prerequisites
    vary for Windows, macOS, and Linux. Any packages that need to be installed in
    this section will be required by any users of the applications that you develop
    as well. It's also necessary to have CGo running (the ability for Go code to call
    C functions is illustrated in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml),
    *Go to the Rescue!*), which may require the installation of additional build tools.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为利用每个平台原生控件的 API，Windows、macOS 和 Linux 的先决条件各不相同。在此部分需要安装的任何包都将由您开发的应用程序的用户所需要。还需要确保
    CGo 运行（Go 代码调用 C 函数的能力在[第 3 章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)，*Go
    来拯救!*中有所说明），这可能需要安装额外的构建工具。
- en: Microsoft windows
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft windows
- en: The native widgets used on Windows are the Common Controls—the same used by
    the Walk library that we explored in detail in the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications*. As they are native to the operating
    system, no installation is required when using Windows Vista or later. If you
    want to support earlier versions (back to Windows XP), it's possible if you install
    at least version 6.0 of `ComCtl32.dll`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 上使用的原生控件是通用控件——与我们在[第 4 章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk
    - 构建图形化窗口应用程序*中详细探讨的 Walk 库所使用的相同。由于它们是操作系统的原生控件，因此在使用 Windows Vista 或更高版本时不需要安装。如果您想支持更早的版本（回溯到
    Windows XP），如果安装至少 `ComCtl32.dll` 版本 6.0，则是有可能的。
- en: Andlabs UI, like many of the other toolkits featured in this book, requires
    the presence of CGo to utilize native libraries. On a full development system,
    it's likely that this is already set up. If you're unsure, or would like a reminder
    of how to set up the Cgo dependencies, please check *Setting up CGo* section from
    the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation Details*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Andlabs UI，像本书中介绍的其他许多工具包一样，需要 CGo 的存在来利用原生库。在完整的开发系统中，这可能是已经设置好的。如果您不确定，或者想要回顾如何设置
    Cgo 依赖项，请检查[附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml)中的*设置 CGo*部分，*安装详情*。
- en: macOS
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: When developing for macOS, the native widgets are used directly. As these are
    provided by the operating system for every recent version of macOS, no additional
    libraries are required.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 macOS 开发时，直接使用原生控件。因为这些控件由操作系统为 macOS 的每个最新版本提供，所以不需要额外的库。
- en: CGo support is required for andlabs UI and this requires XCode command-line
    tools to be installed. If you have not already set this up please check the *Setting
    up CGo* section from the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation
    Details**.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CGo 支持对于 andlabs UI 是必需的，这需要安装 XCode 命令行工具。如果您还没有设置好，请检查[附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml)中的*设置
    CGo*部分，*安装详情*。
- en: Linux
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: On Linux, andlabs UI uses the GTK+ widget library (which we will explore in
    detail in [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml), *Go-GTK - Multiple
    Platforms with GTK*) and so the library must be installed on your computer. If
    you have the Gnome desktop installed, or other applications that use GTK+ (such
    as Gimp), the library will already be installed. If not, you will need to install
    this dependency using your system's package manager.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，andlabs UI 使用 GTK+ 控件库（我们将在[第 6 章](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml)，*Go-GTK
    - 多平台与 GTK*中详细探讨）因此，必须在您的计算机上安装此库。如果您已安装 Gnome 桌面或使用 GTK+ 的其他应用程序（如 Gimp），库已安装。如果没有，您将需要使用系统包管理器安装此依赖项。
- en: While this is a simple task, the package name varies across systems—it will
    probably be called `gtk3-devel`, `libgtk-3-dev`, or `gtk3`. Install this in the
    usual manner and you'll be ready to set up andlabs UI library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的任务，但包名在不同的系统之间可能会有所不同——它可能被称为 `gtk3-devel`、`libgtk-3-dev` 或 `gtk3`。按照常规方式安装它，您就准备好设置
    andlabs UI 库了。
- en: To enable CGo, required by andlabs UI, on Linux you must have a compiler (gcc
    or clang) installed. This is often already installed on a development Linux installation,
    but if you're unsure, you can follow the *Setting up CGo* section from the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml), *Installation
    Details*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 上启用 CGo，这是 andlabs UI 所必需的，您必须安装一个编译器（gcc 或 clang）。这通常已经安装在开发 Linux
    安装中，但如果您不确定，可以遵循[附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml)中的*设置 CGo*部分，*安装详情*。
- en: Setup
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: The setup of andlabs UI is very simple—it only requires you to get the library
    using Go tools. You only need to execute `go get github.com/andlabs/ui`. This
    works exactly the same on Windows, macOS, and Linux, assuming that you have Go
    installed and running (if not, check out *Installing Go* section in the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml),
    *Installation Details*). If you encounter an error, first check that your Go installation
    is up to date—these issues often get fixed quickly—and that you have set up CGo
    as described.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI的设置非常简单——它只需要你使用Go工具获取库。你只需要执行`go get github.com/andlabs/ui`。在Windows、macOS和Linux上，这完全一样，前提是你已经安装并运行了Go（如果没有，请查看[附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml)中的*安装Go*部分，*安装细节*)。如果你遇到错误，首先检查你的Go安装是否是最新的——这些问题通常很快就会得到修复——并且你已经按照描述设置了CGo。
- en: Rebuilding the UI library (workaround)
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新构建UI库（解决方案）
- en: The libui library that andlabs UI is built upon is packaged with the main library,
    but sometimes this gets out of date or is not compiled for the exact configuration
    of your computer. If you see an error when this happens, such as `relocation R_X86_64_32S
    against '.rodata' can not be used when making a shared object`, these instructions
    will help. If you see no error when installing, please skip these tips!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI构建所基于的libui库与主库一起打包，但有时这会过时或没有为你的电脑的精确配置编译。如果你看到错误，例如`relocation R_X86_64_32S
    against '.rodata' can not be used when making a shared object`，这些说明将有所帮助。如果你在安装时没有看到错误，请跳过这些提示！
- en: 'The following commands will rebuild the libui file for your computer. It assumes
    a Linux bash shell, as this situation is most likely to occur on a Linux computer.
    This is not going to be needed for anyone using the applications you build—just
    for setting up your development environment. The libui project is downloaded from
    Github and built using standard cmake tools. Be sure to specify the `-DBUILD_SHARED_LIBS=OFF`
    parameter, as we must build a static library to embed in the Go library:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将为你的电脑重新构建libui文件。它假设使用Linux bash shell，因为这种情况最有可能发生在Linux电脑上。这不会是使用你构建的应用程序的人所需要的——只是用于设置你的开发环境。libui项目是从GitHub下载的，并使用标准的cmake工具构建。务必指定`-DBUILD_SHARED_LIBS=OFF`参数，因为我们必须构建一个静态库以嵌入Go库中：
- en: '![](img/c9ad32e8-e03a-4a29-89a3-06212cfe6276.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9ad32e8-e03a-4a29-89a3-06212cfe6276.png)'
- en: Rebuilding libui if the packaged version doesn't work
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打包版本不起作用，重新构建libui
- en: The commands are designed to work without any environment configuration, but
    you will need cmake installed—your system's package manager will be able to install
    it if you find it isn't installed. Once the build is complete, the resulting library, `out/libui.a`,
    should be moved into the UI project and renamed appropriately.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计为无需任何环境配置即可工作，但你需要安装cmake——如果你的系统包管理器找不到它，它将能够安装。一旦构建完成，生成的库`out/libui.a`应该移动到UI项目中并适当地重命名。
- en: Code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'Now that the library is installed, it''s time to write some code. The following
    sample is andlabs UI equivalent of the *hello world* example we used in the [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*. Start by entering the following code into a new file, named `hello.go`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在库已经安装，是时候编写一些代码了。以下示例是andlabs UI的*hello world*示例，我们在[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk
    - 构建图形化窗口应用程序*中使用过。首先，将以下代码输入到一个新文件中，命名为`hello.go`：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is pretty straightforward, but there are a few things that we should
    cover, so let's step through it. As usual, for a simple graphical Go app, we are
    using the `main` package and importing the toolkit library, before defining the
    `main()` function. We then call the main entry point for an andlabs UI application,
    `ui.Main()`, which takes a single function that will build and show the app's
    GUI. If an error occurred, we cause the binary to panic, as the interface couldn't
    be loaded.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当简单，但还有一些事情我们应该讨论，所以让我们一步步来。通常情况下，对于一个简单的图形化Go应用程序，我们在定义`main()`函数之前使用`main`包并导入工具库。然后我们调用andlabs
    UI应用程序的主入口点`ui.Main()`，它接受一个函数来构建和显示应用程序的GUI。如果发生错误，我们将二进制文件导致panic，因为接口无法加载。
- en: In our user interface code, we first set up a window with `ui.NewWindow()`,
    with a title and a default size, and the final parameter indicates whether the
    window should have a menu bar. We turn on the default margin (padding) and assign
    a closing function to exit the app by calling `ui.Quit()`. Next, a new button
    is created with `ui.NewButton()`, labelled `Quit`, that also exits the application
    when clicked. These components are laid out using a container with `ui.NewVerticalBox()`.
    A `Hello World!` label and the `Quit` button are both added. The `Append()` method
    of `ui.Box` takes a Boolean parameter, `stretchy`—if this is set to `true`, the
    component will expand to fill the available space. Last, we set the content of
    the window with `SetChild()` and show it using `Show()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用户界面代码中，我们首先使用`ui.NewWindow()`设置一个窗口，带有标题和默认大小，最后一个参数表示窗口是否应该有菜单栏。我们打开默认边距（填充），并通过调用`ui.Quit()`分配一个关闭函数以退出应用程序。接下来，使用`ui.NewButton()`创建一个新的按钮，标签为`Quit`，点击它也会退出应用程序。这些组件使用`ui.NewVerticalBox()`容器进行布局。一个`Hello
    World!`标签和一个`Quit`按钮都被添加。`ui.Box`的`Append()`方法接受一个布尔参数`stretchy`——如果设置为`true`，则组件将扩展以填充可用空间。最后，我们使用`SetChild()`设置窗口的内容，并使用`Show()`显示它。
- en: Build
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'Building this sample app is trivial. For example, in the following screenshot,
    we are running a Terminal on a Linux computer and simply execute `go build hello.go`.
    This creates an executable file that can be run directly without needing the Go
    tools installed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这个示例应用非常简单。例如，在下面的屏幕截图中，我们正在Linux计算机上运行一个终端，并简单地执行`go build hello.go`。这会创建一个可以直接运行的可执行文件，无需安装Go工具：
- en: '![](img/b3de9f96-2285-4865-b01d-914b9e26b047.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b3de9f96-2285-4865-b01d-914b9e26b047.png)'
- en: Building for the current Linux environment
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为当前Linux环境构建
- en: 'Building on a Windows computer (as long as gcc is in the command-line path—see
    *Prerequisites* section mentioned earlier) is just as simple as on Linux or macOS:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows计算机上构建（只要gcc在命令行路径中——参见前面提到的*先决条件*部分）与在Linux或macOS上构建一样简单：
- en: '![](img/28d70e8c-5e3d-472b-8e4e-42f0d564e00c.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/28d70e8c-5e3d-472b-8e4e-42f0d564e00c.png)'
- en: Building the hello world app on Windows
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上构建hello world应用程序
- en: In these examples, we are building the applications on the platform they will
    run. Cross-compilation, one of the strengths of the Go toolchain, is more complicated
    with andlabs UI.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们是在它们将要运行的平台构建应用程序。与andlabs UI相比，交叉编译是Go工具链的优势之一，但更为复杂。
- en: Run
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'The application can be run from the command line (`./hello` on Linux or macOS,
    and `hello.exe` on Windows) or simply by double-clicking the file icon from your
    system''s file browser. Either way, the result should be the appearance of a familiar
    *hello world* window. This will look very similar across multiple operating systems,
    but the look and feel will vary:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过命令行（Linux或macOS上的`./hello`，Windows上的`hello.exe`）运行，或者简单地通过双击系统文件浏览器中的文件图标。无论哪种方式，结果都应该是出现一个熟悉的*hello
    world*窗口。这将在多个操作系统上看起来非常相似，但外观和感觉会有所不同：
- en: 'On Windows this is the same as Walk:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上这与Walk相同：
- en: '![](img/e1024499-c9e2-417a-88e0-f1dffbdf98b3.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1024499-c9e2-417a-88e0-f1dffbdf98b3.png)'
- en: 'Andlabs UI hello world on Linux:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Andlabs UI在Linux上的hello world：
- en: '![](img/2e5a1ab8-3a60-469b-a144-f6dd50e61764.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e5a1ab8-3a60-469b-a144-f6dd50e61764.png)'
- en: 'Hello world running on macOS:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上运行的hello world：
- en: '![](img/6d5f8a00-07a0-435b-9a0e-956a805eebee.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d5f8a00-07a0-435b-9a0e-956a805eebee.png)'
- en: Generic API for multiple platforms
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多平台通用的API
- en: The andlabs UI project provides a generic API that wraps operating-system-native
    widgets on Windows, Linux, and macOS. Due to this approach, it's largely limited
    to the *lowest common denominator* level of functionality, but considering how
    similar these toolkits are, the resulting API is surprisingly rich.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI项目提供了一个通用的API，它封装了Windows、Linux和macOS上的操作系统原生小部件。由于这种方法，它主要限于*最低共同分母*级别的功能，但考虑到这些工具包的相似性，生成的API出人意料地丰富。
- en: All widgets inherit from the `ui.Control` interface, which defines the `Show()`,
    `Hide()`, `Enable()`, and `Disable()` methods that all controls must implement
    (with obvious expected behavior). Additionally, it defines the `LibuiControl()`
    and `Handle()` methods, which provide a pointer to the low-level libui and operating-system
    widgets, respectively. The use of those methods is generally not recommended and
    so not covered in this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有小部件都继承自`ui.Control`接口，该接口定义了所有控件必须实现的`Show()`、`Hide()`、`Enable()`和`Disable()`方法（具有明显的预期行为）。此外，它还定义了`LibuiControl()`和`Handle()`方法，分别提供对低级libui和操作系统小部件的指针。这些方法的使用通常不推荐，因此在本章中未涉及。
- en: When compared to the Qt inspired Walk API of the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk - Building Graphical Windows Applications*, the layout capabilities of andlabs
    UI appear limited with fewer controls managing the GUI visual flow. Native controls
    (while broadly similar) are programmed differently and not necessarily compatible
    with the same high-level layout definitions. What you will see in the following
    section is that containers are typically set up to expect one child, which is
    laid out using a `ui.Box` control. Many widgets, which could be considered containers
    in other toolkits, are managed as a single control in andlabs UI (such as `ui.RadioButtons`)
    so that the operating-system-specific implementation can be handled internally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)中受Qt启发的Walk API相比，andlabs
    UI的布局功能似乎有限，因为管理GUI视觉流的控件较少。本地控件（尽管广泛相似）编程方式不同，并且不一定与相同的顶级布局定义兼容。您将在下一节中看到，容器通常被设置为期望一个子控件，该子控件使用`ui.Box`控件进行布局。在许多其他工具包中可能被视为容器的小部件，在andlabs
    UI中作为单个控件管理（例如`ui.RadioButtons`），以便可以内部处理操作系统特定的实现。
- en: Controls
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控件
- en: All the widgets defined in andlabs UI implement the `Control` interface and,
    as such, can be shown, hidden, enabled, or disabled and set as the content of
    a window through `SetChild()` (with the obvious exception of `ui.Window`). A window
    may not be the child of any other `ui.Control`, for obvious reasons. The definition
    of `show()` and `hide()` for a window will be set by the operating system or widget
    toolkit, as will the manner of disabling the window content.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI中定义的所有小部件都实现了`Control`接口，因此可以通过`SetChild()`（除`ui.Window`之外）显示、隐藏、启用或禁用，并将它们设置为窗口的内容。出于明显的原因，窗口不能是任何其他`ui.Control`的子控件。窗口的`show()`和`hide()`定义将由操作系统或小部件工具包设置，禁用窗口内容的方式也是如此。
- en: Box
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Box
- en: It is probable that any window will have its content set to a Box—this is because
    it's the only control that provides a way to group multiple controls together.
    It's a control with no visible container, which is the basic layout mechanism
    within andlabs UI. You can create a new box using `ui.NewHorizontalBox()` or `ui.NewVerticalBox()`,
    which lays out its child controls horizontally or vertically in a linear arrangement.
    In a horizontal arrangement, the child items will all have the same height (which
    will match the height required for the tallest child), and in a vertical (stacked)
    configuration, they will all have the same width.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能任何窗口的内容都将设置为Box——这是因为它是唯一一个提供将多个控件组合在一起方式的控件。这是一个没有可见容器的控件，这是withinlabs UI中的基本布局机制。您可以使用`ui.NewHorizontalBox()`或`ui.NewVerticalBox()`创建一个新的Box，它以线性排列的方式水平或垂直布局其子控件。在水平排列中，子项将具有相同的高度（这将与最高子项所需的高度相匹配），而在垂直（堆叠）配置中，它们的宽度将相同。
- en: The method of adding child controls to a box is to call the `Append()` function,
    which takes a `ui.Control` child parameter and a `bool` stretchy parameter. The
    **child** will be added to the list of the components, and the **stretchy** parameter
    determines how the available space should be filled. When the stretchy parameter
    is `true`, the item will expand to fill extra space; if it's `false`, the minimum
    size will be observed. If multiple components have stretchy switched on, the spare
    space will be divided equally between them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向Box添加子控件的方法是调用`Append()`函数，该函数接受一个`ui.Control`子控件参数和一个`bool`可伸缩参数。**子控件**将被添加到组件列表中，而**可伸缩**参数决定了如何填充可用空间。当可伸缩参数为`true`时，项目将扩展以填充额外空间；如果为`false`，则观察最小尺寸。如果有多个组件的可伸缩性被打开，则额外空间将在它们之间平均分配。
- en: It's often going to provide a better visual flow for your user interface if
    widgets are separated by some space. There is a suitable method provided, `SetPadded()`,
    which will set a standard space between child widgets in the box. This size is
    set by the widget toolkit's standard metrics, and will vary from platform to platform.
    The padding applied in this way is placed between the child components—for outer
    (surrounding) space, you should set a margin. The margin is available in controls
    which embed a child control—dubbed `containers` in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小部件之间留有一定的空间，通常会对用户界面提供更好的视觉流程。提供了一个合适的方法，`SetPadded()`，它将在Box中的子小部件之间设置标准空间。这个大小由小部件工具包的标准度量设置，并且会因平台而异。以这种方式应用的填充放置在子组件之间——对于外部（周围）空间，您应该设置边距。边距在嵌入子控件的控件中可用——在本章中被称为“容器”。
- en: Containers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Containers, or controls that allow us to embed another control, are typically
    identified by the existence of a `SetChild()` or `SetMargined()` function in their
    type definition. As these controls embed one another, a margin around the content
    is often desirable—this is the outer equivalent of the padding in `ui.Box`. This
    can be turned on using `SetMargined(true)`, and the system-defined margin size
    will be introduced around the child control.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器，或允许我们嵌入另一个控件的控件，通常通过其类型定义中存在的 `SetChild()` 或 `SetMargined()` 函数来识别。由于这些控件相互嵌入，通常希望围绕内容有边距——这是
    `ui.Box` 中填充的外部等效物。这可以通过使用 `SetMargined(true)` 来开启，并且将在子控件周围引入系统定义的边距大小。
- en: 'The following containers are defined as part of andlabs UI:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下容器是作为 andlabs UI 的一部分定义的：
- en: '`Window` controls describe an application window and are the main entry point
    for an andlabs UI graphical application. The main content is set using `SetChild()`.
    Margins should probably be switched on if it''s a simple content window, or left
    off if you are adding further container controls.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Window` 控件描述了一个应用程序窗口，并且是 andlabs UI 图形应用程序的主要入口点。主要内容是通过 `SetChild()` 设置的。如果是一个简单的内容窗口，则可能需要开启边距，如果您正在添加进一步的容器控件，则可能不需要开启。'
- en: '`Group` defines a frame around a child widget (assigned with `SetChild()`)
    with a title (passed to `ui.NewGroup()`). The appearance of the group control
    will vary across systems; on some it may be a box around the child, and on others
    it may be invisible. As with the window controls, you should consider the child
    content before deciding whether the margins should be enabled.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Group` 定义了一个围绕子小部件（通过 `SetChild()` 分配）的框架，并带有标题（通过 `ui.NewGroup()` 传递）。组控件的外观在不同系统之间可能会有所不同；在某些系统上，它可能是一个围绕子小部件的框，而在其他系统上则可能不可见。与窗口控件一样，在决定是否启用边距之前，您应该考虑子内容。'
- en: '`Tab` is slightly different from the others, as it may contain multiple child
    controls—but only one is visible at a time. As there are multiple child controls,
    the method to add the child is `Append(string, Control)—`the first parameter is
    the title to be displayed on the tab and the second is the child for this new
    tab. To accommodate multiple child controls, the margin control is adapted also—you
    will need to call `SetMargined(int, bool)` where the first parameter is the tab
    index, and the latter is the usual parameter to turn margins on or off.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tab` 与其他控件略有不同，因为它可能包含多个子控件——但一次只能看到一个。由于存在多个子控件，添加子控件的方法是 `Append(string,
    Control)`——第一个参数是要在标签上显示的标题，第二个参数是此新标签的子控件。为了适应多个子控件，边距控件也进行了调整——您需要调用 `SetMargined(int,
    bool)`，其中第一个参数是标签索引，后者是用于打开或关闭边距的常规参数。'
- en: That's all of the controls that manage others, let's look at the details of
    the main widgets that an andlabs UI application is constructed from.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是管理其他控件的所有控件，让我们看看构成 andlabs UI 应用程序的主要小部件的详细信息。
- en: Widgets
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: 'The remaining widgets will be familiar to to any developer of desktop graphical
    applications, or indeed anyone who uses them. Provided here is a quick overview
    for the features or limitations of each:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的小部件对任何桌面图形应用程序的开发者或实际上使用它们的人来说都很熟悉。以下是每个小部件的功能或限制的快速概述：
- en: '`Button`: A standard `pushbutton` with a label, and an `onClicked` callback'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`: 一个带有标签的标准 `pushbutton`，并具有 `onClicked` 回调'
- en: '`Checkbox`: A toggled entry that is either checked or unchecked; an `onToggled`
    callback will trigger on change'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Checkbox`: 一个可切换的条目，可以是勾选的或未勾选的；在更改时将触发 `onToggled` 回调'
- en: '`Combobox`: A widget that provides a list of strings to select from'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Combobox`: 一个提供字符串列表以供选择的控件'
- en: '`DateTimePicker`: A field for entering date and/or time—the configuration is
    set by different constructor functions'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DateTimePicker`: 一个用于输入日期和/或时间的字段——配置是通过不同的构造函数设置的'
- en: '`Entry`: A single-line text-entry widget, which can be read-only; it supports
    an `onChanged` handler for change events'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry`: 一个单行文本输入控件，可以是只读的；它支持用于更改事件的 `onChanged` 处理程序'
- en: '`Label`: A simple read-only text component for annotating the user interface'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`: 一个简单的只读文本组件，用于注释用户界面'
- en: '`ProgressBar`: A horizontal bar to indicate progress; values range from 0 to
    100'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressBar`: 一个水平条，用于指示进度；值范围从 0 到 100'
- en: '`RadioButtons`: A control for presenting a list of options, such as check boxes,
    but where only one can be selected'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RadioButtons`: 一个用于展示选项列表的控件，如复选框，但只能选择一个'
- en: '`Separator`: A horizontal or vertical line to visually separate other controls'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Separator`: 一个水平或垂直线，用于在视觉上分隔其他控件'
- en: '`Slider`: A horizontal bar for selecting between the set min and max integer
    values by moving an indicator'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Slider`：一个水平条，可以通过移动指示器在设定的最小值和最大整数值之间选择'
- en: '`Spinbox`: An entry box for selecting an integer between the min and max values
    with the up and down buttons'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spinbox`：一个输入框，可以通过上下按钮选择介于最小值和最大值之间的整数'
- en: A noticeable omission on this list is menu or toolbar widgets; they are not
    included in andlabs UI toolkit at the time of writing. Next, we'll look at a potential
    workaround for menus (which unfortunately will not work for a toolbar) by accessing
    the underlying libui.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中一个明显的遗漏是菜单或工具栏小部件；在撰写本文时，它们不包括在andlabs UI工具包中。接下来，我们将查看一个可能的解决方案，通过访问底层的libui来处理菜单（不幸的是，这不会适用于工具栏）。
- en: Menu
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜单
- en: 'At the time of writing, andlabs UI doesn''t expose a menu API (despite `ui.NewWindow()`
    taking a `hasMenubar` parameter). There is a project underway to properly expose
    menu functionality to the Go API, but for now it''s only available if you work
    with the underlying libui C code. The menu defined in the C library can be accessed
    from a Go project by adding a little CGo code, such as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，andlabs UI没有公开菜单API（尽管`ui.NewWindow()`接受一个`hasMenubar`参数）。目前有一个项目正在进行中，旨在正确公开菜单功能到Go
    API，但到目前为止，它仅在你与底层的libui C代码一起工作时才可用。C库中定义的菜单可以通过添加一些CGo代码从Go项目中访问，例如以下代码：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code snippet sets up a click handler for a New menu item, and a quit handler
    for the Quit menu item (which is a special item due to macOS handling a quit menu
    item differently). Then we have a `loadMenu()` function, which sets up a File
    menu to which the child items are added, with a separator, and a currently-empty
    Help menu.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段为“新建”菜单项设置了一个点击处理程序，并为“退出”菜单项（由于macOS以不同的方式处理退出菜单项，因此它是一个特殊项）设置了一个退出处理程序。然后我们有一个`loadMenu()`函数，它设置了一个文件菜单，子项被添加到其中，有一个分隔符，以及一个目前为空的“帮助”菜单。
- en: 'To compile this code correctly will require the `cfuncs.go` file knowing where
    the header file and C library are stored. Before running this code make sure that
    the `CFLAGS` and `LDFLAGS` show the correct locations. While the code to build
    a menu is not very complicated, the CGo configuration and linking is rather complex,
    and as such, may not be recommended:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确编译此代码，需要`cfuncs.go`文件知道头文件和C库存储的位置。在运行此代码之前，请确保`CFLAGS`和`LDFLAGS`显示了正确的位置。虽然构建菜单的代码并不复杂，但CGo配置和链接相当复杂，因此可能不推荐这样做：
- en: '![](img/ddb3b8fe-6bac-4a65-9b06-c98d54710f62.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddb3b8fe-6bac-4a65-9b06-c98d54710f62.png)'
- en: Launching the menu example
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 启动菜单示例
- en: 'The result should look similar to this screenshot, which was taken on a Linux
    computer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于这张截图，它是在Linux计算机上拍摄的：
- en: '![](img/e8606215-3a10-45b4-b741-e9fe9b2824c0.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8606215-3a10-45b4-b741-e9fe9b2824c0.png)'
- en: The andlabs libui menu
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs libui菜单
- en: There is a complete menu project in the code repository for this book. Unfortunately,
    it isn't a cross-platform project and may not execute correctly on every operating
    system or version of Go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码仓库中有一个完整的菜单项目。不幸的是，它不是一个跨平台项目，可能无法在所有操作系统或Go版本上正确执行。
- en: Area and drawing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面积和绘图
- en: The `ui.Area` widget presents a canvas-like control—a surface that can be drawn
    on using Path and other drawing primitives. At the time of writing, these APIs
    are all part of the `ui` package, but it may soon move to `ui/draw` in an effort
    to separate them from the main controls API. An area can either be the size of
    the space it occupies or it can be larger, in which case it will be embedded in
    a scrollable control. The desired behavior is chosen based on whether `ui.NewArea(handler)`
    or `ui.NewScrollingArea(handler, width, height)` is called (where width and height
    are the desired content size).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ui.Area`小部件呈现一个类似于画布的控制元素——一个可以使用路径和其他绘图原语绘制的表面。在撰写本文时，这些API都是`ui`包的一部分，但它们可能很快就会移动到`ui/draw`，以便将它们与主要控件API分开。一个区域可以是它占据的空间的大小，也可以更大，在这种情况下，它将嵌入到一个可滚动的控件中。所需的行为基于是否调用`ui.NewArea(handler)`或`ui.NewScrollingArea(handler,
    width, height)`（其中width和height是期望的内容大小）。'
- en: The logic behind an area is `ui.AreaHandler`, the first parameter to either
    of the area constructor functions. Its `Draw(*ui.Area, *ui.AreaDrawParams)` function
    is invoked by the toolkit whenever the area needs to be redrawn, the first parameter
    being the area it's registered on and the second providing context, such as the
    clipping rectangle to be filled. As well as drawing the content of an area, the
    handler is responsible for handling the mouse and key events, with `MouseEvent(*ui.Area,
    *ui.AreaMouseEvent)` being called whenever a mouse event occurs and `KeyEvent(*ui.Area,
    *ui.AreaKeyEvent)` for any keyboard events.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 面积背后的逻辑是 `ui.AreaHandler`，它是面积构造函数的任意一个的第一个参数。它的 `Draw(*ui.Area, *ui.AreaDrawParams)`
    函数在工具包需要重新绘制面积时被调用，第一个参数是它注册的面积，第二个提供了上下文，例如要填充的剪辑矩形。除了绘制面积的内容外，处理器还负责处理鼠标和键盘事件，当鼠标事件发生时调用
    `MouseEvent(*ui.Area, *ui.AreaMouseEvent)`，对于任何键盘事件调用 `KeyEvent(*ui.Area, *ui.AreaKeyEvent)`。
- en: 'To look more closely at the drawing capabilities, let''s run a little code.
    In this example, we are creating a new `ui.AreaHandler` type (named `areaHandler`)
    that implements all the required functions from the interface. The only method
    of interest is the `Draw()` call, which is included here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更仔细地查看绘图功能，让我们运行一段小代码。在这个例子中，我们创建了一个新的 `ui.AreaHandler` 类型（命名为 `areaHandler`），它实现了接口中所有必需的函数。唯一感兴趣的方法是
    `Draw()` 调用，它包含在这里：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is split into two parts: first we set up a `ui.Path` and then we
    use the path to draw. The path (named p) is set to be 10 pixels inside the clip
    area that is being drawn—this is done so the canvas background is demonstrated
    (the drawing area is cleared before every `Draw()` call). Next, we use this path
    to `Fill()` and `Stroke()` within the draw context (`dp.Context`). The call to
    `Fill()` specifies a Brush that is a solid orange color of full opacity (`A` in
    the preceding code stands for alpha). Then, we call `Stroke()` using the same
    path (this will draw a line around the filled box). We are asking for a four-pixel-wide
    dashed line with round caps—this time with a semi-transparent blue color.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码分为两部分：首先我们设置一个 `ui.Path`，然后我们使用路径进行绘制。路径（命名为 p）被设置为在正在绘制的剪辑区域内部 10 像素处——这样做是为了演示画布背景（在每次
    `Draw()` 调用之前都会清除绘图区域）。接下来，我们使用这个路径在绘图上下文 (`dp.Context`) 中进行 `Fill()` 和 `Stroke()`。`Fill()`
    调用指定了一个不透明的橙色画笔（前述代码中的 `A` 代表 alpha）。然后，我们使用相同的路径调用 `Stroke()`（这将绘制一个围绕填充框的线）。我们要求一个四像素宽的虚线，带有圆形端点——这次使用半透明的蓝色颜色。
- en: 'To draw this to screen, we need to configure a window to have a `ui.Area` control
    that expands to fill the window, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此绘制到屏幕上，我们需要配置一个窗口，使其具有一个 `ui.Area` 控制器，该控制器扩展以填充窗口，如下所示：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you put all this together (or run the `chapter5/draw` example), you should
    see something like the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些放在一起（或运行 `chapter5/draw` 示例），你应该会看到以下截图类似的内容：
- en: '![](img/687129fa-f84e-4a76-b986-c77a862d0c7b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/687129fa-f84e-4a76-b986-c77a862d0c7b.png)'
- en: Andlabs UI draw functions
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Andlabs UI 绘图函数
- en: Notice how the transparent blue is outlining the orange—filled rectangle, and
    also displaying the rectangle and the background from beneath. If we reversed
    the order of the `Fill()` and `Stroke()` calls, the orange rectangle would completely
    cover half of the dashed outline.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意透明蓝色是如何勾勒出橙色填充的矩形，并且也显示了矩形和下面的背景。如果我们颠倒 `Fill()` 和 `Stroke()` 调用的顺序，橙色矩形将完全覆盖虚线轮廓的一半。
- en: Building a user interface
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Now that we've looked at the API capabilities of andlabs UI, let's look at building
    a graphical application of some complexity. For this section, we will follow the
    design of the "GoMail" application introduced in the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk - Building Graphical Windows Applications*. The design presented was created
    using the Qt Creator tool which, while being a good fit for developing applications
    with the Walk library, is not a direct fit for all GUI toolkits. The multiple-platform
    approach of andlabs UI to use the native widgets means that some components are
    not available, but some can be created by combining simple widgets to form more
    complex components.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 andlabs UI 的 API 功能，让我们看看如何构建一个具有一定复杂性的图形应用程序。对于本节，我们将遵循在 [第 4 章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)
    中介绍的 "GoMail" 应用程序的设计，即 *Walk - 构建图形窗口应用程序*。所提出的设计是使用 Qt Creator 工具创建的，虽然它非常适合使用
    Walk 库开发应用程序，但并不是所有 GUI 工具包的直接选择。andlabs UI 的多平台方法使用原生小部件意味着某些组件不可用，但可以通过组合简单的小部件来创建更复杂的组件。
- en: With that in mind, let's have a quick look at how the different platforms' styling
    capabilities may affect the application we are building. After exploring styles,
    we will start implementing the basic layout of our application and add the controls
    and features to demonstrate the user interface capabilities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们快速看一下不同平台的样式功能可能会如何影响我们正在构建的应用程序。在探索样式之后，我们将开始实现应用程序的基本布局，并添加控件和功能来展示用户界面能力。
- en: Style
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: The styling of an andlabs-UI-based application is platform-specific and is normally
    set by the operating system. Some support user-based customization, which can
    subtly or vastly affect the look and feel of your application—so it's important
    to consider the possible variations during your application design and testing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 基于andlabs-UI的应用程序样式是平台特定的，通常由操作系统设置。一些支持基于用户的自定义，这可能会微妙或极大地影响应用程序的外观和感觉——因此在应用程序设计和测试期间考虑可能的变体是很重要的。
- en: When run on Microsoft Windows, the toolkit in use is Common Controls (discussed
    in the [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building
    Graphical Windows* *Applications*). Essentially, the controls will look somewhat
    different across versions of Windows, which helps the applications blend in with
    the evolving desktop's look and feel. Most user-customization options within Windows
    are focused on the newer ("Universal") applications, but may show some color changes
    within applications built using Common Controls (and therefore with andlabs UI).
    Be sure to consider which versions of Windows you intend to support when testing
    your application layout and design.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Microsoft Windows上运行时，使用的工具包是通用控件（在第4章[3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml]中讨论，*构建图形窗口应用程序*）。基本上，控件在Windows的不同版本中看起来会有所不同，这有助于应用程序与不断发展的桌面外观和感觉相融合。Windows中的大多数用户自定义选项都集中在较新的（“通用”）应用程序上，但可能会在使用通用控件（因此与andlabs
    UI相关）构建的应用程序中显示一些颜色变化。在测试你的应用程序布局和设计时，务必考虑你打算支持的Windows版本。
- en: Apple also evolves their macOS widget toolkit look and feel over time, though
    most recent versions (since OS X 10.5—released in 2007) remain largely consistent
    in the layout and sizing of components. Applications running on andlabs UI in
    the macOS environment should remain fairly consistent across all supported versions—unless
    users enable the new `dark mode` in macOS Mojave (released in late 2018). Following
    this new user-configuration option, the user interface may be presented in a light
    (default) or dark mode to match the user's preference. Application designers should
    consider this and ensure their content presents well in both configurations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司也在随着时间的推移不断进化他们的macOS小部件工具包的外观和感觉，尽管大多数最新版本（自2007年发布的OS X 10.5以来）在组件的布局和尺寸上保持大体一致。在macOS环境中运行andlabs
    UI的应用程序应该在整个支持的版本中保持相当一致——除非用户在2018年底发布的macOS Mojave中启用了新的“深色模式”。随着这个新的用户配置选项的出现，用户界面可能会以亮色（默认）或深色模式呈现，以匹配用户的偏好。应用程序设计师应考虑这一点，并确保他们的内容在两种配置中都能良好展示。
- en: 'The widgets used within andlabs UI adapt correctly to this new style, but custom
    content may not. There is currently no API to detect which color mode is being
    used and so the easiest approach is to either limit your interface to standard
    controls or to pick a color scheme that will look suitable in either mode:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在andlabs UI中使用的组件能够正确适应这种新样式，但自定义内容可能不行。目前还没有API来检测正在使用哪种颜色模式，因此最简单的方法是限制你的界面使用标准控件，或者选择一个在两种模式下都看起来合适的颜色方案：
- en: '![](img/3a42f309-39f0-4c2c-a316-42915b4742eb.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a42f309-39f0-4c2c-a316-42915b4742eb.jpg)'
- en: Side- by-side comparison of macOS light and dark modes (copyright IDG UK via
    MacWorld)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: macOS浅色和深色模式的并排比较（版权所有：IDG UK via MacWorld）
- en: In Linux, andlabs UI toolkit is built upon the GTK+ widget set, which is designed
    to allow theming and style adjustments. While these types of themes can't substantially
    change the layout of components, they can significantly impact the sizing, padding,
    and colouring that a theme provides, and so affect the flow and sizing of an application's
    user interface. This can present a challenge for software developers who want
    to support the inherent flexibility in their programs. There are over a thousand
    GTK+ themes, and many can be found on the Gnome Look website: [https://www.gnome-look.org/browse/cat/135/ord/top/](https://www.gnome-look.org/browse/cat/135/ord/top/).
    GTK+ Theming is explored further in [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml),
    *Go-GTK - Multiple Platforms with GTK*. where we take a deeper look at the GTK+
    toolkit.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，andlabs UI工具包建立在GTK+小部件集之上，该小部件集旨在允许主题和样式调整。虽然这些类型的主题不能实质性地改变组件的布局，但它们可以显著影响主题提供的尺寸、填充和着色，从而影响应用程序用户界面的流动和尺寸。这对于希望在其程序中支持固有灵活性的软件开发者来说可能是一个挑战。GTK+有超过一千个主题，许多可以在Gnome
    Look网站上找到：[https://www.gnome-look.org/browse/cat/135/ord/top/](https://www.gnome-look.org/browse/cat/135/ord/top/)。GTK+主题在[第6章](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml)，*Go-GTK
    - 多平台与GTK*中进一步探讨，我们更深入地研究了GTK+工具包。
- en: 'These two screenshots compare a popular light and dark theme—clearly they can
    change more than simply the color scheme:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个截图比较了一个流行的浅色和深色主题——显然它们可以改变不仅仅是配色方案：
- en: '| ![](img/cd0e0e02-5fa7-40ea-8fc5-998a2ff064fc.png) | ![](img/f199d48b-6a6d-4666-b381-227a0050350a.png)
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ![图片1](img/cd0e0e02-5fa7-40ea-8fc5-998a2ff064fc.png) | ![图片2](img/f199d48b-6a6d-4666-b381-227a0050350a.png)
    |'
- en: GTK+ SuperFlat and Vertex themes compared
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+ SuperFlat 和 Vertex 主题比较
- en: Each of these platform themes and configuration options can have an impact on
    the look and feel of the resulting application. If you're planning to support
    these visual styles, the best strategy is to avoid custom controls, and draw features
    and let the native controls adapt appropriately. If your application requires
    custom content or rendering, it will be important to choose a color palette that
    works well across many different themes or styles.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些平台主题和配置选项中的每一个都可能影响最终应用程序的外观和感觉。如果您计划支持这些视觉风格，最佳策略是避免自定义控件，绘制功能并让原生控件适当地适应。如果您的应用程序需要自定义内容或渲染，选择一个适用于许多不同主题或样式的调色板将非常重要。
- en: Layout
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: Layouts in andlabs UI are composed of horizontal and vertical boxes, each of
    which contain a list of child elements, which may be stretched or static. Horizontal
    boxes are laid out on a single row, and every control within has the same height
    (that is, matching the height of the tallest element). In a vertical box, the
    controls are laid out in a single column and every element is the same width (being
    that of the widest item). If the container is larger than the minimum required
    to fit the items, any extra space is shared between any element that was appended
    as *stretchy—*if none stretch, the items will remain left- or top-aligned.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: andlabs UI中的布局由水平和垂直的盒子组成，每个盒子都包含一个子元素列表，这些元素可以是可拉伸的或静态的。水平盒子在一个单独的行上布局，盒子内的每个控件都有相同的高度（即与最高元素的高度相匹配）。在垂直盒子中，控件以单列布局，每个元素都有相同的宽度（即最宽项的宽度）。如果容器比容纳项目所需的最小尺寸大，任何额外的空间都将由任何被附加为*可拉伸*的元素共享——如果没有可拉伸的元素，项目将保持左对齐或顶对齐。
- en: To provide a visual separation between groups of elements, we can use the `ui.Separator`
    control, which draws a thin line horizontally or vertically*—*remember to mark
    it as not stretchy within the box layout. If you wish to introduce space within
    your layout without the visual line, you can create a blank label (using `ui.Label("")`)
    and set its stretchy parameter to `true` when appended to a box.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在元素组之间提供视觉分隔，我们可以使用`ui.Separator`控件，它在水平或垂直方向上绘制一条细线——记得在盒子布局中将其标记为不可拉伸。如果您希望在布局中引入空间而不使用视觉线，可以创建一个空白标签（使用`ui.Label("")`），并将其附加到盒子时将可拉伸参数设置为`true`。
- en: Main email window
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要电子邮件窗口
- en: The main layout box of our email client, `content`, is a horizontal box created
    with `ui.NewHorizontalBox()`, which contains the email list on the left (the first
    item to be appended), a vertical `ui.Separator`, and the detail view on the right
    (as it was the list item to be appended). The email list is composed of a `ui.Group` named
    `inbox`, which includes the `Inbox` title; note that our title label is followed
    by a series of spaces—this helps to create a more spacious layout in our application.
    Within this, we have a vertical `ui.Box`, which has a `ui.Label` for each of our
    emails.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们电子邮件客户端的主要布局框`content`是一个使用`ui.NewHorizontalBox()`创建的水平框，其中包含左侧的电子邮件列表（第一个要附加的项目）、一个垂直的`ui.Separator`以及右侧的详细视图（因为它是要附加的项目列表项）。电子邮件列表由一个名为`inbox`的`ui.Group`组成，包括`Inbox`标题；请注意，我们的标题标签后面跟着一系列空格——这有助于在我们的应用程序中创建更宽敞的布局。在这个布局中，我们有一个垂直的`ui.Box`，其中每个电子邮件都有一个`ui.Label`。
- en: 'As there is no grid layout available, the `detail` view is composed of various
    boxes. You can see that the `meta` box is a horizontal layout of two child instances
    of a vertical `ui.Box`: the first containing a vertical box of labels, the second
    being the list of values that will be filled later—the padding will provide a
    suitable gap between them.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有可用的网格布局，详细视图由各种框组成。你可以看到`meta`框是两个垂直`ui.Box`子实例的水平布局：第一个包含标签的垂直框，第二个是稍后将要填充的值的列表——填充将提供它们之间的合适间隔。
- en: 'As with the *hello world* example, we create a window with the `GoMail` title,
    a requested size, and set `false` for the `hasMenu` parameter. At the end of the
    sample, we set the content of the window and `Show()` it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与*hello world*示例一样，我们创建了一个带有`GoMail`标题、请求的大小，并将`hasMenu`参数设置为`false`的窗口。在示例的末尾，我们设置窗口的内容并调用`Show()`：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By dropping that code into the same `main()` wrapper that we used in the *hello
    world* application, we can run this user interface to see how the layout works.
    You should see something like the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将那段代码放入我们在*hello world*应用程序中使用的相同`main()`包装器中，我们可以运行这个用户界面以查看布局是如何工作的。你应该会看到以下截图：
- en: '![](img/1954760c-e09d-4adb-a98e-dc20ebdf861c.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1954760c-e09d-4adb-a98e-dc20ebdf861c.png)'
- en: The main email browser layout
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 主要电子邮件浏览器布局
- en: 'As you can see, we weren''t able to use the splitter from the Walk example,
    but have simulated that look using `ui.Separator`. Whilst the code is the same,
    they can behave differently across different operating systems, like the following
    expanded vertical `ui.Box` on macOS:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们无法使用Walk示例中的拆分器，但使用`ui.Separator`模拟了那种外观。虽然代码相同，但它们在不同操作系统上可能表现不同，如下所示macOS上扩展的垂直`ui.Box`：
- en: '![](img/dc748417-5991-4960-b9e5-236f5c18d369.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc748417-5991-4960-b9e5-236f5c18d369.png)'
- en: On macOS, the layout is different but will improve as we add content
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上，布局不同，但随着我们添加内容将会改进
- en: The tree, or list, component on the left is a simple collection of labels at
    this stage, as there is no standard list component provided. Lastly, we have not
    rendered the labels in bold. This is possible, but only by using the draw API,
    which significantly complicates the code. Additionally, the use of drawing can
    cause parts of the user interface to vary from the loaded platform theme; for
    this purpose, we have stuck with the standard `ui.Label` component. In the preceding
    screenshot, you can see how different platforms have very different layouts at
    this stage—this will even out as we add more content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的树形或列表组件在这个阶段只是一个简单的标签集合，因为没有提供标准的列表组件。最后，我们没有将标签加粗。这是可能的，但只能通过使用draw API，这将显著复杂化代码。此外，使用绘图可能导致用户界面的某些部分与加载的平台主题不同；为此，我们坚持使用标准的`ui.Label`组件。在先前的屏幕截图中，你可以看到在这个阶段不同平台具有非常不同的布局——随着我们添加更多内容，这将趋于一致。
- en: Email compose dialog
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件编写对话框
- en: 'The layout of our compose dialog window is slightly more basic: a vertical
    box named `layout` manages the stack of controls into which the input elements
    are appended. We need to create another box, in horizontal arrangement, to place
    the To label before the input field; make sure to turn the padding on to provide
    some spacing. Each of the text input boxes is created using `ui.NewEntry()`, which
    creates a simple one-line input field. Unfortunately, at the time of writing,
    there was no multi-line input field—a constraint that does not have an obvious
    workaround at this stage. The next release of the UI library will have a new `ui.MultilineEntry`,
    which will provide this functionality.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的对话框窗口布局稍微简单一些：一个名为 `layout` 的垂直框管理着输入元素附加的控件堆栈。我们需要创建另一个水平排列的框，将“收件人”标签放置在输入字段之前；确保开启填充以提供一些间隔。每个文本输入框都是使用
    `ui.NewEntry()` 创建的，它创建了一个简单的单行输入字段。不幸的是，在撰写本文时，还没有多行输入字段——在当前阶段，这个限制没有明显的解决方案。UI库的下一个版本将有一个新的
    `ui.MultilineEntry`，这将提供这个功能。
- en: 'The last of the compose layout is the second horizontal box, `buttonBox`, which
    uses the familiar empty label trick to cause the Cancel and Send buttons to be
    right-aligned within the available space:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 编写布局的最后一个是第二个水平框，`buttonBox`，它使用熟悉的空标签技巧使取消和发送按钮在可用空间内右对齐：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the preceding code, it uses the same `ui.NewWindow()` as
    the main email browser code—this is because andlabs UI doesn''t differentiate
    between types of windows. Various dialog windows do exist but they are predefined
    for specific purposes, and so for our custom dialog, we will use a normal window.
    Therefore, you can test this code easily by using the same `main()` method as
    the previous code examples. Once run, you should see something similar to these
    screenshots:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，它使用了与主电子邮件浏览器代码相同的 `ui.NewWindow()` —这是因为andlabs UI不区分窗口类型。各种对话框窗口确实存在，但它们是为特定目的预定义的，因此对于我们的自定义对话框，我们将使用普通窗口。因此，你可以通过使用与之前的代码示例相同的
    `main()` 方法轻松测试此代码。一旦运行，你应该会看到类似于以下截图的内容：
- en: 'The email compose window:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件编写窗口：
- en: '![](img/8e5c1e80-b4dd-4b42-8472-d89e9f90d72f.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e5c1e80-b4dd-4b42-8472-d89e9f90d72f.png)'
- en: 'Email compose on macOS:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: macOS上的电子邮件编写：
- en: '![](img/1a7f13b2-19f2-4ca7-bc67-f0423ef2cb31.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a7f13b2-19f2-4ca7-bc67-f0423ef2cb31.png)'
- en: 'Loaded on a Windows computer:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows计算机上加载：
- en: '![](img/38aa675b-9541-4608-b100-671646a49f31.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38aa675b-9541-4608-b100-671646a49f31.png)'
- en: Toolbar and menu
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏和菜单
- en: 'Unfortunately there is currently no API support for menu or toolbar features
    in andlabs UI. Instead, we will simulate a toolbar by using a horizontal box,
    buttons, and a separator, which should provide the desired effect. As the separator
    can be very thin, we are padding it with an extra space on either side:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，目前andlabs UI中没有API支持菜单或工具栏功能。相反，我们将通过使用水平框、按钮和分隔符来模拟工具栏，这应该会提供所需的效果。由于分隔符可以非常细，我们在其两侧添加了额外的空间：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have specified that no buttons, separators, or spacers should
    expand, so the buttons will be left-aligned on the bar. This behavior could be
    changed if you'd prefer the buttons to spread out, by passing `true` for the `stretchy` parameter,
    for example, when appending the empty `ui.Label` controls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，我们指定了没有任何按钮、分隔符或间隔应该扩展，因此按钮将左对齐在栏上。如果你希望按钮展开，可以通过传递 `true` 给 `stretchy`
    参数来改变这种行为，例如，在附加空的 `ui.Label` 控件时。 '
- en: 'We need to add this to the window—a new vertical box, called layout, is added
    and the previous content is packed underneath the toolbar. To provide some separation
    between this toolbar and the main content, we''ve called `SetPadded(true)`. Notice
    that the toolbar and space don''t stretch (vertically), but the content layout
    does:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将此添加到窗口中——添加了一个新的垂直框，称为 `layout`，并将之前的内容打包在工具栏下方。为了在工具栏和主要内容之间提供一些间隔，我们调用了
    `SetPadded(true)`。请注意，工具栏和空间（垂直方向）不会拉伸，但内容布局会：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By combining this code with the main layout described, you should get an application
    that''s approaching the look of the email user interface that we designed in [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此代码与前面描述的主要布局相结合，你应该会得到一个接近我们在[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，“漫步
    - 构建图形窗口应用程序”中设计的电子邮件用户界面的应用程序：
- en: '![](img/3e9fb07f-cbd3-4f7b-939e-54bf9b637a90.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e9fb07f-cbd3-4f7b-939e-54bf9b637a90.png)'
- en: A box of buttons is added to simulate a toolbar
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个按钮框来模拟工具栏
- en: 'Notice how the look can vary between different operating systems—the following
    is running on Microsoft Windows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意外观如何在不同的操作系统之间有所不同——以下是在Microsoft Windows上运行的：
- en: '![](img/40acca23-2adf-4d8c-8236-a360b5e915bf.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40acca23-2adf-4d8c-8236-a360b5e915bf.png)'
- en: The addition of our toolbar box on Windows
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上添加我们的工具栏框
- en: Communicating with the GUI
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GUI通信
- en: Now that the basic layout is coded, we will add functionality to present some
    data from a mock email server. As with the Walk example, we will load the model
    definitions and a test email server from the `github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client`
    package.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本布局已经编码完成，我们将添加功能以展示从模拟电子邮件服务器获取的一些数据。与Walk示例一样，我们将从`github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/client`包中加载模型定义和测试电子邮件服务器。
- en: 'First of all, let''s write the code to load content from our model into the
    user interface. We will create a `SetEmail(EmailMessage)` function that sets the
    content of an email into the user interface. To help with converting from `client.Email`
    and `time.Time` to `string`, we will use the helper `ToEmailString()` and `DateString()`
    functions. This function will be called during interface load and also whenever
    we change the selected email:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写代码将模型内容加载到用户界面中。我们将创建一个`SetEmail(EmailMessage)`函数，该函数将电子邮件的内容设置到用户界面中。为了帮助将`client.Email`和`time.Time`转换为`string`，我们将使用辅助函数`ToEmailString()`和`DateString()`。此函数将在界面加载期间调用，并且每次更改所选电子邮件时也会调用：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we should update the email list. Instead of two dummy emails in the list,
    we create a new method that will iterate over all emails and add an item for each.
    To be able to set the email content when clicked, we have to move from `ui.Label`
    to `ui.Button` (no other andlabs UI standard controls have an `OnClicked` callback).
    As you can see, we set a new function for each button added, which sets the displayed
    email by calling the `setEmail()` function. The `captured` variable is required
    to avoid the for loop''s re-definition of `email` in each iteration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该更新电子邮件列表。在列表中不再使用两个虚拟电子邮件，而是创建一个新的方法，该方法将遍历所有电子邮件并为每个电子邮件添加一个条目。为了能够在点击时设置电子邮件内容，我们必须从`ui.Label`移动到`ui.Button`（没有其他andlabs
    UI标准控件有`OnClicked`回调）。正如你所见，我们为每个添加的按钮设置了一个新函数，该函数通过调用`setEmail()`函数来设置显示的电子邮件。`captured`变量是必需的，以避免在每次迭代中重新定义for循环的`email`：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To invoke these new functions on load, we need to update the `main()` method.
    First, a new server is created with `client.NewTestServer()`, and then the functions
    we wrote are invoked with the appropriate information from the server:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在加载时调用这些新功能，我们需要更新`main()`方法。首先，使用`client.NewTestServer()`创建一个新的服务器，然后使用从服务器获取的适当信息调用我们编写的函数：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last step for the main view is to open the compose window when the user
    clicks on the New button. This is easily accomplished with another `OnClicked`
    handler, which builds and shows the secondary `ui.Window`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 主视图的最后一步是在用户点击新建按钮时打开撰写窗口。这可以通过另一个`OnClicked`处理程序轻松完成，该处理程序构建并显示二级`ui.Window`：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we can send an email, we need to construct one from the controls in
    the compose user interface. This new `CreateMessage()` function simply gathers
    the information entered by the user and encapsulates it in a new `client.EmailMessage` that''s
    ready for sending:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够发送电子邮件之前，我们需要从撰写用户界面中的控件构造一个电子邮件。这个新的`CreateMessage()`函数简单地收集用户输入的信息，并将其封装在一个新的`client.EmailMessage`中，该消息已准备好发送：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Lastly, we want the Cancel and Send buttons to function as expected. Both should
    close the compose window, but the Send button should first attempt to send the
    email. We add simple `OnClicked` handlers for these buttons, attached to the buttons
    which are appended to the `buttonBox` already created in the UI code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望取消和发送按钮能按预期工作。两个按钮都应该关闭撰写窗口，但发送按钮应首先尝试发送电子邮件。我们在UI代码中已经创建的`buttonBox`上为这些按钮添加了简单的`OnClicked`处理程序：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once all of this code is put together, you can run it, and should see an application
    that looks something like these screenshots:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将所有这些代码组合在一起，你就可以运行它，应该会看到一个看起来像这些屏幕截图的应用程序：
- en: 'The GoMail interface with test data loaded running on Linux:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载测试数据后运行的GoMail接口在Linux上：
- en: '![](img/f04eeffe-bafc-4d02-a525-e022b2fb5aa1.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f04eeffe-bafc-4d02-a525-e022b2fb5aa1.png)'
- en: 'The same interface with a different theme (Minwaita):'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同主题（Minwaita）的相同界面：
- en: '![](img/aa407337-87bf-4a7a-8e3c-46cc957e333e.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa407337-87bf-4a7a-8e3c-46cc957e333e.png)'
- en: 'The completed GoMail interface running on macOS:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上运行的完成后的GoMail界面：
- en: '![](img/77223f1f-3e44-4c64-922e-d5f0e9fba2a3.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77223f1f-3e44-4c64-922e-d5f0e9fba2a3.png)'
- en: 'Running on macOS dark mode:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 暗黑模式下运行：
- en: '![](img/f699006a-9c7a-45e4-8411-a10cf778b52a.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f699006a-9c7a-45e4-8411-a10cf778b52a.png)'
- en: 'The GoMail interface running on windows 10:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 10 上运行的 GoMail 接口：
- en: '![](img/13203d19-894a-44e9-9e00-3bf360273dfc.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13203d19-894a-44e9-9e00-3bf360273dfc.png)'
- en: Background processing
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台处理
- en: As you may have realized from the first line of andlabs UI code (`ui.Main(func()
    { ... })`), multithreading is something that needs to be considered when building
    using this API. This is due to the fact that most of the toolkits it integrates
    with will require graphical updates to all execute on the same thread (often,
    the main application thread). The andlabs UI aims to hide this complexity by managing
    the threads internally and provides helper methods to manage this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从 andlabs UI 代码的第一行（`ui.Main(func() { ... })`）中可能已经意识到的，在构建此 API 时需要考虑多线程。这是因为它集成的大多数工具包都要求所有图形更新都在同一线程上执行（通常是主应用程序线程）。andlabs
    UI 通过内部管理线程并提供辅助方法来管理这些复杂性。
- en: 'As a result of this design, any user interface updates outside of the `ui.Main()`
    setup (or callbacks on controls created there) must be passed to the `ui.QueueMain()` method
    in the form of a function, as with the initial setup. This allows andlabs UI code
    to process the updates on the appropriate thread for the current framework. The
    following code illustrates how a label''s text could be changed as the result
    of some background processing:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种设计，任何在 `ui.Main()` 设置之外的用户界面更新（或在该处创建的控件上的回调）都必须以函数的形式传递给 `ui.QueueMain()`
    方法，就像初始设置一样。这允许 andlabs UI 代码在当前框架的适当线程上处理更新。以下代码说明了标签文本如何作为某些后台处理的结果而更改：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Callbacks such as `OnClicked()` and `OnClosing()` also take a `func()` parameter,
    just as the `ui.QueueMain()` function does. This code will automatically be executed
    on the correct thread, so there is no additional complexity to worry about.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数如 `OnClicked()` 和 `OnClosing()` 也像 `ui.QueueMain()` 函数一样接受一个 `func()` 参数。此代码将在正确的线程上自动执行，因此无需担心额外的复杂性。
- en: Example
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: To look at the impact of background threads, we will add another feature to
    the GoMail application—updating the user interface when a new email arrives. To
    enable this, we must listen to the `Incoming` channel that our `client.EmailServer` type
    defines.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看后台线程的影响，我们将向 GoMail 应用程序添加另一个功能——当新电子邮件到达时更新用户界面。为了启用此功能，我们必须监听 `client.EmailServer`
    类型定义的 `Incoming` 通道。
- en: 'First, we create a function that will handle incoming email. This is simply
    a wrapper to a new method, `appendEmail(*client.EmailMessage)`, that handles adding
    new items to the email list. But it must create a wrapping `func()` and pass it
    to `ui.QueueMain` so that the code executes on the correct thread:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个处理传入电子邮件的函数。这只是一个对新的方法 `appendEmail(*client.EmailMessage)` 的包装，该方法负责将新项目添加到电子邮件列表中。但必须创建一个包装的
    `func()` 并将其传递给 `ui.QueueMain`，以便代码在正确的线程上执行：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we add a little more code to our `main()` method to listen for incoming
    emails from `client.EmailServer`. The following code requests the incoming channel
    from the server model and then loops over any emails that are communicated through
    the channel, triggering our handler for any that arrive:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在 `main()` 方法中添加一些额外的代码来监听来自 `client.EmailServer` 的传入电子邮件。以下代码从服务器模型请求传入通道，然后遍历通过该通道通信的任何电子邮件，触发任何到达的处理程序：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these updates running, the same client will trigger a new email to appear
    after 10 seconds. With Go, the concurrency is simple to handle, and the preceding
    code shows how andlabs UI allows us to benefit from that in the handling of our
    user interface.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更新运行的同时，相同的客户端将在 10 秒后触发一个新的电子邮件出现。使用 Go，并发处理很简单，前面的代码显示了 andlabs UI 如何使我们能够从处理用户界面的并发中受益。
- en: Challenges with multiple native GUIs
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个原生 GUI 的挑战
- en: In this chapter, we've seen how a single code base can create applications that
    work with native widget toolkits across multiple platforms. This is a very powerful
    approach to quickly develop graphical apps that are consistent with the platform
    style to provide a familiar user experience. However, this approach also has challenges
    you may need to overcome for your project.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用单个代码库创建可以在多个平台上与原生小部件工具包协同工作的应用程序。这是一种非常强大的快速开发与平台风格一致、提供熟悉用户体验的图形应用程序的方法。然而，这种方法也可能会对你的项目带来挑战，你可能需要克服这些挑战。
- en: Consistent style
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致的风格
- en: While it may not be obvious that a consistent style is important when choosing
    to adapt to the native toolkit, there are many parameters involved in style and
    application design. Does your design team or product specialist have defined standards
    or approaches to user experience that they wish to apply across all applications
    and platforms? Are there brand guidelines that you should be including in your
    interface design?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在决定适应本地工具包时，一致的风格可能并不明显很重要，但在风格和应用程序设计中涉及许多参数。你们的设计团队或产品专家是否有定义的标准或方法，希望应用于所有应用程序和平台？是否应该将品牌指南包含在界面设计中？
- en: Brand styles
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌风格
- en: As andlabs UI is a toolkit that aims to provide an abstraction to standard widgets
    (and therefore using the current platform's look and feel), customization options
    are limited. The only facility to introduce custom elements is the `ui.Area` widget
    and the draw features we explored. This enables a company font or logo to be drawn
    (support for loading images is said to be coming in a later version) at a certain
    location in the interface.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 andlabs UI 是一个旨在提供对标准小部件抽象的工具包（因此使用当前平台的视觉和感觉），定制选项有限。引入自定义元素的唯一方式是 `ui.Area`
    小部件和我们所探索的绘图功能。这使公司字体或标志可以在界面中的某个位置绘制（据说在稍后的版本中将支持加载图像）。
- en: If you are looking for further abilities to customize or theme the applications
    you are building, then andlabs UI may not be the right solution for your project.
    It's probably better to explore GTK+ or Qt (which we cover in [Chapter 6](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml), *Go-GTK
    - Multiple Platforms with GTK*, and [Chapter 7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml),
    *Go-Qt - Multiple Platforms with QT*) or skip to Part 3 ([Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    - Experimental Go GUI API*, [Chapter 9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml), *nk
    - Nuklear for Go* and [Chapter 10](2476a1b6-0915-496b-8290-7a673f533aca.xhtml),
    *Fyne - Material Design based GUI*) and read about other approaches to graphical
    application design.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找进一步定制或主题化您正在构建的应用程序的能力，那么 andlabs UI 可能不是您项目的正确解决方案。可能更好的是探索 GTK+ 或 Qt（我们在第
    6 章 [Go-GTK - 多平台与 GTK](6becd530-0233-44fa-adbb-6a23a895d9e7.xhtml) 和第 7 章 [Go-Qt
    - 多平台与 QT](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml) 中进行了介绍），或者跳转到第 3 部分（第 8
    章 [Shiny - 实验性的 Go GUI API](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)，第 9 章
    [nk - Nuklear for Go](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml) 和第 10 章 [Fyne
    - 基于 Material Design 的 GUI](2476a1b6-0915-496b-8290-7a673f533aca.xhtml)），并了解其他图形应用程序设计的途径。
- en: User experience
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户体验
- en: Using a single API does not guarantee consistency across multiple operating
    systems. The toolkits used may have different layout defaults, with different
    padding or alignment, for example. The andlabs UI (and the underlying andlabs
    `libui`) API is designed to provide an application that's as close to the OS defaults
    as possible. If you have specific requirements that should be met regarding the
    user interface appearance (other than the style), such as layout or alignment,
    you may need to write special code. Using Go's approach to build tags and load
    different code for different operating systems, you can adapt your code to behave
    slightly differently on different platforms.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个 API 并不能保证在多个操作系统上的一致性。所使用的工具包可能有不同的布局默认值，例如不同的填充或对齐。The andlabs UI（以及其底层的
    andlabs `libui`）API 被设计为提供尽可能接近操作系统默认值的程序。如果您有关于用户界面外观（除了风格之外）的具体要求，例如布局或对齐，您可能需要编写特殊的代码。使用
    Go 的构建标签方法，为不同的操作系统加载不同的代码，您可以使您的代码在不同平台上略有不同地表现。
- en: If we look at the previous *hello world* example, we can update the code to
    adjust the quit button's layout on different platforms. Here, we will load a right-aligned
    button for macOS, but leave it as full width for other systems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看之前的 *hello world* 示例，我们可以更新代码以调整不同平台上的退出按钮布局。在这里，我们将为 macOS 加载一个右对齐的按钮，但其他系统则保持全宽。
- en: 'The code to create the Quit button is removed from `hello.go` and replaced
    with a line that calls into a new `layoutQuit()` function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建退出按钮的代码已从 `hello.go` 中移除，并替换为调用新的 `layoutQuit()` 函数的行：
- en: '[PRE17]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In a new file, called `custom_other.go`, we move the previous button definition
    into a new `layoutQuit()` function. Additionally, a conditional build comment
    is added at the top to ensure that this file is not included for macOS (darwin).
    Note that the text has also changed to Exit, to illustrate how platforms can be
    adapted:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`custom_other.go`的新文件中，我们将之前的按钮定义移动到一个新的`layoutQuit()`函数中。此外，在顶部添加了一个条件编译注释，以确保此文件不包括macOS（darwin）。请注意，文本也已更改为退出，以说明平台如何进行适配：
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s all pretty straightforward; then we add another file, named `custom_darwin.go`,
    where we define the alternative behavior. In this file, we don''t need the build
    definition, as the filename provides that for us. In this implementation, we create
    a horizontal `ui.Box` with the Quit button padded to the right using an empty,
    stretchy `ui.Label`, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很直接；然后我们添加另一个名为`custom_darwin.go`的文件，在那里我们定义了替代行为。在这个文件中，我们不需要构建定义，因为文件名为我们提供了这个信息。在这个实现中，我们创建了一个带有退出按钮并使用一个空的可拉伸`ui.Label`向右填充的水平`ui.Box`，如下所示：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using this approach, it''s possible to adapt your user interface to appear
    slightly differently on specific platforms. This is a useful approach if you need
    to have different widget layouts on different systems:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，您可以将用户界面适配为在特定平台上略有不同。如果您需要在不同的系统上使用不同的小部件布局，这是一个有用的方法：
- en: '![](img/09a2c322-a5d9-424b-91d0-79da426968dc.png)  ![](img/79ca5af6-fcb5-4ffb-9b2b-94904eb8d102.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/09a2c322-a5d9-424b-91d0-79da426968dc.png) ![图片2](img/79ca5af6-fcb5-4ffb-9b2b-94904eb8d102.png)'
- en: The updated hello app (left) and layout for macOS (right)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的hello应用程序（左侧）和macOS的布局（右侧）
- en: Testing
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Due to various aspects of multiple-platform abstraction (including the variation
    in style), it can take a long time to test an andlabs UI application. As well
    as developing an application that, by design, looks and works slightly differently
    across Windows, macOS, and Linux, the application may be subject to additional
    user customization. All three of those platforms offer some user options to change
    the user interface—Windows allows color adjustments, macOS similarly has highlight
    colors and recently added a dark mode, and GTK+ (the Linux implementation) offers
    full theme support.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多平台抽象的各个方面（包括风格的差异），测试andlabs UI应用程序可能需要很长时间。此外，由于设计上的原因，该应用程序在Windows、macOS和Linux上看起来和工作方式略有不同，可能还会受到额外的用户自定义的影响。这三个平台都提供了一些用户选项来更改用户界面——Windows允许调整颜色，macOS类似地有高亮颜色，最近还增加了暗黑模式，而GTK+（Linux的实现）提供完整的主题支持。
- en: Part of testing an application built in this way is to decide which platforms
    and variations you will support. Should your Windows users all be on the latest
    version of Windows, or will you ensure the application works with older widget
    styles? On macOS, are you checking that your interface reads well in dark and light
    modes? With Linux, are you supporting (and therefore testing) a variety of different
    themes?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 测试以这种方式构建的应用程序的一部分是决定您将支持哪些平台和变体。您的Windows用户是否都在Windows的最新版本上，还是您将确保应用程序与较旧的控件样式兼容？在macOS上，您是否检查您的界面在暗黑和浅色模式下是否易于阅读？对于Linux，您是否支持（因此测试）各种不同的主题？
- en: It's highly recommended that you have a configured test environment for every
    variation of a system that can impact how your application looks. Thankfully,
    this is made easier with virtual machines—you no longer need to have rows of computers
    or complex multi-boot configurations. If you can load and set up each of these
    configurations in separate virtual machine images, it should be possible to test
    all of these potential variations. Note that macOS licensing requires that it's
    run on a Macintosh computer—even if within a virtualized environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 非常推荐您为可能影响应用程序外观的每个系统变体配置一个测试环境。幸运的是，虚拟机使这变得更容易——您不再需要一排电脑或复杂的多启动配置。如果您可以在单独的虚拟机镜像中加载和设置这些配置，那么应该可以测试所有这些潜在变体。请注意，macOS许可要求它在Macintosh计算机上运行——即使是在虚拟化环境中。
- en: Of course, the impact of this cross-platform approach may be wider-reaching—operating
    systems have many non-visible differences as well. It's important to load and
    fully run through your application to check all features, simply looking at the
    user interface isn't enough to satisfy a solid test strategy.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种跨平台方法的影响可能更为深远——操作系统还有许多不可见的不同之处。重要的是要加载并完全运行您的应用程序以检查所有功能，仅仅查看用户界面是不够的，以满足一个坚实的测试策略。
- en: Cross-compilation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编译
- en: Due to the way that libui builds against native widget APIs, the cross-complication
    is more complicated than a simple Go application. As well as the developer tools
    that are required for building an application with andlabs UI for the current
    computer, you will need to have access to the widget library definitions to successfully
    cross-compile. In some instances, that means a simple library installation, in
    other cases it may be necessary to install the operating system's **Software Development
    Kit** (**SDK**). Let's look at the details for each target platform.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于libui是针对本地小部件API构建的，因此交叉编译比简单的Go应用程序更复杂。除了为当前计算机上的andlabs UI构建应用程序所需的开发工具外，你还需要访问小部件库定义以成功进行交叉编译。在某些情况下，这意味着简单的库安装，在其他情况下，可能需要安装操作系统的**软件开发套件**（**SDK**）。让我们看看每个目标平台的详细信息。
- en: 'As with normal Go cross-compilation, we start by setting the environment variable, `GOOS`
    (and optionally `GOARCH`), to define the target platform of our build. To work
    with libui, we need to turn CGo back on (this is disabled when cross-compiling
    by default) using `CGO_ENABLED=1`. Simply executing the build with this setup
    would likely fail due to a missing library or SDK, as shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的Go交叉编译一样，我们首先设置环境变量`GOOS`（可选的`GOARCH`），以定义构建的目标平台。为了与libui一起工作，我们需要使用`CGO_ENABLED=1`重新启用CGo（默认情况下交叉编译时是禁用的）。简单地使用此设置执行构建可能会因为缺少库或SDK而失败，如下所示：
- en: '![](img/a26eff48-0c0b-47f6-b177-80f92bc64990.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a26eff48-0c0b-47f6-b177-80f92bc64990.png)'
- en: Building on macOS for Linux fails
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上为Linux构建失败
- en: '![](img/7ba40449-f2aa-4734-937d-dd5a8c3f5a05.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ba40449-f2aa-4734-937d-dd5a8c3f5a05.png)'
- en: A Linux computer failing to compile for macOS
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一台Linux计算机编译macOS失败
- en: Let's look into how cross-compilation can be enabled for various configurations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何为各种配置启用交叉编译。
- en: Building for Linux on macOS or windows
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS或Windows上为Linux构建
- en: To be able to cross-compile for Linux, the main requirement is the GTK+ library,
    which provides the widgets for andlabs UI on Linux. Installing this is a little
    more difficult as the operating systems don't come with a standard package manager,
    but if you follow the steps described here it should be possible. The process
    also involves installing the cross-compiling toolchain, much like other examples
    in this section. The details for setting up cross-compilation can be found in
    *Cross compiling for Linux with CGo* section given in the [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml),
    *Cross-Compiler Setup*. The main steps are outlined here for quick reference.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够为Linux进行交叉编译，主要要求是GTK+库，它为Linux上的andlabs UI提供小部件。由于操作系统没有标准的包管理器，安装这个库会稍微困难一些，但如果你遵循这里描述的步骤，应该可以完成。这个过程还涉及到安装交叉编译工具链，就像本节中的其他示例一样。设置交叉编译的详细信息可以在附录中找到，即[附录](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)的*交叉编译设置*部分。主要步骤在此处概述，以供快速参考。
- en: macOS
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: 'To cross-compile with macOS, we need to install a package manager. The easiest
    and most complete is Homebrew—you can install it from [https://brew.sh/](https://brew.sh/).
    The recommended toolchain for Linux compilation is `musl-cross`, which is in the `FiloSottile/musl-cross/musl-cross`
    package. With Homebrew installed, execute the following commands in your Terminal
    window:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要为macOS进行交叉编译，我们需要安装一个包管理器。最简单且最完整的是Homebrew——你可以从[https://brew.sh/](https://brew.sh/)安装它。Linux编译推荐的工具链是`musl-cross`，它位于`FiloSottile/musl-cross/musl-cross`包中。安装Homebrew后，在你的终端窗口中执行以下命令：
- en: '`brew install gtk+3`'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`brew install gtk+3`'
- en: '`export HOMEBREW_BUILD_FROM_SOURCE=1`'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`export HOMEBREW_BUILD_FROM_SOURCE=1`'
- en: '`brew install FiloSottile/musl-cross/musl-cross`'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`brew install FiloSottile/musl-cross/musl-cross`'
- en: 'Once that is completed, you should be able to build for Linux by setting the
    `GOOS=linux`, `GOARCH=amd64`, `CGO_ENABLED=1`, and `CC=x86_64-linux-musl-gcc` environment
    variables with `CXX=x86_64-linux-musl-g++`. You can then build as normal, resulting
    in a Linux executable instead of macOS:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你应该可以通过设置`GOOS=linux`、`GOARCH=amd64`、`CGO_ENABLED=1`和`CC=x86_64-linux-musl-gcc`环境变量（`CXX=x86_64-linux-musl-g++`）来为Linux构建。然后你可以像平常一样构建，结果将是一个Linux可执行文件而不是macOS：
- en: '![](img/e21d08e5-1c6a-40bb-a186-3f117d939eb6.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e21d08e5-1c6a-40bb-a186-3f117d939eb6.png)'
- en: Building a Linux executable from macOS
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上构建Linux可执行文件
- en: Windows
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: Cross-compiling with Windows is a little more complicated as there is no standard
    package manager. The recommended approach is to install Cygwin (from [cygwin.com/install.html](https://cygwin.com/install.html)).
    Then install the gtk3 and linux-gcc (cross compiler) packages. From there, follow
    the preceding instructions for macOS, but use `CC=linux-gcc` and `CXX=linux-g++`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Windows 进行交叉编译稍微复杂一些，因为没有标准的包管理器。推荐的方法是安装 Cygwin（从 [cygwin.com/install.html](https://cygwin.com/install.html)）。然后安装
    gtk3 和 linux-gcc（交叉编译器）软件包。从那里开始，按照前面为 macOS 概述的说明进行，但使用 `CC=linux-gcc` 和 `CXX=linux-g++`。
- en: Building for windows on Linux or macOS
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 或 macOS 上为 Windows 构建
- en: Building for Windows from another platform requires an installation of mingw
    (similar to what we installed on Windows to support CGo). The details for setting
    up cross-compilation can be found in the *Cross compiling for Windows with CGo*
    section of an [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler
    Setup*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从其他平台构建 Windows 需要安装 mingw（类似于我们在 Windows 上安装的以支持 CGo）。设置交叉编译的详细信息可以在 [附录](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)
    的 *使用 CGo 交叉编译 Windows* 部分，*交叉编译器设置* 中找到。
- en: 'The main steps are outlined here for quick reference:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 主要步骤在此处概述，以便快速参考：
- en: Using your package manager (Homebrew on macOS and various on Linux), install
    the mingw package, which is usually named `mingw-w64-clang or w64-mingw`. If you
    cannot find this package, it can be installed directly using the instructions
    at [https://github.com/tpoechtrager/wclang](https://github.com/tpoechtrager/wclang).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的包管理器（macOS 上的 Homebrew 和 Linux 上的各种），安装 mingw 软件包，该软件包通常命名为 `mingw-w64-clang`
    或 `w64-mingw`。如果您找不到此软件包，可以直接使用 [https://github.com/tpoechtrager/wclang](https://github.com/tpoechtrager/wclang)
    中的说明进行安装。
- en: 'Once installed, we need to set up the appropriate build flags—specifically `CC=x86_64-w64-mingw32-clang` (for
    the C toolchain) and `CXX=x86_64-w64-mingw32-g++` (for C++ requirements). Assuming
    you also have set `CGO_ENABLED=1` and `GOOS=windows`, you can build the Windows
    binary. Looking at the resulting `hello.exe` file, you can see it''s an MS Windows
    binary:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们需要设置适当的构建标志——特别是 `CC=x86_64-w64-mingw32-clang`（用于 C 工具链）和 `CXX=x86_64-w64-mingw32-g++`（用于
    C++ 需求）。假设您还设置了 `CGO_ENABLED=1` 和 `GOOS=windows`，则可以构建 Windows 可执行文件。查看生成的 `hello.exe`
    文件，您可以看到它是一个 MS Windows 可执行文件：
- en: '![](img/cf726ec5-1d71-4f28-8ae5-b2a3d70e8dd4.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf726ec5-1d71-4f28-8ae5-b2a3d70e8dd4.png)'
- en: Using mingw (x86_64-w64-mingw32-clang), we built a Windows-native UI application
    on Linux
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 mingw（x86_64-w64-mingw32-clang），我们在 Linux 上构建了一个 Windows 原生 UI 应用程序
- en: When building from macOS, you can use Homebrew to install the mingw-w64 package.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 macOS 构建时，可以使用 Homebrew 安装 mingw-w64 软件包。
- en: Building for macOS on Linux or Windows
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 或 Windows 上为 macOS 构建
- en: Cross-compiling for mac requires that the macOS SDK is available to link against.
    When building from a Linux or Windows computer, we must download and install the
    SDK and also update our build toolchain to use it. The easiest way to do this
    is with the *osxcross* tool. The details for this setup can be found in the *Cross
    compiling for macOS with CGo* section of an [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler
    Setup*. The main steps are outlined here for quick reference using a Linux terminal—the
    Windows setup is similar once you have installed the cygwin or mingw terminals.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为 macOS 进行交叉编译需要 macOS SDK 可用于链接。当从 Linux 或 Windows 计算机构建时，我们必须下载并安装 SDK，并更新我们的构建工具链以使用它。最简单的方法是使用
    *osxcross* 工具。有关此设置的详细信息，请参阅 [附录](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)
    中的 *使用 CGo 交叉编译 macOS* 部分，*交叉编译器设置*。此处概述了主要步骤，以便快速参考，使用 Linux 终端——一旦安装了 cygwin
    或 mingw 终端，Windows 设置类似。
- en: First, we need to download the macOS SDK, which is bundled with Xcode. Download
    `XCode.dmg` from the Apple download site at [https://developer.apple.com/download/more/?name=Xcode%207.3](https://developer.apple.com/download/more/?name=Xcode%207.3) (7.3.1
    is recommended for osxcross). Next, install the osxcross tools from [github.com/tpoechtrager/osxcross](https://github.com/tpoechtrager/osxcross)
    (full installation details are available at that URL or in the Appendix). Completing
    the installation will have extracted the macOS SDK and created the compilation
    toolchain that will build against these installed APIs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要下载 macOS SDK，它包含在 Xcode 中。从苹果下载网站 [https://developer.apple.com/download/more/?name=Xcode%207.3](https://developer.apple.com/download/more/?name=Xcode%207.3)
    下载 `XCode.dmg`（推荐使用 7.3.1 版本用于 osxcross）。接下来，从 [github.com/tpoechtrager/osxcross](https://github.com/tpoechtrager/osxcross)
    安装 osxcross 工具（完整的安装细节可在该网址或附录中找到）。完成安装后，将提取 macOS SDK 并创建用于构建这些已安装 API 的编译工具链。
- en: 'And now we are ready to build. As well as the previous environment variables,
    we add `CC=o32-clang`, after which our build command should succeed. Here you
    can see that our Linux computer managed to create a macOS 64-bit Mach-O executable
    file named `hello`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备构建。除了之前的环境变量外，我们添加了`CC=o32-clang`，之后我们的构建命令应该能够成功执行。在这里，你可以看到我们的Linux计算机成功创建了一个名为`hello`的macOS
    64位Mach-O可执行文件：
- en: '![](img/f7c76b31-1997-4acd-8d1b-2e45e8dfa85a.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7c76b31-1997-4acd-8d1b-2e45e8dfa85a.png)'
- en: Using osxcross (o32-clang), we built a macOS-native UI application on Linux.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用osxcross（o32-clang），我们在Linux上构建了一个macOS本机UI应用程序。
- en: The process for Windows is similar and full details can be found in the *Cross
    compiling for macOS with CGo* section of an [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler
    Setup*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Windows的过程类似，详细内容可以在附录的*使用CGo为macOS交叉编译*部分找到，*交叉编译器设置*。
- en: A better solution
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更好的解决方案
- en: These steps are complicated and potentially fragile. Due to these challenges,
    a new project was created to assist in the cross compilation of andlabs UI applications.
    You can find out more and compare the process with those detailed here by visiting
    the project homepage at [https://github.com/magJ/go-ui-crossbuild/](https://github.com/magJ/go-ui-crossbuild/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤很复杂且可能很脆弱。由于这些挑战，创建了一个新的项目来帮助跨编译andlabs UI应用程序。你可以通过访问项目主页了解更多信息，并比较以下详细说明的过程：[https://github.com/magJ/go-ui-crossbuild/](https://github.com/magJ/go-ui-crossbuild/)。
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored andlabs UI toolkit, which provides a single API
    to build graphical Go applications using the native widgets of the running operating
    system. We stepped through getting set up to build an andlabs UI application on
    macOS, Windows, and Linux, and showed how a simple *hello world* application could
    be run on each system from a single Go source file. We then looked in detail at
    the widget API for building applications and the drawing APIs for custom rendering.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了andlabs UI工具包，它提供了一个单一的API，用于使用运行操作系统的本地小部件构建图形Go应用程序。我们逐步介绍了如何在macOS、Windows和Linux上设置构建andlabs
    UI应用程序，并展示了如何从单个Go源文件在各个系统上运行一个简单的*hello world*应用程序。然后我们详细研究了用于构建应用程序的小部件API和用于自定义渲染的绘图API。
- en: With this knowledge, we revisited the GoMail application from [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications*, and built the user interface again
    using andlabs UI library. While there were some limitations with the current version,
    we were able to simulate some of the missing widgets to almost completely recreate
    the application. The benefit, of course, is that we could then run the GUI on
    Windows, Linux, and macOS from the same source code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，我们回顾了[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk - 构建图形Windows应用程序*中的GoMail应用程序，并再次使用andlabs
    UI库构建用户界面。尽管当前版本有一些限制，但我们能够模拟一些缺失的小部件，几乎完全重现了应用程序。当然，好处是我们可以从相同的源代码在Windows、Linux和macOS上运行GUI。
- en: Testing an application built with a library where the user interface varies,
    and ensuring it looks as consistent as possible, may be difficult depending on
    your app design. Additionally, the simple cross-compilation that Go provides is
    significantly harder with andlabs UI due to the way it implements using operating-system-specific
    widget APIs. We explored how to work within these constraints and build applications
    for different platforms.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用具有可变用户界面的库构建的应用程序，并确保其尽可能保持一致性，可能取决于你的应用程序设计而变得困难。此外，由于Go提供的简单交叉编译方式在andlabs
    UI中由于它使用特定于操作系统的小部件API实现而变得相当困难。我们探讨了如何在这些限制下工作并构建适用于不同平台的应用程序。
- en: In the next two chapters, investigate existing cross-platform widget libraries
    that have been made available through Go APIs. GTK+ (which we saw being used by
    andlabs UI for Linux) and QT both present a standard widget set, which will seem
    familiar to users of existing desktop applications. We'll start by exploring GTK+
    in detail in the next chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个章节中，我们将调查通过Go API提供的现有跨平台小部件库。GTK+（我们在andlabs UI中看到它被用于Linux）和QT都提供了一个标准的
    widget 集合，这对现有桌面应用程序的用户来说会感觉熟悉。我们将在下一章中详细探讨GTK+。
