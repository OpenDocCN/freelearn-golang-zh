- en: Go-GTK - Multiple Platforms with GTK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go-GTK - 使用 GTK+ 的多平台
- en: We've explored toolkits that connect directly to an operating system's native
    widget set (Walk for Windows only and andlabs UI for Windows, macOS, and Linux)
    in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical
    Windows Applications,* and [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-platform Native UIs*. In this chapter and the next ([Chapter
    7](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml), *Go-Qt - Multiple Platforms with
    Qt*), we'll look at widget toolkits that were designed to look similar to traditional
    native widgets while being built for multi-platform distribution. In each chapter,
    we'll work with a popular Go binding that provides access to most of the functionality
    of the underlying API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 4 章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，*Walk - 构建图形窗口应用程序*
    和 [第 5 章](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)，*andlabs UI - 跨平台原生 UI*
    中探讨了直接连接到操作系统原生小部件集的工具包（仅适用于 Windows 的 Walk 和适用于 Windows、macOS 和 Linux 的 andlabs
    UI）。在本章和下一章（[第 7 章](68a93b63-2eb7-4c9b-89cf-caa2e29d1ee5.xhtml)，*Go-Qt - 使用 Qt
    的多平台*）中，我们将查看旨在看起来类似于传统原生小部件同时为多平台分发而构建的小部件工具包。在每一章中，我们将使用一个流行的 Go 绑定，它提供了对底层
    API 大多数功能的访问。
- en: 'In this chapter, we''ll explore Go-GTK, the most popular Go binding to the
    GTK+ widget library. We''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 Go-GTK，这是最流行的 GTK+ 小部件库的 Go 绑定。我们将涵盖以下内容：
- en: GTK+ background
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GTK+ 背景知识
- en: Getting started with Go-GTK
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Go-GTK
- en: Signals and namespaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号和命名空间
- en: Sample application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: Theming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题设计
- en: By the end of this chapter, you'll be familiar with GTK+ and the Go-GTK library,
    having explored a few example applications. We will build a new version of the
    GoMail application and compare the results with our previous versions built with
    Walk and andlabs UI.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉 GTK+ 和 Go-GTK 库，通过探索一些示例应用程序。我们将构建 GoMail 应用程序的新版本，并将其与之前使用 Walk
    和 andlabs UI 构建的版本进行比较。
- en: GTK+ background
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GTK+ 背景知识
- en: 'GTK+, or the **GNU Image Manipulation Program** (**GIMP**) Toolkit (a popular
    cross-platform image editor), is a cross-platform API for creating graphical applications.
    The project aims to provide a complete set of GUI widgets, supporting small graphical
    utilities up to large application suites:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+，或称为 **GNU 图像处理程序**（**GIMP**）工具包（一个流行的跨平台图像编辑器），是一个用于创建图形应用程序的跨平台 API。该项目旨在提供一套完整的
    GUI 小部件，支持从小型图形工具到大型应用程序套件：
- en: '![](img/50f4ae3b-fb9e-4ae7-a12b-37847595cc39.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50f4ae3b-fb9e-4ae7-a12b-37847595cc39.png)'
- en: GIMP, which uses GTK+, shown on Windows Vista; copyright the GTK+ team
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GTK+ 的 GIMP，在 Windows Vista 上显示；版权所有 GTK+ 团队
- en: Since its creation, the toolkit's adoption has rapidly expanded, supported by
    its open source license, which supports its use in commercial and freely available
    applications alike. While version 1.0 (released in 1998) was primarily to support
    the functions of the GIMP application, by 1.2 (released less than a year later)
    the toolkit was aiming at a broader audience. In 2002, version 2.0 was released,
    which saw GTK+ become the official tookit for the Gnome Linux desktop. This fully
    featured release greatly expanded adoption, to become one of the most popular
    widget sets available for cross-platform development—and minor releases of the
    2.x version are still very popular in 2018\. In 2011, 3.0 was released with many
    changes included, the most visual of which was a new theme engine based on **Cascading
    Style Sheets** (**CSS**), which is familiar to most web developers. Though CSS
    is easier to create themes for, there have been criticisms of the new approach,
    and many distributors continue to deliver version 2.24 despite it being more than
    seven years old.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自其创建以来，该工具包的采用率迅速扩大，得益于其开源许可，它支持在商业和免费应用程序中 alike 的使用。虽然 1.0 版本（于 1998 年发布）主要是为了支持
    GIMP 应用程序的功能，但在一年后的 1.2 版本中，工具包的目标是更广泛的受众。2002 年，发布了 2.0 版本，这使得 GTK+ 成为 Gnome
    Linux 桌面的官方工具包。这个功能齐全的发布极大地扩大了采用率，成为跨平台开发中最受欢迎的控件集之一——2.x 版本的次要发布在 2018 年仍然非常受欢迎。2011
    年，发布了 3.0 版本，其中包含了许多更改，其中最引人注目的是基于 **级联样式表**（**CSS**）的新主题引擎，这对于大多数网页开发者来说都很熟悉。尽管
    CSS 更容易创建主题，但新方法也受到了批评，许多发行商继续提供 2.24 版本，尽管它已经超过七年了。
- en: One of the benefits of Go is that it offers a single API for applications that
    behave consistently across multiple platforms. GTK+ (and Qt, covered in the following
    chapter) is an API that has a similar approach to enabling GUI application development.
    By combining the two through a binding to the Go language, we can create applications
    that can (depending on a user's theme settings) look and behave the same across
    all supported operating systems (Windows, macOS, Linux, and many Unix distributions). The
    Go bindings that we're working with in this chapter were created by Yasuhiro Matsumoto
    and the project has a long list of maintainers. It focuses on GTK2 support and
    aims to offer bindings for the complete API, but currently many features aren't
    available. As you will see in this chapter, the bindings currently available support
    the needs of most applications and so the partial completion of their goal won't
    impact most developer's use of this API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的一个优点是它为在多个平台上表现一致的应用程序提供了一个单一的API。GTK+（以及下一章中将要介绍的Qt）是一个采用类似方法来启用GUI应用程序开发的API。通过将Go语言与这两个API结合，我们可以创建出（根据用户的主题设置）在所有支持的操作系统（Windows、macOS、Linux以及许多Unix发行版）上看起来和表现都一样的应用程序。在本章中我们使用的Go绑定是由Yasuhiro
    Matsumoto创建的，该项目有一长串的维护者名单。它专注于GTK2支持，并旨在提供完整的API绑定，但当前许多功能尚不可用。正如您在本章中将要看到的，目前可用的绑定支持了大多数应用程序的需求，因此它们目标的局部完成不会影响大多数开发者对这一API的使用。
- en: Getting started with Go-GTK
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Go-GTK
- en: Getting up and running with Go-GTK involves installing the GTK+ library on your
    system (if it's not already installed), setting up CGo, and downloading the Go
    bindings. Users of applications built using Go-GTK will need the GTK+ library
    installed on their computer and so the *Installing GTK+* section may need to be
    included in your documentation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Go-GTK，需要在您的系统上安装GTK+库（如果尚未安装），设置CGo，并下载Go绑定。使用Go-GTK构建的应用程序的用户需要在他们的计算机上安装GTK+库，因此“安装GTK+”部分可能需要包含在您的文档中。
- en: Prerequisites
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: Compiling against the GTK+ library will require CGo to be set up; if this isn't
    already done, you can work through the [Appendix](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml),
    *Installation Details*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 针对GTK+库进行编译将需要设置CGo；如果尚未完成，您可以查阅[附录](a0605c81-4926-45d1-b90c-63047f1e2b76.xhtml)，*安装细节*。
- en: Installing GTK+
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GTK+
- en: Using a package manager to install the GTK+ library is the easiest way to get
    it set up, as it'll also configure your development environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器安装GTK+库是最简单的方法，因为它还会配置您的开发环境。
- en: macOS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: The recommended approach with macOS is to install it using Homebrew. If you
    haven't previously set up Homebrew, you can simply follow the instructions at
    `https://brew.sh`. Once Homebrew is installed, you can simply open a Terminal
    and run `brew install gtk+`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS，建议使用Homebrew进行安装。如果您之前没有设置Homebrew，可以简单地遵循`https://brew.sh`上的说明。一旦安装了Homebrew，只需打开一个终端并运行`brew
    install gtk+`即可。
- en: Windows
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: 'Windows doesn''t come with a standard package manager for things such as GTK+,
    but the `MSYS` project aims to solve this problem. Using the `MSYS Mingw-w64`
    terminal (installed previously if you followed the CGo setup instructions), we
    can install the additional libraries. By issuing the following commands, the correct
    libraries should be up and running:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Windows没有标准包管理器来处理GTK+之类的工具，但`MSYS`项目旨在解决这个问题。使用已安装的`MSYS Mingw-w64`终端（如果您遵循了CGo设置说明，则已安装），我们可以安装额外的库。通过执行以下命令，正确的库应该可以正常运行：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This installs the GTK+ library and all of its dependencies. The examples in
    this chapter will need to run from the MSYS terminal, even once built.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装GTK+库及其所有依赖项。本章中的示例需要从MSYS终端运行，即使已经构建完成。
- en: Linux
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: On a Linux installation, there's a good chance that you already have GTK+ 2
    installed, as so many applications use this widget set. If not (or if you are
    not sure), then your system's package manager will manage the installation; simply
    look for a package named `gtk2` or `gtk`. You may need to install an additional
    `gtk2-dev` or `gtk-dev` package if your distribution splits development headers
    from the runtime library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux安装中，有很大可能性您已经安装了GTK+ 2，因为许多应用程序都使用这个小部件集。如果没有（或者您不确定），那么您的系统包管理器将负责安装；只需查找名为`gtk2`或`gtk`的包。如果您的发行版将开发头文件与运行时库分开，您可能需要安装额外的`gtk2-dev`或`gtk-dev`包。
- en: Install Go-GTK
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Go-GTK
- en: Once Go is working and the GTK+ dependency is installed, you can simply `go
    get github.com/mattn/go-gtk` and then `go get github.com/mattn/go-pointer`, on
    which the `go-gtk` project depends. With that installed, we're ready to build
    a test application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Go运行并且GTK+依赖项安装完毕，你可以简单地使用`go get github.com/mattn/go-gtk`，然后使用`go get github.com/mattn/go-pointer`，`go-gtk`项目依赖于它。安装好之后，我们就准备好构建一个测试应用程序。
- en: Build
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'A basic hello world application with Go-GTK is similar to the previous one
    we looked at: we create a window, add a vertical box, and append a label and a
    button. The following code sample should be straightforward, but we''ll look in
    more detail at some of the specifics:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go-GTK的基本欢迎世界应用程序与之前我们看到的类似：我们创建一个窗口，添加一个垂直框，并附加一个标签和一个按钮。下面的代码示例应该很简单，但我们将更详细地查看一些具体细节：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Firstly, we import the `github.com/mattn/go-gtk/gtk` package for the main GTK
    namespace. The `Go-GTK` project is split into various namespaces, which we will
    explore further later in this chapter. Next, the window is created with `gtk.NewWindow()`—note
    that the parameter to this function is the `window` type, not its title (which
    is set next with `SetTitle()`). The `Quit` button is created with `gtk.NewButton()` and
    the text is set with `SetLabel()`, and then we add the code to quit using the
    `Clicked()` function, passing an anonymous function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`github.com/mattn/go-gtk/gtk`包作为主要的GTK命名空间。`Go-GTK`项目被分割成多个命名空间，我们将在本章后面进一步探讨。接下来，使用`gtk.NewWindow()`创建窗口——请注意，这个函数的参数是`window`类型，而不是它的标题（标题将在`SetTitle()`中设置）。使用`gtk.NewButton()`创建`Quit`按钮，并使用`SetLabel()`设置文本，然后我们添加使用`Clicked()`函数的代码来退出，传递一个匿名函数。
- en: The layout is managed by a vertical box that's created with `gtk.NewVBox(bool,
    int)`. The parameters to this message are firstly a *homogeneous* `bool` flag
    (determining whether all child components should be the same size), and secondly
    an `int` value for *spacing* (this specifies the amount of padding to place between
    each child element).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 布局由使用`gtk.NewVBox(bool, int)`创建的垂直框管理。这个消息的参数首先是一个*均匀的*`bool`标志（确定所有子组件是否应该具有相同的大小），其次是用于*间距*的`int`值（这指定了在每个子元素之间放置的填充量）。
- en: Lastly, the content is set on the window using `Add()` and we set a padding
    consistent with the spacing in the VBox using `SetBorderWidth(3)`. Calling `ShowAll()`
    sets the window and its contents to be shown (as widgets are hidden by default),
    and the call to `gtk.Main()` runs the application to render and respond to user
    input.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`Add()`在窗口上设置内容，并使用`SetBorderWidth(3)`设置与VBox中间距一致的填充。调用`ShowAll()`将窗口及其内容设置为显示（因为小部件默认是隐藏的），调用`gtk.Main()`运行应用程序以渲染并响应用户输入。
- en: 'You can build this using the standard `go build hello.go` command, which should
    create a runnable file for your operating system:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用标准的`go build hello.go`命令构建这个程序，它应该为你的操作系统创建一个可运行的文件：
- en: '![](img/94373a75-5e1f-4436-8dfc-06bd1c544adc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94373a75-5e1f-4436-8dfc-06bd1c544adc.png)'
- en: Building the hello world example with Go-GTK
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go-GTK构建欢迎世界示例
- en: Run
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'You can run the built file from the command line by double-clicking the file
    icon, or even using the Go tools (with `go run hello.go`). No matter how it''s
    launched, you should see something like this screenshot appear:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过双击文件图标或使用Go工具（使用`go run hello.go`）从命令行运行构建的文件。无论以何种方式启动，你应该看到类似以下截图的内容：
- en: 'Go-GTK hello world:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go-GTK 欢迎世界：
- en: '![](img/fb078678-c95c-41e0-aade-9de9aad34b50.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb078678-c95c-41e0-aade-9de9aad34b50.png)'
- en: 'Go-GTK on macOS:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go-GTK在macOS上：
- en: '![](img/e6d5026b-c542-4b32-b2c9-ed60f722385f.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6d5026b-c542-4b32-b2c9-ed60f722385f.png)'
- en: 'Go-GTK default Windows look:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Go-GTK默认Windows外观：
- en: '![](img/580b3592-c4cd-4561-a113-9c49301dde2d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/580b3592-c4cd-4561-a113-9c49301dde2d.png)'
- en: You can see that, just like with andlabs UI, we were able to run this single
    file on many operating systems. The difference here is that the applications look
    almost identical. That's the benefit of using a toolkit like GTK+ and why you
    may consider Go-GTK for your next application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，就像和andlabs UI一样，我们能够在许多操作系统上运行这个单个文件。这里的区别是应用程序看起来几乎完全相同。这就是使用像GTK+这样的工具包的好处，这也是你为什么可能考虑为你的下一个应用程序使用Go-GTK的原因。
- en: Before we look at a more complete application user interface, we should investigate
    some of the details of the Go-GTK API.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看更完整的应用程序用户界面之前，我们应该调查一些Go-GTK API的细节。
- en: Signals and namespaces
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和命名空间
- en: GTK+ is an event-driven toolkit; that means that nothing happens unless an event
    is emitted and a callback is registered to receive it. The events in GTK+ are
    implemented through signals, and registering a callback for a signal is called
    connecting. Signals include most events involved in the GUI behavior and communication,
    including button click events or the window life cycle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: GTK+是一个事件驱动的工具包；这意味着除非发射了一个事件并且注册了一个回调来接收它，否则不会发生任何事情。GTK+中的事件通过信号实现，为信号注册回调称为连接。信号包括大多数涉及GUI行为和通信的事件，包括按钮点击事件或窗口生命周期。
- en: Signals
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: 'Did you notice that, in our hello world example, the `Quit` button would exit
    the application, but that closing the window did not? That''s because we didn''t
    connect any callback to the window destroy signal. We can fix this by adding the
    following lines to handle this case:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到在我们的hello world示例中，`Quit`按钮会退出应用程序，但关闭窗口却没有吗？这是因为我们没有将任何回调连接到窗口销毁信号。我们可以通过添加以下行来修复这种情况：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code connects the provided anonymous function to the `destroy` signal
    of `window`. When the signal is emitted, the function is called and the application
    will now exit correctly. As the `gtk.MainQuit()` function takes 0 parameters,
    we could write the same more concisely as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将提供的匿名函数连接到`window`的`destroy`信号。当信号被发射时，函数被调用，应用程序现在将正确退出。由于`gtk.MainQuit()`函数不接受任何参数，我们可以更简洁地写成如下：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But hold on a moment, how come the button click worked? That''s because we
    used the `Clicked()` function on the `button` component. This is a convenience
    function that sets up the signal connection for you (and keeps the code a little
    neater!). If you look at the source code for the `Button.Clicked()` function,
    you will see what happens:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，按钮点击是如何工作的呢？这是因为我们在`button`组件上使用了`Clicked()`函数。这是一个便利函数，它会为你设置信号连接（并且使代码更整洁！）！如果你查看`Button.Clicked()`函数的源代码，你会看到发生了什么：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And so, you can see it is not always essential to *wire* these connections manually
    as `Go-GTK` provides many convenience methods like this one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到，并不总是需要手动*连接*这些连接，因为`Go-GTK`提供了许多像这样的便利方法。
- en: Passing data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递数据
- en: The previous examples all use a function with no parameters. While this is often
    enough, it can be helpful to pass additional information into your signal handling
    functions. This can be done easily as the connect functionality (mirrored by the
    `Clicked()` convenience function) allows for additional parameters to be sent.
    After the function reference, you can pass additional data parameters, which will
    be available to the function that executes the callback.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的所有示例都使用了一个不带参数的函数。虽然这通常足够了，但向您的信号处理函数传递更多信息可能会有所帮助。这可以通过连接功能（通过`Clicked()`便利函数镜像）轻松完成，它允许发送额外的参数。在函数引用之后，您可以传递额外的数据参数，这些参数将可用于执行回调的函数。
- en: 'We can demonstrate that by creating a new button and passing this button along
    with the function to the signal connection:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的按钮并将此按钮及其功能传递给信号连接来证明这一点：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the callback function, we update the function signature to accept a `*glib.CallbackContext`
    parameter. This parameter contains the data that was specified when the signal
    was connected. The data can be accessed using the context's `Data()` function
    call.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调函数中，我们将函数签名更新为接受一个`*glib.CallbackContext`参数。此参数包含在连接信号时指定的数据。可以使用上下文的`Data()`函数调用访问数据。
- en: 'It''s convenient to convert the type of the data returned, but remember to
    be careful when asserting the new type, as an incorrect type will cause your program
    to crash:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 转换返回数据的类型很方便，但记住在断言新类型时要小心，因为错误类型会导致你的程序崩溃：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Bringing this together in a simple example where we create three buttons with
    the same callback function, we can see how this data parameter allows us to avoid
    unnecessary functions being created:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的示例中，我们创建三个具有相同回调函数的按钮，我们可以看到这个数据参数如何使我们避免创建不必要的函数：
- en: '![](img/595b9349-0a69-4380-97f1-bd584cb48caf.png)    ![](img/594dc77d-9ddc-4305-a148-05de9ff54e10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/595b9349-0a69-4380-97f1-bd584cb48caf.png)    ![](img/594dc77d-9ddc-4305-a148-05de9ff54e10.png)'
- en: Multiple buttons; The clicked function handling multiple buttons' click callbacks
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 多个按钮；处理多个按钮点击回调的点击函数
- en: As you may have noticed, the previous code snippet mentioned a new package, `glib`.
    Let's look at the different packages that the `Go-GTK` project consists of and
    when you might want to use them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，之前的代码片段提到了一个新的包，`glib`。让我们看看`Go-GTK`项目包含的不同包以及你何时可能想要使用它们。
- en: Namespaces
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: The `Go-GTK` project contains a number of namespaces used to organize the code
    and make it easier for developers to find what they're looking for. These sub-projects
    or packages reflect the naming within the main GTK+ project, so those familiar
    with this can skip this section. Most of the examples so far used just `gtk`,
    which is clearly the main package to use for building a user interface but, as
    we saw before, `glib` may be important too (for things not specifically about
    widgets).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Go-GTK`项目包含多个命名空间，用于组织代码并使开发者更容易找到他们需要的内容。这些子项目或包反映了GTK+主项目中的命名，因此熟悉这些内容的可以跳过这一部分。到目前为止的大多数示例都使用了`gtk`，这显然是构建用户界面时需要使用的主要包，但正如我们之前看到的，`glib`也可能很重要（对于与小部件无关的事情）。'
- en: 'Let''s look at what each namespace covers and see where it might be useful
    in application development:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个命名空间覆盖的内容，并看看在应用程序开发中它们可能在哪里有用：
- en: '| `gdk` | GDK stands for GIMP Drawing Kit; it''s a low-level component of GTK+
    that handles the details of rendering on each platform that is supported. This
    provides an abstraction of the operating system details, therefore allowing other
    areas of GTK+ to be platform agnostic. This package will be useful if your application
    needs to draw any custom elements. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `gdk` | GDK代表GIMP绘图工具包；它是GTK+的低级组件，负责处理每个受支持平台上的渲染细节。这提供了操作系统细节的抽象，因此允许GTK+的其他区域实现平台无关性。如果你的应用程序需要绘制任何自定义元素，这个包将非常有用。|'
- en: '| `gdkpixbuf` | Pixbuf refers to an in-memory buffer containing pixel data
    for rendering images. This package provides some convenience functions for managing
    images that can be loaded into a Go-GTK application. Of note is the `gdkpixbuf.NewPixbufFromData`
    function, which, combined with the `make_inline_pixbuf` tool, allows the loading
    of images embedded in the application. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `gdkpixbuf` | Pixbuf指的是包含用于渲染图像的像素数据的内存缓冲区。这个包提供了一些管理可以加载到Go-GTK应用程序中的图像的便利函数。值得注意的是`gdkpixbuf.NewPixbufFromData`函数，它与`make_inline_pixbuf`工具结合使用，允许加载嵌入到应用程序中的图像。|'
- en: '| `gio` | `gio` represents an input/output abstraction for GTK+ applications.
    It provides access to local and remote files with a consistent API. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `gio` | `gio`代表GTK+应用程序的输入/输出抽象。它提供了一个一致的API来访问本地和远程文件。|'
- en: '| `glib` | `glib` is the supporting library for all GTK+ features and applications.
    It implements the object-oriented system as well as various data structures and
    utilities. As the Go language defines many of these natively, the glib package
    within Go-GTK is responsible for translating from Go to glib (C) structures. This
    is where thread management and message passing are handled, but most of these
    features are hidden by the higher-level functions of the library. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `glib` | `glib`是所有GTK+功能和应用程序的支持库。它实现了面向对象的系统以及各种数据结构和实用工具。由于Go语言原生定义了许多这些，Go-GTK中的glib包负责将Go结构转换为glib（C）结构。这是处理线程管理和消息传递的地方，但大多数这些功能都被库的高级函数隐藏了。|'
- en: '| `gtk` | The main namespace for widgets in the GTK+ library. As we''ve already
    seen, it presents a cross-platform toolkit for creating graphical applications,
    which is made possible by the other packages listed here. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `gtk` | GTK+库中小部件的主要命名空间。正如我们已经看到的，它提供了一个跨平台的工具包来创建图形应用程序，这是由这里列出的其他包实现的。|'
- en: '| `pango` | **Pango** is a font rendering library, which provides high-quality
    text glyphs for GTK+ applications. It''s unlikely that you would need to call
    any of these APIs directly; it is mainly used internally for rendering text within
    GTK+. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `pango` | **Pango**是一个字体渲染库，为GTK+应用程序提供高质量的文本符号。你不太可能需要直接调用这些API；它主要用于GTK+内部渲染文本。|'
- en: Having looked at the main packages within `Go-GTK` (and seen that an application
    will probably only need to use `gtk`, `glib`, and `gdk`), we will see how this
    comes together in a larger application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`Go-GTK`（Go-GTK）中的主要包（并看到应用程序可能只需要使用`gtk`、`glib`和`gdk`）之后，我们将看到这些包是如何在一个更大的应用程序中结合在一起的。
- en: Sample application
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用
- en: It's time to dust off the GoMail application design again and adapt it for GTK+
    widgets. As the andlabs UI application (when run on Linux) was using GTK+, it
    would seem logical to start from there. However, this time we are not limited
    by the *lowest common denominator* design constraint, which the native cross-platform
    design of andlabs worked around, so let's start from scratch and see what GTK+
    can do.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候再次整理GoMail应用程序的设计，并使其适应GTK+小部件了。由于andlabs UI应用程序（在Linux上运行）使用GTK+，因此从那里开始似乎是合理的。然而，这次我们不受*最低共同分母*设计约束的限制，andlabs的本地跨平台设计绕过了这个限制，所以让我们从头开始，看看GTK+能做什么。
- en: Layout
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'Basic layout with GTK+-based applications uses a familiar vertical and horizontal
    box model. Go-GTK (as a straightforward binding to this API) exposes this same
    functionality. We lay out the GoMail main window using a vertical box to position
    the menu and toolbar above the main content. Our main content is then a horizontally
    split pane created with `gtk.NewHPaned()` (where **H** refers to the horizontal
    layout, not the bar orientation, which is vertical). Before looking at the details,
    here''s the basic layout code for the main window. The toolbar and menu creation
    code is omitted for brevity but can be found in the example code repository:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于GTK+的应用程序的基本布局使用熟悉的垂直和水平盒模型。Go-GTK（作为此API的直接绑定）公开了相同的功能。我们使用垂直盒定位菜单和工具栏在主内容上方来布局GoMail主窗口。然后，我们的主要内容是一个使用`gtk.NewHPaned()`创建的水平分割窗格（其中**H**指的是水平布局，而不是条形方向，条形方向是垂直的）。在查看细节之前，以下是主窗口的基本布局代码。为了简洁起见，省略了工具栏和菜单创建代码，但可以在示例代码仓库中找到：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are two things of note in this code. First is the `padding` constant defined
    at the top of the file. The box model doesn't define a standard spacing and so
    we pass this constant each time the layout requires some visual padding. The second
    important lesson is the difference between the `Add(IWidget)` and `PackStart(IWidget,
    bool, bool, uint)` methods on the boxes. The `Add` method simply appends the widget
    to the container (`gtk.Box` inherits from `gtk.Container`) and it'll cause the
    child to expand to fill the space available. For a menu bar and toolbar, we don't
    desire a vertical expansion so we use the `PackStart` method, which allows more
    control over behavior. The first Boolean parameter controls expansion; by passing
    `false`, we instruct the container that the widget shouldn't take up any free
    space.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中有两点值得注意。首先是在文件顶部定义的`padding`常量。盒模型没有定义标准间距，因此每次布局需要一些视觉填充时，我们都会传递这个常量。第二个重要的教训是`Add(IWidget)`和`PackStart(IWidget,
    bool, bool, uint)`方法在盒子上的区别。`Add`方法简单地将小部件追加到容器中（`gtk.Box`继承自`gtk.Container`），这将导致子项扩展以填充可用空间。对于菜单栏和工具栏，我们不希望垂直扩展，因此我们使用`PackStart`方法，这允许对行为有更多的控制。第一个布尔参数控制扩展；通过传递`false`，我们指示容器该小部件不应占用任何空闲空间。
- en: The second Boolean controls fill and states whether or not the widget should
    fill any space available after any space calculations have been performed, so
    passing `true` specifies that our toolbar should be full width. In `gtk.VBox`,
    the expand parameter refers to vertical stretch and the fill applies to horizontal.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个布尔参数控制填充，并确定小部件是否应在任何空间计算完成后填充任何可用空间，因此传递`true`指定我们的工具栏应占满全宽。在`gtk.VBox`中，扩展参数指的是垂直拉伸，而填充应用于水平。
- en: 'We also need to add some content to the list view, which requires the creation
    of a model to represent the content we will present. As the content will be a
    single column with no parent/child relationship, we can use `gtk.ListStore`, rather
    than the more complex `gtk.TreeStore`. The way that content is set into a model
    is by using an iterator and applying values to each row of data. For the purpose
    of this layout, we add `email1` and `email2` to the 0th (first) column of the
    view:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向列表视图添加一些内容，这需要创建一个模型来表示我们将要展示的内容。由于内容将是一个没有父/子关系的单列，我们可以使用`gtk.ListStore`，而不是更复杂的`gtk.TreeStore`。将内容设置到模型中的方法是使用迭代器并将值应用于数据表的每一行。对于此布局的目的，我们将`email1`和`email2`添加到视图的0th（第一）列：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The toolbar API is simple to use and, by utilizing the stock icons included
    in GTK+, provides standard icons for many common actions. As some of our buttons
    are non-standard (`Reply` and `Reply All`), we set the toolbar style to show icons
    and labels; later, we can add some custom icons. Each item can have its action
    set using the `OnClicked()` function or by connecting the `clicked` signal:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏 API 简单易用，通过利用 GTK+ 中包含的库存图标，为许多常见操作提供标准图标。由于我们的一些按钮是非标准的（例如“回复”和“全部回复”），我们将工具栏样式设置为显示图标和标签；稍后，我们可以添加一些自定义图标。每个项目都可以使用
    `OnClicked()` 函数或通过连接 `clicked` 信号来设置其操作：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The rest of the icons can be added similarly. The menu code is slightly more
    complicated; each drop-down menu (whether a sub-menu or a main menu) needs to
    be created with `gtk.NewMenu()`, and its items added as shown. Each top-level
    menu then needs to have a new menu item created (for example, `gtk.NewMenuItemWithLabel()`)
    and the menu connected using `SetSubmenu()`. The constructed menu can then be
    appended to the menu bar:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的图标可以类似地添加。菜单代码稍微复杂一些；每个下拉菜单（无论是子菜单还是主菜单）都需要使用 `gtk.NewMenu()` 创建，并按所示添加其项目。然后，每个顶级菜单需要创建一个新的菜单项（例如，`gtk.NewMenuItemWithLabel()`），并使用
    `SetSubmenu()` 连接菜单。构建的菜单可以随后附加到菜单栏：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With all of this code in place (and a few more items in the toolbar and menu),
    we have a basic application layout that should look familiar. As you can see,
    we are already benefiting from the additional features of a larger widget toolkit
    with standard icons and more complete styling and layouts:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些代码到位（以及工具栏和菜单中的几个更多项目）之后，我们有一个基本的布局，应该看起来很熟悉。如您所见，我们已经开始从更大的小部件工具包的附加功能中受益，包括标准图标、更完整的样式和布局：
- en: '![](img/ab1087c8-df37-4f30-9439-8971ab1b8ecd.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab1087c8-df37-4f30-9439-8971ab1b8ecd.png)'
- en: The basic layout of GoMail using Go-GTK before we make any style adjustments
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何样式调整之前，使用 Go-GTK 的 GoMail 的基本布局
- en: The layout, particularly of the email details panel, can be improved using `label.SetAlignment(0,
    0)` to set a left alignment, and the content of a label can be made bold by using
    the markup capability of the `pango` library; just call `label.SetMarkup(fmt.Sprintf("<b>%s</b>",
    label.GetText()))`. The preceding code was focused on the basic layout, so these
    tweaks have been left out. The additional details are included in the example
    code repository and the completed interface can be seen in the later section about
    themes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `label.SetAlignment(0, 0)` 可以设置左对齐，从而改善布局，尤其是电子邮件详情面板的布局。通过使用 `pango` 库的标记功能，可以将标签内容设置为粗体；只需调用
    `label.SetMarkup(fmt.Sprintf("<b>%s</b>", label.GetText()))` 即可。前面的代码主要关注基本布局，因此这些调整被省略了。附加的细节包含在示例代码仓库中，完成的界面可以在关于主题的后续部分中查看。
- en: Compose layout
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撰写布局
- en: The code to display the compose dialog should look very familiar by now. The
    window is created as  `gtk.WINDOW_TOPLEVEL` because Go-GTK only allows a choice
    of top-level or popup (that is, floating content), rather than child windows such
    as a dialog. We set up a destroy function that will close the window rather than
    exiting the application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 显示撰写对话框的代码现在应该非常熟悉了。窗口被创建为 `gtk.WINDOW_TOPLEVEL`，因为 Go-GTK 只允许选择顶级或弹出（即浮动内容），而不是对话框等子窗口。我们设置了一个销毁函数，它会关闭窗口而不是退出应用程序。
- en: 'The rest of the layout code is the usual vertical box for each item with a
    horizontal box for the `to` label, which is left of the input field:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的布局代码是每个项目的常规垂直框，对于 `to` 标签，它位于输入字段左侧的水平框：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see with `buttonBox`, we''ve made use of the `PackEnd()` function
    described before to right-align the buttons at the bottom of the compose window.
    We also make use of the `padding` definition from the main window to provide consistent
    spacing for our widgets. Running the preceding code should load a window similar
    to this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您通过 `buttonBox` 所见，我们已经使用了之前描述的 `PackEnd()` 函数，将按钮在撰写窗口的底部右对齐。我们还使用了主窗口的 `padding`
    定义，为我们的小部件提供一致的间距。运行前面的代码应该会加载一个类似于这样的窗口：
- en: '![](img/4a944182-f93f-4f78-837f-0754e2dc0461.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a944182-f93f-4f78-837f-0754e2dc0461.png)'
- en: The GoMail compose window with Go-GTK
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go-GTK 的 GoMail 撰写窗口
- en: Now that we have the basic layout and input fields prepared, let's connect to
    some content using our test email server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了基本的布局和输入字段，让我们通过我们的测试电子邮件服务器连接到一些内容。
- en: Signaling
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: In a traditional GTK+ application, it would be possible, even recommended, to
    make use of the built-in signal handling capabilities. A new signal could be created,
    which would then be emitted by the application at an appropriate time; components
    could connect to this signal and respond appropriately. However, the ability to
    create signals is not exposed through the Go-GTK API and so we will use callbacks
    like the previous examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的 GTK+ 应用程序中，使用内置的信号处理能力是可能的，甚至是被推荐的。可以创建一个新的信号，然后在适当的时候由应用程序发出；组件可以连接到这个信号并做出相应的响应。然而，创建信号的能力并没有通过
    Go-GTK API 暴露出来，因此我们将使用类似于前例的回调。
- en: 'To load our test server, we first update the `main()` function to set up a
    server and pass it to the user interface creation code. We then set the content
    to show the current message from our test server:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载我们的测试服务器，我们首先更新 `main()` 函数以设置服务器并将其传递给用户界面创建代码。然后，我们设置内容以显示测试服务器的当前消息：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This makes use of a new helper function that will set the content of the email
    detail panel. We will call this from our list selection code later as well:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了新的辅助函数，该函数将设置电子邮件详细面板的内容。我们将在稍后的列表选择代码中调用此函数：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To set the content of the email list, we store the iterator and the model in
    our application struct when created, so they can be referenced later. The following
    helper function handles the details of prepending an item to the email list. This
    function is called on each message in `server.ListMessages()` to set up the initial
    list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置电子邮件列表的内容，我们在创建应用程序结构体时存储迭代器和模型，以便以后可以引用。以下辅助函数处理将项目预加到电子邮件列表中的细节。这个函数在
    `server.ListMessages()` 中的每个消息上被调用，以设置初始列表：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last part of the basic communication with the user interface is to handle
    the selection of items in the tree view. To handle this, our application must
    implement `gtk.GtkTreeSelecter`, which has a single `Select()` function. The following
    implementation will suit our needs. Firstly, note that this can be called for
    selection and deselection, so we need to check that the item is not currently
    selected. Then, we use the path specified when the callback is invoked to determine
    the row that was clicked. This row number is used to get the email from the server
    list of messages. We can then call our helpful `setEmail()` function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户界面基本通信的最后一部分是处理树视图中项目的选择。为了处理这一点，我们的应用程序必须实现 `gtk.GtkTreeSelecter`，它有一个单一的
    `Select()` 函数。以下实现将满足我们的需求。首先，请注意，这可以用于选择和取消选择，因此我们需要检查项目当前是否未被选中。然后，我们使用回调调用时指定的路径来确定被点击的行。这个行号用于从消息的服务器列表中获取电子邮件。然后，我们可以调用我们的有用函数
    `setEmail()`：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the select handler to be called, we must register it on `gtk.ListView`
    when it is created:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使选择处理程序被调用，我们必须在创建 `gtk.ListView` 时注册它：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, the user interface should be complete. We need to handle background updates
    when new emails arrive.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户界面应该已经完成。我们需要处理新电子邮件到达时的后台更新。
- en: Thread handling
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程处理
- en: 'Before we can correctly handle background processing with Go-GTK (or any GTK+
    implementations), we must correctly initialize the thread handling portions of
    the underlying libraries (`glib` and `gdk`). These lines should be entered at
    the start of an application''s `main()` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够正确处理 Go-GTK（或任何 GTK+ 实现）的背景处理之前，我们必须正确初始化底层库（`glib` 和 `gdk`）的线程处理部分。这些行应该在应用程序的
    `main()` 函数开始时输入：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once the thread handling has been set up, we can write background code that
    will communicate with the user interface. This code must execute on the same thread
    that the application was created with. To ensure this, we use the helper functions, `gdk.ThreadsEnter()`
    and `gdk.ThreadsLeave()`, around the code we wish to execute. For our application
    to add new messages to the end of our email list when they arrive, add the following
    code immediately before calling `gtk.Main()` to start the application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了线程处理，我们就可以编写将与用户界面通信的后台代码。此代码必须在创建应用程序时相同的线程上执行。为了确保这一点，我们在要执行的代码周围使用辅助函数
    `gdk.ThreadsEnter()` 和 `gdk.ThreadsLeave()`。为了使我们的应用程序在消息到达时将新消息添加到电子邮件列表的末尾，在调用
    `gtk.Main()` 以启动应用程序之前立即添加以下代码：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This completes the implementation of our GoMail application in Go-GTK, but how
    can we compile the app for different platforms?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们在 Go-GTK 中实现 GoMail 应用程序的工作，但如何为不同的平台编译应用程序呢？
- en: Cross compilation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编译
- en: Compiling a Go-GTK based application for additional platforms requires requires
    additional C compilers to be installed so that CGo can create the necessary binary
    output. The steps for completing this, if you haven't done so already, are in the
    [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup*.
    You'll also need to have GTK+ installed, which should obviously already be the
    case. As the *Cross compilation* section of [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* andlabs UI already stepped through
    the details, so we won't repeat them here. The process is identical due to andlabs
    UI's use of the GTK+ library for some target platforms. Be sure to set the appropriate `GOOS`,
    `GOARCH`, `CGO_ENABLED`, `CC`, and `CXX` environment variables.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为Go-GTK基于的应用程序编译针对额外平台需要安装额外的C编译器，以便CGo可以创建必要的二进制输出。如果您还没有这样做，完成此步骤的步骤在[附录](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)，*交叉编译设置*中。您还需要安装GTK+，这显然已经是既定事实。由于andlabs
    UI使用GTK+库针对某些目标平台，[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)的*构建图形窗口应用程序*部分已经详细说明了，所以我们在这里不再重复。由于andlabs
    UI使用GTK+库针对某些目标平台，这个过程是相同的。请确保设置适当的`GOOS`、`GOARCH`、`CGO_ENABLED`、`CC`和`CXX`环境变量。
- en: Before we wrap up our exploration of the toolkit, we should look at the benefits
    provided by its theming capabilities.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对工具包的探索之前，我们应该看看它提供的主题功能带来的好处。
- en: Theming
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: One of the large benefits of using a GTK+ (or Qt)-based API is that the widget
    set can be themed. Users are able to install any number of themes (or write their
    own) to control how applications look. While this can add a testing overhead,
    they will behave the same across all platforms so the burden is somewhat reduced.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于GTK+（或Qt）的API的一个大优点是，小部件集可以主题化。用户可以安装任意数量的主题（或编写自己的主题）来控制应用程序的外观。虽然这可能会增加测试开销，但它们将在所有平台上表现相同，因此负担有所减轻。
- en: Let's see a few different themes applied to our GoMail application illustrated
    here, starting with a great light theme named `Clearlooks`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里展示的GoMail应用程序应用的一些不同主题，首先是名为`Clearlooks`的出色浅色主题。
- en: 'The Clearlooks theme on Linux:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux上的Clearlooks主题：
- en: '![](img/b098c234-0783-4547-bdea-f04ef12277e0.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b098c234-0783-4547-bdea-f04ef12277e0.png)'
- en: 'Compose in Clearlooks:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Clearlooks中撰写：
- en: '![](img/5b9f0b84-23d6-4ce9-857f-afc942a03423.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b9f0b84-23d6-4ce9-857f-afc942a03423.png)'
- en: On Windows, the default theme looks more like the standard widgets, though the
    user can load any other GTK+ theme. Notice that the default icons are also different,
    more in-keeping with the operating system standards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，默认主题看起来更像标准小部件，尽管用户可以加载任何其他GTK+主题。注意，默认图标也有所不同，更符合操作系统标准。
- en: 'The Windows default theme:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows默认主题：
- en: '![](img/6cf8a775-a445-4453-865e-55ee25d8bbcc.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cf8a775-a445-4453-865e-55ee25d8bbcc.png)'
- en: 'Compose with Windows:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Windows撰写：
- en: '![](img/04381830-6892-4a64-a081-e6a380c21ced.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/04381830-6892-4a64-a081-e6a380c21ced.png)'
- en: There are also many dark themes; *Arc Dark* is very popular.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多深色主题；*Arc Dark*非常受欢迎。
- en: 'Arc Dark theme running on Linux:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上运行的Arc Dark主题：
- en: '![](img/4d074dae-f1b5-4de5-9b98-03641d205430.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d074dae-f1b5-4de5-9b98-03641d205430.png)'
- en: 'Ark Dark compose window:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ark Dark撰写窗口：
- en: '![](img/72bfdb9e-5b75-483d-80cc-7b37de092b5f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72bfdb9e-5b75-483d-80cc-7b37de092b5f.png)'
- en: Many themes are designed for nostalgia, including this CDE theme, which is based
    on a colorful desktop environment from the 1990s.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 许多主题是为怀旧而设计的，包括这个基于20世纪90年代彩色桌面环境的CDE主题。
- en: 'Running a CDE theme for the old-school look:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行CDE主题以获得复古外观：
- en: '![](img/d0c5c8e9-5504-4fd0-939d-1b2ee96e4c04.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0c5c8e9-5504-4fd0-939d-1b2ee96e4c04.png)'
- en: 'Composing in a CDE theme:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CDE主题中撰写：
- en: '![](img/d0b8e27c-2dc1-4d6e-aabf-d39e0b2745c7.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0b8e27c-2dc1-4d6e-aabf-d39e0b2745c7.png)'
- en: As you can see, the colors of the user interface elements can vary significantly
    but the layouts are largely consistent. If you look at the buttons (`Send` and
    `Cancel` on the compose window), there's also a difference between how rounded
    some edges are. Applications built with Go-GTK should work well with any theme
    loaded, but it is advisable to check various different configurations as part
    of your quality assurance process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用户界面元素的色彩可以有很大差异，但布局大体上一致。如果您查看按钮（撰写窗口中的`发送`和`取消`按钮），某些边缘的圆角也有所不同。使用Go-GTK构建的应用程序应该能够与任何加载的主题良好工作，但在质量保证过程中检查各种不同的配置是明智的。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the details of the GTK+ toolkit and how it is made
    available to Go through go-GTK. We looked at how to get it set up on macOS, Windows,
    and Linux and how the applications look and behave exactly the same across these
    platforms. We explored the API design, its various components, and how its event
    driven model is exposed to developers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了GTK+工具包的细节以及它是如何通过go-GTK提供给Go的。我们研究了如何在macOS、Windows和Linux上设置它，以及这些平台上的应用程序看起来和行为方式完全相同。我们探讨了API设计、其各种组件以及其事件驱动模型是如何向开发者公开的。
- en: We then returned to the GoMail application from [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* and [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-Platform Native UIs*, rebuilding it using the Go-GTK library.
    As the API provides access to most GTK+ features, we found that the application
    looks more complete than the GTK+ based application created by the Linux driver
    within andlabs UI used in [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-Platform Native UIs*. We implemented some basic thread and
    signal handling within the application to handle user input and background events.
    Lastly, we explored how the powerful GTK+ theme engine could style the created
    application user interface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回到了[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)的GoMail应用程序，“Walk -
    构建图形窗口应用程序”，以及[第5章](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)，“andlabs UI -
    跨平台原生UI”，使用Go-GTK库重新构建它。由于API提供了对大多数GTK+功能的访问，我们发现该应用程序看起来比在[第5章](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)中使用的andlabs
    UI内由Linux驱动程序创建的基于GTK+的应用程序更完整。我们在应用程序中实现了一些基本的线程和信号处理，以处理用户输入和后台事件。最后，我们探讨了强大的GTK+主题引擎如何样式化创建的应用程序用户界面。
- en: By now, you should be familiar with the Go-GTK library, and how it leverages
    the underlying GTK+ toolkit and allows the quick development of GUI applications
    with Go. These applications will differ from the operating system standard look
    and feel, but are close to standard application design and so should be familiar
    to most users. If the interface widget design or API wasn't quite what you were
    looking for, then read the next chapter, where we look at an alternative to GTK,
    the Qt framework.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了Go-GTK库，以及它是如何利用底层的GTK+工具包，并允许使用Go快速开发GUI应用程序。这些应用程序将与操作系统标准的界面和感觉不同，但接近标准应用程序设计，因此应该对大多数用户来说都很熟悉。如果界面小部件设计或API并不是你想要的，那么请阅读下一章，我们将探讨GTK的替代方案，即Qt框架。
