- en: Go-Qt - Multiple Platforms with Qt
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go-Qt - 使用Qt的多平台
- en: Similar to the Go-GTK library we explored in the previous chapter, qt by therecipe allows
    you to write cross-platform graphical applications with a single Go code base.
    It leverages Qt, a multi-platform application framework that's designed for rapid
    delivery of applications to desktop and embedded computing environments. Like
    GTK+, it's designed to draw widgets that are familiar to the end user but aren't
    reliant upon the operating system's provided toolkit. Additionally, Qt provides
    a different look for mobile and embedded devices where users expect a different
    style of presentation. All of this is controlled within the framework so the developer
    can concentrate on developing a single application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一章中探讨的Go-GTK库类似，therecipe的qt允许你使用单个Go代码库编写跨平台的图形应用程序。它利用Qt，这是一个为快速将应用程序交付到桌面和嵌入式计算环境而设计的多平台应用程序框架。像GTK+一样，它旨在绘制用户熟悉的控件，但不依赖于操作系统提供的工具包。此外，Qt为移动和嵌入式设备提供了不同的外观，用户期望不同的展示风格。所有这些都在框架内部控制，这样开发者就可以专注于开发单个应用程序。
- en: 'In this chapter, we''ll look at the details of therecipe/qt, the most widely
    adopted Qt binding for the Go language. We''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨最广泛采用的Go语言Qt绑定recipe/qt的细节。我们将涵盖以下内容：
- en: The history and aims of the Qt framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt框架的历史和目标
- en: How the API is designed and bridged into Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API是如何设计和桥接到Go的
- en: Creating an application using therecipe/qt library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用therecipe/qt库创建应用程序
- en: The theming capabilities of Qt applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt应用程序的主题功能
- en: By the end of this chapter, you'll be familiar with the capabilities of the
    Qt framework and its support of many different platforms. Through the exploration
    of some example applications and our GoMail application, you'll learn how the
    Go bindings of therecipe provide access to these features for development in Go.
    You should also have an understanding of whether the Qt framework is a good fit
    for your next application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将熟悉Qt框架的功能及其对许多不同平台的支持。通过探索一些示例应用程序和我们的GoMail应用程序，你将了解recipe的Go绑定如何为Go开发提供对这些功能的访问。你还应该了解Qt框架是否适合你的下一个应用程序。
- en: Qt background
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt背景
- en: The Qt framework was created in 1991 by a company named Trolltech (now called
    the Qt Company). The KDE Linux desktop is based on Qt and its increase in popularity
    may be a key reason why Qt development became more widespread. As a platform that's,
    in part, aimed at embedded devices, the typical developers using Qt are different
    to those for the GTK+ framework. Additionally, the tooling and support available
    is better developed due to their commercial backing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架是由名为Trolltech的公司在1991年创建的（现在称为Qt公司）。KDE Linux桌面是基于Qt的，Qt的流行度的增加可能是Qt开发变得更加普遍的关键原因。作为一个部分针对嵌入式设备的平台，使用Qt的典型开发者与GTK+框架的开发者不同。此外，由于他们的商业支持，可用的工具和支持得到了更好的发展。
- en: The Qt framework is released in two separate distributions, one commercial and
    one open source (known as dual licensing). In this manner, they can support open
    source-compliant applications for free, while providing unrestricted usage for
    closed source commercial projects. Before the year 2000 (with the release of 2.2),
    the source code for the free distribution had been under various licenses that
    some groups considered incompatible with common open source initiatives. For the
    2.2 release, it was changed to GPL licensing, which settled any concerns about
    the group's commitment to true open source freedoms. In 2007, Qt 4.5 was released
    and they added LGPL as an option for developers who prefer the more permissive
    license.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架以两种不同的发行版发布，一个是商业版，另一个是开源版（称为双重许可）。这样，他们可以免费支持符合开源规范的应用程序，同时为封闭源代码的商业项目提供无限制的使用。在2000年之前（2.2版本的发布），免费分发的源代码在多种许可证下，一些团体认为这些许可证与常见的开源倡议不兼容。对于2.2版本的发布，它被改为GPL许可证，这解决了关于该团体对真正开源自由的承诺的任何疑虑。2007年，发布了Qt
    4.5，他们为更喜欢更宽松许可证的开发者添加了LGPL作为选项。
- en: 'In 2011, the Nokia company founded the Qt Project in a move to open up the
    development and road map of the Qt libraries. Qt''s largest market is in embedded
    devices, such as cars and appliances, the technology being utilized by large companies
    such as Tesla and Mercedes Benz:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在2011年，诺基亚公司成立了Qt项目，旨在开放Qt库的开发路线图。Qt最大的市场是在嵌入式设备上，如汽车和家电，这项技术被特斯拉和奔驰等大型公司所采用：
- en: '![](img/62482bd5-b103-447a-a4b8-fca90f0d343a.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62482bd5-b103-447a-a4b8-fca90f0d343a.png)'
- en: 'Scribus is a popular desktop publishing application written with Qt (image
    copyright: Henrik Hüttemann)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Scribus 是一个用 Qt 编写的流行桌面出版应用程序（图片版权：Henrik Hüttemann）
- en: The Go bindings by therecipe (whose real name isn't attached to the project),
    along with many contributors, aims to bring the Qt API along with its substantial
    list of supported platforms to the Go language. The project supports building
    applications for Windows, macOS, and Linux desktop computers but also Android,
    iOS, and many other mobile and embedded devices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: therecipe 的 Go 绑定（其真实名称未与项目相关联），以及许多贡献者，旨在将 Qt API 及其庞大的支持平台列表带到 Go 语言中。该项目支持为
    Windows、macOS 和 Linux 桌面计算机以及 Android、iOS 和许多其他移动和嵌入式设备构建应用程序。
- en: Getting started with therecipe/qt
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 therecipe/qt
- en: To begin our exploration of Qt and the binding to Go, we'll build a simple *hello
    world* application. To be able to do so, we first need to install therecipe/qt,
    which depends on various prerequisites that we must first set up.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始探索 Qt 和 Go 的绑定，我们将构建一个简单的 *hello world* 应用程序。为了能够做到这一点，我们首先需要安装 recipe/qt，它依赖于各种必须首先设置的前提条件。
- en: Prerequisites
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: As with Go-GTK, we'll be relying on a native library that requires that we both
    set up the CGo functionality and install the Qt library appropriate for the current
    platform.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Go-GTK 一样，我们将依赖于一个本地库，这要求我们设置 CGo 功能并安装适用于当前平台的 Qt 库。
- en: Preparing CGo
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 CGo
- en: The Qt Go bindings, like many of the other toolkits featured in this book, require
    the presence of CGo to utilize native libraries. On a full development system,
    it's likely that this is already set up. If you're unsure or would like a reminder
    of how to set up the CGo dependencies, please check the Appendix, *Setting Up
    CGo*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Go 绑定，就像本书中介绍的其他许多工具包一样，需要 CGo 的存在来利用本地库。在一个完整的开发系统中，这可能是已经设置好的。如果您不确定或想回顾如何设置
    CGo 依赖项，请查阅附录 *设置 CGo*。
- en: Installing Qt
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Qt
- en: The Qt website ([www.qt.io/download](https://www.qt.io/download)) offers various
    methods of installation, including a customized online installer available to
    anyone with a Qt account (which is free to sign up for). Typically, a Qt installation
    comes with Qt Creator (the project IDE), the GUI designer, additional tools, and
    examples. Visiting the preceding site will automatically detect your system and
    suggest the most appropriate download (this is normally the best option).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 网站 ([www.qt.io/download](https://www.qt.io/download)) 提供了各种安装方法，包括任何拥有 Qt
    账户的人都可以使用的定制在线安装程序（注册 Qt 账户是免费的）。通常，Qt 安装包括 Qt Creator（项目 IDE）、GUI 设计器、其他工具和示例。访问前面的网站将自动检测您的系统并建议最合适的下载（这通常是最佳选项）。
- en: Be aware that the Qt installation can be quite large. If you don't have at least
    40 GB of space on your hard drive, you need to make a little space before installing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Qt 安装可能相当大。如果您硬盘上没有至少 40 GB 的空间，您需要在安装之前腾出一些空间。
- en: Some operating systems offer Qt libraries and tools as part of their package
    manager, which often provides a more lightweight installation that'll automatically
    stay up to date. However, this option doesn't deliver the complete feature set
    of the Qt development tools, and the Qt bindings discussed in this chapter default
    to using the standard Qt installation provided by the online installer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作系统将 Qt 库和工具作为其包管理器的一部分提供，这通常提供了一种更轻量级的安装方式，可以自动保持更新。然而，此选项并不提供 Qt 开发工具的完整功能集，本章中讨论的
    Qt 绑定默认使用在线安装程序提供的标准 Qt 安装。
- en: macOS
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: On Apple macOS, the best approach to installation is to use the installer application
    available at the Qt download site. Visit [www.qt.io/download](https://www.qt.io/download) and
    download the macOS installer. Once it has downloaded, open the package and run
    the program inside; this will install the selected compilers, tools, and supporting
    applications. If you encounter any errors during installation, the first step
    would be to check that your Xcode installation is complete and up to date (for
    more information, see the *Installation Details* appendix).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apple macOS 上，最佳安装方法是使用 Qt 下载网站提供的安装程序应用程序。访问 [www.qt.io/download](https://www.qt.io/download)
    并下载 macOS 安装程序。下载完成后，打开包并运行程序；这将安装所选的编译器、工具和支持应用程序。如果在安装过程中遇到任何错误，第一步应该是检查您的 Xcode
    安装是否完整且最新（更多信息，请参阅 *安装详情* 附录）。
- en: Windows
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: Installing on Windows is more straightforward than some of the other toolkits
    we've looked at, as the Qt installer has a `mingw` package bundled to set up most
    of the compiling requirements (though it's still recommended to have your own
    compiler set up for the binding phase next). To install it, go to the download
    page listed previously and access the Windows installer. Run the downloaded executable
    and follow the onscreen instructions. It's recommended to install to the default
    location. Once that's done, you're ready to set up the bindings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装比我们之前查看的一些工具包更简单，因为 Qt 安装程序捆绑了 `mingw` 包，用于设置大多数编译需求（尽管在绑定阶段仍建议您设置自己的编译器）。要安装它，请访问之前列出的下载页面并访问
    Windows 安装程序。运行下载的可执行文件并按照屏幕上的说明操作。建议安装到默认位置。一旦完成，您就可以设置绑定了。
- en: Linux
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'Using the online installer from [https://www.qt.io](https://www.qt.io) is the
    easiest approach, though it may be possible to install through your system''s
    package manager (if you want to try the package manager approach, then first read
    the Qt Linux documentation at [https://github.com/therecipe/qt/wiki/Installation-on-Linux](https://github.com/therecipe/qt/wiki/Installation-on-Linux)).
    On most Linux platforms, the Qt downloads website will correctly detect the platform
    and offer a simple run installer. After downloading the file, you should make
    it executable and then run it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 [https://www.qt.io](https://www.qt.io) 的在线安装程序是最简单的方法，尽管也可能通过您的系统包管理器进行安装（如果您想尝试包管理器方法，请首先阅读
    Qt Linux 文档，见 [https://github.com/therecipe/qt/wiki/Installation-on-Linux](https://github.com/therecipe/qt/wiki/Installation-on-Linux)）。在大多数
    Linux 平台上，Qt 下载网站将正确检测平台并提供一个简单的运行安装程序。下载文件后，您应该使其可执行，然后运行它：
- en: '![](img/81bc1ed7-f7fc-4d74-b9e5-8c188a6b796f.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81bc1ed7-f7fc-4d74-b9e5-8c188a6b796f.png)'
- en: On Linux, you need to make the install file executable and run it
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，您需要使安装文件可执行并运行它
- en: This will start the installer just as on macOS; from here, follow the onscreen
    instructions and complete the installation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动安装程序，就像在 macOS 上一样；从这里开始，按照屏幕上的说明完成安装。
- en: License / Qt account
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许可证 / Qt 账户
- en: When it comes to the login screen, then you should enter your Qt account details
    if you have them. If you qualify for their open source license (GPL or LGPL),
    you can skip this step—to do so; make sure the email and password fields are empty.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当来到登录屏幕时，如果您有 Qt 账户详情，请输入。如果您符合他们的开源许可证（GPL 或 LGPL），您可以跳过此步骤——要这样做，请确保电子邮件和密码字段为空。
- en: Installing qt (the bindings)
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 qt（绑定）
- en: To use qt (the Go Qt bindings), we need to download the project and its dependencies
    and then run a setup script to configure and compile the library. If using Windows,
    it's recommended to use the MSYS2 Terminal described in the Appendix.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 qt（Go Qt 绑定），我们需要下载项目和其依赖项，然后运行一个设置脚本以配置和编译库。如果使用 Windows，建议使用附录中描述的 MSYS2
    终端。
- en: If you installed the Qt download to anything other than the default location,
    then make sure to set up the `QT_DIR` environment variable to the location you
    chose.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将 Qt 下载安装到了非默认位置，请确保将 `QT_DIR` 环境变量设置为所选位置。
- en: First, the library and its dependencies should be installed using the `go` tools,
    by running `go get github.com/sirupsen/logrus` and `go get github.com/therecipe/qt`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应使用 `go` 工具安装库及其依赖项，通过运行 `go get github.com/sirupsen/logrus` 和 `go get github.com/therecipe/qt`。
- en: 'Once the download has completed, we need to run the `qtsetup` tool, which is
    included in the qt project; so, within the `cmd/qtsetup` folder, execute `go run
    main.go`. Using a Linux Terminal, it should look something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，我们需要运行 `qtsetup` 工具，该工具包含在 qt 项目中；因此，在 `cmd/qtsetup` 文件夹中，执行 `go run main.go`。使用
    Linux 终端，它应该看起来像这样：
- en: '![](img/7edffb31-a6d7-43ad-a88a-49b9832ea4fa.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7edffb31-a6d7-43ad-a88a-49b9832ea4fa.png)'
- en: Executing the qtsetup script for therecipe/qt bindings
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 therecipe/qt 绑定的 qtsetup 脚本
- en: Once this process completes, the bindings should be ready to use. If you encounter
    errors, then it's probably because the Qt tools aren't correctly installed or
    the location was customized and you forgot to set the `QT_DIR` environment variable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦此过程完成，绑定应该可以使用了。如果您遇到错误，那么可能是因为 Qt 工具没有正确安装，或者位置被自定义了，而您忘记设置 `QT_DIR` 环境变量。
- en: Build
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'To build our first qt application with Go, let''s make another *Hello World* application.
    As with previous examples, we''ll make use of a simple vertical box layout within
    a single application window. The following code should be sufficient to load your
    first application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Go 构建我们的第一个 qt 应用程序，让我们再创建一个 *Hello World* 应用程序。与之前的示例一样，我们将在单个应用程序窗口内使用一个简单的垂直框布局。以下代码应该足以加载你的第一个应用程序：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's note a few details from this code snippet. You'll see that each of the
    widget constructor functions takes (typically) two parameters, each is the parent
    widget and a `flags` parameter. Additional types passed in will usually be added
    before these values with a note in the function name that there are additional
    parameters. For example, `widgets.NewQLabel2(title, parent, flags)` is equivalent
    to `widgets.NewQLabel(parent, flags).SetTitle(title)`. Additionally, you'll see
    that the layout is applied to a new `widgets.QWidget` through `SetLayout(layout)`,
    and that's set to the window content through `window.SetCentralWidget(widget)`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这段代码中注意一些细节。您会看到每个小部件构造函数通常接受两个参数，每个参数都是父小部件和一个 `flags` 参数。传递给这些值的附加类型通常会在函数名中添加一个注释，表明有额外的参数。例如，`widgets.NewQLabel2(title,
    parent, flags)` 等同于 `widgets.NewQLabel(parent, flags).SetTitle(title)`。此外，您会看到布局是通过
    `SetLayout(layout)` 应用到新的 `widgets.QWidget` 上的，并且通过 `window.SetCentralWidget(widget)`
    设置为窗口内容。
- en: 'To load the display and run the application, we call `window.Show()` and then
    `widgets.QApplication_Exec()`. This file is built in the usual way with `go build
    hello.go`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载显示并运行应用程序，我们调用 `window.Show()` 然后调用 `widgets.QApplication_Exec()`。此文件以通常的方式构建，使用
    `go build hello.go`：
- en: '![](img/5c9075ef-025a-43d9-a4af-2f3275a4b57e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c9075ef-025a-43d9-a4af-2f3275a4b57e.png)'
- en: Building is simple though the output file is rather large
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 构建很简单，但输出文件相当大
- en: The file built is quite large due to the size of the Qt framework. This will
    be reduced significantly when packaging for a specific distribution. This topic
    will be covered in depth in [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml),
    *Distributing your Application*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Qt 框架的大小，构建的文件相当大。在为特定发行版打包时，这将显著减少。这个主题将在第 14 章“分发你的应用程序”中深入探讨。
- en: Run
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: 'The output of the build phase is a binary that can be executed on the current
    computer, either on the command line or by double-clicking in a file manager.
    Additionally, you could execute it directly with `go run hello.go`—either way,
    you should see a simple window, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段的输出是一个可以在当前计算机上执行的二进制文件，无论是在命令行上还是在文件管理器中双击。此外，您还可以直接使用 `go run hello.go`
    来执行它——无论哪种方式，您都应该看到一个简单的窗口，如图所示：
- en: '![](img/1498312d-2fd5-4bdd-b0bc-b7435b659dc4.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1498312d-2fd5-4bdd-b0bc-b7435b659dc4.png)'
- en: qt Hello on Linux
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上运行 qt Hello
- en: '![](img/b241f60e-5044-47ce-975b-69de70895561.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b241f60e-5044-47ce-975b-69de70895561.png)'
- en: Running on macOS
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上运行
- en: At this stage, the binaries can be executed on a computer with the same architecture
    that also has Qt installed. We'll look at wider distribution later in this chapter.
    Before that, let's take a deeper look into the Qt API and how the qt bindings
    work.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，二进制文件可以在安装了 Qt 的具有相同架构的计算机上执行。我们将在本章后面讨论更广泛的分发。在此之前，让我们更深入地了解 Qt API 和
    qt 绑定的运作方式。
- en: Object model and event handling
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象模型和事件处理
- en: The Qt framework is written using the C++ language, and so much of its architecture
    will be familiar to those who've coded in C++ before. It's important to note that
    Go isn't a complete object-oriented language and, as such, doesn't match these
    capabilities directly. In particular, we should look at inheritance as it's important
    to the Qt object model.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 框架是用 C++ 语言编写的，因此其架构对之前使用过 C++ 编码的人来说非常熟悉。需要注意的是，Go 不是一个完整的面向对象语言，因此它不能直接匹配这些功能。特别是，我们应该关注继承，因为它对
    Qt 对象模型非常重要。
- en: Inheritance
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: The Qt API is a fully object-oriented model that makes heavy use of the inheritance
    model. While Go doesn't truly support object-oriented inheritance in the traditional manner,
    its composition approach is very powerful and works well in its place. The result
    means that you probably won't notice the difference! This only comes into play
    if you wish to implement a custom widget, which is out of scope for this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Qt API 是一个完全面向对象的模型，大量使用了继承模型。虽然 Go 并不完全支持传统方式的对象继承，但其组合方法非常强大，并且在其位置上运行良好。结果是，你可能不会注意到任何区别！这只有在你想实现一个自定义小部件时才会出现，而这超出了本章的范围。
- en: Memory management
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: As you'll have noticed in the preceding example, each widget expects the parent
    to be passed to the constructing function. This enables the Qt framework to handle
    the tidying up, and freeing of memory when a tree of widgets is removed. `QObject`
    (which is the base object for all of the Qt API) keeps track of its child objects
    and so, when being removed, can remove its children too. This makes the creation
    and deletion of complex widget hierarchies easier to handle correctly. To make
    use of this feature, you should always remember to pass the parent object to a
    widget's constructor (the Go functions starting with `New...`), despite the fact
    that passing `nil` may look like it's working.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的示例中所注意到的，每个小部件都期望将父对象传递给构造函数。这使得 Qt 框架能够处理小部件树的清理和内存释放。`QObject`（它是所有
    Qt API 的基对象）跟踪其子对象，因此当被移除时，它也可以移除其子对象。这使得创建和删除复杂的 widget 层次结构更容易正确处理。为了使用这个功能，你应该始终记得将父对象传递给小部件的构造函数（以
    `New...` 开头的 Go 函数），尽管传递 `nil` 可能看起来像是在工作。
- en: Signals and slots
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽
- en: Qt is, like GTK+, an event-driven framework and uses signals extensively to
    handle event management and data communications. In Qt, this concept is split
    into signals and slots; a signal is what will be generated when an event occurs
    and a slot is what can receive a signal. The action of setting a slot to receive
    a signal is called **connecting** and this causes a slot function to be called
    when its connected signal is invoked. In Qt, these are typed events meaning that
    each signal has a list of type parameters associated with it. When the signal
    is defined, this type is set and any slot wishing to connect to the signal will
    need to have the same type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 与 GTK+ 类似，是一个事件驱动的框架，并广泛使用信号来处理事件管理和数据通信。在 Qt 中，这个概念被分为信号和槽；信号是事件发生时将生成的内容，槽是可以接收信号的内容。将槽设置为接收信号的动作称为**连接**，这会导致当连接的信号被调用时，槽函数将被调用。在
    Qt 中，这些是类型化的事件，意味着每个信号都有一个与其关联的类型参数列表。当信号被定义时，这个类型被设置，任何希望连接到信号的槽都需要有相同的类型。
- en: 'In qt Go code, signals and slots are defined using struct tags such as `` _
    func(string) `signal:"mySignal"` `` and `` _ func(string) `slot:"mySlot"` ``,
    which provide metadata to the Go type system, much as our JSON example in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*. Given a struct,
    `s`, which defines these properties, we could set a function to execute when `mySignal`
    is fired with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 qt Go 代码中，信号和槽使用类似于 `func(string) `signal:"mySignal"`` 和 `func(string) `slot:"mySlot"``
    的结构标签来定义，这些标签为 Go 类型系统提供元数据，就像我们在第 3 章“Go to the Rescue!”中的 JSON 示例一样。给定一个定义这些属性的
    `s` 结构，我们可以设置一个函数，当 `mySignal` 触发时执行以下代码：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Signals and slots are what power user interfaces generated with Qt Designer
    and are the recommended way of handling multi-threaded applications. A signal
    may fire from a background thread and the user interface code can connect this
    signal to its own slot—in essence, listening for the signal. When the signal fires,
    any associated data (parameters to the signal) will be passed from one thread
    to another so it can be used safely within the GUI updates. In many ways, this
    is similar to how Go channels work, which we've discussed extensively in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽是 Qt Designer 生成的用户界面的动力源泉，也是处理多线程应用程序的推荐方式。一个信号可能从后台线程触发，用户界面代码可以将这个信号连接到自己的槽——本质上是在监听信号。当信号触发时，任何相关数据（信号的参数）将从一条线程传递到另一条线程，以便在
    GUI 更新中安全使用。在许多方面，这与我们在第 3 章“Go to the Rescue!”中广泛讨论的 Go 通道的工作方式相似。
- en: As qt is a lightweight binding to the Qt API, the Go-specific documentation
    is minimal but you can find out a lot more about the Qt design and all of the
    classes available in the official documentation available at [https://doc.qt.io/qt-5/classes.html](https://doc.qt.io/qt-5/classes.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Qt 是对 Qt API 的轻量级绑定，Go 特定的文档很少，但你可以在官方文档中找到更多关于 Qt 设计和所有可用类的信息，官方文档的网址是 [https://doc.qt.io/qt-5/classes.html](https://doc.qt.io/qt-5/classes.html)。
- en: Now that we know how a Qt application and the qt Go implementation are set up,
    let's explore a more complete application by returning to our GoMail example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Qt 应用程序和 qt Go 实现的设置，让我们通过回到我们的 GoMail 示例来探索一个更完整的应用程序。
- en: Sample application
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: To look at a more complete application, we'll dust off the original designs
    for the GoMail application—after all, they were created with Qt Designer in the
    first place. We'll recreate the exact layout generated in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk
    - Building Graphical Windows Applications,* and explain the implementation as
    we go.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一个更完整的应用程序，我们将重新审视GoMail应用程序的原始设计——毕竟，它们最初是用Qt Designer创建的。我们将重新创建[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)“构建图形窗口应用程序”中生成的确切布局，并在进行过程中解释实现方式。
- en: Layout
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'For the first time in our GoMail examples, we have a toolkit that provides
    all of the layouts required to match the user interface we designed at the beginning
    of [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits Using Existing
    Widgets*. That''s perhaps no surprise, as it was created using the Qt tools, but
    it''s a chance to explore the more complete set of layouts provided by Qt and
    made available using the qt bindings. The most useful ones are the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GoMail示例中，我们首次拥有了一个工具包，它提供了所有所需的布局来匹配我们在[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)“使用现有小部件的工具包”开始时设计的用户界面。这或许并不令人惊讶，因为它使用了Qt工具创建，但这是一个探索Qt提供的更完整布局集以及通过qt绑定提供的机会。最有用的布局如下：
- en: '| **Layout** | **Description** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **布局** | **描述** |'
- en: '| **box** | The box layout is very familiar by now; it lays out widgets in
    a horizontal or vertical box. Therefore, it''s created with `widgets.NewQVBoxLayout()` or `widgets.NewQVBoxLayout()` accordingly.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **框** | 框布局现在非常熟悉；它将小部件布局在水平或垂直框中。因此，它使用`widgets.NewQVBoxLayout()`或`widgets.NewQVBoxLayout()`相应地创建。
    |'
- en: '| **form** | This is a convenience layout that''s basically a two-column grid
    where all of the widgets in the left column are labels. This is styled accordingly
    to produce the design we saw in Qt Creator. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **表单** | 这是一个便利的布局，基本上是一个两列网格，其中左侧列的所有小部件都是标签。它根据Qt Creator中看到的设计进行了相应的样式化。
    |'
- en: '| **grid** | This layout represents a flexible grid layout so that cells aren''t
    forced to all be the same size but instead rows and columns flex to accommodate
    the minimum size of items packed into the grid. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **网格** | 这种布局代表了一种灵活的网格布局，使得单元格不必都强制保持相同的大小，而是行和列会根据网格中打包项目的最小尺寸进行伸缩以适应。
    |'
- en: '| **spacer** | While not strictly a layout, the spacer item can be used in
    layouts to create visual space. Constructed using `widgets.NewQSpacerItem(width,
    height, hPolicy, vPolicy)`, it''s possible to add various different types of space
    using this helpful class. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **间隔** | 虽然间隔项本身不是布局，但它可以在布局中用来创建视觉空间。使用`widgets.NewQSpacerItem(width, height,
    hPolicy, vPolicy)`构造，可以使用这个有用的类添加各种不同类型的间隔。 |'
- en: '| **stacked** | A stacked layout sets all child objects to be the full size
    of the containing widget, but ensures that only one can be visible at a time.
    The `SetCurrentWidget()` and `SetCurrentIndex()` functions can be used to control
    which child is visible. This is very useful for implementing tabbed panels or
    paged controls. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **堆叠** | 堆叠布局将所有子对象设置为包含小部件的全尺寸，但确保一次只能看到一个。可以使用`SetCurrentWidget()`和`SetCurrentIndex()`函数来控制哪个子对象可见。这对于实现标签面板或分页控件非常有用。
    |'
- en: Using this knowledge, we can re-create the GoMail browse interface using pure
    Qt widgets. A lot of this code will be familiar by now, but there are a number
    of notable differences. Firstly, you can see that layouts (as listed previously)
    are typically set on `widgets.QWidget` rather than creating a whole new widget
    for their own purpose. This approach means that the number of different widgets
    can be kept lower, but it also causes some functionality to be attached to the
    layout and not the widget. For example, the `widgets.NewQFormLayout()` we set
    on the `detail` widget is designed to lay out form components, and as such has
    helper functions to add rows (`form.AddRow3`, for example). To use these functions,
    we must keep a reference to the layout (the `form` variable in this code) to operate
    on. You can also see that `AddWidget()` is called on `widget.Layout()` rather
    than on `widget` directly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些知识，我们可以使用纯 Qt 小部件重新创建 GoMail 浏览界面。现在，大部分代码都很熟悉，但也有不少显著的不同之处。首先，你可以看到布局（如之前所列）通常设置在
    `widgets.QWidget` 上，而不是为它们自己的目的创建全新的小部件。这种方法意味着可以保持不同小部件的数量较低，但也导致一些功能被附加到布局上而不是小部件上。例如，我们设置在
    `detail` 小部件上的 `widgets.NewQFormLayout()` 是为了布局表单组件，因此具有添加行（例如 `form.AddRow3`）的辅助函数。要使用这些函数，我们必须保持对布局（本代码中的
    `form` 变量）的引用以进行操作。你还可以看到 `AddWidget()` 是在 `widget.Layout()` 上而不是直接在 `widget`
    上调用的。
- en: 'This snippet contains most of the code to create our basic layout. Some of
    the toolbar and menu code (which is rather repetitive) has been left out, but
    it can be found in the code repository that accompanies this book. We start with
    the imports and a basic skeleton for creating a menu bar:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段包含了创建我们基本布局的大部分代码。一些工具栏和菜单代码（相当重复）已被省略，但可以在伴随本书的代码仓库中找到。我们首先导入并创建一个基本的菜单栏框架：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And similarly, we can create a new toolbar using built-in icons:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用内置图标创建一个新的工具栏：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And lastly, we lay out the main content of the window:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们布局窗口的主要内容：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is similar in structure to the previous chapter (as GTK+
    and Qt APIs have many similarities), though the naming will remind you of [Chapter
    4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk - Building Graphical Windows
    Applications,* and the Walk example. Clearly, as Walk is based largely on Qt,
    the naming is often the same, but the qt APIs being used here don't offer the
    same declarative syntax and so must be created using the function-based constructors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码结构与上一章类似（因为 GTK+ 和 Qt API 有很多相似之处），尽管命名会让你想起第 4 章（3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml），*构建图形窗口应用程序*，以及
    Walk 示例。显然，由于 Walk 主要基于 Qt，命名通常是相同的，但这里使用的 Qt API 不提供相同的声明性语法，因此必须使用基于函数的构造函数来创建。
- en: 'This example introduces two new qt packages, `core` and `gui`. As you can see
    from the example, we use the `core` package with data models (which many of the
    more complex widgets make use of). The `gui` package provides helpful additions
    to make a user interface more compelling; in this instance, we''re looking up
    standard icons using the `gui.QIcon_FromTheme2` function. In a more complete application,
    we could provide fallback icons that would complete the Reply and Reply All toolbar
    buttons:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本例介绍了两个新的 Qt 包，`core` 和 `gui`。如你所见，我们使用 `core` 包与数据模型（许多更复杂的小部件都使用）一起使用。`gui`
    包提供了有助于使用户界面更具吸引力的辅助功能；在这种情况下，我们使用 `gui.QIcon_FromTheme2` 函数查找标准图标。在一个更完整的应用程序中，我们可以提供备选图标，以完成回复和全部回复的工具栏按钮：
- en: '![](img/ba6d0d00-306d-4898-976f-575f62f71bec.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba6d0d00-306d-4898-976f-575f62f71bec.png)'
- en: The complete layout of our GoMail application using qt
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Qt 的 GoMail 应用程序的完整布局
- en: As you can see from this screenshot, a qt application can look polished with
    even the most basic of code. You may notice the 1 above our email list instead
    of Inbox; this is due to a limitation in `core.QStringListModel` used for this
    layout example and should be addressed in our full implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如从这张截图所示，一个 Qt 应用程序甚至可以用最基础的代码看起来也很精致。你可能注意到了电子邮件列表上方的数字1而不是收件箱；这是由于用于此布局示例的
    `core.QStringListModel` 的限制，应在我们的完整实现中解决。
- en: The compose layout
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写布局
- en: 'The GoMail compose layout is even simpler: we use `widgets.QFormLayout` again,
    though the `To` field is the only line with a label included. For this simpler
    window, we create `widgets.QDialog` and set the layout directly on the dialog
    widget. To add the buttons at the bottom of the screen, we use a new `widgets.QWidget`
    with the layout set to `widgets.NewQHBoxLayout()` to lay the buttons out horizontally.
    To manage the right alignment, we first include `widgets.NewQSpacerItem()` in
    the button box before the buttons. Note lastly that we call `SetDefault(true)`
    on the `send` button so it becomes the default action:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: GoMail的撰写布局甚至更简单：我们再次使用`widgets.QFormLayout`，尽管`To`字段是唯一包含标签的行。对于这个更简单的窗口，我们创建`widgets.QDialog`并将布局直接设置在对话框小部件上。为了在屏幕底部添加按钮，我们使用一个新的`widgets.QWidget`，其布局设置为`widgets.NewQHBoxLayout()`以水平排列按钮。为了管理右对齐，我们在按钮之前首先包含`widgets.NewQSpacerItem()`在按钮框中。最后请注意，我们在`send`按钮上调用`SetDefault(true)`，使其成为默认操作：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the preceding code, we get the following desired outcome—a simple and
    familiar compose dialog window:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们得到以下期望的结果——一个简单且熟悉的撰写对话框窗口：
- en: '![](img/4ae3c61a-ffb3-4135-9f6d-7f0b58246388.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ae3c61a-ffb3-4135-9f6d-7f0b58246388.png)'
- en: The email compose dialog using qt widgets
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt小部件的电子邮件撰写对话框
- en: Now that the layout is complete, let's connect our test email server to show
    some email data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局已经完成，让我们将我们的测试电子邮件服务器连接起来，以显示一些电子邮件数据。
- en: Signalling
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: 'To complete the interaction of our GoMail examples, we''ll make use of the
    standard signals and slots within qt. Firstly, we need to set up an instance of
    our test email server and load the data. We add a `setMessage(*client.EmailMessage)`
    function to set the content of our labels, which can be called on the loading
    of our GUI and when the email list is clicked:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成GoMail示例的交互，我们将使用Qt中的标准信号和槽。首先，我们需要设置我们的测试电子邮件服务器的一个实例并加载数据。我们添加一个`setMessage(*client.EmailMessage)`函数来设置标签的内容，这个函数可以在我们的GUI加载时和电子邮件列表被点击时调用：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code to handle clicking on the email list looks something like the following
    snippet. We''re creating an anonymous function and connecting it to the `selectionChanged`
    signal. Remember to check whether there are no selected indexes before finding
    the selected row number:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 处理点击电子邮件列表的代码看起来像以下片段。我们创建一个匿名函数并将其连接到`selectionChanged`信号。记住在查找所选行号之前检查是否没有选中的索引：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we need to update our toolbar and menu to open the compose dialog when
    New is clicked. The `triggered` signal is the one to connect to; we need to wrap
    `showCompose()` in an anonymous function as the signal type passes a `bool` flag
    (for the checked status) that we want to ignore. The code is identical for toolbars
    and menus:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的工具栏和菜单，以便在点击“新建”时打开撰写对话框。要连接的信号是`triggered`；我们需要将`showCompose()`包裹在一个匿名函数中，因为信号类型传递一个`bool`标志（用于检查状态），而我们想忽略这个标志。代码对于工具栏和菜单是相同的：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similar code is used to handle button presses, which send a `clicked` signal;
    our compose dialog, `c`, will connect an anonymous function to compose an email,
    send it, and hide the dialog when Send is clicked:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相似的代码用于处理按钮点击，它发送一个`clicked`信号；我们的撰写对话框`c`将连接一个匿名函数来撰写电子邮件，发送它，并在点击“发送”时隐藏对话框：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thread handling
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程处理
- en: As shown in the preceding click handlers, the multi-threaded aspects of a complex
    application are handled by the signal-slot design in Qt. Code executed in a slot
    will be running on the correct thread to do graphical updates. Additionally, any
    data passed as part of the signal definition can be accessed in a thread-safe
    manner. We'll make use of this property to handle our background email notifications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的点击处理程序所示，复杂应用程序的多线程方面由Qt中的信号-槽设计处理。在槽中执行的代码将在正确的线程上运行以进行图形更新。此外，任何作为信号定义一部分传递的数据都可以以线程安全的方式访问。我们将利用这个特性来处理我们的后台电子邮件通知。
- en: 'To set this up, we create a new  custom signal. This is made possible by the
    `qtmoc` tool, which comes with therecipe/qt bindings. We''ll update our `mainUI`
    struct definition to inherit from `core.QObject` (this is a requirement) and then
    define an anonymous function with the `signal` tag, which defines the name of
    the signal:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个，我们创建一个新的自定义信号。这是由`qtmoc`工具实现的，该工具与recipe/qt绑定一起提供。我们将更新我们的`mainUI`结构定义，使其继承自`core.QObject`（这是一个要求），然后定义一个带有`signal`标记的匿名函数，该标记定义了信号的名字：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once this is set up, you should run the `qtmoc` tool in the current directory;
    this generates various methods including the `ConnectNewMail()` and `NewMail()`
    methods (the slots connecting method and signal trigger respectively), as well
    as a new constructor. Once this is complete, we must update our code to use the
    newly generated constructor (if your signals don''t trigger slots, then this step
    was probably missed):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，你应该在当前目录下运行 `qtmoc` 工具；这将生成包括 `ConnectNewMail()` 和 `NewMail()` 方法（分别连接方法和信号触发器）以及一个新的构造函数。一旦完成，我们必须更新我们的代码以使用新生成的构造函数（如果你的信号没有触发槽，那么这个步骤可能被遗漏了）：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then add new code to connect `prependEmail(client.EmailMessage)` to the
    `newMail` signal. Once that''s connected, we listen to the `server.Incoming()`
    channel and, each time a message arrives, we send the signal using the generated `NewMail(client.EmailMessage)`
    function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后添加新的代码来将 `prependEmail(client.EmailMessage)` 连接到 `newMail` 信号。一旦连接成功，我们就监听
    `server.Incoming()` 通道，并且每次有消息到达时，我们使用生成的 `NewMail(client.EmailMessage)` 函数发送信号：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this code in place, our background code will trigger the appropriate handlers
    and all updates occur on the correct thread for immediate updates to the screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，我们的后台代码将触发适当的处理程序，并且所有更新都将在正确的线程上发生，以便立即更新屏幕。
- en: Cross-compilation
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨编译
- en: Compiling a qt-based application for another desktop platform isn't currently
    supported in the same way that we've compiled other examples. There's an alternative
    approach, however, using Docker as a deployment method. Setting up the tools and
    running a build in this way is out of scope for this chapter, but you can read
    more about deploying qt apps at [github.com/therecipe/qt/wiki/Deploying-Application](https://github.com/therecipe/qt/wiki/Deploying-Application).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为其他桌面平台编译基于 Qt 的应用程序目前不支持与其他示例相同的方式。然而，有一个替代方法，即使用 Docker 作为部署方法。使用这种方式设置工具和运行构建超出了本章的范围，但你可以在
    [github.com/therecipe/qt/wiki/Deploying-Application](https://github.com/therecipe/qt/wiki/Deploying-Application)
    上了解更多关于部署 Qt 应用程序的信息。
- en: Theming
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题化
- en: The Qt theme (known as *Style* in Qt terminology) can be adjusted similarly
    to GTK apps in the previous chapter. Before Qt 5, the current theme could be configured
    using a standard setup application but in Qt 5, the aim was to fit in with the
    current desktop—therefore, the application style will adapt to blend in. It's
    possible to override these settings on a per-application basis. As our application
    passes the command-line parameters in our `QApplication` constructor (`widgets.NewQApplication(len(os.Args),
    os.Args)`), we inherit some helpful options, such as `-style=OtherStyle`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 主题（在 Qt 术语中称为 *Style*）可以像前一章中的 GTK 应用程序一样进行调整。在 Qt 5 之前，当前主题可以通过标准设置应用程序进行配置，但在
    Qt 5 中，目标是与当前桌面兼容——因此，应用程序样式将适应以融合。可以在每个应用程序的基础上覆盖这些设置。由于我们的应用程序在 `QApplication`
    构造函数中传递了命令行参数（`widgets.NewQApplication(len(os.Args), os.Args)`），我们继承了某些有用的选项，例如
    `-style=OtherStyle`。
- en: 'Another default parameter that can be very powerful for applications is `-reverse`.
    This option will tell all layouts to work in a right-to-left orientation instead
    of the default left to right:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能对应用程序非常有用的默认参数是 `-reverse`。此选项将告诉所有布局以从右到左的方向工作，而不是默认的从左到右：
- en: '![](img/7afeb70c-f3eb-458f-89c8-991a8356bbcd.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7afeb70c-f3eb-458f-89c8-991a8356bbcd.png)'
- en: GoMail with reversed layout
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 带有反向布局的 GoMail
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the popular Qt toolkit, its history, and how we
    can use it to build attractive graphical applications with Go. We saw how easy
    it is to create a GUI that works identically across many supported platforms.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了流行的 Qt 工具包，其历史以及我们如何使用它用 Go 构建吸引人的图形应用程序。我们看到了创建一个在许多支持的平台上工作方式相同的
    GUI 是多么容易。
- en: Through exploring our GoMail application, we found how the powerful layout and
    built-in standard icons help to quickly build an attractive user interface. The
    tools provided as part of therecipe's qt bindings allowed us to create custom
    signals to handle our background processing and avoid multi-threading issues.
    We'll look further into the distribution of these Go apps for multiple operating
    systems in [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml), *Distributing
    Your Application*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索我们的 GoMail 应用程序，我们发现强大的布局和内置的标准图标有助于快速构建吸引人的用户界面。therecipe 的 Qt 绑定提供的工具允许我们创建自定义信号来处理我们的后台处理并避免多线程问题。我们将在第
    14 章 [Distributing Your Application](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml)
    中进一步探讨这些 Go 应用的多操作系统分发。
- en: In [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern Graphical
    Toolkits*, we leave behind the familiar toolkits that make use of standard widget
    sets. We'll look at various widget toolkits that have either been designed from
    scratch for cross-platform delivery or to be a great match for the Go programming
    language.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)“现代图形工具包”中，我们告别了那些使用标准小部件集的熟悉工具包。我们将探讨各种小部件工具包，这些工具包要么是为了跨平台交付而从头设计的，要么是为了与Go编程语言完美匹配。
