- en: Shiny - Experimental Go GUI API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shiny - 实验性Go GUI API
- en: Shiny is an experimental GUI library designed from scratch and written purely
    in Go. It was created to explore what's possible when building a cross-platform
    GUI for the Go language. It is not an official GUI toolkit for Go (though it was
    created by developers at Google) but provides a solid basis for graphical applications
    on most supported Go platforms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny是一个从头开始设计和纯Go编写的实验性GUI库。它被创建来探索为Go语言构建跨平台GUI时可能实现的内容。它不是Go语言的官方GUI工具包（尽管它是由谷歌的开发者创建的），但它为大多数受支持的Go平台上的图形应用程序提供了一个坚实的基础。
- en: 'This chapter explores how to use the Shiny project to build cross-platform
    graphical applications without the need for C libraries or pre-installed dependencies.
    The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何使用Shiny项目构建跨平台的图形应用程序，无需C库或预安装的依赖项。本章将涵盖以下主题：
- en: The design principles of the Shiny project and its widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shiny项目的原理及其小部件的设计
- en: How the toolkit is built to support multiple platforms without external drivers
    or native libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具包是如何构建以支持多个平台而无需外部驱动程序或本地库的
- en: Building a basic graphical application that can easily cross-compile to different
    systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个可以轻松交叉编译到不同系统的基本图形应用程序
- en: Creating a a complete application using Shiny
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shiny创建一个完整的应用程序
- en: At the end of this chapter, you should be well-versed in this experimental new
    API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对这一实验性新API了如指掌。
- en: Background and the vision for Shiny
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shiny的背景和愿景
- en: The Shiny project was created in an effort to understand how a graphical application
    toolkit could be created to be in keeping with the Go idiom. Therefore, it is
    important that its API and methodologies should match the Go language semantics
    and standard library, its dependencies should be only pure Go libraries or existing
    system routines, and it should provide a modern approach to developing an application
    GUI. Much of this is only possible if you start from scratch, as you can tell
    from the toolkit bindings we saw in [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml), *Toolkits
    Using Existing Widgets* of this book. It lives in the `golang.org/x/exp/shiny`
    repository—an experimental extension to the Go libraries.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny项目是为了理解如何创建一个符合Go语法的图形应用程序工具包而创建的。因此，它的API和方法应该与Go语言语义和标准库相匹配，其依赖项应该是纯Go库或现有系统例程，并且它应该提供一种现代的方法来开发应用程序GUI。正如我们从本书的[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)中看到的工具包绑定所知，这一切大多只有在从头开始时才有可能。它位于`golang.org/x/exp/shiny`存储库中——这是Go库的一个实验性扩展。
- en: The project was started as an investigation by Nigel Tao, a Go developer who
    had been working on `golang.org/x/mobile` (on which Shiny depends), as he wanted
    to see desktop applications supported by a new API. After substantial development,
    it was proposed that this be added as an experimental project within the [golang.org](http://www.golang.org/) repositories,
    which was accepted in 2015\. It is expected that, at some future point, the commonality
    between `golang.org/x/mobile` and `golang.org/x/exp/shiny` will be captured in
    a separate project, leaving the mobile and desktop specific portions in their
    respective projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目最初是由Go开发者Nigel Tao发起的一项调查，他一直在从事`golang.org/x/mobile`（Shiny所依赖的项目），因为他想看到桌面应用程序由新的API支持。经过大量开发后，建议将其添加为[golang.org](http://www.golang.org/)存储库中的实验性项目，并于2015年获得批准。预计在未来某个时刻，`golang.org/x/mobile`和`golang.org/x/exp/shiny`之间的共性将体现在一个独立的项目中，而移动和桌面特定的部分将保留在其各自的项目中。
- en: The project's development has slowed in recent years but it remains a strong
    foundation for graphical applications to be built upon. Whether the project will
    see a resurgence or instead become the base upon which another is built is unclear
    at this time. Either way, it is an excellent low-level graphical API for Go and
    so we will look into the details of it and start to build a sample application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，该项目的开发速度有所放缓，但它仍然是构建图形应用程序的强大基础。目前尚不清楚该项目是否会复兴，或者将成为其他项目的基础。无论如何，它是一个优秀的低级图形API，适用于Go语言，因此我们将深入研究其细节，并开始构建一个示例应用程序。
- en: Design and supported platforms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和受支持的平台
- en: The Shiny project has been designed to ensure good separation between the widget
    code and the lower-level rendering code that widgets utilize. It is also built
    with the understanding that graphical drivers may be useful on more than a single
    platform and could potentially be changed or added to over time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny 项目被设计成确保小部件代码和底层渲染代码之间有良好的分离。它还基于这样的理解：图形驱动程序可能对多个平台都很有用，并且随着时间的推移可能会被更改或添加。
- en: Architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: The Shiny API is split into two layers, a lower layer that handles graphical
    buffers and rendering, and a higher layer where the widget and layout code is
    located. Each layer has clear responsibilities and their separation helps to maintain
    a clean API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny API 被分为两层，底层处理图形缓冲区和渲染，高层则存放小部件和布局代码。每一层都有明确的职责，它们的分离有助于保持 API 的整洁。
- en: Lower layer
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层
- en: 'The lower layer of the Shiny API is responsible for creating a render context
    for each platform supported. It is also responsible for handling input from keyboard
    and other peripheral devices. The main concepts of the graphical presentation
    are **Buffer**s, **Texture**s, and **Window**s:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny API 的底层负责为每个支持的平台创建渲染上下文。它还负责处理来自键盘和其他外围设备输入。图形展示的主要概念是 **缓冲区**、**纹理**
    和 **窗口**：
- en: '**Buffer:** A buffer refers to an array of pixel data in memory. This could
    be a loaded image, a canvas for drawing, or any other graphical data that needs
    to be presented within an application.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区**：缓冲区指的是内存中像素数据的一个数组。这可能是加载的图像、绘图画布或任何需要在应用程序中展示的其他图形数据。'
- en: '**Texture:** A texture is a handle to a snapshot of graphical state that''s
    ready to be rendered. It will not be accessible to the application. A texture
    may be rendered immediately (such as the current widget state) or stored and rendered
    many times in the future (such as an image).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：纹理是对图形状态的快照的引用，它已准备好进行渲染。它将不可用于应用程序。纹理可以立即渲染（例如当前小部件状态）或存储并在将来多次渲染（例如图像）。'
- en: '**Window:** A window is the location of an application''s graphical output.
    Textures are rendered to the window after certain transformations (determined
    by the driver) have been applied.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口**：窗口是应用程序图形输出的位置。在应用了某些变换（由驱动程序确定）后，纹理将被渲染到窗口中。'
- en: In normal application flow, the code of a graphical user interface will update
    a widget or layout state—resulting in a buffer's contents being updated. This
    buffer will then be uploaded to a texture in preparation for being drawn by the
    driver. The texture will then be rendered to the application window, potentially
    through transformations within the driver or the underlying platform's graphical
    implementation. If you are familiar with how OpenGL works, then the processes
    will seem quite familiar—this is no coincidence, as the approach is well-proven
    and one of the Shiny drivers uses the OpenGL APIs. For most application developers,
    the existence of textures will not be visible or important, but it can help to
    consider the process when optimizing your code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的应用程序流程中，图形用户界面的代码将更新小部件或布局状态——导致缓冲区内容更新。然后，该缓冲区将被上传到纹理中，以便由驱动程序进行绘制。纹理随后将被渲染到应用程序窗口，可能通过驱动程序或底层平台的图形实现中的变换。如果你熟悉
    OpenGL 的工作方式，那么这些过程将看起来非常熟悉——这不是巧合，因为这种方法已被充分验证，Shiny 驱动程序之一就使用了 OpenGL API。对于大多数应用程序开发者来说，纹理的存在可能不可见或不重要，但在优化代码时考虑这个过程可能会有所帮助。
- en: The driver also handles user interactions, encapsulating them as `mouse.Event`
    and `key.Event` structures (defined in `x/mobile/event`). A `widget.Widget` can
    register to receive these events, using a filter that will determine which are
    relevant to that object, and mark them as handled. Alternatively, an application
    could access the event queue directly from `screen.Window`, where calling `NextEvent()`
    would wait until another event occurs. An application that takes this approach
    should be aware of the vast number of events that can be generated by Shiny (see
    *Example* in the *Getting started* section later in this chapter). When working
    with events, the Shiny project includes a powerful gesture package, that enables
    you to filter on `gesture.Event`, which describes more intent-based information
    than lower-level data. Helpful event types include `gesture.TypeDrag`, `gesture.TypeIsLongPress`,
    and `gesture.TypeIsDoublePress` (the event type is accessible through `Event.Type` on
    gesture events).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序还处理用户交互，将它们封装为`mouse.Event`和`key.Event`结构（在`x/mobile/event`中定义）。一个`widget.Widget`可以注册接收这些事件，使用过滤器来确定哪些与该对象相关，并将它们标记为已处理。或者，应用程序可以直接从`screen.Window`访问事件队列，调用`NextEvent()`将等待另一个事件发生。采用这种方法的程序应该意识到Shiny可以生成大量的事件（参见本章后面的*入门*部分中的*示例*）。当处理事件时，Shiny项目包括一个强大的手势包，它允许你根据`gesture.Event`进行过滤，该事件描述了比底层数据更多的基于意图的信息。有用的事件类型包括`gesture.TypeDrag`、`gesture.TypeIsLongPress`和`gesture.TypeIsDoublePress`（事件类型可以通过手势事件上的`Event.Type`访问）。
- en: Higher layer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高层
- en: Higher-layer APIs are focused on widgets and the overall layout and behavior
    of a graphical user interface. Working at this level, a developer wouldn't expect
    to be dealing with buffers and events but with high-level concepts such as buttons,
    text areas, and layouts. The types and functions defined at this layer (within
    the `widget` package) are designed to be easy to understand from a high level
    and includes graphical user interface concepts that will be familiar to most developers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 高层API专注于小部件和图形用户界面的整体布局和行为。在这个级别工作，开发者不会期望处理缓冲区和事件，而是处理按钮、文本区域和布局等高级概念。在这个层（在`widget`包内）定义的类型和函数旨在从高层次易于理解，并包括大多数开发者都熟悉的图形用户界面概念。
- en: The Shiny widgets (detailed further in the *Widgets and material design* section
    later in this chapter) are all written in pure Go and encapsulate any widget logic
    (such as input handling), as well as rendering (by implementing the `node.PaintBase()`
    or `node.Paint()` functions). This allows the user interface code to remain completely
    detached from the drivers for better testing and to promote consistency across
    all supported operating systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny小部件（在本章后面的*小部件和材料设计*部分中进一步详细说明）都是用纯Go编写的，并封装了任何小部件逻辑（如输入处理），以及渲染（通过实现`node.PaintBase()`或`node.Paint()`函数）。这使得用户界面代码可以完全与驱动程序分离，以便更好地测试，并促进所有支持的操作系统的统一性。
- en: Supported platforms
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持的平台
- en: The Shiny project currently supports Windows, macOS, Linux, DragonFly BSD, and
    OpenBSD. Other BSD distributions or Unix systems that use X11 (see the following
    discussion of drivers) may work but are not officially supported at this time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny项目目前支持Windows、macOS、Linux、DragonFly BSD和OpenBSD。其他使用X11的BSD发行版或Unix系统（参见以下关于驱动程序的讨论）可能可以工作，但在此时尚未官方支持。
- en: The code required to support an operating system is relatively lightweight if
    one of the existing drivers is able to run. For example, if OpenGL is installed
    on a not-yet-supported platform, then you may be able to add the operating system-specific
    code to wire it in. In this situation, a platform-specific Go file would need
    to open a window and handle any platform-specific input or device setup for the
    OpenGL window.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有的驱动程序能够运行，支持操作系统的代码相对较轻量。例如，如果在一个尚未得到支持的平台上安装了OpenGL，那么你可能能够添加操作系统特定的代码来连接它。在这种情况下，需要为特定平台创建一个Go文件来打开窗口，并处理OpenGL窗口的任何平台特定输入或设备设置。
- en: On a platform where an existing driver does not currently work, it would be
    a tremendous amount of work to add support. As well as the window- and user-interaction
    code, it would be necessary to write the graphical renderer and presentation layer
    from scratch or provide an API bridge to an existing one. Such an implementation
    would have to handle the complete set of draw primitives and transformations utilized
    by the main Shiny code (such a list is outside the scope of this book).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现有驱动程序当前无法工作的平台上，添加支持将是一项巨大的工作。除了窗口和用户交互代码外，还需要从头编写图形渲染器和表示层，或者提供一个API桥接到现有的一个。这种实现必须处理主Shiny代码使用的完整绘图原语和变换集（此类列表超出了本书的范围）。
- en: Drivers currently included
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前包含的驱动程序
- en: 'Shiny has three complete drivers at the time of writing (**win**, **gl,** and
    **x11)** and each of these drivers must implement all of the input and output
    capabilities of the Shiny toolkit. The output portion of a driver is required
    to define a suitable `screen.Texture` provider so that buffers can be uploaded
    ready for rendering and to handle the rendering process. On the input side, a
    driver must handle mouse and keyboard events and translate them into `golang.org/x/mobile` types
    that can then be filtered by the Shiny event-handling code. The details of each
    driver are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Shiny有三个完整的驱动程序（**win**、**gl**和**x11**），并且这些驱动程序必须实现Shiny工具包的所有输入和输出功能。驱动程序输出部分需要定义一个合适的`screen.Texture`提供者，以便将缓冲区上传并准备好进行渲染，并处理渲染过程。在输入方面，驱动程序必须处理鼠标和键盘事件，并将它们转换为`golang.org/x/mobile`类型，然后由Shiny事件处理代码进行过滤。每个驱动程序的详细信息如下：
- en: '**gl:** The most commonly used driver, built on top of the cross-platform OpenGL,
    it makes use of this standard API for graphical display. Many operating systems
    provide this functionality, though it should be noted that this may not be supported
    on all devices.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gl**：最常用的驱动程序，基于跨平台的OpenGL构建，它利用这个标准API进行图形显示。许多操作系统提供此功能，但应注意的是，这可能在所有设备上都不受支持。'
- en: '**win:** The win driver is built specifically for the Microsoft Windows operating
    system to work without the OpenGL APIs. Rendering is provided by the **Graphics
    Device Interface** (**GDI**).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**win**：win驱动程序专门为Microsoft Windows操作系统构建，无需OpenGL API即可工作。渲染由**图形设备接口**（**GDI**）提供。'
- en: '**x11:** The X11 driver provides support for the standard graphical desktop
    platform on Linux and Unix. It communicates directly with the *XServer* and uses
    the **SHared Memory** (**SHM**) extension for communicating image data efficiently.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x11**：X11驱动程序为Linux和Unix上的标准图形桌面平台提供支持。它直接与*XServer*通信，并使用**共享内存**（**SHM**）扩展来有效地通信图像数据。'
- en: Between these drivers, there is at least one render definition for all of the
    operating systems supported by the toolkits described earlier in this book, and
    potentially more. These details shouldn't be a concern day to day when programming
    with Shiny but it helps to understand possible extensions in the future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些驱动程序之间，至少为本书前面描述的工具包支持的操作系统提供了至少一个渲染定义，可能还有更多。这些细节在日常使用Shiny编程时不应成为问题，但了解未来的可能扩展是有帮助的。
- en: Getting started with Shiny
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Shiny
- en: In keeping with the design of Shiny to not depend on any native libraries or
    system dependencies, there are no prerequisites to using it. So, we can jump straight
    into getting the library installed and see it in action.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循Shiny的设计原则，不依赖于任何本地库或系统依赖项，因此使用Shiny没有先决条件。因此，我们可以直接开始安装库并看到它的实际应用。
- en: Setup
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Installing the Shiny library is as simple as installing the Go files from `golang.org/x/exp/shiny`
    and its `x/mobile` and `x/image` dependencies. As these are top-level projects,
    you may see a warning about no Go files—you can ignore this, as the APIs will
    be installed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Shiny库就像安装来自`golang.org/x/exp/shiny`的Go文件及其`x/mobile`和`x/image`依赖项一样简单。由于这些都是顶级项目，您可能会看到有关没有Go文件的警告——您可以忽略这个警告，因为API将被安装：
- en: '![](img/1ccc3970-43df-461b-8e14-43fd0ab5b9d8.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ccc3970-43df-461b-8e14-43fd0ab5b9d8.png)'
- en: Getting x/exp/shiny will download the package contents
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获取x/exp/shiny将下载包内容
- en: No extra libraries or system configuration are required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要额外的库或系统配置。
- en: Example
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'Before we start building an application, let''s load an example project to
    check that Shiny is installed and working correctly. The project provides various
    example projects—we will check the one called *basic*. Simply change to the `examples/basic`
    directory and run `main.go`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建应用程序之前，让我们加载一个示例项目来检查Shiny是否已安装并且工作正常。该项目提供了各种示例项目——我们将检查名为*basic*的项目。只需切换到`examples/basic`目录并运行`main.go`：
- en: '![](img/338a4a6e-9938-4b01-86ce-e77f15bbc616.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/338a4a6e-9938-4b01-86ce-e77f15bbc616.png)'
- en: Launching the basic Shiny example
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 启动基本的Shiny示例
- en: 'After launching, you should see the following window and (as illustrated in
    the preceding) the output of all of the events triggered by the application. The
    size of the window may vary depending on the operating system you are running,
    due to driver default values:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，你应该看到以下窗口，以及（如前所述）由应用程序触发的事件输出。窗口的大小可能因你运行的操作系统而异，这是由于驱动程序的默认值：
- en: '![](img/c33590d3-f78b-456f-b3f5-b19fe63fdf3c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c33590d3-f78b-456f-b3f5-b19fe63fdf3c.png)'
- en: A rather unconventional example application
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相当不寻常的示例应用
- en: As you can see, this example application is unlike the other toolkits we've
    explored. This represents the main focus of the Shiny project as primarily a technology
    demo.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这个示例应用与其他我们探索的工具包不同。这代表了Shiny项目的主要焦点，即作为一个技术演示。
- en: Cross-compiling
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译
- en: 'As a project that aims to be written purely in Go, one of its goals is to be
    just as easy to cross-compile for different platforms as it is to build for the
    current operating system. In cases where the Shiny driver for the operating system
    is pure Go (as is currently the case for **windows** and **x11**, used by Linux
    and BSD), compiling for a specific operating system is as simple as using the
    `GOOS` parameter, as described in [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml),
    *Go to the Rescue!*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旨在完全用Go编写的项目，其目标之一是使其交叉编译到不同平台与为当前操作系统构建一样简单。在Shiny驱动程序是纯Go（如当前**windows**和**x11**，由Linux和BSD使用）的操作系统的情况下，为特定操作系统编译就像使用`GOOS`参数一样简单，如[第3章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)中所述，*Go来拯救！*：
- en: '![](img/72688dd8-3f79-4fa7-bd44-baf54fd17b27.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72688dd8-3f79-4fa7-bd44-baf54fd17b27.png)'
- en: Compiling Linux and Windows binaries from a Linux Command Prompt
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux命令提示符编译Linux和Windows的二进制文件
- en: The **gl** driver that provides hardware-accelerated rendering (used by macOS
    and Linux) depends on a system API that is not currently available without CGO
    and so is more challenging to cross-compile. Through the toolkit design, it's
    possible to use the **x11** driver for a Unix target platform if CGO is not available—so
    Linux or BSD can still be cross compiled.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 提供硬件加速渲染（由macOS和Linux使用）的**gl**驱动程序依赖于一个当前没有CGO就无法获得的系统API，因此交叉编译更具挑战性。通过工具包设计，如果CGO不可用，可以使用**x11**驱动程序为Unix目标平台，因此Linux或BSD仍然可以进行交叉编译。
- en: Note that cross-compiling a Shiny application for Linux will result in an application
    that does not have graphical acceleration enabled. This can be overcome by using
    `CGO_ENABLED=1` and installing various libraries but it is easily forgotten, so
    it's advisable to set up a dedicated Linux build environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为Linux交叉编译Shiny应用程序将导致应用程序没有启用图形加速。这可以通过使用`CGO_ENABLED=1`并安装各种库来解决，但它很容易被遗忘，因此建议设置一个专门的Linux构建环境。
- en: 'This means that, from macOS, we can cross-compile both Linux and Windows executables
    by simply setting the appropriate `GOOS` variable as would be expected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，从macOS出发，我们可以通过简单地设置适当的`GOOS`变量来交叉编译Linux和Windows的可执行文件，正如预期的那样：
- en: '![](img/13bce09b-80e8-4ed2-ae16-7a3d2f7346f5.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13bce09b-80e8-4ed2-ae16-7a3d2f7346f5.png)'
- en: Cross-compiling for macOS
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为macOS交叉编译
- en: With Windows and Linux (and some BSD flavours), all cross-compiling completes
    without CGO, therefore, we only need to look at macOS as a special case. To cross-compile
    successfully for macOS, we must add `CGO_ENABLED=1` to our build, which will then
    look for the required system libraries. Clearly, these are not normally available
    and so we must set up our development environment to provide the required APIs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows和Linux（以及一些BSD版本），所有交叉编译都不需要CGO，因此我们只需要关注macOS作为一个特殊情况。为了成功为macOS交叉编译，我们必须在我们的构建中添加`CGO_ENABLED=1`，这将使构建过程寻找所需的系统库。显然，这些库通常不可用，因此我们必须设置我们的开发环境以提供所需的API。
- en: The procedure for setting up the clang binary and required API bundles for macOS
    cross-compiling is a complicated process, but if you worked through [Chapter 5](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml),
    *andlabs UI - Cross-platform Native UIs*, this will already be set up. If you've
    jumped straight to this chapter, then you may need to follow the steps in the
    [Appendix](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup, *under
    *Cross-compiling for macOS with cgo*. Once that's complete, you should have a
    new compiler available named `o32-clang`, which is able to link to macOS Foundation
    APIs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用于macOS交叉编译的clang二进制文件和所需API包的过程可能很复杂，但如果你已经完成了[第5章](4b414e87-1c86-4d14-b88b-cb3e01c1fabe.xhtml)，*andlabs
    UI - 跨平台原生UIs*，那么这些设置已经完成。如果你直接跳到了这一章，那么你可能需要遵循[附录](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)，*跨平台编译设置，*在*使用cgo进行macOS交叉编译*部分中的步骤。一旦完成，你应该会有一个名为`o32-clang`的新编译器可用，它能够链接到macOS
    Foundation API。
- en: 'To build the application, we now set up the `GOOS` and `CGO_ENABLED` flags
    as before, but also specify the compiler to use through an extra `CC` environment
    variable, setting it to `o32-clang`. With that configuration complete, we can
    build a macOS Shiny application from our Linux Terminal:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建应用程序，我们现在设置`GOOS`和`CGO_ENABLED`标志，就像之前一样，但还通过额外的`CC`环境变量指定要使用的编译器，将其设置为`o32-clang`。完成此配置后，我们可以从Linux终端构建macOS
    Shiny应用程序：
- en: '![](img/f1a1b415-fd9b-4629-9ff5-19c88243f0e5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1a1b415-fd9b-4629-9ff5-19c88243f0e5.png)'
- en: Building a macOS application from a Linux terminal
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux终端构建macOS应用程序
- en: Applications built in this manner will have full OpenGL acceleration as though
    they were built directly on a macOS computer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建的应用程序将具有完整的OpenGL加速，就像它们是在macOS计算机上直接构建的一样。
- en: Now that we've seen all of the details for building with Shiny, let's explore
    how these applications are designed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了使用Shiny构建的所有细节，让我们来探索这些应用程序是如何设计的。
- en: Widgets and material design
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件和材料设计
- en: Before we can start a simple application, we need to understand more about Shiny
    widgets and how their visual design impacts development. The other toolkits that
    we've looked at didn't need this understanding to start using the API, but the
    experimental status of the higher-level APIs in Shiny means that even a *hello
    world* application requires some understanding of how the toolkit functions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始一个简单的应用程序之前，我们需要更多地了解Shiny小部件及其视觉设计对开发的影响。我们之前探讨的其他工具箱在使用API时不需要这种理解，但Shiny中高级API的实验性状态意味着即使是“hello
    world”应用程序也需要对工具箱的工作方式有一定的了解。
- en: Before we get into the details of the widgets that Shiny provides and how to
    work with them, let's take a look at the design and iconography of the Shiny project.
    This design takes a different approach to the toolkits we've previously looked
    at in this book, but it should be familiar to any Android app developers or users
    of the Google product suite.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解Shiny提供的小部件及其使用方法之前，让我们先看看Shiny项目的整体设计和图标设计。这种设计方法与我们在本书中之前探讨的工具箱有所不同，但对于任何Android应用开发者或Google产品套件的用户来说，应该都很熟悉。
- en: Design
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: 'Material design, if you are not already familiar with the concept, can be defined
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对“材料设计”这个概念还不熟悉，可以这样定义：
- en: '... an adaptable system of guidelines, components, and tools that support the
    best practices of user interface design"'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '...一个灵活的指南、组件和工具系统，支持用户界面设计的最佳实践"'
- en: -[material.io](https://material.io/)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: -[material.io](https://material.io/)
- en: The design principles will be familiar to anyone with an Android smartphone
    or tablet and are somewhat similar to the user interface design adopted by Microsoft
    for recent releases of the Windows operating system, which support tablets and
    touch screen user input. The approach aims to help developers quickly create beautiful
    applications and to ease communication between developers and designers. The *design
    language* also helps to promote a consistent user experience in a world where
    applications are trying to stand out with their own brand design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计原则对于拥有Android智能手机或平板电脑的人来说都很熟悉，并且与微软为最近发布的支持平板电脑和触摸屏用户输入的Windows操作系统所采用的用户界面设计有些相似。这种方法旨在帮助开发者快速创建美观的应用程序，并简化开发者和设计师之间的沟通。这种*设计语言*也有助于在应用程序试图通过自己的品牌设计脱颖而出的世界中，促进一致的用户体验。
- en: 'An application that utilizes the material design principles will not look identical
    to all of the others, but will have sufficient similarities that a user should
    have no trouble understanding how it works. Colors, layouts, and navigation can
    be different from one interface to another, as long as they follow the guidelines
    set out. Material design includes some standard color palettes and advice for
    creating custom ones for your needs. Layouts and navigation widgets similarly
    have standard implementations, but these can be extended and used to suit the
    context. These standard widgets are called *material components* and have been
    created for Android, iOS, Flutter, and the web—Shiny is one potential approach
    to bringing them to desktop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 利用材料设计原则的应用程序可能不会与所有其他应用程序完全相同，但将具有足够的相似性，用户应该不会难以理解其工作方式。颜色、布局和导航可能因界面而异，只要它们遵循设定的指南。材料设计包括一些标准调色板和创建自定义调色板的建议，以满足您的需求。布局和导航小部件也有标准实现，但可以根据上下文进行扩展和使用。这些标准小部件被称为*材料组件*，它们是为Android、iOS、Flutter和网页创建的——Shiny是将它们带到桌面的一种潜在方法：
- en: '![](img/626d86cb-3063-4955-99e8-4c510d3adf3f.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/626d86cb-3063-4955-99e8-4c510d3adf3f.png)'
- en: 'An Android app demonstrating material design. Image copyright: Google.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 展示材料设计的Android应用程序。图片版权：Google。
- en: There are many tools online to help you learn about and adopt material design
    principles. They can be found on the material design website at [material.io](https://material.io/).
    Let's explore a few of the details that are at the core of the Shiny API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在线有许多工具可以帮助您了解和采用材料设计原则。它们可以在材料设计网站上找到，网址为[material.io](https://material.io/)。让我们探索Shiny
    API核心的一些细节。
- en: Icons
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图标
- en: 'The material design project has created a standard set of icons that are freely
    available to use in any application. Integrating these clear, concise icons into
    your user interface adds simple-to-understand hints that are consistent with other
    applications and can alleviate the need for too much text in the resulting user
    interface. Shiny bundles the most commonly used icons in the `materialdesign/icons` package
    and they can be referenced by name through the API. To see the list of names and
    the icons, you can run the Shiny *IconGallery* example (pictured in the following
    screenshot):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计项目创建了一套标准的图标，这些图标可以免费在任何应用程序中使用。将这些清晰、简洁的图标集成到用户界面中，可以添加简单易懂的提示，与其它应用程序保持一致，并可以减少最终用户界面中过多的文本。Shiny将最常用的图标打包在`materialdesign/icons`包中，并且可以通过API通过名称引用。要查看名称和图标的列表，可以运行Shiny的*IconGallery*示例（如图中所示）：
- en: '![](img/c9af972e-e8e9-4075-98d2-05e57fe1fa52.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9af972e-e8e9-4075-98d2-05e57fe1fa52.png)'
- en: Shiny includes the material icon set as vector graphics
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny包括矢量图形的材料图标集
- en: The icons can be painted within a `node.PaintBase()` method by creating an `iconvg.Rasterizer` instance
    for `node.PaintBaseContext` and calling `iconvg.Decode()` for the icon reference
    (these icons are stored in the compact IconVG format). Examples of this code in
    action can be found later in the chapter (or in the Shiny example code).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图标可以通过在`node.PaintBase()`方法中创建一个`iconvg.Rasterizer`实例来绘制，并为`node.PaintBaseContext`调用`iconvg.Decode()`来解码图标引用（这些图标以紧凑的IconVG格式存储）。本章后面（或Shiny示例代码中）可以找到此代码的示例。
- en: Themes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: One of the central concepts in material design is the color palette—while it
    does not mandate the colors that an application can use, it has very clear rules
    about color choice and combinations that work. Designers are encouraged to pick
    a primary color from the standard palettes (used in most user interface elements)
    and a secondary color (for highlights and accents) that complement each other.
    For each color, there are standard light and dark variants, which can add depth
    to an application interface. You can explore these through the online color tool
    at [material.io/tools/color](https://material.io/tools/color).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计中的一个核心概念是调色板——虽然它不强制规定应用程序可以使用的颜色，但它对颜色选择和搭配有非常明确的规则。鼓励设计师从标准调色板（用于大多数用户界面元素）中选择一个主色（用于突出显示和强调），以及一个辅助色（用于辅助色和强调色），以相互补充。对于每种颜色，都有标准的浅色和深色变体，这可以为应用程序界面增加深度。您可以通过[material.io/tools/color](https://material.io/tools/color)上的在线颜色工具来探索这些。
- en: 'The palette that Shiny uses follows this approach; the available colors are:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny使用的调色板遵循这种方法；可用的颜色有：
- en: '`theme.Foreground`: The standard foreground color for the theme—used for text
    and icons'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme.Foreground`：主题的标准前景色——用于文本和图标'
- en: '`theme.Background`: The standard background color for containers'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme.Background`：容器标准背景颜色'
- en: '`theme.Neutral`: A background color for smaller areas that should be distinct
    from the background'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme.Neutral`：较小区域的后景色，应与背景区分开来'
- en: '`theme.Light`: A lighter version of the neutral color'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme.Light`：中性颜色的较浅版本'
- en: '`theme.Dark`: A darker version of the neutral color'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme.Dark`：中性颜色的较深版本'
- en: '`theme.Accent`: The main color from the secondary palette, used for highlighting
    key elements'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme.Accent`：次要调色板中的主颜色，用于突出显示关键元素'
- en: Colors in the Shiny API are passed using the `theme.Color` type instead of the
    golang `color.Color` type. This ensures that the colors used are from the theme
    palette. From a theme color type, you can call the `Color()` function to get a
    standard color type or the `Uniform()` function to get `image.Uniform` which is
    used to draw filled rectangles in a `Paint()` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shiny API中，颜色是通过`theme.Color`类型而不是golang的`color.Color`类型传递的。这确保了使用的颜色来自主题调色板。从主题颜色类型中，您可以调用`Color()`函数来获取标准颜色类型或调用`Uniform()`函数来获取`image.Uniform`，这在`Paint()`函数中用于绘制填充矩形。
- en: Applications can choose to use the built-in theme (`theme.Default`) or to provide
    their own. Any type that implements `theme.Theme` can be used in the rendering
    of a Shiny GUI.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以选择使用内置主题（`theme.Default`）或提供自己的主题。任何实现了`theme.Theme`类型的类型都可以用于Shiny GUI的渲染。
- en: Widgets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: 'As a project that has focused more on the capabilities of cross-platform graphical
    rendering on the lower layer, Shiny toolkit does not come with many standard widgets.
    A lot of work has gone in to setting up the building blocks so that applications
    can provide their own widgets, but if you are looking to use built-in types, the
    list provided by the `widget` package is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更专注于底层跨平台图形渲染能力的项目，Shiny工具包不附带许多标准小部件。已经投入了大量工作来设置构建块，以便应用程序可以提供自己的小部件，但如果您想使用内置类型，`widget`包提供的列表如下：
- en: '**Flow:** This is a container that lays out its children along a horizontal
    or vertical axis (set in `Flow.Axis` or `NewFlow()`).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流：**这是一个容器，其子小部件沿水平或垂直轴（在`Flow.Axis`或`NewFlow()`中设置）排列。'
- en: '**Flex:** Actually, in a `flex` sub-package, this is a container that lays
    out its children according to the CSS flexbox algorithm. As with `widget.Flow`, the
    parameters for the layout are set on the `flex.Flex` container.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性：**实际上，在`flex`子包中，这是一个根据CSS flexbox算法排列其子小部件的容器。与`widget.Flow`一样，布局参数是在`flex.Flex`容器上设置的。'
- en: '**Image:** This widget renders a golang `image.Image` onscreen. Its dimensions
    are specified separately to the image.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像：**此小部件在屏幕上渲染golang的`image.Image`。其尺寸是单独指定给图像的。'
- en: '**Label:** This is a simple widget for displaying a line of text with a theme
    color (for example, `theme.Foreground`).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签：**这是一个简单的显示带有主题颜色（例如，`theme.Foreground`）的文本行的工具。'
- en: '**Padder:** An invisible widget that contains a child widget and displays it
    with a specified amount of space around the horizontal or vertical dimensions (or
    both).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充器：**一个包含子小部件并带有指定空间围绕水平或垂直维度（或两者）显示的不可见小部件。'
- en: '**Sheet:** A sheet provides the buffer on which all other widgets will draw.
    Any widgets that are not children of a Sheet may not be rendered. Multiple sheets
    are required if content should move independently, such as a scroll view.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作表：**工作表提供了所有其他小部件将绘制其上的缓冲区。任何不是工作表子小部件的小部件可能不会被渲染。如果内容应独立移动，则需要多个工作表，例如滚动视图。'
- en: '**Sizer:** A sizer is an invisible widget that contains a child widget but
    overrides its size. This can be used to specify a different natural size than
    the default for an existing widget.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸调整器：**尺寸调整器是一个包含子小部件但覆盖其尺寸的不可见小部件。这可以用来指定与现有小部件默认尺寸不同的自然尺寸。'
- en: '**Space:** An invisible widget that takes up available space. Placed between
    two widgets, they will become left- and right- aligned, or by placing  `widget.Space` either
    side of a widget, it will become centered.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间：**一个占据可用空间的不可见小部件。放置在两个小部件之间，它们将变为左对齐和右对齐，或者通过在`widget.Space`小部件的任一侧放置小部件，它将变为居中对齐。'
- en: '**Text:** A multi-line text widget for displaying more complicated text than `widget.Label`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本：**一个多行文本小部件，用于显示比`widget.Label`更复杂的文本。'
- en: '**Uniform:** This is a simple widget that draws a rectangle of a solid color
    from the theme palette (for example, `theme.Background`).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**均匀：**这是一个简单的绘制来自主题调色板（例如，`theme.Background`）的实色矩形的工具。'
- en: There is also an advanced widget named `glwidget.GL`, which renders a **OpenGL
    for embedded systems** (**GLES**) `framebuffer` into a Shiny application. This
    is not commonly required for traditional applications but it's a great additional
    feature to support.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个名为`glwidget.GL`的高级小部件，它将**嵌入式系统的OpenGL**（**GLES**）`framebuffer`渲染到Shiny应用程序中。这对于传统应用程序来说并不常见，但它是一个很好的附加功能，以支持这一功能。
- en: Despite the length of the preceding list, you'll probably notice that it does
    not provide all the widgets we have used in other chapters. For this reason, we
    will build a different sample application. This time, one that's a better fit
    for the toolkit's capabilities. Before that, however, let's return to *getting
    started* and creating a hello world application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的列表很长，但你可能会注意到它并没有提供我们在其他章节中使用过的所有小部件。因此，我们将构建一个不同的示例应用程序。这次，一个更适合工具包功能的应用程序。在此之前，让我们回到*开始*并创建一个hello
    world应用程序。
- en: Getting started continued
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始继续
- en: Now that we have explored a little of how Shiny is designed and its current
    constraints, we can implement our first graphical application and see it run.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了Shiny的设计方式和当前的限制，我们可以实现我们的第一个图形应用程序并看到它运行。
- en: Code
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'Let''s get started with writing a simple *hello world* window, as in the previous
    chapters. This code is a little more complicated than in previous examples due
    to the low-level nature of the toolkit at this time. As well as defining the window,
    label, and button, we will need to set up a background layer and measure the minimum
    size for the containing window:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编写一个简单的*hello world*窗口开始，就像前面的章节一样。由于当前工具包的低级性质，这段代码比前面的例子要复杂一些。除了定义窗口、标签和按钮外，我们还需要设置背景层并测量包含窗口的最小尺寸：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, you can see the flow layout (`widget.NewFlow()`), a background
    layer (`widget.NewSheet()`), and the measurement initialization (`w.Measure()`).
    With Shiny, `widget.Sheet` is required underneath any widgets so they can paint
    correctly. On a simple application, a single sheet should be sufficient, but on
    a more complex user interface where items move independently (that is, scrolling),
    additional sheets will probably be required.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到流布局（`widget.NewFlow()`）、背景层（`widget.NewSheet()`）和测量初始化（`w.Measure()`）。在Shiny中，`widget.Sheet`是任何小部件下面的必需项，这样它们才能正确绘制。在简单的应用程序中，一个单独的层应该足够，但在更复杂的用户界面中，其中项目可以独立移动（即，滚动），可能需要额外的层。
- en: Supporting code
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持代码
- en: 'As you may have noticed, the preceding code has two issues, both relating to
    the `Quit` button. Firstly, the `func()` that''s called does not actually exit
    the application. This is a current limitation of the Shiny lifecycle code. It
    can be worked around with a custom lifecycle, but this is not recommended due
    to the large amount of code that would be required. Secondly, you may notice that
    `newButton()` is a local function and not part of the `widget` package. One of
    the widgets currently missing from the toolkit list is a standard button, therefore,
    we must define one ourselves. This can be done by adding the code described as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，前面的代码有两个问题，都与`Quit`按钮有关。首先，被调用的`func()`实际上并没有退出应用程序。这是Shiny生命周期代码的一个当前限制。可以通过自定义生命周期来解决这个问题，但由于需要大量代码，这并不推荐。其次，你可能注意到`newButton()`是一个局部函数，而不是`widget`包的一部分。工具包列表中目前缺少的一个标准按钮，因此，我们必须自己定义一个。这可以通过添加以下描述的代码来完成：
- en: 'First, we define the custom node; it must begin by inheriting from `node.LeafEmbed`.
    We add fields for the text label it''ll contain and the `onClick` function that
    should be called when it is tapped. We should also add a convenience method to
    construct the button. This needs to set the `node.Embed.Wrapper` field, as that
    should never be `nil`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义自定义节点；它必须首先继承自`node.LeafEmbed`。我们添加了包含文本标签的字段和当它被点击时应该调用的`onClick`函数。我们还应该添加一个方便的方法来构建按钮。这需要设置`node.Embed.Wrapper`字段，因为这个字段不应该为`nil`：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To define a suitable area for the button to take up, we need to implement the
    `Measure()` function. This will update a cached size (`node.Embed.MeasuredSize`)
    that''s used for the interface layout:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义按钮占据的合适区域，我们需要实现`Measure()`函数。这将更新一个用于界面布局的缓存大小（`node.Embed.MeasuredSize`）：
- en: '[PRE2]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To display content onscreen (this actually paints to an underlying `widget.Sheet`
    described earlier), we add a `PaintBase()` function. For our button, we will paint
    a `theme.Foreground` colored rectangle as a base and use the `theme.Background`
    color for the text (so our button stands out from other text). Note that, before
    actually painting, we remove the `node.MarkNeedsPaintBase` mark from the object
    so that it will not be redrawn on the next interface redraw:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示内容（这实际上是将画到前面提到的底层 `widget.Sheet` 上），我们添加一个 `PaintBase()` 函数。对于我们的按钮，我们将绘制一个
    `theme.Foreground` 颜色的矩形作为基础，并使用 `theme.Background` 颜色作为文本的颜色（这样我们的按钮就能从其他文本中脱颖而出）。请注意，在实际绘制之前，我们从对象中移除
    `node.MarkNeedsPaintBase` 标记，这样它就不会在下一个界面重绘时被重新绘制：
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Lastly, a button needs a click handler. We can implement the `OnInputEvent()`
    function so that Shiny can send events to the button. Here, we check to see whether
    the event''s a `gesture.Event`, and if so, see that its type is `gesture.TypeTap`.
    If these conditions are met, and we have an `onClick` handler registered, then
    call `b.onClick()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按钮需要一个点击处理程序。我们可以实现 `OnInputEvent()` 函数，以便 Shiny 可以向按钮发送事件。在这里，我们检查事件是否为
    `gesture.Event`，如果是，则检查其类型是否为 `gesture.TypeTap`。如果满足这些条件，并且我们已注册 `onClick` 处理程序，则调用
    `b.onClick()`：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That concludes the code required to fulfill a hello world GUI app with Shiny
    (the complete code is in this book's code repository). Let's now build and run
    the application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了使用 Shiny 实现一个“Hello World”图形应用程序所需的代码（完整代码在本书的代码库中）。现在，让我们构建并运行该应用程序。
- en: Build and Run
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 & 运行
- en: 'Building our Shiny hello world app is simple as Shiny has no native dependencies—we
    can simply build or run the `hello.go` file directly. Additionally, as many platform
    drivers are written without CGo, we can easily cross-compile for those operating
    systems. The following screenshot illustrates building for Linux and then Windows
    with no additional setup:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Shiny 没有原生依赖项，构建我们的 Shiny “Hello World” 应用程序非常简单——我们可以直接构建或运行 `hello.go`
    文件。此外，由于许多平台驱动程序没有使用 CGo 编写，我们可以轻松地为这些操作系统进行交叉编译。以下屏幕截图显示了为 Linux 构建然后为 Windows
    构建而没有额外设置的情况：
- en: '![](img/8d248088-92a3-45af-9ca2-8f358eaed9b3.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d248088-92a3-45af-9ca2-8f358eaed9b3.png)'
- en: Building our hello app and running it with no CGo is easy
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 构建我们的 hello 应用程序并在没有 CGo 的情况下运行它很容易
- en: Note that building for macOS would require some additional setup, as its driver
    uses CGo (as described in the preceding *Cross-compiling* section of *Getting
    started*).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为 macOS 构建将需要一些额外的设置，因为它的驱动程序使用 CGo（如 *入门* 中先前所述的 *交叉编译* 部分中描述的）。
- en: 'However you build or run the application, you should see a little window, something
    like the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何构建或运行应用程序，你应该看到一个小的窗口，类似于以下内容：
- en: '![](img/65c0afec-005e-4362-aed7-0e114a55f93a.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65c0afec-005e-4362-aed7-0e114a55f93a.png)'
- en: Hello world with Shiny
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shiny 的“Hello World”
- en: We could refine the visuals of our app, but instead, we will move on to a larger
    application to demonstrate the capabilities of Shiny.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完善我们应用程序的视觉效果，但我们将继续进行一个更大的应用程序，以展示 Shiny 的功能。
- en: Building a user interface
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: To explore the capabilities of the Shiny toolkit, we will build another complete
    graphical application. As the development of Shiny has been focused on the lower
    layer of graphical APIs, an application such as GoMail would involve the creation
    of many custom widgets. Instead, we will look at a more graphically-oriented application—an
    image viewer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索 Shiny 工具包的功能，我们将构建另一个完整的图形应用程序。由于 Shiny 的发展主要集中在图形 API 的底层，因此像 GoMail 这样的应用程序将涉及创建许多自定义小部件。相反，我们将查看一个更具图形导向的应用程序——图像查看器。
- en: Design
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: 'To get an idea of how the image viewer should look, we will make a rough design
    that we can follow. The online tool Balsamiq ([balsamiq.com](https://balsamiq.com/))
    is a good way to rapidly create wireframes that will suit this purpose. Take a
    look at the following export. It includes a navigation bar along the top, a directory
    listing on the left, and a full-size image view on the right:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解图像查看器应该如何看起来，我们将制作一个粗略的设计，以便我们遵循。在线工具 Balsamiq ([balsamiq.com](https://balsamiq.com/))
    是快速创建适合此目的的线框的好方法。看看下面的导出。它包括顶部的导航栏、左侧的目录列表和右侧的全尺寸图像视图：
- en: '![](img/b5014e8c-d3b3-45c8-aee8-0be926181769.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5014e8c-d3b3-45c8-aee8-0be926181769.png)'
- en: A mockup of the GoImages application using the Balsamiq tool
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Balsamiq 工具制作的 GoImages 应用程序原型
- en: Clearly, this image has a far lower level of detail than the design tool we
    used in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml), *Walk – Building
    Graphical Windows Applications* (back at the beginning of [Section 2](36bfea00-c659-4569-864c-de2c460c7467.xhtml),
    *Toolkits Using Existing Widgets*) for our GoMail design, but this is intentional.
    Each toolkit in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits* of this book has a very different look, set by its theme definition
    and by using a rough design we can build an implementation using the best practice
    for each of them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这张图片的细节水平远低于我们在[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)，“走——构建图形窗口应用”（回到[第2节](36bfea00-c659-4569-864c-de2c460c7467.xhtml)，“使用现有小部件的工具包”）中使用的图形设计工具，但这是故意的。本书[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)，“现代图形工具包”中的每个工具包都有一个非常不同的外观，由其主题定义和通过使用粗略的设计来设置，我们可以为每个工具包构建一个使用最佳实践的实现。
- en: Layout
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'To get started, we will implement the layout. The easiest way to set this up
    for the application we designed is to use horizontal and vertical flow layouts.
    Before creating the layout, we should define those widgets that will be included.
    For now these are represented by the placeholders created in `makeBar()` and `makeList()`—each
    of which simply creates a label to show the purpose. We also want to ensure that
    the items are padded according to our design. To do this with Shiny, we use `widget.NewPadder()`
    and a defined unit, `padSize`. We also define a `spaceSize` used later for the
    central padding:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将实现布局。为我们的应用设置布局的最简单方法是使用水平和垂直流布局。在创建布局之前，我们应该定义那些将被包含的小部件。目前这些由`makeBar()`和`makeList()`中创建的占位符表示——每个都简单地创建一个标签来显示其目的。我们还希望确保项目根据我们的设计进行填充。为了使用Shiny实现这一点，我们使用`widget.NewPadder()`和一个定义的单位`padSize`。我们还定义了一个`spaceSize`，稍后用于中央填充：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To show the image in our layout, we can use `widget.Image`, but first we need
    to load an image from the filesystem—a helper function, `loadImage()`, is defined
    to handle this for the application. When loading an image, don''t forget to import
    the appropriate decoder (in this case, `image/jpeg`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的布局中显示图片，我们可以使用`widget.Image`，但首先我们需要从文件系统加载一张图片——一个辅助函数`loadImage()`被定义来处理这个应用。当加载图片时，别忘了导入适当的解码器（在这个例子中，`image/jpeg`）：
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With that in place, we''re ready to implement the layout. The main method constructs
    the widget tree and creates `widget.Sheet` to manage their rendering. This is
    passed to `widget.RunWindow()` to show the contents and run the application. The
    main layout elements are `body` (a horizontal flow) and `container` (the vertical
    flow, containing the navigation and the body). Note how a `nil` child is passed
    to `widget.NewPadder()` between the file list and the image viewer to approximate
    widget spacing. You can also see that the child widget of  `sheet` is actually
    a `theme.Background` colored rectangle created using `widget.NewUniform()` – this
    helps to ensure that we have a consistent background color if any widgets leave
    part of their area unpainted. The container then fills the space by being the
    uniform''s child widget:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，我们就可以实现布局了。主方法构建了小部件树并创建`widget.Sheet`来管理它们的渲染。这被传递给`widget.RunWindow()`以显示内容和运行应用。主要的布局元素是`body`（水平流）和`container`（垂直流，包含导航和主体）。注意在文件列表和图片查看器之间传递了一个`nil`子小部件给`widget.NewPadder()`，以近似小部件间距。你还可以看到`sheet`的子小部件实际上是一个使用`widget.NewUniform()`创建的`theme.Background`着色矩形——这有助于确保如果有小部件未绘制其部分区域，我们有一个一致的后台颜色。然后容器通过成为均匀的子小部件来填充空间：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the preceding code should result in a window showing the following
    contents, which broadly matches the layout we designed before. As we progress
    through this chapter, we will add the content to each area and polish each part
    of the interface:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码应该会显示一个窗口，其中包含以下内容，这与我们之前设计的布局大致匹配。随着我们进入本章，我们将向每个区域添加内容并完善界面的每个部分：
- en: '![](img/209c4b68-1685-4721-9637-0de41329152b.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/209c4b68-1685-4721-9637-0de41329152b.png)'
- en: The GoImages layout with the navigation bar and file list placeholders
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 带有导航栏和文件列表占位符的GoImages布局
- en: Navigation
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: 'To create the navigation bar in our design, a horizontal flow layout is the
    right tool for the job. We can use `widget.Spacer` to create the gaps between
    the buttons and the label and to ensure the filename is centered within the space
    available. A helper method, `expandSpace()`, is added to create a new spacer that
    will expand along the flow layout axis. We also define the `previousImage()` and
    `nextImage()` functions, which will execute when the buttons are pressed:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的设计中创建导航栏时，水平流布局是完成这项工作的正确工具。我们可以使用`widget.Spacer`在按钮和标签之间创建间隔，并确保文件名在可用空间中居中。我们添加了一个辅助方法`expandSpace()`，它将创建一个新的间隔，该间隔将沿着流布局轴扩展。我们还定义了`previousImage()`和`nextImage()`函数，这些函数将在按钮被按下时执行：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With those functions defined, we can lay out the navigation bar. We define
    the `prev`, `next`, and `name` items and add them to a `widget.AxisHoriontal`
    flow container that includes `expandSpace()` elements to space the items. To create
    buttons, we are using the same `newButton()` function as earlier in this chapter
    (due to the Shiny widget API not having a standard button defined). We use `theme.Neutral` for
    the background container for this section and we set the whole bar to expand along
    the horizontal axis:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些函数后，我们可以布局导航栏。我们定义了`prev`、`next`和`name`项，并将它们添加到一个包含`expandSpace()`元素的`widget.AxisHoriontal`流容器中，以分隔项目。为了创建按钮，我们使用本章前面（由于Shiny小部件API没有定义标准按钮）提到的相同的`newButton()`函数。我们使用`theme.Neutral`作为此部分的背景容器，并将整个栏设置为沿水平轴扩展：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code should update the navigation bar, as follows. As we''ve
    defined the buttons ourselves, they can be customized to use the border style
    if preferred (the full code listing is available in this book''s code repository):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应更新导航栏，如下所示。因为我们自己定义了按钮，所以如果需要，可以使用边框样式进行自定义（完整的代码列表可在本书的代码仓库中找到）：
- en: '![](img/17ab4070-c897-4feb-8dd4-ab2d1c06ecd7.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17ab4070-c897-4feb-8dd4-ab2d1c06ecd7.png)'
- en: The updated navigation bar with left- and right- aligned buttons
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的导航栏，按钮左对齐和右对齐
- en: File list
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件列表
- en: 'As Shiny does not define a list widget, we will construct one using another
    vertical flow container. Each item within this list will be a custom cell widget
    that displays an icon on the left with the filename text left-aligned in the remaining
    space. First, we will update our `makeList()` function to add some dummy data.
    Each item is a new cell, created using `makeCell()` (which is defined later).
    The items are laid out as a list using `widget.NewFlow()` on the vertical axis:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Shiny没有定义列表小部件，我们将使用另一个垂直流容器来构建一个。列表中的每个项目都将是一个自定义单元格小部件，它将在左侧显示一个图标，并将文件名文本左对齐在剩余的空间中。首先，我们将更新我们的`makeList()`函数以添加一些虚拟数据。每个项目都是一个新单元格，使用`makeCell()`（稍后定义）创建。项目使用`widget.NewFlow()`在垂直轴上作为列表布局：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the first item in the list is the name of our directory, which
    needs a different icon. We can load a standard icon from the Shiny icon collection
    using the `iconvg` package, specifically, `iconvg.Rasterizer` and `iconvg.Decode()`.
    Using the following helper function, we can load the `icons.FileFolder` icon into
    an image so it can be drawn using the same functions as images we load from the
    filesystem:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列表中的第一项是我们目录的名称，它需要一个不同的图标。我们可以使用`iconvg`包从Shiny图标库中加载一个标准图标，具体来说，使用`iconvg.Rasterizer`和`iconvg.Decode()`。使用以下辅助函数，我们可以将`icons.FileFolder`图标加载到图像中，以便可以使用与从文件系统加载的图像相同的函数进行绘制：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last part of our layout code is the `makeCell()` function. In this case,
    it''s a simple wrapper around the creation of a `cell` widget. When this function
    is passed a `nil` icon, it will set up the directory icon using the helper above.
    When an icon is passed, then it creates an `onClick` function that will load the
    image in the main view:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们布局代码的最后部分是`makeCell()`函数。在这种情况下，它是一个简单的包装，用于创建`cell`小部件。当此函数传递一个`nil`图标时，它将使用上面的辅助程序设置目录图标。当传递一个图标时，它创建一个`onClick`函数，该函数将在主视图中加载图像：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The details of our cell widget are very similar to the button we created earlier
    and so most of the code is omitted. The next excerpt shows its `PaintBase()` function,
    which draws the icon and text to screen. It calculates the ratio of an image so
    that it can be correctly painted within the cell. The text is then drawn like
    the button code, but with a space between it and the image we painted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们单元格小部件的细节与之前创建的按钮非常相似，因此大部分代码被省略了。下一个摘录显示了它的`PaintBase()`函数，该函数将图标和文本绘制到屏幕上。它计算图像的比率，以便可以在单元格中正确绘制。然后，文本就像按钮代码一样绘制，但与绘制的图像之间有一个空格。
- en: 'To make this work, a simple `scaleImage()` function is also needed, which uses `draw.ApproxBiLinear`
    to resize the graphic to fit with reasonable performance:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这起作用，还需要一个简单的`scaleImage()`函数，它使用`draw.ApproxBiLinear`将图形缩放到适合的尺寸，以获得合理的性能：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All this code comes together to create a file listing with an image preview,
    as shown in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些代码组合在一起，创建了一个带有图像预览的文件列表，如下面的截图所示：
- en: '![](img/417d4265-d111-43d9-853b-5ca4e8168127.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/417d4265-d111-43d9-853b-5ca4e8168127.png)'
- en: The completed file list on the left with placeholder content
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧完成的文件列表，包含占位符内容
- en: Image view
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像视图
- en: The `widget.Image` type draws an image to the buffer at the same resolution
    as it was loaded (a pixel in the source image matches a pixel on screen). What
    we need to do for the image viewer is scale it to fit the available space. To
    do this, we create a new custom widget named `scaledImage`. The code is very similar
    to the Shiny image widget but with a more complicated `PaintBase()` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`widget.Image`类型以加载时的相同分辨率在缓冲区中绘制图像（源图像中的一个像素与屏幕上的一个像素匹配）。对于图像查看器，我们需要将其缩放以适应可用空间。为此，我们创建了一个名为`scaledImage`的新自定义小部件。代码与Shiny图像小部件非常相似，但`PaintBase()`函数更复杂。'
- en: 'This function calculates `imgWidth` and `imgHeight` to fit within the current
    bounds of the widget and maintain the aspect ratio of the source image. It then
    scales the image using the `scaleImage()` helper function defined earlier, ready
    to paint at the correct resolution. Lastly, `offset` is calculated so that the
    image is centered within the available space:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算`imgWidth`和`imgHeight`以适应当前小部件的边界并保持源图像的宽高比。然后使用之前定义的`scaleImage()`辅助函数缩放图像，以便以正确的分辨率绘制。最后，计算`offset`以确保图像在可用空间中居中：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To avoid a blank space being left by the preceding calculations, let''s add
    a checkered pattern typical in many other image applications. To make this possible,
    we create a custom image type named `checkerImage` that simply returns pixels
    from the `At()` function based on a regular checker pattern. As images are bounded,
    we need to add a `resize()` function so the image can expand to fill the space:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免前述计算留下的空白空间，让我们添加一个在许多其他图像应用程序中常见的棋盘图案。为了实现这一点，我们创建了一个名为`checkerImage`的自定义图像类型，它简单地根据规则的棋盘图案从`At()`函数返回像素。由于图像是有限的，我们需要添加一个`resize()`函数，以便图像可以扩展以填充空间：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To include the checker pattern, we simply need to update the end of the `PaintBase()`
    function of `scaledImage`. Before the image itself is drawn, we set the checker
    pattern to expand to the correct size and paint it onto the background. The checkers
    are drawn with the `draw.Src` mode and the image is then drawn over the top using
    the `draw.Over` mode:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含棋盘图案，我们只需更新`scaledImage`的`PaintBase()`函数的末尾。在绘制图像本身之前，我们将棋盘图案设置为扩展到正确的尺寸，并将其绘制到背景上。棋盘是用`draw.Src`模式绘制的，然后使用`draw.Over`模式在顶部绘制图像：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With all of this code in place, we have an updated application that correctly
    fills the layout we designed and scales and positions the placeholder image we
    have to fit within the available space:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些代码到位后，我们有一个更新的应用程序，它正确地填充了我们设计的布局，并缩放和定位了占位符图像以适应可用空间：
- en: '![](img/1a08c0b1-bfd3-4f72-87cc-b15cb00e1d1d.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a08c0b1-bfd3-4f72-87cc-b15cb00e1d1d.png)'
- en: The interface updated to show images centered at the correct aspect ratio
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 界面更新以显示以正确宽高比居中的图像
- en: That's the majority of our graphical code complete. Next, we will make the necessary
    additions to load real content from the local filesystem.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的图形代码的大部分内容。接下来，我们将添加必要的代码来从本地文件系统加载实际内容。
- en: Communicating with the GUI
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GUI通信
- en: 'Now that we have a user interface up and running, we need to load some real
    data and display it. We start this task by obtaining a list of image files for
    the requested directory and updating the user interface to list those instead
    of the placeholder information. Remember, at this stage, to add the extra image
    imports so we can decode all of the images that we will then filter for in a new
    `getImageList()` function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个运行的用户界面，我们需要加载一些实际数据并显示它。我们通过获取请求目录的图像文件列表并更新用户界面以列出这些文件而不是占位符信息来开始这个任务。记住，在这个阶段，添加额外的图像导入，以便我们可以解码我们将在新的`getImageList()`函数中过滤的所有图像：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The listing shows a fairly simple algorithm for checking each item in a directory
    and adding it to a `names` list if the filename looks like a image file that we
    support. Simple filename extension checking should be sufficient for our purposes
    here. We add these filenames to a global list for later use in the user interface.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示了一个相当简单的算法，用于检查目录中的每个项目，如果文件名看起来像我们支持的图像文件，则将其添加到 `names` 列表中。简单的文件扩展名检查应该足以满足我们的目的。我们将这些文件名添加到全局列表中，以便在用户界面中稍后使用。
- en: 'Once we have a list of supported files, we can update the existing `makeList()`
    function. The new version iterates over the `files` list and adds a new cell for
    each item. The `makeCell()` function does not need any additional work to use
    this new content, but we do pass the array index for use later in the button handlers.
    We also save the `images` loaded in memory for display when selected:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个支持文件的列表，我们就可以更新现有的 `makeList()` 函数。新版本遍历 `files` 列表并为每个项目添加一个新单元格。`makeCell()`
    函数不需要进行任何额外的工作即可使用新内容，但我们确实传递了数组索引，以便在按钮处理程序中稍后使用。我们还保存了在选中时用于显示的内存中加载的 `images`：
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To update the main image displayed, we need to add a new function to our `scaledImage`
    widget. This new `SetImage()` function sets the image reference to be displayed
    and marks the widget for painting. Updating the `node.MarkNeedsPaintBase` mark
    means that the widget will be repainted next time there is a graphical paint event
    (we will discuss paint events in more detail shortly):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新显示的主图像，我们需要为我们的 `scaledImage` 小部件添加一个新功能。这个新的 `SetImage()` 函数设置要显示的图像引用，并标记小部件进行绘制。更新
    `node.MarkNeedsPaintBase` 标记意味着小部件将在下一次图形绘制事件发生时重新绘制（我们将在稍后更详细地讨论绘制事件）：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To make use of this new function, we update our `chooseImage()` code to set
    the image selected. We also need to store a reference to the `scaledImage` widget
    created to call the function on:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新功能，我们需要更新我们的 `chooseImage()` 代码以设置选定的图像。我们还需要存储对创建以调用此函数的 `scaledImage`
    小部件的引用：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the image is changed, we also need to set the correct filename to the
    label above the image. To do so, we will add a reference to the `widget.Label`
    object and set its `Text` field. After updating this property, we also need to
    set the `node.MarkNeedsMeasureLayout` flag, as the text may have a different size
    to the previous content. We use the `names` array and the index variable passed
    into `chooseImage()` to look up the content. This could also be accomplished by
    creating a list of items using a new object type that stores the image, name,
    and metadata in a single list, but the approach of multiple indexed lists is easier
    to explain in smaller code samples:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像更改时，我们还需要将正确的文件名设置到图像上方的标签中。为此，我们将添加对 `widget.Label` 对象的引用并设置其 `Text` 字段。更新此属性后，我们还需要设置
    `node.MarkNeedsMeasureLayout` 标志，因为文本可能具有与之前内容不同的尺寸。我们使用 `names` 数组和传递给 `chooseImage()`
    的索引变量来查找内容。这也可以通过创建一个使用新对象类型存储图像、名称和元数据的单个列表来完成，但使用多个索引列表的方法在较小的代码示例中更容易解释：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We also need to fill in the empty `previousImage()` and `nextImage()` functions
    that the header buttons call. A simple helper function called `changeImage()`
    is added to handle image switching based on an offset from the current image (either
    `1` or `-1`). Each button callback calls this with the appropriate offset:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要填写由标题按钮调用的空 `previousImage()` 和 `nextImage()` 函数。添加了一个名为 `changeImage()`
    的简单辅助函数，用于根据当前图像的偏移量（`1` 或 `-1`）处理图像切换。每个按钮回调都使用适当的偏移量调用此函数：
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this in place, the `main()` function can include a call to `chooseImage(0)` to
    load the first image found in the directory. Of course, you should check that
    there is at least one image before you do this.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，`main()` 函数可以包含对 `chooseImage(0)` 的调用，以加载目录中找到的第一个图像。当然，在这样做之前，你应该检查至少存在一个图像。
- en: 'The last change is to determine which directory to show images for when the
    application loads. The previous `main()` function is renamed `loadUI()` (which
    takes a directory parameter to pass into `getImageList()` and `makeList()`). A
    new main function is created that parses command-line arguments to allow the user
    to specify a directory. The following code will print out a helpful usage hint
    if some unexpected parameters are passed (or if `--help` is specified) and if
    no parameters are found, it will show the current working directory (using `os.Getwd()`):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是在应用程序加载时确定要显示图像的目录。之前的`main()`函数被重命名为`loadUI()`（它接受一个目录参数传递给`getImageList()`和`makeList()`）。创建了一个新的主函数，它解析命令行参数，允许用户指定一个目录。如果传递了意外的参数（或指定了`--help`），以下代码将打印出有用的使用提示；如果没有找到参数，它将显示当前工作目录（使用`os.Getwd()`）：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With these modifications, we''ve created a complete image viewer application
    that displays thumbnails for a whole directory of images and one large image view.
    By tapping on items in the list, or using the Next and Previous buttons, you can
    switch between the images available. While this works, it can be quite slow to
    load in a large directory. Next, we''ll explore how this can be improved:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，我们创建了一个完整的图像查看器应用程序，可以显示整个图像目录的缩略图和一张大图像视图。通过点击列表中的项目，或使用“下一张”和“上一张”按钮，可以在可用的图像之间切换。虽然这样可以工作，但在大型目录中加载可能会非常慢。接下来，我们将探讨如何改进这一点：
- en: '![](img/4e068050-5e41-4272-968d-64f3ec23dba9.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e068050-5e41-4272-968d-64f3ec23dba9.png)'
- en: The completed GoImages application running on macOS
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS上运行的完成的GoImages应用程序
- en: Background processing
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景处理
- en: Image processing, even just loading the images to be viewed, is a CPU-intensive
    task, so if we open a directory with a lot of pictures, the application will be
    very slow to load. We can fix this delay by moving our image loading to work in
    the background while we load the user interface. Thankfully, creating new threads
    for asynchronous processing is very simple with Go (as we explored in [Chapter
    3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml), *Go to the Rescue!*), but we also
    need to ensure that the user interface is updated accordingly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图像处理，即使是加载要查看的图像，也是一个CPU密集型任务，所以如果我们打开一个包含大量图片的目录，应用程序加载将非常慢。我们可以通过将图像加载移动到后台工作，在我们加载用户界面时进行修复这个延迟。幸运的是，使用Go创建新的线程进行异步处理非常简单（如我们在[第3章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)，*Go
    to the Rescue!*中探讨的那样），但我们还需要确保用户界面相应地更新。
- en: 'To delay the loading of images until there is processing power available, we
    can replace uses of `loadImage()` with a replacement `asyncImage` type that will
    handle the heavy lifting. The main image loading code will be moved into a private `load()`
    function that''s called from `newAsyncImage()` using `go img.load()`, therefore
    starting it in the background:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了延迟图像的加载直到有处理能力可用，我们可以用替换的`asyncImage`类型替换`loadImage()`的使用，该类型将处理繁重的工作。主图像加载代码将被移动到一个私有的`load()`函数中，该函数由`newAsyncImage()`调用，使用`go
    img.load()`启动，因此它在后台开始：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the definition of an asynchronous image loader, we can replace the use
    of `image.Image` with `asyncImage`. The important thing to remember is that the
    image in the `img` field will be `nil` until the `load()` function has completed.
    Be sure that any code using images checks for `nil` data before processing. The
    first function we update is `makeCell()` so that it no longer accepts an image
    parameter. Instead, we pass a `loaded` callback function to set the image once
    it is loaded. We update `makeList()` to replace the cell creation code with the
    following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义异步图像加载器，我们可以用`asyncImage`替换`image.Image`的使用。需要记住的重要一点是，`img`字段中的图像在`load()`函数完成之前将是`nil`。确保任何使用图像的代码在处理之前检查`nil`数据。我们首先更新的是`makeCell()`函数，使其不再接受图像参数。相反，我们传递一个`loaded`回调函数，以便在图像加载后设置图像。我们将`makeList()`更新为用以下代码替换单元格创建代码：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code will ensure that thumbnails are shown once the image has loaded but
    also that, if the image is the current selection, it updates the main image `view`
    as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将确保在图像加载完成后显示缩略图，同时如果图像是当前选择，它还会更新主图像`view`。
- en: 'If you run the application at this point, you will notice that some images
    are loaded while others may not be. This is due to us not having signaled to Shiny
    that a re-paint is necessary. The marks that were applied to the widgets to force
    them to be repainted do not actually trigger the painting of the interface; it
    simply marks them as needing to be painted the next time a re-paint is triggered:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候运行应用程序，你会注意到一些图像被加载，而其他可能没有被加载。这是因为我们没有通知Shiny需要重新绘制。应用于小部件以强制它们重新绘制的标记实际上并没有触发界面的绘制；它只是标记它们需要在下一次重新绘制时进行绘制：
- en: '![](img/353de3f4-1d2d-4602-b60e-6f1e9ae39bb6.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/353de3f4-1d2d-4602-b60e-6f1e9ae39bb6.png)'
- en: A partial rendering when loading images in the background
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台加载图像时的部分渲染
- en: 'There is no easy way to signal Shiny to refresh the user interface, so we will
    make a `refresh()` function for convenience. This should be called when the text
    for a filename is updated and when a different (or lazy-loaded) image is set on
    the `scaledImage` widget:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法来通知Shiny刷新用户界面，因此我们将创建一个`refresh()`函数以方便使用。当文件名的文本更新以及在不同（或懒加载）的图像被设置在`scaledImage`小部件上时，应该调用此函数：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unfortunately, at this point, we can't proceed further without a significant
    amount of extra code. This is a limitation of the recommended `widget.RunWindow()`
    function that we used to load our interface. The window reference that we would
    need to send the paint event to is not available outside the Shiny package. To
    resolve this issue, it would be necessary to use the `NewWindow()` function on
    the `screen.Screen` instance, passed into the `driver.Main()` function—but to
    do so would mean completely re-implementing the event loop as well, which is a
    lot of work.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在这个阶段，没有大量的额外代码，我们无法进一步进行。这是我们所使用的推荐`widget.RunWindow()`函数的限制。我们需要发送绘图事件到窗口的引用在Shiny包外部不可用。为了解决这个问题，有必要在`screen.Screen`实例上使用`NewWindow()`函数，该实例被传递到`driver.Main()`函数中——但是这样做意味着完全重新实现事件循环，这是一项大量工作。
- en: The reason we didn't notice the issue when setting the main image earlier is
    because, when the application is receiving user events (mouse moves and so on),
    its event loop runs. Each time an iteration of the loop completes, the user interface
    is repainted. Sending the `paint.Event` previously illustrated would also cause
    this to happen. Therefore, it follows that the interface will update after background
    image loading if the user is currently interacting with the GUI (even just moving
    the mouse over it). It's left as an exercise for the reader to implement the replacement
    lifecycle to resolve this issue, if desired.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设置主图像时没有注意到这个问题，是因为当应用程序接收用户事件（鼠标移动等）时，其事件循环会运行。每次循环迭代完成时，用户界面都会重新绘制。发送之前展示的`paint.Event`也会导致这种情况发生。因此，如果用户当前正在与GUI交互（即使只是将鼠标移到上面），则界面将在后台图像加载后更新。如果需要，将实现替换生命周期以解决这个问题，留作读者的练习。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at our first modern widget toolkit, Shiny, which
    has been designed specifically for the Go language. We explored its design principles
    and how it manages to support cross-platform graphical application development
    without the need for external dependencies. We also saw that its design makes
    use of powerful features of the Go language, such as concurrency and the standard
    library.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了我们的第一个现代小部件工具包Shiny，它专门为Go语言设计。我们探讨了其设计原则以及它是如何在不需要外部依赖的情况下支持跨平台图形应用程序开发的。我们还看到，其设计利用了Go语言的一些强大功能，如并发和标准库。
- en: The graphical design principles behind Shiny provide a new interpretation of
    the desktop application GUI, which will be familiar to users of the Android mobile
    operating system (due to them using the same material design approach). While
    exploring its graphical capabilities, we saw that the widget set is currently
    in its early stages and so isn't yet ready to support the GoMail application we've
    been creating in previous chapters. To explore the capabilities of the Shiny toolkit,
    we instead developed an image viewer application, which is better suited to the
    current feature set. We saw how powerful the rendering capabilities of Shiny are,
    but also that there are a few challenges around creating a rich application user
    interface.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Shiny背后的图形设计原则为桌面应用程序GUI提供了一种新的解释，这对于使用相同材料设计方法的Android移动操作系统用户来说将非常熟悉。在探索其图形功能时，我们发现当前的小部件集还处于早期阶段，因此尚未准备好支持我们在前几章中创建的GoMail应用程序。为了探索Shiny工具包的功能，我们反而开发了一个图像查看器应用程序，它更适合当前的功能集。我们看到了Shiny的渲染能力是多么强大，但也意识到在创建丰富的应用程序用户界面方面存在一些挑战。
- en: In the next chapter, we will look at another toolkit that takes a modern approach
    to the widget toolkit. Nuklear also helps developers to create cross-platform
    graphical user interfaces but does so from an embedded user interface approach.
    We'll explore the Go bindings for this library, named `nk`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一个采用现代方法处理小部件工具包的工具包。Nuklear还帮助开发者创建跨平台的图形用户界面，但它采用嵌入式用户界面方法。我们将探索这个名为`nk`的库的Go绑定。
