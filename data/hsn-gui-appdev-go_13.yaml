- en: Fyne - Material Design-Based GUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fyne - 基于 Material Design 的 GUI
- en: Fyne is a UI toolkit and application API designed to be easy to use. Its interface
    design follows the material design principles, providing cross-platform graphics
    that appear identical on all supported platforms. This chapter explores how to
    write graphical applications for multiple platforms with Fyne.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 是一个 UI 工具包和应用 API，旨在易于使用。其界面设计遵循材料设计原则，提供跨平台的图形，在所有支持的平台上都看起来相同。本章探讨了如何使用
    Fyne 编写多平台的图形应用程序。
- en: 'We''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: The vision and design of the Fyne project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fyne 项目的愿景和设计
- en: Building a simple Fyne-based application for multiple platforms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建基于 Fyne 的简单多平台应用程序
- en: API design and the widgets provided by Fyne
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 设计和 Fyne 提供的小部件
- en: How to create a complete application using Fyne
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Fyne 创建完整的应用程序
- en: By the end of this chapter, you should have an understanding of Fyne project's
    ambitions and will have built multiple cross-platform graphical applications using
    the toolkit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对 Fyne 项目的雄心壮志有所了解，并且将使用工具包构建了多个跨平台的图形应用程序。
- en: Background and vision for Fyne
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fyne 的背景和愿景
- en: The Fyne project was created by Andrew Williams (the author of this book) in
    response to growing criticism of the complexity in existing graphical toolkits
    and application APIs. It was designed with the aim of being easy to use, and the
    Go language was chosen for its powerful simplicity. Like the Shiny project we
    explored in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny –
    Experimental Go GUI API*, its APIs benefit from being created specifically for
    the Go language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 项目是由本书的作者 Andrew Williams 创建的，以回应人们对现有图形工具包和应用 API 复杂性的日益批评。它旨在易于使用，并选择了
    Go 语言，因为它具有强大的简洁性。就像我们在 [第 8 章](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml) 中探索的
    Shiny 项目一样，*Shiny – Experimental Go GUI API*，其 API 从为 Go 语言专门创建中受益。
- en: As with the other widget toolkits in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits,* it facilitates the building of graphical applications that
    look identical across all platforms, rather than adopting the look and feel of
    the operating system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 3 节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml) 中其他小部件工具包一样，*现代图形工具包*，它便于构建在所有平台上看起来相同的图形应用程序，而不是采用操作系统的外观和感觉。
- en: '"Fyne''s APIs aim to be the best for developing beautiful, usable, and lightweight
    applications for desktop and beyond."'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"Fyne 的 API 旨在为开发美观、易用和轻量级的桌面和超越桌面应用程序提供最佳选择。"'
- en: -[g](https://github.com/fyne-io/fyne/wiki/Vision)[ithub.com/fyne-io/fyne/wiki/Vision](https://github.com/fyne-io/fyne/wiki/Vision)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: -[g](https://github.com/fyne-io/fyne/wiki/Vision)[ithub.com/fyne-io/fyne/wiki/Vision](https://github.com/fyne-io/fyne/wiki/Vision)
- en: The toolkit was initially built using the Enlightenment Foundation Libraries
    (EFL: [enlightenment.org/about-efl](https://www.enlightenment.org/about-efl))
    to facilitate cross-platform rendering. Since then, Fyne has moved to an OpenGL-based
    driver, much like the nk package from the previous chapter. This makes for a much
    simpler setup and means that there are no runtime dependencies for apps created
    with Fyne. Before we examine the toolkit in detail, let's see how to set up a
    simple Fyne application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '工具包最初是使用 Enlightenment Foundation Libraries (EFL: [enlightenment.org/about-efl](https://www.enlightenment.org/about-efl))
    构建的，以促进跨平台渲染。从那时起，Fyne 已经转向基于 OpenGL 的驱动程序，就像上一章中的 nk 包一样。这使得设置更加简单，并且意味着使用 Fyne
    创建的应用程序没有运行时依赖。在我们详细检查工具包之前，让我们看看如何设置一个简单的 Fyne 应用程序。'
- en: Getting started with Fyne
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Fyne
- en: Before we start building a Fyne application, we will step through the installation
    and run an example application. For most systems, the setup is as simple as installing
    the `fyne.io/fyne` package using standard Go tools. For some systems, however,
    there are development prerequisites to check, so let's start there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建 Fyne 应用程序之前，我们将逐步进行安装并运行一个示例应用程序。对于大多数系统，设置就像使用标准的 Go 工具安装 `fyne.io/fyne`
    包一样简单。然而，对于某些系统，存在需要检查的开发前提条件，所以让我们从这里开始。
- en: Prerequisites
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: For the majority of platforms, there are no installation requirements to begin
    using Fyne. On macOS and Windows, the toolkit uses built-in OpenGL capabilities,
    so you can skip straight to the following *Setup* section (however, if you are
    developing for the first time on macOS, examine the following notes). If you are
    working with Linux (or another Unix system), then it may be necessary to install
    a number of system header files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数平台，开始使用 Fyne 无需安装任何要求。在 macOS 和 Windows 上，工具包使用内置的 OpenGL 功能，因此你可以直接跳到以下 *设置* 部分（然而，如果你是第一次在
    macOS 上开发，请检查以下说明）。如果你在与 Linux（或其他 Unix 系统）一起工作，那么可能需要安装一些系统头文件。
- en: Linux
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: 'To compile on Linux, you will need to have the Xorg and GL (*mesa* or similar)
    headers installed (this is not required for running the applications). The specifics
    will vary from system to system, but the most common requirements are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 上编译，你需要安装 Xorg 和 GL（*mesa* 或类似）头文件（运行应用程序不需要这些）。具体要求会因系统而异，但最常见的要求如下：
- en: 'Debian / Ubuntu:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Debian / Ubuntu:'
- en: '`libgl1-mesa-dev` and `xorg-dev`'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`libgl1-mesa-dev` 和 `xorg-dev`'
- en: 'Fedora / CentOS:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Fedora / CentOS:'
- en: '`libX11-devel`, `libXcursor-devel`, `libXrandr-devel`, `libXinerama-devel`,
    `mesa-libGL-devel`, and `libXi-devel`'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`libX11-devel`, `libXcursor-devel`, `libXrandr-devel`, `libXinerama-devel`,
    `mesa-libGL-devel`, 和 `libXi-devel`'
- en: 'Arch Linux:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Arch Linux:'
- en: '`mesa`'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`mesa`'
- en: On a development computer these packages may well already be installed, but
    if you have compile errors later in this chapter, the first thing to check would
    be that these packages, or their equivalent for your system, are installed correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发计算机上，这些软件包可能已经安装，但如果你在本章的后面部分遇到编译错误，首先应该检查这些软件包或它们在你系统中的等效软件包是否正确安装。
- en: macOS
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS
- en: 'For developing on macOS, you must have the Xcode command-line tools installed.
    If you''ve been working with C or CGo previously, then this is probably already
    set up; if not, then you may need to execute the `xcode-select --install` command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 macOS 上开发，你必须安装 Xcode 命令行工具。如果你之前已经使用过 C 或 CGo，那么这可能是已经设置好的；如果没有，那么你可能需要执行
    `xcode-select --install` 命令：
- en: '![](img/9569940d-c5c1-4d39-b3da-63f83bd7a487.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9569940d-c5c1-4d39-b3da-63f83bd7a487.png)'
- en: If you don't already have the command-line tools installed, then xcode-select
    will display this prompt
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装命令行工具，那么 xcode-select 将显示此提示
- en: Setup
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Setting up the Fyne API for use is as simple as downloading it using the `go
    get` command. The project is accessed from its base import name, `fyne.io/fyne`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `go get` 命令下载 Fyne API 以进行设置非常简单。项目通过其基本导入名称访问，`fyne.io/fyne`：
- en: '![](img/142daf59-b48e-4740-aa96-f72150ff3dd9.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/142daf59-b48e-4740-aa96-f72150ff3dd9.png)'
- en: Installing Fyne is easy once CGo is set up
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好 CGo，安装 Fyne 就变得简单
- en: Example
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: 'The Fyne toolkit comes with an example application built in that can be used
    to explore its features and assets. We can use this to verify that the setup is
    working. Simply use the Go tools to install the application and then run it using
    the `fyne_demo` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 工具包内置了一个示例应用程序，可以用来探索其功能和资产。我们可以使用这个应用程序来验证设置是否正常。只需使用 Go 工具安装应用程序，然后使用
    `fyne_demo` 命令运行它：
- en: '![](img/c05a4a8b-4994-442a-b39f-752141715fcf.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c05a4a8b-4994-442a-b39f-752141715fcf.png)'
- en: Install and run the fyne_demo command from the project repository
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目仓库安装并运行 fyne_demo 命令
- en: 'Running the demo application opens a single window that offers various options
    to explore. If we tap on a few items, additional windows will open and you should
    see something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 运行演示应用程序将打开一个窗口，该窗口提供各种选项以供探索。如果我们点击几个项目，将打开额外的窗口，你应该看到如下所示的内容：
- en: '![](img/8cf3c5f8-e8fb-4d4c-b51d-dff87a681a41.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8cf3c5f8-e8fb-4d4c-b51d-dff87a681a41.png)'
- en: Some of the features demonstrated in Fyne's example application
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 示例应用程序中展示的一些功能
- en: Code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码
- en: 'The basic *Hello World* application with Fyne is quite succinct, as the application
    setup is encapsulated in a single call. The entry point, `app.New()`, provided
    by the `app` sub-package, sets up a new application that we use to open a new
    window. The `widget` sub-package defines the various widgets available that we
    can add to our new window:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fyne 的基本 *Hello World* 应用程序相当简洁，因为应用程序设置封装在一个单独的调用中。由 `app` 子包提供的入口点 `app.New()`
    设置了一个新的应用程序，我们使用它来打开一个新窗口。`widget` 子包定义了我们可以添加到新窗口的各种小部件：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code block, the newly created `fyne.Window`
    has its content set to a new `widget.VBox` that provides the basic layout. Into
    this, we add a *Hello World*! label using `widget.NewLabel()` and a Quit button
    using `widget.NewButton()`. The second parameter to the button is `func()`, which
    will be called when the button is tapped.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码块所示，新创建的 `fyne.Window` 将其内容设置为一个新的 `widget.VBox`，它提供了基本的布局。在这个布局中，我们使用
    `widget.NewLabel()` 添加了一个 *Hello World* 标签，并使用 `widget.NewButton()` 添加了一个退出按钮。按钮的第二个参数是
    `func()`，当按钮被点击时会调用这个函数。
- en: Lastly, we call `ShowAndRun()` on the window we created. This function will
    show the window and start the application `event` loop. It is shorthand for `win.Show();
    app.Run()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在创建的窗口上调用 `ShowAndRun()`。这个函数将显示窗口并启动应用程序 `event` 循环。它是 `win.Show(); app.Run()`
    的简写。
- en: Build and run
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 和 运行
- en: 'This simple application can be run directly with `go run hello.go`, or built
    using `go build hello.go` and then run using the compiled binary:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单应用程序可以直接使用 `go run hello.go` 运行，或者使用 `go build hello.go` 构建，然后运行编译后的二进制文件：
- en: '![](img/41bfc04d-4c83-40d7-8518-ec246c5f55f5.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41bfc04d-4c83-40d7-8518-ec246c5f55f5.png)'
- en: Compiling or running directly works the same on any supported system
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何支持的系统上直接编译或运行的效果相同
- en: 'Running the code should produce a simple app that looks like the following.
    Clicking the Quit button or closing the window will exit the application:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码应该会生成一个看起来像下面的简单应用程序。点击退出按钮或关闭窗口将退出应用程序：
- en: '![](img/bc83f9a8-9447-4a22-9dfb-d3c97c3d4d4f.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc83f9a8-9447-4a22-9dfb-d3c97c3d4d4f.png)'
- en: Running Hello World on macOS
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上运行 Hello World
- en: Cross compiling
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台编译
- en: Due to the dependency on CGo, compiling for a platform other than the one you
    are developing in is, unfortunately, not as simple as setting the `GOOS` environment
    variable. Building for a different platform requires an installation of the C
    compiler for the target operating system. If you've been working through the previous
    chapters, then this may already be set up, but if not, then the process is documented
    in [Appendix 2](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml), *Cross-Compiler Setup*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖于 CGo，为除你正在开发的平台之外的平台编译，不幸的是，并不像设置 `GOOS` 环境变量那样简单。为不同的平台构建需要为目标操作系统安装 C
    编译器。如果你一直在阅读前面的章节，那么这可能已经设置好了，如果没有，那么这个过程在 [附录 2](4ddcb0bf-c964-4734-9919-b18a7593fc5b.xhtml)
    中有文档说明，*交叉编译器设置*。
- en: 'Once you have the appropriate compiler installed, then the build process is
    configured by setting the `GOOS`, `CGO_ENABLED`, and `CC` environment variables.
    You may also need to update your path—it''s advisable to put this in your Terminal
    or shell configuration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了适当的编译器，构建过程就通过设置 `GOOS`、`CGO_ENABLED` 和 `CC` 环境变量来配置。你可能还需要更新你的路径——建议将其添加到你的终端或shell配置中：
- en: '![](img/95877658-3203-477c-905d-42e4fe47359d.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95877658-3203-477c-905d-42e4fe47359d.png)'
- en: Building from Linux for macOS and Windows is a case of using the correct compiler
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Windows 上从 Linux 构建是一个使用正确编译器的例子
- en: Now that we've explored the details of getting up and running and compiling
    for multiple platforms, let's look more at how Fyne is designed and organized.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了如何启动和运行以及为多个平台编译的细节，让我们更深入地了解 Fyne 的设计和组织方式。
- en: Rendering and vector graphics
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和矢量图形
- en: The Fyne widgets (much like those in the Nuklear library in [Chapter 9](48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml),
    *nk – Nuklear for Go*) are made up of simple graphical objects that the render
    drivers are responsible for drawing. The driver is included as part of the package,
    and so no additional setup is required to start an application. Similar to the
    Shiny toolkit (that we explored in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    – Experimental Go GUI API*), the iconography is all vector-based, which Fyne uses
    to create scalable user interfaces that adapt to the device screen density.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 小部件（类似于第 9 章 [48b682de-d742-4c7b-b9a8-2926a76d7cb8.xhtml] 中 Nuklear 库中的那些）由简单的图形对象组成，渲染驱动程序负责绘制这些对象。驱动程序作为包的一部分包含在内，因此不需要额外的设置即可启动应用程序。类似于我们在第
    8 章 [9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml] 中探索的 Shiny 工具包（*Shiny – Experimental
    Go GUI API*），图标都是基于矢量的，Fyne 使用矢量图形来创建可缩放的用户界面，以适应设备屏幕的密度。
- en: Vector graphics
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矢量图形
- en: Vector graphics refers to images that are made up of lines and shapes rather
    than a collection of pixels (referred to as raster graphics). Whilst these images
    can be slower to load, they're excellent for drawing perfect images at any scale.
    As computer screens and smart phones have continued to increase their pixel density,
    measured in **Dots Per Inch** (**DPI**), it has become more difficult to produce
    raster graphics that look good on all devices. Platforms such as iOS have historically
    approached this by requiring multiple files of the same content at different resolutions—such
    as `Icon.png`, `Icon@2x.png`, and `Icon@3x.png` (which could be, for example,
    60 x 60, 120 x 120, or 180 x 180 pixels, respectively)—so that the closest match
    image for the screen can be used. With a vector icon, you would provide a single
    image, `Icon.svg` (**Scalable Vector Graphics**), that can be drawn at exactly
    the resolution required for a sharp image.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 向量图形指的是由线条和形状组成的图像，而不是像素集合（称为位图图形）。虽然这些图像加载可能较慢，但它们非常适合在任何比例下绘制完美的图像。随着计算机屏幕和智能手机像素密度的持续增加，以每英寸点数（**DPI**）衡量，生产在所有设备上看起来都好的位图图形变得越来越困难。例如，iOS平台历史上通过要求相同内容的不同分辨率的多个文件来解决这个问题——如`Icon.png`、`Icon@2x.png`和`Icon@3x.png`（例如，分别为60
    x 60、120 x 120或180 x 180像素）——以便可以使用最适合屏幕的图像。使用向量图标时，您将提供一个单独的图像，`Icon.svg`（**可缩放矢量图形**），它可以绘制出所需的精确分辨率，以获得清晰的图像。
- en: The Fyne toolkit uses vector graphics throughout so that applications built
    using it can scale appropriately for any computer screen. When an application
    starts, it calculates the pixel density (DPI) of the current screen and sets an
    appropriate scale for the application. Additionally, when a Fyne window is moved
    to a screen with a different resolution, the content (and window containing it)
    will re-size accordingly. This means that when an application running on a laptop
    (typically, a high-resolution screen) moves to an external monitor (usually a
    lower resolution), the window will be resized to a smaller number of pixels to
    try and maintain a consistent size for the user. If you wish to override the scale
    that's auto detected, then it is possible to set a `FYNE_SCALE` environment variable
    before launching the application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包在整个工具包中使用向量图形，以便使用它构建的应用程序可以适当地缩放以适应任何计算机屏幕。当应用程序启动时，它会计算当前屏幕的像素密度（DPI）并设置适当的缩放比例。此外，当Fyne窗口移动到具有不同分辨率的屏幕时，内容（以及包含它的窗口）将相应地调整大小。这意味着当在笔记本电脑（通常是高分辨率屏幕）上运行的应用程序移动到外部显示器（通常是低分辨率）时，窗口将调整到更少的像素数量，以尝试保持用户的一致大小。如果您希望覆盖自动检测到的缩放比例，那么在启动应用程序之前设置`FYNE_SCALE`环境变量是可能的。
- en: 'An example of setting scale values—notice the crisp text and icons:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置比例值的示例——注意清晰的文本和图标：
- en: '![](img/814807d2-14b4-4bd6-8fd9-dd1a04d5dc98.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/814807d2-14b4-4bd6-8fd9-dd1a04d5dc98.png)'
- en: FYNE_SCALE=0.5
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: FYNE_SCALE=0.5
- en: '![](img/d1ed9bea-dd20-4113-a50a-c3036ee6ca7b.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1ed9bea-dd20-4113-a50a-c3036ee6ca7b.png)'
- en: FYNE_SCALE=2.5
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: FYNE_SCALE=2.5
- en: 'In some situations, it may be appropriate to use a raster image instead of
    a vector. This is usually helpful if you want to draw exactly as many pixels as
    are visible in the space available. An example of this may be found in image manipulation
    programs or when drawing the result of a complex calculation. For these situations,
    there is a type of image within the Fyne API (created with `canvas.NewRaster()`)
    that provides this functionality. One of the examples provided by Fyne is a fractal
    viewer, where each pixel is calculated and drawn using the raster image feature:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，使用位图图像而不是向量图像可能是合适的。如果您想要绘制与可用空间中可见像素数量完全相同的像素，这通常是有帮助的。这种情况的一个例子可以在图像处理程序中找到，或者在绘制复杂计算的结果时。对于这些情况，Fyne
    API（使用`canvas.NewRaster()`创建）中存在一种图像类型，它提供了这种功能。Fyne提供的示例之一是分形查看器，其中每个像素都是使用位图图像功能计算和绘制的：
- en: '![](img/78962a72-b4cd-40b7-a867-c4a9fb0f31ea.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78962a72-b4cd-40b7-a867-c4a9fb0f31ea.png)'
- en: A mandelbrot fractal calculated per-pixel for the output device. Observe the
    level of detail
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为输出设备逐像素计算出的曼德布罗特分形。观察细节水平
- en: Drivers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驾驶员
- en: A driver in Fyne is responsible for rendering the text, canvas objects, and
    images, as well as handling window management and user input. The drivers are
    also required to handle any thread management behind the scenes. By adopting this
    design, it is possible for background processes or asynchronous events to update
    the user interface without any of the thread management code that is common in
    many graphical toolkits.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne中的驱动程序负责渲染文本、画布对象和图像，以及处理窗口管理和用户输入。驱动程序还必须处理任何后台的线程管理。通过采用这种设计，背景进程或异步事件可以在没有任何图形工具包中常见的线程管理代码的情况下更新用户界面。
- en: The default driver for Fyne uses Go-GL and the Go GLFW bindings, which means
    it has the same dependencies as the examples we worked through in the previous
    chapter, *nk – Nuklear for Go*. If your computer, and that of your target customers,
    supports OpenGL (which includes all recent desktop computers, most laptops, smart
    phones, and tablets, and beyond), then you don't need any additional libraries
    or support packages. Having the appropriate Go developer tools installed (see
    *Prerequisites* within the *Getting started with Fyne*, discussed earlier) is
    all you need, and there are no runtime requirements for users of your apps.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne的默认驱动程序使用Go-GL和Go GLFW绑定，这意味着它具有与我们在上一章中工作的示例相同的依赖项，即*nk – Nuklear for Go*。如果你的电脑和目标客户电脑支持OpenGL（这包括所有最新的桌面电脑、大多数笔记本电脑、智能手机和平板电脑等），那么你不需要任何额外的库或支持包。安装适当的Go开发者工具（参见*入门Fyne*中的*先决条件*，前面已讨论）就是你所需要的，并且你的应用程序用户没有运行时要求。
- en: If you wish to build for an older computer, or one that does not have support
    for OpenGL, it is possible to use the alternative `efl` driver. This driver uses
    the Enlightenment Foundation Libraries to handle rendering, window management,
    and user input in a cross platform manner. Their years of development for a wide
    range of platforms (alongside desktop platforms, they support Playstation, Tizen,
    Samsung Gear watch, and various set-top boxes) means that applications could potentially
    run on a wider range of devices. To run using this driver, just add `-tags efl` to
    any go build or run command, such as `go run -tags efl hello.go`. While this driver
    does offer better multi-platform support, it also requires that the EFL libraries
    are installed both on the developer's computer and the target device. For this
    reason, it is often not the preferred approach when working with Fyne.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为旧电脑或没有OpenGL支持电脑构建，可以使用替代的`efl`驱动程序。这个驱动程序使用Enlightenment Foundation Libraries以跨平台的方式处理渲染、窗口管理和用户输入。它们在广泛平台上的多年开发（除了桌面平台，它们还支持Playstation、Tizen、Samsung
    Gear手表和各种机顶盒）意味着应用程序可以在更广泛的设备上运行。要使用此驱动程序运行，只需在任意的go构建或运行命令中添加`-tags efl`，例如`go
    run -tags efl hello.go`。虽然这个驱动程序确实提供了更好的多平台支持，但它也要求在开发者的电脑和目标设备上都安装了EFL库。因此，当使用Fyne时，这通常不是首选的方法。
- en: Supported platforms
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持的平台
- en: Although the different Fyne drivers have potentially different supported platforms,
    the core toolkit just supports a standard set of operating systems. At the time
    of writing, this covered macOS, Windows, Linux, and BSD variants. Any operating
    system-specific code understands how applications should function on each of these
    target. Unlike the other toolkits in [Section 3](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml), *Modern
    Graphical Toolkits,* Fyne is designed to provide APIs for managing applications
    as well as their graphical interfaces. For example, `app.OpenURL()` allows an
    application to launch an external document in the default browser for each supported
    system.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不同的Fyne驱动程序可能支持不同的平台，但核心工具包仅支持一组标准的操作系统。在撰写本文时，这包括macOS、Windows、Linux和BSD变体。任何特定操作系统的代码都理解应用程序应该如何在这些目标上运行。与[第3节](ab9e1a04-12c8-4239-938e-9cac4c604b65.xhtml)中的其他工具包不同，*现代图形工具包*，Fyne旨在为应用程序及其图形界面提供API。例如，`app.OpenURL()`允许应用程序在每个支持的系统上使用默认浏览器启动外部文档。
- en: Now that we've explored the Fyne project background, as well as its design and
    operating system support, let's explore the APIs it provides to application developers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了Fyne项目背景，以及其设计和操作系统支持，让我们来探索它为应用程序开发者提供的API。
- en: Canvas, widgets, and layouts
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布、小部件和布局
- en: The Fyne API is divided into various sub-packages for basic drawing definition,
    container layout, high-level widgets, and theme description. In this section,
    we will look at each in turn. These packages provide the implementation details
    that are useful from an application developer point of view, and they typically
    implement generic interfaces. These interface definitions are at the top level
    of the hierarchy and include things such as `fyne.CanvasObject` (which is implemented
    by any object that can be added to a canvas), `fyne.Container` (that describes
    how multiple objects can be grouped and laid out), and `fyne.Resource` (representing
    an embedded application resource, such as an icon or font). Additionally, there
    are some math and geometry utilities as well as definitions for event and text
    handling.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne API 被划分为多个子包，用于基本绘图定义、容器布局、高级小部件和主题描述。在本节中，我们将逐一查看。这些包提供了从应用程序开发人员的角度来看有用的实现细节，并且它们通常实现通用接口。这些接口定义位于层次结构的顶层，包括如
    `fyne.CanvasObject`（任何可以添加到画布的对象都实现了它）、`fyne.Container`（描述多个对象如何分组和布局）和 `fyne.Resource`（表示嵌入的应用程序资源，如图标或字体）。此外，还有一些数学和几何实用工具以及事件和文本处理的定义。
- en: There are additional packages that we will not cover, including `dialog` (helpful
    classes for common dialog windows), `driver` (which is where drivers are loaded
    from), and `test` (which provides helpful test facilities). Let's explore the
    other, more commonly used, packages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会介绍其他一些额外的包，包括 `dialog`（用于常见对话框窗口的有用类）、`driver`（驱动程序从这里加载）和 `test`（提供有用的测试设施）。让我们探索其他更常用的包。
- en: Canvas (drawing)
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas (绘图)
- en: 'The `canvas` package includes definitions of all of the basic drawing objects
    that Fyne understands. Each of these types defines a number of fields that represent
    the configuration, such as color, size, and visibility. These are the objects
    that a Fyne driver will iterate over, drawing each to create the rendered user
    interface:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas` 包包含 Fyne 理解的所有基本绘图对象的定义。这些类型中的每一个都定义了代表配置的多个字段，例如颜色、大小和可见性。这些是 Fyne
    驱动程序将遍历的对象，将每个对象绘制出来以创建渲染的用户界面：'
- en: '| `Circle` | This is a circle, or ellipse, defined by the bounding top-left
    to bottom-right rectangle. It could be created with `NewCircle()` or `&Circle{}`.
    It isn''t commonly used in most applications. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `Circle` | 这是一个由边界左上角到右下角的矩形定义的圆形或椭圆。它可以由 `NewCircle()` 或 `&Circle{}` 创建。在大多数应用程序中并不常用。|'
- en: '| `Image` | An image may be a vector or bitmap-based image loaded from a file
    (with `NewImageFromFile()`) or embedded resource, or it may be an image generated
    dynamically to fill available space (using `NewRaster()` and a `func(w, h int)
    *image.Image` callback). |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `Image` | 一张图像可能是一个从文件（使用 `NewImageFromFile()`）或嵌入的资源加载的矢量或位图图像，或者它可能是一个动态生成的图像以填充可用空间（使用
    `NewRaster()` 和 `func(w, h int) *image.Image` 回调）。|'
- en: '| `Line` | This is a simple line that draws from one position to another. It
    isn''t commonly used unless drawing diagrams. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `Line` | 这是一个从一点绘制到另一点的简单线条。除非绘制图表，否则并不常用。|'
- en: '| `Rectangle` | The basic building block for widgets, a rectangle draws an
    area with a specified color. Create with `NewRectangle()` or `&Rectangle{}`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Rectangle` | 是小部件的基本构建块，矩形以指定的颜色绘制一个区域。可以通过 `NewRectangle()` 或 `&Rectangle{}`
    创建。|'
- en: '| `Text` | The text canvas primitive draws a single string to screen in a specified
    color and alignment. It does not handle any special characters or formatting.
    It can be created directly using `&Text{}` or with the helper `NewText()` function.
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | 文本画布原语以指定的颜色和对齐方式在屏幕上绘制单个字符串。它不处理任何特殊字符或格式。可以直接使用 `&Text{}` 或使用辅助
    `NewText()` 函数创建。|'
- en: The preceding list makes up the primitive drawing elements of the Fyne canvas.
    Next, we look at how layouts can be used to position them within a container.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表构成了 Fyne 画布的原始绘图元素。接下来，我们将查看如何使用布局在容器内定位它们。
- en: Layout
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Layout
- en: 'Multiple objects in Fyne are grouped in a `fyne.Container` type and its child
    objects are laid out by `fyne.Layout`. Various standard layouts are provided,
    as detailed in the following table. A layout provides two functions: first, it
    manages the size and position for a list of `fyne.CanvasObject` objects; and second,
    it must define the minimum size required to fit all of the objects it arranges:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne 中的多个对象被分组在 `fyne.Container` 类型中，其子对象通过 `fyne.Layout` 进行布局。提供了各种标准布局，具体细节如下表所示。布局提供两个功能：首先，它管理一系列
    `fyne.CanvasObject` 对象的大小和位置；其次，它必须定义容纳所有它安排的对象所需的最小大小：
- en: '| `BorderLayout` | The border layout places a specific canvas object at each
    of the top, bottom, left, and right edges of a container. Any other objects in
    the container will fill the central space. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `BorderLayout` | 边界布局将特定的画布对象放置在容器的顶部、底部、左侧和右侧边缘。容器中的任何其他对象将填充中央空间。|'
- en: '| `BoxLayout` | The box layout is either vertical or horizontal (created with
    `NewVBoxLayout()` or `NewHBoxLayout()` functions). It will arrange items in a
    list, each at their minimum height (vertical) or width (horizontal), and the other
    dimension will expand to the container edge. A box layout may also contain a spacer
    that will expand to fill available space (normally created with `NewSpacer()`).
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `BoxLayout` | 箱式布局是垂直或水平（使用`NewVBoxLayout()`或`NewHBoxLayout()`函数创建）。它将项目排列在列表中，每个项目都位于其最小高度（垂直）或宽度（水平），另一个维度将扩展到容器边缘。箱式布局还可以包含一个填充器，它将扩展以填充可用空间（通常使用`NewSpacer()`创建）。|'
- en: '| `FixedGridLayout` | The fixed grid layout specifies the size of every cell
    and then arranges them in rows within the available space. A new row is created
    when the next widget would have extended beyond the container width. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `FixedGridLayout` | 固定网格布局指定每个单元格的大小，然后在可用空间内按行排列它们。当下一个小部件扩展到容器宽度之外时，将创建新的一行。|'
- en: '| `GridLayout` | The grid layout has a specified number of columns and each
    child object will be the appropriate fraction of the container width. The height
    is defined similarly, depending on the number of child canvas objects. For example,
    with five objects in two columns, there will be three equal height rows. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `GridLayout` | 网格布局具有指定的列数，每个子对象将占据容器宽度的适当比例。高度以类似的方式定义，取决于子画布对象的数量。例如，如果有五个对象分布在两列中，将有三行等高。|'
- en: '| `MaxLayout` | This is the simplest layout. Every item is set to the same
    size to fill the available space. Be careful to specify container objects in the
    correct order (the first will be drawn under any subsequent items). For example,
    a button may simply be a rectangle with text positioned above where both should
    expand equally. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `MaxLayout` | 这是最简单的布局。每个项目都设置为相同的大小以填充可用空间。请注意，以正确的顺序指定容器对象（第一个将被绘制在后续任何项目下方）。例如，一个按钮可能只是一个矩形，文本位于上方，两者都应等比例扩展。|'
- en: It is also possible to write a custom layout by implementing the `fyne.Layout`
    interface. The `MinSize()` function should determine the size required (probably
    respecting the `MinSize()` function of the child objects) and the `Layout()` function
    calls `Move()` and `Resize()` on child objects to configure the display for rendering.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过实现`fyne.Layout`接口来编写自定义布局。`MinSize()`函数应确定所需的大小（可能尊重子对象上的`MinSize()`函数）并且`Layout()`函数在子对象上调用`Move()`和`Resize()`以配置显示以进行渲染。
- en: Whilst containers and layouts are useful, most of our time will be spent with
    higher-level widget definitions, so let's see what is available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器和布局很有用，但我们将大部分时间将花费在高级小部件定义上，所以让我们看看有哪些可用。
- en: Widgets
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件
- en: 'Fyne widgets are divided into two parts: the behavior, which is what the main
    API exposes, and the renderer, which controls how a widget will look. Unless you
    are building a custom widget, it is not recommended to access the render functionality
    (hidden behind the `widget.Renderer()` utility function). Customization of the
    user interface, if required, should be managed using the `theme` package (refer
    to the next section).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne小部件分为两部分：行为，这是主API暴露的内容，以及渲染器，它控制小部件的外观。除非你正在构建自定义小部件，否则不建议访问渲染功能（隐藏在`widget.Renderer()`实用函数后面）。如果需要，用户界面的定制应使用`theme`包管理（参考下一节）。
- en: 'All widgets can be created using their constructing function (such as `NewButton("text",
    callback)`) or using the initializer syntax, such as `&Button{Text: "text", OnTapped:
    callback}`. If the latter is used, then fields can also be set immediately after
    the widget is initiated until it is first rendered. After a widget is shown, setter
    functions, such as `SetText()`, should be used to ensure that the GUI is updated
    to reflect the changes. Widget fields can still be useful—if you want to update
    multiple properties at once, you can set the appropriate fields to be applied
    in a single refresh. Just be sure to call `widget.Refresh(myObject)` once you''ve
    applied the changes.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '所有小部件都可以使用它们的构造函数（如`NewButton("text", callback)`）或使用初始化语法创建，例如`&Button{Text:
    "text", OnTapped: callback}`。如果使用后者，则还可以在初始化小部件后立即设置字段，直到它首次渲染。小部件显示后，应使用设置函数（如`SetText()`）来确保GUI更新以反映更改。小部件字段仍然很有用——如果您想一次性更新多个属性，可以将适当的字段设置为在单个刷新中应用。只需确保在应用更改后调用`widget.Refresh(myObject)`即可。'
- en: 'The full list of widgets at the time of writing is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 写作时的完整小部件列表如下：
- en: '| `Box` | This is a simple widget that uses a `layout.BoxLayout` to arrange
    the child objects in horizontal or vertical lists. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `Box` | 这是一个简单的使用`layout.BoxLayout`来排列子对象在水平或垂直列表中的小部件。 |'
- en: '| `Button` | The basic button contains text and/or an icon and will call a
    passed `func()` when it is tapped. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `Button` | 基本按钮包含文本和/或图标，并在被轻触时调用传递的`func()`。 |'
- en: '| `Check` | A check widget displays a label next to a check box and triggers
    a `func(bool)` callback if it is toggled. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Check` | 复选框小部件显示在复选框旁边的标签，并在切换时触发`func(bool)`回调。 |'
- en: '| `Entry` | A text entry widget for single- or multiple-line input. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `Entry` | 用于单行或多行输入的文本输入小部件。 |'
- en: '| `Form` | The form widget lays out a simple data form, with labels in one
    column and input widgets on the other. Setting `OnSubmit` or `OnCancel` fields
    for callbacks will include the appropriate buttons on an additional row. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Form` | 表单小部件布局一个简单的数据表单，其中标签在一列，输入小部件在另一列。设置`OnSubmit`或`OnCancel`回调字段将包括在附加行上的适当按钮。
    |'
- en: '| `Group` | A visual grouping of child objects. A line is drawn around the
    items and a title label is drawn above them. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `Group` | 子对象的视觉分组。在项目周围绘制一条线，并在它们上方绘制一个标题标签。 |'
- en: '| `Icon` | A simple widget for drawing a themed icon. Create it with an icon
    resource (refer to *Themes* in the following section), and it will adapt to the
    current theme configuration. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `Icon` | 用于绘制主题图标的简单小部件。使用图标资源（参考以下部分的*主题*）创建它，它将适应当前主题配置。 |'
- en: '| `Label` | This is a simple text widget that draws using the current theme
    text color and updates if that changes. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Label` | 这是一个简单的文本小部件，使用当前主题文本颜色绘制，并在颜色更改时更新。 |'
- en: '| `PasswordEntry` | The same as for the preceding `Entry` widget, but the text
    is hidden as `*` characters. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `PasswordEntry` | 与前面的`Entry`小部件相同，但文本以`*`字符隐藏。 |'
- en: '| `TabContainer` | Similar to a standard container, except that it can display
    different contents. Each child container is associated with a tab button that,
    when pressed, will show the appropriate content. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `TabContainer` | 与标准容器类似，但可以显示不同的内容。每个子容器都与一个标签按钮相关联，当按下时，将显示适当的内容。 |'
- en: '| `Toolbar` | A toolbar widget shows a row of icon buttons, optionally separated
    with `NewToolbarSpacer()` (an invisible space) or `NewToolbarSeparator()` (a thin
    line to show the grouping). |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `Toolbar` | 工具栏小部件显示一行图标按钮，可选地用`NewToolbarSpacer()`（一个不可见的空间）或`NewToolbarSeparator()`（一条细线以显示分组）分隔。
    |'
- en: It is possible to implement your own widgets—all they need to do is implement
    the `fyne.Widget` interface. As well as the basic `fyne.CanvasObject` functions,
    a widget must also define a `CreateRenderer()` function returning a `fyne.WidgetRenderer`
    instance. A widget renderer is similar to a container object, but it also has
    a background color and should reflect the current theme (the required `ApplyTheme()`
    function will be called on all widgets if the theme is changed). As we've mentioned
    it many times, let's now explore more of what a Fyne theme provides.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自己的小部件是可能的——它们需要做的只是实现`fyne.Widget`接口。除了基本的`fyne.CanvasObject`函数外，小部件还必须定义一个返回`fyne.WidgetRenderer`实例的`CreateRenderer()`函数。小部件渲染器类似于容器对象，但它还具有背景颜色，并且应该反映当前主题（如果更改主题，将调用所有小部件的所需`ApplyTheme()`函数）。正如我们多次提到的，现在让我们进一步探索Fyne主题提供的内容。
- en: Themes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: 'The `theme` package is an implementation of a material design inspired user
    interface. It provides the color palette, icons, font, and spacing information
    required to display the Fyne user interface:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`theme`包是一个受材料设计启发的用户界面实现。它提供了显示Fyne用户界面所需的色彩方案、图标、字体和间距信息：'
- en: '![](img/6f634169-9efc-449a-aa9b-bb3b408b1045.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f634169-9efc-449a-aa9b-bb3b408b1045.png)'
- en: The "baseline" material design color palette. Fyne uses a blue/gray variant
    by default
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: “基准”材料设计色彩方案。Fyne默认使用蓝色/灰色变体
- en: Widgets utilize the theme package extensively to match the current settings.
    For example, a button will be colored `theme.ButtonColor()` (unless it is a primary
    button, in which case it's `theme.PrimaryColor()`) and a label text is `theme.TextColor()`.
    Fyne also packages a standard font that can be accessed using `theme.TextFont()`
    (and variations), but these are not often needed. Instead, use `fyne.TextStyle`
    properties on a text object or label. However, `theme.TextSize()` and `theme.Padding()`
    are useful ways to match the user interface style in a custom widget.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件广泛使用主题包以匹配当前设置。例如，按钮将被着色为`theme.ButtonColor()`（除非它是主按钮，在这种情况下为`theme.PrimaryColor()`），而标签文本为`theme.TextColor()`。Fyne还打包了一个标准字体，可以使用`theme.TextFont()`（及其变体）访问，但这些通常不需要。相反，请在文本对象或标签上使用`fyne.TextStyle`属性。然而，`theme.TextSize()`和`theme.Padding()`是匹配自定义小部件用户界面风格的有用方式。
- en: Fyne themes also provide a collection of material design icons that can be used
    in any application, for example, `theme.ContentPasteIcon()`. Icons loaded from
    a theme will adapt to a new theme loading when used with any standard widgets.
    These icons are bundled with the toolkit and do not require any installation or
    additional items to be shipped with an application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne主题还提供了一组可以在任何应用程序中使用的材料设计图标，例如，`theme.ContentPasteIcon()`。从主题加载的图标在使用任何标准小部件时将适应新的主题加载。这些图标与工具包捆绑在一起，不需要安装或与应用程序一起发送任何额外项目。
- en: Any time you use a theme method, it's important to realize that the result may
    change over time—a new theme could be loaded or the user may change the configuration.
    To handle this correctly, you should implement `fyne.ThemedObject`, which requires
    a single function, `ApplyTheme()`. Inside this function, you should re-apply any
    theme-based values that were accessed. This functionality is handled automatically
    by widgets, so it is not commonly required that an application handles theme changes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用主题方法时，重要的是要意识到结果可能会随时间而改变——可能会加载新的主题或用户可能会更改配置。为了正确处理这种情况，您应该实现`fyne.ThemedObject`，它需要一个函数`ApplyTheme()`。在这个函数内部，您应该重新应用任何访问过的基于主题的值。这种功能由小部件自动处理，因此通常不需要应用程序处理主题更改。
- en: Packaged themes
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包的主题
- en: 'The Fyne toolkit provides two themes to match a user''s preference—a light
    theme and a dark theme. To change the theme for an application, the environment
    variable, `FYNE_THEME`, can be set to *light* or *dark*. If you are implementing
    a custom widget, it''s advisable to test it with at least these two themes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Fyne工具包提供了两个主题以匹配用户的偏好——浅色主题和深色主题。要更改应用程序的主题，可以将环境变量`FYNE_THEME`设置为*light*或*dark*。如果您正在实现自定义小部件，建议至少使用这些两个主题进行测试：
- en: '![](img/7a3c5abd-2738-4a79-a741-189e46afb8b6.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a3c5abd-2738-4a79-a741-189e46afb8b6.png)'
- en: The default dark theme
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的深色主题
- en: '![](img/6793a240-1c09-440d-801e-556769b1a86d.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6793a240-1c09-440d-801e-556769b1a86d.png)'
- en: The alternative light theme
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的浅色主题
- en: At the time of writing, Fyne does not provide the ability to download user-created
    custom themes, but this may change in the future. It is, however, possible for
    an application to be displayed using its own theme. After implementing the `fyne.Theme`
    interface, you should pass an instance of the type to your application configuration
    using `app.Settings().SetTheme()`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Fyne不提供下载用户创建的自定义主题的功能，但未来可能会有所改变。然而，应用程序可以使用自己的主题进行显示。在实现`fyne.Theme`接口后，您应使用`app.Settings().SetTheme()`将类型的实例传递给应用程序配置。
- en: Building a user interface
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: To explore the Fyne toolkit further, let's build our latest version of the GoMail
    application designed in [Chapter 4](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml),
    *Walk – Building Graphical Windows Applications*. We will start by setting out
    the basic application layout.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步探索Fyne工具包，让我们构建[第4章](3b8f1272-2158-4744-945f-3258b5c4f61c.xhtml)中设计的GoMail应用程序的最新版本，*Walk
    – 构建图形窗口应用程序*。我们将从设置基本应用程序布局开始。
- en: Layout
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: Creating a complex layout with Fyne is a case of combining multiple containers,
    each of which are using one of the layouts provided. It would be possible to write
    our own layout to set up the interface with a single container, but for this exploration,
    we will use only the built-in components. Let's start by creating the main application
    window.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fyne创建复杂布局的情况是将多个容器组合起来，每个容器都使用提供的布局之一。我们有可能编写自己的布局来使用单个容器设置界面，但在这个探索中，我们将仅使用内置组件。让我们从创建主应用程序窗口开始。
- en: Main email window
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要电子邮件窗口
- en: 'To load the first window of a Fyne application, we must create a new application
    instance using `app.New()`. After that, we can call the `NewWindow()` function
    on this application object. The returned `fyne.Window` object allows us to control
    the window on screen and to set its content:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载Fyne应用程序的第一个窗口，我们必须使用`app.New()`创建一个新的应用程序实例。之后，我们可以在该应用程序对象上调用`NewWindow()`函数。返回的`fyne.Window`对象允许我们控制屏幕上的窗口并设置其内容：
- en: '[PRE1]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we will create the required widgets for our GUI. This starts by adding
    the widget import line, and then we add the declarations to the `main()` function
    created previously. A toolbar is added using `widget.NewToolbar()` (we will add
    items to it later). For the email list on the left, we create a new titled group
    using `widget.NewGroup()` with the title `Inbox`. Into this group we add placeholder
    labels using `widget.NewLabel()`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的GUI创建所需的控件。这首先是通过添加控件导入行开始的，然后我们在之前创建的`main()`函数中添加声明。使用`widget.NewToolbar()`添加了一个工具栏（我们稍后会向其中添加项目）。对于左侧的电子邮件列表，我们使用`widget.NewGroup()`创建一个新的带标题的组，标题为`Inbox`。我们向这个组添加了占位符标签，使用`widget.NewLabel()`。
- en: 'Then, we create new labels for the content and subject of the email to display.
    We set the text of the subject label using a `fyne.TextStyle` declaration. Lastly,
    we set up the grid layout for our email metadata using `widget.NewForm()`. A form
    widget matches our design of where we list rows with a bold text label next to
    the widget it describes. To the form, we append the **To**, **From**, and **Date** items, shown as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为电子邮件的内容和主题创建新的标签以显示。我们使用`fyne.TextStyle`声明设置主题标签的文本。最后，我们使用`widget.NewForm()`设置我们的电子邮件元数据的网格布局。表单小部件符合我们的设计，即列出带有描述小部件的粗体文本标签的行。对于表单，我们添加了**收件人**、**发件人**和**日期**项，如下所示：
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have defined all of the widgets, we need to lay them out appropriately.
    In Fyne, we typically use a `fyne.Container` object and optionally pass a layout
    to control how it is set up. There are also some helper widgets that provide easier-to-use
    APIs, such as `widget.NewVBox()` used in the following section (that sets up a
    container where items are arranged in a vertical list).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所有控件，我们需要适当地布局它们。在Fyne中，我们通常使用`fyne.Container`对象，并可选地传递一个布局来控制其设置方式。还有一些辅助控件提供了更易于使用的API，例如在下一节中使用的`widget.NewVBox()`（它设置了一个容器，其中项目按垂直列表排列）。
- en: In both containers in this code snippet, we are using `BorderLayout`. When calling
    `layout.NewBorderLayout()`, we pass the objects that should be positioned in the
    top, bottom, left, and right positions of the layout (or `nil` if they are to
    be left empty). Any items that are included in the container not listed in a particular
    position will be arranged to fill the center of the layout, taking up all remaining
    space. Remember that items to be placed in one of the border sections should also
    be passed into the `fyne.NewContainerWithLayout()` function as subsequent parameters,
    as this controls which objects will be drawn within the container. Refer to the
    following section to see how `subject` and `box` are passed to the layout as well
    as the container, as we wish them to be positioned by the layout and drawn by
    the container.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中的两个容器中，我们使用的是`BorderLayout`。在调用`layout.NewBorderLayout()`时，我们传递了应该放置在布局顶部、底部、左侧和右侧的对象（如果它们要留空，则为`nil`）。任何包含在容器中但未在特定位置列出的项目将被排列以填充布局的中心，占据所有剩余空间。记住，要放置在边框部分的项目也应作为后续参数传递给`fyne.NewContainerWithLayout()`函数，因为这控制了将在容器内绘制的对象。请参阅以下部分，了解如何将`subject`和`box`传递给布局以及容器，因为我们希望它们由布局定位并由容器绘制。
- en: 'In the first container (`detail`), we''ve set the `subject` label to stretch
    along the top and the `box` containing our metadata and content to be left-aligned
    within the container. The following container (`container`) is our overall application
    layout and it positions the `toolbar` at the top, the email `list` on the left,
    and the `detail` container fills the remaining space for the layout (since it
    is not specified as a border parameter):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个容器（`detail`）中，我们将 `subject` 标签设置为沿顶部拉伸，并将包含我们的元数据和内容的 `box` 在容器内左对齐。下一个容器（`container`）是我们的整体应用程序布局，它将
    `toolbar` 放在顶部，将电子邮件 `list` 放在左侧，并将 `detail` 容器填充布局的剩余空间（因为它没有指定为边框参数）：
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With all of the containers and layouts defined, we need to complete the window
    by setting its content and optionally specifying a size. You may not have to call
    the `Resize()` function on a window—its default size will be the appropriate size
    to fit all of the widgets and containers at their minimum size.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有容器和布局之后，我们需要通过设置其内容并可选地指定大小来完成窗口。你可能不需要在窗口上调用 `Resize()` 函数——它的默认大小将适合所有小部件和容器在其最小尺寸。
- en: 'Finally, we call `ShowAndRun()` on the window, which will cause the window
    to appear and the application''s main loop to start. Any subsequent windows can
    simply call `Show()` (since an application should only start once):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在窗口上调用 `ShowAndRun()`，这将使窗口出现并启动应用程序的主循环。任何后续的窗口只需简单地调用 `Show()`（因为应用程序应该只启动一次）：
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the preceding code (which can be found in the source code repository
    for this book) should result in a window much like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码（可以在本书的源代码仓库中找到）应该会产生一个类似于以下窗口的窗口：
- en: '![](img/2111f93c-7306-4e2c-a3ca-16df5e2be976.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2111f93c-7306-4e2c-a3ca-16df5e2be976.png)'
- en: The basic application layout with Fyne. The bar at the top is an empty toolbar
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fyne 的基本应用程序布局。顶部的栏是一个空的工具栏
- en: Compose dialog
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撰写对话框
- en: 'To start our secondary window, the compose dialog, we could use the custom
    dialog feature in Fyne (created with `dialog.ShowCustom()`). However, all dialog
    windows in Fyne are of a fixed size, and we would like the compose window to be
    flexible. Instead, we will create a new window, as in our `main()` function, using
    `app.NewWindow()`. To do this, we will need to pass the app instance into a new
    `ShowCompose()` function (as windows are created from the app object):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的次要窗口，即撰写对话框，我们可以使用 Fyne 中的自定义对话框功能（使用 `dialog.ShowCustom()` 创建）。然而，Fyne
    中的所有对话框窗口都是固定大小的，而我们希望撰写窗口是灵活的。因此，我们将创建一个新的窗口，就像我们的 `main()` 函数中一样，使用 `app.NewWindow()`。为此，我们需要将应用程序实例传递给一个新的
    `ShowCompose()` 函数（因为窗口是从应用程序对象创建的）：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we create the widgets for the compose window. We will use `widget.NewEntry()`
    for each of the text entry components. For the multiple-line message widget, we
    could set `Entry.MultiLine` to `true`, but instead, we use the `widget.NewMultiLineEntry()`
    helper function. In each instance, we use `Entry.SetPlaceHolder()` to set a placeholder
    value (that will display as a hint, until the user enters their own text).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建用于撰写窗口的小部件。我们将为每个文本输入组件使用 `widget.NewEntry()`。对于多行消息小部件，我们可以将 `Entry.MultiLine`
    设置为 `true`，但相反，我们使用 `widget.NewMultiLineEntry()` 辅助函数。在每个实例中，我们使用 `Entry.SetPlaceHolder()`
    设置一个占位符值（在用户输入自己的文本之前将显示为提示）。
- en: 'Two new buttons are created using `widget.NewButton()`, one with a `"Send"`
    label, and the other with `"Cancel"`. We keep a reference to the `send` button
    so that we can set `Button.Style` to `widget.PrimaryButton`. This highlights the
    button as the window default action. Lastly, we create a new horizontal box for
    the button bar using `widget.NewHBox()`. Into that, we first add a spacer to right-align
    the buttons (using `layout.NewSpacer()`), and then we include the Cancel and Send
    buttons:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `widget.NewButton()` 创建了两个新的按钮，一个带有 `"Send"` 标签，另一个带有 `"Cancel"`。我们保留了对 `send`
    按钮的引用，以便我们可以将 `Button.Style` 设置为 `widget.PrimaryButton`。这突出了按钮作为窗口的默认操作。最后，我们使用
    `widget.NewHBox()` 创建了一个新的水平框用于按钮栏。在这个框中，我们首先添加了一个填充物以使按钮右对齐（使用 `layout.NewSpacer()`），然后包括了取消和发送按钮：
- en: '[PRE6]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, we set up the layout of the window. Once again, this is a non-trivial
    layout due to Fyne's simple layout options. We use `layout.NewBorderLayout()`
    to specify which components should stretch and which should be placed around them.
    The `top` layout places the subject along its top edge and aligns the `to` field
    left of the expanding `toLabel`. The second layout, `content`, positions the `message`
    editor in the center, with the `top` layout above and the `buttons` bar below.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置窗口的布局。再次强调，这是一个非平凡的布局，因为Fyne的布局选项很简单。我们使用`layout.NewBorderLayout()`来指定哪些组件应该拉伸，哪些应该放置在其周围。`top`布局将主题放置在其顶部边缘，并将`to`字段与扩展的`toLabel`左对齐。第二个布局`content`将`message`编辑器放置在中心，`top`布局在其上方，`buttons`栏在其下方。
- en: 'We then set the content of the new `compose` window, set it to a default size
    (larger than the `minSize()` calculated by the layouts), and call `Show()`. Remember
    that, this time, we do not use `ShowAndRun()`, since the application is already
    running:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置新`compose`窗口的内容，将其设置为默认大小（大于布局计算的`minSize()`），并调用`Show()`。记住，这次我们不使用`ShowAndRun()`，因为应用程序已经运行：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although we don''t have a `compose` button yet, this code can be invoked from
    the `main()` function immediately before the `browse.ShowAndRun()` just for test
    purposes (remember to remove this line afterward). The result should be something
    like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还没有`compose`按钮，但此代码可以从`main()`函数立即调用，在`browse.ShowAndRun()`之前进行测试（记得之后删除此行）。结果应该类似于以下内容：
- en: '![](img/3a1bf64c-1a2e-458c-b310-33d2002f2811.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a1bf64c-1a2e-458c-b310-33d2002f2811.png)'
- en: Our compose dialog box using basic Fyne components
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用基本的Fyne组件创建的compose对话框
- en: Toolbar and menu
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具栏和菜单
- en: Unfortunately, Fyne has no menu bar support (although it is proposed in the
    following project issue: [https://github.com/fyne-io/fyne/issues/41](https://github.com/fyne-io/fyne/issues/41))[.](https://github.com/fyne-io/fyne/issues/41)
    We also cannot easily create one from simpler components, as there is currently
    no support for pop-over widgets. Therefore, we will just add a toolbar (as in
    some previous examples).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Fyne没有菜单栏支持（尽管在以下项目问题中提出了建议：[https://github.com/fyne-io/fyne/issues/41](https://github.com/fyne-io/fyne/issues/41)）。我们也不能轻易地从更简单的组件中创建一个，因为目前没有对弹出小部件的支持。因此，我们只需添加一个工具栏（如一些之前的示例所示）。
- en: Using Fyne's built-in iconography (from the material design project), we can
    quickly create an attractive toolbar. To set up the toolbar, we will create a
    new function, `buildToolbar()`, that will create the toolbar and add the items
    to it. We pass in the application instance so that the Compose item can pass it
    into the `ShowCompose()` function we created earlier.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fyne内置的图标（来自材料设计项目），我们可以快速创建一个吸引人的工具栏。为了设置工具栏，我们将创建一个新的函数`buildToolbar()`，该函数将创建工具栏并添加项目。我们传递应用程序实例，以便`Compose`项目可以将其传递到我们之前创建的`ShowCompose()`函数。
- en: 'The toolbar constructing function takes a list of `ToolbarItem` objects (any
    widget or type that implements `widget.ToolbarItem`). It is also possible to call
    `Append()` or `Prepend()` after the toolbar is created. For each item that should
    appear in the toolbar, we pass an action item using `widget.NewToolbarAction()`.
    A toolbar action takes a `fyne.Resource` parameter (the icon) and a `func()` that''s
    called when the item is tapped. For resources, we use the theme API to access
    standard icons that are packaged in the framework. Additionally, we add a separator
    to group actions using `widget.NewToolbarSeparator()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏构建函数接受一个`ToolbarItem`对象列表（任何实现`widget.ToolbarItem`的控件或类型）。在创建工具栏后，也可以调用`Append()`或`Prepend()`。对于应在工具栏中出现的每个项目，我们使用`widget.NewToolbarAction()`传递一个操作项。工具栏操作接受一个`fyne.Resource`参数（图标）和一个当项目被点击时调用的`func()`。对于资源，我们使用主题API来访问框架中打包的标准图标。此外，我们添加一个分隔符来分组操作，使用`widget.NewToolbarSeparator()`：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To use this new method, we update the toolbar creation code in the `main()`
    method to read simply `toolbar := buildToolbar(mailApp)`. With these changes in
    place, we see a full toolbar using the material design icons at the top of the
    main window, shown as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新方法，我们更新了`main()`方法中的工具栏创建代码，使其简单地读取`toolbar := buildToolbar(mailApp)`。这些更改到位后，我们会在主窗口顶部看到使用材料设计图标的完整工具栏，如下所示：
- en: '![](img/56e8b97f-fc33-427f-99d7-0e7eabc9ddc4.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56e8b97f-fc33-427f-99d7-0e7eabc9ddc4.png)'
- en: The built-in Fyne toolbar provides default icons for many actions
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的Fyne工具栏为许多操作提供了默认图标
- en: Communicating with the GUI
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GUI通信
- en: Setting up the user interface to show real data and perform the appropriate
    interactions is as simple as setting text values and filling in click handlers.
    To begin with, we will add two helper methods.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户界面以显示真实数据并执行适当的交互，就像设置文本值和填写点击处理程序一样简单。首先，我们将添加两个辅助方法。
- en: Loading emails
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载电子邮件
- en: 'The first new function, `setMessage()`, will simply call `SetText()` on each
    of our `widget.Label` elements. This requires saving a reference to the `to`,
    `from`, `date`, `subject`, and `content` label widgets that were created earlier
    in this section. Their content can be updated using the `SetText()` function as
    follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新函数，`setMessage()`，将简单地调用 `SetText()` 对每个 `widget.Label` 元素。这需要保存之前在本节中创建的
    `to`、`from`、`date`、`subject` 和 `content` 标签小部件的引用。它们的内容可以使用以下 `SetText()` 函数更新：
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also create another helper function, `addEmail()`, to add a new email
    to the list. This is a change from the initial list of `widget.Labels` that we
    added to `widget.Group`—we are using buttons to utilize their built-in click handling.
    The button created in this function sets the label to be the email subject, as
    before, and calls the new `setMessage()` function if it is tapped:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建另一个辅助函数，`addEmail()`，用于向列表中添加新电子邮件。这与我们最初添加到 `widget.Group` 中的 `widget.Labels`
    列表不同——我们正在使用按钮来利用它们内置的点击处理功能。在此函数中创建的按钮将标签设置为电子邮件主题，就像之前一样，并在被点击时调用新的 `setMessage()`
    函数：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, the list code is updated to call the new `addEmail()` function when we
    load the user interface:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，列表代码更新为在加载用户界面时调用新的 `addEmail()` 函数：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Those are the only changes that we need to implement in order to make the browser
    interface functional. Now, let's add the appropriate handling code to the compose
    window.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要实现以使浏览器界面功能性的唯一更改。现在，让我们向编写窗口添加适当的处理代码。
- en: Sending email
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: 'To complete the work on the compose view, we need to update the buttons callback.
    For the cancel button, all that''s necessary is to call `Close()` on the window
    object. In the click handler for the send button, we will construct a new email
    and send it using the server object''s `Send()` function. The `client.NewMessage()`
    function handles creation of the email object. All we need to do is use the `Entry.Text`
    field for each input in order to access the current state:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成编写视图的工作，我们需要更新按钮的回调。对于取消按钮，只需要在窗口对象上调用 `Close()`。在发送按钮的点击处理程序中，我们将构建一个新的电子邮件并使用服务器对象的
    `Send()` 函数发送它。`client.NewMessage()` 函数处理电子邮件对象的创建。我们只需要使用每个输入的 `Entry.Text` 字段来访问当前状态：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this code in place, the application should function in exactly the same
    way as the previous examples we''ve built. Although the compose window does not
    look any different, our email browser window now has some real data in that should
    look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码到位后，应用程序应该与之前构建的示例完全一样地运行。尽管编写窗口看起来没有变化，但我们的电子邮件浏览器窗口现在有一些真实数据，看起来应该像这样：
- en: '![](img/c7280b53-4868-492e-a8b0-d20accbd3788.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7280b53-4868-492e-a8b0-d20accbd3788.png)'
- en: The completed GoMail interface in Fyne's default dark theme
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fyne 默认深色主题下的完成 GoMail 接口
- en: 'As Fyne provides two built-in themes, we can also see how the application looks
    if users prefer a light colored theme. By setting the `FYNE_THEME` environment
    variable to "light", we can load the alternative theme, demonstrated as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Fyne 提供了两种内置主题，我们还可以看到如果用户更喜欢浅色主题，应用程序看起来会是什么样子。通过将 `FYNE_THEME` 环境变量设置为
    "light"，我们可以加载替代主题，如下所示：
- en: '![](img/f43ebdf7-ea09-4023-82d9-b3354e38e929.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f43ebdf7-ea09-4023-82d9-b3354e38e929.png)'
- en: You can either set FYNE_THEME in the environment or pass it to the run command
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在环境中设置 FYNE_THEME 或将其传递给运行命令
- en: 'Setting the correct theme value will result in a light version of the application
    loading instead:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 设置正确的主题值将导致应用程序加载一个浅色版本：
- en: '![](img/bc399f14-aaba-4b9a-ad89-5ce43ac3ad91.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc399f14-aaba-4b9a-ad89-5ce43ac3ad91.png)'
- en: Our GoMail interface with the light Fyne theme
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们带有浅色 Fyne 主题的 GoMail 接口
- en: Before we complete this application, we should also cover the background processing
    portion—to handle when a new email arrives.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成此应用程序之前，我们还应该涵盖后台处理部分——处理新电子邮件到达的情况。
- en: Background processing
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台处理
- en: Background processing that updates the user interface does not require any special
    thread handling code with Fyne. You can execute the full set of graphical and
    widget commands in any goroutine—the toolkit will take care of any system thread
    management.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fyne 进行后台处理以更新用户界面不需要任何特殊的线程处理代码。你可以在任何 goroutine 中执行完整的图形和控件命令——工具包将负责任何系统线程管理。
- en: 'To add incoming emails to the list in our application, all we need to do is
    call `addEmail()` for the new `client.EmailMessage` and pass that to the `list.Prepend()`
    function. The code is as straightforward as the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新收到的电子邮件添加到我们应用程序中的列表，我们只需要为新的 `client.EmailMessage` 调用 `addEmail()` 并将其传递给
    `list.Prepend()` 函数。代码就像以下这样：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That completes our basic GoMail application. Given the Fyne project's similarities
    to the Shiny toolkit that we explored in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    – Experimental Go GUI API*, let's also see how we could rebuild the image viewer
    application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的基本 GoMail 应用程序。鉴于 Fyne 项目与我们在第 8 章中探讨的 Shiny 工具包相似，即 [Shiny – Experimental
    Go GUI API](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)，让我们也看看我们如何重新构建图像查看器应用程序。
- en: Building an image viewer
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建图像查看器
- en: Since the Fyne toolkit includes a canvas API and image handling similar to the
    Shiny project, it makes sense to also compare with the image viewer application
    that we created in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny
    – Experimental Go GUI API*. Let's start, as usual, with the basic application
    layout.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Fyne 工具包包括类似于 Shiny 项目的画布 API 和图像处理，因此与我们在第 8 章中创建的图像查看器应用程序进行比较也是有意义的，即
    [Shiny – Experimental Go GUI API](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)。让我们像往常一样，从基本的应用程序布局开始。
- en: Layout
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'As we will be working with canvas APIs, as well as widgets and layouts, we
    will need to start by importing most of the Fyne sub-packages. In addition to
    *canvas*, where we get the basic image APIs, we will also use the `theme` package
    for accessing icons and the `app` package to launch our application. We don''t
    need to import the image libraries, such as `image/jpeg`, because Fyne image widgets
    import them for us:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用画布 API、控件和布局，我们需要首先导入大多数 Fyne 子包。除了 *canvas*，其中我们获取基本的图像 API，我们还将使用 `theme`
    包来访问图标，并使用 `app` 包来启动我们的应用程序。我们不需要导入图像库，如 `image/jpeg`，因为 Fyne 图像控件会为我们导入它们：
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As with any Fyne application, we start by creating an application using `app.New()`
    and then create a window for the application by calling `NewWindow()` with an
    appropriate title:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 Fyne 应用程序一样，我们首先使用 `app.New()` 创建一个应用程序，然后通过调用 `NewWindow()` 并提供一个合适的标题来为应用程序创建一个窗口：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we will create the widgets for the main layout. To achieve a visually
    distinct navigation bar, let's use a toolbar as in the GoMail application. In
    addition to standard icon buttons, we also add a spacer (with `widget.NewToolbarSpacer()`)
    so that the second button is right aligned in the bar. We will come back to the
    navigation later to add the filename display and functionality.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建主布局的控件。为了实现一个视觉上独特的导航栏，让我们像在 GoMail 应用程序中那样使用工具栏。除了标准图标按钮外，我们还添加了一个空格（使用
    `widget.NewToolbarSpacer()`），以便第二个按钮在栏中右对齐。我们稍后会回到导航，添加文件名显示和功能。
- en: 'Next, we use the `widget.Group` widget to visually group the file listing (we
    could use the `widget.Box` widget if the border-less look is preferred). Into
    the group, we append various labels that will serve as file placeholders. Lastly,
    we load the image view to show the placeholder file. The `canvas.NewImageFromFile()`
    function handles all of the image loading for us, as can be seen in the following
    code block:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `widget.Group` 控件来视觉上分组文件列表（如果更喜欢无边框的外观，我们可以使用 `widget.Box` 控件）。在组中，我们添加各种标签，它们将作为文件占位符。最后，我们加载图像视图以显示占位符文件。`canvas.NewImageFromFile()`
    函数为我们处理所有图像加载，如下面的代码块所示：
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For this application, a simple `layout.BorderLayout` will provide exactly the
    layout we are looking for. We create a new layout with `navBar` at the top and
    `fileList` on the left. The container also includes `image`, which will be stretched
    to fill the remaining space:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，简单的 `layout.BorderLayout` 将提供我们需要的精确布局。我们创建一个新的布局，其中 `navBar` 在顶部，`fileList`
    在左侧。容器还包括 `image`，它将被拉伸以填充剩余的空间：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we set this container to be the content of our window, resize the whole
    window to be larger than the calculated minimum size, and show it. As before,
    we use `ShowAndRun()` as a shortcut to running the application with this first
    window:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将此容器设置为窗口的内容，将整个窗口的大小调整为大于计算出的最小尺寸，并显示它。和之前一样，我们使用`ShowAndRun()`作为运行应用程序的快捷方式：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With all of this code in place, the example can be run. You should see a window
    very much like the following (assuming you are using the default dark theme):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些代码到位后，可以运行示例。你应该会看到一个与以下非常相似的窗口（假设你正在使用默认的深色主题）：
- en: '![](img/4e10814f-2052-4dfc-8395-e1e4a3de9fae.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e10814f-2052-4dfc-8395-e1e4a3de9fae.png)'
- en: A basic image viewer layout using default Fyne widgets
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认Fyne小部件的基本图像查看器布局
- en: Navigation
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航
- en: 'To complete the navigation bar, we need to also display the filename in the
    middle of the bar. As you may have noticed, there is no toolbar widget that allows
    the showing of text, but we can create our own. Every item in a toolbar implements
    the `widget.ToolbarItem` interface, so we can create a new type that follows this
    pattern. By implementing `ToolbarObject()` (the only function this interface requires),
    we can return the appropriate label to display:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成导航栏，我们还需要在栏的中间显示文件名。正如你可能已经注意到的，没有工具栏小部件允许显示文本，但我们可以创建自己的。工具栏中的每个项目都实现了`widget.ToolbarItem`接口，因此我们可以创建一个遵循此模式的新类型。通过实现`ToolbarObject()`（该接口仅要求一个函数），我们可以返回适当的标签以显示：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'While we are updating the navigation bar, we should create placeholder functions
    that will handle the button presses for "previous" (left arrow) and "next" (right
    arrow). An empty parameter list matches the function type for a `widget.Button`
    callback, so these are simply as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新导航栏时，我们应该创建占位符函数来处理“上一个”（左箭头）和“下一个”（右箭头）按钮的点击。空参数列表与`widget.Button`回调的函数类型相匹配，因此这些函数很简单如下：
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Lastly, we update the navigation bar creation to use the new `toolbarLabel`
    type that we created. By adding a second spacer widget, we are asking the layout
    to center the label as well as retain the right alignment of the next button:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将导航栏的创建更新为使用我们创建的新`toolbarLabel`类型。通过添加第二个间隔小部件，我们要求布局将标签居中，同时保留下一个按钮的右对齐：
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With these changes in place, running the code should result in the following
    updated navigation bar. We will return to this later to set the correct filename,
    but for now, we shall move on to the file listing on the left of the interface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，运行代码应该导致以下更新的导航栏。我们将在稍后返回此设置正确的文件名，但现在，我们将继续处理界面左侧的文件列表：
- en: '![](img/50885e41-fbc9-4dce-892b-2dda4ba901ba.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50885e41-fbc9-4dce-892b-2dda4ba901ba.png)'
- en: The navigation bar created using customized toolbar components
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义工具栏组件创建的导航栏
- en: File listing
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件列表
- en: 'As the Fyne list widgets do not support icon and text combinations, we will
    need to construct one from basic components. Within the file group, we update
    each item to call a new function, `makeRow()`, that will be defined later on.
    We pass the filename to this function so that it can load the image and display
    a suitable caption:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Fyne列表小部件不支持图标和文本的组合，我们需要从基本组件构建一个。在文件组中，我们将每个项目更新为调用一个新函数`makeRow()`，该函数将在稍后定义。我们向此函数传递文件名，以便它可以加载图像并显示合适的标题：
- en: '[PRE22]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The new `makeRow()` function will return a horizontal box widget containing
    the image preview and caption text. The preview image is loaded using `canvas.NewImageFromFile()` and
    a suitable size is set using `SetMinSize()`. To be consistent in terms of sizing,
    `theme.IconInlineSize()` is used for height and a 50% larger width—assuming most
    pictures are landscape. Finally, this is returned in a horizontal box, along with
    a new label widget, using `widget.NewHBox()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`makeRow()`函数将返回一个包含图像预览和标题文本的水平框小部件。预览图像使用`canvas.NewImageFromFile()`加载，并使用`SetMinSize()`设置一个合适的大小。为了在尺寸上保持一致，使用`theme.IconInlineSize()`作为高度，以及50%更大的宽度——假设大多数图片是横向的。最后，这在一个水平框中返回，以及一个新的标签小部件，使用`widget.NewHBox()`：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With these changes in place, you should see the same interface with icon previews
    before each filename. Before we are done with the layout, let''s polish the image
    view and see how we can maintain the image aspect ratio:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，你应该会看到每个文件名前都有图标预览的相同界面。在我们完成布局之前，让我们润色一下图像视图，看看我们如何保持图像的宽高比：
- en: '![](img/ebab6d07-eddd-48f6-977d-48f6f84ffd29.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebab6d07-eddd-48f6-977d-48f6f84ffd29.png)'
- en: Placeholder files and image thumbnails added to the interface
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到界面的占位符文件和图像缩略图
- en: Image view
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像视图
- en: To complete the image viewer layout, we need to look at the main image view.
    The default behavior for images in Fyne is that they'll expand to fill the available
    space (this is the `canvas.ImageFillStretch` mode). However, we want the image
    to maintain its aspect ratio, as well as remain within the bounds of the viewing
    area. We will also add a background pattern as we did in the Shiny example in
    [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny – Experimental
    Go GUI API*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成图像查看器布局，我们需要查看主图像视图。Fyne中图像的默认行为是它们将扩展以填充可用空间（这是`canvas.ImageFillStretch`模式）。然而，我们希望图像保持其宽高比，同时保持在查看区域范围内。我们还将添加一个背景图案，就像在[第8章](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)的Shiny示例中做的那样，*Shiny
    – 实验性Go GUI API*。
- en: Firstly, we create a new image for the background pattern. Fyne provides a helper
    method to create an image that's drawn dynamically called `canvas.NewRasterWithPixels()`.
    It takes a single parameter, which is the pixel calculation function that returns `color.Color`
    for the pixel requested. Its parameters are `x, y, width, height` (all `int` variables).
    This means that we can use just the `x` and `y` coordinates, or we can perform
    calculations based on the width and height values (that specify the number of
    pixels on each axis).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为背景图案创建一个新的图像。Fyne提供了一个名为`canvas.NewRasterWithPixels()`的辅助方法，用于创建一个动态绘制的图像。它接受一个参数，即返回请求像素的`color.Color`值的像素计算函数。其参数是`x,
    y, width, height`（所有`int`变量）。这意味着我们可以仅使用`x`和`y`坐标，或者我们可以根据宽度和高度值（指定每个轴上的像素数）进行计算。
- en: 'In our checker pattern implementation, we simply return a light or dark gray
    color to make a pattern of squares. The blocks are 10 x 10 pixels in size and
    we calculate which square a pixel coordinate is within, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的检查器图案实现中，我们简单地返回浅灰色或深灰色以形成正方形图案。这些块的大小为10 x 10像素，我们计算像素坐标位于哪个正方形内，如下所示：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The checker pattern image is created by passing our `checkerColor` function
    to the `canvas.NewRasterWithPixels()` function. This variable can now be used
    like any other `canvas.Image` type:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 检查器图案图像是通过将我们的`checkerColor`函数传递给`canvas.NewRasterWithPixels()`函数创建的。现在，这个变量可以像任何其他`canvas.Image`类型一样使用：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Additionally, the main image view should be set to maintain its aspect ratio
    within the available space. To do so, we set the `FillMode` field of the `image` variable
    to `canvas.ImageFillContain`. Like the CSS3 definition, this will center the image
    at the largest scaled size that fits within the space:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，主图像视图应设置为在可用空间内保持其宽高比。为此，我们将`image`变量的`FillMode`字段设置为`canvas.ImageFillContain`。类似于CSS3定义，这将使图像在空间内以最大缩放尺寸居中：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, the checker pattern image is added to our layout. By passing it before
    the main image object, we specify that it is layered lower in the draw order,
    and therefore set as a background. Notice that any item not listed as specifically
    positioned in a border position is sized to fill the remaining space. In this
    way, our image view is drawn above the background and both are set to fill the
    space inside our border widgets:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将检查器图案图像添加到我们的布局中。通过将其传递到主图像对象之前，我们指定它在绘制顺序中位于较低层，因此被设置为背景。请注意，任何未明确指定在边框位置中的项目都将调整大小以填充剩余空间。这样，我们的图像视图就在背景之上绘制，并且两者都被设置为填充边框小部件内的空间：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Updating the code with these changes results in the completed image viewer
    layout, which should look like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些更改更新代码将产生完成的图像查看器布局，其外观应如下所示：
- en: '![](img/3f44ffd6-b5b6-4252-bdca-2076819ba71b.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f44ffd6-b5b6-4252-bdca-2076819ba71b.png)'
- en: Centering the image over a checkerboard pattern
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在棋盘图案上居中图像
- en: Communicating with the GUI
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GUI进行通信
- en: To add the code that handles updating the GUI and responding to user events,
    we will need to save references to some widgets that have been created; mainly
    the `widget.Label` toolbar and the main view, `canvas.Image`. By storing these
    references, we can update their content later.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加处理GUI更新和响应用户事件的代码，我们需要保存对已创建的一些小部件的引用；主要是`widget.Label`工具栏和主视图`canvas.Image`。通过存储这些引用，我们可以在以后更新它们的内容。
- en: 'Additionally, we will add a `[]string` to list `images` for the directory we
    are accessing and save `int` `index` of the current image so that we can calculate
    the previous and the next. Once those are created, we can fill in the content
    of our `previousImage()` and `nextImage()` functions to call a new `chooseImage()`
    function that will update the display:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在访问的目录中添加一个 `[]string` 列表 `images`，并保存当前图像的 `int` `index`，以便我们可以计算上一个和下一个。一旦这些创建完成，我们就可以填写
    `previousImage()` 和 `nextImage()` 函数的内容，以调用一个新的 `chooseImage()` 函数来更新显示：
- en: '[PRE28]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `chooseImage()` function accesses the file path from the image list that
    will be loaded later and uses this information to update our user interface. From
    `path`, we call `label.SetText()` to show the filename and then set `image.File` to
    update the path for the main image display:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`chooseImage()` 函数从稍后将要加载的图像列表中访问文件路径，并使用这些信息来更新我们的用户界面。从 `path`，我们调用 `label.SetText()`
    来显示文件名，然后设置 `image.File` 以更新主图像显示的路径：'
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To most easily implement the click handling behavior in order to choose an
    image from the list, we will change from `widget.Label` to `widget.Button` items.
    As the buttons have a different color background, we should tidy up the display
    by using `layout.BorderLayout` so that the buttons fill the available space. Finally,
    because buttons are taller than labels, we update the `minSize()` preview code
    to be relative to the button''s minimum height rather than the previous inline
    icon size defined by the theme:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最简单地实现点击处理行为以从列表中选择图像，我们将从 `widget.Label` 更改为 `widget.Button` 项目。由于按钮具有不同的颜色背景，我们应该使用
    `layout.BorderLayout` 来整理显示，以便按钮填充可用空间。最后，因为按钮比标签高，我们更新 `minSize()` 预览代码，使其相对于按钮的最小高度，而不是之前由主题定义的行内图标大小：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to add a `getImageList()` function that will access the list
    of images in a directory. The contents of this function are identical to the same
    function in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml), *Shiny –
    Experimental Go GUI API*, so it is omitted here for brevity. With that in place,
    we can update our `makeList()` function, which now takes a `dir` parameter, to
    load the image file list and create the new rows using `makeRow()`, as well as
    populating our stored `images` list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一个 `getImageList()` 函数，该函数将访问目录中的图像列表。此函数的内容与第 8 章[Shiny – Experimental
    Go GUI API](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml) 中相同的函数相同，因此为了简洁起见在此省略。有了这个，我们可以更新我们的
    `makeList()` 函数，它现在接受一个 `dir` 参数，以加载图像文件列表并使用 `makeRow()` 创建新行，以及填充我们存储的 `images`
    列表：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then update the creation of the `fileList` in `main()` function to pass
    a directory path to load:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新 `main()` 函数中 `fileList` 的创建，以传递要加载的目录路径：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As with the previous GoImages code, we can use the built-in `flag` handling
    to allow users to specify the directory to display. The code is listed here and
    we can invoke it simply by setting the preceding `dirpath` variable to the result
    of `parseArgs()` (if you add this code, remember to import the `flag`, `fmt`,
    and `os` packages):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 GoImages 代码一样，我们可以使用内置的 `flag` 处理来允许用户指定要显示的目录。代码在此列出，我们可以通过将前面的 `dirpath`
    变量设置为 `parseArgs()` 的结果来调用它（如果您添加此代码，请记住导入 `flag`、`fmt` 和 `os` 包）：
- en: '[PRE33]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Updating all of the preceding code should result in our complete image viewer
    application. If you''d prefer to access the complete code, this can be downloaded
    from this book''s source code repository on GitHub:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 更新所有前面的代码应该会导致我们的完整图像查看器应用程序。如果您想访问完整的代码，可以从本书的源代码仓库在 GitHub 上下载：
- en: '![](img/7d1157ad-a07c-4919-a039-7f1a8d88e503.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d1157ad-a07c-4919-a039-7f1a8d88e503.png)'
- en: Our completed image viewer showing a wallpaper directory
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的图像查看器显示了壁纸目录
- en: 'As with the previous GoMail example, we can load this interface using the light
    theme by specifying `FYNE_THEME=light` in the command-line environment:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 GoMail 示例一样，我们可以通过在命令行环境中指定 `FYNE_THEME=light` 来使用浅色主题加载此界面：
- en: '![](img/b5a2c58a-2b81-4e69-af86-aa614a2a8c61.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a2c58a-2b81-4e69-af86-aa614a2a8c61.png)'
- en: The same app and directory with the Fyne light theme
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 Fyne 浅色主题的相同应用程序和目录
- en: Background processing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景处理
- en: With Fyne a lot of image handling is already processing on multiple threads,
    but that may not be enough for image-intensive applications. In this GoImages
    app, there are many images being loaded before the user interface is displayed.
    We can update the image handling to allow the GUI to display faster. To do so,
    we once again create a new `asyncImage` type, that loads the image on a background
    thread before displaying it. Whereas Shiny was passing the images directly to
    the rendering, here, we are providing them to a `canvas.Image` object, so the
    code is slightly different.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fyne 时，许多图像处理已经在多个线程上进行了处理，但这可能对于图像密集型应用来说还不够。在这个 GoImages 应用中，在用户界面显示之前，有大量图像正在被加载。我们可以更新图像处理，以便让
    GUI 显示得更快。为此，我们再次创建一个新的 `asyncImage` 类型，在显示之前在后台线程上加载图像。与 Shiny 直接将图像传递给渲染器不同，在这里，我们向
    `canvas.Image` 对象提供它们，因此代码略有不同。
- en: 'We start by creating the basic `asyncImage` type—its main work is in the `load()`
    function, which will run on a background thread. The `loadPath()` function sets
    up the path to the file to be loaded and starts the background processing. Notice
    that once we''ve changed the image data, we need to call `canvas.Refresh()` to
    ensure the interface updates—there is no need for any thread-handling code, since
    Fyne will deal with that for us:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建基本的 `asyncImage` 类型——其主要工作在 `load()` 函数中，该函数将在后台线程上运行。`loadPath()` 函数设置要加载的文件的路径并开始后台处理。请注意，一旦我们更改了图像数据，我们需要调用
    `canvas.Refresh()` 来确保界面更新——由于 Fyne 会为我们处理，因此不需要任何线程处理代码：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As this async image loader will be providing raw image data to the image widget,
    we also need to implement the `image.Image` API. In each of the methods, we check
    to see whether the `pixels` variable has been set (it will be `nil` until the
    image is loaded), returning the appropriate value or a sensible fallback:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个异步图像加载器将提供原始图像数据给图像小部件，我们还需要实现 `image.Image` API。在每个方法中，我们检查 `pixels` 变量是否已设置（在图像加载之前将是
    `nil`），返回适当的值或合理的回退：
- en: '[PRE35]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lastly, our `asyncImage` type would benefit from a convenience constructor
    to set up the `image` widget that will render. We also begin the loading of the
    first image file, `path`, on a background thread:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的 `asyncImage` 类型将受益于一个便利的构造函数来设置将要渲染的 `image` 小部件。我们还开始在后台线程上加载第一个图像文件，`path`：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To complete the use of our asynchronous image loader, we update the `chooseImage()`
    function to set the new path. With this change, the application will be loading
    all images on a background thread instead of on the main loop. Go will distribute
    this across our processors appropriately to make use of the available CPU:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成异步图像加载器的使用，我们更新了 `chooseImage()` 函数以设置新的路径。通过这个更改，应用程序将在后台线程上加载所有图像，而不是在主循环上。Go
    将适当地分布到我们的处理器上，以利用可用的 CPU：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Running this new version of the application will load noticeably faster. You'll
    also see the images appear as the loading of each file is completed. By using
    the simple `canvas.Refresh()` call after we load each image, we ensure that the
    user interface updates appropriately.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新版本的应用程序将加载得更快。你也会看到，随着每个文件的加载完成，图像将出现。通过在加载每个图像后使用简单的 `canvas.Refresh()`
    调用，我们确保用户界面适当地更新。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the last of the toolkits to be explored in this
    book, Fyne. We learned how it was created specifically for Go so as to make it
    simple to build graphical applications. We quickly got set up with the toolkit
    and explored how to build applications that will run identically on macOS, Windows,
    and Linux.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了本书要探索的最后一种工具包，Fyne。我们学习了它是如何专门为 Go 创建的，以便于构建图形应用程序。我们很快设置了工具包，并探讨了如何构建在
    macOS、Windows 和 Linux 上运行完全相同的应用程序。
- en: We looked at the architecture of the Fyne toolkit and its use of vector graphics
    to provide scalable graphical interfaces. By learning the features of the `layout`,
    `canvas`, and `widget` packages, we saw how to quickly build basic user interfaces.
    We also saw how Fyne provides two different themes, *light* and *dark*, which
    will be used based on user settings or environment variables.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了 Fyne 工具包的架构及其使用矢量图形提供可伸缩的图形界面。通过学习 `layout`、`canvas` 和 `widget` 包的功能，我们看到了如何快速构建基本用户界面。我们还看到了
    Fyne 提供的两个不同的主题，*浅色* 和 *深色*，它们将根据用户设置或环境变量来使用。
- en: Applying this knowledge, we built the sixth version of our GoMail application,
    which included built-in material design icons and avoided any thread-handling
    complexities. We also explored the image APIs and background processing capabilities
    by re-building the GoImages application designed in [Chapter 8](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml),
    *Shiny – Experimental Go GUI API*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这一知识，我们构建了GoMail应用的第六版，其中包含了内置的材料设计图标，并避免了任何线程处理复杂性。我们还通过重新构建第8章中设计的GoImages应用，即[“Shiny
    – 实验性Go GUI API”](9e373c53-f82e-4bf2-ba31-7a59c22d9791.xhtml)，探索了图像API和后台处理能力。
- en: Now that we've explored the main toolkits available, we will move to [Section
    4](935a315b-9890-4c6a-a126-3dda28108886.xhtml), *Growing and Distributing Your
    Application**.* In the final part of this book, we change focus to topics that
    apply to all graphical applications, regardless of the toolkit used. We will explore
    topics that help polish and distribute complete graphical user interfaces*,* starting
    with [Chapter 11](03c04362-6937-47f3-a2de-cd99d9ae9080.xhtml), *Navigation and
    Multiple Windows.*
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了可用的主要工具包，我们将转向[第4节](935a315b-9890-4c6a-a126-3dda28108886.xhtml)，*“增长和分发您的应用”*。在这本书的最后部分，我们将关注所有图形应用都适用的主题，无论使用哪种工具包。我们将探讨有助于润色和分发完整图形用户界面的主题，*从第11章开始*，*“导航和多窗口”。
