- en: Concurrency, Networking, and Cloud Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发、网络和云服务
- en: So far, we've been focusing on designing and building the graphical elements
    of applications. Most modern software isn't complete without a solid connection
    to internet services and networking features. Adding dependencies to remote services
    could affect the stability of an application if it isn't correctly managed. Concurrency
    is also a key part of managing an interaction with remote services; we'll need
    to add more advanced task handling to manage these various communication channels.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于设计和构建应用程序的图形元素。大多数现代软件如果没有与互联网服务和网络功能稳固的连接就不完整。如果未正确管理，向远程服务添加依赖项可能会影响应用程序的稳定性。并发也是管理与远程服务交互的关键部分；我们需要添加更高级的任务处理来管理这些不同的通信渠道。
- en: 'In this chapter, we''ll explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Thread handling and managing the user interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程处理和管理用户界面
- en: Including remote resources in your application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序中包含远程资源
- en: Connecting to cloud services and handling error cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到云服务并处理错误情况
- en: Maintaining user experience when the network disconnects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络断开时维护用户体验
- en: By the end of this chapter, you should be able to integrate remote resources
    and cloud services into your application. You'll also see how to maintain a responsive
    user interface despite this new functionality relying on network connections that
    may be unreliable or unavailable. The addition of long-running background processes
    and the communication challenges they can cause will be completely solved as your
    application is updated to manage data from a multitude of sources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够将远程资源和云服务集成到你的应用程序中。你还将看到如何维护响应式用户界面，尽管这种新功能依赖于可能不可靠或不稳定的网络连接。随着应用程序更新以管理来自多个来源的数据，长时间运行的后台过程和它们可能引起的通信挑战将完全解决。
- en: Concurrency, threads, and GUI updates
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发、线程和GUI更新
- en: Goroutines are a very powerful tool for running concurrent operations and background
    tasks, especially if they're short-running. As we move more application logic
    and data handling to background processes, we need to add appropriate safeguards
    to ensure that errors are handled and that the user interface is kept up to date.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines是运行并发操作和后台任务的非常强大的工具，尤其是如果它们是短运行的。随着我们将更多的应用程序逻辑和数据处理移到后台进程，我们需要添加适当的保障措施来确保错误得到处理，并且用户界面保持最新。
- en: Managing long-running processes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理长时间运行的过程
- en: A goroutine is typically created so that code flow continues while another task
    completes in the background. If these tasks start to be used for application-critical
    tasks or to handle important data, especially if these tasks could take a long
    time, we need to manage them more carefully. The main consideration is how to
    shut down background tasks gracefully if the application exits. This may not seem
    essential, and for some tasks it may not be, but if the process is involved in
    data integrity, we want to be certain that early termination doesn't cause problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常创建goroutine是为了在后台任务完成的同时继续代码流程。如果这些任务开始用于应用程序关键任务或处理重要数据，尤其是如果这些任务可能需要很长时间，我们需要更仔细地管理它们。主要考虑的是如何在应用程序退出时优雅地关闭后台任务。这可能看起来不是必需的，对于某些任务可能确实不是，但如果过程涉及数据完整性，我们希望确保提前终止不会引起问题。
- en: Signaling shutdown
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号关闭
- en: 'To demonstrate the problem, let''s start with a simple goroutine demo; we''ll
    launch three threads that print progress. For each thread, we''ll print `Started` followed
    by `.` until the thread stops, at which point `Ended` will be printed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，让我们从一个简单的goroutine演示开始；我们将启动三个线程来打印进度。对于每个线程，我们将打印`Started`然后是`.`，直到线程停止，此时将打印`Ended`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run this code, you''ll see the following output. The threads start and
    tick as expected and, after a `5` second timeout, the program exits. No `Ended` messages
    are seen:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你将看到以下输出。线程按预期启动并计时，在`5`秒超时后，程序退出。没有看到`Ended`消息：
- en: '![](img/ac958baf-0554-4a72-910b-2c719f22641c.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac958baf-0554-4a72-910b-2c719f22641c.png)'
- en: The output of unterminated goroutines
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 未终止goroutine的输出
- en: As you can see from this simple demo, the goroutines aren't gracefully terminated;
    they simply stop running. If we're writing complex data, sending a message to
    a remote server, or waiting for an important response, this would probably result
    in data corruption or other unexpected results. Let's look at how to signal goroutines
    to stop when our application terminates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从这个简单的演示中看到的，goroutines并没有优雅地终止；它们只是停止运行。如果我们正在编写复杂的数据，向远程服务器发送消息，或等待重要响应，这可能会导致数据损坏或其他意外结果。让我们看看如何在应用程序终止时如何向goroutines发出停止信号。
- en: 'We start by creating a simple channel called `stop` that''s passed into each
    goroutine. When the application is ready to exit, we''ll signal each thread so
    it can finish its work by closing this channel. We update the tick function to
    check whether this new channel is closed and if so, it''ll exit. To allow the
    code to complete before the application exits, we must add a new pause at the
    end of `main()` for the cleanup. The updated code looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个简单的名为`stop`的通道，并将其传递给每个goroutine。当应用程序准备退出时，我们将向每个线程发出信号，以便它们可以通过关闭此通道来完成工作。我们更新tick函数以检查这个新通道是否已关闭，如果是，它将退出。为了在应用程序退出之前允许代码完成，我们必须在`main()`的末尾添加一个新的暂停，以便进行清理。更新的代码如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running this should display the following output, which is what we were looking
    for in the first place:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码应显示以下输出，这正是我们最初所寻找的：
- en: '![](img/bfd5e764-bd47-4678-8427-e92fbb82982b.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bfd5e764-bd47-4678-8427-e92fbb82982b.png)'
- en: With a signal channel, our threads can end just before the program exits
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信号通道，我们的线程可以在程序退出前结束
- en: Checking completion
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查完成情况
- en: The preceding example technically works, but depending on a timer to wait for
    threads to complete isn't reliable. If the threads need to wait for a response
    or are part way through a long calculation, we'll still have potential corruption
    if the timer elapses. The solution is to have the goroutine signal once the cleanup
    is complete. This can be done with `sync.WaitGroup` or by using another channel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例在技术上可行，但依赖于定时器等待线程完成并不可靠。如果线程需要等待响应或正在进行长时间的计算，如果定时器超时，我们仍然有可能出现数据损坏。解决方案是在清理完成后让goroutine发出信号。这可以通过`sync.WaitGroup`或使用另一个通道来实现。
- en: For our completed thread example, we create `sync.WaitGroup`, which is passed
    to each of the tick threads. Before we start the goroutine, we increment the number
    of threads to wait on using `wg.Add(1)`. Once each thread is complete, they mark
    that using `wg.Done()`. Our application is then free to call `wg.Wait()` immediately
    before exiting, safe in the knowledge that it won't prematurely terminate any
    of the grouped background processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的完成线程示例，我们创建`sync.WaitGroup`，并将其传递给每个tick线程。在我们启动goroutine之前，我们使用`wg.Add(1)`增加等待线程的数量。一旦每个线程完成，它们就会使用`wg.Done()`标记。然后，我们的应用程序可以自由地立即在退出前调用`wg.Wait()`，安全地知道它不会提前终止任何分组的后台进程。
- en: 'The following code demonstrates signaling and waiting for multiple goroutines:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何向多个goroutines发出信号和等待：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of this is almost exactly the same as the previous version, but
    the specific timing of the threads ending is slightly different:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出几乎与上一个版本完全相同，但线程结束的具体时间略有不同：
- en: '![](img/e175e59c-936b-44f5-81bb-b10881ddff2c.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e175e59c-936b-44f5-81bb-b10881ddff2c.png)'
- en: Waiting for our goroutines to complete instead of waiting a set time
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 等待goroutines完成而不是等待固定的时间
- en: Communicating through channels
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过通道进行通信
- en: As we've seen in earlier chapters, goroutines offer powerful but simple concurrent
    operation. Most of these examples have been generating output or responding to
    user requests, but long running processes are often generating data that needs
    to be utilized by the application. In this example, we see how a channel can be
    used to effectively gather data from multiple threads to aggregate and report.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，goroutines提供了强大而简单的并发操作。大多数这些示例都是生成输出或响应用户请求，但长时间运行的过程通常会产生需要由应用程序利用的数据。在这个例子中，我们看到如何使用通道有效地从多个线程收集数据以聚合和报告。
- en: 'Our example is a simple tool that''ll get the disk usage of a directory. For
    each element within this directory, we''ll start a goroutine (`dirSize()`) that''ll
    calculate the space used by the directory and the files it contains. This function
    returns the result through a channel so the application can use the information
    once it''s available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例是一个简单的工具，可以获取目录的磁盘使用情况。对于这个目录内的每个元素，我们将启动一个goroutine（`dirSize()`），它会计算目录及其包含的文件使用的空间。这个函数通过通道返回结果，这样应用程序就可以在信息可用时使用它：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Within the `reportUsage()` function, we start as many goroutines as there are
    files reported in the specified directory. The code then prints the usage result
    from each goroutine when it completes using `for info := range result`, and then
    terminates when every result is returned (`if results == len(files) {break}`),
    adding a simple total before we exit:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reportUsage()`函数中，我们为指定目录中报告的每个文件启动尽可能多的goroutine。然后代码在goroutine完成时打印使用结果，使用`for
    info := range result`，并在每个结果返回时终止（`if results == len(files) {break}`），在我们退出之前添加一个简单的总数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, we add a `main()` function that simply parses arguments to initialize
    the `reportUsage()` function. If no argument is specified, we''ll report for the
    current directory reported by `os.Getwd()`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个`main()`函数，它简单地解析参数以初始化`reportUsage()`函数。如果没有指定参数，我们将为`os.Getwd()`报告的当前目录报告：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this example may return immediately, but if you invoke it on a large
    directory, it may take some time to complete. By doing this, you can see that
    each printed appears as soon as the related goroutine completes, and the total
    is always last to appear. The preceding listing doesn''t include some boilerplate
    number formatting seen in the resulting screenshot (that can be found in this
    book''s code repository):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例可能立即返回，但如果你在大型目录上调用它，可能需要一些时间才能完成。通过这样做，你可以看到每个打印的输出都会在相关的goroutine完成时立即出现，而总数总是最后出现。前面的列表中没有包括在结果截图（可在本书的代码库中找到）中看到的一些样板数字格式化：
- en: '![](img/12a868a5-a3bd-4202-8373-f3bc1ad82f47.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/12a868a5-a3bd-4202-8373-f3bc1ad82f47.png)'
- en: Reporting the usage of a directory; typically smaller items appear first as
    they're faster to calculate
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 报告目录的使用情况；通常较小的项目先出现，因为它们计算得更快
- en: Graphical updates from goroutines
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自goroutine的图形更新
- en: Communicating with the graphical interface (in most frameworks) means managing
    threads correctly. In the preceding example, we could have updated a GUI within
    the `dirSize()` method, adding a row to a table, for instance. In theory, that
    would have avoided the need for a channel and the struct that we passed back to
    the `reportUsage()` function. However, changing threads is a (relatively) slow
    process depending on other application activities, and moreover we should try
    to separate our logic and processing from the user interface code. Doing so will
    make it easier to reuse code later and possibly to change toolkit if our requirements
    change.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与图形界面（在大多数框架中）通信意味着正确管理线程。在先前的示例中，我们可以在`dirSize()`方法中更新GUI，例如添加一行到表格中。从理论上讲，这样就可以避免需要通道和传递回`reportUsage()`函数的结构。然而，更改线程是一个（相对）缓慢的过程，这取决于其他应用程序活动，而且我们应尝试将我们的逻辑和数据处理与用户界面代码分离。这样做将使以后重用代码更容易，并且如果我们的需求发生变化，还可能更容易更改工具包。
- en: 'Our design to handle most of the user interaction in a single function means
    that our actual directory usage code is completely separate from our user interface.
    Let''s update the preceding example to generate a graphical output instead. We''ll
    use Go-GTK this time, as its thread handling is quite explicit:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计是将大部分用户交互处理在一个单独的函数中，这意味着我们的实际目录使用代码与用户界面完全分离。让我们更新前面的示例，以生成图形输出。这次我们将使用Go-GTK，因为它的线程处理非常明确：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that our replacement usage reporting method has two instances of `gdk.ThreadsEnter()`
    and `gdk.ThreadsLeave()`; each time we update the user interface, we must switch
    to the `gdk` main thread. As in previous Go-GTK examples, we need to also update
    the main method to correctly initialize thread handling:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的替代使用报告方法有两个`gdk.ThreadsEnter()`和`gdk.ThreadsLeave()`实例；每次我们更新用户界面时，我们必须切换到`gdk`主线程。正如之前的Go-GTK示例中那样，我们还需要更新主方法以正确初始化线程处理：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The full user interface creation is omitted from this chapter for brevity,
    but can be found in this book''s source code (in `chapter12/goroutines/gtkdiskusage.go`).
    It''s a requirement of most graphical toolkits that background processes switch
    to the main or graphics thread when updating the user interface. Some, such as
    Fyne, don''t have this requirement, which you can see in an alternative version
    of the example (also available in this book''s code repository at `chapter12/goroutines/fynediskusage.go`).
    Instead of wrapping GUI calls in thread handling code, we simply call `list.Append()`
    or `label.SetText()` from the background code and the interface will update accordingly:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，本章省略了完整的用户界面创建，但可以在本书的源代码中找到（在`chapter12/goroutines/gtkdiskusage.go`中）。大多数图形工具包都要求后台进程在更新用户界面时切换到主线程或图形线程。一些，如Fyne，没有这个要求，您可以在示例的替代版本中看到这一点（本书的代码库中也可用，在`chapter12/goroutines/fynediskusage.go`）。我们不是在线程处理代码中包装GUI调用，而是简单地从后台代码调用`list.Append()`或`label.SetText()`，界面将相应更新：
- en: '![](img/ef0f0cb4-f2c7-4110-ae17-c9b403eda9ea.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef0f0cb4-f2c7-4110-ae17-c9b403eda9ea.png)'
- en: A GTK interface for the disk usage example
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 用于磁盘使用示例的GTK界面
- en: '![](img/e66deffd-88fc-40a2-b83f-26083d0e1f1a.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e66deffd-88fc-40a2-b83f-26083d0e1f1a.png)'
- en: The same disk usage example using Fyne
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Fyne的相同磁盘使用示例
- en: Network resources and caching
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络资源和缓存
- en: 'Accessing remote resources, on a local network or from a server across the
    internet, is likely to play a part in most applications. Unfortunately, it''s
    also the source of a significant number of potential issues: slow responses, unexpected
    data, or no data at all. Let''s look at some ways we can work to create a robust
    application even when we need to use the network and integrate cloud services.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 访问远程资源，无论是在本地网络中还是在互联网上的服务器上，在大多数应用程序中都可能扮演一定的角色。不幸的是，这也可能是许多潜在问题的来源：响应缓慢、数据意外或根本没有数据。让我们看看一些我们可以采取的方法，即使在需要使用网络和集成云服务的情况下，也能创建一个健壮的应用程序。
- en: Loading remote resources
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载远程资源
- en: Accessing resources in Go is normally through a byte stream, either locally
    (for embedded resources or file system access) or remotely (for HTTP requests
    and data from a remote server). As the method for reading local and remote data
    is similar, we can load remote resources in most of the places where local or
    embedded assets have been used.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中访问资源通常是通过字节流进行的，无论是本地（用于嵌入式资源或文件系统访问）还是远程（用于HTTP请求和远程服务器上的数据）。由于读取本地和远程数据的方法相似，我们可以在大多数使用本地或嵌入式资源的地方加载远程资源。
- en: Images
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像
- en: 'Following the stream-based design, the Go `image` package decodes images from
    a stream. By connecting to a remote stream and reading the bytes from the request,
    we can easily render an image from a web server. The following code uses the Fyne `canvas.NewImageFromImage()` function
    to render a Go decoded image, which we''ve loaded from the [https://golang.org/doc/gopher/frontpage.png](https://golang.org/doc/gopher/frontpage.png) URL
    using `image.Decode()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循基于流的架构，Go的`image`包可以从流中解码图像。通过连接到远程流并从请求中读取字节，我们可以轻松地从Web服务器渲染图像。以下代码使用Fyne的`canvas.NewImageFromImage()`函数来渲染从[https://golang.org/doc/gopher/frontpage.png](https://golang.org/doc/gopher/frontpage.png)
    URL使用`image.Decode()`加载的Go解码图像：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you would expect, this application opens a single window with the image
    loaded as its content:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，此应用程序打开一个窗口，其中包含加载的图像作为其内容：
- en: '![](img/71afb2b1-5e52-4d3a-a18d-96c1d4b2ddaa.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71afb2b1-5e52-4d3a-a18d-96c1d4b2ddaa.png)'
- en: Loading a file from the internet
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网上加载文件
- en: But this only works appropriately when the internet connection is behaving correctly
    and, even then, may take longer than the user expects to load. Before we look
    at strategies to improve this, let's see how to do the same for data downloaded
    from a web service.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仅在互联网连接表现正常时才适用，即使如此，也可能比用户预期的加载时间更长。在我们探讨改进策略之前，让我们看看如何从Web服务下载的数据执行相同的操作。
- en: JSON
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: 'To explore how to work with remote data from a web service, we shall start
    by adapting our web service example from [Chapter 3](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml),
    *Go to the Rescue!*. The code is slimmed down and updated to use the same `readStream()`
    function as created for the preceding image example. The resulting code is very
    basic but demonstrates how easily we can decode JSON data into a struct using
    built-in Go features:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索如何与来自网络服务的远程数据一起工作，我们将从[第3章](62fca679-0393-4bcf-a94d-dbfd9b862f9d.xhtml)的示例开始，*Go
    to the Rescue!*。代码被精简并更新，以使用为前面的图片示例创建的相同`readStream()`函数。生成的代码非常基础，但展示了我们可以如何轻松地使用内置的Go功能将JSON数据解码到结构体中：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using a single method for our resource loading enables us to put more robust
    error handling in a central place. Until we''ve made those improvements, our application
    will crash if the request fails (no internet or server error, for example):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一方法来加载我们的资源使我们能够在一个中央位置放置更健壮的错误处理。在我们做出这些改进之前，如果请求失败（例如没有互联网或服务器错误），我们的应用程序将会崩溃：
- en: '![](img/cfaf7f47-d26d-4367-a7f4-e1006dcd73ee.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfaf7f47-d26d-4367-a7f4-e1006dcd73ee.png)'
- en: Image failure when there's no network connection
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 没有网络连接时的图片加载失败
- en: '![](img/3492757b-c8aa-40d4-a532-694465b75930.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3492757b-c8aa-40d4-a532-694465b75930.png)'
- en: JSON can't be accessed when offline either
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 离线时也无法访问JSON
- en: While these errors could be handled better, we would still have downloaded no
    content. An image not loading may not matter, situations when the connection but
    missing JSON data would probably reduce the functionality of our application.
    What we should aim for is to better handle situations where the connection isn't
    present or isn't responding correctly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些错误可以得到更好的处理，但我们仍然没有下载任何内容。图片加载失败可能无关紧要，但连接存在但缺少JSON数据的情况可能会降低我们应用程序的功能。我们应该努力改善连接不存在或响应不正确的情况。
- en: Caching resource data
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存资源数据
- en: Our first approach to providing a better experience when an internet connection
    is slow or unreliable is to implement a caching mechanism for our remote resources.
    With this in place, a single online run of the application would be sufficient
    to defend against connectivity problems as it'll populate the cache data. The
    bonus is that, on repeated runs of the application, it'll be much faster to load
    these resources.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络连接缓慢或不稳定时，我们提供更好体验的第一种方法是为我们的远程资源实现缓存机制。这样一来，应用程序的一次在线运行就足以防御连接问题，因为它会填充缓存数据。额外的好处是，在应用程序的重复运行中，加载这些资源会更快。
- en: 'Building on the previous image example, we implement a new function, `cacheStream()`,
    which we''ll call instead of `readStream()`. A helper function called `cacheFileName()`
    establishes a file location to use for the cache based on a `url` parameter. Every
    time we request a URL using this function, it''ll attempt to load a cached copy
    from that location; if it''s present, then `io.ReadCloser` to this location will
    be returned directly. If the cache file isn''t present, then we use the original
    `readStream()` function to download the content into the cache file and then return
    a stream to the cache file as before:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图片示例的基础上，我们实现了一个新的函数，`cacheStream()`，我们将用它来代替`readStream()`。一个名为`cacheFileName()`的辅助函数根据`url`参数确定用于缓存的文件位置。每次我们使用此函数请求URL时，它都会尝试从该位置加载缓存的副本；如果存在，则直接返回该位置的`io.ReadCloser`。如果缓存文件不存在，则我们使用原始的`readStream()`函数将内容下载到缓存文件中，然后像以前一样返回缓存文件的流：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This implementation is just an illustration of how this can be done; if it were
    to be used in a production application, you would need to use a better cache location and
    handle potential thread issues.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现只是说明了如何做到这一点；如果要在生产应用程序中使用，你需要使用更好的缓存位置并处理潜在的线程问题。
- en: In the 1.11 release of Go, there's a new `os.UserCacheDir()` function. However,
    it's often wise to wait for a while before relying on new functionality as not
    everyone will have upgraded yet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go 1.11版本中，有一个新的`os.UserCacheDir()`函数。然而，在依赖新功能之前等待一段时间通常是明智的，因为并非所有人都会升级。
- en: 'The benefit of the stream-based approach is that we can use it for assets other
    than images. Just like the image example, we can update our JSON code to use `cacheStream()`
    instead of `readStream()`, and our data will be downloaded once and then read
    from the local file by the cache code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 基于流的这种方法的优点是，我们可以用它来处理除了图片之外的资产。就像图片示例一样，我们可以更新我们的JSON代码，用`cacheStream()`代替`readStream()`，然后我们的数据将下载一次，然后由缓存代码从本地文件读取：
- en: '![](img/fa2ff163-efdf-4517-86fe-0d3f225667ec.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa2ff163-efdf-4517-86fe-0d3f225667ec.png)'
- en: Caching our remote image means better resilience of the application
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存远程图像意味着应用程序具有更好的弹性
- en: '![](img/47120207-bee3-4bde-b4f4-105e0f218f53.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47120207-bee3-4bde-b4f4-105e0f218f53.png)'
- en: By caching the JSON, our application can function if the network fails
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过缓存 JSON，即使网络失败，我们的应用程序也能正常运行
- en: These examples should help to work with remote resources in your application,
    but are relatively simple examples. How do we work with more complicated cloud
    services?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例应该有助于在您的应用程序中处理远程资源，但它们相对简单。我们如何处理更复杂的云服务？
- en: Connecting to cloud services
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到云服务
- en: There are many frameworks and libraries available that aim to help you to work
    with cloud services in Go. However, if you ask the Go community which is best,
    they'll probably suggest that you stick with the built-in packages. Doing so may
    seem strange for anyone coming from C or Java (or many other languages created
    before internet connected applications became commonplace), but the standard library
    for Go is very capable. We'll explore here how to work with the provided tools
    and add cloud service-based functionality to our code without additional dependencies.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多框架和库旨在帮助您在 Go 中使用云服务。然而，如果您询问 Go 社区哪个最好，他们可能会建议您坚持使用内置包。对于来自 C 或 Java（或许多在互联网连接应用程序变得普遍之前创建的语言）的人来说，这样做可能看起来很奇怪，但
    Go 的标准库非常强大。我们将探讨如何使用提供的工具，并在不添加额外依赖项的情况下将基于云服务的功能添加到我们的代码中。
- en: Encoding
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码
- en: To start looking at this, we'll return to the `EmailMessage` model defined in
    the `client` package at [https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/tree/master/client](https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/tree/master/client),
    which was imported in previous chapters. By adding simple hints to this object,
    we can correctly serialize and deserialize in both JSON and XML formats with ease.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始查看这个，我们将回到在 `client` 包中定义的 `EmailMessage` 模型，该模型在之前的章节中已导入。[https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/tree/master/client](https://github.com/PacktPublishing/Hands-On-GUI-Application-Development-in-Go/tree/master/client)。通过向此对象添加简单的提示，我们可以轻松地在
    JSON 和 XML 格式之间进行序列化和反序列化。
- en: JSON
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: 'As the convention in JSON is for map keys to be in lowercase, we add hints
    to our struct of the `` `json:"subject"` `` form that tell the `json` package
    how to handle the field names within the struct. The updated definition should
    look like the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JSON 中的约定是映射键为小写，我们在结构体中添加了 `json:"subject"` 形式的提示，告诉 `json` 包如何处理结构体内的字段名称。更新后的定义应如下代码所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To aid in testing, let''s also add a `String()` function to the definition
    for easier debugging later:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于测试，我们还在定义中添加了一个 `String()` 函数，以便稍后更容易进行调试：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once this is in place, we can add some code that demonstrates the usage. Firstly,
    let''s construct a new `EmailMessage` object and encode it to JSON. The encoding
    is very simple, and is illustrated as follows. We just create a new `json.Encoder` instance
    (that will output to the standard output), set the indent values (for improved
    readability), and ask it to encode our struct:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，我们就可以添加一些代码来演示其用法。首先，让我们构建一个新的 `EmailMessage` 对象并将其编码为 JSON。编码非常简单，如下所示。我们创建一个新的
    `json.Encoder` 实例（它将输出到标准输出），设置缩进值（以提高可读性），并要求它将我们的结构体编码：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Decoding a struct from JSON is also simple. We connect to a URL, open a stream
    using code from earlier in this chapter (the URL is omitted here for brevity),
    and defer the closing of the stream. Then, a new `json.Decoder` instance is created
    from this stream and we ask it to decode into the email struct. We''ll then output
    the data (using the preceding helpful `String()` function) to see the result:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSON 解码结构体也很简单。我们连接到一个 URL，使用本章前面（为了简洁省略了 URL）中的代码打开一个流，并延迟关闭该流。然后，从这个流中创建一个新的
    `json.Decoder` 实例，并要求它将数据解码到电子邮件结构体中。然后，我们将数据（使用前面的有用 `String()` 函数）输出以查看结果：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running all of that''ll result in some pretty easy-to-read output that shows
    we''ve successfully created, encoded, and then decoded JSON data for our struct:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有这些将产生一些非常易于阅读的输出，显示我们已经成功创建了、编码了，然后解码了结构体的 JSON 数据：
- en: '![](img/7554c724-fbfc-4a81-a2d7-c51f49da445a.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7554c724-fbfc-4a81-a2d7-c51f49da445a.png)'
- en: JSON data from a struct and from a WebService
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构体和 WebService 获取的 JSON 数据
- en: XML
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XML
- en: 'Working with XML is very similar to JSON. In fact, as XML and Go share the
    semantics of capitalizing their public variable names, there''s less mapping annotation
    required, so the struct only requires a single mapping tag:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与XML一起工作与JSON非常相似。事实上，由于XML和Go共享将公共变量名首字母大写的语义，所需的映射注解更少，因此结构体只需要一个映射标签：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Encoding and decoding are almost identical; obviously, we need to create `xml.Encoder`
    and `xml.Decoder` rather than the JSON counterparts. The only other difference
    is the method call to set the indenting (only required for pretty printing):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编码和解码几乎相同；显然，我们需要创建`xml.Encoder`和`xml.Decoder`而不是JSON的对应版本。唯一的另一个区别是设置缩进的方法调用（仅用于美化打印）：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And, we can use a web service to provide us with XML to decode (the URL is
    omitted here for brevity but can be found in this book''s source code repository):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用一个网络服务为我们提供XML进行解码（为了简洁，这里省略了URL，但可以在本书的源代码库中找到）：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Executing all of the preceding code will give a similar output to the JSON
    example but with a different format when encoded. Note also that the variable
    names start with uppercase letters, which is common in XML:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有前面的代码将给出与JSON示例相似的输出，但在编码时格式不同。注意，变量名以大写字母开头，这在XML中很常见：
- en: '![](img/a851fd81-508d-4ea3-85a5-8bfa32054e5d.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a851fd81-508d-4ea3-85a5-8bfa32054e5d.png)'
- en: XML data can just as easily be used when communicating with WebServices
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与Web服务通信时，同样可以轻松地使用XML数据。
- en: Authentication – OAuth 2.0
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证 – OAuth 2.0
- en: Authentication is often a requirement for accessing a service over the web—not
    always for the entire API, but certainly to access privileged user data. Most
    web-based authentication currently utilizes OAuth 2.0, a framework that allows
    applications to gain partial access to user data after permission is granted by
    the user. The authentication will need to show a web page the first time a resource
    is accessed to explain the request. As a GUI-based application, this workflow
    is often presented using an embedded browser window to hide the complexity of
    going to a web page for the permission request. Unfortunately, such functionality
    isn't built into many of the toolkits we've covered and so we'll instead simply
    open an external web browser for illustrating the workflow. This should only be
    required for first usage and, after that, the access granted should be remembered
    across application runs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 认证通常是访问网络服务的必要条件——不一定适用于整个API，但肯定需要访问受保护的用户数据。目前大多数基于Web的认证都使用OAuth 2.0，这是一个框架，允许应用程序在用户授权后获得对用户数据的部分访问权限。认证需要在第一次访问资源时显示一个网页来解释请求。作为一个基于GUI的应用程序，这个工作流程通常通过嵌入的浏览器窗口来展示，以隐藏访问网页进行权限请求的复杂性。不幸的是，这种功能并没有集成在我们所讨论的许多工具包中，所以我们将会简单地打开一个外部Web浏览器来展示这个工作流程。这仅适用于首次使用，之后，授权的访问应该可以在应用程序运行之间被记住。
- en: To demonstrate authentication, we'll further progress the client code used in
    each GoMail example. We'll extend it to read from the Gmail APIs to download messages.
    For this, you'll need to have a Gmail account and to have created a project in
    the Google Developer Console and enabled API access, which will generate `CLIENT_ID`
    and `CLIENT_SECRET`. First of all, we'll create a new function called `authStream()`
    that'll take a URL `string` parameter and return an `io.ReadCloser` stream like
    the previous `readStream()` and `cacheStream()` functions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示认证，我们将进一步扩展每个GoMail示例中使用的客户端代码。我们将扩展它以从Gmail API中读取并下载消息。为此，你需要有一个Gmail账户，并在Google开发者控制台中创建了一个项目并启用了API访问，这将生成`CLIENT_ID`和`CLIENT_SECRET`。首先，我们将创建一个新的函数`authStream()`，它将接受一个`string`类型的URL参数，并返回一个类似于之前的`readStream()`和`cacheStream()`函数的`io.ReadCloser`流。
- en: First request
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一次请求
- en: To return an authenticated stream, we need to check whether authentication is
    required (a status code of 401 on an HTTP request means just that). If we've already
    authenticated, then the request will complete as normal and we can just return
    the request body. If authentication is required, then we must initiate the process
    by loading a web browser at the correct URL to ask the user for permission; this
    is completed by a helper function, `openBrowser()`, which can be found in this
    book's source code repository.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回一个经过认证的流，我们需要检查是否需要认证（HTTP请求上的状态码401意味着正是如此）。如果我们已经认证过，那么请求将正常完成，我们只需返回请求体。如果需要认证，那么我们必须通过在正确的URL加载一个网络浏览器来启动这个过程，请求用户的权限；这个过程由一个辅助函数`openBrowser()`完成，该函数可以在本书的源代码库中找到。
- en: When the browser window opens, the user will be told about the permission being
    requested and, assuming they accept, the page will redirect to a callback URL.
    We need to set up a simple web server locally to handle this redirect. To do so,
    we register a handler at the `/oauth/callback` path and wait for a connection
    on port 19999.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器窗口打开时，用户将被告知正在请求的权限，如果他们接受，页面将重定向到回调URL。我们需要设置一个简单的本地Web服务器来处理这个重定向。为此，我们在`/oauth/callback`路径上注册一个处理程序，并等待在端口19999上的连接。
- en: 'The server is started, which will cause the function to block until we shut
    it down later:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，函数将阻塞，直到我们稍后关闭它：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The callback handler is relatively simple. It''s responsible for extracting
    the authorization code from the redirection and, using this code, requesting a
    reusable token from the server that sent the single-use code (this is handled
    by `conf.Exchange()`). Upon the exchange completing, we try once again to connect
    to the URL originally specified; if we, succeed, then the return stream is set
    and if not, we fail with the appropriate error. Whatever the outcome, we prompt
    the user to close the browser window (as web page security dictates this can''t
    be done automatically). After we''ve returned this content to the user, we''ll
    shut down the server. This returns control to the original `authStream()` function,
    which will return the newly authenticated request stream:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回调处理程序相对简单。它负责从重定向中提取授权码，并使用此代码从发送一次性代码的服务器请求一个可重复使用的令牌（这由`conf.Exchange()`处理）。交换完成后，我们再次尝试连接到最初指定的URL；如果我们成功，则设置返回流，如果不成功，则失败并返回适当的错误。无论结果如何，我们都会提示用户关闭浏览器窗口（因为网页安全规定这不能自动完成）。在我们将此内容返回给用户后，我们将关闭服务器。这会将控制权交回原始的`authStream()`函数，该函数将返回新认证的请求流：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last piece of this puzzle is to set up the OAuth2 configuration and context.
    We''ll be requesting `read-only` authentication scope from the Gmail API and specifying
    our local server for the callback URL. You''ll need to provide values for `CLIENT_ID`
    and `CLIENT_SECRET` for this to operate correctly. Much of the configuration is
    helpfully provided by the `google.Endpoint` definition from the `golang.org/x/oauth2/google` package:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后一步是设置OAuth2配置和上下文。我们将从Gmail API请求`只读`认证范围，并指定我们的本地服务器作为回调URL。为了正确运行，您需要提供`CLIENT_ID`和`CLIENT_SECRET`的值。大部分配置都由`golang.org/x/oauth2/google`包中的`google.Endpoint`定义提供帮助：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Storing tokens
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储令牌
- en: For a repeat request, we can avoid having the user go through a permission workflow
    again by reusing the token we've been issued. The token that's returned by `conf.Exchange()`
    can be persisted and used in subsequent requests. This token contains a reference
    to refresh the token, which means that, even if the token has expired, the application
    can probably request a new token automatically.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重复请求，我们可以通过重新使用我们收到的令牌来避免让用户再次经历权限工作流程。`conf.Exchange()`返回的令牌可以持久化并用于后续请求。此令牌包含一个用于刷新令牌的引用，这意味着即使令牌已过期，应用程序也可以自动请求新的令牌。
- en: To store and retrieve the token, we shall use a JSON serialization that's already
    set up on the `oauth2.Token` type. When the token is originally issued, we'll
    save it to a file (this could be a database or any other persistence your application
    has access to). As the `client` object we're using to issue `Get()` requests is
    shared; we don't need to reload the token for each request. Instead, we can simply
    load it the next time the application starts. This should mean that, upon a second
    launch of an example, you'll immediately see the results rather than having to
    go through the permission request a second time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储和检索令牌，我们将使用已经设置在`oauth2.Token`类型上的JSON序列化。当令牌最初颁发时，我们将将其保存到文件中（这可以是数据库或任何其他应用程序可以访问的持久化存储）。因为我们使用的`client`对象是共享的；我们不需要为每个请求重新加载令牌。相反，我们可以在应用程序下次启动时简单地加载它。这意味着，在第二次启动示例时，您将立即看到结果，而无需再次进行权限请求。
- en: 'And so we update the `callbackHandler()` function to store the token, if it
    was successfully returned:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们更新`callbackHandler()`函数以存储令牌，如果它成功返回：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And in our application''s `main()` function, we add the token load line immediately
    after setting up the OAuth configuration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们应用程序的`main()`函数中，我们在设置OAuth配置后立即添加令牌加载行：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This loads the stored token (if one exists) into a global variable to be accessed
    later by the `authStream()` function, which should be updated to check for the
    token to see whether it has been loaded:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将存储的令牌（如果有的话）加载到全局变量中，以便稍后由 `authStream()` 函数访问，该函数应更新以检查令牌是否已加载：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Simple implementations of `saveToken()` and `loadToken()` are available in
    the source code repository. For testing purposes, it''s sufficient to print the
    content to the system output and then copy and paste it into the `loadToken()`
    function before the next run. With all of this together, we can implement a simple
    request that''ll count the messages in a user''s inbox. This function requests
    a Gmail API that requires authentication and counts the number of items in the
    resulting JSON message list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码库中有简单的 `saveToken()` 和 `loadToken()` 实现。为了测试目的，将内容打印到系统输出并复制粘贴到 `loadToken()`
    函数中，以便在下次运行之前，这已经足够了。有了所有这些，我们可以实现一个简单的请求，该请求将计算用户收件箱中的消息数量。此函数请求需要身份验证的 Gmail
    API，并计算结果 JSON 消息列表中的项目数量：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run this twice, we see that the first request required the browser
    to open and confirm the authorization. On the second run, that token is reused
    and the same content is returned without interrupting the user:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行两次时，我们可以看到第一次请求需要浏览器打开并确认授权。在第二次运行中，该令牌被重用，并且返回相同的内容，而不会中断用户：
- en: '![](img/f613915a-66d4-4845-92e8-a9f9049a3a02.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f613915a-66d4-4845-92e8-a9f9049a3a02.png)'
- en: Requesting OAuth2 authorization the first time opens a browser window; repeat
    calls use the token we saved
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次请求 OAuth2 授权时将打开浏览器窗口；重复调用使用我们保存的令牌
- en: Posting data
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布数据
- en: 'Posting data to a web service should be just as easy as changing a `Get()`
    function call to a `Post()` but there are often complications. Consider our email
    example and the task of connecting to Gmail. The API is straightforward and we
    can easily make the request, but the data must be appropriately formatted. Emails
    have complex encodings when sent to mail servers and we need to implement that
    to work with the API. The Gmail service requires an RFC 2822 encoded email (which
    the Go standard library doesn''t provide), which is then base64url encoded (the
    standard library can handle this). Before we can post any email messages, we need
    to add an encoder to our `EmailMessage` type, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据发布到网络服务应该和将 `Get()` 函数调用改为 `Post()` 一样简单，但通常会有一些复杂情况。考虑我们的电子邮件示例和连接到 Gmail
    的任务。API 很简单，我们可以轻松地发出请求，但数据必须适当地格式化。当发送到邮件服务器时，电子邮件具有复杂的编码，我们需要实现这一点才能与 API 一起工作。Gmail
    服务需要一个 RFC 2822 编码的电子邮件（Go 标准库不提供），然后进行 base64url 编码（标准库可以处理这一点）。在我们能够发布任何电子邮件之前，我们需要向我们的
    `EmailMessage` 类型添加一个编码器，如下所示：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code makes use of an external library, `github.com/sloonz/go-mime-message`, and
    it has been imported as `mime` for convenience. We''re using the name `Demo` as
    we haven''t recorded people''s names in these examples; you could omit that part
    if you prefer. To implement the sending of emails, we can check the Google documentation
    at [https://developers.google.com/gmail/api/v1/reference/users/messages/send](https://developers.google.com/gmail/api/v1/reference/users/messages/send)
    to find out that we need to pass a JSON payload with the encoded data as a value
    associated with the `raw` key. A simple method should be able to package that
    and send it to the API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了外部库 `github.com/sloonz/go-mime-message`，并且为了方便起见，我们使用了 `mime` 名称；在这些示例中我们没有记录人们的名字，如果您愿意，可以省略该部分。为了实现发送电子邮件，我们可以查看
    Google 文档 [https://developers.google.com/gmail/api/v1/reference/users/messages/send](https://developers.google.com/gmail/api/v1/reference/users/messages/send)，以了解我们需要传递一个与
    `raw` 键关联的编码数据的 JSON 有效负载。一个简单的方法应该能够打包并发送到 API：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For this code, we need just one more function, `authPost()`. This function
    will make an authenticated post to our URL passing the content type and request
    body as the second and third parameters. This method could save the URL, content
    type, and payload to re-submit if the authorization workflow is required, but
    often this is unwise or impossible for an HTTP post request and so we simply re-use
    the token that was generated in the previous `authStream()` function. If you do
    reuse this token, then you''ll need to remember to update the code to request
    additional permissions; the updated scope should be as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码，我们还需要一个额外的函数，`authPost()`。这个函数将对我们的URL进行认证发送，将内容类型和请求体作为第二个和第三个参数传递。这种方法可以将URL、内容类型和有效负载保存下来，以便在需要授权工作流程时重新提交，但通常对于HTTP
    POST请求来说，这既不明智也不可行，所以我们简单地重新使用之前在 `authStream()` 函数中生成的令牌。如果你确实重新使用了这个令牌，那么你需要记得更新代码以请求额外的权限；更新的作用域应如下所示：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this changed, a new token is issued and, with the preceding code in place,
    we can execute a simple method to send an email using the `postMessage()` function
    listed previously:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，将颁发新的令牌，并且，在放置了前面的代码之后，我们可以执行一个简单的方法，使用之前列出的 `postMessage()` 函数发送电子邮件：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding `postMessage()` function outputs useful debug information, but
    that can clearly be switched off and the email can send handle failures in a more
    appropriate manner:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的 `postMessage()` 函数输出了有用的调试信息，但显然可以将其关闭，并且可以通过更合适的方式处理电子邮件发送失败：
- en: '![](img/72e90d90-fe54-4347-9251-59f40952a9a9.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72e90d90-fe54-4347-9251-59f40952a9a9.png)'
- en: The debug from our email post example; Gmail returns the message and thread
    ID along with label information
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 来自我们电子邮件发送示例的调试信息；Gmail返回消息和线程ID以及标签信息
- en: GUI integration
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI集成
- en: In the previous *Concurrency, threads, and GUI updates* section, we looked at
    thread management and how to update the user interface from background tasks.
    Now that we're working with real cloud services, let's look at additional complications
    that we may need to deal with.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 *并发、线程和GUI更新* 部分，我们探讨了线程管理以及如何从后台任务更新用户界面。现在我们正在使用真实的云服务，让我们看看我们可能需要处理的额外复杂性。
- en: Incoming messages
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来信消息
- en: The client API that has been used to simulate a connection to an email server
    included the `Incoming()` function, which returned a channel of `EmailMessage`
    objects. A new message would be sent to this channel each time a new email arrived,
    and we can use this same model for a real email server connection as well. The
    email message abstraction works to communicate a standard structure and so all
    a new email connection (such as the preceding Gmail examples) needs to do is package
    the incoming data into an `EmailMessage` struct and add it to the channel.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用于模拟连接到电子邮件服务器的客户端API包括 `Incoming()` 函数，该函数返回一个 `EmailMessage` 对象的通道。每当有新电子邮件到达时，都会向该通道发送一条新消息，我们也可以使用这个相同的模型来连接真实的电子邮件服务器。电子邮件消息抽象用于传达标准结构，因此新的电子邮件连接（如前面的Gmail示例）需要做的只是将传入的数据打包到
    `EmailMessage` 结构体中，并将其添加到通道中。
- en: This means the only additional work that we need to do is update the code in
    the server connection package to monitor for new messages and add some JSON decoding
    when a new message is detected. All of this can be done without changing a single
    line of our GoMail example application GUIs. In fact, to activate a real Gmail
    account instead of our test server "we need to change the `client.NewTestServer()`
    function call to `client.NewGmailServer()` (a full description of this Gmail provider
    is available in the final [Appendix](e0ad4219-5c9a-4d4b-87ce-5bc4b7baa67c.xhtml),
    *Connecting GoMail to a Real Email Server*).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们唯一需要做的额外工作就是更新服务器连接包中的代码，以监视新消息，并在检测到新消息时添加一些JSON解码。所有这些都可以在不更改我们GoMail示例应用程序GUI的任何一行代码的情况下完成。实际上，为了激活真实的Gmail账户而不是我们的测试服务器
    "我们需要将 `client.NewTestServer()` 函数调用更改为 `client.NewGmailServer()`（有关此Gmail提供者的完整描述可在最后的
    [附录](e0ad4219-5c9a-4d4b-87ce-5bc4b7baa67c.xhtml)，*将GoMail连接到真实电子邮件服务器*)。
- en: Activity notifications
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动通知
- en: It can be helpful for users to know when an application is executing code in
    the background. If, for example, you wanted to include a Check Email button in
    your application, then it may be helpful to indicate when email is being checked
    so the user knows that pressing the button won't do anything. As a developer,
    this is most commonly seen in an IDE status bar, indicating that a build is in
    progress or a packaging task is running. If working on a laptop and fans start
    to spin, it's useful to know what's executing in the background so that any potential
    concerns can be put to one side for a while.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，知道应用程序何时在后台执行代码可能很有帮助。例如，如果你想在应用程序中包含一个检查电子邮件的按钮，那么指示电子邮件正在被检查可能有助于用户知道按下按钮不会做任何事情。作为开发者，这种情况最常见于IDE状态栏，指示构建正在进行或打包任务正在运行。如果在笔记本电脑上工作，风扇开始旋转，了解后台正在执行什么操作是有用的，这样任何潜在的问题都可以暂时搁置。
- en: 'To support this type of interface update, we need to track when tasks start
    and stop. Depending on the type of visual design, there are two strategies we
    could use: a simple counter of background tasks or a list of running tasks. The
    former is far easier to implement but the latter is able to report more information
    to the application user. If you''ll just use a spinner or an infinite progress
    bar, then the first strategy will work well. If, however, you want to add a status
    bar that shows the current running task, you''ll need to go with the second.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种界面更新，我们需要追踪任务何时开始和结束。根据视觉设计的类型，我们可以使用两种策略：后台任务的简单计数器或正在运行的任务列表。前者更容易实现，但后者能够向应用程序用户报告更多信息。如果你只是使用旋转器或无限进度条，那么第一种策略将很好地工作。然而，如果你想要添加一个显示当前运行任务的进度条，那么你需要选择第二种策略。
- en: Spinner
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转器
- en: A spinner (or other simple activity indicator) can be a helpful visualization
    of whether or not there's background activity. It'll be visible if the number
    of background tasks is non-zero. To track this, we can implement a simple counter
    in the application and update it using the `StartTask()` and `StopTask()` functions.
    A listener or channel would then tell the user interface element that the number
    of running tasks had changed so it can update the GUI by showing or hiding the
    visual element.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个旋转器（或其他简单的活动指示器）可以是有助于可视化是否有后台活动。如果后台任务的数量非零，它将是可见的。为了追踪这一点，我们可以在应用程序中实现一个简单的计数器，并使用`StartTask()`和`StopTask()`函数更新它。然后，一个监听器或通道会通知用户界面元素正在运行的任务数量已更改，以便它可以通过显示或隐藏可视化元素来更新GUI。
- en: 'In a cloud-based application where a background task is using network connections,
    there''s an added benefit: we can insert these task tracking function calls into
    the network request code. For example, we could update `readStream()` to call
    `StartTask()` and all of the background tasks will increment the counter. To signal
    that the task had ended, we would return a wrapper to the stream so that, when
    `Close()` is called, it can correctly call `StopTask()`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个基于云的应用程序中，如果后台任务正在使用网络连接，这将带来额外的优势：我们可以将这些任务追踪功能调用插入到网络请求代码中。例如，我们可以更新`readStream()`以调用`StartTask()`，这样所有的后台任务都会增加计数器。为了表示任务已结束，我们将返回一个包装器到流中，这样当调用`Close()`时，它就可以正确地调用`StopTask()`。
- en: Status panel
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态面板
- en: A status panel, which displays the current (or most recent) task, will need
    us to track the name of a task when it starts. To accurately display which task
    is still running, we'll also need to track which task ends (otherwise a quick
    task that starts after a long running one and then stops won't correctly update
    the status display).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个状态面板，用于显示当前（或最近的）任务，将需要我们在任务开始时追踪任务名称。为了准确显示哪些任务仍在运行，我们还需要追踪哪些任务结束（否则，一个在长时间运行的任务之后开始并停止的快速任务将无法正确更新状态显示）。
- en: An example implementation would be for the appropriate start function to return
    a task reference, which is then stopped directly, for example, `task := StartTask("My
    task name")`, which is then stopped later using `task.Stop()`. A similar listener
    or channel would be needed, but this time the data would be a task reference instead
    of the count of background tasks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例实现是，适当的开始函数返回一个任务引用，然后直接停止，例如，`task := StartTask("我的任务名称")`，稍后使用`task.Stop()`停止。还需要一个类似的监听器或通道，但这次数据是任务引用而不是后台任务的数量。
- en: Consistent user experience when offline
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线时保持一致的用户体验
- en: In modern graphical applications, a good user experience is clearly dependent
    upon great design and a high level of quality, but it's also important to handle
    network and service failures. In the *Network resources and caching* section of
    this chapter, we covered, caching of server responses to be more fault tolerant
    and to speed up application loading, but that's a small portion of a larger strategy
    for great offline support.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代图形应用程序中，良好的用户体验显然取决于优秀的设计和高质量，但处理网络和服务故障也同样重要。在本章的*网络资源和缓存*部分，我们介绍了缓存服务器响应以提高容错性和加快应用程序加载速度，但这只是为出色的离线支持制定更大策略的一小部分。
- en: Caching responses
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存响应
- en: The response caching code introduced earlier in this chapter can be applied
    to almost all HTTP requests, but we only used it for HTTP GET. Of the many different
    types of HTTP requests, only three are deemed to be cacheable (GET, HEAD, and
    POST), and the HEAD request doesn't return a body and so isn't useful in our application.
    The POST method is indicative of an action being performed, so in our context
    (and most others), it's more important to know that it completed, rather than
    to save the response it caused (see the *Queuing actions* section next). To learn
    more about the types of HTTP requests, see [https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面引入的响应缓存代码可以应用于几乎所有的HTTP请求，但我们只使用了它来处理HTTP GET。在许多不同的HTTP请求类型中，只有三种被认为是可缓存的（GET、HEAD和POST），而HEAD请求不返回主体，因此在我们的应用程序中并不有用。POST方法表示正在执行的操作，所以在我们这个上下文（以及大多数其他上下文）中，知道它是否完成比保存它引起的响应更重要（请参阅下一节的*排队操作*）。要了解更多关于HTTP请求类型的信息，请参阅[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)。
- en: In addition to this, it may not be suitable to cache the response to every GET
    request. While HTTP is a stateless protocol, the server that you're communicating
    with may be tracking state that could affect the response to your request. If
    your application knows that the response to a request will be time sensitive,
    you could make sure that it skips the cache or set a timeout on that cache entry.
    Unfortunately, it may not always be possible to know this in advance; this is
    where HTTP headers (and the HEAD method) can be helpful. By examining the headers
    of a response, you may see Last-Modified or ETag metadata (by issuing a HEAD request,
    you can access this information without the full response data being sent). If
    the Last-Modified header contains a time that's earlier than the creation of your
    cache entry, then your cache can still be used, otherwise you should remove the
    cached item and replace it with a fresh request. Using ETag is usually more efficient
    as it doesn't require any date parsing, but you'll need to store the appropriate
    tag for each cached response. This metadata is used as a unique identity for the
    response content and, if the data were to be changed in any way, the ETag would
    change as well (at which point you would reset the cache, as mentioned earlier).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能不适合缓存每个GET请求的响应。虽然HTTP是无状态协议，但你正在与之通信的服务器可能正在跟踪可能影响你请求响应的状态。如果你的应用程序知道请求的响应将是时间敏感的，你可以确保它跳过缓存或在该缓存条目上设置超时。不幸的是，可能并不总是能够提前知道这一点；这就是HTTP头部（以及HEAD方法）可以发挥作用的地方。通过检查响应的头部，你可能看到Last-Modified或ETag元数据（通过发出HEAD请求，你可以访问这些信息而不需要发送完整的响应数据）。如果Last-Modified头部包含一个早于你的缓存条目创建时间的日期，那么你的缓存仍然可以使用，否则你应该删除缓存的项并用新的请求替换它。使用ETag通常更高效，因为它不需要任何日期解析，但你需要为每个缓存的响应存储适当的标签。这些元数据用作响应内容的唯一标识符，如果数据以任何方式更改，ETag也会更改（此时你应该像之前提到的那样重置缓存）。
- en: If implementing a complete HTTP cache, there are other headers to be aware of
    as well, most notably `Cache-Control`. If this value is set to `no-cache` or `no-store` (or
    a combination including those values), the server is indicating that the response
    must never be cached. This is probably an indication that the content is specific
    to that request and the time of request, or that there's another reason that issuing
    the same request again would return a different response body.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现完整的HTTP缓存，还有其他一些头部信息需要注意，最值得注意的是`Cache-Control`。如果这个值设置为`no-cache`或`no-store`（或包括这些值的组合），服务器表明响应不得被缓存。这可能是内容针对特定请求和时间的一个指示，或者有其他原因导致再次发出相同的请求会返回不同的响应体。
- en: With all of these considerations properly addressed, the code to manage a response
    cache is a lot more complicated than illustrated earlier in this chapter, which
    is why various Go packages exist to manage the details. Searching in your favorite
    search engine for *golang http cache* will probably return the most popular results.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在妥善处理所有这些考虑因素之后，管理响应缓存的代码比本章前面所展示的要复杂得多，这也是为什么存在各种Go包来管理细节。在您最喜欢的搜索引擎中搜索“golang
    http cache”可能会返回最相关的结果。
- en: Queuing actions
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列操作
- en: Other HTTP methods, such as POST, PUT, or DELETE, are typically indicative of
    a user action whereby confirmation that it has been communicated is the main requirement.
    In these situations, a cache isn't helpful; if requested a second time, the cache
    could stop our action from reaching the server at all. For this reason, it's uncommon
    to cache these requests. Moreover, if we're to build a resilient application,
    we need to plan for unsuccessful requests. In these situations, the server may
    or may not have received our request and the action may or may not have been processed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其他HTTP方法，如POST、PUT或DELETE，通常表示用户操作，确认其已被传达是主要要求。在这些情况下，缓存没有帮助；如果再次请求，缓存可能会阻止我们的操作到达服务器。因此，通常不会缓存这些请求。此外，如果我们打算构建一个健壮的应用程序，我们需要为失败的请求做出计划。在这些情况下，服务器可能已经或未收到我们的请求，操作可能已经或未处理。
- en: The usual approach to this challenge is to build a queue of outgoing responses.
    Adding a request to such a queue could be done using  *fire and forget*, whereby
    the user doesn't care when the request is completed, or to add a callback so that
    appropriate notifications (such as *Email sent*) can be communicated upon completion.
    Building queues like this with Go is well documented; support for multi-threading,
    channels, and wait groups makes it a relatively simple task so we'll not go into
    the details of how this could be executed. What's important, however, is determining
    whether a request succeeded or failed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 应对这一挑战的通常方法是为出站响应构建一个队列。将请求添加到此类队列可以是“发射并忘记”，用户不关心请求何时完成，或者添加一个回调，以便在完成时传达适当的通知（例如，“邮件已发送”）。使用Go构建此类队列有很好的文档支持；对多线程、通道和等待组的支持使其相对简单，所以我们不会深入探讨如何执行。然而，重要的是确定请求是成功还是失败。
- en: If an HTTP POST (for example) times out or returns with an error of 500 (or
    above), we must assume it failed. Re-issuing the same request is safe as re-issuing
    an identical POST shouldn't cause any additional state change if it was successfully
    completed the first time. A response code from 400 to 499 means that there was
    a fault with the request and re-trying won't fix the issue. In these cases, it's
    likely that the user needs to be informed of the failure (and the code should
    probably log the error to your team somehow).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个HTTP POST请求（例如）超时或返回500（或更高）的错误，我们必须假设它失败了。重新发出相同的请求是安全的，因为如果它第一次成功完成，重新发出一个相同的POST请求不应该引起任何额外的状态变化。从400到499的响应代码意味着请求有误，重试不会解决问题。在这些情况下，可能需要通知用户失败（并且代码应该以某种方式记录错误到你的团队）。
- en: 'Be careful not to blindly accept a status code of 200 (OK) as success; many
    protocols communicate certain failure conditions within the body of a successful
    HTTP response. Be sure to read the documentation for the API you''re using to
    see how to check for additional errors. For example, a typical `graphql` response
    may return an HTTP status code 200 but have failed internally; knowing whether
    to retry in the background or to communicate the error to the application user
    will be specific to the service and the error encountered. In the following example,
    the server response helpfully indicated that a retry may help to resolve the issue:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要盲目地将状态码200（OK）视为成功；许多协议在成功的HTTP响应体中传达某些失败条件。请确保阅读您所使用的API文档，了解如何检查额外的错误。例如，一个典型的`graphql`响应可能会返回HTTP状态码200，但内部可能已经失败；是否在后台重试或向应用程序用户传达错误将取决于服务和遇到的错误。在以下示例中，服务器响应有用地指出重试可能有助于解决问题：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Starting offline
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离线启动
- en: The preceding strategies help to deal with intermittent internet connections,
    or continuing to work with an application in offline mode after some time online.
    But what if your application is designed to work offline right from the first
    usage? If a login isn't required immediately, then you may be able to support
    an initial offline state; probably not ideal for an email client but it may be
    expected for a collaborative documentation platform or entertainment system. How
    can we make use of the techniques we've explored already to provide a great first-use
    experience if there's no network available?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述策略有助于处理间歇性互联网连接，或者在线一段时间后继续以离线模式使用应用程序。但如果您的应用程序从一开始就被设计为离线工作呢？如果不需要立即登录，那么您可能能够支持初始离线状态；这可能不是电子邮件客户端的理想选择，但对于协作文档平台或娱乐系统来说可能是有预期的。如果没有网络可用，我们如何利用我们已经探索过的技术来提供出色的首次使用体验呢？
- en: 'The simplest approach to this problem is probably to package data with the
    application so that it can be used as a cache if no recently cached data is available.
    In this manner, the application could attempt to use a local cache if one exists,
    then fall back to the application data otherwise, and if neither is available,
    then attempt to make the remote connection, like the following prototypical function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法可能是将数据与应用程序捆绑在一起，以便在没有最近缓存的可用数据时用作缓存。以这种方式，应用程序可以尝试使用本地缓存（如果存在），否则回退到应用程序数据，如果两者都不可用，则尝试建立远程连接，如下面的典型函数所示：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we re-use the `cacheStream()` and `readStream()` functions
    before and  use a new (hypothetical) function named `resourceStream()`, which
    would encode the URL, look up some bundled resources in the application, and return
    a stream to one if it's found. An alternative approach is for the first run of
    an application to extract all of the cached resources it has packaged and set
    up a local cache, then later code could simply use `cacheStream()` as before.
    For more information about bundling resources for distribution, see [Chapter 14](8a8d3a29-3634-46de-90cf-ad3e6129e487.xhtml),
    *Distributing your Application*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在之前重新使用了`cacheStream()`和`readStream()`函数，并使用了一个名为`resourceStream()`的新（假设的）函数，该函数将编码URL，在应用程序中查找一些捆绑的资源，并在找到时返回一个流。另一种方法是，在应用程序首次运行时提取所有已打包的缓存资源并设置本地缓存，然后后续代码可以像之前一样简单地使用`cacheStream()`。有关捆绑资源以进行分发的更多信息，请参阅第14章，*分发您的应用程序*。
- en: Of course, whichever strategy you use, be sure to consider how important it
    is for the data to be up to date; is falling back to an old cache that's bundled
    in the application a good strategy for your data? Do you want to update the local
    copy of this information on a regular basis? If it's important that the data be
    as fresh as possible, then the preceding function should probably be changed so
    that `readStream()` is attempted before `resourceStream()` or even `cacheStream()` and
    a *live* request is attempted if possible. If you take this approach, be sure
    to consider timeouts and other failure conditions, and handle user expectations
    appropriately.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，无论您使用哪种策略，都务必考虑数据保持最新程度的重要性；将旧缓存捆绑到应用程序中是否是您数据的良好策略？您是否希望定期更新此信息的地方副本？如果数据必须尽可能新鲜，那么前面的函数可能需要更改，以便在可能的情况下尝试`resourceStream()`或`cacheStream()`之前尝试`readStream()`，并尝试进行实时请求。如果您采取这种方法，请务必考虑超时和其他失败条件，并适当地处理用户期望。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored some of the more complex aspects of developing
    a rich application with long-running background threads and a reliance on remote
    resources or web services. We first looked at multi-threading and the management
    of long-running processes, building on the basics of goroutines and thread handling
    from earlier chapters. We looked at how background processes can be designed to
    minimize the impact of the code overhead required by some graphical toolkits.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了开发具有长时间运行的后台线程和依赖远程资源或网络服务的丰富应用程序的一些更复杂方面。我们首先回顾了goroutines和线程处理的基础知识，然后研究了如何设计后台进程以最小化某些图形工具包所需的代码开销。
- en: Most of the complexity discussed in this chapter covered working with remote
    resources and web services. We saw how to implement caching strategies and how
    they can work to create a more resilient application when network conditions aren't
    optimal. We also explored authentication of requests (using the common OAuth2
    workflow) and connected the GoMail examples to a live Gmail account to read and
    send emails.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的大部分复杂性涉及与远程资源和网络服务的工作。我们看到了如何实现缓存策略以及它们如何在网络条件不佳时帮助创建一个更具弹性的应用程序。我们还探讨了请求的认证（使用常见的OAuth2工作流程），并将GoMail示例连接到一个真实的Gmail账户以读取和发送电子邮件。
- en: All of these topics help to build robustness into an application and maintain
    a high quality user experience even when required resources aren't available.
    In the next chapter, [Chapter 13](fae83854-5529-4783-a6a4-b019dc45f831.xhtml),
    *Best Practices in Go GUI Development*, we'll move our focus from user experience
    to great source code and look into best practices for GUI development with Go.
    We'll also cover how to set up your code for ease of development and collaboration,
    as well as the tools and processes that'll help along the way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些主题都有助于将健壮性构建到应用程序中，并在所需资源不可用的情况下保持高质量的用户体验。在下一章，[第13章](fae83854-5529-4783-a6a4-b019dc45f831.xhtml)，*Go
    GUI开发的最佳实践*中，我们将关注点从用户体验转移到优秀的源代码，并探讨使用Go进行GUI开发的最佳实践。我们还将介绍如何设置代码以方便开发和协作，以及沿途将帮助的工具和流程。
