- en: Introduction to Performance in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go性能简介
- en: This book is written with intermediate to advanced Go developers in mind. These
    developers will be looking to squeeze more performance out of their Go application.
    To do this, this book will help to drive the four golden signals as defined in
    the *Site Reliability Engineering Workbook* ([https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/](https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/)).
    If we can reduce latency and errors, as well as increase traffic whilst reducing
    saturation, our programs will continue to be more performant. Following the ideology
    of the four golden signals is beneficial for anyone developing a Go application
    with performance in mind.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是针对中级到高级Go开发人员编写的。这些开发人员将希望从其Go应用程序中挤出更多性能。为此，本书将帮助推动《Site Reliability Engineering
    Workbook》中定义的四个黄金信号（[https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/](https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/)）。如果我们能减少延迟和错误，同时增加流量并减少饱和，我们的程序将继续更加高效。遵循四个黄金信号的理念对于任何以性能为目标开发Go应用程序的人都是有益的。
- en: In this chapter, you'll be introduced to some of the core concepts of performance
    in computer science. You'll learn some of the history of the Go computer programming
    language, how its creators decided that it was important to put performance at
    the forefront of the language, and why writing performant Go is important. Go
    is a programming language designed with performance in mind, and this book will
    take you through some of the highlights on how to use some of Go's design and
    tooling to your advantage. This will help you to write more efficient code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将介绍计算机科学性能的一些核心概念。您将了解Go计算机编程语言的一些历史，其创建者是如何决定将性能置于语言的前沿，并且为什么编写高性能的Go很重要。Go是一种以性能为重点设计的编程语言，本书将带您了解如何利用Go的设计和工具来提高性能。这将帮助您编写更高效的代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding performance in computer science
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解计算机科学中的性能
- en: A brief history of Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的简要历史
- en: The ideology behind Go performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go性能背后的理念
- en: These topics are provided to guide you in beginning to understand the direction
    you need to take to write highly performant code in the Go language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题旨在指导您开始了解在Go语言中编写高性能代码所需的方向。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this book, you should have a moderate understanding of the Go language.
    Some key concepts to understand before exploring these topics include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，您应该对Go语言有一定的了解。在探索这些主题之前，了解以下一些关键概念是很重要的：
- en: 'The Go reference specification: [https://golang.org/ref/spec](https://golang.org/ref/spec)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go参考规范：[https://golang.org/ref/spec](https://golang.org/ref/spec)
- en: 'How to write Go code: [https://golang.org/doc/code.html](https://golang.org/doc/code.html)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写Go代码：[https://golang.org/doc/code.html](https://golang.org/doc/code.html)
- en: 'Effective Go: [https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Effective Go: [https://golang.org/doc/effective_go.html](https://golang.org/doc/effective_go.html)'
- en: Throughout this book, there will be many code samples and benchmark results.
    These are all accessible via the GitHub repository at [https://github.com/bobstrecansky/HighPerformanceWithGo/](https://github.com/bobstrecansky/HighPerformanceWithGo/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，将提供许多代码示例和基准结果。所有这些都可以通过GitHub存储库访问[https://github.com/bobstrecansky/HighPerformanceWithGo/](https://github.com/bobstrecansky/HighPerformanceWithGo/)。
- en: If you have a question or would like to request a change to the repository,
    feel free to create an issue within the repository at [https://github.com/bobstrecansky/HighPerformanceWithGo/issues/new](https://github.com/bobstrecansky/HighPerformanceWithGo/issues/new).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有问题或想要请求更改存储库，请随时在存储库内创建问题[https://github.com/bobstrecansky/HighPerformanceWithGo/issues/new](https://github.com/bobstrecansky/HighPerformanceWithGo/issues/new)。
- en: Understanding performance in computer science
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解计算机科学中的性能
- en: Performance in computer science is a measure of work that can be accomplished
    by a computer system. Performant code is vital to many different groups of developers.
    Whether you're part of a large-scale software company that needs to quickly deliver
    masses of data to customers, an embedded computing device programmer who has limited
    computing resources available, or a hobbyist looking to squeeze more requests
    out of the Raspberry Pi that you are using for your pet project, performance should
    be at the forefront of your development mindset. Performance matters, especially
    when your scale continues to grow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的性能是计算机系统可以完成的工作量的衡量标准。高性能的代码对许多不同的开发人员群体至关重要。无论您是大型软件公司的一部分，需要快速向客户交付大量数据，还是嵌入式计算设备程序员，可用的计算资源有限，或者是业余爱好者，希望从用于宠物项目的树莓派中挤出更多请求，性能都应该是您开发思维的前沿。性能很重要，特别是当您的规模不断增长时。
- en: It is important to remember that we are sometimes limited by physical bounds.
    CPU, memory, disk I/O, and network connectivity all have performance ceilings
    based on the hardware that you either purchase or rent from a cloud provider.
    There are other systems that may run concurrently alongside our Go programs that
    can also consume resources, such as OS packages, logging utilities, monitoring
    tools, and other binaries—it is prudent to remember that our programs are very
    frequently not the only tenants on the physical machines they run on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，我们有时会受到物理限制。 CPU、内存、磁盘I/O和网络连接性都有性能上限，这取决于您从云提供商购买或租用的硬件。还有其他系统可能会与我们的Go程序同时运行，也会消耗资源，例如操作系统软件包、日志记录工具、监控工具和其他二进制文件——要记住，我们的程序很频繁地不是物理机器上唯一的租户。
- en: 'Optimized code generally helps in many ways, including the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的代码通常在许多方面有所帮助，包括以下内容：
- en: 'Decreased response time: The total amount of time it takes to respond to a
    request.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间减少：响应请求所需的总时间。
- en: 'Decreased latency: The time delay between a cause and effect within a system.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低延迟：系统内因果关系之间的时间延迟。
- en: 'Increased throughput: The rate at which data can be processed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加吞吐量：数据处理速率。
- en: 'Higher scalability: More work can be processed within a contained system.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高的可扩展性：可以在一个封闭系统内处理更多的工作。
- en: There are many ways to service more requests within a computer system. Adding
    more individual computers (often referred to as horizontal scaling) or upgrading
    to more powerful computers (often referred to as vertical scaling) are common
    practices used to handle demand within a computer system. One of the fastest ways
    to service more requests without needing additional hardware is to increase code
    performance. Performance engineering acts as a way to help with both horizontal
    and vertical scaling. The more performant your code is, the more requests you
    can handle on a single machine. This pattern can potentially result in fewer or
    less expensive physical hosts to run your workload. This is a large value proposition
    for many businesses and hobbyists alike, as it helps to drive down the cost of
    operation and improves the end user experience.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机系统中有许多方法可以处理更多的请求。增加更多的个体计算机（通常称为横向扩展）或升级到更强大的计算机（通常称为纵向扩展）是处理计算机系统需求的常见做法。在不需要额外硬件的情况下，提高代码性能是服务更多请求的最快方法之一。性能工程既可以帮助横向扩展，也可以帮助纵向扩展。代码性能越高，单台机器就能处理更多的请求。这种模式可能导致运行工作负载的物理主机减少或更便宜。这对许多企业和爱好者来说是一个巨大的价值主张，因为它有助于降低运营成本，改善最终用户体验。
- en: A brief note on Big O notation
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Big O符号简要说明
- en: Big O notation ([https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation)) is
    commonly used to describe the limiting behavior of a function based on the size
    of the inputs. In computer science, Big O notation is used to explain how efficient
    algorithms are in comparison to one another—we'll discuss this more in detail
    in [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and
    Algorithms*. Big O notation is important in optimizing performance because it
    is used as a comparison operator in explaining how well algorithms will scale.
    Understanding Big O notation will help you to write more performant code, as it
    will help to drive performance decisions in your code as the code is being composed.
    Knowing at what point different algorithms have relative strengths and weaknesses
    helps you to determine the correct choice for the implementation at hand. We can't
    improve what we can't measure—Big O notation helps us to give a concrete measurement
    to the problem statement at hand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Big O符号([https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation))通常用于描述基于输入大小的函数的极限行为。在计算机科学中，Big
    O符号用于解释算法相对于彼此的效率——我们将在[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中更详细地讨论这一点，*数据结构和算法*。Big
    O符号在优化性能方面很重要，因为它被用作比较运算符，解释算法的扩展性如何。了解Big O符号将帮助您编写更高性能的代码，因为它将在代码编写时帮助您做出性能决策。了解不同算法在何时具有相对优势和劣势的点，将帮助您确定实现的正确选择。我们无法改进我们无法衡量的东西——Big
    O符号帮助我们对手头的问题陈述给出一个具体的衡量。
- en: Methods to gauge long term performance
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 衡量长期性能的方法
- en: 'As we make our performance improvements, we will need to continually monitor
    our changes to view impact. Many methods can be used to monitor the long-term
    performance of computer systems. A couple of examples of these methods would be
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行性能改进时，我们需要不断监视我们的变化以查看影响。有许多方法可以用来监视计算机系统的长期性能。其中一些方法的例子如下：
- en: 'Brendan Gregg''s USE Method: Utilization, saturation, and errors ([www.brendangregg.com/usemethod.html](http://www.brendangregg.com/usemethod.html))'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Brendan Gregg的USE方法：利用率、饱和度和错误([www.brendangregg.com/usemethod.html](http://www.brendangregg.com/usemethod.html))
- en: 'Tom Wilkie''s RED Metrics: Requests, errors, and duration ([https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/](https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/))'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tom Wilkie的RED指标：请求、错误和持续时间([https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/](https://www.weave.works/blog/the-red-method-key-metrics-for-microservices-architecture/))
- en: 'Google SRE''s four Golden Signals: Latency, traffic, errors, and saturation
    ([https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/](https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google SRE的四个黄金信号：延迟、流量、错误和饱和度([https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/](https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/))
- en: We will discuss these concepts further in [Chapter 15](88e04ed3-8f84-43a9-ac4a-bf9d26b88e68.xhtml),
    *Comparing Code Quality Across Versions*. These paradigms help us to make smart
    decisions about the performance optimizations in our code as well as avoid premature
    optimization. Premature optimization plays as a very crucial aspect for many a
    computer programmers. Very frequently, we have to determine what *fast enough*
    is. We can waste our time trying to optimize a small segment of code when many
    other code paths have an opportunity to improve from a performance perspective.
    Go's simplicity allows for additional optimization without cognitive load overhead
    or an increase in code complexity. The algorithms that we will discuss in [Chapter
    2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and Algorithms*,
    will help us to avoid premature optimization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第15章](88e04ed3-8f84-43a9-ac4a-bf9d26b88e68.xhtml)中进一步讨论这些概念，*跨版本比较代码质量*。这些范式帮助我们做出关于代码性能优化的明智决策，避免过早优化。过早优化对许多计算机程序员来说是非常关键的一个方面。我们经常不得不确定什么是*足够快*。当许多其他代码路径有机会从性能角度进行改进时，我们可能会浪费时间尝试优化一小部分代码。Go的简单性允许进行额外的优化，而不会增加认知负担或增加代码复杂性。我们将在[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中讨论的算法，将帮助我们避免过早优化。
- en: Optimization strategies overview
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化策略概述
- en: In this book, we will also attempt to understand what exactly we are optimizing
    for. The techniques for optimizing for CPU or memory utilization may look very
    different than optimizing for I/O or network latency. Being cognizant of your
    problem space as well as your limitations within your hardware and upstream APIs
    will help you to determine how to optimize for the problem statement at hand.
    Optimization also often shows diminishing returns. Frequently the return on development
    investment for a particular code hotspot isn't worthwhile based on extraneous
    factors, or adding optimizations will decrease readability and increase risk for
    the whole system. If you can determine whether an optimization is worth doing
    early on, you'll be able to have a more narrowly scoped focus and will likely
    continue to develop a more performant system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们还将尝试理解我们到底在优化什么。优化CPU或内存利用率的技术可能看起来与优化I/O或网络延迟的技术大不相同。了解问题空间以及硬件和上游API中的限制将帮助您确定如何针对手头的问题陈述进行优化。优化通常也会显示出递减的回报。经常情况下，基于外部因素，特定代码热点的开发投资回报不值得，或者添加优化会降低可读性并增加整个系统的风险。如果您能够早期确定优化是否值得进行，您将能够更加狭窄地聚焦，并可能继续开发更高性能的系统。
- en: 'It can be helpful to understand baseline operations within a computer system.
    *Peter Norvig*, the Director of Research at Google, designed a table (the image
    that follows) to help developers understand the various common timing operations
    on a typical computer ([https://norvig.com/21-days.html#answers](https://norvig.com/21-days.html#answers)):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 了解计算机系统中的基线操作可能是有帮助的。*Peter Norvig*，谷歌研究总监，设计了一张表（随后的图片），帮助开发人员了解典型计算机上各种常见的时间操作（[https://norvig.com/21-days.html#answers](https://norvig.com/21-days.html#answers)）。
- en: '![](img/0761aefe-aed8-4d74-ad2b-32047bce2da4.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0761aefe-aed8-4d74-ad2b-32047bce2da4.png)'
- en: Having a clear understanding of how different parts of a computer can interoperate
    with one another helps us to deduce where our performance optimizations should
    lie. As derived from the table, it takes quite a bit longer to read 1 MB of data
    sequentially from disk versus sending 2 KBs over a 1 Gbps network link. Being
    able to have *back-of-the-napkin math* comparison operators for common computer
    interactions can very much help to deduce which piece of your code you should
    optimize next. Determining bottlenecks within your program becomes easier when
    you take a step back and look at a snapshot of the system as a whole.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地了解计算机的不同部分如何相互协作有助于我们推断出我们的性能优化应该放在哪里。从表中得出，从磁盘顺序读取1 MB的数据所需的时间要比通过1 Gbps网络链路发送2
    KB的数据要长得多。当您能够对常见的计算机交互进行*草稿计算*比较运算符时，可以帮助您推断出下一个应该优化的代码部分。当您退后一步并全面审视系统的快照时，确定程序中的瓶颈变得更容易。
- en: Breaking down performance problems into small, manageable sub problems that
    can be improved upon concurrently is a helpful shift into optimization. Trying
    to tackle all performance problems at once can often leave the developer stymied
    and frustrated, and often lead to many performance efforts failing. Focusing on
    bottlenecks in the current system can often yield results. Fixing one bottleneck
    will often quickly identify another. For example, after you fix a CPU utilization
    problem, you may find that your system's disk can't write the values that are
    computed fast enough. Working through bottlenecks in a structured fashion is one
    of the best ways to create a piece of performant and reliable software.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将性能问题分解为可以同时改进的小而可管理的子问题是一种有助于优化的转变。试图一次解决所有性能问题通常会让开发人员感到受挫和沮丧，并且经常导致许多性能努力失败。专注于当前系统中的瓶颈通常会产生结果。解决一个瓶颈通常会很快地发现另一个。例如，解决了CPU利用率问题后，您可能会发现系统的磁盘无法快速写入计算出的值。以结构化方式解决瓶颈是创建高性能和可靠软件的最佳方法之一。
- en: Optimization levels
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化级别
- en: 'Starting at the bottom of the pyramid in the following image, we can work our
    way up to the top. This diagram shows a suggested priority for making performance
    optimizations. The first two levels of this pyramid—the design level and algorithm
    and data structures level—will often provide more than ample real-world performance
    optimization targets. The following diagram shows an optimization strategy that
    is often efficient. Changing the design of a program alongside the algorithms
    and data structures are often the most efficient places to improve the speed and
    quality of code bases:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从下图的金字塔底部开始，我们可以逐步向上发展。这张图表显示了进行性能优化的建议优先级。这个金字塔的前两个级别——设计级别和算法和数据结构级别——通常会提供更多的现实世界性能优化目标。以下图表显示了一种通常有效的优化策略。改变程序的设计以及算法和数据结构往往是提高代码质量和速度的最有效的地方：
- en: '![](img/cda5e953-f4d8-49cc-97fc-2c030dfc3a3f.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cda5e953-f4d8-49cc-97fc-2c030dfc3a3f.png)'
- en: Design-level decisions often have the most measurable impact on performance.
    Determining goals during the design level can help to determine the best methodology
    for optimization. For example, if we are optimizing for a system that has slow
    disk I/O, we should prioritize lowering the number of calls to our disk. Inversely,
    if we are optimizing for a system that has limited compute resources, we need
    to calculate only the most essential values needed for our program's response.
    Creating a detailed design document at the inception of a new project will help
    with understanding where performance gains are important and how to prioritize
    time within the project. Thinking from a perspective of transferring payloads
    within a compute system can often lead to noticing places where optimization can
    occur. We will talk more about design patterns in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency.*
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设计层面的决策通常对性能有最明显的影响。在设计层面确定目标可以帮助确定最佳的优化方法。例如，如果我们正在为一个具有缓慢磁盘I/O的系统进行优化，我们应该优先降低对磁盘的调用次数。相反，如果我们正在为一个具有有限计算资源的系统进行优化，我们需要计算程序响应所需的最基本值。在新项目开始时创建详细的设计文档将有助于理解性能提升的重要性以及如何在项目中优先考虑时间。从在计算系统内传输有效载荷的角度思考往往会导致注意到优化可能发生的地方。我们将在《理解并发》的[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中更多地讨论设计模式。
- en: Algorithm and data structure decisions often have a measurable performance impact
    on a computer program. We should focus on trying to utilize constant O(1), logarithmic
    O(log n), linear O(n), and log-linear O(n log n) functions while writing performant
    code. Avoiding quadratic complexity O(n²) at scale is also important for writing
    scalable programs. We will talk more about O notation and its relation to Go in
    [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and
    Algorithms*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 算法和数据结构的决策通常会对计算机程序产生可衡量的性能影响。在编写高性能代码时，我们应该专注于尝试利用常数O(1)、对数O(log n)、线性O(n)和对数线性O(n
    log n)函数。在规模上避免二次复杂度O(n²)对于编写可扩展的程序也很重要。我们将在《数据结构和算法》的[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中更多地讨论O符号及其与Go语言的关系。
- en: A brief history of Go
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go的简要历史
- en: 'Robert Griesemer, Rob Pike, and Ken Thompson created the Go programming language
    in 2007\. It was originally designed as a general-purpose language with a keen
    focus on systems programming. The creators designed the Go language with a couple
    of core tenets in mind:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Robert Griesemer、Rob Pike和Ken Thompson于2007年创建了Go编程语言。最初，它被设计为一种以系统编程为重点的通用语言。语言的创造者们在设计Go语言时考虑了一些核心原则：
- en: Static typing
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型
- en: Runtime efficiency
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行效率
- en: Readable
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性
- en: Usable
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Easy to learn
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易学习
- en: High-performance networking and multiprocessing
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能网络和多处理
- en: Go was publicly announced in 2009 and v1.0.3 was released on March 3, 2012\.
    At the time of the writing of this book, Go version 1.14 has been released, and
    Go version 2 is on the horizon. As mentioned, one of Go's initial core architecture
    considerations was to have high-performance networking and multiprocessing. This
    book will cover a lot of the design considerations that Griesemer, Pike, and Thompson
    have implemented and evangelized on behalf of their language. The designers created
    Go because they were unhappy with some of the choices and directions that were
    made in the C++ language. Long-running complications on large distributed compile
    clusters were a main source of pain for the creators. During this time, the authors
    started learning about the next C++ programming language release, dubbed C++x11\.
    This C++ release had very many new features being planned, and the Go team decided
    they wanted to adopt an idiom of *less is more* in the computing language that
    they were using to do their work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Go于2009年公开宣布，v1.0.3于2012年3月3日发布。在撰写本书时，Go版本1.14已发布，Go版本2也即将推出。正如前面提到的，Go最初的核心架构考虑之一是具有高性能的网络和多处理。本书将涵盖Griesemer、Pike和Thompson实施和宣传的许多设计考虑。设计者们创建Go是因为他们对C++语言中做出的一些选择和方向感到不满。长时间运行的大型分布式编译集群是创作者们的主要痛点。在此期间，作者们开始了解下一个C++编程语言版本的发布，被称为C++x11。这个C++版本计划中有很多新功能，Go团队决定他们想要在他们的工作中采用“少即是多”的计算语言习惯。
- en: The authors of the language had their first meeting where they discussed starting
    with the C programming language, building features and removing extraneous functionality
    they didn't feel was important to the language. The team ended up starting from
    scratch, only borrowing some of the most atomic pieces of C and other languages
    they were comfortable with writing. After their work started to take form, they
    realized that they were taking away some of the core traits of other languages,
    notably the absence of headers, circular dependencies, and classes. The authors
    believe that even with the removal of many of these fragments, Go still can be
    more expressive than its predecessors.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的作者们在第一次会议上讨论了从C编程语言开始，构建功能并删除他们认为对语言不重要的多余功能。最终，团队从零开始，只借用了一些最基本的C和其他编程语言的部分。在他们的工作开始形成后，他们意识到他们正在剥夺其他语言的一些核心特性，尤其是没有头文件、循环依赖和类。作者们相信，即使剥夺了许多这些片段，Go仍然可以比其前身更具表现力。
- en: The Go standard library
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go标准库
- en: The standard library in Go follows this same pattern. It has been designed with
    both simplicity and functionality in mind. Adding slices, maps, and composite
    literals to the standard library helped the language to become opinionated early.
    Go's standard library lives within `$GOROOT` and is directly importable. Having
    these default data structures built into the language enables developers to use 
    these data structures effectively.  The standard library packages are bundled
    in with the language distribution and are available immediately after you install
    Go. It is often mentioned that the standard library is a solid reference on how
    to write idiomatic Go. The reasoning on standard library idiomatic Go is these
    core library pieces are written clearly, concisely, and with quite a bit of context.
    They also add small but important implementation details well, such as being able
    to set timeouts for connections and being explicitly able to gather data from
    underlying functions. These language details have helped the language to flourish.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库遵循相同的模式。它旨在同时考虑简单性和功能性。将切片，映射和复合文字添加到标准库有助于语言早期变得有见地。Go的标准库位于`$GOROOT`中，并且可以直接导入。将这些默认数据结构内置到语言中使开发人员能够有效地使用这些数据结构。标准库包与语言分发捆绑在一起，并在安装Go后立即可用。经常提到标准库是如何编写符合惯用法的Go的可靠参考。标准库符合惯用法的原因是这些核心库部分清晰，简洁，并且具有相当多的上下文。它们还很好地添加了一些小但重要的实现细节，例如能够为连接设置超时，并明确地能够从底层函数中收集数据。这些语言细节有助于语言的繁荣。
- en: 'Some of the notable Go runtime features include the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显着的Go运行时特性包括以下内容：
- en: Garbage collection for safe memory management (a concurrent, tri-color, mark-sweep
    collector)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集以进行安全内存管理（并发的，三色的，标记-清除收集器）
- en: Concurrency to support more than one task simultaneously (more about this in
    [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml), *Understanding Concurrency*)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发性以支持同时执行多个任务（关于这一点，可以在[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中了解更多，*理解并发性*）
- en: Stack management for memory optimization (segmented stacks were used in the
    original implementation; stack copying is the current incantation of Go stack
    management)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈管理以进行内存优化（原始实现中使用了分段堆栈；当前的Go堆栈管理采用了堆栈复制）
- en: Go toolset
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go工具集
- en: Go's binary release also includes a vast toolset for creating optimized code.
    Within the Go binary, the `go` command has a lot of functions that help to build,
    deploy, and validate code. Let's discuss a couple of the core pieces of functionality
    as they relate to performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Go的二进制发布还包括用于创建优化代码的庞大工具集。在Go二进制文件中，`go`命令具有许多功能，可帮助构建，部署和验证代码。让我们讨论一些与性能相关的核心功能。
- en: Godoc is Go's documentation tool that keeps the cruxes of documentation at the
    forefront of program development. A clean implementation, in-depth documentation,
    and modularity are all core pieces of building a scalable, performant system.
    Godoc helps with accomplishing these goals by auto-generating documentation. Godoc
    extracts and generates documentation from packages it finds within `$GOROOT` and
    `$GOPATH`. After generating this documentation, Godoc runs a web server and displays
    the generated documentation as a web page. Documentation for the standard library
    can be seen on the Go website. As an example, the documentation for the standard
    library `pprof` package can be found at [https://golang.org/pkg/net/http/pprof/](https://golang.org/pkg/net/http/pprof/).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Godoc是Go的文档工具，将文档的要点放在程序开发的前沿。清晰的实现，深入的文档和模块化都是构建可扩展，高性能系统的核心要素。Godoc通过自动生成文档来帮助实现这些目标。Godoc从在`$GOROOT`和`$GOPATH`中找到的包中提取和生成文档。生成文档后，Godoc运行一个Web服务器，并将生成的文档显示为Web页面。可以在Go网站上查看标准库的文档。例如，标准库`pprof`包的文档可以在[https://golang.org/pkg/net/http/pprof/](https://golang.org/pkg/net/http/pprof/)找到。
- en: The addition of `gofmt` (Go's code formatting tool) to the language brought
    a different kind of performance to Go. The inception of `gofmt` allowed Go to
    be very opinionated when it comes to code formatting. Having precise enforced
    formatting rules makes it possible to write Go in a way that is sensible for the
    developer whilst letting the tool format the code to follow a consistent pattern
    across Go projects. Many developers have their IDE or text editor perform a `gofmt`
    command when they save the file that they are composing. Consistent code formatting
    reduces the cognitive load and allows the developer to focus on other aspects
    of their code, rather than determining whether to use tabs or spaces to indent
    their code. Reducing the cognitive load helps with developer momentum and project
    velocity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将`gofmt`（Go的代码格式化工具）添加到语言中为Go带来了不同类型的性能。`gofmt`的诞生使得Go在代码格式化方面非常有见地。强制执行精确的格式化规则使得可以以对开发人员有意义的方式编写Go，同时让工具按照一致的模式格式化代码，从而使得在Go项目中保持一致的模式成为可能。许多开发人员在保存他们正在编写的文件时，让他们的IDE或文本编辑器执行`gofmt`命令。一致的代码格式化减少了认知负荷，并允许开发人员专注于代码的其他方面，而不是确定是否使用制表符或空格来缩进他们的代码。减少认知负荷有助于开发人员的动力和项目速度。
- en: Go's build system also helps with performance. The `go build` command is a powerful
    tool that compiles packages and their dependencies. Go's build system is also
    helpful in dependency management. The resulting output from the build system is
    a compiled, statically linked binary that contains all of the necessary elements
    to run on the platform that you've compiled for. `go module` (a new feature with
    preliminary support introduced in Go 1.11 and finalized in Go 1.13) is a dependency
    management system for Go. Having explicit dependency management for a language
    helps to deliver a consistent experience with groupings of versioned packages
    as a cohesive unit, allowing for more reproducible builds. Having reproducible
    builds helps developers to create binaries via a verifiable path from the source
    code. The optional step to create a vendored directory within your project also
    helps with locally storing and satisfying dependencies for your project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Go的构建系统也有助于性能。`go build`命令是一个强大的工具，用于编译包及其依赖项。Go的构建系统还有助于依赖管理。构建系统的输出结果是一个编译的、静态链接的二进制文件，其中包含了在您为其编译的平台上运行所需的所有必要元素。`go
    module`（Go 1.11中引入的初步支持功能，Go 1.13中最终确定）是Go的依赖管理系统。语言的显式依赖管理有助于以版本化包的组合作为一个统一单元提供一致的体验，从而实现更可重现的构建。可重现的构建有助于开发人员通过源代码的可验证路径创建二进制文件。在项目中创建一个vendored目录的可选步骤也有助于本地存储和满足项目的依赖关系。
- en: 'Compiled binaries are also an important piece of the Go ecosystem. Go also
    lets you build your binaries for other target environments, which can be useful
    if you need to cross-compile a binary for another computer architecture. Having
    the ability to build a binary that can run on any platform helps you to rapidly
    iterate and test your code to find bottlenecks on alternate architectures before
    they become more difficult to fix. Another key feature of the language is that
    you can compile a binary on one machine with the OS and architecture flags, and
    that binary is executable on another system. This is crucial when the build system
    has high amounts of system resources and the build target has limited computing
    resources. Building a binary for two architectures is as simple as setting build
    flags:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后的二进制文件也是Go生态系统中的重要组成部分。Go还允许您为其他目标环境构建二进制文件，这在需要为另一台计算机架构交叉编译二进制文件时非常有用。能够构建可以在任何平台上运行的二进制文件，有助于您快速迭代和测试代码，以便在它们变得更难以修复之前，在其他架构上找到瓶颈。语言的另一个关键特性是，您可以在一个带有OS和架构标志的机器上编译二进制文件，然后在另一个系统上执行该二进制文件。当构建系统具有大量系统资源而构建目标具有有限的计算资源时，这一点至关重要。为两种架构构建二进制文件就像设置构建标志一样简单：
- en: 'To build a binary for macOS X on an x86_64 architecture, the following execution
    pattern is used:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64架构的macOS X上构建二进制文件时，使用以下执行模式：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To build a binary for Linux on an ARM architecture, the following execution
    pattern is used:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM架构的Linux上构建二进制文件时，使用以下执行模式：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can find a list of all the valid combinations of `GOOS` and `GOARCH` using
    the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令找到所有有效的`GOOS`和`GOARCH`组合的列表：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This can be helpful in allowing you to see all of the CPU architectures and
    OSes that the Go language can compile binaries for.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于您查看Go语言可以为其编译二进制文件的所有CPU架构和操作系统。
- en: Benchmarking overview
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试概述
- en: The concept of benchmarking will also be a core tenant in this book. Go's testing
    functionality has performance built in as a first-class citizen. Being able to
    trigger a test benchmark during your development and release processes makes it
    possible to continue to deliver performant code. As new side effects are introduced,
    features are added, and code complexity increases, it's important to have a method
    for validating performance regression across a code base. Many developers add
    benchmarking results to their continuous integration practices to ensure that
    their code continues to be performant with all of the new pull requests added
    to a repository. You can also use the `benchstat` utility provided in the [golang.org/x/perf/cmd/benchstat](http://golang.org/x/perf/cmd/benchstat)
    package to compare statistics about benchmarks. The following sample repository
    has an example of benchmarking the standard library's sort functions, at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/1-introduction](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/1-introduction).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的概念也将是本书的核心要点。Go的测试功能内置了性能。在开发和发布过程中触发测试基准是可能的，这使得继续交付高性能代码成为可能。随着引入新的副作用、添加功能和代码复杂性的增加，验证代码库中性能回归的方法变得很重要。许多开发人员将基准测试结果添加到其持续集成实践中，以确保其代码在向存储库添加的所有新拉取请求中继续保持高性能。您还可以使用[golang.org/x/perf/cmd/benchstat](http://golang.org/x/perf/cmd/benchstat)包中提供的`benchstat`实用程序来比较基准测试的统计信息。以下示例存储库演示了对标准库的排序函数进行基准测试的示例，网址为[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/1-introduction](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/1-introduction)。
- en: Having testing and benchmarking married closely in the standard library encourages
    performance testing as part of your code release process. It's always important
    to remember that benchmarks are not always indicative of real-world performance
    scenarios, so take the results you receive from them with a grain of salt. Logging,
    monitoring, profiling, and tracing a running system (as will be discussed in [Chapter
    12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml), *Profiling Go Code*; [Chapter
    13](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml), *Tracing Go Code*; and [Chapter
    15](88e04ed3-8f84-43a9-ac4a-bf9d26b88e68.xhtml), *Comparing Code Quality Across
    Versions*) can help to validate the assumptions that you have made with your benchmarking
    after you've committed the code you are working on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中密切结合测试和基准测试鼓励将性能测试作为代码发布过程的一部分。重要的是要记住，基准测试并不总是表明真实世界的性能场景，因此要对从中获得的结果持保留态度。记录、监控、分析和跟踪运行中的系统（将在第12章《Go代码性能分析》、第13章《Go代码跟踪》和第15章《跨版本比较代码质量》中讨论）可以帮助验证您在进行基准测试后对代码所做的假设。
- en: The ideology behind Go performance
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go性能背后的思想
- en: Much of Go's performance stance is gained from concurrency and parallelism.
    Goroutines and channels are often used to perform many requests in parallel. The
    tools available for Go help to achieve near C-like performance, with very readable
    semantics. This is one of the many reasons that Go is commonly used by developers
    in large-scale solutions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Go的许多性能立场都来自并发和并行。Goroutines和channels经常用于并行执行许多请求。Go提供的工具有助于实现接近C语言的性能，同时语义清晰易读。这是Go常被开发人员在大规模解决方案中使用的许多原因之一。
- en: Goroutines – performance from the start
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines - 从一开始就有性能
- en: When Go was conceived, multi-core processors were beginning to become more and
    more commonplace in commercially available commodity hardware. The authors of
    the Go language recognized a need for concurrency within their new language. Go
    makes concurrent programming easy with goroutines and channels (which we will
    discuss in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml), *Understanding
    Concurrency*). Goroutines, lightweight computation threads that are distinct from
    OS threads, are often described as one of the best features of the language. Goroutines
    execute their code in parallel and complete when their work is done. The startup
    time for a goroutine is faster than the startup time for a thread, which allows
    a lot more concurrent work to occur within your program. Compared to a language
    such as Java that relies on OS threads, Go can be much more efficient with its
    multiprocessing model. Go is also intelligent about blocking operations with respect
    to goroutines. This helps Go to be more performant in memory utilization, garbage
    collection, and latency. Go's runtime uses the `GOMAXPROCS` variable to multiplex
    goroutines onto real OS threads. We will learn more about goroutines in [Chapter
    2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and Algorithms*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的诞生是在多核处理器开始在商用硬件中变得越来越普遍的时候。Go语言的作者意识到他们的新语言需要并发性。Go通过goroutines和channels（我们将在第3章《理解并发性》中讨论）使并发编程变得简单。Goroutines是轻量级的计算线程，与操作系统线程不同，通常被描述为该语言的最佳特性之一。Goroutines并行执行它们的代码，并在工作完成时完成。与依赖于操作系统线程的Java等语言相比，Goroutines的启动时间比线程的启动时间更快，这允许程序中发生更多的并发工作。Go还对于与goroutines相关的阻塞操作非常智能。这有助于Go在内存利用、垃圾回收和延迟方面更加高效。Go的运行时使用`GOMAXPROCS`变量将goroutines复用到真实的操作系统线程上。我们将在第2章《数据结构和算法》中学习更多关于goroutines的知识。
- en: Channels – a typed conduit
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Channels - 一种类型的导管
- en: Channels provide a model to send and receive data between goroutines, whilst
    skipping past synchronization primitives provided by the underlying platform.
    With properly thought-out goroutines and channels, we can achieve high performance.
    Channels can be both buffered and unbuffered, so the developer can pass a dynamic
    amount of data through an open channel until the value has been received by the
    receiver, at which time the channel is unblocked by the sender. If the channel
    is buffered, the sender blocks for the given size of the buffer. Once the buffer
    has been filled, the sender will unblock the channel. Lastly, the `close()` function
    can be invoked to indicate that the channel will not receive any more values.
    We will learn more about channels in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Channels提供了在goroutines之间发送和接收数据的模型，同时跳过底层平台提供的同步原语。通过深思熟虑的goroutines和channels，我们可以实现高性能。Channels可以是有缓冲的，也可以是无缓冲的，因此开发人员可以通过开放的通道传递动态数量的数据，直到接收者接收到值时，发送者解除通道的阻塞。如果通道是有缓冲的，发送者将会阻塞直到缓冲区填满。一旦缓冲区填满，发送者将解除通道的阻塞。最后，`close()`函数可以被调用来指示通道将不再接收任何值。我们将在第3章《理解并发性》中学习更多关于channels的知识。
- en: C-comparable performance
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C-可比性能
- en: Another initial goal was to approach the performance of C for comparable programs.
    Go also has extensive profiling and tracing tools baked into the language that
    we'll learn about in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml), *Profiling
    Go Code*, and [Chapter 13](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml), *Tracing
    Go Code*. Go gives developers the ability to see a breakdown of goroutine usage,
    channels, memory and CPU utilization, and function calls as they pertain to individual
    calls. This is valuable because Go makes it easy to troubleshoot performance problems
    with data and visualizations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个最初的目标是接近C语言对于类似程序的性能。Go语言还内置了广泛的性能分析和跟踪工具，我们将在第12章“Go代码性能分析”和第13章“Go代码跟踪”中了解到。Go语言让开发人员能够查看goroutine使用情况、通道、内存和CPU利用率，以及与个别调用相关的函数调用的细分。这是非常有价值的，因为Go语言使得通过数据和可视化轻松解决性能问题。
- en: Large-scale distributed systems
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大规模分布式系统
- en: Go is often used in large-scale distributed systems due to its operational simplicity
    and its built-in network primitives in the standard library. Being able to rapidly
    iterate whilst developing is an essential part of building a robust, scalable
    system. High network latency is often an issue in distributed systems, and the
    Go team has worked to try and alleviate this concern on their platform. From standard
    library network implementations to making gRPC a first-class citizen for passing
    buffered messaging between clients and servers on a distributed platform, the
    Go language developers have put distributed systems problems at the forefront
    of the problem space for their language and have come up with some elegant solutions
    for these complex problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其操作简单性和标准库中内置的网络原语，Go经常用于大规模分布式系统。在开发过程中能够快速迭代是构建强大、可扩展系统的重要部分。在分布式系统中，高网络延迟经常是一个问题，Go团队一直致力于解决这个平台上的问题。从标准库网络实现到使gRPC成为在分布式平台上在客户端和服务器之间传递缓冲消息的一等公民，Go语言开发人员已经将分布式系统问题置于他们语言问题空间的前沿，并为这些复杂问题提出了一些优雅的解决方案。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the core concepts of performance in computer science.
    We also learned some of the history of the Go computer programming language and
    how its inception ties in directly with performance work. Lastly, we learned that
    Go is used in a myriad of different cases because of the utility, flexibility,
    and extensibility of the language. This chapter has introduced concepts that will
    continually be built upon in this book, allowing you to rethink the way you are
    writing your Go code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了计算机科学中性能的核心概念。我们还了解了Go编程语言的一些历史，以及它的起源与性能工作直接相关。最后，我们了解到由于语言的实用性、灵活性和可扩展性，Go语言在许多不同的情况下被使用。本章介绍了将在本书中不断建立的概念，让您重新思考编写Go代码的方式。
- en: In [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures
    and Algorithms*, we'll dive into data structures and algorithms. We'll learn about
    different algorithms, their Big O notation, and how these algorithms are constructed
    in Go. We'll also learn about how these theoretical algorithms relate to real-world
    problems and write performant Go to serve large amounts of requests quickly and
    efficiently. Learning more about these algorithms will help you to become more
    efficient in the second layer of the optimizations triangle that was laid out
    earlier in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章“数据结构和算法”中，我们将深入研究数据结构和算法。我们将学习不同的算法、它们的大O表示法，以及这些算法在Go语言中的构建方式。我们还将了解这些理论算法如何与现实世界的问题相关，并编写高性能的Go代码，以快速高效地处理大量请求。了解更多关于这些算法的知识将帮助您在本章早期提出的优化三角形的第二层中变得更加高效。
