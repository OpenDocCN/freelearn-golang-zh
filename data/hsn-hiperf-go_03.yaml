- en: Data Structures and Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法
- en: Data structures and algorithms are the basic units of building software, notably
    complex, performance software. Understanding them helps us think about how to
    impactfully organize and manipulate data in order to write effective, performant
    software. This chapter will include explanations of different data structures
    and algorithms, as well as how their Big O notation is impacted.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构和算法是构建软件的基本单元，尤其是复杂的性能软件。了解它们有助于我们思考如何有影响地组织和操作数据，以编写有效的、高性能的软件。本章将包括不同数据结构和算法的解释，以及它们的大O符号受到的影响。
- en: As we mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml),
    *Introduction to Performance in Go*, design-level decisions very often have the
    most measurable impact on performance. The least expensive calculation is the
    one you don't have to make – if you work toward optimizing your design early on
    while architecting your software, you can save yourself from a lot of performance
    penalties down the line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml)中提到的，“Go性能简介”，设计层面的决策往往对性能有着最明显的影响。最廉价的计算是您不必进行的计算——如果您在软件架构时早期努力优化设计，就可以避免很多性能惩罚。
- en: 'In this chapter, we will be discussing the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Benchmarking by utilizing Big O notation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用大O符号进行基准测试
- en: Search and sort algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和排序算法
- en: Trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列
- en: Creating simple data structures that don't contain superfluous information will
    help you write practical, performant code. Algorithms will also help improve the
    performance of the data structures that you have.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不包含多余信息的简单数据结构将帮助您编写实用的、高性能的代码。算法也将有助于改善您拥有的数据结构的性能。
- en: Understanding benchmarking
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基准测试
- en: Metrics and measurement are at the root of optimization. The adage *You can't
    improve what you can't measure* rings true with performance. To be able to make
    intelligent decisions about performance optimizations, we must continuously measure
    the performance of the functions we are trying to optimize.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 度量和测量是优化的根本。谚语“不能衡量的东西无法改进”在性能方面是正确的。为了能够对性能优化做出明智的决策，我们必须不断地测量我们试图优化的函数的性能。
- en: As we mentioned in [Chapter 1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml),
    *Introduction to Performance in Go*, the Go creators made performance a forethought
    in their language design. The Go testing package ([https://golang.org/pkg/testing/](https://golang.org/pkg/testing/))
    is used to test Go code in a systematic way. The testing package is a fundamental
    part of the Go language. This package also includes a helpful built-in benchmarking
    functionality. This functionality, which is invoked by `go test -bench`, runs
    the benchmarks that you've defined for your functions. The results from your tests
    can also be saved and viewed at a later date. Having previous results of benchmarks
    from your functions available allows you to track the long-term changes that you
    are making in your functions and their outcomes. Benchmarking dovetails nicely
    with profiling and tracing to retrieve an accurate report of the state of our
    system. We will learn more about profiling and tracing in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml),
    *Profiling Go Code*, and [Chapter 13](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml),
    *Tracing Go Code*. As we are benchmarking, it's important to note that CPU frequency
    scaling should be disabled (see [https://blog.golang.org/profiling-go-programs](https://blog.golang.org/profiling-go-programs)).
    This will allow for more consistent benchmarking across benchmarking runs. An
    included bash script for disabling frequency scaling can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/frequency_scaling_governor_diable.bash](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/frequency_scaling_governor_diable.bash).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml)中提到的，“Go性能简介”，Go的创建者在语言设计中将性能作为首要考虑。Go测试包（[https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)）用于系统化地测试Go代码。测试包是Go语言的基本组成部分。该包还包括一个有用的内置基准测试功能。通过`go
    test -bench`调用的这个功能运行您为函数定义的基准测试。测试结果也可以保存并在以后查看。拥有函数的基准测试以前的结果可以让您跟踪您在函数和它们结果中所做的长期变化。基准测试与性能分析和跟踪相结合，可以获取系统状态的准确报告。我们将在[第12章](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml)“Go代码性能分析”和[第13章](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml)“Go代码跟踪”中学习更多关于性能分析和跟踪的知识。在进行基准测试时，重要的是要注意禁用CPU频率调整（参见[https://blog.golang.org/profiling-go-programs](https://blog.golang.org/profiling-go-programs)）。这将确保在基准测试运行中更加一致。可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/frequency_scaling_governor_diable.bash](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/frequency_scaling_governor_diable.bash)找到一个包含的禁用频率调整的bash脚本。
- en: Benchmark execution
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试执行
- en: 'Benchmarks in Go use the axiom of starting with the word `Benchmark` (with
    a capital B) in the function call to denote that they are a benchmark and that
    they should use the benchmark functionality. To execute the benchmarks that you''ve
    defined for your code in your test package, you can use the `-bench=.` flag in
    your `go test` execution. This testing flag ensures all your benchmarking tests
    are run. An example of a benchmark is shown in the following code block:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，基准测试使用在函数调用中以大写B开头的单词`Benchmark`来表示它们是基准测试，并且应该使用基准测试功能。要执行您在测试包中为代码定义的基准测试，可以在`go
    test`执行中使用`-bench=.`标志。这个测试标志确保运行所有您定义的基准测试。以下是一个基准测试的示例代码块：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this (admittedly simple) benchmark, we are iterating over our `fmt.Sprintf`
    statement b.N times. The benchmarking package executes and runs our `Sprintf`
    statement. During our test run, `b.N` is adjusted in the benchmark test until
    this function can be timed reliably. By default, a go benchmark test is run for
    1 second in order to get a statistically significant result set.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个（诚然简单的）基准测试中，我们对我们的 `fmt.Sprintf` 语句进行了 b.N 次迭代。基准测试包执行并运行我们的 `Sprintf` 语句。在我们的测试运行中，基准测试会调整
    `b.N`，直到可以可靠地计时该函数。默认情况下，go 基准测试会运行 1 秒，以获得具有统计学意义的结果集。
- en: 'There are a number of flags that are available during the invocation of the
    benchmarking utility. A few helpful flags for benchmarking can be found in the
    following table:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用基准测试实用程序时有许多可用的标志。以下表格列出了一些有用的基准测试标志：
- en: '| **Flag** | **Use Case** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **用例** |'
- en: '| `-benchtime t` | Run enough iterations of the test to take the defined t
    duration. Increasing this value will run more iterations of `b.N`. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `-benchtime t` | 运行足够的测试迭代以达到定义的 t 时长。增加此值将运行更多的 `b.N` 迭代。 |'
- en: '| `-count n` | Run each test n times. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `-count n` | 每个测试运行 n 次。 |'
- en: '| `-benchmem` | Turn on memory profiling for your test. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `-benchmem` | 为你的测试打开内存分析。 |'
- en: '| `-cpu x,y,z` | Specify a list of `GOMAXPROCS` values for which the benchmarks
    should be executed. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `-cpu x,y,z` | 指定应执行基准测试的 `GOMAXPROCS` 值列表。 |'
- en: 'The following is an example of benchmark execution. In our example execution,
    we are profiling our existing Hello benchmark twice. We''re also using four `GOMAXPROCS`,
    viewing the memory profiling for our test, and performing these requests for 2
    seconds instead of the default 1-second test invocation. We can invoke our `go
    test -bench` functionality like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基准测试执行的示例。在我们的示例执行中，我们两次对现有的 Hello 基准测试进行了分析。我们还使用了四个 `GOMAXPROCS`，查看了我们测试的内存分析，并将这些请求执行了
    2 秒，而不是默认的 1 秒测试调用。我们可以像这样调用我们的 `go test -bench` 功能：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A benchmark will run until the function returns, fails, or skips. The results
    of the benchmark are returned as a standard error once the test has completed.
    After the tests have completed and the results have been collated, we can make
    smart comparisons about the results of our benchmarks. Our following result shows
    an example test execution and the  resulting output from the preceding `BenchmarkHello`
    function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试将一直运行，直到函数返回、失败或跳过。一旦测试完成，基准测试的结果将作为标准错误返回。在测试完成并整理结果后，我们可以对基准测试的结果进行智能比较。我们的下一个结果显示了一个示例测试执行以及前面的
    `BenchmarkHello` 函数的结果输出：
- en: '![](img/96668579-0851-402f-af1e-051278ef6c8d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96668579-0851-402f-af1e-051278ef6c8d.png)'
- en: 'In our output result, we can see a couple of different bits of data being returned:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出结果中，我们可以看到返回了一些不同的数据：
- en: '`GOOS` and `GOARCH` (which were discussed in the *Go toolset* section of [Chapter
    1](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml), *Introduction to Performance in
    Go*)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOOS` 和 `GOARCH`（在[第1章](27d9fd37-672c-499b-88b9-89b9990117ed.xhtml)的*Go工具集*部分讨论过）'
- en: 'The name of the benchmark that was run, followed by the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行的基准测试的名称，然后是以下内容：
- en: '-8: The number of `GOMAXPROCS` that were used to execute the tests.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -8：用于执行测试的 `GOMAXPROCS` 的数量。
- en: '10000000: The number of times our loop ran to gather the necessary data.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10000000：我们的循环运行了这么多次以收集必要的数据。
- en: '112 ns/op: The speed per loop during our test.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 112 ns/op：我们测试中每次循环的速度。
- en: 'PASS: Indicates the end state of our benchmark run.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PASS：表示我们的基准测试运行的结束状态。
- en: The final line of the test, with a compilation of the end state of our test
    run (ok), the path that we ran the test on, and the total time of our test run.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的最后一行，编译测试运行的结束状态（ok），我们运行测试的路径以及测试运行的总时间。
- en: Real-world benchmarking
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实世界的基准测试
- en: 'While you are running the benchmarks in this book, be sure to remember that
    benchmarks aren''t the be-all and end-all for performance results. Benchmarking
    has both positives and drawbacks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中运行基准测试时，请记住基准测试并非性能结果的全部和终极标准。基准测试既有积极的一面，也有缺点：
- en: 'The positives of benchmarking are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的积极面如下：
- en: Surfaces potential problems before they become unwieldy
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在问题变得难以控制之前就能发现潜在问题
- en: Helps developers have a deeper understanding of their code
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助开发人员更深入地了解他们的代码
- en: Can identify potential bottlenecks in the design and data structures and algorithms
    stages
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以识别设计和数据结构以及算法阶段的潜在瓶颈
- en: 'The drawbacks of benchmarking are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的缺点如下：
- en: Needs to be completed on a given cadence for meaningful results
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要按照给定的节奏进行，才能产生有意义的结果
- en: Data collation can be difficult
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据整理可能会很困难
- en: Does not always yield a meaningful result for the problem at hand
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非总是能为手头的问题产生有意义的结果
- en: Benchmarking is good for comparison. Benchmarking two things against one another
    on the same system can yield relatively consistent results. If you have the ability
    to run longer running benchmarks, it'll probably give you a much more indicative
    result of how a function is performing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试适用于比较。在同一系统上将两个事物进行基准测试可以得到相对一致的结果。如果你有能力运行更长时间的基准测试，可能会更准确地反映函数的性能。
- en: 'The Go `benchstat` ([https://godoc.org/golang.org/x/perf/cmd/benchstat](https://godoc.org/golang.org/x/perf/cmd/benchstat))
    package is a useful utility that helps you compare two benchmarks. Comparisons
    are very important in order to deduce whether or not the change you made to your
    function had a positive or negative impact on the system. You can install `benchstat`
    by using the `go get` utility:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Go `benchstat` ([https://godoc.org/golang.org/x/perf/cmd/benchstat](https://godoc.org/golang.org/x/perf/cmd/benchstat))
    包是一个有用的实用程序，它帮助你比较两个基准测试。比较非常重要，以便推断你对函数所做的更改对系统是否产生了积极或消极的影响。你可以使用 `go get` 实用程序安装
    `benchstat`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Consider the following comparison test. We are going to test the marshaling
    of a single JSON structure with three elements, compared to the marshaling of
    two JSON arrays with five elements. You can find the source for these at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/Benchstat-comparison](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/Benchstat-comparison).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下比较测试。我们将测试单个JSON结构的编组，其中包含三个元素，与两个包含五个元素的JSON数组的编组进行比较。您可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/Benchstat-comparison](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/Benchstat-comparison)找到这些的源代码。
- en: 'To get an example comparison operator, we execute our benchmarks against our
    tests, as shown in the following code snippet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到一个示例比较运算符，我们执行我们的基准测试，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This produces an HTML table that can be used to validate the largest delta
    at execution time. As shown in the following screenshot, adding even a small amount
    of complexity to our data structure and the number of elements we process makes
    a fairly substantial change to the execution time of the function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个HTML表格，用于验证执行时间的最大增量。如下图所示，即使对我们的数据结构和我们处理的元素数量增加了一点复杂性，也会对函数的执行时间产生相当大的变化：
- en: '![](img/7c08f7d1-7c30-4e40-b081-c9c6165f057d.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c08f7d1-7c30-4e40-b081-c9c6165f057d.png)'
- en: Quickly identifying the performance pain points for your end users can help
    you determine the path to writing performant software.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 快速识别终端用户的性能痛点可以帮助您确定编写高性能软件的路径。
- en: In the next section, we will see what Big O notation is.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到大O符号是什么。
- en: Introducing Big O notation
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍大O符号
- en: Big O notation is a good way to approximate the speed in which the algorithm
    you've chosen will change with the size of the data that's passed to your algorithm.
    Big O notation is often described as the growth behavior of a function, specifically
    its upper limit. Big O notation is broken down into classes. The most common classes
    that are described are O(1), O(log n), O(n), O(n log n), O(n²), and O(2^n). Let's
    take a quick look at each of these algorithms, their definitions, and a practical
    example of them in Go.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号是一种近似算法速度的好方法，它会随着传递给算法的数据大小而改变。大O符号通常被描述为函数的增长行为，特别是它的上限。大O符号被分解为不同的类。最常见的类别是O(1)、O(log
    n)、O(n)、O(n log n)、O(n²)和O(2^n)。让我们快速看一下每个算法的定义和在Go中的实际示例。
- en: 'A graph of these common classes is as follows. The source code for generating
    this plot can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/2-data-structures-and-algorithms/plot/plot.go](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/2-data-structures-and-algorithms/plot/plot.go):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常见类别的图表如下。生成此图的源代码可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/2-data-structures-and-algorithms/plot/plot.go](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/2-data-structures-and-algorithms/plot/plot.go)找到：
- en: '![](img/034638be-b29a-488f-8aa3-c3493058aa2a.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/034638be-b29a-488f-8aa3-c3493058aa2a.png)'
- en: This Big O notation graph gives us a visual representation of the different
    algorithms that are commonly used in computer software.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大O符号图表给我们一个常用的计算机软件中不同算法的可视化表示。
- en: Practical Big O notation example
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际的大O符号示例
- en: 'If we take a sample dataset of 32 input values, we can quickly calculate the
    amount of time it''s going to take for each of our algorithms to complete. You''ll
    notice that the unit time to complete in the following table starts to grow very
    quickly. The practical Big O notation values are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拿一个包含32个输入值的样本数据集，我们可以快速计算每个算法完成所需的时间。您会注意到下表中的完成单位时间开始迅速增长。实际的大O符号值如下：
- en: '| **Algorithm** | **Unit time to complete** |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **完成的单位时间** |'
- en: '| O(1) | 1 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| O(1) | 1 |'
- en: '| O(log n) | 5 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| O(log n) | 5 |'
- en: '| O(n) | 32 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| O(n) | 32 |'
- en: '| O(n log n) | 160 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| O(n log n) | 160 |'
- en: '| O(n²) | 1,024 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| O(n²) | 1,024 |'
- en: '| O(2^n) | 4,294,967,296 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| O(2^n) | 4,294,967,296 |'
- en: As the unit time to complete gets larger, our code becomes less performant.
    We should strive to use the simplest algorithm possible to solve the dataset that
    we have at hand.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着完成单位时间的增加，我们的代码变得不那么高效。我们应该努力使用尽可能简单的算法来解决手头的数据集。
- en: Data structure operations and time complexity
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构操作和时间复杂度
- en: 'The following diagram contains some of the common data structure operations
    and their time complexities. As we mentioned previously, data structures are a
    core piece of computer science performance. Understanding the difference between
    different data structures is important when writing performant code. Having this
    table readily accessible can help the developer choose the right data structure
    operation for the task at hand, while considering the impact that this operation
    is going to have on performance:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表包含一些常见的数据结构操作及其时间复杂度。正如我们之前提到的，数据结构是计算机科学性能的核心部分。在编写高性能代码时，了解不同数据结构之间的差异是很重要的。有这个表格可以帮助开发人员在考虑操作对性能的影响时选择正确的数据结构操作：
- en: '![](img/7fcfc5a9-a9fb-4bf2-8891-b508ce6d290c.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fcfc5a9-a9fb-4bf2-8891-b508ce6d290c.png)'
- en: Common data structure operations (from bigocheatsheet.com) – thanks to Eric
    Rowell
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的数据结构操作（来自bigocheatsheet.com）- 感谢Eric Rowell
- en: This table shows us time and space complexity given specific data structures.
    It is a valuable performance reference tool.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格向我们展示了特定数据结构的时间和空间复杂度。这是一个有价值的性能参考工具。
- en: O(1) – constant time
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O(1) - 常数时间
- en: Algorithms written in constant time have an upper bound that does not depend
    on the input size of the algorithm. Constant time is an upper bound by a constant
    value, and thus won't take longer than the upper bound of the dataset. This type
    of algorithm is usually okay to add to a function in practice – it doesn't add
    a lot of processing time to your function. Make sure to note the constant that
    occurs here. A single array lookup adds a negligible amount of time to a function.
    Looking up thousands of individual values in an array may add some overhead. Performance
    is always relative, and it is important to maintain cognizant of the additional
    load you're adding to your functions, even if they only perform a trivial amount
    of processing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在常数时间内编写的算法具有不依赖于算法输入大小的上限。常数时间是一个常数值的上限，因此不会比数据集的上限时间长。这种类型的算法通常可以添加到实践中的函数中——它不会给函数增加太多的处理时间。请注意这里发生的常数。单个数组查找对函数的处理时间增加了可忽略的时间量。在数组中查找成千上万个单独的值可能会增加一些开销。性能始终是相对的，重要的是要注意您为函数增加的额外负载，即使它们只执行微不足道的处理。
- en: 'Examples of constant time are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 常数时间的例子如下：
- en: Accessing a single element in a map or an array
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问地图或数组中的单个元素
- en: Determining the modulus of a number
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定一个数字的模
- en: Stack push or stack pop
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈推送或堆栈弹出
- en: Deducing whether or not an integer is even or odd
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断一个整数是偶数还是奇数
- en: An example of a constant time algorithm in Go would be accessing a single element
    within an array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，一个常数时间算法的例子是访问数组中的单个元素。
- en: 'This would be written as follows in Go:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，这将被写成如下形式：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function has a Big O notation of O(1) because we only have to look at
    the individual defined value of `words[1]` in order to find the value we are looking
    for, that is, `bar`. As our array size in this example grows, the time to refer
    to an object within the array will remain constant. The normalized timings for
    this algorithm should all be the same, as shown in the following table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的大O符号是O(1)，因为我们只需要查看`words[1]`的单个定义值，就可以找到我们要找的值，也就是`bar`。在这个例子中，随着数组大小的增长，引用数组中的对象的时间将保持恒定。该算法的标准化时间应该都是相同的，如下表所示：
- en: '| **Number of items in the dataset** | **Resulting computation time** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **数据集中的项目数** | **结果计算时间** |'
- en: '| 10 | 1 second |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1秒 |'
- en: '| 100 | 1 second |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1秒 |'
- en: '| 1,000 | 1 second |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 1秒 |'
- en: 'Some sample code for O(1) notation is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: O(1)符号的一些示例代码如下：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'No matter how many items are in an array, the lookup for one element takes
    the same amount of time. In the following example output, we have arrays with
    three elements and 10 elements, respectively. Both take the same amount of time
    to execute and complete the same number of test iterations within their allotted
    time frame. This can be seen in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论数组中有多少项，查找一个元素的时间都是相同的。在下面的示例输出中，我们分别有三个元素和十个元素的数组。它们都花费了相同的时间来执行，并在规定的时间范围内完成了相同数量的测试迭代。这可以在下面的截图中看到：
- en: '![](img/11a995b2-cec2-497c-971e-264288fee4ae.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11a995b2-cec2-497c-971e-264288fee4ae.png)'
- en: This benchmark performs as we would expect it to. Both the `BenchmarkThree`
    and `BenchmarkTen` benchmarks took 0.26 ns/op, which should be consistent across
    array lookups.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试的表现与我们的预期一样。`BenchmarkThree`和`BenchmarkTen`基准测试都花费了0.26 ns/op，这应该在数组查找中保持一致。
- en: O(log n) - logarithmic time
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O(log n) - 对数时间
- en: 'Logarithmic growth is often represented as a partial sum of the harmonic series.
    This can be represented as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对数增长通常表示为调和级数的部分和。可以表示如下：
- en: '![](img/5a4ae3d3-8114-4368-9af5-cf2254c4bfd8.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a4ae3d3-8114-4368-9af5-cf2254c4bfd8.png)'
- en: An algorithm written in logarithmic time has a number of operations that tend
    toward zero as the size of the input decreases. An O(log n) algorithm cannot be
    used in an algorithm when all of the elements in the array must be accessed. O(log
    n) is usually considered an efficient algorithm when it is used by itself. One
    important concept to think about with respect to performance in logarithmic time
    is that search algorithms are commonly used with sort algorithms, which adds to
    the complexity of finding the solution. Depending on the size and complexity of
    the dataset, it can often make sense to sort the data before the search algorithm
    is executed. Note the input and output ranges for this test – additional tests
    were added to show the logarithmic growth of the resulting computation time of
    the dataset.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数时间内编写的算法具有随着输入大小减少而趋于零的操作数量。当必须访问数组中的所有元素时，不能在算法中使用O(log n)算法。当O(log n)单独使用时，通常被认为是一种高效的算法。关于对数时间性能的一个重要概念是，搜索算法通常与排序算法一起使用，这增加了找到解决方案的复杂性。根据数据集的大小和复杂性，通常在执行搜索算法之前对数据进行排序是有意义的。请注意此测试的输入和输出范围——额外的测试被添加以显示数据集的结果计算时间的对数增长。
- en: 'Some examples of logarithmic time algorithms are as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对数时间算法的例子如下：
- en: Binary search
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分查找
- en: Dictionary search
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典搜索
- en: 'The following table shows the normalized timings for logarithmic time:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了对数时间的标准化时间：
- en: '| **Number of items in the dataset** | **Resulting computation time** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **数据集中的项目数** | **结果计算时间** |'
- en: '| 10 | 1 second |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1秒 |'
- en: '| 100 | 2 seconds |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 2秒 |'
- en: '| 1,000 | 3 seconds |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 3秒 |'
- en: 'Go''s standard library has a function called `sort.Search()`. It has been included
    in the following snippet for reference:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go的标准库有一个名为`sort.Search()`的函数。以下代码片段中已包含了它以供参考：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code sample can be found in the standard library at [https://golang.org/src/sort/search.go](https://golang.org/src/sort/search.go).
    The code and benchmark for an O(log n) function can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-logn](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-logn).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例可以在标准库中找到[https://golang.org/src/sort/search.go](https://golang.org/src/sort/search.go)。O(log
    n)函数的代码和基准可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-logn](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-logn)找到。
- en: 'The following screenshot shows a logarithmic time benchmark:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了对数时间基准：
- en: '![](img/cf9bd878-23e5-42f0-b56c-efa3ba48457e.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf9bd878-23e5-42f0-b56c-efa3ba48457e.png)'
- en: This test shows a logarithmic increase in timing based on the input we set.
    Algorithms with a logarithmic time response are very helpful in writing performant
    code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试显示了基于我们设置的输入的对数增长的时间。具有对数时间响应的算法在编写高性能代码方面非常有帮助。
- en: O(n) – linear time
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O(n) – 线性时间
- en: Algorithms written in linear time scale linearly with the size of their dataset.
    Linear time is the best possible time complexity when an entire dataset needs
    to be read sequentially. The amount of time an algorithm takes in linear time,
    scales on a 1:1 relationship with the number of items that are contained within
    the dataset.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以线性时间编写的算法与其数据集的大小成线性比例。线性时间是当整个数据集需要按顺序读取时的最佳时间复杂度。算法在线性时间内花费的时间量与数据集中包含的项目数量呈1:1的关系。
- en: 'Some examples of linear time are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一些线性时间的例子如下：
- en: Simple loop
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单循环
- en: Linear search
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索
- en: 'Normalized timings for linear time can be found in the following table:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间的标准化时间可以在以下表中找到：
- en: '| **Number of items in the dataset** | **Resulting computation time** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **数据集中的项目数量** | **结果计算时间** |'
- en: '| 10 | 10 seconds |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 10秒 |'
- en: '| 100 | 100 seconds |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 100秒 |'
- en: '| 1,000 | 1,000 seconds |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 1,000秒 |'
- en: 'Note that the result computation time increases linearly and correlates to
    the number of items that were found in our dataset (refer to the following screenshot).
    The code and benchmark of an O(n) function can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，结果计算时间呈线性增长，并与我们的数据集中找到的项目数量相关（参见以下截图）。O(n)函数的代码和基准可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n)找到：
- en: '![](img/0353b6e7-8ef9-4446-b4f5-100d01bdd6d5.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0353b6e7-8ef9-4446-b4f5-100d01bdd6d5.png)'
- en: An important point to remember is that Big O notation isn't necessarily a perfect
    indicator of response time growth; it just denotes an upper ceiling. While reviewing
    this benchmark, focus on the fact that the resulting computation time grows linearly
    with the number of items in the dataset. O(n) algorithms are typically not the
    big showstopper in computer science from a performance perspective. Computer scientists
    perform loops on iterators frequently, and it's a common pattern that's used to
    get computational work completed. Make sure that you're always cognizant of the
    size of your dataset!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，大O符号并不一定是响应时间增长的完美指标；它只表示一个上限。在审查这个基准时，要注意计算时间随数据集中项目数量的线性增长。O(n)算法通常不是计算机科学中性能的主要瓶颈。计算机科学家经常在迭代器上执行循环，这是一个常用的模式，用于完成计算工作。确保你始终注意你的数据集的大小！
- en: O(n log n) – quasilinear time
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O(n log n) – 准线性时间
- en: Algorithms written in quasilinear (or log-linear) time are often used to order
    values within an array in Go.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，通常使用准线性（或对数线性）时间编写的算法来对数组中的值进行排序。
- en: 'Some examples of quasilinear time are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些准线性时间的例子如下：
- en: The average case time complexity for Quicksort
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quicksort的平均情况时间复杂度
- en: The average case time complexity for Mergesort
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mergesort的平均情况时间复杂度
- en: The average case time complexity for Heapsort
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heapsort的平均情况时间复杂度
- en: The average case time complexity for Timsort
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Timsort的平均情况时间复杂度
- en: 'The normalized timings for quasilinear time can be found in the following table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 准线性时间的标准化时间可以在以下表中找到：
- en: '| **Number of items in the dataset** | **Resulting computation time** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **数据集中的项目数量** | **结果计算时间** |'
- en: '| 10 | 10 seconds |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 10秒 |'
- en: '| 100 | 200 seconds |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 200秒 |'
- en: '| 1,000 | 3,000 seconds |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 3,000秒 |'
- en: 'You''ll see a familiar pattern here. This algorithm follows a pattern that''s
    similar to the O(log n) algorithm. The only thing that changes here is the n multiplier,
    so we can see similar results with a scaling factor (refer to the following screenshot).
    The code and benchmark of an O(n log n) function can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-nlogn](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-nlogn):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在这里看到一个熟悉的模式。这个算法遵循了与O(log n)算法类似的模式。这里唯一改变的是n的乘数，所以我们可以看到类似的结果与一个缩放因子（参见以下截图）。O(n
    log n)函数的代码和基准可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-nlogn](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-nlogn)找到：
- en: '![](img/dba95ab6-8b0c-41c9-8531-dc894233bcb7.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dba95ab6-8b0c-41c9-8531-dc894233bcb7.png)'
- en: 'Sorting algorithms are still fairly fast and aren''t the crux of ill-performing
    code. Frequently, sorting algorithms used in languages use a hybrid of multiple
    sorting algorithms based on size. Go''s `quickSort` algorithm, the sort that''s
    used in `sort.Sort()`, uses `ShellSort` and `insertionSort` if the slice contains
    less than 12 elements. This standard library algorithm for `quickSort` is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法仍然相当快，并不是性能不佳代码的关键。通常，语言中使用的排序算法使用基于大小的多种排序算法的混合。Go的`quickSort`算法，在`sort.Sort()`中使用，如果切片包含少于12个元素，则使用`ShellSort`和`insertionSort`。`quickSort`的标准库算法如下：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code can be found in the standard library at [https://golang.org/src/sort/sort.go#L183](https://golang.org/src/sort/sort.go#L183).
    This `quickSort` algorithm is performant and is used constantly in the Go ecosystem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以在标准库中找到[https://golang.org/src/sort/sort.go#L183](https://golang.org/src/sort/sort.go#L183)。这个`quickSort`算法性能良好，并且在Go生态系统中经常使用。
- en: O(n2) – quadratic time
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O(n2) – 二次时间
- en: Algorithms written in quadratic time have an execution time that corresponds
    directly to the square of the input size. Nested loops are common quadratic time
    algorithms, which brings along sorting algorithms.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 用二次时间编写的算法的执行时间与输入大小的平方成正比。嵌套循环是常见的二次时间算法，这带来了排序算法。
- en: 'Some examples of quadratic time are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 二次时间的一些例子如下：
- en: Bubble Sort
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Insertion Sort
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Selection Sort
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: 'Normalized timings for quadratic time can be found in the following table:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 二次时间的标准化时间可以在下表中找到：
- en: '| **Number of items in the dataset** | **Resulting computation time** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **数据集中的项目数量** | **计算时间** |'
- en: '| 10 | 100 seconds |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 100秒 |'
- en: '| 100 | 10,000 seconds |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 10,000秒 |'
- en: '| 1,000 | 1,000,000 seconds |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 1,000,000秒 |'
- en: You'll note from this table that as the input grows by a factor of 10, the resulting
    computation time grows quadratically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到从这个表中，随着输入增加了10倍，计算时间呈二次增长。
- en: Quadratic time algorithms should be avoided if possible. If you need to have
    a nested loop or a quadratic calculation, be sure to validate your inputs and
    attempt to constrain your input sizes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，应该避免二次时间算法。如果需要嵌套循环或二次计算，请确保验证您的输入并尝试限制输入大小。
- en: 'The code and benchmark of an O(n²) function can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2).
    The following is the output of running this benchmark:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2)找到O(n²)函数的代码和基准测试。以下是运行此基准测试的输出：
- en: '![](img/f412695c-2fa3-46c7-9204-eaf40c91c468.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f412695c-2fa3-46c7-9204-eaf40c91c468.png)'
- en: Quadratic timing algorithms get very expensive very quickly. We can see this
    with our own benchmark.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 二次时间算法的计时非常迅速增加。我们可以通过自己的基准测试看到这一点。
- en: O(2n) – exponential time
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: O(2n) – 指数时间
- en: An exponential algorithm grows exponentially when data is added to the input
    set. These are usually used when there isn't an inclination of the input dataset
    and you must try every possible composite of the input set.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据添加到输入集时，指数算法呈指数增长。通常在没有输入数据集的倾向时使用，必须尝试输入集的每种可能的组合。
- en: 'Some examples of exponential time are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 指数时间的一些例子如下：
- en: Poor recursion implementation of the Fibonacci sequence
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斐波那契数列的递归实现不佳
- en: Towers of Hanoi
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汉诺塔
- en: Traveling salesman problem
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行推销员问题
- en: 'Normalized timings for exponential time can be found in the following table:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 指数时间的标准化时间可以在下表中找到：
- en: '| **Number of items in the dataset** | **Resulting computation time** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **数据集中的项目数量** | **计算时间** |'
- en: '| 10 | 1,024 seconds |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1,024秒 |'
- en: '| 100 | 1.267 * 10^(30) seconds |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1.267 * 10^(30)秒 |'
- en: '| 1,000 | 1.07 * 10^(301) seconds |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 1.07 * 10^(301)秒 |'
- en: As the number of items in the dataset grows, the resulting computation time
    grows exponentially.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据集中项目数量的增加，计算时间呈指数增长。
- en: Exponential time algorithms should only be used in dire situations with very
    narrowly scoped datasets. Usually, clarifying your underlying problem or dataset
    further can help you avoid using an exponential time algorithm.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 指数时间算法应该只在非常狭窄的数据集范围内的紧急情况下使用。通常，澄清您的潜在问题或数据集进一步可以帮助您避免使用指数时间算法。
- en: 'The code for an O(n²) algorithm can be found at [https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2).
    Some example output for this benchmark can be seen in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2](https://github.com/bobstrecansky/HighPerformanceWithGo/tree/master/2-data-structures-and-algorithms/BigO-notation-o-n2)找到O(n²)算法的代码。可以在以下截图中看到此基准测试的一些示例输出：
- en: '![](img/5fc4a22c-73c8-485f-91af-d06ed8509d48.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fc4a22c-73c8-485f-91af-d06ed8509d48.png)'
- en: Exponential time algorithm problems can often be broken down into smaller, more
    digestible pieces. This also allows for optimization.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 指数时间算法问题通常可以分解为更小、更易消化的部分。这也可以进行优化。
- en: In the next section, we will look at sort algorithms.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看排序算法。
- en: Understanding sort algorithms
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解排序算法
- en: 'Sorting algorithms are used to take individual elements in a dataset and put
    them in a specific order. Usually, sorting algorithms take a dataset and put them
    in either lexicographical or numerical order. Being able to sort efficiently is
    important in writing performant code, as many search algorithms require a sorted
    dataset. The common data structure operations can be seen in the following diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法用于获取数据集中的各个元素并按特定顺序排列它们。通常，排序算法会获取数据集并将其按字典顺序或数字顺序排列。能够高效地进行排序对于编写高性能代码很重要，因为许多搜索算法需要排序的数据集。常见的数据结构操作可以在以下图表中看到：
- en: '![](img/e82896f2-626c-45f7-9ce7-54b0be484b54.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e82896f2-626c-45f7-9ce7-54b0be484b54.png)'
- en: Common Data Structure Operations (from bigocheatsheet.com) - thanks to Eric
    Rowell
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 常见数据结构操作（来自bigocheatsheet.com）- 感谢Eric Rowell
- en: As you can see, array sorting algorithms can have vastly different Big O notation.
    Choosing the correct sort algorithm for your unordered list is important when
    it comes to providing an optimized solution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，数组排序算法的大O符号表示可以有很大的不同。在为无序列表选择正确的排序算法时，这对于提供优化的解决方案非常重要。
- en: Insertion sort
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序
- en: Insertion sort is a sorting algorithm that constructs an array one item at a
    time until it results in a sorted array. It's not very efficient, but it does
    have a simple implementation and is quick for very small datasets. The array is
    sorted in place, which can also help reduce the memory footprint of the function
    call.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序是一种排序算法，它一次构建一个数组项，直到结果为排序数组。它并不是非常高效，但它有一个简单的实现，并且对于非常小的数据集来说很快。数组是原地排序的，这也有助于减少函数调用的内存占用。
- en: 'This standard library algorithm for `insertionSort` can be found in the following
    code snippet. We can use the following code snippet to deduce that insertion sort
    is an average case of an O(n²) algorithm. This is due to the fact that we iterate
    through a 2D array and manipulate data:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标准库中的`insertionSort`算法可以在下面的代码片段中找到。我们可以使用下面的代码片段来推断插入排序是一个O(n²)算法的平均情况。这是因为我们要遍历一个二维数组并操作数据：
- en: '[PRE8]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code can be found in the standard library at [https://golang.org/src/sort/sort.go#L183](https://golang.org/src/sort/sort.go#L24).
    A simple insertion sort is often valuable for small datasets because it is very
    easy to read and comprehend. Simplicity often outweighs everything else when it
    comes to writing performant code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在标准库中找到[https://golang.org/src/sort/sort.go#L183](https://golang.org/src/sort/sort.go#L24)。简单的插入排序通常对小数据集很有价值，因为它非常容易阅读和理解。当编写高性能代码时，简单性往往比其他一切都更重要。
- en: Heap sort
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆排序
- en: 'Go has a built-in `heapSort` in the standard library, as shown in the following
    code snippet. This code snippet helps us understand that `heapSort` is an O(n
    log n) sorting algorithm. This is better than our preceding insertion sort example,
    so for larger datasets, we are going to have more performant code when using our
    heap sort algorithm:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言在标准库中内置了`heapSort`，如下面的代码片段所示。这段代码片段帮助我们理解`heapSort`是一个O(n log n)的排序算法。这比我们之前的插入排序示例要好，因此对于更大的数据集，使用我们的堆排序算法时，我们将拥有更高性能的代码：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code can be found in the standard library at [https://golang.org/src/sort/sort.go#L53](https://golang.org/src/sort/sort.go#L53).
    When our datasets become larger, it is important to start using efficient sort
    algorithms such as `heapSort`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在标准库中找到[https://golang.org/src/sort/sort.go#L53](https://golang.org/src/sort/sort.go#L53)。当我们的数据集变得更大时，开始使用高效的排序算法如`heapSort`是很重要的。
- en: Merge sort
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: 'Merge sort is a sorting algorithm with an O(n log n) average time complexity.
    `MergeSort` is often used if the goal of the algorithm is to produce a stable
    sort. A stable sort ensures that two objects that share the same key in an input
    array appear in the resulting array in the same order. Stability is important
    if we want to make sure that a key-value order pair is organized within an array.
    An implementation of a stable sort can be found in the Go standard library. This
    can be seen in the following code snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序是一种平均时间复杂度为O(n log n)的排序算法。如果算法的目标是产生稳定的排序，通常会使用`MergeSort`。稳定的排序确保输入数组中具有相同键的两个对象在结果数组中以相同的顺序出现。如果我们想要确保键-值对在数组中有序，稳定性就很重要。Go标准库中可以找到稳定排序的实现。下面的代码片段中可以看到：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code can be found in the standard library at [https://golang.org/src/sort/sort.go#L356](https://golang.org/src/sort/sort.go#L356).
    Stable sorting algorithms are important when order needs to be maintained.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在标准库中找到[https://golang.org/src/sort/sort.go#L356](https://golang.org/src/sort/sort.go#L356)。当需要保持顺序时，稳定的排序算法非常重要。
- en: Quick sort
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序
- en: The Go standard library has a quick sort algorithm, as we saw in the *O( n log
    n) – quasilinear time* section. QuickSort was initially implemented in Unix as
    the default sort routine in the standard library. From there, it was built upon
    and used as qsort in the C programming language. Because of its familiarity and
    vast history, it is commonly used as a sorting algorithm in many computer science
    problems today. Using our algorithms table, we can deduce that a standard implementation
    of the `quickSort` algorithm has an average time complexity of O(n log n). It
    also has the added benefit of using, at worst, an O(log n) space complexity, making
    it ideal for in-place moves.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库中有一个快速排序算法，正如我们在*O(n log n) – quasilinear time*部分中看到的。快速排序最初在Unix中作为标准库中的默认排序例程实现。从那时起，它被构建并用作C编程语言中的qsort。由于它的熟悉度和悠久的历史，它通常被用作今天许多计算机科学问题中的排序算法。使用我们的算法表，我们可以推断`quickSort`算法的标准实现具有O(n
    log n)的平均时间复杂度。它还具有使用最坏情况下O(log n)的空间复杂度的额外好处，使其非常适合原地移动。
- en: Now that we are done with sort algorithms, we will move on to search algorithms.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了排序算法，我们将转向搜索算法。
- en: Understanding search algorithms
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解搜索算法
- en: 'Search algorithms are typically used in order to retrieve an element from a
    dataset or to check for the presence of that element. Search algorithms are generally
    classified into two separate categories: linear search and interval search.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法通常用于从数据集中检索元素或检查该元素是否存在。搜索算法通常分为两个独立的类别：线性搜索和区间搜索。
- en: Linear search
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: In a linear search algorithm, every element in the slice or array is checked
    when the slice or array is traversed sequentially. This algorithm isn't the most
    efficient algorithm since it ranks in at an O(n) complexity because it can traverse
    every element on the list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性搜索算法中，当顺序遍历切片或数组时，会检查切片或数组中的每个元素。这个算法并不是最高效的算法，因为它的复杂度为O(n)，因为它可以遍历列表中的每个元素。
- en: 'A linear search algorithm can be written simply as an iteration through a slice,
    as shown in the following code snippet:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 线性搜索算法可以简单地写成对切片的迭代，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function shows us that it'll get expensive quickly with larger datasets.
    With a dataset of 10 elements, this algorithm won't take very long as it will
    only iterate through 10 values at a maximum. If our dataset contained 1 million
    elements, this function would take much longer to return a value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数告诉我们，随着数据集的增大，它会很快变得昂贵。对于包含10个元素的数据集，这个算法不会花费太长时间，因为它最多只会迭代10个值。如果我们的数据集包含100万个元素，这个函数将需要更长的时间才能返回一个值。
- en: Binary search
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: 'A much more commonly used pattern (and the pattern that you''d most likely
    want to use for a performant search algorithm) is called binary search. An implementation
    of a binary search algorithm can be found in the Go standard library at [https://golang.org/src/sort/search.go](https://golang.org/src/sort/search.go)
    and was displayed in the sort search function earlier in this chapter. A binary
    search tree has an O(log n) search complexity compared to the O(n) complexity
    of the linear search function that we wrote previously. Binary search tends to
    get used frequently, especially when the dataset that needs to be searched gets
    to any sort of reasonable size. Binary search is also smart to implement early
    – if the dataset that you have grows without you being privy to the growth, at
    least the utilized algorithm will not increase in complexity. In the following
    code, we''re using the `SearchInts` convenience wrapper for the Go search function.
    This allows us to iterate through an integer array with a binary search:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更常用的模式（也是您最有可能想要用于高性能搜索算法的模式）称为二分搜索。二分搜索算法的实现可以在Go标准库中找到[https://golang.org/src/sort/search.go](https://golang.org/src/sort/search.go)，并且在本章前面的排序搜索函数中显示过。与我们之前编写的线性搜索函数的O(n)复杂度相比，二分搜索树具有O(log
    n)的搜索复杂度。二分搜索往往经常被使用，特别是当需要搜索的数据集达到任何合理大小时。二分搜索也很聪明地早早实现 - 如果您的数据集增长而您不知情，至少所使用的算法不会增加复杂性。在下面的代码中，我们使用了`SearchInts`便利包装器来进行Go搜索函数。这允许我们使用二分搜索迭代整数数组：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output from this function is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的输出如下：
- en: '![](img/66928f1b-7aa7-44b9-a8a6-79fd381a9650.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66928f1b-7aa7-44b9-a8a6-79fd381a9650.png)'
- en: This shows us that the binary search library was able to find the number we
    were searching for (`34`) in the array that we were searching (`intArray`). It
    found the integer 34 in the 6th position in the array (which is correct; the array
    is 0 indexed).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，二分搜索库能够在我们搜索的数组（`intArray`）中找到我们正在搜索的数字（`34`）。它在数组中的第6个位置找到了整数34（这是正确的；数组是从0开始索引的）。
- en: 'The upcoming section deals with another data structure: trees.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分涉及另一个数据结构：树。
- en: Exploring trees
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索树
- en: A tree is a non-linear data structure that is used in computer science to store
    information. It's commonly used to store data that maintains relationships, particularly
    if the relationships form a hierarchy. Trees are also simple to search (diagram
    for array sorting algorithms in the *Understanding sort algorithms* section) shows
    us that many trees have an O(log n) time complexity with operations in trees).
    For many problems, trees are the best solution because of how they reference hierarchical
    data. Trees are combinations of nodes that don't make a cycle.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种非线性数据结构，用于存储信息。它通常用于存储维护关系的数据，特别是如果这些关系形成层次结构。树也很容易搜索（*理解排序算法*部分的数组排序算法图表向我们展示了许多树的操作具有O(log
    n)的时间复杂度）。对于许多问题，树是最佳解决方案，因为它们引用分层数据。树是由不形成循环的节点组合而成。
- en: Each tree is made up of elements called nodes. We start at the root node (the
    yellow box labeled root in the binary trees figure below). There is a left and
    a right reference pointer (numbers 2 and 7, in our case ) and a data element (the
    number 1, in this case) within each node. As a tree grows, the depth of the node
    (the number of edges from the root to a given node) increases. Nodes 4, 5, 6,
    and 7 all have a depth of 3 in this diagram. The height of the node is the number
    of edges that occur from the node to the deepest leaf in the tree (as seen in
    the height 4 box in the following binary tree diagram). The height of the entire
    tree is equivalent to the height of the root node.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 每棵树都由称为节点的元素组成。我们从根节点开始（下面的二叉树图中标有根的黄色框）。在每个节点中有一个左引用指针和一个右引用指针（在我们的例子中是数字2和7），以及一个数据元素（在本例中是数字1）。随着树的增长，节点的深度（从根到给定节点的边的数量）增加。在这个图中，节点4、5、6和7的深度都是3。节点的高度是从节点到树中最深的叶子的边的数量（如下面二叉树图中的高度4框所示）。整个树的高度等于根节点的高度。
- en: Binary trees
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二叉树
- en: 'Binary trees are an important data structure in computer science. They are
    often used for search, priority queues, and databases. They are efficient because
    they are easy to traverse in a concurrent fashion. Go has great concurrency primitives
    (which we''ll discuss in [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml),
    *Understanding Concurrency*) that allow us to do this in a simple manner. Being
    able to use goroutines and channels to walk a binary tree can help speed up how
    we traverse a grouping of hierarchical data. A balanced binary tree can be seen
    in the following diagram:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是计算机科学中重要的数据结构。它们经常用于搜索、优先队列和数据库。它们是高效的，因为它们易于以并发方式遍历。Go语言具有出色的并发原语（我们将在[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中讨论，*理解并发*），可以让我们以简单的方式做到这一点。能够使用goroutines和通道来遍历二叉树可以帮助加快我们遍历分层数据的速度。平衡的二叉树可以在下图中看到：
- en: '![](img/b4cfd02e-78ce-43a6-a49c-7b5b7a863f90.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4cfd02e-78ce-43a6-a49c-7b5b7a863f90.png)'
- en: 'A couple of special binary trees are as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些特殊的二叉树：
- en: '**Full binary tree**: Every node sans the leaf nodes has 2 child nodes.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满二叉树**：除了叶子节点外，每个节点都有2个子节点。'
- en: '**Complete binary tree**: A tree that is completely filled, sans the bottom
    layer. The bottom layer must be filled from left to right.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全二叉树**：一棵完全填充的树，除了底层之外。底层必须从左到右填充。'
- en: '**Perfect binary tree**: A complete binary tree in which all the nodes have
    two children and all the leaves of the tree are at the same level.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完美二叉树**：一个完全二叉树，其中所有节点都有两个子节点，树的所有叶子都在同一层。'
- en: Doubly linked list
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'Doubly linked lists are also part of the Go standard library. This is a relatively
    large package, so for convenience, the function signatures for this package can
    be found in the following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表也是Go标准库的一部分。这是一个相对较大的包，因此为了方便起见，可以在以下代码片段中找到此包的函数签名：
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These function signatures (and their corresponding methods) can be found in
    the Go standard library at [https://golang.org/src/container/list/list.go](https://golang.org/src/container/list/list.go).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数签名（以及它们对应的方法）可以在Go标准库中找到，网址为[https://golang.org/src/container/list/list.go](https://golang.org/src/container/list/list.go)。
- en: Finally, we will look at queues.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看一下队列。
- en: Exploring queues
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索队列
- en: A queue is a pattern that is frequently used in computer science to implement
    a **first in first out** (**FIFO**) data buffer. The first thing to come into
    the queue is also the first thing to leave. This happens in an ordered fashion
    in order to process sorted data. Adding things to the queue is known as enqueueing
    the data into the queue, and removing it from the end of the queue is known as
    dequeuing. Queues are commonly used as a fixture in which data is stored and processed
    at another time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是计算机科学中经常用来实现**先进先出**（**FIFO**）数据缓冲区的模式。进入队列的第一件事也是离开的第一件事。这是以有序的方式进行的，以处理排序数据。将事物添加到队列中称为将数据入队列，从队列末尾移除称为出队列。队列通常用作存储数据并在另一个时间进行处理的固定装置。
- en: Queues are beneficial because they don't have a fixed capacity. A new element
    can be added to the queue at any time, which makes a queue an ideal solution for
    asynchronous implementations such as a keyboard buffer or a printer queue. Queues
    are used in situations where tasks must be completed in the order that they were
    received, but when real-time occurs, it may not be possible based on extraneous
    factors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的好处在于它们没有固定的容量。新元素可以随时添加到队列中，这使得队列成为异步实现的理想解决方案，例如键盘缓冲区或打印机队列。队列用于必须按接收顺序完成任务的情况，但在实时发生时，可能基于外部因素而不可能完成。
- en: Common queuing functions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的排队函数
- en: 'Very frequently, other small queue operations are added in order to make a
    queue a little more useful:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 非常频繁地，其他小的排队操作被添加，以使队列更有用：
- en: '`isfull()` is commonly implemented to check whether or not a queue is full.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isfull()`通常用于检查队列是否已满。'
- en: '`isempty()` is commonly implemented to check whether or not a queue is empty.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isempty()`通常用于检查队列是否为空。'
- en: '`peek()` retrieves the element that is ready to be dequeued, but does not dequeue
    it.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`检索准备出队的元素，但不出队。'
- en: 'These functions are useful because a normal enqueueing operation goes as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数很有用，因为正常的入队操作如下：
- en: Check to see if the queue is full and return an error if the queue is full
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查队列是否已满，如果队列已满则返回错误
- en: Increment the rear pointer; return the next empty space
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递增后指针；返回下一个空位
- en: Add the data element to the location in which the rear is being pointed at
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据元素添加到后指针指向的位置
- en: After these steps are completed, we can enqueue the next item in our queue.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们可以将下一个项目入队到我们的队列中。
- en: 'Dequeuing is also just as simple as doing the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 出队也和以下操作一样简单：
- en: Check to see if the queue is empty and return an error if the queue is empty
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查队列是否为空，如果队列为空则返回错误
- en: Access the data at the front of the queue
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问队列前端的数据
- en: Increment the front pointer to the next available element
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前指针递增到下一个可用元素
- en: After these steps are completed, we have dequeued this item from our queue.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们已经从队列中出队了这个项目。
- en: Common queuing patterns
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的排队模式
- en: Having an optimized queuing mechanism can be very helpful for writing performant
    Go code. Being able to push non-critical tasks to a queue allows you to complete
    the critical tasks faster. Another point to consider is that the queueing mechanism
    that you're using doesn't necessarily have to be a Go queue. You can push data
    to external mechanisms such as Kafka ([https://kafka.apache.org/](https://kafka.apache.org/))
    or RabbitMQ ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)) in a distributed
    system. Managing your own messaging queue can become very operationally expensive,
    so having a separate message queuing system is commonplace today. We will cover
    this in more detail in [Chapter 14](74c0cef8-9628-4e31-abc3-9bd9aa52fafa.xhtml),
    *Clusters and Job Queues*, when we look at clustering and job queuing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有优化的排队机制对于编写高性能的Go代码非常有帮助。能够将非关键任务推送到队列中，可以让您更快地完成关键任务。另一个要考虑的问题是，您使用的排队机制不一定非得是Go队列。您可以将数据推送到外部机制，如Kafka
    ([https://kafka.apache.org/](https://kafka.apache.org/))或RabbitMQ ([https://www.rabbitmq.com/](https://www.rabbitmq.com/))在分布式系统中。管理自己的消息队列可能会变得非常昂贵，因此在今天，拥有单独的消息排队系统是司空见惯的。当我们研究集群和作业排队时，我们将在[第14章](74c0cef8-9628-4e31-abc3-9bd9aa52fafa.xhtml)
    *集群和作业队列*中更详细地介绍这一点。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about benchmarking Go programs. We learned about
    how Big O notation considerations can help you design impactful data structures
    and algorithms around your problem set. We also learned about search and sorting
    algorithms, trees, and queues in order to make our data structures and algorithms
    most impactful to the problem at hand.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何对Go程序进行基准测试。我们了解了如何根据Big O符号的考虑来设计对问题集具有影响力的数据结构和算法。我们还学习了搜索和排序算法、树和队列，以使我们的数据结构和算法对手头的问题具有最大的影响力。
- en: In [Chapter 3](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml), *Understanding Concurrency*,
    we'll learn about some of the most important Go constructs and how they can impact
    performance. Closures, channels, and goroutines can help us make some powerful
    design decisions with respect to both parallelism and concurrency.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](61b73482-0431-4b8f-a069-d647ac1c1b87.xhtml)中，*理解并发*，我们将学习一些最重要的Go构造，并了解它们如何影响性能。闭包、通道和goroutines可以帮助我们在并行性和并发性方面做出一些强大的设计决策。
