- en: GPU Parallelization in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的GPU并行化
- en: GPU accelerated programming is becoming more and more important in today's high-performance
    computing stacks. It is commonly used in fields such as **Artificial Intelligence**
    (**AI**) and **Machine Learning** (**ML**). GPUs are commonly used for these tasks
    because they tend to be excellent for parallel computation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GPU加速编程在当今的高性能计算堆栈中变得越来越重要。它通常用于**人工智能**（**AI**）和**机器学习**（**ML**）等领域。GPU通常用于这些任务，因为它们往往非常适合并行计算。
- en: 'In this chapter, we will learn about Cgo, GPU accelerated programming, **CUDA**
    (short for **Compute Unified Device Architecture**), make commands, C style linking
    for Go programs, and executing a GPU enabled process within a Docker container.
    Learning all of these individual things will help us to use a GPU to power a Go
    backed CUDA program. Doing this will help us to determine how we can use the GPU
    effectively to help solve computational problems using Go:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Cgo、GPU加速编程、**CUDA**（**Compute Unified Device Architecture**的缩写）、make命令、Go程序的C样式链接，以及在Docker容器中执行启用GPU的进程。学习所有这些单独的东西将帮助我们使用GPU来支持Go支持的CUDA程序。这将帮助我们确定如何有效地使用GPU来帮助使用Go解决计算问题：
- en: Cgo – writing C in Go
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cgo - 在Go中编写C
- en: GPU-accelerated computing – utilizing the hardware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU加速计算-利用硬件
- en: CUDA on GCP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCP上的CUDA
- en: CUDA – powering the program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CUDA-为程序提供动力
- en: Cgo – writing C in Go
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cgo - 在Go中编写C
- en: Cgo is a library that is built into the standard library of Go that allows users
    to invoke calls to underlying C programs in their Go code. Cgo is often used as
    a delegator for things that are currently coded in C but don't have equivalent
    Go code written.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Cgo是Go标准库中内置的一个库，允许用户在其Go代码中调用底层C程序。Cgo通常用作当前用C编写但没有等效Go代码的事物的代理。
- en: 'Cgo should be used sparingly and only when there isn''t an equivalent Go library
    available for a system. Cgo adds a few limitations to your Go programs:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应该谨慎使用Cgo，只有在系统中没有等效的Go库可用时才使用。Cgo对您的Go程序添加了一些限制：
- en: Needless complexity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不必要的复杂性
- en: Difficulty troubleshooting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 困难的故障排除
- en: Added complexity of building and compiling C code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和编译C代码的复杂性增加
- en: Much of Go's tooling is not available for use in Cgo programs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的许多工具在Cgo程序中不可用
- en: Cross-compiling doesn't work as expected or at all
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉编译不像预期的那样有效，或者根本不起作用
- en: The complexity of C code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C代码的复杂性
- en: Native Go calls are much faster than Cgo calls
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本机Go调用比Cgo调用快得多
- en: Slower build times
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建时间较慢
- en: If you can (or must) live with all of these stipulations, Cgo may be a necessary
    resource for the project that you're working on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以（或必须）接受所有这些规定，Cgo可能是您正在开发的项目的必要资源。
- en: 'There are a few instances where it is appropriate to use Cgo. A couple of primary
    examples are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况是适合使用Cgo的。主要的两个例子如下：
- en: When you must use a proprietary **Software Development Kit** (**SDK**) or proprietary
    library.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您必须使用专有的**软件开发工具包**（**SDK**）或专有库时。
- en: When you have a legacy piece of software in C that would be difficult to port
    to Go because of business logic validation.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有一个遗留的C软件，由于业务逻辑验证的原因，将其移植到Go可能会很困难。
- en: You've exhausted the Go runtime to its limit and you need further optimization.
    It is very rare that we get to this particular case.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已经将Go运行时耗尽，并且需要进一步优化。我们很少有机会遇到这种特殊情况。
- en: 'More excellent cgo documentation can be found at the following URLs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更多优秀的cgo文档可以在以下网址找到：
- en: '[https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)'
- en: '[https://blog.golang.org/c-go-cgo](https://blog.golang.org/c-go-cgo)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.golang.org/c-go-cgo](https://blog.golang.org/c-go-cgo)'
- en: In the next section, we are going to take a look at a simple cgo example in
    order to familiarize ourselves with how Cgo works, along with some of its highlights
    and shortcomings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一个简单的cgo示例，以便熟悉Cgo的工作原理，以及它的一些亮点和缺点。
- en: A simple Cgo example
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的Cgo示例
- en: 'Let''s take a look at a relatively straightforward Cgo example. In this example,
    we will write a simple function to print "Hello Gophers" from a C binding and
    then we will call that C code from our Go program. In this function, we return
    a constant character string. We then call the `hello_gophers` C function within
    our Go program. We also use the `C.GoString` function to convert the C string
    type and the Go string type:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个相对简单的Cgo示例。在这个例子中，我们将编写一个简单的函数来从C绑定打印“Hello Gophers”，然后我们将从我们的Go程序中调用该C代码。在这个函数中，我们返回一个常量字符字符串。然后我们在Go程序中调用`hello_gophers`
    C函数。我们还使用`C.GoString`函数将C字符串类型转换为Go字符串类型：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once this program has been executed, we can see a simple `Hello Gophers!` output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了这个程序，我们就可以看到一个简单的“Hello Gophers！”输出：
- en: '![](img/3678c8b4-c73c-4039-b628-2bc85cd3e795.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3678c8b4-c73c-4039-b628-2bc85cd3e795.png)'
- en: 'This example, while simple, shows us how we can bind C functions in our Go
    programs. To further emphasize the difference in execution time, we can look at
    a benchmark of our Cgo function and our Go function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子虽然简单，但向我们展示了如何在我们的Go程序中绑定C函数。为了进一步强调执行时间的差异，我们可以看一下我们的Cgo函数和我们的Go函数的基准测试： '
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then use these functions for benchmarking our bound C function in comparison
    to just a normal `GoPrint` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这些函数来对我们的绑定C函数进行基准测试，以比较普通的`GoPrint`函数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we execute this, we can see the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完这个之后，我们可以看到以下输出：
- en: '![](img/53f3c348-4a5b-43ea-842a-409ddd9d7a41.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53f3c348-4a5b-43ea-842a-409ddd9d7a41.png)'
- en: Note that the bound Cgo function takes about an order of magnitude longer than
    the native Go functionality. This is okay in some cases. This benchmark is just
    further verifying the fact that we should use Cgo bindings only when it makes
    sense. It's important to remember that there are specific times where we can justify
    using Cgo, such as when we have to perform actions that aren't available natively
    as Go functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，绑定的Cgo函数所需的时间大约比本机Go功能长一个数量级。在某些情况下这是可以接受的。这个基准测试只是进一步验证了我们只有在有意义的时候才应该使用Cgo绑定。重要的是要记住，有特定的时机我们可以证明使用Cgo是合理的，比如当我们必须执行本地Go功能中不可用的操作时。
- en: In the next section, we are going to learn about GPU-accelerated programming
    and NVIDIA's CUDA platform.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习GPU加速编程和NVIDIA的CUDA平台。
- en: GPU-accelerated computing – utilizing the hardware
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU加速计算-利用硬件
- en: In today's modern computers, we have a couple of pieces of hardware that do
    most of the work for the system. The CPU performs most instructional operations
    from other parts of the computer and delivers the results of those operations.
    The memory is a fast, short-term location for data storage and manipulation. Hard
    disks are used for longer-term data storage and manipulation, and networking devices
    are used to send these bits of data between computing devices across a network.
    A device that is often also used in a modern computing system is a discrete GPU.
    Whether it is to display the latest computer games with high-fidelity graphics,
    decoding 4K video, or performing financial number-crunching, GPUs are becoming
    a more popular option for high-speed computing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的现代计算机中，我们有一些硬件部件来完成系统的大部分工作。CPU执行大部分来自计算机其他部分的指令操作，并传递这些操作的结果。内存是数据存储和处理的快速短期位置。硬盘用于长期数据存储和处理，网络设备用于在网络中的计算设备之间发送这些数据位。现代计算系统中经常使用的设备是独立GPU。无论是显示具有高保真图形的最新电脑游戏，解码4K视频，还是执行金融数字计算，GPU都成为高速计算的更受欢迎的选择。
- en: GPUs are designed for performing specific tasks in an efficient manner. Use
    of GPUs as **General-Purpose Graphics Processing Units** (**GPGPUs**) is becoming
    more commonplace as high-throughput computing is seeing wider adoption.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: GPU旨在以高效的方式执行特定任务。随着高吞吐量计算的广泛采用，将GPU用作通用图形处理单元（GPGPUs）变得更加普遍。
- en: 'There are many different APIs available for GPU programming to use GPUs to
    their fullest extent, including the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的GPU编程API可供使用，以充分利用GPU的性能，包括以下内容：
- en: 'OpenCL: [https://www.khronos.org/opencl/](https://www.khronos.org/opencl/)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCL：[https://www.khronos.org/opencl/](https://www.khronos.org/opencl/)
- en: 'OpenMP: [https://www.openmp.org/](https://www.openmp.org/)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenMP：[https://www.openmp.org/](https://www.openmp.org/)
- en: 'NVIDIA''s CUDA platform: [https://developer.nvidia.com/cuda-zone](https://developer.nvidia.com/cuda-zone)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NVIDIA的CUDA平台：[https://developer.nvidia.com/cuda-zone](https://developer.nvidia.com/cuda-zone)
- en: NVIDIA's CUDA library is mature, performant, and widely accepted. We are going
    to use the CUDA library in our examples in this chapter. Let's talk more about
    the CUDA platform.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: NVIDIA的CUDA库是成熟、高性能且广泛接受的。我们将在本章的示例中使用CUDA库。让我们更多地了解CUDA平台。
- en: 'NVIDIA''s CUDA platform is an API written by the NVIDIA team that is used to
    increase parallelism and improve speed with a CUDA-enabled graphics card. Using
    a GPGPU for performing parallel algorithms on data structures can seriously improve
    compute time. Many of the current ML and AI toolsets use CUDA under the hood,
    including, but not limited to, the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NVIDIA的CUDA平台是由NVIDIA团队编写的API，用于增加并行性并提高具有CUDA启用的图形卡的速度。在数据结构上执行并行算法可以严重提高计算时间。许多当前的ML和AI工具集在内部使用CUDA，包括但不限于以下内容：
- en: 'TensorFlow: [https://www.tensorflow.org/install/gpu](https://www.tensorflow.org/install/gpu)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TensorFlow：[https://www.tensorflow.org/install/gpu](https://www.tensorflow.org/install/gpu)
- en: 'Numba: [https://devblogs.nvidia.com/gpu-accelerated-graph-analytics-python-numba/](https://devblogs.nvidia.com/gpu-accelerated-graph-analytics-python-numba/)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba：[https://devblogs.nvidia.com/gpu-accelerated-graph-analytics-python-numba/](https://devblogs.nvidia.com/gpu-accelerated-graph-analytics-python-numba/)
- en: 'PyTorch: [https://pytorch.org/](https://pytorch.org/)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyTorch：[https://pytorch.org/](https://pytorch.org/)
- en: CUDA provides an API for accessing these processing idioms in C++. It uses the
    concept of kernels, which are functions called from the C++ code that get executed
    on the GPU device. Kernels are the parts of the code that get executed in parallel. CUDA
    uses C++ syntax rules in order to process instructions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CUDA提供了一个用于在C++中访问这些处理习语的API。它使用内核的概念，内核是从C++代码调用的函数，在GPU设备上执行。内核是代码的部分，可以并行执行。CUDA使用C++语法规则来处理指令。
- en: 'There are many places you can use GPUs in the cloud to perform compute jobs,
    such as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多地方可以使用云中的GPU来执行计算任务，例如以下：
- en: 'Google Cloud GPUs: [https://cloud.google.com/gpu/](https://cloud.google.com/gpu/)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud GPU：[https://cloud.google.com/gpu/](https://cloud.google.com/gpu/)
- en: 'AWS EC2 instances with GPU: [https://aws.amazon.com/nvidia/](https://aws.amazon.com/nvidia/)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有GPU的AWS EC2实例：[https://aws.amazon.com/nvidia/](https://aws.amazon.com/nvidia/)
- en: 'Paperspace: [https://www.paperspace.com/](https://www.paperspace.com/)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paperspace：[https://www.paperspace.com/](https://www.paperspace.com/)
- en: 'FloydHub: [https://www.floydhub.com/](https://www.floydhub.com/)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FloydHub：[https://www.floydhub.com/](https://www.floydhub.com/)
- en: 'You can also run CUDA programs on your local workstation. The requirements
    for doing so are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在本地工作站上运行CUDA程序。这样做的要求如下：
- en: A GPU that is CUDA capable (I used a NVIDIA GTX670 in my example)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持CUDA的GPU（我在示例中使用了NVIDIA GTX670）
- en: An **Operating System** (**OS**) that has a GCC compiler and toolchain (I used
    Fedora 29 in my example)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有GCC编译器和工具链的操作系统（我在示例中使用了Fedora 29）
- en: 'In the next section, we''ll run through how to get our workstation set up for
    CUDA processing:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何设置我们的工作站进行CUDA处理：
- en: 'First, we''ll have to install the proper kernel development tools and kernel
    headers for our host. We can do this on our example Fedora host by executing the
    following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的主机安装适当的内核开发工具和内核头文件。我们可以通过执行以下命令在我们的示例Fedora主机上执行此操作：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also need to install `gcc` and the appropriate build tools. We can do so
    with the following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要安装`gcc`和适当的构建工具。我们可以通过以下方式来实现：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we have the prerequisites installed, we can retrieve the local `.run`
    file installer that NVIDIA gives us for CUDA. At the time of writing, the `cuda_10.2.89_440.33.01_linux.run`
    package was the latest available. You can find the latest CUDA toolkit package
    for download from [https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads):'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了先决条件后，我们可以获取NVIDIA为CUDA提供的本地`.run`文件安装程序。在撰写本文时，`cuda_10.2.89_440.33.01_linux.run`包是最新可用的。您可以从[https://developer.nvidia.com/cuda-downloads](https://developer.nvidia.com/cuda-downloads)下载最新的CUDA工具包：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then install this package with the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下代码安装此软件包：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will give us an installation prompt, as seen in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个安装提示，如下截图所示：
- en: '![](img/0e949b8a-966e-4ceb-b0d4-c9cb23c4e84b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e949b8a-966e-4ceb-b0d4-c9cb23c4e84b.png)'
- en: 'After we accept the EULA, we can choose the necessary dependencies to install
    and select `Install`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '接受最终用户许可协议后，我们可以选择安装所需的依赖项并选择`Install`： '
- en: '![](img/6b6958e4-be34-4ada-9069-a91439c6b6d8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b6958e4-be34-4ada-9069-a91439c6b6d8.png)'
- en: 'After you accept the installation prompt, the CUDA installer should successfully
    complete the installation. If you have any errors during your installation, looking
    in the following locations may help you to sort out your installation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接受安装提示后，CUDA安装程序应成功完成安装。如果在安装过程中出现任何错误，请查看以下位置可能会帮助您解决安装问题：
- en: '`/var/log/cuda-installer.log`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/log/cuda-installer.log`'
- en: '`/var/log/nvidia-installer.log`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/log/nvidia-installer.log`'
- en: In the next section, we are going to discuss how to use the host machine for
    CUDA processes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何使用主机机器进行CUDA进程。
- en: CUDA – utilizing host processes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA - 利用主机进程
- en: After you've successfully installed CUDA, you'll need to set some environment
    variables in order to add the installed bits to your execution path. This functionality
    works as expected if you don't have access to Docker on your host or if you'd
    rather use your bare machine to perform GPU-intensive operations. If you'd like
    to use a more reproducible build, you can use the Docker configuration defined
    in the following *Docker for GPU-enabled programming* section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了CUDA后，您需要设置一些环境变量，以便将安装的部分添加到执行路径中。如果您在主机上没有Docker访问权限，或者您更愿意使用裸机执行GPU密集型操作，此功能将按预期工作。如果您想使用更可重现的构建，可以使用以下*Docker
    for GPU-enabled programming*部分中定义的Docker配置。
- en: We'll need to update our `PATH` to include the CUDA binary paths that we just
    installed. We can do this by executing the following: `export PATH=$PATH:/usr/local/cuda-10.2/bin:/usr/local/cuda-10.2/NsightCompute-2019.1`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新我们的`PATH`以包括我们刚刚安装的CUDA二进制路径。我们可以通过执行以下命令来实现：`export PATH=$PATH:/usr/local/cuda-10.2/bin:/usr/local/cuda-10.2/NsightCompute-2019.1`。
- en: We also need to update our `LD_LIBRARY_PATH` variable, which is an environment
    variable that your OS looks for when linking dynamic and shared libraries. We
    can add the CUDA libraries by executing `export LD_LIBRARY_PATH=:/usr/local/cuda-10.2/lib64`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的`LD_LIBRARY_PATH`变量，这是一个环境变量，您的操作系统在链接动态和共享库时会查找它。我们可以通过执行`export
    LD_LIBRARY_PATH=:/usr/local/cuda-10.2/lib64`来添加CUDA库。
- en: This will add the CUDA libraries to your library path. We will add these to
    our path programmatically with a GNU Makefile for our examples in the closing
    sections of this chapter. In the next section, we'll discuss how to utilize CUDA
    with Docker.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把CUDA库添加到您的库路径中。我们将在本章的结束部分的GNU Makefile中以编程方式将这些添加到我们的路径中。在下一节中，我们将讨论如何使用Docker利用CUDA。
- en: Docker for GPU-enabled programming
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于GPU启用编程的Docker
- en: If you'd like to use Docker for your GPU-enabled programming in this chapter,
    you can perform the following steps, but to use this, you must have a compatible
    NVIDIA CUDA GPU in your computer. You can find a full list of enabled cards at [https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本章中使用Docker进行GPU启用的编程，可以执行以下步骤，但是为了使用此功能，您必须在计算机上拥有兼容的NVIDIA CUDA GPU。您可以在[https://developer.nvidia.com/cuda-gpus](https://developer.nvidia.com/cuda-gpus)找到已启用的卡的完整列表。
- en: We might not use Docker in this way in a production environment for GPU-accelerated
    computing, because you'd most likely want to be as close to the hardware as possible
    for GPU-accelerated programming, but I've chosen to use this methodology in this
    chapter in order to have a reproducible build for the consumer of this book to
    use.  Most of the time a reproducible build is an acceptable trade off for the
    slight performance penalty of using containerized methodologies.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，我们可能不会以这种方式使用Docker进行GPU加速计算，因为您很可能希望尽可能接近硬件以进行GPU加速编程，但我选择在本章中使用这种方法，以便本书的使用者有一个可重现的构建。大多数情况下，可重现的构建是使用容器化方法略有性能损失的可接受折衷方案。
- en: If you're unsure of what your NVIDIA-enabled GPU supports, you can use the `cuda-z` utility to
    find more information about your graphics card. The executable for this program
    can be found at [http://cuda-z.sourceforge.net/](http://cuda-z.sourceforge.net/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定您的NVIDIA启用的GPU支持什么，您可以使用`cuda-z`实用程序来查找有关您的显卡的更多信息。该程序的可执行文件可以在[http://cuda-z.sourceforge.net/](http://cuda-z.sourceforge.net/)找到。
- en: 'After you download the version for your particular OS, you should be able to
    execute the file like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下载适用于您特定操作系统的版本后，您应该能够执行以下文件：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You''ll see an output that gives you all sorts of information about the card
    you''re currently using:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个输出，其中包含有关您当前使用的卡的各种信息：
- en: '![](img/967739f9-a0a3-46c0-8cf1-01bbc0876823.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/967739f9-a0a3-46c0-8cf1-01bbc0876823.png)'
- en: 'Once you''re certain your card supports the GPU processing required, we can
    use Docker to hook into your GPU for processing. To do so, we will go through
    the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定您的卡支持所需的GPU处理，我们可以使用Docker来连接到您的GPU进行处理。为此，我们将按照以下步骤进行：
- en: 'Enable the NVIDIA container toolkit for your computer. With my Fedora test
    system, I had to make a small tweak to this by changing my distribution to ``centos7``—the
    installed RPMs still worked as expected:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的计算机启用NVIDIA容器工具包。对于我的Fedora测试系统，我不得不通过将我的发行版更改为``centos7``来进行一些小调整——安装的RPM仍然按预期工作：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The full instructions for installing this on other OSes can be found at [https://github.com/NVIDIA/nvidia-docker#quickstart](https://github.com/NVIDIA/nvidia-docker#quickstart%7C).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他操作系统上安装的完整说明可以在[https://github.com/NVIDIA/nvidia-docker#quickstart](https://github.com/NVIDIA/nvidia-docker#quickstart%7C)找到。
- en: 'Install the `nvidia-container-toolkit`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`nvidia-container-toolkit`：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Restart Docker in order to pick up these new changes:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Docker以应用这些新更改：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Disable SELINUX so that your computer has the ability to use your GPU for these
    requests:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用SELINUX，以便您的计算机能够使用GPU进行这些请求：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Execute a test `docker run` to ensure that you are able to perform GPU actions
    within Docker and inspect the information about your particular NVIDIA card:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个测试`docker run`，以确保您能够在Docker中执行GPU操作，并检查有关您特定NVIDIA卡的信息：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next section, we'll go through how to set up a CUDA GPU enabled machine
    in Google Cloud Platform.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何在Google Cloud Platform上设置支持CUDA GPU的机器。
- en: CUDA on GCP
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCP上的CUDA
- en: If you don't have the necessary hardware or you'd like to run your workloads
    for your GPU-enabled code in the cloud, you may decide that you'd rather use CUDA
    on a shared hosting environment. In the following example, we'll show you how
    to get set up using GPUs on GCP.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有必要的硬件，或者您想在云中运行支持GPU的代码，您可能决定您更愿意在共享托管环境中使用CUDA。在下面的示例中，我们将向您展示如何在GCP上使用GPU。
- en: There are many other hosted GPU providers (you can see all of them listed in
    the *GPU-accelerated computing – utilizing the hardware* section of this chapter)—we
    are going to use GCP's GPU instances as an example here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他托管的GPU提供商（您可以在本章的*GPU加速计算-利用硬件*部分中看到所有这些提供商的列表）——我们将在这里以GCP的GPU实例为例。
- en: You can learn more about GCP's GPU offerings at [https://cloud.google.com/gpu](https://cloud.google.com/gpu).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://cloud.google.com/gpu](https://cloud.google.com/gpu)了解更多关于GCP的GPU提供。
- en: Creating a VM with a GPU
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有GPU的虚拟机
- en: We need to create a Google Compute Engine instance in order to be able to utilize
    GPUs on GCP.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个Google Compute Engine实例，以便能够在GCP上利用GPU。
- en: 'You may need to increase your GPU quota.  To do so, you can follow the steps
    at the following URL:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要增加GPU配额。要这样做，您可以按照以下网址的步骤进行：
- en: https://cloud.google.com/compute/quotas#requesting_additional_quota
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: https://cloud.google.com/compute/quotas#requesting_additional_quota
- en: 'At the time of writing, the NVIDIA P4 GPU is the least expensive on the platform,
    and has ample power to demonstrate our work.  You can verify your quota by checking
    the NVIDIA P4 GPUs metric on the IAM Admin quotas page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，NVIDIA P4 GPU是平台上最便宜的，而且具有足够的性能来展示我们的工作。您可以通过在IAM管理员配额页面上检查NVIDIA P4
    GPU指标来验证您的配额：
- en: '![](img/8736ef6d-39c6-4752-97b7-4652f0ff2bee.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8736ef6d-39c6-4752-97b7-4652f0ff2bee.png)'
- en: 'To do this, we can visit the VM instances page on the Google Cloud console.
    A screenshot of this page follows. Click on the Create button in the center of
    the screen:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以访问Google Cloud控制台上的VM实例页面。以下是此页面的截图。点击屏幕中央的创建按钮：
- en: '![](img/6a30a93c-431c-4daf-9ac0-95fffc36c1e8.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a30a93c-431c-4daf-9ac0-95fffc36c1e8.png)'
- en: 'We next create an Ubuntu 18.04 VM with a GPU attached. Our VM instance configuration
    for this example is shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个附加了GPU的Ubuntu 18.04 VM。我们的VM实例配置示例如下截图所示：
- en: '![](img/953115ed-637a-4d16-be10-f2a23a328187.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/953115ed-637a-4d16-be10-f2a23a328187.png)'
- en: We are using Ubuntu 18.04 here as an example, rather than Fedora 29, to show
    how to set CUDA up for multiple architectures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用Ubuntu 18.04作为示例，而不是Fedora 29，以展示如何为多种架构设置CUDA。
- en: 'Our OS and other configuration parameters are shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的操作系统和其他配置参数如下截图所示：
- en: '![](img/ab76ddc8-01ba-4415-b116-41b9acdbab27.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab76ddc8-01ba-4415-b116-41b9acdbab27.png)'
- en: 'After we click the Create button, we are taken back to the VM instances page.
    Wait for your VM to be fully provisioned (it''ll have a green checkmark to the
    left of its name):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 点击创建按钮后，我们将返回到VM实例页面。等待您的VM完全配置好（它的名称左侧会有一个绿色的勾号）：
- en: '![](img/23d21efe-e7d0-4608-bf27-8204a4517118.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23d21efe-e7d0-4608-bf27-8204a4517118.png)'
- en: 'Next, we can SSH to the instance, as seen in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以SSH到实例，如下截图所示：
- en: '![](img/b333f11f-0d5f-4507-b644-59599f3cf668.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b333f11f-0d5f-4507-b644-59599f3cf668.png)'
- en: In the next subsections, we will install all the necessary dependencies for
    running our GPU enabled CGo program.  I've also included a script that performs
    all these actions at the end of the explanation for your convenience.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将安装运行支持GPU的CGo程序所需的所有依赖项。我还在解释的最后包括了一个执行所有这些操作的脚本，以方便您使用。
- en: Install the CUDA driver
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CUDA驱动程序
- en: 'Follow the instructions from [https://cloud.google.com/compute/docs/gpus/install-drivers-gpu](https://cloud.google.com/compute/docs/gpus/install-drivers-gpu)
    to get the NVIDIA CUDA drivers installed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[https://cloud.google.com/compute/docs/gpus/install-drivers-gpu](https://cloud.google.com/compute/docs/gpus/install-drivers-gpu)中的说明安装NVIDIA
    CUDA驱动程序：
- en: 'Retrieve the CUDA repository:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索CUDA存储库：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Install the `.deb` package:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`.deb`软件包：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the NVIDIA GPG key to the apt sources keyring:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将NVIDIA GPG密钥添加到apt源密钥环：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install the NVIDIA CUDA drivers:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装NVIDIA CUDA驱动程序：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now have a CUDA-enabled GPU on our GCP VM. We can validate this with the
    `nvidia-smi` command:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在GCP VM上有一个支持CUDA的GPU。我们可以使用`nvidia-smi`命令验证这一点：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will see the following output in the screenshot:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在截图中看到以下输出：
- en: '![](img/94ef6bd0-d6a3-47e2-bcb3-a1afe673d7e0.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94ef6bd0-d6a3-47e2-bcb3-a1afe673d7e0.png)'
- en: Install Docker CE on GCP
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCP上安装Docker CE
- en: 'We next need to install Docker CE on our CUDA enabled GCE VM. To install Docker
    CE on our VM, we can follow the instructions on this page:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在启用CUDA的GCE VM上安装Docker CE。要在我们的VM上安装Docker CE，我们可以按照此页面上的说明进行操作：
- en: '[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)'
- en: 'At the time of writing this book, the following steps were necessary:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，以下步骤是必要的：
- en: 'Validate there aren''t any other docker versions on the host:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证主机上没有其他docker版本：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Make sure our repositories are up to date:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们的存储库是最新的：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Install the necessary dependencies to install docker CE:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装安装docker CE所需的依赖项：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the docker CE repository:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加docker CE存储库：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run an update to ensure the docker CE repository is up to date:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行更新以确保docker CE存储库是最新的：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Install the necessary docker dependencies:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的docker依赖项：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We now have a working instance of Docker CE on our host.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在主机上有一个可用的Docker CE实例。
- en: Installing NVIDIA Docker on GCP
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GCP上安装NVIDIA Docker
- en: 'To install the NVIDIA docker driver on our VM, we can follow the instructions
    on this page:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的VM上安装NVIDIA docker驱动程序，我们可以按照此页面上的说明进行操作：
- en: '[https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster](https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster](https://github.com/NVIDIA/nvidia-docker#ubuntu-16041804-debian-jessiestretchbuster)'
- en: 'Set a distribution variable:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个分发变量：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `nvidia-docker` repo gpg key and apt repository:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`nvidia-docker`存储库gpg密钥和apt存储库：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Install the nvidia-container-toolkit:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装nvidia-container-toolkit：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Restart your VM for this driver to take effect.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动您的VM以使此驱动程序生效。
- en: Scripting it all together
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容脚本化
- en: 'The following bash script performs all of the previous actions together. First,
    we install the CUDA driver:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下bash脚本将所有先前的操作组合在一起。首先，我们安装CUDA驱动程序：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then install Docker CE:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们安装Docker CE：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally we install the `nvidia-docker` driver:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后我们安装`nvidia-docker`驱动程序：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is included in the repo at [https://git/HighPerformanceWithGo/9-gpu-parallelization-in-go/gcp_scripts](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/9-gpu-parallelization-in-go/gcp_scripts/nvidia-cuda-gcp-setup.sh)
    and can be executed by running:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含在[https://git/HighPerformanceWithGo/9-gpu-parallelization-in-go/gcp_scripts](https://github.com/bobstrecansky/HighPerformanceWithGo/blob/master/9-gpu-parallelization-in-go/gcp_scripts/nvidia-cuda-gcp-setup.sh)中的repo中，并且可以通过运行以下命令来执行：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: within the directory.    In the next section, we'll go through an example CUDA
    program that is executed using Cgo.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录中。在下一节中，我们将通过一个使用Cgo执行的示例CUDA程序。
- en: CUDA – powering the program
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA-推动程序。
- en: 'After we have all of our CUDA dependencies installed and running, we can start
    out with a simple CUDA C++ program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了所有CUDA依赖项并运行后，我们可以从一个简单的CUDA C++程序开始：
- en: 'First, we''ll include all of our necessary header files and define the number
    of elements we''d like to process. `1 << 20` is 1,048,576, which is more than
    enough elements to show an adequate GPU test. You can shift this if you''d like
    to see the difference in processing time:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将包括所有必要的头文件，并定义我们想要处理的元素的数量。`1 << 20`是1,048,576，这已经足够多的元素来展示一个合适的GPU测试。如果您想要查看处理时间的差异，可以进行移位：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our `multiply` function is wrapped in a `__global__` specifier. This allows
    `nvcc`, the CUDA-specific C++ compiler, to run a particular function on the GPU.
    This multiply function is relatively straightforward: it takes the `a` and `b`
    arrays, multiplies them together using some CUDA magic, and returns the value
    in the `c` array:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`multiply`函数被包装在一个`__global__`说明符中。这允许`nvcc`，CUDA特定的C++编译器，在GPU上运行特定的函数。这个乘法函数相对简单：它使用一些CUDA魔法将`a`和`b`数组相乘，并将值返回到`c`数组中：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This CUDA magic is referencing the parallel-processing functionality of the
    GPU. The variables are defined as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CUDA魔法是指GPU的并行处理功能。变量定义如下：
- en: '`gridDim.x`: The number of thread blocks available on the processor'
  id: totrans-184
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gridDim.x`：处理器上可用的线程块数'
- en: '`blockDim.x`: The number of threads in each block'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockDim.x`：每个块中的线程数'
- en: '`blockIdx.x`: The index of the current block within the grid'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockIdx.x`：网格内当前块的索引'
- en: '`threadId.x`: The index of the current thread within the block'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threadId.x`：块内当前线程的索引'
- en: 'We then need to add an `extern "C"` call to have a C-style linkage for this
    particular function, so we can effectively call this function from our Go code.
    This `cuda_multiply` function creates three arrays:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要添加一个`extern "C"`调用，以便为这个特定函数使用C风格的链接，这样我们就可以有效地从我们的Go代码中调用这个函数。这个`cuda_multiply`函数创建了三个数组：
- en: '`a` and `b`, which store random numbers between 1 and 10'
  id: totrans-189
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`和`b`，它们存储1到10之间的随机数'
- en: '`c`, which stores the result of the multiplication of `a` and `b`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`，它存储了`a`和`b`的乘积的结果'
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then create our arrays of random floats:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建我们的随机浮点数数组：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then perform our multiply function (which we defined at the beginning of
    our file) based on a block size.  We calculate the number of blocks we''d like
    to use based on the number:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行我们的乘法函数（我们在文件开头定义的），基于块大小。我们根据数字计算出我们想要使用的块数：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After our multiplication is completed, we will wait for the GPU to finish before
    accessing our information on the host: `cudaDeviceSynchronize();`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的乘法后，我们将等待GPU完成，然后才能访问我们在主机上的信息：`cudaDeviceSynchronize();`。
- en: 'We can then print the values of the multiplication that we performed to the
    screen in order to let the end user see the computations we are performing. This
    is commented out in the code, as printing to `stdout` doesn''t show a very good
    performance story for this particular code. You can uncomment it if you''d like
    to see the computation that is occurring:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以将我们执行的乘法的值打印到屏幕上，以便让最终用户看到我们正在执行的计算。这在代码中被注释掉了，因为打印到`stdout`对于这段特定的代码来说并不显示很好的性能。如果您想要查看正在发生的计算，可以取消注释：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then free the GPU memory that we allocated for the multiply function with
    `cudaMallocManaged()` by calling `cudaFree` on each of our array pointers, followed
    by returning `0` to finish up our program:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们释放为乘法函数分配的GPU内存，通过在每个数组指针上调用`cudaFree`，然后返回`0`来完成我们的程序：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will then add our header file, `cuda_multiply.h`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加我们的头文件`cuda_multiply.h`：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Our Go program in this chapter is just a wrapper around the `cuda_multiply.cu`
    function that we've created with a little syntactical sugar.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们的Go程序只是围绕我们使用一些语法糖创建的`cuda_multiply.cu`函数的包装器。
- en: 'We instantiate `main` and import the necessary packages:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实例化`main`并导入必要的包：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then add the necessary `CFLAGS` and `LDFLAGS` that we need in order to reference
    the libraries that we have created with our nvcc make, as well as the system libraries.
    It''s important to note here that these comments, referred to as *preambles* in
    cgo code, are used as the header while compiling the C parts of our package. We
    can include any C code that is necessary here in order to make the Go portion
    of our code more palatable. If you''re planning on using any of the following
    styles of flags, they must be preempted with a `#cgo` directive to tweak the behavior
    of the underlying compiler:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加了我们需要的`CFLAGS`和`LDFLAGS`，以便引用我们使用nvcc make创建的库，以及系统库。这里需要注意的是，这些注释，在cgo代码中称为*preambles*，在编译包的C部分时用作头文件。我们可以在这里包含任何必要的C代码，以使我们的Go代码更易于理解。如果您计划使用以下任何一种风格的标志，它们必须以`#cgo`指令为前缀，以调整底层编译器的行为：
- en: '`CFLAGS`'
  id: totrans-207
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFLAGS`'
- en: '`CPPFLAGS`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPPFLAGS`'
- en: '`CXXFLAGS`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXXFLAGS`'
- en: '`FFLAGS`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FFLAGS`'
- en: '`LDFLAGS`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDFLAGS`'
- en: 'We then import the pseudo-package `C`, which allows us to execute the C that
    we wrote (recall our `extern C` call in our `cuda_multiply.cu` file). We also
    add a timing wrapper around this function in order to see how long it takes to
    execute this function:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导入伪包`C`，这使我们能够执行我们编写的C代码（回想一下我们在`cuda_multiply.cu`文件中的`extern C`调用）。我们还在这个函数周围添加了一个计时包装器，以便查看执行这个函数需要多长时间：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A Makefile is provided for the Docker container that we are going to build
    next. Our Makefile defines a method to build our nvcc library, run our Go code,
    and clean up our nvcc library:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为接下来要构建的Docker容器提供一个Makefile。我们的Makefile定义了一个方法来构建我们的nvcc库，运行我们的Go代码，并清理我们的nvcc库：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our Dockerfile ties it all together for our demonstration to be very easily
    reproducible:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Dockerfile将所有内容整合在一起，以便我们的演示可以非常容易地再现：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we will build and run our Docker container. The following is the output
    from a cached build to truncate the build steps for brevity:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将构建和运行我们的Docker容器。以下是来自缓存构建的输出，以缩短构建步骤的长度：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can then execute our Docker container with the following command (optionally
    with sudo depending on how your docker daemon is configured):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令执行我们的Docker容器（根据您的docker守护程序配置情况，可能需要使用sudo）：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The follwing is the output of the preceding command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是前述命令的输出：
- en: '![](img/eb5b521c-f3a6-443c-9d6e-2d3b125b8663.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb5b521c-f3a6-443c-9d6e-2d3b125b8663.png)'
- en: Pretty impressive for such a large multiplication calculation! With high computational
    workloads, GPU programming can often be a good solution for very quick calculations.
    An equivalent C++ program using just the CPU takes roughly 340 ms to run on the
    same machine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如此大的乘法计算来说，相当令人印象深刻！在高计算工作负载下，GPU编程通常是非常快速计算的良好解决方案。在同一台机器上，仅使用CPU的等效C++程序大约需要340毫秒才能运行。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about cgo, GPU-accelerated programming, CUDA, Make
    commands, C-style linking for Go programs, and executing a GPU-enabled process
    within a Docker container. Learning about all of these individual elements helped
    us to develop a performant GPU-driven application that can make some very large
    mathematical calculations. These steps could be repeated to do a lot of very large-scale
    computations in a performant manner.  We also learned how to set up a GPU enabled
    VM in GCP so that we can use cloud resources to perform our GPU computations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了cgo、GPU加速编程、CUDA、Make命令、用于Go程序的C风格链接，以及在Docker容器中执行启用GPU的进程。学习所有这些单独的元素帮助我们开发了一个性能良好的GPU驱动应用程序，可以进行一些非常大的数学计算。这些步骤可以重复进行，以便以高性能的方式进行大规模计算。我们还学会了如何在GCP中设置启用GPU的VM，以便我们可以使用云资源来执行GPU计算。
- en: In the next chapter, we'll discuss runtime evaluations in Go.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Go语言中的运行时评估。
