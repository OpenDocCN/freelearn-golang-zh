- en: Building and Deploying Go Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和部署Go代码
- en: Once we have come up with a method to write performant Go code, we need to ship
    it, validate it, and continue iterating it. The first step of this process is
    to deploy the new Go code. Go's code is compiled into binaries, which allows for
    the modular deployment of new Go code as we iterate through code development.
    We can push this out to one or multiple places in order to test against different
    environments. Doing this will allow us to optimize our code to fully utilize the
    throughput that will be available to us in our system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们找到了编写高性能Go代码的方法，我们需要部署它，验证它，并继续迭代它。这个过程的第一步是部署新的Go代码。Go的代码被编译成二进制文件，这允许我们在代码开发的迭代过程中以模块化的方式部署新的Go代码。我们可以将其推送到一个或多个位置，以便针对不同的环境进行测试。这样做将使我们能够优化我们的代码，充分利用系统中将可用的吞吐量。
- en: 'In this chapter, we will learn all about the Go build process. We''ll look
    at how the Go compiler builds binaries, and we''ll use this knowledge to build
    right-sized, optimized binaries for the platform at hand. We will cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习有关Go构建过程的所有内容。我们将看看Go编译器如何构建二进制文件，并利用这些知识为当前平台构建合适大小、优化的二进制文件。我们将涵盖以下主题：
- en: Building Go binaries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Go二进制文件
- en: Using `go clean` to remove object files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go clean`来删除对象文件
- en: Using `go get` to download and install dependencies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go get`来下载和安装依赖项
- en: Using `go mod` for dependency management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go mod`进行依赖管理
- en: Using `go list` to list packages and modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go list`来列出包和模块
- en: Using `go run` to execute programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go run`来执行程序
- en: Using `go install` to install packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go install`来安装包
- en: These topics will help us build efficient Go binaries from our source code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题将帮助我们从我们的源代码构建高效的Go二进制文件。
- en: Building Go binaries
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Go二进制文件
- en: In [Chapter 10](6a020af6-5b7c-48af-95a7-cf52014ae1ca.xhtml), *Compile Time Evaluations
    in Go*, we discussed some Go build optimizations that can potentially help optimize
    our build strategy. Go's build system has quite a few options that can help the
    system operator add additional parameterization to their build strategy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](6a020af6-5b7c-48af-95a7-cf52014ae1ca.xhtml)中，*Go中的编译时评估*，我们讨论了一些可能有助于优化我们构建策略的Go构建优化。Go的构建系统有很多选项，可以帮助系统操作员向他们的构建策略添加额外的参数化。
- en: 'The Go tool has many different methodologies for building our source code.
    Let''s investigate top-level understandings of each, and then we will discuss
    each package in more depth. Knowing the key differences between these commands
    may help you to understand how they interplay with one another and choose the
    right tool for the job. Let''s have a look at them:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go工具有许多不同的方法来构建我们的源代码。让我们先了解每个顶层理解，然后我们将更深入地讨论每个包。了解这些命令之间的关键区别可能会帮助您了解它们如何相互作用，并选择适合工作的正确工具。让我们来看看它们：
- en: '`go build`: Builds a binary for your project, compiling packages and dependencies'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go build`：为您的项目构建二进制文件，编译包和依赖项'
- en: '`go clean`: Removes object and cached files from package source directories'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go clean`：从包源目录中删除对象和缓存文件'
- en: '`go get`: Downloads and installs packages and their dependencies'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go get`：下载并安装包及其依赖项'
- en: '`go mod`: Go''s (relatively new) built-in dependency module system'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go mod`：Go的（相对较新的）内置依赖模块系统'
- en: '`go list`: Lists named packages and modules and can display important build
    information about files, imports, and dependencies'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go list`：列出命名的包和模块，并显示有关文件、导入和依赖项的重要构建信息'
- en: '`go run`: Runs and compiles a named Go program'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go run`：运行和编译命名的Go程序'
- en: '`go install`: Builds the binary for your project, moves the binary to `$GOPATH/bin`,
    and caches all non-main packages'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go install`：为您的项目构建二进制文件，将二进制文件移动到`$GOPATH/bin`，并缓存所有非主要包'
- en: In this chapter, we are going to investigate these different pieces of the Go
    build system. As we learn more about how these programs interoperate with one
    another, we will be able to see how to use them to our advantage to build slim,
    feature-filled binaries that will work as we expect them to on the supported architectures
    and operating systems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将调查Go构建系统的这些不同部分。随着我们对这些程序如何相互操作的了解越来越多，我们将能够看到如何利用它们来构建适合我们期望的支持架构和操作系统的精简、功能丰富的二进制文件。
- en: In the next section, we shall see through `go build`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过`go build`来看一下。
- en: Go build – building your Go code
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go build - 构建您的Go代码
- en: 'The invocation stanza for go build is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: go build的调用标准如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining an output with `-o` compiles a binary using a specifically named file.
    This is helpful when you have a particular naming convention that you want to
    keep for your file, or if you want to name binaries based on different build parameters
    (platform/OS/git SHA and others).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-o`定义输出，使用特定命名的文件编译二进制文件。当您有特定的命名约定要保留到您的文件中，或者如果您想根据不同的构建参数（平台/操作系统/git
    SHA等）命名二进制文件时，这将非常有帮助。
- en: Packages can be defined as a list of go source files or they can be omitted.
    If a list of go source files is specified, the build program will use the list
    of files that were passed as a group that specifies a single package. If no packages
    are defined, the build program will validate that the packages within the directory
    can be built, but it will discard the results of the build.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 包可以定义为一组go源文件，也可以省略。如果指定了一组go源文件的列表，构建程序将使用作为指定单个包的组传递的文件列表。如果未定义任何包，构建程序将验证目录中的包是否可以构建，但将丢弃构建的结果。
- en: Build flags
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建标志
- en: 'Go''s build flags are all shared by the `build`, `clean`, `install`, `list`,
    `run`, and `test` commands. A table stating the build flags and their usage descriptions
    is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go的构建标志被`build`、`clean`、`install`、`list`、`run`和`test`命令共享。以下是一个表格，列出了构建标志及其用法描述：
- en: '| **Build flag** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **构建标志** | **描述** |'
- en: '| `-a` | Forces packages to be rebuilt. This can be especially handy if you''d
    like to make sure that all of your dependencies are up to date. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 强制重新构建包。如果您想确保所有依赖项都是最新的，这可能特别方便。|'
- en: '| `-n` | Prints the commands that the compiler utilizes but doesn''t run the
    commands (akin to a dry run in other languages). This is useful to see how a package
    gets compiled. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|`-n` | 打印编译器使用的命令，但不运行命令（类似于其他语言中的干运行）。这对于查看包的编译方式很有用。'
- en: '| `-p n` | Parallelizes your build commands. By default, this value is set
    to the number of CPUs that are available to the build system. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|`-p n` | 并行化构建命令。默认情况下，此值设置为构建系统可用的CPU数量。'
- en: '| `-race` | Enables race detection. Only certain architectures have the ability
    to detect race detections:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|`-race` | 启用竞争检测。只有某些架构才能检测到竞争检测：'
- en: linux/amd64
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: linux/amd64
- en: freebsd/amd64
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: freebsd/amd64
- en: darwin/amd64
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: darwin/amd64
- en: windows/amd64
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: windows/amd64
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `-msan` | Detects uninitialized memory reads in C. This is only supported
    on Linux with amd64 or arm64 architectures, and it is necessary to use a clang/LLVM
    compiler for the host. This can be called with `CC=clang go build -msan example.go`.
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|`-msan` | 检测C中未初始化的内存读取。这仅在Linux上支持amd64或arm64架构，并且需要使用clang/LLVM编译器进行主机。可以使用`CC=clang
    go build -msan example.go`进行调用。'
- en: '| `-v` | As the program is compiled, the names of the packages that are built
    are listed to stdout. This can help verify which packages are used for the build.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|`-v` | 在编译程序时，构建的包的名称将列在stdout中。这有助于验证用于构建的包。'
- en: '| `-work` | Prints the value of the temporary work directory Go uses in order
    to build the binary. This is usually stored in `/tmp/` by default. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|`-work` | 打印Go在构建二进制文件时使用的临时工作目录的值。这通常默认存储在`/tmp/`中。'
- en: '| `-x` | Shows all of the commands that were used during the build process.
    This can be helpful to determine how a package is built. See the *Build information*
    section for more information. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|`-x` | 显示构建过程中使用的所有命令。这有助于确定如何构建包。有关更多信息，请参见*构建信息*部分。|'
- en: '| `-asmflags ''[pattern=]arg list''` | A list of arguments to pass when `go
    tool asm` is invoked. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|`-asmflags ''[pattern=]arg list''` | 调用`go tool asm`时要传递的参数列表。'
- en: '| `-buildmode=type` | This tells the build command which type of object file
    we''d like to build. There are currently a couple of type options for `buildmode`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|`-buildmode=type` | 这告诉构建命令我们想要构建哪种类型的目标文件。目前，`buildmode`有几种类型选项：'
- en: '`archive`: Builds non-main packages into `.a` files.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`archive`: 将非主包构建为`.a`文件。'
- en: '`c-archive`: Builds the main package and all of its imports into a C archive
    file.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c-archive`: 将主包和其所有导入项构建为C存档文件。'
- en: '`c-shared`: Builds the main package and its imports into a C shared library.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c-shared`: 将主包和其导入项构建为C共享库。'
- en: '`default`: A list of main packages is created.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`: 创建主包列表。'
- en: '`shared`: Combines all non-main packages into a single shared library.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared`: 将所有非主包合并为单个共享库。'
- en: '`exe`: Builds main packages and their imports into executables.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exe`: 将主包和其导入项构建为可执行文件。'
- en: '`pie`: Builds main packages and their imports into **position-independent executables** (**PIE**).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pie`: 将主包和其导入项构建为**位置无关可执行文件**（**PIE**）。'
- en: '`plugin`: Builds main packages and their imports into a Go plugin.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugin`: 将主包和其导入项构建为Go插件。'
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `-compiler name` | Determines which compiler to use. Common uses are `gccgo`
    and `gc`. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|`-compiler name` | 确定要使用的编译器。常见用途是`gccgo`和`gc`。'
- en: '| `-gccgoflags` | `gccgo` compiler and linker invocation flags. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|`-gccgoflags` | `gccgo`编译器和链接器调用标志。|'
- en: '| `-gcflags` | `gc` compiler and linker invocation flags. See the *Compiler
    and linker* section for more details. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|`-gcflags` | `gc`编译器和链接器调用标志。有关更多详细信息，请参见*编译器和链接器*部分。'
- en: '| `-installsuffix suffix` | Adds a suffix to the name of the package installation
    directory. This is used in order to keep the output separate from default builds.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|`-installsuffix suffix` | 向包安装目录的名称添加后缀。这是为了使输出与默认构建分开而使用的。'
- en: '| `-ldflags ''[pattern=]arg list'' ` | Go tool link invocation arguments. See
    the *Compiler and linker* section for more details. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|`-ldflags ''[pattern=]arg list''` | Go工具链接调用参数。有关更多详细信息，请参见*编译器和链接器*部分。'
- en: '| `-linkshared` | After a `-buildmode=shared` invocation occurs, this flag
    links against the newly created shared libraries. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|`-linkshared` | 在进行`-buildmode=shared`调用后，此标志将链接到新创建的共享库。'
- en: '| `-mod` | Determines which module download mode to use. At the time of writing,
    there are two options: `- readonly` or `vendor`. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|`-mod` | 确定要使用的模块下载模式。在撰写本文时，有两个选项：`- readonly`或`vendor`。'
- en: '| `-pkgdir dir` | Utilize the `dir` defined to install and load all packages.
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|`-pkgdir dir` | 利用定义的`dir`来安装和加载所有包。'
- en: '| `-tags tag,list` | A list of build tags that are to be satisfied during the
    build. This list is passed as a comma-separated list. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|`-tags tag,list` | 要在构建过程中满足的构建标签列表。此列表以逗号分隔的形式传递。'
- en: '| `-trimpath` | The resulting built executable will use a different naming
    scheme for filesystem paths during an executable build. These are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|`-trimpath` | 结果构建的可执行文件将在可执行文件构建期间使用不同的文件系统路径命名方案。这些如下：'
- en: Go (for the standard library)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go（用于标准库）
- en: path @version (for go modules)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径@版本（用于go模块）
- en: plain import path (while using `GOPATH`)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通导入路径（使用`GOPATH`）
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `-toolexec ''cmd args''` | Invokes toolchain programs, such as debuggers
    or other interactive programs. This is used for programs such as vet and asm. 
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|`-toolexec ''cmd args''` | 调用工具链程序，例如调试器或其他交互式程序。这用于诸如vet和asm的程序。'
- en: With all of this information, you'll be able to build correct linker flags impactfully.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些信息，您将能够有效地构建正确的链接器标志。
- en: Build information
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建信息
- en: To garner some understanding of the build process, let's take a look at some
    build examples so we can gain some insight into how the build tooling works together.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解构建过程，让我们看一些构建示例，以便更好地了解构建工具是如何协同工作的。
- en: 'Let''s say we want to build a simple HTTP server that has a Prometheus exporter.
    We can create an exporter like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个简单的HTTP服务器，其中有一个Prometheus导出器。我们可以这样创建一个导出器：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After we have our package ready, we can build our package with the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的包准备好后，我们可以使用以下命令构建我们的包：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we build this binary, we will see a couple of things coming back to stdout
    (since we passed the `-x` flag to see the commands that were used during the process).
    Let''s take a look:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这个二进制文件时，我们会看到一些东西回到stdout（因为我们传递了`-x`标志来查看在过程中使用的命令）。让我们来看一下：
- en: 'We are going to truncate the output so that the results are easier to read.
    If you test this out yourself, you''ll see a much larger build output:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将截断输出，以便结果更易于阅读。如果你自己测试一下，你会看到更大的构建输出：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This sets a temporary working directory for the build. As we mentioned previously,
    this usually lives in the `/tmp/` directory unless otherwise specified:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为构建设置了一个临时工作目录。正如我们之前提到的，这通常位于`/tmp/`目录中，除非另有规定：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A sub-working directory is also created by the compiler:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器还创建了一个子工作目录：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A linking configuration is created and added. This adds all sorts of different
    arguments to the linking configuration:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加了一个链接配置。这会向链接配置添加各种不同的参数：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The package for command-line arguments is referenced from the cache:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行参数的包是从缓存中引用的：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`fmt` is the printing package we use to display `fmt.Println("Prometheus Handler
    listening on port ", port)`. This is referenced like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt`是我们用来显示`fmt.Println("Prometheus Handler listening on port ", port)`的打印包。这样引用：'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The compiler also adds the package for the Prometheus HTTP client library. After
    this, there are many other references that are added to the build. This has been
    truncated for brevity.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器还为Prometheus HTTP客户端库添加了包。之后，还有许多其他引用被添加到构建中。由于篇幅原因，这部分已被截断。
- en: The end of the file is signified with `EOF`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 文件末尾用`EOF`表示。
- en: 'An executable directory is created:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可执行目录：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The compiler then builds the binary using the `importcfg` that was created
    earlier:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后编译器使用之前创建的`importcfg`构建二进制文件：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A `buildid` is then added:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加了一个`buildid`：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, the binary is renamed to the filename we had for our exporter example
    (since we did not specify a different binary name with `-o`):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，二进制文件被重命名为我们在导出示例中使用的文件名（因为我们没有使用`-o`指定不同的二进制文件名）：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the work directory is removed:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，工作目录被删除：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output of the work from this program is a Go binary. In the next section,
    we'll talk about compiler and linker flags.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的工作输出是一个Go二进制文件。在下一节中，我们将讨论编译器和链接器标志。
- en: Compiler and linker flags
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器和链接器标志
- en: 'While building a Go binary, the `-gcflags` flag lets you pass optional compiler
    arguments, while the `-ldflags` flag lets you pass optional linker arguments.
    A full list of compiler and linker flags can be found by invoking the following
    commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Go二进制文件时，`-gcflags`标志允许您传递可选的编译器参数，而`-ldflags`标志允许您传递可选的链接器参数。可以通过调用以下命令找到编译器和链接器标志的完整列表：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s look at an example of utilizing compiler and linker flags. We can build
    a simple program that returns the value of an uninitialized string variable. The
    following program seems innocuous enough:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个利用编译器和链接器标志的例子。我们可以构建一个简单的程序，返回一个未初始化的字符串变量的值。以下程序看起来似乎无害：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we build this with some of the common compiler and linker flags, we will
    see some helpful output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一些常见的编译器和链接器标志构建这个，我们将看到一些有用的输出：
- en: '![](img/035f3d29-623d-495c-85a2-11918dda45ca.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/035f3d29-623d-495c-85a2-11918dda45ca.png)'
- en: 'The compiler flags that we passed here achieve the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器标志我们在这里传递的实现了以下功能：
- en: '`"-m -m"`: Prints information about the compiler''s optimization decisions.
    This is the output that we can see in the preceding screenshot after the build
    command.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"-m -m"`：打印有关编译器优化决策的信息。这是我们在构建命令后看到的前面截图中的输出。'
- en: '`"-N"`: Disables optimizations within the Go binary.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"-N"`：禁用Go二进制文件中的优化。'
- en: '`"-l"`: Disables inlining.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"-l"`：禁用内联。'
- en: 'The linker flags that we passed do the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递的链接器标志做了以下事情：
- en: '`"-X main.linkerFlag=Hi_Gophers"`: Sets a value for the `linkerFlag` variable
    in `main`. Being able to add a variable during build time is important as many
    developers want to add some sort of build parameter to their code during compilation
    time. We can pass a build date using ``date -u +.%Y%m%d%.H%M%S`` or a git commit
    version using `git rev-list -1 HEAD`. These values can be helpful later for referencing
    the state of the build.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"-X main.linkerFlag=Hi_Gophers"`：为`main`中的`linkerFlag`变量设置一个值。在构建时添加变量是很重要的，因为许多开发人员希望在编译时向他们的代码添加某种构建参数。我们可以使用``date
    -u +.%Y%m%d%.H%M%S``传递构建日期，也可以使用`git rev-list -1 HEAD`传递git提交版本。这些值以后可能对引用构建状态很有帮助。'
- en: '`"-s"`: Disables the symbol table, a data structure that stores each identifier
    in the source code alongside declaration information. This is often not needed
    for production binaries.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"-s"`：禁用符号表，这是一种存储源代码中每个标识符的数据结构，以及声明信息。这通常不需要用于生产二进制文件。'
- en: '`"-w"`: Disables DWARF generation. The dwarf table often doesn''t need to be
    saved since the Go binary includes basic type information, PC-to-line data, and
    a symbol table.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"-w"`：禁用DWARF生成。由于Go二进制文件包括基本类型信息、PC到行数据和符号表，通常不需要保存dwarf表。'
- en: 'If we build the binary using a standard method followed by using some of the
    compiler and linker flags we have available, we will be able to see a difference
    in binary size:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用标准方法构建二进制文件，然后使用一些可用的编译器和链接器标志，我们将能够看到二进制文件大小的差异：
- en: 'Non-optimized build:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非优化构建：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Optimized build:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化构建：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we can see, the `Optimized` binary is 28.78% smaller than the `nonOptimized`
    binary:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Optimized`二进制文件比`nonOptimized`二进制文件小28.78%：
- en: '![](img/96137129-bf02-41ac-a309-f719fda97509.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96137129-bf02-41ac-a309-f719fda97509.png)'
- en: Both of these binaries will perform the same function for the end user, so consider
    removing some of the build optimizations using compiler and linker flags in order
    to reduce the end resulting binary size. This can be beneficial during the storage
    and deployment of said binaries.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个二进制文件对最终用户执行相同的功能，因此考虑使用编译器和链接器标志删除一些构建优化，以减少最终生成的二进制文件大小。这在存储和部署这些二进制文件时可能是有益的。
- en: Build constraints
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建约束
- en: If you'd like to add a build constraint to your Go build, you can add a comment
    line at the beginning of the file that's only preceded by blank lines and other
    comments. The form of this comment is `// +build darwin,amd64,!cgo, android,386,cgo`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要向您的Go构建添加构建约束，可以在文件开头添加一行注释，该注释只在空行和其他注释之前。此注释的形式是`// +build darwin,amd64,!cgo,
    android,386,cgo`。
- en: This corresponds to a boolean output of `darwin AND amd64 AND (NOT cgo)) OR
    (android AND 386 AND cgo`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于`darwin AND amd64 AND (NOT cgo)) OR (android AND 386 AND cgo`的布尔输出。
- en: 'This needs to proceed with the package declaration with a newline between the
    build constraint and the package initialization. This takes the following form:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要在包声明之前，构建约束和包初始化之间有一个换行。这采用以下形式：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The complete list of build constraints can be found at [https://golang.org/pkg/go/build/#hdr-Build_Constraints](https://golang.org/pkg/go/build/#hdr-Build_Constraints).
    This list includes the following build constraints:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://golang.org/pkg/go/build/#hdr-Build_Constraints](https://golang.org/pkg/go/build/#hdr-Build_Constraints)找到完整的构建约束列表。此列表包括以下构建约束：
- en: '`GOOS`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOOS`'
- en: '`GOARCH`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GOARCH`'
- en: Compiler type (`gc` or `gccgo`)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器类型（`gc`或`gccgo`）
- en: '`cgo`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cgo`'
- en: All the 1.x Go versions (no build tags for beta or minor releases)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有1.x Go版本（beta或次要版本没有构建标签）
- en: Additional words that are listed in `ctxt.BuildTags`
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctxt.BuildTags`中列出的其他单词'
- en: 'If you have a file in your library that you''d like to exclude from your build,
    you can also add a comment in the following form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的库中有一个文件，您希望在构建中排除它，您也可以以以下形式添加注释：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inversely, you can restrict file builds to specific `GOOS`, `GOARCH`, and `cgo`
    bits using a comment in the following form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以使用以下形式的注释将文件构建限制为特定的`GOOS`、`GOARCH`和`cgo`位：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will only build a file when you're using `cgo` and building on a 386 processor
    in a Windows operating system. This is a powerful construct in the Go language
    because you have the ability to build packages based on the necessary build parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用`cgo`并在Windows操作系统的386处理器上构建时才会构建文件。这是Go语言中的一个强大构造，因为您可以根据必要的构建参数构建包。
- en: Filename conventions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件名约定
- en: 'If a file matches the `GOOS` and `GOARCH` patterns after stripping any extensions
    and the `_test` suffix (for test cases), the file will be built for that particular
    `GOOS` or `GOARCH` pattern. Patterns like so are often referenced as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件匹配`GOOS`和`GOARCH`模式，并去除任何扩展名和`_test`后缀（用于测试用例），则该文件将为特定的`GOOS`或`GOARCH`模式构建。这样的模式通常被引用如下：
- en: '`*_GOOS`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*_GOOS`'
- en: '`*_GOARCH`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*_GOARCH`'
- en: '`*_GOOS_GOARCH`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*_GOOS_GOARCH`'
- en: For example, if you have a file that's named `example_linux_arm.go`, it will
    only be built as part of the Linux arm builds.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个名为`example_linux_arm.go`的文件，它将只作为Linux arm构建的一部分构建。
- en: In the next section, we will explore the `go clean` command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨`go clean`命令。
- en: Go clean – cleaning your build directory
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go clean - 清理您的构建目录
- en: The Go command builds binaries in a temporary directory. The go clean command
    was created in order to remove extraneous object files that are created by other
    tools or when go build is manually invoked. Go clean has a usage stanza of `go
    clean [clean flags] [build flags] [packages]`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Go命令会在临时目录中构建二进制文件。go clean命令是为了删除其他工具创建的多余的对象文件或手动调用go build时创建的对象文件。Go clean有一个用法部分`go
    clean [clean flags] [build flags] [packages]`。
- en: 'The following flags are available for the clean command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于clean命令，以下标志是可用的：
- en: The `-cache` flag removes the entire go build cache. This can be helpful if
    you're trying to compare a fresh build across multiple systems or if you'd like
    to see the amount of time a fresh build takes.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-cache`标志会删除整个go构建缓存。如果您想要比较多个系统上的新构建，或者想要查看新构建所需的时间，这可能会有所帮助。'
- en: The `-i` flag removes the archive or binary that go install creates.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`标志会删除go install创建的存档或二进制文件。'
- en: The `-n` flag is a noop; printing the result removes commands but doesn't execute
    them.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`标志是一个空操作；打印结果会删除命令，但不执行它们。'
- en: The `-r` flag applies logic recursively to all the dependencies of the import
    path's packages.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`标志会递归地应用逻辑到导入路径包的所有依赖项。'
- en: The `-x` flag prints and executes the remove commands that were generated.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`标志会打印并执行生成的删除命令。'
- en: The `-cache` flag removes the whole go build cache.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-cache`标志会删除整个go构建缓存。'
- en: The `-testcache` flag removes the test results in the build cache.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-testcache`标志会删除构建缓存中的测试结果。'
- en: The `-modcache` flag removes the module download cache.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-modcache`标志会删除模块下载缓存。'
- en: 'If we want to attempt a clean build with no existing dependencies, we can use
    a command to remove items from many of the important caches in the go build system.
    Let''s take a look:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想尝试一个没有现有依赖关系的干净构建，我们可以使用一个命令从go构建系统的许多重要缓存中删除项目。让我们来看一下：
- en: 'We will build our `prometheusExporterExample` in order to validate the size
    of the build cache changing. We can find our build cache location using the go
    environment `GOCACHE` variable:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将构建我们的`prometheusExporterExample`以验证构建缓存的大小是否发生变化。我们可以使用go环境`GOCACHE`变量找到我们的构建缓存位置：
- en: '![](img/02570ce5-f34e-400f-a39f-184fec134edb.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02570ce5-f34e-400f-a39f-184fec134edb.png)'
- en: For our validation, we'll use a couple of commands in a row. First, we'll remove
    our entire cache directory with `rm -rf ~/.cache/go-build/`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的验证，我们将连续使用几个命令。首先，我们将使用`rm -rf ~/.cache/go-build/`删除整个缓存目录。
- en: Next, we can build our Go binary by running the `go build prometheusExporterExample.go` command.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过运行`go build prometheusExporterExample.go`命令来构建我们的Go二进制文件。
- en: Then, we can validate that the cache has grown significantly in size by checking
    its size with `du -sh ~/.cache/go-build/`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以通过使用`du -sh ~/.cache/go-build/`检查其大小来验证缓存的大小是否显著增加。
- en: Now, we can clean the caches using the go clean program, that is, `go clean
    -cache -modcache -i -r 2&>/dev/null`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用go clean程序来清除缓存，即`go clean -cache -modcache -i -r 2&>/dev/null`。
- en: It's important to note that some of the cache information is stored in main
    libraries, so that can't be removed by a normal user. We can get around this if
    needed by running the clean command as a superuser, but this isn't often recommended.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，一些缓存信息存储在主要库中，因此普通用户无法删除。如果需要，我们可以通过以超级用户身份运行clean命令来绕过这个问题，但这通常不被推荐。
- en: 'Then, we can validate that the cache has shrunk in size. If we look into the
    cache directory after the clean, we''ll see that we only have three items left
    in the cache directory:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以验证缓存的大小是否减小。如果我们在清理后查看缓存目录，我们会发现缓存目录中只剩下三个项目：
- en: A `README` file explaining the directory.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解释目录的`README`文件。
- en: A `log.txt` file that tells us about cache information.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个`log.txt`文件告诉我们有关缓存信息。
- en: 'A `trim.txt` file, which tells us the time of the last completed cache trim.
    In the following screenshot, we can see a cleaned build cache:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`trim.txt`文件，告诉我们上次完成缓存修剪的时间。在下面的截图中，我们可以看到一个清理后的构建缓存：
- en: '![](img/bd4592fa-bed5-483e-b348-d476141c9533.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd4592fa-bed5-483e-b348-d476141c9533.png)'
- en: Validating that you're caching the correct things as part of the build will
    speed up the build process and make for a less toilsome development experience.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 验证构建的正确缓存将加快构建过程并使开发体验更加轻松。
- en: In the next section, we'll look at the `go get` and `go mod` commands.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下`go get`和`go mod`命令。
- en: Retrieving package dependencies with go get and go mod
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用go get和go mod检索包依赖项
- en: As you construct Go programs, you'll likely run into places where you'd like
    to add dependencies. `go get` downloads and installs packages and their dependencies.
    The invocation stanza for `go get` is `go get [-d] [-f] [-t] [-u] [-v] [-fix]
    [-insecure] [build flags] [packages]`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Go程序时，您可能会遇到希望添加依赖项的地方。`go get`下载并安装包及其依赖项。`go get`的调用语法是`go get [-d] [-f]
    [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]`。
- en: Go 1.11 added preliminary support for Go modules. We learned how to utilize
    Go modules in [Chapter 6](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml), *Composing
    Readable Go Code*, under the *Go modules* section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.11增加了对Go模块的初步支持。我们在[第6章](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml)中学习了如何在*Go模块*部分中利用Go模块。
- en: A Go mod vendor is often included as part of the Go build system since we can
    use vendored dependencies in our Go programs. There are positives and negatives
    to vendoring dependencies in your code base. Having all of the required dependencies
    available locally during build time can make the build faster. If the upstream
    repository that you're using for your build dependencies changes or is removed,
    you'll have a build failure. This is because your program won't be able to satisfy
    its upstream dependencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在我们的Go程序中使用打包的依赖项，因此Go mod vendor通常作为Go构建系统的一部分。在您的代码库中打包依赖项有积极和消极的方面。在构建时本地可用所有必需的依赖项可以加快构建速度。如果您用于构建依赖项的上游存储库发生更改或被删除，您将遇到构建失败。这是因为您的程序将无法满足其上游依赖项。
- en: The negatives to having vendored dependencies include the fact that vendoring
    dependencies puts the onus of keeping the packages up to date on the programmer
    – updates from the upstream such as security updates, performance improvements,
    and stability enhancements could be lost if a dependency is vendored and not updated.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打包依赖项的消极方面包括，打包依赖项将使程序员负责保持包的最新状态 - 来自上游的更新，如安全更新、性能改进和稳定性增强可能会丢失，如果依赖项被打包而没有更新。
- en: Many enterprises take the vendored approach as they feel the safety of storing
    all of the required dependencies outweighs the need to update the vendored directory
    with newer packages from upstream as they become available.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业采用打包的方法，因为他们认为存储所有必需的依赖项的安全性胜过了需要从上游更新打包目录中的新包。
- en: 'After we initialize our go module, we vendor our dependencies and build them
    using our vendored modules:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化go模块后，我们将我们的依赖项打包并使用我们的打包模块构建它们：
- en: '![](img/afb44250-21d2-4722-b549-e2200876aef3.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afb44250-21d2-4722-b549-e2200876aef3.png)'
- en: As shown in the preceding output, we have vendored dependencies (from [https://github.com/](https://github.com/)
    and [https://golang.org/](https://golang.org/)) that are needed to satisfy our
    build constraints in our project. We can use `go mod tidy` in our builds to validate
    that `go.mod` contains all of the necessary elements for the repository.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，我们有需要满足项目构建约束的依赖项（来自[https://github.com/](https://github.com/)和[https://golang.org/](https://golang.org/)）。我们可以在我们的构建中使用`go
    mod tidy`来验证`go.mod`是否包含了仓库的所有必要元素。
- en: '`go mod tidy` adds missing modules and removes unused modules in order to validate
    our source code with the directory''s `go.mod` matches.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`go mod tidy`添加丢失的模块并删除未使用的模块，以验证我们的源代码与目录的`go.mod`匹配。'
- en: In the following section, we will learn about the `go list` command.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习`go list`命令。
- en: Go list
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go list
- en: '`go list` performs the action of listing named packages and modules, as well
    as displaying important build information about files, imports, and dependencies.
    The invocation stanza for go list is `usage: go list [-f format] [-json] [-m]
    [list flags] [build flags] [packages]`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`go list`执行列出命名的包和模块的操作，并显示有关文件、导入和依赖项的重要构建信息。`go list`的调用语法是`usage: go list
    [-f format] [-json] [-m] [list flags] [build flags] [packages]`。'
- en: 'Having access to the data structures that are the main pieces of the build
    process is powerful. We can use `go list` to find out a lot about the programs
    that we are building. For example, take the following simple program, which prints
    a message and computes a square root for the end user:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有访问构建过程的主要数据结构的权限是强大的。我们可以使用`go list`来了解我们正在构建的程序的很多信息。例如，考虑以下简单的程序，它打印一条消息并为最终用户计算平方根：
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we want to find out about all the dependencies that we have for our particular
    project, we can invoke the `go list -f '{{.Deps}}'` command.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想了解我们特定项目的所有依赖项，我们可以调用`go list -f '{{.Deps}}'`命令。
- en: 'The result will be a slice of all of the dependencies that our repository contains:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是我们的存储库包含的所有依赖项的切片：
- en: '![](img/f971b2e1-767a-4219-a5a0-4e9adb984b7c.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f971b2e1-767a-4219-a5a0-4e9adb984b7c.png)'
- en: 'The `go list` data structure can be found here: [https://golang.org/cmd/go/#hdr-List_packages_or_modules](https://golang.org/cmd/go/#hdr-List_packages_or_modules).
    It has many different parameters. One of the other popular outputs from the go
    list program is the JSON formatted output. In the following screenshot, you can
    see the output from executing `go list -json` for our `listExample.go`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`go list`数据结构可以在这里找到：[https://golang.org/cmd/go/#hdr-List_packages_or_modules](https://golang.org/cmd/go/#hdr-List_packages_or_modules)。它有许多不同的参数。从go
    list程序中得到的另一个流行输出是JSON格式的输出。在下面的截图中，您可以看到执行`go list -json`对我们的`listExample.go`的输出：'
- en: '![](img/2057923f-07ed-46e1-8575-eda631d7289c.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2057923f-07ed-46e1-8575-eda631d7289c.png)'
- en: '`go list -m -u all` will also show you the dependencies that you have. The
    resulting output will also have a second version listed in brackets, if they have
    available upgrades. This can be helpful if we want to closely monitor our dependencies
    and their upgrades using the `go mod` package.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`go list -m -u all`也会显示您的依赖项。如果它们有可用的升级，结果输出中还会列出第二个版本。如果我们想要密切监视我们的依赖项及其升级，使用`go
    mod`包可能会有所帮助。'
- en: 'If we use our Prometheus exporter example, we can see whether or not our packages
    have dependencies that need upgrading:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用我们的Prometheus导出器示例，我们可以看到我们的包是否有需要升级的依赖关系：
- en: '![](img/d12a5df1-df63-46d7-892f-46950cec2002.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d12a5df1-df63-46d7-892f-46950cec2002.png)'
- en: In this example, we can see that there are a couple of packages that have available
    upgrades. If we invoke go get for one of these dependencies, we'll be able to
    upgrade them effectively. We can upgrade the errors package listed in the preceding
    screenshot from v0.8.0 to v0.8.1 using `go get github.com/pkg/errors@v0.8.1`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到有几个包可以升级。如果我们为其中一个依赖项调用go get，我们将能够有效地升级它们。我们可以使用`go get github.com/pkg/errors@v0.8.1`将前面截图中列出的errors包从v0.8.0升级到v0.8.1。
- en: After we complete this upgrade, we can validate that the dependency has been
    upgraded by running `go list -m -u github.com/pkg/errors`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这次升级后，我们可以通过运行`go list -m -u github.com/pkg/errors`来验证依赖项是否已经升级。
- en: 'We can see this output in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面的截图中看到这个输出：
- en: '![](img/67ab2f1e-f1ae-4815-81af-79a0079e09d2.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ab2f1e-f1ae-4815-81af-79a0079e09d2.png)'
- en: In our preceding output, we can see that the errors package that's being referenced
    is now v0.8.1, rather than v0.8.0, which was shown in our previous output.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的输出中，我们可以看到被引用的errors包现在是v0.8.1，而不是我们之前输出中显示的v0.8.0。
- en: Next, let's take a look at what `go run` is.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`go run`是什么。
- en: Go run – executing your packages
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go run – 执行您的包
- en: '`go run` runs and compiles a named Go program. The invocation stanza for `go
    run` is `go run [build flags] [-exec xprog] package [arguments...]`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`go run`运行并编译一个命名的Go程序。`go run`的调用标准是`go run [build flags] [-exec xprog] package
    [arguments...]`。'
- en: Go run allows a developer to quickly compile and run a go binary in one operation.
    During this process, `go run` builds the executable file, runs it, and then deletes
    the executable file. This is particularly helpful in a development environment.
    As you rapidly iterate on your Go program, `go run` can be used as a shortcut
    to validate that the code you are changing will result in a build artifact that
    you deem acceptable for use. As we learned earlier in this chapter, the build
    flags for many of these tools are consistent.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Go run允许开发人员快速编译和运行一个go二进制文件。在这个过程中，`go run`构建可执行文件，运行它，然后删除可执行文件。这在开发环境中特别有帮助。当您快速迭代您的Go程序时，`go
    run`可以用作一个快捷方式，以验证您正在更改的代码是否会产生您认为可以接受的构建产物。正如我们在本章前面学到的，许多这些工具的构建标志是一致的。
- en: '`goRun.go` is one of the simplest possible go programs. It has no arguments,
    just an empty `main()` function invocation. We are using this as an example to
    show this process with no additional dependencies or overhead:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`goRun.go`是可能的go程序中最简单的一个。它没有参数，只是一个空的`main()`函数调用。我们使用这个作为一个例子，以展示这个过程没有额外的依赖或开销：'
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see the work output associated with a `go run` invocation by executing
    the `go run -x goRun.go` command.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`go run -x goRun.go`命令来看到与`go run`调用相关的工作输出。
- en: 'When we perform this action, we will be able to see the build parameters that
    are being called as part of the `go run` program:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此操作时，我们将能够看到作为`go run`程序的一部分调用的构建参数：
- en: '![](img/9d4b103a-02c9-44da-aeeb-7bc01600dfff.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d4b103a-02c9-44da-aeeb-7bc01600dfff.png)'
- en: This should seem eerily familiar as the output closely resembles the output
    we saw in our go build example. Then, we can see our package being invoked.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来非常熟悉，因为输出与我们在go build示例中看到的输出非常相似。然后，我们可以看到我们的包被调用。
- en: If we were to perform this same action with our Prometheus HTTP server, we would
    see that our Prometheus HTTP server is started and run as the result of executing
    the `go run` program. After we kill our process during this go run invocation,
    we'll notice that we don't have any binaries stored in our local directory. The
    `go run` invocation doesn't save these outputs by default.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对我们的Prometheus HTTP服务器执行相同的操作，我们会看到我们的Prometheus HTTP服务器是通过执行`go run`程序启动和运行的。在这个go
    run调用期间杀死进程后，我们会注意到我们的本地目录中没有存储任何二进制文件。`go run`调用不会默认保存这些输出。
- en: The Go command in the next section (`go install`) is the last one for this chapter.
    Let's see what it is all about.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节中的Go命令（`go install`）是本章的最后一个命令。让我们看看它是什么。
- en: Go install – installing your binaries
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go install – 安装您的二进制文件
- en: '`go install` compiles and installs a named Go program. The invocation stanza
    for go run is `go install [-i] [build flags] [packages]`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`go install`编译并安装一个命名的Go程序。`go run`的调用标准是`go install [-i] [build flags] [packages]`。'
- en: These are imported to `$GOPATH/pkg`. Cached items will be used on the next compilation
    if they haven't been modified. The resulting output from go install is an executable
    file that is the same as the one that gets compiled with a go build command, installed
    on the `$GOBIN` path on the system. For example, if we wanted to install our Prometheus
    HTTP server on our host, we could invoke a go install command, that is, `GOBIN=~/prod-binaries/
    go install -i prometheusExporterExample.go`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被导入到`$GOPATH/pkg`。如果它们没有被修改，下次编译时将使用缓存的项目。go install的结果输出是一个可执行文件，与使用go build命令编译的文件相同，安装在系统上的`$GOBIN`路径上。例如，如果我们想要在我们的主机上安装我们的Prometheus
    HTTP服务器，我们可以调用go install命令，即`GOBIN=~/prod-binaries/ go install -i prometheusExporterExample.go`。
- en: 'Setting our `GOBIN` variable tells the compiler where to install the compiled
    binary after compilation is complete. The go install program allows us to install
    the binary to our `GOBIN` location. The `-i` flag installs the dependencies of
    the named packages. We can see this in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们的`GOBIN`变量告诉编译器在编译完成后安装编译后的二进制文件的位置。go install程序允许我们将二进制文件安装到我们的`GOBIN`位置。`-i`标志安装命名包的依赖项。我们可以在以下截图中看到这一点：
- en: '![](img/a01089af-4fdb-4474-8777-e0b192bc60dd.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a01089af-4fdb-4474-8777-e0b192bc60dd.png)'
- en: After this is completed, we can see that we have a `prometheusExporterExample`
    binary available in the `GOBIN` location that we defined in our example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以看到我们在示例中定义的`GOBIN`位置有一个`prometheusExporterExample`二进制文件可用。
- en: In the upcoming and the last section of this chapter, we shall see how to build
    Go binaries with Docker.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的即将到来的最后一节中，我们将看到如何使用Docker构建Go二进制文件。
- en: Building Go binaries with Docker
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker构建Go二进制文件
- en: Depending on your target architecture, you may wish to build your Go binaries
    with Docker to maintain a reproducible build, limit your build size, and minimize
    the attack vectors for your service. Using multistage Docker builds can help us
    to accomplish this task.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标架构的不同，您可能希望使用Docker构建您的Go二进制文件，以保持可重现的构建，限制构建大小，并最小化服务的攻击向量。使用多阶段Docker构建可以帮助我们完成这项任务。
- en: To perform these actions, you must have a recent version of Docker installed.
    The multistage builds feature that we are going to use requires Docker version 17.05
    or higher in both the daemon and the client. You can find the most recent version
    of Docker for your OS, as well as instructions on how to install it, at [https://docs.docker.com/install/](https://docs.docker.com/install/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些操作，您必须安装最新版本的Docker。我们将要使用的多阶段构建功能要求守护程序和客户端的Docker版本都为17.05或更高。您可以在[https://docs.docker.com/install/](https://docs.docker.com/install/)找到您的操作系统的最新版本的Docker，以及安装说明。
- en: 'Consider the following simple package that logs a debug message to the screen:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下简单的包，它将一个调试消息记录到屏幕上：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we want to build this and execute it within a Docker container while minimizing
    dependencies, we can use a multistage Docker build. To do so, we can perform the
    following steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在Docker容器中构建并执行它，同时最小化依赖关系，我们可以使用多阶段Docker构建。为此，我们可以执行以下步骤：
- en: 'Initialize the current directory as the root of a module by executing the following:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下操作将当前目录初始化为模块的根：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `vendor` repositories by executing the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令添加`vendor`存储库：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We now have all of the required vendor packages (in our case, the Zap logger)
    available in our repository.  This can be seen in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的存储库中有所有必需的vendor包（在我们的情况下是Zap记录器）。可以在以下截图中看到：
- en: '![](img/ecffe0fa-4cd9-49b5-9571-2a7bf865bcc8.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecffe0fa-4cd9-49b5-9571-2a7bf865bcc8.png)'
- en: 'Build our `zapLoggerExample` Docker container.  We can build our container
    using the following Dockerfile:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的`zapLoggerExample` Docker容器。我们可以使用以下Dockerfile构建我们的容器：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Please note that we use the `golang:alpine` image for building the Go binary,
    as it's one of the simplest Docker images that contains the necessary elements
    to successfully build our Go binary. We use the `alpine:latest` image for executing
    the Go binary, as it's one of the simplest Docker images that contains the necessary
    elements to successfully run our Go binary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`golang:alpine`镜像来构建Go二进制文件，因为它是包含成功构建我们的Go二进制文件所需的必要元素的最简单的Docker镜像之一。我们使用`alpine:latest`镜像来执行Go二进制文件，因为它是包含成功运行我们的Go二进制文件所需的必要元素的最简单的Docker镜像之一。
- en: In this Dockerfile example, we are using a multistage Docker build to build
    and execute our binary. In stage 1 of 2 (the builder stage), we use a golang alpine
    image as a base.  We copy all of our files from our current directory into the `/src/` directory
    on the Docker container, we make `/src/` our working directory, and we build our
    Go binary.  Disabling cgo, building for our Linux architecture, and adding the
    vendor directory we created in *step 1* can all help minimize build size and time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Dockerfile示例中，我们使用多阶段Docker构建来构建和执行我们的二进制文件。在第1阶段（构建阶段）中，我们使用golang alpine镜像作为基础。我们将当前目录中的所有文件复制到Docker容器的`/src/`目录中，将`/src/`设置为我们的工作目录，并构建我们的Go二进制文件。禁用cgo，为我们的Linux架构构建，并添加我们在*步骤1*中创建的vendor目录都可以帮助减小构建大小和时间。
- en: In stage 2 of 2 (the executor stage), we use a basic alpine Docker image, make `/src/` our
    working directory, and copy the binary we built in the first stage to this Docker
    container. We then execute our logger as the final command within this Docker
    build.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2阶段（执行器阶段）中，我们使用基本的alpine Docker镜像，将`/src/`设置为我们的工作目录，并将我们在第一阶段构建的二进制文件复制到这个Docker容器中。然后我们在这个Docker构建中执行我们的记录器作为最后的命令。
- en: 'After we have our necessary dependencies together, we can build our Docker
    container. We do this by performing the following command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们收集了必要的依赖项之后，我们可以构建我们的Docker容器。我们可以通过执行以下命令来完成这个过程：
- en: '[PRE27]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once we have our Docker container built, we can execute it by performing the
    following command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以通过执行以下命令来执行Docker容器：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following screenshot, you can see our build and execution steps being
    completed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，您可以看到我们的构建和执行步骤已经完成：
- en: '![](img/b0fd4e02-76bb-4058-8114-b3679888ca84.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0fd4e02-76bb-4058-8114-b3679888ca84.png)'
- en: Building our Go programs in multistage Docker containers can be helpful in creating
    reproducible builds, limiting binary size, and minimizing the attack vectors for
    our services by using only the bits and pieces we need.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段Docker容器中构建我们的Go程序可以帮助我们创建可重复的构建，限制二进制文件大小，并通过仅使用我们需要的部分来最小化我们服务的攻击向量。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to build Go binaries. We learned how to do
    this effectively and permanently. We also learned how to understand and manage
    dependencies, test go code with `go run`, and install go binaries to a specific
    location using go install. Understanding how these binaries work will help you
    iterate more effectively on your code.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何构建Go二进制文件。我们学会了如何有效和永久地做到这一点。我们还学会了如何理解和管理依赖关系，使用`go run`测试go代码，并使用go
    install将go二进制文件安装到特定位置。了解这些二进制文件的工作原理将帮助您更有效地迭代您的代码。
- en: In the next chapter, we'll be looking at how to profile Go code to find functional
    bottlenecks.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何分析Go代码以找到功能瓶颈。
