- en: Profiling Go Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go代码分析
- en: 'Profiling is a practice that can be used to measure the resources utilized
    in a computer system. Profiling is often done to understand the CPU or memory
    utilization within a program in order to optimize for execution time, size, or
    reliability. Alongside profiling, in this chapter, we are going to learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分析是一种用于测量计算机系统中所使用资源的实践。通常进行分析以了解程序内的CPU或内存利用率，以便优化执行时间、大小或可靠性。在本章中，我们将学习以下内容：
- en: How to profile requests in Go with `pprof`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`pprof`对Go中的请求进行分析
- en: How to compare multiple profiles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何比较多个分析
- en: How to read the resulting profiles and flame graphs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何阅读生成的分析和火焰图
- en: Performing profiling will help you to deduce where you can make improvements
    within your function and how much time individual pieces take within your function
    call with respect to the overall system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 进行分析将帮助您推断在函数内部可以进行哪些改进，以及在函数调用中个别部分所需的时间与整个系统相比有多少。
- en: Understanding profiling
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解分析
- en: 'Profiling Go code is one of the best ways to determine where the bottlenecks
    are within your code base. We have physical limitations to our computer systems
    (CPU clock speed, memory size/speed, I/O read/write speeds, and network throughput,
    to give a few examples), but we can often optimize our programs to more efficiently
    utilize our physical hardware. After a profile of a computer program is taken
    with a profiler, a report is created. This report, often called a profile, can
    tell you information about the program that you ran. There are many reasons why
    you might want to understand the CPU and memory utilization of your program. A
    couple of examples are listed as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对Go代码进行分析是确定代码基础中瓶颈所在的最佳方法之一。我们的计算机系统有物理限制（CPU时钟速度、内存大小/速度、I/O读/写速度和网络吞吐量等），但我们通常可以优化我们的程序，以更有效地利用我们的物理硬件。使用分析器对计算机程序进行分析后，将生成一份报告。这份报告通常称为分析报告，可以告诉您有关您运行的程序的信息。有许多原因可能会让您想了解程序的CPU和内存利用率。以下是一些例子：
- en: '**CPU profiling reasons:**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: CPU性能分析的原因：
- en: Check performance improvements in new releases of software
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查软件新版本的性能改进
- en: Validate how much CPU is being utilized for each task
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证每个任务使用了多少CPU
- en: Limit CPU utilization in order to save money
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制CPU利用率以节省成本
- en: Understanding where latency comes from
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解延迟来自何处
- en: '**Memory profiling reasons:**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析的原因：
- en: Incorrect usage of global variables
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量的不正确使用
- en: Goroutines that don't complete
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未完成的Goroutines
- en: Incorrect reflection usage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的反射使用
- en: Large string allocation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大字符串分配
- en: We will next talk about exploring instrumentation methodologies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论探索仪器方法。
- en: Exploring instrumentation methodologies
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索仪器方法
- en: The `pprof` tool has many different methodologies for incorporating profiling
    into your code. The Go language creators wanted to make sure that it was simple
    and effective in implementing the profiling necessary to write performant programs.
    We can implement profiling in many stages of Go software development—namely, engineering,
    the creation of new functions, testing, and production.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`pprof`工具有许多不同的方法来将分析纳入您的代码。Go语言的创建者希望确保它在实现编写高性能程序所需的分析方面简单而有效。我们可以在Go软件开发的许多阶段实现分析，包括工程、新功能的创建、测试和生产。'
- en: It is important to remember that profiling does add a small performance penalty,
    as more metrics are being collected on a continuous basis in your running binaries.
    Many companies (Google included) feel that this trade-off is acceptable. Adding
    an additional 5% overhead for CPU and memory profiling is worth the cost in order
    to consistently write performant code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，分析确实会增加一些性能开销，因为在运行的二进制文件中会持续收集更多的指标。许多公司（包括谷歌）认为这种权衡是可以接受的。为了始终编写高性能代码，增加额外的5%的CPU和内存分析开销是值得的。
- en: Implementing profiling with go test
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用go test实施分析
- en: You can create both CPU and memory profiles using the `go test` command. This
    can be useful if you'd like to compare the outputs from multiple test runs. These
    outputs will often be stored in long-term storage for comparison over a longer
    date range. To execute CPU and memory profiles for a test, execute the `go test
    -cpuprofile /tmp/cpu.prof -memprofile /tmp/mem.prof -bench` command.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`go test`命令创建CPU和内存分析。如果您想比较多次测试运行的输出，这可能很有用。这些输出通常会存储在长期存储中，以便在较长的日期范围内进行比较。要执行测试的CPU和内存分析，请执行`go
    test -cpuprofile /tmp/cpu.prof -memprofile /tmp/mem.prof -bench`命令。
- en: This will create two output files, `cpu.prof` and `mem.prof`, which will both
    be stored in the `/tmp/` folder. These resulting profiles can be analyzed using
    the techniques in the *Analyzing profiles* section later in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建两个输出文件，`cpu.prof`和`mem.prof`，它们都将存储在`/tmp/`文件夹中。稍后在本章的*分析分析*部分中可以使用这些生成的分析。
- en: Manually instrumenting profiling in code
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中手动进行仪器分析
- en: If there is a particular place in your code that you'd like to profile specifically,
    you can implement profiling directly around that code. This can be especially
    useful if you only want to profile a smaller segment of your code, if you want
    the `pprof` output to be smaller and more concise, or if you don't want to add
    additional overhead to known expensive parts of your code by implementing profiling
    around them. There are separate methodologies for performing CPU and memory profiling
    around different segments of a code base.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想特别对代码中的特定位置进行分析，可以直接在该代码周围实施分析。如果您只想对代码的一小部分进行分析，如果您希望`pprof`输出更小更简洁，或者如果您不想通过在已知的昂贵代码部分周围实施分析来增加额外开销，这可能特别有用。对代码基础的不同部分进行CPU和内存分析有不同的方法。
- en: 'Profiling CPU utilization for a specific chunk of code would look as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对特定代码块进行CPU利用率分析如下：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Profiling memory utilization for a specific chunk of code would look as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对特定代码块进行内存利用率分析如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Hopefully, we won't have to implement individual segments of code if we design
    effectively, iterate with impact, and implement our profiling using the idioms
    from the next section, but it is nice to know that this is always a potential
    option for profiling code and retrieving meaningful output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 希望，如果我们设计有效，迭代有影响，并且使用下一节中的习语实现我们的分析，我们就不必实现代码的各个部分，但知道这始终是分析代码和检索有意义输出的潜在选择是很好的。
- en: Profiling running service code
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析运行服务代码
- en: The most commonly utilized method for implementing profiling in Go code is enabling
    the profiler in your HTTP handler function. This can be useful for debugging live
    production systems. Being able to profile your production system in real time
    lets you make decisions based on real, live production data, rather than your
    local development environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go代码中实施分析的最常用方法是在HTTP处理程序函数中启用分析器。这对于调试实时生产系统非常有用。能够实时分析生产系统让您能够基于真实的生产数据做出决策，而不是基于您的本地开发环境。
- en: Sometimes, errors only occur when the order of magnitude of data for a particular
    system reaches a specific scale. A method or function that can handle 1,000 data
    points effectively might not be able to handle 1,000,000 data points effectively
    on the underlying hardware that the function or method is running on. This is
    especially important while running on hardware that changes. Whether you are running
    on Kubernetes with noisy neighbors, a new piece of physical hardware with unknown
    specs, or with a new version of a piece of code or third-party library, understanding
    the performance impact of changes is paramount in creating reliability and resilience.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，错误只会在特定规模的数据达到特定规模时发生。一个可以有效处理1,000个数据点的方法或函数，在其基础硬件上可能无法有效处理1,000,000个数据点。这在运行在不断变化的硬件上尤为重要。无论您是在具有嘈杂邻居的Kubernetes上运行，还是在具有未知规格的新物理硬件上运行，或者使用代码或第三方库的新版本，了解更改的性能影响对于创建可靠性和弹性至关重要。
- en: Being able to receive the data from a production system, where your end users
    and the order of magnitude of their data may be larger than what you use locally,
    can help you to make performance improvements impacting the end user that you
    might not have ever spotted when iterating locally.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '能够从生产系统接收数据，其中您的最终用户及其数据的数量级可能大于您在本地使用的数量级，可以帮助您进行性能改进，影响最终用户，这可能是您在本地迭代时从未发现的。 '
- en: If we'd like to implement the `pprof` library in our HTTP handler, we can use
    the `net/http/pprof` library. This can be done by importing `_ "net/http/pprof"` into
    your main package.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在我们的HTTP处理程序中实现`pprof`库，我们可以使用`net/http/pprof`库。这可以通过将`_ "net/http/pprof"`导入到您的主包中来完成。
- en: 'Your HTTP handler will then have HTTP handlers registered for your profiling.
    Make sure that you aren''t performing this action on a publicly exposed HTTP server;
    having the breakdown of your program''s profile would expose some serious security
    vulnerabilities. The index of the `pprof` package displays paths that become available
    to you when you utilize this package. The following is a screenshot of the index
    of the `pprof` tool:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您的HTTP处理程序将为您的分析注册HTTP处理程序。确保您不要在公开的HTTP服务器上执行此操作；您的程序概要会暴露一些严重的安全漏洞。`pprof`包的索引显示了在使用此包时可用的路径。以下是`pprof`工具索引的屏幕截图：
- en: '![](img/f6f83adb-86ca-49aa-83a5-38ed0d43d3dc.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6f83adb-86ca-49aa-83a5-38ed0d43d3dc.png)'
- en: 'We can take a look at the exposed HTTP `pprof` paths and their descriptions.
    The paths and related descriptions can be found in the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看公开的HTTP `pprof`路径及其描述。路径和相关描述可以在以下表中找到：
- en: '| **Name** | **HTTP path** | **Description** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **HTTP路径** | **描述** |'
- en: '| `allocs` | `/debug/pprof/allocs` | Memory allocation information. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `allocs` | `/debug/pprof/allocs` | 内存分配信息。 |'
- en: '| `block` | `/debug/pprof/block` | Information on where the goroutines block
    waits. This typically happens on synchronization primitives. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `block` | `/debug/pprof/block` | Goroutines阻塞等待的信息。这通常发生在同步原语上。 |'
- en: '| `cmdline` | `/debug/pprof/cmdline` | Values of the invocation of the command
    line of our binary. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `cmdline` | `/debug/pprof/cmdline` | 我们二进制命令行调用的值。 |'
- en: '| `goroutine` | `/debug/pprof/goroutine` | Stack traces of goroutines that
    are currently running. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `goroutine` | `/debug/pprof/goroutine` | 当前正在运行的goroutines的堆栈跟踪。 |'
- en: '| `heap` | `/debug/pprof/heap` | Memory allocations sampling (for monitoring
    memory usage and leaks). |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `heap` | `/debug/pprof/heap` | 内存分配采样（用于监视内存使用和泄漏）。 |'
- en: '| `mutex` | `/debug/pprof/mutex` | Contended mutex stack traces. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `mutex` | `/debug/pprof/mutex` | 有争议的互斥锁堆栈跟踪。 |'
- en: '| `profile` | `/debug/pprof/profile` | The CPU profile. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `profile` | `/debug/pprof/profile` | CPU概要。 |'
- en: '| `symbol` | `/debug/pprof/symbol` | Request program counters. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `symbol` | `/debug/pprof/symbol` | 请求程序计数器。 |'
- en: '| `threadcreate` | `/debug/pprof/threadcreate` | OS thread creation stack traces.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `threadcreate` | `/debug/pprof/threadcreate` | 操作系统线程创建堆栈跟踪。 |'
- en: '| `trace` | `/debug/pprof/trace` | Current program trace. This will be discussed
    in depth in [Chapter 13](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml), *Tracing
    Go Code*. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `trace` | `/debug/pprof/trace` | 当前程序跟踪。这将在[第13章](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml)中深入讨论，*跟踪Go代码*。
    |'
- en: In the next section, we will discuss CPU profiling.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论CPU分析。
- en: Briefing on CPU profiling
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU分析简介
- en: 'Let''s perform some example profiling on a simple Go program in order to understand
    how the profiler works. We will create a sample program with a couple of sleep
    parameters in order to see the timings for different function calls:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对一个简单的Go程序执行一些示例分析，以了解分析器的工作原理。我们将创建一个带有一些休眠参数的示例程序，以便查看不同函数调用的时间：
- en: 'First, we instantiate our package and add all of our imports:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们实例化我们的包并添加所有导入：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, in our `main` function, we have an HTTP handler that has two sleep functions
    that are called as part of the handler:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`main`函数中，我们有一个HTTP处理程序，其中包含两个休眠函数，作为处理程序的一部分调用：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `sleep` function just sleeps for a particular millisecond duration and
    prints the resulting output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sleep`函数只是睡眠了一段特定的毫秒数，并打印出结果输出：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we run our program, we see the output `go run httpProfiling.go`. To generate
    a profile from this particular code, we need to call `curl -s "localhost:1234/debug/pprof/profile?seconds=10"
    > out.dump`. This will run a profile for 10 seconds and return the results to
    a file named `out.dump`. By default, the `pprof` tool will run for 30 seconds
    and return the binary to `STDOUT`. We want to make sure that we limit the time
    of this test to something that is reasonable for the test duration, and we need
    to redirect the output in order to be able to capture something meaningful to
    look at in our profiling tools.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，我们看到输出`go run httpProfiling.go`。要从这个特定的代码生成概要文件，我们需要调用`curl -s "localhost:1234/debug/pprof/profile?seconds=10"
    > out.dump`。这将运行一个10秒钟的概要文件，并将结果返回到一个名为`out.dump`的文件中。默认情况下，`pprof`工具将运行30秒，并将二进制文件返回到`STDOUT`。我们要确保我们限制这个测试的时间，以便测试持续时间合理，并且我们需要重定向输出，以便能够捕获一些有意义的内容在我们的分析工具中查看。
- en: Next, we generate a test load for our function. We can use Apache Bench to accomplish
    this task, generating 5,000 requests with a concurrency of 10; we set this up
    using `ab -n 5000 -c 10 http://localhost:1234/`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的函数生成一个测试负载。我们可以使用Apache Bench来完成这个任务，生成5,000个并发为10的请求；我们使用`ab -n 5000
    -c 10 http://localhost:1234/`来设置这个。
- en: Once we get the output from this test, we can take a look at our `out.dump`
    file, `go tool pprof out.dump`. This will take you into the profiler. This is
    a slight variant of the C++ profiler `pprof`. This tool has quite a bit of functionality.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们得到了这个测试的输出，我们可以查看我们的`out.dump`文件，`go tool pprof out.dump`。这将带您进入分析器。这是C++分析器`pprof`的一个轻微变体。这个工具有相当多的功能。
- en: 'We can use the `topN` command to look at the top *N* samples that are contained
    in the profile we generated, as shown in the following screenshot:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`topN`命令查看概要文件中包含的前*N*个样本，如下图所示：
- en: '![](img/2559344c-6b24-4454-88e5-f3b963485d80.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2559344c-6b24-4454-88e5-f3b963485d80.png)'
- en: 'While the profiler is being executed, Go stops the program roughly 100 times
    per second. During this time, it records the program counters on the goroutine''s
    stack. We can also use the cumulative flag `(-cum)` in order to sort by the cumulative
    values that we have in our current profile sampling:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行分析器时，Go程序大约每秒停止100次。在此期间，它记录goroutine堆栈上的程序计数器。我们还可以使用累积标志`(-cum)`，以便按照我们当前概要文件采样中的累积值进行排序：
- en: '![](img/e0b8c731-8d0f-4b85-ae22-87ef49d77237.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0b8c731-8d0f-4b85-ae22-87ef49d77237.png)'
- en: We also have the ability to display a visual representation of the trace in
    graph form. After we make sure that the `graphviz` package is installed (it should
    be included in your package manager, or it can be downloaded from [http://www.graphviz.org/](http://www.graphviz.org/)
    by simply typing the `web` command)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以显示跟踪的可视化图形表示形式。确保安装了`graphviz`包（它应该包含在您的包管理器中，或者可以从[http://www.graphviz.org/](http://www.graphviz.org/)下载，只需键入`web`命令）
- en: 'This will give us a visual representation of the profile that we generated
    from within our program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一个从我们的程序内生成的概要文件的可视化表示：
- en: '![](img/f4b4289d-63a6-459f-817e-fd642cceee4c.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4b4289d-63a6-459f-817e-fd642cceee4c.png)'
- en: The red boxes in the profile are the code paths that are the most impactful
    to the request flow. We can take a look at these boxes, and, as we'd expect, we
    can see that a good portion of our sample program takes time in sleeping and writing
    responses back to the client. We can take a look at the specific functions in
    this same web format by passing the name of the function that we want to see a
    web graph for. For example, if we want to see a detailed view of our `sleep` function,
    we can just type the `(pprof) web sleep` command.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 概要文件中的红色框表示对请求流最有影响的代码路径。我们可以查看这些框，并且正如我们所期望的那样，我们可以看到我们的示例程序中有相当多的时间用于睡眠和向客户端写回响应。我们可以通过传递我们想要查看的函数的名称来以相同的web格式查看这些特定函数。例如，如果我们想要查看我们的`sleep`函数的详细视图，我们只需键入`(pprof)
    web sleep`命令。
- en: 'We''ll then get an `SVG` with the image focused on the sleep call:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将获得一个以睡眠调用为焦点的SVG图像：
- en: '![](img/66241c91-a271-45ea-8575-4766a652208d.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66241c91-a271-45ea-8575-4766a652208d.png)'
- en: 'After we get this breakdown, we may want to take a look into what the sleep
    function is actually performing. We can use the `list` command in `pprof` in order
    to get the output that profiles the invocation of the `sleep` command and its
    subsequent calls. The following screenshot shows this; the code is shortened for
    the sake of brevity:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们得到这个分解之后，我们可能想要查看睡眠函数实际执行了什么。我们可以使用`pprof`中的`list`命令，以便获得对`sleep`命令及其后续调用的调用进行分析的输出。以下屏幕截图显示了这一点；为了简洁起见，代码被缩短了：
- en: '![](img/89c2dac7-abe2-414f-9738-993f76fafc9a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89c2dac7-abe2-414f-9738-993f76fafc9a.png)'
- en: Being able to break down the work we are doing by profiling into segmentable
    chunks can tell us a lot about the direction we need to take our development in
    from a utilization perspective.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对我们正在进行的工作进行分析并将其分解为可分段的块，可以告诉我们很多关于我们需要从利用角度采取的开发方向。
- en: In the next section, we will see what memory profiling is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到内存分析是什么。
- en: Briefing on memory profiling
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分析简介
- en: We can perform similar actions to the CPU testing that we did in the previous
    section with memory. Let's take a look at another method to handle profiling,
    using the testing functionality. Let's use an example that we created back in
    [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data Structures and
    Algorithms—*the `o-logn` function. We can use the benchmark that we have already
    created for this particular function and add some memory profiling to this particular
    test. We can execute the `go test -memprofile=heap.dump -bench` command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对内存执行与我们在上一节中对CPU测试相似的操作。让我们看看另一种处理分析的方法，使用测试功能。让我们使用我们在[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中创建的例子，*数据结构和算法*中的`o-logn`函数。我们可以使用我们已经为这个特定函数创建的基准，并为这个特定的测试添加一些内存分析。我们可以执行`go
    test -memprofile=heap.dump -bench`命令。
- en: 'We will see a similar output to what we saw in [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml), *Data
    Structures and Algorithms*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到与我们在[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中看到的类似的输出，*数据结构和算法*：
- en: '![](img/6e4f4592-7126-4df9-9b54-48cc7363664b.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e4f4592-7126-4df9-9b54-48cc7363664b.png)'
- en: 'The only difference is that now we''ll have the heap profile from this test.
    If we view it with the profiler, we''ll see data about the heap usage rather than
    the CPU usage. We''ll also be able to see the memory allocation for each of our
    functions in that program. The following diagram illustrates this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是现在我们将从这个测试中得到堆剖析。如果我们用分析器查看它，我们将看到关于堆使用情况的数据，而不是CPU使用情况。我们还将能够看到该程序中每个函数的内存分配情况。以下图表说明了这一点：
- en: '![](img/0addac7e-6218-4608-8628-cad13ac28e26.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0addac7e-6218-4608-8628-cad13ac28e26.png)'
- en: 'This is helpful, as it enables us to see the generated heap sizes for each
    of the parts of this code. We can also take a look at the top cumulative memory
    allocations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，因为它使我们能够看到代码中每个部分生成的堆大小。我们还可以查看累积内存分配的前几名：
- en: '![](img/df629a1d-7502-4fba-88f8-41e8e3219e28.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df629a1d-7502-4fba-88f8-41e8e3219e28.png)'
- en: As our programs grow more complex, being able to understand the state of the
    memory utilization becomes more and more important. In the next section, we will
    discuss how to extend our profiling capabilities with upstream `pprof`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的程序变得更加复杂，理解内存利用情况变得越来越重要。在下一节中，我们将讨论如何通过上游`pprof`扩展我们的分析能力。
- en: Extended capabilities with upstream pprof
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上游pprof的扩展功能
- en: 'If we want to be able to use additional functionality by default, we can use
    the upstream `pprof` binary in order to extend the views we have with our profiles:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要默认使用额外的功能，我们可以使用上游的`pprof`二进制文件来扩展我们的分析视图：
- en: We can retrieve this with an invocation of `go get github.com/google/pprof`. The `pprof` tool has
    a couple different invocation methods. We can use the report generation method
    to generate a file in the requested format (currently supported are the `.dot`,
    `.svg`, `.web`, `.png`, `.jpg`, `.gif`, and `.pdf` formats). We can also use the
    interactive terminal format in a similar way to what we did in the previous sections
    about CPU and memory profiling. The last and most commonly used method is using
    the HTTP server. This method involves hosting an HTTP server that includes much
    of the pertinent output in an easily digestible format.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过调用`go get github.com/google/pprof`来获取这个。`pprof`工具有几种不同的调用方法。我们可以使用报告生成方法来生成所请求格式的文件（目前支持`.dot`、`.svg`、`.web`、`.png`、`.jpg`、`.gif`和`.pdf`格式）。我们还可以像在前几节关于CPU和内存分析中所做的那样，使用交互式终端格式。最后，最常用的方法是使用HTTP服务器。这种方法涉及在一个易于消化的格式中托管包含大部分相关输出的HTTP服务器。
- en: 'Once we have retrieved the binary via `go get`, we can invoke it with a web
    interface, looking at an output that we generated previously: `pprof -http=:1234
    profile.dump`.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们通过`go get`获取了二进制文件，我们可以使用web界面调用它，查看我们之前生成的输出：`pprof -http=:1234 profile.dump`。
- en: 'We can then visit the newly available UI and see the features and functionality
    that were not built into the default `pprof` tool. A couple of the key highlights
    available from this tool are as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以访问新提供的UI，看看默认的`pprof`工具中没有内置的功能和功能。这个工具提供的一些关键亮点如下：
- en: A regex searchable form field to help with searching for necessary profiling
    elements
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正则表达式可搜索的表单字段，以帮助搜索必要的分析元素
- en: A drop-down view menu for easy viewing of the different profiling tools available
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个下拉式视图菜单，方便查看不同的分析工具
- en: A sample dropdown to display the samples from the profile
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个样本下拉菜单，显示来自剖析的样本
- en: A refine filter for hiding/showing different parts of the request flow
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个细化的过滤器，用于隐藏/显示请求流的不同部分
- en: 'Having all of these tools at our disposal for profiling helps to make the profiling
    process more streamlined. If we want to take a look at the time that is taken
    to run anything with a `fmt` in the name of the call, we can use the sample view
    with the regex filter, and it''ll highlight the `fmt` calls, as we can see in
    the following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有所有这些工具来进行分析有助于使分析过程更加流畅。如果我们想要查看运行任何带有`fmt`名称的调用所花费的时间，我们可以使用带有正则表达式过滤器的示例视图，它将突出显示`fmt`调用，正如我们在下面的截图中所看到的那样：
- en: '![](img/dd1b454e-ebb1-4ded-aaa4-a57165b00f4a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd1b454e-ebb1-4ded-aaa4-a57165b00f4a.png)'
- en: Being able to filter according to these values can be helpful in narrowing the
    scope of your ill-performing function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些值进行过滤可以帮助缩小性能不佳函数的范围。
- en: Comparing multiple profiles
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较多个分析
- en: 'One of the really nice features of profiling is that you can compare profiles
    with one another. If we have two separate measurements from the same program,
    we can determine whether or not the change we made is having a positive impact
    on the system. Let''s augment our HTTP sleep timing function a little bit:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 分析的一个非常好的特性是可以将不同的分析进行比较。如果我们从同一个程序中有两个单独的测量，我们可以确定我们所做的更改是否对系统产生了积极的影响。让我们稍微改进一下我们的HTTP睡眠定时函数：
- en: 'Let''s add a few extra imports:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一些额外的导入：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we''ll augment our handler to take a query string parameter for `time`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将增强我们的处理程序以接受`time`的查询字符串参数：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll leave our sleep function exactly the same:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将保持我们的睡眠函数完全相同：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have this extra functionality, we can take multiple profiles with
    different timings just by passing a query parameter to our HTTP handler:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个额外的功能，我们可以通过向我们的HTTP处理程序传递查询参数来使用不同时间进行多个配置文件的采集：
- en: 'We can run our new timed profiling tool:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以运行我们的新定时配置工具：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In another Terminal, we can start our profiling tool:'
  id: totrans-109
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个终端中，我们可以启动我们的配置工具：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then make many requests for our new resource:'
  id: totrans-111
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们可以对我们的新资源进行多次请求：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can then gather a second profile:'
  id: totrans-113
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们可以收集第二个配置文件：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we make a second request for our new resource, generating a second profile:'
  id: totrans-115
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们对我们的新资源进行第二次请求，生成第二个配置文件：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now have two separate profiles available, which are stored in `5-millisecond-profile.dump`
    and `10-millisecond-profile.dump`. We can compare these using the same tools as
    before, setting a base profile and a secondary profile. The following screenshot
    illustrates this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有两个单独的配置文件，分别存储在`5-millisecond-profile.dump`和`10-millisecond-profile.dump`中。我们可以使用与之前相同的工具进行比较，设置一个基本配置文件和一个次要配置文件。以下截图说明了这一点：
- en: '![](img/fa125aa7-f40e-4fcc-b0f1-f7de7862cb9b.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa125aa7-f40e-4fcc-b0f1-f7de7862cb9b.png)'
- en: Comparing profiles allows us to understand how changes impact our systems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 比较配置文件可以帮助我们了解变化如何影响我们的系统。
- en: Let's move on to flame graphs in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一节的火焰图。
- en: Interpreting flame graphs within pprof
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释pprof中的火焰图
- en: One of the most helpful/useful tools in the upstream `pprof` package is the
    flame graph. A flame graph is a fixed-rate sampling visualization that can help
    to determine hot codepaths in a profile. As your programs get more and more complex,
    the profiles become larger and larger. It will often become difficult to know
    exactly what codepath is eating up the most CPU, or, as I often like to call it,
    *the long pole in the tent*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上游`pprof`包中最有帮助/有用的工具之一是火焰图。火焰图是一种固定速率采样可视化，可以帮助确定配置文件中的热代码路径。随着您的程序变得越来越复杂，配置文件变得越来越大。往往很难知道到底哪段代码路径占用了最多的CPU，或者我经常称之为*帐篷中的长杆*。
- en: 'Flame graphs were originally developed by Brendan Gregg at Netflix to solve
    a MySQL CPU utilization problem. The advent of this visualization has helped many
    programmers and system administrators determine what the source of latency is
    in their program. The `pprof` binary produces an icicle-style (flames pointing
    downward) flame graph. In a flame graph, we have data visualized in a specific
    frame:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图最初是由Netflix的Brendan Gregg开发的，用于解决MySQL的CPU利用率问题。这种可视化的出现帮助许多程序员和系统管理员确定程序中延迟的来源。`pprof`二进制文件生成一个icicle-style（火焰向下指）火焰图。在火焰图中，我们有特定帧中的数据可视化。
- en: The *x* axis is the collection of all of the samples from our request
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*轴是我们请求的所有样本的集合'
- en: The y axis shows the number of frames that are on the stack, also often known
    as the stack depth
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y轴显示了堆栈上的帧数，通常称为堆栈深度
- en: The width of the box shows the total amount of CPU time a particular function
    call used
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方框的宽度显示了特定函数调用使用的总CPU时间
- en: 'These three things visualized together helps to determine which part of the
    program introduces the most latency. You can visit the flame graph section of
    the `pprof` profile at `http://localhost:8080/ui/flamegraph`. The following image
    shows an example of such a flame graph:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个东西一起可视化有助于确定程序的哪一部分引入了最多的延迟。您可以访问`pprof`配置文件的火焰图部分，网址为`http://localhost:8080/ui/flamegraph`。以下图片显示了一个火焰图的示例：
- en: '![](img/8be26f48-4577-485d-999c-888ddc547d29.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8be26f48-4577-485d-999c-888ddc547d29.png)'
- en: If we look at our `bubbleSort` example from [Chapter 2](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml),
    *Data Structures and Algorithms*, we can see the breakdown of the different bits
    that take up CPU time in our tests. In the interactive web mode, we can hover
    over each of these samples and validate their duration and percentage execution
    time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看看[第2章](7bacdf42-9455-4499-a70a-c50c9a6c4e26.xhtml)中的`bubbleSort`示例，*数据结构和算法*，我们可以看到在我们的测试中占用CPU时间的不同部分。在交互式网络模式中，我们可以悬停在每个样本上，并验证它们的持续时间和百分比执行时间。
- en: In the upcoming section, we will see how to detect memory leaks in Go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到如何检测Go中的内存泄漏。
- en: Detecting memory leaks in Go
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Go中的内存泄漏
- en: As discussed in the *Memory object allocation* section of [Chapter 8](8b95d93a-6bc1-4307-bd75-0e317898321a.xhtml),
    *Memory Management in Go*, we have a myriad of tools at our disposal to view the
    current memory statistics for our currently executing program. In this chapter,
    we will also learn about profiling using the pprof tool. One of the more common
    Go memory leaks is the unbounded creation of goroutines. This happens frequently
    when you overload an unbuffered channel or you have an abstraction with a lot
    of concurrency spawning new goroutines that don't finish. Goroutines have a very
    small footprint and systems can often spawn a very large number of them, but they
    eventually have an upper bound that becomes taxing to find when trying to troubleshoot
    your program in a production environment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第8章](8b95d93a-6bc1-4307-bd75-0e317898321a.xhtml)中*Go内存管理*部分所讨论的，我们有很多工具可以查看当前正在执行的程序的内存统计信息。在本章中，我们还将学习使用pprof工具进行配置文件。Go中更常见的内存泄漏之一是无限创建goroutine。当您过载一个非缓冲通道或者有一个具有大量并发生成新goroutine的抽象时，这种情况经常发生。Goroutine的占用空间非常小，系统通常可以生成大量的goroutine，但最终会有一个上限，在生产环境中调试程序时很难找到。
- en: 'In the following example, we are going to look at an unbuffered channel that
    has a leaky abstraction:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将查看一个有泄漏抽象的非缓冲通道：
- en: 'We start by initializing our package and importing our necessary dependencies:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先初始化我们的包并导入我们需要的依赖项：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In our main function, we handle HTTP listening to and serving the `leakyAbstraction`
    function.  We are serving this over HTTP in order to make it simple to see the
    number of goroutines grow:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们处理HTTP监听和为`leakyAbstraction`函数提供服务。我们通过HTTP提供这个服务，以便简单地看到goroutines的数量增长：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our `leakyAbstraction` function, we first initialize an unbuffered string
    channel.  We then endlessly iterate through a for loop, writing the number of
    goroutines to the HTTP response writer and writing the result of our `wait()`
    function to the channel:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`leakyAbstraction`函数中，我们首先初始化一个无缓冲的字符串通道。然后我们通过一个for循环无休止地迭代，将goroutines的数量写入HTTP响应写入器，并将我们的`wait()`函数的结果写入通道：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our `wait()` function sleeps for five microseconds and returns a string:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`wait()`函数休眠五微秒并返回一个字符串：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These functions together will spawn goroutines until the runtime is no longer
    able to do so and dies.  We can test this by running our server by executing the
    following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数一起将生成goroutines，直到运行时不再能够这样做并死亡。我们可以通过执行以下命令来测试这一点：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the server is running, in a separate Terminal window, we can make a request
    to our server with the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行后，在一个单独的终端窗口中，我们可以使用以下命令向服务器发出请求：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `curl` command will print the number of goroutines generated until the
    server is killed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`命令将打印生成的goroutines数量，直到服务器被关闭：'
- en: '![](img/e971d565-e6a6-4825-980c-71da2d27ecba.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e971d565-e6a6-4825-980c-71da2d27ecba.png)'
- en: Please note that this request may take a while depending on the specifications
    of your system.  This is okay—it illustrates the number of goroutines that your
    program has available for use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据您系统的规格，此请求可能需要一段时间。这没关系——它说明了您的程序可用于使用的goroutines数量。
- en: Using the techniques we learn in this chapter, we will be able to further debug
    memory issues like this one with pprof, but understanding the underlying problems
    will help us to avoid memory issues.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在本章学到的技术，我们将能够进一步调试类似这样的内存问题，但理解潜在的问题将帮助我们避免内存问题。
- en: 'This example was written in order to explicitly show a memory leak, but if
    we wanted to make this executable not leak goroutines, we''d have to fix two things:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是为了明确展示内存泄漏，但如果我们想要使这个可执行文件不泄漏goroutines，我们需要修复两件事：
- en: Our unbounded for loop should most likely have a bound
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的无限循环很可能应该有一个限制
- en: We could add a buffered channel in order to make sure we have the ability to
    process all the spawned goroutines that come in through the channel
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加一个带缓冲的通道，以确保我们有能力处理通过通道进入的所有生成的goroutines
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned about profiles—what profiles are and how to
    generate profiles using `pprof`. You also learned how to analyze profiles using
    different methodologies, how to compare profiles, and how to read flame graphs
    for performance. Being able to perform this action in a production environment
    will help you to maintain stability, improve performance, and give your end user
    a better end user experience. In the next chapter, we will discuss another methodology
    of analyzing code—tracing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于profiles的知识——profiles是什么，以及如何使用`pprof`生成profiles。您还学会了如何使用不同的方法分析profiles，如何比较profiles，以及如何阅读性能的火焰图。能够在生产环境中执行这个操作将帮助您保持稳定，提高性能，并为最终用户提供更好的用户体验。在下一章中，我们将讨论另一种分析代码的方法——跟踪。
