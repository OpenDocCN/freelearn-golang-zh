- en: Getting Started with REST API Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用REST API开发
- en: A web service is a communication mechanism defined between various computer
    systems. Without web services, custom peer-to-peer communication becomes cumbersome
    and platform-specific. The web needs to understand and interpret a hundred different
    things in the form of protocols. If computer systems can align with the protocols
    that the web can understand easily, it is a great help.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是在各种计算机系统之间定义的一种通信机制。没有网络服务，定制的对等通信会变得繁琐且与平台相关。网络需要理解和解释以协议形式存在的上百种不同事物。如果计算机系统能够与网络可以轻松理解的协议对齐，这将大有裨益。
- en: A web service is a software system designed to support interoperable machine-to-machine
    interaction over a network, as defined by the **World Wide Web Consortium** (**W3C**)
    at [https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是一种软件系统，旨在支持通过网络进行可互操作的机器到机器交互，这是由万维网联盟（**World Wide Web Consortium，W3C**）在[https://www.w3.org/TR/ws-arch/](https://www.w3.org/TR/ws-arch/)定义的。
- en: Now, in simple words, a web service is a road between two endpoints where messages
    are transferred smoothly. The message transfer is usually one way. Two individual
    programmable entities can also communicate with each other through their own APIs.
    Two people communicate through language, two applications communicate through
    an **Application Programming Interface **(**API**).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，一个网络服务是两个端点之间的一条道路，消息在这里可以顺畅地传输。消息传输通常是单向的。两个独立的可编程实体也可以通过它们自己的API相互通信。两个人通过语言交流，两个应用程序通过**应用程序编程接口（Application
    Programming Interface，API**）交流。
- en: The reader might be wondering; what is the importance of the API in the current
    digital world? The rise of the **Internet of Things **(**IoT**) made API usage
    heavier than before. Awareness of APIs is growing day by day, and there are hundreds
    of APIs that are being developed and documented all over the world every day.
    Notable major businesses are seeing the future in the **API as a Service** (**AaS**).
    A bright example in recent times is **Amazon Web Services** (**AWS**). AWS is
    a huge success in the cloud world. Developers write their own applications using
    the **Representational State Transfer** (**REST**) API provided by AWS and access
    it via **Command-Line Interface** (**CLI**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会想，在当前的数字世界中，API的重要性是什么？物联网（**Internet of Things，IoT**）的兴起使得API的使用比以前更加频繁。对API的认识每天都在增长，每天都有数百个API在全球范围内被开发和记录。值得注意的主要企业都看到了**API即服务（API
    as a Service，AaS**）的未来。一个最近的亮点例子是**亚马逊网络服务（Amazon Web Services，AWS**）。AWS在云世界中取得了巨大的成功。开发者使用AWS提供的**表示状态转移（Representational
    State Transfer，REST**）API编写自己的应用程序，并通过**命令行界面（Command-Line Interface，CLI**）访问它。
- en: A few more hidden use cases are from travel sites such as [http://Booking.com](http://Booking.com) and
    [https://www.expedia.com/](https://www.expedia.com/), which fetch real-time prices
    by calling the APIs of third-party gateways and data vendors. Web service usage
    is often charged these days by the amount of data requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些隐藏的使用案例来自像[http://Booking.com](http://Booking.com)和[https://www.expedia.com/](https://www.expedia.com/)这样的旅行网站，它们通过调用第三方网关和数据供应商的API来获取实时价格。如今，网络服务的使用通常按数据请求量收费。
- en: 'In this chapter, we will focus on the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下主题：
- en: The different web services available
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的不同网络服务
- en: REST architecture in detail
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍REST架构
- en: The rise of **Single-page applications** (**SPAs**) with REST
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于REST的**单页应用程序（Single-page applications，SPAs**）的兴起
- en: Setting up a Go project and running a development server
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Go项目并运行开发服务器
- en: Building our first service for finding the fastest mirror site from a list of
    Debian servers hosted worldwide
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的第一个服务，从全球托管的Debian服务器列表中找到最快的镜像站点
- en: The Open API specification and Swagger documentation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放API规范和Swagger文档
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the pieces of software that should be pre-installed for running
    the code samples in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中运行代码示例之前应预先安装的软件组件：
- en: 'OS: Linux (Ubuntu 18.04)/ Windows 10/Mac OS X >=10.13'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux（Ubuntu 18.04）/ Windows 10/Mac OS X >=10.13
- en: 'Software: Docker >= 18 (Docker Desktop for Windows and Mac OS X)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件：Docker >= 18（适用于Windows和Mac OS X的Docker Desktop）
- en: The latest version of the Go compiler == 1.13.5
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编译器的最新版本 == 1.13.5
- en: We use Docker in this book to run a few sandbox environments. Docker is a virtualization
    platform that imitates an OS in a sandbox. Using it, we can cleanly run an application
    or service without affecting the host system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Docker运行几个沙盒环境。Docker是一个虚拟化平台，它在一个沙盒中模仿操作系统。使用它，我们可以干净地运行应用程序或服务，而不会影响宿主系统。
- en: You can find the code used in this chapter on the book's GitHub repository at [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter1](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到本章使用的代码，网址为 [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter1](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter1)。
- en: Types of web services
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务的类型
- en: 'There are many types of web services that have evolved over time. Some of the
    more prominent ones are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，已经演变出许多类型的 Web 服务。其中一些较为突出的如下：
- en: '**Simple Object Access Protocol** (**SOAP**)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单对象访问协议**（**SOAP**）'
- en: '**Universal Description**, **Discovery, and Integration** (**UDDI**)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用描述、发现和集成**（**UDDI**）'
- en: '**Web Services Description Language** (**WSDL**)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 服务描述语言**（**WSDL**）'
- en: '**Representational State Transfer** (**REST**)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）'
- en: Out of these, SOAP became popular in the early 2000s, when XML riding on a high
    wave. The XML data format is used by various distributed systems to communicate
    with each other.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，SOAP 在 2000 年代初变得流行，当时 XML 正在经历高潮。XML 数据格式被各种分布式系统用于相互通信。
- en: 'A `SOAP` request usually consists of these three basic components:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `SOAP` 请求通常由这三个基本组件组成：
- en: The envelope
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: The header
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头
- en: The body
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体
- en: 'Just to perform an HTTP request and response cycle, we have to attach a lot
    of additional data in SOAP. A sample SOAP request to a fictional book server, `www.example.org`,
    looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了执行 HTTP 请求和响应周期，我们不得不在 SOAP 中附加大量额外的数据。一个针对虚构的图书服务器 `www.example.org` 的示例
    SOAP 请求看起来如下：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a standard example of a SOAP request for getting book data. If we observe
    carefully, it is in XML format, with special tags specifying the envelope and
    body. Since XML works by defining a lot of namespaces, the response gets bulky.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个获取图书数据的 SOAP 请求的标准示例。如果我们仔细观察，它是以 XML 格式编写的，带有特殊的标签来指定封装和主体。由于 XML 通过定义大量的命名空间来工作，因此响应会变得庞大。
- en: The main drawback of SOAP is that it is too complex for implementing web services
    and is a heavyweight framework. A SOAP HTTP request can get very bulky and can
    cause bandwidth wastage. The experts looked for a simple alternative, and in came REST.
    In the next section, we will briefly discuss REST.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP 的主要缺点是它对于实现 Web 服务来说过于复杂，并且是一个重量级的框架。一个 SOAP HTTP 请求可能会变得非常大，并可能导致带宽浪费。专家们寻找了一个简单的替代方案，于是出现了
    REST。在下一节中，我们将简要讨论 REST。
- en: The REST API
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API
- en: The name **Representational state transfer** (**REST**) was coined by Roy Fielding
    from the University of California. It is a very simplified and lightweight web
    service compared to SOAP. Performance, scalability, simplicity, portability, and
    flexibility are the main principles behind the REST design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**表征状态转移**（**REST**）这个名称是由加州大学的 Roy Fielding 提出的。与 SOAP 相比，它是一个非常简化和轻量级的 Web
    服务。性能、可扩展性、简单性、可移植性和灵活性是 REST 设计背后的主要原则。'
- en: The REST API allows different systems to communicate and send/receive data in
    a very simple way. Each and every REST API call has a relation between an HTTP
    verb and the URL. The resources in the database in an application can be mapped
    with an API endpoint in the REST architecture.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 允许不同的系统以非常简单的方式通信和发送/接收数据。每个 REST API 调用都与 HTTP 动词和 URL 之间有一个关系。应用程序数据库中的资源可以与
    REST 架构中的 API 端点相对应。
- en: When you are using a mobile app on your phone, your phone might be talking to
    many cloud services to retrieve, update, or delete your data. REST services have
    a huge impact on our daily lives.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在手机上使用移动应用时，你的手机可能在与许多云服务进行通信，以检索、更新或删除你的数据。REST 服务对我们日常生活有着巨大的影响。
- en: REST is a stateless, cacheable, and simple architecture that is not a protocol,
    but a pattern. This pattern allows different endpoints to communicate with each
    other over HTTP.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是一种无状态、可缓存且简单的架构，它不是一个协议，而是一种模式。这种模式允许不同的端点通过 HTTP 互相通信。
- en: Characteristics of REST services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 服务的特性
- en: 'These are the main properties that make REST simple and unique compared to
    its predecessors:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使 REST 相比其前辈简单且独特的最主要属性：
- en: '**Client-server based architecture**: This architecture is most essential for
    the modern web to communicate over HTTP. A single client-server may look naive
    initially, but many hybrid architectures are evolving. We will discuss more of
    these shortly.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于客户端-服务器架构**：这种架构对于现代网络通过 HTTP 进行通信至关重要。单个客户端-服务器最初可能看起来很天真，但许多混合架构正在演变。我们很快会讨论更多这些内容。'
- en: '**Stateless**: This is the most important characteristic of a REST service.
    A REST HTTP request consists of all the data needed by the server to understand
    and return the response. Once a request is served, the server doesn''t remember
    whether the request arrived after a while. So, the operation will be a stateless
    one.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：这是REST服务最重要的特性。一个REST HTTP请求包含了服务器理解并返回响应所需的所有数据。一旦请求被处理，服务器不会记住请求是否在一段时间后到达。因此，操作将是无状态的。'
- en: '**Cacheable**: In order to scale an application well, we need to cache certain
    responses. REST services can be cached for better throughput.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可缓存**：为了良好地扩展应用程序，我们需要缓存某些响应。REST服务可以被缓存以提高吞吐量。'
- en: '**Representation of resources**: The REST API provides the uniform interface
    to talk to. It uses a **Uniform Resource Identifier** (**URI**) to map the resources
    (data). It also has the advantage of requesting a specific data'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源的表示**：REST API提供了统一的接口来进行通信。它使用**统一资源标识符**（**URI**）将资源（数据）进行映射。它还有请求特定数据的优势'
- en: '**Implementation freedom**: REST is just a mechanism to define your web services.
    It is an architectural style that can be implemented in multiple ways. Because
    of this flexibility, you can create REST services in the way you wish to. As long
    as it follows the principles of REST, you have the freedom to choose the platform
    or technology for your server.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现自由度**：REST只是定义你的Web服务的一种机制。它是一种可以以多种方式实现的架构风格。正因为这种灵活性，你可以以你希望的方式创建REST服务。只要它遵循REST的原则，你就有权选择你的服务器平台或技术。'
- en: Thoughtful caching is essential for REST services to scale.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑周到的缓存对于REST服务的扩展至关重要。
- en: We have seen the types of web services and understood what is REST API. We also
    looked at the characteristics that make REST services unique. In the next section,
    we will take a look at REST verbs and status code and cover a few examples of
    path parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Web服务的类型，并了解了什么是REST API。我们还探讨了使REST服务独特的特性。在下一节中，我们将探讨REST动词和状态码，并介绍一些路径参数的示例。
- en: REST verbs and status codes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST动词和状态码
- en: 'REST verbs specify an action to be performed on a specific resource or a collection
    of resources. When a request is made by the client, it should send the following
    information in the HTTP request:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: REST动词指定对特定资源或一组资源要执行的操作。当客户端发起请求时，它应该在HTTP请求中发送以下信息：
- en: The REST verb
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST动词
- en: Header information
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部信息
- en: The body (optional)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体（可选）
- en: 'As we mentioned previously, REST uses the URI to decode the resource to be
    handled. There are quite a few REST verbs available, but six of them are used
    particularly frequently. They are presented, along with their expected actions,
    in the following table:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，REST使用URI来解码要处理的数据资源。有相当多的REST动词可用，但其中六个被特别频繁地使用。它们及其预期的操作如下表所示：
- en: '| **REST Verb** | **Action** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **REST动词** | **操作** |'
- en: '| `GET` | Fetches a record or set of resources from the server |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 从服务器获取记录或一组资源 |'
- en: '| `OPTIONS` | Fetches all available REST operations  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 获取所有可用的REST操作 |'
- en: '| `POST` | Creates a resource or a new set of resources |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 创建资源或一组新资源 |'
- en: '| `PUT` | Updates or replaces the given record |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 更新或替换指定的记录 |'
- en: '| `PATCH` | Modifies the given record |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 修改指定的记录 |'
- en: '| `DELETE` | Deletes the given resource  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 删除指定的资源 |'
- en: 'The status of these operations can be known from HTTP status codes. Whenever
    a client initiates a REST operation, since REST is stateless, the client should
    know a way to find out whether the operation was successful or not. For that reason,
    HTTP responses have a status code. REST defines a few standard status code types
    for a given operation. This means a REST API should strictly follow the following
    rules to achieve stable results in client-server communication. There are three
    important ranges available based on the types of error. See the following table
    for error ranges:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作的状态可以通过HTTP状态码得知。每当客户端发起一个REST操作时，由于REST是无状态的，客户端应该知道一种方式来找出操作是否成功。因此，HTTP响应有一个状态码。REST为特定操作定义了几种标准状态码类型。这意味着REST
    API应该严格遵循以下规则，以在客户端-服务器通信中实现稳定的结果。根据错误类型，有三个重要的范围可用。请参阅以下表格以了解错误范围：
- en: '| **Status Code Type** | **Number Range** | **Action** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **状态码类型** | **数字范围** | **操作** |'
- en: '| `Success` | 200 - 226 |  The 2xx family is used for successful responses.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `成功` | 200 - 226 | 2xx系列用于成功响应。 |'
- en: '| `Error` | 400 - 499 (client), 500 - 599 (server) | The 4xx family is used
    for indicating client errors. The 5xx is for server failures to process the request.
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Error` | 400 - 499 (客户端), 500 - 599 (服务器) | 4xx系列用于指示客户端错误。5xx用于指示服务器无法处理请求。
    |'
- en: '| `Redirect` | 300 - 308 | The 3xx family is for URL redirection. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Redirect` | 300 - 308 | 3xx系列用于URL重定向。 |'
- en: The detail of what each status code does is very precisely defined, and the
    overall count of codes increases every year. We mention the important ones in
    the upcoming section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态码的作用非常精确地定义，并且每年代码的总数都在增加。我们将在下一节中提到重要的那些。
- en: All requests to REST services have the following format. It consists of the
    host and the API endpoint. The API endpoint is the URL path that is predefined
    by the server. It can also include optional query parameters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对REST服务的请求都具有以下格式。它由主机和API端点组成。API端点是服务器预先定义的URL路径。它还可以包含可选的查询参数。
- en: A trivial REST API URI looks like the following: `http://HostName/APIEndpoint/?key=value(optional)`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的REST API URI看起来如下：`http://HostName/APIEndpoint/?key=value(可选)`
- en: Let's look at all the verbs in more detail. The REST API design starts with
    the defining of operations and API endpoints. Before implementing the API, the
    design document should list all the endpoints for the given resources.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看所有的动词。REST API设计始于定义操作和API端点。在实现API之前，设计文档应该列出给定资源的所有端点。
- en: In the following section, we carefully observe the REST API endpoints using
    PayPal's REST API as a use case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们仔细观察了REST API端点，以PayPal的REST API作为用例。
- en: GET
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GET
- en: 'A `GET` method fetches the given resource from the server. To specify a resource,
    `GET` uses a few types of URI queries:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法从服务器获取指定的资源。为了指定资源，`GET`使用几种类型的URI查询：'
- en: Query parameters
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数
- en: Path-based parameters
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路径的参数
- en: In case you didn't know, most of your browsing of the web is done by performing
    a `GET` request to the server. For example, if you type [www.google.com](http://www.google.com),
    you are actually making a `GET` request to fetch the search page. Here, your browser
    is the client and Google's web server is the backend implementer of web services.
    A successful `GET` operation returns a `200` status code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道，你大部分的网页浏览都是通过向服务器执行`GET`请求来完成的。例如，如果你输入[www.google.com](http://www.google.com)，你实际上是在向服务器发送一个`GET`请求以获取搜索页面。在这里，你的浏览器是客户端，而Google的Web服务器是Web服务的后端实现者。成功的`GET`操作返回`200`状态码。
- en: Examples of path parameters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径参数的示例
- en: Everyone knows **PayPal**. PayPal creates billing agreements with companies.
    If you register with PayPal for a payment system, they provide you with a REST
    API for all your billing needs. The sample `GET` request for getting the information
    of a billing agreement looks like this: `/v1/payments/billing-agreements/agreement_id`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道**PayPal**。PayPal与公司建立账单协议。如果你通过PayPal注册支付系统，他们将为你提供用于所有账单需求的REST API。获取账单协议信息的示例`GET`请求如下：`/v1/payments/billing-agreements/agreement_id`。
- en: Here, the resource query is with the path parameter. When the server sees this
    line, it interprets it as *I got an HTTP request with a need for* `agreement_id`
    *from the billing agreements*. Then it searches through the database, goes to
    the `billing-agreements` table, and finds an agreement with the given `agreement_id`.
    If that resource exists, it sends back a copy of the details in response (`200
    OK`), or else it sends a response saying, "resource not found" (`404`).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，资源查询是与路径参数一起的。当服务器看到这一行时，它将其解释为*我收到了一个需要* `agreement_id` *的HTTP请求，来自账单协议*。然后它通过数据库搜索，进入`billing-agreements`表，并找到具有给定`agreement_id`的协议。如果该资源存在，它将发送包含详细信息的副本作为响应（`200
    OK`），否则它将发送一条表示“资源未找到”的响应（`404`）。
- en: Using `GET`, you can also query a list of resources, instead of a single one
    as in the preceding example. PayPal's API for getting billing transactions related
    to an agreement can be fetched with `/v1/payments/billing-agreements/transactions`.
    This line fetches all transactions that occurred on that billing agreement. In
    both instances, the data is retrieved in the form of a JSON response. The response
    format should be designed beforehand so that the client can consume it in the
    agreement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GET`，你也可以查询资源列表，而不是像上一个示例中那样查询单个资源。可以通过`/v1/payments/billing-agreements/transactions`获取与协议相关的账单交易的PayPal
    API。这一行获取了在该账单协议上发生的所有交易。在这两种情况下，数据都以JSON响应的形式检索。响应格式应该事先设计好，以便客户端可以在协议中消费它。
- en: 'Examples of query parameters are as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数的示例如下：
- en: 'Query parameters are intended to add detailed information to identify a resource
    from the server. For example, imagine a sample fictitious API. Let''s assume this
    API is created for fetching, creating, and updating the details of the book. A
    query parameter based `GET` request will be in this format:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询参数的目的是向服务器添加详细的信息以标识资源。例如，想象一个示例虚构的API。假设这个API是为了获取、创建和更新书籍的详细信息而创建的。基于查询参数的`GET`请求将具有以下格式：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding URI has a couple of query parameters. The URI is requesting a
    book from the `books` resource that satisfies the following conditions:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的URI包含一些查询参数。该URI请求`books`资源中的一个书籍，满足以下条件：
- en: It should be a fiction book
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该是一本小说
- en: The book should have been published in the year 2017
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书应该在2017年出版
- en: '*Get all the fiction books that are released in the year 2017* is the question
    the client is posing to the server.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户向服务器提出的问题是*获取2017年发布的所有小说*。
- en: '`Path` vs `Query` parameters—When to use them? It is a common rule of thumb
    that `Query` parameters are used to fetch multiple resources based on the `Query`
    parameters. If a client needs a single resource with exact URI information, it
    can use `Path` parameters to specify the resource. For example, a user dashboard
    can be requested with `Path` parameters, and fetch data on filtering can be modeled
    with `Query` parameters.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`参数与`Query`参数——何时使用它们？一个常见的经验法则是使用`Query`参数根据`Query`参数获取多个资源。如果客户端需要一个具有精确URI信息的单一资源，它可以使用`Path`参数来指定资源。例如，用户仪表板可以使用`Path`参数请求，并且可以使用`Query`参数来模拟过滤数据获取。'
- en: Use `Path` parameters for a single resource and `Query` parameters for multiple
    resources in a `GET` request.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GET`请求中，使用`Path`参数用于单一资源，使用`Query`参数用于多个资源。
- en: POST, PUT, and PATCH
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POST、PUT和PATCH
- en: The `POST` method is used to create a resource on the server. In the previous
    `books` API, this operation creates a new book with the given details. A successful
    `POST` operation returns a 2xx status code. The `POST` request can update multiple
    resources: `/v1/books`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`方法用于在服务器上创建资源。在之前的`books` API中，这个操作会创建一个具有给定详细信息的新的书籍。一个成功的`POST`操作返回2xx状态码。`POST`请求可以更新多个资源：`/v1/books`。'
- en: 'The `POST` request can have a JSON body like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`请求可以有一个如下的JSON体：'
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This actually creates a new book in the database. An ID is assigned to this
    record so that when we `GET` the resource, the URL is created. So, `POST` should
    be done only once, in the beginning. In fact, *Lord of the Rings* was published
    in *1955*. So, we entered the published date incorrectly. In order to update the
    resource, let's use the `PUT` request.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上在数据库中创建了一个新的书籍记录。为这个记录分配了一个ID，以便当我们`GET`资源时，URL被创建。所以，`POST`应该只在开始时进行一次。实际上，《指环王》是在*1955年*出版的。所以我们输入的出版日期是错误的。为了更新资源，让我们使用`PUT`请求。
- en: 'The `PUT` method is similar to `POST`. It is used to replace the resource that
    already exists. The main difference is that `PUT` is an idempotent operation.
    A `POST` call creates two instances with the same data. But `PUT` updates a single
    resource that already exists:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`方法类似于`POST`。它用于替换已经存在的资源。主要区别在于`PUT`是一个幂等操作。一个`POST`调用会创建两个具有相同数据的新实例。但是`PUT`更新一个已经存在的单一资源：'
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`PUT` does this using a body containing JSON syntax, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`使用包含JSON语法的体来实现，如下所示：'
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`1256` is the ID of the book. It updates the preceding book with `year:1955`.
    Did you observe the drawback of `PUT`? It actually replaced the entire old record
    with the new one. We needed to change a single column. But `PUT` replaced the
    whole record. That is bad. For this reason, the `PATCH` request was introduced.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`1256` 是这本书的ID。它更新了之前的书籍信息，`year:1955`。你是否注意到了`PUT`方法的缺点？它实际上是用新的记录替换了整个旧的记录。我们只需要更改一个列。但是`PUT`替换了整个记录。这是不好的。因此，引入了`PATCH`请求。'
- en: 'The `PATCH` method is similar to `PUT`, except it won''t replace the whole
    record. `PATCH`, as the name suggests, patches the column that is being modified.
    Let''s update the book `1256` with a new column called `ISBN`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH`方法类似于`PUT`，但它不会替换整个记录。正如其名所示，`PATCH`会修补正在修改的列。让我们用一个新的列`ISBN`更新书籍`1256`：'
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s use put the following JSON in the body:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把以下JSON放入体中：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It tells the server, "*search for the book with ID* `1256`*. Then add/modify
    this column with the given value*."
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉服务器，“*搜索ID为* `1256`* 的书籍。然后添加/修改这个列的给定值*。”
- en: '`PUT` and `PATCH` both return a 2xx status for success and 404 for not found.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`和`PATCH`在成功时都返回2xx状态码，在未找到时返回404。'
- en: DELETE and OPTIONS
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DELETE 和 OPTIONS
- en: The `DELETE` API method is used to delete a resource from the database. It is
    similar to `PUT` but without a body. It just needs an ID of the resource to be
    deleted. Once a resource gets deleted, subsequent `GET` requests return a 404
    not found status.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` API 方法用于从数据库中删除资源。它与 `PUT` 类似，但没有主体。它只需要要删除的资源 ID。一旦资源被删除，后续的 `GET`
    请求将返回 404 未找到状态。'
- en: Responses to this method are *not cacheable* (should caching be implemented)
    because the `DELETE` method is idempotent.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对此方法的响应 *不可缓存*（如果应该实现缓存的话），因为 `DELETE` 方法是幂等的。
- en: The `OPTIONS` API method is the most underrated in API development. Given the
    resource, this method tries to find all possible methods (`GET`, `POST`, and so
    on) defined on the server. It is like looking at the menu card at a restaurant
    and then ordering an item that is available (whereas if you randomly order a dish,
    the waiter will tell you it is not available). It is best practice to implement
    the `OPTIONS` method on the server. From the client, make sure `OPTIONS` is called
    first, and if the method is available, then proceed with it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONS` API 方法在 API 开发中被低估了。给定资源，此方法试图找到服务器上定义的所有可能的方法（`GET`、`POST` 等）。这就像在餐厅看菜单卡，然后点一个可用的菜（而如果你随机点菜，服务员会告诉你它不可用）。在服务器上实现
    `OPTIONS` 方法是最佳实践。从客户端确保首先调用 `OPTIONS`，如果该方法可用，则继续进行。'
- en: Cross-Origin Resource Sharing (CORS)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨源资源共享（CORS）
- en: The most important application of this `OPTIONS` method is **Cross-Origin Resource
    Sharing** (**CORS**). Initially, browser security prevented the client from making
    cross-origin requests. It means a site loaded with the `www.foo.com` URL can only
    make API calls to that host. If the client code needs to request files or data
    from `www.bar.com`, then the second server, `bar.com`, should have a mechanism
    to recognize `foo.com` to get its resources.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `OPTIONS` 方法的最重要应用是 **跨源资源共享**（**CORS**）。最初，浏览器安全机制阻止客户端进行跨源请求。这意味着加载了 `www.foo.com`
    URL 的站点只能对该主机进行 API 调用。如果客户端代码需要从 `www.bar.com` 请求文件或数据，那么第二个服务器 `bar.com` 应该有一个机制来识别
    `foo.com` 以获取其资源。
- en: 'The following is the diagram depicting the CORS process:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 CORS 流程：
- en: '![](img/07f80e14-0814-48e4-945f-eee3fc018de1.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07f80e14-0814-48e4-945f-eee3fc018de1.png)'
- en: 'Let''s examine the steps followed in the preceding CORS diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面 CORS 图表中遵循的步骤：
- en: '`foo.com` requests the `OPTIONS` method on `bar.com`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foo.com` 在 `bar.com` 上请求 `OPTIONS` 方法'
- en: '`bar.com` sends a header like `Access-Control-Allow-Origin: http://foo.com` in
    response to the client'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bar.com` 在对客户端的响应中发送一个类似于 `Access-Control-Allow-Origin: http://foo.com` 的头信息'
- en: Next, `foo.com` can access the resources on `bar.com` without any restrictions
    that call any `REST` method
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`foo.com` 可以无任何限制地访问 `bar.com` 上的资源，调用任何 `REST` 方法
- en: If `bar.com` feels like supplying resources to any host after one initial request,
    it can set the access control to `*`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `bar.com` 在一个初始请求之后感觉可以向任何主机提供资源，它可以设置访问控制为 `*`。
- en: In the next section, we see why the REST API plays such a major role in the
    next generation of web services. SPAs made it possible to leverage APIs for all
    purposes, including the UI, clients, and so on.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到为什么 REST API 在下一代 Web 服务中扮演如此重要的角色。SPA 使得可以利用 API 用于所有目的，包括 UI、客户端等。
- en: The rise of the REST API with SPAs
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API 与单页应用（SPAs）的兴起
- en: Let's try to understand why SPAs are already standards of today's web. Instead
    of building a UI in the traditional way (that is, requesting rendered web pages),
    SPA designs allow developers to write code in a totally different way. There are
    many **Model-View-Controller** (**MVC**) frameworks, including Angular, React,
    Vue.js, and so on, for developing web UIs rapidly, but the essence of each of
    them is pretty simple. All MVC frameworks help us to implement one design pattern.
    That design pattern is *no requesting of web pages, only REST API usage.*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解为什么单页应用（SPAs）已经成为今天网络的行业标准。与传统方式（即请求渲染的网页）构建 UI 不同，SPA 设计允许开发者以完全不同的方式编写代码。有许多
    **模型-视图-控制器**（**MVC**）框架，包括 Angular、React、Vue.js 等，用于快速开发 Web UI，但它们的本质都很简单。所有
    MVC 框架都帮助我们实现一个设计模式。这个设计模式是 *不请求网页，只使用 REST API*。
- en: Modern frontend web development has advanced a lot in the last decade (2010-2020).
    In order to exploit the features ofthe MVC architecture, we have to consider the
    frontend as a separate entity that talks to the backend only using the REST API
    (preferably using JSON data).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 过去十年（2010-2020年）现代前端Web开发取得了很大的进步。为了利用MVC架构的特性，我们必须将前端视为一个独立的实体，它仅通过REST API（最好是使用JSON数据）与后端通信。
- en: Old and new methods of data flow in SPA
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用（SPA）中数据流的传统和新方法
- en: 'In the traditional flow of serving requests, the order looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的请求处理流程中，顺序如下：
- en: The client requests a web page from the server
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端从服务器请求网页
- en: The server authenticates and returns a rendered response
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器进行身份验证并返回渲染的响应
- en: Every rendered response is in HTML with embedded data
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个渲染的响应都是HTML，并嵌入数据
- en: 'With SPAs, however, the flow is quite different:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用SPAs的流程却相当不同：
- en: Request the HTML templates with the browser in one single go
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一次性使用浏览器请求HTML模板
- en: Then, query the JSON REST API to fill a model (the data object)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，查询JSON REST API以填充模型（数据对象）
- en: Adjust the UI according to the data in the model (in JSON)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据模型中的数据（JSON格式）调整UI
- en: From the browser, push back the changes to the server via an API call
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从浏览器通过API调用将更改推回服务器
- en: 'In this way, communication happens only in the form of the REST API. The client
    takes care of logically representing the data. This causes systems to move from
    **Response-Oriented Architecture** (**ROA**) to **Service-Oriented Architecture**
    (**SOA**). Take a look at the following diagram:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通信仅以REST API的形式发生。客户端负责逻辑上表示数据。这导致系统从**面向响应的架构**（**ROA**）转向**面向服务的架构**（**SOA**）。请看以下图表：
- en: '![](img/32cf1a89-be4d-47fd-9af6-138118491a8d.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32cf1a89-be4d-47fd-9af6-138118491a8d.png)'
- en: SPAs reduce bandwidth usage and improve site performance. SPAs are a major boost
    for API-centric server development because now a server can satisfy requirements
    for both browser and API clients.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPAs）减少了带宽使用并提高了网站性能。SPAs对以API为中心的服务器开发是一个巨大的推动，因为现在服务器可以满足浏览器和API客户端的双重需求。
- en: Why use Go for REST API development?
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用Go进行REST API开发？
- en: REST services are trivial in the modern web. SOA (which we discuss in more detail
    later) created an activity space for REST services to take web development to
    the next level. **Go** is a programming language from the house of Google for
    solving the bigger problems they have. It has been over ten years since its first
    appearance. It matured along the way with the developer community jumping in and
    creating huge-scale systems in it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web中，REST服务很简单。SOA（我们将在后面更详细地讨论）为REST服务创造了一个活动空间，将Web开发提升到下一个层次。**Go**是谷歌公司为解决他们更大的问题而开发的一种编程语言。自从它首次出现以来已经超过十年了。它在开发社区的参与下不断成熟，并在其中创建了大规模的系统。
- en: Go is the darling of the web. It solves bigger problems in an easy way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go是Web的宠儿。它以简单的方式解决了更大的问题。
- en: 'We could choose Python or JavaScript (*Node.js*) for our REST API development,
    but the main advantage of Go lies in its speed and compile-time error detection.
    Go has been proven to be faster than dynamic programming languages in terms of
    computational performance according to various benchmarks. These are the three
    reasons why a company should write their next API in Go:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择Python或JavaScript (*Node.js*) 来开发我们的REST API，但Go的主要优势在于其速度和编译时错误检测。根据各种基准测试，Go在计算性能方面已被证明比动态编程语言更快。以下是公司应该用Go编写下一个API的三个原因：
- en: To scale your API for a wider audience
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为更广泛的受众扩展您的API
- en: To enable your developers to build robust systems
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使您的开发者能够构建健壮的系统
- en: To start simple and go big
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从简单开始，逐步扩大规模
- en: As we progress through this book, we learn how to build efficient REST services
    in Go.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在这本书中的进展，我们将学习如何在Go中构建高效的REST服务。
- en: Setting up the project and running the development server
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目和运行开发服务器
- en: This is a building series book. It assumes you already know the basics of Go.
    If not, no worries. You can get a jump-start and learn the basics quickly from
    Go's official site at [https://golang.org/](https://golang.org/). Writing a simple
    standalone program with Go is straightforward. But for big projects, we have to
    set up a clean project layout. For that reason, as a Go developer, you should
    know how Go projects are laid out and the best practices to keep your code clean.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一系列构建书籍。它假设你已经了解了 Go 的基础知识。如果不是，不用担心。你可以从 Go 的官方网站 [https://golang.org/](https://golang.org/)
    快速入门并学习基础知识。用 Go 编写一个简单的独立程序很简单。但对于大型项目，我们必须设置一个干净的项目布局。因此，作为一个 Go 开发者，你应该了解 Go
    项目的布局和保持代码整洁的最佳实践。
- en: 'Make sure you have done the following things before proceeding:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经完成了以下事项：
- en: Install the Go compiler on your machine
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的机器上安装 Go 编译器
- en: Set the `GOROOT` and `GOPATH` environment variables
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `GOROOT` 和 `GOPATH` 环境变量
- en: There are many online references from which you can get to know the preceding
    details. Depending on your machine type (Windows, Linux, or Mac OS X ), set up
    a working Go compiler. We will see more details about `GOPATH` in the following
    section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多在线参考资料，你可以从中了解前面的细节。根据你的机器类型（Windows、Linux 或 Mac OS X），设置一个可工作的 Go 编译器。我们将在下一节中看到更多关于
    `GOPATH` 的细节。
- en: Demystifying GOPATH
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭秘 GOPATH
- en: '`GOPATH` is nothing but the current appointed workspace on your machine. It
    is an environment variable that tells the Go compiler where your source code,
    binaries, and packages are placed.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOPATH` 仅仅是你在机器上指定的当前工作区。它是一个环境变量，告诉 Go 编译器你的源代码、二进制文件和包存放的位置。'
- en: The programmers coming from a Python background may be familiar with the `Virtualenv`
    tool for creating multiple projects (with different Python interpreter versions)
    at the same time. But at a given time, you can activate the environment for the
    project that you wish to work on and develop your project. Similarly, you can
    have any number of Go projects on your machine. While developing, set the `GOPATH`
    to one of your projects. The Go compiler now activates that project.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Python 背景的程序员可能熟悉 `Virtualenv` 工具，它可以同时创建多个项目（具有不同的 Python 解释器版本）。但在特定时间，你可以激活你想要工作的项目的环境并开发你的项目。同样，你可以在你的机器上拥有任意数量的
    Go 项目。在开发时，将 `GOPATH` 设置为你的一个项目。Go 编译器现在激活了该项目。
- en: 'It is a common practice to create a project under the `home` directory and
    set the `GOPATH` environment variable as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `home` 目录下创建项目并设置 `GOPATH` 环境变量是一种常见的做法，如下所示：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we install external packages like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们这样安装外部包：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Go copies a project called `mux` from GitHub into the currently activated project
    `workspace`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Go 会从 GitHub 复制一个名为 `mux` 的项目到当前激活的项目 `workspace`。
- en: For `go get`, use the `-u` flag to install the updated dependencies of the external
    package, and `-v` to see the verbose details of the installation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `go get`，使用 `-u` 标志来安装外部包的更新依赖，使用 `-v` 来查看安装的详细日志。
- en: 'A typical Go project, `hello`, should reside in the `src` directory in `GOPATH`,
    as mentioned on the official Go website:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如官方 Go 网站所述，一个典型的 Go 项目 `hello` 应该位于 `GOPATH` 的 `src` 目录下：
- en: '![](img/9131a9e3-2370-4186-b5bf-643b42b2287a.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9131a9e3-2370-4186-b5bf-643b42b2287a.png)'
- en: 'Let''s understand this structure before digging further:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究之前，让我们了解这个结构：
- en: '`bin`: Stores the binary of our project; a shippable binary that can be run
    directly'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin`: 存储我们的项目二进制文件；可以直接运行的可分发二进制文件'
- en: '`pkg`: Contains the package objects; a compiled program that supplies package
    methods'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`: 包含包对象；提供包方法的编译程序'
- en: '`src`: The place for your project source code, tests, and user packages'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`: 这是你的项目源代码、测试和用户包的存放地'
- en: In Go, all the packages imported into the main program have an identical structure,
    `github.com/user/project`. But who creates all these directories? Should the developer
    do that? Yes. It is the developer's responsibility to create directories for their
    project. It means they only create the `src/github.com/user/hello` directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，所有导入到主程序中的包都具有相同的结构，`github.com/user/project`。但是，谁创建所有这些目录呢？应该是开发者来做。这意味着开发者只需创建他们项目的
    `src/github.com/user/hello` 目录。
- en: 'When a developer runs the `install` command, the `bin` and `package` directories are
    created if they did not exist before. `.bin` consists of the binary of our project
    source code and `.pkg` consists of all internal and external packages we use in
    our Go programs:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者运行`install`命令时，如果之前不存在，则会创建`bin`和`package`目录。`.bin`包含我们项目源代码的二进制文件，而`.pkg`包含我们在Go程序中使用的所有内部和外部包：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's build a small service to brush up on our Go language skills. Operating
    systems such as Debian and Ubuntu host their release images on multiple FTP servers.
    These are called mirrors. Mirrors are helpful in serving an OS image from the
    closest point to a client. Let's build a service that finds the fastest mirror
    from a list of mirrors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个小型服务来提高我们的Go语言技能。例如，Debian和Ubuntu操作系统在多个FTP服务器上托管其发布镜像。这些被称为镜像。镜像有助于从离客户端最近的位置提供操作系统镜像。让我们构建一个从镜像列表中找到最快镜像的服务。
- en: Building our first service – finding the fastest mirror site from a list
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个服务 - 从列表中找到最快的镜像站点
- en: With the concepts we have built up to now, let's write our first REST service.
    Many mirror sites exist for hosting operating system images including Ubuntu and
    Debian. The mirror sites here are nothing but websites on which OS images are
    hosted to be geographically close to the downloading machines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们至今已建立的概念，让我们编写我们的第一个REST服务。许多镜像站点用于托管操作系统镜像，包括Ubuntu和Debian。这里的镜像站点只是托管OS镜像的网站，以便地理位置上靠近下载机器。
- en: 'Let''s look at how we can create our first service:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何创建我们的第一个服务：
- en: '**Problem**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**:'
- en: Build a REST service that returns the information of the fastest mirror to download
    a given OS from a huge list of mirrors. Let's take the Debian OS mirror list for
    this service. You can find the list at [https://www.debian.org/mirror/list](https://www.debian.org/mirror/list).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个REST服务，该服务返回从大量镜像中下载给定操作系统的最快镜像的信息。让我们以Debian操作系统镜像列表为例。您可以在[https://www.debian.org/mirror/list](https://www.debian.org/mirror/list)找到该列表。
- en: We use that list as input when implementing our service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实现我们的服务时使用该列表作为输入。
- en: '**Design**:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计**:'
- en: Our REST API should return the URL of the fastest mirror.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的REST API应该返回最快镜像的URL。
- en: 'The block of the API design document may look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: API设计文档的块可能看起来像这样：
- en: '| **HTTP Verb** | **PATH** | **Action** | **Resource** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **路径** | **操作** | **资源** |'
- en: '| `GET` | `/fastest-mirror` | fetch | `URL: string` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/fastest-mirror` | 获取 | `URL: 字符串` |'
- en: '**Implementation**:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现**:'
- en: 'Now we are going to implement the preceding API step by step:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将逐步实现前面的API：
- en: The code for this project is available at [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go) in
    the `chapter1` subdirectory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码可在[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go)的`chapter1`子目录中找到。
- en: 'As we previously discussed, you should set the `GOPATH` variable first. Let''s
    assume the `GOPATH` variable is `/home/user/workspace`. Create a directory called
    `mirrorFinder` in the following path. `git-user`should be replaced with your GitHub
    username under which this project resides:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，你应该首先设置`GOPATH`变量。假设`GOPATH`变量为`/home/user/workspace`。在以下路径中创建一个名为`mirrorFinder`的目录。`git-user`应替换为该项目所在的GitHub用户名：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our project is ready. We don''t have any data store configured yet. Create
    an empty file called `main.go`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的项目已经准备好了。我们还没有配置任何数据存储。创建一个名为`main.go`的空文件：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Our main logic for the API server goes into this file. For now, we can create
    a data file that works as a data service for our main program. Create one more
    directory for packaging the mirror list data:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们API服务器的主体逻辑将放入这个文件。目前，我们可以创建一个数据文件，作为我们主程序的数据服务。为打包镜像列表数据创建一个额外的目录：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, create an empty file called `data.go` in the `mirrors` directory. The `src`
    directory structure so far looks like this:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`mirrors`目录下创建一个名为`data.go`的空文件。到目前为止，`src`目录结构如下所示：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s start adding code to the files. Create an input data file called `data.go`
    for our API to use:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始向文件中添加代码。为我们的API创建一个名为`data.go`的输入数据文件：
- en: '[PRE14]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We create a map of strings called `MirrorList`. This map holds information on
    the URL to reach the mirror site. We are going to import this information into
    our main program to serve the request from the client.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为`MirrorList`的字符串映射。这个映射包含到达镜像站点的URL信息。我们将把这些信息导入到我们的主程序中，以服务来自客户端的请求。
- en: 'Open `main.go` and add the following code:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.go`并添加以下代码：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We created the main function that runs an HTTP server. Go provides the `net/http`
    package for that purpose. The response of our API is a struct with two fields:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个主函数，用于运行HTTP服务器。Go提供了`net/http`包来实现这个目的。我们的API响应是一个包含两个字段的struct：
- en: '`fastest_url`: The fastest mirror site'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastest_url`：最快的镜像站点'
- en: '`latency`: The time it takes to download the README from the Debian OS repository'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latency`：从Debian OS仓库下载README所需的时间'
- en: 'We will code a function called `findFastest` to make requests to all the mirrors
    and calculate the fastest of all. To do this, instead of making sequential API
    calls to each and every URL one after the other, we use Go routines to parallelly
    request the URLs and once a goroutine returns, we stop there and return that data
    back.:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`findFastest`的函数，向所有镜像发送请求并计算最快的。为此，我们不是依次对每个URL进行顺序的API调用，而是使用goroutines并行请求URL，一旦goroutine返回，我们就停止并返回该数据。：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `findFastest` function is taking a list of URLs and returning the response
    struct. The function creates a goroutine per mirror site URL. It also creates
    two channels, `urlChan` and `latencyChan`, which are passed to the goroutines.
    In the goroutines, we calculate the latency (time taken for the request).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`findFastest`函数接受一个URL列表并返回响应struct。该函数为每个镜像站点URL创建一个goroutine。它还创建了两个通道，`urlChan`和`latencyChan`，这些通道被传递给goroutines。在goroutines中，我们计算延迟（请求所需的时间）。'
- en: The smart logic here is, whenever a goroutine receives a response, it writes
    data into two channels with the URL and latency information respectively. Upon
    receiving data, the two channels make the response struct and return from the `findFastest`
    function. When that function is returned, all goroutines spawned from that are
    stopped from whatever they are doing. So, we will have the shortest URL in `urlChan`
    and the smallest latency in `latencyChan`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的智能逻辑是，每当goroutine收到响应时，它会将数据写入两个分别带有URL和延迟信息的通道。在接收到数据后，这两个通道会创建响应struct并从`findFastest`函数返回。当该函数返回时，所有从该函数产生的goroutine都会停止它们正在做的事情。因此，我们将在`urlChan`中获得最短的URL，在`latencyChan`中获得最小的延迟。
- en: 'Now if you add this function to the main file (`main.go`), our code is complete
    for the task:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你将此函数添加到主文件（`main.go`），我们的代码就完成了这个任务：
- en: Always use the Go `fmt` tool to format your Go code. Some example usage of `fmt` looks
    like the following: `go fmt github.com/narenaryan/romanserver`
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用Go的`fmt`工具来格式化你的Go代码。`fmt`的一些示例用法如下：`go fmt github.com/narenaryan/romanserver`
- en: 'Now, install this project with the Go command, `install`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用Go命令`install`安装此项目：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This step does two things:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤执行两个操作：
- en: Compiles the package `mirrors` and places a copy in the `$GOPATH/pkg` directory
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译`mirrors`包并将其副本放置在`$GOPATH/pkg`目录中
- en: Places a binary in the `$GOPATH/bin`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制文件放置在`$GOPATH/bin`
- en: 'We can run the preceding API server like this:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像这样运行前面的API服务器：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The server is up and running on `http://localhost:8000`. Now we can make a `GET`
    request to the API using a client such as a browser or a curl command. Let's fire
    a `curl` command with a proper API `GET` request.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器正在`http://localhost:8000`上运行。现在我们可以使用浏览器或curl命令等客户端向API发送`GET`请求。让我们使用正确的API
    `GET`请求发送一个`curl`命令。
- en: 'Request one is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请求如下：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The response is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our fastest-mirror-finding API is working great. The right status code is being
    returned. The output may change with each API call, but it fetches the lowest-latency
    link at any given moment. This example also shows where goroutines and channels
    shine.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最快镜像查找API运行得很好。返回了正确的状态码。输出可能会随着每次API调用而变化，但它会获取任何给定时刻的最低延迟链接。此示例还展示了goroutines和channels的优势。
- en: In the next section, we'll look at an API specification called Open API. An
    API specification is for documenting the REST API. To visualize the specification,
    we will use the Swagger UI tool.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看一个名为Open API的API规范。API规范是用于记录REST API的。为了可视化规范，我们将使用Swagger UI工具。
- en: Open API and Swagger
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放API和Swagger
- en: Because APIs are very common, the Open API Specification is a community-driven
    open specification within the [OpenAPI Initiative](https://www.openapis.org/),
    a Linux Foundation Collaborative Project.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API非常常见，因此Open API规范是[OpenAPI Initiative](https://www.openapis.org/)内部的一个社区驱动的开放规范，OpenAPI
    Initiative是一个Linux Foundation协作项目。
- en: 'The **OpenAPI Specification** (**OAS**), formerly called the `Swagger` Specification,
    is an API description format for REST APIs. An Open API file allows you to describe
    your entire API, including the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenAPI 规范**（**OAS**），以前称为 `Swagger` 规范，是 REST API 的 API 描述格式。Open API 文件允许您描述您的整个
    API，包括以下内容：'
- en: Available endpoints
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用端点
- en: Endpoint operations (GET, PUT, DELETE, and so on)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点操作（GET、PUT、DELETE 等）
- en: Parameter input and output for each operation
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个操作的参数输入和输出
- en: Authentication methods
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证方法
- en: Contact information, license, terms of use, and other information.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系信息、许可、使用条款和其他信息。
- en: Open API has many versions and is rapidly developing. The current stable version
    is `3.0`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Open API 有许多版本，并且正在快速发展。当前稳定版本是 `3.0`。
- en: 'There are two formats, **JSON** and **YAML**, that are supported by `OAS`.
    Swagger and Open API both are different. Swagger has many products, including
    the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`OAS` 支持两种格式，**JSON** 和 **YAML**。Swagger 和 Open API 是不同的。Swagger 有许多产品，包括以下内容：'
- en: Swagger UI (for validating Open API files and interactive docs)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger UI（用于验证 Open API 文件和交互式文档）
- en: Swagger Codegen (for generating server stubs)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger Codegen（用于生成服务器存根）
- en: Whenever we develop a REST API, it is a better practice to create an Open API/Swagger
    file that captures all the necessary details and descriptions of the API. The
    file can then be used in Swagger UI to create interactive documentation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们开发 REST API 时，创建一个 Open API/Swagger 文件以捕获 API 所需的所有详细信息和描述是一个更好的做法。然后可以使用
    Swagger UI 创建交互式文档。
- en: Installing Swagger UI
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Swagger UI
- en: 'Swagger UI can be installed/downloaded on various operating systems, but the
    best way could be using Docker. A Swagger UI Docker image is available on the
    Docker Hub. Then we can pass our Open API/Swagger file to the Docker container
    we run out of the image. Before that, we need to create a JSON file. The Swagger
    JSON file has few sections:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger UI 可以在各种操作系统上安装/下载，但最好的方法可能是使用 Docker。Docker Hub 上有一个 Swagger UI Docker
    镜像。然后我们可以将我们的 Open API/Swagger 文件传递到我们运行的 Docker 容器中。在此之前，我们需要创建一个 JSON 文件。Swagger
    JSON 文件有几个部分：
- en: '`info`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`'
- en: '`servers`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`servers`'
- en: '`paths`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`'
- en: 'Let''s create a Swagger file with the preceding sections for the first service
    we built. Let''s name it `openapi.json`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为第一个构建的服务创建一个具有前面各节的 Swagger 文件。让我们称它为 `openapi.json`：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Please notice how we defined the `info`, `servers`, and `paths` sections.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何定义了 `info`、`servers` 和 `paths` 部分。
- en: The `openapi` tag specifies the version of the API document we are using.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`openapi` 标签指定我们正在使用的 API 文档的版本。'
- en: The `info` section has a service-related description. The `servers` section has
    the URL of the server where the application/server is running. We used `localhost:8000`
    as we are running it locally. The `paths` section has information about all the
    API endpoints a service provides. It also has information about the request body,
    response type, and body structure. Even the possible error codes can be encapsulated
    into `paths`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`info` 部分包含与服务相关的描述。`servers` 部分包含应用程序/服务器运行的服务器 URL。我们使用了 `localhost:8000`，因为我们是在本地运行。`paths`
    部分包含服务提供的所有 API 端点的信息。它还包含有关请求体、响应类型和体结构的信息。甚至可能的错误代码也可以封装到 `paths` 中。'
- en: 'Now let''s install Swagger UI and make use of our Swagger file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们安装 Swagger UI 并使用我们的 Swagger 文件：
- en: 'To install Swagger UI via Docker, run this command from your shell:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过 Docker 安装 Swagger UI，请在您的 shell 中运行以下命令：
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you are on Windows 10/Mac OS X , make sure Docker Desktop is running. On
    Linux, Docker is available all the time once installed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows 10/Mac OS X，请确保 Docker Desktop 正在运行。在 Linux 上，一旦安装，Docker 就始终可用。
- en: 'This pulls the image from the Docker Hub to your local machine. Now we can
    run a container that can take an `openapi.json` file and launch Swagger UI. Assuming
    that you have this file in the `chapter1` directory, let''s use the following
    command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将从 Docker Hub 将镜像拉取到您的本地机器。现在我们可以运行一个容器，该容器可以接受一个 `openapi.json` 文件并启动 Swagger
    UI。假设您在 `chapter1` 目录中拥有此文件，让我们使用以下命令：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command tells Docker to do the following things:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉 Docker 执行以下操作：
- en: Run a container using the `swaggerapi/swagger-ui` image
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `swaggerapi/swagger-ui` 镜像运行容器
- en: Mount `chapter1` (where `openapi.json` resides) to the `/app` directory in the
    container
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `chapter1`（`openapi.json` 所在的位置）挂载到容器中的 `/app` 目录
- en: Expose host port `80` to container port `8080`
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主机端口 `80` 暴露给容器端口 `8080`
- en: Set the `SWAGGER_JSON` environment variable to `/app/openapi.json`
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `SWAGGER_JSON` 环境变量设置为 `/app/openapi.json`
- en: 'When the container starts, launch `http://locahost` in the browser. You will
    see nice documentation for your API:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，在浏览器中打开`http://locahost`。您将看到您API的精美文档：
- en: '![](img/0ece99df-f5f1-44b0-85d8-2ef5dd1d7170.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ece99df-f5f1-44b0-85d8-2ef5dd1d7170.png)'
- en: In this way, without any cost, we can create instant documentation of our REST
    API using Swagger UI and Open API 3.0.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们无需任何成本，就可以使用Swagger UI和Open API 3.0创建我们REST API的即时文档。
- en: For testing an API within Swagger UI, the REST API server needs to be accessible
    to the Docker container (for example, via a network bridge).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Swagger UI中测试API，REST API服务器需要对Docker容器可访问（例如，通过网络桥接）。
- en: From now on, in all chapters, we will try to create Swagger files to document
    our API design. It is a wise decision to start API development by creating API
    specifications first and then jumping into implementation. I hope this chapter
    helped you to brush up on the basics of REST API fundamentals. In the following
    chapters, we will go deeply into many diverse topics.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在所有章节中，我们将尝试创建Swagger文件来记录我们的API设计。首先创建API规范，然后进入实现，这是一个明智的决定。我希望这一章能帮助您复习REST
    API基础。在接下来的章节中，我们将深入探讨许多不同的主题。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gave an introduction to the REST API. We saw that REST is
    not a protocol, but an architectural pattern. HTTP is the actual protocol on which
    we can implement our REST service. We jumped into the fundamentals of the REST
    API to be clear about what they actually are. Then we explored types of web services.
    Before REST, we had something called SOAP, which used XML as its data format.
    REST operates on JSON as its primary format. REST has verbs and status codes.
    We saw what these status codes refer to.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了REST API。我们了解到REST不是一个协议，而是一种架构模式。HTTP是我们可以在其上实现REST服务的实际协议。我们深入探讨了REST
    API的基础，以清楚地了解它们实际上是什么。然后我们探讨了Web服务的类型。在REST之前，我们有一种叫做SOAP的东西，它使用XML作为其数据格式。REST以JSON作为其主要格式。REST有动词和状态码。我们看到了这些状态码指的是什么。
- en: We designed and implemented a simple service that finds the fastest mirror site
    to download OS images from all Debian mirror sites hosted worldwide. In this process,
    we also saw how to package a Go project into a binary. We understood the `GOPATH`
    environment variable, which is a workspace definition in Go. We now know that
    all packages and projects reside on that path.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计和实现了一个简单的服务，该服务从全球所有Debian镜像站点中找到下载OS镜像的最快镜像站点。在这个过程中，我们还看到了如何将Go项目打包成二进制文件。我们了解了`GOPATH`环境变量，它是Go中的工作空间定义。我们现在知道所有包和项目都位于该路径上。
- en: Next, we jumped into the world of OpenAPI specification by introducing Swagger
    UI and Swagger files. The structure of these files and how to run Swagger UI with
    the help of Docker were discussed briefly. We also saw why a developer should
    start API development by writing down the specifications in the form of a Swagger
    file.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过介绍Swagger UI和Swagger文件，跳入了OpenAPI规范的世界。简要讨论了这些文件的结构以及如何使用Docker运行Swagger
    UI。我们还看到了为什么开发者应该通过编写Swagger文件形式的规范来开始API开发。
- en: In the next chapter, we will dig deeper into URL routing. Starting from the
    built-in router, we will explore Gorilla Mux, a powerful URL routing library.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨URL路由。从内置路由器开始，我们将探索Gorilla Mux，这是一个强大的URL路由库。
