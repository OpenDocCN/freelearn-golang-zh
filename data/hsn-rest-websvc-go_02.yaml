- en: Handling Routing for our REST Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理REST服务的路由
- en: In this chapter, we will discuss routing for a REST application. To create an
    API, the first step is to define routes. To define routes, we have to figure out
    the available system packages in Go. We'll begin this chapter by exploring the
    basic internal routing mechanism in Go. We then see how to create a custom multiplexer,
    an entity that matches a given URL to a registered pattern. A multiplexer basically
    allows a developer to create a route to listen to client requests and attaches
    handlers that hold the business logic of the application. The `ServeMux` package
    is the basic multiplexer provided by Go. We'll then explore a few other frameworks
    as `ServeMux` capabilities are very limited.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论REST应用程序的路由。要创建API，第一步是定义路由。要定义路由，我们必须了解Go中可用的系统包。我们将从探索Go中的基本内部路由机制开始本章。然后，我们将看到如何创建一个自定义的多路复用器，该实体将给定的URL与已注册的模式匹配。多路复用器基本上允许开发者创建一个路由来监听客户端请求，并附加包含应用程序业务逻辑的处理程序。`ServeMux`包是Go提供的基礎多路复用器。然后，我们将探索一些其他框架，因为`ServeMux`的功能非常有限。
- en: This chapter also includes the likes of third-party libraries such as `httprouter`
    and `gorilla/mux`. Then, we'll discuss topics such as SQL injection. The crux
    of this chapter is to teach you how to create elegant HTTP routers in Go using
    `gorilla/mux`. We'll also briefly discuss designing a URL shortening service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还包括类似`httprouter`和`gorilla/mux`的第三方库。然后，我们将讨论诸如SQL注入等主题。本章的核心是教您如何使用`gorilla/mux`在Go中创建优雅的HTTP路由器。我们还将简要讨论设计URL缩短服务。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding Go's  `net/http` package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Go的`net/http`包
- en: '`ServeMux`—a basic router in Go'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServeMux`——Go中的基本路由器'
- en: Understanding `httprouter`—a lightweight HTTP router
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`httprouter`——一个轻量级的HTTP路由器
- en: Introducing` gorilla/mux`—a powerful HTTP router
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍`gorilla/mux`——一个强大的HTTP路由器
- en: 'Reader''s challenge: an API for URL shortening'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者挑战：一个URL缩短API
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the software that should be pre-installed for running code
    samples:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行代码示例之前应预安装的软件：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13
- en: Go latest version compiler >= 1.13.5
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go最新版本编译器 >= 1.13.5
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2).
    Clone the code and use the code samples in the `chapter2` directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter2)下载本章的代码。克隆代码并使用`chapter2`目录中的代码示例。
- en: Understanding Go's net/http package
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Go的`net/http`包
- en: 'Accepting HTTP requests is the primary goal of a web server. In Go, there is
    a `system-level` package that helps developers create HTTP servers and clients.
    The name of the package is `net/http`. We can understand the functionality of
    the `net/http` package by creating a small example. The example accepts an incoming
    request and returns the timestamp of the server. Let us see the steps for creating
    such a server:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接受HTTP请求是Web服务器的主要目标。在Go中，有一个`系统级`的包帮助开发者创建HTTP服务器和客户端。该包的名称是`net/http`。我们可以通过创建一个小示例来理解`net/http`包的功能。该示例接受传入的请求并返回服务器的时间戳。让我们看看创建此类服务器的步骤：
- en: 'Create the program file as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建程序文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we have a file where we can develop a server with a Health Check API that
    returns a date/time string.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个文件，我们可以开发一个带有健康检查API的服务器，该API返回日期/时间字符串。
- en: 'Import the `net/http` package and create a function handler called `HealthCheck`.
    The `http.HandleFunc` is a method that takes a route and a function handler as
    its arguments. This function handler has to return an `http.ResponseWriter` object:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`net/http`包并创建一个名为`HealthCheck`的函数处理程序。`http.HandleFunc`是一个方法，它接受一个路由和一个函数处理程序作为其参数。这个函数处理程序必须返回一个`http.ResponseWriter`对象：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code creates a `HealthCheck` function and attaches it to an HTTP
    route. `HandleFunc` is used to attach a route pattern to a handler function. `ListenAndServe` starts
    a new HTTP server. It returns an error if the server launch is unsuccessful. It
    takes `address:port` as the first argument and the second argument is `nil`, which
    says use the default multiplexer. We will see multiplexers in detail in the upcoming
    sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码创建了一个`HealthCheck`函数并将其附加到一个HTTP路由上。`HandleFunc`用于将路由模式附加到处理函数。`ListenAndServe`启动一个新的HTTP服务器。如果服务器启动失败，它将返回一个错误。它将`address:port`作为第一个参数，第二个参数是`nil`，表示使用默认的多路复用器。我们将在接下来的章节中详细了解多路复用器。
- en: Use the `log` function to debug potential errors. The `ListenAndServe` function
    returns an error if there is one.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`log`函数来调试潜在的错误。如果存在错误，`ListenAndServe`函数将返回一个错误。
- en: 'Now, we can start the web server using this command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令启动Web服务器：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the `healthCheck.go` file from a shell.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从shell中运行`healthCheck.go`文件。
- en: 'Now, fire up a shell or browser to see the server in action. Here, we use the
    `curl` request:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开一个shell或浏览器来查看服务器运行的情况。在这里，我们使用`curl`请求：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The response is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 响应如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Go has a different concept for handling request and response. We used the `io`
    library to write to the response. For web development, we can use a template to
    automatically fill in the details. Go's internal URL handlers use a ServeMuxmultiplexer.
    In the next section, we will discuss more on ServeMux, a built-in URL router in
    Go.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Go在处理请求和响应方面有一个不同的概念。我们使用了`io`库来写入响应。对于Web开发，我们可以使用模板来自动填充细节。Go的内部URL处理程序使用ServeMux多路复用器。在下一节中，我们将进一步讨论ServeMux，Go内置的URL路由器。
- en: ServeMux – a basic router in Go
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ServeMux – Go中的基本路由器
- en: ServeMux is an HTTP request multiplexer. The `HandleFunc` we used in the preceding
    section is actually a method of ServeMux. By using ServeMux, we can handle multiple
    routes. We can also create our own multiplexer. A multiplexer handles the logic
    of separating routes with a function called `ServeHTTP`. So, if we create a Go
    struct with the `ServeHTTP` method, it can do the job as the in-built multiplexer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ServeMux是一个HTTP请求多路复用器。在前一节中我们使用的`HandleFunc`实际上是ServeMux的一个方法。通过使用ServeMux，我们可以处理多个路由。我们也可以创建自己的多路复用器。多路复用器通过一个名为`ServeHTTP`的函数来处理分离路由的逻辑。因此，如果我们创建一个具有`ServeHTTP`方法的Go结构体，它就可以像内置的多路复用器一样完成工作。
- en: Consider a route as a key in a Go dictionary (map) and a multiplexer as its
    value. Go finds the multiplexer from the route and tries to execute the `ServeHTTP`
    function. In the following section, we will see the usage of ServeMux by creating
    an API that generates UUID strings.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将路由视为Go字典（map）中的键，将多路复用器视为其值。Go从路由中查找多路复用器并尝试执行`ServeHTTP`函数。在下一节中，我们将通过创建一个生成UUID字符串的API来查看ServeMux的使用。
- en: Developing a UUID generation API using ServeMux
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ServeMux开发UUID生成API
- en: 'A UUID is a unique identifier for a resource or a transaction. UUIDs are widely
    used for identifying an HTTP request. Let us develop an API for generating a UUID.
    Please follow these steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: UUID是一个资源或事务的唯一标识符。UUID被广泛用于标识HTTP请求。让我们开发一个生成UUID的API。请按照以下步骤操作：
- en: 'Create the program file as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建程序文件：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any Go struct with a few dedicated HTTP methods is qualified to be a ServeMux.
    For example, we can create a custom `UUID struct` and implement the **`ServeHTTP`** function
    in order to make it a `ServeMux` object. Following is the implementation for the
    `uuidGenerator.go` module:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何具有几个专用HTTP方法的Go结构体都符合成为ServeMux的资格。例如，我们可以创建一个自定义的`UUID`结构体并实现`**ServeHTTP**`函数，使其成为一个ServeMux对象。以下是`uuidGenerator.go`模块的实现：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It consists of the `UUID struct` that acts as a `ServeMux` object. We can access
    the URL path in the handler function and use that information to manually route
    the requests to different response generators.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它由作为ServeMux对象的`UUID`结构体组成。我们可以在处理函数中访问URL路径，并使用这些信息手动将请求路由到不同的响应生成器。
- en: '`giveRandomUUID` is a response generator function that sets a random UUID string
    to response. Go''s `crypto` package has a `Read` function that fills random characters
    into a byte array.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`giveRandomUUID`是一个响应生成函数，它将一个随机的UUID字符串设置到响应中。Go的`crypto`包有一个`Read`函数，可以将随机字符填充到一个字节数组中。'
- en: 'Now add a main function to the module using the `ServeMux` object. We should
    pass our ServeMux to the  `http.ListenAndServe` function to get our content served.
    We are serving our content on port `8000`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向模块中添加一个主函数，使用ServeMux对象。我们应该将我们的ServeMux传递给`http.ListenAndServe`函数以提供我们的内容。我们在端口`8000`上提供服务：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use UUID as a multiplexer in the `ListenAndServe` function, which starts
    an HTTP server. The server executes the `ServeHTTP` method that is defined preceding
    on the `mux` object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ListenAndServe` 函数中，我们使用 UUID 作为多路复用器，该函数启动一个 HTTP 服务器。服务器执行在 `mux` 对象之前定义的
    `ServeHTTP` 方法。
- en: 'Run the following command from your shell/Terminal:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的 shell/Terminal 运行以下命令：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can make a `curl` request like this to make a request to the web server
    that is listening on port `8000`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像这样发送 `curl` 请求来向监听端口 `8000` 的 Web 服务器发送请求：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The response that is returned will be a random string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的响应将是一个随机字符串：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Use *Ctrl* + *C* or *Cmd* + *C* to stop your Go server. If you are running it
    as a background process, use `` sudo kill `sudo lsof -t -i:8000` `` to kill a
    process running on port `8000`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *C* 或 *Cmd* + *C* 来停止您的 Go 服务器。如果您将其作为后台进程运行，请使用 `sudo kill `sudo
    lsof -t -i:8000` ` 来终止在端口 `8000` 上运行的进程。
- en: Until now, we have worked with a single handler. Let us see how we can add multiple
    handlers to route to different function handlers using ServeMux.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用单个处理器。让我们看看如何使用 ServeMux 将多个处理器添加到不同的函数处理器路由中。
- en: Adding multiple handlers using ServeMux
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ServeMux 添加多个处理器
- en: 'Let us say we have an API requirement that generates random numbers of different
    types such as int, float, and so on. The custom **multiplexer** (**mux**) we developed can
    be cumbersome when there are multiple endpoints with different functionalities.
    To add that logic, we need to add multiple `if/else` conditions to manually check
    the URL route. To overcome that complex code structure, we can instantiate a new
    in-built `ServeMux` object and define many handlers. Let''s look at the code with
    `ServeMux`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 API 需求，它生成不同类型的随机数，如 int、float 等。当我们有多个具有不同功能的端点时，我们开发的自定义 **多路复用器**（**mux**）可能会变得繁琐。为了添加该逻辑，我们需要添加多个
    `if/else` 条件来手动检查 URL 路由。为了克服这种复杂的代码结构，我们可以实例化一个新的内置 `ServeMux` 对象并定义许多处理器。让我们看看带有
    `ServeMux` 的代码：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code snippet shows how to create a `ServeMux` and attach multiple handlers
    to it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段展示了如何创建 `ServeMux` 并将其附加到多个处理器。
- en: '`randomFloat` and `randomInt` are the two routes we create for returning a
    random `float` and random `int`, respectively. Now, we pass that to the `ListenAndServe`
    function. `Int(100)` returns a random integer number from the range 0-100.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`randomFloat` 和 `randomInt` 是我们创建的两个路由，分别用于返回随机的 `float` 和随机的 `int`。现在，我们将这些传递给
    `ListenAndServe` 函数。`Int(100)` 返回一个 0-100 范围内的随机整数。'
- en: For more details on random functions, visit the Go random package page at: [http://golang.org](http://golang.org).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于随机函数的详细信息，请访问 Go 随机包页面：[http://golang.org](http://golang.org)。
- en: 'Let us see a complete example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个完整的示例：
- en: 'Create a file to hold our program and call it `multipleHandlers.go` in the
    following path:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件来存放我们的程序，并将其命名为 `multipleHandlers.go`，路径如下：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now create a main function and add the code for creating the `ServeMux` object
    and function handlers.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个主函数，并添加创建 `ServeMux` 对象和函数处理器的代码。
- en: 'Finally, run the server with the `http.ListenAndServe` method:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用 `http.ListenAndServe` 方法运行服务器：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can run the program directly using the `run` command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以直接使用 `run` 命令来运行程序：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let us fire two `curl` commands and see the output:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们执行两个 `curl` 命令并查看输出：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The responses will be:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将包括：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We saw how we can create a URL router with basic Go constructs. Let us have
    a look at a few popular URL routing frameworks that are widely used by the Go
    community for their API servers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用基本的 Go 构造创建 URL 路由器。让我们看看一些在 Go 社区中广泛使用的、用于 API 服务器的流行 URL 路由框架。
- en: Understanding httprouter – a lightweight HTTP router
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 httprouter – 一个轻量级 HTTP 路由器
- en: '`httprouter`**,** as the name suggests, routes the HTTP requests to particular
    handlers. `httprouter` is a well-known package in Go for creating simple routers
    with an elegant API. The developers coming from the Python/Django community are
    very familiar with a full-blown URL dispatcher in the Django framework. `httprouter`
    provides similar features:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`httprouter`，正如其名所示，将 HTTP 请求路由到特定的处理器。`httprouter` 是 Go 中创建具有优雅 API 的简单路由器的知名包。来自
    Python/Django 社区的开发者非常熟悉 Django 框架中的完整 URL 分派器。`httprouter` 提供了类似的功能：'
- en: Allows variables in the route paths
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在路由路径中使用变量
- en: Matches the REST methods (`GET`, `POST`, `PUT`, and so on)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配 REST 方法（`GET`、`POST`、`PUT` 等）
- en: No compromise of performance
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不妥协性能
- en: 'We are going to discuss these qualities in more detail in the following section.
    Before that, there are a few noteworthy points that make `httprouter` an even
    better URL router:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地讨论这些特性。在此之前，有一些值得注意的点使得 `httprouter` 成为一个更好的 URL 路由器：
- en: '`httprouter` plays well with the in-built `http.Handler`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httprouter` 与内置的 `http.Handler` 兼容得很好'
- en: '`httprouter` explicitly says that a request can only match to one route or
    no route'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httprouter` 明确表示一个请求只能匹配到一个路由或没有路由'
- en: The router's design encourages building sensible, hierarchical RESTful APIs
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器的设计鼓励构建合理、分层的 RESTful API
- en: You can build simple and efficient static file servers
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以构建简单高效的静态文件服务器
- en: In the next section, we see the installation of `httprouter` and its basic usage.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到 `httprouter` 的安装及其基本用法。
- en: Installing httprouter
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 httprouter
- en: '`httprouter` is an open source Go package and can be installed using the `go
    get` command. Let us see the installation and basic usage in the steps given as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`httprouter` 是一个开源的 Go 包，可以使用 `go get` 命令安装。让我们看看以下步骤中的安装和基本用法：'
- en: 'Install `httprouter` using this command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 `httprouter`：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can import the library in our source code, like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在源代码中导入这个库，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The basic usage of `httprouter` can be understood through an example.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过示例可以理解 `httprouter` 的基本用法。
- en: 'Let us write a REST service in Go that provides two things:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们用 Go 编写一个 REST 服务，提供以下两个功能：
- en: Gets the Go compiler version
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Go 编译器版本
- en: Gets the content of a given file
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取指定文件的正文
- en: We need to use a system package called `os/exec` to fetch the preceding details.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用一个名为 `os/exec` 的系统包来获取前面的详细信息。
- en: 'The `os/exec` package has a `Command` function, using which we can make any
    system call and the function signature is this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`os/exec` 包有一个 `Command` 函数，我们可以用它来执行任何系统调用，其函数签名如下：'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **`exec.Command`** function takes the command and an additional argument''s
    array. Additional arguments are the options or input for the command. It can then
    be executed by calling the `Output` function, like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`exec.Command`** 函数接收命令和一个额外的参数数组。额外的参数是命令的选项或输入。然后可以通过调用 `Output` 函数来执行它，如下所示：'
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This program uses `httprouter` to create the service. Let us create it at the
    following path:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序使用 `httprouter` 创建服务。让我们在以下路径创建它：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The program''s main function creates two routes and two function handlers.
    The responsibilities of function handlers are:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主函数创建了两个路由和两个函数处理器。函数处理器的职责是：
- en: To get the current Go compiler version
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前 Go 编译器版本
- en: To get the contents of a file
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取文件的正文
- en: 'The program is trying to implement a REST service using `httprouter`**.** We
    are defining two routes here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正在尝试使用 `httprouter` 实现 REST 服务**。** 我们在这里定义了两个路由：
- en: '`/api/v1/go-version`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/v1/go-version`'
- en: '`/api/v1/show-file/:name`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/v1/show-file/:name`'
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`:name` is a path parameter. The basic Go router cannot define these special
    parameters. By using `httprouter`, we can match the REST methods. In the main
    block, we are matching `GET` requests to their respective routes.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`:name` 是一个路径参数。基本的 Go 路由器无法定义这些特殊参数。通过使用 `httprouter`，我们可以匹配 REST 方法。在主块中，我们正在匹配
    `GET` 请求到相应的路由。'
- en: 'Now we are coming to the implementation of three handler functions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向三个处理器函数的实现：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`exec.Command` takes the `bash` command and respective options as its arguments
    and returns an object. That object has an `Output` method that returns the output
    result of command execution. We are utilizing this utility `getCommandOutput` 
    function in both `goVersion` and `getFileContent` handlers. We use shell command
    formats such as `go --version` and `cat file_name` in handlers.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec.Command` 接收 `bash` 命令及其相应选项作为其参数，并返回一个对象。该对象有一个 `Output` 方法，它返回命令执行的结果输出。我们在
    `goVersion` 和 `getFileContent` 处理器中都使用了这个 `getCommandOutput` 函数。我们在处理器中使用如 `go
    --version` 和 `cat file_name` 这样的 shell 命令格式。'
- en: If you observe the code, we used `/usr/local/go/bin/go` as the Go executable
    location because it is the Go compiler location in Mac OS X. While executing `exec.Command`,
    you should give the absolute path of the executable. So, if you are working on
    an Ubuntu machine or Windows, use the path to your installed Go executable. On
    Linux machines, you can easily find that out by using the `$ which go` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果观察代码，我们使用了 `/usr/local/go/bin/go` 作为 Go 可执行文件的位置，因为它是 Mac OS X 中的 Go 编译器位置。在执行
    `exec.Command` 时，你应该给出可执行文件的绝对路径。因此，如果你在 Ubuntu 机器或 Windows 上工作，请使用你安装的 Go 可执行文件的路径。在
    Linux 机器上，你可以通过使用 `$ which go` 命令轻松找到它。
- en: 'Now create two new files in the same directory. These files will be served
    by our file server program. You can create any custom files in this directory
    for testing:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个目录中创建两个新文件。这些文件将由我们的文件服务器程序提供服务。你可以在该目录中创建任何自定义文件进行测试：
- en: '`Latin.txt`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Latin.txt`：'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`Greek.txt`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greek.txt`：'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now run the program with this command. This time, instead of firing a `curl` command,
    let us use the browser as our output for `GET`. Windows users may not have curl
    as the first-hand application. They can use API testing software such as the Postman
    client while developing the REST API. Take a look at the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行程序。这次，我们不再使用`curl`命令，而是使用浏览器作为`GET`请求的输出。Windows用户可能没有curl作为首选应用程序。在开发REST
    API时，他们可以使用Postman客户端等API测试软件。看看以下命令：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output for the first `GET` request looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次`GET`请求的输出如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result will be this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是这样的：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second `GET` request requesting `Greek.txt` is:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个请求`Greek.txt`的`GET`请求是：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we will see the file output in Greek:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到希腊语的文件输出：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Never give the user the power to execute system commands over the REST API.
    In the `exec` example, we made handlers use a `getCommandOutput` helper function
    to execute system commands.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要让用户在REST API上执行系统命令。在`exec`示例中，我们让处理程序使用`getCommandOutput`辅助函数来执行系统命令。
- en: The endpoint `/api/v1/show-file/` we defined in the `exec` example is not so
    efficient. Using `httprouter`, we can build advanced and performance-optimized
    file servers. In the next section, we'll learn how to do that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`exec`示例中定义的端点`/api/v1/show-file/`并不那么高效。使用`httprouter`，我们可以构建高级和性能优化的文件服务器。在下一节中，我们将学习如何做到这一点。
- en: Building a simple static file server in minutes
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几分钟内构建一个简单的静态文件服务器
- en: Sometimes, an API can serve files. The other application of `httprouter`, apart
    from routing, is building an efficient file server. It means that we can build
    a content delivery platform of our own. Some clients need static files from the
    server. Traditionally, we use Apache2 or Nginx for that purpose. If one has to
    create something similar purely in Go, they can leverage `httprouter.`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个API可以提供文件。除了路由之外，`httprouter`的另一个应用是构建高效的文件服务器。这意味着我们可以构建自己的内容交付平台。一些客户端需要从服务器获取静态文件。传统上，我们使用Apache2或Nginx来达到这个目的。如果必须完全使用Go创建类似的东西，他们可以利用`httprouter`。
- en: 'Let us build one. From the Go server, in order to serve the static files, we
    need to route them through a universal route, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来构建一个。从Go服务器开始，为了提供静态文件，我们需要通过一个通用路由来路由它们，如下所示：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The plan is to use `http` package''s `Dir` method to load the filesystem, and
    pass filesystem handler it returns to `httprouter`. We can use the **`ServeFiles` **function
    of the `httprouter` instance to attach a router to the filesystem handler. It
    should serve all the files in the given public directory. Usually, static files
    are kept in the **`/var/public/www` **folderon a Linux machine. Create a folder
    called `static` in your home directory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 计划使用`http`包的`Dir`方法来加载文件系统，并将它返回的文件系统处理程序传递给`httprouter`。我们可以使用`httprouter`实例的`ServeFiles`函数将路由器附加到文件系统处理程序。它应该为给定的公共目录中的所有文件提供服务。通常，静态文件保存在Linux机器上的`/var/public/www`文件夹中。在你的主目录中创建一个名为`static`的文件夹：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, copy the `Latin.txt` and `Greek.txt` files,which we created for the previous
    example, to the preceding static directory. After doing that, let us write the
    program for the file server using the following steps. You will be amazed at the
    simplicity of `httprouter`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将我们为前一个示例创建的`Latin.txt`和`Greek.txt`文件复制到前面的静态目录中。完成此操作后，让我们按照以下步骤编写文件服务器的程序。你会对`httprouter`的简单性感到惊讶：
- en: 'Create a program at the following path:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下路径创建一个程序：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Update the code like the following. You have to add a route that links a static
    file path route to a filesystem handler:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新代码如下。你必须添加一个路由，将静态文件路径路由链接到文件系统处理程序：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now run the server and see the output:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行服务器并查看输出：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open another Terminal and fire this `curl` request:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端并发出以下`curl`请求：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, the output will be a static file content server from our file server:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输出将是一个来自我们的文件服务器的静态文件内容服务器：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the next section, we discuss about a widely used HTTP router called `gorilla/mux`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一个广泛使用的HTTP路由器，称为`gorilla/mux`。
- en: Introducing gorilla/mux – a powerful HTTP router
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍gorilla/mux – 一个强大的HTTP路由器
- en: The word `Mux` stands for the multiplexer. `gorilla/mux` is a multiplexer designed
    to multiplex HTTP routes (URLs) to different handlers. Handlers are the functions
    that can handle the given requests. `gorilla/mux` is a wonderful package for writing
    beautiful routes for our API servers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 `Mux` 代表多路复用器。`gorilla/mux` 是一个设计用于多路复用 HTTP 路由（URL）到不同处理器的多路复用器。处理器是可以处理给定请求的函数。`gorilla/mux`
    是一个编写我们 API 服务器美丽路由的绝佳包。
- en: '`gorilla/mux` provides tons of options to control how routing is done to your
    web application. It allows a lot of features, such as:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux` 提供了大量选项来控制如何对您的 Web 应用程序进行路由。它允许许多功能，例如：'
- en: Path-based matching
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路径的匹配
- en: Query-based matching
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于查询的匹配
- en: Domain-based matching
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于域的匹配
- en: Sub-domain-based matching
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于子域的匹配
- en: Reverse URL generation
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向 URL 生成
- en: Which type of routing to use depends on the types of clients requesting the
    server. We first see the installation and then a basic example to understand the `gorilla/mux`
    package.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用哪种类型的路由取决于请求服务器的客户端类型。我们首先看到安装，然后是一个基本示例，以了解 `gorilla/mux` 包。
- en: Installing gorilla/mux
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 gorilla/mux
- en: 'Follow these steps to install the mux package:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 mux 包：
- en: 'You need to run this command in the Terminal (Mac OS X and Linux):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要在终端（Mac OS X 和 Linux）中运行此命令：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you get any errors saying `package github.com/gorilla/mux: cannot download,
    $GOPATH not set. For more details see--go help gopath`, set the `$GOPATH` environment
    variable using the following command:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果您收到任何错误消息说 `package github.com/gorilla/mux: cannot download, $GOPATH not
    set. For more details see--go help gopath`，请使用以下命令设置 `$GOPATH` 环境变量：'
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we discussed in [Chapter 1](eb93f11e-bb80-40dc-873c-e350560467db.xhtml), *Getting
    Started with REST API Development*, all the packages and programs go into GOPATH.
    It has three folders: `bin`, **`pkg`**, and `src`. Now, add `GOPATH` to the `PATH`
    variable to use the installed bin files as system utilities that have no `./executable`
    style. Refer to the following command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](eb93f11e-bb80-40dc-873c-e350560467db.xhtml)“REST API 开发入门”中讨论的那样，所有包和程序都放入
    GOPATH。它有三个文件夹：`bin`、**`pkg`** 和 `src`。现在，将 `GOPATH` 添加到 `PATH` 变量中，以便将安装的 bin
    文件作为没有 `./executable` 风格的系统实用程序使用。请参考以下命令：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These settings stay until you turn off your machine. So, to make it a permanent
    change, add the preceding line to your `bash/zsh` profile file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些设置将持续到您关闭计算机。因此，要使其成为永久更改，请将前面的行添加到您的 `bash/zsh` 配置文件中：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can import `gorilla/mux` in our programs, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在程序中导入 `gorilla/mux`，如下所示：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we are ready to go. Assuming `gorilla/mux` is installed, we can now explore
    its basics.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备出发。假设 `gorilla/mux` 已安装，我们现在可以探索其基础知识。
- en: Fundamentals of gorilla/mux
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gorilla/mux 的基础
- en: The `gorilla/mux` package primarily helps to create routers, similar to `httprouter`.
    The difference between both is the attachment of a handler function to a given
    URL. If we observe, the `gorilla/mux` way of attaching a handler is similar to
    that of basic ServeMux. Unlike `httprouter`, `gorilla/mux` wraps all the information
    of an HTTP request into a single request object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux` 包主要帮助创建路由器，类似于 `httprouter`。两者之间的区别在于将处理函数附加到给定的 URL 上。如果我们观察，`gorilla/mux`
    附加处理函数的方式类似于基本的 ServeMux。与 `httprouter` 不同，`gorilla/mux` 将 HTTP 请求的所有信息封装到一个单一的请求对象中。'
- en: 'The three important tools provided in the `gorilla/mux` API are:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`gorilla/mux` API 提供的三个重要工具是：'
- en: The `mux.NewRouter` method
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mux.NewRouter` 方法'
- en: The `*http.Request` object
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*http.Request` 对象'
- en: The `*http.ResponseWriter` object
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*http.ResponseWriter` 对象'
- en: 'The `NewRouter` method creates a `new router` object. That object basically
    maps a route to a function handler. `gorilla/mux` passes a modified `*http.Request`
    and `*http.ResponseWriter` object to the function handler. These special objects
    have lots of additional information about headers, path parameters, request body,
    and query parameters. Let us explain how to define and use different routers in
    `gorilla/mux` with two common types:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewRouter` 方法创建一个新的路由器对象。该对象基本上将路由映射到函数处理器。`gorilla/mux` 将修改后的 `*http.Request`
    和 `*http.ResponseWriter` 对象传递给函数处理器。这些特殊对象包含有关头部、路径参数、请求体和查询参数的大量附加信息。让我们解释如何在
    `gorilla/mux` 中定义和使用不同类型的路由器，使用两种常见类型：'
- en: Path-based matching
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路径的匹配
- en: Query-based matching
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于查询的匹配
- en: Path-based matching
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于路径的匹配
- en: 'A path parameter in the URL of an HTTP `GET` request looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP `GET` 请求的 URL 中的路径参数看起来像这样：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Since it is passed after the base URL and API endpoint, in this case `https://example.org/articles/`,
    they are called path parameters. In the preceding URL, `books` and `123` are path
    parameters. Let us see an example of how to create routes that can consume data
    supplied as path parameters. Follow these steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是在基础URL和API端点之后传递的，在这个例子中是`https://example.org/articles/`，因此它们被称为路径参数。在上面的URL中，`books`和`123`是路径参数。让我们看看如何创建可以消费作为路径参数提供的数据的路由的示例。按照以下步骤操作：
- en: 'Create a new file for our program at the following path:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下路径创建我们程序的新的文件：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The idea is to create a new router, `mux.NewRouter`, and use it as a handler
    with in-built `http.Server`. We can attach URL endpoints to handler functions
    on this router object. The URL endpoints attached can also be regular expressions.
    The simple program to collect path parameters from a client HTTP request and return
    back the same looks like this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 策略是创建一个新的路由器，`mux.NewRouter`，并使用内置的`http.Server`作为处理程序。我们可以将URL端点附加到这个路由对象上的处理程序函数。附加的URL端点也可以是正则表达式。一个简单的程序，用于从客户端HTTP请求中收集路径参数并返回相同的内容，如下所示：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now run the server using the following command in a shell:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在shell中使用以下命令运行服务器：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Make a `curl` request from another shell and we can get the output as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个shell中发出`curl`请求，我们可以得到以下输出：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This example shows how to match and parse path parameters. There is one more
    popular way to collect variable information from an HTTP request and that is with
    query parameters. In the next section, we see how to create routes that match
    HTTP requests with query parameters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何匹配和解析路径参数。还有另一种从HTTP请求中收集变量信息的方法，那就是使用查询参数。在下一节中，我们将看到如何创建匹配带有查询参数的HTTP请求的路由。
- en: Query-based matching
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于查询的匹配
- en: 'Query parameters are variables that get passed along with the URL in an HTTP
    request. This is what we commonly see in a REST `GET` request. The `gorilla/mux`
    route can match and collect query parameters. See this following URL, for example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是随HTTP请求一起传递的变量。这是我们通常在REST `GET`请求中看到的内容。"gorilla/mux"路由可以匹配并收集查询参数。以下是一个示例URL：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It has `id` and `category` as query parameters. All query parameters begin after
    the `?` character.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它有`id`和`category`作为查询参数。所有查询参数都开始于`?`字符之后。
- en: 'Let us modify our copy of our previous example into a new one with the name
    `queryParameters/main.go`. Modify the route object to point to a new handler called
    `QueryHandler`, like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们之前的示例的副本修改成一个新的，命名为`queryParameters/main.go`。修改路由对象，使其指向一个新的名为`QueryHandler`的处理程序，如下所示：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `QueryHandler`, we can use `request.URL.Query()` to obtain query parameters
    from the HTTP request. `QueryHandler` looks like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QueryHandler`中，我们可以使用`request.URL.Query()`从HTTP请求中获取查询参数。"QueryHandler"看起来像这样：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This program is similar to the previous example, but processes query parameters
    instead of path parameters.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与之前的示例类似，但处理查询参数而不是路径参数。
- en: 'Run the new program:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新的程序：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Fire a `curl` request in this format in a Terminal:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中按照以下格式发出`curl`请求：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We need to escape special characters in the shell. If it is in the browser,
    there is no problem of escaping. The output looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在shell中转义特殊字符。如果在浏览器中，则没有转义的问题。输出看起来像这样：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The **`r.URL.Query()` **function returns a map with all the parameter and value
    pairs. They are basically strings and, in order to use them in our program logic,
    we need to convert the number strings to integers. We can use Go's `strconv` package
    to convert a string to an integer, and vice versa.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**`r.URL.Query()`**函数返回一个包含所有参数和值对的映射。它们基本上是字符串，为了在程序逻辑中使用它们，我们需要将数字字符串转换为整数。我们可以使用Go的`strconv`包将字符串转换为整数，反之亦然。'
- en: We have used `http.StatusOK` to write a successful HTTP response. Similarly,
    use appropriate status codes for different REST operations. For example, 404 – Not
    found, 500 – Server error, and so on.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`http.StatusOK`来写入成功的HTTP响应。同样，为不同的REST操作使用适当的状态码。例如，404 – 未找到，500 – 服务器错误，等等。
- en: Other notable features of gorilla/mux
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猩猩/mux的其他显著特性
- en: We have seen two basic examples. What next? The `gorilla/mux` package provides
    many handy features that makes an API developer's life easy. It gives a lot of
    flexibility while creating routes. In this section, we try to discuss a few important
    features. The first feature of interest is generating a dynamic URL with the **reverse
    mapping** technique.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两个基本示例。接下来是什么？`gorilla/mux`包提供了许多方便的特性，使得API开发者的生活变得容易。它在创建路由时提供了很多灵活性。在本节中，我们尝试讨论一些重要特性。第一个引人注目的特性是使用**反向映射**技术生成动态URL。
- en: 'In simple words, reverse mapping a URL is getting the complete API route for
    an API resource. Reverse mapping is quite useful when we share links to our web
    application or API. However, in order to create a URL from data, we should associate
    a `Name` with the `gorilla/mux` route. You can name a multiplexer route, like
    this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，反向映射URL是获取API资源的完整API路由。反向映射在分享我们的Web应用程序或API链接时非常有用。然而，为了从数据创建URL，我们应该将一个`Name`与`gorilla/mux`路由关联起来。你可以像这样命名多路复用路由：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, we can get a dynamically generated API route by using the `url` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`url`方法获取动态生成的API路由：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If a route consists of the additional path parameters defined, we should pass
    that data as arguments to the `URL` method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个路由包含定义的附加路径参数，我们应该将那些数据作为参数传递给`URL`方法。
- en: The next important feature of a URL router is **path prefix**. A path prefix
    is a wildcard route for matching all possible paths. It matches all the routes
    to the API server, post a root word. The general use case of path prefixes is
    a static file server. Then, when we serve files from a static folder, the API
    paths should match to filesystem paths to successfully return file content.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: URL路由的下一个重要特性是**路径前缀**。路径前缀是一个通配符路由，用于匹配所有可能的路径。它匹配所有以根词为前缀的API服务器路由。路径前缀的一般用例是静态文件服务器。然后，当我们从静态文件夹中提供文件时，API路径应该与文件系统路径匹配，以成功返回文件内容。
- en: For example, if we define `/static/` as a path prefix, every API route that
    has this root word as a prefix is routed to the handler attached.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们定义`/static/`为路径前缀，那么具有此根词作为前缀的每个API路由都将被路由到附加的处理程序。
- en: 'These paths are matched:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径将被匹配：
- en: '`http://localhost:8000/static/js/jquery.min.js`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/static/js/jquery.min.js`'
- en: '`http://localhost:8000/static/index.html`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/static/index.html`'
- en: '`http://localhost:8000/static/some_file.extension`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8000/static/some_file.extension`'
- en: 'Using gorilla/mux''s `PathPrefix` and `StripPefix` methods, we can write a
    static file server, like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gorilla/mux的`PathPrefix`和`StripPrefix`方法，我们可以编写一个静态文件服务器，如下所示：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The next important feature is **strict slash**. A strict slash activated on
    a `gorilla/mux` router allows a URL to redirect to the same URL with `/` appended
    at the end and vice versa.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要特性是**严格斜杠**。在`gorilla/mux`路由器上激活严格斜杠允许URL重定向到末尾添加了`/`的相同URL，反之亦然。
- en: 'For example, let us say we have an **`/articles/`** route that is attached
    to an `ArticleHandler` handler:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个附加到`ArticleHandler`处理器的`/articles/`路由：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding case, strict slash is set to `true`. The router then redirects
    even `/articles` (without '/' at the end) to the `ArticleHandler`. If it is set
    to `false`, the router treats both `/articles/` and `/articles` as different paths.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个例子中，严格斜杠设置为`true`。然后，路由器会将`/articles`（末尾没有'/'）重定向到`ArticleHandler`。如果设置为`false`，路由器将`/articles/`和`/articles`视为不同的路径。
- en: The next important feature of a URL router is to match encoded path parameters.
    The `gorilla/mux UseEncodedPath` method can be called on a router to match encoded
    path parameters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: URL路由的下一个重要特性是匹配编码的路径参数。可以在路由器上调用`gorilla/mux UseEncodedPath`方法来匹配编码的路径参数。
- en: 'A server can receive encoded paths from a few clients. We can match the encoded
    path parameter, we can even match the encoded URL route and forward it to the
    given handler:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以从几个客户端接收编码路径。我们可以匹配编码的路径参数，甚至可以匹配编码的URL路由并将其转发给指定的处理器：
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This can match the following URL:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以匹配以下URL：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As well as this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Where `%2F2` stands for `/2` in encoded form.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`%2F2`代表编码形式中的`/2`。
- en: Its pattern-matching features and simplicity push `gorilla/mux` as a popular
    choice for an HTTP router in projects. Many successful projects worldwide are
    already using mux for their routing needs.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它的模式匹配特性和简单性使得`gorilla/mux`成为HTTP路由器在项目中的热门选择。全球许多成功的项目已经使用mux来满足他们的路由需求。
- en: We are free to define routes for our application. Since routes are entry points
    to any API, developers should be careful about how they process the data received
    from a client. Clients can be attackers too, who can inject malicious scripts
    into the path or query parameters. That situation is called a **security vulnerability**.
    APIs are prone to a common application vulnerability called SQL injection. In
    the next section, we introduce it briefly and see possible countermeasure steps.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自由地为我们的应用程序定义路由。由于路由是任何 API 的入口点，因此开发者应该小心处理从客户端接收到的数据。客户端也可能是攻击者，他们可以在路径或查询参数中注入恶意脚本。这种情况被称为
    **安全漏洞**。API 容易受到一种常见的应用程序漏洞，即 SQL 注入。在下一节中，我们将简要介绍它并查看可能的对策步骤。
- en: SQL injection in URLs and ways to avoid them
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL 中的 SQL 注入及其避免方法
- en: '**SQL injection** is a process of attacking a database with malicious scripts.
    If one is not careful when defining URL routes, there may be an opportunity for
    SQL injection. These attacks can happen for all kinds of REST operations. For
    example, if we are allowing the client to pass parameters to the server, then
    there is a chance for an attacker to append an ill-formed string to those parameters.
    If we are using those variables/parameters directly into an SQL query executing
    on our database, it could lead to a potential vulnerability.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL注入** 是一种使用恶意脚本攻击数据库的过程。在定义 URL 路由时如果不小心，可能会给 SQL 注入留下机会。这些攻击可能发生在所有类型的
    REST 操作中。例如，如果我们允许客户端向服务器传递参数，那么攻击者就有可能向这些参数中添加格式不正确的字符串。如果我们直接将这些变量/参数用于在数据库上执行的
    SQL 查询，可能会导致潜在的安全漏洞。'
- en: 'Look at the following Go code snippet that inserts `username` and `password`
    details into the database. It collects values from an HTTP `POST` request and
    appends raw values to the SQL query:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下 Go 代码片段，它将 `username` 和 `password` 详细信息插入到数据库中。它从 HTTP `POST` 请求中收集值并将原始值附加到
    SQL 查询中：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the snippet, we are executing a database SQL query, but since we are appending
    the values directly, we may include malicious SQL statements such as `--` comments
    and `ORDER BY n` range clauses in the query:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们正在执行数据库 SQL 查询，但由于我们直接附加了值，我们可能会在查询中包含恶意 SQL 语句，如 `--` 注释和 `ORDER BY
    n` 范围子句：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the application returns the database response directly to the client, it
    can leak information about the columns the table has. An attacker can change the
    `ORDER BY` to another number and extract sensitive information:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序直接将数据库响应返回给客户端，可能会泄露有关表列的信息。攻击者可以将 `ORDER BY` 改为另一个数字并提取敏感信息：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will see more about this in our upcoming chapters where we build fully-fledged
    REST services with other methods, such as `POST`, `PUT`, and so on:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中了解更多关于这一点，其中我们将使用其他方法，如 `POST`、`PUT` 等，构建完整的 REST 服务：
- en: 'Now, how to avoid these injections. There are several precautions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何避免这些注入呢？有几种预防措施：
- en: Set the user level permissions to various tables in the database
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户权限设置为数据库中的各种表
- en: Log the requests and find the suspicious ones
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录请求并找出可疑的请求
- en: Use the **`HTMLEscapeString` **function from Go's **`text/template` **package
    to escape special characters in the API parameters, such as `body` and `path `
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 的 `text/template` 包中的 `HTMLEscapeString` 函数来转义 API 参数中的特殊字符，例如 `body`
    和 `path`
- en: Use a driver program instead of executing raw SQL queries
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用驱动程序程序而不是执行原始 SQL 查询
- en: Stop relaying database debug messages back to the client
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止将数据库调试消息回传给客户端
- en: Use security tools such as `sqlmap` to find out vulnerabilities
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全工具如 `sqlmap` 来发现漏洞
- en: With the basics of routing and security covered, in the next section we present
    an interesting challenge for the reader. It is to create a URL shortening service.
    We provide all the background details briefly in the next section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了路由和安全的基础之后，在下一节中，我们将向读者提出一个有趣的挑战。那就是创建一个 URL 缩短服务。我们将在下一节中简要提供所有背景细节。
- en: Reader's challenge – an API for URL shortening
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者挑战 - URL 缩短 API
- en: With all the basics you have learned up to now, try to implement a URL shortening
    service. A URL shortener takes a very long URL and returns a shortened, crisp,
    and memorable URL back to the user. At first sight, it looks like magic, but it
    is a simple math trick.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了到目前为止的所有基础知识之后，尝试实现一个 URL 缩短服务。URL 缩短器接受一个非常长的 URL，并返回一个简短、清晰且易于记忆的 URL
    给用户。乍一看，这似乎像魔术，但实际上是一个简单的数学技巧。
- en: 'In a single statement, URL shortening services are built upon two things:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个单独的语句中，URL 缩短服务建立在两个东西之上：
- en: A string mapping algorithm to map long strings to short strings (Base 62)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种将长字符串映射到短字符串的字符串映射算法（Base 62）
- en: A simple web server that redirects a short URL to the original URL
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的网络服务器，将短 URL 重定向到原始 URL
- en: 'There are a few obvious advantages of URL shortening:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: URL 缩短有几个明显的优势：
- en: Users can remember the URL; easy to maintain
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以记住 URL；易于维护
- en: Users can use the links where there are restrictions on text length, for example,
    Twitter
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以在文本长度有限的地方使用链接，例如 Twitter
- en: Predictable shortened URL length
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可预测的缩短 URL 长度
- en: 'Take a look at the following diagram:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下图表：
- en: '![](img/d9f22550-1bdc-4284-b716-09cf96dfcc5f.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9f22550-1bdc-4284-b716-09cf96dfcc5f.png)'
- en: 'Under the hood, the following things happen in a URL shortening service:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 缩短服务的底层，以下事情会发生：
- en: Take the original **URL**
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取原始 **URL**
- en: Apply **BASE62** encoding on it; it generates a **Shortened URL**
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其应用 **BASE62** 编码；它生成一个 **缩短的 URL**
- en: 'Store that URL in the database. Map it to the original URL (`[shortened_url:
    original_url]`)'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将该 URL 存储在数据库中。将其映射到原始 URL (`[shortened_url: original_url]`)'
- en: Whenever a request comes to the shortened URL, just do an HTTP redirect to the
    original URL
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当请求到达缩短的 URL 时，只需进行 HTTP 重定向到原始 URL
- en: We will implement a full example in upcoming chapters when we integrate databases
    to our API server, but before that, though, we should specify the API design documentation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 API 服务器中集成数据库时，我们将在接下来的章节中实现一个完整的示例，但在那之前，我们应该指定 API 设计文档。
- en: 'Take a look at the following table:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下表格：
- en: '| **URL** | **REST Verb** | **Action** | **Success** | **Failure** |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **REST 动词** | **操作** | **成功** | **失败** |'
- en: '| `/api/v1/new` | `POST` | `Create a shortened URL` | `200` | `500, 404` |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `/api/v1/new` | `POST` | `创建缩短的 URL` | `200` | `500, 404` |'
- en: '| `/api/v1/:url` | `GET` | `Redirect to original URL` | `301` | `404` |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `/api/v1/:url` | `GET` | `重定向到原始 URL` | `301` | `404` |'
- en: You can use a dummy JSON file/Go map to store the URL for now instead of a database.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用一个虚拟的 JSON 文件/Go 地图来存储 URL，而不是使用数据库。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we first introduced the HTTP router. We tried to create HTTP
    routes using Go's `net/http` package. Then, we briefly discussed ServeMux with
    an example. We saw how to add multiple handler functions to multiple routes. Then,
    we introduced a lightweight router package called `httprouter`, which allows developers
    to create elegant routes, with the option of parsing parameters passed in the
    URL path.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了 HTTP 路由器。我们尝试使用 Go 的 `net/http` 包创建 HTTP 路由。然后，我们通过一个示例简要讨论了 ServeMux。我们看到了如何向多个路由添加多个处理函数。然后，我们介绍了一个名为
    `httprouter` 的轻量级路由包，它允许开发者创建优雅的路由，并可选择解析 URL 路径中传递的参数。
- en: We can also serve files over the HTTP using `httprouter`. We built a small service
    to get the Go version and file contents (read-only). That example can be extended
    to fetch any system information or run a system command.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `httprouter` 通过 HTTP 提供文件。我们构建了一个小型服务来获取 Go 版本和文件内容（只读）。该示例可以扩展为获取任何系统信息或运行系统命令。
- en: Next, we introduced the popular Go routing library, `gorilla/mux`. We discussed
    how it is different from `httprouter` and explored its functionality by implementing
    two examples. We explained how `Vars` can be used to get path parameters and `r.URL.Query` to
    parse query parameters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了流行的 Go 路由库 `gorilla/mux`。我们讨论了它与 `httprouter` 的不同之处，并通过实现两个示例来探索其功能。我们解释了如何使用
    `Vars` 获取路径参数和 `r.URL.Query` 解析查询参数。
- en: As part of securing API routes, we discussed SQL injection and how it can happen
    in our applications. We have also seen the counter measures. By the end of this
    chapter, one can define routes and handler functions to accept HTTP API requests.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为保护 API 路由的一部分，我们讨论了 SQL 注入及其在我们的应用程序中可能发生的方式。我们还看到了对策。在本章结束时，可以定义路由和处理函数以接受
    HTTP API 请求。
- en: In the next chapter, we will look at `Middleware` functions, which act as tamperers
    for HTTP requests and responses. That phenomenon helps us to modify the API response
    on the fly. The next chapter also features **Remote Procedure Call **(**RPC**).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 `Middleware` 函数，这些函数作为 HTTP 请求和响应的篡改者。这种现象帮助我们即时修改 API 响应。下一章还将介绍
    **远程过程调用**（**RPC**）。
