- en: Simplifying RESTful Services with Popular Go Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流行的Go框架简化RESTful服务
- en: In this chapter, we are going to use different frameworks for simplifying the
    process of building REST services. First, we will take a quick look at `go-restful`,
    a REST API creation framework, and then move to a framework called Gin. We will
    build a Metro Rail API in this chapter. The frameworks that we will discuss are
    fully-fledged web frameworks that can also be used to create REST APIs in a short
    time. We will also talk a lot about resources and REST verbs in this chapter.
    We will then try to integrate a small database called SQLite3 with our API. Finally,
    we explore `revel.go` and see how to prototype our REST API with it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用不同的框架来简化构建REST服务的流程。首先，我们将快速浏览`go-restful`，这是一个REST API创建框架，然后转向一个名为Gin的框架。在本章中，我们将构建一个地铁铁路API。我们将讨论的框架是功能齐全的Web框架，也可以在短时间内创建REST
    API。在本章中，我们还将大量讨论资源和REST动词。然后，我们将尝试将一个小型数据库SQLite3与我们的API集成。最后，我们将探索`revel.go`，看看如何用它来原型化我们的REST
    API。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: '`go-restful` – a framework for REST API creation'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go-restful` – 用于创建REST API的框架'
- en: SQLite3 basics and CRUD operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite3基础知识及CRUD操作
- en: Building a Metro Rail API with `go-restful`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`go-restful`构建地铁铁路API
- en: Building a RESTful API with the Gin framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gin框架构建RESTful API
- en: Building a RESTful API with `revel.go`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`revel.go`构建RESTful API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the software that should be pre-installed for running code
    samples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行代码示例之前应该预先安装的软件：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X  >=10.13'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13
- en: 'Software: Docker >= 18 (Docker Desktop for Windows and Mac OS X)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件：Docker >= 18 (Docker Desktop for Windows and Mac OS X)
- en: Go latest version compiler >= 1.13.5
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go最新版本编译器 >= 1.13.5
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4).
    Clone the code and use the code samples in the `chapter4` directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter4)下载本章的代码。克隆代码，并使用`chapter4`目录中的代码示例。
- en: Introducing go-restful – a REST API framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍go-restful – 一个REST API框架
- en: '`go-restful` is a package for building REST-style web services in Go. REST,
    as we discussed in [Chapter 1](eb93f11e-bb80-40dc-873c-e350560467db.xhtml), *Getting
    Started with REST API Development*, asks developers to follow a set of design
    protocols. There we also discussed how the REST verbs are defined and what they
    do to the resources.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-restful`是一个用于在Go中构建REST风格Web服务的包。正如我们在[第1章](eb93f11e-bb80-40dc-873c-e350560467db.xhtml)“开始REST
    API开发”中讨论的，REST要求开发者遵循一系列设计协议。在那里我们也讨论了REST动词是如何定义的以及它们对资源做了什么。'
- en: 'Using `go-restful`, we can separate the logic for API handlers and attach REST
    verbs. The benefit is that it clearly shows what resources are manipulated by
    looking at the code. Before jumping into an example, we have to install a database
    called SQLite3 for our REST API with `go-restful`. The installation steps are
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`go-restful`，我们可以将API处理器的逻辑分离并附加REST动词。好处是，通过查看代码可以清楚地显示哪些资源被操作。在进入示例之前，我们必须为使用`go-restful`的REST
    API安装一个名为SQLite3的数据库。安装步骤如下：
- en: 'First, install the dependencies for the `go-restful` package. On Ubuntu, run
    this command:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装`go-restful`包的依赖项。在Ubuntu上运行以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Mac OS X, you can use the `brew` command to install `sqlite3`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，您可以使用`brew`命令安装`sqlite3`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, install the `go-restful` package with the following `get` command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下`get`命令安装`go-restful`包：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On Windows OS, you can download the SQLite3 executable from [https://www.sqlite.org](https://www.sqlite.org).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统上，您可以从[https://www.sqlite.org](https://www.sqlite.org)下载SQLite3的可执行文件。
- en: 'We are now ready to go. First, let''s write a simple program showing what `go-restful`
    can do in a few lines of code. It provides a `WebService` using which we can attach
    a route to a handler. The use case is to create a simple ping server that echoes
    the server time back to the client. The steps are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备出发。首先，让我们编写一个简单的程序，展示`go-restful`在几行代码中能做什么。它提供了一个`WebService`，我们可以用它来将路由附加到处理器。用例是创建一个简单的ping服务器，将服务器时间回显给客户端。步骤如下：
- en: 'Let''s create a `basicExample.go` program:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`basicExample.go`程序：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, create a function that writes  the server time to the response. It takes
    `Request` and `Response` objects:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个函数，将服务器时间写入响应。它接受 `Request` 和 `Response` 对象：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `pingTime` handler is straightforward and simply writes a server time to
    the response.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`pingTime` 处理器很简单，只是将服务器时间写入响应。'
- en: 'We have to create an instance of `restful.WebService` to attach a given route
    to a verb and a handler. See how we can do it in the following `main` block:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须创建一个 `restful.WebService` 实例，以便将给定的路由附加到一个动词和一个处理器上。以下是如何在 `main` 块中实现它的示例：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, run the program:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The server will be running on port `8000` of localhost. So, we can either make
    a `curl` request or use a browser to see the `GET` request output:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器将在本地主机的 `8000` 端口上运行。因此，我们可以通过发送 `curl` 请求或使用浏览器来查看 `GET` 请求的输出：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding program, we imported the `go-restful` library and created a
    new service using an instance of the `restful.WebService` struct.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们导入了 `go-restful` 库，并使用 `restful.WebService` 结构体实例创建了一个新的服务。
- en: 'Next, we will create a REST verb using the following statement:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用以下语句创建一个 REST 动词：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then attach a function handler to execute this verb; `pingTime` is one such
    function. These chained functions are passed to a `Route` function to create a
    router. Then comes the following important statement:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将一个函数处理器附加到执行此动词；`pingTime` 就是一个这样的函数。这些链式函数被传递给 `Route` 函数以创建路由器。接下来是以下重要语句：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This registers the newly created `webservice` with `go-restful`. If you observe,
    we are not passing any `ServeMux` objects to the `http.ListenServe` function;
    `go-restful` will take care of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把新创建的 `webservice` 注册到 `go-restful` 中。如果你观察的话，我们没有向 `http.ListenServe` 函数传递任何
    `ServeMux` 对象；`go-restful` 会处理它。
- en: The main concept here is to use the resource-based REST API creation in `go-restful`.
    Going from the basic example, let's build something practical.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要概念是使用基于资源的 REST API 创建 `go-restful`。从基本示例开始，让我们构建一些实用的东西。
- en: Take a scenario where your city is getting a new Metro Rail project and you
    have to develop a REST API for other developers to create apps around it. We will
    create one such API in this chapter and use various frameworks to show the implementation.
    Before that, for **Create**, **Read**, **Update**, **Delete** (**CRUD**) operations,
    we should know how to query or insert data into a database with Go code. We pick
    the simplest one called SQLite3 and discuss it in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的城市正在实施一个新的地铁铁路项目，你必须为其他开发者开发一个围绕它创建应用的 REST API。我们将在本章中创建这样一个 API，并使用各种框架来展示实现。在此之前，对于
    **创建**、**读取**、**更新**、**删除**（**CRUD**）操作，我们应该知道如何使用 Go 代码查询或插入数据库中的数据。我们选择最简单的一个，称为
    SQLite3，并在下一节中讨论它。
- en: SQLite3 basics and CRUD operations
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite3 基本和 CRUD 操作
- en: '**SQLite3** is a lightweight, file-based SQL database. It is very useful to
    quickly build persistence for API. It leverages the SQL language and a relational
    database. In this section, we see how to interact with SQLite3 from Go.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQLite3** 是一种轻量级的基于文件的 SQL 数据库。它对于快速构建 API 的持久性非常有用。它利用 SQL 语言和关系数据库。在本节中，我们将了解如何从
    Go 语言中与 SQLite3 交互。'
- en: 'All SQLite3 operations are going to be done using the `go-sqlite3` library.
    We can install that package using the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 SQLite3 操作都将使用 `go-sqlite3` 库来完成。我们可以使用以下命令安装该包：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The special thing about this library is that it uses the internal `sql` package
    of Go. We usually import `database/sql` and use SQL to execute database queries
    on the database (here, SQLite3):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的特殊之处在于它使用了 Go 的内部 `sql` 包。我们通常导入 `database/sql` 并使用 SQL 在数据库（此处为 SQLite3）上执行数据库查询：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can use the following steps to create a database driver and then execute
    the SQL commands on it using the `Query` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下步骤来创建一个数据库驱动程序，然后使用 `Query` 方法在它上面执行 SQL 命令：
- en: 'Let''s create a file in this path:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在该路径下创建一个文件：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s define the main block that creates a table if none exists and calls
    another function for CRUD operations:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个主块，如果不存在则创建一个表，并调用另一个函数进行 CRUD 操作：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are creating a database called `books.db` and execute a SQL statement for
    creating a `books` table. We created a SQL statement with the `db.Prepare` method.
    Then we executed it using the statement's `Exec` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个名为 `books.db` 的数据库，并使用 `db.Prepare` 方法创建一个 `books` 表的 SQL 语句。然后我们使用语句的
    `Exec` 方法执行它。
- en: 'If you notice, we called the `dbOperations` function for performing CRUD operations.
    In that function, we create a book, read it, then update, and then delete it.
    Let''s see the implementation:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你注意到，我们调用了`dbOperations`函数来执行CRUD操作。在那个函数中，我们创建了一个书籍，读取它，然后更新，最后删除它。让我们看看实现：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to the `Prepare` function, now we have another `Query` method. This
    is mainly used for reading data from a database. `Exec` is a common function for
    executing a prepared/queried statement on SQLite.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Prepare`函数外，现在我们还有一个`Query`方法。这主要用于从数据库中读取数据。`Exec`是在SQLite上执行准备/查询语句的常见函数。
- en: A Prepare statement is for performing actions on a database that causes a change
    in the database, and Query is for read-only.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 准备语句用于在数据库上执行导致数据库变化的操作，而查询用于只读操作。
- en: 'Let''s run the `sqliteFunamentals` program:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行`sqliteFunamentals`程序：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output looks like the following, printing all the log statements:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如下，打印所有日志语句：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is an important thing related to security while running queries. Take
    a statement from the preceding code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行查询时，有一个与安全相关的重要事项。从前面的代码中取一个语句：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you pass incorrect values, such as strings that cause SQL injection, the
    driver rejects the SQL operation instantly. This is to avoid any raw strings being
    executed by the database engine. It could be dangerous as SQL can do anything,
    even dropping a database. Always prepare the statement first and then pass the
    necessary details.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递了错误的数据，例如可能导致SQL注入的字符串，驱动程序会立即拒绝SQL操作。这是为了避免任何原始字符串被数据库引擎执行。这可能是危险的，因为SQL可以做任何事情，甚至删除数据库。始终先准备语句，然后传递必要的详细信息。
- en: In the next section, we try to build an example API with `go-restful` and SQLite3.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们尝试使用`go-restful`和SQLite3构建一个示例API。
- en: Building a Metro Rail API with go-restful
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用go-restful构建地铁铁路API
- en: 'Let''s use the knowledge of `go-restful` and SQLite3 we have gained and create
    an API for the Metro Rail project we talked about in the preceding section. The
    road map is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们获得的`go-restful`和SQLite3的知识，为我们在上一节中讨论的地铁铁路项目创建一个API。路线图如下：
- en: Design a REST API document
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计REST API文档
- en: Create models for a database
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数据库创建模型
- en: Implement the API logic
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现API逻辑
- en: Let's understand each of them in detail.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解每个部分。
- en: Design specification
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计规范
- en: 'Before creating any API, we should know what the specifications of APIs are
    in the form of a document. We showed an example in [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml),
    *Handling Routing for our REST Services*, where we showed the URL shortener API
    design document. Let''s try to create one for this Metro Rail project. Take a
    look at the following table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何API之前，我们应该知道API的规范，以文档的形式呈现。我们在[第2章](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)，*处理我们的REST服务路由*中展示了示例，其中我们展示了URL缩短器API设计文档。让我们尝试为这个地铁铁路项目创建一个。看看下面的表格：
- en: '| **HTTP verb** | **Path** | **Action** | **Resource** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **路径** | **操作** | **资源** |'
- en: '| `POST` | `/v1/train (details as JSON body)` | `Create` | `Train` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/v1/train (details as JSON body)` | `Create` | `Train` |'
- en: '| `POST` | `/v1/station (details as JSON body)` | `Create` | `Station` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/v1/station (details as JSON body)` | `Create` | `Station` |'
- en: '| `GET` | `/v1/train/id ` | `Read` | `Train` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/v1/train/id` | `Read` | `Train` |'
- en: '| `GET` | `/v1/station/id` | `Read` | `Station` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/v1/station/id` | `Read` | `Station` |'
- en: '| `POST` | `/v1/schedule (source and destination)` | `Create` | `Route` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/v1/schedule (source and destination)` | `Create` | `Route` |'
- en: We can also include the `UPDATE` and `DELETE` methods. By implementing the preceding
    design, it will be obvious for users to implement them on their own.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以包括`UPDATE`和`DELETE`方法。通过实现前面的设计，用户将很容易自己实现它们。
- en: Creating database models
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库模型
- en: Let's write a few SQL strings for creating the tables for the preceding `train`,
    `station`, and `route` resources. We are going to create a project layout for
    this API. Create two directories called `railAPI` and `dbutils` in `$GOPATH/src/github.com/git-user/chapter4`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为前面提到的`train`、`station`和`route`资源编写一些SQL字符串以创建表。我们将为这个API创建一个项目布局。在`$GOPATH/src/github.com/git-user/chapter4`中创建两个名为`railAPI`和`dbutils`的目录。
- en: 'Here, `railAPI` is our project source, and `dbutils` is our own package for
    handling database initialization utility functions. Follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`railAPI`是我们项目的源代码，而`dbutils`是我们自己用于处理数据库初始化实用函数的包。按照以下步骤操作：
- en: 'Let''s start with the `dbutils/models.go` file. Add three models each for `train`,
    `station`, and `schedule` in the `models.go` file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从 `dbutils/models.go` 文件开始。在 `models.go` 文件中为 `train`、`station` 和 `schedule`
    每个添加三个模型：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These are plain multi-line strings that are delimited by the back tick `` `
    `` character. `schedule` holds the information of a train arriving at a particular
    station at a given time. Here, `train` and `station` are foreign keys to the `schedule`
    table. For `train`, the details related to it are columns. The package name is
    `dbutils`. When we use the package names, all the Go programs in that package
    can share variables and functions without an explicit import.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是普通的由反引号 `` ` `` 定界的多行字符串。`schedule` 保存了火车在特定时间到达特定站点的信息。在这里，`train` 和 `station`
    是 `schedule` 表的外键。对于 `train`，与之相关的细节是列。包名为 `dbutils`。当我们使用包名时，该包中的所有 Go 程序都可以在不进行显式导入的情况下共享变量和函数。
- en: 'Now, let''s add code to initialize the (create tables) database in the `init-tables.go`
    file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `init-tables.go` 文件中添加初始化（创建表）数据库的代码：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are importing `database/sql` to pass the type of argument in the function.
    All other statements in the function are similar to the SQLite3 example we gave
    in the preceding section. It is creating three tables in the SQLite3 database.
    Our main program should pass the database driver to this function. If you observe
    here, we are not importing `train`, `station`, and `schedule`. However, since
    this file is in the `dbutils` package, variables in `models.go` are accessible
    here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `database/sql` 以传递函数中的参数类型。函数中的所有其他语句都与我们在前一小节中给出的 SQLite3 示例类似。它是在 SQLite3
    数据库中创建三个表。我们的主程序应该将数据库驱动程序传递给此函数。如果你注意到这里，我们没有导入 `train`、`station` 和 `schedule`。然而，由于此文件位于
    `dbutils` 包中，`models.go` 中的变量在这里是可访问的。
- en: 'Now, our initial package is finished. Build the object code for this package
    using the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的初始包已经完成。使用以下命令为该包构建对象代码：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is not useful until we create and run our main program. So, let''s write
    a simple main program that imports the `Initialize` function from the `dbutils`
    package. Let''s call the `main.go` file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直到我们创建并运行主程序之前，这都没有什么用处。所以，让我们编写一个简单的主程序，从 `dbutils` 包中导入 `Initialize` 函数。让我们称这个文件为
    `main.go`：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, in the main function, let''s import the `dbutils` package and initialize
    the tables:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主函数中，让我们导入 `dbutils` 包并初始化表：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the program from the `railAPI` directory using the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从 `railAPI` 目录运行程序：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output should be something like the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous `railAPI` example, we delegated the table creation task to the `Initialize`
    function in the `dbutils` package. We can do that straight away in our main program,
    but it is good practice to decompose the logic into multiple packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 `railAPI` 示例中，我们将创建表的任务委托给了 `dbutils` 包中的 `Initialize` 函数。我们可以在主程序中直接这样做，但将逻辑分解到多个包中是一种良好的实践。
- en: The `railapi.db` file from the preceding directory tree screenshot gets created
    once we run our main program. SQLite3 will take care of creating the database
    file if it doesn't exist. SQLite3 databases are simple files. You can enter into
    the SQLite shell using the `$ sqlite3 file_name` command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个目录树截图中的 `railapi.db` 文件会在我们运行主程序时创建。如果不存在，SQLite3 将负责创建数据库文件。SQLite3 数据库是简单的文件。你可以使用
    `$ sqlite3 file_name` 命令进入 SQLite shell。
- en: 'Let''s extend the main program from `railAPI`. Our goal is to create an API
    that was mentioned in the *Design specification* section. We will go step by step
    and understand how to build REST services using `go-restful` and SQLite3 in this
    example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 `railAPI` 的主程序。我们的目标是创建在 *设计规范* 部分提到的 API。我们将一步一步地了解如何使用本例中的 `go-restful`
    和 SQLite3 构建 REST 服务：
- en: 'First, add the necessary imports to the program:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，向程序中添加必要的导入：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We need two external packages, `go-restful` and `go-sqlite3`, for building the
    API logic. The first one is for handlers and the second package is for adding
    storage. `dbutils` stays as it is from the `railAPI` example. The `time` and `net/http`
    packages are for general purpose tasks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个外部包，`go-restful` 和 `go-sqlite3`，来构建 API 逻辑。第一个用于处理程序，第二个包用于添加存储。`dbutils`
    在 `railAPI` 示例中保持不变。`time` 和 `net/http` 包用于通用任务。
- en: 'Even though concrete names are given to the columns in the SQLite database''s
    tables, in Go programming, we need a few struct types to handle data going in
    and out of the database. Take a look at the following code snippet that defines
    necessary structs to hold data:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管SQLite数据库表中的列有具体的名称，但在Go编程中，我们需要几个结构体类型来处理数据库的输入和输出数据。请看以下代码片段，它定义了必要的结构体来存储数据：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `DB` variable is allocated to hold the global database driver. All the preceding
    structs are exact representations of the database models in SQL. Go's `time.Time`
    struct type can actually hold the `Time` field from the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB`变量被分配来存储全局数据库驱动程序。所有前面的结构体都是SQL数据库模型的确切表示。Go的`time.Time`结构类型实际上可以存储数据库中的`Time`字段。'
- en: 'Now comes the actual `go-restful` implementation. We need to create a container
    for our API in `go-restful`. Then, we should register the web services to that
    container. What we have to do now is pick a resource and define a `Register` method
    on it. In our case, say `TrainResource` struct is a resource. The method argument
    will be a `go-restful` container where we can attach a service to a namespace,
    as shown in the following code snippet:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是实际的`go-restful`实现。我们需要在`go-restful`中为我们的API创建一个容器。然后，我们应该将网络服务注册到该容器中。我们现在需要做的是选择一个资源，并在其上定义一个`Register`方法。在我们的例子中，假设`TrainResource`结构体是一个资源。方法参数将是一个`go-restful`容器，我们可以将其附加到一个命名空间，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We first created a service, then added path and routes to the resource. Finally,
    we attached the service to the container. A path is the URL endpoint, and routes
    are the path parameters or query parameters attached to the function handlers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个服务，然后为资源添加了路径和路由。最后，我们将服务附加到容器中。路径是URL端点，路由是附加到函数处理器的路径参数或查询参数。
- en: We attached three REST methods, namely `GET`, `POST`, and `DELETE` to three
    function handlers, `getTrain`, `createTrain`, and `removeTrain`, respectively.
    We haven't implemented those handlers yet, but we will soon.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将三个REST方法，即`GET`、`POST`和`DELETE`分别附加到三个函数处理器`getTrain`、`createTrain`和`removeTrain`。我们尚未实现这些处理器，但很快就会。
- en: 'If you look at this special statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看这个特殊的语句：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It tells us that our API will only entertain Content-Type as application/JSON
    in the request. For all other types, it automatically returns a `415--Media Not
    Supported` error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉我们我们的API将只接受请求中的Content-Type为application/JSON。对于所有其他类型，它将自动返回一个`415--Media
    Not Supported`错误。
- en: The returned response is automatically converted to a pretty JSON. We can also
    have a list of formats such as XML, JSON, and so on. `go-restful` provides this
    feature out of the box.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的响应将自动转换为漂亮的JSON。我们还可以有XML、JSON等多种格式。`go-restful`提供了这个功能。
- en: 'Now, let''s define the function handlers. The `getTrain` handler takes an HTTP
    request and accesses the `path` parameter, then creates a `DB` query statement
    to fetch the row from the database. `WriteEntity` is used to write a struct as
    JSON to a response:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义函数处理器。`getTrain`处理器接收一个HTTP请求，访问`path`参数，然后创建一个`DB`查询语句从数据库中检索行。`WriteEntity`用于将结构体作为JSON写入响应：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now comes the `POST` handler, `createTrain`. It is similar to `GET`, but instead
    of fetching information from path parameters, it decodes the body of the incoming
    request. Then it prepares a database query statement to insert body data. It returns
    the `ID` of the inserted record in response with the `201-created` status:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是`POST`处理程序，`createTrain`。它与`GET`类似，但不是从路径参数中获取信息，而是解码传入请求的正文。然后它准备一个数据库查询语句来插入正文数据。它以`201-created`状态响应返回插入记录的`ID`：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `DELETE` function is quite obvious if you understand the previous two handlers.
    We are making a `DELETE` SQL command using `DB.Prepare` and returning a `201`
    Status created back, telling us the delete operation was successful. Otherwise,
    we are sending back the actual error as a server error:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你理解了前面的两个处理器，`DELETE`函数就非常明显了。我们使用`DB.Prepare`创建了一个`DELETE` SQL命令，并返回一个`201`状态创建，告诉我们删除操作成功。否则，我们将实际错误作为服务器错误发送回来：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let''s write the main function handler, which is an entry point for our
    program. It creates a `go-restful` container and registers `TrainResource`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写主函数处理器，它是我们程序的入口点。它创建一个`go-restful`容器并注册`TrainResource`：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first few lines are performing the database-related housekeeping. Then,
    we are creating a new container using `restful.NewContainer`. The `go-restful`
    package provides a router called `CurlyRouter` (which allows us to use {train_id}
    syntax in paths while setting routes) for our container, and there are other types
    too. We have chosen that router for incoming HTTP requests. Then, we created an
    instance of the `TrainResource` struct and passed this container to the `Register`
    method. That container can act as a wrapped HTTP handler, so we can directly pass
    it to `http.Server` easily.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行是执行数据库相关的维护工作。然后，我们使用`restful.NewContainer`创建一个新的容器。`go-restful`包提供了一个名为`CurlyRouter`的路由器（它允许我们在设置路由时使用{train_id}语法），为我们的容器提供路由，还有其他类型。我们选择了这个路由器来处理传入的HTTP请求。然后，我们创建了一个`TrainResource`结构体的实例，并将其传递给`Register`方法。这个容器可以作为包装的HTTP处理器，因此我们可以轻松地将其传递给`http.Server`。
- en: Use `request.QueryParameter` to fetch the query parameters from an HTTP request
    in the `go-restful` handler.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`request.QueryParameter`在`go-restful`处理器中从HTTP请求中获取查询参数。
- en: 'Let''s run the program:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行程序：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, make a `curl` `POST` request to create a train:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，发送一个`curl` `POST`请求来创建一个火车：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This creates a new train with the driver and operation status details. The
    response is the newly created resource with the train `ID` allocated:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的火车，包括驾驶员和操作状态详情。响应是新创建的资源，其中包含了分配的火车`ID`：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s make a `curl` request to check `GET`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们发送一个`curl`请求来检查`GET`：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will see the JSON output, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下JSON输出：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use the same names for both posting data and JSON returned, but in order
    to show the difference between two operations, different variable names are used.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为发布数据和返回的JSON使用相同的名称，但为了显示两个操作之间的区别，使用了不同的变量名称。
- en: 'Now, delete the resource we created in the preceding code snippet with the `DELETE`
    API call:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`DELETE` API调用删除前面代码片段中创建的资源：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It won't return any response body; it returns Status `200 OK` if the operation
    was successful.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会返回任何响应体；如果操作成功，则返回状态`200 OK`。
- en: 'Now, if we try to do `GET` on the `ID 1` train, then it returns us this response:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试对`ID 1`的火车进行`GET`操作，那么它将返回以下响应：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To support more API operations such as `PUT` and `PATCH`, we need to add two
    more routes to the web service in the `Register` method and define respective
    handlers. Here, we created a web service for `TrainResource`. In a similar way,
    web services can be created for doing CRUD operations on the `Station` and `Schedule`
    tables. That task is left as an exercise for the readers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持更多API操作，例如`PUT`和`PATCH`，我们需要在`Register`方法中添加两个额外的路由到web服务，并定义相应的处理器。在这里，我们为`TrainResource`创建了一个web服务。以类似的方式，可以为对`Station`和`Schedule`表进行CRUD操作创建web服务。这项任务留给读者作为练习。
- en: '`go-restful` is a lightweight library that is powerful in creating RESTful
    services in an elegant way. The main theme is to convert resources (models) into
    consumable APIs. Using other heavy frameworks may speed up the development, but
    the API can end up slower because of the wrapping of code. `go-restful` is a lean
    and low-level package for API creation.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-restful`是一个轻量级的库，以优雅的方式创建RESTful服务非常强大。主要主题是将资源（模型）转换为可消费的API。使用其他重型框架可能会加快开发速度，但API可能会因为代码的包装而变得较慢。`go-restful`是一个精简的底层包，用于API创建。'
- en: '`go-restful` also provides built-in support for documenting the REST API with
    swagger. It is a tool that runs and generates templates for documenting the REST
    API we build. By integrating it with our `go-restful`-based web services, we can
    generate documentation on the fly. For more information, visit [https://github.com/emicklei/go-restful-swagger12](https://github.com/emicklei/go-restful-swagger12).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`go-restful`还提供了对使用swagger记录REST API的内置支持。它是一个运行并生成我们构建的REST API文档模板的工具。通过将其与基于`go-restful`的web服务集成，我们可以即时生成文档。更多信息，请访问[https://github.com/emicklei/go-restful-swagger12](https://github.com/emicklei/go-restful-swagger12)。'
- en: Building RESTful API with the Gin framework
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gin框架构建RESTful API
- en: Gin-Gonic is a framework based on `httprouter`. We learned about `httprouter`
    in [Chapter 2](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml), *Handling Routing
    for our REST Services*. It is an HTTP multiplexer like `gorilla/mux`, but it is
    faster. Gin allows a high-level API to create REST services in a clean way.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Gin-Gonic是一个基于`httprouter`的框架。我们在[第2章](72226cd9-cd86-497f-ba6c-4a273e0e3193.xhtml)，*为我们的REST服务处理路由*中学习了`httprouter`。它是一个类似于`gorilla/mux`的HTTP多路复用器，但速度更快。Gin允许以干净的方式创建REST服务的高级API。
- en: Gin can be compared to another web framework in Go called Martini. All web frameworks
    allow us to do a lot more things such as templates and web server design, in addition
    to service creation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Gin 可以与 Go 中另一个名为 Martini 的 Web 框架进行比较。所有 Web 框架都允许我们做更多的事情，例如模板和 Web 服务器设计，以及除了服务创建之外的事情。
- en: 'One can install the Gin package using the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令安装 Gin 包：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s write a simple hello world program in Gin to get familiarized with the Gin
    constructs:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Gin 中编写一个简单的 hello world 程序，以熟悉 Gin 构造：
- en: 'First, create a file that holds our program:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个包含我们程序的文件：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Gin provides a `Default` method to create HTTP route/verb/handler combinations.
    It also provides a context object inside the handler function to easily operate
    on HTTP request and response. See an API created with Gin to request `serverTime UTC`
    here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gin 提供了一个 `Default` 方法来创建 HTTP 路由/动词/处理程序组合。它还在处理程序函数内部提供了一个上下文对象，以便轻松操作 HTTP
    请求和响应。请看这里使用 Gin 创建的请求 `serverTime UTC` 的 API：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This simple server tries to implement a service that serves UTC server time
    to the clients. If you look carefully, Gin allows you to do a lot of stuff with
    just a few lines of code; all the boilerplate details such as route are taken
    away.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的服务器试图实现一个服务，该服务向客户端提供 UTC 服务器时间。如果你仔细观察，Gin 允许你仅用几行代码就做很多事情；所有样板细节，如路由，都被移除了。
- en: Coming to the program, we are creating a router with the `gin.Default` function.
    Then, we are attaching routes with REST verbs as we did in `go-restful`; a route
    to the function handler. Then, we are calling the `Run` function by passing the
    port to run. The default port will be `8080`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 来到程序，我们使用 `gin.Default` 函数创建一个路由器。然后，我们像在 `go-restful` 中那样使用 REST 动词附加路由到函数处理程序。然后，我们通过传递要运行的端口来调用
    `Run` 函数。默认端口将是 `8080`。
- en: '`c` is a context variable that holds the information about the individual request.
    We can serialize data into JSON before sending it back to the client using the `context.JSON`
    function.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`c` 是一个上下文变量，它包含有关单个请求的信息。我们可以使用 `context.JSON` 函数在发送回客户端之前将数据序列化为 JSON。'
- en: 'Now, if we run the `ginBasic` program:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行 `ginBasic` 程序：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Make a `curl` request to see the response:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个 `curl` 请求以查看响应：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'At the same time, the Gin server console captures beautiful logs about HTTP
    requests to the server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Gin 服务器控制台捕获了关于服务器 HTTP 请求的美丽日志：
- en: '![](img/d90432a3-1fea-4d86-849e-0f5ad50b9d0d.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d90432a3-1fea-4d86-849e-0f5ad50b9d0d.png)'
- en: It is an Apache-style log showing `<the endpoint, the latency of the request,
    and the REST method>`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Apache 风格的日志，显示了 `<端点，请求的延迟和 REST 方法>`。
- en: In order to run Gin in production mode, set the `GIN_MODE=release` environment
    variable. Then the console output will be muted and log files can be used for
    monitoring the logs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在生产模式下运行 Gin，设置 `GIN_MODE=release` 环境变量。然后控制台输出将被静音，日志文件可用于监控日志。
- en: 'Now, let''s write our Metro Rail API in Gin to show how to implement exactly
    the same API, but with a different framework. We use the same project layout,
    name the new project `railAPIGin`, and use the `dbutils` as it is. Let''s look
    at the steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 Gin 编写我们的地铁铁路 API，以展示如何使用不同的框架实现完全相同的 API。我们使用相同的工程布局，将新项目命名为 `railAPIGin`，并直接使用
    `dbutils`。让我们看看步骤：
- en: 'First, let''s prepare the imports for our program:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的程序准备导入：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We imported `sqlite3` and `dbutils` for database-related actions. We imported
    `gin` for creating our API server. `net/http` is useful in providing the intuitive
    status codes to be sent along with the response.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了 `sqlite3` 和 `dbutils` 以进行数据库相关操作。我们导入了 `gin` 以创建我们的 API 服务器。`net/http`
    在提供与响应一起发送的直观状态码方面很有用。
- en: 'let''s define a struct to represent a station in program memory and a database
    driver:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个结构体来表示程序内存中的一个站点和数据库驱动程序：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`StationResource` is the placeholder for two kinds of data. First, for the POST
    body coming from an HTTP request, and second for data queried from the database.
    This is why it is slightly modified from the `railAPI` example of `go-restful`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`StationResource` 是两种数据的占位符。首先，对于来自 HTTP 请求的 POST 主体，其次对于从数据库查询的数据。这就是为什么它与
    `go-restful` 的 `railAPI` 示例略有不同。'
- en: Now, let's write the handlers implementing the `GET`, `POST`, and `DELETE` methods
    for the station resource. We define CRUD handlers similar to the previous Metro
    Rail API `go-restful` example.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写处理程序，实现站点资源的 `GET`、`POST` 和 `DELETE` 方法。我们定义了类似于之前地铁铁路 API `go-restful`
    示例的 CRUD 处理程序。
- en: 'The first handler is a `GET` handler. In `GetStation`, we use `c.Param` to
    strip the `station_id` path parameter. We use that value as an ID while querying
    a database record from the SQLite3 station table:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个处理程序是一个`GET`处理程序。在`GetStation`中，我们使用`c.Param`来剥离`station_id`路径参数。我们使用该值作为ID，从SQLite3站点表中查询数据库记录：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you observe carefully, the SQL query is a bit different. We are using the `CAST` method
    to retrieve the `SQL TIME` field as a string for Go to consume properly. If you
    remove the casting, a panic error will be raised because we are trying to load
    a `TIME` field into the Go string at run time. To give you an idea, the TIME field
    looks like `8:00:00`, `17:31:12`, and so on. We are returning back the result
    using the `gin.H` method if there is no error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，SQL查询略有不同。我们正在使用`CAST`方法将`SQL TIME`字段作为字符串检索，以便Go能够正确消费。如果你取消转换，将会引发panic错误，因为我们试图在运行时将`TIME`字段加载到Go字符串中。为了给你一个概念，`TIME`字段看起来像`8:00:00`、`17:31:12`等等。如果没有错误，我们使用`gin.H`方法返回结果。
- en: 'In the `POST` handler, `CreateStation`, we perform a database insertion. We
    need to use the `c.BindJSON` function in Gin to extract data from the request
    body. This function loads the data into the struct that is passed as the argument.
    The idea is to load the station struct with body details. That is why `StationResource`
    has the JSON inference strings to tell what key values are expected. See the function
    body:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POST`处理程序`CreateStation`中，我们执行数据库插入。我们需要使用Gin中的`c.BindJSON`函数从请求体中提取数据。此函数将数据加载到作为参数传递的结构体中。我们的想法是将站点结构体加载到具有体详细信息的结构体中。这就是为什么`StationResource`有JSON推断字符串来告诉预期的键值。请看函数体：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After collecting the data from a `POST` request body, we are preparing a database
    insert statement and executing it. The result is the ID of the inserted record.
    We are using that ID to send station details back to the client.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`POST`请求体收集数据后，我们正在准备数据库插入语句并执行它。结果是插入记录的ID。我们使用该ID将站点详情发送回客户端。
- en: 'In the HTTP `DELETE` function handler `RemoveStation`, we should use a `DELETE`
    SQL query. If the operation is successful, we return a `200 OK` status back. Otherwise,
    we send the appropriate response back with a `500-Internal Server Error`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTTP `DELETE`函数处理程序`RemoveStation`中，我们应该使用`DELETE` SQL查询。如果操作成功，我们返回一个`200
    OK`状态。否则，我们发送带有`500-Internal Server Error`的适当响应：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now comes the main program, which runs the database logic first to make sure
    tables are created. Then, it tries to create a Gin router and adds routes to it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是主程序，它首先运行数据库逻辑以确保创建表。然后，它尝试创建Gin路由器并将其路由添加到其中：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We are registering the `GET`, `POST`, and `DELETE` routes with the Gin router.
    Then, we are passing routes and handlers to them. Finally, we are starting the
    server using the `Run` function of Gin with `8000` as the port. Run the preceding
    program, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Gin路由器注册`GET`、`POST`和`DELETE`路由。然后，我们将路由和处理程序传递给它们。最后，我们使用Gin的`Run`函数以`8000`作为端口启动服务器。按照以下方式运行前面的程序：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can create a new station by performing a `POST` request:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行`POST`请求来创建一个新的站点：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It returns:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now try to fetch the station details using `GET`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用`GET`获取站点详情：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can also delete the station record using the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下命令删除站点记录：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It returns a `200 OK` status, confirming the resource was successfully deleted.
    As we already discussed, Gin provides intuitive debugging on the console, showing
    the attached handler, and highlighting the latency and REST verbs with colors:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个`200 OK`状态，确认资源已被成功删除。正如我们之前讨论的，Gin在控制台提供了直观的调试功能，显示附加的处理程序，并以颜色突出显示延迟和REST动词：
- en: '![](img/8f0de0ec-2bdf-4e27-a642-3ee9e097d129.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f0de0ec-2bdf-4e27-a642-3ee9e097d129.png)'
- en: For example, a 200 is green, a 404 is yellow, DELETE is red, and so on. Gin
    provides many other features such as the categorization of routes, redirects,
    and middleware functions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，200是绿色，404是黄色，DELETE是红色，等等。Gin还提供了许多其他功能，如路由分类、重定向和中间件函数。
- en: Use the Gin framework if you are quickly prototyping a REST web service. You
    can also use it for many other things such as static file serving, and so on.
    Remember that it is a fully-fledged web framework. For fetching the query parameters
    in Gin, use the following method on the Gin context object: `c.Query` (parameter).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要快速原型化RESTful Web服务，请使用Gin框架。你还可以用它来做许多其他事情，如静态文件服务等等。请记住，它是一个完整的Web框架。在Gin中获取查询参数时，请使用Gin上下文对象上的以下方法：`c.Query`（参数）。
- en: Building a RESTful API with revel.go
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用revel.go构建RESTful API
- en: '`revel.go` is also a fully-fledged web framework like Python''s Django. It
    is older than Gin and is termed as a highly productive web framework. It is an
    asynchronous, modular, and stateless framework. Unlike the `go-restful` and Gin
    frameworks where we created the project ourselves, Revel generates a scaffold
    for working directly:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`revel.go` 也是一个完整的网络框架，类似于 Python 的 Django。它比 Gin 更老，被称为高度生产力的网络框架。它是一个异步的、模块化的、无状态的框架。与
    `go-restful` 和 Gin 框架不同，我们在其中自己创建了项目，Revel 生成骨架以直接工作：'
- en: 'Install `revel.go` using the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 `revel.go`：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In order to run the scaffold tool, we should install one more supplementary
    package:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行骨架工具，我们应该安装一个额外的补充包：
- en: '[PRE57]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Make sure that `$GOPATH/bin` is in your PATH variable. Some external packages
    install the binary in the `$GOPATH/bin` directory. If it is in the path, we can
    access the executables system wide. Here, Revel installs a binary called `revel`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `$GOPATH/bin` 添加到您的 PATH 变量中。一些外部包将二进制文件安装到 `$GOPATH/bin` 目录中。如果它在路径中，我们可以全局访问可执行文件。在这里，Revel
    安装了一个名为 `revel` 的二进制文件。
- en: 'On Ubuntu or Mac OS X, you can make sure to point Go binaries to the system
    path using this command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 或 Mac OS X 上，您可以使用以下命令确保将 Go 二进制文件指向系统路径：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Add this export statement to `~/.bashrc` to save the setting permanently. On
    Windows, you have to directly call the executable by its location. Now we are
    ready to go with Revel.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将此导出语句添加到 `~/.bashrc` 以永久保存设置。在 Windows 上，您必须直接通过其位置调用可执行文件。现在我们准备好使用 Revel
    进行操作了。
- en: 'Let''s create a new project called `railAPIRevel` in `github.com/git-user/chapter4`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `github.com/git-user/chapter4` 中创建一个名为 `railAPIRevel` 的新项目：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This creates a project scaffold without writing a single line of code. This
    is how web frameworks abstract things for quick prototyping. A Revel project layout
    tree looks like this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这创建了一个无需编写任何代码的项目骨架。这就是网络框架如何抽象事物以快速原型化的方式。一个 Revel 项目布局树看起来像这样：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Out of all those boilerplate directories, three things are important for creating
    an API. Those are:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些样板目录中，有三个东西对于创建 API 很重要。那些是：
- en: '`app/controllers`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app/controllers`'
- en: '`conf/app.conf`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf/app.conf`'
- en: '`conf/routes`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf/routes`'
- en: Controllers are the logic containers that execute the API logic. The `app.conf`
    file allows us to set the host, port, dev mode/production mode, and so on. `routes`
    defines the triple of the endpoint, REST verb, and function handler (here, controller's
    function). This is required for combining routes, verbs, and function handlers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是执行 API 逻辑的逻辑容器。`app.conf` 文件允许我们设置主机、端口、开发模式/生产模式等。`routes` 定义了端点、REST 动词和函数处理器的三元组（在这里，是控制器的函数）。这是组合路由、动词和函数处理器所必需的。
- en: 'Let''s use the same Rail API example we developed with `go-restful` and Gin.
    However, here, due to the redundancy, we drop the database logic. We will see
    shortly how to build `GET`, `POST`, and `DELETE` actions for the API using Revel:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们与 `go-restful` 和 Gin 一起开发的相同 Rail API 示例。然而，在这里，由于冗余，我们省略了数据库逻辑。我们将很快看到如何使用
    Revel 构建 `GET`、`POST` 和 `DELETE` 操作：
- en: 'Now, modify the routes file to this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改路由文件如下：
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The syntax may look a bit new. It is a configuration file where we simply define
    a route in this format:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可能看起来有点新。这是一个配置文件，我们只需以这种格式定义一个路由：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`VERB` is a REST verb, `END_POINT` is the API endpoint, and `HANDLER` is the
    name of the function that processes requests.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`VERB` 是 REST 动词，`END_POINT` 是 API 端点，`HANDLER` 是处理请求的函数名称。'
- en: We haven't defined handlers yet. In the endpoint, the path parameters are accessed
    using the :param notation. This means for a `GET` request to the server, `train-id`
    will be passed as the path parameter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未定义处理器。在端点中，路径参数使用 `:param` 符号访问。这意味着对于服务器的 `GET` 请求，`train-id` 将作为路径参数传递。
- en: Now, navigate to the `controllers` folder and modify the existing controller
    in the `app.go` file.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到 `controllers` 文件夹并修改 `app.go` 文件中的现有控制器。
- en: 'We first create a `struct` that represents our application context. let''s
    name it `App`. We should also define another struct for `TrainResource` that holds
    rail information:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个表示我们的应用程序上下文的 `struct`，让我们称它为 `App`。我们还应该为 `TrainResource` 定义另一个 `struct`，它包含铁路信息：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now let''s define CRUD handlers in Revel. First is `GetTrain`. Why a capital
    lettered name for a controller? Because Revel expects controllers to be exported
    out of the package. Go packages only export names starting with capital letters.
    The controller accesses the path parameter to get a train ID and uses it to query
    the database. Here we are mocking the database result for brevity:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 Revel 中定义 CRUD 处理器。首先是 `GetTrain`。为什么控制器名称要以大写字母开头？因为 Revel 期望控制器从包中导出。Go
    包只导出以大写字母开头的名称。控制器访问路径参数以获取火车 ID，并使用它来查询数据库。在这里，我们为了简洁起见模拟了数据库结果：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In `CreateTrain`, we add the `POST` request logic. We should create an object
    of `TrainResource` struct and pass it to a function called `c.Params.BindJSON`.
    JSON tags(`` ''json:"id"` ``) gives us the flexibility of defining output fields.
    This is a good practice in Go while working with JSON. Then, we return an HTTP
    response with `201 created` status. We can use the `RenderJSON` method on context
    to marshal a struct to JSON on the fly:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CreateTrain` 中，我们添加了 `POST` 请求逻辑。我们应该创建一个 `TrainResource` 结构体的对象，并将其传递给名为
    `c.Params.BindJSON` 的函数。JSON 标签（`'json:"id"``）为我们提供了定义输出字段的灵活性。在 Go 语言中处理 JSON
    时，这是一个好的实践。然后，我们返回一个带有 `201 created` 状态的 HTTP 响应。我们可以使用上下文上的 `RenderJSON` 方法即时将结构体序列化为
    JSON：
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `RemoveTrain` handler logic is similar to that of `GET`. A subtle difference
    is that nothing is sent in the body. As we previously mentioned, database CRUD
    logic is omitted from the preceding example. It is an exercise for readers to
    try adding SQLite3 logic by observing what we have done in the `go-restful` and
    Gin sections:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RemoveTrain` 处理器逻辑与 `GET` 相似。一个细微的区别是，在体中没有发送任何内容。正如我们之前提到的，数据库 CRUD 逻辑已从前面的示例中省略。这是读者尝试通过观察我们在
    `go-restful` 和 Gin 部分所做的工作来添加 SQLite3 逻辑的练习：'
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, the default port on which the Revel server runs is `9000`. The configuration
    to change the port number is in the `conf/app.conf` file. Let''s follow the tradition
    of running our app on `8000`. So, modify the HTTP port section of `app.conf` to
    the following. This tells the Revel server to run on a different port:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，Revel 服务器运行的默认端口是 `9000`。更改端口号的配置在 `conf/app.conf` 文件中。让我们遵循在 `8000` 上运行我们的应用程序的传统。因此，将
    `app.conf` 中的 HTTP 端口部分修改如下。这告诉 Revel 服务器在不同的端口上运行：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, we can run our Revel API server using this command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行我们的 Revel API 服务器：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Our app server starts at `http://localhost:8000`. Now, let''s make a few API
    requests:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序服务器在 `http://localhost:8000` 上启动。现在，让我们进行一些 API 请求：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`POST` request:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 请求：'
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`DELETE` is the same as `GET`, but no body is returned. Here, the code is illustrated
    to show how to handle the request and response. Remember, Revel is more than a
    simple API framework. It is a fully-fledged web framework similar to Django (Python)
    or Ruby on Rails. We have got templates, tests, and many more bundled in `revel.go`.
    It is mainly used for web development, but one can also use it to quickly develop
    a REST API.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 与 `GET` 相同，但不会返回任何体。在这里，代码展示了如何处理请求和响应。记住，Revel 不仅仅是一个简单的 API 框架。它是一个完整的网络框架，类似于
    Django（Python）或 Ruby on Rails。我们在 `revel.go` 中获得了模板、测试和许多其他功能。它主要用于网络开发，但也可以用它快速开发
    REST API。'
- en: Make sure that you create a new Revel project for `GOPATH/user`, otherwise,
    your Revel command-line tool may not find the project while running the project.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你为 `GOPATH/user` 创建一个新的 Revel 项目，否则你的 Revel 命令行工具在运行项目时可能找不到项目。
- en: There is middleware support in all the web frameworks we saw in this chapter.
    `go-restful` names its middleware Filters, whereas Gin names them Custom Middleware,
    and Revel calls its middleware, Interceptors. A middleware reads or writes the
    request and response before and after a function handler, respectively.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的所有网络框架都支持中间件。`go-restful` 将其中间件命名为 Filters，Gin 命名为 Custom Middleware，而
    Revel 则将其命名为 Interceptors。中间件在函数处理器前后分别读取或写入请求和响应。
- en: In [Chapter 3](ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml), *Working with Middleware
    and RPC*, we have already briefly discussed middleware.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml) *与中间件和 RPC 一起工作* 中，我们已经简要讨论了中间件。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a Metro Rail API with the help of a few web frameworks
    available in Go. The most popular ones are `go-restful`, Gin Gonic, and `revel.go`.
    We have introduced a database layer in this chapter. We chose SQLite3 and tried
    to write a sample application using the `go-sqlite3` library.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在 Go 语言的一些网络框架的帮助下构建了一个地铁铁路 API。最受欢迎的框架是 `go-restful`、Gin Gonic 和 `revel.go`。我们在本章中引入了数据库层。我们选择了
    SQLite3，并尝试使用 `go-sqlite3` 库编写一个示例应用程序。
- en: We then explored `go-restful` and looked in detail at how to create routes and
    handlers. `go-restful` has the concept of building APIs on top of resources. We
    explained why `go-restful` is lightweight and can be used to create low-latency
    APIs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探索了 `go-restful` 并详细探讨了如何创建路由和处理程序。`go-restful` 有在资源之上构建 API 的概念。我们解释了为什么
    `go-restful` 是轻量级的，并且可以用来创建低延迟的 API。
- en: Next, we introduced the Gin framework and tried to re-implement the `railAPI`.
    Finally, we tried to create another API on the train resource, but this time with
    the `revel.go` web framework. Revel is a framework that is similar to Django and
    Ruby on Rails. It provides scaffolding for most of the server needs such as routing,
    handlers, and middleware.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了 Gin 框架，并尝试重新实现 `railAPI`。最后，我们尝试在火车资源上创建另一个 API，但这次使用的是 `revel.go`
    网络框架。Revel 是一个类似于 Django 和 Ruby on Rails 的框架。它为大多数服务器需求提供脚手架，如路由、处理程序和中间件。
- en: The main theme of this chapter is to suggest you use available frameworks for
    REST API development. Use `revel.go` when you have an end-to-end web application
    (templates and UI) in addition to the REST API, use Gin to quickly create REST
    services, and use `go-restful` when the performance of the API is critical.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要主题是建议您使用可用的框架进行 REST API 开发。当您除了 REST API 之外还有端到端 Web 应用程序（模板和 UI）时，使用
    `revel.go`，当 API 的性能至关重要时，使用 Gin 快速创建 REST 服务，当 API 的性能至关重要时，使用 `go-restful`。
- en: We also worked with a relational database in the form of SQLite3\. In the next
    chapter, we introduce a popular non-relational database called MongoDB for building
    an API.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一种名为 SQLite3 的关系型数据库。在下一章中，我们将介绍一个流行的非关系型数据库 MongoDB，用于构建 API。
