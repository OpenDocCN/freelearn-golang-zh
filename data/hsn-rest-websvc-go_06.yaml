- en: Working with Protocol Buffers and gRPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议缓冲区和gRPC进行工作
- en: In this chapter, we are going to enter the world of protocol buffers. The REST
    API needs support from other internal services. Those internal services can implement
    a **Remote Procedure Call** (**RPC**) and use a protocol buffer as a data exchange
    format. First, we will discover the benefits of using protocol buffers instead
    of JSON for services, and where to use both. We will use Google's `proto` library
    to compile protocol buffers. We will also try to write a few web services with
    protocol buffers that can talk to either Go, or other applications such as Python
    and Node.js. Then, we'll explain gRPC, an advanced simplified form of RPC. We
    will learn how gRPC and protocol buffers can help us build low-bandwidth services
    that can be consumed by different clients. Finally, we will discuss HTTP/2 and
    its benefits over plain HTTP/1.1-based services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进入协议缓冲区的世界。REST API需要来自其他内部服务的支持。这些内部服务可以实现**远程过程调用**（RPC）并使用协议缓冲区作为数据交换格式。首先，我们将发现使用协议缓冲区而不是JSON对服务的好处，以及在哪里使用两者。我们将使用谷歌的`proto`库来编译协议缓冲区。我们还将尝试使用协议缓冲区编写一些可以与Go或其他应用程序（如Python和Node.js）通信的Web服务。然后，我们将解释gRPC，这是一种高级简化的RPC形式。我们将学习如何使用gRPC和协议缓冲区帮助我们构建低带宽服务，这些服务可以被不同的客户端消费。最后，我们将讨论HTTP/2及其相对于基于纯HTTP/1.1服务的优势。
- en: 'In short, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将涵盖以下主题：
- en: Introduction to protocol buffers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲区简介
- en: Protocol buffer language
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲区语言
- en: Compiling a protocol buffer with protoc
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用protoc编译协议缓冲区
- en: Introduction to gRPC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC简介
- en: Bidirectional streaming with gRPC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用gRPC的双向流
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You''ll need to preinstall the following software in order to run the code
    examples in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中的代码示例，您需要预先安装以下软件：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux（Ubuntu 18.04）/Windows 10/Mac OS X >=10.13
- en: Go's latest version compiler >= 1.13.5
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的最新版本编译器 >= 1.13.5
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6).
    Clone the code and use the code samples in the `chapter6` directory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter6)下载本章的代码。克隆代码并使用`chapter6`目录中的代码示例。
- en: Introduction to protocol buffers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲区简介
- en: 'HTTP/1.1 is the standard that is adopted by the web community. In recent times,
    HTTP/2 is becoming more popular because of its advantages. Some of the benefits
    of using HTTP/2 are as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.1是网络社区采用的行业标准。近年来，由于它的优势，HTTP/2变得越来越受欢迎。使用HTTP/2的一些好处如下：
- en: Flow control between sender and receiver
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送者和接收者之间的流量控制
- en: Better compression of HTTP headers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的HTTP头部压缩
- en: Single TCP connection for bidirectional streaming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向流的单一TCP连接
- en: Server push support for sending files on one TCP connection
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单一TCP连接上发送文件的推送支持
- en: Support from all major browsers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有主流浏览器的支持
- en: 'The technical definition from Google about protocol buffers is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 来自谷歌关于协议缓冲区的技术定义如下：
- en: Protocol buffers are a flexible, efficient, automated mechanism for serializing
    structured data—think XML, but smaller, faster, and simpler. You define how you
    want your data to be structured once, then you can use the specially generated
    source code to easily write and read your structured data to and from a variety
    of data streams and using a variety of languages. You can even update your data
    structure without breaking deployed programs that are compiled against the "old"
    format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区是一种灵活、高效、自动化的机制，用于序列化结构化数据——想象一下XML，但更小、更快、更简单。您只需定义一次您希望数据如何结构化，然后您就可以使用特别生成的源代码轻松地将结构化数据写入和读取到各种数据流中，并使用各种语言。您甚至可以在不破坏针对“旧”格式编译的已部署程序的情况下更新您的数据结构。
- en: Let's look at this in detail. A protocol buffer is a strongly typed specification
    language. A tight data interface is essential for designing microservices. Protocol
    buffers allow us to define the data contract between multiple systems. Once a
    protocol buffer file has been defined, we can compile it to a target programming
    language. The output of this compilation will be classes and functions in the
    target programming language. The sender serializes data into a binary format that
    is transferred over the network. The receiver deserializes the data and consumes
    it. Basically, protocol buffers are similar to data formats such as JSON and XML,
    but the latter formats are text-based while protocol buffers are binary.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看。协议缓冲是一种强类型规范语言。紧凑的数据接口对于设计微服务至关重要。协议缓冲允许我们定义多个系统之间的数据合约。一旦定义了协议缓冲文件，我们就可以将其编译为目标编程语言。编译的输出将是目标编程语言中的类和函数。发送者将数据序列化为二进制格式，通过网络传输。接收者反序列化数据并消费它。基本上，协议缓冲类似于
    JSON 和 XML 等数据格式，但后者的格式是基于文本的，而协议缓冲是二进制的。
- en: In Go, protocol buffers can be transported over different transports, such as
    HTTP/2 and **Advanced Message Queuing Protocol **(**AMQP**). They are a transport
    format similar to JSON but strictly typed, and can only be understood between
    the client and the server. First, we will understand why **protocol buffers** (**protobufs**)
    exist and how to use them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，协议缓冲可以通过不同的传输方式传输，例如 HTTP/2 和 **高级消息队列协议** **（AMQP**）。它们是一种类似于 JSON 的传输格式，但具有严格的类型，并且只能在客户端和服务器之间理解。首先，我们将了解为什么
    **协议缓冲** **（protobufs**） 存在以及如何使用它们。
- en: 'Protocol buffers have many advantages over JSON/XML for serializing structured
    data, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲在序列化结构化数据（如以下内容）方面比 JSON/XML 有许多优势：
- en: They have a strong interface
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个强大的接口
- en: They are a lot smaller than text-based data formats
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们比基于文本的数据格式小得多
- en: They are usually faster than JSON/XML when it comes to serialization/deserialization
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在序列化/反序列化方面通常比 JSON/XML 快
- en: They are less ambiguous because of type and order
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于类型和顺序，它们更少含糊不清
- en: They generate data access classes that are easier to use programmatically
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们生成易于编程使用的数据访问类
- en: We will prove these points while discussing a few examples later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论几个示例时证明这些观点。
- en: Protocol buffer language
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲语言
- en: A protocol buffer is a file with minimalist language syntax. We compile a protocol
    buffer, and a new file is generated for a target programming language. For example,
    in Go, the compiled file will be a `.go` file with structs mapping the `protobuf`
    file. In Java, a `class` file will be created. Think of a protocol buffer as a
    data structure with types. The protocol buffer language provides various types
    that we can use to create interfaces. First, we'll discuss all the types with
    equivalent JSON snippets. After that, we'll implement a full example of a protocol
    buffer. From here on, we'll use the terms `protobuf/s` and protocol buffers interchangeably.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲是一个具有极简语言语法的文件。我们编译协议缓冲，为目标编程语言生成一个新的文件。例如，在 Go 中，编译后的文件将是一个 `.go` 文件，其中包含映射
    `protobuf` 文件的 struct。在 Java 中，将创建一个 `class` 文件。将协议缓冲视为具有类型的数据结构。协议缓冲语言提供了各种类型，我们可以使用它们来创建接口。首先，我们将讨论所有与等效
    JSON 片段相对应的类型。之后，我们将实现一个完整的协议缓冲示例。从现在开始，我们将交替使用术语 `protobuf/s` 和协议缓冲。
- en: Here, we are going to use `proto3` as our protobuf version. There are slight
    variations in versions, so please note the differences when you are using older
    versions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 `proto3` 作为我们的 protobuf 版本。版本之间有一些细微的差异，所以请注意在使用较旧版本时的差异。
- en: 'First, let''s learn how to model messages in a protobuf. A message is a resource
    that is transmitted to the receiver. Here, we''re trying to define a simple network
    interface message:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何在 protobuf 中建模消息。消息是一种传输给接收者的资源。在这里，我们试图定义一个简单的网络接口消息：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This syntax may look new to you. In the preceding code, we were defining a
    message type called `NetworkInterface`.It has four fields: `index`, **maximum
    transmission** **unit** (**MTU**), `name`, and hardware address *(*MAC). If we
    wish to write the same in JSON, it would look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法可能对你来说很新。在前面的代码中，我们正在定义一个名为 `NetworkInterface` 的消息类型。它有四个字段：`index`、**最大传输单元**
    **（MTU**）、`name` 和硬件地址（*MAC*）。如果我们用 JSON 写同样的内容，它看起来会是这样：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The field names are changed to comply with the JSON style guide, but the essence
    and structure are the same. But what are the sequential numbers (1,2,3,4) that
    are given to the fields in the preceding protobuf file? They are the ordering
    tags that are given to serialize and deserialize protocol buffer data between
    two systems. It's like hinting at the protocol buffer encoding/decoding systems
    to write/read the data in that particular order, respectively. When the preceding
    protobuf file is compiled in Go as a target, the protocol buffer message will
    be converted into a Go struct and the fields will be filled with empty default
    values.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称被更改为符合JSON风格指南，但本质和结构保持不变。但是，前一个protobuf文件中字段所赋予的顺序数字（1、2、3、4）是什么？它们是用于在两个系统之间序列化和反序列化协议缓冲区数据的顺序标签。这就像是在暗示协议缓冲区编码/解码系统按特定顺序写入/读取数据。当前一个protobuf文件以Go为目标编译时，协议缓冲区消息将被转换为Go结构体，字段将被填充为空默认值。
- en: 'In the protobuf language, there are many basic types. Some of the important
    ones are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在protobuf语言中，有许多基本类型。其中一些重要的类型如下：
- en: Scalar values
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量值
- en: Enumerations and repeated fields
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举和重复字段
- en: Nested fields
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套字段
- en: We'll discuss each of them briefly in the upcoming sections.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中简要讨论每个类型。
- en: Scalar values
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标量值
- en: The types we assigned to the fields in the `networkInterface` message are scalar
    types. These types are similar to Go types and match with them. For other programming
    languages, they will be converted into their respective types. Protobufs support
    many diverse types, such as `int`, `int32`, `int64`, `string`, and `bool`, which
    resemble Go types, but with a few variations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给`networkInterface`消息中的字段的类型是标量类型。这些类型与Go类型相似，并且与它们匹配。对于其他编程语言，它们将被转换为它们各自的数据类型。Protobuf支持许多不同的类型，如`int`、`int32`、`int64`、`string`和`bool`，它们类似于Go类型，但有一些变化。
- en: 'They are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它们如下所示：
- en: '| **Go type** | **Protobuf type** |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **Go类型** | **Protobuf类型** |'
- en: '| `float32` | `float` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | `float` |'
- en: '| `float64` | `double` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | `double` |'
- en: '| `uint32` | `fixed32` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `fixed32` |'
- en: '| `uint64` | `fixed64` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `fixed64` |'
- en: '| `[]byte` | `bytes` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `[]byte` | `bytes` |'
- en: 'These types can be used while defining fields in a `protobuf` file. These fields
    and types in protobuf are converted into their respective Go variables and types
    upon being compiled. Go fills an unassigned variable with its empty value. Let''s
    look at a few default empty values in Go for the protobuf message type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型可以在定义`protobuf`文件中的字段时使用。在编译时，这些字段和类型在protobuf中将转换为相应的Go变量和类型。Go将为未分配的变量填充其空值。让我们看看protobuf消息类型在Go中的几个默认空值：
- en: '| **Protobuf type** | **Default value** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **Protobuf类型** | **默认值** |'
- en: '| `string` | `""` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `""` |'
- en: '| `bytes` | `empty bytes[]` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | `empty bytes[]` |'
- en: '| `bool` | `false` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `false` |'
- en: '| `int`, `int32`, `int64`, `float`, `double` | `0` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `int`、`int32`、`int64`、`float`、`double` | `0` |'
- en: '| `enum` | `0` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | `0` |'
- en: Since protobufs make an agreement beforehand about messages and fields between
    end systems using a data structure, they don't take up additional space for keys
    like they do in JSON.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于protobufs在端系统之间使用数据结构预先就消息和字段达成协议，因此它们不会像JSON那样为键占用额外的空间。
- en: Enumerations and repeated fields
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举和重复字段
- en: '**Enumerations **(**enum**) provide the ordering of numbers for a given set
    of elements. The default order of values is from *0 *to *n*. So, in a protocol
    buffer message, we can have an enumeration type. Let''s look at an example of
    the `enum`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**（**enum**）为给定的一组元素提供数字的顺序。值的默认顺序是从*0*到*n*。因此，在协议缓冲区消息中，我们可以有一个枚举类型。让我们看看`enum`的一个例子：'
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What if we have to assign the same values for the multiple enumeration members?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须为多个枚举成员分配相同的值怎么办？
- en: 'Protobuf3 has an option called **`allow_alias` **that we can use to assign
    two different members the same value, like so:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf3有一个名为**`allow_alias`**的选项，我们可以使用它为两个不同的成员分配相同的值，如下所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `STARTED` and `RUNNING` both have a `1` tag. This means that both can
    have the same value in the data. If we try to remove duplicated values, we should
    also remove the `allow_alias`option. Otherwise, the proto compiler will throw
    an error (we will see what a proto compiler is shortly).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`STARTED`和`RUNNING`都有一个`1`标签。这意味着它们在数据中可以具有相同的值。如果我们尝试删除重复的值，我们也应该删除`allow_alias`选项。否则，proto编译器将抛出错误（我们很快就会看到proto编译器是什么）。
- en: '`repeated` fields are the fields in the message of a protocol buffer that represent
    a list of items. In JSON, we have a list of elements for a given key. Similarly,
    repeated fields allow us to define an array/list of elements of a particular type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeated`字段是协议缓冲区消息中的字段，代表一个项目列表。在JSON中，我们有一个给定键的元素列表。同样，重复字段允许我们定义特定类型的元素数组/列表：'
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, the third field is a repeated field, which means it is
    an array/list of proxies. The value could be something like `["100.104.112.10",
    "100.104.112.12"]`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第三个字段是重复字段，这意味着它是一个代理的数组/列表。值可能如下所示：`["100.104.112.10", "100.104.112.12"]`。
- en: Nested fields
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套字段
- en: We can also use a message as a type of another message. It is similar to a map
    data structure. It is analogous to nested JSON.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个消息用作另一个消息的类型。它类似于map数据结构。它类似于嵌套的JSON。
- en: 'For example, take a look at the following JSON code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看下面的JSON代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding JSON contains information about a site that has a list of proxies.
    Each proxy is a map itself and contains details such as `url` and `latency`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON包含有关具有代理列表的站点的信息。每个代理本身就是一个映射，并包含诸如`url`和`latency`之类的详细信息。
- en: 'How can we model the same thing in protobufs? We can do this using the nested
    messages, as shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在protobufs中建模相同的东西呢？我们可以使用嵌套消息来实现，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we are nesting the `Proxy` type into `Site`. We will look at all of these
    field types soon. You can find more details about types here: [https://developers.google.com/protocol-buffers/docs/proto](https://developers.google.com/protocol-buffers/docs/proto).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`Proxy`类型嵌套到`Site`中。我们很快就会查看所有这些字段类型。您可以在[https://developers.google.com/protocol-buffers/docs/proto](https://developers.google.com/protocol-buffers/docs/proto)找到更多关于类型的详细信息。
- en: In the next section, we'll learn about a protobuf compiler and how to use it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解protobuf编译器及其使用方法。
- en: Compiling a protocol buffer with protoc
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用protoc编译协议缓冲
- en: So far, we have discussed how to write a protocol buffer file by defining messages
    and their field types. But how do we actually integrate one into our Go programs?
    Remember that protobufs are a format of communication between various systems,
    similar to JSON. But the actual data that is transferred is binary. The protoc
    compiler automatically generates Go structs from `.proto` files. Later, those
    structs can be imported to create binary data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何通过定义消息及其字段类型来编写协议缓冲文件。但我们是怎样实际上将其集成到我们的Go程序中的呢？记住，protobufs是各种系统之间通信的格式，类似于JSON。但实际传输的数据是二进制的。`protoc`编译器会自动从`.proto`文件生成Go结构体。之后，这些结构体可以被导入以创建二进制数据。
- en: 'The following are the practical steps we follow when using protobufs in our
    Go programs:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们使用protobufs在Go程序中遵循的实际步骤：
- en: Install the `protoc` command-line tool and the `proto` library.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`protoc`命令行工具和`proto`库。
- en: Write a protobuf file with the `.proto` extension.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.proto`扩展名编写protobuf文件。
- en: Compile the file so that it targets a programming language (in our case, it
    is Go).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译文件，使其针对编程语言（在我们的例子中是Go）。
- en: Import structs from the generated target file and add the necessary data.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从生成的目标文件导入结构体并添加必要的数据。
- en: Serialize the data into binary format and send it to the receiver.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据序列化为二进制格式并发送给接收器。
- en: On a remote machine, the receiver deserializes the data and decodes data.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程机器上，接收器反序列化数据并解码数据。
- en: 'These steps can be seen in the following diagram:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤可以在以下图中看到：
- en: '![](img/a5e4950f-1e7d-4899-996e-b95bff240ee2.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5e4950f-1e7d-4899-996e-b95bff240ee2.jpg)'
- en: 'The first step is to install the `protobuf` compiler on our machine. For this,
    download the `protobuf` package from [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    On Mac OS X, we can install `protobuf` using this command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在我们的机器上安装`protobuf`编译器。为此，从[https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases)下载`protobuf`包。在Mac
    OS X上，我们可以使用以下命令安装`protobuf`：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On Ubuntu or Linux, we can copy `protoc` to the `/usr/bin` folder:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu或Linux上，我们可以将`protoc`复制到`/usr/bin`文件夹：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Windows, we can just copy the executable (`.exe`) from [https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip](https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip)
    to the `PATH` environment variable. Let''s write a simple protocol buffer to illustrate
    how to compile and use structs from the target file. Create a folder called `protobufs`
    in your `GOPATH`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，我们只需将可执行文件（`.exe`）从[https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip](https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-win64.zip)复制到`PATH`环境变量中。让我们编写一个简单的协议缓冲文件来展示如何编译和使用目标文件中的结构体。在你的`GOPATH`中创建一个名为`protobufs`的文件夹：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside protobufs, create a new directory called `protofiles`. This directory
    holds the compiled files from protocol buffers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protobufs`内部，创建一个名为`protofiles`的新目录。此目录包含来自协议缓冲的编译文件。
- en: 'In the `protofiles` directory, create a file called `person.proto`, which models
    a person''s information. It defines name, ID, email, and phone number. Add a few
    messages to it, as shown in the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protofiles`目录中，创建一个名为`person.proto`的文件，该文件模拟一个人的信息。它定义了姓名、ID、电子邮件和电话号码。向其中添加一些消息，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we created two main messages called `AddressBook` and `Person`.The`AddressBook`
    message contains a list of persons. A `Person` has a `name`, `id`, `email`, and
    `PhoneNumber`. In the second line, we declared the package as `protofiles`, like
    this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个主要的消息，称为`AddressBook`和`Person`。`AddressBook`消息包含一个人员列表。一个`Person`具有`name`、`id`、`email`和`PhoneNumber`。在第二行，我们将包声明为`protofiles`，如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This tells the compiler to add the generating file in relation to the given
    package name. Go cannot consume this `.proto` file directly. We need to compile
    it to a valid Go file. When compiled, the `protofiles` package will be used to
    create a Go package. To compile our `person.proto` protocol buffer file, traverse
    to the `protofiles` directory and run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器添加与给定包名称相关的生成文件。Go不能直接消费这个`.proto`文件。我们需要将其编译为有效的Go文件。编译后，`protofiles`包将用于创建Go包。要编译我们的`person.proto`协议缓冲文件，转到`protofiles`目录并运行以下命令：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command converts the given protocol buffer file(s) into the Go file(s)
    with the same name. After running this command, you''ll see that a new file has
    been created in the same directory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将给定的协议缓冲文件转换为具有相同名称的Go文件。运行此命令后，你会在同一目录中看到一个新文件已创建：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The new file''s name is `person.pb.go`.If we open and inspect this file, we''ll
    see that it contains automatically generated code blocks:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件的名称是`person.pb.go`。如果我们打开并检查此文件，我们会看到它包含自动生成的代码块：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is just one part of that file. Many getter and setter methods will be created
    for the given structs, such as `Person` and `AddressBook`, in the output file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是该文件的一部分。输出文件将为给定的结构体（如`Person`和`AddressBook`）创建许多getter和setter方法。
- en: 'The preceding `person.pb.go` package is automatically generated boilerplate
    by the `proto` compiler. We need to consume that package in the main program to
    create protocol buffer strings. Now, we should create the `main.go` file, which
    uses the `Person` struct from the `person.pb.go` file like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`person.pb.go`包是由`proto`编译器自动生成的样板代码。我们需要在主程序中消费该包以创建协议缓冲字符串。现在，我们应该创建`main.go`文件，该文件使用`person.pb.go`文件中的`Person`结构体，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, for Go to serialize a struct into binary format, we need to install the
    Go `proto` driver. Install it using the `go get` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使Go能够将结构体序列化为二进制格式，我们需要安装Go的`proto`驱动程序。使用`go get`命令安装它：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The goal of the program we are going to create is to read the `Person` struct
    from the auto-generated package and serialize it into a buffer string using the `proto.Marshal`
    method. The fill the `main.go` like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的程序的目标是从自动生成的包中读取`Person`结构体，并使用`proto.Marshal`方法将其序列化为缓冲字符串。现在，我们将`main.go`填写如下：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we are importing the **protocol buffer** (`pb`) from the `protofiles`
    package. We initialized the `Person` struct with details. Then, we serialized
    the struct using the `proto.Marshal`function. If we run this program, the output
    looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在从`protofiles`包导入**协议缓冲**（`pb`）。我们使用详细信息初始化了`Person`结构体。然后，我们使用`proto.Marshal`函数序列化结构体。如果我们运行这个程序，输出将如下所示：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second output of the marshaled data is not obvious because the `proto`
    library serializes data into binary bytes. Another good thing about protocol buffers
    in Go is that the structs that are generated by compiling the proto files can
    be used to generate JSON on the fly. Let''s modify the preceding example into
    a new program. Call it `jsonExample`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: marshaled data的第二种输出并不明显，因为`proto`库将数据序列化为二进制字节。在Go中使用协议缓冲区的另一个优点是，通过编译proto文件生成的struct可以用来动态生成JSON。让我们将前面的示例修改成一个新的程序。命名为`jsonExample`：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this program, we''ll use JSON''s marshaler instead of protobuf''s marshaler.
    The beauty of the Go interfaces is that it allows the protocol buffer struct to
    be an input for different types of marshalers. The following is the modified code
    for converting the `Person` struct into JSON:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将使用JSON的marshaler而不是protobuf的marshaler。Go接口的美丽之处在于它允许协议缓冲区struct作为不同类型marshaler的输入。以下是将`Person`
    struct转换为JSON的修改后的代码：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we run this, it prints a JSON string that can be sent to any client that
    can understand JSON:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，它将打印出一个可以发送给任何理解JSON的客户端的JSON字符串：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Any other web service/receiver can easily consume this JSON string instantly.
    So, what is the benefit of using protocol buffers instead of JSON? First of all,
    protocol buffers are intended for two backend systems to communicate with each
    other with a strong interface and smaller payload size. Since the size of the
    binary is less than the text, the protocol marshaled data is always significantly
    smaller than the JSON text.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他web服务/接收器都可以轻松地立即消费这个JSON字符串。那么，使用协议缓冲区而不是JSON的好处是什么？首先，协议缓冲区旨在让两个后端系统通过一个强大的接口和较小的有效载荷大小相互通信。由于二进制的大小小于文本，因此协议序列化的数据始终比JSON文本小得多。
- en: The output that's generated by a `protobuf` compiler is nothing but a plain
    Go struct. This allows you to convert from and protobuf into JSON easily.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`protobuf`编译器生成的输出仅仅是普通的Go struct。这允许你轻松地将protobuf转换为JSON。'
- en: Protocol buffers are just a data format. They need a mode of transport to move
    between systems. We saw how RPC works and also created an RPC client and server
    in [Chapter 3](ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml), *Working with Middleware
    and RPC*. Now, we are going to extend that knowledge to use a **Google Remote
    Procedure Call** (**gRPC**) with protocol buffers to efficiently transfer data.
    A server and a client, in this case, can talk with each other in the protocol
    buffer format.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区仅仅是一种数据格式。它们需要一个传输模式在系统之间移动。我们看到了RPC是如何工作的，并在[第3章](ab89bca5-b60d-4681-bc36-23ee51a56cc6.xhtml)，*与中间件和RPC一起工作*中创建了一个RPC客户端和服务器。现在，我们将扩展这些知识，使用带有协议缓冲区的**Google远程过程调用**（**gRPC**）来高效地传输数据。在这种情况下，服务器和客户端可以使用协议缓冲区格式相互通信。
- en: Introduction to gRPC
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC简介
- en: '**gRPC** is a transport mechanism that sends and receives messages between
    two systems. Traditionally, these systems are a server and a client. As we described
    in the previous chapters, RPC can be implemented in Go for transferring JSON.
    We called it a **JSON RPC** service. Similarly, gRPC is specially designed to
    transfer data in the form of protocol buffers.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**gRPC**是一种在两个系统之间发送和接收消息的传输机制。传统上，这些系统是服务器和客户端。正如我们在前面的章节中描述的，RPC可以在Go中实现以传输JSON。我们称之为**JSON
    RPC**服务。同样，gRPC专门设计用来以协议缓冲区的形式传输数据。'
- en: gRPC makes service creation easy and elegant. It provides a nice set of APIs
    that we can use to define services and start running them. In this section, we
    will focus on how to create a gRPC service and how to use it. The main advantage
    of gRPC is that it can be understood by multiple programming languages. Protocol
    buffers provide a common data structure. So, this combination enables seamless
    communication between various tech stacks and systems. This is the integral concept
    of distributed computing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC使服务创建变得简单而优雅。它提供了一套不错的API，我们可以使用这些API来定义服务并启动它们。在本节中，我们将重点介绍如何创建gRPC服务以及如何使用它。gRPC的主要优势是它可以被多种编程语言理解。协议缓冲区提供了一种公共的数据结构。因此，这种组合使得各种技术栈和系统之间的通信无缝。这是分布式计算的基本概念。
- en: Square, Netflix, and many other giants leverage this gRPC to scale their huge
    traffic-prone services. Google uses gRPC heavily for their web services. We can
    leverage it to get better throughput between two internal services.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Square、Netflix和其他许多巨头利用gRPC来扩展他们巨大的流量密集型服务。Google在他们的网络服务中大量使用gRPC。我们可以利用它来在两个内部服务之间获得更好的吞吐量。
- en: 'We need to install the `grpc` Go library and a `protoc-gen` plugin before writing
    the services. Install them using the following commands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写服务之前，我们需要安装 `grpc` Go 库和一个 `protoc-gen` 插件。使用以下命令安装它们：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'gRPC has the following benefits over a traditional HTTP/REST/JSON architecture:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的 HTTP/REST/JSON 架构相比，gRPC 有以下优点：
- en: gRPC uses HTTP/2, which is a binary protocol.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 使用 HTTP/2，这是一个二进制协议。
- en: Header compression is possible in HTTP/2, which means less overhead.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2 中可以实现头部压缩，这意味着开销更小。
- en: We can multiplex many requests on one connection.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在一个连接上多路复用多个请求。
- en: We can use protobufs for strict typing of data.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 protobufs 来进行数据的严格类型化。
- en: Streaming requests or responses, instead of using a request/response transaction,
    is possible.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流式请求或响应，而不是使用请求/响应事务，是可能的。
- en: 'Take a look at the following diagram:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表：
- en: '![](img/c7bb83e9-7c49-40d3-871c-c97d984c538b.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7bb83e9-7c49-40d3-871c-c97d984c538b.jpg)'
- en: The preceding diagram clearly shows that any back-end system or mobile app can
    directly communicate to a gRPC server using a protocol buffer. Let's write a money
    transaction service in Go using gRPC and protocol buffers. A service in gRPC is
    an RPC contract. It takes a message and returns another message.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表清楚地表明，任何后端系统或移动应用都可以直接通过协议缓冲区与 gRPC 服务器通信。让我们用 Go 语言和 gRPC 以及协议缓冲区编写一个货币交易服务。gRPC
    中的一个服务是一个 RPC 合同。它接收一个消息并返回另一个消息。
- en: 'The steps for implementing the money transaction service are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现货币交易服务的步骤如下：
- en: Create the protocol buffer with the definitions of service and messages.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含服务和消息定义的协议缓冲区。
- en: Compile the protocol buffer file.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译协议缓冲区文件。
- en: Use the generated Go package to create a gRPC server.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的 Go 包创建一个 gRPC 服务器。
- en: Create a gRPC client that talks to the server.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与服务器通信的 gRPC 客户端。
- en: 'To understand these steps, let''s create the project directories for our upcoming
    example, like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些步骤，让我们为即将到来的示例创建项目目录，如下所示：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a file called `transaction.proto` for defining gRPC services:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `transaction.proto` 的文件来定义 gRPC 服务：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the `transaction.proto` file, define the service and transaction messages,
    like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `transaction.proto` 文件中，定义服务和交易消息，如下所示：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a simple protocol buffer for a money transaction on the server. We
    introduced the `message` keyword when we discussed protocol buffers. The new keyword, `service`,
    defines a gRPC service. This new keyword is solely related to gRPC, and the `protoc-gen-go` helper
    plugin translates it into an understandable format via the `protoc` compiler.
    Now, let''s compile this file using `protoc` from the `grpcExample` directory:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的服务器端货币交易协议缓冲区。我们在讨论协议缓冲区时介绍了 `message` 关键字。新的关键字 `service` 定义了一个 gRPC
    服务。这个新关键字仅与 gRPC 相关，`protoc-gen-go` 辅助插件通过 `protoc` 编译器将其转换为可理解格式。现在，让我们使用 `grpcExample`
    目录中的 `protoc` 编译此文件：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command is slightly bigger than the compile command we used previously.
    This is because we are using the `protoc-gen-go` plugin. This command simply says
    to use data files as the input directory for proto files and use the same directory
    for outputting the target Go files. Now, if we list the `protofiles` directory,
    we''ll see an autogenerated file called `transaction.pb.go`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令比我们之前使用的编译命令稍大。这是因为我们使用了 `protoc-gen-go` 插件。这个命令只是说使用数据文件作为 proto 文件的输入目录，并使用相同的目录输出目标
    Go 文件。现在，如果我们列出 `protofiles` 目录，我们会看到一个自动生成的文件，名为 `transaction.pb.go`：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we have to build a server and client that consumes previously built protobufs.
    Create two more directories for the server and client logic in `grpcExample`,
    like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须构建一个服务器和客户端，它们消费之前构建的 protobufs。在 `grpcExample` 中创建两个额外的目录，用于服务器和客户端逻辑，如下所示：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's create a `grPC` server first. Add a file called `server.go` to the `grpcServer`
    directory, which implements the transaction service. Our goal is to create a server
    that collects a transaction request from the client and returns the confirmation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个 `gRPC` 服务器。在 `grpcServer` 目录中添加一个名为 `server.go` 的文件，该文件实现了交易服务。我们的目标是创建一个服务器，它可以从客户端收集交易请求并返回确认。
- en: 'We need the help of more packages here, that is, `context` and `reflection`.`context`
    is used to create a `context` variable, which lives throughout an RPC request''s
    lifetime. Both of these libraries are used by gRPC for its internal functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要更多包的帮助，即 `context` 和 `reflection`。`context` 用于创建一个在 RPC 请求整个生命周期中存在的
    `context` 变量。这两个库都由 gRPC 用于其内部函数：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we open the autogenerated `transaction.pb.go` package in `protofiles`, we
    can clearly see that there are two important things:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `protofiles` 中打开自动生成的 `transaction.pb.go` 包，我们可以清楚地看到有两件重要的事情：
- en: The `MakeTransaction` function, as part of the `MoneyTransactionServer` interface
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MakeTransaction` 函数作为 `MoneyTransactionServer` 接口的一部分'
- en: The `RegisterMoneyTransactionServer` function
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterMoneyTransactionServer` 函数'
- en: '`MakeTransaction` is used for implementing the service. Let''s take a look
    at the implementation. It defines a struct and a method. This method performs
    the money transaction using the data that''s supplied via the `*pb.TransactionRequest`
    argument:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeTransaction` 用于实现服务。让我们看看实现细节。它定义了一个结构和一种方法。该方法使用通过 `*pb.TransactionRequest`
    参数提供的数据进行货币交易：'
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`MakeTransaction` contains the RPC request details. It is basically a struct
    that maps to the `TransactionRequest` message we defined in the protocol buffer
    file. What''s returned from `MakeTransaction` is `TransactionResponse`.This function
    signature matches with the one we defined in the protocol buffer file initially:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeTransaction` 包含 RPC 请求细节。它基本上是一个结构体，映射到我们在协议缓冲文件中定义的 `TransactionRequest`
    消息。`MakeTransaction` 返回的是 `TransactionResponse`。此函数签名与我们在协议缓冲文件中最初定义的相匹配：'
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now comes the main block. Here, we have to create an instance of the gRPC server
    and register the server struct with it. We run this gRPC server on port `50051`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是主块。在这里，我们必须创建 gRPC 服务器的实例，并将其与服务器结构注册。我们在端口 `50051` 上运行这个 gRPC 服务器：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we need to write a client. Add a file called `client.go` in the `grpcClient`
    directory. The client should dial the server and acquire a connection. Using that
    connection, we can call remote functions and get the results. A gRPC client also
    uses the same protobuf boilerplate classes so that it''s in sync with the server.
    The following is the code for the client:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编写一个客户端。在 `grpcClient` 目录中添加一个名为 `client.go` 的文件。客户端应该连接到服务器并获取连接。使用该连接，我们可以调用远程函数并获取结果。gRPC
    客户端也使用相同的 protobuf 模板类，以确保与服务器同步。以下是为客户端编写的代码：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This client is also using the `grpc`package. It uses an empty context called
    `context.Background()`to pass to the `MakeTransaction`function. The second argument
    of the function is the `TransactionRequest` struct:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此客户端也使用 `grpc` 包。它使用一个名为 `context.Background()` 的空上下文传递给 `MakeTransaction` 函数。函数的第二个参数是
    `TransactionRequest` 结构体：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s run both the server and the client and view the output. Open a
    new console and run the gRPC server by using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们同时运行服务器和客户端并查看输出。打开一个新的控制台，并使用以下命令运行 gRPC 服务器：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The TCP server starts listening on port `50051`. Now, open one more Terminal/shell
    and start the client program that talks to this server:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 服务器开始监听端口 `50051`。现在，打开另一个终端/外壳，并启动与该服务器通信的客户端程序：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It prints the output of the successful transaction:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印了成功交易的输出：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At the same time, the server logs this message to the console:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，服务器将此消息记录到控制台：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the client made a single request to the gRPC server and passed details
    of the `From A/c` number, the `To A/c` number, and `Amount`. The server picks
    those details, processes them, and sends a response saying everything is fine.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，客户端向 gRPC 服务器发送了一个单一请求，并传递了 `From A/c` 账号、`To A/c` 账号和 `Amount` 的详细信息。服务器选择这些详细信息，处理它们，并发送响应表示一切正常。
- en: A gRPC client can request a gRPC server to perform a computation-heavy/secure
    operation. The client can be a mobile device too.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 客户端可以请求 gRPC 服务器执行计算密集型/安全操作。客户端也可以是移动设备。
- en: The full programs can be found in this chapter's project repository. In the
    next section, we'll look at bidirectional streaming in gRPC.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的程序可以在本章的项目仓库中找到。在下一节中，我们将探讨 gRPC 中的双向流。
- en: Bidirectional streaming with gRPC
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC 的双向流
- en: The main advantage of gRPC over traditional HTTP/1.1 is that it can use a single
    TCP connection for sending and receiving multiple messages between the server
    and the client. We saw the example of a money transaction previously. Another
    real-world use case is a GPS installed in a taxi. Here, the taxi is the client
    that sends its geographical points to the server along its route. Finally, the
    server can calculate the total fare amount depending on the time spent between
    points and the total distance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC相对于传统HTTP/1.1的主要优势是它可以使用单个TCP连接在服务器和客户端之间发送和接收多个消息。我们之前看到了货币交易的例子。另一个现实世界的用例是出租车中安装的GPS。在这里，出租车是客户端，它在其路线中将地理坐标发送到服务器。最后，服务器可以根据两点之间花费的时间和总距离计算总费用。
- en: 'Another use case is a server pushing data to a client. This is called a server
    push model, where a server can send a stream of results back to the client. This
    is different from polling, where the client creates a new request/response cycle
    each and every time. The server push can be very handy for building real-time
    applications. Let''s implement an example to illustrate this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是服务器向客户端推送数据。这被称为服务器推送模型，其中服务器可以将结果流发送回客户端。这与轮询不同，轮询中客户端每次都会创建一个新的请求/响应周期。服务器推送对于构建实时应用非常有用。让我们实现一个示例来说明这一点：
- en: 'Create a project called `serverPush`, like this:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`serverPush`的项目，如下所示：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, add the transactions to `protofiles`, a protocol buffer that is similar
    to the one that we used in the previous gRPC money transaction example, except
    the return type of `MakeTransaction` is a stream:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将交易添加到`protofiles`中，这是一个类似于我们在之前的gRPC货币交易示例中使用的协议缓冲区，但`MakeTransaction`的返回类型是一个流：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have two messages and one service defined in the protocol buffer file. The
    exciting part is in the service; we are returning a stream instead of a plain
    response:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲区文件中定义了两个消息和一个服务。最有趣的部分在于服务；我们返回一个流而不是一个普通响应：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use case of this project is that *the client sends a money transfer request
    to the server, the server does a few tasks, and then sends those step details
    as a stream of responses back to the server*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的用例是，客户端向服务器发送货币转账请求，服务器执行一些任务，然后将这些步骤详情作为响应流发送回服务器。
- en: 'Now, let''s compile the `.proto` file:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译`.proto`文件：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This creates a new file called `transaction.pb.go` in the `protofiles` directory.
    We use the definitions in this file in our server and client programs, which we
    will create shortly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`protofiles`目录中创建了一个新文件`transaction.pb.go`。我们在服务器和客户端程序中使用此文件中的定义，我们将很快创建这些程序。
- en: 'Now, let''s write the gRPC server code. This code is a bit different compared
    to the previous example because of the introduction of streams:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写gRPC服务器代码。这段代码与之前的示例略有不同，因为引入了流：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We skip the imports and look at the main logic of the program. The main function
    is similar to the previous gRPC example, but the most interesting thing is the
    handler. Let''s say the handler takes the request from the client and performs
    three steps. At the end of each step, the server sends a notification to the client.
    It is a long-living connection, unlike the one-time RPC call we saw earlier. The
    following is the code for streaming `MakeTransaction`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过导入部分，看看程序的主要逻辑。主函数与之前的gRPC示例类似，但最有趣的是处理程序。假设处理程序从客户端接收请求并执行三个步骤。在每个步骤的末尾，服务器向客户端发送通知。这是一个长期连接，与之前我们看到的一次性RPC调用不同。以下是为流`MakeTransaction`编写的代码：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`MakeTransaction`takes a request and a stream as its arguments. In the function,
    we are looping through the number of steps (here, there are three) and performing
    the computation. The server is simulating the mock I/O or computation using the `time.Sleep`function.
    The crucial server method for sending a message is `Send`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`MakeTransaction`函数接受一个请求和一个流作为其参数。在函数中，我们正在遍历步骤的数量（这里有三步）并执行计算。服务器正在使用`time.Sleep`函数模拟模拟I/O或计算。发送消息的关键服务器方法是`Send`：'
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function sends a stream response from the server to the client.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从服务器向客户端发送流响应。
- en: 'Now, let''s compose the client program. This is also a bit different from the
    basic gRPC client that we saw in the money transaction example''s client code.
    Create a new directory for the client program:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写客户端程序。这与我们在货币交易示例中看到的基gRPC客户端代码略有不同。为客户端程序创建一个新的目录：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, the client should listen indefinitely for the stream of messages. For
    that, we used a `for loop` and `break`. Let''s modify our previous client handler
    into a new one called `ReceiveStream`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，客户端应该无限期地监听消息流。为此，我们使用了`for loop`和`break`。让我们将我们之前的客户端处理程序修改为一个新的名为`ReceiveStream`的处理程序：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, `ReceiveStream`is the custom function we wrote for the sake of sending
    a request and receiving a stream of messages. It takes two arguments: `MoneyTransactionClient`and
    `TransactionRequest`.It uses the first argument to create a stream and starts
    listening to it. Whenever the server exhausts all the messages, the client will
    stop listening and terminate. Then, an `io.EOF` error will be returned if the
    client tries to receive messages. We are logging the responses that we collected
    from the gRPC server. The second argument, `TransactionRequest`,is used to send
    the request to the server for the first time. Running this will make this process
    clearer to us.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ReceiveStream`是我们为了发送请求和接收消息流而编写的自定义函数。它接受两个参数：`MoneyTransactionClient`和`TransactionRequest`。它使用第一个参数创建一个流并开始监听它。每当服务器耗尽所有消息时，客户端将停止监听并终止。如果客户端尝试接收消息，将返回一个`io.EOF`错误。我们正在记录从gRPC服务器收集到的响应。第二个参数`TransactionRequest`用于首次将请求发送到服务器。运行此操作将使此过程对我们来说更加清晰。
- en: The imports and main logic for the server and client are dropped for brevity.
    Please refer to this project's repository for the complete programs: `chapter6/serverPush`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，省略了服务器和客户端的导入和主要逻辑。请参阅此项目的存储库以获取完整的程序：`chapter6/serverPush`。
- en: 'On the first Terminal, run the gRPC server:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个终端上运行gRPC服务器：
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It will keep on listening for incoming requests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它将持续监听传入的请求。
- en: 'Now, run the client on the second Terminal to see it in action:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在第二个终端上运行客户端以查看其效果：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This outputs the following to the console:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出以下内容：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'At the same time, the server also logs its own messages on the first Terminal:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，服务器也在第一个终端上记录了自己的消息：
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This process happens in sync with the server. The client stays alive until
    the last streaming message is sent back. The server can handle any number of clients
    at a given time. Every client request is considered an individual entity. This
    is an example of the server sending a stream of responses. There are other use
    cases that can also be implemented with protocol buffers and gRPC:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程与服务器同步进行。客户端会保持活跃状态，直到最后一个流式消息被发送回。服务器可以同时处理任意数量的客户端。每个客户端请求都被视为一个独立实体。这是一个服务器发送流式响应的示例。还有其他可以使用协议缓冲和gRPC实现的使用案例：
- en: The client sends streamed requests to get one final response from the server
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送流式请求以从服务器获取一个最终的响应
- en: The client and server can both send streamed requests and responses at the same
    time
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器都可以同时发送和接收流式请求和响应
- en: The official gRPC team has provided a nice example of routing a taxi on GitHub.
    You can take a look at it to learn more about the functionality of bidirectional
    streams at [https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的gRPC团队在GitHub上提供了一个很好的示例，演示了如何在GitHub上路由出租车。[https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide)。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our journey by understanding the basics of protocol
    buffers. Then, we came across the protocol buffers language, which has many types,
    such as scalar, enumeration, and repeated types. We look at a few analogies between
    JSON and protocol buffers. We learned that protocol buffers are more memory-efficient
    than the plain JSON data format as the former are binary-based.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过了解协议缓冲的基本知识开始了我们的旅程。然后，我们遇到了协议缓冲语言，它有许多类型，如标量、枚举和重复类型。我们探讨了JSON和协议缓冲之间的几个类比。我们了解到，由于协议缓冲是基于二进制的，因此它们比纯JSON数据格式更节省内存。
- en: Next, we installed the `protoc` compiler to compile our files written in the
    protocol buffer language. Then, we learned how to compile a `.proto` file to generate
    a `.go` file with boilerplate code. This Go file contains all the structs and
    interfaces for the main program to consume. Next, we wrote a protocol buffer for
    an address book and person.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装了`protoc`编译器来编译我们用协议缓冲语言编写的文件。然后，我们学习了如何编译`.proto`文件以生成包含样板代码的`.go`文件。这个Go文件包含了主程序所需的所有结构和接口。接下来，我们为地址簿和人员编写了协议缓冲。
- en: Then, we moved on to gRPC, an RPC technology from Google that uses protocol
    buffers. We saw the benefits of HTTP/2 and gRPC. Then, we defined a gRPC service
    and some data in the form of protocol buffers. Next, we implemented a gRPC server
    and gRPC with respect to the file we generated from `.proto`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了gRPC，这是Google的一种使用协议缓冲区的RPC技术。我们看到了HTTP/2和gRPC的好处。然后，我们定义了一个gRPC服务和一些以协议缓冲区形式的数据。接下来，我们实现了从`.proto`文件生成的gRPC服务器和gRPC。
- en: gRPC technology provides a bidirectional and full-duplex transport mechanism
    for stream data. This means that it can use a single TCP connection for all its
    message transmissions. We implemented one such scenario where the client sends
    a message to a server and the server replies with a stream of messages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC技术为流数据提供了一种双向和全双工的传输机制。这意味着它可以使用单个TCP连接来传输所有消息。我们实现了一个这样的场景，其中客户端向服务器发送消息，服务器以消息流的形式回复。
- en: In the next chapter, we will learn about using PostgreSQL as backend storage
    for an API. There, we'll learn how to work with a relational database and Go.
    We'll also learn how to run a database in the form of a Docker container.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将PostgreSQL用作API的后端存储。在那里，我们将学习如何与关系型数据库和Go一起工作。我们还将学习如何以Docker容器的形式运行数据库。
