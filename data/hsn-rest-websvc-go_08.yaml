- en: Building a REST API Client in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中构建 REST API 客户端
- en: In this chapter, we are going to discuss how Go client applications work in
    depth. We will explore `grequests`, a Python requests-style library that allows
    us to make API calls from the Go code. Then, we'll write some client software
    that uses the GitHub API. While doing that, we'll try to learn about two Go libraries
    called `cli` and `cobra`. After learning about the fundamentals of those packages,
    we'll write an API testing tool for the command line. Then, we'll introduce Redis,
    an in-memory database that we can use to cache the API responses to back up the
    data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入讨论 Go 客户端应用程序的工作原理。我们将探索 `grequests`，这是一个类似 Python requests 的库，允许我们从
    Go 代码中发起 API 调用。然后，我们将编写一些使用 GitHub API 的客户端软件。在这个过程中，我们将尝试了解两个名为 `cli` 和 `cobra`
    的 Go 库。在了解这些库的基本原理之后，我们将编写一个用于命令行的 API 测试工具。然后，我们将介绍 Redis，这是一个内存数据库，我们可以用它来缓存
    API 响应以备份数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Plan for building a REST API client
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 REST API 客户端的计划
- en: Basics for writing a command-line tool in Go
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中编写命令行工具的基础
- en: '`grequests` – a REST API package for Go'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grequests` – Go 的 REST API 包'
- en: Getting comfortable with the GitHub REST API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉 GitHub REST API
- en: Cobra, an advanced CLI library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cobra，一个高级 CLI 库
- en: Creating a CLI tool as an API client for the GitHub REST API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 GitHub REST API 创建 CLI 工具
- en: Using Redis to cache the API data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 缓存 API 数据
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software needs to be pre-installed so that you can run the code
    samples in this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件需要预先安装，以便您可以在本章中运行代码示例：
- en: 'OS: Linux(Ubuntu 18.04)/ Windows 10/Mac OS X >=10.13'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux(Ubuntu 18.04)/ Windows 10/Mac OS X >=10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dep: Go >= 0.5.3 的依赖管理工具'
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter8](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter8).
    Clone the code and use the code samples in the `chapter8` directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter8](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter8)下载本章的代码。克隆代码并使用`chapter8`目录中的代码示例。
- en: Plan for building a REST API client
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 REST API 客户端的计划
- en: So far, we've mainly focused on writing server-side REST APIs. Basically, these
    are server programs. In a few cases, such as gRPC, we need a client. A client
    program takes input from the user and executes some logic. For developing a Go
    client, we should know about the `flag` library in Go. Before that, we should
    be aware of how to make requests for an API from a Go program. In the previous
    chapters, we used different clients such as cURL, Browser, Postman, and so on.
    But how can we turn a Go program into a client?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要关注编写服务器端 REST API。基本上，这些都是服务器程序。在某些情况下，例如 gRPC，我们需要一个客户端。客户端程序从用户那里获取输入并执行一些逻辑。为了开发
    Go 客户端，我们应该了解 Go 中的 `flag` 库。在此之前，我们应该了解如何从 Go 程序中发起 API 请求。在前几章中，我们使用了不同的客户端，如
    cURL、浏览器、Postman 等。但如何将 Go 程序转换为客户端？
- en: Command-line tools are equally important as web user interfaces to perform system
    tasks. In **business-to-business** (**B2B**) companies, the software is packaged
    as a single binary instead of having multiple different packages. As a Go developer,
    you should know how to achieve the goal of writing apps for the command line.
    Then, that knowledge can be invested in creating REST API-related web clients
    easily and elegantly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具与网络用户界面同等重要，用于执行系统任务。在 **企业对企业（B2B**）公司中，软件被打包成一个单一的二进制文件，而不是多个不同的包。作为一名
    Go 开发者，您应该知道如何实现为命令行编写应用程序的目标。然后，您可以将这些知识用于轻松优雅地创建与 REST API 相关的 Web 客户端。
- en: Let's explore the basics of how we can write **command-line interface **(**CLI**)
    tools in Go.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在 Go 中编写 **命令行界面（CLI**）工具的基础。
- en: Basics for writing a command-line tool in Go
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中编写命令行工具的基础
- en: Go provides a built-in library called `flag` for writing CLI tools. It refers
    to the command-line flags. Since it is already packed with the Go distribution,
    there is no need to install anything externally. The `flag` package has multiple
    functions, such as `Int` and `String`, to handle the respective type input that's
    supplied as a command-line flag. Let's suppose that we collect a name from the
    user and print it back to the console.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个名为`flag`的内置库，用于编写CLI工具。它指的是命令行标志。由于它已经包含在Go发行版中，因此无需外部安装任何东西。`flag`包具有多个函数，如`Int`和`String`，用于处理作为命令行标志提供的相应类型输入。假设我们从用户那里收集一个名字并将其打印回控制台。
- en: 'To do this, we can use the `flag.String` method, as shown in the following
    code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用`flag.String`方法，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s write a short program to illustrate the `flag` API in more detail:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简短的程序来更详细地说明`flag`API：
- en: 'Create a file called `flagExample.go` in the `GOPATH`, as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GOPATH`中创建一个名为`flagExample.go`的文件，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can use the `flag` package''s `String` method to receive a string from
    the command line as an option, like so:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`flag`包的`String`方法从命令行作为选项接收一个字符串，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this program, we are creating a flag called `name`. It is a string pointer.
    `flag.String` takes three arguments. The first argument is the name of the option.
    The second and third method arguments are the default values of that flag and
    the help text, respectively. We have asked the program to parse all the flag pointers
    in the main block.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了一个名为`name`的标志。它是一个字符串指针。`flag.String`接受三个参数。第一个参数是选项的名称。第二个和第三个参数是该标志的默认值和帮助文本。我们已要求程序在主块中解析所有标志指针。
- en: When we run the program, it maps the values supplied from the command-line options
    to the respective variables. To access the value of a flag in code, we use `*`,
    which is a pointer value reference; for example `*name` in the preceding code
    block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，它会将命令行选项提供的值映射到相应的变量。要在代码中访问标志的值，我们使用`*`，这是一个指针值引用；例如，在先前的代码块中的`*name`。
- en: 'Build and then run the program using the following command:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建并运行程序：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This creates a binary in the `basic` directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`basic`目录中创建了一个二进制文件。
- en: 'We can run it like a normal executable, as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像正常的可执行文件一样运行它，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It gives us the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了以下输出：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you may have noticed, we didn't pass the `name` argument to the command.
    However, we did assign the default value to that argument. Go's flag takes the
    default value and proceeds further.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，我们没有将`name`参数传递给命令。然而，我们确实为该参数分配了默认值。Go的标志默认值会继续执行。
- en: 'Now, in order to see what options are available and to find out about them,
    we need to ask for help, like this:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了查看可用的选项并了解它们，我们需要请求帮助，如下所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the reason why we passed the help text as the third argument for the
    flag command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们将帮助文本作为标志命令的第三个参数传递的原因。
- en: In Windows, `.exe` will be generated when we build a `.go` file. After that,
    from the command line, we can run the program by calling the program name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，当我们构建`.go`文件时，将生成`.exe`文件。之后，从命令行，我们可以通过调用程序名称来运行程序。
- en: 'Now, try to pass the `name` option with a value:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试传递带有值的`name`选项：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both styles work fine and the output prints the supplied value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 两种样式都可以正常工作，输出会打印出提供的值：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we wish to pass multiple options, modify the preceding program in the `basic`
    directory to add age, and call it `flagExampleMultipleParam.go`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们希望传递多个选项，请将`basic`目录中的先前的程序修改为添加年龄，并将其命名为`flagExampleMultipleParam.go`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This takes two options, with the addition of a different type. If we build
    and run this, we''ll see the following output:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这有两个选项，加上不同类型的添加。如果我们构建并运行它，我们将看到以下输出：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is exactly what we expected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们预期的。
- en: 'Instead of using pointers, we can bind a variable to the parsed output. This
    binding is done through the `init()` function, which runs in a Go program, irrespective
    of whether the main function exists or not:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以不使用指针，而是通过`init()`函数将变量绑定到解析后的输出。这种绑定是通过`init()`函数完成的，它在Go程序中运行，无论是否存在`main`函数：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this way, the value will be directly stored in the variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，值将直接存储在变量中。
- en: 'Completely rewriting the preceding program to create a new one using the `init()`
    function can be seen in the following code snippet:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全重写先前的程序以使用`init()`函数创建一个新的程序，可以在以下代码片段中看到：
- en: '`basic/initFlag.go`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`basic/initFlag.go`'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output is exactly the same as it was for the preceding program. Here, instead
    of using pointers, we are able to load data directly into our variables.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与先前的程序完全相同。在这里，我们能够直接将数据加载到我们的变量中，而不是使用指针。
- en: In Go, execution starts from the main program. However, a Go program can have
    any number of `init` functions. If a package has an `init` function in it, that
    will be executed before the `main` function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，执行从主程序开始。然而，一个Go程序可以有任意数量的`init`函数。如果一个包中有一个`init`函数，那么它将在`main`函数之前执行。
- en: This `flag` library is very basic to work with. However, in order to write advanced
    client applications, we need to take the help of a CLI package. In the next section,
    we'll explore a package called `cli` that will do just this.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`flag`库非常易于使用。然而，为了编写高级客户端应用程序，我们需要借助CLI包的帮助。在下一节中，我们将探讨一个名为`cli`的包，它将做这件事。
- en: CLI – a package for building beautiful clients
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI – 用于构建美观客户端的包
- en: The `cli` package is the next step for a Go developer after working with the
    `flag` package. It provides an intuitive API for creating command-line applications
    with ease. It allows a Go program to collect arguments and flags. It's quite handy
    for designing complex applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`cli`包是Go开发者在使用`flag`包之后的下一步。它提供了一个直观的API，可以轻松地创建命令行应用程序。它允许Go程序收集参数和标志。对于设计复杂应用程序来说，它非常方便。'
- en: 'First, create a directory for our example programs. For our basic CLI example,
    create the following directory:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为我们的示例程序创建一个目录。对于我们的基本CLI示例，创建以下目录：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To install the package, we use the `dep` tool. Initialize the tool first and
    then add the `cli` package as the dependency:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此包，我们使用`dep`工具。首先初始化工具，然后将`cli`包作为依赖项添加：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we can write a program that does exactly the same job as the preceding
    flag example. Create a file called `example1/main.go`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个程序，它的工作方式与先前的标志示例完全相同。创建一个名为`example1/main.go`的文件。
- en: 'The `cli` package provides three major elements:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`cli`包提供了三个主要元素：'
- en: App
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: Flag
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标志
- en: Action
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行动
- en: '**Apps** are used for defining namespaces in applications. A **flag** is an
    actual container that stores options passed. **Action** is a function that executes
    on collected options. Let''s look at the following example code for further insight.
    Here, we''re trying to use the `cli` API to create App, Flags, and Action. We
    have to import the package into our program:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apps**用于在应用程序中定义命名空间。**标志**是一个实际的容器，用于存储传递的选项。**Action**是一个在收集的选项上执行的函数。让我们看看以下示例代码以获得更深入的了解。在这里，我们试图使用`cli`
    API创建App、Flags和Action。我们必须将包导入到我们的程序中：'
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is lengthier than the one we saw previously, but it is more expressive.
    Here, we created a new app using the `cli.NewApp` function. This creates a new
    struct. We need to attach parameters to this struct, specifically the `Flags`
    struct and the `Action` function. The `Flags` struct is a list that defines all
    possible flags for this application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这比我们之前看到的要长，但表达性更强。在这里，我们使用`cli.NewApp`函数创建了一个新的应用程序。这创建了一个新的结构体。我们需要将参数附加到这个结构体上，特别是`Flags`结构体和`Action`函数。`Flags`结构体是一个列表，定义了此应用程序的所有可能的标志。
- en: 'The structure of `Flag` from GoDoc ([https://godoc.org/github.com/urfave/cli#Flag](https://godoc.org/github.com/urfave/cli#Flag))
    is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GoDoc中`Flag`的结构如下（[https://godoc.org/github.com/urfave/cli#Flag](https://godoc.org/github.com/urfave/cli#Flag)）：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The inbuilt structs, such as `StringFlag` and `IntFlag`, implement this `Flag`
    interface. The `Name`, `Value`, and `Usage` fields are straightforward. They are
    similar to the ones we used in the `flag` package. The `Action` function takes
    the `cli.Context` argument.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的结构体，如`StringFlag`和`IntFlag`，实现了这个`Flag`接口。`Name`、`Value`和`Usage`字段很简单。它们与我们使用的`flag`包中的类似。`Action`函数接受`cli.Context`参数。
- en: 'The context object holds any information regarding flags and command-line arguments.
    The `c.String`, `c.Int`, and other functions are used to look up the flag variables.
    For example, in the preceding program, `c.String("name")` fetches a flag variable
    whose name is `name`. This program runs the same as the previous flag example.
    You can build and run the program like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文对象持有有关标志和命令行参数的任何信息。`c.String`、`c.Int`和其他函数用于查找标志变量。例如，在先前的程序中，`c.String("name")`获取一个名为`name`的标志变量。这个程序运行效果与先前的标志示例相同。你可以这样构建和运行程序：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's it regarding the basic usage of the `cli` package. This package also
    provides advanced combinations of flags and arguments. We'll look at this in the
    next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`cli`包的基本用法就这么多。此包还提供了标志和参数的高级组合。我们将在下一节中查看这一点。
- en: Collecting command-line arguments in the CLI
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CLI中收集命令行参数
- en: 'In bash terminology, there is a difference between command-line arguments and
    flags. The following diagram clearly specifies the distinction between them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash术语中，命令行参数和标志之间有一个区别。以下图表清楚地说明了它们之间的区别：
- en: '![](img/df0a34bf-d4fc-4c65-a291-af487838555c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df0a34bf-d4fc-4c65-a291-af487838555c.png)'
- en: 'Suppose that we have a command-line app called `storeMarks` for saving the
    marks of a student. It has a flag (called `save`) to specify whether details should
    be persisted or not. The arguments that are given are the name and actual marks
    of the student. We already saw how to collect the flag values in the program.
    In this section, we will learn how to collect program arguments in an expressive
    way. Follow these steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`storeMarks`的命令行应用程序，用于保存学生的分数。它有一个标志（称为`save`），用于指定是否应该持久化详细信息。提供的参数是学生的姓名和实际分数。我们已经看到了如何在程序中收集标志值。在本节中，我们将学习如何以表达性的方式收集程序参数。按照以下步骤操作：
- en: 'For collecting arguments, we use the `c.Args` function, where `c` is the `cli`
    context of the `Action` function. Add a new directory called `example2` for our
    project:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于收集参数，我们使用`c.Args`函数，其中`c`是`Action`函数的`cli`上下文。为我们的项目添加一个名为`example2`的新目录：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, create a program file called `example2/main.go`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`example2/main.go`的程序文件。
- en: 'Define the app in the main block `cli.NewApp` creates a new application:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主块中定义应用程序 `cli.NewApp`创建一个新的应用程序：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we define the flags on the `app.cli.Flag` takes a few predefined flags,
    such as integer flag or string flag. Here, we need a string flag:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义`app.cli.Flag`上的标志，它包含一些预定义的标志，例如整数标志或字符串标志。在这里，我们需要一个字符串标志：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we have to define actions on the app. Actions are the control structures
    that define the dynamics of logic upon given flags. These options are as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须在应用程序上定义操作。操作是定义给定标志上逻辑动态的控制结构。这些选项如下：
- en: '`--save=no`, which skips saving arguments to the database'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--save=no`，跳过将参数保存到数据库'
- en: '`--save=yes` (or) no flag, which saves arguments to the database:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--save=yes`（或）没有标志，将保存参数到数据库：'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All the preceding statements will go into the main function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述语句都将进入主函数。
- en: 'We have to run the app using `app.Run` to make the tool run and collect arguments:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须使用`app.Run`运行应用程序，以便使工具运行并收集参数：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`c.Args` stores all the arguments supplied with the command. Since we know
    the order of the arguments, we deduced that the first argument is the name, and
    the remaining values are the marks. We are checking a flag called `save` to save
    those details in a database or not (we don''t have database logic here, for simplicity).
    `app.Version` sets the version of the tool. Everything else remains the same as
    the previous `cli` introductory example.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`c.Args`存储与命令一起提供的所有参数。由于我们知道参数的顺序，我们推断第一个参数是名称，其余的值是分数。我们正在检查一个名为`save`的标志，以确定是否将这些详细信息保存到数据库中（为了简单起见，这里没有数据库逻辑）。`app.Version`设置工具的版本。其他所有内容都与之前的`cli`入门示例相同。'
- en: 'First, let''s build the program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建程序：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, from the `example2` directory, run the built tool by passing the flag
    and its arguments:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`example2`目录中，通过传递标志及其参数来运行构建的工具：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we don''t give a flag, the default is `save=no`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供标志，默认是`save=no`：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So far, everything looks good. But how can we make the command-line tool display
    help text when a user needs it? The `cli` library creates a nice help section
    for the given app. If you type in any of these commands, some help text will be
    auto-generated:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都很不错。但我们如何使命令行工具在用户需要时显示帮助文本呢？`cli`库为给定的应用程序创建了一个很好的帮助部分。如果您输入以下任何命令，将自动生成一些帮助文本：
- en: '`./storeMarks -h`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks -h`'
- en: '`./storeMarks -help`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks -help`'
- en: '`./storeMarks --help`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks --help`'
- en: '`./storeMarks help`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./storeMarks help`'
- en: 'A nice help section appears, like the one shown in the following code, which
    shows version details and available flags (global options), commands, and arguments:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一个很好的帮助部分，如下面的代码所示，它显示了版本细节和可用的标志（全局选项）、命令和参数：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `cli` package simplifies client application development. It is much faster
    and intuitive than the internal `flag` package.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`cli`包简化了客户端应用程序的开发。它比内部的`flag`包更快、更直观。'
- en: Command-line tools are binaries that are generated after building the program.
    They need to be run with the options. It is like any system program and not related
    to the Go compiler anymore. Make sure you build them for the target architecture
    where you want to run them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具是在构建程序后生成的二进制文件。它们需要带选项运行。它们就像任何系统程序一样，不再与Go编译器相关。确保你为想要运行它们的目标架构构建它们。
- en: We can use the `flag` package or `cli` to build a REST API client. However,
    for advanced applications, we might need a robust library with rich features.
    In the next section, we'll explore such a library called `cobra`, which is used
    to create command-line tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`flag`包或`cli`来构建REST API客户端。然而，对于高级应用程序，我们可能需要一个功能丰富的强大库。在下一节中，我们将探讨这样一个名为`cobra`的库，它用于创建命令行工具。
- en: Cobra, an advanced CLI library
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cobra，一个高级CLI库
- en: 'Like `cli`, `cobra` is a package for writing client binaries but takes a different
    approach. In cobra, we have to create separate commands and use them in our main
    app. We can install `cobra` using dep. Let''s create our cobra project repository:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与`cli`一样，`cobra`是一个用于编写客户端二进制的包，但采用不同的方法。在cobra中，我们必须创建单独的命令并在我们的主应用程序中使用它们。我们可以使用dep安装`cobra`。让我们创建我们的cobra项目仓库：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's create another directory called `cmd` in the project for defining
    commands. In cobra apps, there will be a root command. This can have multiple
    subcommands. We can implement the same example we used for the flag package. Input
    the name and age from the command line using cobra.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在项目中创建一个名为`cmd`的另一个目录来定义命令。在cobra应用程序中，将有一个根命令。这可以有多个子命令。我们可以实现与标志包相同的示例。使用cobra从命令行输入姓名和年龄。
- en: 'Let''s define a root command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个根命令：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This creates a command with "details" as a command. It has few properties,
    such as `Use`, `Short`, `Long`, `Args` and, `Run`. See the following table to
    find their exact meaning:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为“details”的命令。它有几个属性，如`Use`、`Short`、`Long`、`Args`和`Run`。请参阅以下表格以了解它们的精确含义：
- en: '| **Parameter** | **Meaning** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **含义** |'
- en: '| `Use` | Name of the command |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `Use` | 命令名称 |'
- en: '| `Short` | Short description |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `Short` | 短描述 |'
- en: '| `Long` | Long description |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `Long` | 长描述 |'
- en: '| `Args` | Number of arguments expected |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `Args` | 预期参数数量 |'
- en: '| `Run` | Process inputs after collection |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `Run` | 收集后处理输入 |'
- en: 'In the `Run` command, we are expecting two arguments: `name` and `age`. However,
    in order to collect them, we have to define them. Where can we define them? Cobra
    asks the developer to define them in a special function called `Execute`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Run`命令中，我们期望两个参数：`name`和`age`。然而，为了收集它们，我们必须定义它们。在哪里定义它们？Cobra要求开发者在一个特殊函数`Execute`中定义它们：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We need to use the previously defined root command to attach the flags. `PersistentFlags`
    has various types that can be used to collect flags. Now, create the main program
    and import this command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用之前定义的根命令来附加标志。`PersistentFlags`有各种类型，可以用来收集标志。现在，创建主程序并导入此命令：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, in this file, you can import the command and call the `Execute` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个文件中，你可以导入命令并调用`Execute`函数：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That''s it. We have a client application that can be used to collect the name
    and age of the student. When we build this, it generates a binary:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们有一个客户端应用程序，可以用来收集学生的姓名和年龄。当我们构建它时，它会生成一个二进制文件：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can run that binary as a client tool:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以作为客户端工具运行该二进制文件：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It prints a log to the console:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它将日志打印到控制台：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also pass flags in a different order:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以不同的顺序传递标志：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can also create many subcommands on top of this command and do a lot more.
    This is just a basic example. We will look at an advanced example in the next
    section, where you will implement the same with cobra.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这个命令之上创建许多子命令并做更多的事情。这只是一个基本示例。在下一节中，我们将看到一个高级示例，你将使用cobra实现相同的操作。
- en: Later in this chapter, we'll discuss creating REST clients in Go. Before that,
    you should know how to make HTTP requests from a Go program. Although this is
    possible with Go's built-in `net/http` package, we need a more intuitive package.
    In the next section, we'll look at `grequests`, a similar package to Python's
    `Requests` for making HTTP requests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论在Go中创建REST客户端。在那之前，你应该知道如何从Go程序中发送HTTP请求。尽管这可以通过Go的内置`net/http`包实现，但我们需要一个更直观的包。在下一节中，我们将查看`grequests`，这是一个类似于Python的`Requests`的用于发送HTTP请求的包。
- en: grequests a REST API package for Go
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: grequests，Go的REST API包
- en: The developers who worked on Python know about the `Requests` library. It is
    a clean, short library that is not included in the standard library of Python.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python上工作的开发者都知道`Requests`库。这是一个干净、简洁的库，它不包括在Python的标准库中。
- en: The Go `grequests` package is inspired by `Requests`. It provides a simple set
    of functions, using which we can make API requests such as `GET`, `POST`, `PUT`,
    and `DELETE` from our Go code. Using `grequests` allows us to encapsulate the
    in-built HTTP request and response.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`grequests`包受`Requests`的启发。它提供了一套简单的函数，通过这些函数我们可以从Go代码中发出`GET`、`POST`、`PUT`和`DELETE`等API请求。使用`grequests`允许我们封装内置的HTTP请求和响应。
- en: 'Create the project directory and install `grequests` using the `dep` tool:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dep`工具创建项目目录并安装`grequests`：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To install the `grequests` package for Go, run the following `dep` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Go安装`grequests`包，请运行以下`dep`命令：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s write a basic program illustrating the use of the `grequests` library
    to make a `GET` request to a REST API. It uses the `Get` method from the `grequests`
    library:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个基本程序，说明如何使用`grequests`库向REST API发出`GET`请求。它使用了`grequests`库中的`Get`方法：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `grequests` package contains methods for performing all REST actions. The
    preceding program uses the `Get` function from the package. It takes two function
    arguments. The first one is the URL of the API, while the second one is the request
    parameters object. Since we are not passing any request parameters, the second
    argument is `nil` here. `resp` is returned from the request, and it has a function
    called `String()` that returns the response body:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`grequests`包包含执行所有REST操作的方法。前面的程序使用了包中的`Get`函数。它接受两个函数参数。第一个参数是API的URL，而第二个参数是请求参数对象。由于我们没有传递任何请求参数，这里的第二个参数是`nil`。`resp`是从请求返回的，它有一个名为`String()`的函数，该函数返回响应体：'
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is the JSON response that''s returned by `httpbin`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`httpbin`返回的JSON响应：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we understood how to use `grequests`. However, to leverage its power,
    we should be aware of its API (functions).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们了解了如何使用`grequests`。然而，为了利用其功能，我们应该了解其API（函数）。
- en: In the next section, we'll look at the `grequests` library in more detail. We'll
    learn how request parameters and response properties are configured.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地了解`grequests`库。我们将学习如何配置请求参数和响应属性。
- en: API overview of grequests
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: grequests API概述
- en: 'The most important thing to explore in `grequests` is not the HTTP functions,
    but the `RequestOptions` struct. It is a very big struct that holds various kinds
    of information regarding the type of API method being used. If the REST method
    is `GET`, `RequestOptions` holds the `Params` property. If the method is a `POST`,
    the struct will have a `Data` property. Whenever we make a request to a URL endpoint,
    we get a response back. Let''s look at the structure of the response. From the
    official documentation, the response looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grequests`中要探索的最重要的事情不是HTTP函数，而是`RequestOptions`结构体。这是一个非常大的结构体，包含有关正在使用的API方法类型的各种信息。如果REST方法是`GET`，则`RequestOptions`包含`Params`属性。如果方法是`POST`，则结构体将有一个`Data`属性。每次我们向URL端点发出请求时，我们都会得到一个响应。让我们看看响应的结构。根据官方文档，响应看起来是这样的：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Ok` property of the response holds information about whether a request
    was successful or not. If something went wrong, an error will be found in the
    `Error` property. `RawResponse` is the Go HTTP response that will be used by other
    functions of the `grequests` response. `StatusCode` and `Header` store the status
    codes of the response and header details, respectively. There are a few functions
    in `Response` that are useful
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的`Ok`属性包含有关请求是否成功的信息。如果出现问题，`Error`属性中将会找到错误。`RawResponse`是Go HTTP响应，它将被`grequests`响应的其他函数使用。`StatusCode`和`Header`分别存储响应的状态码和头部细节。`Response`中有一些有用的函数
- en: '`Response.JSON()`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.JSON()`'
- en: '`Response.XML()`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.XML()`'
- en: '`Response.String()`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.String()`'
- en: '`Response.Bytes()`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response.Bytes()`'
- en: 'The data from the response can be filled into a generic map by the preceding
    functions. Let''s take a look at an example, that is `requestExample/jsonRequest.go`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数可以将响应数据填充到一个通用映射中。让我们看看一个例子，即`requestExample/jsonRequest.go`：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we declared an interface to hold the JSON values. Then, we populated `returnData`
    (empty interface) using the `resp.JSON` function. This program prints the map
    instead of plain JSON.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个接口来保存JSON值。然后，我们使用`resp.JSON`函数填充`returnData`（空接口）。这个程序打印的是映射而不是纯JSON。
- en: 'You can find out about all the available options by looking at the project
    documentation: [https://godoc.org/github.com/levigross/grequests](https://godoc.org/github.com/levigross/grequests).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看项目文档来了解所有可用的选项：[https://godoc.org/github.com/levigross/grequests](https://godoc.org/github.com/levigross/grequests)。
- en: In the next section, we'll understand how GitHub API version 3 works and use
    our knowledge of command-line arguments to develop a client that fetches useful
    information from the GitHub API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解GitHub API版本3的工作原理，并利用我们对命令行参数的了解来开发一个从GitHub API获取有用信息的客户端。
- en: Getting comfortable with the GitHub REST API
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉GitHub REST API
- en: GitHub provides a well-written, easy to consume REST API. It opens up the data
    about users, repositories, repository statistics, and so on to the clients through
    well-formed API. The current stable version is v3\. The API documentation can
    be found at [https://developer.github.com/v3/](https://developer.github.com/v3/).
    The root endpoint of the API is `https://api.github.com`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub提供了一个编写良好、易于消费的REST API。它通过良好的API向客户端开放了有关用户、仓库、仓库统计等信息。当前稳定版本是v3。API文档可以在[https://developer.github.com/v3/](https://developer.github.com/v3/)找到。API的根端点是`https://api.github.com`。
- en: All GitHub API routes will be appended to this root endpoint. Let's learn how
    to make a few queries and get data. For an unauthenticated client, the rate limit
    is 60/hour, whereas, for clients who are passing `client_id` (we can get it from
    their GitHub account console), it is 5,000/hour.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GitHub API路由都将附加到这个根端点上。让我们学习如何进行一些查询并获取数据。对于未经身份验证的客户端，速率限制是每小时60次，而对于传递`client_id`（我们可以从他们的GitHub账户控制台获取）的客户端，则是每小时5,000次。
- en: If you have a GitHub account (if not, it is highly recommended that you create
    one), you can find the access tokens in the Your Profile | Personal Access Tokens
    section or by visiting [https://github.com/settings/tokens](https://github.com/settings/tokens).
    Create a new access token using the Generate new token button. You'll be asked
    for various permissions for different resources. Tick the `repo` and `gist` options.
    A new personal token string will be generated for you. Save it somewhere safe
    and private. The token that was generated can now be used to access the GitHub
    API (for a longer rate limit).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有GitHub账户（如果没有，强烈建议您创建一个），您可以在“您的资料”|“个人访问令牌”部分找到访问令牌，或者通过访问[https://github.com/settings/tokens](https://github.com/settings/tokens)来找到。使用“生成新令牌”按钮创建一个新的访问令牌。您将被要求为不同的资源提供各种权限。勾选`repo`和`gist`选项。将为您生成一个新的个人令牌字符串。将其保存在安全且私密的地方。生成的令牌现在可以用来访问GitHub
    API（以更长的速率限制）。
- en: 'The next step is to export that access token as an environment variable, **`GITHUB_TOKEN`**.
    You can set it using the `export` command, like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将访问令牌导出为环境变量，**`GITHUB_TOKEN`**。您可以使用`export`命令来设置它，如下所示：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`YOUR_GITHUB_ACCESS_TOKEN` is what was generated and saved from the GitHub
    account. You can also add the preceding export command to your **`~/.bashrc`**
    file to make it persistent from the next shell launch.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`YOUR_GITHUB_ACCESS_TOKEN`是从GitHub账户生成并保存的。您还可以将前面的导出命令添加到您的**`~/.bashrc`**文件中，以便在下次shell启动时保持持久性。'
- en: 'Let''s write a program for fetching all the repositories of a user:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来获取一个用户的全部仓库：
- en: 'Create a new directory and program, like so:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录和程序，如下所示：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We should use this logic to make a `GET` request from a Go program. This program
    fetches repository information from the GitHub API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用这个逻辑从Go程序中发出`GET`请求。此程序从GitHub API获取仓库信息。
- en: 'Create a struct that will hold the repository''s information. Let''s call it
    `Repo`. We will also define an environment variable that will fetch `GITHUB_TOKEN`.
    Now, we can create request options from that token. For GitHub to authenticate
    the origin of the `GET` request, we should pass an argument called `Auth` to the
    `RequestOptions` struct. This can be seen in the following code block:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个结构体来保存仓库的信息。让我们称它为`Repo`。我们还将定义一个环境变量来获取`GITHUB_TOKEN`。现在，我们可以从这个令牌创建请求选项。为了使GitHub验证`GET`请求的来源，我们应该将一个名为`Auth`的参数传递给`RequestOptions`结构体。这可以在以下代码块中看到：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, define a function handler that takes a URL as input and returns the GitHub
    API `Response`. It makes a simple GET request to the given URL location. We use
    the `grequests` package to make API calls to GitHub:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个函数处理程序，它接受一个URL作为输入并返回GitHub API的`Response`。它会对给定的URL位置执行一个简单的GET请求。我们使用`grequests`包来对GitHub进行API调用：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, define the main block, which passes a GitHub link to the preceding function
    and stores the response in the `Repo` struct:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义主块，它将 GitHub 链接传递给前面的函数，并将响应存储在 `Repo` 结构体中：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`Response` consists of multiple repositories, so we have to load the response
    JSON into an array of `Repo`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 包含多个仓库，因此我们必须将响应 JSON 加载到 `Repo` 的数组中。'
- en: 'If you run the preceding program, you will receive the following output:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行前面的程序，你将收到以下输出：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding program illustrates how we can query the GitHub API and load that
    data into our custom struct called `Repo`. The JSON that's returned contains many
    fields, but for simplicity's sake, we are just picking a few important fields.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序说明了我们如何查询 GitHub API 并将数据加载到我们自定义的 `Repo` 结构体中。返回的 JSON 包含许多字段，但为了简单起见，我们只选择了一些重要的字段。
- en: So far, we've seen how to make HTTP requests to the GitHub API. In the next
    section, we'll create a client that makes HTTP requests to the GitHub API based
    on user commands.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何向 GitHub API 发送 HTTP 请求。在下一节中，我们将创建一个客户端，根据用户命令向 GitHub API 发送
    HTTP 请求。
- en: Creating a CLI tool as an API client for the GitHub REST API
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 CLI 工具作为 GitHub REST API 的 API 客户端
- en: 'After looking at this example, we''ll be able to easily access the GitHub API
    from our Go client. We can combine both of the techniques we''ve learned about
    in this chapter to come up with a command-line tool that consumes the GitHub API.
    Let''s create a new command-line application that does the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个示例之后，我们将能够轻松地从我们的 Go 客户端访问 GitHub API。我们可以结合本章中我们学到的两种技术来创建一个消耗 GitHub
    API 的命令行工具。让我们创建一个新的命令行应用程序，执行以下操作：
- en: Provides options to get repository details by username
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供通过用户名获取仓库详情的选项
- en: Uploads a file to GitHub gist (text snippets) with a given description
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的描述将文件上传到 GitHub Gist（文本片段）
- en: Authenticates using a personal access token
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用个人访问令牌进行身份验证
- en: We'll use the `cli` package and `grequests` to build this tool. You can re-implement
    the same example in cobra too.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `cli` 包和 `grequests` 来构建这个工具。你还可以在 cobra 中重新实现相同的示例。
- en: Gist are snippets provided by GitHub that store text content. For more details,
    visit [https://gist.github.com](https://gist.github.com).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Gist 是 GitHub 提供的存储文本内容的小片段。有关更多详情，请访问 [https://gist.github.com](https://gist.github.com)。
- en: 'Create a directory called `gitTool` in this chapter''s directory and add the
    `main` file to it, like so:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的目录中创建一个名为 `gitTool` 的目录，并将 `main` 文件添加到其中，如下所示：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, let''s define the main block with a few `cli` commands so that we can
    input commands for repository details and gist upload actions. Here, we''re using
    `app` from the `cli` package and creating `Commands`. We''re defining two commands
    here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义主块，包含一些 `cli` 命令，这样我们就可以输入用于仓库详细信息和大纲上传操作的命令。在这里，我们使用 `cli` 包中的 `app`
    创建 `Commands`。我们在这里定义了两个命令：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, `getStats` and `createGist` are the functions that are used
    for actual API calls. We''ll define these next, but, before we do, we should prepare
    a few data structures that hold information about the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`getStats` 和 `createGist` 是用于实际 API 调用的函数。我们将在下面定义这些函数，但在定义之前，我们应该准备一些数据结构来保存有关以下信息的数据：
- en: The repository
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库
- en: The file to upload as a gist
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要作为大纲上传的文件
- en: Gist on GitHub (list of files)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 上的 Gist（文件列表）
- en: 'Now, we need to create three structs that hold the preceding information, as
    follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建三个结构体来保存前面的信息，如下所示：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, create a request option that builds a header and uses GitHub tokens from
    environment variables:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个请求选项，构建一个头并使用环境变量中的 GitHub 令牌：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, it''s time to write the `getStats` and `createGist` functions. Let''s
    code `getStats` first:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写 `getStats` 和 `createGist` 函数了。让我们先编写 `getStats`：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function makes a `GET` request and returns the response object. The code
    is simple and is a generic GET request.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数发送一个 `GET` 请求并返回响应对象。代码很简单，是一个通用的 GET 请求。
- en: 'Now, let''s look at `createGist`. Here, we have to do more. A gist contains
    multiple files. Due to this, we need to do the following in our program:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `createGist`。在这里，我们必须做更多的事情。一个大纲包含多个文件。因此，在我们的程序中，我们需要做以下事情：
- en: Get the list of files from command-line arguments.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行参数中获取文件列表。
- en: Read the file content and store it in a map of files with the filename as the
    key and content as the value.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件内容并将其存储在以文件名为键、内容为值的文件映射中。
- en: Convert this map into JSON.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个映射转换为 JSON。
- en: Make a `POST` request to the Gist API with the preceding JSON as the body.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的 JSON 作为正文向 Gist API 发送 `POST` 请求。
- en: 'We have to make a `POST` request to the Gist API. The `createGist` function
    takes a URL string and other arguments. The function should return the response
    of the `POST` request:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须向Gist API发出`POST`请求。`createGist`函数接受一个URL字符串和其他参数。该函数应返回`POST`请求的响应：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We are using `grequests.Post` to pass files to GitHub''s Gist API. It returns
    `Status: 201 Created` on successful creation with gist details in the response
    body.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用`grequests.Post`将文件传递给GitHub的Gist API。在成功创建并包含在响应体中的gist详细信息时，它返回`Status:
    201 Created`。'
- en: 'Now, let''s build the command-line tool:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建命令行工具：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This creates a binary in the same directory. If we type in `./gitTool -h`,
    it shows us the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在同一目录中创建一个二进制文件。如果我们输入`./gitTool -h`，它将显示以下内容：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you take a look at the help commands, you''ll see two commands, `fetch`
    and `create`. The `fetch` command fetches the repositories of a given user, while
    the `create` command creates a `gist` with the supplied files. Let''s create two
    sample files in the same directory of the program to test the `create` command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看帮助命令，你会看到两个命令，`fetch`和`create`。`fetch`命令检索给定用户的仓库，而`create`命令使用提供的文件创建一个`gist`。让我们在程序的同一目录中创建两个示例文件来测试`create`命令：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the tool with the first command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令运行工具：
- en: '[PRE58]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This returns all the repositories that belong to the great Linus Torvalds.
    The log message prints the struct that was filled:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回属于伟大的林纳斯·托瓦兹的所有仓库。日志消息打印出填充的结构体：
- en: '[PRE59]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let''s check the second command. This creates the `gist` with the given
    description and a set of files as arguments:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查第二个命令。这个命令使用给定的描述和一组文件作为参数创建`gist`：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It returns JSON details about the created gist. It is a very lengthy JSON,
    so the output has been skipped here. Now, if you open your [gist.github.com](https://gist.github.com/)
    account, you will see the created `gist`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回有关创建的gist的JSON详细信息。这是一个非常长的JSON，所以这里省略了输出。现在，如果你打开你的[gist.github.com](https://gist.github.com/)账户，你会看到创建的`gist`：
- en: '![](img/ba9cac57-bc13-4037-b122-ed603ce99890.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba9cac57-bc13-4037-b122-ed603ce99890.png)'
- en: 'Remember, the GitHub `gists` API expects JSON data as a body in the following
    format:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，GitHub的`gists`API期望以下格式的JSON数据作为正文：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: For any Go program to read and comprehend quickly, follow the `main` function
    and then step into the other functions. By doing this, we can read the code from
    the whole application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Go程序快速读取和理解，请遵循`main`函数，然后进入其他函数。通过这样做，我们可以从整个应用程序中阅读代码。
- en: As an exercise, build a command-line tool for the preceding requirements in
    `cobra`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，在`cobra`中根据前面的要求构建一个命令行工具。
- en: Using Redis to cache the API data
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis缓存API数据
- en: '**Redis** is an in-memory database that can store key/value pairs. It best
    suits the use case of storing heavy read-intensive data. For example, news agencies
    such as the BBC and The Guardian show the latest news articles on their dashboard.
    Their traffic is high and, if documents are to be fetched from the database, they
    have to maintain a huge cluster of databases at all times.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**是一个内存数据库，可以存储键/值对。它最适合存储大量读密集型数据的使用场景。例如，BBC和《卫报》等新闻机构在他们的仪表板上显示最新的新闻文章。他们的流量很高，如果需要从数据库中检索文档，他们必须始终维护一个巨大的数据库集群。'
- en: Since the given set of news articles does not change (for hours), an agency
    can maintain a cache of articles. When the first customer visits the page, a copy
    is pulled from the DB, placed in the Redis cache, and then sent to the browser.
    Then, for another customer, the news agency server reads content from Redis instead
    of hitting the DB. Since Redis runs in the primary memory, latency is minimal.
    As a result, the customer sees faster page loads. The benchmarks on the web can
    tell us more about how efficiently a site can optimize its contents.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于给定的新闻文章集合在数小时内不会改变，一个机构可以维护一个文章缓存。当第一个客户访问页面时，文章的副本从数据库中提取出来，放置在Redis缓存中，然后发送到浏览器。然后，对于另一个客户，新闻机构服务器从Redis读取内容而不是直接击中数据库。由于Redis运行在主内存中，延迟最小。因此，客户看到页面加载更快。网络上的基准测试可以告诉我们一个网站如何有效地优化其内容。
- en: What if data is no longer relevant in Redis? (For example, the agency updated
    its top stories.) Redis provides a way to expire the `keys:values` stored in it.
    We can run a scheduler that updates Redis whenever the expiration time has passed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据在Redis中不再相关怎么办？（例如，机构更新了其头条新闻。）Redis提供了一种使存储在其中的`keys:values`过期的方法。我们可以运行一个调度器，在过期时间过后更新Redis。
- en: Similarly, we can cache the third-party API responses for the given request
    (`GET`). We need to do this because third-party systems such as GitHub have a
    rate limit (telling us to be conservative). For a given `GET URL`, we can store
    the `URL` as a key and the `Response` as a value. Whenever the same request is
    given within the next time (before key expiration), just pull the response out
    of Redis instead of hitting the GitHub servers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以缓存给定请求（`GET`）的第三方 API 响应。我们需要这样做，因为像 GitHub 这样的第三方系统有速率限制（建议我们保守）。对于给定的
    `GET URL`，我们可以将 `URL` 存储为键，将 `Response` 存储为值。当在下一个时间（在键过期之前）收到相同的请求时，只需从 Redis
    中拉取响应，而不是击中 GitHub 服务器。
- en: This method is applicable to our REST API, too. The most frequent and unchanged
    REST API responses can be cached in order to reduce the load on the primary database.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也适用于我们的 REST API。最频繁且未更改的 REST API 响应可以被缓存，以减少对主数据库的负载。
- en: 'There is a wonderful library available for Go that can talk to Redis. It can
    be found at [https://github.com/go-redis/redis](https://github.com/go-redis/redis).
    It is a well-known library that many developers recommend. The following diagram
    illustrates this concept very well:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Go 语言，有一个可以与 Redis 通信的出色库。它可以在 [https://github.com/go-redis/redis](https://github.com/go-redis/redis)
    找到。这是一个广为人知的库，许多开发者都推荐使用。以下图表很好地说明了这个概念：
- en: '![](img/8fd94758-390c-4550-a156-ec17f046aa32.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fd94758-390c-4550-a156-ec17f046aa32.jpg)'
- en: One caveat here is the expiration of the API. A real-time API should not be
    cached because of its dynamic nature. Caching brings performance optimization
    to our plate, as well as a few headaches regarding data syncing.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个需要注意的地方是 API 的过期。由于其实时性，实时 API 不应该被缓存。缓存将性能优化带到了我们的餐桌上，同时也带来了一些关于数据同步的头痛问题。
- en: Be careful while caching. Always implement a robust cache-busting method. There
    are many better practices available globally. Please go through them to get an
    understanding of the various architectures.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存时请小心。始终实现一个健壮的缓存失效方法。全球有许多更好的实践。请查阅它们，以了解各种架构。
- en: We'll discuss Redis in more detail in the next chapter, where we'll discuss
    strategies that can be used to develop asynchronous APIs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章更详细地讨论 Redis，其中我们将讨论可以用来开发异步 API 的策略。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We started this chapter with understanding client software: how a software
    client works and how we can create a few. We saw the basics of writing a command-line
    application. `cli` is a third-party package that allows us to create beautiful
    command-line applications. After installing it, we learned how to collect command-line
    arguments through the tool. We also explored commands and flags in our CLI application.
    Next, we looked into `grequest``s`, a package similar to Python requests that''s
    used to make API requests from Go code. We learned how to make `GET`, `POST`,
    and other requests from the client programs. We looked at a fresh package called
    `cobra` for creating commands/sub-commands.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解客户端软件开始本章：软件客户端是如何工作的，以及我们如何创建几个。我们看到了编写命令行应用程序的基础。`cli` 是一个第三方包，它允许我们创建美观的命令行应用程序。安装后，我们学习了如何通过该工具收集命令行参数。我们还探索了
    CLI 应用程序中的命令和标志。接下来，我们研究了 `grequest`，这是一个类似于 Python 请求的包，用于从 Go 代码中发送 API 请求。我们学习了如何从客户端程序中制作
    `GET`、`POST` 和其他请求。我们还查看了一个名为 `cobra` 的新包，用于创建命令/子命令。
- en: Then, we explored the GitHub API and how to fetch details about repositories.
    With the knowledge of both concepts, we developed a client that lists the repositories
    for a given user and also creates a `gist` (a set of text snippets on GitHub).
    Finally, we introduced the Redis architecture and how caching can help us handle
    the rate-limited API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探索了 GitHub API 以及如何获取存储库的详细信息。在了解这两个概念之后，我们开发了一个客户端，该客户端列出给定用户的存储库，并创建一个
    `gist`（GitHub 上的文本片段集合）。最后，我们介绍了 Redis 架构以及缓存如何帮助我们处理速率限制的 API。
- en: In the next chapter, we'll discuss strategies for building asynchronous APIs
    with the help of queuing and caching.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在队列和缓存的帮助下构建异步 API 的策略。
