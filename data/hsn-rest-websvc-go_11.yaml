- en: Scaling our REST API Using Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务扩展我们的REST API
- en: Building a REST API is easy in terms of the concept. But scaling it to accept
    huge traffic is a challenge. Till now, we've looked into the details of creating
    REST API structures and sample REST APIs. In this chapter, we are going to explore
    Go Micro, a wonderful, idiomatic Go package for building microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，构建REST API很容易。但将其扩展以接受大量流量是一个挑战。到目前为止，我们已经探讨了创建REST API结构和示例REST API的细节。在本章中，我们将探讨Go
    Micro，这是一个用于构建微服务的优秀、惯用的Go包。
- en: This is the age of microservices, where huge applications are commonly broken
    down into loosely coupled components. The microservice architecture allows companies
    to quickly iterate in parallel. We will start by defining the term *microservices*,
    and then move on to Go Micro by creating **Remote Procedure Call** (**RPC**)-/REST-style
    microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务的时代，大型应用程序通常被分解为松耦合的组件。微服务架构允许公司快速并行迭代。我们将首先定义术语*微服务*，然后通过创建**远程过程调用**（**RPC**）/REST风格的微服务来介绍Go
    Micro。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are microservices?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: Monoliths versus microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体与微服务
- en: Introducing Go Micro, a package for building microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Go Micro，一个用于构建微服务的包
- en: Adding logging to the microservices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务添加日志记录
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software should be pre-installed for running code samples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件应预先安装以运行代码示例：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X  >= 10.13'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux（Ubuntu 18.04）/Windows 10/Mac OS X >= 10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Dep: 用于Go的依赖管理工具 >= 0.5.3'
- en: Docker version >= 18.09.2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker版本 >= 18.09.2
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11).
    Clone the code, and use the code samples in the `chapter11` directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter11)下载本章的代码。克隆代码，并使用`chapter11`目录中的代码示例。
- en: What are microservices?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是微服务？
- en: What are microservices? This is the question the enterprise world is asking
    the computing world. The sustainability of a product depends on how easily modifiable
    it is. Huge products should retire at some point in time if they cannot be maintained
    properly. The microservice architecture replaces the traditional monolith with
    granular services that talk to each other in some kind of agreement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是微服务？这是企业界向计算界提出的问题。产品的可持续性取决于其可修改性。如果无法得到适当的维护，大型产品应在某个时间点退役。微服务架构用细粒度的服务取代了传统的单体，这些服务通过某种协议相互通信。
- en: 'Microservices bring the following benefits to the table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务带来了以下好处：
- en: Small teams can iterate in parallel by working on a small set of features.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型团队可以通过专注于一组小的功能来并行迭代。
- en: Adaptability is easy for new developers.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于新开发者来说，适应性很容易。
- en: They allow **Continuous Integration** (**CI**) and **Continuous** **Delivery**
    (**CD**) for individual components of a system.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许系统各个组件的**持续集成**（**CI**）和**持续交付**（**CD**）。
- en: They offer easily replaceable software with a loosely coupled architecture.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供易于替换的软件，具有松耦合的架构。
- en: The architecture is not coupled to a specific technology
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构不依赖于特定的技术
- en: 'In a monolithic application (*traditional application*), a single application
    serves the incoming requests by sharing the computing power. It is good because
    we have everything in one place, and it is easily manageable. But there are few
    problems with monoliths, such as the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序（*传统应用程序*）中，单个应用程序通过共享计算能力来服务传入的请求。这很好，因为我们把所有东西都放在一个地方，并且易于管理。但是，单体有一些问题，例如以下内容：
- en: A tightly coupled architecture.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧耦合的架构。
- en: A single point of failure.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点故障。
- en: The velocity of adding new features and components.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新特性和组件的速度。
- en: The fragmentation of work is limited to teams.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作碎片化仅限于团队。
- en: '**Continuous** **Delivery** (**CD**) is tough because an entire application
    needs to be redeployed for a small change.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）和**持续交付**（**CD**）是困难的，因为即使是微小的更改也需要重新部署整个应用程序。'
- en: In a monolithic application, the entire software is treated as a single entity.
    If the database fails, the app fails. If a bug in the code crashes the software
    application, the entire connectivity with clients goes down. This requirement
    paved the way for microservices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用程序中，整个软件被视为一个单一实体。如果数据库失败，应用程序也会失败。如果代码中的错误导致软件应用程序崩溃，与客户的整个连接都会中断。这一需求为微服务铺平了道路。
- en: Let's take a scenario. A company run by Bob uses the traditional monolith model,
    where developers work around the clock to add new features. At the time of a software
    release, people need to test the code overall for every small component. The project
    moves from development to testing, when all changes are done.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个场景。由鲍勃经营的公司使用传统的单体模型，开发者昼夜不停地添加新功能。在软件发布时，人们需要测试代码的每个小组件。当所有更改完成后，项目从开发转移到测试。
- en: Another company on the next street, run by Alice, uses a microservices architecture.
    The software developers in Alice's company work on individual services, who in
    turn test their individual components. The developers talk with each other's REST/RPC
    API to add new features. They can easily shift their stack from one technology
    to another, as compared to Bob's team.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在隔壁街道的另一家公司，由爱丽丝经营，使用微服务架构。爱丽丝公司的软件开发者专注于单个服务，然后测试它们各自的组件。开发者通过对方的REST/RPC API进行交流以添加新功能。与鲍勃的团队相比，他们可以轻松地将技术栈从一种技术切换到另一种技术。
- en: This example shows that Alice's company is highly flexible than Bob's.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，爱丽丝的公司比鲍勃的公司更加灵活。
- en: Orchestration and service discovery are very important aspects to consider when
    talking about microservices. A tool such as Kubernetes can be used to orchestrate
    the Docker containers. Generally, it is a good practice to have a Docker container
    per microservice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论微服务时，编排和服务发现是非常重要需要考虑的方面。可以使用像Kubernetes这样的工具来编排Docker容器。通常，每个微服务拥有一个Docker容器是一个好的实践。
- en: '**Service discovery** is the automatic detection of the IP address of a microservice
    instance on the fly. This removes the potential threat of hardcoding the IP addresses,
    which can cause a lack of connectivity between services. In the next section,
    we''ll use a diagram to understand what is the crucial difference between a monolith
    and microservice.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务发现**是在运行时自动检测微服务实例的IP地址。这消除了硬编码IP地址的潜在威胁，这可能导致服务之间连接失败。在下一节中，我们将使用图表来了解单体架构和微服务之间关键的区别。'
- en: Monoliths versus microservices
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体与微服务对比
- en: 'It is a common practice to begin a software application as a monolith, and
    then break it down into microservices in the long run. This actually helps to
    focus on the application delivery, instead of blindly following the microservice
    pattern. Once the product is stabilized, then developers should find a way to
    break down product features. Take a look at the following diagram for the difference
    between a monolith and microservices:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，软件应用的开发都是从单体架构开始，然后在长期发展中将其拆分为微服务。这实际上有助于关注应用交付，而不是盲目遵循微服务模式。一旦产品稳定，开发者就应该找到一种方法来拆分产品特性。请看以下图表，了解单体架构和微服务之间的区别：
- en: '![](img/0228d9b8-e898-42e0-8aa2-dd5cb9175ea5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图表](img/0228d9b8-e898-42e0-8aa2-dd5cb9175ea5.png)'
- en: This diagram depicts the structure of monolithic and microservices architectures.
    A monolith has everything wrapped in a single system. It is called a **tightly
    coupled** architecture. In contrast, microservices are individual entities that
    are easy to replace and modifiable. Each microservice can talk to one another
    through various transport mechanisms, such as HTTP, REST, or RPC. The data format
    exchanged between services could be either JSON or Protocol buffers. Microservices
    can also handle various request entry points, such as **UI** and **API clients**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表展示了单体架构和微服务架构的结构。单体架构将所有内容封装在单个系统中。它被称为**紧密耦合**的架构。相比之下，微服务是易于替换和可修改的独立实体。每个微服务可以通过各种传输机制（如HTTP、REST或RPC）相互通信。服务之间交换的数据格式可以是JSON或协议缓冲区。微服务还可以处理各种请求入口点，如**UI**和**API客户端**。
- en: Microservices can be implemented in any technology (Java, Go, Python, and so
    on), and can be replaced with any technology because of their loosely coupled
    nature.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以用任何技术（Java、Go、Python等）实现，并且由于它们的松散耦合性质，可以用任何技术进行替换。
- en: In the next section, we explore how to create microservices in Go using a lightweight
    framework called Go Micro. There, we see how to develop mini services that can
    talk to each other.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用名为 Go Micro 的轻量级框架在 Go 中创建微服务。在那里，我们将了解如何开发可以相互通信的微型服务。
- en: Introducing Go Micro, a package for building microservices
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Go Micro，一个用于构建微服务的包
- en: Netflix's Eureka and Spring Boot from the Java community are famous for building
    microservices. The Go Micro package provides the same set of features. It is a
    toolkit for building microservices in Go. It is lightweight, which means start
    small and go big.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 的 Eureka 和来自 Java 社区的 Spring Boot 以构建微服务而闻名。Go Micro 包提供了相同的功能集。它是一个用于在
    Go 中构建微服务的工具包。它是轻量级的，这意味着从小处着手，逐步发展。
- en: It has a Go style of adding services, which makes developers feel good. In the
    upcoming sections, we will see how to create a microservice with the steps defined
    by Go Micro. Go Micro provides requirements to implement RPC and **event-driven
    architectures** (**EDAs**). It also has a pluggable interface where we can plug
    any external functionality.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有 Go 风格的服务添加方式，这使得开发者感觉良好。在接下来的章节中，我们将看到如何按照 Go Micro 定义的步骤创建一个微服务。Go Micro
    提供了实现 RPC 和 **事件驱动架构**（**EDAs**）的要求。它还有一个可插拔接口，我们可以在这里插入任何外部功能。
- en: 'The main features supported by Go Micro are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go Micro 支持的主要功能如下：
- en: Request/response
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求/响应
- en: Service discovery
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Load balancing
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Message encoding
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息编码
- en: Async messaging
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步消息
- en: Pluggable interfaces
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可插拔接口
- en: '**Request/response** is a plain HTTP/RPC call. **Service discovery** is useful
    for finding microservice instances at runtime. **Load balancing** is for routing
    requests to multiple same-type applications. **Message encoding** is essential
    for services to understand each other. **Async messaging** involves the generation
    and consumption of events. Go Micro''s **pluggable interfaces** provide functionality
    such as codecs for translation, and brokers for storage systems.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**请求/响应** 是一个简单的 HTTP/RPC 调用。**服务发现** 用于在运行时查找微服务实例。**负载均衡** 用于将请求路由到多个相同类型的应用程序。**消息编码**
    对于服务相互理解至关重要。**异步消息** 涉及事件的产生和消费。Go Micro 的 **可插拔接口** 提供了诸如用于翻译的编解码器以及用于存储系统的代理等功能。'
- en: 'Install Go Micro using the `dep` tool in any project in this way:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dep` 工具以这种方式在任何项目中安装 Go Micro：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the next section, we lay down the plan for our first microservice. We see
    how to encrypt and decrypt messages in Go. We will then build an encrypting/decrypting
    service using Go Micro.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将制定我们的第一个微服务的计划。我们将了解如何在 Go 中加密和解密消息。然后，我们将使用 Go Micro 构建一个加密/解密服务。
- en: Understanding encryption
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解加密
- en: We all know about the encryption of messages. **Encryption** is a process that
    uses a base message and a key to produce an encoded message through a mathematical
    algorithm that can only be decoded using the original key. That message can be
    passed over the wire. The recipient decrypts the message with a key and gets back
    the original message. We are going to create a microservice that provides both
    encryption and decryption.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道消息加密。**加密** 是一个使用基本消息和密钥通过一个只能使用原始密钥解码的数学算法产生编码消息的过程。该消息可以通过网络传输。接收者使用密钥解密消息并获取原始消息。我们将创建一个提供加密和解密功能的微服务。
- en: 'See the plan for the development of our first microservice:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们第一个微服务开发的计划：
- en: Develop utility functions for encryption/decryption.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发加密/解密实用函数。
- en: Then, integrate it with Go Micro to produce a service.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其与 Go Micro 集成以生成服务。
- en: 'Go comes with packages for encrypting messages. We need to import encrypting
    algorithms from those packages and use them. For that, we create a project that
    uses the **Advanced Encryption Standard** (**AES**), as in the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Go 内置了用于加密消息的包。我们需要从这些包中导入加密算法并使用它们。为此，我们创建了一个使用 **高级加密标准**（**AES**）的项目，如下步骤所示：
- en: 'Create a directory called `encryptString` in your `GOPATH/src/github.com` directory,
    as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `GOPATH/src/github.com` 目录下创建一个名为 `encryptString` 的目录，具体步骤如下：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, add one more file in the new directory, called `utils`. Add `main.go`
    in the project directory and `utils.go` in the new `utils` directory. The directory
    structure looks like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在新的目录中添加一个名为 `utils` 的文件。在项目目录中添加 `main.go`，在新的 `utils` 目录中添加 `utils.go`。目录结构如下所示：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s add the logic of encryption in our `utils.go` file. We create two
    functions, one for encryption and another for the decryption of a message. First,
    import the necessary packages, `crypto` and `encoding`, as shown in the following
    code block:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`utils.go`文件中添加加密逻辑。我们创建两个函数，一个用于加密，另一个用于消息的解密。首先，导入必要的包`crypto`和`encoding`，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The AES algorithm takes an initialization vector. The vector is an arbitrary
    byte array that can be used along with a secret key for data encryption. Define
    it like this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AES算法需要一个初始化向量。该向量是一个任意字节数组，可以与密钥一起用于数据加密。定义如下：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The values in the vector can also be generated randomly. Here, we use a predefined
    vector.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向量中的值也可以随机生成。这里，我们使用一个预定义的向量。
- en: 'Now, let''s implement the logic for encryption. It declares a new cipher using
    the `aes.NewCipher` and `aes.NewCFBEncryptor` functions. Then, we execute a function
    called `XORKeyStream` on the cipher to get the encrypted string. Then, we need
    to do a `base64` encoding to generate the protected string, like so:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现加密逻辑。它使用`aes.NewCipher`和`aes.NewCFBEncryptor`函数声明一个新的密文。然后，我们在密文上执行名为`XORKeyStream`的函数以获取加密字符串。然后，我们需要进行`base64`编码以生成受保护的字符串，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, in the same way, let's define a `DecryptString` function that takes a
    key and `ciphertext` and generates an original message. In the `DecryptString`
    function, first, decode the `base64` encoded text and create a cipher block with
    the key. Pass this cipher block with the initialization vector to `NewCFBEncrypter`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，以同样的方式，让我们定义一个`DecryptString`函数，它接受一个密钥和`ciphertext`，并生成原始消息。在`DecryptString`函数中，首先，解码`base64`编码的文本，并使用密钥创建一个密文块。将此密文块与初始化向量一起传递给`NewCFBEncrypter`。
- en: 'Then, use `XORKeyStream` to load content from `ciphertext` to `plaintext`.
    Basically, it is a process of swapping the encrypted and decrypted messages in
    `XORKeyStream`. The code looks like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`XORKeyStream`从`ciphertext`加载内容到`plaintext`。基本上，这是一个在`XORKeyStream`中交换加密和解密消息的过程。代码如下：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This completes the definition of utility files for encryption and decryption.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了加密和解密工具文件的定义。
- en: 'Now, let''s edit the `main.go` file to leverage the preceding `utils` package
    and its functions. The `main` function should encrypt a message using the `EncryptString`
    function, and then decrypt a message using the `DecryptString` function, like
    this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编辑`main.go`文件，利用前面的`utils`包及其函数。`main`函数应该使用`EncryptString`函数加密一条消息，然后使用`DecryptString`函数解密一条消息，如下所示：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The original message should not change.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 原始消息不应改变。
- en: 'Here, we are importing the `encrypting/decrypting` functions from the `utils`
    package and using them to show an example. If we run this program, we see the
    following output:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们从`utils`包中导入`encrypting/decrypting`函数，并使用它们来展示一个示例。如果我们运行这个程序，我们会看到以下输出：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This program illustrates how we can use the AES algorithm to encrypt a message
    and get it back using the same secret key. This algorithm is also called the **Rijndael**
    (pronounced as *rain-dahl*) algorithm.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序说明了我们如何使用AES算法加密一条消息，并使用相同的密钥将其恢复。此算法也称为**Rijndael**（发音为*rain-dahl*）算法。
- en: In the next section, we use this encryption knowledge to create a microservice
    using Go Micro.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们使用这些加密知识使用Go Micro创建一个微服务。
- en: Building a microservice with Go Micro
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go Micro构建微服务
- en: 'We will use Go Micro and our encryption logic in `utils` to write a microservice.
    A Go microservice should be built in a step-wise manner. To create a service,
    we need to design a few entities upfront. They are as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Go Micro和`utils`中的加密逻辑来编写一个微服务。一个Go微服务应该逐步构建。要创建一个服务，我们需要提前设计几个实体。它们如下：
- en: A protocol buffer file for defining RPC methods of service
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义服务RPC方法的协议缓冲文件
- en: A handler file that has an actual implementation of methods
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有方法实际实现的处理器文件
- en: A server that exposes RPC methods
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公开RPC方法的服务器
- en: A client that can make RPC requests and get results
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以发出RPC请求并获取结果的客户端
- en: 'We need two system level-tools called `protoc` and `protoc-gen-micro` for compiling
    protocol buffers to Go packages. Let''s see the steps for creating an encryption
    microservice, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个系统级工具`protoc`和`protoc-gen-micro`来编译协议缓冲到Go包。让我们看看创建加密微服务的步骤，如下：
- en: 'Let''s install those compilers using the `go get` command, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`go get`命令安装这些编译器，如下所示：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s create our project directories, like this:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建我们的项目目录，如下所示：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, define an `encryption.proto` protocol buffer file in the `proto` directory,
    like this:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `proto` 目录中定义一个 `encryption.proto` 协议缓冲文件，如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It should have a service called `Encrypter` and two messages called `Request`
    and `Response`. These two messages are for requesting encryption and decryption.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该有一个名为 `Encrypter` 的服务以及两个名为 `Request` 和 `Response` 的消息。这两个消息用于请求加密和解密。
- en: The syntax of the preceding file is `"proto3"`. The `Request` message has two
    fields, called `message` and `key` respectively. The client uses these field to
    send a `plaintext`/`ciphertext` message.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件的语法是 `"proto3"`。`Request` 消息有两个字段，分别称为 `message` 和 `key`。客户端使用这些字段发送 `plaintext`/`ciphertext`
    消息。
- en: The `Response` message has a field called `result`. It is the result of the
    encryption/decryption process. The `Encrypter` service has two RPC methods called
    `Encrypt` and `Decrypt`. Both take a `Request` and return a `Response`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 消息有一个名为 `result` 的字段。它是加密/解密过程的结果。`Encrypter` 服务有两个名为 `Encrypt`
    和 `Decrypt` 的 RPC 方法。两者都接受一个 `Request` 并返回一个 `Response`。'
- en: 'Now, we can generate the Go files by compiling a `.proto` file, like this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过编译 `.proto` 文件来生成 Go 文件，如下所示：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the breakdown of the command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令的分解：
- en: '| **Option** | **Meaning** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **含义** |'
- en: '| `-I` | The input of project root |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `-I` | 项目根目录的输入 |'
- en: '| `--go_out` | The output of the Go file that has autogenerated methods |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `--go_out` | 自动生成方法的 Go 文件输出 |'
- en: '| `--micro_out` | Similar to `--go_out`, but generates an extra file with Go
    micro methods |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `--micro_out` | 与 `--go_out` 类似，但生成一个包含 Go 微方法的额外文件 |'
- en: '| `proto/encryption.proto` | Path to the protocol buffer file to be compiled
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `proto/encryption.proto` | 编译的协议缓冲文件路径 |'
- en: 'It generates two new files in the project''s `proto` directory. Their names
    are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它在项目的 `proto` 目录中生成两个新的文件。它们的名称如下：
- en: '`encryption.pb.go`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encryption.pb.go`'
- en: '`encryption.pb.micro.go`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encryption.pb.micro.go`'
- en: These code-generated files should not be modified by hand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由代码生成的文件不应手动修改。
- en: 'Let''s copy the `utils.go` file we have defined in the `encryptString` example.
    It can be reused as it is, except for a small change in the package name, as shown
    here:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们复制在 `encryptString` 示例中定义的 `utils.go` 文件。它可以原样重用，除了包名的小幅更改，如下所示：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After the copy, change the package name in the file from `utils` to `main`
    (because now, this file is in the new project''s root), as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制后，将文件中的包名从 `utils` 更改为 `main`（因为现在，此文件位于新项目的根目录），如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this, we have the `EncryptString` and `DecryptString` functions available
    throughout the Go project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以在整个 Go 项目中使用 `EncryptString` 和 `DecryptString` 函数。
- en: 'Now, add one more file called `handlers.go`, where we define the business logic
    for our service. It exports an `Encrypter` struct and a few methods that handle
    RPC requests. The code for this is shown here:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个名为 `handlers.go` 的文件，其中我们定义了服务的业务逻辑。它导出 `Encrypter` 结构体和一些处理 RPC 请求的方法。此代码如下所示：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Encrypter` struct should have two methods, `Encrypt` and `Decrypt`. Each
    method takes a context object, an RPC request object, and an RPC response object.
    The job each method does is to call the respective utility function and set the
    response object with a result, like so:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Encrypter` 结构体应该有两个方法，`Encrypt` 和 `Decrypt`。每个方法都接受一个上下文对象、一个 RPC 请求对象和一个
    RPC 响应对象。每个方法执行的操作是调用相应的实用函数，并设置响应对象的结果，如下所示：'
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Encrypt` and `Decrypt` methods are mapped to these RPC methods in the
    protocol buffer file, like so:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Encrypt` 和 `Decrypt` 方法映射到协议缓冲文件中的这些 RPC 方法，如下所示：'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we have to plug these handlers into our `main` program, like so:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将这些处理程序插入到我们的 `main` 程序中，如下所示：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `main` program imports the `proto` and `go-micro` packages and tries to
    create a new microservice instance. Then, it registers the service to the `Encrypter`
    handler we exported from the `handlers.go` file. Finally, it runs the service.
    All this is illustrated in the following block of code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 程序导入 `proto` 和 `go-micro` 包，并尝试创建一个新的微服务实例。然后，它将服务注册到从 `handlers.go`
    文件中导出的 `Encrypter` 处理程序。最后，它运行服务。所有这些都在以下代码块中展示：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding program, `micro.NewService` is being used to create a new microservice.
    It returns a `service` object. We can also collect command-line arguments by running
    `service.Init()`. In our example, we are not passing any. We can register the
    service to the handler by using the `RegisterEncrypterHandler` method. This method
    is dynamically generated by the protocol buffer compiler. Finally, `service.Run`
    starts the server. Let's run the service.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，`micro.NewService` 被用来创建一个新的微服务。它返回一个 `service` 对象。我们也可以通过运行 `service.Init()`
    来收集命令行参数。在我们的例子中，我们没有传递任何参数。我们可以使用 `RegisterEncrypterHandler` 方法将服务注册到处理器。该方法是由协议缓冲区编译器动态生成的。最后，`service.Run`
    启动服务器。让我们运行这个服务。
- en: 'Try to build the project from the project root directory, `encryptService`,
    as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试从项目根目录 `encryptService` 构建项目，如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you see from the server output, Go Micro starts the microservice with a transport
    and a message broker. Now, clients can make requests to these ports. The service
    is not so useful unless there is a client to consume the API. So, in the next
    section, we'll try to build a Go Micro client and see how to connect to the preceding
    server.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，从服务器输出中，Go Micro 使用传输和消息代理启动了微服务。现在，客户端可以对这些端口发起请求。如果没有客户端来消费API，这个服务就没有太大用处。所以，在下一节中，我们将尝试构建一个Go
    Micro客户端，并看看如何连接到前面的服务器。
- en: If you want to run the program without building it, you have to include all
    the packages that are imported in the `main` file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行程序而不构建它，你必须包含在 `main` 文件中导入的所有包。
- en: For example, `go run main.go handlers.go utils.go` is equivalent to `go build
    && ./encryptService`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`go run main.go handlers.go utils.go` 等同于 `go build && ./encryptService`。
- en: Building an RPC client with Go Micro
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go Micro构建RPC客户端
- en: In [Chapter 6](613be150-a44b-4840-8fe5-9b41f53f3244.xhtml), *Working with Protocol
    Buffers and gRPC*, where we discussed protocol buffers, we mentioned that a server
    and client should agree on the same protocol buffer. In the same way, Go Micro
    expects the service and client to use the same `.proto` file—in our case, `encryption.proto`.
    A client can be another service that is requesting some information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第6章](613be150-a44b-4840-8fe5-9b41f53f3244.xhtml) *使用协议缓冲区和gRPC* 中，我们讨论了协议缓冲区，我们提到服务器和客户端应该就相同的协议缓冲区达成一致。同样，Go
    Micro期望服务和客户端使用相同的 `.proto` 文件——在我们的例子中是 `encryption.proto`。客户端可以是请求某些信息的另一个服务。
- en: 'We can build clients using Go Micro. It includes all the necessary constructs
    to connect and make RPC calls to a microservice. Our plan is to create a client
    and ask the service to encrypt and decrypt messages. Those requests will be RPC
    calls. Let''s see the steps for creating and using a Go Micro client, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Go Micro构建客户端。它包括连接到微服务和进行RPC调用的所有必要构造。我们的计划是创建一个客户端，并要求服务加密和解密消息。这些请求将是RPC调用。让我们看看创建和使用Go
    Micro客户端的步骤，如下所示：
- en: 'Create a new project for the client, like this:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为客户端创建一个新的项目，如下所示：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, add an `encryption.proto` file in the `proto` directory, which looks exactly
    similar to that of the `service`, like this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `proto` 目录中添加一个 `encryption.proto` 文件，其外观与 `service` 完全相同，如下所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If observed carefully, the service name, messages, and their definitions are
    matching with that of the `service`. Now, compile the protocol buffer from the
    `encryptClient` project root, as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果仔细观察，服务名称、消息及其定义与 `service` 中的相匹配。现在，从 `encryptClient` 项目根目录编译协议缓冲区，如下所示：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After this, the client generates two files in the `proto` directory. Those
    should not be modified. Now, we are ready with our setup. Add a `main.go` file
    for making RPC calls to the service, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，客户端在 `proto` 目录中生成了两个文件。这些文件不应该被修改。现在，我们已经准备好了我们的设置。为进行RPC调用到服务添加一个 `main.go`
    文件，如下所示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `main` program imports the `proto` and `go-micro` packages where we compiled
    protocol buffers, like so:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 程序导入了 `proto` 和 `go-micro` 包，我们在其中编译了协议缓冲区，如下所示：'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A client should also be created with a function called `micro.NewService`,
    like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端也应该使用名为 `micro.NewService` 的函数创建，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It can be initialized to collect environment variables. The key difference between
    a client and a service is that for the client, we create an instance of `service`
    using the `proto.NewEncrypterService` function. We use that instance to make API
    calls. Remember that the function is auto-generated by the `protoc` command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被初始化来收集环境变量。客户端和服务之间的关键区别在于，对于客户端，我们使用 `proto.NewEncrypterService` 函数创建 `service`
    的实例。我们使用该实例进行API调用。记住，该函数是由 `protoc` 命令自动生成的。
- en: 'The `encrypter` is the service instance in the code. Next, we can make RPC
    calls by calling RPC methods directly on the service instance. Let''s pass a text
    called `"I am a Message"` with the key `"111023043350789514532147"` to encrypt
    the method, like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`encrypter`是代码中的服务实例。接下来，我们可以通过直接在服务实例上调用RPC方法来执行RPC调用。让我们传递一个名为`"I am a Message"`的文本和密钥`"111023043350789514532147"`来加密方法，如下所示：'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function, as specified in the protocol buffer, returns a response that has
    a `Result` field. We are printing that value to the console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，如协议缓冲区中指定的，返回一个包含`Result`字段的响应。我们将该值打印到控制台。
- en: 'Next, let''s pass this result back as a cipher for the `Decrypt` function.
    It should return the original message back. We use the same key as we did for
    encryption, like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将这个结果作为密文传递给`Decrypt`函数。它应该返回原始消息。我们使用与加密相同的密钥，如下所示：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These two blocks go into the `main` function. Once we are done adding them,
    let''s build and run the client, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个块放入`main`函数中。一旦我们添加了它们，让我们构建并运行客户端，如下所示：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We passed the plaintext and key, and the original message is returned back as
    the final result. It confirms that the `encrypt` and `decrypt` RPC calls are working
    properly. The benefit of Go Micro is, with a few lines of code, we can create
    microservices and clients.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了明文和密钥，原始消息作为最终结果返回。这证实了`encrypt`和`decrypt`RPC调用正常工作。Go Micro的好处是，用几行代码就可以创建微服务和客户端。
- en: In the next section, we see how Go Micro supports EDAs where services and clients
    can communicate via events.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Go Micro如何支持EDAs，其中服务和客户端可以通过事件进行通信。
- en: Building event-driven microservices
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建事件驱动型微服务
- en: In [Chapter 9](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml), *Asynchronous API
    Design*, we learned about asynchronous programming. An asynchronous API can be
    achieved by events. The service and client can talk to each other using events.
    They don't have to wait until one party finishes their job.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](4c4f37a7-48db-4168-a228-4c684a4ebd3c.xhtml)的*异步API设计*中，我们学习了异步编程。异步API可以通过事件实现。服务和客户端可以使用事件相互通信。他们不必等待一方完成工作。
- en: An event generator is an entity that generates events. An event consumer consumes
    the events from other parties. Publish/Subscribe is an architectural pattern that
    is possible with events. Go Micro supports Publish/Subscribe by using a message
    broker interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 事件生成器是一个生成事件的实体。事件消费者从其他方消费事件。发布/订阅是一种可以通过事件实现的设计模式。Go Micro通过使用消息代理接口支持发布/订阅。
- en: 'See the following diagram to understand the event flow:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表以了解事件流：
- en: '![](img/096710a3-5922-4935-ada7-c79fe1162c6d.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/096710a3-5922-4935-ada7-c79fe1162c6d.png)'
- en: A Go Micro client can **Subscribe** to a topic. A Go microservice can **Publish**
    messages into that **Topic**. Events flow from right to left in this case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Go Micro 客户端可以**订阅**一个主题。Go 微服务可以将消息发布到该**主题**。在这种情况下，事件从右向左流动。
- en: It comes with an inbuilt HTTP message broker and can be easily replaced with
    widely used message brokers such as RabbitMQ or Kafka. In our discussion, we stick
    to the default HTTP broker.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它自带内置的HTTP消息代理，可以轻松替换为广泛使用的消息代理，如RabbitMQ或Kafka。在我们的讨论中，我们坚持使用默认的HTTP代理。
- en: We will illustrate Publish/Subscribe with an example. Let's say a microservice
    should push weather alerts every 5 seconds. Instead of the client calling the
    service API, the service can publish those changes to a topic where a client can
    subscribe. The client consumes those alerts and does the processing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用示例来说明发布/订阅。假设一个微服务应该每5秒推送一次天气警报。而不是客户端调用服务API，服务可以将这些更改发布到一个客户端可以订阅的主题。客户端消费这些警报并进行处理。
- en: 'In all the projects we are working on, we should install Go Micro using the
    `dep` tool and running the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在工作的所有项目中，我们应该使用`dep`工具安装Go Micro并运行以下代码：
- en: '`> dep init`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`> dep init`'
- en: '`> dep ensure -add "github.com/micro/go-micro"`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`> dep ensure -add "github.com/micro/go-micro"`'
- en: 'We are going to create an `asyncServer` and an `asyncClient`. The `asyncServer`
    generates weather events, and the client consumes them. Let''s look at the steps
    for this example here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`asyncServer`和一个`asyncClient`。`asyncServer`生成天气事件，客户端消费它们。让我们看看这个示例的步骤：
- en: 'Create a project directory, like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个项目目录，如下所示：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a `weather.proto` file in the `proto` directory of both `asyncService`
    and `asyncClient`. It holds a structure and RPC methods for communication. This
    file defines an `Event` that is a weather alert, and the code can be seen as follows:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `asyncService` 和 `asyncClient` 的 `proto` 目录中创建一个 `weather.proto` 文件。它包含用于通信的结构和
    RPC 方法。此文件定义了一个 `Event`，它是一个天气警报，代码如下所示：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It has three fields, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个字段，如下所示：
- en: '`city name`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`城市名称`'
- en: '`unix timestamp`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unix 时间戳`'
- en: '`temperature in Celsius`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`摄氏度温度`'
- en: A service should publish this event to a topic called `alerts`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应该将此事件发布到名为 `alerts` 的主题。
- en: 'Now, compile the `.proto` file in both the service and client, and get auto-generated
    Go files, as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在服务和客户端中编译 `.proto` 文件，并获取自动生成的 Go 文件，如下所示：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For brevity, we are skipping the imports in this example, so please access the
    chapter repo for the complete code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们在这个例子中省略了导入，请访问章节仓库以获取完整的代码。
- en: 'Coming to the service, the `main.go` file should declare a microservice and
    a publisher. A publisher is created by the `micro.NewPublisher` method. It takes
    the topic name `alerts` and a `service.Client()` as its arguments, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来到服务端，`main.go` 文件应该声明一个微服务和发布者。发布者是通过 `micro.NewPublisher` 方法创建的。它接受主题名称 `alerts`
    和 `service.Client()` 作为参数，如下所示：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we create a dummy ticker that publishes a weather alert every `15` seconds.
    We achieve that by using the `time.Tick` built-in Go method. We spawn a `go-routine`
    that loops forever, listens to a tick, and publishes an event into the topic using
    the `publisher.Publish` method. The `Publish` method takes a context object and
    an event with data as arguments, as can be seen in the following code block:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个虚拟的计时器，每 `15` 秒发布一次天气警报。我们通过使用内置的 Go 方法 `time.Tick` 来实现这一点。我们启动一个无限循环的
    `go-routine`，监听一个滴答声，并使用 `publisher.Publish` 方法将事件发布到主题。`Publish` 方法接受一个上下文对象和一个包含数据的事件作为参数，如下面的代码块所示：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After this, finally, we have to run the service by calling the `service.Run`
    method, like this:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，我们必须通过调用 `service.Run` 方法来运行服务，如下所示：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Both `service` and `go-routine` run in parallel. When you run this service,
    you see this output:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`service` 和 `go-routine` 并行运行。当你运行此服务时，你会看到以下输出：'
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, the service is pushing events, but there is no client to consume them.
    Let''s update the `main.go` file `asyncClient` with consuming logic. In the client,
    we should declare a handler function to process the event. The handler is executed
    whenever there is an incoming event. It prints out the event in our case, as can
    be seen here:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，服务正在推送事件，但没有客户端来消费它们。让我们更新 `main.go` 文件中的 `asyncClient` 以包含消费逻辑。在客户端中，我们应该声明一个处理函数来处理事件。处理函数在收到事件时执行。在我们的例子中，它打印出事件，如下所示：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After defining the handler function to process events, we can attach the client
    with the topic. The `micro.RegisterSubscriber` function attaches a `ProcessEvent`
    handler function to the `alerts` topic, like this:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义处理函数以处理事件后，我们可以将客户端与主题关联起来。`micro.RegisterSubscriber` 函数将 `ProcessEvent`
    处理函数附加到 `alerts` 主题，如下所示：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run this program, it consumes the alerts published by the service we
    defined previously, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行此程序，它将消费我们之前定义的服务发布的警报，如下所示：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is how asynchronous behavior is achieved in microservices. The border between
    clients and services can blur, as anyone can publish or subscribe. In a distributed
    system, services are clients to other services. So, Go Micro provides a lightweight
    and flexible approach to creating microservices.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在微服务中实现异步行为的方式。客户端和服务的边界可能会变得模糊，因为任何人都可以发布或订阅。在一个分布式系统中，服务是其他服务的客户端。因此，Go
    Micro 提供了一种轻量级且灵活的方法来创建微服务。
- en: In the next section, we will discuss the logging and instrumentation of microservices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论微服务的日志记录和仪表化。
- en: Adding logging to microservices
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向微服务添加日志记录
- en: Logging is a crucial aspect of microservices. We can write middleware to capture
    all requests and responses going into and out of a service. Even for a client,
    we can capture logs while making RPC calls to a service.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是微服务的一个关键方面。我们可以编写中间件来捕获进入和离开服务的所有请求和响应。即使是客户端，我们也可以在向服务进行 RPC 调用时捕获日志。
- en: Go Micro is a lean framework and doesn't enforce logging by default. We can
    easily wrap a service handler with our own custom logger. For example, in the
    `encryptService` example, we have a file called `handlers.go`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Go Micro 是一个轻量级的框架，默认不强制执行日志记录。我们可以轻松地将自定义日志记录器包装在服务处理函数中。例如，在 `encryptService`
    示例中，我们有一个名为 `handlers.go` 的文件。
- en: 'In order to activate logging for each request in a custom format, we have to
    define a wrapper, and then link it to the service. As an example, if we have to
    log every incoming encryption request, follow these steps:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以自定义格式激活每个请求的日志记录，我们必须定义一个包装器，并将其链接到服务。例如，如果我们必须记录每个传入的加密请求，请按照以下步骤操作：
- en: 'Create a new `wrapper` function. It takes `Context`, `Request`, and `Response`
    as arguments. Here, we just print the time of the request arrival, like this:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`wrapper`函数。它接受`Context`、`Request`和`Response`作为参数。在这里，我们只打印请求到达的时间，如下所示：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `service`, we can attach the wrapper, like this:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`service`中，我们可以附加包装器，如下所示：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, the service logs every request in the format defined in the wrapper function,
    like so:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务以包装函数中定义的格式记录每个请求，如下所示：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For more information about logging, see the documentation at [https://micro.mu/docs/go-micro.html#wrappers](https://micro.mu/docs/go-micro.html#wrappers).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关于日志记录的更多信息，请参阅[https://micro.mu/docs/go-micro.html#wrappers](https://micro.mu/docs/go-micro.html#wrappers)的文档。
- en: The instrumentation of services is out of the scope of this book, but there
    is an open standard called **OpenTracing** ([https://opentracing.io/](https://opentracing.io/)).
    It defines a standard for how to metricize API endpoints, number of requests,
    and so on. Please feel free to explore it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的仪器化超出了本书的范围，但有一个名为**OpenTracing**（[https://opentracing.io/](https://opentracing.io/)）的开放标准。它定义了如何度量API端点、请求数量等的标准。请随意探索它。
- en: The APIs we created in this chapter are RPC-based. To convert them to REST,
    you just have to use a plugin called **Micro Web**. For more information, see
    this link for easy conversion to REST ([https://micro.mu/docs/go-web.html](https://micro.mu/docs/go-web.html)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们创建的API是基于RPC的。要将它们转换为REST，只需使用一个名为**Micro Web**的插件。更多信息，请参阅此链接以轻松转换为REST（[https://micro.mu/docs/go-web.html](https://micro.mu/docs/go-web.html)）。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with the definition of microservices. The main difference
    between a monolithic application and a microservice is the way a tightly coupled
    architecture is broken into a loosely coupled architecture.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从微服务的定义开始。单体应用和微服务之间的主要区别在于紧密耦合架构分解为松散耦合架构的方式。
- en: Microservices talk to each other using either REST-based JSON or RPC-based protocol
    buffers. Using microservices, we can break business logic into multiple chunks.
    Each service does one job pretty well. Go has a lightweight framework called **Go
    Micro**. Using it, we can create services and clients.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务使用基于REST的JSON或基于RPC的协议缓冲区相互通信。使用微服务，我们可以将业务逻辑分解成多个部分。每个服务都做得相当不错。Go有一个轻量级的框架称为**Go
    Micro**。使用它，我们可以创建服务和客户端。
- en: We first created an encryption service using `Micro go`. We then developed a
    client for consuming the service. Go Micro also allows asynchronous programming
    by providing a Publish/Subscribe pattern. Any client/service can subscribe or
    push events to a topic. It uses an HTTP broker by default but can be easily configured
    to RabbitMQ or Kafka. Go Micro also provides features such as service discovery,
    and various transport mechanisms such as protocol buffers, JSON, and so on. Small
    organizations can start with a monolith, but in bigger organizations with huge
    teams, microservices are better suited.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`Micro go`创建了一个加密服务。然后我们开发了一个用于消费服务的客户端。Go Micro还通过提供发布/订阅模式允许异步编程。任何客户端/服务都可以订阅或向一个主题推送事件。它默认使用HTTP代理，但可以轻松配置为RabbitMQ或Kafka。Go
    Micro还提供诸如服务发现和多种传输机制（如协议缓冲区、JSON等）等功能。小型组织可以从单体应用开始，但在大型组织中有庞大团队的情况下，微服务更适合。
- en: In the next chapter, we are going to see how to deploy our Go services using
    nginx. A service needs to be deployed for it to be exposed to the outside world.
    We also use `docker-compose` and containers for a clean deployment.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用nginx部署我们的Go服务。服务需要部署才能对外公开。我们还使用`docker-compose`和容器进行干净部署。
