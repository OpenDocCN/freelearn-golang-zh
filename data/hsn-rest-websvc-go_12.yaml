- en: Containerizing REST Services for Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为部署容器化 REST 服务
- en: In this chapter, we will explore how to containerize our Go applications using
    a few tools such as Docker, Docker Compose, Nginx, and Supervisord. Containerization
    is required to avoid platform dependency during deployment of an application.
    To deploy an application properly, we must prepare an ecosystem. That ecosystem
    consists of a web server, an application server, and a process monitor. This chapter
    deals with how to take our API server from a standalone application to a production-grade
    service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用 Docker、Docker Compose、Nginx 和 Supervisord 等工具将我们的 Go 应用程序容器化。容器化是为了在应用程序部署过程中避免平台依赖。为了正确部署应用程序，我们必须准备一个生态系统。这个生态系统包括一个
    Web 服务器、一个应用服务器和一个进程监控器。本章将讨论如何将我们的 API 服务器从独立应用程序转变为生产级服务。
- en: In recent times, most cloud providers tend to host web applications. Some big
    players such as AWS, Azure, Google Cloud Platform, along with start-ups such as
    DigitalOcean and Heroku are a few such examples. In the upcoming sections, we
    will focus on making a platform ready for deploying REST services. In the next
    chapter, we will look at how to deploy this ecosystem on a famous cloud provider,
    AWS.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，大多数云服务提供商倾向于托管 Web 应用程序。一些大型玩家，如 AWS、Azure、Google Cloud Platform，以及初创公司如
    DigitalOcean 和 Heroku，都是这样的例子。在接下来的章节中，我们将专注于为部署 REST 服务准备平台。在下一章中，我们将探讨如何在著名的云服务提供商
    AWS 上部署此生态系统。
- en: Nginx is a web server that can be a reverse proxy for a web application. It
    can also act as a load balancer when multiple instances of the server are running.
    Supervisord makes sure that an application server is up and running in the event
    of a crash or a system restart. An application server/REST service are both the
    same, so please consider them in equal context throughout this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 是一个可以作为 Web 应用程序反向代理的 Web 服务器。当多个服务器实例运行时，它还可以充当负载均衡器。Supervisord 确保在崩溃或系统重启的情况下，应用程序服务器处于运行状态。应用程序服务器/REST
    服务是相同的，所以请在本章中同等考虑它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing the Nginx server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Nginx 服务器
- en: What is a reverse proxy server?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是反向代理服务器？
- en: Deploying a Go service using Nginx
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Nginx 部署 Go 服务
- en: Monitoring our Go API server with Supervisord
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Supervisord 监控我们的 Go API 服务器
- en: '`Makefile` and Docker Compose-based deployment'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 `Makefile` 和 Docker Compose 的部署
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is the software that should be preinstalled for running the code
    samples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行代码示例之前应预先安装的软件：
- en: 'OS: Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X >=10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dep：Go >= 0.5.3 的依赖管理工具
- en: Docker version >= 18.09.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 版本 >= 18.09.2
- en: Docker Compose >= 1.23.2
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose >= 1.23.2
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter12).
    Clone the code and use the code samples in the `chapter12` directory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter12](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter12)下载本章的代码。克隆代码并使用`chapter12`目录中的代码示例。
- en: Installing the Nginx server
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Nginx 服务器
- en: Nginx is a high-performing web server and load balancer. It is well suited for
    deploying high-traffic websites and API servers. Even though this decision is
    opinionated, it is a community-driven, industry-strong web server. It is similar
    to the Apache2 web server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 是一个高性能的 Web 服务器和负载均衡器。它非常适合部署高流量网站和 API 服务器。尽管这个决定是主观的，但它是一个社区驱动、行业强大的
    Web 服务器。它与 Apache2 Web 服务器类似。
- en: Nginx can also act as a reverse proxy server that allows us to redirect our
    HTTP requests to multiple application servers running on the same network. The
    main contender of Nginx is Apache's `httpd`.Nginx is an excellent static file
    server that can be used by web clients. Since we are dealing with APIs, we will
    take a look at how to deal with HTTP requests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 也可以作为反向代理服务器，允许我们将 HTTP 请求重定向到同一网络上的多个运行的应用服务器。Nginx 的主要竞争对手是 Apache 的
    `httpd`。Nginx 是一个优秀的静态文件服务器，可以被 Web 客户端使用。由于我们处理的是 API，我们将探讨如何处理 HTTP 请求。
- en: 'We can access Nginx in two ways:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式访问 Nginx：
- en: Installation on a bare machine
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在裸机上安装
- en: Using a preinstalled Docker container
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预先安装的 Docker 容器
- en: Let's understand both in more detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解这两者。
- en: Installation on a bare machine
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在裸机上的安装
- en: 'On Ubuntu 18.04, use these commands to install Nginx:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 18.04 上，使用以下命令安装 Nginx：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Mac OS X , you can install it with `brew`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上，你可以使用 `brew` 来安装它：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**brew **[(https://brew.sh/)](https://brew.sh/) is a very useful software packaging
    system for Mac OS X users. My recommendation is that you use it for installing
    software. Once it is successfully installed, you can check it by opening the machine
    IP in the browser. Open `http://localhost/` on your web browser. You should see
    this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**brew** [(https://brew.sh/)](https://brew.sh/) 是一个针对 Mac OS X 用户非常有用的软件打包系统。我的建议是您用它来安装软件。一旦成功安装，您可以通过在浏览器中打开机器
    IP 来检查它。在您的网页浏览器上打开 `http://localhost/`。您应该看到以下内容：'
- en: '![](img/a3bab13d-ea36-4be2-ac43-056cd178786a.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3bab13d-ea36-4be2-ac43-056cd178786a.png)'
- en: 'If you see the preceding message, that means Nginx has been successfully installed.
    It serves on port `80` and serves the default page. On Mac OS X, the default Nginx
    listening port will be `80`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到前面的消息，这意味着 Nginx 已成功安装。它监听端口 `80` 并提供默认页面。在 Mac OS X 上，默认的 Nginx 监听端口将是
    `80`：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Ubuntu (Linux), the file will be on this path:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu (Linux) 上，文件将位于此路径：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the file and search for a server block. If it is listening on port `80`,
    everything is fine. However, if it is on some other port, for example `8080`,
    then change it to `80`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件并搜索服务器块。如果它在端口 `80` 上监听，那么一切正常。然而，如果它在其他端口上，例如 `8080`，那么将其改为 `80`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, everything is ready. The server runs on the `80` HTTP port, which means
    a client can access it using a URL (`http://localhost/`). This basic server serves
    static files from a directory called `html`. The `root` parameter can be modified
    to any directory where we place our web assets. You can check the status of Nginx
    with the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪。服务器运行在 `80` HTTP 端口上，这意味着客户端可以使用 URL (`http://localhost/`) 访问它。这个基本服务器从一个名为
    `html` 的目录中提供静态文件。`root` 参数可以被修改为放置我们 Web 资产的任何目录。您可以使用以下命令检查 Nginx 的状态：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nginx for the Windows operating system is quite basic and is not really intended
    for production-grade deployments. Open source developers usually prefer Debian
    or Ubuntu servers for deploying the API servers with Nginx.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 操作系统上的 Nginx 非常基础，并不真正适用于生产级部署。开源开发者通常更喜欢 Debian 或 Ubuntu 服务器来部署带有 Nginx
    的 API 服务器。
- en: We can also get a Docker image that has Nginx installed already. In the next
    section, we will demonstrate how to install it as a Docker container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获取一个已经安装了 Nginx 的 Docker 镜像。在下一节中，我们将演示如何将其作为 Docker 容器安装。
- en: Installation via a Docker container
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Docker 容器安装
- en: 'Getting a container that has preinstalled Nginx has two benefits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 获取预装了 Nginx 的容器有两个好处：
- en: It is easy to ship containers.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化很容易。
- en: We can destroy and recreate the containers any number of times.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以多次销毁和重新创建容器。
- en: 'To get the latest Nginx image and start a container, run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取最新的 Nginx 镜像并启动一个容器，请运行以下命令：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This pulls the `nginx` image from Docker Hub (make sure you are connected to
    the internet). If the image is already pulled, it reuses that. Then, it starts
    a container with the name of `nginxServer` and serves it on port `80`. Now, visit
    `http://localhost` from your browser and you will see the Nginx home page.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从 Docker Hub 拉取 `nginx` 镜像（确保您已连接到互联网）。如果镜像已经拉取，它将重用该镜像。然后，它将以 `nginxServer`
    为名启动一个容器，并在端口 `80` 上提供服务。现在，从您的浏览器访问 `http://localhost`，您将看到 Nginx 的主页。
- en: 'However, the preceding command is not useful for configuring Nginx after starting
    the container. We have to mount a directory from localhost to the container or
    copy files to the container to make changes to the Nginx configuration file. Let''s
    modify the command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的命令在容器启动后配置 Nginx 时并不适用。我们必须从 localhost 挂载一个目录到容器，或者将文件复制到容器中，以更改 Nginx
    配置文件。让我们修改命令：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The extra command is `--mount`, which mounts a file/directory from the source
    (*host*) to the destination (*container*). If you modify a file on the host system
    in that directory, then it also reflects on the container. The `readonly` option
    stops users/system processes modifying the Nginx configuration inside the container.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的命令是 `--mount`，它将文件/目录从源（*主机*）挂载到目标（*容器*）。如果您在那个目录中修改了主机系统上的文件，那么它也会反映在容器上。`readonly`
    选项阻止用户/系统进程修改容器内的 Nginx 配置。
- en: In the preceding command, we are mounting the Nginx configuration file, `nginx.conf`.
    We use the Docker container-based deployment in the latter part of this chapter,
    where we use `docker-compose` to deploy our application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们正在挂载Nginx配置文件，`nginx.conf`。在本章的后半部分，我们将使用基于Docker容器的部署，其中我们使用`docker-compose`来部署我们的应用程序。
- en: What is a reverse proxy server?
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向代理服务器是什么？
- en: A **reverse proxy server** is a server that holds the information regarding
    the original servers in it. It acts as the front-facing entity for the client
    request. Whenever a client makes an HTTP request, it can directly go to the application
    server. However, if the application server is written in a programming language,
    then you need a translator that can turn the application response into a  response
    understandable by the clients. **Common Gateway Interface** (**CGI**) does the
    same thing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向代理服务器**是一个包含有关原始服务器信息的服务器。它作为客户端请求的前端实体。每当客户端发起一个HTTP请求时，它可以直接访问应用程序服务器。然而，如果应用程序是用编程语言编写的，那么你需要一个可以将应用程序响应转换为客户端可理解响应的翻译器。**通用网关接口**（**CGI**）就做同样的事情。'
- en: We can run a simple Go HTTP server and it can serve incoming requests (no CGI
    is required). We should also protect our application server from **Denial of Service**
    (**DoS**) attacks. So, why are we using another server called Nginx? Well, because
    it brings a lot of things into the picture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行一个简单的Go HTTP服务器，它可以处理入站请求（不需要CGI）。我们还应该保护我们的应用程序服务器免受**拒绝服务**（**DoS**）攻击。那么，为什么我们使用另一个名为Nginx的服务器呢？因为它带来了很多好处。
- en: 'The benefits of having a reverse proxy server (Nginx) are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有反向代理服务器（Nginx）的好处如下：
- en: It can act as a load balancer.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以作为负载均衡器。
- en: It can provide access control and rate limiting.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以提供访问控制和速率限制。
- en: It can sit in front of a cluster of applications and redirect HTTP requests.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以位于应用程序集群的前端，并重定向HTTP请求。
- en: It can serve a filesystem with a good performance.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以以良好的性能服务文件系统。
- en: It streams media very well.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在流媒体方面表现良好。
- en: If the same machine is running on multiple applications, then we can bring all
    of those  applications under one umbrella. Nginx can also act as the API gateway
    that can be the starting point for multiple API endpoints. We will explore a dedicated
    API gateway in the next chapter, but it is good to know that Nginx can also work
    as one.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同一台机器运行着多个应用程序，那么我们可以将这些应用程序统一在一个大伞下。Nginx还可以作为API网关，可以作为多个API端点的起点。我们将在下一章中探讨专门的API网关，但了解Nginx也可以作为网关使用是很好的。
- en: Nginx works as a traffic router for incoming requests. It is a protective shield
    for our application servers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx作为入站请求的交通路由器。它是我们应用程序服务器的保护盾。
- en: 'Take a look at the following diagram:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的图：
- en: '![](img/543de7d3-c339-49bc-b713-d5b5f293983b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/543de7d3-c339-49bc-b713-d5b5f293983b.png)'
- en: It has three apps running in different programming languages and **Client**
    only knows a single API endpoint. Let's say that all of the apps run on different
    ports.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行着三个使用不同编程语言编写的应用程序，并且**客户端**只知道一个API端点。假设所有这些应用程序都在不同的端口上运行。
- en: As you can see, the diagram **Client** is talking directly to **Nginx** instead
    of the ports where other applications are running. In the diagram, Go is running
    on port `8000` and other applications are running on different ports. This means
    that the different servers are providing different API endpoints.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，图中**客户端**是直接与**Nginx**对话，而不是与其他应用程序运行的端口。在图中，Go运行在端口`8000`上，其他应用程序运行在不同的端口上。这意味着不同的服务器提供不同的API端点。
- en: Without Nginx, if the client wishes to call an API, it needs to access three
    different endpoints (ports). Instead, if we have Nginx, it can act as a reverse
    proxy server for all three and simplifies the client request-response cycle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Nginx，如果客户端想要调用API，它需要访问三个不同的端点（端口）。相反，如果我们有Nginx，它可以作为三个应用程序的反向代理服务器，简化客户端请求-响应周期。
- en: Nginx is also an upstream server. An upstream server serves the requests from
    one server to the other. From the diagram, you can see that a Python app can request
    an API endpoint from a Go app and Nginx will take care of routing them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx也是一个上游服务器。上游服务器负责将一个服务器的请求转发到另一个服务器。从图中可以看出，Python应用程序可以从Go应用程序请求API端点，而Nginx将负责路由它们。
- en: Important Nginx paths
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的Nginx路径
- en: There are a few important Nginx paths that we need to know about in order to
    work with the proxy server. In Nginx, we can host multiple sites (`www.example1.com`,
    `www.example2.com`, and so on) at the same time. This means that many API servers
    can be run under one Nginx instance.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与代理服务器一起工作，我们需要了解一些重要的Nginx路径。在Nginx中，我们可以同时托管多个网站（例如`www.example1.com`、`www.example2.com`等）。这意味着许多API服务器可以在一个Nginx实例下运行。
- en: You should be aware of the following paths in the table to configure Nginx properly.
    An advanced deployment may require bypassing authentication (for example, the
    Health check API), rate limiting, and a backup of the logs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解表中的以下路径，以便正确配置Nginx。高级部署可能需要绕过身份验证（例如，健康检查API）、速率限制和日志备份。
- en: 'Take a look at the following table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的表格：
- en: '| **Type** | **Path** | **Description** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **路径** | **描述** |'
- en: '| `Configuration` | `/etc/nginx/nginx.conf` | This is the base Nginx configuration
    file. It can be used as the default file. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `配置` | `/etc/nginx/nginx.conf` | 这是基本的Nginx配置文件。它可以作为默认文件使用。 |'
- en: '| `Configuration` | `/etc/nginx/sites-available/` | If we have multiple sites
    running within Nginx, we can have a configuration file for each site. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `配置` | `/etc/nginx/sites-available/` | 如果我们在Nginx中运行多个网站，我们可以为每个网站有一个配置文件。
    |'
- en: '| `Configuration` | `/etc/nginx/sites-enabled/` | These are the sites currently
    activated on Nginx. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `配置` | `/etc/nginx/sites-enabled/` | 这些是当前在Nginx上激活的网站。 |'
- en: '| `Log` | `/var/log/nginx/access.log` | This log file records the server activity,
    such as timestamps and API endpoints.  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `日志` | `/var/log/nginx/access.log` | 此日志文件记录服务器活动，如时间戳和API端点。  |'
- en: '| `Log` | `/var/log/nginx/error.log` | This log file logs all proxy server-related
    errors, such as disk space, filesystem permissions, and more. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `日志` | `/var/log/nginx/error.log` | 此日志文件记录所有代理服务器相关的错误，如磁盘空间、文件系统权限等。 |'
- en: These paths are in the Linux operating system. For Mac OS X, use `/usr/local/nginx`
    as the base path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些路径位于Linux操作系统上。对于Mac OS X，使用`/usr/local/nginx`作为基本路径。
- en: In the next section, we will explore server blocks that are mainly used for
    configuring applications with Nginx.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨主要用于配置Nginx应用程序的服务器块。
- en: Using server blocks
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务器块
- en: 'Server blocks are the actual configuration pieces that tell the server what
    to serve and on which port to listen. We can define multiple server blocks in
    the `sites-available` folder. On Ubuntu, the location will be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器块是实际配置组件，告诉服务器要提供什么服务以及要在哪个端口上监听。我们可以在`sites-available`文件夹中定义多个服务器块。在Ubuntu上，位置如下：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Mac OS X, the location will be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，位置如下：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Until we create a symlink from the `sites-available` to the `sites-enabled`
    directory, the configuration has no effect. So, always create a symlink for `sites-available`
    to `sites-enabled` for every new configuration you create.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建从`sites-available`到`sites-enabled`目录的符号链接之前，配置没有效果。因此，始终为每个新创建的配置创建`sites-available`到`sites-enabled`的符号链接。
- en: Deploying a Go service using Nginx
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nginx部署Go服务
- en: 'As we have already discussed, Nginx can be a reverse proxy for a Go application.
    Let''s say that we have a server that provides a REST API to access book data.
    A client can send a request and get it back in JSON. The server also stores all
    the logs in an external file. Let''s take a look at the steps to create this application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，Nginx可以作为一个Go应用的反向代理。假设我们有一个提供REST API以访问书籍数据的服务器。客户端可以发送请求并返回JSON格式的响应。服务器还把所有日志存储在外部文件中。让我们看看创建此应用程序的步骤：
- en: 'Let''s name our project `bookServer`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们给我们的项目命名为`bookServer`：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This file is a basic Go server to illustrate the functioning of a reverse proxy
    server. We first run our program on port `8000`. Then, we add a configuration
    that maps `8000` (Go's running port) to `80` (the Nginx HTTP port).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是一个基本的Go服务器，用于说明反向代理服务器的工作原理。我们首先在端口`8000`上运行我们的程序。然后，我们添加一个配置，将`8000`（Go的运行端口）映射到`80`（Nginx
    HTTP端口）。
- en: 'Now, let''s write the code. We will use a few packages for our server. We can
    use Go''s built-in `net/http` package for server implementation:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码。我们将为我们的服务器使用几个包。我们可以使用Go的内置`net/http`包来实现服务器：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now our server needs a struct to hold the book information. Let''s create a
    struct with fields such as `ID`, `ISBN`, `Author`, and `PublishedYear`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要一个结构体来存储书籍信息。让我们创建一个具有`ID`、`ISBN`、`Author`和`PublishedYear`等字段的struct：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now goes our `main` function. It should open a file for writing logs. We can
    do that using the `os.Openfile` function. This takes the file and mode as arguments.
    Let''s name the file `app.log`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进入我们的 `main` 函数。它应该打开一个文件用于写入日志。我们可以使用 `os.Openfile` 函数来实现。这个函数需要文件和模式作为参数。让我们将文件命名为
    `app.log`：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The file permission, `os.O_RDWR|os.O_CREATE|os.O_APPEND`, allows the Go program
    to create, write, and append to the file. `log.SetOutput(f)` redirects app logs
    to the file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 文件权限，`os.O_RDWR|os.O_CREATE|os.O_APPEND`，允许 Go 程序创建、写入和追加到文件。`log.SetOutput(f)`
    将应用日志重定向到文件。
- en: 'Now, create a function handler and attach it to a route using the `net/http`
    function. The handler converts a struct into JSON and returns it as an HTTP response.
    Also, attach that handler to a route called `/api/books`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个函数处理程序并将其附加到一个路由上，使用 `net/http` 函数。处理程序将结构体转换为 JSON 并将其作为 HTTP 响应返回。还将该处理程序附加到名为
    `/api/books` 的路由：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The previous code block essentially returns a book whenever a client requests `/api/books`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码块在客户端请求 `/api/books` 时实际上返回一本书。
- en: 'Now, start an HTTP server that serves the whole application on port `8000`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动一个在端口 `8000` 上为整个应用程序提供服务的 HTTP 服务器：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This finishes the main program.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了主程序。
- en: 'We can run our application and see whether it is running correctly:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以运行我们的应用程序并查看它是否运行正确：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, open a shell and make a `curl` command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开一个 shell 并执行一个 `curl` 命令：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It returns the data:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回数据：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, the client needs to request to port `8000`. So, how can we proxy this
    server using Nginx? As we previously discussed, we need to edit the default `sites-available`
    server block, called `default`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，客户端需要请求端口 `8000`。那么，我们如何使用 Nginx 代理这个服务器呢？正如我们之前讨论的，我们需要编辑默认的 `sites-available`
    服务器块，称为 `default`：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Edit the preceding file, find the server block, and add `proxy_pass` to it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑前面的文件，找到服务器块，并添加 `proxy_pass` 到它：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This section of the `config` file is called a `server` block. This controls
    the setting up of the proxy server where `listen` says where `nginx` should listen.
    `root`and `index` point to the static files if we need to serve any file. `server_name`is
    the domain name of yours.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `config` 文件的这一部分被称为 `server` 块。它控制代理服务器的设置，其中 `listen` 表示 `nginx` 应该监听的位置。`root`
    和 `index` 指向静态文件，如果我们需要提供任何文件。`server_name` 是你的域名。
- en: 'Since we don''t have a domain name with us, it is just localhost. `location`is
    the key section here. In `location`, we can define our `proxy_pass`, which can
    reverse proxy to a given `URL:PORT`. Since our Go application is running on port `8000`,
    we mentioned it there. Let''s try running our app on a different domain, `example.com`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有域名，所以这里只是 localhost。`location` 是这里的关键部分。在 `location` 中，我们可以定义我们的 `proxy_pass`，它可以反向代理到给定的
    `URL:PORT`。由于我们的 Go 应用程序运行在端口 `8000` 上，我们在那里提到了它。让我们尝试在不同的域名 `example.com` 上运行我们的应用程序：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can give the same name as a parameter to `proxy_pass`. In order to take
    this configuration into effect, we need to restart the Nginx server. You can do
    that using the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相同的名称作为参数传递给 `proxy_pass`。为了使此配置生效，我们需要重新启动 Nginx 服务器。你可以使用以下命令来完成：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, make a `curl` request to `http://localhost` and you will see the Go application''s
    output:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `http://localhost` 发送一个 `curl` 请求，你将看到 Go 应用程序的输出：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `location` is a directive that defines a **Unified Resource Identifier**
    (**URI**) that can proxy a given `server:port` combination. This means that, by
    defining various URI, we can proxy multiple applications running on the same server.
    It looks like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`location` 是一个指令，它定义了一个 **统一资源标识符**（**URI**），它可以代理给定的 `server:port` 组合。这意味着，通过定义各种
    URI，我们可以代理同一服务器上运行的多达多个应用程序。它看起来像这样：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, three applications are running on different ports. These, after being
    added to our configuration file, can be accessed by the client as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，有三个应用程序在不同的端口上运行。这些，在被添加到我们的配置文件后，可以被客户端如下访问：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the next section, we explore how to load balance API requests to multiple
    instances of applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将 API 请求负载均衡到应用程序的多个实例。
- en: Load balancing with Nginx
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Nginx 进行负载均衡
- en: 'In practical cases, multiple servers are deployed instead of one for handling
    huge sets of incoming requests for APIs. But, who should forward an incoming client request
    to a server instance? A load balancer does that job. Load balancing is a process
    where the central server distributes the load to various servers based on certain
    criteria. Refer to the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下，为了处理大量针对 API 的传入请求，通常会部署多个服务器而不是一个。但是，谁应该将传入的客户端请求转发到服务器实例呢？负载均衡器负责这项工作。负载均衡是一个过程，其中中央服务器根据某些标准将负载分配给各个服务器。参考以下图表：
- en: '![](img/929be2ee-6e11-4130-9016-93ce0a4e8b74.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/929be2ee-6e11-4130-9016-93ce0a4e8b74.jpeg)'
- en: 'A load balancer employs few strategies such as `Round Robin` or `Least Connection`
    for routing requests to instances. Let''s take a look at what each does in a simple
    table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器采用一些策略，如 `Round Robin` 或 `Least Connection`，来路由请求到实例。让我们通过一个简单的表格来看看每个方法的作用：
- en: '| **Load-balancing method** | **Description** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **负载均衡方法** | **描述** |'
- en: '| `Round Robin` | The incoming requests are uniformly distributed across servers
    based on the criteria of server weights. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `Round Robin` | 根据服务器权重标准，将传入请求均匀地分配到服务器。 |'
- en: '| `Least Connection` | Requests are sent to the server that is currently serving
    the least number of clients. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Least Connection` | 请求被发送到当前正在为最少客户端服务的服务器。 |'
- en: '| `IP Hash` | This is used to send the requests from a given client''s IP to
    the given server. Only when that server is not available is it given to another
    server.  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `IP Hash` | 这用于将来自给定客户端 IP 的请求发送到指定的服务器。只有当该服务器不可用时，才会将其发送到另一个服务器。  |'
- en: '| `Least Time` | A request from the client is sent to the machine with the
    lowest average latency (the time-to-serve client) and the least number of active
    connections. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Least Time` | 来自客户端的请求被发送到具有最低平均延迟（服务客户端的时间）和最少活动连接数的机器。 |'
- en: We can set which strategy to apply for load balancing in the Nginx configuration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Nginx 配置中设置用于负载均衡的策略。
- en: 'Let''s explore how load balancing is practically achieved in Nginx for our
    Go API servers. The first step in this process is to create an `upstream cluster`
    in the `http` section of the Nginx configuration file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何在 Nginx 中实际实现负载均衡，以适用于我们的 Go API 服务器。这个过程的第一步是在 Nginx 配置文件的 `http` 部分创建一个
    `upstream cluster`：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, servers are the IP addresses or domain names of the servers running the
    same code. We are defining an upstream called cluster here. It is a server group
    that we can refer to in our `location` directive. Weights should be given in proportion
    to the resources available. In the preceding code, `site1` is given a higher weight
    because it may be a bigger instance (memory and CPU). Now, in the `location` directive,
    we can specify the server group with the `proxy_pass` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，服务器是运行相同代码的服务器的 IP 地址或域名。我们在这里定义了一个名为 cluster 的上游。它是一个服务器组，我们可以在 `location`
    指令中引用它。权重应根据可用的资源成比例分配。在前面的代码中，`site1` 被分配了更高的权重，因为它可能是一个更大的实例（内存和 CPU）。现在，在 `location`
    指令中，我们可以使用 `proxy_pass` 命令指定服务器组：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the proxy server that is running will pass requests to the machines in
    the cluster for all API endpoints hitting the `/` endpoint. The default request
    routing algorithm will be `Round Robin`, which means that all of the server''s
    turns will be repeated one after the other. If we need to change it, we can mention
    that in the upstream definition. Take a look at the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正在运行的代理服务器将把所有针对 `/` 端点的 API 端点请求传递给集群中的机器。默认的请求路由算法将是 `Round Robin`，这意味着服务器的轮次将依次重复。如果我们需要更改它，我们可以在上游定义中提及。看看以下代码片段：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding configuration says to *create a cluster of three machines and
    add load balancing method as least connections*. `least_conn` is the string we
    used to mention the load balancing method. The other values could be `ip_hash`
    or `least_time`. You can try this by having a set of machines in the **Local Area
    Network** (**LAN**). Otherwise, we can have Docker installed with multiple virtual
    containers as different machines to test out load balancing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置表示要创建一个由三台机器组成的集群，并将负载均衡方法设置为 `least connections`。"least_conn" 是我们用来提及负载均衡方法的字符串。其他值可以是
    `ip_hash` 或 `least_time`。您可以通过在 **局域网**（**LAN**）中有一组机器来尝试此操作。否则，我们可以安装 Docker
    并使用多个虚拟容器作为不同的机器来测试负载均衡。
- en: We need to add that `http` block in the `/etc/nginx/nginx.conf` file, whereas
    the server block is in `/etc/nginx/sites-enabled/default`.It is better to separate
    these two settings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `/etc/nginx/nginx.conf` 文件中添加那个 `http` 块，而服务器块在 `/etc/nginx/sites-enabled/default`
    中。最好将这两个设置分开。
- en: 'Here''s a small exercise: try to run three `bookServer` instances on different
    ports and enable load balancing on Nginx. In the next section, we''ll examine
    how to rate limit an API in Nginx for certain clients.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小练习：尝试在不同的端口上运行三个 `bookServer` 实例，并在 Nginx 上启用负载均衡。在下一节中，我们将探讨如何在 Nginx
    中对特定客户端的 API 进行速率限制。
- en: Rate limiting our REST API
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制我们的 REST API
- en: 'We can also limit the rate of access to our Nginx proxy server by rate limiting.
    This provides a directive called `limit_conn_zone` ([http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone](http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone)).
    The format of it is this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过速率限制来限制对 Nginx 代理服务器的访问速率。这提供了一个名为 `limit_conn_zone` 的指令（[http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone](http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html#limit_conn_zone)）。其格式如下：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`client_type` can be one of two types:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`client_type` 可以是两种类型之一：'
- en: An IP address (limit requests from a given IP address)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP 地址（限制来自特定 IP 地址的请求）
- en: A server name (limit requests from a server)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器名称（限制来自服务器的请求）
- en: '`zone_type`also changes in correspondence to `client_type`. It takes values
    as per the following table:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`zone_type` 也会根据 `client_type` 而变化。它取值如下表所示：'
- en: '| **Client type** | **Zone type** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **客户端类型** | **区域类型** |'
- en: '| `$binary_remote_address` | `addr` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `$binary_remote_address` | `addr` |'
- en: '| `$server_name` | `servers` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `$server_name` | `servers` |'
- en: 'Nginx has to save a few things in memory to remember the IP addresses and servers
    for rate limiting. The `size` parameter is the storage that we allocate for Nginx
    to perform its memory operations. It takes values such as 8 m (8 MB) or 16 m (16
    MB). Now, let''s take a look at where to add these settings. The preceding one
    should be added as a global setting to the `http` directive in the `nginx.conf`
    file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 必须在内存中保存一些东西以记住用于速率限制的 IP 地址和服务器。`size` 参数是我们为 Nginx 分配以执行其内存操作的空间。它取值如
    8 m（8 MB）或 16 m（16 MB）。现在，让我们看看在哪里添加这些设置。前面的设置应作为全局设置添加到 `nginx.conf` 文件中的 `http`
    指令：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This allocates the shared memory for Nginx to use. Now, in the server directive
    of `sites-available/default`, add the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这为 Nginx 使用分配了共享内存。现在，在 `sites-available/default` 的服务器指令中添加以下内容：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The total number of connections for the given server will not exceed `1000`
    in the preceding configuration using `limit_conn`. If we try to put the rate limit
    from a given IP address to the client, then use this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中使用 `limit_conn`，给定服务器的总连接数不会超过 `1000`。如果我们尝试将速率限制从给定 IP 地址到客户端，则使用以下方法：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This setting stops a client (that is, IP address) from opening more than one
    connection to the server (for example, in an online railway booking session, a
    user can only use one session per IP address to book tickets). If we have a file
    that the client downloads and need to set a bandwidth constraint, use `limit_rate`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置阻止客户端（即 IP 地址）向服务器打开超过一个连接（例如，在在线铁路订票会话中，用户每个 IP 地址只能使用一个会话来订票）。如果我们有一个客户端下载的文件并需要设置带宽限制，请使用
    `limit_rate`：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this way, we can control the client's interaction with our services that
    are proxied under Nginx.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以控制客户端与我们的在 Nginx 下代理的服务之间的交互。
- en: Securing our Nginx proxy server
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护我们的 Nginx 代理服务器
- en: 'This is the most important piece in the Nginx setup. In this section, we will
    look at how to restrict access to our server using basic authentication. This
    is very important for our REST API servers because, suppose we have servers *X*, *Y*,
    and *Z* that can talk to each other. *X* can serve clients directly, but *X* consults
    *Y* and *Z* for some information by calling an internal API. We should prevent
    clients from accessing *Y* and *Z*. We can allow or deny IP addresses using the `nginx`
    access module. It looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Nginx 设置中最重要的一部分。在本节中，我们将探讨如何使用基本身份验证来限制对服务器的访问。这对我们的 REST API 服务器非常重要，因为，假设我们有服务器
    *X*、*Y* 和 *Z* 可以相互通信。*X* 可以直接服务客户端，但 *X* 通过调用内部 API 向 *Y* 和 *Z* 获取一些信息。我们应该阻止客户端访问
    *Y* 和 *Z*。我们可以使用 `nginx` 访问模块允许或拒绝 IP 地址。它看起来是这样的：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This configuration tells Nginx to allow requests from clients ranging `192.168.1.1/24`,
    excluding `192.168.1.2`. The next line tells us to allow requests from the same
    host and block all other requests from any other client. The complete server block
    looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置告诉 Nginx 允许来自 `192.168.1.1/24` 范围内的客户端请求，排除 `192.168.1.2`。下一行告诉我们允许来自同一主机的请求，并阻止来自任何其他客户端的所有其他请求。完整的服务器块如下所示：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For more information regarding this, you can refer to the documentation at [http://nginx.org/en/docs/http/ngx_http_access_module.html?_ga=2.117850185.1364707364.1504109372-1654310658.1503918562](http://nginx.org/en/docs/http/ngx_http_access_module.html?_ga=2.117850185.1364707364.1504109372-1654310658.1503918562).
    We can also add password-secured access to our Nginx serving static files. It
    is mostly not applicable to the API because there, the application takes care
    of authenticating the user. The whole idea is to only allow the IP that is approved
    by us and deny all other requests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此方面的更多信息，您可以参考 [http://nginx.org/en/docs/http/ngx_http_access_module.html?_ga=2.117850185.1364707364.1504109372-1654310658.1503918562](http://nginx.org/en/docs/http/ngx_http_access_module.html?_ga=2.117850185.1364707364.1504109372-1654310658.1503918562)
    上的文档。我们还可以为我们的 Nginx 服务器提供的静态文件添加密码保护的访问。这主要不适用于 API，因为在那里，应用程序负责验证用户。整个想法是只允许我们批准的
    IP，并拒绝所有其他请求。
- en: Nginx can only serve requests when the application server's health is good.
    If the application crashes, we have to restart it manually. A crash can occur
    from a system shutdown, a problem in the network storage, or various other external
    factors. In the next section, we will discuss a process monitoring tool called
    `supervisord` that can automatically restart a crashed application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 只能在应用程序服务器健康时提供服务请求。如果应用程序崩溃，我们必须手动重启它。崩溃可能由系统关闭、网络存储问题或各种其他外部因素引起。在下一节中，我们将讨论一个名为
    `supervisord` 的进程监控工具，它可以自动重启崩溃的应用程序。
- en: Monitoring our Go API server with Supervisord
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Supervisord 监控我们的 Go API 服务器
- en: Sometimes, a web application server may stop due to an operating system restarting
    or crashing. Whenever a web server is killed, it is someone's job to bring it
    back to life. It is wonderful if that is automated. Supervisord is a tool that
    comes to the rescue. To make our API server run all of the time, we need to monitor
    it and recover it quickly. Supervisord is a generic tool that can monitor running
    processes (systems) and can restart them when they are terminated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于操作系统重启或崩溃，Web 应用程序服务器可能会停止。每当 Web 服务器被终止时，就有人的工作是将其恢复。如果这可以自动化，那就太好了。Supervisord
    是一个救命的工具。为了使我们的 API 服务器始终运行，我们需要监控它并快速恢复。Supervisord 是一个通用的工具，可以监控正在运行的过程（系统），并在它们终止时重新启动它们。
- en: Installing Supervisord
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Supervisord
- en: We can easily install Supervisord using Python's `pip` command.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的 `pip` 命令轻松安装 Supervisord。
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On Ubuntu 18.04, you can also use the `apt-get` command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ubuntu 18.04 上，您还可以使用 `apt-get` 命令：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This installs two tools, `supervisor` and `supervisorctl`. `Supervisorctl` is
    intended to control the supervisor to add tasks, restart tasks, and more.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装两个工具，`supervisor` 和 `supervisorctl`。`Supervisorctl` 用于控制 supervisor，以添加任务、重启任务等。
- en: 'Let''s use the `bookServer.go` program we created for illustrating process
    monitoring. Install the binary to the `$GOPATH/bin` directory using this command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们为说明进程监控而创建的 `bookServer.go` 程序。使用以下命令将二进制文件安装到 `$GOPATH/bin` 目录：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Always add `$GOPATH/bin` to the system path. Whenever you install the project
    binary, it is available as a normal executable from the overall system environment.
    You can add following line to the `~/.profile` or `~/.bashrc` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总是添加 `$GOPATH/bin` 到系统路径。每次安装项目二进制文件时，它都可以作为普通可执行文件从整体系统环境中使用。您可以将以下行添加到 `~/.profile`
    或 `~/.bashrc` 文件：
- en: '`export PATH=$PATH:$GOPATH/bin`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`export PATH=$PATH:$GOPATH/bin`'
- en: 'Now, create a new configuration file for `supervisor`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为 `supervisor` 创建一个新的配置文件：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The supervisor reads this file and looks for processes to monitor and rules
    to apply when they are started/stopped.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Supervisor 读取此文件，并查找要监控的进程以及它们启动/停止时应用的规则。
- en: You can add any number of configuration files and `supervisord` treats them
    as separate processes to run.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加任意数量的配置文件，`supervisord` 将它们视为单独的进程来运行。
- en: 'By default, we have a file called `supervisord.conf` in `/etc/supervisor/`.
    Look at it for further reference:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们在 `/etc/supervisor/` 中有一个名为 `supervisord.conf` 的文件。查看它以获取更多信息：
- en: The `[supervisord]` section gives the location of the log file for `supervisord`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[supervisord]` 部分给出了 `supervisord` 的日志文件位置。'
- en: '`[program:myserver]` is the task block that defines a command.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[程序：myserver]` 是一个任务块，它定义了一个命令。'
- en: 'Modify the content of the `supervisord.conf` file to the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `supervisord.conf` 文件的内容修改为以下内容：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The command in the file is the command to launch the application server. `/root/workspace`
    is `$GOPATH`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的命令是启动应用程序服务器的命令。`/root/workspace` 是 `$GOPATH`。
- en: Please use an absolute path while running a command in Supervisord. Relative
    paths will not work by default.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Supervisord 中运行命令时，请使用绝对路径。默认情况下，相对路径将不起作用。
- en: 'Now, we can ask our `supervisorctl reread` to reread the configuration and
    start the task (process). For that, just say the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以要求我们的 `supervisorctl reread` 重新读取配置并启动任务（进程）。为此，只需说出以下内容：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, launch the controller tool, `supervisorctl`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动控制器工具，`supervisorctl`：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You should see something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下内容：
- en: '![](img/e175901e-6972-410f-9f84-fd8e0be4bdec.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e175901e-6972-410f-9f84-fd8e0be4bdec.png)'
- en: 'So, here, our book service is getting monitored by `Supervisor`. Let''s try
    to kill the process manually and see what `Supervisor` does:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们的书籍服务正在被 `Supervisor` 监控。让我们尝试手动终止进程并看看 `Supervisor` 会做什么：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, as soon as possible, `Supervisor` starts a new process (using a different
    pid) by running the binary:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Supervisor` 会立即启动一个新的进程（使用不同的 pid），通过运行二进制文件：
- en: '![](img/cb4790ea-1ec2-43c3-b4f9-42f5b6092c50.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb4790ea-1ec2-43c3-b4f9-42f5b6092c50.png)'
- en: 'This is very useful in a production where a service requires the least downtime.
    So, how do we start/stop an application service manually? well, you can use the `start`
    and `stop` commands from `supervisorctl` for those operations:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这在生产环境中非常有用，因为一个服务需要最少的停机时间。那么，我们如何手动启动/停止应用程序服务呢？嗯，你可以使用 `supervisorctl` 的
    `start` 和 `stop` 命令来执行这些操作：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For more information about the supervisor, visit [http://supervisord.org/](http://supervisord.org/).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `supervisor` 的信息，请访问 [http://supervisord.org/](http://supervisord.org/)。
- en: In the next section, we will try to simplify our deployment using containers.
    We will launch the application and Nginx as separate containers and establish
    a communication channel between them with the help of `docker-compose`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将尝试通过使用容器来简化我们的部署。我们将分别启动应用程序和 Nginx 作为独立的容器，并借助 `docker-compose` 在它们之间建立通信通道。
- en: Makefile and Docker Compose-based deployment
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefile 和基于 Docker Compose 的部署
- en: 'Until now, we have seen the manual deployment of a reverse proxy server (Nginx).
    Let''s automate that by gluing things together. We are going to use a few tools,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了反向代理服务器（Nginx）的手动部署。让我们通过将事物粘合在一起来自动化它。我们将使用一些工具，如下所示：
- en: '`Make`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Make`'
- en: '`docker-compose`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose`'
- en: 'On Linux-based machines (Ubuntu and Mac OS X), `Make` is available as part
    of GCC (the C language toolchain). You can install `docker-compose` using the
    Python `pip` tool:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Linux 的机器（Ubuntu 和 Mac OS X）上，`Make` 作为 GCC（C 语言工具链）的一部分可用。你可以使用 Python
    的 `pip` 工具安装 `docker-compose`：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: On Windows OS, `docker-compose` is already available as part of Docker Desktop.
    Our goal is to bundle all deployable entities with one single `Make` command.
    `Makefile` is used to write control commands for the application. You should define
    a rule and the `Make` tool will execute it ([https://www.gnu.org/software/make/manual/make.html#Rule-Example](https://www.gnu.org/software/make/manual/make.html#Rule-Example)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 操作系统上，`docker-compose` 已经作为 Docker Desktop 的一部分可用。我们的目标是使用单个 `Make`
    命令将所有可部署实体捆绑在一起。`Makefile` 用于编写应用程序的控制命令。你应该定义一个规则，然后 `Make` 工具将执行它（[https://www.gnu.org/software/make/manual/make.html#Rule-Example](https://www.gnu.org/software/make/manual/make.html#Rule-Example)）。
- en: 'Let''s create a directory called `deploySetup`. It holds the whole code we
    are going to show. It has two directories – one for the app and another for Nginx:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `deploySetup` 的目录。它包含了我们将要展示的所有代码。它包含两个子目录——一个用于应用程序，另一个用于 Nginx：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s copy our `bookServer` project into `deploySetup` like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的 `bookServer` 项目复制到 `deploySetup` 中，如下所示：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We need this to build an executable and copy it to the container. We should
    containerize both the Go application and Nginx in order to use them together.
    So, this is the plan for creating such a workflow:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做来构建可执行文件并将其复制到容器中。为了将 Go 应用程序和 Nginx 一起使用，我们应该将它们都容器化。因此，这是创建此类工作流程的计划：
- en: Create a `Dockerfile` for copying Go build into the container.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Dockerfile` 以将 Go 构建复制到容器中。
- en: Create an Nginx configuration file called `nginx.conf` to copy into Nginx container.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `nginx.conf` 的 Nginx 配置文件以复制到 Nginx 容器中。
- en: Write a `Makefile` to build binary as well as deploy the containers.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `Makefile` 以构建二进制文件以及部署容器。
- en: So, first, we should build and run the docker containers for application and
    Nginx. For that, we can use `docker-compose`. The `docker-compose` tool is very
    handy for managing multiple containers. It also builds and runs the containers
    on the fly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们应该构建并运行应用程序和Nginx的docker容器。为此，我们可以使用`docker-compose`。`docker-compose`工具在管理多个容器时非常方便。它还可以动态构建和运行容器。
- en: 'In the `bookServer` directory, we need a Dockerfile that stores a project build
    binary. Let''s say we build our project in `app`. We use Alpine Linux (lightweight)
    as the base Docker image, so we should target our build to that Linux platform.
    We should copy the binary on the Docker container and execute it. Let''s say we
    chose the app path as `/go/bin/app`. Create a `Dockerfile` at this location:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bookServer`目录中，我们需要一个Dockerfile来存储项目构建的二进制文件。假设我们在`app`中构建我们的项目。我们使用Alpine
    Linux（轻量级）作为基础Docker镜像，因此我们应该将构建目标设置为该Linux平台。我们应该在Docker容器中复制二进制文件并执行它。假设我们选择了app路径为`/go/bin/app`。在这个位置创建一个`Dockerfile`：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Dockerfile` looks like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`看起来像这样：'
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The Dockerfile is basically pulling the Alpine Linux image. It creates and sets
    the working directory for the application binary. Then, it copies the application
    binary to the given path, `/go/bin`. After copying, it runs the binary.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile基本上是拉取Alpine Linux镜像。它为应用程序的二进制文件创建并设置工作目录。然后，它将应用程序的二进制文件复制到指定的路径，即`/go/bin`。复制完成后，它运行该二进制文件。
- en: 'Before copying the application binary, someone has to build it. Let''s write
    a `Make` command for building `bookServer` in this `Makefile` here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制应用程序二进制文件之前，必须有人构建它。让我们在这个`Makefile`中编写一个构建`bookServer`的`Make`命令：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It consists of commands and their respective executions. First, let''s add
    a `build` command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 它由命令及其相应的执行组成。首先，让我们添加一个`build`命令：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The top-level variables in the `Makefile` declare the project root and build
    (binary) name. It also composes the build commands. The interesting command is
    `build`, which simply calls the Go build tool with a few `GOOS` and `GOARCH` flags. Those
    `build` flags are required to target a `binary` for Alpine Linux. Now from the
    `deploySetup` directory, run this command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile`中的顶级变量声明了项目根目录和构建（二进制）名称。它还组合了构建命令。有趣的命令是`build`，它只是简单地使用一些`GOOS`和`GOARCH`标志调用Go构建工具。这些`build`标志是针对Alpine
    Linux的二进制文件所必需的。现在从`deploySetup`目录运行此命令：'
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you look in the `bookServer` directory, there is an `app` binary newly created.
    That is our application server. We are launching this binary directly in the container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`bookServer`目录，会发现有一个新创建的`app`二进制文件。那是我们的应用程序服务器。我们直接在容器中启动这个二进制文件。
- en: 'Now, let''s create a `docker-compose` file that defines two services:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个定义两个服务的`docker-compose`文件：
- en: '`App Service`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`App 服务`'
- en: '`Nginx Service`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Nginx 服务`'
- en: 'Each of these services has instructions for where to build the image, which
    ports to be opened, which network bridge to be used, and more. For more information
    about `docker-compose`, please refer to (`https://docs.docker.com/compose/`).
    Let''s create a `docker-compose.yml` file in the `deploySetup` directory:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务中的每一个都有关于在哪里构建镜像、要打开哪些端口、要使用哪个网络桥接器等指令。有关`docker-compose`的更多信息，请参阅（`https://docs.docker.com/compose/`）。让我们在`deploySetup`目录中创建一个`docker-compose.yml`文件：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this file, we are defining a network called `app-network` and two services,
    namely `app` and `nginx`. For the `app` service, we are pointing to `bookServer`
    to pick `Dockerfile` to build an image.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们定义了一个名为`app-network`的网络和两个服务，即`app`和`nginx`。对于`app`服务，我们指向`bookServer`以选择`Dockerfile`来构建镜像。
- en: 'We don''t need the `supervisord` tool in the Docker deployment because `docker-compose`
    takes care of restarting crashed containers. It takes a decision from the `restart:
    unless-stopped` option in the `docker-compose` file.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '在Docker部署中，我们不需要`supervisord`工具，因为`docker-compose`负责重启崩溃的容器。它从`docker-compose`文件中的`restart:
    unless-stopped`选项做出决定。'
- en: 'For the `nginx` service in the Compose file, it pulls a default `nginx:alpine`
    image from Docker Hub. However, as we have to copy our own configuration file
    to the Nginx server, we should create a file in the `nginx-conf` directory:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Compose文件中的`nginx`服务从Docker Hub拉取默认的`nginx:alpine`镜像。然而，由于我们必须将我们自己的配置文件复制到Nginx服务器，我们应该在`nginx-conf`目录中创建一个文件：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can mount our configuration file in the `nginx-conf` directory to `/etc/nginx/conf.d`
    in the container using the `volumes` option. Both services use the same network
    so that they can discover each other. The Nginx service exposes port 80 to host,
    but `app` only opens up its port internally on `8000`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `volumes` 选项将 `nginx-conf` 目录中的配置文件挂载到容器中的 `/etc/nginx/conf.d`。这两个服务使用相同的网络，以便它们可以相互发现。Nginx
    服务将端口 80 暴露给主机，但 `app` 只在内部打开 `8000` 端口。
- en: 'Our `nginx.conf` file should have the proxy information like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `nginx.conf` 文件应该包含如下代理信息：
- en: '[PRE55]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `nginx.conf` file defines an upstream service. It connects to app service
    in `docker-compose.yml`. This is possible because of the bridging of the network.
    `docker-compose` takes care of assigning a hostname for the application container.
    In the last block, we are defining a location that reverses proxy requests to
    the `upstream service`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`nginx.conf` 文件定义了一个上游服务。它连接到 `docker-compose.yml` 中的应用服务。这是由于网络的桥接才成为可能。`docker-compose`
    负责为应用容器分配主机名。在最后一个块中，我们定义了一个位置，它将反向代理请求转发到 `upstream service`。'
- en: 'Now, everything is ready. The `docker-compose.yml` file, Supervisord configuration,
    and Nginx configuration are in place. `docker-compose` has an option to start
    Docker containers by building images as specified in the `compose` file. We can
    bring containers up using this command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切准备就绪。`docker-compose.yml` 文件、Supervisord 配置和 Nginx 配置都已就绪。`docker-compose`
    有一个选项可以通过构建 `compose` 文件中指定的镜像来启动 Docker 容器。我们可以使用此命令启动容器：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s update the `Makefile` to add two new commands—one to `deploy`, and another
    one to `build` and `deploy` containers:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `Makefile` 以添加两个新命令——一个用于 `deploy`，另一个用于 `build` 和 `deploy` 容器：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With the `deploy` command, we are cleaning up the containers first and then
    launching new ones. We added one more command called `all`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `deploy` 命令，我们首先清理容器，然后启动新的容器。我们添加了一个名为 `all` 的额外命令。
- en: 'The `make all` command is a universal command that executes when no command
    is passed. For example, consider the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`make all` 命令是一个通用命令，在没有传递任何命令时执行。例如，考虑以下情况：'
- en: '[PRE58]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This executes `make all`. Our plan is to build the binary, and start the Docker
    containers using `docker-compose`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行 `make all`。我们的计划是构建二进制文件，并使用 `docker-compose` 启动 Docker 容器。
- en: 'Now, we have everything we need. From Terminal, run `make` to see the servers
    up and running:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了所需的一切。从终端运行 `make` 命令以查看服务器正在运行：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can also confirm that the containers are up and running with the `docker
    ps` command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `docker ps` 命令来确认容器正在运行：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, make a `curl` request to see the server output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `curl` 发送请求以查看服务器输出：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Instead of calling the API with the port, now the client is accessing the REST
    API via Nginx. Nginx routes the request to the application server that is started
    in the container. With this deployment setup, we can make our code changes and
    just run the `make` command to update the application service.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不是通过端口调用 API，客户端现在通过 Nginx 访问 REST API。Nginx 将请求路由到容器中启动的应用服务器。在这种部署设置中，我们可以对代码进行更改，只需运行
    `make` 命令来更新应用服务。
- en: 'This is how Go applications can be containerized using `Makefile` and `docker-compose`.
    Servers stop gracefully when you hit *Ctrl *+ *C*. If you want them to run in
    the background, just add a `-d` flag to the `Makefile` `deploy` command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 `Makefile` 和 `docker-compose` 对 Go 应用进行容器化的方法。当你按下 *Ctrl *+ *C* 时，服务器会优雅地停止。如果你想让它们在后台运行，只需在
    `Makefile` 的 `deploy` 命令中添加一个 `-d` 标志：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`-d` stands for run containers as daemons. Now, containers silently run in
    the background, and logs for the `nginx` and `app` containers can be seen with
    the `docker inspect CONTAINER_ID` command.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d` 代表以守护进程运行容器。现在，容器在后台静默运行，可以使用 `docker inspect CONTAINER_ID` 命令查看 `nginx`
    和 `app` 容器的日志。'
- en: Things may not work properly if the base image (Alpine Linux, in our case) of
    the container is changed. Always consider the image-specific default configuration
    path for Nginx (`/etc/nginx/conf.d`) to copy the custom configuration.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改了容器的基础镜像（在我们的例子中是 Alpine Linux），可能会导致某些功能无法正常工作。始终考虑针对特定镜像的默认配置路径（对于 Nginx
    是 `/etc/nginx/conf.d`）以复制自定义配置。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter demonstrated how to prepare API services for deployment in production.
    We need a web proxy server, application server, and a process monitor for deployment.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了如何为生产部署准备 API 服务。我们需要一个网络代理服务器、应用服务器和一个进程监控器。
- en: Nginx is a web proxy server that can pass requests to multiple servers running
    on the same host or on a different host.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 是一个网络代理服务器，可以将请求传递到同一主机或不同主机上运行的多台服务器。
- en: 'We learned how to install Nginx and start configuring it. Nginx provides features
    such as load balancing and rate limiting, which are very important features for
    APIs to have. Load balancing is the process of distributing loads among similar
    servers. We explored all the available types of loading mechanisms: Round Robin,
    IP Hash, Least Connection, and more. Then, we looked at how to add access control
    to our servers by allowing and denying a few sets of IP addresses. We have to
    add rules in the Nginx server blocks to achieve that.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何安装 Nginx 并开始对其进行配置。Nginx 提供了诸如负载均衡和速率限制等特性，这些特性对于 API 来说非常重要。负载均衡是指将负载分配到相似服务器的过程。我们探讨了所有可用的加载机制类型：轮询（Round
    Robin）、IP 哈希（IP Hash）、最少连接（Least Connection）等。然后，我们探讨了如何通过允许和拒绝一些 IP 地址集合来为我们的服务器添加访问控制。我们必须在
    Nginx 服务器块中添加规则来实现这一点。
- en: Finally, we saw a process monitor named `Supervisord` that brings a crashed
    application back to life. We saw how to install Supervisord and also launch `supervisorctl`,
    a command-line application to control running servers. We then tried to automate
    the deployment process by creating a `Makefile` and `docker-compose` file. We
    also explored how to containerize a Go application along with Nginx using Docker
    and Docker Compose. In the real world, containers are the preferable way to deploy
    software.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了一个名为 `Supervisord` 的进程监控工具，它可以将崩溃的应用程序恢复到正常状态。我们学习了如何安装 Supervisord
    以及如何启动 `supervisorctl`，这是一个用于控制运行服务器的命令行应用程序。然后，我们尝试通过创建 `Makefile` 和 `docker-compose`
    文件来自动化部署过程。我们还探讨了如何使用 Docker 和 Docker Compose 将 Go 应用程序与 Nginx 容器化。在现实世界中，容器是部署软件的首选方式。
- en: In the next chapter, we are going to demonstrate how to make our REST services
    publicly visible with the help of AWS EC2 and Amazon API Gateway.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将演示如何借助 AWS EC2 和 Amazon API Gateway 使我们的 REST 服务公开可见。
