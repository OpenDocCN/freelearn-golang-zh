- en: Deploying REST Services on Amazon Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在亚马逊网络服务上部署REST服务
- en: After preparing a deployable ecosystem, we have to host that ecosystem on a
    cloud provider to make **application programming interface** (**API**) endpoints
    visible to the public internet. We need to leverage cloud services such as **Amazon
    Web Services** (**AWS**) **Elastic Compute Cloud** (**EC2**) to deploy web services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好可部署的生态系统后，我们必须在云服务提供商上托管该生态系统，以便使**应用程序编程接口**（**API**）端点对公共互联网可见。我们需要利用云服务，如**亚马逊网络服务**（**AWS**）的**弹性计算云**（**EC2**）来部署网络服务。
- en: The journey doesn't end right after deployment. We have to track our API usage
    and performance for a better understanding of the clients. Who are the clients
    that are connecting to an API? How frequent are their requests? How many failed
    authorizations and so on are important factors for fine-tuning an API? For better
    security, an API server should not be directly exposed to the public internet.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，旅程并未结束。我们必须跟踪我们的API使用情况和性能，以便更好地了解客户。连接到API的客户是谁？他们的请求频率如何？失败的授权数量等因素对于微调API非常重要。为了更好的安全性，API服务器不应直接暴露给公共互联网。
- en: In this chapter, we will explore AWS. However, sticking to a single cloud provider
    can be a problem for migration later. So, we will use a tool called Terraform
    to define and create our resources. Terraform is an **Infrastructure as Code**
    (**IaC**) tool that is cloud-agnostic. We provision an EC2 instance and an API
    Gateway in order to properly deploy our **Representational State Transfer** (**REST**)
    services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨AWS。然而，坚持使用单一云服务提供商可能会在后续迁移时遇到问题。因此，我们将使用一个名为Terraform的工具来定义和创建我们的资源。Terraform是一个**基础设施即代码**（**IaC**）工具，它具有云无关性。我们配置了一个EC2实例和一个API网关，以便正确部署我们的**表示状态传输**（**REST**）服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basics for working with AWS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS工作基础
- en: IaC with Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform进行IaC
- en: Why is an API Gateway required?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要API网关？
- en: Introducing AWS API Gateway
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍AWS API网关
- en: Other API Gateways
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他API网关
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following software should be pre-installed for running the code samples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件应预先安装以运行代码示例：
- en: 'Operating system: Linux (Ubuntu 18.04)/Windows 10/Mac OS X>= 10.13'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统：Linux (Ubuntu 18.04)/Windows 10/Mac OS X>= 10.13
- en: Go stable version compiler >= 1.13.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go稳定版本编译器 >= 1.13.5
- en: 'Dep: A dependency management tool for Go >= 0.5.3'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dep：Go的依赖管理工具 >= 0.5.3
- en: Docker version >= 18.09.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker版本 >= 18.09.2
- en: Terraform version >= 0.12.18
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform版本 >= 0.12.18
- en: You can download the code for this chapter from [https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter13](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter13).
    Clone the code, and use the code samples in the `chapter13` directory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter13](https://github.com/PacktPublishing/Hands-On-Restful-Web-services-with-Go/tree/master/chapter13)下载本章的代码。克隆代码，并使用`chapter13`目录中的代码示例。
- en: Basics for working with AWS
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS工作基础
- en: 'AWS is a cloud provider that manages the infrastructure for cloud applications.
    The other big players are Microsoft Azure and **Google Cloud Platform** (**GCP**).
    Each of them is equipped with many diverse solutions for managing a variety of
    artifacts, such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: AWS是一个管理云应用程序基础设施的云服务提供商。其他主要玩家包括微软Azure和**谷歌云平台**（**GCP**）。它们都配备了多种多样的解决方案来管理各种工件，如下所示：
- en: Applications
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: Databases
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库
- en: Message queues
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列
- en: Network
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Docker image management
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像管理
- en: Event buses
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件总线
- en: There are multiple types of managed services for running applications. We'll
    discuss a few in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序的托管服务有多种类型。我们将在下一节讨论其中的一些。
- en: Managed services for applications from AWS
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS的应用程序托管服务
- en: An application should be hosted on a cloud server to serve an API to the public
    internet. That server can be an independent machine or a container. AWS provides
    a standalone server called a **virtual machine **(**VM**), in the form of EC2\.
    AWS EC2 is a managed service that provides easy creation and teardown of VMs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序应该托管在云服务器上，以向公共互联网提供API服务。该服务器可以是独立机器或容器。AWS提供了一个名为**虚拟机**（**VM**）的独立服务器，即EC2。AWS
    EC2是一种托管服务，它提供了VM的轻松创建和拆卸。
- en: '**Elastic Container Service** (**ECS**), another managed service from AWS,
    allows developers to run their applications in containers. A Go application can
    be bundled into a Docker image and deployed on AWS ECS.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹性容器服务** （**ECS**），AWS 的另一种托管服务，允许开发者在其容器中运行应用程序。Go 应用程序可以打包到 Docker 镜像中，并在
    AWS ECS 上部署。'
- en: '**AWS Lambda** is another managed service that can run serverless functions.
    This is a service that runs Go functions. These functions are short-lived and
    suitable for use cases such as **Extract-Transform-Load** (**ETL) **on data. A
    lambda function definition takes compiled Go code and can run thousands of lambda
    instances on demand.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS Lambda** 是另一种托管服务，可以运行无服务器函数。这是一个运行 Go 函数的服务。这些函数是短暂的，适用于例如 **数据提取-转换-加载**
    （**ETL**） **的数据** 等用例。Lambda 函数定义接受编译后的 Go 代码，并且可以根据需求运行数千个 Lambda 实例。'
- en: Depending on the use case, we should pick the right service for running our
    application. The Docker container-based ECS is preferable over EC2 for running
    long-running services as well as short-lived applications because of its simplified
    build, push, and deploy cycle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例，我们应该选择适合运行我们应用程序的正确服务。由于简化了构建、推送和部署周期，基于 Docker 容器的 ECS 在运行长期运行服务和短暂应用程序方面比
    EC2 更受欢迎。
- en: 'In this chapter, we will try to leverage AWS EC2 to deploy an API server. Next,
    we secure our server using Amazon API Gateway. The following chart can guide you
    about picking the right AWS service for managing a Go application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试利用 AWS EC2 来部署 API 服务器。接下来，我们将使用 Amazon API Gateway 保护我们的服务器。以下图表可以指导您选择合适的
    AWS 服务来管理 Go 应用程序：
- en: '| **Type** | **Where To Use** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **使用位置** |'
- en: '| `AWS Lambda` | Functions that live less than 15 minutes (as per the time
    of writing) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `AWS Lambda` | 存活时间少于 15 分钟（根据写作时间）的函数 |'
- en: '| `AWS ECS` | Short-lived and long-running services with AWS-managed containers
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `AWS ECS` | 使用 AWS 管理容器的短暂和长期运行服务 |'
- en: '| `AWS EC2` | Long-running services with a self-managed VM |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `AWS EC2` | 使用自管理 VM 的长期运行服务 |'
- en: In the next section, we'll see how to set up an AWS Free Tier account. We will
    use that account for all our code examples in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解如何设置 AWS 免费层账户。我们将使用该账户在本章的所有代码示例中。
- en: Setting up an AWS account
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 AWS 账户
- en: We need an AWS account to work on this chapter. If you don't have one, you can
    try AWS for 1 year, using the Free Tier program: [https://aws.amazon.com/free/](https://aws.amazon.com/free/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 AWS 账户来完成本章的工作。如果您还没有，您可以使用 AWS 免费层计划试用 1 年：[https://aws.amazon.com/free/](https://aws.amazon.com/free/)。
- en: After signing up for the Free Tier, we can get access to our AWS account by
    setting a password. AWS accounts have a custom URL, where account administrators
    and other users can log in to the account dashboard: [https://console.aws.amazon.com/billing/home?#/account](https://console.aws.amazon.com/billing/home?#/account).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册免费层后，我们可以通过设置密码来访问我们的 AWS 账户。AWS 账户有一个自定义 URL，账户管理员和其他用户可以登录到账户仪表板：[https://console.aws.amazon.com/billing/home?#/account](https://console.aws.amazon.com/billing/home?#/account)。
- en: All the main services are free, but with a few limits. So, always monitor the
    free-tier usage of AWS services while testing. AWS offers a unique model of roles
    called **Identity and Access Management** (**IAM**). This enables new users to
    be created and gives permissions to various services.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要服务都是免费的，但有一些限制。因此，在测试时始终监控 AWS 服务的免费层使用情况。AWS 提供了一种独特的角色模型，称为 **身份和访问管理**
    （**IAM**）。这允许创建新用户并授予各种服务的权限。
- en: After we set up our AWS account, we should create IAM users and roles. But for
    the sake of simplicity, we will proceed with the account we created previously,
    where the creator is automatically an admin. We should allow programmatic access
    to our AWS account in order to deploy applications.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置 AWS 账户后，我们应该创建 IAM 用户和角色。但为了简单起见，我们将使用之前创建的账户，其中创建者自动是管理员。我们应该允许以编程方式访问我们的
    AWS 账户以便部署应用程序。
- en: 'There are three ways we can interact with AWS to provision managed services:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方式可以与 AWS 交互以提供托管服务：
- en: AWS console
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS 控制台
- en: AWS **Command-Line Interface** (**CLI**) tool
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS **命令行界面** （**CLI**） 工具
- en: Third-party **Software Development Kit** (**SDK**)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方 **软件开发工具包** （**SDK**）
- en: In the first option, a user logs in to an AWS account and manually configures
    the AWS resources. In the second one, a user can install the client on their machine
    and manage resources using a command-line API. The third option is very low-level,
    where third-party libraries wrap the AWS API and provide a clean interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种选项中，用户登录 AWS 账户并手动配置 AWS 资源。在第二种情况下，用户可以在他们的机器上安装客户端并使用命令行 API 管理资源。第三种选项非常底层，第三方库封装
    AWS API 并提供干净的接口。
- en: 'For the second and third options, a security credential has to be generated.
    A security credential consists of two keys:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种和第三种选项，必须生成安全凭证。安全凭证由两个密钥组成：
- en: Access Key ID
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问密钥 ID
- en: Secret access key
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密访问密钥
- en: This security credential is used to authenticate any third-party applications
    with AWS. It can be obtained by navigating to IAM| Users| User| Name| Security
    Credentials on the AWS account and performing a Create Access Key operation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此安全凭证用于验证任何第三方应用程序与 AWS。可以通过在 AWS 账户中导航到 IAM| 用户| 用户| 名称| 安全凭证并执行创建访问密钥操作来获取。
- en: Creating an `access_key_id` also generates a `secret_access_key`. These should
    be stored in a safe place. If you lose your secret key, you have to delete it
    from the IAM security credentials and create a new one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `access_key_id` 也会生成一个 `secret_access_key`。这些应该存储在安全的地方。如果您丢失了秘密密钥，您必须从 IAM
    安全凭证中删除它并创建一个新的。
- en: Once a user obtains an access key ID and a secret access key successfully, they
    should create two files in the `.aws` directory in the `home` path.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户成功获得访问密钥 ID 和秘密访问密钥，他们应该在 `home` 路径的 `.aws` 目录中创建两个文件。
- en: 'On Linux and Mac OS X, create two files with the names `credentials` and `config`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Mac OS X 上，创建两个名为 `credentials` 和 `config` 的文件：
- en: '`~/.aws/credentials`:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.aws/credentials`:'
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`~/.aws/config`:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.aws/config`:'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The credential file holds information about the access key and the secret access
    key in order to authenticate with AWS. The configuration file configures settings
    such as the AWS region in operation and the AWS CLI output format, such as JSON,
    XML, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 凭证文件包含有关访问密钥和秘密访问密钥的信息，以便与 AWS 进行身份验证。配置文件配置设置，例如操作的 AWS 区域和 AWS CLI 输出格式，如
    JSON、XML 等。
- en: On Windows, files should be created in `C:\> dir "%UserProfile%\.aws"`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，文件应在 `C:\> dir "%UserProfile%\.aws"` 中创建。
- en: You have to replace the `YOUR_ACCESS_KEY_ID` and  `YOUR_SECRET_KEY` variables
    with actual security credentials from your AWS account.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须将 `YOUR_ACCESS_KEY_ID` 和 `YOUR_SECRET_KEY` 变量替换为 AWS 账户中的实际安全凭证。
- en: The region in the configuration file is the geographical location where the
    application is hosted. In the preceding configuration, we picked Frankfurt(eu-central-1)
    as the preferred region. You should select the region that's closed to the client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件中的区域是应用程序托管的地域位置。在前面的配置中，我们选择了法兰克福（eu-central-1）作为首选区域。您应该选择离客户端较近的区域。
- en: Our goal is to run an application behind the API Gateway on AWS. Instead of
    doing that manually from the AWS console, we are going to use a tool called Terraform.
    Terraform provides IaC, where we can have Terraform scripts record the resource
    creation on AWS. AWS provides an in-house IaC solution called **CloudFormation**.
    Terraform is much simpler—as well as less verbose—than AWS CloudFormation. In
    the next section, we'll explore Terraform and its internals.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在 AWS 的 API Gateway 后运行应用程序。而不是手动从 AWS 控制台进行操作，我们将使用一个名为 Terraform 的工具。Terraform
    提供了 IaC，我们可以让 Terraform 脚本记录 AWS 上的资源创建。AWS 提供了一个内部 IaC 解决方案，称为 **CloudFormation**。与
    AWS CloudFormation 相比，Terraform 更简单，以及更简洁。在下一节中，我们将探讨 Terraform 及其内部结构。
- en: IaC with Terraform
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 进行 IaC
- en: '**Terraform** is a software tool for provisioning infrastructure on cloud platforms,
    including AWS. Using Terraform, we can create, configure, or delete resources.
    Terraform allows automatic resource provisioning compared to the AWS Console.
    When compared to low-level REST APIs and SDKs, Terraform has a clean, high-level
    API. Terraform stores the current state of provisioned infrastructure in a state
    file.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform** 是一种用于在云平台上（包括 AWS）提供基础设施的软件工具。使用 Terraform，我们可以创建、配置或删除资源。与 AWS
    控制台相比，Terraform 允许自动资源提供。与低级 REST API 和 SDK 相比，Terraform 具有干净、高级的 API。Terraform
    将已提供基础设施的当前状态存储在状态文件中。'
- en: Let's say the infrastructure provisioned on an account should be replicated
    on another account as part of disaster recovery. If we do not have IaC, all resources
    have to be reconfigured manually. However, if the whole infrastructure is modeled
    in the form of Terraform scripts, then it is easy to replay the infrastructure
    on any number of accounts. This approach is very readable and maintainable compared
    to hand-wiring infrastructure on the AWS console.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设要在另一个账户上复制在账户上配置的基础设施作为灾难恢复的一部分。如果没有IaC，所有资源都必须手动重新配置。然而，如果整个基础设施以Terraform脚本的形式建模，那么在任意数量的账户上重新播放基础设施就变得容易了。与在AWS控制台上手动配置基础设施相比，这种方法可读性和可维护性更强。
- en: 'Terraform provisions almost all AWS managed services on the Cloud. It should
    be run from a local machine. It generates state files while provisioning. See
    the following diagram for provisioning direction:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform在云上几乎提供了所有AWS托管服务。它应该在本地机器上运行。在提供时，它生成状态文件。请参阅以下图示以了解提供方向：
- en: '![](img/33ebc2b1-eda6-439e-b579-ee40bfd9dcf7.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33ebc2b1-eda6-439e-b579-ee40bfd9dcf7.png)'
- en: A Terraform installation binary for all platforms can be obtained here: [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平台的Terraform安装二进制文件都可以在这里获得：[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)。
- en: 'For Linux and Mac OS X, copy the executable to the respective binary paths
    so that it is available system-wide. Confirm your installation with this command.
    It prints out the `version` of the `Terraform` software you''ve installed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux和Mac OS X，将可执行文件复制到相应的二进制路径，以便在系统范围内可用。使用此命令确认您的安装。它将打印出您安装的`Terraform`软件的`version`：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To give a brisk introduction to Terraform, let us provision an EC2 instance
    for our REST API server using the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对Terraform进行简要介绍，让我们按照以下步骤为我们的REST API服务器提供EC2实例：
- en: 'Create a project directory called `intro` to hold the script for the provisioning
    EC2 instance, like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`intro`的项目目录来存放提供EC2实例的脚本，如下所示：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All Terraform files have a `.tf` file extension. So, add a script called `api_server.tf`,
    like this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有Terraform文件都有`.tf`文件扩展名。因此，添加一个名为`api_server.tf`的脚本，如下所示：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The language syntax of a Terraform file looks like this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Terraform文件的语法看起来像这样：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we can see, a Terraform script is made up of four fundamental building blocks:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Terraform脚本由四个基本构建块组成：
- en: '**Block Type**: A set of predefined block types by Terraform—for example, resource
    and data.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块类型**：Terraform预定义的一组块类型——例如，资源和数据。'
- en: '**Block Label**: The namespace of a block type in a Terraform script.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块标签**：Terraform脚本中块类型的命名空间。'
- en: '**Identifier**: The variable inside a block.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标识符**：块内的变量。'
- en: '**Expression**: The value of the variable inside a block.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式**：块内变量的值。'
- en: You can check out all the possible values of these four entities in the Terraform
    configuration language at [https://www.terraform.io/docs/configuration/index.html](https://www.terraform.io/docs/configuration/index.html).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.terraform.io/docs/configuration/index.html](https://www.terraform.io/docs/configuration/index.html)查看这些四个实体的所有可能值。
- en: 'Now comes the actual script, `api_server.tf`. It should have two blocks, `provider`
    and `resource` like so:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是实际的脚本，`api_server.tf`。它应该有两个块，`provider`和`resource`，如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `provider` block defines the type of cloud provider to use and configures
    the security credentials and region. The `resource` block is used to define the
    type of resource to be provisioned and its attributes. Here, we are provisioning
    an EC2 instance, thus we provided `aws_instance` as the resource type. The `api_server`
    is the name of the instance that gets created. There are many instance types provided
    by EC2\. Here, we use the smaller-capacity instance called `t2.micro`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider`块定义了要使用的云提供商类型，并配置了安全凭据和区域。`resource`块用于定义要提供的资源类型及其属性。在这里，我们正在提供EC2实例，因此我们提供了`aws_instance`作为资源类型。`api_server`是创建的实例的名称。EC2提供了许多实例类型。在这里，我们使用容量较小的实例`t2.micro`。'
- en: AWS uses an **Amazon Machine Image** (**AMI**) to create a virtual machine.
    We picked Ubuntu 18.04 as the `ami-03818140b4ac9ae2b` operating system image in
    the Terraform file. You can find the AMI image closest to your region here: [https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: AWS使用**Amazon Machine Image**（**AMI**）来创建虚拟机。我们在Terraform文件中选择了Ubuntu 18.04作为`ami-03818140b4ac9ae2b`操作系统映像。您可以在以下位置找到与您所在区域最接近的AMI映像：[https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/)。
- en: The attributes can change according to the resource type. So, if we pick a different
    resource, we have to check the Terraform documentation for appropriate attributes.
    In the preceding resource block, we only defined two attributes: `ami` and `instance_type`.
    Those two attributes are mandatory for the AWS EC2 API. All other attributes—such
    as network, security groups, and CPU—default to reasonable values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以根据资源类型而变化。因此，如果我们选择不同的资源，我们必须检查Terraform文档以获取适当的属性。在前面的资源块中，我们只定义了两个属性：`ami`和`instance_type`。这两个属性对于AWS
    EC2 API是强制性的。所有其他属性，如网络、安全组和CPU，默认为合理的值。
- en: 'Now, run the script from the `intro` directory, as follows:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从`intro`目录运行脚本，如下所示：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The script outputs the following message, and also asks for confirmation of
    the `apply` process:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本输出以下消息，并要求确认`apply`过程：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It successfully created the EC2 instance. We can navigate to the EC2 section
    on the AWS console to see our instance up and running, as shown in the following
    screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功创建了EC2实例。我们可以导航到AWS控制台上的EC2部分，查看我们的实例正在运行，如下面的截图所示：
- en: '![](img/846fd16e-1287-408a-878b-ccf8f1b7551f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/846fd16e-1287-408a-878b-ccf8f1b7551f.png)'
- en: Details such as Availability Zone, Public IP, and so on are automatically assigned
    because we didn't specify them as attributes in the Terraform file. AWS creates
    a default **Virtual Private Cloud** (**VPC**), subnets, and a public **Domain
    Name System** (**DNS**).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在Terraform文件中将它们指定为属性，因此自动分配了如可用区、公共IP等详细信息。AWS创建了一个默认的**虚拟专用网络**（**VPC**）、子网和一个公共**域名系统**（**DNS**）。
- en: 'If you observe carefully, `terraform apply` generates the following additional
    files in the directory:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，`terraform apply`会在目录中生成以下附加文件：
- en: '`terraform.tfstate`: This holds the JSON plan that is executed with AWS.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform.tfstate`：这包含与AWS执行的JSON计划。'
- en: '`.terraform`: This is a directory that holds plugins, depending on the provider.
    In our case, the provider type is AWS.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.terraform`：这是一个目录，包含插件，取决于提供者。在我们的例子中，提供者类型是AWS。'
- en: Terraform installs a provider-related executable in the project's `.terraform`
    directory. This is to reduce the file size of the Terraform binary, which excludes
    the packages for compiling scripts to other cloud providers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform在项目的`.terraform`目录中安装与提供者相关的可执行文件。这是为了减少Terraform二进制文件的文件大小，排除编译脚本到其他云提供者的包。
- en: The plugin version in `.terraform/plugins` also has a version. You should have
    the latest plugin to benefit from up-to-date Terraform syntax. Otherwise, the
    syntax for referencing one resource in another may raise errors. To be safe, please
    upgrade the plugin to the latest version using this command: `terraform 0.12upgrade`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`.terraform/plugins`中的插件版本也有一个版本号。你应该使用最新的插件来从最新的Terraform语法中受益。否则，引用另一个资源时可能会引发错误。为了安全起见，请使用以下命令升级插件到最新版本：`terraform
    0.12upgrade`。'
- en: 'We have successfully provisioned an EC2 instance, but it is useless until we
    can SSH into it. For that, we should provide a key pair. Let''s look at the steps
    to do that, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功配置了一个EC2实例，但直到我们可以SSH进入它之前，它都是无用的。为此，我们应该提供一个密钥对。让我们看看如何操作的步骤，如下所示：
- en: 'You can generate a public/private key pair on your local machine like this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在本地机器上生成一个公钥/私钥对，如下所示：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This generates public and private key files in the `~/.ssh` directory. A public
    key is for other parties to encrypt data, and a private key is for the owner to
    decrypt that data. Your public key file's default name is `id_rsa.pub` .
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在`~/.ssh`目录中生成公钥和私钥文件。公钥用于其他方加密数据，私钥用于所有者解密该数据。你的公钥文件的默认名称是`id_rsa.pub`。
- en: 'Create a new resource type called `aws_key_pair` in the `api_server.tf` file,
    like this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`api_server.tf`文件中创建一个新的资源类型名为`aws_key_pair`，如下所示：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding block, Terraform creates a new AWS key-pair resource called
    `api_server_key`. It takes a `key_name` and a `public_key`. This is your newly
    created public key. AWS adds this key to `~/.ssh/known_hosts` on an EC2 instance
    so that you can log in to the VM once the provision is successful.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的块中，Terraform创建了一个名为`api_server_key`的新AWS密钥对资源。它需要一个`key_name`和一个`public_key`。这是你新创建的公钥。AWS将此密钥添加到EC2实例上的`~/.ssh/known_hosts`，以便在配置成功后登录到虚拟机。
- en: 'Next, we should link this newly created resource to our main resource `aws_instance`,
    as follows:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们应该将这个新创建的资源链接到我们的主要资源`aws_instance`，如下所示：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can see the plan that Terraform executes with the `terraform plan`
    command, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以看到使用`terraform plan`命令执行的Terraform计划，如下所示：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As it clearly states in the preceding log, Terraform performs the creation of
    one new resource, `aws_key_pair`, and recreates the server. The Terraform `plan`
    step is a good way to inspect changes before applying them on AWS.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述日志中明确指出的，Terraform 执行了一个新资源 `aws_key_pair` 的创建，并重新创建了服务器。Terraform 的 `plan`
    步骤是在 AWS 上应用更改之前检查更改的好方法。
- en: 'Now, let us actually apply the changes with the `terraform apply` command,
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实际使用 `terraform apply` 命令来应用这些更改，如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, in the AWS account console (browser), navigate to the EC2| NETWORK &
    SECURITY| Key Pairs section. You will find the newly added key pair there, as
    shown in the following screenshot:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 AWS 账户控制台（浏览器）中，导航到 EC2| 网络 & 安全 |密钥对部分。您将在那里找到新添加的密钥对，如下面的截图所示：
- en: '![](img/77b9c398-3eb8-448a-85e7-4d04f88501ea.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77b9c398-3eb8-448a-85e7-4d04f88501ea.png)'
- en: Now, in order to SSH into our EC2 instance, we need the public DNS of the instance.
    We can get the public DNS either from the AWS console or from the `terraform.tfstate`
    file.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了 SSH 进入我们的 EC2 实例，我们需要实例的公共 DNS。我们可以从 AWS 控制台或从 `terraform.tfstate` 文件中获取公共
    DNS。
- en: 'The public DNS, in our case, is `ec2-52-59-192-138.eu-central-1.compute.amazonaws.com`.
    We can now SSH into this system as a Ubuntu user, like this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们这个例子中，公共 DNS 是 `ec2-52-59-192-138.eu-central-1.compute.amazonaws.com`。现在我们可以以
    Ubuntu 用户身份 SSH 进入这个系统，如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command picks the `~/.ssh` folder and locates the private key. It then
    does a handshake with the public key we linked with the EC2 instance.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令选择 `~/.ssh` 文件夹并定位到私钥。然后它与与 EC2 实例关联的公钥进行握手。
- en: The Ubuntu image comes almost zero configured. Software such as the Go compiler,
    Docker, and docker-compose is not installed by default on the Ubuntu EC2 instance.
    We have to install them before deploying our application. Make sure you SSH into
    the machine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 镜像几乎没有任何配置。Go 编译器、Docker 和 docker-compose 等软件默认情况下并未安装在 Ubuntu EC2 实例上。在部署我们的应用程序之前，我们必须安装它们。确保您已
    SSH 进入该机器。
- en: 'Install the latest version of the Go compiler and Docker, like this:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装最新版本的 Go 编译器和 Docker，如下所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install `docker-compose`, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `docker-compose`，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you may have notice, the username we used for SSH is `ubuntu`. It depends
    on the AMI used for instance provision. For example, if the image is an Amazon
    Linux Image, then the SSH username will be `ec2-user`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，我们用于 SSH 的用户名是 `ubuntu`。这取决于用于实例配置的 AMI。例如，如果镜像是一个亚马逊 Linux 镜像，那么
    SSH 用户名将是 `ec2-user`。
- en: In the next section, we'll walk through the deployment of a REST API on an EC2
    instance. We will use the previously provisioned machine in our journey.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍在 EC2 实例上部署 REST API 的过程。我们将使用我们旅程中之前配置的机器。
- en: Deploying a service on EC2
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 EC2 上部署服务
- en: 'So far we''ve provisioned an EC2 instance with a public DNS. Now, we need an
    API to deploy on the instance. Let us use the `bookServer` containerized application from
    [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing REST
    Services for Deployment*. There, we developed a Go API server that serves book
    details on an endpoint. In this section, let us try to deploy that ecosystem on
    an AWS EC2 instance. Let''s look at the steps to deploy `bookServer` on AWS EC2,
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了一个具有公共 DNS 的 EC2 实例。现在，我们需要一个 API 来在实例上部署。让我们使用 [第 12 章](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml)
    中的 `bookServer` 容器化应用程序，“为部署容器化 REST 服务”。在那里，我们开发了一个 Go API 服务器，在端点上提供书籍详情。在本节中，让我们尝试在
    AWS EC2 实例上部署该生态系统。让我们看看在 AWS EC2 上部署 `bookServer` 的步骤，如下所示：
- en: 'Copy the code from `chapter12/deploySetup` into the `/home/ubuntu` directory
    of the instance. You can do that using the `scp` command, like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `chapter12/deploySetup` 中的代码复制到实例的 `/home/ubuntu` 目录。您可以使用 `scp` 命令完成此操作，如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command copies the source code from [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing
    REST Services for Deployment*,to the target instance. We have our application
    code ready. The code has a `Makefile` that builds the Go binary and deploys various
    containers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 [第 12 章](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml)，“为部署容器化 REST 服务”，中的源代码复制到目标实例。我们的应用程序代码已经准备好了。代码有一个
    `Makefile`，用于构建 Go 可执行文件并部署各种容器。
- en: 'If you remember building the `deploySetup` application from [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing
    REST Services for Deployment*, then you''ll remember that we can launch nginx,
    the application server, and `supervisord` using the `make` command, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还记得从 [第 12 章](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml)，“为部署容器化 REST 服务”中构建的
    `deploySetup` 应用程序，那么您会记得我们可以使用 `make` 命令启动 nginx 应用服务器和 `supervisord`，如下所示：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This step builds and starts Docker containers in the background, as shown here:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤在后台构建并启动 Docker 容器，如下所示：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need to use `sudo make` instead of `make` because of user permissions. The
    default `ubuntu` user doesn't have permissions to the Docker daemon by default.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户权限，我们需要使用 `sudo make` 而不是 `make`，因为默认的 `ubuntu` 用户默认没有对 Docker 守护进程的权限。
- en: 'Now, the nginx container and app container are up and running. We can confirm
    this with the `docker ps` command, as shown in the following code block:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，nginx 容器和应用容器都在运行。我们可以使用以下代码块中的 `docker ps` 命令来确认这一点：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This shows that our nginx and app containers are up and running on the EC2 instance,
    and nginx is serving on port `80`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的 nginx 和应用容器正在 EC2 实例上运行，nginx 正在端口 `80` 上提供服务。
- en: Get the public IP from the AWS console or the `terraform.tfstate` file.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 AWS 控制台或 `terraform.tfstate` 文件中获取公网 IP。
- en: Always confirm the ports that have been exposed for Docker containers. The format
    `0.0.0.0:80->80/tcp` means the container TCP port `80` forwards packets to the
    host port `80`. In our case, the host is an EC2 instance and the container is
    nginx.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总是确认已暴露的 Docker 容器端口。格式 `0.0.0.0:80->80/tcp` 表示容器 TCP 端口 `80` 将数据包转发到主机端口 `80`。在我们的例子中，主机是一个
    EC2 实例，容器是 nginx。
- en: 'In our case, the instance''s public IP is `52.59.192.138`. Refer to the following
    screenshot to see where we can find out the public IP from the AWS console EC2
    instances section:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，实例的公网 IP 是 `52.59.192.138`。请参考以下截图，以了解我们如何在 AWS 控制台 EC2 实例部分找到公网 IP：
- en: '![](img/d0c339c0-a385-40c2-b165-e759991ed3b0.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0c339c0-a385-40c2-b165-e759991ed3b0.png)'
- en: 'Make a `curl` request to the `http://public-ip/api/books` endpoint from your
    host machine (not from the EC2 instance). You''ll get a JSON response back from
    the server, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的宿主机（不是从 EC2 实例）向 `http://public-ip/api/books` 端点发起 `curl` 请求。您将从服务器获得以下 JSON
    响应：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Hurray! Our API has been published to the web and is accessible worldwide.
    Here, nginx is acting as an entry point to HTTP requests. The setup we deployed
    is a minimal way to publish an API on AWS. In a real-world scenario, you have
    to do a few more things, such as the following, to secure the API:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 哈喽！我们的 API 已经发布到网络上，并且可以在全球范围内访问。在这里，nginx 正在充当 HTTP 请求的入口点。我们部署的设置是在 AWS 上发布
    API 的最小方式。在现实世界的场景中，你必须做更多的事情，例如以下内容，以保护 API：
- en: Serve requests on HTTPS (by adding certificates)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加证书在 HTTPS 上处理请求
- en: Configure the VPC, subnets, and security groups properly
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确配置 VPC、子网和安全组
- en: Adding the preceding recommendations to our EC2 instance is out of the scope
    of this book. Please refer to the AWS documentation on these topics for more information.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的建议添加到我们的 EC2 实例超出了本书的范围。请参考 AWS 关于这些主题的文档以获取更多信息。
- en: In the next section, we'll configure our EC2 instance with Amazon API Gateway.
    As we discussed at the beginning of this chapter, an AWS Gateway is a primary
    way to secure EC2 instances.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 Amazon API Gateway 配置我们的 EC2 实例。正如我们在本章开头讨论的那样，AWS 网关是保护 EC2 实例的主要方式之一。
- en: Why is an API Gateway required?
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要 API 网关？
- en: 'Suppose a company named `XYZ` developed an API for its internal purposes. There
    are two ways in which it exposes that API for external use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一家名为 `XYZ` 的公司为其内部用途开发了一个 API。它有两种方式将此 API 暴露给外部使用：
- en: It exposes it using authentication from known clients.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用已知客户端的认证来暴露它。
- en: It exposes it as an API as a service.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将其作为一项服务以 API 的形式暴露。
- en: In the first case, this API is consumed by the other services inside the company.
    Since they are internal, we don't restrict access. But in the second case, since
    the API details are given to the outside world, we need a broker in-between to
    check and validate the requests. This broker is the API Gateway. An API Gateway
    is a broker that sits in-between the client and the server and forwards the request
    to the server, on the passing of specific conditions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，此 API 由公司内部的其他服务消费。由于它们是内部的，我们没有限制访问。但在第二种情况下，由于 API 详细信息已经提供给外部世界，我们需要一个中间代理来检查和验证请求。这个代理就是
    API 网关。API 网关是一个位于客户端和服务器之间的代理，在满足特定条件后将请求转发到服务器。
- en: 'Now, the company `XYZ` has an API written in Go and also in Java. There are
    a few common things that apply to any API:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，公司 `XYZ` 有一个用 Go 编写的 API 和一个用 Java 编写的 API。有一些适用于任何 API 的共同点：
- en: Authentication
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Logging of requests and responses
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录请求和响应
- en: Without an API Gateway, we need to write another server that tracks things such
    as requests and authentication of the API. This can be hectic to implement and
    maintain when new APIs keep being added to the organization. To take care of these
    basic things, an API Gateway is a fine piece of middleware.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 没有API网关，我们需要编写另一个服务器来跟踪诸如请求和API认证等事项。当组织不断添加新的API时，实现和维护这些基本功能可能会变得很繁琐。为了处理这些基本事务，API网关是一块很好的中间件。
- en: 'Basically, an API Gateway does these things:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，API网关做以下事情：
- en: Logging
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: Security
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Traffic control
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交通控制
- en: Middleware
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件
- en: Logging is the way in which we track requests and responses. In contrast to
    application-level logging, which happens in the Go web server, an API Gateway
    can support organization-level logging across multiple applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是我们跟踪请求和响应的方式。与在Go网络服务器中发生的应用级日志记录不同，API网关可以支持跨多个应用程序的组织级日志记录。
- en: Authentication is a part of securing applications. It can be basic authentication,
    token-based authentication, OAuth2.0, and so on. It is essential to restrict access
    to the API for valid customers/clients.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是应用安全的一部分。它可以是基本认证、基于令牌的认证、OAuth2.0等。对于限制对API的有效客户/客户端的访问至关重要。
- en: Traffic control comes into play when an API is a paid service. When an organization
    sells data as an API, it needs to limit the operations per client. For example,
    a client can make 10,000 API requests per month. The rate can be set according
    to the plan the client has opted for. This is a very important feature.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当API是一项付费服务时，交通控制就派上用场。当组织以API的形式销售数据时，需要限制每个客户端的操作次数。例如，一个客户端每月可以发起10,000次API请求。可以根据客户端选择的计划设置速率。这是一个非常重要的功能。
- en: Middleware is for modifying the request before it hits the application server
    or for modifying the response before it is sent back to the client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件用于在请求到达应用服务器之前修改请求，或者在将响应发送回客户端之前修改响应。
- en: 'Take a look at the following diagram:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图示：
- en: '![](img/b421c07d-fa75-4a71-8ee2-2b9b2b7223ca.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b421c07d-fa75-4a71-8ee2-2b9b2b7223ca.png)'
- en: The preceding diagram depicts an **API Gateway** accepting all **client** requests.
    The API Gateway can forward requests to respective API servers based on HTTP headers,
    URL path prefix, or IP address. Once the API server finishes its job, the **API
    Gateway** collects an intermediate response and returns it to the **Client**.
    In this chapter, we'll try to leverage Amazon API Gateway.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了接受所有**客户端**请求的**API网关**。API网关可以根据HTTP头、URL路径前缀或IP地址将请求转发到相应的API服务器。一旦API服务器完成其工作，**API网关**收集中间响应并将其返回给**客户端**。在本章中，我们将尝试利用Amazon
    API网关。
- en: Introducing Amazon API Gateway
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Amazon API网关
- en: 'Amazon API Gateway has the following features:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon API网关具有以下功能：
- en: Reverse proxy service
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向代理服务
- en: Rate limiting
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Monitoring
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Authentication
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: '**Reverse proxying** is the process of passing a REST API request to another
    endpoint. Amazon API Gateway can register a REST endpoint with a custom path and
    method. It forwards a matching request to the application server. It can also
    authenticate using AWS user credentials, as well as security tokens. The user
    has to be created on AWS IAM in order to access the API.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向代理**是将REST API请求传递到另一个端点的过程。Amazon API网关可以注册一个具有自定义路径和方法的REST端点。它将匹配的请求转发到应用服务器。它还可以使用AWS用户凭证以及安全令牌进行认证。用户必须在AWS
    IAM上创建，才能访问API。'
- en: Monitoring is possible by writing Gateway rules. The logs can be directed to
    AWS CloudWatch, which is another Amazon-offered service. When there are suspicious
    incoming requests, the Gateway can also raise a CloudWatch alarm. A CloudWatch
    alarm is a notification for special situations. These notifications can trigger
    other actions, such as sending an email or logging an event.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写网关规则可以实现监控。日志可以被定向到AWS CloudWatch，这是另一项由Amazon提供的服务。当有可疑的入站请求时，网关还可以触发CloudWatch警报。CloudWatch警报是针对特殊情况的通知。这些通知可以触发其他操作，例如发送电子邮件或记录事件。
- en: 'Now, let us provision an API Gateway for our EC2 instance. The architecture
    diagram looks like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的EC2实例配置一个API网关。架构图看起来像这样：
- en: '![](img/94e89dba-b3fb-4c2b-9d9b-b5d3baedd344.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94e89dba-b3fb-4c2b-9d9b-b5d3baedd344.png)'
- en: 'In the preceding diagram, the Amazon API Gateway defines methods and integrations.
    The target is an EC2 instance where a `books` API is deployed. We should configure
    six types of components to run API Gateway on AWS. Those are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，Amazon API Gateway 定义了方法和集成。目标是部署了 `books` API 的 EC2 实例。我们应该配置六种类型的组件来在
    AWS 上运行 API Gateway。具体如下：
- en: Gateway REST API
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关 REST API
- en: Gateway Method Request
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关方法请求
- en: Gateway Method Response
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关方法响应
- en: Gateway Integration Request
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关集成请求
- en: Gateway Integration Response
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关集成响应
- en: Gateway Deployment
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关部署
- en: 'Why do we have to create the preceding components? The Amazon API Gateway architecture
    defines these components in its design. See the following diagram to see how an
    API is represented on Amazon API Gateway:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们必须创建前面的组件？Amazon API Gateway 架构在其设计中定义了这些组件。参见以下图表，了解 API 在 Amazon API
    Gateway 上的表示方式：
- en: '![](img/d505974d-9119-47f8-8426-3d921edecf71.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d505974d-9119-47f8-8426-3d921edecf71.png)'
- en: The **Client** request is sent through the **Gateway Method Request** and **Integration
    Request** stages. The Integration Request stage then forwards the request to a
    configured API endpoint. That endpoint will be `/api/books` with the `GET` method
    and will be running on an EC2 instance. This finishes the request life cycle.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端**请求通过**网关方法请求**和**集成请求**阶段发送。集成请求阶段然后将请求转发到配置的 API 端点。该端点将是 `/api/books`，使用
    `GET` 方法，并且将在 EC2 实例上运行。这完成了请求的生命周期。'
- en: Next, the endpoint returns a response from the EC2 instance. This response is
    forwarded to the **Integration Response** stage and then to the **Gateway Method
    Response** stage. This finishes the response life cycle.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，端点从 EC2 实例返回一个响应。此响应被转发到**集成响应**阶段，然后到**网关方法响应**阶段。这完成了响应的生命周期。
- en: Each stage can be configured further to transform responses into different formats.
    For simplicity, we leave the default settings as they are for each stage. In the
    next section, we'll try to build the preceding components in Terraform.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都可以进一步配置，以将响应转换为不同的格式。为了简单起见，我们保留每个阶段的默认设置。在下一节中，我们将尝试在 Terraform 中构建前面的组件。
- en: Manually create the API Gateway for our API in the AWS console before writing
    Terraform scripts. This helps you understand the basic vocabulary of Amazon API
    Gateway.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 Terraform 脚本之前，在 AWS 控制台中手动创建我们的 API 的 API Gateway。这有助于你理解 Amazon API Gateway
    的基本词汇。
- en: Deploying our service behind Amazon API Gateway
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Amazon API Gateway 后部署我们的服务
- en: 'Pausing the theory, let us quickly jump into an example. Our goal is to set
    up the API Gateway for the previously deployed `books` API as a target. Follow
    these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停理论，让我们快速跳入一个例子。我们的目标是设置 API Gateway，作为之前部署的 `books` API 的目标。按照以下步骤操作：
- en: 'Let us create a new project and write a new Terraform script that creates and
    deploys an API on Amazon API Gateway, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的项目并编写一个新的 Terraform 脚本，该脚本在 Amazon API Gateway 上创建和部署一个 API，如下所示：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It also links our EC2 instance and API endpoints.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它还链接了我们的 EC2 实例和 API 端点。
- en: 'Let us add the Gateway REST API component to the script:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在脚本中添加网关 REST API 组件：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It takes a few important attributes, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一些重要的属性，如下所示：
- en: '`name`: Name of the API'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: API 的名称'
- en: '`description`: Text about the API'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`: 关于 API 的文本'
- en: '`endpoint_configuration`: Defines which mode of the API to publish (`REGIONAL` or `EDGE`)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endpoint_configuration`: 定义要发布的 API 的模式（`REGIONAL` 或 `EDGE`）'
- en: These details are used to identify an API in the Amazon API Gateway. We named
    our API `EC2Example`. The `aws_api_gateway_rest_api` resource type is a Terraform
    resource type. Our resource name is `test`. From here on, we will see similar
    names for all other resource types we create.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些详细信息用于在 Amazon API Gateway 中识别一个 API。我们给我们的 API 命名为 `EC2Example`。`aws_api_gateway_rest_api`
    资源类型是 Terraform 资源类型。我们的资源名称是 `test`。从现在开始，我们将看到所有其他资源类型都使用类似的名字。
- en: When AWS creates the `aws_api_gateway_rest_api` component, it also creates a
    default Gateway Resource on AWS. A Gateway Resource is a relative path for endpoints
    we configure as part of the integration.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当 AWS 创建 `aws_api_gateway_rest_api` 组件时，它也在 AWS 上创建了一个默认的网关资源。网关资源是我们作为集成部分配置的端点的相对路径。
- en: Next, we have to create a gateway method called `test`. It takes the `rest_api_id`,
    `resource_id`, and `http_method` attributes. These three attributes are common
    for all components. Let us call these `DEFAULT_ATTRIBUTES`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个名为 `test` 的网关方法。它接受 `rest_api_id`、`resource_id` 和 `http_method`
    属性。这三个属性对所有组件都是通用的。让我们称这些为 `DEFAULT_ATTRIBUTES`。
- en: 'In addition, we set `Authorization=NONE` on this component. If we set authorization
    to `AWS_IAM`, then a client has to provide AWS access keys and a token along with
    the request. We are disabling the gateway authentication for now, as shown in
    the following code block:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们在该组件上设置了`Authorization=NONE`。如果我们设置授权为`AWS_IAM`，那么客户端必须提供AWS访问密钥和令牌，与请求一起提供。目前我们正在禁用网关认证，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After adding the method request, we should add the method response component.
    This also takes `DEFAULT_ATTRIBUTES` plus `status_code`. That means whenever a
    method response receives `200` `OK` from an integration response, it passes it
    to the client as a successful message, as shown in the following code block:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加方法请求后，我们应该添加方法响应组件。这也需要`DEFAULT_ATTRIBUTES`加上`status_code`。这意味着每当方法响应从集成响应中接收到`200`
    `OK`时，它将作为成功消息传递给客户端，如下面的代码块所示：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add the integration components. There are two integration components,
    as we recollect from the API architecture diagram in the previous section. The
    `integration response` component is similar to the `method_response` component,
    as shown in the following code block:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加集成组件。根据上一节中的API架构图，我们有两个集成组件。`integration response`组件与`method_response`组件类似，如下面的代码块所示：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The main link between the API Gateway and our API running on an EC2 instance
    is created in the `integration request` component. It takes `DEFAULT_ATTRIBUTES`,
    plus three important attributes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: API网关和运行在EC2实例上的我们的API之间的主要链接是在`integration request`组件中创建的。它包含`DEFAULT_ATTRIBUTES`，以及三个重要属性：
- en: '`integration_http_method`: Decides which HTTP method should be called on the
    endpoint'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`integration_http_method`：决定应在端点上调用哪种HTTP方法'
- en: '`type`: Denotes which type of endpoint is being used: `HTTP`, `Lambda`, or `AWS_PROXY`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：表示正在使用哪种类型的端点：`HTTP`、`Lambda`或`AWS_PROXY`'
- en: '`uri`: The actual reference of the endpoint'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri`：端点的实际引用'
- en: 'In our case, because we want to link the Gateway and the EC2 instance, we use
    `HTTP` as our `type`, and the public DNS of our EC2 instance as `uri`. The Terraform
    block looks like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，因为我们想将网关和EC2实例链接起来，我们使用`HTTP`作为我们的`type`，并将我们的EC2实例的公网DNS作为`uri`。Terraform块看起来像这样：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have set `integration_http_method` to `GET` because our `books` API only
    has an endpoint with the GET method. For the `uri` attribute value, we are referencing
    `public_dns` from the `aws_instance.api_server` EC2 instance resource. Since both
    the Terraform scripts— `api_server.tf` and `api_gateway.tf`—are in the same `intro` project
    directory, we can import the resources from another.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`integration_http_method`设置为`GET`，因为我们的`books` API只有一个使用GET方法的端点。对于`uri`属性值，我们引用了`aws_instance.api_server`
    EC2实例资源中的`public_dns`。由于Terraform脚本`api_server.tf`和`api_gateway.tf`都在同一个`intro`项目目录中，我们可以从另一个脚本中导入资源。
- en: 'This finishes all five crucial components of the API. We have to deploy the
    API using a test environment. Terraform provides a resource type called `aws_api_gateway_deployment`
    to create a deployment. Deployments are useful for testing or publishing Amazon
    API Gateway endpoints to the web. The deployment takes the following attributes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了API的所有五个关键组件。我们必须使用测试环境部署API。Terraform提供了一个名为`aws_api_gateway_deployment`的资源类型来创建部署。部署对于测试或发布Amazon
    API网关端点到Web非常有用。部署需要以下属性：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A deployment also depends on an `integration request`, so we added a `depends_on`
    attribute. The `stage_name` attribute can take stage, `"test"`, or prod environment
    types. This finishes our API Gateway creation. Let us run the script to create
    and deploy our API on Amazon API Gateway, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 部署还依赖于`integration request`，因此我们添加了`depends_on`属性。`stage_name`属性可以接受`test`阶段或生产环境类型。这样，我们就完成了API网关的创建。让我们运行脚本，在Amazon
    API网关上创建和部署我们的API，如下所示：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, where can clients access the new URL of the API Gateway? You can get the
    `invoke_url` from the `terraform.tfstate` file, like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端在哪里可以访问API网关的新URL？您可以从`terraform.tfstate`文件中获取`invoke_url`，如下所示：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`invoke_url` is the API Gateway endpoint. This endpoint should be attached
    to a custom domain while publishing an API. If you make a `curl` request to the
    preceding URL, you should receive books as a JSON response, as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke_url`是API网关端点。在发布API时，此端点应附加到自定义域名。如果您向前面的URL发出`curl`请求，您应该收到如下所示的JSON响应：'
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This confirms that all the components are functioning properly and that all
    requests/responses are routed through API Gateway. You can define many such endpoints
    and configure components to achieve the desired behavior. Adding authentication
    is left as an exercise to you.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这确认了所有组件都在正常工作，并且所有请求/响应都通过API网关路由。您可以定义许多这样的端点并配置组件以实现所需的行为。添加身份验证留作练习。
- en: 'Tip for solving this exercise: Try to modify the right component to authenticate
    and authorize client requests.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个练习的技巧：尝试修改正确的组件来验证和授权客户端请求。
- en: In the next section, we'll mention other important API Gateways that are available.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将提到其他重要的API网关。
- en: Other API Gateways
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他API网关
- en: There are many other API Gateway providers available in the market. As we mentioned
    earlier, all gateways provide the same set of features. Similar to AWS API Gateway,
    Apigee is another well-known API Gateway technology that is a part of Google Cloud.
    The problem with cloud providers is that they can cause vendor lock (that is,
    they cannot easily migrate to another platform). There are many open source API
    Gateways available on the market.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上还有许多其他API网关提供商。正如我们之前提到的，所有网关都提供相同的功能集。类似于AWS API网关，Apigee是另一个广为人知的API网关技术，它是Google
    Cloud的一部分。云提供商的问题在于它们可能导致供应商锁定（即，它们不能轻易迁移到另一个平台）。市场上有许多开源API网关。
- en: 'The right way to pick an API Gateway depends on the conditions of the business.
    If the API server is living on the AWS cloud, AWS API Gateway is a nice choice.
    For a company that can manage a gateway by itself, it is worth trying the following
    open source alternatives:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 选择API网关的正确方式取决于业务条件。如果API服务器位于AWS云上，AWS API网关是一个不错的选择。对于能够自行管理网关的公司，尝试以下开源替代方案是值得的：
- en: Kubernetes
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Kong
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kong
- en: Tyk
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tyk
- en: KrakenD
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KrakenD
- en: There is no best choice, but if workloads are not so big, nginx can also be
    used as an API Gateway. See [https://www.nginx.com/learn/api-gateway/](https://www.nginx.com/learn/api-gateway/) for
    more details.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 没有最佳选择，但如果工作负载不是很大，nginx也可以用作API网关。有关更多详细信息，请参阅[https://www.nginx.com/learn/api-gateway/](https://www.nginx.com/learn/api-gateway/)。
- en: Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) can be a wise
    choice for those who like to manage the API Gateway by themselves. Also, another
    good reason to use Kubernetes is that it is getting widely adapted.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes ([https://kubernetes.io/](https://kubernetes.io/)) 对于喜欢自己管理API网关的人来说是一个明智的选择。另外，使用Kubernetes的另一个好理由是它正在被广泛采用。
- en: Amazon also provides the **Elastic Kubernetes Service** (**EKS**) for running highly
    available clusters over different regions. With EKS, the API Gateway is included
    as an installed component.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊还提供了**弹性Kubernetes服务**（**EKS**）来在不同的区域运行高可用集群。使用EKS，API网关作为已安装的组件包含在内。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with the basics of working with AWS. Amazon provides
    a free-tier to experiment with their cloud. Once we sign up for the free-tier,
    we should get access to the AWS console and be able to create security credentials.
    These security credentials are required for applications to access AWS.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从AWS的基本操作开始。亚马逊提供了一个免费层，以便实验他们的云服务。一旦我们注册了免费层，我们应该能够访问AWS控制台并能够创建安全凭证。这些安全凭证是应用程序访问AWS所必需的。
- en: We then saw how a tool such as Terraform can provision cloud resources. We picked
    AWS EC2 as our choice to deploy an API. We wrote a Terraform script to provision
    an EC2 instance, along with a key pair. This key pair was required to log in to
    the instance.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后看到了如何使用像Terraform这样的工具来配置云资源。我们选择了AWS EC2作为部署API的选择。我们编写了一个Terraform脚本来配置EC2实例，以及一个密钥对。这个密钥对是登录实例所必需的。
- en: Once we were able to log in to the EC2 instance, we installed all the dependencies
    for our API server. We reused the project code from [Chapter 12](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml), *Containerizing
    REST Services for Deployment*, where we prepared an API ecosystem. We successfully
    deployed the `books` API from the EC2 instance.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够登录到EC2实例，我们就安装了我们API服务器所需的全部依赖。我们重用了来自[第12章](da5ccac6-f448-4cf5-bb81-5d3839d2240c.xhtml)，*容器化REST服务以进行部署*的项目代码，其中我们准备了一个API生态系统。我们成功地将`books`
    API从EC2实例部署出去。
- en: A simple API server has fewer capabilities in terms of rate-limiting to clients,
    authentication, and authorization. We need a dedicated API Gateway that can pass
    the requests to the API server. AWS provides a managed gateway solution called
    `Amazon API Gateway`. We saw the architecture of Amazon API Gateway and provisioned
    an API on the gateway using Terraform. The architecture has six important components,
    which discussed in detail.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的API服务器在客户端的速率限制、认证和授权方面功能较少。我们需要一个专门的API网关来将请求传递到API服务器。AWS提供了一个名为`Amazon
    API Gateway`的托管网关解决方案。我们看到了Amazon API网关的架构，并使用Terraform在该网关上配置了一个API。该架构有六个重要的组件，将在详细讨论。
- en: Finally, we mentioned other gateway solutions available in the market. In the
    next chapter, we will discuss API authentication patterns, including **JSON Web
    Token** (**JWT**) authentication, in detail.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到了市场上可用的其他网关解决方案。在下一章中，我们将详细讨论API认证模式，包括**JSON Web Token**（JWT）认证。
