- en: Building the Frontend with S3
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用S3构建前端
- en: 'In this chapter, we will learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将学习以下内容：
- en: How to build a static website that consumes API Gateway responses using AWS
    Simple Storage Service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建一个消耗API Gateway响应的静态网站，使用AWS简单存储服务
- en: How to optimize the access to your website assets such as JavaScript, CSS, images
    with CloudFront distribution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过CloudFront分发优化对网站资产的访问，例如JavaScript、CSS、图像
- en: How to set up a custom domain name for a serverless application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为无服务器应用程序设置自定义域名
- en: How to create an SSL certificate to show your content with HTTPS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建SSL证书以使用HTTPS显示您的内容
- en: Automating the deployment process of the web application using a CI/CD pipeline.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CI/CD管道自动化Web应用程序的部署过程。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before proceeding with this chapter, you should have a basic understanding of
    web development and knowledge of how DNS works. The code bundle for this chapter
    is hosted on GitHub at [https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，您应该对Web开发有基本的了解，并了解DNS的工作原理。本章的代码包托管在GitHub上，网址为[https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go)。
- en: Single Page Application
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: 'In this section, we will learn how to build a web application that will call
    the API Gateway invocation URL that we built in previous chapters and list the
    movies, as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何构建一个Web应用程序，该应用程序将调用我们在之前章节中构建的API Gateway调用URL，并列出电影，如下所示：
- en: '![](img/03e5c169-f346-4aa6-b14e-aa8e484514a3.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03e5c169-f346-4aa6-b14e-aa8e484514a3.png)'
- en: 'For each movie, we will display its cover image and title. In addition, a user
    can filter the movies by their categories by clicking on the button to the right
    of Horror . Finally, to add a new movie to the database, a modal will pop up if
    the user clicks on the New button on the navigation bar. The modal will ask the
    user to fill in the following fields:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每部电影，我们将显示其封面图像和标题。此外，用户可以通过单击右侧的按钮来按类别筛选电影。最后，如果用户单击导航栏上的“New”按钮，将弹出一个模态框，要求用户填写以下字段：
- en: '![](img/52d23b4d-2387-4b89-b66a-31f1b0bc0b67.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52d23b4d-2387-4b89-b66a-31f1b0bc0b67.png)'
- en: Now that the application mock-ups are defined, we will use a JavaScript framework
    to build the web application quickly. For example, I will be using **Angular 5**,
    which is currently the latest stable version of Angular.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序的模拟已经定义，我们将使用JavaScript框架快速构建Web应用程序。例如，我将使用当前最新稳定版本的Angular 5。
- en: Developing web applications with Angular
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular开发Web应用程序
- en: Angular is a fully-integrated framework developed by Google. It allows you to
    build dynamic web applications without thinking about which libraries to select
    and how to deal with everyday problems. Keep in mind that the goal is to reach
    a large audience, Angular was chosen because it's one of the most commonly-used
    frameworks. However, it's up to you to choose whichever framework you're familiar
    with, such as React, Vue, or Ember.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是由Google开发的完全集成的框架。它允许您构建动态Web应用程序，而无需考虑选择哪些库以及如何处理日常问题。请记住，目标是要吸引大量观众，因此选择了Angular作为最常用的框架之一。但是，您可以选择您熟悉的任何框架，例如React、Vue或Ember。
- en: In addition to built-in ready-to-use modules, Angular leverages the power of
    the **Single Page Application** **(SPA)** architecture. This architecture allows
    you to navigate between pages without refreshing the browser, hence allowing a
    better user experience as the application is more fluid and responsive, including
    better performance (you can preload and cache extra pages).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的可用模块外，Angular还利用了**单页应用程序**（SPA）架构的强大功能。这种架构允许您在不刷新浏览器的情况下在页面之间导航，因此使应用程序更加流畅和响应，包括更好的性能（您可以预加载和缓存额外的页面）。
- en: Angular comes with its own CLI. You can install it by going to [https://cli.angular.io](https://cli.angular.io)
    for a step-by-step guide. This book is dedicated to Lambda. Hence, only the basic
    concepts of Angular are covered in the upcoming sections, to make this chapter
    easy to understand for those who aren't web developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自带CLI。您可以按照[https://cli.angular.io](https://cli.angular.io)上的逐步指南进行安装。本书专注于Lambda。因此，本章仅涵盖了Angular的基本概念，以便让那些不是Web开发人员的人能够轻松理解。
- en: 'Once the **Angular CLI** is installed, we need to create a new Angular application
    using the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了**Angular CLI**，我们需要使用以下命令创建一个新的Angular应用程序：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CLI will generate the basic templates files and install all the required
    **npm** dependencies to run an Angular 5 application. The file structure looks
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CLI将生成基本模板文件并安装所有必需的**npm**依赖项以运行Angular 5应用程序。文件结构如下：
- en: '![](img/dc7d0c0d-e3c7-469e-af1b-bd5248fcea5e.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc7d0c0d-e3c7-469e-af1b-bd5248fcea5e.png)'
- en: 'Next, on the `frontend` directory, start a local web server with this command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`frontend`目录中，使用以下命令启动本地Web服务器：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The command will compile all the `TypeScripts` files, build the project, and
    start a web server on port `4200`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将编译所有的`TypeScripts`文件，构建项目，并在端口`4200`上启动Web服务器：
- en: '![](img/38a446fd-123d-4aaf-ae92-912de1d9a18d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38a446fd-123d-4aaf-ae92-912de1d9a18d.png)'
- en: 'Open your browser and navigate to [http://localhost:4200](http://localhost:4200). This
    is what you should see in your browser:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并导航至[http://localhost:4200](http://localhost:4200)。您在浏览器中应该看到以下内容：
- en: '![](img/3da4087e-5f28-4843-96d6-532f7b448647.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3da4087e-5f28-4843-96d6-532f7b448647.png)'
- en: Now that our sample app is built and running, let's create our web application.
    The Angular structure is based on either a components and services architecture
    (similar to Model-View-Controller).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的示例应用程序已构建并运行，让我们创建我们的Web应用程序。Angular结构基于组件和服务架构（类似于模型-视图-控制器）。
- en: Generating your first Angular component
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成您的第一个Angular组件
- en: 'For those who haven''t had much experience with Angular, a component is basically
    a Lego brick for the UI. Your web application can be divided into multiple components.
    Each component has the following files:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些没有太多Angular经验的人来说，组件基本上就是UI的乐高积木。您的Web应用程序可以分为多个组件。每个组件都有以下文件：
- en: '**COMPONENT_NAME.component.ts**: The component-logic definition written in
    TypeScript'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COMPONENT_NAME.component.ts**：用TypeScript编写的组件逻辑定义'
- en: '**COMPONENT_NAME.component.html**: The HTML code of the component'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COMPONENT_NAME.component.html**：组件的HTML代码'
- en: '**COMPONENT_NAME.component.css**: The CSS structure of the component'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COMPONENT_NAME.component.css**：组件的CSS结构'
- en: '**COMPONENT_NAME.component.spec.ts**: The unit test of the component class'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COMPONENT_NAME.component.spec.ts**：组件类的单元测试'
- en: 'In our example, we will need at least three components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们至少需要三个组件：
- en: The Navigation Bar component
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航栏组件
- en: The List of Movies component
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影列表组件
- en: The Movie component
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影组件
- en: Before we create our first component, let's install **Bootstrap**, which is
    a frontend web framework developed by Twitter to build attractive user interfaces.
    It comes with a set of CSS-based design templates for forms, buttons, navigation,
    and other interface components, as well as optional JavaScript extensions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建第一个组件之前，让我们安装**Bootstrap**，这是Twitter开发的用于构建吸引人用户界面的前端Web框架。它带有一组基于CSS的设计模板，用于表单、按钮、导航和其他界面组件，以及可选的JavaScript扩展。
- en: 'Go ahead and install Bootstrap 4 from your terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在终端中安装Bootstrap 4：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, import the Bootstrap CSS classes in the `.angular-cli.json` file in order
    to make the CSS directives available in all components of the application:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`.angular-cli.json`文件中导入Bootstrap CSS类，以便在应用程序的所有组件中使CSS指令可用：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we are ready to create our navigation bar component by issuing the following
    command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备通过发出以下命令来创建我们的导航栏组件：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Override the HTML code generated by default in `navbar.component.html`to use
    the navigation bar provided by the Bootstrap framework:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖默认生成的`navbar.component.html`中的HTML代码，以使用Bootstrap框架提供的导航栏：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open `navbar.component.ts` and update the selector property to `movies-navbar`.
    The selector here is nothing but a tag that can be used to reference the component
    on other components:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`navbar.component.ts`并将选择器属性更新为`movies-navbar`。这里的选择器只是一个标签，可以用来引用其他组件上的组件：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `movies-navbar` selector needs to be added in the `app.component.html`
    file, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies-navbar`选择器需要添加到`app.component.html`文件中，如下所示：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Angular CLI uses live reload. Hence, every time our code is changed, the
    CLI will recompile, re-inject if needed, and ask the browser to refresh the page:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI使用实时重新加载。因此，每当我们的代码更改时，CLI将重新编译，重新注入（如果需要），并要求浏览器刷新页面：
- en: '![](img/6c6f1c45-5246-4dfb-a0b3-fbe06fdfe08a.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c6f1c45-5246-4dfb-a0b3-fbe06fdfe08a.png)'
- en: When the `movies-navbar` tag is added, everything that is present in the `navbar.component.html`
    file of the new component will be displayed in the browser.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加`movies-navbar`标签时，`navbar.component.html`文件中的所有内容都将显示在浏览器中。
- en: 'Similarly, we will create a new component for the movie item:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将为电影项目创建一个新组件：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are going to display movies as cards in our interface; replace the `movie-item.component.html`
    code with the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在界面中将电影显示为卡片；用以下内容替换`movie-item.component.html`代码：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the browser, you should see something similar to this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，您应该看到类似于这样的东西：
- en: '![](img/c7123f3d-1d1a-44b3-9d50-3afa01f7bc29.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7123f3d-1d1a-44b3-9d50-3afa01f7bc29.png)'
- en: 'Create another component to display the list of movies:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个组件来显示电影列表：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This component will use the Angular `ngFor` directive to iterate over `movie`
    in the `movies` array and print out the movie by calling the `movie-item` component
    (this is known as composition):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件将使用Angular的`ngFor`指令来遍历`movies`数组中的`movie`并通过调用`movie-item`组件打印出电影（这称为组合）：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `movies` array is declared in`list-movies.component.ts` and initialized
    in the class constructor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies`数组在`list-movies.component.ts`中声明，并在类构造函数中初始化：'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Movie` class is a simple entity with three fields, namely, `name`, `cover`,
    and `description`, and getters and setters to access and modify the class attributes:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Movie`类是一个简单的实体，有三个字段，即`name`，`cover`和`description`，以及用于访问和修改类属性的getter和setter：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we run the preceding code, we will see three movies displayed in the browser:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们将在浏览器中看到三部电影：
- en: '![](img/5cd01aa8-7d2d-4026-90ac-d566046acdd9.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cd01aa8-7d2d-4026-90ac-d566046acdd9.png)'
- en: 'By now, the movie attributes are hardcoded in the HTML page, in order to change
    that, we need to pass the movie item to the `movie-item` element. Update `movie-item.component.ts`
    to add a new movie field and use the `Input` annotation to use the Angular input
    binding:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，电影属性在HTML页面中是硬编码的，为了改变这一点，我们需要将电影项目传递给`movie-item`元素。更新`movie-item.component.ts`以添加一个新的电影字段，并使用`Input`注释来使用Angular输入绑定：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the HTML template of the preceding component, use the getters of the `Movie`
    class to get the values of attributes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面组件的HTML模板中，使用`Movie`类的getter来获取属性的值：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, make the `ListMoviesComponent` nest the `MovieItemComponent` child inside
    an `*ngFor` repeater, and bind the`movie` instance to the child''s `movie` property
    on each iteration:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使`ListMoviesComponent`将`MovieItemComponent`子嵌套在`*ngFor`重复器中，并在每次迭代中将`movie`实例绑定到子的`movie`属性上：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the browser, you should ensure that the movie''s attributes are properly
    defined:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，您应该确保电影的属性已经正确定义：
- en: '![](img/630275ba-4d91-40d0-a0d8-d402270dc7c9.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/630275ba-4d91-40d0-a0d8-d402270dc7c9.png)'
- en: Everything is going well so far. However, the movies list is still static and
    hardcoded. We will fix that by calling the serverless API to retrieve the list
    of movies dynamically from the database.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很顺利。但是，电影列表仍然是静态的和硬编码的。我们将通过调用无服务器API从数据库动态检索电影列表来解决这个问题。
- en: Accessing Rest web services with Angular
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular访问Rest Web服务
- en: 'In the previous chapters, we created two stages, the `staging` and `production`
    environments. Therefore, we should create two environment files to point to the
    right API Gateway deployment stage:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们创建了两个阶段，即`staging`和`production`环境。因此，我们应该创建两个环境文件，以指向正确的API Gateway部署阶段：
- en: '`environment.ts`: Contains the development HTTP URL:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment.ts`：包含开发HTTP URL：'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`environment.prod.ts`: Contains the production HTTP URL:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment.prod.ts`：包含生产HTTP URL：'
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `environment` object will read the values from `environment.ts` if `ng build`
    or `ng serve` are executed, and read the values from `environment.prod.ts` if
    you build your application for production mode with the `ng build --prod` command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行`ng build`或`ng serve`，`environment`对象将从`environment.ts`中读取值，并且如果使用`ng build
    --prod`命令将应用程序构建为生产模式，则将从`environment.prod.ts`中读取值。
- en: 'To create a service, we need to make use of the command line. The command is
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，我们需要使用命令行。命令如下：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`movies-api.service.ts` will implement the `findAll` function, which will call
    the API Gateway `findAll` endpoint using the `Http` service. The `map` method
    will help convert the response to JSON format:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`movies-api.service.ts`将实现`findAll`函数，该函数将使用`Http`服务调用API Gateway的`findAll`端点。`map`方法将帮助将响应转换为JSON格式：'
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before calling `MoviesApiService`, it needs to be imported in the `app.module.ts` main
    module in the providers section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`MoviesApiService`之前，需要在`app.module.ts`的主模块中的提供程序部分导入它。
- en: 'Update `MoviesListComponent` to call the new service. On the browser console,
    you should have an error message regarding the Access-Control-Allow-Origin header
    not being present in the  response returned by the API Gateway.That will be the
    topic of the upcoming section:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`MoviesListComponent`以调用新服务。在浏览器控制台中，您应该会收到有关Access-Control-Allow-Origin头在API
    Gateway返回的响应中不存在的错误消息。这将是即将到来部分的主题：
- en: '![](img/851f2f1c-7972-4bc7-bdc7-5f9b7f7a7bb5.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/851f2f1c-7972-4bc7-bdc7-5f9b7f7a7bb5.png)
- en: Cross Origin Resource Sharing
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨域资源共享
- en: For security purposes, the browser will block the flow if the external requests
    don't match the exact host, protocol, and port of your website. In our example,
    we have different domain names (localhost and API Gateway URL).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全目的，如果外部请求与您的网站的确切主机、协议和端口不匹配，浏览器将阻止流。在我们的示例中，我们有不同的域名（localhost和API Gateway
    URL）。
- en: 'This mechanism is known as the **Same-origin policy**. To solve this problem,
    you can either use a CORS header, proxy server, or JSON workaround. In this section,
    I will demonstrate how we can use a CORS header in the response returned by the
    Lambda function to resolve this issue:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制被称为**同源策略**。为了解决这个问题，您可以使用CORS头、代理服务器或JSON解决方法。在本节中，我将演示如何在Lambda函数返回的响应中使用CORS头来解决此问题：
- en: 'Modify the `findAllMovie` function''s code to add `Access-Control-Allow-Origin:*`to
    enable cross-origin requests from anywhere (or specify a domain instead of *):'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`findAllMovie`函数的代码以添加`Access-Control-Allow-Origin:*`以允许来自任何地方的跨域请求（或指定域而不是*）：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Commit your changes; a new build should be triggered. At the end of the CI/CD
    pipeline, the `FindAllMovies` Lambda function''s code will be updated. Test it
    out; you should have the new key as part of the `headers` attribute:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交您的更改；应触发新的构建。在CI/CD管道的最后，`FindAllMovies` Lambda函数的代码将被更新。测试一下；您应该会在`headers`属性的一部分中看到新的密钥：
- en: '![](img/07d58921-c7aa-4a90-b4c1-07eeb1c06fc0.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/07d58921-c7aa-4a90-b4c1-07eeb1c06fc0.png)
- en: 'If you refresh the web application page, the JSON objects will be displayed
    in the console too:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果刷新Web应用程序页面，JSON对象也将显示在控制台中：
- en: '![](img/c4214806-29e1-4105-98d1-f7c212456f0e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/c4214806-29e1-4105-98d1-f7c212456f0e.png)
- en: 'Update `list-movies.component.ts` to call the `findAll` function from `MoviesApiService`.
    The data returned will be stored in the `movies` variable:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`list-movies.component.ts`以调用`MoviesApiService`的`findAll`函数。返回的数据将存储在`movies`变量中：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a result, the list of movies will be retrieved and displayed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果，电影列表将被检索并显示：
- en: '![](img/deeaef10-1459-4d94-ba8d-3ce1d7d111c0.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/deeaef10-1459-4d94-ba8d-3ce1d7d111c0.png)
- en: 'We don''t have cover images; you can update the DynamoDB `movies` table to
    add an image and description attributes:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有封面图片；您可以更新DynamoDB的`movies`表以添加图像和描述属性：
- en: '![](img/05553e5c-ccd9-442f-b0e1-340b1d1880ec.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/05553e5c-ccd9-442f-b0e1-340b1d1880ec.png)
- en: The NoSQL database allows you to alter the table schema at any time without
    having to first define the structure, while the relational database requires you
    to use predefined schemas to determine the structure of your data before you work
    with it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库允许您随时更改表模式，而无需首先定义结构，而关系数据库则要求您使用预定义的模式来确定在处理数据之前的结构。
- en: 'If you refresh the web-application page, you should have the movies with their
    corresponding description and poster cover:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果刷新Web应用程序页面，您应该可以看到带有相应描述和海报封面的电影：
- en: '![](img/38fd8f1e-4d36-468e-baca-ea0ea6b6d55f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/38fd8f1e-4d36-468e-baca-ea0ea6b6d55f.png)
- en: 'Let''s improve this web application by implementing a new movie feature. As
    the user needs to fill in the movie''s image cover and description, we need to
    update the `insert` Lambda function to add a cover and description fields in addition
    to a random unique ID generated on the backend:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现新的电影功能来改进此Web应用程序。由于用户需要填写电影的图像封面和描述，因此我们需要更新`insert` Lambda函数，以在后端生成随机唯一ID的同时添加封面和描述字段：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the new changes are pushed to the code repository and deployed, open your
    REST client and issue a POST request to add a new movie with the following JSON
    scheme:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦新更改被推送到代码存储库并部署，打开您的REST客户端并发出POST请求以添加新的电影，其JSON方案如下：
- en: '![](img/06a712ec-4680-4479-a7a0-0ff4dd8b9a4f.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/06a712ec-4680-4479-a7a0-0ff4dd8b9a4f.png)
- en: 'A `200` success code should be returned, and in the web application, the new
    movie should be listed:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应返回`200`成功代码，并且在Web应用程序中应列出新电影：
- en: '![](img/604c09c6-c24d-4dae-916c-2e9d1cffd8ba.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/604c09c6-c24d-4dae-916c-2e9d1cffd8ba.png)
- en: 'As seen in the *Single Page Application* section, when the user clicks on the
    New button, a modal will pop up with a creation form. In order to build this modal
    and to avoid using jQuery, we will use another library that provides a set of
    native Angular directives based on Bootstrap''s markup and CSS:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如*单页应用程序*部分所示，当用户点击“新建”按钮时，将弹出一个带有创建表单的模态框。为了构建这个模态框并避免使用jQuery，我们将使用另一个库，该库提供了一组基于Bootstrap标记和CSS的本机Angular指令：
- en: 'Install this library with the following command:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令安装此库：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once installed, you need to import it into the main `app.module.ts` module,
    as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装后，需要将其导入到主`app.module.ts`模块中，如下所示：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To hold the creation form, we need to create a new component:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了容纳创建表单，我们需要创建一个新的组件：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This component will have two `input` fields for the movie''s title and cover
    link. Plus, a `textarea` element for the movie''s description:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该组件将有两个用于电影标题和封面链接的`input`字段。另外，还有一个用于电影描述的`textarea`元素：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Each time the user clicks on the Save button, a `save` function will be invoked
    in response to the click event. The `insert` function defined in the `MoviesApiService`
    service calls the `POST` method on the `insert` endpoint of the API Gateway:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户每次点击保存按钮时，将响应点击事件调用`save`函数。`MoviesApiService`服务中定义的`insert`函数调用API Gateway的`insert`端点上的`POST`方法：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a click event on the Newelement from the navigation bar:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航栏中的New元素上添加点击事件：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The click event will call `newMovie` and open the modal by calling the `ModalService`
    module of the `ng-bootstrap` library:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击事件将调用`newMovie`并通过调用`ng-bootstrap`库的`ModalService`模块打开模态框：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once these changes are compiled, click on the New item from the navigation
    bar, and the modal will pop up. Fill in the required fields and click on the Save
    button:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦编译了这些更改，从导航栏中单击“新建”项目，模态框将弹出。填写必填字段，然后单击保存按钮：
- en: '![](img/e44877e8-d1ca-4658-9c42-39974e51867e.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e44877e8-d1ca-4658-9c42-39974e51867e.png)'
- en: 'The movie will be saved in the database table. If you refresh the page, the
    movie will be in the list of movies displayed:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影将保存在数据库表中。如果刷新页面，电影将显示在电影列表中：
- en: '![](img/a92e0046-6172-4658-abb6-19d3781897f5.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a92e0046-6172-4658-abb6-19d3781897f5.png)'
- en: S3 static website hosting
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: S3静态网站托管
- en: Now that our application has been created, let's deploy it to a remote server.
    Instead of maintaining a web server, such as Apache or Nginx in an EC2 instance,
    let's keep it serverless and use an S3 bucket with the S3 website-hosting feature
    enabled.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已创建，让我们将其部署到远程服务器。不要维护Web服务器，如EC2实例中的Apache或Nginx，让我们保持无服务器状态，并使用启用了S3网站托管功能的S3存储桶。
- en: Setting up an S3 bucket
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置S3存储桶
- en: 'To get started, create an S3 bucket either from the AWS console or with the
    following AWS CLI command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，可以从AWS控制台或使用以下AWS CLI命令创建一个S3存储桶：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, build the web application for production mode:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为生产模式构建Web应用程序：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `--prod` flag will generate an optimized version of the code and do additional
    build steps, such as JavaScript and CSS minification, dead code elimination, and
    bundling:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`--prod`标志将生成代码的优化版本，并执行额外的构建步骤，如JavaScript和CSS文件的最小化，死代码消除和捆绑：'
- en: '![](img/322a7e1e-7bf4-4653-a81c-ea30977265c7.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/322a7e1e-7bf4-4653-a81c-ea30977265c7.png)'
- en: 'This will give you the `dist/` directory with `index.html` and all the bundled
    `js` files ready for production. Configure the bucket to host a website:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供`dist/`目录，其中包含`index.html`和所有捆绑的`js`文件，准备用于生产。配置存储桶以托管网站：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Copy everything within the *dist/* folder into the S3 bucket we created earlier:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将*dist/*文件夹中的所有内容复制到之前创建的S3存储桶中：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can verify that the files have been successfully stored from the S3 bucket
    dashboard or with the `aws s3 ls` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过S3存储桶仪表板或使用`aws s3 ls`命令验证文件是否已成功存储：
- en: '![](img/ba4ee6eb-461b-4b32-b183-62721b89b64a.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba4ee6eb-461b-4b32-b183-62721b89b64a.png)'
- en: 'By default, when you create an S3 bucket, it''s private. Hence, you should
    make it publicly accessible with the following bucket policy:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，创建S3存储桶时是私有的。因此，您应该使用以下存储桶策略使其公开访问：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On the bucket configuration page, click on the Permissions tab, then Bucket
    Policy, paste the policy content to the editor, and then Save it. A warning message
    will pop up indicating that the bucket has become public:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储桶配置页面上，单击“权限”选项卡，然后单击“存储桶策略”，将策略内容粘贴到编辑器中，然后保存。将弹出警告消息，指示存储桶已变为公共状态：
- en: '![](img/b07d05cc-d54b-4ed7-a076-8db8261c65f4.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b07d05cc-d54b-4ed7-a076-8db8261c65f4.png)'
- en: 'To access the web application, point your browser to [http://serverlessmovies.s3-website-us-east-1.amazonaws.com](http://serverlessmovies.s3-website-us-east-1.amazonaws.com) (replace
    this with your own bucket name):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问Web应用程序，请将浏览器指向[http://serverlessmovies.s3-website-us-east-1.amazonaws.com](http://serverlessmovies.s3-website-us-east-1.amazonaws.com)（用您自己的存储桶名称替换）：
- en: '![](img/ce0b68f2-d681-4e91-bb0d-3341014dc12f.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce0b68f2-d681-4e91-bb0d-3341014dc12f.png)'
- en: Now that our application is deployed to production, let's create a custom domain
    name to have a user-friendly link to access the website. To route domain traffic
    to the S3 bucket, we will use **Amazon Route 53** to create an alias record that
    points into the bucket.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序已部署到生产环境，让我们创建一个自定义域名，以便用户友好地访问网站。为了将域流量路由到S3存储桶，我们将使用**Amazon Route
    53**创建一个指向存储桶的别名记录。
- en: Setting up Route 53
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Route 53
- en: 'If you are new to Route 53, create a new hosted zone with the domain name you
    own, as in the following image. You can either use an existing domain name or
    buy one from the Amazon registrar or an external DNS registrar, such as GoDaddy. Make
    sure to choose Public Hosted Zone:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Route 53的新手，请使用您拥有的域名创建一个新的托管区域，如下图所示。您可以使用现有的域名，也可以从亚马逊注册商或GoDaddy等外部DNS注册商购买一个域名。确保选择公共托管区域：
- en: '![](img/b0d9e07c-47dc-4076-a2da-0d1b79f751a9.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0d9e07c-47dc-4076-a2da-0d1b79f751a9.png)'
- en: Once created, the `NS` and `SOA` records are created automatically for you.
    If you bought your domain name from AWS, you can skip this section. If not, you
    must change the nameservers record on the registrar you bought the domain name
    from. In this example, I bought the [http://serverlessmovies.com/](http://serverlessmovies.com/)[ domain
    name from GoDaddy, so on the domain name settings page, I have changed the nameservers
    to point to the `NS` record values provided by AWS, as follows:](http://serverlessmovies.com/)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，`NS`和`SOA`记录将自动为您创建。如果您从AWS购买了域名，您可以跳过此部分。如果没有，您必须更改您从域名注册商购买的域名的名称服务器记录。在本例中，我从GoDaddy购买了[http://serverlessmovies.com/](http://serverlessmovies.com/)域名，因此在域名设置页面上，我已将名称服务器更改为AWS提供的`NS`记录值，如下所示：
- en: '![](img/841ce75e-ea5f-4dc9-a242-19a701c61d99.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/841ce75e-ea5f-4dc9-a242-19a701c61d99.png)'
- en: 'It may take a few minutes for the changes to propagate. Once it''s validated
    by the registrar, hop over to `Route 53` and create a new `A` alias record that
    points to the S3 website we created earlier by selecting the target S3 bucket
    from the drop-down list:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 更改可能需要几分钟才能传播。一旦由注册商验证，跳转到`Route 53`并创建一个新的`A`别名记录，该记录指向我们之前创建的S3网站，方法是从下拉列表中选择目标S3存储桶：
- en: '![](img/1d24fc9d-79d0-4dbc-814f-3f1af412a9db.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d24fc9d-79d0-4dbc-814f-3f1af412a9db.png)'
- en: 'When you''re finished, you''ll be able to open a browser, enter the name of
    your domain, and view your web application:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您将能够打开浏览器，输入您的域名，并查看您的Web应用程序：
- en: '![](img/c14323ae-631c-4a93-9724-5839221e9c21.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c14323ae-631c-4a93-9724-5839221e9c21.png)'
- en: Having a secure website can make a difference and make users trust your web
    application more, which is why, in the upcoming section, we will use a free SSL
    provided by AWS to show the content with `HTTPS` at your custom domain name.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个安全的网站可以产生差异，并使用户更加信任您的Web应用程序，这就是为什么在接下来的部分中，我们将使用AWS提供的免费SSL来显示自定义域名的内容，并使用`HTTPS`。
- en: Certificate Manager
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书管理器
- en: 'You can easily get an SSL certificate with **AWS Certificate Manager** **(ACM)**.
    Click on the Request a certificate button to create a new SSL certificate:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地通过**AWS证书管理器（ACM）**获得SSL证书。点击“请求证书”按钮创建一个新的SSL证书：
- en: '![](img/2440c5ce-c1b2-4233-bfbc-42b7fe24561c.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2440c5ce-c1b2-4233-bfbc-42b7fe24561c.png)'
- en: 'Select Request a public certificateand add your domain name. You might also
    want to secure your subdomains by adding an asterisk:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 选择请求公共证书并添加您的域名。您可能还希望通过添加一个星号来保护您的子域：
- en: '![](img/8931642d-6d2c-423d-b287-0f63b7952fd2.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8931642d-6d2c-423d-b287-0f63b7952fd2.png)'
- en: 'Under both domain names, click on the Create record in Route 53 button. This
    will automatically create a `CNAME` record set in Route 53 with the given values,
    which ACM will then check in order to validate that you own those domains:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个域名下，点击Route 53中的创建记录按钮。这将自动在Route 53中创建一个`CNAME`记录集，并由ACM检查以验证您拥有这些域：
- en: '![](img/da7ccd6e-11a6-44a0-bef5-9d1036d6c1ba.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da7ccd6e-11a6-44a0-bef5-9d1036d6c1ba.png)'
- en: 'Once Amazon verifies that the domain name is yours, the certificate status
    will change from Pending validation to Issued:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦亚马逊验证域名属于您，证书状态将从“待验证”更改为“已签发”：
- en: '![](img/6629d9fa-fbb7-43a4-a7f5-10f1c68b672b.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6629d9fa-fbb7-43a4-a7f5-10f1c68b672b.png)'
- en: However, we can't configure the S3 bucket to use our SSL to encrypt the traffic.
    That's why we will use a **CloudFront** distribution, also known as a CDN, in
    front of the S3 bucket.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法配置S3存储桶以使用我们的SSL来加密流量。这就是为什么我们将在S3存储桶前使用一个CloudFront分发，也被称为CDN。
- en: CloudFront distribution
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFront分发
- en: In addition to using CloudFront to add SSL termination on the website, CloudFront
    is mostly used as a **Content Delivery Network** **(CDN)** to store static assets
    (such as HTML pages, images, fonts, CSS, and JavaScript) in multiple edge locations
    around the world, which results in faster downloads and within less response time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用CloudFront在网站上添加SSL终止外，CloudFront主要用作**内容交付网络（CDN）**，用于在世界各地的多个边缘位置存储静态资产（如HTML页面、图像、字体、CSS和JavaScript），从而实现更快的下载和更短的响应时间。
- en: 'That being said, navigate to CloudFront, and then create a new web distribution.
    Set the S3 website URL in the Origin Domain Name field and leave the other fields
    as the default. You may want to redirect the `HTTP` traffic to `HTTPS`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，导航到CloudFront，然后创建一个新的Web分发。在原始域名字段中设置S3网站URL，并将其他字段保留为默认值。您可能希望将`HTTP`流量重定向到`HTTPS`：
- en: '![](img/b7c1a87b-b91d-4312-97dd-e7006fa3b72b.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7c1a87b-b91d-4312-97dd-e7006fa3b72b.png)'
- en: 'Next, select the SSL certificate we created in the *Certificate Manager* section
    and add your domain name to the Alternate Domain Names (CNAMEs) area:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择我们在*证书管理器*部分创建的SSL证书，并将您的域名添加到备用域名（CNAME）区域：
- en: '![](img/e35d051d-c500-49ee-bdbe-60b5dde4ea99.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e35d051d-c500-49ee-bdbe-60b5dde4ea99.png)'
- en: 'Click on Save and wait a few minutes while CloudFront copies all the files
    to the AWS edge locations:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 点击保存，并等待几分钟，让CloudFront复制所有文件到AWS边缘位置：
- en: '![](img/9709af60-4dd2-4963-b3aa-6dd5b70eb130.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9709af60-4dd2-4963-b3aa-6dd5b70eb130.png)'
- en: 'Once the CDN is fully deployed, jump to the domain-name-hosted zone page and
    update the website record to point to the CloudFront distribution domain:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CDN完全部署，跳转到域名托管区域页面，并更新网站记录以指向CloudFront分发域：
- en: '![](img/01ecaef5-9cfb-466d-9572-b5919502ef19.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01ecaef5-9cfb-466d-9572-b5919502ef19.png)'
- en: 'If you go to the URL again, you should be redirected to `HTTPS`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次转到URL，您应该会被重定向到`HTTPS`：
- en: '![](img/82344bd0-45df-49a9-8b65-2215ddd6f002.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82344bd0-45df-49a9-8b65-2215ddd6f002.png)'
- en: Feel free to create a new `CNAME` record for the API Gateway URL. The record
    might be [https://api.serverlessmovies.com](https://api.serverlessmovies.com),
    which points to[https://51cxzthvma.execute-api.us-east-1.amazonaws.com/production/movies](http://51cxzthvma.execute-api.us-east-1.amazonaws.com/production/movies).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 随意创建一个新的`CNAME`记录用于API Gateway URL。该记录可能是[https://api.serverlessmovies.com](https://api.serverlessmovies.com)，指向[https://51cxzthvma.execute-api.us-east-1.amazonaws.com/production/movies](http://51cxzthvma.execute-api.us-east-1.amazonaws.com/production/movies)。
- en: CI/CD workflow
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD工作流
- en: Our serverless application is deployed to production. However, to avoid doing
    the same steps over and over each time you implement a new functionality, we can
    create a CI/CD pipeline to automate the workflow described in the previous section.
    I opt for CircleCI as a CI server. However, you might use Jenkins or CodePipeline—make
    sure to read the previous chapters for more details.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无服务器应用程序已部署到生产环境。但是，为了避免每次实现新功能时都重复相同的步骤，我们可以创建一个CI/CD流水线，自动化前一节中描述的工作流程。我选择CircleCI作为CI服务器。但是，您可以使用Jenkins或CodePipeline——请确保阅读前几章以获取更多详细信息。
- en: 'As seen in the previous chapters, the pipeline should be defined in a template
    file. The following is an example of the pipeline used to automate the deployment
    process of the web app:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所示，流水线应该在模板文件中定义。以下是用于自动化Web应用程序部署流程的流水线示例：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following steps will be executed in order:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将按顺序执行：
- en: Checking out the changes from the code repository
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从代码存储库检出更改
- en: Installing the AWS CLI, application npm dependencies, and the Angular CLI
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装AWS CLI，应用程序npm依赖项和Angular CLI
- en: Building the artifacts with the `ng build` command
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ng build`命令构建工件
- en: Copying over the artefacts to the S3 bucket
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工件复制到S3存储桶
- en: 'Now, all changes to your web application''s code will go through the pipeline
    and will be deployed automatically to production:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的Web应用程序代码的所有更改都将通过流水线进行，并将自动部署到生产环境：
- en: '![](img/3d1c29e1-1de2-410b-bff5-ba6ce1d90eca.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d1c29e1-1de2-410b-bff5-ba6ce1d90eca.png)'
- en: API documentation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API文档
- en: Before finishing this chapter, we will go through how to create documentation
    for the serverless API we've built so far.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们将介绍如何为迄今为止构建的无服务器API创建文档。
- en: 'On the API Gateway console, select the deployment stage that you''re interested
    in generating documentation for. In the following example, I chose the `production`
    environment. Then, click on the Export tab and click on the Export as Swagger section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在API Gateway控制台上，选择要为其生成文档的部署阶段。在下面的示例中，我选择了`production`环境。然后，单击“导出”选项卡，单击“导出为Swagger”部分：
- en: '![](img/68a99745-c216-4fa1-ba0a-3d7851162a5c.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68a99745-c216-4fa1-ba0a-3d7851162a5c.png)'
- en: Swagger is an implementation of the **OpenAPI**, which is a standard defined
    by the Linux Foundation on how to describe and define APIs. This definition is
    called the **OpenAPI specification document**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是**OpenAPI**的实现，这是Linux Foundation定义的关于如何描述和定义API的标准。这个定义被称为**OpenAPI规范文档**。
- en: 'You can save the document in either a JSON or YAML file. Then, navigate to [https://editor.swagger.io/](https://editor.swagger.io/)
    and paste the content on the website editor, it will be compiled and an HTML page
    will be generated as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将文档保存为JSON或YAML文件。然后，转到[https://editor.swagger.io/](https://editor.swagger.io/)并将内容粘贴到网站编辑器上，它将被编译，并生成一个HTML页面，如下所示：
- en: '![](img/0c8796d5-7187-469e-be1b-263ab3498dac.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c8796d5-7187-469e-be1b-263ab3498dac.png)'
- en: The AWS CLI can also be used to export the API Gateway documentation with the
    `aws apigateway get-export --rest-api-id API_ID --stage-name STAGE_NAME --export-type
    swagger swagger.json` command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI也可以用于导出API Gateway文档，使用`aws apigateway get-export --rest-api-id API_ID
    --stage-name STAGE_NAME --export-type swagger swagger.json`命令。
- en: 'API Gateway and Lambda functions are similar to the serverless application.
    A CI/CD can be written to automate the generation of the documentation automatically
    each time a new endpoint or resource has been implemented on the API Gateway.
    The pipeline must implement the following steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: API Gateway和Lambda函数与无服务器应用程序类似。可以编写CI/CD来自动化生成文档，每当在API Gateway上实现新的端点或资源时。流水线必须执行以下步骤：
- en: Create an S3 bucket
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个S3存储桶
- en: Enable a static website feature on the bucket
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储桶上启用静态网站功能
- en: Download the Swagger UI from [https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)
    and copy the source code to S3
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从[https://github.com/swagger-api/swagger-ui](https://github.com/swagger-api/swagger-ui)下载Swagger
    UI，并将源代码复制到S3
- en: Create a DNS record ([docs.serverlessmovies.com](http://docs.serverlessmovies.com))
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建DNS记录（[docs.serverlessmovies.com](http://docs.serverlessmovies.com)）
- en: Run the `aws apigateway export` command to generate the Swagger definition file
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`aws apigateway export`命令生成Swagger定义文件
- en: Copy the `spec` file to S3 with the `aws s3 cp` command
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`aws s3 cp`命令将`spec`文件复制到S3
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To sum up, we have seen how to build a serverless API from scratch using multiple
    Lambda functions, as well as how to use API Gateway to create a unified API and
    dispatch the incoming requests to the right Lambda function. We resolved the Lambda's
    stateless issue with a DynamoDB datastore and looked at how the use of reserved
    concurrency can help protect downstream resources. Then, we hosted a serverless
    web application in an S3 bucket with CloudFront in front of it to optimize the
    delivery of the web assets. Finally, we learned how to route domain traffic to
    the web application using Route 53 and how to secure it with SSL termination.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经看到了如何使用多个Lambda函数从头开始构建无服务器API，以及如何使用API Gateway创建统一的API并将传入的请求分派到正确的Lambda函数。我们通过DynamoDB数据存储解决了Lambda的无状态问题，并了解了保留并发性如何帮助保护下游资源。然后，我们在S3存储桶中托管了一个无服务器Web应用程序，并在其前面使用CloudFront来优化Web资产的交付。最后，我们学习了如何使用Route
    53将域流量路由到Web应用程序，并如何使用SSL终止来保护它。
- en: 'The following figure illustrates the architecture we''ve implemented so far:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了我们迄今为止实施的架构：
- en: '![](img/1db81716-6ac1-4b45-bb1b-070252a8166d.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1db81716-6ac1-4b45-bb1b-070252a8166d.png)'
- en: In the next chapter, we will improve the CI/CD workflow to add unit and integration
    testing to catch bugs and issues before deploying Lambda functions to production.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将改进CI/CD工作流程，添加单元测试和集成测试，以在将Lambda函数部署到生产环境之前捕获错误和问题。
- en: Questions
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Implement a Lambda function that takes the movie category as input and returns
    a list of movies that correspond to that category.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个以电影类别为输入并返回与该类别对应的电影列表的Lambda函数。
- en: Implement a Lambda function that takes a movie's title as input and returns
    all movies that have the keyword in their title.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个Lambda函数，以电影标题作为输入，返回所有标题中包含关键字的电影。
- en: Implement a delete button on the web application to delete a movie by calling
    the `DeleteMovie` Lambda function from API Gateway.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web应用程序上实现一个删除按钮，通过调用API Gateway的`DeleteMovie` Lambda函数来删除电影。
- en: Implement an edit button on the web application to allow the user to update
    movie attributes.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web应用程序上实现一个编辑按钮，允许用户更新电影属性。
- en: Implement a CI/CD workflow with either CircleCI, Jenkins, or CodePipeline to
    automate the generation and deployment of the API Gateway documentation.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CircleCI、Jenkins或CodePipeline实现CI/CD工作流程，自动化生成和部署API Gateway文档。
