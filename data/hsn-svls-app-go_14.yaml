- en: Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: A typical Lambda-based application consists of multiple functions triggered
    by events, such as a new object in the S3 bucket, incoming HTTP requests, or a
    new SQS message. Those functions can stand alone or leverage other resources,
    such as DynamoDB tables, Amazon S3 buckets, and other Lambda functions. So far,
    we have seen how to create those resources from the AWS Management Console or
    with the AWS CLI. In a real-world scenario, you want to spend less time provisioning
    the required resources and focus more on your application logic. In the end, that's
    the serverless approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的基于Lambda的应用程序由多个函数组成，这些函数由事件触发，例如S3存储桶中的新对象，传入的HTTP请求或新的SQS消息。这些函数可以独立存在，也可以利用其他资源，例如DynamoDB表，Amazon
    S3存储桶和其他Lambda函数。到目前为止，我们已经看到如何从AWS管理控制台或使用AWS CLI创建这些资源。在实际情况下，您希望花费更少的时间来提供所需的资源，并更多地专注于应用程序逻辑。最终，这就是无服务器的方法。
- en: This last chapter will introduce the concept of Infrastructure as Code to help
    you design and deploy your N-Tier serverless application in an automated way,
    in order to avoid human error and repeatable tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章将介绍基础设施即代码的概念，以帮助您以自动化的方式设计和部署N-Tier无服务器应用程序，以避免人为错误和可重复的任务。
- en: Technical requirements
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book assumes some basic familiarity with the AWS Serverless Application
    Model. If you're new to SAM itself, refer to [Chapter 1](746d14b6-7349-4f9e-b76f-f56706e1d0d5.xhtml),
    *Go Serverless* through [Chapter 10](c5d49fcf-6c18-46c5-8841-6b39f7ec4b89.xhtml),
    *Testing Your Serverless Application*. You will get a step-by-step guide on how
    to get started with SAM. The code bundle for this chapter is hosted on GitHub
    at [https://github.com/PacktPublishing/Hands-On-serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您对AWS无服务器应用程序模型有一些基本了解。如果您对SAM本身还不熟悉，请参阅[第1章](746d14b6-7349-4f9e-b76f-f56706e1d0d5.xhtml)，*无服务器Go*，直到[第10章](c5d49fcf-6c18-46c5-8841-6b39f7ec4b89.xhtml)，*测试您的无服务器应用程序*。您将获得一个逐步指南，了解如何开始使用SAM。本章的代码包托管在GitHub上，网址为[https://github.com/PacktPublishing/Hands-On-serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go)。
- en: Deploying AWS Lambda with Terraform
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Terraform部署AWS Lambda
- en: '**Terraform** is an open source automation tool built by HashiCorp. It is used
    to create, manage, and update infrastructure resources through declarative configuration
    files. It supports the following providers:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform**是HashiCorp构建的开源自动化工具。它用于通过声明性配置文件创建，管理和更新基础设施资源。它支持以下提供程序：'
- en: '**Cloud providers**: AWS, Azure, Oracle Cloud, and GCP'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云提供商**：AWS，Azure，Oracle Cloud和GCP'
- en: '**Infrastructure software**:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施软件**：'
- en: '**Consul**: It is a distributed, highly available service-discovery and configuration
    system.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul**：这是一个分布式，高可用的服务发现和配置系统。'
- en: '**Docker**: It is a tool designed to make it easier to create, deploy, and
    run applications by using containers.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：这是一个旨在通过使用容器更轻松地创建，部署和运行应用程序的工具。'
- en: '**Nomad**: It is an easy-to-use enterprise-grade cluster scheduler.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nomad**：这是一个易于使用的企业级集群调度程序。'
- en: '**Vault**: It is a tool that provides a secure, reliable way to store and distribute
    secrets.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vault**：这是一个提供安全，可靠的存储和分发机密的工具。'
- en: Other **SaaS** and **PaaS**
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他**SaaS**和**PaaS**
- en: Terraform is not a configuration-management tool (such as Ansible, Chef, and
    Puppet & Salt). It was created to spawn and destroy infrastructure, while configuration-management
    tools were used to install things on top of existing infrastructure. However,
    Terraform can do a bit of provisioning ([https://www.terraform.io/docs/provisioners/index.html](https://www.terraform.io/docs/provisioners/index.html)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform不是配置管理工具（如Ansible，Chef和Puppet＆Salt）。它是用来生成和销毁基础设施的，而配置管理工具用于在现有基础设施上安装东西。但是，Terraform可以进行一些配置（[https://www.terraform.io/docs/provisioners/index.html](https://www.terraform.io/docs/provisioners/index.html)）。
- en: 'This guide will show you how to deploy AWS Lambda using Terraform, so you will
    need to have Terraform installed. You can find the appropriate package for your
    system and download it ([https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)).
    Once downloaded, make sure that the `terraform` binary is available on the `PATH`
    variable. Configure your credentials so that Terraform is able to act on your
    behalf. The following are four ways to provide credentials for authentication:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南将向您展示如何使用Terraform部署AWS Lambda，因此您需要安装Terraform。您可以找到适合您系统的包并下载它（[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)）。下载后，请确保`terraform`二进制文件在`PATH`变量中可用。配置您的凭据，以便Terraform能够代表您进行操作。以下是提供身份验证凭据的四种方法：
- en: Provide AWS `access_key` and `secret_key` directly through the provider.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供商直接提供AWS `access_key`和`secret_key`。
- en: AWS environment variables.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS环境变量。
- en: Shared credentials file.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享凭据文件。
- en: EC2 IAM role.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EC2 IAM角色。
- en: If you followed [Chapter 2](52476096-dfc4-445d-ab4c-df692471bff7.xhtml), *Getting
    Started with AWS Lambda*, you should have installed and configured the AWS CLI.
    Therefore, no action is required on your part.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了[第2章](52476096-dfc4-445d-ab4c-df692471bff7.xhtml)，*开始使用AWS Lambda*，您应该已经安装并配置了AWS
    CLI。因此，您无需采取任何行动。
- en: Creating the Lambda function
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Lambda函数
- en: 'To begin creating the Lambda function, follow the given steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建Lambda函数，请按照以下步骤进行：
- en: 'Create a new project with the following structure:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下结构创建一个新项目：
- en: '![](img/fd50ed4b-1380-47ea-b8cf-f65b91f15a5d.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd50ed4b-1380-47ea-b8cf-f65b91f15a5d.png)'
- en: 'We will use the easiest Hello world example. The `function` folder contains
    a Go-based Lambda function that displays a simple message:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用最简单的Hello world示例。`function`文件夹包含一个基于Go的Lambda函数，显示一个简单的消息：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can build a Linux-based binary and generate a `deployment` package with
    the following commands:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以构建基于Linux的二进制文件，并使用以下命令生成`deployment`包：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that the function code is defined, let''s create our first Lambda function
    with Terraform. Copy the following content to the `main.tf` file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，函数代码已经定义，让我们使用Terraform创建我们的第一个Lambda函数。将以下内容复制到`main.tf`文件中：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is telling Terraform that we''re going to be using the AWS provider and
    to default to the `us-east-1` region for creating our resources:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉Terraform我们将使用AWS提供程序，并默认为创建我们的资源使用`us-east-1`区域：
- en: '**IAM role** is an execution role that will be assumed by the Lambda function
    during execution. It defines the resources our Lambda function has access to:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IAM角色**是在执行期间Lambda函数将要承担的执行角色。它定义了我们的Lambda函数可以访问的资源：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**IAM policy** is a list of permissions to grant our Lambda function the right
    to stream its logs to CloudWatch. The following policy will be attached to the
    IAM role:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IAM策略**是授予我们的Lambda函数权限的权限列表，以将其日志流式传输到CloudWatch。以下策略将附加到IAM角色：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Lambda function** is a Go-based Lambda function. The deployment package can
    be specified either directly as a local file (using the `filename` attribute)
    or via Amazon S3 bucket. For in-depth details on how to deploy the Lambda function
    to AWS, refer to [Chapter 6](3b3b7465-2646-4532-8303-9e0b8d06bc64.xhtml), *Deploying
    Your Serverless Application*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda函数**是一个基于Go的Lambda函数。部署包可以直接指定为本地文件（使用`filename`属性）或通过Amazon S3存储桶。有关如何将Lambda函数部署到AWS的详细信息，请参阅[第6章](3b3b7465-2646-4532-8303-9e0b8d06bc64.xhtml)，*部署您的无服务器应用*。'
- en: 'On the terminal, run the `terraform init` command to download and install the
    AWS provider, shown as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上运行`terraform init`命令以下载和安装AWS提供程序，如下所示：
- en: '![](img/793cedcf-efd2-4df4-884b-2dcff8c945b3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/793cedcf-efd2-4df4-884b-2dcff8c945b3.png)'
- en: 'Create an execution plan (dry run) with the `terraform plan` command. It shows
    you things that will be created in advance, which is good for debugging and ensuring
    that you''re not doing anything wrong, as shown in the next screenshot:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`terraform plan`命令创建执行计划（模拟运行）。它会提前显示将要创建的内容，这对于调试和确保您没有做错任何事情非常有用，如下一个屏幕截图所示：
- en: '![](img/ff77d443-7739-47c1-bf80-f60ebccac982.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff77d443-7739-47c1-bf80-f60ebccac982.png)'
- en: 'You will be able to examine Terraform''s execution plan before you deploy it
    to AWS. When you''re ready, go ahead and apply the changes by issuing the following
    command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将其部署到AWS之前，您将能够检查Terraform的执行计划。准备好后，通过发出以下命令应用更改：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Confirm the configuration by typing `yes`. The following output will be displayed
    (some parts were cropped for brevity):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认配置，输入`yes`。将显示以下输出（为简洁起见，某些部分已被裁剪）：
- en: '![](img/d87027bf-45ba-4bc0-b2bd-9c3134baadb6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d87027bf-45ba-4bc0-b2bd-9c3134baadb6.png)'
- en: Make sure the IAM user used to execute these commands has permissions to perform
    IAM and Lambda operations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用于执行这些命令的IAM用户具有执行IAM和Lambda操作的权限。
- en: 'If you head back to AWS Lambda Console, a new Lambda function should be created.
    If you try to invoke it, it should return the expected message, as shown in the
    next screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果返回AWS Lambda控制台，应该创建一个新的Lambda函数。如果尝试调用它，应返回预期的消息，如下一个屏幕截图所示：
- en: '![](img/f704065d-9e21-4134-93c4-4191896b72e4.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f704065d-9e21-4134-93c4-4191896b72e4.png)'
- en: 'So far, we defined the AWS region and function name in the template file. However,
    one of the reasons we use infrastructure-as-code tools is usability and automation.
    Hence, you should always use variables and avoid hardcoding values. Luckily, Terraform
    allows you to define your own variables. To do so, create a `variables.tf` file
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们在模板文件中定义了AWS区域和函数名称。但是，我们使用基础架构即代码工具的原因之一是可用性和自动化。因此，您应始终使用变量并避免硬编码值。幸运的是，Terraform允许您定义自己的变量。为此，请创建一个`variables.tf`文件，如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update `main.tf` to use the variables instead of hardcoded values. Note the
    usage of the `${var.variable_name}` keyword:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`main.tf`以使用变量而不是硬编码的值。注意使用`${var.variable_name}`关键字：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the function working as expected, create the serverless API we built so
    far with Terraform.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数按预期工作后，使用Terraform创建我们迄今为止构建的无服务器API。
- en: 'In a new directory, create a file named `main.tf` that contains the following
    configuration:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新目录中，创建一个名为`main.tf`的文件，其中包含以下配置：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code snippet creates an IAM role with permissions to scan a DynamoDB
    table and writes the log entry to CloudWatch. Configure a Go-based Lambda function
    with the DynamoDB table name as an environment variable:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个具有扫描DynamoDB表和将日志条目写入CloudWatch权限的IAM角色。使用DynamoDB表名作为环境变量配置一个基于Go的Lambda函数：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting up DynamoDB table
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置DynamoDB表
- en: 'Next, we have to set up the DynamoDB table. Perform the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置DynamoDB表。执行以下步骤：
- en: 'Create a DynamoDB table with an ID as the partition key for the table:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为表的分区键创建一个DynamoDB表：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Initialize the `movies` table with a new item:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新项目初始化`movies`表：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The item attributes are defined in the `movie.json` file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目属性在`movie.json`文件中定义：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Configuring API Gateway
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置API Gateway
- en: 'Finally, we need to trigger the function with API Gateway:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过API Gateway触发函数：
- en: 'Create a `movies` resource on the REST API and expose a `GET` method on it.
    If the incoming requests match the resource defined, it will call the Lambda function
    defined earlier:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REST API上创建一个`movies`资源，并在其上公开一个`GET`方法。如果传入的请求与定义的资源匹配，它将调用之前定义的Lambda函数：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Issue the following commands to install the AWS plugin, generate an execution
    plan, and apply the changes:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出以下命令安装AWS插件，生成执行计划并应用更改：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It should take a few seconds to create the whole infrastructure. After the
    creation steps are complete, the Lambda function should be created and properly
    configured, as shown in the following screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建整个基础架构应该只需要几秒钟。创建步骤完成后，Lambda函数应该已创建并正确配置，如下一个屏幕截图所示：
- en: '![](img/d1897e2e-f42c-4e22-85a4-81d1b9f222fe.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1897e2e-f42c-4e22-85a4-81d1b9f222fe.png)'
- en: 'The same goes for API Gateway, a new REST API should be defined with a `GET`
    method on `/movies` resource, shown as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API Gateway也是一样，应该定义一个新的REST API，其中`/movies`资源上有一个`GET`方法，如下所示：
- en: '![](img/6f59c9fa-c19d-4738-8a0a-c26d9cc75ab8.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f59c9fa-c19d-4738-8a0a-c26d9cc75ab8.png)'
- en: 'In DynamoDB Console, a new table should be created with a movie item, as shown
    in the next screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DynamoDB控制台中，应创建一个新表，并在下一个屏幕截图中显示一个电影项目：
- en: '![](img/7c0ef84f-bef8-42c4-b050-753afab85f38.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c0ef84f-bef8-42c4-b050-753afab85f38.png)'
- en: 'In order to invoke our API Gateway, we need to deploy it. Create a deployment
    stage, let''s call it `staging`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调用我们的API Gateway，我们需要部署它。创建一个部署阶段，让我们称之为`staging`：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will use Terraform''s output feature to expose the API URL; create an `outputs.tf`
    file with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用Terraform的输出功能来公开API URL；创建一个`outputs.tf`文件，内容如下：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run `terraform apply` again to create these new objects, it will detect the
    changes and ask you to confirm it should perform the actions, shown as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`terraform apply`以创建这些新对象，它将检测到更改并要求您确认它应该执行的操作，如下所示：
- en: '![](img/cf53db32-5b7b-4831-9695-d12ed0177c8e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf53db32-5b7b-4831-9695-d12ed0177c8e.png)'
- en: 'The API Gateway URL will be displayed in the Outputs section; copy it to the
    clipboard:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: API Gateway URL将显示在输出部分；将其复制到剪贴板：
- en: '![](img/681877fa-8271-4164-a912-a941b72f6142.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/681877fa-8271-4164-a912-a941b72f6142.png)'
- en: 'If you point your favorite browser to the API Invocation URL, an error message
    should be displayed, as shown in the next screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将您喜欢的浏览器指向API调用URL，将显示错误消息，如下一张截图所示：
- en: '![](img/5de0d7f6-45c5-4d7d-ae2f-1ab45692a4d4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5de0d7f6-45c5-4d7d-ae2f-1ab45692a4d4.png)'
- en: 'We will fix that, by granting execution permission to API Gateway to invoke
    the Lambda function. Update the `main.tf` file to create a `aws_lambda_permission`
    resource:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过授予API Gateway调用Lambda函数的执行权限来解决这个问题。更新`main.tf`文件以创建`aws_lambda_permission`资源：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Apply the latest changes with the `terraform apply` command. On the Lambda
    Console, the API Gateway trigger should be displayed, shown as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`terraform apply`命令应用最新更改。在Lambda控制台上，API Gateway触发器应该显示如下：
- en: '![](img/b8921922-962d-4e9b-a955-f2f4a7b66b09.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8921922-962d-4e9b-a955-f2f4a7b66b09.png)'
- en: 'Load the URL given in the output from your run in your favorite web browser.
    If everything has worked, you will see the movie stored in the DynamoDB table
    in a JSON format, as shown in the next screenshot:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的网络浏览器中加载输出中给出的URL。如果一切正常，您将以JSON格式在DynamoDB表中看到存储的电影，如下一张截图所示：
- en: '![](img/7d8b3b18-2817-4eea-bde5-b2163cd7af3e.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d8b3b18-2817-4eea-bde5-b2163cd7af3e.png)'
- en: Terraform stores the state of the infrastructure in a state file (`.tfstate`).
    The state contains resource IDs and all the resource attributes. If you're using
    Terraform to create a RDS instance, the database credentials will be in plaintext
    in the state file. Hence, you should keep your file in a remote backend, such
    as S3 bucket.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将基础设施的状态存储在状态文件（`.tfstate`）中。状态包含资源ID和所有资源属性。如果您使用Terraform创建RDS实例，则数据库凭据将以明文形式存储在状态文件中。因此，您应该将文件保存在远程后端，例如S3存储桶中。
- en: Cleaning up
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'Finally, to delete all the resources (Lambda function, IAM role, IAM policies,
    DynamoDB table, and API Gateway), you can issue the `terraform destroy` command,
    shown as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要删除所有资源（Lambda函数、IAM角色、IAM策略、DynamoDB表和API Gateway），您可以发出`terraform destroy`命令，如下所示：
- en: '![](img/a90beaea-d753-4a9b-8518-4142389ae9f7.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a90beaea-d753-4a9b-8518-4142389ae9f7.png)'
- en: 'If you want to delete a specific resource, you can use the `--target` option
    as follows: `terraform destroy --target=RESOURCE_NAME`. The operation will be
    limited to the resource and its dependencies.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想删除特定资源，可以使用`--target`选项，如下所示：`terraform destroy --target=RESOURCE_NAME`。操作将仅限于资源及其依赖项。
- en: So far, we have defined the AWS Lambda function and its dependencies using a
    template file. Hence, we can version it just like any other code. The whole serverless
    infrastructure we use and configure is treated as a source code, allowing us to
    share it among team members, replicate it in other AWS regions, and rollback in
    case of failure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用模板文件定义了AWS Lambda函数及其依赖关系。因此，我们可以像任何其他代码一样对其进行版本控制。我们使用和配置的整个无服务器基础设施被视为源代码，使我们能够在团队成员之间共享它，在其他AWS区域中复制它，并在失败时回滚。
- en: Deploying AWS Lambda with CloudFormation
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation部署AWS Lambda
- en: '**AWS CloudFormation** is an infrastructure-as-code tool for specifying resources
    in a declarative way. You model all the resources you want AWS to spin up in a
    blueprint document (template) and AWS creates the defined resources for you. Thus, you
    spend less time managing those resources and more time focusing on your applications
    that run in AWS.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS CloudFormation**是一种基础设施即代码工具，用于以声明方式指定资源。您可以在蓝图文档（模板）中对您希望AWS启动的所有资源进行建模，AWS会为您创建定义的资源。因此，您花费更少的时间管理这些资源，更多的时间专注于在AWS中运行的应用程序。'
- en: Terraform covers almost all services and features by AWS and supports third-party
    providers (platform-agnostic) while CloudFormation is AWS specific (vendor lock-in).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform几乎涵盖了AWS的所有服务和功能，并支持第三方提供商（平台无关），而CloudFormation是AWS特定的（供应商锁定）。
- en: You can use AWS CloudFormation to specify, deploy, and configure serverless
    applications. You create a template that describes your serverless application
    dependencies (Lambda functions, DynamoDB tables, API Gateway, IAM roles, and so
    on), and AWS CloudFormation takes care of provisioning and configuring those resources
    for you. You don't need to individually create and configure AWS resources and
    figure out what depends on what.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用AWS CloudFormation来指定、部署和配置无服务器应用程序。您创建一个描述无服务器应用程序依赖关系的模板（Lambda函数、DynamoDB表、API
    Gateway、IAM角色等），AWS CloudFormation负责为您提供和配置这些资源。您不需要单独创建和配置AWS资源，并弄清楚什么依赖于什么。
- en: 'Before we dive into CloudFormation, we need to understand the template structure:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解CloudFormation之前，我们需要了解模板结构：
- en: '**AWSTemplateFormatVersion**: CloudFormation template version.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWSTemplateFormatVersion**：CloudFormation模板版本。'
- en: '**Description**: A brief description of the template.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Description**：模板的简要描述。'
- en: '**Mappings**: A mapping of keys and associated values that you can use to specify
    conditional parameter values.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mappings**：键和相关值的映射，可用于指定条件参数值。'
- en: '**Parameters**: Values to pass to your template at runtime.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Parameters**：运行时传递给模板的值。'
- en: '**Resources**: AWS resources and their properties (Lambda, DynamoDB, S3, and
    so on).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Resources**：AWS资源及其属性（Lambda、DynamoDB、S3等）。'
- en: '**Outputs**: Describe the values that are returned whenever you view your stack’s
    properties.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：描述每当查看堆栈属性时返回的值。'
- en: 'After you understand the different parts of the AWS CloudFormation template,
    you can put them together and define a minimal template in a `template.yml` file,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 了解AWS CloudFormation模板的不同部分后，您可以将它们放在一起，并在`template.yml`文件中定义一个最小模板，如下所示：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding file defines two resources:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件定义了两个资源：
- en: '`ExecutionRole`: The IAM role assigned to the Lambda function, it defines what
    entitlements the code invoked by the Lambda runtime has.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutionRole`：分配给Lambda函数的IAM角色，它定义了Lambda运行时调用的代码的权限。'
- en: '`HelloWorldFunction`: The AWS Lambda definition, we have set the runtime property
    to use Go and set the function''s code to be stored in a ZIP file on S3\. The
    function references the IAM role using CloudFormation''s built-in `GetAtt` function;
    it also uses the `Ref` keyword to reference variables defined in the parameters
    section.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HelloWorldFunction`：AWS Lambda定义，我们已将运行时属性设置为使用Go，并将函数的代码存储在S3上的ZIP文件中。该函数使用CloudFormation的内置`GetAtt`函数引用IAM角色；它还使用`Ref`关键字引用参数部分中定义的变量。'
- en: The JSON format can be used also; a JSON version can be found on the GitHub
    repository ([https://github.com/PacktPublishing/Hands-On-serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用JSON格式；在GitHub存储库中可以找到JSON版本（[https://github.com/PacktPublishing/Hands-On-serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go)）。
- en: 'Perform the following steps to begin:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤开始：
- en: 'Create an S3 bucket on which you store the deployment package after building
    it with the following commands:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建后，创建一个S3存储桶来存储部署包：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Navigate to AWS CloudFormation Console, and choose Create Stack, as shown in
    the next screenshot:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到AWS CloudFormation控制台，然后选择“创建堆栈”，如下一个屏幕截图所示：
- en: '![](img/0feeae8d-1e10-4f28-a4f4-3aaf49b8e73a.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0feeae8d-1e10-4f28-a4f4-3aaf49b8e73a.png)'
- en: 'On the Select Template page, select the template file, and it will be uploaded
    to the Amazon S3 bucket, shown as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“选择模板”页面上，选择模板文件，它将上传到Amazon S3存储桶，如下所示：
- en: '![](img/c4b8d238-5224-4326-a5d1-3322e5aac1ed.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4b8d238-5224-4326-a5d1-3322e5aac1ed.png)'
- en: 'Click on Next, define the stack name, and override the default parameters if
    needed, as shown in the next screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“下一步”，定义堆栈名称，并根据需要覆盖默认参数，如下一个屏幕截图所示：
- en: '![](img/9682d28e-043c-4206-978c-54277bc9adb6.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9682d28e-043c-4206-978c-54277bc9adb6.png)'
- en: 'Click on Next, leave the options as default, and click on Create, as shown
    in the next screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“下一步”，将选项保留为默认值，然后单击“创建”，如下一个屏幕截图所示：
- en: '![](img/378aec0b-6713-4877-9cf7-a203509f0361.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/378aec0b-6713-4877-9cf7-a203509f0361.png)'
- en: 'The stack will start creating all the resources defined in the template file.
    Once created, the stack status will change from **CREATE_IN_PROGRESS** to **CREATE_COMPLETE** (in
    case something went wrong, a rollback will be executed automatically), shown as
    follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 堆栈将开始创建模板文件中定义的所有资源。创建后，堆栈状态将从**CREATE_IN_PROGRESS**更改为**CREATE_COMPLETE**（如果出现问题，将自动执行回滚），如下所示：
- en: '![](img/6a932901-01dd-476c-a189-00a7a4cdbad7.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a932901-01dd-476c-a189-00a7a4cdbad7.png)'
- en: 'As a result, our Lambda function should be created as illustrated in the following
    screenshot:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们的Lambda函数应该如下屏幕截图所示创建：
- en: '![](img/4a2a75b1-0523-49df-8036-eb09c05a80f0.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a2a75b1-0523-49df-8036-eb09c05a80f0.png)'
- en: 'You can always update your CloudFormation template file. For example, let''s
    create a new DynamoDB table:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您始终可以更新您的CloudFormation模板文件。例如，让我们创建一个新的DynamoDB表：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the CloudFormation Console, select the stack we created earlier and click
    on Update Stack from the menu, shown as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在CloudFormation控制台上，选择我们之前创建的堆栈，然后从菜单中单击“更新堆栈”，如下所示：
- en: '![](img/cbd01613-eb12-4154-bc05-eb91302dba44.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbd01613-eb12-4154-bc05-eb91302dba44.png)'
- en: 'Upload the updated template file, shown as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上传更新后的模板文件，如下所示：
- en: '![](img/e9ffce4b-26db-44e2-ab9b-5358cdd81cfc.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9ffce4b-26db-44e2-ab9b-5358cdd81cfc.png)'
- en: 'Similar to Terraform, AWS CloudFormation will detect the changes and display
    the resources that will be changed in advance, shown as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Terraform类似，AWS CloudFormation将检测更改并提前显示将更改的资源，如下所示：
- en: '![](img/6b64c142-d567-4f82-b452-c5426fc57337.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b64c142-d567-4f82-b452-c5426fc57337.png)'
- en: 'Click on the Update button to apply the changes. The stack status will change
    to UPDATE_IN_PROGRESS, as shown in the next screenshot:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“更新”按钮以应用更改。堆栈状态将更改为UPDATE_IN_PROGRESS，如下一个屏幕截图所示：
- en: '![](img/aff2ab2c-6736-42f4-a8ea-55cb7db47223.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aff2ab2c-6736-42f4-a8ea-55cb7db47223.png)'
- en: 'After the changes have been applied, a new DynamoDB table will be created and
    DynamoDB permissions will be granted to the Lambda function, shown as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用更改后，将创建一个新的DynamoDB表，并向Lambda函数授予DynamoDB权限，如下所示：
- en: '![](img/f01be3a6-0f19-4e9c-9304-212617986da1.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f01be3a6-0f19-4e9c-9304-212617986da1.png)'
- en: The `--capabilities CAPABILITY_IAM` option is required whenever the CloudFormation
    has to define IAM roles, policies, or related resources.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每当CloudFormation必须定义IAM角色、策略或相关资源时，`--capabilities CAPABILITY_IAM`选项是必需的。
- en: 'The AWS CLI can also be used to create your CloudFormation stack with the following
    command:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AWS CLI也可以用来使用以下命令创建您的CloudFormation堆栈：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: CloudFormation designer
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CloudFormation设计师
- en: 'In addition to writing your own template from scratch, you can use the CloudFormation
    design template feature to create your stack easily. The following screenshot
    shows how to view the design of the stack we''ve created so far:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从头开始编写自己的模板外，还可以使用CloudFormation设计模板功能轻松创建您的堆栈。以下屏幕截图显示了如何查看到目前为止创建的堆栈的设计：
- en: '![](img/53509c27-1e72-49ac-9539-882a4a98d329.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53509c27-1e72-49ac-9539-882a4a98d329.png)'
- en: 'If all has gone well, you should see the following components:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该看到以下组件：
- en: '![](img/eb2d5838-3e48-49e6-85de-7913d9c3e669.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb2d5838-3e48-49e6-85de-7913d9c3e669.png)'
- en: You can now create a complex CloudFormation template by dragging and dropping
    components from the left menu.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过从左侧菜单拖放组件来创建复杂的CloudFormation模板。
- en: Deploying AWS Lambda with SAM
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SAM部署AWS Lambda
- en: The **AWS Serverless Application Model** (**AWS SAM**) is a model to define
    serverless applications. AWS SAM is natively supported by AWS CloudFormation and
    defines a simplified syntax for expressing serverless resources. You simply define
    the resources you need as part of your application in the template file and create
    a CloudFormation stack with the SAM deploy command.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS无服务器应用程序模型**（**AWS SAM**）是定义无服务器应用程序的模型。AWS SAM受到AWS CloudFormation的本地支持，并定义了一种简化的语法来表达无服务器资源。您只需在模板文件中定义应用程序中所需的资源，并使用SAM部署命令创建一个CloudFormation堆栈。'
- en: 'Previously, we saw how AWS SAM can be used to locally test your Lambda function.
    In addition, SAM can be used to design and deploy your function to AWS Lambda.
    You can initialize a quick Go-based serverless project (a boilerplate) with the
    following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何使用AWS SAM来本地测试Lambda函数。此外，SAM还可以用于设计和部署函数到AWS Lambda。您可以使用以下命令初始化一个快速的基于Go的无服务器项目（样板）：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding command will create a folder with the following structure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个具有以下结构的文件夹：
- en: '![](img/0b5d1241-e25c-46a6-aa2b-cad64a26be94.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b5d1241-e25c-46a6-aa2b-cad64a26be94.png)'
- en: The `sam init` command provides a quick way to create a serverless application.
    It generates a simple Lambda function in Go with an associated unit test. In addition,
    a Makefile will be generated with a list of steps to build and generate the deployment
    package. Finally, a template file, called a SAM file, will be created which describes
    all the AWS resources needed to deploy the function to AWS Lambda.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`sam init`命令提供了一种快速创建无服务器应用程序的方法。它生成一个简单的带有关联单元测试的Go Lambda函数。此外，将生成一个包含构建和生成部署包步骤列表的Makefile。最后，将创建一个模板文件，称为SAM文件，其中描述了部署函数到AWS
    Lambda所需的所有AWS资源。'
- en: 'Now that we know how to generate a boilerplate with SAM, let''s write our own
    template from scratch. Create a folder called `findall`, and inside it, create
    a `main.go` file with the content of the `FindAllMovies` function''s code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用SAM生成样板，让我们从头开始编写自己的模板。创建一个名为`findall`的文件夹，在其中创建一个`main.go`文件，其中包含`FindAllMovies`函数的代码内容：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, create a serverless app definition in a `template.yaml` file. The following
    example illustrates how to create a Lambda function with a DynamoDB table:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`template.yaml`文件中创建一个无服务器应用程序定义。以下示例说明了如何创建一个带有DynamoDB表的Lambda函数：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The template is similar to the CloudFormation template we wrote earlier. SAM
    extends CloudFormation and simplifies the syntax for expressing serverless resources.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该模板类似于我们之前编写的CloudFormation模板。SAM扩展了CloudFormation并简化了表达无服务器资源的语法。
- en: 'Use the `package` command to upload the deployment package to the S3 bucket
    created in the *CloudFormation* section:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`package`命令将部署包上传到*CloudFormation*部分中创建的S3存储桶：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding command will upload the deployment page to the S3 bucket, as
    shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将部署页面上传到S3存储桶，如下截图所示：
- en: '![](img/8bfd86bd-6cd4-407a-82d4-4f837e7cc92a.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bfd86bd-6cd4-407a-82d4-4f837e7cc92a.png)'
- en: 'In addition, a SAM template file called `serverless.yaml` will be generated
    based on the definition file you provided. It should contain the `CodeUri` property that
    points to the `deployment` ZIP in the Amazon S3 bucket that you specified:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将基于您提供的定义文件生成一个名为`serverless.yaml`的SAM模板文件。它应该包含指向您指定的Amazon S3存储桶中的`deployment`
    ZIP的`CodeUri`属性：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, deploy the function to AWS Lambda with the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令将函数部署到AWS Lambda：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`CAPABILITY_IAM` is used to explicitly acknowledge that AWS CloudFormation
    is allowed to create an IAM role for the Lambda function on your behalf.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAPABILITY_IAM`用于明确确认AWS CloudFormation被允许代表您为Lambda函数创建IAM角色。'
- en: 'When you run the `sam deploy` command, it creates an AWS CloudFormation stack
    called APIStack, as shown in the next screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`sam deploy`命令时，它将创建一个名为APIStack的AWS CloudFormation堆栈，如下截图所示：
- en: '![](img/33f5c604-5883-4c0c-9f17-c13f094a2a34.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33f5c604-5883-4c0c-9f17-c13f094a2a34.png)'
- en: 'Once the resources are created, the function should be deployed to AWS Lambda,
    shown as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 资源创建后，函数应该部署到AWS Lambda，如下所示：
- en: '![](img/7a65c8f6-52b6-472f-859d-5e1718705e77.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a65c8f6-52b6-472f-859d-5e1718705e77.png)'
- en: The SAM scope is limited to serverless resources (a list of supported AWS services
    is available at: [https://docs.aws.amazon.com/serverlessrepo/latest/devguide/using-aws-sam.html](https://docs.aws.amazon.com/serverlessrepo/latest/devguide/using-aws-sam.html)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SAM范围仅限于无服务器资源（支持的AWS服务列表可在以下网址找到：[https://docs.aws.amazon.com/serverlessrepo/latest/devguide/using-aws-sam.html](https://docs.aws.amazon.com/serverlessrepo/latest/devguide/using-aws-sam.html)）。
- en: Exporting a serverless application
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出无服务器应用程序
- en: 'AWS Lambda allows you to export SAM template files for existing functions.
    Select the target function and click on Export function from the Actions menu,
    shown as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda允许您为现有函数导出SAM模板文件。选择目标函数，然后从操作菜单中单击“导出函数”，如下所示：
- en: '![](img/3807cd11-1678-4917-b8e8-dc14dc4d60d6.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3807cd11-1678-4917-b8e8-dc14dc4d60d6.png)'
- en: 'Click on Download AWS SAM file to download the template file, shown as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“下载AWS SAM文件”以下载模板文件，如下所示：
- en: '![](img/83cc9b85-60af-4865-a357-6e17562ba2af.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83cc9b85-60af-4865-a357-6e17562ba2af.png)'
- en: 'The template will contain the definition of your function, necessary permissions,
    and triggers:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 模板将包含函数的定义、必要的权限和触发器：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can now use the `sam package` and `sam deploy` commands to import the function
    into a different AWS region or AWS account.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`sam package`和`sam deploy`命令将函数导入到不同的AWS区域或AWS账户中。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Managing serverless application resources can be either very manual, or you
    can automate the workflow. Automating the process can be tricky, though, if you
    have a complex infrastructure. This is where tools such as AWS CloudFormation,
    SAM, and Terraform come in.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 管理无服务器应用程序资源可以是非常手动的，或者您可以自动化工作流程。但是，如果您有一个复杂的基础架构，自动化流程可能会很棘手。这就是AWS CloudFormation、SAM和Terraform等工具发挥作用的地方。
- en: In this chapter, we learned how to use infrastructure-as-code tools to automate
    the creation of the serverless application resources and dependencies in AWS.
    We saw tools that are cloud-specific, and loosely coupled ones that work on multiple
    platforms. Then, we saw how these tools can be used to deploy Lambda-based applications
    to AWS.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用基础设施即代码工具来自动化创建AWS中无服务器应用程序资源和依赖关系。我们看到了一些特定于云的工具，以及松散耦合的工具，可以在多个平台上运行。然后，我们看到了这些工具如何用于部署基于Lambda的应用程序到AWS。
- en: By now, you can write your serverless infrastructure code once and then use
    it many times. The code that defines the infrastructure can be versioned, forked,
    rolled back (going back in time), and used for auditing the infrastructure changes,
    just like any other code. Moreover, it can be discovered and addressed in a programmatic
    fashion. In other words, if the infrastructure has been manually modified, you
    destroy that infrastructure and respawn a clean copy—the Immutable Infrastructure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以编写一次无服务器基础设施代码，然后多次使用它。定义基础设施的代码可以进行版本控制、分叉、回滚（回到过去）并用于审计基础设施更改，就像任何其他代码一样。此外，它可以以编程方式发现和解决。换句话说，如果基础设施已经被手动修改，您可以销毁该基础设施并重新生成一个干净的副本——不可变基础设施。
- en: Questions
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Write a Terraform template to create the `InsertMovie` Lambda function resources.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Terraform模板来创建`InsertMovie` Lambda函数资源。
- en: Update the CloudFormation template to trigger the defined Lambda function with
    API Gateway in response to incoming HTTP requests.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新CloudFormation模板，以便在收到传入的HTTP请求时通过API Gateway触发定义的Lambda函数。
- en: Write a SAM file to model and define all the resources needed to build the serverless
    API we built throughout this book.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个SAM文件来建模和定义构建本书中一直使用的无服务器API所需的所有资源。
- en: Configure Terraform to store the generated state file in a remote S3 backend.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Terraform以将生成的状态文件存储在远程S3后端。
- en: Create a CloudFormation template for the serverless API we built throughout
    this book.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们在本书中构建的无服务器API创建一个CloudFormation模板。
- en: Create a Terraform template for the serverless API we built throughout this
    book.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们在本书中构建的无服务器API创建一个Terraform模板。
