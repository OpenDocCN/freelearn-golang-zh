- en: Graph-Based Data Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于图的数据处理
- en: '"Big data is at the foundation of all of the megatrends that are happening
    today, from social to mobile to the cloud to gaming."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “大数据是今天所有重大趋势的基础，从社交到移动，再到云和游戏。”
- en: '- Chris Lynch'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 克里斯·林奇'
- en: Ask any highly successful company out there and they will all unequivocally
    agree that data is a precious commodity. Companies use data to not only make informed
    short-term decisions that affect their day to day operations but also as a guide
    for shaping their strategy in the long term. In fact, in some industries (such
    as advertising), data *is* the product!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 询问任何非常成功的企业，它们都会毫不犹豫地同意数据是一种宝贵的商品。公司使用数据不仅是为了做出影响日常运营的明智的短期决策，而且也是为了塑造其长期战略的指南。实际上，在某些行业（如广告）中，数据*就是*产品！
- en: Nowadays, with the advent of cheap storage solutions, the collection of data
    has increased exponentially in comparison to the last few years. Furthermore,
    the rate of increase in storage requirements is expected to keep following an
    exponential curve well into the future.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着廉价存储解决方案的出现，与过去几年相比，数据的收集量呈指数级增长。此外，存储需求增长的速度预计将继续遵循指数曲线，甚至在未来很长一段时间内也是如此。
- en: While there are quite a few solutions for processing structured data (such as
    systems supporting map-reduce operations), they fall short when the data to be
    processed is organized as a *graph*. Running specialized algorithms against massive
    graphs is a fairly common use case for companies in the field of logistics or
    companies that operate social networks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多处理结构化数据（如支持map-reduce操作的系统）的解决方案，但当要处理的数据以*图*的形式组织时，它们就不够用了。针对大规模图运行专用算法是物流领域或运营社交网络的公司中相当常见的用例。
- en: 'In this chapter, we will be focusing our attention on systems that process
    graphs at scale. More specifically, the following topics will be covered:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注那些大规模处理图的系统。更具体地说，以下主题将被涵盖：
- en: Understanding the **Bulk Synchronous Parallel** (**BSP**) model for distributing
    computation across multiple nodes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**批量同步并行**（**BSP**）模型以在多个节点间分配计算
- en: Applying the BSP model principles to create our very own graph processing system
    in Go
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将BSP模型原则应用于创建我们自己的Go语言图处理系统
- en: Using the graph system as a platform for solving graph-based problems such as
    shortest path and graph coloring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图系统作为解决基于图的问题（如最短路径和图着色）的平台
- en: Implementing an iterative version of the PageRank algorithm for the Links 'R'
    Us project
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Links 'R' Us项目实现PageRank算法的迭代版本
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The full code for the topics that will be discussed in this chapter has been
    published in this book's GitHub repository under the `Chapter08` folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将要讨论的主题的完整代码已发布在本书的GitHub仓库的`Chapter08`文件夹下。
- en: 'You can access this book''s GitHub repository by visiting the following URL:
    [https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang](https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下URL来访问本书的GitHub仓库：[https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang](https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang)。
- en: 'To get you up and running as quickly as possible, each example project includes
    a Makefile that defines the following set of targets:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您尽快开始，每个示例项目都包含一个Makefile，它定义了以下一组目标：
- en: '| **Makefile target** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **Makefile目标** | **描述** |'
- en: '| `deps` | Install any required dependencies |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `deps` | 安装所需的任何依赖项 |'
- en: '| `test` | Run all tests and report coverage |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `test` | 运行所有测试并报告覆盖率 |'
- en: '| `lint` | Check for lint errors |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `lint` | 检查lint错误 |'
- en: As with all other chapters in this book, you will need a fairly recent version
    of Go, which you can download at [https://golang.org/dl](https://golang.org/dl)*.*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的所有其他章节一样，您需要一个相当新的Go语言版本，您可以在[https://golang.org/dl](https://golang.org/dl)*.*下载。
- en: Exploring the Bulk Synchronous Parallel model
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索批量同步并行模型
- en: How can we efficiently run a graph algorithm against a massive graph? To be
    able to answer this question, we need to clarify what we mean by the word *massive*.
    Is a graph with 1 million nodes considered to be massive? How about 10 million,
    100 million, or even 1 billion nodes? The real question we should be asking ourselves
    is whether the graph can actually *fit in memory*. If the answer is yes, then
    we can simply buy (or rent from a cloud provider) a server with a beefy CPU, max
    out the amount of installed memory, and execute our graph-processing code on a
    single node.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何高效地在大型图上运行图算法？为了回答这个问题，我们需要明确我们所说的*大型*是什么意思。一个包含100万个节点的图被认为是大型吗？10百万、100百万，甚至10亿个节点呢？我们应该问自己的真正问题是图是否实际上可以*适应内存*。如果答案是肯定的，那么我们只需购买（或从云服务提供商那里租用）一台配备强大CPU的服务器，将安装的内存量最大化，并在单个节点上执行我们的图处理代码。
- en: On the other hand, things get much more interesting when the answer to the preceding
    question is *no...* Congratulations; you can now claim that you work with big
    data! In such cases, traditional compute models are evidently inadequate; we need
    to start exploring alternative applications that are explicitly designed for out
    of core processing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当回答前面的问题是否定的...恭喜你；你现在可以宣称你在处理大数据！在这种情况下，传统的计算模型显然是不够的；我们需要开始探索专门为离核处理设计的替代应用。
- en: The BSP model is one of the most popular models for building systems that can
    process massive datasets by distributing calculations to a cluster of processing
    nodes. It was proposed in 1990 by Leslie Valiant ^([10]) as a novel and elegant
    approach for bridging together parallel hardware and software.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: BSP模型是构建能够通过将计算分配到处理节点集群来处理大量数据集的系统中最受欢迎的模型之一。它在1990年由Leslie Valiant提出，作为一种新颖而优雅的方法，用于将并行硬件和软件连接起来。
- en: 'At the heart of the BSP model lies the **BSP computer**. The BSP computer,
    which can be seen in the following diagram, is an abstract computer model made
    up of a collection of, potentially heterogeneous, processors that are interconnected
    via a computer network:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: BSP模型的核心是**BSP计算机**。如图所示，BSP计算机是一个由一组，可能异构的，通过计算机网络相互连接的处理机构成的抽象计算机模型：
- en: '![](img/2f23d84d-39d0-4ac5-83e6-a90dc0962c8d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2f23d84d-39d0-4ac5-83e6-a90dc0962c8d.png)'
- en: 'Figure 1: The components that comprise the BSP computer model'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：构成BSP计算机模型的组件
- en: The BSP model itself is not particularly concerned with the network implementation
    details. In fact, the network is treated as a black box; the model can support
    any type of network as long as the network provides a mechanism for routing messages
    between processors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: BSP模型本身并不特别关注网络实现细节。实际上，网络被视为一个黑盒；只要网络提供在处理器之间路由消息的机制，模型就可以支持任何类型的网络。
- en: Processors can not only access their own local memory, but they can also use
    the network link to exchange data with other processors. To this end, the BSP
    computer is effectively a *distributed memory* computer that can perform computations
    in parallel. However, this functionality comes with a catch! While access to local
    memory is fast, accessing a remote processor's memory is significantly slower
    as it involves an exchange of messages over the network link. Therefore, the BSP
    computer can be also characterized as a **non-uniform memory access** (**NUMA**)
    architecture.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器不仅可以访问它们自己的本地内存，还可以使用网络链路与其他处理器交换数据。为此，BSP计算机实际上是一个*分布式内存*计算机，可以并行执行计算。然而，这种功能也有一个代价！虽然访问本地内存很快，但访问远程处理器的内存要慢得多，因为它涉及到通过网络链路交换消息。因此，BSP计算机也可以被描述为一种**非统一内存访问**（**NUMA**）架构。
- en: So, what kinds of programs can we run on a BSP computer? Algorithms or data
    processing operations that can be expressed as a *sequence of iteration steps*
    are generally a good fit for the BSP model. The BSP model uses the term *super-step*
    to refer to the execution of a single iteration of a user-defined program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们可以在BSP计算机上运行哪些类型的程序呢？可以表示为*迭代步骤序列*的算法或数据处理操作通常非常适合BSP模型。BSP模型使用术语*超级步骤*来指代用户定义程序的单次迭代执行。
- en: One thing that differentiates the BSP model from other concurrent programming
    models is that BSP achieves parallelism through the use of a technique referred
    to as **Single Program Multiple Data** (**SPMD**). Software engineers who are
    interested in writing programs for the BSP computer can do so as if they were
    writing a program for a single-core machine. The program simply receives a set
    of data as input, applies a processing function to it, and emits some output.
    In other words, software engineers are completely oblivious to the existence of
    individual processors and the network that connects them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: BSP 模型与其他并发编程模型的一个区别是，BSP 通过使用称为 **单程序多数据**（**SPMD**）的技术来实现并行性。对为 BSP 计算机编写程序感兴趣的软件工程师可以像为单核机器编写程序一样进行操作。程序简单地接收一组数据作为输入，对其应用处理函数，并输出一些结果。换句话说，软件工程师对个别处理器及其连接的网络的存在一无所知。
- en: 'Before commencing the execution of the user''s program, the BSP computer transparently
    uploads the program to every single processor, splits the data to be processed
    into a set of partitions, and assigns each partition to one of the available processors.
    The model employs a rather cunning strategy to reduce computation latency: it
    breaks down each super-step into two phases or substeps: a **compute** step and
    a **communication** step. During the compute step, each processor executes a single
    iteration of the user''s program using the data that was assigned to the processor
    as input. Once *all* the processors have completed their individual computations,
    they can communicate through the network and – depending on the use case – compare,
    exchange, or aggregate the results of their individual computations.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始执行用户的程序之前，BSP 计算机透明地将程序上传到每个处理器，将需要处理的数据分割成一组分区，并将每个分区分配给一个可用的处理器。该模型采用了一种相当巧妙的策略来减少计算延迟：它将每个超步骤分解为两个阶段或子步骤：一个
    **计算** 步骤和一个 **通信** 步骤。在计算步骤中，每个处理器使用分配给处理器的数据作为输入，执行用户程序的单一迭代。一旦 *所有* 处理器完成它们的个别计算，它们可以通过网络进行通信，并根据用例比较、交换或汇总它们个别计算的结果。
- en: 'Given that each processor can perform computation work in parallel and independently
    from other processors, the BSP model makes use of **blocking barriers** to synchronize
    processors. The following diagram summarizes the way in which the BSP computer
    model executes programs as a sequence of super-steps that are isolated from each
    other via write barriers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个处理器可以并行且独立于其他处理器执行计算工作，BSP 模型利用 **阻塞屏障** 来同步处理器。以下图表总结了 BSP 计算机模型执行程序的方式，即作为一系列通过写屏障相互隔离的超步骤：
- en: '![](img/3c87d7d2-1148-4ae9-a9c8-29c43ae3efe4.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c87d7d2-1148-4ae9-a9c8-29c43ae3efe4.png)'
- en: 'Figure 2: The BSP computer model executes programs as a sequence of super-steps
    that are isolated from each other via write barriers'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2：BSP 计算机模型通过写屏障将程序作为一系列相互隔离的超步骤执行
- en: In Go parlance, a blocking barrier is equivalent to a `sync.WaitGroup`; the
    BSP computer waits for all the processors to reach the barrier before assigning
    them the next chunk of work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 术语中，阻塞屏障相当于 `sync.WaitGroup`；BSP 计算机等待所有处理器达到屏障后，才分配给它们下一块工作。
- en: In the last couple of years, interest in models such as BSP has spiked. This
    can largely be attributed to Google, which (excluding state-funded three-letter
    agencies) is the undisputed worldwide leader in big data processing. Google engineers
    incorporated several of the BSP model concepts into Pregel, an in-house solution
    for out-of-core graph processing. In 2010, Google published a paper ^([7]) detailing
    the design decisions and architecture behind Pregel. This publication paved the
    way for creating open source equivalents such as Stanford's GPS ^([4]) and Apache
    Giraph ^([1]). The latter is currently used at Facebook to analyze the social
    graph that's formed by the network's users and their connections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，对 BSP 等模型的需求激增。这很大程度上归功于谷歌，它是（不包括由政府资助的三字母机构）全球大数据处理领域当之无愧的领导者。谷歌工程师将
    BSP 模型的几个概念融入了 Pregel，这是一个用于离核图处理的内部解决方案。2010 年，谷歌发表了一篇论文^([7])，详细介绍了 Pregel 的设计决策和架构。这篇论文为创建开源替代品铺平了道路，例如斯坦福的
    GPS^([4]) 和 Apache Giraph^([1])。后者目前被 Facebook 用于分析由网络用户及其连接形成的社会图。
- en: Building a graph processing system in Go
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中构建图处理系统
- en: There is no better way to gain a deeper understanding of the BSP model principles
    than to build, from scratch, our very own scalable Pregel-like graph processing
    system in Go.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比从头开始构建我们自己的可扩展Pregel-like图处理系统更好的方法来深入理解BSP模型原理。
- en: 'Here are a few of the design requirements for the system we will be building:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要构建的系统的一些设计要求：
- en: Graphs will be represented as a collection of vertices and directed edges. Each
    vertex will be assigned a unique ID. In addition, both vertices and edges can
    optionally store a user-defined value.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图将被表示为一组顶点和有向边。每个顶点将被分配一个唯一的ID。此外，顶点和边可以可选地存储用户定义的值。
- en: At every super-step, the system executes a user-defined compute function for
    *every* vertex in the graph.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个超级步骤中，系统都会为图中的每个顶点执行一个用户定义的计算函数。
- en: Compute functions are allowed to inspect and modify the internal state of the
    vertex they are invoked on. They can also iterate the list of outgoing edges and
    exchange messages with other vertices.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算函数允许检查和修改它们被调用时的顶点的内部状态。它们还可以遍历输出边列表，与其他顶点交换消息。
- en: Any outgoing messages that are produced during a super-step will be buffered
    and delivered to their intended recipients in the *following* super-step.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在超级步骤期间产生的任何输出消息都将被缓冲，并在*下一个*超级步骤中交付给预期的接收者。
- en: The system must be able to support both single- and multi-node (distributed)
    graph topologies. In a multi-node topology, each node is responsible for managing
    a subset of the graph vertices and their outgoing edges. While operating in a
    multi-node configuration, the system should provide a mechanism for relaying vertex
    messages between nodes (for example, over a network link).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统必须能够支持单节点和多节点（分布式）图拓扑。在多节点拓扑中，每个节点负责管理图顶点及其输出边的一个子集。在多节点配置下操作时，系统应提供一种机制，用于在节点之间中继顶点消息（例如，通过网络链接）。
- en: In the following sections, we will analyze each of these requirements in more
    detail and elaborate on how they can be implemented in Go. You can find the fully
    documented source code and test suites for the graph processing system from this
    chapter in the `Chapter08/bspgraph` folder in this book's GitHub repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地分析这些要求，并阐述如何在Go语言中实现它们。您可以从本书GitHub仓库的`Chapter08/bspgraph`文件夹中找到图处理系统的完整文档源代码和测试套件。
- en: Queueing and delivering messages
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列和交付消息
- en: One of the core ideas of the BSP model is that graph components communicate
    with each other by exchanging messages. The fact that each vertex in the graph
    can potentially receive multiple messages mandates the introduction of some sort
    of abstraction for storing or queuing incoming messages until they are ready to
    be processed by the intended recipient.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: BSP模型的一个核心思想是图组件通过交换消息相互通信。每个图顶点可能接收多个消息的事实，要求引入某种抽象来存储或排队传入的消息，直到它们准备好被预期的接收者处理。
- en: In the three sections that follow, we will kick off our design discussion by
    defining the required interfaces for modeling messages and queues. Then, we will
    take a stab at implementing a simple, concurrent-safe in-memory queue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三个部分中，我们将通过定义建模消息和队列所需的接口来启动我们的设计讨论。然后，我们将尝试实现一个简单、线程安全的内存队列。
- en: The Message interface
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息接口
- en: 'It logically follows that the contents of messages that are exchanged between
    vertices heavily depend on the application or graph algorithm that we are trying
    to execute. Consequently, to avoid passing plain `interface{}` values around,
    we need to come up with a plausible interface for describing messages in a generic
    way. The `Message` interface, which lives in the `Chapter08/bspgraph/message`
    package, is an attempt at doing exactly that:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，交换顶点之间消息的内容在很大程度上取决于我们试图执行的应用或图算法。因此，为了避免传递简单的`interface{}`值，我们需要想出一个合理的接口来以通用方式描述消息。位于`Chapter08/bspgraph/message`包中的`Message`接口正是为此目的而设计的：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this point, you are probably dubious about the usefulness of having a `Type`
    method on this interface. Can this really be any better than simply using an `interface{}`?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能对在这个接口上有一个`Type`方法的有效性表示怀疑。这真的会比简单地使用`interface{}`更好吗？
- en: If you recall our discussion of the BSP computer model, processors communicate
    with each other over network links. Before a message can be transmitted over the
    network, the sender must serialize it into a byte stream. On the receiving end,
    the byte stream is unserialized back into a message and delivered to the intended
    recipient.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们关于BSP计算机模型的讨论，处理器通过网络链路相互通信。在消息可以通过网络传输之前，发送者必须将其序列化为字节流。在接收端，字节流被反序列化为消息并交付给预期的接收者。
- en: The `Type` method is quite handy for supporting use cases where the sender and
    the receiver can exchange *different* types of messages over the same channel
    (for example, a TCP socket). At serialization time, the sender queries the type
    of the message and attaches this information as additional metadata to the serialized
    payload. The receiver can then decode the metadata and unserialize the payload's
    byte stream back to the appropriate type of message.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Type`方法对于支持发送者和接收者可以在同一通道上交换*不同*类型消息的场景非常有用（例如，TCP套接字）。在序列化时，发送者查询消息的类型，并将此信息作为附加元数据附加到序列化负载中。接收者然后可以解码元数据并将负载的字节流反序列化回适当的消息类型。'
- en: Queues and message iterators
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列和消息迭代器
- en: 'Queues serve as buffers for storing incoming messages and making them available
    for consumption by compute functions. Users of the graph processing system can
    either make use of the built-in in-memory queue (see the next section) or inject
    their application-specific queue implementation as long as it adheres to the `Queue`
    interface, whose definition is listed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 队列作为存储传入消息并使其可供计算函数消费的缓冲区。图处理系统的用户可以使用内置的内存队列（参见下一节）或注入符合`Queue`接口的应用特定队列实现，只要它遵循以下定义：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The methods on the `Queue` interface are pretty standard for any type of queue
    system. A call to `PendingMessages` reveals whether the queue is currently empty,
    while a call to `DiscardMessages` can be used to flush any stored messages. The
    `Enqueue` method can be used to append a new `Message` to the queue, while the
    `Messages` method returns an `Iterator` for accessing the list of already enqueued
    messages. Since iterator implementations are typically coupled to the underlying
    queue system, `Iterator` is also defined as an interface:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`接口上的方法对于任何类型的队列系统来说都很标准。调用`PendingMessages`可以揭示队列当前是否为空，而调用`DiscardMessages`可以用来清除任何存储的消息。`Enqueue`方法可以用来将新的`Message`追加到队列中，而`Messages`方法返回一个用于访问已入队消息列表的`Iterator`。由于迭代器实现通常与底层队列系统耦合，因此`Iterator`也被定义为接口：'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This interface follows exactly the same iterator pattern that you should be
    familiar with from the previous chapters. Calling `Next` advances the iterator
    and returns a Boolean value to indicate whether more messages are available. After
    a successful call to `Next`, the current message can be retrieved by calling `Message`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口遵循与之前章节中你应该熟悉的相同迭代器模式。调用`Next`会移动迭代器并返回一个布尔值以指示是否有更多消息可用。在成功调用`Next`之后，可以通过调用`Message`来检索当前消息。
- en: Implementing an in-memory, thread-safe queue
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现内存、线程安全的队列
- en: For the majority of applications, using an in-memory queue implementation such
    as the one presented here should suffice. Implementing support for other types
    of queue systems (for example, Kafka, nats-streaming, or even plain files) is
    left as an exercise for you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用来说，使用如本文中展示的内存队列实现应该足够。实现对其他类型队列系统的支持（例如，Kafka、nats-streaming，甚至是普通文件）则留作你的练习。
- en: 'Let''s start by defining the `inMemoryQueue` type and its constructor:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义`inMemoryQueue`类型及其构造函数：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the in-memory queue is nothing more than a slice of `Message`
    instances – a slot for storing the message that's being currently pointed to by
    an iterator and a `sync.Mutex` for serializing access to the list of messages.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内存队列不过是一系列`Message`实例的切片——一个用于存储当前由迭代器指向的消息的槽位，以及一个`sync.Mutex`用于序列化对消息列表的访问。
- en: 'Next, we will take a look at the implementation of `Enqueue` and `PendingMessages`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`Enqueue`和`PendingMessages`的实现：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To enqueue a new message, we acquire the lock and then append the messages to
    the list. In a similar fashion, checking for pending messages is facilitated by
    obtaining the lock and checking whether the message list is empty.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要入队一个新消息，我们获取锁并将消息追加到列表中。以类似的方式，检查待处理消息可以通过获取锁并检查消息列表是否为空来实现。
- en: 'The last set of functions that we need to implement so that the type satisfies
    the `Queue` interface are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现最后一组函数，以便类型满足`Queue`接口，具体如下：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see in the preceding code block, the implementation of the `DiscardMessages`
    method uses a nifty trick: the message list is purged via a slice operation that
    *retains* the already allocated slice capacity but resets its length to zero.
    This allows us to reduce the number of memory allocations that need to be performed
    and, by extension, reduce the pressure on the Go garbage collector.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个代码块所示，`DiscardMessages`方法的实现使用了一个巧妙的技巧：通过切片操作清空消息列表，同时保留已分配的切片容量，但将其长度重置为零。这使我们能够减少需要执行的内存分配次数，从而减轻Go垃圾收集器的压力。
- en: 'Furthermore, the `Messages` method body is quite interesting in itself as the
    returned value implies that the `inMemoryQueue` type must *also* implement the
    `Iterator` interface! The following code shows the implementation of the relevant
    methods for satisfying the `Iterator` interface:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Messages`方法体本身也非常有趣，因为返回值暗示`inMemoryQueue`类型也必须实现`Iterator`接口！以下代码显示了满足`Iterator`接口的相关方法的实现：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While most queue implementations use FIFO semantics, as you can easily tell
    by the `Message` method's implementation, the in-memory queue follows **last-in
    first-out** (**LIFO**) semantics. This is intentional; if we were to dequeue from
    the head of the list (for example, `q.msgs = q.msgs[1:]`), its capacity would
    decrease and we wouldn't be able to reuse the already allocated memory to append
    new messages in the future.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数队列实现使用FIFO语义，正如您可以通过`Message`方法的实现轻松看出，内存队列遵循**后进先出**（**LIFO**）语义。这是故意的；如果我们从列表的头部出队（例如，`q.msgs
    = q.msgs[1:]`），其容量将减少，我们将来将无法重用已分配的内存来追加新的消息。
- en: As the graph system that we are building is not required to provide any guarantee
    about the order of incoming messages, our in-memory queue implementation can be
    used as-is without any issue. Now that we have a solution for storing messages,
    we can go ahead and define the necessary structures that will represent the vertices
    and edges of our graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们构建的图系统不需要提供关于传入消息顺序的任何保证，因此我们可以直接使用内存队列实现，而不会出现任何问题。现在我们已经有了存储消息的解决方案，我们可以继续定义表示图顶点和边的必要结构。
- en: Modeling the vertices and edges of graphs
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模图的顶点和边
- en: As we mentioned when we discussed the requirements for the graph processing
    system, we need to come up with a model for describing the vertices and edges
    that comprise a graph. Moreover, we need to provide an API that we can use to
    insert new vertices and edges into the graph.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在讨论图处理系统需求时提到的，我们需要提出一个描述构成图的顶点和边的模型。此外，我们还需要提供一个API，我们可以使用它将新的顶点和边插入到图中。
- en: Defining the Vertex and Edge types
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义顶点和边类型
- en: 'The `Vertex` type encapsulates the state of each vertex that is part of a `Graph`
    instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vertex`类型封装了`Graph`实例中每个顶点的状态：'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An interesting tidbit about the `Vertex` type definition is that we actually
    need to maintain two `message.Queue` instances. Any messages produced by compute
    function invocations while executing a super-step must be buffered so that they
    can be delivered to the intended recipient in the *following* super-step. To this
    end, our implementation will employ a double-buffering scheme. We will use one
    queue to hold the messages for the current super-step and another queue to buffer
    the messages for the next super-step. At the end of each super-step, we will swap
    the queues around so that the output queue from the previous super-step becomes
    the input queue for the following super-step and vice versa. To avoid having to
    physically swap the queue pointers for every vertex in the graph, we will rely
    on modulo arithmetic to select the input and output queues based on the current
    super-step number:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Vertex`类型定义的一个有趣的事实是，我们实际上需要维护两个`message.Queue`实例。在执行超级步骤时，由计算函数调用产生的任何消息都必须被缓冲，以便它们可以在下一个超级步骤中交付给预期的接收者。为此，我们的实现将采用双缓冲方案。我们将使用一个队列来保存当前超级步骤的消息，另一个队列来缓冲下一个超级步骤的消息。在每个超级步骤结束时，我们将交换队列，使上一个超级步骤的输出队列成为下一个超级步骤的输入队列，反之亦然。为了避免在每个图的顶点上物理交换队列指针，我们将依靠模运算来根据当前超级步骤编号选择输入和输出队列：
- en: The queue at index `super_step%2` holds the messages that should be consumed
    during the current super-step
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引为 `super_step%2` 的队列持有当前超级步骤应消费的消息
- en: The queue at index `(super_step+1)%2` buffers the messages for the next super-step
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引为 `(super_step+1)%2` 的队列缓冲了下一个超级步骤的消息
- en: 'Moving on, we shouldn''t allow users of the `bspgraph` package to directly
    mutate the internal state of vertices. Therefore, none of the `Vertex` fields
    are exported outside of the `bspgraph` package. Instead, we will define the following
    set of helper methods so that we can access and/or safely manipulate the state
    of a vertex instance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不应该允许 `bspgraph` 包的用户直接修改顶点的内部状态。因此，`Vertex` 字段没有在 `bspgraph` 包外部导出。相反，我们将定义以下一组辅助方法，以便我们可以访问和/或安全地操作顶点实例的状态：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each vertex is uniquely identified by a string-based ID that can be queried
    via a call to the `ID` method. In addition, vertices can optionally store a user-defined
    value that compute functions can read or write via the `Value` and `SetValue`
    methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点都由一个基于字符串的 ID 唯一标识，可以通过调用 `ID` 方法来查询。此外，顶点可以选择存储一个用户定义的值，计算函数可以通过 `Value`
    和 `SetValue` 方法读取或写入该值。
- en: 'What''s more, a vertex can be in one of the following two states: *active*
    or *inactive* state. All the vertices are initially marked as *active. *To conserve
    compute resources, the graph framework will only invoke compute functions on active
    vertices. If the compute method implementation decides that a particular vertex
    has reached a terminal state and no further calculations are required, it can
    opt to explicitly mark the vertex as inactive via a call to its `Freeze` method*.*
    However, should an inactive vertex receive a new message during a super-step,
    the graph framework will automatically mark it as active at the next super-step.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，顶点可以处于以下两种状态之一：*活动*或*非活动*状态。所有顶点最初都被标记为 *活动*。为了节省计算资源，图框架将只对活动顶点调用计算函数。如果计算方法实现决定某个特定顶点已达到终止状态且不再需要进一步计算，它可以选择通过调用其
    `Freeze` 方法显式地将顶点标记为非活动。然而，如果一个非活动顶点在超级步骤期间收到一条新消息，图框架将在下一个超级步骤自动将其标记为活动。
- en: 'Finally, the `Edges` method returns a slice of `Edge` objects that correspond
    to the outgoing, directed edges originating from a particular vertex. The following
    code shows the definition of the `Edge` type and its helper methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Edges` 方法返回一个与特定顶点出发的出边、有向边对应的 `Edge` 对象的切片。以下代码展示了 `Edge` 类型的定义及其辅助方法：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Similar to the `Vertex` type, edges can also store an optional user-defined
    value that can be read/written to via the `Value` and `SetValue` methods. Every
    edge has a destination vertex whose ID can be obtained via a call to the `DstID`
    method. As we will see in the *Sending and receiving messages* section, the vertex
    ID is the only piece of information that we need to be aware of in order to send
    a message to a particular vertex.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Vertex` 类型类似，边也可以存储一个可选的用户定义值，可以通过 `Value` 和 `SetValue` 方法读取/写入。每个边都有一个目标顶点，其
    ID 可以通过调用 `DstID` 方法获得。正如我们将在 *发送和接收消息* 部分中看到的那样，顶点 ID 是我们为了向特定顶点发送消息而需要了解的唯一信息。
- en: Inserting vertices and edges into the graph
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将顶点和边插入到图中
- en: The `Graph` type keeps track of all vertices that comprise the graph with the
    help of a map where keys are vertex IDs and values are `Vertex` instances. Besides
    the fact that the vertex map allows us to quickly lookup vertices by their ID
    – a very important feature for delivering incoming messages – it also provides
    an efficient mechanism (as opposed to using a slice) for *deleting* vertices if
    we ever wish to allow users to mutate the graph topology between super-steps.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 类型通过一个键为顶点 ID、值为 `Vertex` 实例的映射来跟踪构成图的所有顶点。除了顶点映射允许我们快速通过 ID 查找顶点——这对于传递传入消息非常重要——它还提供了一个高效的机制（与使用切片相比），如果我们希望允许用户在超级步骤之间修改图拓扑，我们可以通过它来删除顶点。'
- en: 'New vertices can be inserted into the graph via the `AddVertex` method. It
    expects two arguments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 新顶点可以通过 `AddVertex` 方法插入到图中。它期望两个参数：
- en: A unique vertex ID
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个唯一的顶点 ID
- en: 'An initial value (which may also be `nil`):'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始值（也可能为 `nil`）：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If a vertex with the same ID already exists, we simply override its stored initial
    value. Otherwise, a new `Vertex` instance must be allocated. The code populates
    its ID field, sets the vertex status to active, and invokes the configured (at
    graph construction time) queue factory to instantiate the two queues that we need
    in order to store incoming messages for the current and next super-steps. Finally,
    the new vertex instance is inserted into the map.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经存在具有相同ID的顶点，我们只需覆盖其存储的初始值。否则，必须分配一个新的`Vertex`实例。代码填充其ID字段，将顶点状态设置为活动状态，并调用配置的（在图构建时）队列工厂来实例化我们需要的两个队列，以便存储当前和下一个超级步骤的传入消息。最后，将新的顶点实例插入到映射中。
- en: 'Similarly, the `AddEdge` method creates a new directed edge between two vertices:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`AddEdge`方法在两个顶点之间创建一个新的有向边：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we mentioned in a *Defining the Vertex and Edge types* section, edges are
    *owned* by the vertices they originate from. Ergo, the `AddEdge` implementation
    must check whether the `srcID` can be resolved to an existing vertex. If the source
    vertex cannot be located, then an error is returned to the caller. Otherwise,
    a new edge is created and appended to the edge list of the source vertex.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*定义顶点和边类型*部分中提到的，边由它们起源的顶点拥有。因此，`AddEdge`实现必须检查`srcID`是否可以解析为现有顶点。如果找不到源顶点，则向调用者返回错误。否则，创建一个新的边并将其附加到源顶点的边列表中。
- en: Note that while we expect the source vertex for the edge to be known locally,
    the same assumption cannot be made for the destination vertex. For instance, if
    the graph was spread across two nodes, the source vertex could be managed by the
    first node while the destination vertex could be managed by the second node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们期望边的源顶点在本地是已知的，但对于目标顶点不能做出相同的假设。例如，如果图分布在两个节点上，源顶点可能由第一个节点管理，而目标顶点可能由第二个节点管理。
- en: Sharing global graph state through data aggregation
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过数据聚合共享全局图状态
- en: Aggregators are a key component for implementing several graph-based algorithms
    that rely on sharing global state between vertices. They are concurrent-safe primitives
    that apply an aggregation operator to a set of values and make the result available
    to *all* the vertices at the next super-step.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合器是实现依赖于顶点之间共享全局状态的几个基于图的算法的关键组件。它们是并发安全的原语，将聚合运算符应用于一组值，并在下一个超级步骤中将结果提供给所有顶点。
- en: Any kind of operator can be used to create an aggregator as long as it is commutative
    and associative. Aggregators are commonly used to implement counters, accumulators,
    or for keeping track of the minimum and/or maximum value of some quantity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 只要运算符是交换的和结合的，就可以使用任何类型的运算符来创建聚合器。聚合器通常用于实现计数器、累加器或跟踪某些数量的最小值和/或最大值。
- en: 'In the upcoming sections, we will do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将做以下事情：
- en: Define a generic interface for aggregators
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个通用的聚合器接口
- en: Augment our Graph type with helper methods for registering and looking up `Aggregator`
    instances by name
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注册和按名称查找`Aggregator`实例的辅助方法增强我们的`Graph`类型
- en: Build an example aggregator that accumulates `float64` values
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个累加`float64`值的示例聚合器
- en: Defining the Aggregator interface
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义聚合器接口
- en: 'The `Aggregator` interface describes the set of methods that must be implemented
    by Go types so that they can be used with our graph processing framework for data
    aggregation purposes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregator`接口描述了Go类型必须实现的方法集，以便它们可以用于我们的图处理框架进行数据聚合：'
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: One of my pet peeves is that the methods in the preceding interface definition
    use `interface{}` values. Unfortunately, this is one of the few cases where we
    cannot actually avoid the use of `interface{}` since the types of values that
    can be aggregated are implementation-specific.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一个小烦恼是，前面接口定义中的方法使用了`interface{}`值。不幸的是，这是少数几个我们实际上无法避免使用`interface{}`的情况之一，因为可以聚合的值的类型是特定于实现的。
- en: Whenever we want to apply the aggregation operation to a new value, we can do
    so by invoking the `Aggregate` method. Furthermore, the current value can be retrieved
    via a call to the `Get` method. On the other hand, if we want to set the aggregator
    to a *specific* value (for example, reset a counter to zero), we can invoke the
    `Set` method. The `Type` method provides an identifier for the aggregator's type
    that can be used for serialization purposes (for example, if we want to take a
    snapshot of the graph's state).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要将聚合操作应用于新值时，可以通过调用 `Aggregate` 方法来实现。此外，可以通过调用 `Get` 方法检索当前值。另一方面，如果我们想要将聚合器设置为
    *特定* 的值（例如，将计数器重置为零），我们可以调用 `Set` 方法。`Type` 方法提供了聚合器类型的标识符，可用于序列化目的（例如，如果我们想要对图的状态进行快照）。
- en: The `Delta` method returns the *change* in the aggregator's value since the
    *last* time that either `Delta` or `Set` was called. This method is meant to be
    used in a distributed graph computation scenario (see [Chapter 12](67abdf43-7d4c-4bff-a17e-b23d0a900759.xhtml),
    *Building Distributed Graph Processing Systems*) to reduce the values from individual
    local aggregators into a single global aggregated value.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delta` 方法返回自上次调用 `Delta` 或 `Set` 以来聚合器值的 *变化*。此方法旨在在分布式图计算场景中使用（参见第 12 章，*构建分布式图处理系统*），将单个局部聚合器的值减少到单个全局聚合值。'
- en: 'To understand how the `Delta` method is used, let''s picture a scenario where
    we deploy three nodes: a master and two workers. Our goal is to create a distributed
    counter whose value is synchronized with all the nodes prior to executing a new
    super-step. To achieve this, each node (including the master) defines a *local*
    aggregator instance that implements a simple counter. While executing a super-step,
    compute functions are only allowed access to the local counter of the worker they
    are executing on. The master node is not assigned any vertices. Instead, it is
    responsible for collecting the partial *deltas* from each worker, aggregating
    those into its own counter, and *broadcasting* the new total back to the workers.
    The workers then use the `Set` method to update their local counters to the new
    total.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `Delta` 方法的使用方法，让我们设想一个场景，其中我们部署了三个节点：一个主节点和两个工作节点。我们的目标是创建一个分布式计数器，其值在执行新的超级步骤之前与所有节点同步。为此，每个节点（包括主节点）定义了一个
    *本地* 聚合器实例，该实例实现了一个简单的计数器。在执行超级步骤时，计算函数只能访问它们正在执行的工作节点的本地计数器。主节点没有分配任何顶点。相反，它负责收集每个工作节点的部分
    *delta*，将其聚合到自己的计数器中，并将新的总数 *广播* 回到工作节点。然后，工作节点使用 `Set` 方法更新它们的本地计数器到新的总数。
- en: Registering and looking up aggregators
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册和查找聚合器
- en: 'To facilitate efficient name-based aggregator lookups, `Graph` instances store
    aggregators in a map where the aggregator name is used as a key. New aggregator
    instances can be linked to a `Graph` instance through the `RegisterAggregator`
    method:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于基于名称的聚合器查找，`Graph` 实例将聚合器存储在一个映射中，其中聚合器名称用作键。可以通过 `RegisterAggregator` 方法将新的聚合器实例链接到
    `Graph` 实例：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compute functions that need access to a particular aggregator can invoke the
    `Aggregator` method to look up a registered aggregator instance by name:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 需要访问特定聚合器的计算函数可以调用 `Aggregator` 方法，通过名称查找已注册的聚合器实例：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In an effort to make it easier for clients to create snapshots of the graph's
    state, we will also be providing the auxiliary `Aggregators` method, which just
    returns a copy of the map that contains the complete set of registered aggregator
    instances.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使客户端更容易创建图状态的快照，我们还将提供辅助的 `Aggregators` 方法，该方法仅返回包含已注册聚合器实例完整集合的映射的副本。
- en: Implementing a lock-free accumulator for float64 values
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个无锁的 float64 值累加器
- en: In the `Chapter08/bspgraph/aggregator` package, you can find two concurrent-safe
    accumulator implementations that are designed to work with `int64` and `float64`
    values and can also double as distributed counters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Chapter08/bspgraph/aggregator` 包中，您可以找到两个并发安全的累加器实现，这些实现旨在与 `int64` 和 `float64`
    值一起工作，也可以用作分布式计数器。
- en: Instead of using a mutex to guarantee concurrent access, both accumulators are
    implemented using compare and swap instructions. The int64-based version is pretty
    straightforward and can easily be implemented with the help of the functions provided
    by the `sync/atomic` package. The float64-based version, which we will be dissecting
    here, is more challenging (and fun!) since the `sync/atomic` package offers no
    support for dealing with floating-point values. To work around this limitation,
    we will import the `unsafe` package and employ a few *creative value casting tricks*
    to roll our very own set of atomic functions that can work with `float64` values!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用互斥锁来保证并发访问，这两个累加器都是通过比较和交换指令实现的。基于 int64 的版本相当直接，并且可以很容易地利用 `sync/atomic`
    包提供的函数来实现。我们将在这里剖析的基于 float64 的版本更具挑战性（并且更有趣！），因为 `sync/atomic` 包没有提供处理浮点值的支持。为了克服这一限制，我们将导入
    `unsafe` 包，并使用一些 *创造性的值转换技巧* 来创建我们自己的原子函数集，这些函数可以与 `float64` 值一起工作！
- en: 'Let''s begin by defining the `Float64Accumulator` type:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 `Float64Accumulator` 类型：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Float64Accumulator` type keeps track of two `float64` values: the first
    one holds the current sum while the latter keeps track of the last value that
    was reported by a call to the `Delta` method.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Float64Accumulator` 类型跟踪两个 `float64` 值：第一个存储当前总和，而后者跟踪通过调用 `Delta` 方法报告的最后一个值。'
- en: 'Now, let''s define the necessary set of methods for satisfying the `Accumulator`
    interface. The first method that we will be defining is `Get`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义满足 `Accumulator` 接口所需的一组方法。我们将定义的第一个方法是 `Get`：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `loadFloat64` helper function is where all the magic happens. The
    trick that we will be using is based on the observation that a `float64` value
    takes exactly the same space in memory (8 bytes) as a `uint64` value. With the
    help of the `unsafe` package, we can cast a *pointer* to the `float64` value we
    want to read into a `*uint64` value and use the `atomic.LoadUint64` function to
    read it atomically as a raw `uint64` value. Then, we can use the handy `Float64frombits`
    function from the built-in `math` package to *interpret* the raw `uint64` value
    as a `float64`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`loadFloat64` 辅助函数是所有魔法发生的地方。我们将使用的一个技巧是基于观察，即 `float64` 值在内存中占据的空间（8字节）与
    `uint64` 值相同。借助 `unsafe` 包，我们可以将读取 `float64` 值的指针转换为 `*uint64` 值，并使用 `atomic.LoadUint64`
    函数以原始 `uint64` 值的形式原子地读取它。然后，我们可以使用内置 `math` 包中的方便的 `Float64frombits` 函数将原始 `uint64`
    值 *解释* 为 `float64`。
- en: 'Next, let''s examine the implementation for `Aggregate`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `Aggregate` 方法的实现：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see in the preceding code snippet, we enter an infinite `for` loop
    where we fetch the current aggregator value, add the `float64` value that was
    passed to the method, and keep trying to execute a compare and swap operation
    until we succeed. Like we did previously, we exploit the observation that `float64`
    values take the same space in memory as an `uint64` and use `atomic.CompareAndSwapUint64`
    to perform the swap. This function expects `uint64` values as arguments, so this
    time, we leverage the `math.Float64bits` function to convert the `float64` values
    that we are working with into raw `uint64` values for the compare-and-swap operation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的代码片段中看到的，我们进入一个无限 `for` 循环，在其中获取当前的聚合器值，添加传递给方法的 `float64` 值，并不断尝试执行比较和交换操作，直到成功。像之前一样，我们利用观察到的
    `float64` 值在内存中占据与 `uint64` 相同的空间，并使用 `atomic.CompareAndSwapUint64` 来执行交换。这个函数期望
    `uint64` 值作为参数，所以这次，我们利用 `math.Float64bits` 函数将我们正在处理的 `float64` 值转换为用于比较和交换操作的原始
    `uint64` 值。
- en: 'We can apply exactly the same methodology to implement the `Delta` method,
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用完全相同的方法来实现 `Delta` 方法，如下所示：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once again, we enter an infinite for loop where we latch on to the current and
    previous values and then use a compare and swap operation to copy `curSum` to
    `prevSum`. Once the swap succeeds, we subtract the two latched values and return
    the result to the caller.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次进入一个无限 `for` 循环，在其中捕获当前和前一个值，然后使用比较和交换操作将 `curSum` 复制到 `prevSum`。一旦交换成功，我们就从捕获的两个值中减去，并将结果返回给调用者。
- en: 'To complete the set of methods for implementing our accumulator, we also need
    to provide an implementation for `Set`, which, as you see in the following code
    listing, is slightly more complicated:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成实现我们的累加器的方法集，我们还需要提供一个 `Set` 方法的实现，正如你在下面的代码列表中看到的，这稍微复杂一些：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The extra complexity arises from the fact that we need to perform two sequential
    compare and swap operations, both of which must succeed before we can exit the
    `for` loop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的复杂性源于我们需要执行两个连续的比较和交换操作，这两个操作都必须成功，我们才能退出 `for` 循环。
- en: Sending and receiving messages
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收消息
- en: 'As we mentioned previously, vertices communicate with each other by exchanging
    messages. Sending the *same* message to all immediate neighbors of a particular
    vertex is an often recurring pattern in several graph algorithms. Let''s define
    a convenience method for handling this fairly common use case:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，顶点通过交换消息相互通信。向特定顶点的所有直接邻居发送相同的消息是多个图算法中经常出现的模式。让我们定义一个方便的方法来处理这种相当常见的用例：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`BroadcastToNeighbors` simply iterates the list of edges for a particular vertex
    and attempts to send the message to each neighbor with the help of the `SendMessage`
    method. With the help of `SendMessage`, compute functions can send a message to
    any vertex in the graph, provided that its ID is known to them (for example, discovered
    through the use of a gossip protocol).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`BroadcastToNeighbors` 简单地迭代特定顶点的边列表，并尝试使用 `SendMessage` 方法将消息发送给每个邻居。借助 `SendMessage`，计算函数可以向图中的任何顶点发送消息，前提是它们知道其
    ID（例如，通过使用八卦协议发现）。'
- en: 'Let''s take a look at the implementation for `SendMessage`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `SendMessage` 的实现：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First things first, we need to look up the destination vertex in the graph's
    vertex map. If the lookup yields a valid `Vertex` instance, then we can enqueue
    the message so that it can be delivered to the vertex in the following super-step.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在图顶点映射中查找目标顶点。如果查找返回有效的 `Vertex` 实例，那么我们可以将消息入队，以便在下一次超级步骤中将其传递给顶点。
- en: 'Things get a bit more interesting when the vertex lookup fails… A failed lookup
    can occur because of two reasons:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶点查找失败时，事情变得更有趣… 查找失败可能有两个原因：
- en: We are running in distributed mode and the vertex is managed by a *remote* graph
    instance
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在以分布式模式运行，并且顶点由一个 *远程* 图实例管理
- en: The vertex simply does not exist
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点根本不存在
- en: 'To handle vertices that are potentially hosted remotely, the `Graph` type allows
    users of the `bspgraph` package to register a helper that can relay messages between
    remote graph instances. More specifically, these helpers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可能托管在远程的顶点，`Graph` 类型允许 `bspgraph` 包的用户注册一个助手，该助手可以在远程图实例之间传递消息。更具体地说，这些助手：
- en: Are aware of the topology of a distributed graph (that is, the vertex ID ranges
    that are managed by each node in a cluster)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解分布式图的拓扑结构（即集群中每个节点管理的顶点 ID 范围）
- en: Provide a mechanism for shuttling messages back and forth between the cluster
    nodes
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供在集群节点之间穿梭消息的机制
- en: 'User-defined relay helpers must implement the `Relayer` interface and can be
    registered with a graph instance through the `RegisterRelayer` method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的中继助手必须实现 `Relayer` 接口，并且可以通过 `RegisterRelayer` 方法与图实例注册：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To make it easier for users to provide functions or closures as a suitable
    `Relayer` implementation, let''s also go ahead and define the `RelayerFunc` adapter,
    which converts a function with the appropriate signature into a `Relayer`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用户更容易提供合适的 `Relayer` 实现的函数或闭包，让我们也定义 `RelayerFunc` 适配器，它将具有适当签名的函数转换为 `Relayer`：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the destination vertex ID cannot be located by the graph and the user has
    registered a `Relayer` instance, `SendMessage` invokes its `Relay` method and
    checks the response for errors. If we get an error *other* than `ErrDestinationLocal`,
    we return the error as-is back to the caller.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图无法定位目标顶点 ID，并且用户已注册 `Relayer` 实例，则 `SendMessage` 将调用其 `Relay` 方法并检查响应中的错误。如果我们得到除
    `ErrDestinationLocal` 之外的错误，我们将错误原样返回给调用者。
- en: If the relay helper detects that the destination vertex ID should, in fact,
    be managed by the local graph instance, it will fail with the typed `ErrDestinationIsLocal`
    error to indicate this. In such a case, we assume that the vertex ID is invalid
    and return the typed `ErrInvalidMessageDestination` error to the caller.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中继助手检测到目标顶点 ID 实际上应由本地图实例管理，它将使用类型为 `ErrDestinationIsLocal` 的错误失败，以指示这一点。在这种情况下，我们假设顶点
    ID 无效，并将类型为 `ErrInvalidMessageDestination` 的错误返回给调用者。
- en: Implementing graph-based algorithms using compute functions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算函数实现基于图的算法
- en: 'In order for a compute function to be used with the `bspgraph` package, it
    must adhere to the following signature:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使计算函数与 `bspgraph` 包一起使用，它必须遵循以下签名：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first argument to the compute function is a pointer to the `Graph` instance
    itself. This allows compute functions to use the graph API to query the current
    super-step number, look up aggregators, and send messages to vertices. The second
    argument is a pointer to the `Vertex` instance that the compute function is operating
    on, while the third and final argument is a `message.Iterator` for consuming the
    messages that were sent to the vertex during the *previous* super-step.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 计算函数的第一个参数是指向 `Graph` 实例本身的指针。这允许计算函数使用图 API 来查询当前超级步骤编号、查找聚合器并向顶点发送消息。第二个参数是指向计算函数正在操作的
    `Vertex` 实例的指针，而第三个和最后一个参数是 `message.Iterator`，用于消费在 *上一个* 超级步骤期间发送给顶点的消息。
- en: It is important to note that the system operates under the assumption that compute
    functions can be safely executed concurrently. The only runtime guarantee that's
    provided by the system is that at each super-step, compute functions will be executed
    for each vertex *exactly once*. Consequently, compute function implementations
    can use any of the `Vertex` methods without having to worry about data races and
    synchronization issues. Given that vertices effectively *own* the edges originating
    from them, the same data access principles also apply to any `Edge` instances
    that are obtained by invoking the `Edges` method on a vertex.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，系统在假设计算函数可以安全地并发执行的前提下运行。系统提供的唯一运行时保证是，在每个超级步骤中，计算函数将针对每个顶点 *恰好执行一次*。因此，计算函数实现可以使用任何
    `Vertex` 方法，而无需担心数据竞争和同步问题。鉴于顶点实际上 *拥有* 从它们起源的边，相同的数据访问原则也适用于通过在顶点上调用 `Edges`
    方法获得的任何 `Edge` 实例。
- en: Achieving vertical scaling by executing compute functions in parallel
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过并行执行计算函数实现垂直扩展
- en: Next, we will shift our focus to the mechanism that's used to execute compute
    functions. A rather simplistic approach would be to use a `for` loop construct
    to iterate the vertices in the graph and invoke the compute function for each
    vertex in a sequential fashion. While the approach would undoubtedly work as expected,
    it would be a rather inefficient use of the compute resources that are at our
    disposal. Running compute functions sequentially would only make use of a single
    CPU core; that would be quite a waste given that machines with up to 64 cores
    are readily available from the majority of cloud providers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注用于执行计算函数的机制。一个相当简单的方法是使用 `for` 循环结构迭代图中的顶点，并以顺序方式对每个顶点调用计算函数。虽然这种方法无疑会按预期工作，但它会非常低效地使用我们可用的计算资源。按顺序运行计算函数只会使用单个
    CPU 核心；考虑到大多数云提供商都可以轻松获得多达 64 核心的机器，这将是相当浪费的。
- en: 'A much better alternative would be to fan out the execution of compute functions
    to a pool of workers. This way, compute functions can run in parallel and make
    full use of all the available CPU cores. The graph constructor initializes the
    pool of workers via a call to the `startWorkers` method, whose implementation
    is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的替代方案是将计算函数的执行扇出到工作者池中。这样，计算函数可以并行运行并充分利用所有可用的 CPU 核心。图构造器通过调用 `startWorkers`
    方法初始化工作者池，其实现如下：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The first thing that `startWorkers` does is create a set of channels that are
    needed to communicate with the workers in the pool. Let''s briefly talk about
    each channel''s purpose:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`startWorkers` 的第一件事是创建一组用于与池中的工作者进行通信的通道。让我们简要地谈谈每个通道的作用：'
- en: '`vertexCh` is a channel that is polled by workers to obtain the next vertex
    to be processed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertexCh` 是一个由工作者轮询的通道，用于获取下一个要处理的顶点。'
- en: '`errCh` is a buffered channel where workers publish any errors that may occur
    while invoking compute functions. The graph processing system implementation will
    treat all errors as *fatal*. Therefore, we only need room to store a single error
    value. When a worker detects an error, it will attempt to enqueue it to `errCh`;
    if the channel is full, another fatal error has already been written to it, so
    the new error can safely be ignored.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errCh` 是一个缓冲通道，工作者在此通道中发布在调用计算函数时可能发生的任何错误。图处理系统实现将所有错误视为 *致命的*。因此，我们只需要有足够的空间来存储单个错误值。当工作者检测到错误时，它将尝试将其入队到
    `errCh`；如果通道已满，则已写入另一个致命错误，因此新的错误可以安全地忽略。'
- en: Since we are using a worker pool to execute compute functions in parallel, we
    need to introduce some sort of synchronization mechanism to detect when all the
    vertices have been processed. The `stepCompletedCh` channel allows workers to
    signal when the *last* enqueued vertex has been processed.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用工作池并行执行计算函数，我们需要引入某种同步机制来检测所有顶点是否已被处理。`stepCompletedCh`通道允许工人在最后一个入队的顶点被处理时发出信号。
- en: 'The remainder of the `startWorkers` method is pretty straightforward: we start
    a go-routine for each worker and use a `sync.WaitGroup` to keep track of their
    completion status.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`startWorkers`方法的其余部分相当简单：我们为每个工人启动一个goroutine，并使用`sync.WaitGroup`来跟踪它们的完成状态。'
- en: 'The `step` method, as shown in the following code, is responsible for executing
    a single super-step. If the super-step completes without an error, `step` returns
    the number of vertices that were active during the super-step:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`step`方法负责执行单个超级步。如果超级步在没有错误的情况下完成，`step`将返回超级步期间活跃的顶点数量：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding block of code should be self-explanatory. First, we reset the
    `activeInStep` counter to zero and load the `pendingInStep` counter with the number
    of vertices in the graph. Then, the map that holds the set of the graph `Vertex`
    instances is iterated and each vertex value is written to `vertexCh` so that it
    can be picked up and processed by an idle worker.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块应该是自解释的。首先，我们将`activeInStep`计数器重置为零，并将`pendingInStep`计数器加载为图中顶点的数量。然后，迭代持有图`Vertex`实例集合的映射，并将每个顶点值写入`vertexCh`，以便它可以被空闲的工人拾取和处理。
- en: Once all the vertices have been enqueued, `step` waits for all vertices to be
    processed by the worker pool by performing a blocking read on `stepCompletedCh`.
    Before returning, the code checks whether an error has been enqueued to the error
    channel. If that happens to be the case, the error is dequeued and returned to
    the caller.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有顶点都已入队，`step`将通过在`stepCompletedCh`上执行阻塞读取来等待所有顶点被工作池处理。在返回之前，代码检查是否将错误入队到错误通道。如果发生这种情况，错误将被出队并返回给调用者。
- en: 'Now, let''s take a look at the `stepWorker` method''s implementation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`stepWorker`方法的实现：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The channel's `range` statement ensures that our worker will keep executing
    until the `vertexCh` is closed. After dequeuing the next vertex from `vertexCh`,
    the worker uses modulo arithmetic to select the message queue that contains the
    messages that should be consumed by the compute function during the current super-step.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的`range`语句确保我们的工人将继续执行，直到`vertexCh`被关闭。在从`vertexCh`中出队下一个顶点之后，工人使用模运算来选择包含当前超级步期间应由计算函数消费的消息的消息队列。
- en: Vertices are considered to be active if either their `active` flag is set or
    if their input message queue contains any undelivered messages. For any vertex
    deemed to be active, we set its `active` flag to `true` and atomically increment
    the `activeInStep` counter. As we will see in the following sections, several
    graph algorithms use the number of active vertices in a super-step as a predicate
    for deciding whether the algorithm has completed or not.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点被认为是活跃的，如果它们的`active`标志被设置，或者如果它们的输入消息队列包含任何未投递的消息。对于任何被认为是活跃的顶点，我们将它的`active`标志设置为`true`，并原子性地增加`activeInStep`计数器。正如我们将在以下章节中看到的，几个图算法使用超级步中活跃顶点的数量作为判断算法是否完成的条件。
- en: 'Next, we invoke the registered compute function and check for any errors. If
    an error occurs, we invoke the `tryEmitError` helper to enqueue the error to `errCh`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用注册的计算函数并检查是否有错误。如果发生错误，我们调用`tryEmitError`辅助函数将错误入队到`errCh`：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The last bit of housekeeping that we need to do within the `stepWorker` method
    is to call the queue's `DiscardMessages` method and flush any messages that were
    not consumed by the compute function that we executed in the previous step. This
    ensures that the queue is always empty and ready to store incoming messages for
    `superstep+2`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stepWorker`方法中我们需要做的最后一点家务是调用队列的`DiscardMessages`方法，并刷新任何在前一步执行的计算函数中没有消费的消息。这确保队列始终为空，并准备好存储`superstep+2`的传入消息。
- en: Regardless of whether the vertex is active or not, the worker invokes the `atomic.AddInt64`
    function to *decrement* the `pendingInStep` counter and check whether it has reached
    zero. When that occurs, all the vertices for the current super-step have been
    processed and the worker writes an empty `struct{}` value to `stepCompletedCh`
    to unblock the `step` method and allow it to return.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无论顶点是否活跃，工作进程都会调用`atomic.AddInt64`函数来**递减**`pendingInStep`计数器，并检查它是否已达到零。当这种情况发生时，当前超级步骤的所有顶点都已处理完毕，工作进程将一个空的`struct{}`值写入`stepCompletedCh`，以解除`step`方法的阻塞并允许其返回。
- en: Orchestrating the execution of super-steps
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调超级步骤的执行
- en: In the previous section, we performed a detailed analysis of the mechanism that's
    used by the `Graph` type to execute a single super-step. However, graph algorithms
    typically involve several super-steps. For the `bspgraph` package users to be
    able to run generic graph algorithms using the system we are building, they require
    more fine-grained control over the execution of a sequence of super-steps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们对`Graph`类型执行单个超级步骤所使用的机制进行了详细分析。然而，图算法通常涉及多个超级步骤。为了让`bspgraph`包的用户能够使用我们正在构建的系统运行通用图算法，他们需要对一系列超级步骤的执行有更细粒度的控制。
- en: 'Before executing a super-step, we need to reset the value of one or more aggregators.
    Likewise, after a super-step completes, we might be interested in examining or
    modifying an aggregator''s final value. Furthermore, each algorithm defines its
    own termination condition. For example, an algorithm might terminate when the
    following occurs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行一个超级步骤之前，我们需要重置一个或多个聚合器的值。同样，在超级步骤完成后，我们可能对检查或修改聚合器的最终值感兴趣。此外，每个算法都定义了自己的终止条件。例如，一个算法可能在以下情况下终止：
- en: After a fixed number of steps
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在固定数量的步骤之后
- en: When all vertices in the graph become inactive
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当图中的所有顶点都变为不活跃状态时
- en: When the value of some aggregator exceeds a threshold
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当某些聚合器的值超过阈值时
- en: 'To cater to such requirements, we need to introduce a high-level API that provides
    an orchestration layer for governing the execution of a sequential list of super-steps.
    This API is provided by the `Executor` type, whose definition is as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这样的需求，我们需要引入一个高级API，该API提供了一层协调层来管理一系列超级步骤的执行。这个API由`Executor`类型提供，其定义如下：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'An `Executor` wraps a `Graph` instance and is parameterized with a set of user-defined
    `ExecutorCallbacks`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`封装了一个`Graph`实例，并使用一组用户定义的`ExecutorCallbacks`进行参数化：'
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `PreStep` and `PostStep` callbacks are invoked – if defined – before and
    after the execution of a new super-step. If the `PostStepKeepRunning` callback
    is defined, it will be automatically invoked by the `Executor` after `PostStep`.
    The callback is responsible for checking whether the termination condition for
    the algorithm has been met and to return `false` when no further super-steps need
    to be executed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreStep`和`PostStep`回调在执行新超级步骤之前和之后被调用（如果已定义）。如果定义了`PostStepKeepRunning`回调，它将在`PostStep`之后自动由`Executor`调用。回调负责检查算法的终止条件是否已满足，并在不需要执行更多超级步骤时返回`false`。'
- en: 'The `NewExecutor` function serves as a constructor for creating new `Executor`
    instances:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewExecutor`函数作为创建新`Executor`实例的构造函数：'
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To avoid nil pointer dereference errors when trying to invoke undefined callbacks,
    the constructor uses the following helper to patch missing callbacks with a dummy
    no-op stub:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在尝试调用未定义的回调时发生空指针解引用错误，构造函数使用以下辅助函数来用模拟的空操作存根修补缺失的回调：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The high-level interface that''s exposed by the `Executor` consists of the
    following set of methods:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`公开的高级接口包括以下一组方法：'
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Graph` method provides access to the `Graph` instance that''s linked to
    the `Executor`, while `Superstep` reports the *last* super-step that was executed.
    The `RunSteps` and `RunToCompletion` methods repeatedly execute super-steps until
    one of the following conditions is met:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph`方法提供了访问与`Executor`关联的`Graph`实例的权限，而`Superstep`报告了已执行的**最后一个**超级步骤。`RunSteps`和`RunToCompletion`方法会重复执行超级步骤，直到满足以下条件之一：'
- en: The context expires
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文过期
- en: An error occurs
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生错误
- en: The `PostStepKeepRunning` callback returns false
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostStepKeepRunning`回调返回false'
- en: The maximum number of `numSteps` has been executed (only for `RunSteps`)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行了最大数量的`numSteps`（仅适用于`RunSteps`）
- en: 'Both of these functions are simply proxies for the `run` method, whose implementation
    is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数仅仅是`run`方法的代理，其实现如下：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `run` method enters a `for` loop that keeps running until the caller-provided
    `maxSteps` value becomes equal to zero. At the end of each iteration, `maxSteps`
    is decremented while the graph's `superstep` counter is incremented. However,
    if the caller specifies a *negative* value for `maxSteps` when invoking `run`,
    then the preceding loop is functionally equivalent to an infinite loop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`方法进入一个`for`循环，直到调用者提供的`maxSteps`值等于零时才会停止运行。在每个迭代的末尾，`maxSteps`递减，而图的超步骤计数器递增。然而，如果调用者在调用`run`时指定了`*负值*`作为`maxSteps`，那么前面的循环在功能上等同于一个无限循环。'
- en: The `Executor` begins a new iteration by checking whether the provided context
    has been canceled and then proceeds to invoke the `PreStep` callback. Then, it
    executes a new super-step by invoking the `step` method of the wrapped `Graph`
    instance. Following that, it invokes the `PostStep` and `PostStepKeepRunning`
    callbacks. If any of the callbacks or the `step` method returns an error, then
    we break out of the loop and return the error back to the caller.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`通过检查提供的上下文是否已取消开始新的迭代，然后继续调用`PreStep`回调。然后，它通过调用包装的`Graph`实例的`step`方法执行一个新的超级步骤。随后，它调用`PostStep`和`PostStepKeepRunning`回调。如果任何回调或`step`方法返回错误，则退出循环并将错误返回给调用者。'
- en: Creating and managing Graph instances
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理`Graph`实例
- en: Our graph processing system is nearly complete! To finalize our implementation,
    we need to define a constructor that will create new `Graph` instances and some
    auxiliary methods that will manage the graph's life cycle.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图处理系统几乎完成了！为了最终实现，我们需要定义一个构造函数，该构造函数将创建新的`Graph`实例，以及一些辅助方法来管理图的生命周期。
- en: As we saw in the previous sections, there are quite a few knobs for configuring
    `Graph` instances. Passing each individual configuration option as an argument
    to the graph's constructor is considered to be an anti-pattern – not to mention
    that we would have to bump the major version of our package every time we want
    to add a new configuration option; changing a constructor's signature is the very
    definition of a breaking change!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，有相当多的旋钮可以配置`Graph`实例。将每个单独的配置选项作为参数传递给图的构造函数被认为是一种反模式——更不用说，每次我们想要添加一个新的配置选项时，我们都需要提高我们包的主版本号；更改构造函数的签名正是破坏性更改的定义！
- en: 'A much better solution is to define a typed configuration object and pass that
    as an argument to the constructor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是定义一个类型化的配置对象，并将其作为参数传递给构造函数：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`QueueFactory` will be used by the `AddVertex` method to create the required
    message queue instances for each new vertex that is being added to the graph.
    The `ComputeFn` setting is used to specify the compute function that will be executed
    for each super-step. Finally, the `ComputeWorkers` option allows the end users
    of the package to fine-tune the size of the worker pool so that they can execute
    the provided compute function.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueueFactory`将由`AddVertex`方法使用，为每个被添加到图中的新顶点创建所需的消息队列实例。`ComputeFn`设置用于指定每个超级步骤将执行的计算函数。最后，`ComputeWorkers`选项允许包的最终用户微调工作池的大小，以便他们可以执行提供的计算函数。'
- en: 'From the preceding list of configuration options, only `ComputeFn` is required.
    Let''s create a validator helper to check a `GraphConfig` object and to populate
    missing fields with sane defaults:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置选项列表中，只有`ComputeFn`是必需的。让我们创建一个验证辅助程序来检查`GraphConfig`对象，并用合理的默认值填充缺失的字段：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If a nil `QueueFactory` instance is provided by the caller, the validator code
    will use the in-memory implementation as a sane default. Furthermore, if an invalid
    number of compute workers is specified, the validator will fall back to using
    a single worker. Of course, doing so would effectively turn processing graph vertices
    for every super-step into a *sequential* operation. Nevertheless, this might prove
    to be a useful feature when the end users wish to debug misbehaving compute functions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者提供了一个nil的`QueueFactory`实例，验证代码将使用内存实现作为合理的默认值。此外，如果指定的计算工作员数量无效，验证程序将回退到使用单个工作员。当然，这样做将有效地将每个超级步骤处理图顶点变成一个*顺序*操作。尽管如此，当最终用户希望调试行为不当的计算函数时，这可能会证明是一个有用的功能。
- en: 'A new `Graph` instance can be created via the `NewGraph` constructor, which
    is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`NewGraph`构造函数创建一个新的`Graph`实例，如下所示：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first thing that the constructor needs to do is run a validation check on
    the provided configuration options. With a valid configuration at hand, the code
    creates the `Graph` instance, plugs in the provided configuration options, and
    allocates the maps that are needed to hold the graph's `Vertex` and `Aggregator`
    instances. The last thing that the constructor needs to do before returning the
    new `Graph` instance to the caller is initialize the worker pool via a call to
    `startWorkers`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数需要做的第一件事是对提供的配置选项进行验证检查。有了有效的配置，代码将创建 `Graph` 实例，连接提供的配置选项，并分配所需的映射来存储图的
    `Vertex` 和 `Aggregator` 实例。在将新的 `Graph` 实例返回给调用者之前，构造函数需要做的最后一件事是通过调用 `startWorkers`
    来初始化工作池。
- en: 'After creating a new `Graph` instance, users can proceed with populating the
    graph vertices and edges, register aggregators, and make use of an `Executor`
    to orchestrate the execution of a particular graph-based algorithm. However, after
    a completed run, users may want to reuse a `Graph` instance to run the exact same
    algorithm again but this time to use a different graph layout. Let''s provide
    them with a `Reset` method to reset the graph''s internal state:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的 `Graph` 实例后，用户可以继续填充图顶点和边，注册聚合器，并使用 `Executor` 来编排特定图算法的执行。然而，在完成运行后，用户可能希望重用
    `Graph` 实例以再次运行相同的算法，但这次使用不同的图布局。让我们为他们提供一个 `Reset` 方法来重置图的内部状态：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you may recall, every vertex is associated with two message queue instances.
    The `message.Queue` interface defines a `Close` method that we must call to release
    any resources (for example, file handles, sockets, and so on) that are used by
    the underlying queue implementation. Lastly, to completely reset the graph's internal
    state, we can simply reset the graph's super-step counter to zero and recreate
    the maps that store the graph's vertices and aggregator instances.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，每个顶点都与两个消息队列实例相关联。`message.Queue` 接口定义了一个 `Close` 方法，我们必须调用它来释放底层队列实现使用的任何资源（例如，文件句柄、套接字等）。最后，为了完全重置图的内部状态，我们可以简单地将图的超级步计数器重置为零，并重新创建存储图顶点和聚合器实例的映射。
- en: 'Given that the worker pool consists of a bunch of long-running go-routines,
    we must also provide a mechanism for managing their life cycle and, more importantly,
    to shut them down when we are done with the graph. The last method that we will
    be defining on the `Graph` type is `Close`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作池由许多长时间运行的 go-routines 组成，我们必须提供一个机制来管理它们的生命周期，更重要的是，在我们完成图操作后关闭它们。我们将在
    `Graph` 类型上定义的最后一个方法是 `Close`：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To force the worker pool to cleanly shut down and all its workers to exit, the
    `Close` method implementation closes `vertexCh`, which each worker polls for incoming
    vertex processing jobs. The code then blocks on a wait group until all the workers
    have exited. Before returning, we make a tail call to the `Reset` method to ensure
    that the per-vertex queue instances are properly closed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制工作池干净地关闭并且所有工作进程都退出，`Close` 方法的实现关闭了 `vertexCh`，这是每个工作进程轮询以获取传入的顶点处理作业的通道。然后代码在等待组上阻塞，直到所有工作进程都已退出。在返回之前，我们通过调用
    `Reset` 方法进行尾调用，以确保每个顶点的队列实例被正确关闭。
- en: This concludes the development of a framework that allows us to execute graph-based
    algorithms using the BSP computation model. Next, we will explore how we can leverage
    the framework to solve some real-world problems that involve graphs!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着允许我们使用 BSP 计算模型执行基于图的算法的框架的开发完成。接下来，我们将探讨如何利用这个框架来解决一些涉及图的现实世界问题！
- en: Solving interesting graph problems
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决有趣的图问题
- en: In this section, we will be examining three very popular graph-based problems
    that are good fits for the graph processing system we have just finished building.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查三个非常流行的基于图的难题，这些难题非常适合我们刚刚构建的图处理系统。
- en: After describing each problem in detail and listing some of its potential real-world
    applications, we will continue our discussion by presenting a *sequential* algorithm
    that can be used to solve it. Following that, we will come up with an equivalent
    parallel version of the same algorithm and encode it as a compute function that
    can be used with the `bspgraph` package.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细描述每个问题并列出其潜在的实际应用之后，我们将通过展示一个可以用来解决该问题的 *顺序* 算法来继续我们的讨论。随后，我们将提出相同算法的等效并行版本，并将其编码为一个可以与
    `bspgraph` 包一起使用的计算函数。
- en: Searching graphs for the shortest path
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图中搜索最短路径
- en: If we look around, we are bound to encounter a plethora of quite challenging
    problems that essentially boil down to finding a path or set of paths within a
    graph that minimize a particular cost function. Pathfinding has a multitude of
    real-world use cases, ranging from building efficient computer networks to logistics
    and even games!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们环顾四周，我们肯定会遇到许多相当具有挑战性的问题，这些问题本质上归结为在图中找到一个或一组路径以最小化特定的成本函数。路径查找有众多现实世界的应用案例，从构建高效的计算机网络到物流甚至游戏！
- en: The definition of a suitable cost function and its interpretation is typically
    application-specific.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 适合的成本函数的定义及其解释通常是特定于应用的。
- en: For instance, in the context of a map service, the cost associated with a graph
    edge could reflect the distance between two points or the time that's required
    to drive from one point to another due to traffic congestion. On the other hand,
    if we were talking about packet routing application, cost could represent the
    amount of money that the network operator would need to pay in order to use a
    peering connection with another provider.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在地图服务的背景下，图边相关的成本可能反映了两点之间的距离或由于交通拥堵而从一个点到另一个点驾驶所需的时间。另一方面，如果我们谈论数据包路由应用，成本可能代表网络运营商为了使用与其他提供商的互连而需要支付的费用。
- en: For simplicity, the sole focus of this section will be about finding the shortest
    paths within a graph. It goes without saying that the principles and algorithms
    we will be discussing can be applied, as-is, to any *type* of cost function as
    long as *lower* cost value for a graph edge indicates a *better* path through
    the graph.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，本节将仅关注在图中寻找最短路径。不言而喻，我们将讨论的原则和算法可以应用于任何*类型*的成本函数，只要图中边的*较低*成本值表示通过图的一条*更好*的路径。
- en: 'Depending on how we define the path origin and destination, we can classify
    shortest path queries into three general categories:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们如何定义路径的起点和终点，我们可以将最短路径查询分为三个一般类别：
- en: '**Point to point**: In a *point to point* search query, we are interested in
    locating the shortest path that connects *two points*. An interesting example
    of this type of search would be a real-time strategy game where the user selects
    a unit (the path origin) and subsequently clicks on the map location where they
    want the unit to move to (the path destination). The game engine searches for
    the shortest unobstructed path between the two points (typically by implementing
    an algorithm such as A* ^([5])) and navigates the unit along the path.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对点**：在一个*点对点*的搜索查询中，我们感兴趣的是找到连接两个点的最短路径。这类搜索的一个有趣例子是实时策略游戏，用户选择一个单位（路径起点）并随后点击地图上他们希望单位移动到的位置（路径终点）。游戏引擎在两点之间搜索最短的无障碍路径（通常通过实现如A*算法等算法）并沿着路径导航单位。'
- en: '**Point to multi-point**: A *point to multi-point* search query involves finding
    the shortest paths connecting a *single* graph vertex to *multiple* vertices.
    For example, a user of a map application might be interested in obtaining a list
    of coffee shops located within a particular radius from their current location
    sorted by distance. If we flip this query around, we can identify even more interesting
    use cases. For instance, a ride-hailing application is aware of both the users''
    and the drivers'' locations. A multi-point to point query would allow the application
    to dispatch the nearest driver to a user''s location and reduce the time-to-pickup.
    These types of queries can be efficiently answered using Dijkstra''s algorithm,
    one of the most widely-known graph algorithms.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点对多点**：一个*点对多点*的搜索查询涉及找到连接单个图顶点到多个顶点的最短路径。例如，地图应用的用户可能希望获得一个列表，列出位于他们当前位置特定半径内的咖啡店，并按距离排序。如果我们反转这个查询，我们可以识别出更多有趣的用例。例如，叫车应用了解用户和司机的位置。多点对点查询允许应用调度最近的司机到用户的位置，并减少接单时间。这些类型的查询可以使用迪杰斯特拉算法（Dijkstra''s
    algorithm）等最广为人知的图算法有效地回答。'
- en: '**Multi-point to multi-point**: The third, and most complicated, pathfinding
    query category consists of *multi-point to multi-point* queries where we are effectively
    seeking the shortest path from each vertex to *all* the other vertices in the
    graph. Arguably, we could answer this kind of query by running Dijkstra''s algorithm
    for each vertex in the graph at the cost of a much longer total runtime, especially
    if the graph contains a large number of vertices. A much better alternative performance-wise
    for answering such queries would be to use a dynamic programming algorithm such
    as Floyd-Warshall ^([3]).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多点到多点**：第三个，也是最复杂的路径查找查询类别包括*多点到多点*查询，其中我们实际上是在寻找从每个顶点到图中*所有*其他顶点的最短路径。可以说，我们可以通过在图中每个顶点上运行Dijkstra算法来回答这类查询，但这将付出更长的总运行时间，尤其是如果图中包含大量顶点。在性能方面，使用动态规划算法（如Floyd-Warshall
    ^([3]））来回答这类查询会是一个更好的替代方案。'
- en: Let's take a stab at implementing Dijkstra's algorithm using the graph processing
    framework that we developed in the first half of this chapter. While the original
    version of Dijkstra's algorithm was meant to find the shortest path between two
    points, the variant that we will be working with is designed to locate the *shortest
    path tree*, that is, the shortest path from a point to all the other points in
    the graph.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们在本章前半部分开发的图处理框架来实现Dijkstra算法。虽然Dijkstra算法的原始版本旨在找到两点之间的最短路径，但我们将要使用的是设计用来定位*最短路径树*的变体，即从一点到图中所有其他点的最短路径。
- en: The sequential Dijkstra algorithm
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序Dijkstra算法
- en: 'Before we adapt Dijkstra''s algorithm so that it works with our graph processing
    system, we need to have a clear idea of how the original algorithm works. The
    following snippet outlines an implementation of the sequential version of Dijkstra''s
    algorithm in pseudocode form:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将Dijkstra算法适配到我们的图处理系统之前，我们需要清楚地了解原始算法的工作原理。以下代码片段概述了顺序版本Dijkstra算法的伪代码实现：
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding implementation maintains two arrays, each one having a length
    equal to the number of vertices in the graph:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个实现维护了两个数组，每个数组的长度等于图中顶点的数量：
- en: The first array, `min_cost_via`, tracks the minimum cost (distance) for reaching
    the source vertex from the *i[th]* vertex in the graph.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个数组`min_cost_via`跟踪到达图中第*i*个顶点的源顶点的最小成本（距离）。
- en: The `prev` array keeps track of the previous vertex in the optimal path leading
    from the source vertex to the *i[th]* vertex.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prev`数组跟踪从源顶点到图中第*i*个顶点的最优路径中的前驱顶点。'
- en: At initialization time, we set all the entries in the `prev` array to `nil`.
    Additionally, all the entries in the `min_cost_via` array are initialized to a
    large number with the exception of the entry for the source vertex, whose entry
    is set to `0`. If we were implementing this algorithm in Go and path costs were
    `uint64` values, we would set the initial value to `math.MaxUint64`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时，我们将`prev`数组中的所有条目设置为`nil`。此外，`min_cost_via`数组中的所有条目都初始化为一个大数，除了源顶点的条目，其条目设置为`0`。如果我们用Go语言实现这个算法，并且路径成本是`uint64`值，我们会将初始值设置为`math.MaxUint64`。
- en: Dijkstra's algorithm is bootstrapped by placing all the graph vertices in a
    set called `Q`. The algorithm then executes a number of iterations equal to the
    number of vertices in the graph. At each iteration, we select vertex `u` from
    `Q` which has the *lowest* `min_cost_via` value and remove it from the set.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法通过将所有图顶点放入一个名为`Q`的集合中来进行初始化。然后，算法执行与图中顶点数量相等的迭代次数。在每次迭代中，我们从`Q`中选择具有*最低*`min_cost_via`值的顶点`u`，并将其从集合中移除。
- en: Then, the algorithm examines each neighbor `v` of the selected vertex `u`. If
    a lower cost path from `v` to the source vertex can be constructed by passing
    through `u`, then we update the `min_cost_via` entry for `v` and make `u` the
    predecessor of the optimal path to `v`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，算法检查所选顶点`u`的每个邻居`v`。如果可以通过`u`构建从`v`到源顶点的更低成本路径，则我们更新`v`的`min_cost_via`条目，并将`u`作为到达`v`的最优路径的前驱。
- en: The algorithm completes when all the vertices in set `Q` have been processed.
    The shortest path from the source vertex to any other vertex in the graph can
    be reconstructed by starting at the destination vertex and following the `prev`
    array entries until we reach the source vertex.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Q`集合中的所有顶点都被处理完毕时，算法完成。可以通过从目标顶点开始，并跟随`prev`数组条目直到我们到达源顶点，来重建从源顶点到图中任何其他顶点的最短路径。
- en: What's more, we can slightly tweak the preceding algorithm to obtain the original
    variant that answers point to point queries. All we need to do is terminate the
    algorithm after processing the destination vertex for our query. Those of you
    who are familiar with, or have implemented, the A* algorithm in the past will
    definitely notice a lot of similarities between the two algorithms. In fact, Dijkstra's
    algorithm is a special case of the A* algorithm where no distance heuristic is
    used.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们可以稍微调整前面的算法以获得原始的变体，该变体可以回答点对点查询。我们所需做的只是在我们查询的目标顶点处理完毕后终止算法。那些熟悉或过去实现过A*算法的人肯定会注意到这两个算法之间有很多相似之处。实际上，Dijkstra算法是没有使用距离启发式函数的A*算法的一个特例。
- en: Leveraging a gossip protocol to run Dijkstra in parallel
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Gossip协议并行运行Dijkstra算法
- en: Dijkstra's algorithm is fairly straightforward to implement and its runtime
    can be sped up considerably with the introduction of specialized data structures
    (for example, min-heap or Fibonacci heap) for selecting the next vertex for each
    iteration. Let's take a look at how we can leverage the graph processing system
    that we have built to execute Dijkstra's algorithm in parallel.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法的实现相当直接，并且可以通过引入用于选择每次迭代下一个顶点的专用数据结构（例如，最小堆或斐波那契堆）来显著加快其运行时间。让我们看看我们如何利用我们构建的图处理系统来并行执行Dijkstra算法。
- en: To break the sequential nature of the original algorithm, we will swap out the
    next vertex selection step and replace it with a *gossip protocol*. Whenever a
    vertex identifies a better path to it via another vertex, it will *broadcast*
    this information to all its neighbors by sending them a `PathCostMessage`. The
    neighbors would then process these messages during the *next* super-step, update
    their own min-distance estimates, and broadcast any better paths, if found, to
    their own neighbors. The key concept here is to trigger a wavefront of path updates
    throughout the graph that can be processed by each vertex in parallel.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打破原始算法的顺序性，我们将交换下一个顶点选择步骤，并用一个*Gossip协议*来替换它。每当顶点通过另一个顶点识别出一条更好的路径时，它将通过向它们发送`PathCostMessage`来将此信息*广播*给所有邻居。然后，邻居将在下一个超级步骤中处理这些消息，更新自己的最小距离估计，并在找到更好的路径时将其广播给自己的邻居。这里的关键概念是在整个图中触发路径更新的波前，每个顶点可以并行处理。
- en: 'The first thing we need to do is to define the types for the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为以下内容定义类型：
- en: The message that's exchanged by the vertices
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点之间交换的消息
- en: Storing the state for each vertex
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储每个顶点的状态
- en: 'Consider the following piece of code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `pathState` struct encodes the same kind information as the `min_cost_via`
    and `prev` arrays from the sequential version of the algorithm. The only difference
    is that each vertex maintains its own `pathState` instance, which is stored as
    the vertex value.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathState`结构体编码了与算法的顺序版本中的`min_cost_via`和`prev`数组相同的信息。唯一的区别是每个顶点维护自己的`pathState`实例，该实例作为顶点值存储。'
- en: 'Next, let''s try to put together a compute function for the graph. As you may
    recall from the previous sections, compute functions receive the following input
    arguments: a pointer to the graph, the currently processed vertex, and an iterator
    for the messages that are sent to the vertex during the previous super-step. At
    super-step *0*, each vertex initializes its own internal state with the maximum
    possible distance value:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试为图定义一个计算函数。如您从前面的章节中回忆的那样，计算函数接收以下输入参数：指向图的指针、当前处理的顶点以及在上一个超级步骤期间发送到顶点的消息迭代器。在超级步骤
    *0* 中，每个顶点使用最大可能距离值初始化其自身的内部状态：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, each vertex processes any path announcements from its neighbors and keeps
    track of the path announcement with the minimum cost:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个顶点处理其邻居的任何路径公告，并跟踪具有最低成本的路径公告：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After all the messages have been processed, we compare the cost of the best
    path from all the announcements to the cost of the best path we''ve seen so far
    by this vertex. If the vertex is already aware of a better path with a lower cost,
    we don''t really need to do anything. Otherwise, we update the local vertex state
    to reflect the new best path and send out a message to each of our neighbors:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有消息后，我们比较从所有公告中得出的最佳路径的成本与该顶点迄今为止看到的最佳路径的成本。如果顶点已经知道一条成本更低的更好路径，我们实际上不需要做任何事情。否则，我们将更新局部顶点状态以反映新的最佳路径，并向我们的每个邻居发送一条消息：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each outgoing `PathCostMessage` includes the cost of reaching each neighbor
    through the current vertex and is calculated by adding the cost for the next hop
    (the value associated with the outgoing edge) to the new minimum cost for reaching
    the current vertex.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输出的 `PathCostMessage` 包含通过当前顶点到达每个邻居的成本，并且通过将下一跳的成本（与输出边关联的值）添加到到达当前顶点的新最小成本来计算。
- en: Regardless of whether the best path to a vertex was updated or not, we always
    invoke the `Freeze` method on each vertex and mark it as processed. This means
    that the vertex will not be reactivated in a future super-step unless it receives
    a message from its neighbors. Eventually, all the vertices will figure out the
    optimal path to the source vertex and stop broadcasting cost updates to their
    neighbors. When this happens, all the vertices will end up in a frozen state and
    the algorithm will terminate.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 无论到顶点的最佳路径是否更新，我们都会在每一个顶点上调用 `Freeze` 方法，并将其标记为已处理。这意味着除非顶点从其邻居那里收到消息，否则顶点将在未来的超级步骤中不会被重新激活。最终，所有顶点都会找到到源顶点的最优路径，并停止向邻居广播成本更新。当这种情况发生时，所有顶点最终都会进入冻结状态，算法将终止。
- en: We could definitely argue that this particular approach requires much more effort
    compared to the traditional sequential version. However, contrary to the sequential
    version of the algorithm, the parallel version can run efficiently on massive
    graphs that can be potentially distributed across multiple compute nodes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以肯定地说，与传统的顺序版本相比，这种方法需要更多的努力。然而，与算法的顺序版本相反，并行版本可以在可以潜在地分布在多个计算节点上的大规模图上高效运行。
- en: The full source code and tests for the shortest path calculator from this section
    can be found in this book's GitHub repository in the `Chapter08/shortestpath`
    folder.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提到的最短路径计算器的完整源代码和测试可以在本书的 GitHub 仓库的 `Chapter08/shortestpath` 文件夹中找到。
- en: Graph coloring
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图着色
- en: 'The next graph-based problem that we will be trying to solve using our graph
    processing system is **graph coloring**. The idea behind graph coloring is to
    assign a color to each vertex in the graph so that no adjacent vertices have the
    same color. The following diagram illustrates an example graph whose vertices
    have been colored with the optimal (minimum possible) number of colors:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用我们的图处理系统解决的下一个基于图的问题是 **图着色**。图着色的思想是为图中的每个顶点分配一个颜色，使得相邻的顶点没有相同的颜色。以下图示了一个示例图，其顶点已经用最优（可能的最小）数量的颜色着色：
- en: '![](img/111cf89d-f996-467e-8f83-8016d6d5c74d.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/111cf89d-f996-467e-8f83-8016d6d5c74d.png)'
- en: 'Figure 3: A graph with optimal coloring'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3：具有最优着色的图
- en: 'Graph coloring has numerous real-world applications:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图着色有众多实际应用：
- en: It is frequently used by compilers to perform register allocation ^([2]).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它经常被编译器用于执行寄存器分配 ^([2])。
- en: Mobile operators use graph coloring as the means for solving the frequency assignment
    problem ^([9]) where the goal is to assign frequencies from a limited frequency
    pool to a set of communication links so that there is no interference between
    links in the same vicinity.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动运营商使用图着色作为解决频率分配问题的方法 ^([9])，其目标是将有限的频率池中的频率分配给一组通信链路，以避免同一区域内的链路之间产生干扰。
- en: Many popular puzzle games such as Sudoku can be modeled as a graph and solved
    with the help of a graph coloring variant where the allowed set of colors is fixed
    (k-color graph coloring).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多流行的谜题游戏，如数独，可以建模为图，并使用图着色变体来解决，其中允许的颜色集是固定的（k-着色图着色）。
- en: A sequential greedy algorithm for coloring undirected graphs
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于着色无向图的顺序贪婪算法
- en: 'Calculating the optimal graph coloring is known to be NP-hard. Therefore, researchers
    have proposed greedy algorithms that produce good enough, but not necessarily
    optimal, solutions. The sequential greedy algorithm listed here works with undirected
    graphs and guarantees an upper bound of *d+1* colors where *d* is the maximum
    out-degree (number of outgoing edges) for all the vertices in the graph:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 计算最优图着色已知是 NP-hard 的。因此，研究人员提出了贪婪算法，这些算法可以产生足够好但不一定是最优的解决方案。这里列出的顺序贪婪算法适用于无向图，并保证在图中所有顶点的最大出度（出边数）为
    *d* 的情况下，颜色数量不超过 *d+1*：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The algorithm maintains an array called `C` that holds the assigned color for
    each vertex in the graph. During initialization, we set each entry of the `C`
    array to the value *0* to indicate that no color has been assigned to any of the
    graph vertices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 算法维护一个名为 `C` 的数组，该数组保存图中每个顶点分配的颜色。在初始化期间，我们将 `C` 数组的每个条目设置为值 *0*，以表示尚未为图中的任何顶点分配颜色。
- en: For each vertex `u` in the graph, the algorithm iterates its neighbor list and
    inserts the colors that have been already assigned to each neighbor into a map
    using the color value as a key. Next, the `assigned_color` variable is set to
    the lowest possible color value (in this case, *1*) and the `already_in_use` map
    is consulted to check whether that color is currently in use. If that happens
    to be the case, we increment the `assigned_color` variable and repeat the same
    steps until we finally land on a color value that is not in use. The unused color
    value is assigned to vertex `u` and the process continues until all the vertices
    have been colored.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图中的每个顶点 `u`，算法迭代其邻居列表，并使用颜色值作为键将已分配给每个邻居的颜色插入到一个映射中。接下来，将 `assigned_color`
    变量设置为最低可能的颜色值（在这种情况下，*1*），并咨询 `already_in_use` 映射以检查该颜色是否当前正在使用。如果确实如此，我们增加 `assigned_color`
    变量并重复相同的步骤，直到最终找到一个未使用的颜色值。未使用的颜色值被分配给顶点 `u`，然后过程继续，直到所有顶点都被着色。
- en: 'An interesting fact about the preceding algorithm is that we can tweak it slightly
    to add support for handling pre-colored graphs. In this type of graph, a subset
    of the vertices have been already assigned a color value and the goal is to assign
    non-conflicting colors to the remaining vertices. All we need to do is the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面算法的一个有趣的事实是，我们可以稍作调整以添加对处理预着色图的支持。在这种类型的图中，顶点的一个子集已经被分配了颜色值，目标是给剩余的顶点分配非冲突的颜色。我们只需要做以下事情：
- en: Set `C[u]` to the already assigned color instead of *0* during initialization
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始化期间将 `C[u]` 设置为已分配的颜色而不是 *0*
- en: When iterating the graph vertices, skip the ones that have already been colored
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代图顶点时，跳过那些已经被着色的顶点
- en: Exploiting parallelism for undirected graph coloring
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用并行性进行无向图着色
- en: Parallel graph coloring algorithms are based on the observation that if we split
    the graph into multiple *independent sets of vertices*, we can color those in
    parallel without introducing any conflict.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 并行图着色算法基于观察，如果我们把图分成多个 *独立的顶点集*，我们可以在并行中着色它们而不会引入任何冲突。
- en: An independent set is defined as the collection or set of vertices where no
    two vertices share an edge.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 独立集被定义为顶点的集合，其中没有任何两个顶点共享边。
- en: To develop a parallelized version of the sequential greedy graph coloring algorithm
    from the previous section, we will be relying on a simple, yet effective algorithm
    proposed by Jones and Plassmann ^([6]). Before diving into the implementation
    details, let's take a few minutes to explain how the algorithm generates independent
    sets and how can we guarantee that our compute function will avoid data races
    while accessing the graph.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发从上一节中顺序贪婪图着色算法的并行化版本，我们将依赖于 Jones 和 Plassmann 提出的一种简单而有效的算法 ^([6])。在深入实现细节之前，让我们花几分钟时间解释该算法如何生成独立集，以及我们如何保证我们的计算函数在访问图时避免数据竞争。
- en: At initialization time, each vertex is assigned a random token. During each
    super-step, every vertex that hasn't been colored yet compares its own token value
    to the value of every *uncolored* neighbor. In the highly unlikely case that two
    neighboring vertices have been assigned the same random token, we can use the
    vertex ID as an extra comparison predicate to break the tie. The vertex with the
    highest token value gets to choose the next color using the same steps as the
    sequential algorithm while the neighboring vertices remain idle, waiting for their
    turn.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时间，每个顶点被分配一个随机令牌。在每次超级步骤中，每个尚未着色的顶点将其自己的令牌值与每个 *未着色* 邻居的值进行比较。在极不可能的情况下，两个相邻顶点被分配了相同的随机令牌，我们可以使用顶点
    ID 作为额外的比较谓词来打破平局。具有最高令牌值的顶点有权使用与顺序算法相同的步骤选择下一个颜色，而相邻顶点则保持空闲，等待他们的轮次。
- en: The concept of using tokens to enforce a coloring order guarantees that, at
    every super-step, we only color exactly one vertex from *each* independent set.
    At the same time, since connected vertices wait for their turn before they can
    pick a color, no data races can occur.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用令牌来强制着色顺序的概念保证了在每一个超级步骤中，我们只从每个**独立集**中着色一个顶点。同时，由于连接的顶点在它们可以挑选颜色之前需要等待它们的轮次，因此不会发生数据竞争。
- en: 'Just like we did with the shortest path implementation, we will begin by defining
    a type for holding the state of each vertex and a type that describes the messages
    that are exchanged between neighboring vertices:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在最短路径实现中所做的那样，我们首先定义一个类型来保存每个顶点的状态，以及一个描述相邻顶点之间交换的消息的类型：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `vertexState` struct keeps track of the token and colors that are assigned
    to the vertex. Furthermore, the `usedColors` map tracks colors that have already
    been assigned to the vertex neighbors. Vertices broadcast their state to each
    of their neighbors by exchanging `VertexStateMessage` instances. In addition to
    the token and color value, these messages also include a vertex ID. As we mentioned
    previously, the vertex ID is required for breaking ties while comparing token
    values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertexState` 结构体跟踪分配给顶点的令牌和颜色。此外，`usedColors` 映射跟踪已经分配给顶点邻居的颜色。顶点通过交换 `VertexStateMessage`
    实例向每个邻居广播其状态。除了令牌和颜色值之外，这些消息还包括一个顶点 ID。正如我们之前提到的，顶点 ID 在比较令牌值时用于打破平局。'
- en: 'Now, let''s break down the compute function for this algorithm into small chunks
    and examine each chunk in more detail:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个算法的 compute 函数分解成小块，并更详细地检查每个块：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First things first, each super-step iteration begins by marking *all* the vertices
    as inactive. This way, vertices will only be reactivated in subsequent super-steps
    when a neighbor gets to pick a color and broadcast its selection. Consequently,
    once the last remaining vertex has been colored, no further messages will be exchanged
    and all the vertices will be marked as inactive. This observation will serve as
    the termination condition for the algorithm.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个超级步骤迭代开始时，将所有顶点标记为非活动状态。这样，顶点只有在后续的超级步骤中，当一个邻居选择一个颜色并广播其选择时，才会被重新激活。因此，一旦最后一个剩余的顶点被着色，就不会再交换任何消息，所有顶点都将被标记为非活动状态。这个观察结果将作为算法的终止条件。
- en: 'Super-step *0* serves as an initialization step. During this step, we assign
    random tokens to all the vertices and have them *all* announce their initial state
    to their neighbors. If any of the vertices are pre-colored, their assigned colors
    will also be included in the broadcasted state update message. The `vertexState`
    type defines a handy helper method called `asMessage` which generates a `VertexStateMessage`,
    that can be sent to neighbors via the graph''s `BroadcastToNeighbors` method:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 超级步骤 *0* 作为初始化步骤。在这个步骤中，我们为所有顶点分配随机令牌，并让它们向邻居宣布它们的初始状态。如果任何顶点预先着色，它们分配的颜色也将包含在广播的状态更新消息中。`vertexState`
    类型定义了一个方便的辅助方法 `asMessage`，该方法生成一个 `VertexStateMessage`，可以通过图的 `BroadcastToNeighbors`
    方法发送给邻居：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Of course, the input graph may potentially include vertices with no neighbors.
    If these vertices have not been already pre-colored, we simply assign them the
    first available color, which in our particular implementation is color *1*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，输入图可能包含没有邻居的顶点。如果这些顶点尚未预先着色，我们只需将第一个可用的颜色分配给它们，在我们的特定实现中是颜色 *1*。
- en: 'The next block of code processes state announcements from the vertex neighbors.
    Before iterating each state message, each vertex sets its local `pickNextColor`
    variable to `true`. Then, the message list is iterated and the following occurs:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码处理来自顶点邻居的状态公告。在迭代每个状态消息之前，每个顶点将其本地的 `pickNextColor` 变量设置为 `true`。然后，迭代消息列表，发生以下情况：
- en: If a neighbor has been assigned a color, we insert it into the `usedColors`
    map for the local vertex.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个邻居已经被分配了颜色，我们将它插入到本地顶点的 `usedColors` 映射中。
- en: If any of the neighbors has a higher token value or has the *same* token value
    but their ID string value is greater than the local vertex one, they have a higher
    priority for picking the next color. Therefore, the `pickNextColor` variable will
    be set to `false` for the local vertex.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何邻居具有更高的令牌值，或者具有相同的令牌值但它们的 ID 字符串值大于本地顶点，它们在挑选下一个颜色时具有更高的优先级。因此，`pickNextColor`
    变量将被设置为 `false` 以供本地顶点使用。
- en: 'Once all state announcements have been processed, we check the value of the
    `pickNextColor` variable. If the vertex is not allowed to pick the next color,
    it simply broadcasts its current state and waits for the next super-step, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完所有状态公告，我们检查`pickNextColor`变量的值。如果顶点不允许选择下一个颜色，它只需广播其当前状态并等待下一个超级步骤，如下所示：
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Otherwise, the vertex gets to select the next color to be assigned to it:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，顶点可以选择分配给它的下一个颜色：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since some of the vertices in the graph might be pre-colored, our goal is to
    pick the *smallest* not used color for this vertex. To do this, we initialize
    a counter with the smallest allowed value and enter a loop: at each step, we check
    whether `usedColors` contains an entry for the `nextColor` value. If so, we increment
    the counter and try again. Otherwise, we assign `nextColor` to the vertex and
    broadcast our updated state to the neighbors.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图中的一些顶点可能已经被着色，我们的目标是选择这个顶点尚未使用的**最小**颜色。为此，我们用一个最小的允许值初始化一个计数器并进入循环：在每一步，我们检查`usedColors`是否包含`nextColor`值的条目。如果是这样，我们增加计数器并再次尝试。如果不是，我们将`nextColor`分配给顶点并将我们的更新状态广播给邻居。
- en: In case you are having concerns about the space requirements for keeping track
    of the used colors on a per-vertex basis, we can actually do much better if we
    don't need to support potentially pre-colored graphs. If that happens to be the
    case, each vertex only needs to keep track of the *maximum* color value that's
    assigned to its neighbors. At color selection time, the vertex picks `maxColor
    + 1` as its own color.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心跟踪每个顶点使用的颜色的空间需求，实际上如果我们不需要支持可能预先着色的图，我们可以做得更好。如果这种情况发生，每个顶点只需要跟踪分配给其邻居的最大颜色值。在颜色选择时间，顶点选择`maxColor
    + 1`作为自己的颜色。
- en: The full source code and tests for the graph coloring implementation from this
    section can be found in this book's GitHub repository in the `Chapter08/color`
    folder.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中图着色实现的完整源代码和测试可以在本书的GitHub仓库的`Chapter08/color`文件夹中找到。
- en: Calculating PageRank scores
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算PageRank分数
- en: Whenever someone hears the name Google, the first thing that would probably
    spring to mind is, of course, the widely popular search engine that made its appearance
    some time around 1997 and since then has consistently managed to eclipse all other
    competition in the search engine space.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有人听到Google这个名字，首先想到的肯定是，当然，那个在1997年左右出现并自那以后一直能够超越所有其他搜索引擎竞争的广受欢迎的搜索引擎。
- en: The heart of Google's search engine technology is undoubtedly the patented PageRank
    algorithm, which was published in the 1999 paper by the Google co-founders, Larry
    Page and Sergey Brin ^([8]). Fortunately, the patent to the algorithm expired
    in June 2019; that's a great piece of news as it allows us to freely implement
    it for the Links 'R' Us project!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Google搜索引擎技术的核心无疑是专利的PageRank算法，该算法由Google联合创始人拉里·佩奇和谢尔盖·布林在1999年的论文中发表^([8])。幸运的是，该算法的专利在2019年6月到期；这是一个非常好的消息，因为它允许我们为Links
    'R' Us项目自由实现它！
- en: The PageRank algorithm treats all indexed web pages as a massive, directed graph.
    Each page is represented as a vertex in the graph, while outgoing links from each
    page are represented as directed edges. All the pages in the graph are assigned
    what is referred to as a *PageRank score*. PageRank scores express the importance
    (ranking) of every page compared to all the other pages in the graph. The key
    premise of this algorithm is that if we were to sort the results of a keyword-based
    search by `both` keyword match relevance and by their PageRank score, we would
    be able to increase the quality of the results that are returned to the user performing
    the search.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank算法将所有索引的网页视为一个巨大的、有向图。每个页面在图中表示为一个顶点，而每个页面的出链表示为有向边。图中的所有页面都被分配了一个被称为**PageRank分数**的值。PageRank分数表达了每个页面相对于图中其他页面的重要性（排名）。这个算法的关键前提是，如果我们按照基于关键词的搜索结果的**关键词匹配相关性**和它们的PageRank分数进行排序，我们就能提高返回给执行搜索的用户的结果质量。
- en: In the following sections, we will explore the formula for calculating PageRank
    scores and implement our very own PageRank calculator using the graph processing
    framework that we developed at the beginning of this chapter.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将探讨计算PageRank分数的公式，并使用我们在本章开头开发的图处理框架实现我们自己的PageRank计算器。
- en: The model of the random surfer
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机游走模型
- en: 'To calculate the score for each vertex in the graph, the PageRank algorithm
    utilizes the model of the **random surfer**. Under this model, a user performs
    an initial search and lands on a page from the graph. From that point on, users
    randomly select one of the following two options:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算图中每个顶点的分数，PageRank 算法利用了 **随机游走者** 的模型。在这个模型下，用户进行一次初始搜索并从图中某个页面开始。从那时起，用户随机选择以下两种选项之一：
- en: They can click any outgoing link from the current page and navigate to a new
    page. Users choose this option with a predefined probability that we will be referring
    to with the term **damping factor**.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以点击当前页面上的任何出链并导航到新页面。用户选择这个选项的概率是预定义的，我们将用术语 **damping factor** 来指代。
- en: Alternatively, they can decide to run a new search query. This decision has
    the effect of *teleporting* the user to a random page in the graph.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，他们可以决定运行一个新的搜索查询。这个决定的效果是将用户 *teleporting* 到图中随机的一个页面。
- en: 'The PageRank algorithm works under the assumption that the preceding steps
    are repeated in perpetuity. As a result, the model is equivalent to performing
    a random walk of the web page graph. PageRank score values reflect the *probability*
    that a surfer lands on a particular page. By this definition, we expect the following
    to occur:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 算法在假设前述步骤无限重复的情况下工作。因此，该模型等同于执行网页图上的随机游走。PageRank 分数值反映了用户落在特定页面的 *probability*。根据这个定义，我们期望以下情况发生：
- en: Each PageRank score should be a value in the *[0, 1]* range
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 PageRank 分数应该是一个在 *[0, 1]* 范围内的值
- en: The sum of all assigned PageRank scores should be exactly equal to 1
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有分配的 PageRank 分数之和应正好等于 1
- en: An iterative approach to PageRank score calculation
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank 分数计算的迭代方法
- en: 'To estimate the PageRank score for web page *P* from the graph, we need to
    take two factors into account:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从图中估计网页 *P* 的 PageRank 分数，我们需要考虑两个因素：
- en: The number of links leading to *P*
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 *P* 的链接数量
- en: The quality of the pages linking to *P*, as indicated by their own individual
    PageRank scores
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 *P* 的页面的质量，如它们自己的 PageRank 分数所示
- en: If we only took the number of links into account, we would allow malicious users
    to game the system and artificially boost the score of a particular target page
    by creating a large number of links pointing at it. One way that this could be
    achieved would be, for instance, by cross-posting the same link to online forums.
    On the other hand, if we were to use the PageRank scores of the source pages to
    *weight* the incoming link contributions to the target page, pages with just a
    few incoming links from reputable sources (for example, major news outlets) would
    get a much better score than pages with a greater number of links but from sources
    that are not as popular.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只考虑链接数量，我们就会允许恶意用户通过创建指向特定目标页面的大量链接来操纵系统并人为地提高其分数。例如，可以通过在在线论坛上交叉发布相同的链接来实现这一点。另一方面，如果我们使用源页面的
    PageRank 分数来 *weight* 目标页面的入链贡献，那么只有少量来自信誉良好的来源（例如，主要新闻机构）的入链的页面会比链接数量更多但来源不那么流行的页面获得更好的分数。
- en: 'To figure out the score of a particular page, we need to be aware of the score
    of every page linking to it. To make matters even worse, pages might also link
    *back* to some or all pages that link to them. This sounds a bit like a chicken
    and egg problem! So, how does the calculation work? It turns out that we can actually
    calculate PageRank scores using an iterative algorithm that uses the following
    formula to calculate the PageRank score for page *P*:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定特定页面的分数，我们需要知道链接到它的每个页面的分数。更糟糕的是，页面也可能链接 *back* 到一些或所有链接到它们的页面。这听起来有点像“先有鸡还是先有蛋”的问题！所以，计算是如何工作的？实际上，我们可以使用一个迭代算法来计算
    PageRank 分数，该算法使用以下公式来计算页面 *P* 的 PageRank 分数：
- en: '![](img/02e1279c-48f0-482e-a68f-059961edf01f.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02e1279c-48f0-482e-a68f-059961edf01f.png)'
- en: 'At step *0*, all the vertices in the graph are assigned an initial PageRank
    score of *1/N*, where *N* is the number of vertices in the graph. For the *i[th]*
    step, we calculate the PageRank score by taking the weighted sum of two terms:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 *0* 中，图中所有顶点都被分配了一个初始的 PageRank 分数为 *1/N*，其中 *N* 是图中顶点的数量。对于 *第 i* 步，我们通过取两个项的加权总和来计算
    PageRank 分数：
- en: The first term encodes the PageRank score contribution from a random page in
    the graph due to a teleport operation. According to the random surfer model, users
    can decide to stop clicking outgoing links from the page they are currently visiting
    and instead run a new query which lands them on page *P*. This is equivalent to
    creating a *one-off* connection to *P.* As a result, it transfers *1/N* units
    of PageRank to *P*.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个项编码了由于跳转操作而从图中随机页面贡献的PageRank分数。根据随机漫游模型，用户可以决定停止点击当前访问页面的出站链接，而是运行一个新的查询，将他们带到页面
    *P*。这相当于创建了一个到 *P* 的 *一次性* 连接。因此，它将 *1/N* 单位的PageRank转移到 *P*。
- en: The second term encodes the score contributions for every page in the graph
    that has an outgoing link to *P*. In the preceding equation, *LT(P)* represents
    the set of pages that link to page *P*. For each page *J* in that set, we calculate
    the PageRank contribution to *P* by dividing its accumulated PageRank score from
    step *i-1* by the number of outgoing links. Essentially, at each step, each and
    every page *evenly distributes* its PageRank score to all outgoing links.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个项编码了图中每个有指向 *P* 的出站链接的页面的分数贡献。在先前的方程中，*LT(P)* 代表链接到页面 *P* 的页面集合。对于该集合中的每个页面
    *J*，我们通过将其在第 *i-1* 步积累的PageRank分数除以出站链接的数量来计算对 *P* 的PageRank贡献。本质上，在每一步，每个页面都会
    *均匀分配* 其PageRank分数到所有出站链接。
- en: Since the two terms refer to mutually exclusive events that occur with specific
    probabilities, we need to weigh each term by its respective probability to make
    sure that all PageRank scores add up to 1.0\. Given that users click outgoing
    links with a probability equal to the damping factor *d*, we need to multiply
    the first term by *1-d* and the second term by *d*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个项指的是具有特定概率发生的互斥事件，我们需要根据各自的概率权衡每个项，以确保所有PageRank分数加起来为1.0。鉴于用户以等于阻尼因子 *d*
    的概率点击出站链接，我们需要将第一个项乘以 *1-d*，将第二个项乘以 *d*。
- en: Reaching convergence – when should we stop iterating?
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 达到收敛 – 我们应该在何时停止迭代？
- en: 'By virtue of the fact that we are using an iterative formula to calculate PageRank
    scores, the more steps we execute, the more accurate results we will get. This
    raises an interesting question: how many steps do we need to execute so as to
    reach a desired level of accuracy for the calculated scores?'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用迭代公式来计算PageRank分数，我们执行的步骤越多，结果就越准确。这引发了一个有趣的问题：我们需要执行多少步骤才能达到计算分数所需达到的精度水平？
- en: 'To answer this question, we must come up with a suitable metric that will allow
    us to measure how close we are to reaching convergence. For this purpose, we will
    be calculating the **sum of absolute differences** (**SAD**) for PageRank scores
    between two subsequent iterations using the following formula:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们必须提出一个合适的指标，这将允许我们衡量我们距离达到收敛有多近。为此，我们将使用以下公式计算两次连续迭代之间PageRank分数的**绝对差之和**（**SAD**）：
- en: '![](img/5cccbc92-40e8-42c5-be1b-e9cdbfe37570.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5cccbc92-40e8-42c5-be1b-e9cdbfe37570.png)'
- en: The intuition behind this metric is that while the first few iterations will
    cause significant, in absolute terms, changes to the PageRank scores, as we get
    closer to convergence, the magnitude of each subsequent change will keep decreasing
    and become zero as the number of iterations reaches infinity. Obviously, for our
    particular use case, we need to execute a finite number of steps. Consequently,
    we have to decide on a suitable threshold value (for example, 10^(-3)) and keep
    iterating until the SAD score drops below the target threshold.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个度量背后的直觉是，虽然前几次迭代会在绝对意义上对PageRank分数造成重大变化，但随着我们接近收敛，每次后续变化的大小将不断减小，并在迭代次数达到无穷大时变为零。显然，对于我们的特定用例，我们需要执行有限数量的步骤。因此，我们必须决定一个合适的阈值值（例如，10^(-3)）并持续迭代，直到SAD分数低于目标阈值。
- en: Web graphs in the real world – dealing with dead ends
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现实世界中的Web图 – 处理死胡同
- en: The preceding formula for calculating PageRank scores assumes that all the pages
    link to at *least* one page. In real life, this is not always the case! Let's
    consider the graph shown in the following diagram. Here, all the vertices are
    connected to each other with the exception of vertex **D**, which has incoming
    links but no outgoing links. In other words, **D** is a dead end!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 计算PageRank分数的前一个公式假设所有页面都至少链接到一个页面。在现实生活中，这并不总是如此！让我们考虑以下图中所示的图。在这里，所有顶点都相互连接，除了顶点
    **D**，它有入站链接但没有出站链接。换句话说，**D** 是一个死胡同！
- en: '![](img/e434f76d-ba21-47d9-8c53-b2c0e9895099.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e434f76d-ba21-47d9-8c53-b2c0e9895099.png)'
- en: Figure 4: An example graph where vertex D is a dead end
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：一个顶点D是死胡同的示例图
- en: Would the presence of dead ends in the input graph cause problems with our PageRank
    score calculations? So far, we know that at each iteration of the PageRank algorithm,
    pages evenly distribute their currently accumulated PageRank score across all
    outgoing links. In the case of a dead-end scenario like the one shown in the preceding
    diagram, vertex **D** would keep receiving the PageRank scores from every other
    vertex in the graph but *never* distribute its own accumulated score since it
    has no outgoing links. Therefore, **D** will end up with a relatively high PageRank
    score while all the other vertices will end up with significantly lower scores.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 输入图中存在死胡同会导致我们的PageRank评分计算出现问题吗？到目前为止，我们知道在PageRank算法的每次迭代中，页面会将它们目前累积的PageRank评分平均分配给所有出站链接。在前面图表中所示的那种死胡同场景中，顶点**D**会持续从图中每个其他顶点接收PageRank评分，但由于它没有出站链接，所以**永远**不会分配它自己的累积评分。因此，**D**将最终获得相对较高的PageRank评分，而所有其他顶点将最终获得显著较低的评分。
- en: 'One strategy for mitigating this issue is to pre-process the graph, identify
    vertices that are dead ends, and exclude them from our PageRank calculations.
    However, dead-end elimination is far from a trivial task: the removal of an existing
    dead end might cause some of the vertices that used to link to it to transform
    into dead ends that also need to be removed and so on. As a result, implementing
    this solution and scaling it up to work with large graphs would be quite costly
    in terms of the required compute power.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解此问题的策略之一是在预处理图中，识别死胡同顶点，并将它们排除在我们的PageRank计算之外。然而，消除死胡同远非一项简单任务：移除现有的死胡同可能会使一些曾经链接到它的顶点变成也需要移除的死胡同，依此类推。因此，实现此解决方案并将其扩展到可以与大型图一起工作，在计算能力方面将相当昂贵。
- en: A much better alternative, and the one that we will be using for our Go implementation,
    would be to treat dead ends as having an implicit connection to *all* the other
    vertices in the graph. This approach mitigates the problem of skewed scores by
    distributing the accumulated PageRank scores from each dead end back to all the
    vertices in the graph.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的替代方案，也是我们将用于我们的Go实现的方法，是将死胡同视为与图中**所有**其他顶点有一个隐含的连接。这种方法通过将每个死胡同累积的PageRank评分重新分配回图中的所有顶点来减轻评分偏斜的问题。
- en: 'The naive approach for implementing this strategy using our graph processing
    system would be to have each dead-end node broadcast a message that would transfer
    a quantity equal to *PR/N* to every other vertex in the graph. Obviously, this
    idea would never scale for large graphs, so we need to come up with something
    better… What if, instead of following a push-based approach, we switched to a
    pull-based approach? In fact, this is actually a great use case for leveraging
    the graph processing system''s support for aggregators! Rather than have each
    vertex with no outgoing links distribute its PageRank to every other vertex in
    the graph by means of message broadcasting, they can simply add their per-node
    contribution (the *PR/N* quantity) into an accumulator. We can then extend the
    PageRank formula with an extra term to take this *residual* PageRank into account
    when performing our calculations:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的图处理系统实现此策略的简单方法是将每个死胡同节点广播一条消息，将等于*PR/N*的数量传递给图中的每个其他顶点。显然，这个想法对于大型图来说永远不会扩展，因此我们需要想出更好的方法……如果我们不遵循基于推送的方法，而是转向基于拉取的方法会怎样？事实上，这实际上是一个利用图处理系统对聚合器支持的绝佳用例！而不是让每个没有出站链接的顶点通过消息广播将它们的PageRank分配给图中的每个其他顶点，它们可以简单地将其每节点贡献（*PR/N*数量）添加到一个累加器中。然后我们可以通过添加一个额外的项来扩展PageRank公式，在执行计算时考虑这个*剩余*的PageRank：
- en: '![](img/3f1dfb27-419a-4447-8a36-ea62f87005c5.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f1dfb27-419a-4447-8a36-ea62f87005c5.png)'
- en: In the preceding formula, `ResPR(i)` returns the residual PageRank accumulated
    while executing the *i[th]* step. Given that we treat dead ends as having outgoing
    links to every other node in the graph and that surfers click outgoing links with
    a probability equal to the damping factor *d*, we need to multiply the residual
    PageRank by the damping factor. This yields the preceding equation, which will
    form the basis for our PageRank score calculator.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的公式中，`ResPR(i)`返回执行第*i*步时累积的残差PageRank。鉴于我们将死胡同视为指向图中每个其他节点的出链，并且冲浪者以等于阻尼因子*d*的概率点击出链，我们需要将残差PageRank乘以阻尼因子。这产生了先前的方程，它将成为我们PageRank评分计算器的基础。
- en: Defining an API for the PageRank calculator
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义PageRank计算器的API
- en: Now, let's discuss how we can implement a PageRank calculator on top of the
    functionality provided by the graph processing framework we have built. The full
    source code and tests for the PageRank calculator can be found in this book's
    GitHub repository in the `Chapter08/pagerank` folder.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何在我们构建的图处理框架功能之上实现PageRank计算器。PageRank计算器的完整源代码和测试可以在本书的GitHub仓库中找到，位于`Chapter08/pagerank`文件夹。
- en: 'The `Calculator` type is nothing more than a container for a `bspgraph.Graph`
    instance and a bunch of configuration options:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calculator`类型不过是一个`bspgraph.Graph`实例和一些配置选项的容器：'
- en: '[PRE51]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `executorFactory` points to the executor factory that will be used to create
    new `Executor` instances each time we want to execute the PageRank algorithm on
    a graph. By default, the `Calculator` constructor will use `bspgraph.NewExecutor`
    as the factory implementation, but users will be allowed to override it with a
    `SetExecutorFactory` helper method:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`executorFactory`指向将用于创建新`Executor`实例的执行器工厂。默认情况下，`Calculator`构造函数将使用`bspgraph.NewExecutor`作为工厂实现，但用户可以通过`SetExecutorFactory`辅助方法来覆盖它：'
- en: '[PRE52]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You might be curious why we allow the user to provide a custom factory for creating
    graph executors. The benefit of being able to specify a custom factory is that
    it permits us to intercept, inspect, and modify the `ExecutorCallbacks` object
    *before* it gets passed to the default factory. In [Chapter 12](67abdf43-7d4c-4bff-a17e-b23d0a900759.xhtml),
    *Building Distributed Graph Processing Systems*, we will be leveraging this functionality
    to build a distributed version of the PageRank calculator. We will do all of this
    *without changing a single line of code* in the calculator implementation... Sounds
    impossible? Keep reading and all will be revealed in due course!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能好奇为什么我们允许用户为创建图执行器提供自定义工厂。能够指定自定义工厂的好处是，它允许我们在将`ExecutorCallbacks`对象传递给默认工厂之前拦截、检查和修改它。在[第12章](67abdf43-7d4c-4bff-a17e-b23d0a900759.xhtml)《构建分布式图处理系统》中，我们将利用这一功能来构建PageRank计算器的分布式版本。我们将做到这一切，而无需在计算器实现中更改任何一行代码...听起来不可能？继续阅读，所有的一切都将逐步揭晓！
- en: 'The following is the definition of the `Config` type, which encapsulates all
    the required configuration options for executing the PageRank algorithm:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`Config`类型的定义，它封装了执行PageRank算法所需的所有配置选项：
- en: '[PRE53]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `validate` method, which is defined on the `Config` type, checks the validity
    of each configuration parameter and populates empty parameters with a sane default
    value:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Config`类型上定义的`validate`方法检查每个配置参数的有效性，并将空参数填充为合理的默认值：
- en: '[PRE54]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To create new `Calculator` instances, the clients populate a `Config` object
    that invokes the `NewCalculator` constructor:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的`Calculator`实例，客户端填充一个调用`NewCalculator`构造函数的`Config`对象：
- en: '[PRE55]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Before proceeding any further, the constructor has to validate the provided
    set of configuration options. After the configuration object has been successfully
    validated, the next step is to create a new `bspgraph.Graph` instance and store
    it in a newly allocated `Calculator` instance. To instantiate the graph, we need
    to provide a compute function that is parameterized by the provided `DampingFactor`
    value. This is achieved with the help of the `makeComputeFunc` helper, which closes
    over the `dampingFactor` argument and makes it accessible by the returned closure:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，构造函数必须验证提供的配置选项集。在配置对象成功验证后，下一步是创建一个新的`bspgraph.Graph`实例，并将其存储在分配的新`Calculator`实例中。要实例化图，我们需要提供一个计算函数，该函数由提供的`DampingFactor`值参数化。这是通过`makeComputeFunc`辅助函数实现的，它封装了`dampingFactor`参数，并通过返回的闭包使其可访问：
- en: '[PRE56]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Since the underlying `bspgraph.Graph` instance is encapsulated in the `Calculator`
    type, we also need to provide a set of convenience methods so that we can add
    vertices or edges to the graph and access the raw `bspgraph.Graph` instance:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层的 `bspgraph.Graph` 实例被封装在 `Calculator` 类型中，我们还需要提供一组便利方法，以便我们可以向图中添加顶点或边，并访问原始的
    `bspgraph.Graph` 实例：
- en: '[PRE57]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Of course, once the PageRank algorithm converges, users should be able to query
    the PageRank scores that have been assigned to each vertex in the graph. This
    is facilitated via a call to the `Scores` method. The method implementation invokes
    a user-defined visitor function for each vertex in the graph with the vertex ID
    and assigned PageRank score as arguments:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦 PageRank 算法收敛，用户应该能够查询分配给图中每个顶点的 PageRank 分数。这通过调用 `Scores` 方法来实现。该方法实现将用户定义的访问函数调用到图中的每个顶点，顶点
    ID 和分配的 PageRank 分数作为参数：
- en: '[PRE58]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After creating a new `Calculator` instance and specifying the graph layout
    via calls to `AddVertex` and `AddEdge`, we are ready to execute the PageRank algorithm.
    To do so, we need to obtain a `bspgraph.Executor` instance by invoking the calculator''s
    `Executor` method:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的 `Calculator` 实例并通过调用 `AddVertex` 和 `AddEdge` 指定图布局之后，我们就准备好执行 PageRank
    算法了。为此，我们需要通过调用计算器的 `Executor` 方法来获取 `bspgraph.Executor` 实例：
- en: '[PRE59]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The first task of the `Executor` method is to call the `registerAggregators`
    helper. This helper, whose implementation is outlined in the following code, is
    responsible for registering a set of aggregators that will be used by both the
    PageRank compute function and the executor callbacks that we will be defining
    next:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 方法的第一个任务是调用 `registerAggregators` 辅助函数。此辅助函数的实现概述在以下代码中，它负责注册一组将被
    PageRank 计算函数和我们将定义的执行器回调所使用的聚合器：'
- en: '[PRE60]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s take a closer look at the role of each of these aggregators:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些聚合器各自的作用：
- en: '`link_count` keeps track of the total number of vertices in the graph.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link_count` 跟踪图中顶点的总数。'
- en: '`residual_0` and `residual_1` accumulate the residual PageRank quantities for
    even and odd super-steps. In case you are wondering, the reason why we need two
    accumulators is that, while calculating the PageRank scores for the *i[th]* step,
    we need to add the residual PageRank from the *previous* step and at the same
    time accumulate the residual PageRank for the *next* step. While executing the
    i[th] step, the compute function will read from the accumulator at index `i%2`
    and write to the accumulator at index `(i+1)%2`.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`residual_0` 和 `residual_1` 累加偶数和奇数超步骤的残差 PageRank 数量。如果你想知道为什么我们需要两个累加器，那是因为，在计算第
    *i* 步的 PageRank 分数时，我们需要添加来自 *前一个* 步骤的残差 PageRank，同时还要累加下一个步骤的残差 PageRank。在执行第
    *i* 步时，计算函数将从索引 `i%2` 的累加器中读取，并将写入索引 `(i+1)%2` 的累加器。'
- en: '`SAD` is yet another accumulator that tracks the sum of absolute PageRank score
    differences between two sequential super-steps. The algorithm will keep executing
    while the accumulator''s value is greater than the `MinSADForConvergence` configuration
    option.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SAD` 是另一个跟踪两个连续超步骤之间绝对 PageRank 分数差异总和的累加器。算法将在累加器的值大于 `MinSADForConvergence`
    配置选项时继续执行。'
- en: The second responsibility of the `Executor` method is to define the appropriate
    set of callbacks for executing the PageRank algorithm and invoke the configured
    `ExecutorFactory` to obtain a new `bspgraph.Executor` instance, which is then
    returned to the caller.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor` 方法的第二个职责是定义执行 PageRank 算法所需的一组回调，并调用配置的 `ExecutorFactory` 以获取一个新的
    `bspgraph.Executor` 实例，然后将其返回给调用者。'
- en: 'The `PreStep` callback ensures that each of the required accumulators is set
    to a zero value prior to executing a new step. The handy `residualOutputAccName`
    helper function returns the name of the accumulator that will store the residual
    PageRank score to be used as input by the *next* super-step, as shown here:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreStep` 回调确保在执行新步骤之前，每个所需的累加器都被设置为零值。实用的 `residualOutputAccName` 辅助函数返回将存储用于下一个
    *超步骤* 输入的残差 PageRank 分数的累加器名称，如下所示：'
- en: '[PRE61]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Once the executor successfully runs the compute function for each vertex in
    the graph, it invokes the `PreStepKeepRunning` callback, whose purpose is to decide
    whether a new super-step needs to be executed. The registered callback looks up
    the `SAD` aggregator's value, compares it to the configured threshold, and terminates
    the algorithm's execution once the value becomes less than the threshold.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行器成功为图中每个顶点运行计算函数，它将调用`PreStepKeepRunning`回调，其目的是决定是否需要执行新的超级步骤。注册的回调查找`SAD`聚合器的值，将其与配置的阈值进行比较，一旦值小于阈值，就终止算法的执行。
- en: Implementing a compute function to calculate PageRank scores
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个计算函数以计算PageRank分数
- en: 'Now that we have completed our brief tour of the `Calculator` API, it''s time
    to shift our focus to the most important part of the implementation: the *compute
    function*.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要了解了`Calculator` API，是时候将我们的重点转移到实现的最重要部分：*计算函数*。
- en: 'At the end of each super-step, vertices are expected to evenly distribute their
    PageRank score to their neighbors. Under our graph processing model, this task
    is facilitated by broadcasting a message. The `IncomingScoreMessage` type describes
    the payload for the exchanged messages:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个超级步骤结束时，顶点预计将它们的PageRank分数均匀分布到它们的邻居。在我们的图处理模型中，这项任务通过广播一条消息来简化。`IncomingScoreMessage`类型描述了交换消息的有效负载：
- en: '[PRE62]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To bootstrap the calculator, we need to set the initial PageRank score for every
    vertex in the graph to the value *1/N*, where *N* is the number of vertices (pages)
    in the graph. An easy way to calculate *N* is to simply access the graph and count
    the number of vertices (for example, `len(g.Vertices())`). However, keep in mind
    that the end goal is to run the algorithm in a distributed fashion. In distributed
    mode, each worker node would only have access to a *subset* of the graph vertices.
    As a result, simply counting the vertices in the *local* graph instance would
    not produce a correct result.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动计算器，我们需要将图中每个顶点的初始PageRank分数设置为*1/N*，其中*N*是图中顶点（页面）的数量。计算*N*的一个简单方法是直接访问图并计算顶点的数量（例如，`len(g.Vertices())`）。然而，请记住，最终目标是以分布式方式运行算法。在分布式模式下，每个工作节点只能访问图顶点的*子集*。因此，简单地计算本地图实例中的顶点数量不会产生正确的结果。
- en: 'On the other hand, aggregators provide an elegant solution to our vertex counting
    problem that works for both single- and multi-node scenarios. Super-step *0* serves
    as our initialization step: every compute function invocation increments the value
    of the `page_count` aggregator. At the end of the super-step, the counter will
    contain the total number of vertices in the graph:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，聚合器为我们提供了一个优雅的解决方案，该解决方案适用于单节点和多节点场景。超级步骤*0*作为我们的初始化步骤：每次计算函数调用都会增加`page_count`聚合器的值。在超级步骤结束时，计数器将包含图中顶点的总数：
- en: '[PRE63]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For every other super-step, we apply the PageRank formula to estimate the new
    PageRank score for the current vertex:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个其他超级步骤，我们应用PageRank公式来估计当前顶点的新的PageRank分数：
- en: '[PRE64]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Before storing the new PageRank estimate for the current vertex, we calculate
    the absolute difference from the previous value and add it to the `SAD` aggregator,
    whose role is to track the *sum* of absolute score differences for the current
    super-step:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储当前顶点的新的PageRank估计之前，我们计算与上一个值的绝对差异并将其添加到`SAD`聚合器中，该聚合器的角色是跟踪当前超级步骤的绝对分数差异的总和：
- en: '[PRE65]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If the vertex has no neighbors (that is, it is a dead end), our model assumes
    that it is *implicitly* connected to every other node in the graph. To ensure
    that the PageRank score for the vertex is evenly distributed to every other vertex
    in the graph, we add a quantity equal to `newScore`/`pageCount` to the residual
    PageRank aggregator that will be used as input in the following super-step. Otherwise,
    we need to evenly distribute the calculated PageRank score to the existing vertex
    neighbors. To achieve this, we send out a series of `IncomingScore` messages that
    contribute a quantity equal to `newScore`/`numOutLinks` to every neighbor at the
    next super-step:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果顶点没有邻居（即，它是一个死胡同），我们的模型假设它*隐式地*连接到图中每个其他节点。为了确保顶点的PageRank分数均匀分布到图中每个其他顶点，我们在以下超级步骤中将用作输入的残差PageRank聚合器中添加一个等于`newScore`/`pageCount`的量。否则，我们需要将计算出的PageRank分数均匀分布到现有的顶点邻居。为了实现这一点，我们在下一个超级步骤向每个邻居发送一系列`IncomingScore`消息，这些消息贡献一个等于`newScore`/`numOutLinks`的量：
- en: '[PRE66]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: That's basically it! The graph processing system we have developed made it quite
    easy to construct a fully functioning and vertically scalable PageRank calculator
    that can properly handle dead ends. All that remains is to hook it up to the link
    graph and text indexer components that we created in [Chapter 6](ce489d62-aaa3-4fbb-b239-c9de3daa9a8f.xhtml),
    *Building a Persistence Layer*, and we are in business!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上就是这样！我们开发的图处理系统使得构建一个完全功能且垂直可扩展的PageRank计算器变得相当容易，它可以正确处理死胡同。剩下的只是将其连接到我们在[第
    6 章](ce489d62-aaa3-4fbb-b239-c9de3daa9a8f.xhtml)，*构建持久层*中创建的链接图和文本索引器组件，我们就可以开始工作了！
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter by presenting the BSP model for building systems that
    can support out-of-core processing for massive datasets. Then, we applied the
    key principles of the BSP model so that we could create our own graph processing
    system that can execute user-defined compute functions for every vertex in the
    graph in parallel while taking advantage of all the available CPU cores.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章开始时介绍了用于支持大规模数据集离核处理的BSP模型。然后，我们应用了BSP模型的关键原则，以便我们可以创建自己的图处理系统，该系统可以在并行执行的同时利用所有可用的CPU核心，为图中的每个顶点执行用户定义的计算函数。
- en: In the second half of this chapter, we explored a variety of graph-related problems
    and came up with parallel algorithms that can be efficiently executed against
    graphs of any size. In the last part of this chapter, we described the theory
    behind Google's PageRank algorithm and outlined the formulas for calculating PageRank
    scores in an iterative way. We leveraged the graph processing system to build
    a fully-fledged PageRank calculator that will form the basis for implementing
    the PageRank component for the Links 'R' Us project.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们探讨了各种与图相关的问题，并提出了可以高效执行任何大小图的并行算法。在本章的最后部分，我们描述了Google的PageRank算法背后的理论，并概述了以迭代方式计算PageRank分数的公式。我们利用图处理系统构建了一个完整的PageRank计算器，这将成为实现Links
    'R' Us项目的PageRank组件的基础。
- en: As we are getting closer and closer to completing the required components for
    our project, we need to plan ahead and design some APIs so that our components
    can exchange information between them. This is the main focus of the next chapter.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越接近完成项目所需的组件，我们需要提前规划并设计一些API，以便我们的组件之间可以交换信息。这是下一章的主要关注点。
- en: Further reading
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Apache Giraph: An iterative graph processing system built for high scalability.
    URL: [https://giraph.apache.org/](https://giraph.apache.org/).'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apache Giraph：一个为高可扩展性而构建的迭代图处理系统。URL：[https://giraph.apache.org/](https://giraph.apache.org/)。
- en: 'Chaitin, G. J.: *Register Allocation & Spilling via Graph Coloring.* In: Proceedings
    of the 1982 SIGPLAN Symposium on Compiler Construction, SIGPLAN ''82\. New York,
    NY, USA : ACM, 1982 — ISBN [0-89791-074-5](https://worldcat.org/isbn/0-89791-074-5),
    S. 98–105.'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Chaitin, G. J.: *通过图着色进行寄存器分配与溢出。* 发表于：1982年SIGPLAN编译器构造研讨会论文集，SIGPLAN ''82\.
    纽约，纽约，美国：ACM，1982 — ISBN [0-89791-074-5](https://worldcat.org/isbn/0-89791-074-5)，第
    98–105 页。'
- en: 'Floyd, Robert W.: *Algorithm 97: Shortest Path.* In: Commun. ACM Bd. 5\. New
    York, NY, USA, ACM (1962), Nr. 6, S. 345'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Floyd, Robert W.: *算法 97：最短路径。* 发表于：Commun. ACM Bd. 5\. 纽约，纽约，美国，ACM (1962),
    第 6 期, 第 345 页。'
- en: 'GPS: A graph processing system. URL: [http://infolab.stanford.edu/gps](http://infolab.stanford.edu/gps).'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPS：一个图处理系统。URL：[http://infolab.stanford.edu/gps](http://infolab.stanford.edu/gps)。
- en: 'Hart, P. E. ; Nilsson, N. J. ; Raphael, B.: *A Formal Basis for the Heuristic
    Determination of Minimum Cost Paths.* In: IEEE Transactions on Systems Science
    and Cybernetics Bd. 4 (1968), Nr. 2, S. 100–107.'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Hart, P. E. ; Nilsson, N. J. ; Raphael, B.: *《基于启发式确定最小成本路径的正式基础》.* 发表于：IEEE
    Transactions on Systems Science and Cybernetics Bd. 4 (1968), 第 2 期, 第 100–107
    页。'
- en: 'Jones, Mark T. ; Plassmann, Paul E.: *A Parallel Graph Coloring Heuristic.*
    In: SIAM J. Sci. Comput. Bd. 14\. Philadelphia, PA, USA, Society for Industrial;
    Applied Mathematics (1993), Nr. 3, S. 654–669.'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Jones, Mark T. ; Plassmann, Paul E.: *《并行图着色启发式算法》.* 发表于：SIAM J. Sci. Comput.
    Bd. 14\. 费城，宾夕法尼亚州，美国，工业与应用数学学会 (1993), 第 3 期, 第 654–669 页。'
- en: 'Malewicz, Grzegorz ; Austern, Matthew H. ; Bik, Aart J. C ; Dehnert, James
    C. ; Horn, Ilan ; Leiser, Naty ; Czajkowski, Grzegorz: Pregel: *A System for Large-scale
    Graph Processing.* In: Proceedings of the 2010 ACM SIGMOD International Conference
    on Management of Data, SIGMOD ''10\. New York, NY, USA : ACM, 2010 — ISBN [978-1-4503-0032-2](https://worldcat.org/isbn/978-1-4503-0032-2),
    S. 135–146.'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Malewicz, Grzegorz ; Austern, Matthew H. ; Bik, Aart J. C ; Dehnert, James
    C. ; Horn, Ilan ; Leiser, Naty ; Czajkowski, Grzegorz: Pregel: *一个用于大规模图处理的系统。*
    In: 2010年ACM SIGMOD国际数据管理会议论文集，SIGMOD ''10\. 纽约，NY，美国 : ACM，2010 — ISBN [978-1-4503-0032-2](https://worldcat.org/isbn/978-1-4503-0032-2),
    S. 135–146.'
- en: 'Page, Lawrence ; Brin, Sergey ; Motwani, Rajeev ; Winograd, Terry: *The PageRank
    Citation Ranking: Bringing Order to the Web.*(Technical Report Nr. 1999-66) :
    Stanford InfoLab; Stanford InfoLab, 1999\. – Previous number = SIDL-WP-1999-0120.'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Page, Lawrence ; Brin, Sergey ; Motwani, Rajeev ; Winograd, Terry: *《网页排序引文排名：为网络带来秩序》。*(技术报告
    No. 1999-66) : 斯坦福信息实验室; 斯坦福信息实验室，1999\. – 前一编号 = SIDL-WP-1999-0120.'
- en: 'Park, Taehoon ; Lee, Chae Y.: *Application of the graph coloring algorithm
    to the frequency assignment problem.* In: Journal of the Operations Research Society
    of Japan Bd. 39 (1996), Nr. 2, S. 258–265.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Park, Taehoon ; Lee, Chae Y.: *图着色算法在频率分配问题中的应用。* In: 日本运筹学协会杂志 Bd. 39 (1996),
    Nr. 2, S. 258–265.'
- en: 'Valiant, Leslie G.: *A Bridging Model for Parallel Computation.* In: Commun.
    ACM Bd. 33\. New York, NY, USA, ACM (1990), Nr. 8, S. 103–111.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Valiant, Leslie G.: *并行计算的桥梁模型。* In: ACM通讯 Bd. 33\. 纽约，NY，美国，ACM (1990), Nr.
    8, S. 103–111.'
