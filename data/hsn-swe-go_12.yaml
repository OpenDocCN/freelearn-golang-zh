- en: Communicating with the Outside World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与外部世界通信
- en: '"An API that isn''t comprehensible isn''t usable."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"一个不可理解的 API 是不可用的。"'
- en: '- James Gosling'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- James Gosling'
- en: All software systems eventually need to exchange data with the outside world.
    In many cases, this is achieved via an API. This chapter provides a comparison
    between the REST and RPC patterns for building APIs and discusses some common
    API issues such as authentication, versioning, and security. The rest of this
    chapter explores the gRPC ecosystem in depth and concludes with a gRPC-based API
    implementation for the Links 'R' Us project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件系统最终都需要与外部世界交换数据。在许多情况下，这是通过 API 实现的。本章提供了 REST 和 RPC 模式构建 API 的比较，并讨论了一些常见的
    API 问题，如身份验证、版本控制和安全性。本章的其余部分将深入探讨 gRPC 生态系统，并以 Links 'R' Us 项目的 gRPC 基础 API 实现作为结尾。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basic principles of RESTful APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API 的基本原理
- en: Strategies for securing APIs and pitfalls that you should avoid
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护 API 的策略和应避免的陷阱
- en: Approaches for API versioning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 版本化的方法
- en: gRPC as an alternative to building high-performance services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 作为构建高性能服务的替代方案
- en: Describing messages and RPC services using the protocol buffers definition language
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议缓冲定义语言描述消息和 RPC 服务
- en: The different RPC modes (unary, client, server-streaming, and bi-directional
    streaming)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的 RPC 模式（单一、客户端、服务器流和双向流）
- en: Locking down gRPC APIs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定 gRPC API
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The full code for the topics discussed that will be within this chapter have
    been published to this book's GitHub repository in the `Chapter09` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的主题的完整代码已发布到本书的 GitHub 仓库中的 `Chapter09` 文件夹。
- en: You can access this book's GitHub repository, which contains the code and all
    the required resources for each of this book's chapters, by pointing your web
    browser to the following URL: [https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang](https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将网络浏览器指向以下 URL 来访问本书的 GitHub 仓库，其中包含本书各章节的代码和所有必需的资源：[https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang](https://github.com/PacktPublishing/Hands-On-Software-Engineering-with-Golang)。
- en: 'To get you up and running as quickly as possible, each example project includes
    a Makefile that defines the following set of targets:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您尽快开始，每个示例项目都包含一个 Makefile，它定义了以下目标集：
- en: '| **Makefile target** | **Description** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **Makefile 目标** | **描述** |'
- en: '| deps | Install any required dependencies |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| deps | 安装所有必需的依赖项 |'
- en: '| test | Run all tests and report coverage |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| test | 运行所有测试并报告覆盖率 |'
- en: '| lint | Check for lint errors |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| lint | 检查 lint 错误 |'
- en: As with all the other chapters in this book, you will need a fairly recent version
    of Go, which you can download at [https://golang.org/dl](https://golang.org/dl).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他所有章节一样，您需要一个相当新的 Go 版本，您可以在 [https://golang.org/dl](https://golang.org/dl)
    下载。
- en: Designing robust, secure, and backward-compatible REST APIs
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计健壮、安全且向后兼容的 REST API
- en: Whenever an engineer hears the word API, **REST**, the acronym for **Representational
    State Transfer**, is undoubtedly one of the first words that springs to mind.
    Indeed, the vast majority of online services and applications that people use
    on a daily basis are using a REST API to communicate with the backend servers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每当工程师听到 API 一词时，**REST**（表示性状态转移的缩写）无疑是首先想到的词语之一。确实，人们日常使用的绝大多数在线服务和应用程序都是使用
    REST API 与后端服务器进行通信。
- en: 'The proliferation of what we commonly refer to as RESTful APIs is indeed not
    coincidental. REST, as an architectural style for building applications for the
    web, offers quite a few enticing advantages over alternatives such as the **Simple
    Object Access Protocol** (**SOAP**):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常所说的 RESTful API 的普及并非偶然。REST 作为一种用于构建 Web 应用的架构风格，相较于如 **简单对象访问协议**（**SOAP**）等替代方案，提供了许多诱人的优势：
- en: '**Ease of interaction**: A web browser or a command tool such as `curl` is
    all that is required to interact with REST endpoints'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互简便性**：只需一个网络浏览器或 `curl` 这样的命令行工具即可与 REST 端点进行交互'
- en: The majority of programming languages ship with built-in support for performing
    HTTP requests
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数编程语言都内置了对执行 HTTP 请求的支持
- en: It is quite easy to intercept HTTP requests (for example, via a proxy) and provided
    canned responses for testing purposes
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截 HTTP 请求（例如，通过代理）并提供用于测试的预定义响应非常容易
- en: By virtue of the fact that RESTful APIs are built on top of HTTP, clients (for
    example, web browsers) can opt to cache large HTTP GET responses locally, query
    the remote server to figure out whether the cached data has become stale, and
    needs to be refreshed
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于RESTful API建立在HTTP之上，客户端（例如，网页浏览器）可以选择在本地缓存大型HTTP GET响应，查询远程服务器以确定缓存的数据是否已过时，需要刷新。
- en: 'REST APIs are built around the concept of accessing and mutating resources.
    A resource represents any piece of application data (for example, a product, user,
    order, collection of documents, and so on) that clients can operate on. A typical
    RESTful API exposes a set of endpoints that allow clients to **create**, **read**,
    **update**, and **delete** (**CRUD**) resources of a particular type. Each one
    of these actions maps to an HTTP verb, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: REST API是围绕访问和修改资源的概念构建的。资源代表任何客户端可以操作的应用数据（例如，产品、用户、订单、文档集合等）。一个典型的RESTful
    API公开了一组端点，允许客户端**创建**、**读取**、**更新**和**删除**特定类型的资源。这些操作中的每一个都映射到一个HTTP动词，如下所示：
- en: A new resource can be created via a POST request
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过POST请求创建新资源
- en: Existing resources can be retrieved via a GET request
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过GET请求检索现有资源
- en: Resources can be fully or partially updated via a PUT or PATCH request
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过PUT或PATCH请求完全或部分更新资源
- en: A resource can be deleted via a DELETE request
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过DELETE请求删除资源
- en: While the REST architecture does not dictate the use of a particular data format
    for delivering data to clients, nowadays, JSON has become the de facto standard
    for implementing REST APIs. This can be largely attributed to the fact that it
    is lightweight, human-readable, and easy to compress. Having said that, you can
    still find several organizations out there (banks and payment processing gateways
    are a typical example) that provide RESTful APIs that expect and produce XML payloads.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REST架构没有规定用于向客户端交付数据的数据格式，但如今，JSON已成为实现REST API的事实标准。这主要归因于它轻量级、易于阅读和压缩。尽管如此，您仍然可以在一些组织中找到（例如银行和支付网关是典型例子）提供RESTful
    API的组织，这些API期望并生成XML有效负载。
- en: Using human-readable paths for RESTful resources
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用人类可读的路径为RESTful资源命名
- en: One of the key ideas, and something that clients would typically expect when
    dealing with a RESTful API, is that each resource instance can be individually
    addressed via a **Uniform Resource Identi****fier** (**URI**). Since the format
    of URIs plays a significant role in conveying the API's resource model to the
    clients that will be consuming it, software engineers should always strive to
    come up with consistent URI naming schemes when designing new APIs or introducing
    new resource types to existing APIs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个关键思想，并且是客户端在与RESTful API打交道时通常会期望的，是每个资源实例都可以通过**统一资源标识符**（**URI**）单独寻址。由于URI的格式在向将使用该API的客户端传达API的资源模型方面起着重要作用，因此软件工程师在设计新API或向现有API引入新资源类型时，应始终努力制定一致的URI命名方案。
- en: 'The following opinionated set of conventions for naming resources can help
    you design APIs that are easier for end users to understand and work with:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一组关于资源命名的有见地的约定，可以帮助您设计出对最终用户来说更容易理解和操作的API：
- en: Resource names must always be nouns and never verbs or verb-like expressions.
    Verbs can be used as suffixes to indicate an action to be performed on a particular
    resource. For example, `/basket/checkout` triggers the checkout flow for the current
    user's basket.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源名称必须始终是名词，而不是动词或动词类表达。动词可以用作后缀，以指示对特定资源要执行的操作。例如，`/basket/checkout`触发了当前用户购物车的结账流程。
- en: As an exception to the previously mentioned guideline, verbs related to CRUD
    operations should not be included as part of the resource URI; they can be inferred
    by the HTTP verb that's used when performing requests. In other words, instead
    of using a URI such as `/users/123/delete` to delete a user, clients should perform
    an HTTP **DELETE** request to `/users/123` instead.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为对之前提到的指南的例外，与CRUD操作相关的动词不应包含在资源URI中；它们可以通过执行请求时使用的HTTP动词推断出来。换句话说，与其使用如`/users/123/delete`这样的URI来删除用户，客户端应通过向`/users/123`发送HTTP
    **DELETE** 请求来代替。
- en: When referring to a specific resource instance by name, a singular noun must
    be used. For instance,` /user/account` returns the account details for the currently
    logged-on user. While it might be tempting to use the singular noun pattern to
    refer to a particular item within a collection (for example, `/user/123`), it
    is recommended to avoid this practice as it tends to create inconsistent paths
    for CRUD operations.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当通过名称指代特定资源实例时，必须使用单数名词。例如，`/user/account` 返回当前登录用户的账户详情。虽然使用单数名词模式来指代集合中的特定项（例如，`/user/123`）可能很有吸引力，但建议避免这种做法，因为它往往会为
    CRUD 操作创建不一致的路径。
- en: A plural noun must be used when referring to a collection of resources or a
    specific resource instance within a collection. For example, `order/123/items` would
    return the list of items in order with ID `123`, while `/users/789` would return
    information about the user with ID `789`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指代资源集合或集合中的特定资源实例时，必须使用复数名词。例如，`order/123/items` 会返回 ID 为 `123` 的订单中的项目列表，而
    `/users/789` 会返回 ID 为 `789` 的用户的信息。
- en: Avoid appending trailing forward slashes (/) to the end of URIs. Doing so does
    not provide any additional information to clients and could lead to confusion;
    that is, is the URI complete or does it lack a portion of its path?
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将尾部斜杠 (/) 添加到 URI 的末尾。这样做不会向客户端提供任何额外信息，并可能导致混淆；也就是说，该 URI 是完整的还是缺少其路径的一部分？
- en: RFC3986 ^([6]) defines URIs as being case-sensitive. Therefore, for consistency purposes,
    it's good practice to stick to lowercase characters for URI paths. What's more,
    the use of hyphens (-) to separate long path segments can oftentimes result in
    paths that are much easier to read. Arguably, `/archived-resource` is much easier
    to read than `/archivedresource`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC3986 ^([6]) 定义 URIs 为大小写敏感。因此，为了保持一致性，坚持使用小写字母作为 URI 路径是一个好习惯。更重要的是，使用连字符
    (-) 分隔长路径段往往可以使路径更容易阅读。可以说，`/archived-resource` 比较容易阅读，而 `/archivedresource` 则不然。
- en: 'The following table summarizes the combination of HTTP verbs and URI patterns
    for performing CRUD operations against a collection of products. The set of HTTP
    verbs and resource paths for working with a `products` resource are given as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了执行 CRUD 操作的 HTTP 动词和 URI 模式组合，针对产品集合。与 `products` 资源一起工作的 HTTP 动词和资源路径如下：
- en: '| **HTTP Verb** | **Path** | **Expects (JSON)** | **Returns (JSON)** | **HTTP
    Status** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **路径** | **期望 (JSON)** | **返回 (JSON)** | **HTTP 状态** | **描述**
    |'
- en: '| POST | `/products` | A product entry | The new product entry including its
    ID | 200 (success) or 201 (created) | Create a new product |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| POST | `/products` | 产品条目 | 包含其 ID 的新产品条目 | 200 (成功) 或 201 (已创建) | 创建新产品
    |'
- en: '| GET | `/products` | Nothing | An array with product entries | 200 (success)
    | Get a list of products |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| GET | `/products` | 无 | 包含产品条目的数组 | 200 (成功) | 获取产品列表 |'
- en: '| GET | `/products/:id` | Nothing | The product with the specified ID | 200
    (success) or 404 (not found) | Get product by ID |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| GET | `/products/:id` | 无 | 指定 ID 的产品 | 200 (成功) 或 404 (未找到) | 通过 ID 获取产品
    |'
- en: '| PUT | `/products/:id` | A product entry | The updated product entry | 200
    (success) or 404 (not found) | Update product by ID |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| PUT | `/products/:id` | 产品条目 | 更新的产品条目 | 200 (成功) 或 404 (未找到) | 通过 ID 更新产品
    |'
- en: '| PATCH | `/products/:id` | A partial product entry | The updated product entry
    | 200 (success) or 404 (not found) | Update individual fields for a product by
    ID |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | `/products/:id` | 部分产品条目 | 更新的产品条目 | 200 (成功) 或 404 (未找到) | 通过 ID
    更新产品单个字段 |'
- en: '| DELETE | `/products/:id` | Nothing | Nothing | 200 (success) or 404 (not
    found) | Delete product by ID |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | `/products/:id` | 无 | 无 | 200 (成功) 或 404 (未找到) | 通过 ID 删除产品 |'
- en: As you can probably surmise, the aforementioned patterns can also be applied
    to address resources that form hierarchies. For instance, to retrieve the set
    of permissions that have been assigned to the user with ID `123` within a security
    group with ID `789`, `/security-groups/789/users/123/permissions` can be used
    as a path. In this example, the use of a forward slash to separate the security
    group and user resources implies the existence of a hierarchical relationship
    between them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能推测的那样，上述模式也可以用于处理形成层次结构的资源。例如，要检索分配给 ID 为 `123` 的用户在 ID 为 `789` 的安全组中的权限集合，可以使用
    `/security-groups/789/users/123/permissions` 作为路径。在这个例子中，使用正斜杠分隔安全组和用户资源表明它们之间存在层次关系。
- en: Controlling access to API endpoints
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制对 API 端点的访问
- en: After defining the endpoints for referring to resources, the next logical step
    is to implement a mechanism for enforcing access control. For instance, while `/orders/123` and `orders/789` are
    both valid resource paths, they might belong to different users; obviously, we
    would expect that each user should only be able to access their own orders.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了用于引用资源的端点之后，下一步合乎逻辑的步骤是实现强制访问控制的机制。例如，虽然`/orders/123`和`orders/789`都是有效的资源路径，但它们可能属于不同的用户；显然，我们期望每个用户只能访问他们自己的订单。
- en: In a different scenario, a user might be able to list the users that belong
    to a particular security group by performing a GET request to `/security-groups/123/users`,
    but only an administrator would be allowed to add or remove users from that group
    (for example, by performing POST and DELETErequests to the same endpoint). A fairly
    common pattern for achieving this kind of granular access to resources is **Role-Based
    Access Control** (**RBAC**).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的场景中，用户可能能够通过向`/security-groups/123/users`执行GET请求来列出属于特定安全组的用户，但只有管理员才能添加或从该组中删除用户（例如，通过向同一端点执行POST和DELETE请求）。实现这种细粒度资源访问的相当常见模式是**基于角色的访问控制**（**RBAC**）。
- en: To apply this pattern, we need to define a list of roles (for example, normal
    user, administrator, and so on) and associate each role with a set of access permissions.
    Each user of the system is assigned to one or more roles that the system consults
    when considering whether it should grant access to a particular resource or not.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这个模式，我们需要定义一个角色列表（例如，普通用户、管理员等），并将每个角色与一组访问权限相关联。系统中的每个用户都被分配到一个或多个角色，系统在考虑是否应该授予特定资源的访问权限时会参考这些角色。
- en: Before we can go ahead and implement RBAC, we need to establish a mechanism
    for authenticating users prior to them attempting to access non-public API endpoints.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续实施RBAC之前，我们需要建立一个机制来在用户尝试访问非公开API端点之前进行用户认证。
- en: A lot of people tend to conflate the terms authentication and authorization when,
    in fact, they cannot be used interchangeably.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人倾向于混淆“认证”和“授权”这两个术语，实际上它们不能互换使用。
- en: 'To avoid any confusion, let''s spend a bit of time properly defining the two
    terms:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免任何混淆，让我们花点时间正确地定义这两个术语：
- en: '**Authentication**: This proves that a particular entity (for example, a client
    making API requests) is who they claim to be by providing some form of credential.
    This is akin to displaying your passport when going through security at an airport.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：这证明了特定实体（例如，发起API请求的客户端）通过提供某种形式的凭证来证明其身份。这就像在机场安检时出示护照一样。'
- en: '**Authorization**: This proves that an entity has a right to access a particular
    resource. For instance, a metro ticket grants you access to a train platform without
    you having to disclose your identity.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这证明了实体有权访问特定资源。例如，地铁票让你无需透露身份就能进入火车站台。'
- en: In the following two sections, we will be examining two popular approaches to
    handling authentication, namely, basic HTTP authentication over TLS and authorization to
    an external service provider via **OAuth2**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分中，我们将探讨两种处理认证的流行方法，即通过TLS进行的基本HTTP认证和通过**OAuth2**向外部服务提供商进行授权。
- en: Basic HTTP authentication
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本HTTP认证
- en: Basic HTTP authentication is probably the easiest and simplest way to implement
    an authentication layer for any API. Each client is provided either with a username
    and password tuple or with an API key. The latter approach is generally preferred
    as it allows application developers to generate multiple access keys that are
    tied to the same user account but can be independently managed, metered, and even
    revoked, should the need arise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基本HTTP认证可能是为任何API实现认证层最简单和最直接的方法。每个客户端都提供用户名和密码元组或API密钥。后者通常更受欢迎，因为它允许应用程序开发者生成多个与同一用户账户相关联的访问密钥，这些密钥可以独立管理、计量，甚至在需要时可以撤销。
- en: 'Whenever clients need to perform an authenticated API request, they have to
    encode their access credentials and attach them to the outgoing request by means
    of the standard HTTP authorization header. Clients construct the content of the
    header field in the following way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端需要执行认证的API请求时，他们必须对他们的访问凭证进行编码，并通过标准HTTP授权头将其附加到发出的请求中。客户端按照以下方式构建头字段的内容：
- en: Concatenate the username and password with a colon separator. So, if the username
    is `foo` and the password is `bar`, the concatenated result would be `foo:bar`.
    On the other hand, if the client is only provided with an API key, they need to
    use it as the username and concatenate it with a blank password. In other words,
    if the API key is `abcdefg`, then the concatenated result would be `abcdefg:`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用冒号分隔符连接用户名和密码。因此，如果用户名是`foo`，密码是`bar`，则连接的结果将是`foo:bar`。另一方面，如果客户端只提供了一个API密钥，他们需要将其用作用户名，并与一个空白密码连接。换句话说，如果API密钥是`abcdefg`，则连接的结果将是`abcdefg:`。
- en: The concatenated credentials are then base64-encoded. For the username and password
    scenario we mentioned previously, the encoded output for `foo:bar` becomes `Zm9vOmJhcg==`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接的凭据随后被base64编码。对于之前提到的用户名和密码场景，`foo:bar`的编码输出为`Zm9vOmJhcg==`。
- en: 'The authorization method (basic) followed by a space character is prepended to
    the encoded credentials to yield the final header value, that is, `Authorization:
    Basic Zm9vOmJhcg==`.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将授权方法（基本）后跟一个空格字符添加到编码凭据之前，以生成最终的标头值，即`Authorization: Basic Zm9vOmJhcg==`。'
- en: The obvious caveat of this approach is that the client's credentials are transmitted
    in plaintext over the wire. Therefore, in order to avoid credential leaks, API
    requests need to be transmitted over a secure channel. In principle, this is achieved
    by establishing a TLS session between the client and the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的明显缺点是客户端的凭据以明文形式通过网络传输。因此，为了避免凭据泄露，API请求需要通过安全通道传输。原则上，这是通过在客户端和服务器之间建立TLS会话来实现的。
- en: Securing TLS connections from eavesdropping
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护TLS连接免受窃听
- en: 'It is also important to note that while TLS sessions do offer a secure channel
    for exchanging data, TLS encryption is not a panacea; it is still possible for
    a malicious adversary to intercept and decode TLS traffic by using a proxy to
    perform a **man-in-the-middle** (**MITM**) attack:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，虽然TLS会话确实为数据交换提供了一个安全通道，但TLS加密并不是万能的；恶意对手仍然可以通过使用代理执行**中间人**（**MITM**）攻击来拦截和解码TLS流量：
- en: '![](img/77f12f87-d575-49a2-91a9-5766ec1b9f14.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77f12f87-d575-49a2-91a9-5766ec1b9f14.png)'
- en: Figure 1: Using a MITM attack to intercept TLS traffic
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：使用中间人攻击拦截TLS流量
- en: The preceding diagram illustrates a scenario where **Alice** uses her bank's
    application on her mobile phone to query the balance in her bank account. **Eve**
    is a malicious actor trying to intercept the API calls between the application
    running on **Alice's** phone and the bank backend servers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示说明了**爱丽丝**使用她的手机上的银行应用程序查询其银行账户余额的场景。**爱娃**是一个试图拦截运行在**爱丽丝**手机上的应用程序和银行后端服务器之间API调用的恶意行为者。
- en: To achieve this, **Eve** needs to install a MITM proxy that will intercept and
    record outgoing connection requests from **Alice's** phone and either proxy them
    to the intended server or return fake responses. However, as we mentioned previously,
    the bank's server uses TLS-based encryption, so the bank application will not
    complete the TLS handshake steps unless the server provides a valid TLS certificate
    for the bank's domain.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，**爱娃**需要安装一个中间人代理，该代理将拦截并记录从**爱丽丝**手机发出的连接请求，并将它们代理到目标服务器或返回虚假响应。然而，正如我们之前提到的，银行的服务器使用基于TLS的加密，因此银行应用程序不会完成TLS握手步骤，除非服务器为银行的域名提供了有效的TLS证书。
- en: In order for the MITM attack to succeed, the proxy server needs to be able to
    provide forged TLS certificates to Alice, which not only matches the bank's domain
    but is also signed by one of the globally trusted **Certificate Authorities**
    (**CAs**) that are preinstalled on **Alice's** phone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使中间人攻击成功，代理服务器需要能够向**爱丽丝**提供伪造的TLS证书，这些证书不仅与银行的域名匹配，而且是由预安装在**爱丽丝**手机上的全球受信任的**证书授权机构**（**CA**）之一签发的。
- en: Given that **Eve** does not have access to the private keys of any global CA,
    a prerequisite for forging certificates is for **Eve** to install a custom certificate
    authority on **Alice's** phone. This can be achieved either by exploiting a security
    hole via social engineering or simply by forcing **Alice** to do so if **Eve**
    happens to be a state actor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**爱娃**无法访问任何全球CA的私钥，伪造证书的前提是**爱娃**需要在**爱丽丝**的手机上安装一个自定义证书授权机构。这可以通过利用社会工程学中的安全漏洞或简单地强迫**爱丽丝**这样做来实现，如果**爱娃**是一个国家行为者的话。
- en: 'With **Eve''s** CA certificate in place, the interception process works as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在**爱娃**的CA证书就位的情况下，拦截过程如下：
- en: '**Alice** tries to connect to a website, for example, `https://www.bank.com`.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**爱丽丝**试图连接到一个网站，例如，`https://www.bank.com`。'
- en: '**Eve** intercepts the request and establishes a TCP socket with **Alice**.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伊芙**拦截请求并与**爱丽丝**建立TCP套接字。'
- en: '**Alice** initiates the TLS handshake. The handshake headers include a** Server
    Name Indication **(**SNI**) entry, which indicates the domain name it is trying
    to reach.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**爱丽丝**启动TLS握手。握手头包括一个**服务器名称指示**（**SNI**）条目，该条目指示它试图到达的域名。'
- en: Eve opens a connection to the real `https://www.bank.com` server and initiates
    a TLS handshake, making sure to pass the same SNI entry as **Alice**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伊芙**打开到真实`https://www.bank.com`服务器的连接，并启动TLS握手，确保传递与**爱丽丝**相同的SNI条目。'
- en: The bank server responds with its TLS certificate that also includes information
    about the server **Common Name** (**CN**), which in this case would normally be `www.bank.com` or `bank.com`.
    The certificate may also include a **Subject Alternative Name** (**SAN**) entry,
    which enumerates a list of additional domains that are also secured by the same
    certificate.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 银行服务器响应其TLS证书，该证书还包括有关服务器**通用名称**（**CN**）的信息，在这种情况下，通常会是`www.bank.com`或`bank.com`。证书还可能包括一个**主题备用名称**（**SAN**）条目，该条目列出了由同一证书保护的其他域名。
- en: '**Eve** forges a new TLS certificate that matches the information from the
    bank''s TLS certificate and signs it with the private keys that correspond to
    the custom CA cert installed on **Alice''s** phone. The forged certificate is
    returned to **Alice**.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伊芙**伪造一个新的TLS证书，该证书与银行的TLS证书中的信息相匹配，并使用安装在**爱丽丝**手机上的自定义CA证书的私钥进行签名。伪造的证书返回给**爱丽丝**。'
- en: '**Alice** successfully verifies the forged TLS certificate, that is, it has
    the correct SNI and its parent certificate chain can be fully traced back to a
    trusted root CA. At this point, **Alice** completes the TLS handshake and sends
    out an API request to the bank API, which includes her access credentials.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**爱丽丝**成功验证了伪造的TLS证书，即它具有正确的SNI，并且其父证书链可以完全追溯到受信任的根CA。此时，**爱丽丝**完成TLS握手，并向银行API发送API请求，其中包含她的访问凭证。'
- en: '**Alice''s** request is encrypted with the forged TLS certificate. **Eve** decrypts
    the request and makes a record of it. Acting as a proxy, she opens a connection
    to the real bank server and sends **Alice''s** request through.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**爱丽丝**的请求使用伪造的TLS证书进行加密。**伊芙**解密请求并记录下来。作为代理，她打开到真实银行服务器的连接，并将**爱丽丝**的请求发送过去。'
- en: '**Eve** records the response from the bank server and sends it back to **Alice**.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**伊芙**记录来自银行服务器的响应并将其发送回**爱丽丝**。'
- en: Now that we are fully aware of the extent of damage that can be potentially
    caused by MITM attacks, what steps can we actually take to make our APIs more
    resistant to attacks like this? One approach to mitigating the issue of forged
    TLS certificates is to employ a technique known as public key pinning.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完全了解中间人攻击可能造成的潜在损害程度，我们实际上可以采取哪些步骤来使我们的API更具抗攻击性？缓解伪造TLS证书问题的一种方法是通过使用称为公钥固定（public
    key pinning）的技术。
- en: Each time we release a new client for our application, we embed the fingerprint of
    the public key that corresponds to the TLS certificate that's used to secure the
    API gateway. After completing the TLS handshake, the client calculates the public
    key fingerprint for the certificates that are presented by the server and compares
    it to the embedded value. If a mismatch is detected, the client immediately aborts
    the connection attempt and notifies the user that a potential MITM attack might
    be in progress.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们为我们的应用程序发布新的客户端时，我们都会嵌入与用于保护API网关的TLS证书相对应的公钥指纹。完成TLS握手后，客户端计算由服务器提供的证书的公钥指纹，并将其与嵌入的值进行比较。如果检测到不匹配，客户端将立即终止连接尝试，并通知用户可能正在进行中间人攻击。
- en: Now, let's look at how we can implement public key pinning in our Go applications.
    The full source code for the following example is available in the `Chapter09/pincert/dialer` package of
    this book's GitHub repository. Go's `http.Transport` type is a low-level primitive
    that is used by `http.Client` to perform HTTP and HTTPS requests. When creating
    a new `http.Transport` instance, we can override its `DialTLS` field with a custom
    function that will be invoked each time a new TLS connection needs to be established.
    This sounds like the perfect spot to implement the public key fingerprint verification
    logic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在 Go 应用程序中实现公钥固定。以下示例的完整源代码可在本书 GitHub 存储库的 `Chapter09/pincert/dialer`
    包中找到。Go 的 `http.Transport` 类型是一个低级原语，由 `http.Client` 用于执行 HTTP 和 HTTPS 请求。在创建新的
    `http.Transport` 实例时，我们可以用自定义函数覆盖其 `DialTLS` 字段，该函数将在需要建立新的 TLS 连接时被调用。这似乎是实施公钥指纹验证逻辑的完美位置。
- en: 'The `WithPinnedCertVerification` helper, whose listing is shown in the following
    code, returns a dialer function that can be assigned to the `DialTLS` field of `http.Transport`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，`WithPinnedCertVerification` 辅助函数返回一个拨号器函数，该函数可以被分配给 `http.Transport`
    的 `DialTLS` 字段：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The returned dialer attempts to establish a TLS connection by invoking the `tls.Dial`
    function with the caller-provider network, destination address, and `tls.Config`
    parameters as arguments. Note that the `tls.Dial` call will also automatically
    handle the validation of the TLS certificate chain that''s presented by the remote
    server for us. After successfully establishing a TLS connection, the dialer delegates
    the verification of the pinned certificate to the `verifyPinnedCert` helper function,
    which is shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的拨号器通过调用 `tls.Dial` 函数并传入调用者提供的网络、目标地址和 `tls.Config` 参数作为参数来尝试建立 TLS 连接。请注意，`tls.Dial`
    调用还将自动为我们处理远程服务器提供的 TLS 证书链的验证。在成功建立 TLS 连接后，拨号器将验证固定证书的任务委托给 `verifyPinnedCert`
    辅助函数，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `verifyPinnedCert` implementation iterates the list of X509 certificates
    presented by the remote server and calculates the SHA256 hash for each certificate's
    public key. Each calculated fingerprint is then compared to the pinned certificate's
    fingerprint. If a match is found, then `verifyPinnedCert` returns without an error
    and the TLS connection can be safely used to make API calls. On the other hand,
    an error will be returned if no match was found. In the latter case, the dialer
    will terminate the connection and propagate the error back to the caller.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`verifyPinnedCert` 实现会遍历远程服务器提供的 X509 证书列表，并为每个证书的公钥计算 SHA256 哈希。然后，每个计算出的指纹与固定证书的指纹进行比较。如果找到匹配项，则
    `verifyPinnedCert` 无错误返回，并且可以安全地使用 TLS 连接进行 API 调用。另一方面，如果没有找到匹配项，将返回错误。在后一种情况下，拨号器将终止连接并将错误传播回调用者。'
- en: 'Using this dialer to improve the security of your API clients is quite easy.
    All you need to do is create your own `http.Client` instance, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此拨号器提高您的 API 客户端的安全性相当简单。您需要做的就是创建自己的 `http.Client` 实例，如下所示：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now use this client instance to perform HTTPS requests to your backend
    servers, just like you would normally do, but with the added benefit that your
    code can now detect MITM attack attempts. A complete end-to-end example of using
    this dialer to perform public key pinning can be found in the `Chapter09/pincert` package
    of this book's GitHub repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用此客户端实例执行 HTTPS 请求到您的后端服务器，就像您通常所做的那样，但增加了额外的优势，即您的代码现在可以检测到中间人攻击尝试。使用此拨号器执行公钥固定的一个完整端到端示例可以在本书
    GitHub 存储库的 `Chapter09/pincert` 包中找到。
- en: Authenticating to external service providers using OAuth2
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth2 认证到外部服务提供商
- en: OAuth is an open standard for authorization that was initially proposed as an
    alternative to the basic authentication pattern that we examined in the previous
    section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一个开放标准，用于授权，最初作为替代我们在上一节中检查的基本身份验证模式的提议。
- en: OAuth was designed to solve the following problem: let's assume that we have
    two services, A and B, which are typically unrelated to each other. As end users
    of service A, we wish to grant it access to some of our personal data that is
    hosted by service B. However, we want to avoid having to divulge our credentials
    so that we can access service B from service A.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth被设计用来解决以下问题：假设我们有两个服务，A和B，它们通常彼此无关。作为服务A的终端用户，我们希望授予它访问由服务B托管的一些个人数据的权限。然而，我们不想泄露我们的凭证，以便我们可以从服务A访问服务B。
- en: 'Common use cases for using OAuth are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OAuth的常见用例如下：
- en: Using a third-party service as a **single sign-on** (**SSO**) provider instead
    of creating individual accounts for each service we are interested in using. The
    login with *X* buttons that you commonly see when attempting to sign in to online
    services is a great example of this pattern. Furthermore, SSO providers often
    provide a dashboard where users can examine the list of services that they have
    granted access to and revoke their access at any point in time.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方服务作为**单点登录（SSO**）提供商，而不是为每个我们感兴趣使用的服务创建单独的账户。当你尝试登录在线服务时，常见的带有*X*按钮的登录方式就是这种模式的例子。此外，SSO提供商通常提供一个仪表板，用户可以检查他们已授予访问权限的服务列表，并在任何时间点撤销他们的访问权限。
- en: Allowing a service to use another service's API on behalf of a particular user.
    For instance, a user can log in to a **Continuous Integration** (**CI**) service
    with their GitHub account and allow the CI service to use GitHub's API to query
    the user's repositories or to set up webhooks that will trigger CI runs when a
    pull request is created.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许一个服务代表特定用户使用另一个服务的API。例如，用户可以使用GitHub账户登录到**持续集成（CI**）服务，并允许CI服务使用GitHub的API查询用户的仓库或设置webhooks，当创建pull请求时触发CI运行。
- en: So, how does this work under the hood and how can we integrate the OAuth framework
    into our Go applications? For the remainder of this section, we will be focusing
    on the three-legged OAuth2 flow, which can facilitate data exchange between applications
    without sharing user credentials.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在底层它是如何工作的，我们如何将OAuth框架集成到我们的Go应用程序中呢？在本节的剩余部分，我们将重点关注三腿OAuth2流程，它可以促进应用程序之间在无需共享用户凭证的情况下进行数据交换。
- en: 'The three-legged OAuth2 flow involves the following four parties:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 三腿OAuth2流程涉及以下四个方面：
- en: '**The Resource Owner**: This is the user who wants to give access to their
    data that''s hosted by service B to service A without sharing their credentials.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：这是想要将托管在服务B上的数据访问权限授予服务A的用户，而不共享他们的凭证。'
- en: '**The OAuth client**: In our scenario, service A wants to leverage an API offered
    by service B to obtain the user''s data or to execute some action on behalf of
    the user.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth客户端**：在我们的场景中，服务A想要利用服务B提供的API来获取用户数据或代表用户执行某些操作。'
- en: '**The Resource Server**: In our scenario, service B hosts the user data that
    service A attempts to access.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源服务器**：在我们的场景中，服务B托管了服务A试图访问的用户数据。'
- en: '**The Authorization Server**: This is a part of service B and acts as the key
    component in this particular OAuth flow. It generates the appropriate set of access
    tokens that allow service A to access a specific subset of the user data hosted
    by service B.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这是服务B的一部分，并作为此特定OAuth流程中的关键组件。它生成适当的访问令牌集，允许服务A访问服务B托管的特定子集的用户数据。'
- en: 'The following diagram illustrates the three-legged OAuth2 flow:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了三腿OAuth2流程：
- en: '![](img/40e0989f-d149-4afa-bcfb-41183ec7c649.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40e0989f-d149-4afa-bcfb-41183ec7c649.png)'
- en: Figure 2: The steps in the three-legged OAuth2 flow
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：三腿OAuth2流程的步骤
- en: In order for service A to be able to trigger the three-legged OAuth2 flow, it
    needs to be registered with the authorization server for service B. Upon registering,
    service A will be assigned a unique client ID and client secret token. The client
    ID is a public token that allows the authorization server to identify the application
    that requires access. On the other hand, the client secret is private and is used
    to authenticate the OAuth client whenever it needs to contact the authorization
    server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务A能够触发三腿OAuth2流程，它需要在服务B的授权服务器上进行注册。注册后，服务A将被分配一个唯一的客户端ID和客户端密钥令牌。客户端ID是一个公共令牌，允许授权服务器识别需要访问的应用程序。另一方面，客户端密钥是私有的，并在OAuth客户端需要联系授权服务器时用于验证OAuth客户端。
- en: 'Let''s examine what happens during the three-legged OAuth2 flow:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看三腿OAuth2流程中发生了什么：
- en: The user visits the website for service A and clicks the login with the B button.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问服务A的网站并点击“使用B登录”按钮。
- en: 'The backend server for service A is configured with the API endpoints of the
    authorization server for service B. It returns an authorization URL to the user
    that embeds the following pieces of information:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务A的后端服务器配置了服务B的授权服务器的API端点。它向用户返回一个包含以下信息的授权URL：
- en: The client ID token that is used by the authorization server to identify the
    service requesting access
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器用于识别请求访问的服务客户端ID令牌
- en: A set of granular access permissions (grants) to be granted to service A
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要授予服务A的一组细粒度访问权限（授权）
- en: A URL hosted by service A, which the user will be redirected to by the authorization
    server once they consent to give access
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由服务A托管并将在用户同意提供访问权限后由授权服务器重定向到该URL的URL
- en: A nonce value, which is to be used as a unique identifier for the authorization
    request
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个nonce值，它将用作授权请求的唯一标识符
- en: The user visits the authorization URL using their web browser.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户使用他们的网络浏览器访问授权URL。
- en: The authorization server renders a consent page providing details (name, author,
    and so on) about the application that requires access to the user's data, as well
    as a description for the types of grants that can be requested.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器渲染一个同意页面，提供有关需要访问用户数据的应用程序的详细信息（名称、作者等），以及可以请求的授权类型的描述。
- en: 'An example of a consent page for authorizing access to a user''s GitHub account
    can be seen in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了授权访问用户GitHub账户的示例同意页面：
- en: '![](img/b75ddae0-8177-4df1-9195-effaa6cf2798.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b75ddae0-8177-4df1-9195-effaa6cf2798.png)'
- en: Figure 3: An example consent page for granting access to a user's GitHub account
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：授予访问用户GitHub账户的示例同意页面
- en: Once the user reviews and authorizes the list of permissions that have been
    requested by service A and authorizes them, their web browser will be redirected
    to the URL included in the authorization request URL that was generated in *step
    2*. The authorization server appends two additional values to that URL – the nonce
    value from the authorization request and an access code.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户审查并授权服务A请求的权限列表并授权它们，他们的网络浏览器将被重定向到在步骤2中生成的授权请求URL中包含的URL。授权服务器向该URL附加两个额外的值——授权请求中的nonce值和访问代码。
- en: After receiving the access code and matching the incoming nonce value to the
    one included in the authorization request, the OAuth client contacts the server
    and attempts to exchange the obtained access co de with an access token.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在收到访问代码并将传入的nonce值与授权请求中包含的值匹配后，OAuth客户端联系服务器并尝试用获得的访问代码交换访问令牌。
- en: 'The authorization server returns two tokens: a short-lived access token that
    can be used to access data on the resource server and a long-lived refresh token that
    the OAuth client can use to refresh expired access tokens.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器返回两个令牌：一个短期的访问令牌，可用于访问资源服务器上的数据，以及一个长期的刷新令牌，OAuth客户端可以使用它来刷新过期的访问令牌。
- en: The OAuth client contacts the resource server and obtains the required data
    using the access token.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth客户端联系资源服务器并使用访问令牌获取所需数据。
- en: 'In a similar fashion to the basic authentication mechanism we discussed previously,
    all outgoing requests to the resource server include an HTTP authorization header
    that the client populates with the obtained access token. The only difference
    is that instead of specifying a basic authorization method, this time, the client
    specifies `bearer` as the authorization method, that is, the transmitted header
    looks like `Authorization: Bearer ACCESS_TOKEN`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '与我们之前讨论的基本认证机制类似，所有发送到资源服务器的请求都包含一个HTTP授权头，客户端用获得的访问令牌填充该头。唯一的区别是，这次客户端指定`bearer`作为授权方法，即传输的头部看起来像`Authorization:
    Bearer ACCESS_TOKEN`。'
- en: 'Fortunately, most of the plumbing that''s needed for implementing the three-legged
    OAuth flow in our applications is already provided by the `golang.org/x/oauth2` package.
    All we need to do is implement the redirect handling logic we described in *step
    5*. Let''s begin by creating a new type called `Flow` to encapsulate the logic
    for our OAuth implementation. The `type` definition lives in the `Chapter09/oauthflow/auth` package
    and contains the following set of fields:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们应用中实现三脚OAuth流程所需的大部分管道代码已经由`golang.org/x/oauth2`包提供。我们所需做的只是实现我们在第5步中描述的重定向处理逻辑。让我们首先创建一个名为`Flow`的新类型来封装我们的OAuth实现逻辑。`type`定义位于`Chapter09/oauthflow/auth`包中，并包含以下一系列字段：
- en: '[PRE3]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `cfg` field holds a `oauth2.Config` value, which describes the OAuth provider''s
    endpoints for:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`cfg`字段持有`oauth2.Config`值，它描述了OAuth提供者的端点：'
- en: Authorizing requests
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权请求
- en: Obtaining access tokens
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取访问令牌
- en: Refreshing access tokens when they expire
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问令牌过期时刷新访问令牌
- en: The `srvListener` field stores the `net.Listener` instance, which is where our
    implementation will listen for incoming OAuth redirects, while the `pendingRequests
    map` keeps track of all authorization attempts that are currently in flight. A
    `sync.Mutex` guards the access to both these variables and ensures that our implementation
    is safe for concurrent use.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`srvListener`字段存储了`net.Listener`实例，这是我们实现将监听OAuth重定向的地址，而`pendingRequests`映射跟踪所有当前正在进行的授权尝试。一个`sync.Mutex`保护对这两个变量的访问，并确保我们的实现是线程安全的。'
- en: 'To work with our package, users must create a new `Flow` instance by invoking
    the `NewOAuthFlow` constructor, whose implementation is shown in the following
    code snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的包，用户必须通过调用`NewOAuthFlow`构造函数来创建一个新的`Flow`实例，其实现如下代码片段所示：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The constructor expects three arguments:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数期望三个参数：
- en: An `oauth2.Config` instance for the provider that the user wishes to authenticate
    against.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户希望对其进行身份验证的提供者的`oauth2.Config`实例。
- en: A local address so that it can listen for incoming redirect requests. If not
    specified, the implementation will bind to the default address, `127.0.0.1:8080`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个本地地址，以便它可以监听传入的重定向请求。如果没有指定，实现将绑定到默认地址，`127.0.0.1:8080`。
- en: A redirect URL that is sent to the remote server as part of the three-legged
    OAuth flow. If not specified, the implementation will use the address that the
    listener has bound to.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作为三脚OAuth流程一部分发送到远程服务器的重定向URL。如果没有指定，实现将使用监听器绑定的地址。
- en: You might be wondering why users need to specify both the listen address and
    the redirect URL. When we are testing our application locally, these two values
    will always be the same. In fact, we can leave both parameters blank and our application
    will work just fine with the default values!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么用户需要指定监听地址和重定向URL。当我们在本地上测试我们的应用程序时，这两个值始终相同。事实上，我们可以将这两个参数都留空，我们的应用程序将使用默认值正常工作！
- en: In this scenario, once we log in to the remote service, the OAuth server will
    redirect our browser to a loopback address that the browser can successfully connect
    to, given that it executes on the same machine as our OAuth redirect listener.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，一旦我们登录到远程服务，OAuth服务器将重定向我们的浏览器到一个回环地址，只要它运行在与我们的OAuth重定向监听器相同的机器上，浏览器就可以成功连接。
- en: In a production deployment, our code would run on an isolated virtual machine
    hosted by a cloud provider. While our OAuth-handling code would still be listening
    to a loopback address, the users' browsers would only be able to connect to it
    through a load balancer with a public IP address. In such a case, the only way
    to make the three-legged OAuth flow work correctly is to provide a redirect URL
    whose DNS record resolves to the IP of the external load balancer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产部署中，我们的代码将在由云提供商托管的独立虚拟机上运行。虽然我们的OAuth处理代码仍然会监听回环地址，但用户的浏览器只能通过具有公共IP地址的负载均衡器连接到它。在这种情况下，使三脚OAuth流程正确工作的唯一方法是提供一个重定向URL，其DNS记录解析为外部负载均衡器的IP地址。
- en: Going back to the constructor implementation, the first thing that we need to
    do is bind a new `net.Listener` to the requested address and populate the value
    of the `redirectHost` parameter (if it's not been specified). Next, we overwrite
    the `RedirectURL` field of the user-provided OAuth configuration object with a
    URL that is generated by concatenating the value of the `redirectHost` parameter
    with a known static path (in this example, `/oauth/redirect`). Before returning
    the newly allocated `Flow` instance, the code spawns a go-routine and starts an
    HTTP server for processing incoming redirects from the remote authorization server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回到构造函数实现，我们首先需要做的是将一个新的 `net.Listener` 绑定到请求的地址，并填充 `redirectHost` 参数的值（如果尚未指定）。接下来，我们覆盖用户提供的
    OAuth 配置对象的 `RedirectURL` 字段，将其替换为通过连接 `redirectHost` 参数值和一个已知的静态路径（在这个例子中是 `/oauth/redirect`）生成的
    URL。在返回新分配的 `Flow` 实例之前，代码启动一个 go-routine 并启动一个 HTTP 服务器，用于处理来自远程授权服务器的传入重定向。
- en: 'After obtaining a new `Flow` instance, users can trigger a three-legged OAuth
    flow by invoking its `Authenticate` method, whose source is displayed in the following
    code snippet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 获得一个新的 `Flow` 实例后，用户可以通过调用其 `Authenticate` 方法来触发一个三脚 OAuth 流程，其源代码如下所示：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding code snippet, to distinguish between concurrent authentication
    requests, the `Authenticate` method generates a unique nonce value and associates
    it with every pending request. The generated nonce is then passed to the OAuth
    configuration's `AuthCodeURL` method to generate an authorization URL (pointing
    at the remote service) where the end user can log in using their web browser and
    consent to the grants that have been requested by our application.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，为了区分并发认证请求，`Authenticate` 方法生成一个唯一的 nonce 值，并将其与每个挂起的请求关联起来。然后，生成的
    nonce 被传递到 OAuth 配置的 `AuthCodeURL` 方法，以生成一个授权 URL（指向远程服务），在那里最终用户可以使用他们的网络浏览器登录并同意我们应用程序请求的授权。
- en: The remaining steps of the OAuth flow happen asynchronously. To this end, the
    code allocates a buffered `Result` channel, appends it to the `pendingRequests` map
    while using the generated nonce as a key, and returns both the authorization URL
    and the result channel to the caller. The application must then redirect the end
    user's browser to the generated URL and block until a `Result` instance can be
    read off the returned channel.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 流程的剩余步骤是异步进行的。为此，代码分配了一个缓冲的 `Result` 通道，将其追加到 `pendingRequests` 映射中，同时使用生成的
    nonce 作为键，并将授权 URL 和结果通道返回给调用者。然后，应用程序必须将最终用户的浏览器重定向到生成的 URL，并阻塞，直到可以从返回的通道中读取到
    `Result` 实例。
- en: 'The `Result` type encapsulates the result of an authorization attempt and is
    defined as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 类型封装了授权尝试的结果，并定义如下：'
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once the user completes the authorization process, the remote OAuth server will
    redirect their browser to the HTTP server that we launched in the `Flow` type's
    constructor. Next, we will examine the implementation of the `handleAuthRedirect` HTTP
    handler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户完成授权过程，远程 OAuth 服务器将他们的浏览器重定向到我们在 `Flow` 类型构造函数中启动的 HTTP 服务器。接下来，我们将检查 `handleAuthRedirect`
    HTTP 处理器的实现。
- en: In the following code snippets, the `r` variable refers to an `http.Request` instance,
    while the `w` variable refers to an `http.ResponseWriter` instance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`r` 变量指的是一个 `http.Request` 实例，而 `w` 变量指的是一个 `http.ResponseWriter` 实例。
- en: 'The first task of the HTTP handler is to parse and validate the parameters
    that were sent to us by the authorization server using the following block of
    code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 处理器的第一个任务是解析和验证授权服务器通过以下代码块发送给我们的参数：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ParseForm` method of the `http.Request` object is quite flexible in that
    it is able to decode parameters both from the URL (if this is a **GET** request)
    and the HTTP request body (if this is a **POST** request). If the call returns
    without an error, we use the handy `FormValue` method to extract the state parameter,
    which contains the nonce value that we embedded in our initial authorization request
    URL, and the code value, which contains the access code that was returned by the
    authorization server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Request` 对象的 `ParseForm` 方法非常灵活，因为它能够从 URL（如果这是一个 **GET** 请求）和 HTTP 请求体（如果这是一个
    **POST** 请求）中解码参数。如果没有错误返回，我们使用方便的 `FormValue` 方法提取 `state` 参数，它包含我们嵌入初始授权请求 URL
    中的 nonce 值，以及 `code` 值，它包含授权服务器返回的访问代码。'
- en: 'Next, the handler acquires the lock and indexes the `pendingRequests` map using
    the provided nonce value in an attempt to look up the result channel for the pending
    request. If no match is found, we print out a simple warning message that will
    be displayed to the user''s browser and exit the handler. Otherwise, we remove
    the pending result channel from the map and publish a `Result` instance to it.
    The following block of code illustrates how the aforementioned steps are implemented:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，处理器获取锁并使用提供的nonce值索引`pendingRequests`映射，试图查找待处理请求的结果通道。如果没有找到匹配项，我们将打印出一个简单的警告信息，该信息将被显示在用户的浏览器中，并退出处理器。否则，我们将从映射中移除待处理的结果通道，并向其发布一个`Result`实例。以下代码块展示了上述步骤是如何实现的：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the HTTP handler writes the `Result` value to the channel, the application
    waiting on the channel unblocks and can invoke the result''s `Client` method to
    obtain an `http.Client` instance so that it can make authenticated calls to the
    remote service. The returned `http.Client` instance is specially configured to
    automatically inject the obtained access token into all outgoing requests and
    transparently refresh it when it expires. The complete implementation for this
    method is outlined in the following code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦HTTP处理器将`Result`值写入通道，等待该通道的应用程序将解除阻塞，并可以调用结果对象的`Client`方法以获取一个`http.Client`实例，从而可以对远程服务进行认证调用。返回的`http.Client`实例被特别配置为自动将获取的访问令牌注入所有发出的请求，并在其过期时透明地刷新它。此方法的完整实现概述在以下代码片段中：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As shown in the preceding code snippet, we complete the three-legged OAuth flow
    by exchanging the short-lived authentication code that's sent back to us by the
    authorization server with a long-lived access token. Finally, we pass the `OAuth`
    access token to the similarly-named `Client` method of the stored `oauth2.Config` value
    to create a token-aware `http.Client` instance, which is then returned to the
    caller.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，我们通过将授权服务器发送回的短期认证代码与长期访问令牌进行交换来完成三重认证流程。最后，我们将`OAuth`访问令牌传递给存储的`oauth2.Config`值的同名`Client`方法，以创建一个具有令牌意识的`http.Client`实例，然后将其返回给调用者。
- en: To understand how all the pieces of the puzzle fit together, you can take a
    look at the `Chapter09/oauthflow` package in this book's GitHub repository. It
    contains a complete, end-to-end example of a simple CLI application that uses
    the code from this section to gain access to GitHub's API and to print out a user's
    login name.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解拼图中所有部件是如何组合在一起的，您可以查看本书GitHub仓库中的`Chapter09/oauthflow`包。它包含了一个使用本节代码获取对GitHub
    API的访问权限并打印出用户登录名的简单CLI应用程序的完整、端到端示例。
- en: Dealing with API versions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理API版本
- en: Once a public API for a particular service gets published and third parties
    begin using it, API developers need to be very careful to avoid introducing any
    changes that could cause third-party applications to stop working.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦某个特定服务的公共API发布并第三方开始使用它，API开发者需要非常小心，以避免引入任何可能导致第三方应用程序停止工作的更改。
- en: Imagine that we are building a payment processor similar to PayPal, Stripe,
    or Adyen. The core business value proposition of such a service is to provide
    a solid and easy-to-use API for handling payments. To this end, we expect hundreds
    or thousands of application instances (e-commerce sites, recurring subscription
    services, and so on) to be tightly coupled to our payment processor's public API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个类似于PayPal、Stripe或Adyen的支付处理器。此类服务的核心业务价值主张是提供一个稳固且易于使用的API来处理支付。为此，我们预计会有数百或数千个应用程序实例（电子商务网站、定期订阅服务等）紧密耦合到我们的支付处理器的公共API。
- en: Introducing new API endpoints would be a relatively trivial task; after all,
    none of the applications that depend on the service API will be using the new
    endpoints, so we can't really break something. On the other hand, changing existing
    or removing old API endpoints cannot be done without giving advance notice to
    all the users of our API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 引入新的API端点将是一个相对简单的工作；毕竟，依赖于该服务API的所有应用程序都不会使用新的端点，所以我们实际上无法破坏任何东西。另一方面，更改现有或删除旧的API端点不能在没有提前通知我们API的所有用户的情况下完成。
- en: The problem is compounded even further by the fact that each application integrator
    moves at a different pace; some may update their applications in a relatively
    short amount of time, while others may take months to come up with an update.
    Likewise, application integrators can also go out of business, leaving end users
    with no channel for receiving updates for already deployed application instances.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个应用程序集成商的进度不同，这个问题变得更加复杂；有些人可能在相对较短的时间内更新他们的应用程序，而其他人可能需要数月时间才能推出更新。同样，应用程序集成商也可能倒闭，导致最终用户没有渠道接收已部署应用程序实例的更新。
- en: So, what if we were in complete control of both the server and the client? Would
    it be easier to introduce breaking changes if we were building, for instance,
    a mobile application and opted to use a proprietary API for communicating with
    the backend servers? The answer is still no! To figure out why this is the case,
    let's pretend that we are the operator that's responsible for running a ride-hailing
    application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们完全控制服务器和客户端会怎样？如果我们正在构建一个移动应用程序并选择使用专有API与后端服务器通信，那么引入破坏性更改是否会更简单？答案是仍然不会！为了弄清楚为什么是这样，让我们假设我们是负责运行叫车应用程序的运营商。
- en: One strategy that we can use to our advantage is to ship our mobile application
    with a built-in force-update mechanism. When the application starts, it can contact
    our API servers and check whether an update must be installed before continuing.
    If that happens to be the case, the application can nag the user until they agree
    to update it. That would definitely work... unless, of course, our users were
    standing in the pouring rain on a Saturday night, desperately trying to get a
    taxi.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用的一种策略是将我们的移动应用程序与内置的强制更新机制一起发布。当应用程序启动时，它可以联系我们的API服务器并检查在继续之前是否必须安装更新。如果确实如此，应用程序可以不断提醒用户，直到他们同意更新。这肯定有效...除非，当然，我们的用户在周六晚上站在倾盆大雨中，拼命地想要叫一辆出租车。
- en: In such a scenario, displaying a "please upgrade the application to continue"
    message is definitely a sign of bad UX and would probably trigger many users to
    immediately switch to a competitor's application. In addition, some of our users
    might be owners of older phone models that cannot be upgraded to a newer version
    of our application because they either run on older hardware or because the phone
    manufacturer revoked the keys that are used to sign applications for OS versions
    that are not supported anymore.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，显示“请升级应用程序以继续”的消息无疑是糟糕的用户体验的标志，可能会触发许多用户立即切换到竞争对手的应用程序。此外，我们的一些用户可能是较老手机型号的拥有者，无法升级到我们应用程序的新版本，因为它们运行在较旧的硬件上，或者因为手机制造商撤销了用于签名不再支持的操作系统版本的密钥。
- en: In hindsight, the evolution of APIs is inevitable. Therefore, we need to come
    up with some kind of versioning mechanism for the RESTful APIs that would allow
    us to introduce breaking changes while at the same time still being able to handle
    requests from legacy API clients.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 事后看来，API的演变是不可避免的。因此，我们需要为RESTful API制定某种版本控制机制，这样我们就可以在引入破坏性更改的同时，仍然能够处理来自旧版API客户端的请求。
- en: Including the API version as a route prefix
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将API版本作为路由前缀包含在内
- en: The most popular approach for implementing API versioning is for clients to
    include the requested API version as part of the requested API endpoint paths.
    For instance, `/v1/account` and `/v2/account` are versioned endpoints for retrieving
    the user's account details. However, the `/account` endpoint, when mounted under
    the `v2` prefix, might return a completely different payload than the one mounted
    under the `v1` prefix.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实施API版本控制最流行的方法是客户端将请求的API版本作为请求API端点路径的一部分。例如，`/v1/account`和`/v2/account`是用于检索用户账户详情的版本化端点。然而，当`/account`端点在`v2`前缀下挂载时，可能返回的负载与在`v1`前缀下挂载时的负载完全不同。
- en: 'The choice of the version naming scheme is totally arbitrary and is up to the
    API designer to decide on. Common versioning schemes include the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 版本命名方案的选择完全是任意的，由API设计者决定。常见的版本控制方案包括以下几种：
- en: Numeric values; for example, `v4`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字值；例如，`v4`
- en: API release dates; for example, `20200101`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API发布日期；例如，`20200101`
- en: Season names that coincide with new API releases; for example, `spring2020`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与新API发布同步的季节名称；例如，`spring2020`
- en: It is important to be aware that this particular versioning approach violates
    the principle that URIs should refer to unique resources. Clearly, in the previous
    example, `/v1/account` and `/v2/account` both refer to the same resource. What's
    more, a limitation of this approach is that we cannot version individual API endpoints.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，这种特定的版本化方法违反了URI应引用唯一资源的原则。显然，在前面的例子中，`/v1/account`和`/v2/account`都引用了同一资源。更重要的是，这种方法的一个局限性是我们无法对单个API端点进行版本控制。
- en: Negotiating API versions via HTTP Accept headers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过HTTP Accept头协商API版本
- en: The version as part of the route approach works fine if we assume that the API
    server is always supporting the latest API version. In this scenario, the client
    can simply select the highest version that it can work with without any concern
    about the server hosting the API. What if this assumption does not hold?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设API服务器始终支持最新的API版本，那么作为路由部分版本的这种方法是可行的。在这种情况下，客户端可以简单地选择它可以工作的最高版本，而无需担心API托管的服务器。如果这个假设不成立怎么办？
- en: Let's say that we are developing a chat server that users can download and deploy
    on their own infrastructure. Besides the chat server package, we also develop
    and maintain the official client for connecting to the chat server. The chat server
    exposes an API endpoint with a `/messages/:channel` path, which clients can invoke
    to obtain a list of messages for a particular channel.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在开发一个用户可以下载并部署到他们自己的基础设施上的聊天服务器。除了聊天服务器包之外，我们还开发和维护官方客户端以连接到聊天服务器。聊天服务器公开了一个具有`/messages/:channel`路径的API端点，客户端可以调用它以获取特定通道的消息列表。
- en: 'In version 1 of the API, each returned message includes two fields: the name
    of the user who sent the message and the message itself. In version 2 of the API,
    the message payload is augmented with two additional fields, namely, a timestamp
    and a link to the user''s avatar image.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在API的版本1中，每个返回的消息包含两个字段：发送消息的用户名称和消息本身。在API的版本2中，消息有效负载增加了两个额外的字段，即时间戳和用户头像图片的链接。
- en: Given that the version of the server that gets deployed is ultimately controlled
    by the end user, clients that connect to the server have no means of knowing which
    API version they can safely use. Granted, we could provide a dedicated API endpoint
    that clients could use to query the server version and then select the API version
    based on the server response. However, this approach is not really elegant and
    cannot really scale if we want to version specific endpoints but not the entire
    API.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最终部署的服务器版本由终端用户控制，连接到服务器的客户端无法知道它们可以安全使用哪个API版本。诚然，我们可以提供一个专门的API端点，客户端可以使用它来查询服务器版本，然后根据服务器的响应选择API版本。然而，这种方法并不真正优雅，如果我们只想对特定端点进行版本控制而不是整个API，那么这种方法实际上是无法扩展的。
- en: Clearly, we need to introduce a sort of negotiation protocol that would allow
    the client and server to select the maximum common supported API version that
    is understood by both parties. As it turns out, the HTTP protocol already comes
    with such functionality baked in.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要引入一种协商协议，允许客户端和服务器选择双方都理解的**最大**共同支持的API版本。事实上，HTTP协议已经内置了这样的功能。
- en: The client can use the HTTP Accept header to specify the API versions that it
    supports when it invokes the `/messages/:channel` endpoint. The contents of the Accept header
    must follow the media type specification format defined in RFC6838 ^([9]). For
    JSON-based APIs, the `application/vnd.apiVersion+json` template is typically used.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在调用`/messages/:channel`端点时，可以使用HTTP Accept头指定它支持的API版本。Accept头的内 容必须遵循RFC6838中定义的媒体类型规范格式^([9])。对于基于JSON的API，通常使用`application/vnd.apiVersion+json`模板。
- en: The `vnd` part indicates a vendor-specific media type. The `apiVersion` part
    is used to specify the supported version number, while the `+json` part indicates
    that the client expects a well-formed JSON document to be returned by the server.
    The media type syntax also allows clients to specify multiple media types as a
    comma-separated list. For the scenario we are currently discussing, a client that
    supports both API versions but prefers to use version 2 of the API would populate
    the header with the value `application/vnd.v2+json,application/vnd.v1+json`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`vnd` 部分表示一个供应商特定的媒体类型。`apiVersion` 部分用于指定支持的版本号，而 `+json` 部分表示客户端期望服务器返回一个格式良好的
    JSON 文档。媒体类型语法还允许客户端以逗号分隔的列表形式指定多个媒体类型。对于我们目前正在讨论的场景，一个支持两个 API 版本但更喜欢使用 API 版本
    2 的客户端将使用值 `application/vnd.v2+json,application/vnd.v1+json` 来填充头信息。'
- en: The server parses the header value, locates the highest supported API version,
    and routes the request to it or returns an error if none of the proposed client
    API versions are supported. When responding to the client with the payload, the
    server sets the value of the `Content-Type` header to indicate the API version
    that was actually used to process the request. The client parses this information
    and uses it to correctly unmarshal and handle the response payload.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器解析头信息值，定位最高支持的 API 版本，并将请求路由到该版本或在没有支持任何提议的客户端 API 版本时返回错误。当向客户端发送有效载荷时，服务器将
    `Content-Type` 头的值设置为指示实际用于处理请求的 API 版本。客户端解析这些信息并使用它来正确地反序列化和处理响应有效载荷。
- en: Building RESTful APIs in Go
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中构建 RESTful API
- en: Nowadays, building RESTful APIs in Go is a fairly streamlined process. If you
    don't mind a little bit of elbow grease (for example, using regular expressions
    to manually extract parameters from request paths), you can build your very own HTTP
    router by leveraging the functionality offered by `http.Mux`, a component that
    ships with the Go standard library.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 Go 中构建 RESTful API 是一个相当流畅的过程。如果你不介意一点点的辛苦（例如，使用正则表达式手动从请求路径中提取参数），你可以利用
    Go 标准库中提供的 `http.Mux` 组件的功能来构建自己的 HTTP 路由器。
- en: While building your own router from scratch would undoubtedly be a great learning
    experience, you should probably save quite a bit of time (and effort) and simply
    use one of the popular, battle-tested router packages such as gorilla-mux ^([5]) or
    HttpRouter ^([3]).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从头开始构建自己的路由器无疑会是一个极好的学习经历，但你可能应该节省相当多的时间（和精力），并简单地使用一些流行的、经过实战考验的路由器包，例如 gorilla-mux
    ^([5]) 或 HttpRouter ^([3])。
- en: On the other hand, if fully-fledged web frameworks (combining a router, middleware,
    and perhaps an ORM into a single package) are your cup of tea, you will be positively
    surprised to find out that there are a plethora of packages to choose from! An
    indicative list of popular (based on the number of stars on GitHub) web framework
    packages would definitely include buffalo ^([1]), revel ^([4]), and gin-gonic ^([10]).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你喜欢完整的 Web 框架（将路由器、中间件以及可能是一个 ORM 合并到一个包中），你将会非常惊讶地发现有很多选择！基于 GitHub
    上星标数量的一个指示性列表，流行的 Web 框架包肯定包括 buffalo ^([1])、revel ^([4]) 和 gin-gonic ^([10])。
- en: 'All of these packages have one thing in common: they are all built on top of
    the net/http package. If you happen to be building APIs that can potentially receive
    a large (that is, more than one million requests per server) volume of concurrent
    requests, you may find that the net/http package actually becomes a bottleneck
    that caps your API''s throughput.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些包都有一个共同点：它们都是建立在 net/http 包之上的。如果你碰巧正在构建可能接收大量（即，每个服务器超过一百万个请求）并发请求的 API，你可能会发现 net/http 包实际上成为了一个瓶颈，限制了你的
    API 的吞吐量。
- en: If you ever find yourself in this predicament and don't mind programming against
    a slightly different API than the one offered by the net/http package, you should
    take a look at the fasthttp ^([8]) package.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于这种困境中，并且不介意针对与 net/http 包提供的 API 稍有不同的一些 API 进行编程，你应该看看 fasthttp ^([8]) 包。
- en: Building RPC-based APIs with the help of gRPC
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 gRPC 的帮助下构建 RPC 基础的 API
- en: gRPC ^([2]) is a modern open source framework that was created by Google to
    assist the process of implementing APIs that are based on the **Remote Procedure
    Call** (**RPC**) paradigm. In contrast to the REST architecture, which is more
    suited for connecting web-based clients such as browsers to backend services,
    gRPC was proposed as a cross-platform and cross-language alternative for building
    low-latency and highly scalable distributed systems.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC^([2]) 是一个由 Google 创建的现代开源框架，旨在协助实现基于 **远程过程调用**（**RPC**）范式的 API 的过程。与更适合连接基于
    Web 的客户端（如浏览器）到后端服务的 REST 架构相比，gRPC 被提出作为一种跨平台和跨语言的替代方案，用于构建低延迟和高可扩展的分布式系统。
- en: Do you know what the letter g in gRPC stands for? A lot of people naturally
    think that it stands for Google, a reasonable assumption given that gRPC was released
    by Google in the first place. Others believe that **gRPC** is a recursive acronym,
    that is, **gRPC Remote Procedure Calls**.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道 gRPC 中的字母 g 代表什么吗？许多人自然认为它代表 Google，这是一个合理的假设，因为 gRPC 最初是由 Google 发布的。其他人认为
    **gRPC** 是一个递归缩写词，即 **gRPC Remote Procedure Calls**。
- en: The fun fact is that both interpretations are wrong! According to the gRPC documentation
    on GitHub, the meaning of the letter g changes with every new gRPC release ^([11]).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这两种解释都是错误的！根据 GitHub 上的 gRPC 文档，随着每个新的 gRPC 版本的发布，字母 g 的含义都会发生变化^([11])。
- en: While the construction of high-performance APIs to link together microservices
    is the bread and butter of gRPC, as we will see in the following sections, it
    can also be used as a replacement for existing REST APIs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 gRPC 构建高性能 API 以连接微服务是其核心功能，正如我们将在以下章节中看到的，它也可以作为现有 REST API 的替代品使用。
- en: Comparing gRPC to REST
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 gRPC 与 REST 进行比较
- en: While using REST as an architecture for building APIs provides several benefits,
    it also comes with a few caveats attached. Let's examine these caveats in more
    detail.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 REST 作为构建 API 的架构提供了许多好处，但也附带了一些需要注意的事项。让我们更详细地探讨这些注意事项。
- en: REST APIs are typically implemented on top of the HTTP/1.x protocol, which lacks
    proper support for managing and reusing connections. As a result, clients must
    establish a new TCP connection with the backend server and perform a complete
    TLS handshake every time they wish to invoke an API endpoint. This requirement
    not only incurs additional latency to API calls but also increases the load on
    backend servers (or load balancers, if you are doing TLS termination at the edge)
    since TLS handshaking comes with a non-insignificant computation cost.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 通常是在 HTTP/1.x 协议之上实现的，该协议缺乏对管理和重用连接的适当支持。因此，客户端每次想要调用 API 端点时，都必须与后端服务器建立一个新的
    TCP 连接，并执行完整的 TLS 握手。这一要求不仅给 API 调用带来了额外的延迟，还增加了后端服务器（或者在边缘进行 TLS 终止的情况下，是负载均衡器）的负载，因为
    TLS 握手伴随着相当大的计算成本。
- en: In an attempt to mitigate this issue, HTTP/1.1 introduced the model of HTTP
    pipelining. In this connection-management mode, the client opens a single TCP
    socket to the server and sends a batch of successive requests through. The server
    processes the batch of requests and sends back a batch of responses that match
    the order of the requests sent in by the client. One limitation of this model
    is that it can only be applied to idempotent requests (HEAD, GET, PUT, and DELETE).
    Furthermore, it is susceptible to head-of-line blocking, that is, a request that
    takes a long time to execute will delay the processing of subsequent requests
    in the same batch.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这一问题，HTTP/1.1 引入了 HTTP 管道化模型。在这种连接管理模式下，客户端向服务器打开一个单一的 TCP 套接字，并通过它发送一系列连续的请求。服务器处理这一系列请求，并发送回一系列与客户端发送的请求顺序相匹配的响应。这种模型的一个局限性是它只能应用于幂等请求（HEAD、GET、PUT
    和 DELETE）。此外，它还容易受到首部阻塞的影响，即一个执行时间较长的请求将延迟同一批次中后续请求的处理。
- en: On the other hand, gRPC is built on top of HTTP/2, which defines a new connection
    management model, that is, multiplexed streams. With this model, gRPC can support
    bi-directional streams that are interleaved and transmitted over a single TCP
    connection. This approach avoids the head-of-line blocking problem altogether
    and also allows the server to send push notifications back to the client.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，gRPC 是建立在 HTTP/2 之上的，它定义了一种新的连接管理模型，即多路复用流。使用这种模型，gRPC 可以支持在单个 TCP 连接上交错和传输的双向流。这种方法完全避免了首部阻塞问题，并允许服务器向客户端发送推送通知。
- en: The text-based nature of the HTTP/1.x protocol and the choice of JSON as the dominant serialization
    format for requests and responses makes RESTful APIs a bit too verbose to work
    with in use cases where the goal is to maximize throughput. While JSON payloads
    can definitely be compressed (for example, using gzip), we wouldn't be able to
    achieve the same efficiency as protocol buffers, the binary format that gRPC uses
    to compactly encode messages exchanged between the client and the server.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/1.x 协议的文本性质以及将 JSON 作为请求和响应的主要序列化格式，使得 RESTful API 在旨在最大化吞吐量的用例中过于冗长。虽然
    JSON 负载确实可以被压缩（例如，使用 gzip），但我们无法达到与协议缓冲区相同的效率，协议缓冲区是 gRPC 用于紧凑地编码客户端和服务器之间交换的消息的二进制格式。
- en: Finally, RESTful APIs do not mandate a particular structure for requests and
    response payloads. It's up to the client and server to correctly unmarshal JSON
    payloads and coerce the payload values to the correct type for the language they
    are written in. This approach could lead to errors or, even worse, data corruption.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，RESTful API 不强制要求请求和响应负载具有特定的结构。正确解包 JSON 负载并将负载值强制转换为它们所写语言的正确类型取决于客户端和服务器。这种方法可能会导致错误，甚至更糟，数据损坏。
- en: For example, if the server tries to unmarshal a 64-bit integer into a 32-bit
    integer variable, the value might be truncated if the original value cannot be
    coerced into 32 bits. On the other hand, gRPC uses strongly-typed messages, which
    always unmarshal to the correct types, regardless of the programming language
    that's used by the client or the server.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果服务器尝试将 64 位整数解包到 32 位整数变量中，如果原始值无法强制转换为 32 位，则值可能会被截断。另一方面，gRPC 使用强类型消息，无论客户端或服务器使用的编程语言如何，它总是将消息解包到正确的类型。
- en: Defining messages using protocol buffers
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协议缓冲区定义消息
- en: Protocol buffers are language- and platform-neutral mechanisms for serializing
    structured data in a very efficient manner. To achieve language neutrality, protocol
    buffers describe both messages and RPC services in a high-level **interface definition
    language** (**IDL**).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区是语言和平台中立的机制，以非常高效的方式序列化结构化数据。为了实现语言中立性，协议缓冲区使用高级 **接口定义语言**（**IDL**）描述消息和
    RPC 服务。
- en: To start working with protocol buffers, we need to install the protoc compiler
    for our development environment. You can do this by compiling from source or by
    installing a pre-built binary release for your platform from [https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用协议缓冲区，我们需要为我们的开发环境安装 protoc 编译器。您可以通过从源代码编译或从[https://github.com/protocolbuffers/protobuf/releases](https://github.com/protocolbuffers/protobuf/releases)为您的平台安装预构建的二进制发布版来完成此操作。
- en: 'In addition, you will also need to install the Go output generator for the
    protoc compiler and the Go packages that are required for working with protocol
    buffers and the gRPC framework by executing the following commands:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还需要通过执行以下命令来安装 protoc 编译器的 Go 输出生成器以及用于与协议缓冲区和 gRPC 框架一起工作的 Go 包：
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Protocol buffer message definitions typically live in files with a `.proto` extension.
    They are processed by specialized tools that compile the definitions into language-specific
    types that we can use to build our applications. For Go, the protoc compiler is
    generally invoked as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区消息定义通常位于具有 `.proto` 扩展名的文件中。它们由专门的工具处理，这些工具将定义编译成特定语言类型，我们可以使用这些类型来构建我们的应用程序。对于
    Go，protoc 编译器通常如下调用：
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `--go_out` argument instructs the protoc compiler to enable the Go output
    generator. It expects a comma-delimited list of options that end with a colon
    character. In the aforementioned example, the option list includes a plugin option
    to enable the gRPC plugin. The argument after the colon character specifies the
    location for any file that's generated by the compiler. Here, we set it to the
    current working directory.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`--go_out` 参数指示 protoc 编译器启用 Go 输出生成器。它期望一个以冒号字符结尾的逗号分隔的选项列表。在上面的例子中，选项列表包括一个用于启用
    gRPC 插件的插件选项。冒号字符后面的参数指定了由编译器生成的任何文件的存储位置。在这里，我们将其设置为当前工作目录。'
- en: The `-I` argument can be used to specify additional include paths that the compiler
    scans when resolving include directives. In this example, we add the current working
    directory to the include path.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`-I` 参数可以用来指定编译器在解析包含指令时扫描的附加包含路径。在这个例子中，我们将当前工作目录添加到包含路径中。'
- en: Finally, the last argument to the protoc compiler is the name of the `.proto`
    file to be compiled.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`protoc` 编译器的最后一个参数是要编译的 `.proto` 文件名。
- en: Defining messages
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义消息
- en: 'So, what does a protocol buffer message definition look like? Here is a short
    example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，协议缓冲消息定义看起来是什么样子呢？这里有一个简短的例子：
- en: '[PRE12]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding definition, the first line announces the version of the protocol
    buffer format that's going to be used for the rest of the file to the compiler.
    In this example, we are using version 3, which is the latest version and the one
    should be used for any new projects. The second line defines the name of the package,
    which will be used as a container for the generated protocol buffer definitions.
    As you can probably guess, the use of packages avoids conflicts between projects
    that define messages with the same names.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的定义中，第一行宣布了文件其余部分将要使用的协议缓冲格式版本，通知编译器。在这个例子中，我们使用的是版本 3，这是最新版本，也是任何新项目应该使用的版本。第二行定义了包名，它将被用作生成的协议缓冲定义的容器。正如你可能猜到的，使用包可以避免定义具有相同名称的消息的项目之间的冲突。
- en: 'Message definitions begin with the `message` keyword, which is followed by
    the message name and a list of (field type, field name) tuples. Protocol buffer
    compilers recognize the following set of built-in types ^([7]):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 消息定义以 `message` 关键字开始，后面跟着消息名称和一系列（字段类型，字段名称）元组。协议缓冲编译器识别以下内置类型集 ^([7])：
- en: '| **.proto Type** | **Equivalent Go Type** | **Notes** |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **.proto 类型** | **等效 Go 类型** | **注意事项** |'
- en: '| `double` | `float64` |  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `float64` |  |'
- en: '| `float` | `float32` |  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `float32` |  |'
- en: '| `int32` | `int32` | Uses variable-length encoding |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | `int32` | 使用可变长度编码 |'
- en: '| `int64` | `int64` | Uses variable-length encoding |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `int64` | 使用可变长度编码 |'
- en: '| `uint32` | `uint32` | Uses variable-length encoding |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `uint32` | 使用可变长度编码 |'
- en: '| `uint64` | `uint64` | Uses variable-length encoding |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `uint64` | 使用可变长度编码 |'
- en: '| `sint32` | `int32` | More efficient for storing negative integer values than
    `int32` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `sint32` | `int32` | 比使用 `int32` 更高效地存储负整数值 |'
- en: '| `sint64` | `int64` | More efficient for storing negative integer values than
    `int64` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `sint64` | `int64` | 比使用 `int64` 更高效地存储负整数值 |'
- en: '| `fixed32` | `uint32` | Always 4 bytes; more efficient for values > 228 than
    `uint32` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `fixed32` | `uint32` | 总是 4 个字节；对于大于 2^28 的值，比 `uint32` 更高效 |'
- en: '| `fixed64` | `uint64` | Always 8 bytes; more efficient for values > 256 than
    `uint64` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `fixed64` | `uint64` | 总是 8 个字节；对于大于 2^56 的值，比 `uint64` 更高效 |'
- en: '| `sfixed32` | `int32` | Always 4 bytes |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed32` | `int32` | 总是 4 个字节 |'
- en: '| `sfixed64` | `int64` | Always 8 bytes |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed64` | `int64` | 总是 8 个字节 |'
- en: '| `bool` | `bool` |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |  |'
- en: '| `string` | `string` |  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `string` |  |'
- en: '| `bytes` | `[]byte` |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `bytes` | `[]byte` |  |'
- en: As we mentioned in the previous sections, protocol buffers try to encode messages
    into a compact and space-efficient format. To this end, integers are generally
    serialized using variable-length encoding. Since this approach does not work that
    well for negative values, protocol buffers also define auxiliary types for (mostly)
    negative values (for example, `sint32` and `sint64`), which are encoded in a different
    and more space-efficient way.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，协议缓冲尝试将消息编码成一个紧凑且空间高效的格式。为此，整数通常使用可变长度编码进行序列化。由于这种方法对于负值来说效果不佳，协议缓冲还定义了用于（主要是）负值的辅助类型（例如，`sint32`
    和 `sint64`），它们以不同且更高效的方式进行编码。
- en: 'Of course, we are not limited to just the built-in types. We can use already-defined
    message types as field types too! In fact, these definitions might even live in
    a separate `.proto` file that we include in the following way:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅限于使用内置类型。我们还可以将已定义的消息类型用作字段类型！实际上，这些定义甚至可能存在于一个单独的 `.proto` 文件中，我们可以通过以下方式包含它：
- en: '[PRE13]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another interesting feature of protocol buffers is enumerations, which allow
    us to define fields that can only be assigned a value from a fixed, predefined
    list of values. The following code expands the `Address` message definition so
    that it includes a type field to help us identify the address type:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲的另一个有趣特性是枚举，它允许我们定义只能从固定、预定义值列表中分配值的字段。以下代码扩展了 `Address` 消息定义，以便它包括一个 `type`
    字段，帮助我们识别地址类型：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `enum` block defines the list of constants that can be assigned to the newly
    introduced type field. One important thing to keep in mind is that every enumeration
    list must include a constant that maps to the zero value as its first element.
    This serves as the default value for the field.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`块定义了可以分配给新引入的类型字段的常量列表。需要记住的一个重要事项是，每个枚举列表必须包括一个映射到零值的常量作为其第一个元素。这作为字段的默认值。'
- en: Versioning message definitions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本化消息定义
- en: Each field in a protocol buffer message is assigned a unique ID. The most common
    pattern is to assign IDs in an incremental fashion, starting from 1\. When a field
    is serialized to the wire format, the serializer emits a small header that contains
    information about the field type, its size (for variable-sized fields), and its
    ID.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区消息中的每个字段都被分配了一个唯一的ID。最常见的模式是从1开始按增量分配ID。当一个字段被序列化为线格式时，序列化器会发出一个包含有关字段类型、其大小（对于可变大小的字段）和其ID的小头信息。
- en: The receiver scans the header and checks whether a field with that ID is present
    in its local message definition. If so, the field value is unserialized from the
    stream to the appropriate field. Otherwise, the receiver uses the information
    in the header to skip over any fields it does not recognize.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器扫描头信息并检查具有该ID的字段是否存在于其本地消息定义中。如果是这样，字段值将从流反序列化到适当的字段。否则，接收器使用头中的信息来跳过它不认识的任何字段。
- en: This feature is extremely important as it forms the basis for versioning message
    definitions. Since message definitions evolve over time, new fields can be added
    or existing fields may be reordered without breaking existing consumers who are
    working with messages that have been compiled from older `.proto` files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能非常重要，因为它构成了消息定义版本化的基础。由于消息定义会随着时间的推移而演变，可以添加新字段或重新排序现有字段，而不会破坏使用从较旧的 `.proto`
    文件编译的消息的现有消费者。
- en: Representing collections
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示集合
- en: 'What''s more, protocol buffers can also model two types of collections, namely,
    lists and maps. To create a list of items, all we need to do is add the `repeated` keyword
    as a prefix of the field''s type. On the other hand, maps are defined with a special
    notation, that is, `map<K, V>`, where `K` and `V` represent the types for the
    map keys and values. The following snippet is an example of defining collections:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，协议缓冲区还可以模拟两种类型的集合，即列表和映射。要创建一个项目列表，我们只需要将`repeated`关键字作为字段类型的开头即可。另一方面，映射使用特殊符号定义，即`map<K,
    V>`，其中`K`和`V`代表映射键和值的类型。以下是一个定义集合的示例片段：
- en: '[PRE15]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When compiled to Go code, the fields for the `Users` message will be mapped
    to a `[]User` type and a `map[string]User` type, respectively.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译为Go代码时，`Users`消息的字段将被映射到`[]User`类型和`map[string]User`类型。
- en: Modeling field unions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型字段联合
- en: One frequent requirement for many kinds of applications is the ability to model unions.
    A union is a special kind of value that can have multiple representations, all
    of which point to the same location in memory. The use of shared memory implies
    that every time we write a value to a particular union field, any attempt to read
    one of the other union fields will result in garbled data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的应用程序的一个常见需求是能够模拟联合。联合是一种特殊类型的值，它可以有多种表示形式，所有这些表示形式都指向内存中的同一位置。使用共享内存意味着每次我们将值写入特定的联合字段时，尝试读取其他联合字段之一都将导致数据混乱。
- en: The concept of unions extends quite nicely to protocol buffers. If you are working
    with messages that contain multiple fields where, at most, one field can be set
    at any given time, you can reduce the amount of required memory by grouping all
    these fields in a union.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 联合的概念很好地扩展到了协议缓冲区。如果你正在处理包含多个字段的消息，其中在任何给定时间最多只能设置一个字段，你可以通过将这些字段组合成一个联合来减少所需的内存量。
- en: 'A union definition begins with the `oneof` keyword, followed by the field name
    and a list of fields that comprise the union. The following snippet shows a simple
    example that demonstrates a very common API use case:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 联合定义以`oneof`关键字开始，后跟字段名和组成联合的字段列表。以下是一个简单示例，演示了一个非常常见的API用例：
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, all the responses have an associated correlation ID value.
    However, depending on the outcome of the API call invocation, the response payload
    will either contain an `Account` or an `Error`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，所有响应都有一个相关的关联ID值。然而，根据API调用调用的结果，响应负载将包含一个`Account`或一个`Error`。
- en: 'After compiling the aforementioned message definition, the protoc compiler
    will generate two special types, namely, `CreateAccountResponse_Account` and `CreateAccountResponse_Error`,
    that can be assigned to the `Payload` field of the `CreateAccountResponse` type:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译上述消息定义之后，protoc 编译器将生成两个特殊类型，即 `CreateAccountResponse_Account` 和 `CreateAccountResponse_Error`，这些类型可以分配给
    `CreateAccountResponse` 类型的 `Payload` 字段：
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To prevent other types from being assigned to the `Payload` field, the protoc
    compiler uses an interesting trick: it defines a private interface with an unexported
    dummy method and arranges it so that only the previous two type definitions implement
    it:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止其他类型分配给 `Payload` 字段，protoc 编译器使用了一个有趣的技巧：它定义了一个具有未导出虚拟方法的私有接口，并安排它只让前两个类型定义实现它：
- en: '[PRE18]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The protoc compiler specifies the interface mentioned in the preceding code
    snippet as the type of the `Payload` field, thus making it a compile-time error
    to assign any other type to the field. Moreover, to facilitate the retrieval of
    the union values, the compiler will also generate `GetAccount` and `GetError` helpers
    on the `CreateAccountResponse` type. These helpers peek into the `Payload` field's
    contents and either return the assigned value (`Account` or `Error`) or `nil` if
    no value of that type has been assigned to the union field.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Protoc 编译器将前面代码片段中提到的接口指定为 `Payload` 字段的类型，因此将分配任何其他类型的字段视为编译时错误。此外，为了便于检索联合值，编译器还会在
    `CreateAccountResponse` 类型上生成 `GetAccount` 和 `GetError` 辅助函数。这些辅助函数会查看 `Payload`
    字段的内容，并返回分配的值（`Account` 或 `Error`），如果没有分配该类型的值，则返回 `nil`。
- en: The Any type
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Any` 类型'
- en: 'When building event-driven systems, a common pattern is to define a top-level
    message that acts as an envelope for different event payloads. Since new event
    types may be added (or removed) at any point in time, using a union is simply
    not going to suffice. Furthermore, the following are from the standpoint of event
    consumers:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建事件驱动系统时，一个常见的模式是定义一个顶层消息，该消息作为不同事件负载的封装。由于新的事件类型可能在任何时候添加（或删除），使用联合体显然是不够的。此外，以下是从事件消费者的角度出发的：
- en: Consumers might ship with older `.proto` versions than the event producers do.
    It is quite possible for them to encounter an event payload that they don't really
    know how to decode.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者可能使用比事件生产者更旧的 `.proto` 版本。他们遇到不知道如何解码的事件负载是完全可能的。
- en: Some consumers may only be interested in processing a *subset* of the events.
    In such a scenario, consumers should only decode the messages they care about
    and skip over all other messages.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些消费者可能只对处理事件的子集感兴趣。在这种情况下，消费者应该只解码他们关心的消息，并跳过所有其他消息。
- en: 'To cater for such cases, we can use the `Any` type to define our envelope message:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种情况，我们可以使用 `Any` 类型来定义我们的信封消息：
- en: '[PRE19]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Any` type, as the name implies, can store any protocol buffer message.
    Internally, this is achieved by storing a serialized version of the message, as
    well as a string identifier that describes the type of message stored within.
    The type identifier has the form of a URL and is constructed by concatenating `type.googleapis.com/` with
    the message name. The `ptypes` package (you can find it at [www.github.com/golang/protobuf/ptypes](http://www.github.com/golang/protobuf/ptypes))
    provides several useful helpers for dealing with `Any` messages.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`Any` 类型可以存储任何协议缓冲区消息。内部，这是通过存储消息的序列化版本以及描述存储在其中的消息类型的字符串标识符来实现的。类型标识符的形式为
    URL，它通过将 `type.googleapis.com/` 与消息名称连接起来构建。`ptypes` 包（您可以在 [www.github.com/golang/protobuf/ptypes](http://www.github.com/golang/protobuf/ptypes)
    找到它）为处理 `Any` 消息提供了几个有用的辅助函数。
- en: 'The following code is an example of how we would populate an `Envelope` instance:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是填充 `Envelope` 实例的示例：
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `MarshalAny` helper takes any value that implements the `proto.Message` interface
    and serializes it into an `Any` message, which we then assign to the `Payload` field
    of the `Envelope` type.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarshalAny` 辅助函数接受任何实现 `proto.Message` 接口的价值并将其序列化为 `Any` 消息，然后我们将其分配给 `Envelope`
    类型的 `Payload` 字段。'
- en: 'On the consumer end, we can use the following block of code to process incoming
    envelopes:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端，我们可以使用以下代码块来处理传入的信封：
- en: '[PRE21]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Essentially, the handler switches on the message type and uses the `UnmarshalAny` helper
    to unserialize and handle supported messages. On the other hand, if the message
    type is unknown or not one that the consumer is interested in, they can either
    skip it or return an error, which is what is happening in the preceding code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，处理程序根据消息类型进行切换，并使用`UnmarshalAny`辅助函数来反序列化和处理受支持的消息。另一方面，如果消息类型是未知的或不是消费者感兴趣的，他们可以选择跳过它或返回一个错误，这正是前面代码中发生的情况。
- en: After defining the set of messages that we want to use in our application using
    the protocol buffer definition language, the next logical step is to create RPCs
    that make use of them! In the following section, we will explore how we can enable
    the *grpc* plugin and have the protoc compiler automatically generate the required
    code stubs for our RPCs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用协议缓冲定义语言定义了我们想要在应用程序中使用的消息集之后，下一步逻辑步骤是创建使用它们的RPC！在以下部分，我们将探讨如何启用`*grpc*`插件，并让protoc编译器自动为我们生成所需的RPC代码存根。
- en: Implementing RPC services
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现RPC服务
- en: 'The gRPC framework leverages the stream multiplexing capabilities of `HTTP/2`
    so that it can handle both synchronous and asynchronous RPCs. The protoc compiler,
    when invoked with the *grpc* plugin enabled, will generate the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC框架利用了`HTTP/2`的流多路复用能力，以便它可以处理同步和异步RPC。当使用启用了`*grpc*`插件的protoc编译器调用时，将生成以下内容：
- en: Client and server **interfaces** for every RPC service definition in the compiled
    `.proto` file. For a service named `Foo`, the compiler will generate a `FooServer` and
    a `FooClient` interface. This is quite a useful feature as it allows us to inject
    mocked clients into our code at test time.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的`.proto`文件中每个RPC服务定义的客户端和服务器**接口**。对于名为`Foo`的服务，编译器将生成一个`FooServer`和一个`FooClient`接口。这是一个非常有用的功能，因为它允许我们在测试时将模拟客户端注入到我们的代码中。
- en: Complete client implementation for each service that adheres to the generated
    client interface.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都遵循生成的客户端接口的完整客户端实现。
- en: A helper function to register our service implementation with a gRPC server
    instance. Once again, for a service called `Foo`, the compiler will generate a
    function with a signature similar to `RegisterFooServer(*grpc.Server, FooServer)`.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个辅助函数，用于将我们的服务实现注册到gRPC服务器实例。再次强调，对于名为`Foo`的服务，编译器将生成一个签名类似于`RegisterFooServer(*grpc.Server,
    FooServer)`的函数。
- en: 'The following short code snippet demonstrates how we can create a new gRPC
    server, register our implementation for the `Foo` service, and start serving incoming
    RPCs:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的代码片段演示了我们可以如何创建一个新的gRPC服务器，注册我们的`Foo`服务实现，并开始服务传入的RPC：
- en: '[PRE22]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the following four sections, we will examine the different types of RPC modes
    that are supported by the gRPC framework.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下四个部分中，我们将检查gRPC框架支持的RPC模式的不同类型。
- en: Unary RPCs
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一RPC
- en: 'A unary RPC is equivalent to the request-response model that''s used in traditional
    RESTful APIs. In the following example, we are defining a service with the name `AccountService` that
    exposes a `CreateAccount` method that receives `CreateAccountRequest` as input
    and returns a `CreateAccountResponse` to the caller:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 单一RPC等同于在传统RESTful API中使用的请求-响应模型。在以下示例中，我们定义了一个名为`AccountService`的服务，它公开了一个`CreateAccount`方法，该方法接收`CreateAccountRequest`作为输入，并返回一个`CreateAccountResponse`给调用者：
- en: '[PRE23]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Defining the server handler is also quite similar to a regular RESTful API.
    Consider the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 定义服务器处理程序与常规RESTful API也非常相似。考虑以下代码：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To be able to register our server implementation with gRPC, we need to implement
    the `AccountServiceServer` interface. The server-side implementation in the listing
    (given in the preceding code snippet) receives a `CreateAccountRequest` message
    as an argument. It invokes the `createAccount` helper, which validates the request,
    creates the new account record, and returns its ID. Then, a new `CreateAccountResponse` instance is
    created and returned to the client.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将我们的服务器实现注册到gRPC，我们需要实现`AccountServiceServer`接口。在列表中给出的服务器端实现（在前面代码片段中给出）接收一个`CreateAccountRequest`消息作为参数。它调用`createAccount`辅助函数，验证请求，创建新的账户记录，并返回其ID。然后，创建一个新的`CreateAccountResponse`实例并返回给客户端。
- en: 'On the client side, things are also quite simple. The following code shows
    that the `accountAPI` type simply offers a friendly API for abstracting the RPC
    call to the server:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，事情也同样简单。以下代码展示了`accountAPI`类型仅仅提供了一个友好的API来抽象对服务器的RPC调用：
- en: '[PRE25]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The method receives a model instance that describes the account to be created,
    converts it into `CreateAccountInstance`, and sends it to the server via the `AccountServiceClient` instance
    that was injected at construction time. Upon receiving a response, the client
    extracts the ID that was assigned to the new account and returns it to the caller.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收一个描述要创建的账户的模型实例，将其转换为`CreateAccountInstance`，并通过在构造时注入的`AccountServiceClient`实例将其发送到服务器。收到响应后，客户端提取分配给新账户的ID，并将其返回给调用者。
- en: Server-streaming RPCs
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器流式RPC
- en: In a server-streaming RPC scenario, the client initiates an RPC on the server
    and receives a stream of responses. Clients block reading on the stream until
    new data becomes available or the server closes the stream. In the latter case,
    the client read request will return an `io.EOF` error to indicate that no more
    data is available.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器流式RPC场景中，客户端在服务器上发起RPC调用，并接收一系列响应。客户端在流上阻塞读取，直到有新数据可用或服务器关闭流。在后一种情况下，客户端读取请求将返回一个`io.EOF`错误，以指示没有更多数据可用。
- en: 'In the following example, we are defining a service that streams price updates
    for a particular cryptocurrency:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个服务，该服务流式传输特定加密货币的价格更新：
- en: '[PRE26]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code shows the server-side implementation for the `StreamCryptoPrice`
    RPC:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`StreamCryptoPrice` RPC的服务器端实现：
- en: '[PRE27]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `StreamCryptoPrice` signature shown in the preceding code snippet is different
    than the unary RPC signature we examined in the previous section. Besides the
    incoming request, the handler also receives a helper type that the protoc compiler
    created for us to deal with the streaming aspects of this particular RPC call.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中显示的`StreamCryptoPrice`签名与我们在上一节中检查的单例RPC签名不同。除了传入的请求外，处理程序还接收一个由protoc编译器为我们创建的辅助类型，以处理此特定RPC调用的流式传输方面。
- en: 'The server handler calls out to the `priceStreamFor` helper (implementation
    omitted) to obtain a channel where price updates for the requested currency type
    are posted. Once a new price has been received, the server code invokes the `Send` method
    on the provided stream helper to stream a new response to the client. Once the
    server handler returns (for example, when the price stream channel closes), gRPC
    will automatically shut down the stream and send an `io.EOF` error to the client,
    whose implementation is shown in the following code block:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器处理程序调用`priceStreamFor`辅助函数（实现省略）以获取一个通道，其中发布了对请求货币类型的价格更新。一旦收到新的价格，服务器代码就会在提供的流辅助程序上调用`Send`方法，向客户端流式传输新的响应。一旦服务器处理程序返回（例如，当价格流通道关闭时），gRPC将自动关闭流并向客户端发送一个`io.EOF`错误，其实现如下代码块所示：
- en: '[PRE28]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The client API wrapper uses the injected `PriceServiceClient` instance to initiate
    the RPC and obtain a stream where price updates can be read from. The client then
    enters an infinite `for` loop where it blocks on the stream's `Recv` method until
    a new price update (or an error) is received.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端API包装器使用注入的`PriceServiceClient`实例启动RPC调用，并获取一个可以从中读取价格更新的流。然后客户端进入一个无限`for`循环，在其中它阻塞在流的`Recv`方法上，直到接收到新的价格更新（或错误）。
- en: Client-streaming RPCs
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端流式RPC
- en: Client-streaming RPCs are the opposite of server-streaming RPCs. In this case,
    it's the client that streams data to the server. Once the server has received
    *all* the data, it replies with a *single* response.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端流式RPC与服务器流式RPC相反。在这种情况下，客户端向服务器流式传输数据。一旦服务器收到所有数据，它就会回复一个单一响应。
- en: 'In the following example, we are defining a service that receives a stream
    of metric values from the client and responds with a set of aggregated statistics
    (`count`, `min`, `max`, and `avg` value) for the entire batch:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们定义了一个服务，该服务从客户端接收一系列度量值，并返回整个批次的聚合统计信息（`count`、`min`、`max`和`avg`值）：
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following block of code builds on top of the functionality offered by the
    RPC client for this service and exposes an API for calculating the statistics
    for a stream of values that are read off a caller-provided Go channel:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块构建在为该服务提供的RPC客户端功能之上，并公开了一个API，用于计算从调用者提供的Go通道读取的值流统计信息：
- en: '[PRE30]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As shown in the preceding code snippet, the `GetStats` implementation initially
    makes a call to the underlying RPC client''s `CalculateStats` method and obtains
    a (client-side) stream helper. With the help of a `range`loop, each value from
    the provided `valueCh` is wrapped into a new `Observation` message and transmitted
    to the server for processing. Once the client has sent all observed values to
    the server, it invokes the `CloseAndRecv` method, which performs two tasks:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`GetStats`实现最初调用底层RPC客户端的`CalculateStats`方法，并获取一个（客户端）流辅助工具。借助`range`循环，将提供的`valueCh`中的每个值包装成一个新的`Observation`消息，并将其传输到服务器进行处理。一旦客户端已将所有观察到的值发送到服务器，它将调用`CloseAndRecv`方法，该方法执行两个任务：
- en: It notifies the server that no more data is available
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通知服务器没有更多数据可用
- en: It blocks until the server returns a `StatsResponse`
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会阻塞，直到服务器返回一个`StatsResponse`
- en: 'Next, we will take a look at the server-side implementation for the aforementioned
    RPC:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看上述RPC的服务器端实现：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The server reads incoming `Observation` instances from the stream that's passed
    as an argument to `CalculateStats` and appends them to a slice. Once the server
    detects (via the presence of an `io.EOF` error) that the client has transmitted
    all data, it passes the collected observations slice to the `calcStats` helper,
    which calculates the statistics for the batch and returns them as a `StatsResponse` message that
    the server forwards to the client.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器从传递给`CalculateStats`的流中读取传入的`Observation`实例，并将它们追加到一个切片中。一旦服务器检测到（通过`io.EOF`错误的
    presence）客户端已传输所有数据，它将收集到的观察结果切片传递给`calcStats`辅助工具，该工具计算批次的统计数据，并以`StatsResponse`消息的形式返回，服务器将此消息转发给客户端。
- en: Bi-directional streaming RPCs
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向流RPC
- en: The last RPC mode that we will explore is bi-directional streaming. This mode
    combines client- and server-side streaming and provides us with two independent
    channels where the client and server can *asynchronously* publish and consume
    messages.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的最后一种RPC模式是双向流。这种模式结合了客户端和服务器端流，为我们提供了两个独立的通道，客户端和服务器可以在其中*异步*发布和消费消息。
- en: 'To understand how this mode works, let''s examine the definition for an asynchronous
    `Echo` service:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这种模式的工作原理，让我们检查异步`Echo`服务的定义：
- en: '[PRE32]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The server-side logic for the echo service is not that interesting. As shown
    in the following code snippet, the server runs a `for` loop where it reads the
    next message from the client and echoes it back. The server''s `for` loop keeps
    executing until the client terminates the RPC:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 回声服务的服务器端逻辑并不那么有趣。如下面的代码片段所示，服务器运行一个`for`循环，从中读取客户端的下一个消息并将其回显。服务器的`for`循环会一直执行，直到客户端终止RPC：
- en: '[PRE33]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s take a look at the client implementation, which turns out to be
    a bit more convoluted since we need to deal with two asynchronous streams. In
    a typical bi-directional RPC implementation, we would spin up a go-routine to
    handle each end of the streams. However, to keep this example as simple as possible,
    we will only use a go-routine to process echo responses from the server, as shown
    in the following code snippet:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下客户端实现，它似乎要复杂一些，因为我们需要处理两个异步流。在典型的双向RPC实现中，我们会启动一个goroutine来处理每个流的端点。然而，为了使这个例子尽可能简单，我们将只使用一个goroutine来处理来自服务器的回声响应，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding code snippet, the client invokes the `Echo` method
    on the echo service client and obtains a helper object (assigned to a variable
    called `stream`) to assist us with sending and receiving streaming data to and
    from the server. We then spin up a go-routine to execute `processEcho`, which
    is the function that's responsible for handling incoming echo responses. The function
    receives the `stream` object we obtained as an argument and a buffered error channel
    for reporting received errors.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，客户端在echo服务客户端上调用`Echo`方法，并获取一个辅助对象（分配给名为`stream`的变量），以帮助我们向服务器发送和接收流数据。然后我们启动一个goroutine来执行`processEcho`，这是负责处理传入回声响应的函数。该函数接收我们作为参数获得的`stream`对象和一个缓冲错误通道，用于报告接收到的错误。
- en: 'The following code shows the implementation of `processEcho`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`processEcho`的实现：
- en: '[PRE35]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The receiving end is almost identical to the server-side implementation. We
    keep reading echo messages from the stream until we get an error. If the `Recv` method
    returns an error other than `io.EOF`, we write it to the error channel prior to
    returning it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接收端与服务器端实现几乎相同。我们持续从流中读取回声消息，直到我们得到一个错误。如果`Recv`方法返回的错误不是`io.EOF`，我们在返回之前将其写入错误通道。
- en: Note that, in the preceding code snippet, the error channel is *always closed* when
    the function returns. The `Echo` method exploits this behavior so that it blocks
    until `processEcho` returns and dequeues emitted errors by using a `for` loop
    to range on `errCh`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码片段中，当函数返回时，错误通道总是**关闭**的。`Echo`方法利用这一行为，直到`processEcho`返回并使用`for`循环遍历`errCh`来出队发出的错误。
- en: 'While the `processEcho` function is running in the background, the code calls
    out to `sendEcho`, a *synchronous* function that sends out `msgCount` echo requests
    and then returns:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当`processEcho`函数在后台运行时，代码会调用`sendEcho`，这是一个**同步**函数，它会发送`msgCount`个回声请求，然后返回：
- en: '[PRE36]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, how do we terminate this RPC? The call to the `CloseSend` method terminates
    the upstream channel to the server and causes the `Recv` method in the *server-side* code
    to return an `io.EOF` error. This triggers the server handler to exit and subsequently
    close its downstream channel to the client.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何终止这个RPC？调用`CloseSend`方法终止到服务器的上游通道，并导致服务器端代码中的`Recv`方法返回一个`io.EOF`错误。这触发了服务器处理器的退出，随后关闭其到客户端的下游通道。
- en: The `sendEcho` function returns to `Echo`, which then waits for `processEcho` to
    exit. As soon as the server terminates the downstream channel, the `Recv` call
    in `processEcho` will also return an `io.EOF` error and cause the `processEcho` go-routine
    to return. This last step unblocks the `Echo` call, which can now return to its
    caller.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendEcho`函数返回到`Echo`，然后等待`processEcho`退出。一旦服务器终止了下游通道，`processEcho`中的`Recv`调用也会返回一个`io.EOF`错误，并导致`processEcho`协程返回。这一步解除了`Echo`调用的阻塞，现在它可以返回到其调用者。'
- en: Security considerations for gRPC APIs
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC API的安全考虑
- en: The constructor for each of the RPC clients that the protoc compiler generated
    for you expects a `grpc.Connection` argument. This is intentional as a single
    remote server might expose multiple RPC services. Given that HTTP/2 supports request
    multiplexing, it makes sense to instantiate a single connection to the server
    and share it between the various RPC clients.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: protoc编译器为您生成的每个RPC客户端构造函数都期望一个`grpc.Connection`参数。这是故意的，因为单个远程服务器可能公开多个RPC服务。鉴于HTTP/2支持请求多路复用，实例化一个连接到服务器并共享给各个RPC客户端是有意义的。
- en: So, how can we obtain a `grpc.Connection` instance? The `grpc` package provides
    a convenience helper called `Dial`, which handles all the low-level details for
    establishing a connection to a gRPC server. The `Dial` function expects the address
    of the gRPC server we want to connect to and a variadic list of `grpc.DialOption` values.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何获取一个`grpc.Connection`实例？`grpc`包提供了一个名为`Dial`的便利助手，它处理建立到gRPC服务器的连接的所有底层细节。`Dial`函数期望我们想要连接的gRPC服务器的地址和一个`grpc.DialOption`值的可变列表。
- en: 'At this point, it is important to note that the gRPC dialer assumes that the
    remote server will be secured with TLS and will fail to establish a connection
    if this happens not to be the case. We can definitely come up with scenarios where
    the use of TLS might not be required:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，需要注意的是，gRPC拨号器假定远程服务器将使用TLS进行加密，如果情况不是这样，它将无法建立连接。我们肯定可以想出一些不需要使用TLS的场景：
- en: We might be running a local gRPC server on our development machine
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会在我们的开发机器上运行一个本地gRPC服务器
- en: We might spin up a gRPC server as part of a test
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会在测试中启动一个gRPC服务器
- en: All of our backend services might be running in a private subnet that can't
    be reached from the internet
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所有的后端服务可能都在一个无法从互联网访问的私有子网中运行
- en: To cater for such use cases, we can force gRPC to establish connections to non-TLS
    servers by providing the `grpc.WithInsecure()` dial option to the `Dial` function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对此类用例，我们可以通过向`Dial`函数提供`grpc.WithInsecure()`拨号选项来强制gRPC与非TLS服务器建立连接。
- en: If you do opt for the recommended approach and use TLS everywhere, you will
    be pleasantly surprised to find that the methods for securing RESTful APIs that
    we discussed at the beginning of this chapter can also be applied to gRPC! The
    gRPC framework allows you to configure security at two different levels, namely,
    at the **connection** and at the **application** level.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择推荐的方法并在所有地方使用TLS，你将惊喜地发现，我们在本章开头讨论的用于保护RESTful API的方法也可以应用于gRPC！gRPC框架允许你在两个不同的级别配置安全性，即连接级别和应用程序级别。
- en: At the connection level, gRPC allows us to manually configure the options for
    the TLS handshake with the help of the `grpc.WithTransportCredentials` dial option,
    which takes a `credentials.TransportCredentials` argument. The `grpc/credentials` package
    contains helpers that produce `TransportCredentials` from certificates (if you
    wish to implement client authentication via provisioned TLS certificates) and `tls.Config` instances
    (for implementing server certificate pinning).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接级别，gRPC允许我们使用`grpc.WithTransportCredentials`拨号选项手动配置TLS握手的选项，该选项接受一个`credentials.TransportCredentials`参数。`grpc/credentials`包包含从证书（如果您希望通过配置TLS证书实现客户端身份验证）和`tls.Config`实例（用于实现服务器证书固定）生成`TransportCredentials`的辅助工具。
- en: As far as application-level security is concerned, gRPC offers the `grpc.WithPerRPCCredentials` dial
    option. This option accepts a `credentials.PerRPCCredentials` instance and allows
    gRPC clients to automatically inject the provided set of credentials into every
    outgoing RPC. The `grpc/credentials/oauth` package provides helpers for dealing
    with different authorization mechanisms. For instance, the `oauth.NewOauthAccess` function
    allows us to use an `oauth2.Token` instance that we have obtained via a three-legged
    OAuth2 flow with our RPCs.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 就应用程序级别的安全性而言，gRPC提供了`grpc.WithPerRPCCredentials`拨号选项。此选项接受一个`credentials.PerRPCCredentials`实例，并允许gRPC客户端自动将提供的凭据集注入到每个出站RPC中。`grpc/credentials/oauth`包提供了处理不同授权机制的辅助工具。例如，`oauth.NewOauthAccess`函数允许我们使用通过三脚OAuth2流程从我们的RPC中获得的`oauth2.Token`实例。
- en: On the other end, the server uses specialized middleware (gRPC refers to middleware
    with the term *request interceptors*) to access the credentials provided by clients
    and control access to RPC methods.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，服务器使用专门的中间件（gRPC将中间件称为*请求拦截器*）来访问客户端提供的凭据并控制对RPC方法的访问。
- en: Decoupling Links 'R' Us components from the underlying data stores
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将“Links 'R' Us”组件与底层数据存储解耦
- en: Both the link-crawler component that we created in [Chapter 7](51dcc0d4-2ba3-4db9-83f7-fcf73a33aa74.xhtml), *Data-Processing
    Pipelines*, and the PageRank calculator component that we built in [Chapter 8](c505ec2d-0bd8-4edd-97e1-d06de2b326a5.xhtml),
    *Graph-Based Data Processing*, were designed to work with one of the data store
    implementations from [Chapter 6](ce489d62-aaa3-4fbb-b239-c9de3daa9a8f.xhtml),
    *Building a Persistence Layer*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](51dcc0d4-2ba3-4db9-83f7-fcf73a33aa74.xhtml)，“数据处理管道”中创建的链接爬虫组件，以及我们在[第8章](c505ec2d-0bd8-4edd-97e1-d06de2b326a5.xhtml)，“基于图的数据处理”中构建的PageRank计算器组件，都被设计成可以与[第6章](ce489d62-aaa3-4fbb-b239-c9de3daa9a8f.xhtml)，“构建持久层”中提到的数据存储实现之一一起工作。
- en: 'To this end, when configuring these components, we are expected to provide
    suitable concrete data store implementations that satisfy the `graph.Graph` and `index.Indexer` interfaces.
    If we were building a monolithic application, we would normally be performing
    this bit of initialization inside the `main` package, as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在配置这些组件时，我们预计需要提供满足`graph.Graph`和`index.Indexer`接口的合适具体数据存储实现。如果我们正在构建一个单体应用，我们通常会在这个`main`包内部执行这部分初始化，如下所示：
- en: Import the package with the data store drivers we want to use in our application
    (for example, the **CockroachDB **backed link-graph and the **Elasticsearch **backed
    text indexer).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们希望在应用程序中使用的具有数据存储驱动程序的包（例如，由**CockroachDB**支持的链接图和由**Elasticsearch**支持的文本索引器）。
- en: Create new driver instances and configure them accordingly with a static or
    externally provided driver-specific set of settings (for example, the endpoints
    for the CockroachDB or Elasticsearch cluster).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的驱动程序实例，并根据静态或外部提供的特定于驱动程序的设置集进行相应配置（例如，CockroachDB或Elasticsearch集群的端点）。
- en: Initialize the link-crawler and PageRank calculator components using the data
    store instances we just created. This works out of the box as all datastore implementations
    from [Chapter 6](ce489d62-aaa3-4fbb-b239-c9de3daa9a8f.xhtml), *Building a Persistence
    Layer**,* satisfy the aforementioned interfaces and can be directly assigned to
    the configuration objects that are passed as arguments to the component constructors.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚创建的数据存储实例初始化链接爬虫和PageRank计算器组件。这可以开箱即用，因为[第6章](ce489d62-aaa3-4fbb-b239-c9de3daa9a8f.xhtml)，*构建持久化层*中所有数据存储实现都满足上述接口，可以直接分配给作为组件构造函数参数传递的配置对象。
- en: As we will see in the next chapter, we can make our application a bit more flexible
    by having our code import the packages for all the supported link-graph and text-indexer
    provider implementations and dynamically instantiate one of them at runtime after
    consulting the value of a command-line flag.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一章中看到的，通过让我们的代码导入所有支持的链接图和文本索引器提供者实现包，并在运行时根据命令行标志的值动态实例化其中之一，我们可以使我们的应用程序更加灵活。
- en: One of the issues with this approach is that it introduces a strong coupling
    to a particular data store implementation. What if our design requirements involve
    the creation of multiple applications that all need to use the same datastore
    providers?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是它引入了对特定数据存储实现的强耦合。如果我们设计要求涉及创建多个都需要使用相同数据存储提供者的应用程序，那会怎样？
- en: To apply the aforementioned steps, we would need to duplicate the same initialization
    logic across all our applications. That would violate the **Don't Repeat Yourself**
    (**DRY**) principle and make our code base harder to maintain. Moreover, think
    about the amount of effort that would be required if we are asked to add support
    for a new data store implementation. We would essentially need to modify and recompile
    all our applications!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用上述步骤，我们需要在所有我们的应用程序中重复相同的初始化逻辑。这将违反**不要重复自己**（**DRY**）原则，并使我们的代码库更难维护。此外，考虑如果我们被要求添加对新数据存储实现的支持，所需的努力量。我们实际上需要修改并重新编译所有我们的应用程序！
- en: Given the list of problems related to having a strong coupling between applications
    and data stores, what options do we, as software engineers, have to reduce or
    ideally eliminate this coupling when designing new systems? An elegant solution
    would be to create a standalone proxy service that provides access to a particular
    data store implementation through a REST or (preferably) gRPC-based API. This
    pattern allows us to effectively switch to a different data store at any point
    in time without having to recompile any of our applications that consume the API.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于应用程序和数据存储之间强耦合相关的问题列表，作为软件工程师，我们在设计新系统时有哪些选项来减少或理想情况下消除这种耦合？一个优雅的解决方案是创建一个独立的代理服务，通过REST或（更理想的是）基于gRPC的API提供对特定数据存储实现的访问。这种模式允许我们在任何时间点有效地切换到不同的数据存储，而无需重新编译任何使用API的应用程序。
- en: In the last part of this chapter, we will apply what we have learned so far
    and build gRPC-based APIs so that we can access the link-graph and text-indexer
    components over the network. To keep things as consistent as possible, both the
    RPC names and the field list of the messages that are exchanged between the client
    and the server will *mimic* the signatures of the methods defined by the `graph.Graph`
    and `index.Indexer` interfaces.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将应用我们迄今为止所学的内容，构建基于gRPC的API，以便我们可以通过网络访问链接图和文本索引器组件。为了尽可能保持一致性，RPC名称以及客户端和服务器之间交换的消息的字段列表将*模仿*由`graph.Graph`和`index.Indexer`接口定义的方法签名。
- en: In accordance with the instructions from the previous sections, we will be using
    the protocol buffer definition language to specify the RPCs for our APIs.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前几节的说明，我们将使用协议缓冲定义语言来指定我们API的RPCs。
- en: Defining RPCs for accessing a remote link-graph instance
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用于访问远程链接图实例的RPCs
- en: 'The first API that we will be designing will grant our project''s applications
    access to any concrete link-graph implementation that satisfies the `graph.Graph`
    interface over a network link. The following snippet outlines the protocol buffer
    definitions for the RPC endpoints that we will need:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要设计的第一个API将允许我们的项目应用程序通过网络链接访问满足`graph.Graph`接口的任何具体链接图实现。以下代码片段概述了我们需要的RPC端点的协议缓冲定义：
- en: '[PRE37]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `UpsertLink` call inserts a new link to the graph or updates the details
    of an existing link. The call receives and returns a `Link` message, whose definition
    is shown in the following snippet:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpsertLink` 调用向图中插入新的链接或更新现有链接的详细信息。该调用接收并返回一个 `Link` 消息，其定义如下所示：'
- en: '[PRE38]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `Link` message includes the following bits of information:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`Link` 消息包含以下信息：'
- en: The UUID of the link. Given that protocol buffers do not offer a native type
    for storing UUIDs (16-byte values), we will be representing them as a *byte slice*.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接的 UUID。鉴于协议缓冲区不提供用于存储 UUID（16 字节值）的本地类型，我们将它们表示为 *字节切片*。
- en: The link's URL.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接的 URL。
- en: The timestamp when the link was last retrieved by the crawler.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爬虫上次检索链接的时间戳。
- en: 'The `UpsertEdge` call inserts a new edge to the graph or updates the details
    of an existing edge. The call receives and returns an `Edge` message with the
    following definition:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpsertEdge` 调用向图中插入新的边或更新现有边的详细信息。该调用接收并返回一个具有以下定义的 `Edge` 消息：'
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Each `Edge` message includes the following bits of information:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Edge` 消息包含以下信息：
- en: The UUID of the edge
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边的 UUID
- en: The UUIDs of the source and destination vertices
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源点和目标顶点的 UUID
- en: A timestamp indicating when the edge was last updated by the crawler
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间戳，指示爬虫上次更新边的时间
- en: The next call on our list is `RemoveStaleEdges`. As you may recall from [Chapter
    7](51dcc0d4-2ba3-4db9-83f7-fcf73a33aa74.xhtml), *Data-Processing Pipelines*, this
    call is required by the web-crawler component to discard missing (stale) edges
    every time it retrieves the latest contents of a web page in the link-graph.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个调用是 `RemoveStaleEdges`。如您从第 7 章 [51dcc0d4-2ba3-4db9-83f7-fcf73a33aa74.xhtml]
    的 *数据处理管道* 中回忆的那样，这个调用是由网络爬虫组件在每次检索链接图中网页的最新内容时丢弃缺失（过时）边所必需的。
- en: What's interesting about this particular RPC is that while it accepts a `RemoveStaleEdgesQuery` message
    as input, it doesn't really need to return a result to the caller. However, since
    gRPC mandates that all RPCs return some message to the caller, we will use `google.protobuf.Empty`
    (a placeholder type for an empty/void message) as the RPC's return type.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的 RPC 有趣之处在于，虽然它接受 `RemoveStaleEdgesQuery` 消息作为输入，但它实际上不需要向调用者返回结果。然而，由于
    gRPC 强制要求所有 RPC 都必须向调用者返回某些消息，我们将使用 `google.protobuf.Empty`（一个用于空/空消息的占位符类型）作为
    RPC 的返回类型。
- en: 'Let''s take a quick look at the definition of the `RemoveStaleEdgesQuery` message:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下 `RemoveStaleEdgesQuery` 消息的定义：
- en: '[PRE40]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The last two methods on our RPC list are `Links` and `Edges`. Both calls expect
    the client to provide a `Range` message as input. This message allows clients
    to specify the set of arguments that the server will pass through to the similarly-named
    method of the underlying concrete link-graph implementation, namely, the UUID
    range for selecting the set of entities (links or edges) to return and a cutoff
    timestamp for filtering entities with a more recent last retrieved/updated value.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 RPC 列表中的最后两个方法是 `Links` 和 `Edges`。这两个调用都期望客户端提供 `Range` 消息作为输入。此消息允许客户端指定服务器将通过底层具体链接图实现的同名方法传递的参数集，即选择要返回的实体（链接或边）的
    UUID 范围以及用于过滤具有更晚检索/更新值的实体的截止时间戳。
- en: 'The following snippet outlines the definition of the `Range` message:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的片段概述了 `Range` 消息的定义：
- en: '[PRE41]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Up to this point, all the RPCs that we have examined are unary. However, the `Links` and `Edges` calls
    differ in that they are declared as *server-streaming* RPCs. The use of streaming
    allows clients to process the returned list of links and edges more efficiently.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们检查的所有 RPC 都是单参数的。然而，`Links` 和 `Edges` 调用不同之处在于它们被声明为 *服务器流式* RPC。流的使用允许客户端更有效地处理返回的链接和边列表。
- en: In the next section, we will examine the RPC definitions for accessing the text-indexer.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将检查访问文本索引器的 RPC 定义。
- en: Defining RPCs for accessing a text-indexer instance
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义用于访问文本索引器实例的 RPC
- en: 'The second API that we will be designing will grant our project''s applications
    access to any concrete link-graph implementation that satisfies the `index.Indexer` interface
    over a network link. The following snippet outlines the protocol buffer definitions
    for the RPC endpoints that we will need:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个我们将要设计的 API 将允许我们的项目应用程序通过网络链接访问满足 `index.Indexer` 接口的任何具体链接图实现。下面的片段概述了我们将需要的
    RPC 端点协议缓冲区定义：
- en: '[PRE42]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `Index` method inserts a document into the search index or triggers a reindexing
    operation if the document already exists. As you can see by its method definition,
    the call expects and returns a `Document` message, which is shown in the following
    code snippet:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index`方法将文档插入到搜索索引中，或者如果文档已存在，则触发重新索引操作。正如您从其方法定义中看到的那样，调用期望并返回一个`Document`消息，如下面的代码片段所示：'
- en: '[PRE43]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A successful call to `Index` will return the same `Document` that was passed
    as input. However, the document will also have the `indexed_at` field populated/updated
    by the remote server.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用`Index`将返回与输入相同的`Document`。然而，远程服务器还会填充/更新文档的`indexed_at`字段。
- en: 'The next call that we will be examining is `UpdateScore`. This call will be
    used by the PageRank calculator component to set the PageRank score for a particular
    document. The call accepts an `UpdateScoreRequest` message and returns nothing
    (hence the use of the `google.protobuf.Empty` placeholder message):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的下一个调用是`UpdateScore`。此调用将由PageRank计算器组件用来设置特定文档的PageRank分数。该调用接受一个`UpdateScoreRequest`消息并返回空（因此使用了`google.protobuf.Empty`占位符消息）：
- en: '[PRE44]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last, and more interesting, RPC method that we will be discussing is `Search`.
    Calls to `Search` accept a `Query` message as input and return a *stream* of `QueryResult` responses:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一个，也是更有趣的RPC方法是`Search`。对`Search`的调用接受一个`Query`消息作为输入，并返回一系列`QueryResult`响应的*流*：
- en: '[PRE45]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the message definitions for `Query` and `QueryResult` are a
    bit more complicated. To begin with, the `Query` message defines a nested enumeration
    for specifying the type of query to be executed. By default, the query expression
    is treated as a regular keyword-based search (`MATCH` is the default value for
    the `type` field).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Query`和`QueryResult`的消息定义要复杂一些。首先，`Query`消息定义了一个嵌套枚举来指定要执行的查询类型。默认情况下，查询表达式被视为基于关键字的常规搜索（`MATCH`是`type`字段的默认值）。
- en: However, the caller can also request a phrase-based search by specifying `PHRASE`
    as the value of the `type` field. Furthermore, callers are also allowed to specify
    an offset and instruct the server to skip a number of results from the top of
    the returned result set. This mechanism can be used by clients to implement pagination.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，调用者也可以通过将`PHRASE`指定为`type`字段的值来请求基于短语的搜索。此外，调用者还被允许指定一个偏移量，并指示服务器跳过返回结果集顶部的一定数量的结果。这种机制可以由客户端用来实现分页。
- en: 'The `QueryResult` message uses the **one-of** feature of protocol buffers.
    This message can either contain a `uint64` value that describes the total number
    of documents matched by the query or the next `Document` from the result set.
    Our server implementation will use the following simple protocol to stream results
    to the client:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryResult`消息使用了协议缓冲区的**one-of**特性。此消息可以包含一个`uint64`值，该值描述了查询匹配的总文档数或结果集的下一个`Document`。我们的服务器实现将使用以下简单的协议将结果流式传输到客户端：'
- en: The *first* message in the result stream will *always* describe the total number
    of results for the search. If no documents matched the search query, the server
    will indicate this by setting the `doc_count` field to the value `0`.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果流中的*第一个*消息将*始终*描述搜索的总结果数。如果没有文档匹配搜索查询，服务器将通过将`doc_count`字段设置为值`0`来表示这一点。
- en: Each subsequent message will push the `Document` that matches the client.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个后续的消息都将推送与客户端匹配的`Document`。
- en: Creating high-level clients for accessing data stores over gRPC
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过gRPC访问数据存储的高级客户端
- en: The *protoc* compiler, given the RPC definitions from the previous two sections
    as input, will generate a client and the required server stubs for the data store
    proxy service.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`protoc`编译器，给定前两个部分中的RPC定义作为输入，将为数据存储代理服务生成客户端和所需的服务器存根。'
- en: 'From the perspective of the API server, each RPC method is nothing more than
    a wrapper for invoking the similarly-named method of the underlying concrete store
    implementation that we configured the server to use. More specifically, to implement
    the RPC method called **X**, we perform the following steps:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 从API服务器的角度来看，每个RPC方法不过是调用底层具体存储实现中同名方法的包装器。更具体地说，为了实现名为**X**的RPC方法，我们执行以下步骤：
- en: Convert the fields of the RPC's input message (where required) into the values
    expected by the wrapped method, *X.*
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RPC输入消息的字段（如有必要）转换为包装方法*X*期望的值。
- en: Invoke X while watching out for any errors.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用X时，注意任何错误。
- en: Convert and pack the output of X into the appropriate return message for the
    RPC.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将X的输出转换为适当的RPC返回消息。
- en: Return the generated response to the client.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的响应返回给客户端。
- en: As you can probably tell, our server implementation will mostly consist of boring
    boilerplate code that uses the recipe we just described as a template. To conserve
    some space, we will omit the implementation details from this book. However, you
    can take a look at the full source code for the two API servers by examining the
    `server.go` files in the `Chapter09/linksrus/linkgraphapi` and `Chapter09/linksrus/textindexerapi`
    packages, which can be found in this book's GitHub repository.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经猜到的，我们的服务器实现将主要是由一些无聊的样板代码组成，这些代码使用我们刚才描述的模板。为了节省空间，我们将从本书中省略实现细节。然而，您可以通过检查本书GitHub仓库中`Chapter09/linksrus/linkgraphapi`和`Chapter09/linksrus/textindexerapi`包中的`server.go`文件来查看两个API服务器的完整源代码。
- en: With the RPC server in place, our applications can establish a connection to
    it and use the gRPC client that the *protoc* compiler generated for us to access
    the link-graph and text-indexer components on the other end. An unfortunate caveat
    of our current implementation is that since the auto-generated gRPC clients do
    not implement the `graph.Graph` and `index.Indexer` interfaces, we cannot use
    them as drop-in replacements for configuring the crawler and PageRank calculator
    components.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好RPC服务器之后，我们的应用程序可以与其建立连接，并使用*protoc*编译器为我们生成的gRPC客户端来访问另一端的链接图和文本索引器组件。我们当前实现的一个不幸的副作用是，由于自动生成的gRPC客户端没有实现`graph.Graph`和`index.Indexer`接口，我们无法将它们用作配置爬虫和PageRank计算器组件的即插即用替代品。
- en: Fortunately, there is an elegant way to work around this inconvenience! The
    package for each API will also need to define a *high-level* client that *wraps* the
    gRPC client that the protoc compiler generated for us and implements, depending
    on the API, either the `graph.Graph` interface or the `index.Indexer` interface.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种优雅的方法可以绕过这种不便之处！每个API的包也需要定义一个*高级*客户端，该客户端*封装*了我们由protoc编译器生成的gRPC客户端，并根据API的不同，实现`graph.Graph`接口或`index.Indexer`接口。
- en: Behind the scenes, the high-level client will transparently handle all interactions
    with the remote gRPC server. While this approach does require additional development
    effort, it makes the high-level client appear as yet another graph or indexer
    implementation that we can inject into the **Links 'R' Us components** without
    requiring any code changes. In [Chapter 11](dfb5c555-2534-4bac-b661-34cb9e7a3da8.xhtml),
    *Splitting Monoliths into Microservices,* we will be exploiting this trick to
    split the Links 'R' Us project into a set of microservices!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，高级客户端将透明地处理与远程gRPC服务器所有的交互。虽然这种方法确实需要额外的开发工作，但它使得高级客户端看起来就像是我们可以注入到**Links
    'R' Us组件**中的另一个图或索引器实现，而无需任何代码更改。在[第11章](dfb5c555-2534-4bac-b661-34cb9e7a3da8.xhtml)“将单体拆分为微服务”中，我们将利用这个技巧将Links
    'R' Us项目拆分为一组微服务！
- en: In a similar fashion to the server implementation, the high-level client also
    consists of quite a bit of repetitive boilerplate code, so in the interest of
    brevity, we will also omit its listing from this chapter. The full source code
    for the two high-level clients can be found in a file called `client.go`, which
    is in the same location as the server implementation.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器实现类似，高级客户端也包含相当多的重复样板代码，因此为了简洁起见，我们也将省略其列表。两个高级客户端的完整源代码可以在名为`client.go`的文件中找到，该文件位于服务器实现相同的目录中。
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the first part of this chapter, we discussed the key principles behind RESTful
    APIs. We focused on effective strategies for handling hot topics such as security
    and versioning. Then, we analyzed the pros and cons of RESTful APIs compared to
    the RPC-base paradigm used by the gRPC framework and highlighted the key differences
    that make gRPC more suitable for building high-performance services.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们讨论了RESTful API背后的关键原则。我们关注了处理诸如安全性和版本控制等热点问题的有效策略。然后，我们分析了与gRPC框架使用的基于RPC的范式相比，RESTful
    API的优缺点，并突出了使gRPC更适合构建高性能服务的关键差异。
- en: Now that you're at the end of this chapter, you should be familiar with the
    protocol buffer definition language and know how to leverage the various features
    supported by the gRPC framework for building high-performance secure APIs based
    on the RPC pattern.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经到达本章的结尾，你应该熟悉协议缓冲定义语言，并知道如何利用gRPC框架支持的各项特性来构建基于RPC模式的高性能安全API。
- en: In the next chapter, we will find out how we can perform hermetic builds of
    our software, package it as a container image, and deploy it on a Kubernetes cluster.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何执行我们软件的密封构建，将其打包为容器镜像，并在Kubernetes集群上部署。
- en: Questions
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe the CRUD endpoints for a user entity.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述用户实体的CRUD端点。
- en: Explain how basic authentication over TLS can help us secure APIs.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释基本认证在TLS中如何帮助我们保护API。
- en: Are TLS connections immune to eavesdropping?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TLS连接是否免疫于窃听？
- en: Describe the steps in the three-legged OAuth2 flow.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述三脚OAuth2流程的步骤。
- en: What is the benefit of using protocol buffers compared to JSON for request/response
    payloads?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与JSON相比，使用协议缓冲作为请求/响应负载有什么好处？
- en: Describe the different RPC modes that are supported by gRPC.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述gRPC支持的不同RPC模式。
- en: Further reading
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*A Go web development eco-system, designed to make your life easier;* refer
    to the following link for more information: [https://github.com/gobuffalo/buffalo](https://github.com/gobuffalo/buffalo).'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Go语言Web开发生态系统，旨在使您的生活更轻松；* 更多信息请参考以下链接：[https://github.com/gobuffalo/buffalo](https://github.com/gobuffalo/buffalo)。'
- en: '*A high performance, open-source universal RPC framework;* refer to the following
    link for more information: [https://www.grpc.io](https://www.grpc.io).'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一个高性能、开源的通用RPC框架；* 更多信息请参考以下链接：[https://www.grpc.io](https://www.grpc.io)。'
- en: '*A high-performance HTTP request router that scales well*; refer to the following
    link for more information: [https://github.com/julienschmidt/httprouter](https://github.com/julienschmidt/httprouter).'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一个高性能且扩展性良好的HTTP请求路由器；* 更多信息请参考以下链接：[https://github.com/julienschmidt/httprouter](https://github.com/julienschmidt/httprouter)。'
- en: '*A high productivity, full-stack web framework for the Go language; *refer
    to the following link for more information: [https://github.com/revel/revel](https://github.com/revel/revel).'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一个针对Go语言的，高效率的全栈Web框架；* 更多信息请参考以下链接：[https://github.com/revel/revel](https://github.com/revel/revel)。'
- en: '*A powerful HTTP router and URL matcher for building Go web servers;* refer
    to the following link for more information: [https://github.com/gorilla/mux](https://github.com/gorilla/mux).'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*一个强大的HTTP路由器和URL匹配器，用于构建Go语言Web服务器；* 更多信息请参考以下链接：[https://github.com/gorilla/mux](https://github.com/gorilla/mux)。'
- en: 'Berners-Lee, T.; Fielding, R.; Masinter, L.: RFC 3986, **Uniform Resource Identifier**
    (**URI**): Generic Syntax.'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Berners-Lee, T.; Fielding, R.; Masinter, L.: RFC 3986, **统一资源标识符**（**URI**）：通用语法。'
- en: '*Developer guide for protocol buffer v3;* refer to the following link for more
    information: [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3).'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*协议缓冲v3的开发者指南；* 更多信息请参考以下链接：[https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)。'
- en: '*Fast HTTP package for Go. Tuned for high performance. Zero memory allocations
    in hot paths. Up to 10x faster than net/http*; refer to the following link for
    more information: [https://github.com/valyala/fasthttp](https://github.com/valyala/fasthttp).'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为Go语言优化的快速HTTP包。在热点路径上零内存分配。比net/http快10倍以上；* 更多信息请参考以下链接：[https://github.com/valyala/fasthttp](https://github.com/valyala/fasthttp)。'
- en: '*Media Type Specifications and Registration Procedures;* refer to the following
    link for more information: [https://tools.ietf.org/html/rfc6838](https://tools.ietf.org/html/rfc6838).'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*媒体类型规范和注册程序；* 更多信息请参考以下链接：[https://tools.ietf.org/html/rfc6838](https://tools.ietf.org/html/rfc6838)。'
- en: '*The fastest full-featured web framework for Go; *refer to the following link
    for more information:[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin).'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Go语言最快的全功能Web框架；* 更多信息请参考以下链接：[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)。'
- en: '*The meaning of the letter g in gRPC;* refer to the following link for more
    information: [https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md](https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md).'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*gRPC中字母g的含义；* 更多信息请参考以下链接：[https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md](https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md)。'
