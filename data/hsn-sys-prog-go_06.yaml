- en: Working with the Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件系统
- en: This chapter is all about interacting with the Unix filesystem. Here, we will
    look at everything from the basic read and write operations to more advanced buffered
    operations, like token scanning and file monitoring.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲解与Unix文件系统的交互。在这里，我们将从基本的读写操作到更高级的缓冲操作，如标记扫描和文件监控，一切都会涉及。
- en: All of the information for the user or the system is stored as a file in Unix,
    so in order to interact with the system and user data, we must interact with the
    filesystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Unix中所有用户或系统的信息都存储为文件，因此为了与系统和用户数据交互，我们必须与文件系统交互。
- en: In this chapter, we will see that there are different ways of executing read
    and write operations, and how each one is focused more on simplicity of the code,
    the memory usage of the application and its performance, as well as the speed
    of execution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到执行读写操作的不同方式，以及每种方式更注重代码的简单性，应用程序的内存使用和性能，以及执行速度。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: File path manipulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件路径操作
- en: Reading files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件
- en: Writing files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写文件
- en: Other filesystem operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他文件系统操作
- en: Third-party packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方包
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, please refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: Handling paths
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路径
- en: Go offers a series of functions that make it possible to manipulate file paths
    that are platform-independent and that are contained mainly in the `path/filepath` and `os`
    packages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一系列函数，可以操作与平台无关的文件路径，主要包含在`path/filepath`和`os`包中。
- en: Working directory
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作目录
- en: Each process has a directory associated with it called the **working directory**,
    which is usually inherited from the parent process. This makes it possible to
    specify relative paths – one that doesn't start with the root folder. This will
    be `/` on Unix and macOS and `C:\` (or any other drive letter) on Windows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个与之关联的目录，称为**工作目录**，通常从父进程继承。这使得可以指定相对路径 - 不以根文件夹开头。在Unix和macOS上为`/`，在Windows上为`C:\`（或任何其他驱动器号）。
- en: An absolute/full path starts with the root directory and it represents the same
    location in a filesystem, that is, `/usr/local`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对/完整路径以根目录开头，并且表示文件系统中的相同位置，即`/usr/local`。
- en: A relative path doesn't start with a root, and the path starts with the current
    working directory, that is, `documents`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径不以根目录开头，路径以当前工作目录开头，即`documents`。
- en: 'The operating system interprets these paths as being relative to the current
    directory, so their absolute version is a concatenation of the working directory
    and the relative path. Let''s take a look at the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统将这些路径解释为相对于当前目录，因此它们的绝对版本是工作目录和相对路径的连接。让我们看一个例子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, the user is in their home folder, `~`. The user specifies to change directory
    to `documents`, and the `cd` command automatically adds the working directory
    as a prefix to it and moves to `~/documents`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，用户位于他们的家目录`~`。用户指定要切换到`documents`目录，`cd`命令会自动将工作目录作为前缀添加到它，并移动到`~/documents`。
- en: 'Before moving on to the second command, let''s introduce two special files
    that are available in all the directories for all operative systems:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入第二个命令之前，让我们介绍一下在所有操作系统的所有目录中都可用的两个特殊文件：
- en: '`.`: The dot is a reference to the current directory. If it''s the first element
    of the path, it is the process working directory, otherwise it refers to the path
    element that precedes it (for example, in `~/./documents`, `.` refers to `~`).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`: 点是指当前目录。如果它是路径的第一个元素，则是进程的工作目录，否则它指的是它前面的路径元素（例如，在`~/./documents`中，`.`指的是`~`）。'
- en: '`..`: The double dot refers to the parent of the current directory if it''s
    the first element of the path, or to the parent of the directory that it precedes
    if not (for example, in `~/images/../documents`, `..` refers to the parent of
    `~/images`, `~`).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`..`: 双点是指当前目录的父目录，如果它是路径的第一个元素，或者是它前面的目录的父目录（例如，在`~/images/../documents`中，`..`指的是`~/images`的父目录，`~`）。'
- en: Knowing this, we can easily infer that the second path is first joined in `~/documents/../videos`,
    the parent element, `..`, gets resolved, and the final path, `~/videos`, is obtained.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点，我们可以轻松推断出第二个路径首先加入`~/documents/../videos`，然后解析父元素`..`，得到最终路径`~/videos`。
- en: Getting and setting the working directory
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置工作目录
- en: We can use the `func Getwd() (dir string, err error)` function of the `os` package
    to find out which path represents the current working directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`os`包的`func Getwd() (dir string, err error)`函数来找出表示当前工作目录的路径。
- en: 'Changing the working directory is done with another function of the same package,
    that is, `func Chdir(dir string) error`, as shown in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更改工作目录是使用同一包的另一个函数完成的，即`func Chdir(dir string) error`，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Path manipulation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径操作
- en: 'The `filepath` package contains less than 20 functions, which is a small number
    compared to the packages of the standard library, and it''s used to manipulate
    paths. Let''s take a quick look at these functions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath`包包含不到20个函数，与标准库的包相比数量较少，它用于操作路径。让我们快速看一下这些函数：'
- en: '`func Abs(path string) (string, error)`: Returns the absolute version of the
    path that''s passed by joining it to the current working directory (if it''s not
    already absolute), and then cleans it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Abs(path string) (string, error)`: 返回传递的路径的绝对版本（如果它不是绝对的，则将其连接到当前工作目录），然后清理它。'
- en: '`func Base(path string) string`: Gives the last element of the path (base).
    For instance, `path/to/some/file` returns the file*.* Note that if the path is
    empty, this function returns a `*.*` (dot) path.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Base(path string) string`: 给出路径的最后一个元素（基本路径）。例如，`path/to/some/file`返回`file`。请注意，如果路径为空，此函数将返回一个`*.*`（点）路径。'
- en: '`func Clean(path string) string`: Returns the shortest version of the path
    by applying a series of defined rules. It does operations like replacing `.` and
    `..`, or removing trailing separators.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Clean(path string) string`: 通过应用一系列定义的规则返回路径的最短版本。它执行操作，如替换`.`和`..`，或删除尾部分隔符。'
- en: '`func Dir(path string) string`: Gets the path without its last element. This
    usually returns the parent directory of the element.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Dir(path string) string`: 获取不包含最后一个元素的路径。这通常返回元素的父目录。'
- en: '`func EvalSymlinks(path string) (string, error)`: Returns the path after evaluating
    symbolic links. The path is relative if the provided path is also relative and
    doesn''t contain symbolic links with absolute paths.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func EvalSymlinks(path string) (string, error)`: 在评估符号链接后返回路径。如果提供的路径也是相对的，并且不包含绝对路径的符号链接，则路径是相对的。'
- en: '`func Ext(path string) string`: Gets the file extension of the path, the suffix
    that starts with the final dot of the last element of the path, and it''s an empty
    string if there''s no dot (for example, `docs/file.txt` returns `.txt`).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Ext(path string) string`: 获取路径的文件扩展名，即以路径的最后一个元素的最终点开始的后缀，如果没有点，则为空字符串（例如`docs/file.txt`返回`.txt`）。'
- en: '`func FromSlash(path string) string`: Replaces all `/` (slashes) found in the
    path with the operative system path separator. This function does nothing if the
    OS is Windows, and it executes a replacement under Unix or macOS .'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func FromSlash(path string) string`: 用操作系统路径分隔符替换路径中找到的所有`/`（斜杠）。如果操作系统是Windows，则此函数不执行任何操作，并在Unix或macOS下执行替换。'
- en: '`func Glob(pattern string) (matches []string, err error)`: Finds all files
    matching the specified pattern. If there are no matching files, the result is
    `nil`. It doesn''t report eventual errors that occur during path exploration.
    It shares syntax with `Match`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Glob(pattern string) (matches []string, err error)`: 查找与指定模式匹配的所有文件。如果没有匹配的文件，则结果为`nil`。它不报告在路径探索过程中发生的任何错误。它与`Match`共享语法。'
- en: '`func HasPrefix(p, prefix string) bool`: This function is deprecated.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func HasPrefix(p, prefix string) bool`: 此函数已弃用。'
- en: '`func IsAbs(path string) bool`: Shows if the path is absolute or not.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func IsAbs(path string) bool`: 显示路径是否为绝对路径。'
- en: '`func Join(elem ...string) string`: Concatenates multiple path elements by
    joining them with the filepath separator. Note that this also calls `Clean` on
    the result.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Join(elem ...string) string`: 通过使用文件路径分隔符连接多个路径元素来连接它们。请注意，这也在结果上调用`Clean`。'
- en: '`func Match(pattern, name string) (matched bool, err error)`: Verifies that
    the given name matches the pattern, allowing the use of the wild `char` characters
    `*` and `?`, and groups or sequences of characters using square brackets.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Match(pattern, name string) (matched bool, err error)`: 验证给定的名称是否与模式匹配，允许使用通配符字符`*`和`?`，以及使用方括号的组或字符序列。'
- en: '`func Rel(basepath, targpath string) (string, error)`: Returns the relative
    path from the base to the target path, or an error if this is not possible. This
    function calls `Clean` on the result.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Rel(basepath, targpath string) (string, error)`: 返回从基本路径到目标路径的相对路径，如果不可能则返回错误。此函数在结果上调用`Clean`。'
- en: '`func Split(path string) (dir, file string)`: Divides the path into two parts
    using the final trailing slash. The result is usually the parent path and the
    file name of the input path. If there is no separator, `dir` will be empty and
    the file will be the path itself.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Split(path string) (dir, file string)`: 使用最终的尾部斜杠将路径分成两部分。结果通常是输入路径的父路径和文件名。如果没有分隔符，`dir`将为空，文件将是路径本身。'
- en: '`func SplitList(path string) []string`: Returns a list of paths, separating
    them with the list separator character, which is `:` in Unix and macOS and `;`
    in Windows.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func SplitList(path string) []string`: 使用列表分隔符字符返回路径列表，Unix和macOS中为`:`，Windows中为`;`。'
- en: '`func ToSlash(path string) string`: Operates the opposite substitution that
    the `FromSlash` function executes, changing each path separator to a `/`, doing
    nothing on Unix and macOS, and executing the replacement in Windows.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func ToSlash(path string) string`: 执行与`FromSlash`函数执行的相反替换，将每个路径分隔符更改为`/`，在Unix和macOS上不执行任何操作，并在Windows上执行替换。'
- en: '`func VolumeName(path string) string`: This does nothing in platforms that
    aren''t Windows. It returns the path component which refers to the volume. This
    is done for both local paths and network resources.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func VolumeName(path string) string`: 在非Windows平台上不执行任何操作。它返回引用卷的路径组件。这对本地路径和网络资源都适用。'
- en: '`func Walk(root string, walkFn WalkFunc)` `error`: Starting from the root directory,
    this function travels recursively through the file tree, executing the walk function
    for each entry of the tree. If the walk function returns an error, the walk stops
    and that error is returned. The function is defined as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Walk(root string, walkFn WalkFunc)` `error`: 从根目录开始，此函数递归地遍历文件树，对树的每个条目执行遍历函数。如果遍历函数返回错误，则遍历停止，并返回该错误。该函数定义如下：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before moving on to the next example, let''s introduce an important variable:
    `os.Args`. This variable contains at least one value, which is the path that invoked
    the current process. This can be followed by eventual arguments that are specified
    in the same call.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个示例之前，让我们介绍一个重要的变量：`os.Args`。此变量至少包含一个值，即调用当前进程的路径。这可以跟随在同一调用中指定的可能参数。
- en: We want to realize a small application that lists and counts the number of files
    in a directory. We can use some of the tools we just saw to achieve this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要实现一个小应用程序，列出并计算目录中的文件数量。我们可以使用刚刚看到的一些工具来实现这一点。
- en: 'An example of the list and count files is shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中显示了列出和计数文件的示例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reading from files
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: Getting the contents of a file can be done with an auxiliary function in the
    `io/ioutil` package, as well as with the  `ReadFile` function, which opens, reads,
    and closes the file at once. This uses a small buffer (512 bytes) and loads the
    whole content in memory. This is not a good idea if the file size is very large,
    unknown, or if the content of the file can be processed one part at a time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`io/ioutil`包中的辅助函数，以及`ReadFile`函数来获取文件的内容，该函数一次性打开、读取和关闭文件。这使用一个小缓冲区（512字节）并将整个内容加载到内存中。如果文件大小非常大，未知，或者文件内容可以一次处理一部分，这不是一个好主意。
- en: Reading a huge file from disk at once means copying all the file's content into
    the primary memory, which is a limited resource. This can cause memory shortages,
    as well as runtime errors. Reading chunks of a file at a time can help read the
    content of big files without causing huge memory usage. This is because the same
    part of the memory will be reused when reading the next chunk.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一次从磁盘读取一个巨大的文件意味着将所有文件内容复制到主内存中，这是有限的资源。这可能会导致内存不足，以及运行时错误。一次读取文件的一部分可以帮助读取大文件的内容，而不会导致大量内存使用。这是因为在读取下一块时将重用相同部分的内存。
- en: 'An example of reading all the content at once is shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性读取所有内容的示例如下所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Reader interface
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取器接口
- en: 'For all operations that read from a disk, there''s an interface that is paramount:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有从磁盘读取的操作，有一个至关重要的接口：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Its job is really simple – fill the given slice of bytes with the content that's
    been read and return the number of bytes that's been read and an error, if one
    occurs. There is a special error variable that's defined by the `io` package,
    called `EOF` (**End Of File**), which should be returned when there is no more
    input available.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作非常简单 - 用已读取的内容填充给定的字节片，并返回已读取的字节数和错误（如果发生错误）。有一个特殊的错误变量由`io`包定义，称为`EOF`（**文件结束**），当没有更多输入可用时应返回它。
- en: A reader makes it possible to process data in chunks (the size is determined
    by the slice), and if the same slice is reused for the operations that follow,
    the resulting program is consistently more memory efficient because it is using
    the same limited part of the memory that allocates the slice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 读取器使得可以以块的方式处理数据（大小由切片确定），如果同一切片用于后续操作，则由此产生的程序始终更加内存高效，因为它使用了相同的有限内存部分来分配切片。
- en: The file structure
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件结构
- en: The `os.File` type satisfies the reader interface and is the main actor that's
    used to interact with file contents. The most common way to obtain an instance
    for reading purposes is with the `os.Open` function. It's very important to remember
    to close a file when you're done using it – this will not be obvious with short-lived
    programs, but if an application keeps opening files without closing the ones that
    it's done with, the application will reach the limit of open files imposed by
    the operating system and start failing the opening operations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.File`类型满足读取器接口，并且是用于与文件内容交互的主要角色。获取用于读取目的的实例的最常见方法是使用`os.Open`函数。在使用完文件后记得关闭文件非常重要
    - 对于短暂存在的程序可能不明显，但如果一个应用程序不断打开文件而不关闭已经完成的文件，应用程序将达到操作系统强加的打开文件限制并开始失败打开操作。'
- en: 'The shell offers a couple of utilities, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: shell提供了一些实用程序，如下所示：
- en: One to get the limit of open files – `ulimit -n`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取打开文件的限制 - `ulimit -n`
- en: Another to check how many files are open by a certain process – `lsof -p PID`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个是检查某个进程打开了多少文件 - `lsof -p PID`
- en: The previous example opens a file just to show its contents to standard output,
    which it does by loading all its content in memory. This can be easily optimized
    with the tools we just mentioned. In the following example, we are using a small
    buffer and printing its content before it gets overridden by the next read, using
    a small buffer to keep memory usage at a minimum.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例仅打开文件以将其内容显示到标准输出，通过将所有内容加载到内存中来实现。可以很容易地通过刚才提到的工具进行优化。在下面的示例中，我们使用一个小缓冲区并在下一次读取之前打印其内容，使用小缓冲区以将内存使用量保持在最低。
- en: 'An example of using a byte array as a buffer is shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字节数组作为缓冲区的示例如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The reading loop, if everything works as expected, will continue executing read
    operations until the file content is over. In that case, the reading loop will
    return an `io.EOF` error, which shows that there is no more content available.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，读取循环将继续执行读取操作，直到文件内容结束。在这种情况下，读取循环将返回一个`io.EOF`错误，表明没有更多内容可用。
- en: Using buffers
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓冲区
- en: A **data buffer**, or just a buffer, is a part of memory that is used to store
    temporary data while it is moved. Byte buffers are implemented in the `bytes`
    package, and they are implemented by an underlying slice that is capable of growing
    every time the amount of data that needs to be stored will not fit.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据缓冲区**，或者只是一个缓冲区，是用于在数据移动时存储临时数据的一部分内存。字节缓冲区是在`bytes`包中实现的，并且由一个底层切片实现，该切片能够在需要存储的数据量不适合时进行扩展。'
- en: If new buffers get allocated each time, the old ones will eventually be cleaned
    up by the GC itself, which is not an optimal solution. It's always better to reuse
    buffers instead of allocating new ones. This is because they make it possible
    to reset the slice while keeping the capacity as it is (the array doesn't get
    cleared or collected by the GC).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次分配新缓冲区，旧缓冲区最终将被GC自行清理，这不是一个最佳解决方案。最好始终重用缓冲区而不是分配新的。这是因为它们使得可以重置切片同时保持容量不变（数组不会被GC清除或收集）。
- en: A buffer also offers two functions to show its underlying length and capacity.
    In the following example, we can see how to reuse a buffer with `Buffer.Reset`
    and how to keep track of its capacity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区还提供了两个函数来显示其底层长度和容量。在下面的示例中，我们可以看到如何使用`Buffer.Reset`重用缓冲区以及如何跟踪其容量。
- en: 'An example of buffer reuse and its underlying capacity is shown in the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲重用及其底层容量的示例如下所示：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Peeking content
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窥视内容
- en: In the previous example, we fixed a number of bytes in order to store the content
    at every read before printing it. Some functionality is offered by the `bufio`
    package that makes it possible to use an underlying buffer that is not directly
    controlled by the user, and makes it possible to execute a very important operation
    named *peek*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们固定了一定数量的字节，以便在打印之前存储内容。`bufio`包提供了一些功能，使得可以使用用户无法直接控制的底层缓冲区，并且可以执行一个非常重要的操作，名为*peek*。
- en: '**Peeking** is the ability to read content without advancing the reader cursor.
    Here, under the hood, the peeked data is stored in the buffer. Each reading operation
    checks whether there''s data in this buffer and if there is any, that data is
    returned while removing it from the buffer. This works like a queue (first in,
    first out).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Peeking** 是在不推进阅读器光标的情况下读取内容的能力。在这里，在幕后，被窥视的数据存储在缓冲区中。每次读取操作都会检查这个缓冲区是否有数据，如果有，那么数据将被返回并从缓冲区中移除。这就像一个队列（先进先出）。'
- en: 'The possibilities that this simple operation opens are endless, and they all
    derive from peeking until the desired sequence of data is found, and then the
    interested chunk is actually read. The most common uses of this operation include
    the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单操作打开的可能性是无穷的，它们都源于窥视直到找到所需的数据序列，然后实际读取感兴趣的块。这个操作的最常见用途包括以下内容：
- en: The buffers keeps reading from the reader until it finds a newline character
    (read one line at time).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区从阅读器中读取，直到找到换行符（一次读取一行）。
- en: The same operation is used until a space is found (read one word at a time).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直到找到空格为止（一次读取一个单词）。
- en: 'The structure that allows an application to achieve this behavior is `bufio.Scanner`.
    This makes it possible to define what the splitting function is and has the following
    type:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 允许应用程序实现这种行为的结构是`bufio.Scanner`。这使得可以定义分割函数是什么，并具有以下类型：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function stops when an error is returned, otherwise it returns the number
    of bytes to advance in the content, and eventually a token. The implemented functions
    in the package are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回错误时，此函数停止，否则它返回要在内容中前进的字节数，最终返回一个标记。包中实现的函数如下：
- en: '`ScanBytes`: Byte tokens'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScanBytes`：字节标记'
- en: '`ScanRunes`: Runes tokens'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScanRunes`：符文标记'
- en: '`ScanWord`: Words tokens'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScanWord`：单词标记'
- en: '`ScanLines`: Line tokens'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScanLines`：行标记'
- en: We could implement a file reader that counts the number of lines with just a
    reader. The resulting program will try to emulate what the Unix `wc -l` command
    does.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个文件阅读器，只需一个阅读器就可以计算行数。结果程序将尝试模拟Unix的`wc -l`命令的功能。
- en: 'An example of printing a file and counting lines is shown in the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个打印文件并计算行数的示例在以下代码中显示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Closer and seeker
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Closer和seeker
- en: 'There are two other interfaces that are related to readers: `io.Closer` and
    `io.Seeker`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个与阅读器相关的接口：`io.Closer`和`io.Seeker`：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'These are usually combined with `io.Reader`, and the resulting interfaces are
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常与`io.Reader`结合使用，得到的接口如下：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Close` method ensures that the resource gets released and avoids leaks,
    while the `Seek` method makes it possible to move the cursor of the current object
    (for example, a `Writer`) to the desired offset from the start/end of the file,
    or from its current position.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Close`方法确保资源被释放并避免泄漏，而`Seek`方法使得可以移动当前对象（例如`Writer`）的光标到文件的起始/结束位置，或者从当前位置移动。'
- en: The `os.File` structure implements this method so that it satisfies all the
    listed interfaces. It is possible to close the file when the operations are concluded,
    or to move the current cursor around, depending on what you are trying to achieve.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.File` 结构实现了这个方法，以满足所有列出的接口。在操作结束时关闭文件是可能的，或者根据你想要实现的目标移动当前光标。'
- en: Writing to file
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: As we have seen for reading, there are different ways to write files, each one
    with its own flaws and strengths. In the `ioutil` package, for instance, we have
    another function called `WriteFile` that allows us to execute the whole operation
    in one line. This includes opening the file, writing its contents, and then closing
    it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在阅读中所看到的，写入文件有不同的方式，每种方式都有其自身的缺点和优势。例如，在`ioutil`包中，我们有另一个名为`WriteFile`的函数，它允许我们在一行中执行整个操作。这包括打开文件，写入其内容，然后关闭文件。
- en: 'An example of writing all a file''s content at once is shown in the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个一次性写入文件所有内容的示例在以下代码中显示：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This example writes all the content at once in a single operation. This requires
    that we allocate all the content in memory using a byte slice. If the content
    is too large, memory usage can become a problem for the OS, which could kill the
    process of our application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例一次性写入所有内容。这要求我们使用一个字节切片在内存中分配所有内容。如果内容太大，内存使用可能会成为操作系统的问题，这可能会终止我们的应用程序的进程。
- en: If the size of the content isn't very big and the application is short-lived,
    it's not a problem if the content gets loaded in memory and written with a single
    operation. This isn't the best practice for long-lived applications, which are
    executing reads and writes to many different files. They have to allocate all
    the content in memory, and that memory will be released by the GC at some point
    – this operation is not cost-free, which means that is has disadvantages regarding
    memory usage and performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内容的大小不是很大，而且应用程序的生命周期很短，那么如果内容加载到内存中并用单个操作写入，这不是问题。这对于长期运行的应用程序来说不是最佳实践，这些应用程序对许多不同的文件进行读取和写入。它们必须在内存中分配所有内容，而该内存将在某个时刻被GC释放
    - 这个操作不是免费的，这意味着它在内存使用和性能方面有缺点。
- en: Writer interface
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Writer接口
- en: 'The same principle that is valid for reading also applies for writing – there''s
    an interface in the `io` package that determines writing behaviors, as shown in
    the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于写入也适用于阅读的相同原则 - 在`io`包中有一个确定写入行为的接口，如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `io.Writer` interface defines one method that, given a slice of bytes, returns
    how many of them have been written and/or if there's been any errors. A writer
    makes it possible to write data one chunk at a time without there being a requirement
    to have it all at once. The `os.File` struct also happens to be a writer, and
    can be used in such a fashion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer`接口定义了一个方法，给定一个字节片，返回已写入多少字节以及是否有任何错误。写入器使得可以一次写入一块数据，而无需一次性拥有所有数据。`os.File`结构也恰好是一个写入器，并且可以以这种方式使用。'
- en: We can use a slice of bytes as a buffer to write information piece by piece.
    In the following example, we will try to combine reading from the previous section
    with writing, using the `io.Seeker` capabilities to reverse its content before
    writing it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字节片作为缓冲区逐段写入信息。在下面的示例中，我们将尝试将从上一节读取的内容与写入相结合，使用`io.Seeker`的能力在写入之前反转其内容。
- en: 'An example of reversing the contents of a file is shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例显示了反转文件内容的示例：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After moving to the end of the file and defining a byte buffer, we enter a
    loop that goes a little backwards in the file, then reads a section of it, as
    shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动到文件末尾并定义字节缓冲区后，我们进入一个循环，该循环在文件中稍微向后移动，然后读取其中的一部分，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we reverse the content and write it to the destination, as shown in the
    following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将内容反转并将其写入目标，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Buffers and format
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区和格式
- en: 'In the previous section, we saw how `bytes.Buffer` can be used to store data
    temporarily and how it handles its own growth by appending the underlying slice.
    The `fmt` package extensively uses buffers to execute its operations; these aren''t
    the ones in the bytes package for dependency reasons. This approach is inherent
    to one of Go''s proverbs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到`bytes.Buffer`可以用于临时存储数据，并且通过附加底层切片来处理自己的增长。`fmt`包广泛使用缓冲区来执行其操作；由于依赖原因，这些不是字节包中的缓冲区。这种方法是Go的谚语之一：
- en: '"A little copy is better than a little dependency."'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “少量复制胜过少量依赖。”
- en: If you have to import a package to use one function or type, you should consider
    just copying the necessary code into your own package. If a package contains much
    more than what you need, copying allows you to reduce the final size of the binary.
    You can also customize the code and tailor it to your needs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须导入一个包来使用一个函数或类型，那么应该考虑将必要的代码复制到自己的包中。如果一个包包含的内容远远超出了你的需求，复制可以减少最终二进制文件的大小。您还可以自定义代码并根据自己的需求进行调整。
- en: 'Another use of buffers is to compose a message before writing it. Let''s write
    some code so that we can use a buffer to format a list of books:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区的另一个用途是在写入之前组成消息。让我们编写一些代码，以便我们可以使用缓冲区格式化书籍列表：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The buffer is used to compose the book description, where the year is omitted
    if it''s not present. This is very efficient when handling bytes and even better
    if the buffer is reused each time. If the output of this kind of operation should
    be a string, there is a very similar struct in the `strings` package called `Builder` that
    has the same write methods but some differences, such as the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区用于组成书籍描述，如果不存在年份，则会被省略。在处理字节时，这是非常高效的，如果每次都重用缓冲区，效果会更好。如果此类操作的输出应该是一个字符串，则`strings`包中有一个非常相似的结构称为`Builder`，它具有相同的写入方法，但也有一些不同之处，例如以下内容：
- en: The `String()` method uses the `unsafe` package to convert the bytes into a
    string, instead of copying them.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String()`方法使用`unsafe`包将字节转换为字符串，而不是复制它们。'
- en: It is not permitted to copy a `strings.Builder` and then write to the copy since
    this causes a `panic`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许复制`strings.Builder`，然后对副本进行写入，因为这会导致`panic`。
- en: Efficient writing
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效写入
- en: Each time the `os.File` method, that is, `Write`, is executed, this translates
    to a system call, which is an operation that comes with some overhead. Generally
    speaking, it's a good idea, to minimize the number of operations by writing more
    data at once, thus reducing the time that's spent on such calls.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行`os.File`方法，即`Write`，这将转换为系统调用，这是一个带有一些开销的操作。一般来说，通过一次写入更多的数据来减少在此类调用上花费的时间是一个好主意，从而最小化操作的数量。
- en: 'The `bufio.Writer` struct is a writer that wraps another writer, like `os.File`,
    and executes write operations only when the buffer is full. This makes it possible
    to execute a forced write with the `Flush` method, which is generally reserved
    until the end of the writing process. A good pattern of using a buffer would be
    the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio.Writer`结构是一个包装另一个写入器（如`os.File`）的写入器，并且仅在缓冲区满时执行写入操作。这使得可以使用`Flush`方法执行强制写入，通常保留到写入过程的结束。使用缓冲区的一个良好模式如下：'
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`defer` statements are executed in reverse order before returning the current
    function, so the first `Flush` ensures that whatever is still on the buffer gets
    written, and then `Close` actually closes the file. If the two operations were
    executed in reverse order, flush would have tried to write a closed file, returning
    an error, and failed to write the last chunk of information.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`语句在返回当前函数之前以相反的顺序执行，因此第一个`Flush`确保将缓冲区中的任何内容写入，然后`Close`实际关闭文件。如果两个操作以相反的顺序执行，flush将尝试写入一个关闭的文件，返回错误，并且无法写入最后一块信息。'
- en: File modes
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件模式
- en: We saw that the `os.OpenFile` function makes it possible to choose how to open
    a file with the file mode, which is a `uint32` where each bit has a meaning (like
    Unix files and folder permissions). The `os` package offers a series of values,
    each one specifying a mode, and the correct way to combine them is with `|` (bitwise
    OR).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`os.OpenFile`函数使得可以选择如何使用文件模式打开文件，文件模式是一个`uint32`，其中每个位都有特定含义（类似于Unix文件和文件夹权限）。`os`包提供了一系列值，每个值都指定一种模式，正确的组合方式是使用`|`（按位或）。
- en: 'The following code shows the ones that are available, and have been taken directly
    from Go''s source:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了可用的代码，并且直接从Go的源代码中获取：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first three represent the operation that''s allowed (read, write, or both),
    and the others are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个表示允许的操作（读、写或两者），其他的如下：
- en: '`O_APPEND`: Before each write, the file offset is positioned at the end of
    the file.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O_APPEND`: 在每次写入之前，文件偏移量被定位在文件末尾。'
- en: '`O_CREATE`: Makes it possible to create the file if it doesn''t exist.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O_CREATE`: 可以创建文件（如果文件不存在）。'
- en: '`O_EXCL`: If this is used with create, it fails if the file already exists
    (exclusive creation).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O_EXCL`: 如果与创建一起使用，如果文件已经存在，则失败（独占创建）。'
- en: '`O_SYNC`: Executes a read/write operation and verifies its competition.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O_SYNC`: 执行读/写操作并验证其完成。'
- en: '`O_TRUNC`: If the file exists, its size is truncated to `0`.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O_TRUNC`: 如果文件存在，其大小将被截断为`0`。'
- en: Other operations
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他操作
- en: Read and write are not the only operations that can be executed on a file. In
    the following section, we'll look at how to use them using the `os` package.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 读和写不是文件上可以执行的唯一操作。在下一节中，我们将看看如何使用`os`包来执行它们。
- en: Create
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建
- en: 'In order to create an empty file, we can call a helper function called `Create`,
    which opens a new file with a `0666` permission and truncates it if it doesn''t
    exist. Alternatively, we can use `OpenFile` with the `O_CREATE|O_TRUNCATE` mode
    to specify custom permissions, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个空文件，可以调用一个名为`Create`的辅助函数，它以`0666`权限打开一个新文件，并在文件不存在时将其截断。或者，我们可以使用`OpenFile`与`O_CREATE|O_TRUNCATE`模式来指定自定义权限，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Truncate
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截断
- en: 'To truncate the content of a file under a certain dimension, and leave the
    file untouched if it''s smaller, there is the `os.Truncate` method. Its usage
    is pretty simple, as shown in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要截断文件内容到一定尺寸，并且如果文件较小则保持不变，可以使用`os.Truncate`方法。其用法非常简单，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Delete
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'In order to delete a file, there is another simple function, called `os.Remove`,
    as shown in the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除文件，还有另一个简单的函数，称为`os.Remove`，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Move
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动
- en: The `os.Rename` function makes it possible to change a file name and/or its
    directory. Note that this operation replaces the destination file if it already
    exists.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Rename`函数可以更改文件名和/或其目录。请注意，如果目标文件已经存在，此操作将替换目标文件。'
- en: 'The code for changing a file''s name or its directory is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件名或其目录的代码如下：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Copy
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: 'There''s no unique function that makes it possible to copy a file, but this
    can easily be done with a reader and a writer with the `io.Copy` function. The
    following example shows how to use it to copy from one file to another:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 没有唯一的函数可以复制文件，但可以使用`io.Copy`函数轻松实现。下面的示例显示了如何使用它从一个文件复制到另一个文件：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Stats
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计
- en: 'The `os` package offers the `FileInfo` interface, which returns the metadata
    of a file, as shown in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包提供了`FileInfo`接口，返回文件的元数据，如下面的代码所示：'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `os.Stat` function returns information about the file with the specified
    path.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Stat`函数返回指定路径文件的信息。'
- en: Changing properties
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改属性
- en: 'In order to interact with the filesystem and change these properties, three
    functions are available:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与文件系统交互并更改这些属性，有三个函数可用：
- en: '`func Chmod(name string, mode FileMode) error`: Changes the permissions of
    a file'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Chmod(name string, mode FileMode) error`: 更改文件的权限'
- en: '`func Chown(name string, uid, gid int) error`: Changes the owner and group
    of a file'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Chown(name string, uid, gid int) error`: 更改文件的所有者和组'
- en: '`func Chtimes(name string, atime time.Time, mtime time.Time) error`: Changes
    the access and modification time of a file'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func Chtimes(name string, atime time.Time, mtime time.Time) error`: 更改文件的访问和修改时间'
- en: Third-party packages
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方包
- en: The community offers many packages that accomplish all kinds of tasks. We will
    take a quick look at some of these in this section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 社区提供了许多可以完成各种任务的包。我们将在本节中快速浏览其中一些。
- en: Virtual filesystems
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟文件系统
- en: Files are a struct in Go, a concrete type, and there's no abstraction around
    them, whereas a file's information is represented by `os.FileInfo`, which is an
    interface. This is slightly inconsistent, and there have been many attempts to
    create a full and consistent abstraction on the filesystem, commonly referred
    to as a *virtual filesystem*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，文件是一个具体类型的结构体，没有围绕它们的抽象，而文件的信息由`os.FileInfo`表示，它是一个接口。这有点不一致，已经有许多尝试创建一个完整和一致的文件系统抽象，通常称为*虚拟文件系统*。
- en: 'Two of the most used packages are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的两个包如下：
- en: '`vfs`: [github.com/blang/vfs](https://github.com/blang/vfs)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vfs`: [github.com/blang/vfs](https://github.com/blang/vfs)'
- en: '`afero`: [github.com/spf13/afero](https://github.com/spf13/afero)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afero`: [github.com/spf13/afero](https://github.com/spf13/afero)'
- en: Even if they are developed separately, they both do the same thing – they define
    an interface with all the methods of `os.File`, and then they define an interface
    that implements the function that's available in the `os` package, like creating,
    opening, and deleting files, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们是分开开发的，它们都做同样的事情——它们定义了一个具有`os.File`所有方法的接口，然后定义了一个实现`os`包中可用的函数的接口，比如创建、打开和删除文件等。
- en: They offer a version based on `os.File` that's implemented using the standard
    package, but there's also a memory version that uses data structures that emulate
    a filesystem. This can be very useful for building a test for any package.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它们提供了基于标准包实现的`os.File`版本，但也有一个使用模拟文件系统的数据结构的内存版本。这对于为任何包构建测试非常有用。
- en: Filesystem events
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统事件
- en: Go has some experimental features in the `golang.org/x/` package that are located
    under Go's GitHub handler ([https://github.com/golang/](https://github.com/golang/)).
    The `golang.org/x/sys` package is part of this list and includes a subpackage
    dedicated to Unix system events. This has been used to build a feature that is
    missing from Go's file functionality and can be really useful – observing a certain
    path for events on files like creation, deletion, and update.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Go在`golang.org/x/`包中有一些实验性功能，这些功能位于Go的GitHub处理程序下（[https://github.com/golang/](https://github.com/golang/)）。`golang.org/x/sys`包是其中之一，包括一个专门用于Unix系统事件的子包。这已被用于构建一个在Go的文件功能中缺失的功能，可以非常有用
    - 观察某个路径上的文件事件，如创建、删除和更新。
- en: 'The two most famous implementations are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的两个实现如下：
- en: '`notify`: [github.com/rjeczalik/notify](https://github.com/rjeczalik/notify)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`：[github.com/rjeczalik/notify](https://github.com/rjeczalik/notify)'
- en: '`fsnotify`: [github.com/fsnotify/fsnotify](https://github.com/fsnotify/fsnotify)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fsnotify`：[github.com/fsnotify/fsnotify](https://github.com/fsnotify/fsnotify)'
- en: Both packages expose a function that allows the creation of watchers. Watchers
    are structures that contain channels that are in charge of delivering file events.
    They also expose another function that 's responsible for terminating/closing
    the watchers and underlying channels.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个包都公开了一个函数，允许创建观察者。观察者是包含负责传递文件事件的通道的结构。它们还公开了另一个负责终止/关闭观察者和底层通道的函数。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at an overview of how to execute file operations
    in Go. In order to locate files, an extensive array of functions are offered by
    the `filepath` package. These can help you execute all kind of operations, from
    composing paths to extracting elements from it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了如何在Go中执行文件操作。为了定位文件，`filepath`包提供了广泛的函数数组。这些函数可以帮助您执行各种操作，从组合路径到从中提取元素。
- en: We also looked at how to read an operation using various methods, from the easiest
    and less memory efficient ones that are located in the `io/ioutil` package to
    the ones that require an `io.Writer` implementation to read a fixed chunk of bytes.
    The importance of the ability to peek content, as implemented in the `bufio` package,
    allows for a whole set of operations like read word or read line, which stop the
    reading operation when a token is found. There are other interfaces that are satisfied
    by files that are very useful; for example, `io.Closer` ensures that the resource
    is released, and `io.Seeker` is used to move the reading cursor around without
    the need to actually read the file and discard the output.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看了如何使用各种方法读取操作，从位于`io/ioutil`包中的最简单和内存效率较低的方法到需要`io.Writer`实现来读取固定大小的字节块的方法。在`bufio`包中实现的查看内容的能力的重要性，允许进行一整套操作，如读取单词或读取行，当找到一个标记时停止读取操作。有其他对文件非常有用的接口；例如，`io.Closer`确保资源被释放，`io.Seeker`用于在不需要实际读取文件和丢弃输出的情况下移动读取光标。
- en: Writing a slice of bytes to a file can be achieved in different ways – the `io/ioutil`
    package makes it possible to do so with a function call, while for more complex
    or more memory-efficient operations, there's the `io.Writer` interface. This makes
    it possible to write a slice of bytes at a time, and can be used by the `fmt`
    package to print formatted data. The buffered writing is used to reduce the amount
    of actual writing on the disk. This is done with a buffer that collects the content,
    which then transfers it to a disk every time it gets full.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节切片写入文件可以通过不同的方式实现 - `io/ioutil`包可以通过函数调用实现，而对于更复杂或更节省内存的操作，可以使用`io.Writer`接口。这使得可以一次写入一个字节切片，并且可以被`fmt`包用于打印格式化数据。缓冲写入用于减少在磁盘上的实际写入量。这是通过一个收集内容的缓冲区来实现的，然后每次缓冲区满时将其传输到磁盘上。
- en: Finally, we saw how to accomplish other file operations on the filesystem (creating,
    deleting, copying/moving, and changing a file's attributes) and took a look at
    some of the filesystem-related third-party packages, that is, virtual filesystem
    abstraction and filesystem events notifications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何在文件系统上执行其他文件操作（创建、删除、复制/移动和更改文件属性），并查看了一些与文件系统相关的第三方包，即虚拟文件系统抽象和文件系统事件通知。
- en: The next chapter will be about streams, and will focus on all the instances
    of readers and writers that are not related to the filesystem.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论流，并将重点放在与文件系统无关的所有读取器和写入器的实例上。
- en: Questions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the difference between absolute and relative paths?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绝对路径和相对路径有什么区别？
- en: How do you obtain or change the current working directory?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获取或更改当前工作目录？
- en: What are the advantages and downfalls of using `ioutil.ReadAll`?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ioutil.ReadAll`的优点和缺点是什么？
- en: Why are buffers important for reading operations?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么缓冲对于读取操作很重要？
- en: When should you use `ioutil.WriteFile`?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`ioutil.WriteFile`？
- en: Which operations are available when using a buffered reader that allows peeking?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用允许查看的缓冲读取器时有哪些操作可用？
- en: When is it better to read content using a byte buffer?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时最好使用字节缓冲区读取内容？
- en: How can buffers be used for writing? What's the advantage of using them?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲区如何用于写入？使用它们有什么优势？
