- en: Network Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程
- en: This chapter will cover network programming. This will allow our applications
    to communicate with other programs that are running on any remote computer, on
    the same local network, or even on the internet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖网络编程。这将使我们的应用程序能够与在任何远程计算机上运行的其他程序通信，或者在同一本地网络上，甚至在互联网上。
- en: We will start with some theory about network and architectures. We will then
    discuss socket-level communication and explain how to create a web server. Finally,
    we will discuss how the Go built-in template engine works.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网络和体系结构的一些理论开始。然后，我们将讨论套接字级通信，并解释如何创建Web服务器。最后，我们将讨论Go内置模板引擎的工作原理。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Networking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Socket programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字编程
- en: Web servers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器
- en: Template engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板引擎
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, you can refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，您可以参考[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: Additionally, it requires OpenSSL to be installed on your machine. Many Linux
    distributions are already shipped with some OpenSSL versions. It can also be installed
    on Windows, using the official installer or a third-party package manager, such
    as Chocolatey or Scoop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它需要在您的计算机上安装OpenSSL。许多Linux发行版已经附带了一些OpenSSL版本。它也可以在Windows上安装，使用官方安装程序或第三方软件包管理器，如Chocolatey或Scoop。
- en: Communicating via networks
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过网络通信
- en: Communication between applications can happen through a network, even if the
    applications are on the same machine. In order to transfer information, they need
    to establish a common protocol that specifies what happens all the way from the
    application to the wire.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序位于同一台机器上，应用程序之间也可以通过网络进行通信。为了传输信息，它们需要建立一个共同的协议，该协议规定了从应用程序到传输介质的所有过程。
- en: OSI model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSI模型
- en: The **Open Systems Interconnect** (**OSI**) model is a theoretical model that
    dates back to the early 1970s. It defines a standard of communication that works
    regardless of the physical or technical structure of a network, with the goal
    of providing interoperability for different networks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放系统互联**（**OSI**）模型是一个理论模型，可以追溯到20世纪70年代初。它定义了一种通信标准，无论网络的物理或技术结构如何，都可以提供不同网络的互操作性。'
- en: The model defines seven different layers, numbered from one to seven, and each
    layer has a higher level of abstraction to the previous one. The first three layers
    are often referred to as **media layers**, while the other four are the **host
    layers**. Let's examine each, one by one, in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型定义了七个不同的层，从一到七编号，每一层的抽象级别都比前一层更高。前三层通常被称为**媒体层**，而后四层则是**主机层**。让我们在以下各节中逐一检查每一层。
- en: Layer 1 – Physical layer
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1层-物理层
- en: The very first layer of the OSI model is the physical one, which is in charge
    of the transmission of unprocessed data from a device, similar to an Ethernet
    port, and its transmission medium, such as an Ethernet cable. This layer defines
    all the characteristics that are related to the physical/material nature of the
    connection—size, shape, voltages of the connector, frequencies, and timings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型的第一层是物理层，负责从设备传输未经处理的数据，类似于以太网端口，以及传输介质，如以太网电缆。该层定义了与连接的物理/材料性质相关的所有特征-连接器的大小、形状、电压、频率和时序。
- en: 'Another aspect defined by the physical layer is the direction of the transmission,
    which can be one of the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 物理层定义的另一个方面是传输的方向，可以是以下之一：
- en: '**Simplex**: The communication is one way.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单工**：通信是单向的。'
- en: '**Half duplex**: The communication is two way, but the communication happens
    only in one direction at a time.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半双工**：通信是双向的，但通信只能单向进行。'
- en: '**Full duplex**: Two way-communication, where both ends can communicate at
    the same time.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全双工**：双向通信，两端可以同时通信。'
- en: Many well-known technologies, including Bluetooth and Ethernet, include a definition
    of the physical layer they are using.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 许多知名技术，包括蓝牙和以太网，都包括它们正在使用的物理层的定义。
- en: Layer 2 – Data link layer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2层-数据链路层
- en: 'The next layer is the data link, which defines how the data transfer should
    happen between two nodes that are directly connected. It is responsible for the
    following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层是数据链路层，它定义了两个直接连接的节点之间的数据传输应该如何进行。它负责以下内容：
- en: Detection of communication errors in the first layer
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测第一层的通信错误
- en: Correction of the physical errors
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纠正物理错误
- en: Control of the flow/transmission rate between nodes
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制节点之间的流/传输速率
- en: Connection termination
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接终止
- en: Some real-world examples of data link layers definition are the ones for Ethernet
    (802.3) and Wi-Fi (802.11).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层定义的一些现实世界示例是以太网（802.3）和Wi-Fi（802.11）。
- en: Layer 3 – Network layer
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3层-网络层
- en: The network layer is the next layer, and it focuses on sequences of data, called
    packets, that can have a variable length. A packet is transmitted from one node
    to another, and these two nodes could be located on the same network or on different
    ones.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层是下一层，它专注于称为数据包的数据序列，可以具有可变长度。数据包从一个节点传输到另一个节点，这两个节点可以位于同一网络上，也可以位于不同的网络上。
- en: This layer defines the network as a series of nodes connected to the same medium,
    identified by the previous two layers. The network is capable of delivering a
    message, knowing only its destination address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该层将网络定义为一系列连接到相同介质的节点，由前两层标识。网络能够传递消息，只知道其目的地地址。
- en: Layer 4 – Transport layer
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4层-传输层
- en: The fourth layer is transport, which ensures that packets go from sender to
    receiver. This is achieved with **acknowledgement** (**ACK**) and **negative-acknowledgement**
    (**NACK**) messages from the destination, which can trigger a repetition of the
    messages, until they are received correctly. There are also other mechanisms in
    play, such as splitting a message into chunks for transmission (segmentation),
    reassembling the parts in a single message (desegmentation), and checking if the
    data was sent and received successfully (error control).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第四层是传输层，确保数据包从发送方到接收方。这是通过目的地发送**确认**（**ACK**）和**否认确认**（**NACK**）消息来实现的，这些消息可以触发消息的重复，直到它们被正确接收。还有其他机制在起作用，例如将消息分割成块进行传输（分段），将部分重新组装成单个消息（去分段），并检查数据是否成功发送和接收（错误控制）。
- en: The OSI model specifies five different transport protocols—TP0, TP1, TP2, TP3,
    and TP4\. TP0 is the simplest one, which executes only the segmentation and reassembly
    of messages. The other classes add other functionalities on top of it—for instance,
    retransmission or timeouts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型规定了五种不同的传输协议 - TP0、TP1、TP2、TP3和TP4。TP0是最简单的，只执行消息的分段和重组。其他类别在其基础上添加其他功能，例如重传或超时。
- en: Layer 5 – Session layer
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五层 - 会话层
- en: The fifth layer introduces the concept of sessions, which is the temporary interactive
    exchange of information between two computers. It is responsible for creating
    connections and terminating them (while keeping track of the sessions) and allowing
    checkpointing and recovery.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第五层引入了会话的概念，这是两台计算机之间临时交互信息的交换。它负责创建连接和终止连接（同时跟踪会话），并允许检查点和恢复。
- en: Layer 6 – Presentation layer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六层 - 表示层
- en: The penultimate layer is the presentation layer, which takes care of syntax
    and semantics between applications, through dealing with complex data representation.
    It allows the last layer to be independent from the encoding used to represent
    the data. The presentation of the OSI model used ASN.1 encoding, but there is
    a wide range of different presentation protocols that are widely used, such as
    XML and JSON.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第二层是表示层，负责处理应用程序之间的语法和语义，通过处理复杂的数据表示。它允许最后一层独立于用于表示数据的编码。OSI模型的表示使用ASN.1编码，但有许多不同的表示协议被广泛使用，例如XML和JSON。
- en: Layer 7 – Application layer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七层 - 应用层
- en: The last layer, the application layer, is the one that communicates with the
    application directly. The application is not considered as a part of the OSI model
    and the layer is responsible for defining the interfaces used by the applications. It
    includes protocols such as FTP, DNS, and SMTP.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层，应用层，是直接与应用程序通信的层。应用程序不被视为OSI模型的一部分，该层负责定义应用程序使用的接口。它包括FTP、DNS和SMTP等协议。
- en: TCP/IP – Internet protocol suite
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP - 互联网协议套件
- en: The **Transmission Control Protocol/Internet Protocol** (**TCP/IP**), or internet
    protocol suite, is another model composed by fewer layers than the OSI, and it
    is a model that has been widely adopted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议/互联网协议**（**TCP/IP**），或者互联网协议套件，是由比OSI模型更少层次组成的模型，被广泛采用。'
- en: Layer 1 – Link layer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一层 - 链路层
- en: The first layer is the link layer, a combination of OSI's physical and data
    links, and it defines how the local networking communications will happen by specifying
    a protocol, such as MAC (which includes Ethernet and Wi-Fi).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第一层是链路层，是OSI的物理和数据链路的组合，它定义了本地网络通信的方式，指定了协议，例如MAC（包括以太网和Wi-Fi）。
- en: Layer 2 – Internet layer
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二层 - 互联网层
- en: The internet layer is the second layer, and it can be compared to the OSI's
    network. It defines a common interface that allows different networks to communicate
    effectively without any awareness of the underlying topology of each one of them.
    This layer is responsible for communications between the nodes in a **Local Area
    Network** (**LAN**) and the global interconnected networks that compose the internet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网层是第二层，可以与OSI的网络进行比较。它定义了一个通用接口，允许不同的网络在不了解彼此的底层拓扑的情况下有效地进行通信。该层负责局域网（LAN）中节点之间的通信，以及构成互联网的全球互联网络之间的通信。
- en: Layer 3 – Transport layer
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三层 - 传输层
- en: The third layer is similar to the fourth OSI layer. It handles the end-to-end
    communication of two devices and it also takes care of the error check and recovery,
    leaving the upper layer unaware of the complexity of the data. It defines two
    main protocols—TCP, which allows the receiver to get the data in the correct sequence
    by using an acknowledgement system, and a **User Data Protocol** (**UDP**), which
    does not apply error control or acknowledgement from the receiver.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第三层类似于第四层OSI。它处理两个设备的端到端通信，还负责错误检查和恢复，使上层不了解数据的复杂性。它定义了两个主要协议 - TCP，通过使用确认系统允许接收方按正确顺序获取数据，以及用户数据协议（UDP），不对接收方应用错误控制或确认。
- en: Layer 4 – Application layer
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四层 - 应用层
- en: The last layer, the application layer, sums up the last three levels of OSI—session,
    presentation, and application. This layer defines the architecture used by the
    applications, such as peer-to-peer or client and server, and the protocols used
    by the applications, such as SSH, HTTP, or SMTP. Each process is an address with
    a virtual endpoint of communication called *port*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层，应用层，总结了OSI的最后三个级别 - 会话、表示和应用。该层定义了应用程序使用的体系结构，例如点对点或客户端和服务器，以及应用程序使用的协议，例如SSH、HTTP或SMTP。每个进程都是一个具有虚拟通信端点的地址，称为*端口*。
- en: Understanding socket programming
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解套接字编程
- en: The Go standard library allows us to easily interact with the transport layer,
    using both TCP and UDP connections. In this section, we will look at how to expose
    a service using a socket and how to look it up and use it from another application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库允许我们轻松地与传输层进行交互，使用TCP和UDP连接。在本节中，我们将看看如何使用套接字公开服务，以及如何在另一个应用程序中查找并使用它。
- en: Network package
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络包
- en: The tools needed to create and handle a TCP connection are located inside the
    `net` package. The main interface of the package is `Conn`, which represents a
    connection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和处理TCP连接所需的工具位于`net`包内。该包的主要接口是`Conn`，表示一个连接。
- en: 'It has four implementations:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它有四种实现：
- en: '`IPConn`: Raw connection that uses the IP protocol, the one that TCP and UDP
    connection are built on'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPConn`：使用IP协议的原始连接，TCP和UDP连接都是基于它构建的'
- en: '`TCPConn`: An IP connection that uses the TCP protocol'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TCPConn`：使用TCP协议的IP连接'
- en: '`UDPConn`: An IP connection that uses the UDP protocol'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UDPConn`：使用UDP协议的IP连接'
- en: '`UnixConn`: A Unix domain socket, where the connection is meant for processes
    on the same machine'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnixConn`：Unix域套接字，连接用于同一台机器上的进程'
- en: In the following sections, we are going to look at how to use both TCP and UDP
    differently, and also how to use an IPConn to implement a custom implementation
    of a communication protocol.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看看如何不同地使用TCP和UDP，以及如何使用IPConn来实现通信协议的自定义实现。
- en: TCP connections
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP连接
- en: The TCP is the protocol that is most used on the internet, and it enables delivery
    of data (bytes) that are ordered. The main focus of this protocol is reliability,
    which is obtained by establishing a two-way communication, where the receiver
    sends an acknowledgement signal each time it receives a datagram successfully.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: TCP是互联网上最常用的协议，它能够传递有序的数据（字节）。该协议的主要重点是可靠性，通过建立双向通信来实现，接收方在成功接收数据报时发送确认信号。
- en: 'A new connection can be created using the `net.Dial` function. It is a generic
    function that accepts different networks, such as the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`net.Dial`函数创建新连接。这是一个通用函数，可以接受不同的网络，例如以下内容：
- en: '`tcp`, `tcp4` (IPv4-only), `tcp6` (IPv6-only)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcp`，`tcp4`（仅限IPv4），`tcp6`（仅限IPv6）'
- en: '`udp`, `udp4` (IPv4-only), `udp6` (IPv6-only)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udp`，`udp4`（仅限IPv4），`udp6`（仅限IPv6）'
- en: '`ip`, `ip4` (IPv4-only), `ip6` (IPv6-only)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip`，`ip4`（仅限IPv4），`ip6`（仅限IPv6）'
- en: '`unix` (socket stream), `unixgram` (socket datagram), and `unixpacket` (socket
    packet)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unix`（套接字流），`unixgram`（套接字数据报），和`unixpacket`（套接字数据包）'
- en: 'A TCP connection can be created, specifying the `tcp` protocol, together with
    the host and port:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建TCP连接，指定“tcp”协议，以及主机和端口：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A more direct way of creating a connection is `net.DialTCP`, which allows you
    to specify both a local and remote address. It requires you to create a `net.TCPAddr`
    in order to use it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建连接的更直接的方法是`net.DialTCP`，它允许您指定本地和远程地址。使用它需要创建一个`net.TCPAddr`：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In order to receive and handle connections, there is another interface, `net.Listener`,
    which has four different implementations—one per connection type. For connections,
    there is a generic `net.Listen` function and a specific `net.ListenTCP` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收和处理连接，还有另一个接口`net.Listener`，它有四种不同的实现方式，每种连接类型一个。对于连接，有一个通用的`net.Listen`函数和一个特定的`net.ListenTCP`函数。
- en: 'We can try to build a simple application that creates a TCP listener and connects
    to it, sending whatever comes from the standard input. The app should create a
    listener to start a connection in the background, which will send standard input
    to the connection, then accept it, and handle it. We will use the newline character
    as the delimiter for messages. This is shown in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试构建一个简单的应用程序，创建一个TCP监听器并连接到它，发送来自标准输入的任何内容。该应用程序应该创建一个监听器来启动后台连接，将标准输入发送到连接，然后接受并处理它。我们将使用换行符作为消息的分隔符。如下面的代码所示：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The connection creation is pretty simple. It creates the connection and reads
    messages from the standard input and forwards them to the connection by writing
    them:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 连接创建非常简单。它创建连接并从标准输入读取消息，并通过写入将其转发到连接：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our use case, the connection that sends data will be closed with a special
    message, `\q`, which will be interpreted as a command. Accepting a connection
    in the listener creates another connection that represents the ones obtained by
    the dialing operation. The connection created by the listener will be receiving
    the messages from the dialing one and acting accordingly. It will interpret a
    special message, such as`\q`, with a specific action; otherwise, it will just
    print the message on screen, as shown in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，发送数据的连接将通过特殊消息“\q”关闭，这将被解释为一个命令。在监听器中接受连接会创建另一个连接，代表由拨号操作获得的连接。监听器创建的连接将接收来自拨号连接的消息并相应地执行。它将解释特殊消息，如“\q”，并执行特定操作；否则，它将只是在屏幕上打印消息，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code example creates both a client and server in one application,
    but it could be easily split into two apps—a server (capable of handling more
    connections at once) and a client, creating a single connection to the server.
    The server will have an `Accept` loop that handles the received connection on
    a separate goroutine. The `handleConn` function is the same as we defined earlier:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例在一个应用程序中创建了客户端和服务器，但它可以很容易地分成两个应用程序——一个服务器（能够同时处理多个连接）和一个客户端，创建到服务器的单个连接。服务器将具有一个“Accept”循环，处理单独的goroutine上接收的连接。`handleConn`函数与我们之前定义的相同：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The client will create the connection and send messages. `createConn` will
    be the same as we defined earlier:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将创建连接并发送消息。“createConn”将与我们之前定义的相同：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the separated client and server, it's possible to test what happens when
    the client or server closes the connection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在分离的客户端和服务器中，可以测试当客户端或服务器关闭连接时会发生什么。
- en: UDP connections
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP连接
- en: UDP is another protocol that is widely used on the internet. It focuses on low
    latency, which is why it is not as reliable as TCP. It has many applications,
    from online gaming, to media streaming, and **Voice over Internet Protocol** (**VoIP**).
    In UDP, if a packet is not received, it is lost and will not be sent back again
    as it would be in TCP. Imagine a VoIP call, where if there's a connection problem
    you will lose part of the conversation, but when you resume, you keep communicating
    almost in real time. Using TCP for this kind of application could result in latency
    accumulating for every packet loss—making the conversation impossible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UDP是另一种在互联网上广泛使用的协议。它专注于低延迟，这就是为什么它不像TCP那样可靠。它有许多应用，从在线游戏到媒体流媒体，再到互联网语音协议（VoIP）。在UDP中，如果一个数据包没有收到，它就会丢失，并且不会像在TCP中那样再次发送。想象一下VoIP通话，如果有连接问题，你将会丢失部分对话，但当你恢复时，你几乎可以实时地继续通信。对于这种类型的应用程序使用TCP可能会导致每个数据包丢失都会积累延迟，使得对话变得不可能。
- en: In the following example, we'll create a client and a server application. The
    server will be some sort of echo, sending back the message received from the client,
    but it will also reverse the message content.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将创建一个客户端和一个服务器应用程序。服务器将是一种回声，将从客户端接收到的消息发送回去，但它还将颠倒消息内容。
- en: 'The client will be pretty similar to the TCP one, with some exceptions—it will
    use the `net.ResolveUDPAddr` function to get the address and it will use `net.DialUDP`
    to get the connection:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将与TCP的客户端非常相似，但也有一些例外——它将使用`net.ResolveUDPAddr`函数来获取地址，并使用`net.DialUDP`来获取连接：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The server will be pretty different from the TCP one. The main difference is
    that with TCP, we have a listener that accepts different connections, which are
    handled separately; meanwhile, the UDP listener is a connection. It can receive
    data blindly or use the `ReceiveFrom` method that will also return the recipient''s
    address. This can be used in the `WriteTo` method to answer, as shown in the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将与TCP的服务器非常不同。主要区别在于，使用TCP时，我们有一个监听器来接受不同的连接，这些连接是分开处理的；与此同时，UDP监听器是一个连接。它可以盲目地接收数据，或者使用`ReceiveFrom`方法，该方法还将返回接收者的地址。这可以在`WriteTo`方法中使用来进行回答，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Encoding and checksum
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码和校验和
- en: 'It''s a good practice to set some form of encoding between the clients and
    the server, and even better practice if the encoding includes a checksum to verify
    data integrity. We could improve the example from the last section with a custom
    protocol that does both encoding and checksum. Let''s start by defining the encoding
    function, where a given message will return the following byte sequence:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端和服务器之间设置某种形式的编码是一个很好的做法，如果编码包括校验和以验证数据完整性，那就更好了。我们可以改进上一节的示例，使用既进行编码又进行校验和的自定义协议。让我们从定义编码函数开始，给定消息将返回以下字节序列：
- en: '| **Function** | **Byte sequence** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **字节序列** |'
- en: '| The first four bytes will follow a sequence | `2A 00 2A 00` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 前四个字节将遵循一个序列 | `2A 00 2A 00` |'
- en: '| Two bytes will be the message length stored using Little Endian order (least
    significant byte first) | `08 00` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 两个字节将以小端序（最低有效字节在前）存储消息长度 | `08 00` |'
- en: '| Four bytes for data checksum | `00 00 00 00` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 四个字节用于数据校验和 | `00 00 00 00` |'
- en: '| Followed by the raw message | `0F 1D 3A FF ...` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 紧随原始消息 | `0F 1D 3A FF ...` |'
- en: '| Closing with the same starting sequence | `2A 00 2A 00` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 以相同的起始序列结尾 | `2A 00 2A 00` |'
- en: 'The `Checksum` function will be calculated by summing the message content,
    using a group of five bytes in Little Endian (least significant byte first), adding
    any spare byte left one by one, and then taking the first four bytes of the sum
    as a Little Endian:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Checksum`函数将通过对消息内容进行求和来计算，使用五个字节的小端序（最低有效字节在前），逐个添加任何剩余的字节，然后将求和的前四个字节作为小端序：'
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s create a function that will encapsulate the message using the protocol
    we defined:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数，用来使用我们定义的协议封装消息：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need another function that does the opposite, checking whether a message
    is valid and extracting its content:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要另一个函数，用来检查消息是否有效并提取其内容：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now use them for encoding and decoding messages. For instance, we could
    improve the UDP client and server from the previous section and we could encode
    when sending:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用它们来对消息进行编码和解码。例如，我们可以改进上一节中的UDP客户端和服务器，并在发送时进行编码：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And we can decode the bytes received for incoming messages in order to extract
    the content:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以解码接收到的字节以提取内容：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In order to verify that the content we received is valid, we are using the `MessageContent`
    utility function defined previously. This will check for headers, length, and
    checksum. It will only extract the bytes that compose the message.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们收到的内容是否有效，我们使用了之前定义的`MessageContent`实用程序函数。这将检查头部、长度和校验和。它只会提取组成消息的字节。
- en: Web servers in Go
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的Web服务器
- en: One of Go's biggest and most successful applications is the creation of web
    servers. In this section, we will see what a web server actually is, how the HTTP
    protocol works, and how to implement a web server application using both the standard
    library and third-party packages.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言最大和最成功的应用之一是创建Web服务器。在本节中，我们将看到Web服务器实际上是什么，HTTP协议是如何工作的，以及如何使用标准库和第三方包来实现Web服务器应用程序。
- en: Web server
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器
- en: 'A web server application is software that can serve content using the HTTP
    protocol (and some other related ones) over a TCP/IP network. There are many well-known
    web server applications, such as Apache, NGINX, and Microsoft IIS. Common server
    use case scenarios include the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器应用程序是一种可以使用HTTP协议（以及一些其他相关协议）在TCP/IP网络上提供内容的软件。有许多知名的Web服务器应用程序，如Apache、NGINX和Microsoft
    IIS。常见的服务器使用情况包括以下几种：
- en: '**Serving static files, such websites and related resources**: HTML pages,
    images, style sheets, and scripts.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供静态文件，如网站和相关资源**：HTML页面、图像、样式表和脚本。'
- en: '**Exposing a web application**: An application that runs in the server with
    an HTML-based interface, which requires a browser to access it.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴露Web应用程序**：在服务器上运行的具有基于HTML的界面的应用程序，需要浏览器才能访问。'
- en: '**Exposing a web API**: Remote interfaces that are not used by the user but
    from other applications. Refer to [Chapter 1](27b19b4d-7890-4fdc-9619-5204d0a7a60d.xhtml), *An
    Introduction to System Programming*, for more details.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴露Web API**：不是由用户而是由其他应用程序使用的远程接口。有关更多详细信息，请参阅[第1章](27b19b4d-7890-4fdc-9619-5204d0a7a60d.xhtml)，*系统编程简介*。'
- en: HTTP protocol
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP协议
- en: The HTTP protocol is the cornerstone of a web server. Its design started in
    1989\. The main usage of HTTP is the request and response paradigm, where the
    client sends a request and the server returns back a response to the client.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议是Web服务器的基石。它的设计始于1989年。HTTP的主要用途是请求和响应范式，其中客户端发送请求，服务器返回响应给客户端。
- en: '**Uniform Resource Locators** (**URLs**) are unique identifiers for an HTTP
    request, and they have the following structure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一资源定位符**（**URL**）是HTTP请求的唯一标识符，其结构如下：'
- en: '| **Part** | **Example** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **示例** |'
- en: '| Protocol | `http` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | `http` |'
- en: '| `://` | `://` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `://` | `://` |'
- en: '| Host | `www.website.com` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 主机 | `www.website.com` |'
- en: '| Path | `/path/to/some-resource` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 路径 | `/path/to/some-resource` |'
- en: '| `?` | `?` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `?` | `?` |'
- en: '| Query (optional) | `query=string&with=values` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 查询（可选）| `query=string&with=values` |'
- en: 'From the preceding table, we can derive the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中，我们可以得出以下结论：
- en: There are several different protocols beside HTTP and its encrypted version
    (HTTPS), such as the **File Transfer Protocol** (**FTP**) and its secure counterpart,
    the **SSH File Transfer Protocol** (**S****FTP**).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了HTTP及其加密版本（HTTPS）之外，还有几种不同的协议，如**文件传输协议**（**FTP**）及其安全对应协议，**SSH文件传输协议**（**SFTP**）。
- en: The host could either be an actual IP or a hostname. When a hostname is selected,
    there is another player, a **Domain Name Server** (**DNS**), that acts as a phonebook
    between hostname and physical addresses. The DNS translates hostnames to IPs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机可以是实际IP或主机名。当选择主机名时，还有另一个参与者，即**域名服务器**（**DNS**），它充当主机名和物理地址之间的电话簿。DNS将主机名转换为IP。
- en: The path is the resource desired in the server and it is always absolute.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径是服务器中所需的资源，它总是绝对的。
- en: The query string is something added to a path after a question mark. It is a
    series of key value pairs in the form `key=value` and they are separated by an `&`
    sign.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串是在问号后面添加到路径中的内容。它是一系列以`key=value`形式的键值对，它们由`&`符号分隔。
- en: HTTP is a textual protocol and it contains some of the elements of the URL and
    some other information—method, headers, and body.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种文本协议，它包含URL的一些元素和其他信息，如方法、标题和正文。
- en: The request body is the information sent to server, such as form values, or
    uploaded files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请求正文是发送到服务器的信息，如表单值或上传的文件。
- en: 'Headers are metadata relative to the request, one per line, in a `Key: Value;
    extra data` form. There is a list of defined headers with specific functions,
    such as `Authorization`, `User-Agent`, and `Content-Type`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '标题是相对于请求的元数据，每行一个，以`Key: Value; extra data`形式。有一系列定义的具有特定功能的标题，如`Authorization`，`User-Agent`和`Content-Type`。'
- en: 'Some methods express the action to execute on a resource. These are the most
    commonly used methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法表示对资源执行的操作。这些是最常用的方法：
- en: '`GET`: A representation of the selected resource'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：所选资源的表示'
- en: '`HEAD`: Similar to `GET`, but without any response body'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：类似于`GET`，但没有任何响应体'
- en: '`POST`: Submits a resource to the server, usually a new one'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：向服务器提交资源，通常是新资源'
- en: '`PUT`: Submits a new version of a resource'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：提交资源的新版本'
- en: '`DELETE`: Removes a resource'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除资源'
- en: '`PATCH`: Requests specific change to a resource'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：请求对资源进行特定更改'
- en: 'This is what an HTTP request would look like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTTP请求的样子：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From the preceding code, we can see the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们可以看到以下内容：
- en: 'The first line is a space separated triplet: method—path—protocol.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行是空格分隔的三元组：方法—路径—协议。
- en: It's followed by one line per header.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个标题后面都跟着一行。
- en: One empty line as separator.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空行作为分隔符。
- en: The optional request body.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的请求体。
- en: For each request, there is a response that has a structure that is pretty similar
    to an HTTP request. The only part that differs is the first line that contains
    a different space-separated triplet: HTTP version—status code—reason.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个请求，都有一个响应，其结构与HTTP请求非常相似。唯一不同的部分是包含不同空格分隔的三元组的第一行：HTTP版本—状态码—原因。
- en: 'The status code is an integer that represents the outcome of the request. There
    are four main status categories:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是代表请求结果的整数。有四个主要的状态类别：
- en: '`100`: Information/request was received and will have further processing'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100`：已接收信息/请求，并将进行进一步处理'
- en: '`200`: A successful request; for instance, `OK 200` or `Created 201`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200`：成功的请求；例如，`OK 200`或`Created 201`'
- en: '`300`: A redirection to another URL, temporary or permanent'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`300`：重定向到另一个URL，临时或永久'
- en: '`400`: A client-side error, such as `Not Found 404` or `Conflict 409`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400`：客户端错误，如`Not Found 404`或`Conflict 409`'
- en: '`500`: A server-side error, such as `Internal Server Error 503`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`：服务器端错误，如`Internal Server Error 503`'
- en: 'This is a what an HTTP response would look like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是HTTP响应的样子：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: HTTP/2 and Go
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2和Go
- en: The most commonly used version of HTTP is HTTP/1.1 , dated 1997\.  In 2009, Google
    started a new project to create a faster successor to HTTP/1.1, named SPDY. This
    protocol eventually became what is now a version 2.0 of the **Hypertext Transfer
    Protocol**, **HTTP/2**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的HTTP版本是HTTP/1.1，日期为1997年。2009年，Google启动了一个新项目，创建了一个更快的HTTP/1.1后继者，名为SPDY。该协议最终成为现在的**超文本传输协议**的2.0版本，**HTTP/2**。
- en: 'It is built in a way that existing web applications work, but there are new
    features for applications that are using the new protocol, including a faster
    communication speed. Some of the differences include the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它是以现有Web应用程序的工作方式构建的，但对于使用新协议的应用程序，包括更快的通信速度，有新功能。一些不同之处包括以下内容：
- en: It is binary (HTTP/1.1 is textual).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是二进制的（HTTP/1.1是文本的）。
- en: It is fully multiplexed, and can request data in parallel, using one TCP connection.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是完全多路复用的，并且可以使用一个TCP连接并行请求数据。
- en: It uses header compression to reduce overhead.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用头部压缩来减少开销。
- en: Servers can push responses to the client, instead of being asked by clients
    periodically.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器可以向客户端推送响应，而不是被客户端周期性地询问。
- en: It has a faster protocol negotiation—thanks to the **Application Layer Protocol
    Negotiation** (**ALPN**) extension.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有更快的协议协商——感谢**应用层协议协商**（**ALPN**）扩展。
- en: HTTP/2 is supported by all major modern browsers. Go version 1.6 included transparent
    support for HTTP/2 and version 1.8 introduced the ability to push responses from
    the server to the clients.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的现代浏览器都支持HTTP/2。Go 1.6版本包含了对HTTP/2的透明支持，1.8版本引入了服务器向客户端推送响应的能力。
- en: Using the standard package
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准包
- en: We will now see how to create a web server in Go, using the standard package.
    Everything is contained in the `net/http` package, which exposes a series of functions
    for making HTTP requests and creating HTTP servers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何在Go中使用标准包创建一个Web服务器。一切都包含在`net/http`包中，该包公开了一系列用于发出HTTP请求和创建HTTP服务器的函数。
- en: Making a HTTP request
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出HTTP请求
- en: 'The package exposes a `http.Client` type that can be used to make requests.
    If the requests are simple `GET` or `POST`, then there are dedicated methods.
    The package also offers a function with the same name, but it''s just a shorthand
    to the respective methods for the `DefaultClient` instance. Check the following
    code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该包公开了一个`http.Client`类型，可用于发出请求。如果请求是简单的`GET`或`POST`，则有专用方法。该包还提供了一个同名的函数，但它只是`DefaultClient`实例的相应方法的简写。检查以下代码：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For any other kind of requirement, the `Do` method allows us to execute a specific `http.Request`.
    The `NewRequest` function allows us to specify any `io.Reader`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何其他类型的需求，`Do`方法允许我们执行特定的`http.Request`。`NewRequest`函数允许我们指定任何`io.Reader`：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`http.Client` has several fields and many of these are interfaces that allows
    us to use the default implementation or a custom one. The first is `CookieJar`
    that allows the client to store and reuse web cookies. A cookie is a piece of
    data that the browser sends to the client and the client can send back to the
    server to replace headers, such as authentication. The default client does not
    use a cookie jar. The other interface is `RoundTripper`, which has only one method, `RoundTrip`,
    which gets a request and returns a response. There is a `DeafultTransport` value
    used if no value is specified that can also be used to compose a custom implementation
    of `RoundTripper`. `http.Response` returned by the client has also a body, which
    is `io.ReadCloser`, and its closure is the responsibility of the application.
    That''s why it''s recommended to use a deferred `Close` statement as soon as the
    response is obtained. In the following example, we will implement a custom transport
    that logs the requested URL and modifies one header before executing the standard
    round tripper:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Client`有几个字段，其中许多是允许我们使用默认实现或自定义实现的接口。第一个是`CookieJar`，它允许客户端存储和重用Web
    cookies。Cookie是浏览器发送给客户端的数据，客户端可以发送回服务器以替换头部，例如身份验证。默认客户端不使用cookie jar。另一个接口是`RoundTripper`，它只有一个方法`RoundTrip`，它获取一个请求并返回一个响应。如果未指定值，则使用`DeafultTransport`值，也可以用于组成`RoundTripper`的自定义实现。客户端返回的`http.Response`也有一个body，它是`io.ReadCloser`，其关闭由应用程序负责。这就是为什么建议在获得响应后立即使用延迟的`Close`语句。在下面的示例中，我们将实现一个自定义传输，该传输记录请求的URL并在执行标准往返之前修改一个头部：'
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will use this transport in a client that we will use to make a simple request:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个客户端中使用这个传输来发出一个简单的请求：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating a simple server
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的服务器
- en: The other functionality offered by the package is the server creation. The main
    interface of the package is `Handle`, which has one method, `ServeHTTP` ,that
    uses the request to write a response. Its simplest implementation is `HandlerFunc`,
    which is a function with the same signature of `ServeHTTP` and implements `Handler`
    by executing itself.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该包提供的另一个功能是服务器创建。该包的主要接口是`Handle`，它有一个方法`ServeHTTP`，使用请求来写入响应。它的最简单的实现是`HandlerFunc`，它是一个具有`ServeHTTP`相同签名的函数，并通过执行自身来实现`Handler`。
- en: The `ListenAndServe` function starts a HTTP server using the given address and
    handler. If no handler is specified, it uses the `DefaultServeMux` variable. `ServeMux`
    is special type of `Handler` that manages the execution of different handlers,
    depending on the URL path requested. It has two methods, `Handle` and `HandleFunc`,
    that allow the user to specify the path and the respective handler. The package
    also offers generic handler functions that are similar to what we have seen for
    the `Client`, they will call the methods with same name from the default `ServerMux`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenAndServe`函数使用给定的地址和处理程序启动HTTP服务器。如果未指定处理程序，则使用`DefaultServeMux`变量。`ServeMux`是一种特殊类型的`Handler`，它管理对不同处理程序的执行，具体取决于所请求的URL路径。它有两种方法，`Handle`和`HandleFunc`，允许用户指定路径和相应的处理程序。该包还提供了类似于我们为`Client`所见的通用处理程序函数，它们将调用默认`ServerMux`的同名方法。'
- en: 'In the following example, we will create a `customHandler` and create a simple
    server with some endpoints, including the custom one:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将创建一个`customHandler`并创建一个带有一些端点的简单服务器，包括自定义端点：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Serving filesystem
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供文件系统
- en: The Go standard package allows us to easily serve a certain directory in the
    filesystem, using the `net.FileServer` function, which, when given the `net.FileSystem`
    interface, returns a `Handler` that serves that directory. The default implementation
    is `net.Dir` , which is a custom string that represents a directory in the system.
    The `FileServer` function already has a protection mechanism that prevents us
    to use a relative path, such as`../../../dir`, to access directories outside the
    served one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准包允许我们轻松地在文件系统中为特定目录提供服务，使用`net.FileServer`函数，当给定`net.FileSystem`接口时，返回一个用于提供该目录的`Handler`。默认实现是`net.Dir`，它是一个表示系统中目录的自定义字符串。`FileServer`函数已经有了一个保护机制，防止我们使用相对路径（如`../../../dir`）访问提供服务的目录之外的目录。
- en: 'The following is a sample file server that uses the directory provided as an
    argument, as the root of the file served:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用提供的目录作为文件服务的根目录的示例文件服务器：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Navigating through routes and methods
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过路由和方法导航
- en: 'The HTTP method used is stored in the `Request.Method` field. This field can
    be used inside a handler to have different behaviors for each supported method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的HTTP方法存储在`Request.Method`字段中。这个字段可以在处理程序内部使用，以便为每种支持的方法设置不同的行为：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The advantage of the `http.Handler` interface is that we can define our custom
    types. This can make the code more readable and can generalize this method-specific
    behavior:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Handler`接口的优势在于我们可以定义自定义类型。这可以使代码更易读，并且可以概括这种特定于方法的行为：'
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will make the code much more readable, and it will be reusable for different
    paths:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使代码更易读，并且可以重复用于不同的路径：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multipart request and files
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多部分请求和文件
- en: The request body is an `io.ReadCloser`. This means that it is the server's responsibility
    to close it. For a file upload, the body is not content of the file directly,
    but it is usually a multipart request, which is a request that specifies a boundary
    in the header and uses it inside the body to separate the message in parts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体是一个`io.ReadCloser`。这意味着关闭它是服务器的责任。对于文件上传，请求体不是文件的内容，而是通常是一个多部分请求，它在头部指定一个边界，并在体内使用它来将消息分成部分。
- en: 'This is a sample multipart message:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例多部分消息：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see that the boundary has two dashes as a prefix and it's followed by
    a newline, and the final boundary also has two dashes as a suffix. In the following
    example, the server will handle a file upload, with a small form to send the request
    from a browser.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到边界有两个破折号作为前缀，后面跟着一个换行符，最终边界也有两个破折号作为后缀。在下面的示例中，服务器将处理文件上传，使用一个小表单从浏览器发送请求。
- en: 'Let''s define some constants that we will use in the handler:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些在处理程序中将使用的常量：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can define the handler function. The first part should show the template
    if the method is `GET`, as it executes the upload on `POST` and returns a not
    found status otherwise:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义处理程序函数。第一部分应该在方法为`GET`时显示模板，因为它在`POST`上执行上传，并在其他情况下返回未找到状态：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `upload` function will use the `Request.FormFile` method that returns the
    file and its metadata:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`upload`函数将使用`Request.FormFile`方法返回文件及其元数据：'
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: HTTPS
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS
- en: 'If you want your web server to use HTTPS instead of relying on external applications,
    such as NGINX, you can easily do so if you already have a valid certificate. If
    you don''t, you can use OpenSSL to create one:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的Web服务器使用HTTPS而不是依赖外部应用程序（如NGINX），如果您已经有有效的证书，您可以很容易地这样做。如果没有，您可以使用OpenSSL创建一个：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first command generates a private key, while the second one creates a public
    certificate that you need for the server. The second command will also require
    a lot of additional information in order to create the certificate, from country
    name to email address.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令生成私钥，而第二条命令创建了一个服务器所需的公共证书。第二条命令还需要大量的额外信息来创建证书，从国家名称到电子邮件地址。
- en: 'Once everything is ready, in order to create an HTTPS server, the `http.ListenAndServe` function
    needs to be replaced with its secure counterpart: `http.ListenAndServeTLS`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，为了创建一个HTTPS服务器，需要用其安全对应物`http.ListenAndServeTLS`替换`http.ListenAndServe`函数：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Third-party packages
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方包
- en: The Go open source community develops a lot of packages that integrate with
    `net/http`, implementing the `Handler` interface, but offer a set of unique capabilities
    that allow for an easier development of web servers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Go开源社区开发了许多与`net/http`集成的包，实现了`Handler`接口，但提供了一组独特的功能，可以更轻松地开发Web服务器。
- en: gorilla/mux
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gorilla/mux
- en: 'The `github.com/gorilla/mux` package contains another implementation of `Handler` that
    enhances the capabilities of the standard `ServeMux`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/gorilla/mux`包包含了`Handler`的另一个实现，增强了标准`ServeMux`的功能：'
- en: Better URL matching to handlers using any element from the URL, including schema,
    method, host, or query values.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的URL匹配到处理程序，使用URL中的任何元素，包括模式、方法、主机或查询值。
- en: URL elements, such as host, paths, and query keys can have placeholders (which
    can also use regular expressions).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL元素，如主机、路径和查询键可以有占位符（也可以使用正则表达式）。
- en: Routes can be defined hierarchically with the help of subroutes, nested routes
    which test a part of the path.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过子路由，可以分层定义路由，测试路径的一部分。
- en: Handlers can be also used as middleware, before the main handler, for all paths
    or for a subset of paths.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序也可以用作中间件，在主处理程序之前，用于所有路径或一部分路径。
- en: 'Let''s start with an example of matching using other path elements:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用其他路径元素进行匹配的示例开始：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Variables are another really useful feature, that allow us to specify placeholders,
    and get their values with the auxiliary function, `mux.Vars`, as shown in the
    following example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是另一个非常有用的功能，它允许我们指定占位符，并使用辅助函数`mux.Vars`获取它们的值，如下例所示：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Subrouter` is another helpful function to group same prefixes routes. This
    allows us to simplify the previous code to the following code snippet:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subrouter`是另一个有用的函数，用于对相同前缀路由进行分组。这使我们可以将上一个代码简化为以下代码片段：'
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Middleware is also very useful when combined with subroutes, to execute some
    common tasks as authentication and verification:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当与子路由结合使用时，中间件也非常有用，可以执行一些常见任务，如身份验证和验证：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: gin-gonic/gin
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gin-gonic/gin
- en: 'The `github.com/gin-gonic/gin` package is another Go web framework that extends
    the capabilities of a Go HTTP server with many shorthand and auxiliary functions.
    Its features include the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/gin-gonic/gin`包是另一个Go Web框架，它通过许多简写和辅助函数扩展了Go HTTP服务器的功能。其特点包括以下内容：'
- en: '**Speed**: Its routing is fast and has very little memory footprint.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：它的路由速度快，内存占用很小。'
- en: '**Middleware**: It allows to define and use intermediate handlers with a full
    control of their flow.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**：它允许定义和使用中间处理程序，并完全控制它们的流程。'
- en: '**Panic-free**: It comes with middleware that recovers from panics.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无Panic**：它带有从panic中恢复的中间件。'
- en: '**Grouping**: It can group routes with the same prefix together.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组**：它可以将具有相同前缀的路由分组在一起。'
- en: '**Errors**: It manages and collects error that happen during the request.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：它管理和收集请求期间发生的错误。'
- en: '**Rendering**: It comes out of the box with renderers for most web formats
    (JSON, XML, HTML).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染：它默认带有大多数Web格式的渲染器（JSON、XML、HTML）。
- en: The core of the package is `gin.Engine`, which is also a `http.Handler`. The
    `gin.Default` function returns an engine that uses two middlewares—`Logger`, which
    prints the result of each HTTP request received, and `Recovery`, which recovers
    from panics. The other option is to use the `gin.New` function, which returns
    an engine with no middleware.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该包的核心是`gin.Engine`，也是一个`http.Handler`。`gin.Default`函数返回一个使用两个中间件的引擎——`Logger`，它打印每个接收到的HTTP请求的结果，以及`Recovery`，它从panic中恢复。另一个选项是使用`gin.New`函数，返回一个没有中间件的引擎。
- en: 'It allows us to bind a handler to a single HTTP method with a series of the
    engine''s methods named after their HTTP counterpart:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们将处理程序绑定到单个HTTP方法，使用一系列引擎方法，这些方法以它们的HTTP对应物命名：
- en: '`DELETE`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: '`GET`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`'
- en: '`HEAD`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`'
- en: '`OPTIONS`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`'
- en: '`PATCH`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: '`POST`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`'
- en: '`PUT`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: '`Any` (catch all for any HTTP method)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Any`（适用于任何HTTP方法）'
- en: 'There''s also a `group` method that returns a route grouping for the selected
    path, which exposes all of the preceding methods:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`group`方法，返回一个选定路径的路由分组，公开了所有前面的方法：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The handlers in this framework have a different signature. Instead of having
    a response writer and a request as arguments, it uses `gin.Context`, a structure
    that wraps both, and offers many shorthands and utilities. For instance, the package
    offers the possibility of using placeholders in the URL and the context enables
    these parameters to be read:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架中的处理程序具有不同的签名。它不是使用响应写入器和请求作为参数，而是使用`gin.Context`，这是一个包装了两者的结构，并提供了许多简写和实用工具。例如，该包提供了在URL中使用占位符的可能性，而上下文使这些参数可以被读取：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can also see in the example that the context offers a `String` method that
    enables us to write an HTTP status and the content of the response with a one-liner.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在示例中看到，上下文提供了一个`String`方法，使我们能够用一行代码编写HTTP状态和响应内容。
- en: Other functionalities
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他功能
- en: There are additional features for web servers. Some of them are already supported
    by the standard library (such as HTTP/2 Pusher) and others are available with
    experimental packages or third-party libraries (such as WebSockets).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器还有其他功能。其中一些已经受到标准库的支持（如HTTP/2推送器），其他功能则可通过实验性包或第三方库获得（如WebSockets）。
- en: HTTP/2 Pusher
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP/2推送器
- en: 'We have already discussed that Golang supports the HTTP/2 server side push
    functionality since version 1.8\. Let''s see how to use it in an application.
    Its usage is pretty simple; if the request can be casted to the `http.Pusher`
    interface, it can be used to push additional requests in the main interface. In
    this example, we use it to sideload a SVG image, together with the page:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，自Go 1.8版本以来，Golang支持HTTP/2服务器端推送功能。让我们看看如何在应用程序中使用它。它的使用非常简单；如果请求可以转换为`http.Pusher`接口，它可以用于在主接口中推送额外的请求。在这个例子中，我们用它来并行加载SVG图像，以及页面：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will result in two separate requests for HTTP/1, and one single request
    for HTTP/2, where the second request is obtained using the push capabilities of
    the browser.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致HTTP/1的两个单独请求，以及HTTP/2的一个单一请求，其中第二个请求是使用浏览器的推送功能获得的。
- en: WebSockets protocol
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSockets协议
- en: The HTTP protocol achieves only one-way communication, while the WebSocket protocol
    is a full duplex communication between client and server. The Go experimental
    library offers support for WebSocket with the `golang.org/x/net/websocket` package,
    and Gorilla has another implementation with its own `github.com/gorilla/websocket`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议只实现单向通信，而WebSocket协议是客户端和服务器之间的全双工通信。Go实验性库通过`golang.org/x/net/websocket`包提供了对WebSocket的支持，Gorilla还有另一个实现，使用了自己的`github.com/gorilla/websocket`。
- en: The second one is far more complete, and it's used in the `github.com/olahol/melody`
    package, which implements a framework for an easy WebSocket communication. Each
    package offers different working examples on the WebSocket server and client pair.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个更加完整，它在`github.com/olahol/melody`包中使用，该包实现了一个简单的WebSocket通信框架。每个包都提供了WebSocket服务器和客户端对的不同工作示例。
- en: Beginning with the template engine
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从模板引擎开始
- en: Another very powerful tool is the Go templating engine, available in `text/template`.
    Its functionalities are replicated and extended in the `html/template` package,
    which constitutes another powerful tool for web development with Go.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常强大的工具是Go模板引擎，可在`text/template`中使用。其功能在`html/template`包中得到复制和扩展，这构成了Go Web开发的另一个强大工具。
- en: Syntax and basic usage
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法和基本用法
- en: The template package enables us to separate presentation from data, using text
    files and data structures. The template engine defines two delimiters—left and
    right—for opening and closing actions that represent data evaluation. The default
    delimiters are `{{` and `}}`, and the template evaluates only what's included
    within these delimiters, leaving the rest untouched.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包使我们能够使用文本文件和数据结构将表示与数据分离。模板引擎定义了两个分隔符——左和右——用于表示数据评估的开启和关闭操作。默认的分隔符是`{{`和`}}`，模板只评估这些分隔符内包含的内容，其余部分保持不变。
- en: Usually the data bound to the template is a structure or a map and it is accessible
    anywhere in the template with the `$` variable. Whether it's a map or a struct,
    the fields are always accessed in the same way, using the `.Field` syntax. If
    the dollar is omitted, the value is referred to the current context, which is
    `$` if it's not in special statements, such as loops. Outside of these exceptions,
    the `{{$.Field}}` and `{{.Field}}` statements are equivalent.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常绑定到模板的数据是一个结构或映射，并且可以在模板中的任何位置使用`$`变量访问。无论是映射还是结构，字段的访问方式始终相同，使用`.Field`语法。如果省略了美元符号，则该值将被引用为当前上下文，如果不在特殊语句中，例如循环，则为`$`。在这些例外之外，`{{$.Field}}`和`{{.Field}}`语句是等效的。
- en: The flow in a template is controlled with a condition statement, `{{if}}`, and
    a loop statement, `{{range}}`, and both terminate with the `{{end}}` statement.
    The condition statement also offers the possibility of a chain `{{else if}}` statement
    to specify another condition, acting like a switch, and an `{{else}}` statement,
    which can be considered the default of a switch. `{{else}}` can be used with the
    `range` statement and it's executed when the argument of the range is `nil` or
    has zero length.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的流程由条件语句`{{if}}`和循环语句`{{range}}`控制，并且两者都以`{{end}}`语句结束。条件语句还提供了链式`{{else
    if}}`语句的可能性来指定另一个条件，类似于开关，并且`{{else}}`语句可以被视为开关的默认情况。`{{else}}`可以与`range`语句一起使用，当range的参数为`nil`或长度为零时执行。
- en: Creating, parsing, and executing templates
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、解析和执行模板
- en: 'The `template.Template` type is a collector of one or more templates and can
    be initialized in several ways. The `template.New` function creates a new empty
    template with the given name, which can be used to call the `Parse` method that
    uses a string to create a template. Consider the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.Template`类型是一个或多个模板的收集器，并且可以以多种方式初始化。`template.New`函数创建一个具有给定名称的新空模板，可以用于调用使用字符串创建模板的`Parse`方法。考虑以下代码：'
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The full example is available here: [https://play.golang.org/p/k-t0Ns1b2Mv.](https://play.golang.org/p/k-t0Ns1b2Mv)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/k-t0Ns1b2Mv](https://play.golang.org/p/k-t0Ns1b2Mv)
- en: 'Templates can also be loaded and parsed from a filesystem, using `template.ParseFiles`,
    which takes a list of files, and `template.ParseGlob`, which uses the `glob` Unix
    command syntax to select a list of files. Let''s create a template file with the
    following content:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 模板也可以从文件系统中加载和解析，使用`template.ParseFiles`，它接受一个文件列表，以及`template.ParseGlob`，它使用`glob`
    Unix命令语法来选择文件列表。让我们创建一个包含以下内容的模板文件：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can use one of these two functions to load it and execute it with some sample
    data:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这两个函数中的一个来加载并使用一些示例数据执行它：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When multiple templates are loaded, the `Execute` method will use the last one.
    If a specific template needs to be selected, there is another method, `ExecuteTemplate`,
    which also receives the template name as an argument, to specify which template
    to use.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载多个模板时，`Execute`方法将使用最后一个。如果需要选择特定模板，则还有另一种方法`ExecuteTemplate`，它还接收模板名称作为参数，以指定要使用的模板。
- en: Conditions and loops
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件和循环
- en: The `range` statement can be used in different ways—the simplest way is just
    calling `range` followed by the slice or map that you want to iterate.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`语句可以以不同的方式使用——最简单的方式就是调用`range`，后面跟着要迭代的切片或映射。'
- en: 'Alternatively, you can specify the values, or the index and the value:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以指定值，或索引和值：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When in a loop, the `{{.}}` variable assumes the value of the current element
    in the iteration. The following example loops a slice of items:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，`{{.}}`变量假定为迭代中的当前元素的值。以下示例循环一个项目切片：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The full example is available here: [https://play.golang.org/p/MtU_d9CsFb-.](https://play.golang.org/p/MtU_d9CsFb-)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/MtU_d9CsFb-](https://play.golang.org/p/MtU_d9CsFb-)
- en: 'The next example is a use case of conditional statements that have also made
    use of the `lt` function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例是条件语句的用例，也使用了`lt`函数：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The full example is available here: [https://play.golang.org/p/eBKDcJ47rPU.](https://play.golang.org/p/eBKDcJ47rPU)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/eBKDcJ47rPU](https://play.golang.org/p/eBKDcJ47rPU)
- en: We will explore functions in more detail in the next section.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地探讨函数。
- en: Template functions
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板函数
- en: Functions are an important part of the template engine and there are many built-in
    functions, such as comparison (`eq`, `lt`, `gt`, `le`, `ge`) or logical (`AND`,
    `OR`, `NOT`). Functions are called by their names, followed by arguments using
    space as separator. The function used in the previous example, `lt a b`, means
    `lt(a,b)`. When the functions are more nested, it's required to wrap functions
    and arguments in parentheses. For instance, the `not lt a b` statement means that
    the `X` function has three arguments, `not(lt, a, b)`. The correct version is
    `not (lt a b)`, which tells the template that the elements in the parentheses
    need to be solved first.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是模板引擎的重要部分，有许多内置函数，例如比较（`eq`，`lt`，`gt`，`le`，`ge`）或逻辑（`AND`，`OR`，`NOT`）。函数通过它们的名称调用，后面跟着使用空格作为分隔符的参数。在前面的示例中使用的函数`lt
    a b`表示`lt(a,b)`。当函数嵌套更多时，需要用括号包裹函数和参数。例如，`not lt a b`语句表示`X`函数有三个参数，`not(lt, a,
    b)`。正确的版本是`not (lt a b)`，它告诉模板需要先解决括号中的元素。
- en: 'When creating a template, custom functions can be assigned to it with the `Funcs`
    method and can be used in the template. This is very useful, as we can see in
    this example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模板时，可以使用`Funcs`方法为其分配自定义函数，并在模板中使用。这非常有用，正如我们在这个例子中看到的：
- en: '[PRE44]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The full example is available here: [https://play.golang.org/p/DdoKEOixDDB.](https://play.golang.org/p/DdoKEOixDDB)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里可用：[https://play.golang.org/p/DdoKEOixDDB.](https://play.golang.org/p/DdoKEOixDDB)
- en: The `|` operator can be used to link the output of a statement to the input
    of another statement, similar to how it happens in the Unix shell. For instance,
    the `{{"put" | printf "%s%s" "out" | printf "%q"}}` statement will produce `"output"`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`|`运算符可用于将语句的输出链接到另一个语句的输入，类似于Unix shell中的情况。例如，`{{"put" | printf "%s%s" "out"
    | printf "%q"}}`语句将产生`"output"`。'
- en: RPC servers
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC服务器
- en: '**Remote Procedure Call** (**RPC**) is a method of calling the execution of
    an application functionality from another system, using the TCP protocol. Go has
    native support for RPC servers.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程过程调用**（**RPC**）是一种使用TCP协议从另一个系统调用应用功能执行的方法。Go语言原生支持RPC服务器。'
- en: Defining a service
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个服务
- en: 'The Go RPC server permits us to register any Go type, along with its methods.
    This exposes the methods with the RPC protocol and enables us to call them by
    name from a remote client. Let''s create a helper for keeping track of our progress
    in the book as we are reading:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Go RPC服务器允许我们注册任何Go类型及其方法。这将使用RPC协议公开方法，并使我们能够通过名称从远程客户端调用它们。让我们创建一个辅助函数来跟踪我们在阅读书籍时的进度：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, let''s define a small helper method called `bookIndex` that returns
    the index of a book using its identifier—the ISBN:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个名为`bookIndex`的小辅助方法，它使用书籍的标识符（ISBN）返回书籍的索引：
- en: '[PRE46]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we can define the operation that `ReadingList` will be capable of. It
    should be able to add and remove books:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`ReadingList`将能够执行的操作。它应该能够添加和删除书籍：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It should also be able to read and alter a book''s progress:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它还应该能够读取和修改书籍的进度：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, `SetProgress` changes the progress of a book, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`SetProgress`改变书的进度，如下所示：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`AdvanceProgress` adds pages to the progress of a book:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdvanceProgress`增加书的进度页数：'
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The error variables we are using in these functions are defined as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这些函数中使用的错误变量定义如下：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Creating the server
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器
- en: 'Now we have the service that we can use to create an RPC server very easily.
    However, the type used has to respect some rules for its methods to make them
    available:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以轻松创建RPC服务器的服务。但是，所使用的类型必须遵守一些规则，以使其方法可用：
- en: The method's type and method itself are both exported.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的类型和方法本身都是导出的。
- en: The method has two arguments, both exported.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法有两个参数，都是导出的。
- en: The second argument is a pointer.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是一个指针。
- en: The method returns an error.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法返回一个错误。
- en: 'The method should look something like this: `func (t *T) Method(in T1, out
    *T2) error.`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法应该看起来像这样：`func (t *T) Method(in T1, out *T2) error.`
- en: 'The next step is create a wrapper for the `ReadingList` that satisfies these
    rules:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个满足这些规则的`ReadingList`的包装器：
- en: '[PRE52]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can redefine the book, add and remove functions using `Book`, which is an
    exported type, and built-in types:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新定义书籍，使用`Book`添加和删除函数，这是一个导出类型和内置类型：
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For the progress, we have two inputs (`isbn` and `pages`), so we have to define
    a structure that contains both, since the input must be a single argument:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进度，我们有两个输入（ISBN和页数），因此我们必须定义一个包含两者的结构，因为输入必须是单个参数：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The defined type can be registered and used in an RPC server, which will use
    `rpc.HandleHTTP` to register the HTTP handler for the incoming RPC messages:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的类型可以在RPC服务器中注册并使用，它将使用`rpc.HandleHTTP`来注册传入RPC消息的HTTP处理程序：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Creating the client
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'The client can be created using the RPC package''s `rpc.DialHTTP` function,
    using the same host-port to obtain a client:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用RPC包的`rpc.DialHTTP`函数创建客户端，使用相同的主机端口来获取客户端：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we define a list of books that we are going to use for our example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个我们将在示例中使用的书籍列表：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Considering that the format package prints the address of pointers to built-in
    types, we are going to define a helper function to show the pointer''s content:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到格式包会打印内置类型指针的地址，我们将定义一个辅助函数来显示指针的内容：
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The client gets the operation to execute in the form of `type.method`, so we
    will be using the function like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端以`type.method`的形式获取要执行的操作，因此我们将使用这样的函数：
- en: '[PRE59]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will output each operation with its result.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出每个操作及其结果。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined how network connections are handled in Go. We started
    with some network standards. First, we discussed the OSI model, and then TCP/IP.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们研究了Go语言中如何处理网络连接。我们从一些网络标准开始。首先，我们讨论了OSI模型，然后是TCP/IP。
- en: Then, we checked the network package and learned how to use it to create and
    manage TCP connections. This included the handling of special commands and how
    to terminate the connection from the server side. Next, we saw how to do the same
    with UDP, and we have seen how to implement a custom encoding with checksum control.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了网络包，并学习了如何使用它来创建和管理TCP连接。这包括处理特殊命令以及如何从服务器端终止连接。接下来，我们看到如何使用UDP做同样的事情，并且我们已经看到如何实现具有校验和控制的自定义编码。
- en: Then, we discussed the HTTP protocol, explained how the first version works,
    and then talked about the differences and improvements of HTTP/2\. Then, we learned
    how to make an HTTP request using Go, followed by how to set up a web server.
    We explored how to serve existing files, how to associate different actions to
    different HTTP methods, and how to handle multipart requests and file uploads. We
    set up an HTTPS server easily, and then we learned what advantages are offered
    by some third-party libraries for web servers. Finally, we demonstrated how the
    template engine works in Go, and how to build an RPC client/server easily.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了HTTP协议，解释了第一个版本的工作原理，然后谈到了HTTP/2的差异和改进。然后，我们学习了如何使用Go发出HTTP请求，然后是如何设置Web服务器。我们探讨了如何提供现有文件，如何将不同的操作关联到不同的HTTP方法，以及如何处理多部分请求和文件上传。我们轻松地设置了一个HTTPS服务器，然后学习了一些第三方库为Web服务器提供的优势。最后，我们演示了模板引擎在Go中的工作原理，以及如何轻松构建RPC客户端/服务器。
- en: In the next chapter, we are going to cover how to use the main data interchange
    format such as JSON and XML, which can also be used to create web servers.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何使用JSON和XML等主要数据交换格式，这些格式也可以用于创建Web服务器。
- en: Questions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the advantage of using communication models?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用通信模型有什么优势？
- en: What's the difference between a TCP and a UDP connection?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP连接和UDP连接之间有什么区别？
- en: Who closes the request body when sending requests?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发送请求时，谁关闭了请求体？
- en: Who closes the body when receiving them in the server?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器接收时，谁关闭了请求体？
