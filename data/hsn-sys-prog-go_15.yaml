- en: Dealing with Channels and Goroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理通道和goroutines
- en: This chapter will cover concurrent programming with Go, using its basic built-in
    functionalities, channels, and goroutines. Concurrency describes the capability
    of executing different parts of an application during the same time period.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖使用Go进行并发编程，使用其基本内置功能、通道和goroutines。并发描述了在同一时间段内执行应用程序的不同部分的能力。
- en: Making software concurrent can be a powerful tool in building system applications
    because some operations can be started even if others have not yet ended.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使软件并发可以成为构建系统应用程序的强大工具，因为一些操作可以在其他操作尚未结束时开始。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding goroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解goroutines
- en: Exploring channels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索通道
- en: Advantage usage
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优势使用
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: Understanding goroutines
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解goroutines
- en: Go is a language that centers around concurrency, to the point where two of
    the main features—channels and goroutines—are part of the built-in package. We
    will now see how they work and what their basic functionalities are, starting
    with goroutines, which make it possible to execute parts of an application concurrently.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种以并发为中心的语言，以至于两个主要特性——通道和goroutines——都是内置包的一部分。我们现在将看到它们是如何工作以及它们的基本功能是什么，首先是goroutines，它使得可以并发执行应用程序的部分。
- en: Comparing threads and goroutines
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较线程和goroutines
- en: Goroutines are one of the primitives used for concurrency, but how do they differ
    from threads? Let's read about each of them here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines是用于并发的原语之一，但它们与线程有何不同？让我们在这里阅读它们的每一个。
- en: Threads
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: Current OSes are built for modern architectures that have processors with more
    than one core per CPU, or use technologies, such as hyper-threading, that allow
    a single core to support more than one thread. Threads are parts of processes
    that can be managed by the OS scheduler, which can assign them to a specific core/CPU.
    Like processes, threads carry information about the application execution, but
    the size of such information is smaller than processes. This includes the current
    instruction in the program, a stack of the current execution, and the variables
    needed for it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当前操作系统是为具有每个CPU多个核心的现代架构构建的，或者使用超线程等技术，允许单个核心支持多个线程。线程是可以由操作系统调度程序管理的进程的一部分，可以将它们分配给特定的核心/CPU。与进程一样，线程携带有关应用程序执行的信息，但是这些信息的大小小于进程。这包括程序中的当前指令，当前执行的堆栈以及所需的变量。
- en: The OS is already responsible for the context switch between processes; it saves
    the older process information and loads the new process information. This is called
    a **process context switch** and it's a very costly operation, even more than
    process execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统已经负责进程之间的上下文切换；它保存旧进程信息并加载新进程信息。这被称为**进程上下文切换**，这是一个非常昂贵的操作，甚至比进程执行更昂贵。
- en: In order to jump from one thread to another, the same operation can be done
    between threads. This is called a **t****hread context switch** and it is also
    a heavy operation—even if it is not as hefty as the process switch—because a thread
    carries less information than a process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从一个线程跳转到另一个线程，可以在线程之间执行相同的操作。这被称为**线程上下文切换**，它也是一个繁重的操作，即使它不像进程切换那样繁重，因为线程携带的信息比进程少。
- en: Goroutines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: Threads have a minimum size in memory; usually, it is in the order of MBs (2
    MB for Linux). The minimum size sets some limitations on the application creation
    of a new thread—if each thread is at least some MBs, 1,000 threads will occupy at
    least a few GBs of memory. The way that Go tackles these issues is through the
    use of a construct similar to threads, but this is handled by the language runtime
    instead of the OS. The size of a goroutine in memory is three orders of magnitude
    (2 KB per goroutine), meaning that the minimum memory usage of 1,000 goroutines
    is comparable to the memory usage of a single thread.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 线程在内存中有最小大小；通常，它的大小是以MB为单位的（Linux为2MB）。最小大小对新线程的应用程序创建设置了一些限制——如果每个线程至少有几MB，那么1,000个线程将占用至少几GB的内存。Go解决这些问题的方式是通过使用类似线程的构造，但这是由语言运行时而不是操作系统处理的。goroutine在内存中的大小是三个数量级（每个goroutine为2KB），这意味着1,000个goroutines的最小内存使用量与单个线程的内存使用量相当。
- en: 'This is obtained by defining what data the goroutines are retaining internally,
    using a data structure called `g` that describes the goroutine information, such
    as stack and status. This is an unexported data type in the `runtime` package and
    it can be found in the Go source code. Go keeps a track of OSes using another
    data structure from the same package called `m`. The logical processors that are
    acquired in order to execute a goroutine are stored in `p` structures. This can
    be verified in the Go `runtime` package documentation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过定义goroutines内部保留的数据来实现的，使用一个称为`g`的数据结构来描述goroutine信息，例如堆栈和状态。这是`runtime`包中的一个未导出的数据类型，并且可以在Go源代码中找到。Go使用来自相同包的另一个数据结构来跟踪操作系统，称为`m`。用于执行goroutine的逻辑处理器存储在`p`结构中。这可以在Go
    `runtime`包文档中进行验证：
- en: '`type g`: [golang.org/pkg/runtime/?m=all#m](https://golang.org/pkg/runtime/?m=all#g)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type g`: [golang.org/pkg/runtime/?m=all#m](https://golang.org/pkg/runtime/?m=all#g)'
- en: '`type m`: [golang.org/pkg/runtime/?m=all#g](https://golang.org/pkg/runtime/?m=all#m)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type m`: [golang.org/pkg/runtime/?m=all#g](https://golang.org/pkg/runtime/?m=all#m)'
- en: '`type p`: [golang.org/pkg/runtime/?m=all#p](https://golang.org/pkg/runtime/?m=all#p)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type p`: [golang.org/pkg/runtime/?m=all#p](https://golang.org/pkg/runtime/?m=all#p)'
- en: 'These three entities interact as follows—for each goroutine, a new `g` gets
    created, `g` is queued into `p`, and each `p` tries to acquire `m` to execute
    the code from `g`. There are some operations that will block the execution, such
    as these:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个实体的交互如下——对于每个goroutine，都会创建一个新的`g`，`g`被排入`p`，每个`p`都会尝试获取`m`来执行`g`中的代码。有一些操作会阻塞执行，例如这些：
- en: Built-in synchronization (channels and the `sync` package)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置同步（通道和`sync`包）
- en: System calls that are blocking, such as file operations
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞的系统调用，例如文件操作
- en: Network operations
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络操作
- en: When these kinds of operations happen, the runtime detaches `p` from `m` and
    uses (or creates, if it does not already exist) another dedicated `m` for the
    blocking operation. The thread becomes idle after executing such operations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些类型的操作发生时，运行时会将`p`从`m`中分离出来，并使用（或创建，如果尚不存在）另一个专用的`m`来执行阻塞操作。执行此类操作后，线程变为空闲状态。
- en: New goroutine
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的goroutine
- en: 'Goroutines are one of the best examples of how Go hides complexity behind a
    simple interface. When writing an application in order to launch a goroutine,
    all that is needed is to execute a function preceded by the `go` keyword:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines是Go如何在简单接口后隐藏复杂性的最佳示例之一。在编写应用程序以启动goroutine时，所需的只是执行一个以`go`关键字开头的函数：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The full example is available at [https://play.golang.org/p/3gPGZkJtJYv](https://play.golang.org/p/3gPGZkJtJYv).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/3gPGZkJtJYv](https://play.golang.org/p/3gPGZkJtJYv)找到。
- en: If we run the application of the previous example, we will see that it does
    not produce any output. Why? In Go, the application terminates when the main goroutine
    does, and it looks like this is the case. What happens is that the Go statements
    create the goroutine with the respective `runtime.g`, but this has to be picked
    up by the Go scheduler, and this does not happen because the program terminates
    right after the goroutine has been instantiated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上一个示例的应用程序，我们会发现它不会产生任何输出。为什么？在Go中，应用程序在主goroutine终止时终止，看起来是这种情况。发生的情况是，Go语句创建具有相应`runtime.g`的goroutine，但这必须由Go调度程序接管，而这并没有发生，因为程序在goroutine实例化后立即终止。
- en: 'Using the `time.Sleep` function to let the main goroutine wait (even a nanosecond!)
    is enough to let the scheduler pick up the goroutine and execute its code. This
    is shown in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`time.Sleep`函数让主goroutine等待（即使是一纳秒！）足以让调度程序挑选出goroutine并执行其代码。这在以下代码中显示：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The full example is available at [https://play.golang.org/p/2u125pTclv6](https://play.golang.org/p/2u125pTclv6).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/2u125pTclv6](https://play.golang.org/p/2u125pTclv6)找到。
- en: 'We already saw that Go methods also count as functions, which is why they can
    be executed concurrently the with `go` statement, as they were normal functions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Go方法也算作函数，这就是为什么它们可以像普通函数一样与`go`语句并发执行：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The full example is available at [https://play.golang.org/p/RUhgfRAPa2b](https://play.golang.org/p/RUhgfRAPa2b).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/RUhgfRAPa2b](https://play.golang.org/p/RUhgfRAPa2b)找到。
- en: 'Closures are anonymous functions, so they can be used as well, which is actually
    a very common practice:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是匿名函数，因此它们也可以被使用，这实际上是一个非常常见的做法：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full example is available at [https://play.golang.org/p/a-JvOVwAwUV](https://play.golang.org/p/a-JvOVwAwUV).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/a-JvOVwAwUV](https://play.golang.org/p/a-JvOVwAwUV)找到。
- en: Multiple goroutines
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个goroutines
- en: 'Organizing code in multiple goroutines can be helpful to split the work between
    processors and has many other advantages, as we will see in the next chapters. Since
    they are so lightweight, we can create a number of goroutines very easily using
    loops:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个goroutine中组织代码可以帮助将工作分配给处理器，并具有许多其他优势，我们将在接下来的章节中看到。由于它们如此轻量级，我们可以使用循环非常容易地创建多个goroutine：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The full example is available at [https://play.golang.org/p/Jaljd1padeX](https://play.golang.org/p/Jaljd1padeX).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/Jaljd1padeX](https://play.golang.org/p/Jaljd1padeX)找到。
- en: This example prints a list of numbers from `0` to `9` in parallel, using concurrent
    goroutines instead of doing the same thing sequentially in a single goroutine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例并行打印从`0`到`9`的数字列表，使用并发的goroutines而不是在单个goroutine中顺序执行相同的操作。
- en: Argument evaluation
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数评估
- en: 'If we change this example slightly by using a closure without arguments, we
    will see a very different result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微改变这个示例，使用没有参数的闭包，我们将看到一个非常不同的结果：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The full example is available at [https://play.golang.org/p/RV54AsYY-2y](https://play.golang.org/p/RV54AsYY-2y).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/RV54AsYY-2y](https://play.golang.org/p/RV54AsYY-2y)找到。
- en: 'If we run this program, we can see that the Go compiler issues a warning in
    the loop: `loop variable i captured by func literal`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此程序，我们会看到Go编译器在循环中发出警告：`循环变量i被函数文字捕获`。
- en: The variable in the loop gets referenced in the function we defined—the creation
    loop of the goroutines is quicker than goroutines executing, and the result is
    that the loop finishes before a single goroutine is started, resulting in the
    print of the value of the loop variable after the last iteration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 循环中的变量被引用在我们定义的函数中——goroutines的创建循环比goroutines的执行更快，结果是循环在单个goroutine启动之前就完成了，导致在最后一次迭代后打印循环变量的值。
- en: 'In order to avoid the error of the captured loop variable, it''s better to
    pass the same variable as an argument to the closure. The arguments of the goroutine
    function are evaluated upon creation, meaning that changes to that variable will
    not be reflected inside the goroutine, unless you are passing a reference to a
    value such as a pointer, map, slice, channel, or function. We can see this difference
    by running the following example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免捕获循环变量的错误，最好将相同的变量作为参数传递给闭包。 goroutine函数的参数在创建时进行评估，这意味着对该变量的更改不会在goroutine内部反映出来，除非您传递对值的引用，例如指针，映射，切片，通道或函数。我们可以通过运行以下示例来看到这种差异：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The full example is available at [https://play.golang.org/p/r1dtBiTUMaw](https://play.golang.org/p/r1dtBiTUMaw).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/r1dtBiTUMaw](https://play.golang.org/p/r1dtBiTUMaw)找到。
- en: Passing the argument by value is not influenced by the last assignment of the
    program, while passing a pointer type implies that changes done to the pointer
    content will be seen by the goroutine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递参数不受程序的最后赋值的影响，而传递指针类型意味着对指针内容的更改将被goroutine看到。
- en: Synchronization
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: 'Goroutines allow code to be executed concurrently, but the synchronization
    between values is not ensured out of the box. We can check out what happens when
    trying to use a variable concurrently with the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutine允许代码并发执行，但值之间的同步不能保证。我们可以看看在尝试并发使用变量时会发生什么，例如下面的例子：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We have an integer variable that changes in the main routine—doing a millisecond
    pause between each operation—and after the change, the value is printed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个整数变量，在主例程中更改——在每次操作之间进行毫秒暂停——并在更改后打印值。
- en: In another goroutine, there is a similar loop (using another variable) and another
    `print` statement that compares the two values. Considering that the pauses are
    the same, we would expect to see the same values, but this is not the case. We
    see that sometimes, the two goroutines are out of sync.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个goroutine中，有一个类似的循环（使用另一个变量）和另一个`print`语句来比较这两个值。考虑到暂停是相同的，我们期望看到相同的值，但事实并非如此。我们看到有时两个goroutine不同步。
- en: The changes are not reflected immediately because the memory is not synchronized
    instantaneously. We will learn how to ensure data synchronization in the next
    chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更改不会立即反映，因为内存不会立即同步。我们将在下一章中学习如何确保数据同步。
- en: Exploring channels
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索通道
- en: Channels are a concept that is unique to Go and a few other programming languages.
    Channels are very powerful tools that allow a simple method for synchronizing different
    goroutines, which is one of the ways we can solve the issue raised by the previous
    example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是Go和其他几种编程语言中独有的概念。通道是非常强大的工具，可以简单地实现不同goroutine之间的同步，这是解决前面例子中提出的问题的一种方法。
- en: Properties and operations
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和操作
- en: A channel is a built-in type in Go that is typed as arrays, slices, and maps.
    It is presented in the form of `chan type` and initialized by the `make` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是Go中的一种内置类型，类型为数组、切片和映射。它以`chan type`的形式呈现，并通过`make`函数进行初始化。
- en: Capacity and size
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容量和大小
- en: 'As well as the type that is traveling through the channel, there is another
    property that the channel has: its `capacity`. This represents the number of items
    a channel can hold before any new attempt to send an item is made, resulting in
    a blocking operation. The capacity of the channel is decided at its creation and
    its default value is `0`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过通道传输的类型之外，通道还具有另一个属性：它的`容量`。这代表了通道在进行任何新的发送尝试之前可以容纳的项目数量，从而导致阻塞操作。通道的容量在创建时决定，其默认值为`0`：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The capacity of the channel cannot be changed after its creation and can be
    read at any time using the built-in `cap` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的容量在创建后无法更改，并且可以随时使用内置的`cap`函数进行读取：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The full example is available at [https://play.golang.org/p/Yhz4bTxm5L8](https://play.golang.org/p/Yhz4bTxm5L8).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/Yhz4bTxm5L8](https://play.golang.org/p/Yhz4bTxm5L8)中找到。
- en: 'The `len` function, when used on a channel, tells us the number of elements
    that are held by the channel:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`函数在通道上使用时，告诉我们通道中保存的元素数量：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The full example is available at [https://play.golang.org/p/zJCL5VGmMsC](https://play.golang.org/p/zJCL5VGmMsC).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/zJCL5VGmMsC](https://play.golang.org/p/zJCL5VGmMsC)中找到。
- en: From the previous example, we can see how the channel capacity remains as `5` and
    the length grows with each element.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们可以看到通道容量保持为`5`，并且随着每个元素的增加而增加。
- en: Blocking operations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞操作
- en: 'If a channel is full or its capacity is `0`, then the operation will block.
    If we take the last example, which fills the channel and tries to execute another
    send operation, our application gets stuck:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通道已满或其容量为`0`，则操作将被阻塞。如果我们采用最后一个例子，填充通道并尝试执行另一个发送操作，我们的应用程序将被卡住。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The full example is available at [https://play.golang.org/p/uSfm5zWN8-x](https://play.golang.org/p/uSfm5zWN8-x).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/uSfm5zWN8-x](https://play.golang.org/p/uSfm5zWN8-x)中找到。
- en: 'When all goroutines are locked (in this specific case, we only have the main
    goroutine), the Go runtime raises a deadlock—a fatal error that terminates the
    execution of the application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有goroutine都被锁定时（在这种特定情况下，我们只有主goroutine），Go运行时会引发死锁，这是一个终止应用程序执行的致命错误：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is can happen with both receive or send operations, and it''s the symptom
    of an error in the application design. Let''s take the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能发生在接收或发送操作中，这是应用程序设计错误的症状。让我们看下面的例子：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the previous example, there is the `a <- 10` send operation and the matching `<-a` receive
    operation, but nevertheless, it results in a deadlock. However, the channel we
    created has no capacity, so the first send operation will block. We can intervene
    here in two ways:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，有`a <- 10`发送操作和匹配的`<-a`接收操作，但仍然导致死锁。然而，我们创建的通道没有容量，因此第一个发送操作将被阻塞。我们可以通过两种方式进行干预：
- en: '**By increasing the capacity**: This is a pretty easy solution that involves
    initializing the channel with `make(chan int, 1)`. It works best only if the number
    of receivers is known a priori; if it is higher than the capacity, then the problem
    appears again.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过增加容量**：这是一个非常简单的解决方案，涉及使用`make(chan int, 1)`初始化通道。只有在接收者数量是已知的情况下才能发挥最佳作用；如果它高于容量，则问题会再次出现。'
- en: '**By making the operations concurrent**: This is a far better approach because
    it uses the channels for what they made for—concurrency.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过使操作并发进行**：这是一个更好的方法，因为它使用通道来实现并发。'
- en: 'Let''s try to make the previous example work by using the second approach:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用第二种方法使前面的例子工作：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can see that there are no deadlocks here and the program prints the
    values correctly. Using the capacity approach will also make it work, but it will
    be tailored to the fact that we are sending a single message, while the other
    method will allow us to send any number of messages through the channel and receive
    them accordingly from the other side:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到这里没有死锁，程序正确打印了值。使用容量方法也可以使其工作，但它将根据我们发送单个消息的事实进行调整，而另一种方法将允许我们通过通道发送任意数量的消息，并从另一侧相应地接收它们：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The full example is available at [https://play.golang.org/p/RKcojupCruB](https://play.golang.org/p/RKcojupCruB).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/RKcojupCruB](https://play.golang.org/p/RKcojupCruB)找到。
- en: We now have a constant to store the number of operations executed, but there
    is a better and more idiomatic way to let a receiver know when there are no more
    messages. We will cover this in the next chapter about synchronization.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个常量来存储执行的操作次数，但有一种更好更惯用的方法可以让接收方知道没有更多的消息。我们将在下一章关于同步的内容中介绍这个。
- en: Closing channels
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'The best way of handling the end of a synchronization between a sender and
    a receiver is the `close` operation. This function is normally executed by the
    sender because the receiver can verify whether the channel is still open each
    time it gets a value using a second variable:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 处理发送方和接收方之间同步结束的最佳方法是`close`操作。这个函数通常由发送方执行，因为接收方可以使用第二个变量验证通道是否仍然打开：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second receiver is a Boolean that will be `true` if the channel is still
    open, and `false` otherwise. When a receive operation is done on a `close` channel,
    the second received variable will have the `false` value, and the first one will
    have the `0` value of the channel type, such as these:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个接收方是一个布尔值，如果通道仍然打开，则为`true`，否则为`false`。当在`close`通道上执行接收操作时，第二个接收到的变量将具有`false`值，第一个变量将具有通道类型的`0`值，如下所示：
- en: '`0` for numbers'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字为`0`
- en: '`false` for Booleans'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值为`false`
- en: '`""` for strings'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串为`""`
- en: '`nil` for slices, maps, or pointers'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于切片、映射或指针，使用`nil`
- en: 'The example of sending multiple messages can be rewritten using the `close` function,
    without having prior knowledge of how many messages will be sent:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`close`函数重写发送多条消息的示例，而无需事先知道将发送多少条消息：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The full example is available at [https://play.golang.org/p/GUzgG4kf5ta](https://play.golang.org/p/GUzgG4kf5ta).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/GUzgG4kf5ta](https://play.golang.org/p/GUzgG4kf5ta)找到。
- en: 'There is a more synthetic and elegant way to receive a message from a channel
    until it''s closed: by using the same keyword that we used to iterate maps, arrays,
    and slices. This is done through `range`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更简洁和优雅的方法可以接收来自通道的消息，直到它被关闭：通过使用我们用于迭代映射、数组和切片的相同关键字。这是通过`range`完成的：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One-way channels
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单向通道
- en: 'Another possibility when handling channel variables is specifying whether they
    are only for sending or only for receiving data. This is indicated by the `<-`
    arrow, which will precede `chan` if it''s just for receiving, or follow it if
    it''s just for sending:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理通道变量时的另一种可能性是指定它们是仅用于发送还是仅用于接收数据。这由`<-`箭头指示，如果仅用于接收，则将在`chan`之前，如果仅用于发送，则将在其后：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The full example is available at [https://play.golang.org/p/ZgEPZ99PLJv](https://play.golang.org/p/ZgEPZ99PLJv).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/ZgEPZ99PLJv](https://play.golang.org/p/ZgEPZ99PLJv)找到。
- en: 'Channels are already pointers, so casting one of them to its send-only or receive-only
    version will return the same channel, but will reduce the number of operations
    that can be performed on it. The types of channels are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通道已经是指针了，因此将其中一个转换为其只发送或只接收版本将返回相同的通道，但将减少可以在其上执行的操作数量。通道的类型如下：
- en: Send only channels, `chan<-`, which will allow you to send items, close the
    channel, and prevent you from sending data with a compile error.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只发送通道，`chan<-`，允许您发送项目，关闭通道，并防止您发送数据，从而导致编译错误。
- en: Receive only channel, `<-chan`, that will allow you to receive data, and any
    send or close operations will be compiling errors.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只接收通道，`<-chan`，允许您接收数据，任何发送或关闭操作都将导致编译错误。
- en: When a function argument is a send/receive channel, the conversion is implicit
    and it is a good practice to adopt because it prevents mistakes such as closing
    the channel from the receiver. We can take the other example and make use of the
    one-way channels with some refactoring.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数参数是发送/接收通道时，转换是隐式的，这是一个好习惯，因为它可以防止接收方关闭通道等错误。我们可以采用另一个示例，并利用单向通道进行一些重构。
- en: 'We can also create a function for sending values that uses a send-only channel:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个用于发送值的函数，该函数使用只发送通道：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Do the same thing for receiving using a receive-only channel:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接收，使用只接收通道：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And then, use them with the same channel that will be automatically converted
    in the one-way version:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用相同的通道，它将自动转换为单向版本：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The full example is available at [https://play.golang.org/p/pPuqpfnq8jJ](https://play.golang.org/p/pPuqpfnq8jJ).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/pPuqpfnq8jJ](https://play.golang.org/p/pPuqpfnq8jJ)找到。
- en: Waiting receiver
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待接收方
- en: Most of the examples we saw in the previous section had the sending operations
    done in a goroutine, and had the receiving operations done in the main goroutine.
    It could be the case that all operations are handled by goroutines, so do we synchronize
    the main one with the others?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到的大多数示例都是在goroutine中完成的发送操作，并且在主goroutine中完成了接收操作。可能情况是所有操作都由goroutine处理，那么我们如何将主操作与其他操作同步？
- en: A typical technique is the use of another channel used for the sole purpose
    of signaling that a goroutine has finished its job. The receiving goroutine knows
    that there are no more messages to get with the closure of the communication channel
    and it closes another channel that is shared with the main goroutine after finishing
    its operation. The `main` function can wait for the closure of the channel before
    exiting.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的技术是使用另一个通道，用于唯一的目的是信号一个goroutine已经完成了其工作。接收goroutine知道通过关闭通信通道没有更多的消息可获取，并在完成操作后关闭与主goroutine共享的另一个通道。`main`函数可以在退出之前等待通道关闭。
- en: 'The typical channel that is used for this scope does not carry any additional
    information except for whether it is open or closed, so it is usually a `chan
    struct{}` channel. This is because an empty data structure has no size in memory.
    We can see this pattern in action by making some changes to the previous example,
    starting with the receiver function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此范围的典型通道除了打开或关闭之外不携带任何其他信息，因此通常是`chan struct{}`通道。这是因为空数据结构在内存中没有大小。我们可以通过对先前示例进行一些更改来看到这种模式的实际应用，从接收函数开始：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The receiver function gets an extra argument—the channel. This is used to signal
    that the sender is done and the `main` function will use that channel to wait
    for the receiver to end its task:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接收函数得到了额外的参数——通道。这用于表示发送方已经完成，并且`main`函数将使用该通道等待接收方完成其任务：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full example is available at [https://play.golang.org/p/thPflJsnKj4](https://play.golang.org/p/thPflJsnKj4).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/thPflJsnKj4](https://play.golang.org/p/thPflJsnKj4)找到。
- en: Special values
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊值
- en: There are a couple of situations in which channels behave differently. We will
    now see what happens when a channel is set to its zero value—`nil`—or when it
    is already closed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通道在几种情况下的行为不同。我们现在将看看当通道设置为其零值`nil`时会发生什么，或者当它已经关闭时会发生什么。
- en: nil channels
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nil通道
- en: We have previously discussed how channels belong to the pointer types in Go,
    so their default value is `nil`. But what happens when you send or receive from
    a `nil` channel?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过通道在Go中属于指针类型，因此它们的默认值是`nil`。但是当您从`nil`通道发送或接收时会发生什么？
- en: 'If we create a very simple app that tries to send to an empty channel, we get
    a deadlock:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个非常简单的应用程序，尝试向空通道发送数据，我们会遇到死锁：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The full example is available at [https://play.golang.org/p/KHJ4rvxh7TM](https://play.golang.org/p/KHJ4rvxh7TM).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/KHJ4rvxh7TM](https://play.golang.org/p/KHJ4rvxh7TM)找到。
- en: 'If we do the same for a receiving operation, we get the same result of a deadlock:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对接收操作进行相同的操作，我们会得到死锁的相同结果：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The full example is available at [https://play.golang.org/p/gIjhy7aMxiR](https://play.golang.org/p/gIjhy7aMxiR).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/gIjhy7aMxiR](https://play.golang.org/p/gIjhy7aMxiR)找到。
- en: 'The last thing left to check is how the `close` function behaves with a `nil`
    channel. It panics with the `close of nil channel` explicit value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要检查的是`close`函数在`nil`通道上的行为。它会导致`close of nil channel`的明确值的恐慌：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The full example is available at [https://play.golang.org/p/5RjdcYUHLSL](https://play.golang.org/p/5RjdcYUHLSL).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/5RjdcYUHLSL](https://play.golang.org/p/5RjdcYUHLSL)找到。
- en: To recap, we have seen that a `nil` channel's send and receive are blocking
    operations, and that `close` causes a panic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经看到`nil`通道的发送和接收是阻塞操作，并且`close`会导致恐慌。
- en: Closed channels
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭通道
- en: 'We already know that receiving from a closed channel returns a zero value for
    the channel type, and a second Boolean is `false`. But what happens if we try
    to send something after closing the channel? Let''s find out with the help of
    the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道从关闭的通道接收会返回通道类型的零值，第二个布尔值为`false`。但是如果我们在关闭通道后尝试发送一些东西会发生什么？让我们通过以下代码来找出：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The full example is available at [https://play.golang.org/p/_l_xZt1ZojT](https://play.golang.org/p/_l_xZt1ZojT).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/_l_xZt1ZojT](https://play.golang.org/p/_l_xZt1ZojT)找到。
- en: 'If we try to send data after closing, it will return a very specific panic: `send
    on closed channel`. A similar thing will happen when we try to close a channel
    that has already been closed:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在关闭后尝试发送数据，将返回一个非常特定的恐慌：`在关闭的通道上发送`。当我们尝试关闭已经关闭的通道时，类似的事情会发生：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The full example is available at [https://play.golang.org/p/GHK7ERt1XQf](https://play.golang.org/p/GHK7ERt1XQf).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/GHK7ERt1XQf](https://play.golang.org/p/GHK7ERt1XQf)找到。
- en: This example will cause a panic with a specific value—`close of closed channel`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将导致特定值的恐慌——`关闭已关闭的通道`。
- en: Managing multiple operations
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个操作
- en: There are many situations in which more than one goroutines are executing their
    code and communicating through channels. A typical scenario is to wait for one
    of the channels' send or receive operations to be executed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，多个goroutine正在执行它们的代码并通过通道进行通信。典型的情况是等待其中一个通道的发送或接收操作被执行。
- en: When you operate with many channels, Go makes it possible to use a special keyword
    that executes something similar to `switch` but for channel operations. This is
    done with the `select` statement, followed by a series of `case` statements and
    an optional `default` case.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当您操作多个通道时，Go使得可以使用一个特殊的关键字来执行类似于`switch`的通道操作。这是通过`select`语句完成的，后面跟着一系列`case`语句和一个可选的`default`
    case。
- en: 'We can see a quick example of where we are receiving a value from a channel
    in a goroutine, and sending a value to another channel in a different goroutine.
    In these, the main goroutine we are using is a `select` statement to interact
    with the two channels, receive from the first, and send to the second:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个快速示例，我们在goroutine中从一个通道接收值，并在另一个goroutine中向另一个通道发送值。在这些示例中，主goroutine使用`select`语句与两个通道进行交互，从第一个接收，然后发送到第二个：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The full example is available at [https://play.golang.org/p/_8P1Edxe3o4](https://play.golang.org/p/_8P1Edxe3o4).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/_8P1Edxe3o4](https://play.golang.org/p/_8P1Edxe3o4)找到。
- en: When running this program in the playground, we can see that the receive operation
    from the second channel is always the first to finish. If we switch the execution
    order of the goroutines, we get the opposite results. The operation executed last
    is the one picked up first. This happens because the playground is a web service
    that runs and executes Go code in a safe environment and does some optimizations
    to make this operation deterministic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在playground中运行此程序时，我们可以看到从第二个通道的接收操作总是最先完成。如果我们改变goroutine的执行顺序，我们会得到相反的结果。最后执行的操作是首先接收的。这是因为playground是一个在安全环境中运行和执行Go代码的网络服务，并且进行了一些优化以使此操作具有确定性。
- en: Default clause
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认子句
- en: 'If we add a default case to the previous example, the result of the application
    execution will be very different, particularly if we change `select`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在上一个示例中添加一个默认情况，应用程序执行的结果将会非常不同，特别是如果我们改变`select`：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The full example is available at [https://play.golang.org/p/F1aE7ImBNFk](https://play.golang.org/p/F1aE7ImBNFk).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/F1aE7ImBNFk](https://play.golang.org/p/F1aE7ImBNFk)找到。
- en: 'The `select` statement will always choose the `default` statement. This happens
    because the goroutines are not picked up by the scheduler yet, when the `select` statement
    is executed. If we add a very small pause (using `time.Sleep`) before the `select`
    switch, we will have the scheduler pick at least one goroutine and we will then
    have one of the two operations executed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句将始终选择`default`语句。这是因为当执行`select`语句时，调度程序尚未选择goroutine。如果我们在`select`切换之前添加一个非常小的暂停（使用`time.Sleep`），我们将使调度程序至少选择一个goroutine，然后我们将执行两个操作中的一个：'
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The full example is available at [https://play.golang.org/p/-aXc3FN6qDj](https://play.golang.org/p/-aXc3FN6qDj).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/-aXc3FN6qDj](https://play.golang.org/p/-aXc3FN6qDj)找到。
- en: In this case, we will have a mixed set of operations executed, depending on
    which one gets picked up by the Go scheduler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有一组混合的操作被执行，具体取决于哪个操作被Go调度程序选中。
- en: Timers and tickers
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器和滴答器
- en: The `time` package offers a couple of tools that make it possible to orchestrate
    goroutines and channels—timers and tickers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`包提供了一些工具，使得可以编排goroutines和channels——定时器和滴答器。'
- en: Timers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: 'The utility that can replace the `default` clause in a `select` statement is
    the `time.Timer` type. This contains a receive-only channel that will return a
    `time.Time` value after the duration specified during its construction, using
    `time.NewTimer`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以替换`select`语句中的`default`子句的实用程序是`time.Timer`类型。这包含一个只接收通道，在其构造期间使用`time.NewTimer`指定持续时间后将返回一个`time.Time`值：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The full example is available at [https://play.golang.org/p/vCAff1kI4yA](https://play.golang.org/p/vCAff1kI4yA).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/vCAff1kI4yA](https://play.golang.org/p/vCAff1kI4yA)找到。
- en: A timer exposes a read-only channel, so it's not possible to close it. When
    created with `time.NewTimer`, it waits for the specified duration before firing
    a value in the channel.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器公开一个只读通道，因此无法关闭它。使用`time.NewTimer`创建时，它会在指定的持续时间之前等待在通道中触发一个值。
- en: The `Timer.Stop` method will try to avoid sending data through the channel and
    return whether it succeeded or not. If `false` is returned after trying to stop
    the timer, we still need to receive the value from the channel before being able
    to use the channel again.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer.Stop`方法将尝试避免通过通道发送数据并返回是否成功。如果尝试停止定时器后返回`false`，我们仍然需要在能够再次使用通道之前从通道中接收值。'
- en: '`Timer.Reset` restarts the timer with the given duration, and returns a Boolean
    as it happens with `Stop`. This value is either `true` or `false`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer.Reset`使用给定的持续时间重新启动定时器，并与`Stop`一样返回一个布尔值。这个值要么是`true`要么是`false`：'
- en: '`true` when the timer is active'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当定时器处于活动状态时为`true`
- en: '`false` when the timer was fired or stopped'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当定时器被触发或停止时为`false`
- en: 'We will test these functionalities with a practical example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个实际的示例来测试这些功能：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are creating a new timer of `1ms`. Here, we wait `0.5ms` and then stop it
    successfully:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的`1ms`定时器。在这里，我们等待`0.5ms`，然后成功停止它：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The full example is available at [https://play.golang.org/p/ddL_fP1UBVv](https://play.golang.org/p/ddL_fP1UBVv).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/ddL_fP1UBVv](https://play.golang.org/p/ddL_fP1UBVv)找到。
- en: Then, we are resetting the timer back to `1ms` and waiting for it to fire, to
    see whether `Stop` returns `false` and the channel gets drained.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定时器重置为`1ms`并等待它触发，以查看`Stop`是否返回`false`并且通道是否被排空。
- en: AfterFunc
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AfterFunc
- en: 'A very useful utility that uses `time.Timer` is the `time.AfterFunc` function, which
    returns a timer that will execute the passed function in its own goroutine when
    the timer fires:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`time.Timer`的一个非常有用的实用程序是`time.AfterFunc`函数，它返回一个定时器，当定时器触发时将在其自己的goroutine中执行传递的函数：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The full example is available at [https://play.golang.org/p/77HIIdlRlZ1](https://play.golang.org/p/77HIIdlRlZ1).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/77HIIdlRlZ1](https://play.golang.org/p/77HIIdlRlZ1)找到。
- en: In the previous example, we define two timers for two different closures, and
    we stop one of them and let the other trigger.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们为两个不同的闭包定义了两个定时器，并停止其中一个，让另一个触发。
- en: Tickers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滴答声
- en: '`time.Ticker` is similar to `time.Timer`, but its channel delivers more elements
    at regular intervals equal to the duration. They are specified when creating it
    with `time.NewTicker`.  This makes it possible to stop the ticker from firing
    with the `Ticker.Stop` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Ticker`类似于`time.Timer`，但其通道以持续时间相等的规则间隔提供更多的元素。它们在创建时使用`time.NewTicker`指定。这使得可以使用`Ticker.Stop`方法停止滴答器的触发：'
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The full example is available at [https://play.golang.org/p/8w8I7zIGe-_j](https://play.golang.org/p/8w8I7zIGe-_j).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可在[https://play.golang.org/p/8w8I7zIGe-_j](https://play.golang.org/p/8w8I7zIGe-_j)找到。
- en: In this example, we are also using `time.After`—a function that returns the
    channel from an anonymous `time.Timer`. This can be used when there's no need
    to stop the timer. There is another function, `time.Tick`, that returns the channel
    of an anonymous `time.Ticker`. Both functions will return a channel that the application
    has no control over and this channel will eventually be picked up by the garbage
    collector.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还使用了`time.After`——一个从匿名`time.Timer`返回通道的函数。当不需要停止计时器时，可以使用它。还有另一个函数`time.Tick`，它返回匿名`time.Ticker`的通道。这两个函数都会返回一个应用程序无法控制的通道，这个通道最终会被垃圾收集器回收。
- en: This concludes the overview of channels, from their properties and basic usage
    to some more advanced concurrency examples. We also checked some special cases
    and how to synchronize multiple channels.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了对通道的概述，从它们的属性和基本用法到一些更高级的并发示例。我们还检查了一些特殊情况以及如何同步多个通道。
- en: Combining channels and goroutines
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将通道和goroutines结合
- en: Now that we know the fundamental tools and properties of Go concurrency, we
    can use them to build better tools for our applications. We will see some examples
    that make use of channels and goroutines to solve real-world problems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Go并发的基本工具和属性，我们可以使用它们来为我们的应用程序构建更好的工具。我们将看到一些利用通道和goroutines解决实际问题的示例。
- en: Rate limiter
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速率限制器
- en: A typical scenario is having a web API that has a certain limit to the number
    of calls that can be done in a certain period of time. This type of API will just
    prevent the usage for a while if this threshold is crossed, making it unusable
    for the time being. When creating a client for the API, we need to be aware of
    this and make sure our application does not overuse it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的场景是有一个Web API在一定时间内对调用次数有一定限制。这种类型的API如果超过阈值，将会暂时阻止使用，使其在一段时间内无法使用。在为API创建客户端时，我们需要意识到这一点，并确保我们的应用程序不会过度使用它。
- en: 'That''s a very good scenario where we can use `time.Ticker` to define an interval
    between calls. In this example, we will create a client for Google Maps'' geocoding
    service that has a limit of 100,000 requests per 24 hours. Let''s start by defining
    the client:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的场景，我们可以使用`time.Ticker`来定义调用之间的间隔。在这个例子中，我们将创建一个客户端，用于Google Maps的地理编码服务，该服务在24小时内有10万次请求的限制。让我们从定义客户端开始：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The client is made by an HTTP client that will call maps, a ticker that will
    help prevent passing the rate limit, and needs an API key for authentication with
    the service. We can define a custom `Transport` struct for our use case that will
    inject the key in the request as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端由一个HTTP客户端组成，它将调用地图，一个ticker将帮助防止超过速率限制，并需要一个API密钥用于与服务进行身份验证。我们可以为我们的用例定义一个自定义的`Transport`结构，它将在请求中注入密钥，如下所示：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is a very good example of how Go interfaces allow the extension of their
    own behavior. We are defining a type that implements the `http.RoundTripper` interface,
    and also an attribute that is an instance of the same interface. The implementation
    injects the API key to the request before executing the underlying transport.
    This type allows us to define a helper function that creates a new client, where
    we are using the new transport that we defined together with the default one:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了Go接口如何允许扩展自己的行为。我们正在定义一个实现`http.RoundTripper`接口的类型，并且还有一个是相同接口的实例属性。实现在执行底层传输之前将API密钥注入请求。这种类型允许我们定义一个帮助函数，创建一个新的客户端，我们在这里使用我们定义的新传输和默认传输一起：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The maps geocoding API returns a series of addresses that are composed of various
    parts. This is available at [https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses](https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 地图地理编码API返回由各种部分组成的一系列地址。这可以在[https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses](https://developers.google.com/maps/documentation/geocoding/intro#GeocodingResponses)找到。
- en: 'The result is encoded in JSON, so we need a data structure that can receive
    it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以JSON格式编码，因此我们需要一个可以接收它的数据结构：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can use the structure to execute a reverse geocoding operation—getting a
    location from the coordinates by using the respective endpoint. We wait for the
    ticket before executing the HTTP request, remembering to `defer` the closure of
    the body:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个结构来执行反向地理编码操作——通过使用相应的端点从坐标获取位置。在执行HTTP请求之前，我们等待ticker，记得`defer`关闭body的闭包：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we can decode the result in a data structure that uses the `Result` type
    we already defined and checks for the `status` string:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以解码结果，使用我们已经定义的`Result`类型的数据结构，并检查`status`字符串：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we can use the client to geocode a series of coordinates, expecting
    the requests to be at least `860ms` from each other:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用客户端对一系列坐标进行地理编码，期望请求之间至少相隔`860ms`：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Workers
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者
- en: The previous example is a Google Maps client that uses a `time.Ticker` channel
    to limit the rate of the requests. The rate limit makes sense for an API key.
    Let's imagine that we have more API keys from different accounts, so we could
    potentially execute more requests.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是一个使用`time.Ticker`通道来限制请求速率的Google Maps客户端。速率限制对于API密钥是有意义的。假设我们有来自不同账户的更多API密钥，那么我们可能可以执行更多的请求。
- en: A very typical concurrent approach is the workers pool. Here, you have a series
    of clients that can be picked up to process an input and different parts of the
    application can ask to use such clients, returning the clients back when they
    are done.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常典型的并发方法是工作池。在这里，你有一系列的客户端可以被选中来处理输入，应用程序的不同部分可以请求使用这些客户端，在完成后将客户端返回。
- en: 'We can create more than one client that shares the same channels for both requests
    and responses, with requests being the coordinates and the results being the response
    from the service. Since the channel for responses is unique, we can define a custom
    type that holds all the information needed for that channel:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建多个共享相同通道的客户端，其中请求是坐标，响应是服务的响应。由于响应通道是唯一的，我们可以定义一个自定义类型，其中包含所有需要的通道信息：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next step is creating the channels—we are going to read a comma-separated
    list of values from an environment variable here. We will create a channel for
    requests, and one for responses. Both channels have a capacity equal to the number
    of workers, in this case, but this would work even if the channels were unbuffered.
    Since we are just using channels, we will need another channel, `done`, which
    signals whether a worker has finished working on their last job:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建通道-我们将从环境变量中读取一个逗号分隔的值列表。我们将创建一个用于请求的通道和一个用于响应的通道。这两个通道的容量等于工作人员的数量，在这种情况下，但即使通道是无缓冲的，这也可以工作。由于我们只是使用通道，我们将需要另一个通道“完成”，它表示工作人员是否已完成其最后一项工作：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we will create a goroutine for each of the keys, in which we define a
    client that feeds on the requests channel, executes the request, and sends the
    result to the dedicated channel. When the requests channel is closed, the goroutine
    will exit the range and send a message to the `done` channel, which is shown in
    the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为每个密钥创建一个goroutine，在其中定义一个客户端，该客户端在请求通道上提供数据，执行请求，并将结果发送到专用通道。当请求通道关闭时，goroutine将退出范围并向“完成”通道发送消息，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The locations can be sent to the request channel sequentially in another goroutine:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 位置可以按顺序发送到另一个goroutine中的请求通道：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can keep count of the done signals we are receiving and close the results
    channel when all the workers are done:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以统计我们收到的完成信号的数量，并在所有工作人员完成时关闭结果通道：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The channel is used to count how many workers are done, and once every one
    of them is done, it will close the result channel. This will allow us to just
    loop over it to get the result:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该通道用于计算有多少工作人员已完成，一旦所有工作人员都已完成，它将关闭结果通道。这将允许我们只需循环遍历它以获取结果：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using a channel is just one of the ways to wait for all the goroutines to finish,
    and we will see more idiomatic ways of doing it in the next chapter with the `sync`
    package.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通道只是等待所有goroutine完成的一种方式，我们将在下一章中使用“sync”包看到更多惯用的方法。
- en: Pool of workers
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作人员池
- en: A channel can be used as a pool of resources that allows us to request them
    on demand. In the following example, we will create a small application that will
    look up which addresses are valid in a network, using a third-party client from
    the `github.com/tatsushid/go-fastping` package.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以用作资源池，允许我们按需请求它们。在以下示例中，我们将创建一个小应用程序，该应用程序将查找在网络中哪些地址是有效的，使用来自“github.com/tatsushid/go-fastping”包的第三方客户端。
- en: 'The pool will have two methods, one for getting a new client and another to
    return the client back to the pool. The `Get` method will try to get an existing
    client from the channel or return a new one if this is not available. The `Put`
    method will try to put the client back in the channel, or discard it otherwise:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该池将有两种方法，一种用于获取新客户端，另一种用于将客户端返回到池中。“Get”方法将尝试从通道中获取现有客户端，如果不可用，则返回一个新客户端。“Put”方法将尝试将客户端放回通道，否则将丢弃它：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The client will need to specify which network needs to be scanned, so it requires
    a list of available networks starting with the `net.Interfaces` function, ranging
    through the interfaces and their addresses:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将需要指定需要扫描的网络，因此它需要一个从“net.Interfaces”函数开始的可用网络列表，然后遍历接口及其地址：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can accept a command-line argument to select between interfaces, and we
    can show a list of interfaces to the user to select when the argument is either
    not present or wrong:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以接受命令行参数以在接口之间进行选择，并且当参数不存在或错误时，我们可以向用户显示接口列表以进行选择：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `help` function is just a print of the interfaces IP:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: “help”函数只是一个接口IP的打印：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The next step is obtain the range of IPs that need to be checked:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取需要检查的IP范围：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now that we have the IP, we can create a function to obtain other IPs in the
    same network. IPs in Go are a byte slice, so we will replace the least significant
    bits in order to obtain the final address. Since the IP is a slice, its value
    will be overwritten by each operation (slices are pointers). We are going to update
    a copy of the original IP—because slices are pointers to the same array—in order
    to avoid overwrites:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了IP，我们可以创建一个函数来获取同一网络中的其他IP。在Go中，IP是一个字节切片，因此我们将替换最低有效位以获得最终地址。由于IP是一个切片，其值将被每个操作覆盖（切片是指针）。我们将更新原始IP的副本-因为切片是指向相同数组的指针-以避免覆盖：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we will need one channel for results and another for keeping a track
    of the goroutines; and for each IP, we need to check whether we can launch a goroutine
    for each address. We will use a pool of 10 clients and inside each goroutine—we
    will ask for each client, then return them to the pool. All valid IPs will be
    sent through the result channel:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将需要一个用于结果的通道和另一个用于跟踪goroutine的通道；对于每个IP，我们需要检查是否可以为每个地址启动goroutine。我们将使用10个客户端的池，在每个goroutine中-我们将为每个客户端请求，然后将它们返回到池中。所有有效的IP将通过结果通道发送：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Each time a routine finishes, we send a value in the `done` channel so we can
    keep count of the `done` signals received before exiting the application. This
    will be the result loop:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每次一个例程完成时，我们都会在“完成”通道中发送一个值，以便在退出应用程序之前统计接收到的“完成”信号的数量。这将是结果循环：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The loop will continue until the count from the channel reaches the number of
    goroutines. This concludes the more convoluted examples of the usage of channels
    and goroutines together.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将继续，直到通道中的计数达到goroutine的数量。这结束了一起使用通道和goroutine的更复杂的示例。
- en: Semaphores
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: Semaphores are tools used to solve concurrency issues. They have a certain number
    of available quotas that is used to limit the access to resources; also, various
    threads can request one or more quotas from it, and then release them when they
    are done. If the number of quotas available is one, it means that the semaphore
    supports only one access at time, with a behavior similar to mutexes. If the quota
    is more than one, we are referring to the most common type—the weighted semaphore.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是用于解决并发问题的工具。它们具有一定数量的可用配额，用于限制对资源的访问；此外，各种线程可以从中请求一个或多个配额，然后在完成后释放它们。如果可用配额的数量为1，则意味着信号量一次只支持一个访问，类似于互斥锁的行为。如果配额大于1，则我们指的是最常见的类型——加权信号量。
- en: 'In Go, a semaphore can be implemented using a channel with a capacity equal
    to the quotas, where you send a message to the channel to acquire a quota, and
    receive one from it to release:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，可以使用容量等于配额的通道来实现信号量，其中您向通道发送一条消息以获取配额，并从中接收一条消息以释放配额：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code shows us how to implement a semaphore using a channel in
    a few lines. Here''s an example of how to use it:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码向我们展示了如何使用几行代码在通道中实现信号量。以下是如何使用它的示例：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The full example is available at [https://play.golang.org/p/BR5GN2QopjQ](https://play.golang.org/p/BR5GN2QopjQ).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在[https://play.golang.org/p/BR5GN2QopjQ](https://play.golang.org/p/BR5GN2QopjQ)中找到。
- en: We can see from the previous example how the program serves some requests on
    the first round of acquisition, and the others on the second round, not allowing
    more than five executions at the same time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的示例中看到，程序在第一轮获取时为一些请求提供服务，而在第二轮获取时为其他请求提供服务，不允许同时执行超过五次。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we talked about the two main actors in Go concurrency—goroutines
    and channels. We started by explaining what a thread is, what the differences
    are between threads and goroutines, and why they are so convenient. Threads are
    heavy and require a CPU core, while goroutines are lightweight and not bound to
    a core. We saw how easily a new goroutine can be started by executing a function
    preceded by the `go` keyword, and how it is possible to start a series of different
    goroutines at once. We saw how the arguments of the concurrent functions are evaluated
    when the goroutine is created and not when it actually starts. We also saw that
    it is very difficult to keep different goroutines in sync without any additional
    tools.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Go并发中的两个主要角色——goroutines和通道。我们首先解释了线程是什么，线程和goroutines之间的区别，以及它们为什么如此方便。线程很重，需要一个CPU核心，而goroutines很轻，不绑定到核心。我们看到了一个新的goroutine可以通过在函数前加上`go`关键字来轻松启动，并且可以一次启动一系列不同的goroutines。我们看到了并发函数的参数在创建goroutine时进行评估，而不是在实际开始时进行。我们还看到，如果没有额外的工具，很难保持不同的goroutines同步。
- en: Then, we introduced channels that are used to share information between different
    goroutines and solve the synchronization problem that we mentioned previously.
    We saw that goroutines have a maximum capacity and a size—how many elements it
    is holding at present. Size cannot overcome capacity, and when an extra element
    is sent to a full channel, the operation blocks it until an element is removed
    from the channel. Receiving from a channel that is empty is also a blocking operation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了通道，用于在不同的goroutines之间共享信息，并解决我们之前提到的同步问题。我们看到goroutines有一个最大容量和一个大小——它目前持有多少元素。大小不能超过容量，当额外的元素发送到一个满的通道时，该操作会阻塞，直到从通道中删除一个元素。从一个空通道接收也是一个阻塞操作。
- en: We saw how to close channels with the `close` function, how this operation should
    be done in the same goroutine that sends data, and how operations behave in special
    cases such as `nil` or a closed channel. We introduced the `select` statement
    to choose between concurrent channel operations and control the application flow.
    Then, we introduced the tools related to concurrency from the `time` package—tickers
    and timers.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用`close`函数关闭通道，这个操作应该在发送数据的同一个goroutine中完成，以及在特殊情况下（如`nil`或关闭的通道）操作的行为。我们介绍了`select`语句来选择并发通道操作并控制应用程序流程。然后，我们介绍了与`time`包相关的并发工具——定时器和计时器。
- en: Finally, we showed some real-world examples, including a rate-limited Google
    Maps client and a tool to simultaneously ping all the addresses of a network.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了一些真实世界的例子，包括一个速率限制的Google Maps客户端和一个工具，可以同时ping网络中的所有地址。
- en: In the next chapter, we will look at some synchronization primitives that will
    allow a better handling of goroutines and memory, using more clear and simple
    code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究一些同步原语，这些原语将允许更好地处理goroutines和内存，使用更清晰和简单的代码。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a thread and who is responsible for it?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是线程，谁负责它？
- en: Why are goroutines different from threads?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么goroutines与线程不同？
- en: When are arguments evaluated when launching a goroutine?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动goroutine时何时评估参数？
- en: What's the difference between buffered and unbuffered channels?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓冲和非缓冲通道有什么区别？
- en: Why are one-way channels useful?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么单向通道有用？
- en: What happens when operations are done on `nil` or closed channels?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在`nil`或关闭的通道上进行操作时会发生什么？
- en: What are timers and tickers used for?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计时器和定时器用于什么？
