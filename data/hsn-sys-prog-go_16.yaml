- en: Synchronization with sync and atomic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sync和atomic进行同步
- en: This chapter will continue the journey into Go concurrency, introducing the
    `sync` and `atomic` packages, which are a couple of other tools designed for orchestrating synchronization
    between goroutines. This will make it possible to write elegant and simple code
    that allows concurrent usage of resources and manages a goroutine's lifetime.
    `sync` contains high-level synchronization primitives, while `atomic` contains
    low-level ones.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续介绍Go并发，介绍`sync`和`atomic`包，这是另外两个用于协调goroutine同步的工具。这将使编写优雅且简单的代码成为可能，允许并发使用资源并管理goroutine的生命周期。`sync`包含高级同步原语，而`atomic`包含低级原语。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Lockers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁
- en: Wait groups
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待组
- en: Other sync components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他同步组件
- en: The `atomic` package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atomic`包'
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information on this, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: Synchronization primitives
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步原语
- en: We saw how channels are focused on communication between goroutines, and now
    we will focus on the tools offered by the `sync` package, which includes the basic
    primitives for synchronization between goroutines. The first thing we will see
    is how to implement concurrent access to the same resource with lockers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到通道专注于goroutine之间的通信，现在我们将关注`sync`包提供的工具，其中包括用于goroutine之间同步的基本原语。我们将首先看到如何使用锁实现对同一资源的并发访问。
- en: Concurrent access and lockers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发访问和锁
- en: 'Go offers a generic interface for objects that can be locked and unlocked.
    Locking an object means taking control over it while unlocking releases it for
    others to use. This interface exposes a method for each operation. The following
    is an example of this in code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个通用接口，用于可以被锁定和解锁的对象。锁定对象意味着控制它，而解锁则释放它供其他人使用。该接口为每个操作公开了一个方法。以下是代码中的示例：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Mutex
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: The most simple implementation of locker is `sync.Mutex`. Since its method has
    a pointer receiver, it should not be copied or passed around by value. The `Lock()` method takes
    control of the mutex if possible, or blocks the goroutine until the mutex becomes
    available. The `Unlock()` method releases the mutex and it returns a runtime error
    if called on a non-locked one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的最简单实现是`sync.Mutex`。由于其方法具有指针接收器，因此不应通过值复制或传递。`Lock()`方法尝试控制互斥锁，如果可能的话，或者阻塞goroutine直到互斥锁可用。`Unlock()`方法释放互斥锁，如果在未锁定的情况下调用，则返回运行时错误。
- en: 'Here is a simple example in which we launch a bunch of goroutines using the
    lock to see which is executed first:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，我们在其中使用锁启动一堆goroutine，以查看哪个先执行：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The full example is available at: [https://play.golang.org/p/resVh7LImLf](https://play.golang.org/p/resVh7LImLf)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在以下链接找到：[https://play.golang.org/p/resVh7LImLf](https://play.golang.org/p/resVh7LImLf)
- en: We are using a channel to signal the main goroutine when a job is done, and
    exit the application. Let's create an external counter and increment it concurrently
    using goroutines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用通道来在作业完成时向主goroutine发出信号，并退出应用程序。让我们创建一个外部计数器，并使用goroutine并发地增加它。
- en: 'Operations executed on different goroutines are not thread-safe, as we can
    see from the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同goroutine上执行的操作不是线程安全的，如下例所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We would expect to have 5000 plus one, and 5000 minus one, with a `0` printed
    in the final instruction. However, what we get are different values each time
    we run the application. This happens because these kind of operations are not
    thread-safe, so two or more of them could happen at the same time, with the last
    one shadowing the others. This kind of phenomena is known as a **race condition**;
    that is, when more than one operation is trying to write the same result.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望得到5000加一和5000减一，最后一条指令打印出0。然而，每次运行应用程序时，我们得到的值都不同。这是因为这种操作不是线程安全的，因此两个或更多的操作可能同时发生，最后一个操作会覆盖其他操作。这种现象被称为**竞争条件**；也就是说，多个操作试图写入相同的结果。
- en: 'This means that without any synchronization, the result is not predictable;
    if we check the previous example and use a lock to avoid the race condition, we
    will have zero as the value for the integer—the result that we were expecting:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着没有任何同步，结果是不可预测的；如果我们检查前面的示例并使用锁来避免竞争条件，我们将得到整数的值为零，这是我们期望的结果：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A very common practice is embedding a mutex in a data structure to symbolize
    that the container is the one you want to lock. The counter variable from before
    can be represented as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的做法是在数据结构中嵌入一个互斥锁，以表示要锁定的容器。之前的计数器变量可以表示如下：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The operations that the counter performs can be methods that already take care
    of locking before the main operation, along with unlocking it afterward, as shown
    in the following code block:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器执行的操作可以是已经在主要操作之前进行了锁定并在之后进行了解锁的方法，如下面的代码块所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will simplify the goroutine loop, resulting in a much clearer code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将简化goroutine循环，使代码更清晰：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: RWMutex
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RWMutex
- en: The problem with race conditions is caused by concurred writing, not by reading
    the operation. The other data structure that implements the locker interface, `sync.RWMutex`,
    is made to support both these operations, having write locks that are unique and
    mutually exclusive with read locks. This means that the mutex can be locked either
    by a single write lock, or by one or more read locks. When a reader locks the
    mutex, other readers trying to lock it will not be blocked. They are often referred
    to as shared-exclusive locks. This allows read operations to happen all at the
    same time, without there being a waiting time.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件的问题是由并发写入引起的，而不是由读取操作引起的。实现locker接口的另一个数据结构`sync.RWMutex`，旨在支持这两种操作，具有独特的写锁和与读锁互斥。这意味着互斥锁可以被单个写锁或一个或多个读锁锁定。当读者锁定互斥锁时，其他试图锁定它的读者不会被阻塞。它们通常被称为共享-独占锁。这允许读操作同时发生，而不会有等待时间。
- en: The write lock operations are done using the `Lock` and `Unlock` methods of
    the locker interface. The reading operations are executed using two other methods: `RLock` and `RUnlock`.
    There is another method, `RLocker`, which returns a locker for reading operations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用locker接口的`Lock`和`Unlock`方法执行写锁操作。使用另外两种方法执行读取操作：`RLock`和`RUnlock`。还有另一种方法`RLocker`，它返回一个用于读取操作的locker。
- en: 'We can make a quick example of their usage by creating a concurrent list of
    strings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个字符串的并发列表来快速演示它们的用法：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can iterate the slice to find the selected value and use a read lock to
    delay the writing while we are reading:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以迭代切片以查找所选值，并在读取时使用读锁来延迟写入：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can use the write lock when adding new elements:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新元素时，我们可以使用写锁：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we can try to use several goroutines to execute the same operation on
    the list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以尝试使用多个goroutines在列表上执行相同的操作：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are checking whether the name is contained in the lock first, then we try
    to add the element. This causes more than one routine to attempt to add a new
    element, but since writing locks are exclusive, only one will succeed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们检查名称是否包含在锁中，然后尝试添加元素。这会导致多个例程尝试添加新元素，但由于写锁是排他的，只有一个会成功。
- en: Write starvation
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入饥饿
- en: When designing an application, this kind of mutex is not always the obvious
    choice, because in a scenario where there is a greater number of read locks and
    a few write ones, the mutex will be accepting incoming more read locks after the
    first, letting the write operation wait for a moment where there are no read locks
    active. This is a phenomenon referred to as **write starvation**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，这种类型的互斥锁并不总是显而易见的选择，因为在读锁的数量更多而写锁的数量较少的情况下，互斥锁将在第一个读锁之后接受更多的读锁，让写入操作等待没有活动的读锁的时刻。这是一种被称为**写入饥饿**的现象。
- en: 'To check this out, we can define a type that has both a write and a read operation,
    which take some time, as shown in the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这一点，我们可以定义一个类型，其中包含写入和读取操作，这需要一些时间，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can try to execute both write and read operations with the same cadence in
    separate goroutines, using a duration that is lower than the execution time of
    the methods (50 ms versus 100 ms). We will also check out how much time they spend
    in a locked state:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试在单独的goroutines中以相同的节奏执行写入和读取操作，使用低于方法执行时间的持续时间（50毫秒与100毫秒）。我们还将检查它们在锁定状态下花费了多少时间：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we execute the application, we see that for each write operation, more than
    one read is executed, and each next call is spending more time than the previous,
    waiting for the lock. This is not true for the read operation, which can happen
    at the same time, so as soon as a reader manages to lock the resource, all the
    other waiting readers will do the same. Replacing `RWMutex` with `Mutex` will
    make both operations have the same priority, as in the previous example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行应用程序，我们会发现对于每个写入操作，都会执行多次读取，并且每次调用都会花费比上一次更多的时间，等待锁。这对于读取操作并不成立，因为它可以同时进行，所以一旦读者成功锁定资源，所有其他等待的读者也会这样做。将`RWMutex`替换为`Mutex`将使两种操作具有相同的优先级，就像前面的例子一样。
- en: Locking gotchas
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定陷阱
- en: 'Some care must be taken when locking and unlocking mutexes in order to avoid
    unexpected behavior and deadlocks in the application. Take the following snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在锁定和解锁互斥锁时必须小心，以避免应用程序中的意外行为和死锁。参考以下代码片段：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code seems okay at first sight, but it will inevitably block the goroutine.
    This is because the `defer` statement is not executed at the end of each loop
    iteration, but when the function returns. So the first attempt will lock without
    releasing and the second attempt will remain stuck.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码乍一看似乎没问题，但它将不可避免地阻塞goroutine。这是因为`defer`语句不是在每次循环迭代结束时执行，而是在函数返回时执行。因此，第一次尝试将锁定而不释放，第二次尝试将保持锁定状态。
- en: 'A little refactor can help fix this, as shown in the following snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微重构一下可以帮助解决这个问题，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can use a closure to be sure that the deferred `Unlock` gets executed, even
    if `action` panics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用闭包来确保即使`action`发生恐慌，也会执行延迟的`Unlock`。
- en: 'If the kind of operations that are executed on the mutex will not cause panic,
    it can be a good idea to ditch the defer and just use it after executing the action,
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在互斥锁上执行的操作不会引起恐慌，可以考虑放弃延迟，只在执行操作后使用它，如下所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`defer` has a cost, so it is better to avoid it when it is not necessary, such
    as when doing a simple variable read or assignment.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`是有成本的，因此最好在不必要时避免使用它，例如在进行简单的变量读取或赋值时。'
- en: Synchronizing goroutines
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步goroutines
- en: 'Until now, in order to wait for goroutines to finish, we used a channel of
    empty structures and sent a value through the channel as the last operation, as
    follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，为了等待goroutines完成，我们使用了一个空结构的通道，并通过通道发送一个值作为最后一个操作，如下所示：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This strategy works, but it''s not the preferred way to accomplish the task.
    It''s not correct semantically, because we are using a channel, which is a tool
    for communication, to send empty data. This use case is about synchronization
    rather than communication. That''s why there is the `sync.WaitGroup` data structure,
    which covers such cases. It has a main status, called counter, which represents
    the number of elements waiting:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略有效，但不是实现任务的首选方式。从语义上讲不正确，因为我们使用通道，而通道是用于通信的工具，用于发送空数据。这种用例是关于同步而不是通信。这就是为什么有`sync.WaitGroup`数据结构，它涵盖了这种情况。它有一个主要状态，称为计数器，表示等待的元素数量：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `noCopy` field prevents the structure from being copied by value with `panic`.
    The state is an array made by three `int32`, but only the first and last entries
    are used; the remaining one is used for compiler optimizations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`noCopy`字段防止结构通过`panic`按值复制。状态是由三个`int32`组成的数组，但只使用第一个和最后一个条目；剩下的一个用于编译器优化。'
- en: 'The `WaitGroup` offers three methods to accomplish the same result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup`提供了三种方法来实现相同的结果：'
- en: '`Add`: This changes the value of the counter using the given value, which could
    also be negative. If the counter goes under zero, the application panics.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`：使用给定值更改计数器的值，该值也可以是负数。如果计数器小于零，应用程序将会panic。'
- en: '`Done`: This is a shorthand for `Add` with `-1` as the argument. It is usually
    called when a goroutine finishes its job to decrement the counter by 1.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Done`：这是`Add`的简写，参数为`-1`。通常在goroutine完成其工作时调用，将计数器减1。'
- en: '`Wait`: This operation blocks the current goroutine until the counter reaches
    zero.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait`：此操作会阻塞当前goroutine，直到计数器达到零。'
- en: 'Using the wait group results in a much cleaner and more readable code, as we
    can see in the following example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等待组可以使代码更清晰和可读，如下例所示：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To the wait group, we are adding a delta equal to goroutines, which we will
    launch beforehand. In each single goroutine, we are using the `Done` method to
    reduce the count. If the number of goroutines is not known, the `Add` operation
    (with `1` as its argument) can be executed before starting each goroutine, as
    shown in the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于等待组，我们正在添加一个等于goroutines的`delta`，我们将在之前启动。在每个单独的goroutine中，我们使用`Done`方法来减少计数。如果goroutines的数量未知，则可以在启动每个goroutine之前执行`Add`操作（参数为`1`），如下所示：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we have a 10% chance of finishing each iteration of
    the `for` loop, so we are adding one to the group before starting the goroutine.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们每次`for`循环迭代有10%的机会完成，因此在启动goroutine之前我们会向组中添加一个。
- en: 'A very common error is to add the value inside the goroutine, which usually
    results in a premature exit without any goroutines executed. This happens because
    the application creates the goroutines and executes the `Wait` function before
    the routines start and add their own delta, as in the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的错误是在goroutine内部添加值，这通常会导致在没有执行任何goroutine的情况下过早退出。这是因为应用程序在创建goroutines并执行`Wait`函数之前开始并添加它们自己的增量，如下例所示：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This application will not print anything because it arrives at the `Wait` statement
    before any goroutine is started and the `Add` method is called.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序不会打印任何内容，因为它在任何goroutine启动和调用`Add`方法之前到达`Wait`语句。
- en: Singleton in Go
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的单例
- en: 'The singleton pattern is a commonly used strategy for software development.
    This involves  restricting the number of instances of a certain type to one, using
    the same instance across the whole application. A very simple implementation of
    the concept could be the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是软件开发中常用的策略。这涉及将某种类型的实例数量限制为一个，并在整个应用程序中使用相同的实例。该概念的一个非常简单的实现可能是以下代码：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is perfectly fine in a consecutive scenario but in a concurrent one, like
    in many Go applications, this is not thread-safe and could generate race conditions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这在连续的情况下是完全可以的，但在并发的情况下，就像许多Go应用程序一样，这是不安全的，并且可能会产生竞争条件。
- en: 'The previous example could be made thread-safe by adding a lock that would
    avoid any race condition, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个锁，可以使前面的示例线程安全，从而避免任何竞争条件，如下所示：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is safe, but slower, because `Mutex` will be synchronizing each time the
    instance is requested.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安全的，但速度较慢，因为`Mutex`将在每次请求实例时进行同步。
- en: 'The best solution to implement this pattern, as shown in the following example,
    is to use the `sync.Once` struct that takes care of executing a function once
    using a combination of `Mutex` and `atomic` readings (which we will see in the
    second part of the chapter):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此模式的最佳解决方案是使用`sync.Once`结构，如下例所示，它负责使用`Mutex`和`atomic`读取一次执行函数（我们将在本章的第二部分中看到）：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The resulting code is idiomatic and clear, and has better performance compared
    to the mutex solution. Since the operation will be executed just the once, we
    can also get rid of the `nil` check we were doing on the instance in the previous
    examples.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果代码是惯用的和清晰的，与互斥解决方案相比性能更好。由于操作只会执行一次，我们还可以摆脱在先前示例中对实例进行的`nil`检查。
- en: Once and Reset
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次和重置
- en: The `sync.Once` function is made for executing another function once and no
    more. There is a very useful third-party library, which allows us to reset the
    state of the singleton using the `Reset` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Once`函数用于执行另一个函数一次，不再执行。有一个非常有用的第三方库，允许我们使用`Reset`方法重置单例的状态。'
- en: The package source code can be found at: [github.com/matryer/resync](https://github.com/matryer/resync).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 包的源代码可以在以下位置找到：[github.com/matryer/resync](https://github.com/matryer/resync)。
- en: Typical uses include some initialization that needs to be done again on a particular
    error, such as obtaining an API key or dialing again if the connection disrupts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 典型用途包括一些需要在特定错误上再次执行的初始化，例如获取API密钥或在连接中断时重新拨号。
- en: Resource recycling
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源回收
- en: 'We have already seen how to implement resource recycling, with a buffered channel with
    a pool of workers, in the previous chapter. There will be two methods as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在上一章中使用具有工作池的缓冲通道来实现资源回收。将有两种方法如下：
- en: A `Get` method that tries to receive a message from the channel or return a
    new instance.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Get`方法，尝试从通道接收消息或返回一个新实例。
- en: A `Put` method that tries to return an instance back to a channel or discard it.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Put`方法，尝试将实例返回到通道或丢弃它。
- en: 'This is a simple implementation of a pool with channels:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用通道实现的简单池的实现：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can improve this using the `sync.Pool` structure, which implements a thread-safe
    set of objects that can be saved or retrieved. The only thing that needs to be
    defined is the behavior of the pool when creating a new object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sync.Pool`结构来改进这一点，它实现了一个线程安全的对象集，可以保存或检索。唯一需要定义的是当创建一个新对象时池的行为：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The pool offers two methods: `Get` and `Put`. These methods return an object
    from the pool (or create a new one) and place the object back in the pool. Since
    the `Get` method returns an `interface{}`, the value needs to be cast to the specific
    type in order to be used correctly. We talked extensively about buffer recycling
    and in the following example, we will try to implement one using `sync.Pool`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 池提供两种方法：`Get`和`Put`。这些方法从池中返回对象（或创建新对象），并将对象放回池中。由于`Get`方法返回一个`interface{}`，因此需要将值转换为特定类型才能正确使用。我们已经广泛讨论了缓冲区回收，在以下示例中，我们将尝试使用`sync.Pool`来实现缓冲区回收。
- en: 'We will need to define the pool and functions to obtain and release new buffers.
    Our buffers will have an initial capacity of 4 KB, and the `Put` function will
    ensure that the buffer is reset before putting it back in the pool, as shown in
    the following code example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义池和函数来获取和释放新的缓冲区。我们的缓冲区将具有4 KB的初始容量，并且`Put`函数将确保在将其放回池之前重置缓冲区，如以下代码示例所示：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we will create a series of goroutines, which will use the `WaitGroup` to
    signal when they''re done, and will do the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一系列goroutine，它们将使用`WaitGroup`来在完成时发出信号，并将执行以下操作：
- en: Wait a certain amount of time (1-5 seconds).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待一定时间（1-5秒）。
- en: Acquire a buffer.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个缓冲区。
- en: Write information on the buffer.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缓冲区上写入信息。
- en: Copy the content to the standard output.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内容复制到标准输出。
- en: Release the buffer.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放缓冲区。
- en: 'We will use a sleep time equal to `1` second, plus another second every `4`
    iterations of the loop, up to `5`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用等于`1`秒的睡眠时间，每`4`次循环增加一秒，最多达到`5`秒：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The information in print also contains the buffer memory address. This will
    help us to confirm that the buffers are always the same and no new ones are created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的信息还包含缓冲区内存地址。这将帮助我们确认缓冲区始终相同，没有创建新的缓冲区。
- en: Slices recycling issues
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片回收问题
- en: 'With data structure with an underlying byte slice, such as `bytes.Buffer`,
    we should be careful when using them combined with `sync.Pool` or a similar mechanism
    of recycling. Let''s change the previous example and collect the buffer''s bytes
    instead of printing them to standard output. The following is an example code
    for this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有基础字节片的数据结构，例如`bytes.Buffer`，在与`sync.Pool`或类似的回收机制结合使用时，我们应该小心。让我们改变先前的示例，收集缓冲区的字节而不是将它们打印到标准输出。以下是此示例的示例代码：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, what happens when we print the list of byte slices? We can see this in
    the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们打印字节片段列表时会发生什么？我们可以在以下示例中看到这一点：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We get an unexpected result as the buffers have been overwritten. That's because
    the buffers are reusing the same underlying slice and overriding the content with
    every new usage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区正在重用相同的基础切片，并且在每次新使用时覆盖内容，因此我们得到了意外的结果。
- en: 'A solution to this problem is usually to execute a copy of the bytes, instead
    of just assigning them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常解决此问题的方法是执行字节的副本，而不仅仅是分配它们：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Conditions
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: 'In concurrent programming, a condition variable is a synchronization mechanism
    that contains threads waiting for the same condition to verify. In Go, this means
    that there are some goroutines waiting for something to occur. We already did
    an implementation of this using channels with a single goroutine waiting, as shown
    in the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中，条件变量是一个同步机制，其中包含等待相同条件进行验证的线程。在Go中，这意味着有一些goroutine在等待某些事情发生。我们已经使用单个goroutine等待通道的实现，如以下示例所示：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This approach is limited to a single goroutine, but it can be improved to support
    more listeners switching from message-sending to closing down the channel:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法仅限于单个goroutine，但可以改进为支持更多侦听器，从发送消息切换到关闭通道：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Closing the channel works for more than one listener, but it does not allow
    them to use the channel any further after it closes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭通道适用于多个侦听器，但在关闭后不允许它们进一步使用通道。
- en: 'The `sync.Cond` type is a tool that makes it possible to handle all this behavior
    in a better way. It uses a locker in its implementation and exposes three methods:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Cond`类型是一个工具，可以更好地处理所有这些行为。它在实现中使用锁，并公开三种方法：'
- en: '`Broadcast`: This wakes all goroutines waiting for the condition.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Broadcast`：这会唤醒等待条件的所有goroutine。'
- en: '`Signal`: This wakes a single goroutine waiting for the condition, if there
    is at least one.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Signal`：如果至少有一个条件，则唤醒等待条件的单个goroutine。'
- en: '`Wait`: This unlocks the locker, suspends execution of the goroutine, and later
    resumes the execution and locks it again, waiting for a `Broadcast` or `Signal`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wait`：这会解锁锁定器，暂停goroutine的执行，稍后恢复执行并再次锁定它，等待`Broadcast`或`Signal`。'
- en: It is not required, but the `Broadcast` and `Signal` operations can be done
    while holding the locker, locking it before and releasing it after. The `Wait`
    method requires holding the locker before calling and unlocking it after the condition
    has been used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是必需的，但可以在持有锁时执行`Broadcast`和`Signal`操作，在调用之前锁定它，之后释放它。`Wait`方法要求在调用之前持有锁，并在使用条件后解锁。
- en: 'Let''s create a concurrent application which uses `sync.Cond` to orchestrate
    more goroutines. We will have a prompt from the command line, and each record
    will be written to a series of files. We will have a main structure that holds
    all the data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个并发应用程序，该应用程序使用`sync.Cond`来协调更多的goroutines。我们将从命令行获得提示，每条记录将被写入一系列文件。我们将有一个主结构来保存所有数据：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The condition we will be monitoring is a change in the `buf` field. In the
    `Run` method, the `record` structure will start several goroutines, one for each
    writer. Each goroutine will be waiting for the condition to trigger and will write
    in its file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将监视的条件是`buf`字段的更改。在`Run`方法中，`record`结构将启动多个goroutines，每个写入者一个。每个goroutine将等待条件触发，并将写入其文件：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can see that we lock the condition before using `Wait`, and we unlock it
    after using the value that our condition refers to. The main function will create
    a record and a series of files, according to the command-line arguments provided:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在使用`Wait`之前锁定条件，并在使用我们条件引用的值之后解锁它。主函数将根据提供的命令行参数创建一个记录和一系列文件：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will then use `bufio.Scanner` to read lines and broadcast the change of
    the `buf` field. We will also accept a special value, `\q`, as a quit command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用`bufio.Scanner`读取行并广播`buf`字段的更改。我们还将接受特殊值`\q`作为退出命令：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see that the change of `buf` is done while holding the lock and this
    is followed by the call to `Broadcast`, which wakes up all the goroutines waiting
    for the condition.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在持有锁时更改`buf`，然后调用`Broadcast`唤醒等待条件的所有goroutines。
- en: Synchronized maps
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步地图
- en: 'Built-in maps in Go are not thread-safe, and, therefore, trying to write from
    different goroutines can cause a runtime error: `concurrent map writes`. We can
    verify this using a simple program that tries to make changes concurrently:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的内置地图不是线程安全的，因此尝试从不同的goroutines进行写入可能会导致运行时错误：`concurrent map writes`。我们可以使用一个简单的程序来验证这一点，该程序尝试并发进行更改：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Reading while writing is also a runtime error, `concurrent map iteration and
    map write`, which we can see by running the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入时进行读取也会导致运行时错误，即`concurrent map iteration and map write`，我们可以通过运行以下示例来看到这一点：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Sometimes, trying to iterate a map (as the `Print` statement does) can cause
    panic such as `index out of range`, because the internal slices may have been
    allocated somewhere else.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，尝试迭代地图（如`Print`语句所做的那样）可能会导致恐慌，例如`index out of range`，因为内部切片可能已经在其他地方分配了。
- en: 'A very easy strategy to make a map concurrent is to couple it with `sync.Mutex` or `sync.RWMutex`.
    This makes it possible to lock the map when executing the operations:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使地图并发的一个非常简单的策略是将其与`sync.Mutex`或`sync.RWMutex`配对。这样可以在执行操作时锁定地图：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We use the map for getting or setting the value, such as the following, for
    instance:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用地图来获取或设置值，例如以下示例：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also pass a function that takes a key-value pair and executes it for
    each tuple, while locking the map:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以传递一个接受键值对并对每个元组执行的函数，同时锁定地图：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Go 1.9 introduced a structure called `sync.Map` that does exactly this. It
    is a very generic `map[interface{}]interface{}`, which makes it possible to execute
    thread-safe operations using the following methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.9引入了一个名为`sync.Map`的结构，它正是这样做的。它是一个非常通用的`map[interface{}]interface{}`，可以使用以下方法执行线程安全操作：
- en: '`Load`: Gets a value from the map for the given key.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load`：从地图中获取给定键的值。'
- en: '`Store`: Sets a value in the map for the given key.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`：为给定的键在地图中设置一个值。'
- en: '`Delete`: Removes the entry for the given key from the map.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delete`：从地图中删除给定键的条目。'
- en: '`LoadOrStore`: Returns the value for the key, if present, or the stored value.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadOrStore`：返回键的值（如果存在）或存储的值。'
- en: '`Range`: Calls a function that returns a Boolean for each key-value pair in
    the map. The iteration stops if `false` is returned.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range`：调用一个函数，该函数针对地图中的每个键值对返回一个布尔值。如果返回`false`，则迭代停止。'
- en: 'We can see how this works in the following snippet, in which we try to attempt
    several writes at the same time:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码片段中看到这是如何工作的，我们尝试同时进行多次写入：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This application, unlike the version with a regular `Map`, does not crash and
    executes all the operations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有常规`Map`的版本不同，此应用程序不会崩溃并执行所有操作。
- en: Semaphores
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: In the previous chapter, we saw how it is possible to use channels to create
    weighted semaphores. There is a better implementation in the experimental `sync`
    package. This can be found at: [golang.org/x/sync/semaphore](https://godoc.org/golang.org/x/sync/semaphore).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到可以使用通道创建加权信号量。在实验性的`sync`包中有更好的实现。可以在[golang.org/x/sync/semaphore](https://godoc.org/golang.org/x/sync/semaphore)找到。
- en: This implementation makes it possible to create a new semaphore, specifying
    the weight with `semaphore.NewWeighted`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现使得可以创建一个新的信号量，使用`semaphore.NewWeighted`指定权重。
- en: 'Quotas can be acquired using the `Acquire` method, specifying how many quotas
    you want to acquire. These can be released using the `Release` method, as shown
    in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Acquire`方法获取配额，指定要获取的配额数量。这些可以使用`Release`方法释放，如以下示例所示：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Acquiring quotas requires another argument besides the number, which is `context.Context`.
    This is another concurrency tool available in Go and we are going to see how to
    use this in the next chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 获取配额除了数字之外还需要另一个参数，即`context.Context`。这是Go中可用的另一个并发工具，我们将在下一章中看到如何使用它。
- en: Atomic operations
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作
- en: The `sync` package delivers synchronization primitives, and, under the hood,
    it is using thread-safe operations on integers and pointers. We can find these
    functionalities in another package called `sync/atomic`, which can be used to
    create tools specific to the user use case, with better performance and less memory
    usage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync`包提供了同步原语，在底层使用整数和指针的线程安全操作。我们可以在另一个名为`sync/atomic`的包中找到这些功能，该包可用于创建特定于用户用例的工具，具有更好的性能和更少的内存使用。'
- en: Integer operations
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数操作
- en: 'There is a series of functions for pointers to the different types of integers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列针对不同类型整数的指针的函数：
- en: '`int32   `'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32`'
- en: '`int64   `'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64`'
- en: '`uint32  `'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32`'
- en: '`uint64`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint64`'
- en: '`uintptr `'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uintptr`'
- en: 'This includes a specific type of integer that represents a pointer, `uintptr`.
    The operation available for these types are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括表示指针的特定类型的整数，`uintptr`。这些类型可用的操作如下：
- en: '`Load`: Retrieves the integer value from the pointer'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Load`：从指针中检索整数值'
- en: '`Store`: Stores the integer value in the pointer'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`：将整数值存储在指针中'
- en: '`Add`: Adds the specified delta to the pointer value'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`：将指定的增量添加到指针值'
- en: '`Swap`: Stores a new value in the pointer and returns the old one'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Swap`：将新值存储在指针中并返回旧值'
- en: '`CompareAndSwap`: Swaps the new value for the old one only if this is the same
    as the specified one'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompareAndSwap`：仅当新值与指定值相同时才将其交换'
- en: clicker
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击器
- en: 'This function can be very helpful for defining thread-safe components really
    easily. A very obvious example could be a simple integer counter that uses `Add`
    to change the counter, `Load` to retrieve the current value, and `Store` to reset
    it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对于非常容易定义线程安全的组件非常有帮助。一个非常明显的例子可能是一个简单的整数计数器，它使用`Add`来改变计数器，`Load`来检索当前值，`Store`来重置它：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can see it in action in a simple program, which tries to read, write, and
    reset the counter concurrently.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个简单的程序中看到它的运行情况，该程序尝试同时读取、写入和重置计数器。
- en: 'We define the `clicker` and `WaitGroup` and add the correct number of elements
    to the wait group as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`clicker`和`WaitGroup`，并将正确数量的元素添加到等待组中，如下所示：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can launch a bunch of goroutines doing different actions, such as: 10 reads,
    10 adds, and a reset:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以启动一堆不同操作的goroutines，比如：10次读取，10次添加和一次重置：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We will see the clicker acting as it is supposed to, executing concurrent sums
    without race conditions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到点击器按照预期的方式执行并发求和而没有竞争条件。
- en: Thread-safe floats
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全的浮点数
- en: The `atomic` package offers only primitives for integers, but since `float32`
    and `float64` are stored in the same data structure that `int32` and `int64` use,
    we use them to create an atomic float value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`atomic`包仅提供整数的原语，但由于`float32`和`float64`存储在与`int32`和`int64`相同的数据结构中，我们使用它们来创建原子浮点值。'
- en: 'The trick is to use the `math.Floatbits` functions to get the representation
    of a float as an unsigned integer and the `math.Floatfrombits` functions to transform
    an unsigned integer to a float. Let''s see how this works with a `float64`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是使用`math.Floatbits`函数将浮点数表示为无符号整数，以及使用`math.Floatfrombits`函数将无符号整数转换为浮点数。让我们看看这如何在`float64`中工作：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Creating the `Add` function is a little bit more complicated. We need to get
    the value with `Load`, then compare and swap. Since this operation could fail
    because the load is an `atomic` operation and **compare and swap** (**CAS**) is
    another, we keep trying it until it succeeds in a loop:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Add`函数有点复杂。我们需要使用`Load`获取值，然后比较和交换。由于这个操作可能失败，因为加载是一个`atomic`操作，**比较和交换**（**CAS**）是另一个，我们在循环中不断尝试直到成功：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Thread-safe Boolean
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全的布尔值
- en: 'We can also use `int32` to represent a Boolean value. We can use the integer `0` as `false`, and `1` as `true`,
    creating a thread-safe Boolean condition:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`int32`来表示布尔值。我们可以使用整数`0`作为`false`，`1`作为`true`，创建一个线程安全的布尔条件：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will allow us to use the `cond` type as a thread-safe Boolean value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们将`cond`类型用作线程安全的布尔值。
- en: Pointer operations
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针操作
- en: Pointer variables in Go are stored in `intptr` variables, integers large enough
    to hold a memory address. The `atomic` package makes it possible to execute the
    same operations for other integers types. There is a package that allows unsafe
    pointer operations, which offers the `unsafe.Pointer` type that is used in atomic
    operations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的指针变量存储在`intptr`变量中，这些整数足够大以容纳内存地址。`atomic`包使得可以对其他整数类型执行相同的操作。有一个允许不安全指针操作的包，它提供了`unsafe.Pointer`类型，用于原子操作。
- en: 'In the following example, we define two integer variables and their relative
    integer pointers. Then we execute a swap of the first pointer with the second:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了两个整数变量及其相关的整数指针。然后我们执行第一个指针与第二个指针的交换：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After the swap, both pointers are now referring to the second variable; any
    change to the first value does not influence the pointers. Changing the second
    variable changes the value referred to by the pointers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 交换后，两个指针现在都指向第二个变量；对第一个值的任何更改都不会影响指针。更改第二个变量会改变指针所指的值。
- en: Value
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值
- en: The simplest tool we can use is `atomic.Value`. This holds `interface{}` and
    makes it possible to read and write it with thread safety. It exposes two methods, `Store` and `Load`,
    which make it possible to set or retrieve the value. As it happens, for other
    thread-safe tools, `sync.Value` must not be copied after its first use.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的最简单的工具是`atomic.Value`。它保存`interface{}`，并且可以通过线程安全地读取和写入它。它公开了两种方法，`Store`和`Load`，这使得设置或检索值成为可能。正如其他线程安全工具一样，`sync.Value`在第一次使用后不能被复制。
- en: 'We can try to have many goroutines to set and read the same value. Each load
    operation gets the latest stored value and there are no errors being raised by
    concurrency:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试有许多goroutines来设置和读取相同的值。每次加载操作都会获取最新存储的值，并且并发时不会出现错误：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is a very generic container; it can be used for any type of variable and
    the variable type should change from one to another. If the concrete type changes,
    it will make the method panic; the same thing applies to a `nil` empty interface.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常通用的容器；它可以用于任何类型的变量，变量类型应该从一个变为另一个。如果具体类型发生变化，它将使方法恐慌；同样的情况也适用于`nil`空接口。
- en: Under the hood
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层
- en: 'The `sync.Value` type stores its data in a non-exported interface, as shown
    by the source code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Value`类型将其数据存储在一个非公开的接口中，如源代码所示：'
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It uses a type of `unsafe` package to convert that structure into another one,
    which has the same data structure as an interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`unsafe`包的一种类型来将该结构转换为另一个具有与接口相同的数据结构：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Two types with the same exact memory layout can be converted in this way, skipping
    the Go's type safety. This makes it possible to use `atomic` operations with the
    pointers and execute thread-safe `Store` and `Load` operations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 具有完全相同内存布局的两种类型可以以这种方式转换，跳过Go的类型安全性。这使得可以使用指针进行 `atomic` 操作，并执行线程安全的 `Store`
    和 `Load` 操作。
- en: To get the lock for writing values, `atomic.Value` uses a compare and swap operation
    with the `unsafe.Pointer(^uintptr(0))` value (which is `0xffffffff`) in the type;
    it changes the value and replaces the type with the correct one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了写入值获取锁，`atomic.Value` 使用与类型中的 `unsafe.Pointer(^uintptr(0))` 值（即 `0xffffffff`）进行比较和交换操作；它改变值并用正确的值替换类型。
- en: In the same way, the load operation loops until the type is different to `0xffffffff`,
    before trying to read the value.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，加载操作会循环，直到类型不同于 `0xffffffff`，然后尝试读取值。
- en: Using this expedient, `atomic.Value` is capable of storing and loading any value
    using other `atomic` operations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，`atomic.Value` 能够使用其他 `atomic` 操作存储和加载任何值。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we saw the tools that are available in the Go standard package
    for synchronization. They are located in two packages: `sync`, which provides
    high-level tools such as mutexes, and `sync/atomic`, which executes low-level
    operations.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Go标准包中用于同步的工具。它们位于两个包中：`sync`，提供诸如互斥锁之类的高级工具，以及 `sync/atomic`，执行低级操作。
- en: First, we saw how to synchronize data using lockers. We saw how to use `sync.Mutex` to
    lock a resource regardless of the operation type, and `sync.RWMutex` to allow
    for concurrent readings and blocking writes. We should be careful using the second
    one because writes could be delayed by consecutive readings.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到了如何使用锁同步数据。我们看到了如何使用 `sync.Mutex` 来锁定资源，而不管操作类型如何，并使用 `sync.RWMutex`
    允许并发读取和阻塞写入。我们应该小心使用第二个，因为连续读取可能会延迟写入。
- en: Next, we saw how to keep track of running operations in order to wait for the
    end of a series of goroutines, using `sync.WaitGroup`. This acts as a thread-safe
    counter for current goroutines and makes it possible to put the current goroutine
    to sleep until it reaches zero, using the `Wait` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了如何跟踪正在运行的操作，以便等待一系列goroutine的结束，使用 `sync.WaitGroup`。这充当当前goroutine的线程安全计数器，并使得可以使用
    `Wait` 方法将当前goroutine置于休眠状态，直到计数达到零。
- en: Furthermore, we checked the `sync.Once` structure used to execute a functionality
    once, which allows the implementation of a thread-safe singleton, for instance.
    Then we used `sync.Pool` to reuse instances instead of creating new ones when
    possible. The only thing that a pool needs is the function that returns the new
    instance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们检查了 `sync.Once` 结构，用于执行功能一次，例如允许实现线程安全的单例。然后我们使用 `sync.Pool` 在可能的情况下重用实例而不是创建新实例。池需要的唯一东西是返回新实例的函数。
- en: The `sync.Condition` struct represents a specific condition and uses a locker
    to change it, allowing a goroutine to wait for the change. This can be delivered
    to a single goroutine using `Signal`, or to all goroutines using `Broadcast`.
    The package also offers a thread-safe version of `sync.Map`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.Condition` 结构表示特定条件并使用锁来改变它，允许goroutine等待改变。这可以使用 `Signal` 传递给单个goroutine，或者使用
    `Broadcast` 传递给所有goroutine。该包还提供了 `sync.Map` 的线程安全版本。'
- en: 'Finally, we checked out the functionalities of `atomic`, which are mostly integer
    thread-safe operations: loading, saving, adding, swapping, and CAS. We saw also `atomic.Value`,
    which that makes it possible to change the value of an interface concurrently
    and does not allow it to change type after the first change.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查了 `atomic` 的功能，这些功能主要是整数线程安全操作：加载、保存、添加、交换和CAS。我们还看到了 `atomic.Value`，它使得可以并发更改接口的值，并且在第一次更改后不允许更改类型。
- en: The next chapter will be about the latest element introduced in Go concurrency: `Context`,
    which is an interface that handles deadlines, cancellations, and much more.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍Go并发中引入的最新元素：`Context`，这是一个处理截止日期、取消等的接口。
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's a race condition?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞争条件？
- en: What happens when you try to execute read and write operations concurrently
    with a map?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您尝试并发执行地图的读取和写入操作时会发生什么？
- en: What's the difference between `Mutex` and `RWMutex`?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mutex` 和 `RWMutex` 之间有什么区别？'
- en: Why are wait groups useful?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待组有什么用？
- en: What's the main use of `Once`?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Once` 的主要用途是什么？'
- en: How can you use a `Pool`?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您如何使用 `Pool`？
- en: What's the advantage of using atomic operations?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原子操作的优势是什么？
