- en: Coordination Using Context
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文进行协调
- en: This chapter is about the relatively new context package and its usage in concurrent
    programming. It is a very powerful tool by defining a unique interface that's
    used in many different places in the standard library, as well as in many third-party
    packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于相对较新的上下文包及其在并发编程中的使用。它是一个非常强大的工具，通过定义一个在标准库中的许多不同位置以及许多第三方包中使用的独特接口。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding what context is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解上下文是什么
- en: Studying its usage in the standard library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标准库中研究其用法
- en: Creating a package that uses context
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建使用上下文的包
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go概述*。
- en: Understanding context
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解上下文
- en: Context is a relatively new component that entered the standard library in version
    1.7\. It is an interface for synchronization between goroutines that was used
    internally by the Go team and ended up being a core part of the language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是在1.7版本中进入标准库的相对较新的组件。它是用于goroutine之间同步的接口，最初由Go团队内部使用，最终成为语言的核心部分。
- en: The interface
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'The main entity in the package is `Context` itself, which is an interface.
    It has only four methods:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该包中的主要实体是`Context`本身，它是一个接口。它只有四种方法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s learn about these four methods here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里了解这四种方法：
- en: '`Deadline`: Returns the time when the context should be cancelled, together
    with a Boolean that is `false` when there is no deadline'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deadline`：返回上下文应该被取消的时间，以及一个布尔值，当没有截止日期时为`false`'
- en: '`Done`: Returns a receive-only channel of empty structs, which signals when
    the context should be cancelled'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Done`：返回一个只接收空结构的通道，用于信号上下文应该被取消'
- en: '`Err`: Returns `nil` while the `done` channel is open; otherwise it returns
    the cause of the context cancellation'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Err`：当`done`通道打开时返回`nil`；否则返回上下文取消的原因'
- en: '`Value`: Returns a value associated with a key for the current context, or
    `nil` if there''s no value for the key'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`：返回与当前上下文中的键关联的值，如果该键没有值，则返回`nil`'
- en: 'Context has many methods compared to the other interfaces of the standard library,
    which usually have one or two methods. Three of them are closely related:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准库的其他接口相比，上下文具有许多方法，通常只有一两个方法。其中三个方法密切相关：
- en: '`Deadline` is the time for cancelling'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deadline`是取消的时间'
- en: '`Done` signals when the context is done'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Done`信号上下文已完成'
- en: '`Err` returns the cause of the cancellation'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Err`返回取消的原因'
- en: The last method, `Value`, returns the value associated with a certain key. The
    rest of the package is a series of functions that allow you to create different
    types of contexts. Let's go through the various functions that comprise the package
    and look at various tools for creating and decorating contexts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法`Value`返回与某个键关联的值。包的其余部分是一系列函数，允许您创建不同类型的上下文。让我们浏览包含在该包中的各种函数，并查看创建和装饰上下文的各种工具。
- en: Default contexts
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认上下文
- en: The `TODO` and `Background` functions return `context.Context` without the need
    for any input argument. The value that's returned is an empty context, though,
    their distinction is just semantic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`TODO`和`Background`函数返回`context.Context`，无需任何输入参数。返回的值是一个空上下文，它们之间的区别只是语义上的。'
- en: Background
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Background
- en: '`Background` is an empty context that doesn''t get cancelled, hasn''t got a
    deadline, and doesn''t hold any values. It is mostly used by the `main` function
    as the root context or for testing purposes. The following is some example code
    for this context:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Background`是一个空上下文，不会被取消，没有截止日期，也不保存任何值。它主要由`main`函数用作根上下文或用于测试目的。以下是此上下文的一些示例代码：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The full example is available here: [https://play.golang.org/p/y_3ip7sdPnx](https://play.golang.org/p/y_3ip7sdPnx).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可在此处找到：[https://play.golang.org/p/y_3ip7sdPnx](https://play.golang.org/p/y_3ip7sdPnx)。
- en: We can see that, in the context of the example, the loop goes on infinitely
    because the context is never completed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在示例的上下文中，循环无限进行，因为上下文从未完成。
- en: TODO
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TODO
- en: '`TODO` is another empty context that should be used when the scope of the context
    isn''t clear or if the type of context isn''t available yet. It is used in the
    exact same way as `Background`. As a matter of fact, under the hood, they are
    the same thing; the distinction is only semantical. If we look at the source code,
    they have the exact same definition:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`TODO`是另一个空上下文，当上下文的范围不清楚或上下文的类型尚不可用时应使用。它的使用方式与`Background`完全相同。实际上，在底层，它们是相同的东西；区别只是语义上的。如果我们查看源代码，它们具有完全相同的定义：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The source for this code can be found at [https://golang.org/pkg/context/?m=all#pkg-variables](https://golang.org/pkg/context/?m=all#pkg-variables).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的源代码可以在[https://golang.org/pkg/context/?m=all#pkg-variables](https://golang.org/pkg/context/?m=all#pkg-variables)找到。
- en: These basic contexts can be extended using the other functions of the package.
    They will act as decorators and add more capabilities to them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用包的其他函数来扩展这些基本上下文。它们将充当装饰器，并为它们添加更多功能。
- en: Cancellation, timeout, and deadline
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消、超时和截止日期
- en: The context we looked at is never cancelled, but the package offers different
    options for adding this functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看的上下文从未被取消，但该包提供了不同的选项来添加此功能。
- en: Cancellation
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消
- en: The `context.WithCancel` decorator function gets a context and returns another
    context and a function called `cancel`. The returned context will be a copy of
    the context that has a different `done` channel (the channel that marks that the
    current context is done) that gets closed when the parent context does or when
    the `cancel` function is called – whatever happens first.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.WithCancel`装饰器函数获取一个上下文并返回另一个上下文和一个名为`cancel`的函数。返回的上下文将是具有不同`done`通道（标记当前上下文完成的通道）的上下文的副本，当父上下文完成或调用`cancel`函数时关闭该通道-无论哪个先发生。'
- en: 'In the following example, we can see that we wait a few seconds before calling
    the `cancel` function, and the program terminates correctly. The value of `Err`
    is the `context.Canceled` variable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到在调用`cancel`函数之前等待几秒钟，程序正确终止。`Err`的值是`context.Canceled`变量：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full example is available here: [https://play.golang.org/p/fNHLIZL8e0L](https://play.golang.org/p/fNHLIZL8e0L).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/fNHLIZL8e0L](https://play.golang.org/p/fNHLIZL8e0L)。
- en: Deadline
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截止时间
- en: '`context.WithDeadline` is another decorator, which specifies a time deadline
    as `time.Time`, and applies it to another context. If there is already a deadline
    and it is earlier than the one provided, the specified one gets ignored. If the
    `done` channel is still open when the deadline is met, it gets closed automatically.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.WithDeadline`是另一个装饰器，它将`time.Time`作为时间截止时间，并将其应用于另一个上下文。如果已经有截止时间并且早于提供的截止时间，则指定的截止时间将被忽略。如果在截止时间到达时`done`通道仍然打开，则会自动关闭它。'
- en: 'In the following example, we set the deadline to be 5 seconds from now and
    call `cancel` 10 seconds after. The deadline arrives before the cancellation and
    `Err` returns a `context.DeadlineExceeded` error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将截止时间设置为现在的5秒后，并在10秒后调用`cancel`。截止时间在取消之前到达，`Err`返回`context.DeadlineExceeded`错误：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The full example is available here: [https://play.golang.org/p/iyuOmd__CGH](https://play.golang.org/p/iyuOmd__CGH).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/iyuOmd__CGH](https://play.golang.org/p/iyuOmd__CGH)。
- en: We can see that the preceding example behaves exactly as expected. It will print
    the `tick` statement each second a few times until the the deadline is met and
    the error is returned.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到前面的示例的行为与预期完全一致。它将打印`tick`语句每秒几次，直到截止时间到达并返回错误。
- en: Timeout
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超时
- en: The last cancel-related decorator is `context.WithTimeout`, which allows you
    to specify a `time.Duration` together with the context and closes the `done` channel
    automatically when the timeout is passed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个与取消相关的装饰器是`context.WithTimeout`，它允许您指定`time.Duration`以及上下文，并在超时时自动关闭`done`通道。
- en: 'If there a deadline active, the new value applies only if it''s earlier than
    the parent. We can look at a pretty identical example, beside the context definition,
    and get the same result that we got for the deadline example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有截止时间活动，则新值仅在早于父级时应用。我们可以看一个几乎相同的示例，除了上下文定义之外，得到与截止时间示例相同的结果：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The full example is available here: [https://play.golang.org/p/-Zp63_e0zYD](https://play.golang.org/p/-Zp63_e0zYD).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/-Zp63_e0zYD](https://play.golang.org/p/-Zp63_e0zYD)。
- en: Keys and values
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键和值
- en: The `context.WithValue` function creates a copy of the parent context that has
    the given key associated with the specified value. Its scope holds values that
    are relative to a single request while it gets processed and should not be used
    for other scopes, such as optional function parameters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.WithValue`函数创建了一个父上下文的副本，其中给定的键与指定的值相关联。它的范围包含相对于单个请求的值，而在处理过程中不应该用于其他范围，例如可选的函数参数。'
- en: The key should be something that can be compared, and it's a good idea to avoid
    `string` values because two different packages using context could overwrite each
    other's values. The suggestion is to use user-defined concrete types such as `struct{}`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 键应该是可以比较的东西，最好避免使用`string`值，因为使用上下文的两个不同包可能会覆盖彼此的值。建议使用用户定义的具体类型，如`struct{}`。
- en: 'Here, we can see an example where we take a base context and we add a different
    value for each goroutine, using an empty struct as a key:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个示例，我们使用空结构作为键，为每个goroutine添加不同的值：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The full example is available here: [https://play.golang.org/p/lM61u_QKEW1](https://play.golang.org/p/lM61u_QKEW1).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/lM61u_QKEW1](https://play.golang.org/p/lM61u_QKEW1)。
- en: 'We can also see that cancelling the parent cancels the other contexts. Another
    valid key type could be exported pointer values, which won''t be the same, even
    if the underlying data is:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到取消父级会取消其他上下文。另一个有效的键类型可以是导出的指针值，即使底层数据相同也不会相同：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The full example is available here: [https://play.golang.org/p/05XJwWF0-0n](https://play.golang.org/p/05XJwWF0-0n).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在这里：[https://play.golang.org/p/05XJwWF0-0n](https://play.golang.org/p/05XJwWF0-0n)。
- en: We can see that defining a key pointer with the same underlying value doesn't
    return the expected value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，定义具有相同底层值的键指针不会返回预期的值。
- en: Context in the standard library
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库中的上下文
- en: 'Now that we''ve covered the contents of the package, we will look at how to
    use them with the standard package or in an application. Context is used in a
    few functions and methods of standard packages, mostly network packages. Let''s
    go over them now:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了包的内容，我们将看看如何在标准包或应用程序中使用它们。上下文在标准包中的一些函数和方法中使用，主要是网络包。现在让我们来看看它们：
- en: '`http.Server` uses it with the `Shutdown` method so that it has full control
    over timeout or to cancel an operation.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Server`使用`Shutdown`方法，以便完全控制超时或取消操作。'
- en: '`http.Request` allows you to set a context using the `WithContext` method. It
    also allows you to get the current context using `Context`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http.Request`允许您使用`WithContext`方法设置上下文。它还允许您使用`Context`获取当前上下文。'
- en: In the `net` package, `Listen`, `Dial`, and `Lookup` have a version that uses `Context` to
    control deadlines and timeouts.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`net`包中，`Listen`，`Dial`和`Lookup`有一个使用`Context`来控制截止时间和超时的版本。
- en: In the `database/sql` package, context is used to stop or timeout many different
    operations.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`database/sql`包中，上下文用于停止或超时许多不同的操作。
- en: HTTP requests
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP请求
- en: Before the introduction of the official package, each HTTP-related framework
    was using its own version of context to store data relative to HTTP requests.
    This resulted in fragmentation, and the reuse of handlers and middleware wasn't
    possible without rewriting the middleware or any specific binding code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方包引入之前，每个与HTTP相关的框架都使用自己的版本上下文来存储与HTTP请求相关的数据。这导致了碎片化，并且在不重写中间件或任何特定绑定代码的情况下无法重用处理程序和中间件。
- en: Passing scoped values
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递作用域值
- en: The introduction of `context.Context` in `http.Request` tries to address this
    issue by defining a single interface that can be assigned, recovered, and used
    in various handlers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`http.Request`中引入`context.Context`试图通过定义一个可以分配、恢复和在各种处理程序中使用的单一接口来解决这个问题。
- en: The downside is that a context isn't assigned automatically to a request, and
    context values cannot be recycled. There should be no really good reason to do
    that since the context should store data that's specific to a certain package
    or scope, and the packages themselves should be the only ones that are able to
    interact with them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是上下文不会自动分配给请求，并且上下文值不能被回收利用。没有真正好的理由这样做，因为上下文应该存储特定于某个包或范围的数据，而包本身应该是唯一能够与它们交互的对象。
- en: 'A good pattern is the usage of a unique unexported key type combined with auxiliary
    functions to get or set a certain value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的模式是使用一个独特的未导出的密钥类型，结合辅助函数来获取或设置特定的值：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A context request is the only case in the standard library where it is stored
    in the data structure with the `WithContext` method and it's accessed using the
    `Context` method. This has been done in order to not break the existing code,
    and maintain the promise of compatibility of Go 1.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文请求是标准库中唯一存储在数据结构中的情况，使用`WithContext`方法存储，并使用`Context`方法访问。这样做是为了不破坏现有代码，并保持Go
    1的兼容性承诺。
- en: The full example is available here: [https://play.golang.org/p/W6gGp_InoMp](https://play.golang.org/p/W6gGp_InoMp).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例在此处可用：[https://play.golang.org/p/W6gGp_InoMp](https://play.golang.org/p/W6gGp_InoMp)。
- en: Request cancellation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求取消
- en: 'A good usage of context is for cancellation and timeout when you''re executing
    an HTTP request using `http.Client`, which handles the interruption automatically
    from the context. The following example does exactly that:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的一个很好的用法是在使用`http.Client`执行HTTP请求时进行取消和超时处理，它会自动处理上下文中的中断。以下示例正是如此：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The context cancellation method can also be used to interrupt the current HTTP
    request that's passed to a client. In a scenario where we are calling different
    endpoints and returning the first result that's received, it would be a good idea
    to cancel the other requests.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文取消方法也可以用于中断传递给客户端的当前HTTP请求。在调用不同的端点并返回收到的第一个结果的情况下，取消其他请求是一个好主意。
- en: 'Let''s create an application that runs a query on different search engines
    and returns the results from the quickest one, cancelling the others. We can create
    a web server that has a unique endpoint that answers back in 0 to 10 seconds:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，它在不同的搜索引擎上运行查询，并返回最快的结果，取消其他搜索。我们可以创建一个Web服务器，它有一个唯一的端点，在0到10秒内回复：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use a cancellable context for the requests, combined with a wait group
    to synchronize it with the end of the request. Each goroutine will create a request
    and try to send the result using a channel. Since we are only interested in the
    first one, we will use  `sync.Once` to limit it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为请求使用可取消的上下文，结合等待组将其与请求结束同步。每个goroutine将创建一个请求，并尝试使用通道发送结果。由于我们只对第一个感兴趣，我们将使用`sync.Once`来限制它：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When this program runs, we will see that one of the requests is completed successfully
    and gets sent to the channel, while the others are either cancelled or ignored.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当此程序运行时，我们将看到其中一个请求成功完成并发送到通道，而其他请求要么被取消，要么被忽略。
- en: HTTP server
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: The `net/http` package has several uses of context, including stopping the listener
    or being part of a request.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http`包中有几种上下文的用法，包括停止监听器或成为请求的一部分。'
- en: Shutdown
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭
- en: '`http.Server` allows us to pass a context for the shutdown operation. This
    allows to us to use some of the context capabilities, such as cancelling and timeout.
    We can define a new server with its `mux` and a cancellable context:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Server`允许我们为关闭操作传递上下文。这使我们能够使用一些上下文的功能，如取消和超时。我们可以定义一个新的服务器及其`mux`和可取消的上下文：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can launch the server in a separate goroutine:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个单独的goroutine中启动服务器：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The context will be complete when the shutdown endpoint is called and the cancellation
    function is invoked. We can wait for that event and then use another context with
    a timeout to call the shutdown method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用关闭端点并调用取消函数时，上下文将完成。我们可以等待该事件，然后使用具有超时的另一个上下文调用关闭方法：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will allow us to terminate the server effectively within the timeout, after
    which it will terminate with an error.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在超时内有效地终止服务器，之后将以错误终止。
- en: Passing values
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递值
- en: 'Another usage of context in a server is as a propagation of values and cancellation
    between different HTTP handlers. Let''s look at an example where each request
    has a unique key that is an integer. We will use a couple of functions that are
    similar to the example where we had values using integers. The generation of a
    new key will be done with `atomic`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器中上下文的另一个用法是在不同的HTTP处理程序之间传播值和取消。让我们看一个例子，每个请求都有一个整数类型的唯一密钥。我们将使用一对类似于使用整数的值的函数。生成新密钥将使用`atomic`完成：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can define another function that takes any HTTP handler and creates
    the context, if necessary, and adds the key to it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义另一个函数，它接受任何HTTP处理程序，并在必要时创建上下文，并将密钥添加到其中：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By doing this, we can define a very simple handler that serves files under
    a certain root directory. This function will use the key from the context to log
    information correctly. It will also check that the file exists before trying to
    serve it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以定义一个非常简单的处理程序，用于在特定根目录下提供文件。此函数将使用上下文中的键正确记录信息。它还将在尝试提供文件之前检查文件是否存在：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can combine those handlers to serve content from different folders, such
    as the home user or the temporary directory:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些处理程序组合起来，以便从不同文件夹（如主目录用户或临时目录）提供内容：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are using `http.StipPrefix` to remove the first part of the path and obtain
    the relative path, and pass it to the handler underneath. The resulting server
    will use context to pass the key value between handlers – this allows us to create
    another similar handler and use the `AssignKeyHandler` function to wrap the handler
    and `GetKey(r.Context())` to access the key inside our handler.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`http.StipPrefix`来删除路径的第一部分并获取相对路径，并将其传递给下面的处理程序。生成的服务器将使用上下文在处理程序之间传递键值——这允许我们创建另一个类似的处理程序，并使用`AssignKeyHandler`函数来包装处理程序，并使用`GetKey(r.Context())`来访问处理程序内部的键。
- en: TCP dialing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP拨号
- en: The network package offers context-related functionalities, such as dialing
    cancellation when we're dialing or listening to incoming connections. It allows
    us to use the timeout and cancellation capabilities of context when dialing a
    connection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 网络包提供了与上下文相关的功能，比如在拨号或监听传入连接时取消拨号。它允许我们在拨号连接时使用上下文的超时和取消功能。
- en: Cancelling a connection
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消连接
- en: 'In order to test out the usage of context in a TCP connection, we can create
    a goroutine with a TCP server that will wait a period of time before starting
    the listener:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试在TCP连接中使用上下文的用法，我们可以创建一个带有TCP服务器的goroutine，在开始监听之前等待一段时间：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use a context with a timeout that''s lower than the server waiting time. We
    have to use `net.Dialer` in order to use the context in a dial operation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个比服务器等待时间更短的超时上下文。我们必须使用`net.Dialer`来在拨号操作中使用上下文：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The application will try to connect for a short time, but will eventually give
    up when the context expires, returning an error.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将尝试连接一小段时间，但最终在上下文过期时放弃，返回一个错误。
- en: 'In a situation where you want to establish a single connection from a series
    of endpoints, context cancellation would be a perfect use case. All the connection
    attempts would share the same context, and the first connection that dials correctly
    would call the cancellation, stopping the other attempts. We will create a single
    server that is listening to one of the addresses we will try to call:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在想要从一系列端点建立单个连接的情况下，上下文取消将是一个完美的用例。所有连接尝试将共享相同的上下文，并且正确拨号的第一个连接将调用取消，停止其他尝试。我们将创建一个单个服务器，它正在监听我们将尝试拨打的地址之一：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we can try to dial all three addresses and cancel the context as soon
    as one connects. We will use a `WaitGroup` to synchronize with the end of the
    goroutines:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试拨打所有三个地址，并在其中一个连接时立即取消上下文。我们将使用`WaitGroup`与goroutines的结束进行同步：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What we will see in the output of this program is one connection succeeding,
    followed by the cancellation error of the other attempt.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此程序的输出中，我们将看到一个连接成功，然后是其他尝试的取消错误。
- en: Database operations
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库操作
- en: 'We aren''t looking at the `sql/database` package in this book, but for the
    sake of completion, it is worth mentioning that it uses context too. Most of its
    operations have a counterpart with context, for instance:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们不会讨论`sql/database`包，但为了完整起见，值得一提的是它也使用了上下文。它的大部分操作都有相应的上下文对应，例如：
- en: Beginning a new transaction
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个新的事务
- en: Executing a query
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行查询
- en: Pinging the database
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据库进行ping
- en: Preparing a query
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备查询
- en: This concludes the packages in the standard library that use context. Next,
    we are going to try to use context to build a package to allow the user of that
    package to cancel requests.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是标准库中使用上下文的包的内容。接下来，我们将尝试使用上下文构建一个包，以允许该包的用户取消请求。
- en: Experimental packages
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验性包
- en: A notable example in the experimental package that uses context is one we've
    already looked at – semaphore. Now that we have a better understanding of what
    context is for, it should be pretty obvious why the acquire operation also takes
    a context in as an argument.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实验包中一个值得注意的例子使用了上下文，我们已经看过了——信号量。现在我们对上下文的用途有了更好的理解，很明显为什么获取操作也需要一个上下文作为参数。
- en: 'When creating our application, we can provide a context with a timeout or cancellation
    and act accordingly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序时，我们可以提供带有超时或取消的上下文，并相应地采取行动：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running this application will show that the semaphore is acquired for the first
    second, but after that the context expires and all the remaining operations fail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序将显示，信号量在第一秒被获取，但之后上下文过期，所有剩余操作都失败了。
- en: Context in your application
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序中的上下文
- en: '`context.Context` is the perfect tool to integrate into your package or application
    if it has operations that could take a long time and a user can cancel them, or
    if they should have time limitations such timeouts or deadlines.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包或应用程序具有可能需要很长时间并且用户可以取消的操作，或者应该具有超时或截止日期等时间限制，那么`context.Context`是集成到其中的完美工具。
- en: Things to avoid
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要避免的事情
- en: Even though the context scope has been made very clear by the Go team, developers
    have been using it in various ways – some less orthodox than others. Let's check
    out some of them and which alternatives there are, instead of resorting to context.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go团队已经非常清楚地定义了上下文的范围，但开发人员一直以各种方式使用它——有些方式不太正统。让我们看看其中一些以及有哪些替代方案，而不是求助于上下文。
- en: Wrong types as keys
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的键类型
- en: 'The first practice to avoid is the usage of built-in types as keys. This is
    problematic because they can be overwritten because two interfaces with the same
    built-in values are considered the same, as shown in the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 避免的第一个做法是使用内置类型作为键。这是有问题的，因为它们可以被覆盖，因为具有相同内置值的两个接口被认为是相同的，如下例所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full example is available here: [https://play.golang.org/p/2W3noYQP5eh](https://play.golang.org/p/2W3noYQP5eh).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里可用：[https://play.golang.org/p/2W3noYQP5eh](https://play.golang.org/p/2W3noYQP5eh)。
- en: The first print instruction outputs `true`, and since the keys are compared
    by value, the second assignment shadows the first, resulting in the values for
    both keys being the same. A potential solution to this is to use an empty struct
    custom type, or an unexported pointer to a built-in value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个打印指令输出`true`，由于键是按值比较的，第二个赋值遮蔽了第一个，导致两个键的值相同。解决这个问题的一个潜在方法是使用空结构自定义类型，或者使用内置值的未导出指针。
- en: Passing parameters
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数
- en: It might so happen that you need to travel a long way through a stack of function
    calls. A very tempting solution would be to use a context to store that value
    and recall it only in the function that needs it. It is generally not a good idea
    to hide a required parameter that should be passed explicitly. It results in less
    readable code because it won't make it clear what influences the execution of
    a certain function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生这样的情况，你需要通过一系列函数调用长途跋涉。一个非常诱人的解决方案是使用上下文来存储该值，并且只在需要它的函数中调用它。通常不是一个好主意隐藏应该显式传递的必需参数。这会导致代码不够可读，因为它不会清楚地表明什么影响了某个函数的执行。
- en: It is still much better to pass the function down the stack. If the parameters
    list is getting too long, then it could be grouped into one or more structs in
    order to be more readable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数传递到堆栈下仍然要好得多。如果参数列表变得太长，那么它可以被分组到一个或多个结构中，以便更易读。
- en: 'Let''s have a look at the following function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下函数：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The parameters could be grouped in the following way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以按以下方式分组：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Optional arguments
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: Context should be used to pass optional parameters around, and also used as
    a sort of catch-all, like Python `kwargs` or JavaScript `arguments`. Using context
    as a substitute for behaviors can be very problematic because it could cause the
    shadowing of variables, like we saw in the example of `context.WithValue`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文应该用于传递可选参数，并且还用作一种类似于Python `kwargs` 或JavaScript `arguments` 的万能工具。将上下文用作行为的替代品可能会导致非常严重的问题，因为它可能导致变量的遮蔽，就像我们在`context.WithValue`的示例中看到的那样。
- en: Another big drawback of this approach is hiding what's happening and making
    the code more obscure. A much better approach when it comes to optional values
    is using a pointer to structure arguments – this allows you to avoid passing the
    structure at all with `nil`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个重大缺点是隐藏发生的事情，使代码更加晦涩。当涉及可选值时，更好的方法是使用指向结构参数的指针 - 这允许您完全避免传递结构与`nil`。
- en: 'Let''s say you had the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下代码：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By using `Optional`, you would have something like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Optional`，你会得到这样的东西：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Globals
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: Some global variables can be stored in a context so that they can be passed
    through a series of function calls. This is generally not good practice since
    globals are available in every point of the application, so using context to store
    and recall them is pointless and a waste of resources and performance. If your
    package has some globals, you can use the Singleton pattern we looked at in [Chapter
    12](7d7f27fa-3ef5-4751-baca-dd6169979d01.xhtml), *Synchronization with sync and
    atomic*, to allow access to them from any point of your package or application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些全局变量可以存储在上下文中，以便它们可以通过一系列函数调用传递。这通常不是一个好的做法，因为全局变量在应用程序的每个点都可用，因此使用上下文来存储和调用它们是毫无意义的，而且是资源和性能的浪费。如果您的包有一些全局变量，您可以使用我们在[第12章](7d7f27fa-3ef5-4751-baca-dd6169979d01.xhtml)中看到的Singleton模式，*使用sync和atomic进行同步*，允许从包或应用程序的任何点访问它们。
- en: Building a service with Context
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文构建服务
- en: We will now focus on how to create packages that support the usage of context.
    This will help us put together what we've learned about concurrency up until now.
    We will try to create a concurrent file search that makes uses of channels, goroutines,
    synchronization, and context.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将专注于如何创建支持上下文使用的包。这将帮助我们整合到目前为止学到的有关并发性的知识。我们将尝试创建一个并发文件搜索，使用通道、goroutine、同步和上下文。
- en: Main interface and usage
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主接口和用法
- en: 'The signature of the package will include a context, the root folder, the search
    term, and a couple of optional parameters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 包的签名将包括上下文、根文件夹、搜索项和一对可选参数：
- en: '**Search in contents**: Will look for the string in the file''s contents instead
    of the name'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在内容中搜索**：将在文件内容中查找字符串，而不是名称'
- en: '**Exclude list**: Will not search the files with the selected name/names'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除列表**：不会搜索具有所选名称/名称的文件'
- en: 'The function would look something like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数看起来可能是这样的：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since it should be a concurrent function, the return type could be a channel
    of result, which could be either an error or a series of matches in a file. Since
    we can search for the names of content, the latter could have more than one match:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它应该是一个并发函数，返回类型可以是结果的通道，它可以是错误，也可以是文件中一系列匹配项。由于我们可以搜索内容的名称，后者可能有多个匹配项：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous function will return a receive-only channel of the `Result` type:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数将返回一个只接收的`Result`类型的通道：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, this function would keep receiving values from the channel until it gets
    closed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这个函数将继续从通道接收值，直到它被关闭：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Exit and entry points
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出口和入口点
- en: 'The result channel should be closed by either the cancellation of the context,
    or by the search being over. Since a channel cannot be closed twice, we can use
    `sync.Once` to avoid closing the channel for the second time. To keep track of
    the goroutines that are running, we can use `sync.Waitgroup`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 结果通道应该由上下文的取消或搜索结束来关闭。由于通道不能被关闭两次，我们可以使用`sync.Once`来避免第二次关闭通道。为了跟踪正在运行的goroutines，我们可以使用`sync.Waitgroup`：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We could launch a goroutine for each file so that we can define a private function
    that we can use as an entry point and then use it recursively for subdirectories:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个文件启动一个goroutine，这样我们可以定义一个私有函数，作为入口点，然后递归地用于子目录：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The main exported function will start by adding a value to the wait group.
    It will then launch the private function, starting it as an asynchronous process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 主要导出的函数将首先向等待组添加一个值。然后，启动私有函数，将其作为异步进程启动：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The last thing each `fileSearch` should do is call `WaitGroup.Done` to mark
    the end of the current file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`fileSearch`应该做的最后一件事是调用`WaitGroup.Done`来标记当前文件的结束。
- en: Exclude list
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排除列表
- en: 'The private function will decrease the wait group counter before it finishes
    using the `Done` method.. Besides that, the first thing it should do is check
    the filename so that it can skip it if it is in the exclusion list:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 私有函数将在完成使用`Done`方法之前减少等待组计数器。此外，它应该首先检查文件名，以便如果在排除列表中，可以跳过它：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If that is not the case, we can check the current file''s information using
    `os.Stat` and send an error to the channel if we don''t succeed. Since we cannot
    risk causing a panic by sending into a closed channel, we can check whether the
    context is done, and if not, send the error:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这种情况，我们可以使用`os.Stat`来检查当前文件的信息，并且如果不成功，向通道发送错误。由于我们不能冒险通过向关闭的通道发送数据来引发恐慌，我们可以检查上下文是否完成，如果没有，发送错误：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Handling directories
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理目录
- en: 'The information that''s received will tell us whether the file is a directory
    or not. If it is a directory, we can get a list of files and handle the error,
    as we did earlier with `os.Stat`. Then, we can launch another series of searches,
    one for each file, if the context isn''t already done. The following code sums
    up these operations:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的信息将告诉我们文件是否是目录。如果是目录，我们可以获取文件列表并处理错误，就像我们之前使用`os.Stat`一样。然后，如果上下文尚未完成，我们可以启动另一系列搜索，每个文件一个。以下代码总结了这些操作：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Checking file names and contents
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件名和内容
- en: 'If the file is a regular file and not a directory, we can compare the file
    name or its contents, depending on the options that are specified. Checking the
    file name is pretty easy:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件是常规文件而不是目录，我们可以比较文件名或其内容，具体取决于指定的选项。检查文件名非常容易：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we are searching for the contents, we should open the file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在搜索内容，我们应该打开文件：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we can read the file line by line to search for the selected term. If
    the context expires while we are reading the file, we will stop all operations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以逐行读取文件以搜索所选的术语。如果在读取文件时上下文过期，我们将停止所有操作：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can check for errors from the scanner. If there''s none and the
    search has results, we can send all the matches to the output channel:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以检查扫描器的错误。如果没有错误并且搜索有结果，我们可以将所有匹配项发送到输出通道：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In less than 200 lines, we created a concurrent file search function that uses
    one goroutine per file. It takes advantage of a channel to send results and synchronization
    primitives in order to coordinate operations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不到200行的代码中，我们创建了一个并发文件搜索函数，每个文件使用一个goroutine。它利用通道发送结果和同步原语来协调操作。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at what one of the newer packages, context, is all
    about. We saw that `Context` is a simple interface that has four methods, and
    should be used as the first argument of a function. Its main scope is to handle
    cancellation and deadlines to synchronize concurrent operations and provide the
    user with functionality to cancel an operation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了一个较新的包上下文的用途。我们看到`Context`是一个简单的接口，有四种方法，并且应该作为函数的第一个参数使用。它的主要作用是处理取消和截止日期，以同步并发操作，并为用户提供取消操作的功能。
- en: We saw how the default contexts, `Background` and `TODO`, don't allow cancellation,
    but they can be extended using various functions of the package to add timeouts
    or cancellation. We also talked about the capabilities of context when it comes
    to holding values and how this should be used carefully in order to avoid shadowing
    and other problems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了默认上下文`Background`和`TODO`不允许取消，但它们可以使用包的各种函数进行扩展，以添加超时或取消。我们还谈到了上下文在持有值方面的能力，以及应该小心使用这一点，以避免遮蔽和其他问题。
- en: Then, we dived into the standard package to see where context is already used.
    This included the HTTP capabilities of requests, where it can be used for values,
    cancellation, and timeout, and the server shutdown operation. We also saw how
    the TCP package allows us to use it in a similar fashion with a practical example,
    and we also listed the operations in the database package that allow us to use
    context to cancel them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入研究了标准包，看看上下文已经被使用在哪里。这包括了请求的HTTP功能，它可以用于值、取消和超时，以及服务器关闭操作。我们还看到了TCP包如何允许我们以类似的方式使用它，并且列出了数据库包中允许我们使用上下文来取消它们的操作。
- en: Before building our own functionality using context, we went into some of the
    uses that should be avoided, from using the wrong types of keys to using context
    to pass values around that should be in a function or method signature instead.
    Then, we proceeded to create a function that searches files and contents, using
    what we have learned about concurrency from the last three chapters.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上下文构建自己的功能之前，我们先了解了一些应该避免的用法，从使用错误类型的键到使用上下文传递应该在函数或方法签名中的值。然后，我们继续创建一个函数，用于搜索文件和内容，利用了我们从前三章学到的并发知识。
- en: The next chapter will conclude the concurrency section of this book by showing
    off the most common Go concurrency patterns and their usage. This will allow us
    to put together all that we have learned so far about concurrency in some very
    common and effective configurations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将通过展示最常见的Go并发模式及其用法来结束本书的并发部分。这将使我们能够将迄今为止学到的关于并发的所有知识放在一些非常常见和有效的配置中。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a context in Go?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go中上下文是什么？
- en: What's the difference between cancellation, deadline, and timeout?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消、截止时间和超时之间有什么区别？
- en: What are the best practices when passing values with a context?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用上下文传递值时，有哪些最佳实践？
- en: Which standard packages already use context?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些标准包已经使用了上下文？
