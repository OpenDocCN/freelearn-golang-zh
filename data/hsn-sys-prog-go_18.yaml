- en: Implementing Concurrency Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并发模式
- en: This chapter will be about concurrency patterns and how to use them to build
    robust system applications. We have already looked at all the tools that are involved
    in concurrency (goroutines and channels, `sync` and `atomic`, and context) so
    now we will look at some common ways of combining them in patterns so that we
    can use them in our programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍并发模式以及如何使用它们构建健壮的系统应用程序。我们已经看过了所有涉及并发的工具（goroutines和通道，`sync`和`atomic`，以及上下文），现在我们将看一些常见的组合模式，以便我们可以在程序中使用它们。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Beginning with generators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从生成器开始
- en: Sequencing with pipelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过管道进行排序
- en: Muxing and demuxing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复用和解复用
- en: Other patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模式
- en: Resource leaking
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源泄漏
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, please refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章需要安装Go并设置您喜欢的编辑器。有关更多信息，请参阅[第3章]（602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml），*Go概述*。
- en: Beginning with generators
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从生成器开始
- en: A generator is a function that returns the next value of a sequence each time
    it is called. The biggest advantage of using generators is the lazy creation of
    new values of the sequence. In Go, this can either be expressed with an interface
    or with a channel. One of the upsides of generators when they're used with channels
    is that they produce values concurrently, in a separate goroutine, leaving the
    main goroutine capable of executing other kinds of operations on them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个每次调用时返回序列的下一个值的函数。使用生成器的最大优势是惰性创建序列的新值。在Go中，这可以用接口或通道来表示。当生成器与通道一起使用时，其中一个优点是它们以并发方式产生值，在单独的goroutine中，使主goroutine能够执行其他类型的操作。
- en: 'It can be abstracted with a very simple interface:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用一个非常简单的接口来抽象化：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The return type of the interface will depend on the use case, which is `int64`
    in our case. The basic implementation of it could be something such as a simple
    counter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的返回类型将取决于用例，在我们的情况下是`int64`。它的基本实现可以是一个简单的计数器：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This implementation is not thread-safe, so if we try to use it with goroutines,
    we could lose some elements on the way:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现不是线程安全的，所以如果我们尝试在goroutine中使用它，可能会丢失一些元素：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A simple way to make a generator concurrent is to execute atomic operations
    on the integer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使生成器并发的一个简单方法是对整数执行原子操作。
- en: 'This will make the concurrent generator thread-safe, with very few changes
    to the code needing to happen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使并发生成器线程安全，代码需要进行很少的更改：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will avoid race conditions in the application. However, there is another
    implementation that''s possible, but this requires the use of channels. The idea
    is to produce the value in a goroutine and then pass it in a shared channel to
    the next method, as shown in the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将避免应用程序中的竞争条件。但是，还有另一种可能的实现，但这需要使用通道。其思想是在goroutine中生成值，然后将其传递到共享通道中的下一个方法，如下例所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The loop will go on forever, and will be blocking in the send operation when
    the generator user stops requesting new values with the `Next` method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将永远继续，并且在生成器用户停止使用`Next`方法请求新值时，将在发送操作中阻塞。
- en: 'The code was structured this way because we were trying to implement the interface
    we defined at the beginning. We could also just return a channel and use it for
    receiving:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 代码之所以以这种方式结构化，是因为我们试图实现我们在开头定义的接口。我们也可以只返回一个通道并用它进行接收：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main advantage of using the channel directly is the possibility of including
    it in `select` statements in order to choose between different channel operations.
    The following shows a `select` between two different generators:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用通道的主要优势是可以将其包含在`select`语句中，以便在不同的通道操作之间进行选择。以下显示了两个不同生成器之间的`select`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Avoiding leaks
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免泄漏
- en: 'It is a good idea to allow the loop to end in order to avoid goroutine and
    resource leakage. Some of these issues are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 允许循环结束是个好主意，以避免goroutine和资源泄漏。其中一些问题如下：
- en: When a goroutine hangs without returning, the space in memory remains used,
    contributing to the application's size in memory. The goroutine and the variables
    it defines in the stack will get collected by the GC only when the goroutine returns
    or panics.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当goroutine挂起而不返回时，内存中的空间仍然被使用，导致应用程序在内存中的大小增加。只有当goroutine返回或发生panic时，GC才会收集goroutine和堆栈中定义的变量。
- en: If a file remains open, this can prevent other processes from executing operations
    on it. If the number of files that are open reaches the limit imposed by the OS,
    the process will not be able to open other files (or accept network connections).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件保持打开状态，这可能会阻止其他进程对其执行操作。如果打开的文件数量达到操作系统强加的限制，进程将无法打开其他文件（或接受网络连接）。
- en: 'An easy solution to this problem is to always use `context.Context` so that
    you have a well-defined exit point for the goroutine:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个简单解决方案是始终使用`context.Context`，这样您就有了goroutine的明确定义的退出点：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This can be used to generate values until there is a need for them and cancel
    the context when there''s no need for new values. The same pattern can be applied
    to a version that returns a channel. For instance, we could use the `cancel` function
    directly or set a timeout on the context:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于生成值，直到需要它们并在不需要新值时取消上下文。相同的模式也可以应用于返回通道的版本。例如，我们可以直接使用`cancel`函数或在上下文上设置超时：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The generator will produce numbers until the context that's provided expires.
    At this point, the generator will close the channel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器将生成数字，直到提供的上下文到期。此时，生成器将关闭通道。
- en: Sequencing with pipelines
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过管道进行排序
- en: 'A pipeline is a way of structuring the application flow, and is obtained by
    splitting the main execution into stages that can talk with one another using certain
    means of communication. This could be either of the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种结构化应用程序流程的方式，通过将主要执行分成可以使用某种通信手段相互交谈的阶段来实现。这可以是以下之一：
- en: External, such as a network connection or a file
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部，比如网络连接或文件
- en: Internal to the application, like Go's channels
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序内部，如Go的通道
- en: The first stage is often referred to as the producer, while the last one is
    often called the consumer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段通常被称为生产者，而最后一个通常被称为消费者。
- en: 'The set of concurrency tools that Go offers allows us to efficiently use multiple
    CPUs and optimize their usage by blocking input or output operations. Channels
    in particular are the perfect tools for internal pipeline communication. They
    can be represented by functions that receive an inbound channel and return an
    outbound one. The base structure would look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供的并发工具集允许我们有效地使用多个CPU，并通过阻塞输入或输出操作来优化它们的使用。通道特别适用于内部管道通信。它们可以由接收入站通道并返回出站通道的函数表示。基本结构看起来像这样：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We create a channel of the same type as the input channel and return it. In
    a separate goroutine, we receive data from the input channel, perform an operation
    on the data, and we send it to the output channel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个与输入通道相同类型的通道并返回它。在一个单独的goroutine中，我们从输入通道接收数据，对数据执行操作，然后将其发送到输出通道。
- en: 'This pattern can be further improved by the use of `context.Context` so that
    we have greater control of the application flow. It would look something like
    the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以通过使用`context.Context`进一步改进，以便我们更好地控制应用程序流程。它看起来像以下代码：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are a couple of general rules that we should follow when designing pipelines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计管道时，有一些通用规则应该遵循：
- en: Intermediate stages will receive an inbound channel and return another one.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间阶段将接收一个入站通道并返回另一个。
- en: The producer will not receive any channel, but return one.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者不会接收任何通道，但会返回一个。
- en: The consumer will receive a channel without returning one.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者将接收一个通道而不返回一个。
- en: Each stage will close the channel on creation when it's done sending messages.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个阶段在创建时都会关闭通道，当它发送完消息时。
- en: Each stage should keep receiving from the input channel until it's closed.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个阶段应该保持从输入通道接收，直到它关闭。
- en: 'Let''s create a simple pipeline that filters lines from a reader using a certain
    string and prints the filtered lines, highlighting the search string. We can start
    with the first stage – the source – which will not receive any channel in its
    signature but will use a reader to scan lines. We take a context in for reacting
    to an early exit request (context cancellation) and a `bufio` scanner to read
    line by line. The following code shows this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的管道，使用特定字符串从读取器中过滤行并打印过滤后的行，突出显示搜索字符串。我们可以从第一个阶段开始 - 源 - 它在签名中不会接收任何通道，但会使用读取器扫描行。我们为了对早期退出请求做出反应（上下文取消）和使用`bufio`扫描器逐行读取。以下代码显示了这一点：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can split the remaining operations into two phases: a filtering phase and
    a writing phase. The filtering phase will simply filter from a source channel
    to an output channel. We are still passing context in order to avoid sending extra
    data if the context is already complete. This is the text filter implementation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将剩余的操作分为两个阶段：过滤阶段和写入阶段。过滤阶段将简单地从源通道过滤到输出通道。我们仍然传递上下文，以避免在上下文已经完成的情况下发送额外的数据。这是文本过滤的实现：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we have the final stage, the consumer, which will print the output
    in a writer and will also use a context for early exit:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有最终阶段，消费者，它将在写入器中打印输出，并且还将使用上下文进行早期退出：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The use of this function is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数的方式如下：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this approach, we learned how to split a complex operation into a simple
    task that's executed by stages and connected using channels.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们学会了如何将复杂的操作分解为由阶段执行的简单任务，并使用通道连接。
- en: Muxing and demuxing
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复用和解复用
- en: 'Now that we are familiar with pipelines and stages, we can introduce two new
    concepts:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了管道和阶段，我们可以介绍两个新概念：
- en: '**Muxing (multiplexing) or fan-out**: Receiving from one channel and sending
    to multiple channels'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复用（多路复用）或扇出**：从一个通道接收并发送到多个通道'
- en: '**Demuxing (demultiplexing) or fan-in**: Receiving from multiple channels and
    sending through one channel'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解复用（解多路复用）或扇入**：从多个通道接收并通过一个通道发送'
- en: This pattern is very common and allows us to use the power of concurrency in
    different ways. The most obvious way is to distribute data from a channel that
    is quicker than its following step, and create more than one instance of such
    steps to make up for the difference in speed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常常见，可以让我们以不同的方式利用并发的力量。最明显的方式是从比其后续步骤更快的通道中分发数据，并创建多个此类步骤的实例来弥补速度差异。
- en: Fan-out
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扇出
- en: The implementation of multiplexing is pretty straightforward. The same channel
    needs to be passed to different stages so that each one will be reading from it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 复用的实现非常简单。同一个通道需要传递给不同的阶段，以便每个阶段都从中读取。
- en: Each goroutine is competing for resources during the runtime schedule, so if
    we want to reserve more of them, we can use more than one goroutine for a certain
    stage of the pipeline, or for a certain operation in our application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个goroutine在运行时调度期间竞争资源，因此如果我们想保留更多的资源，我们可以为管道的某个阶段或应用程序中的某个操作使用多个goroutine。
- en: 'We can create a small application that counts the occurrence of words which
    appear in a piece of text using such an approach. Let''s create an initial producer
    stage that reads from a writer and returns a slice of words for that line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个小应用程序，使用这种方法统计出现在一段文本中的单词的次数。让我们创建一个初始的生产者阶段，从写入器中读取并返回该行的单词切片：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now define another stage that will count the occurrence of these words.
    We will use this stage for the fan-out:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义另一个阶段，用于计算这些单词的出现次数。我们将使用这个阶段进行扇出：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to use the first stage as a source for more than one instance of the
    second stage, we just need to create more than one counting stage with the same
    input channel:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将第一阶段用作第二阶段的多个实例的来源，我们只需要使用相同的输入通道创建多个计数阶段：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Fan-in
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扇入
- en: 'Demuxing is a little bit more complicated because we don''t need to receive
    data blindly in one goroutine or another – we actually need to synchronize a series
    of channels. A good approach to avoid race conditions is to create another channel
    where all the data from the various input channels will be received. We also need
    to make sure that this merge channel gets closed once all the channels are done.
    We also have to keep in mind that the channel will be closed if the context is
    cancelled. We are using `sync.Waitgroup` here to wait for all the channels to
    finish:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Demuxing有点复杂，因为我们不需要在一个goroutine中盲目地接收数据，而是需要同步一系列通道。避免竞争条件的一个好方法是创建另一个通道，所有来自各种输入通道的数据都将被接收到。我们还需要确保一旦所有通道都完成，这个合并通道就会关闭。我们还必须记住，如果上下文被取消，通道将被关闭。我们在这里使用`sync.Waitgroup`等待所有通道完成：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The problem is that we have two possible triggers for closing the channel:
    regular transmission ending and context cancelling.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们有两种可能的触发器来关闭通道：常规传输结束和上下文取消。
- en: 'We have to make sure that if the context ends, no message is sent to the outbound
    channel. Here, we are collecting the values from the input channels and sending
    them to the merge channel, but only if the context isn''t complete. We do this
    in order to avoid a send operation being sent to a closed channel, which would
    make our application panic:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保如果上下文结束，不会向输出通道发送任何消息。在这里，我们正在从输入通道收集值并将它们发送到合并通道，但前提是上下文没有完成。我们这样做是为了避免将发送操作发送到关闭的通道，这将使我们的应用程序发生恐慌：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can focus on the last operation, which uses the merge channel to
    execute our final word count:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以专注于使用合并通道执行我们的最终字数的最后一个操作：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The application''s `main` function, with the addition of the fan-in, will look
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的`main`函数，在添加扇入后，将如下所示：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see that the fan-in is the most complex and critical part of the application.
    Let''s recap the decisions that helped build a fan-in function that is free from
    panic or deadlock:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，扇入是应用程序最复杂和关键的部分。让我们回顾一下帮助构建一个没有恐慌或死锁的扇入函数的决定：
- en: Use a merge channel to collect values from the various input.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用合并通道从各种输入中收集值。
- en: Have `sync.WaitGroup` with a counter equal to the number of input channels.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sync.WaitGroup`，计数器等于输入通道的数量。
- en: Use it in a separate goroutine and wait for it to close the channel.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个单独的goroutine中使用它，并等待它关闭通道。
- en: For each input channel, create a goroutine that transfers the values to the
    merge channel.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个输入通道，创建一个将值传输到合并通道的goroutine。
- en: Ensure that you send the record only if the context is not complete.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保只有在上下文没有完成的情况下才发送记录。
- en: Use the wait group's `done` function before exiting such a goroutine.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在退出这样的goroutine之前，使用等待组的`done`函数。
- en: Following the preceding steps will allow us to use the merge channel with a
    simple `range`. In our example, we are also checking whether the context is complete
    before receiving from the channel in order to allow for an early exit from the
    goroutine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循上述步骤将允许我们使用简单的`range`从合并通道中获取值。在我们的示例中，我们还检查上下文是否完成，然后才从通道接收，以便允许goroutine提前退出。
- en: Producers and consumers
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者和消费者
- en: Channels allow us to easily handle a scenario in which multiple consumers receive data
    from one producer and vice versa.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通道允许我们轻松处理多个消费者从一个生产者接收数据的情况，反之亦然。
- en: 'The case with a single producer and one consumer, as we have already seen,
    is pretty straightforward:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与单个生产者和一个消费者的情况一样，我们已经看到，这是非常直接的：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The full example is available here: [https://play.golang.org/p/hNgehu62kjv](https://play.golang.org/p/hNgehu62kjv).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/hNgehu62kjv](https://play.golang.org/p/hNgehu62kjv)。
- en: Multiple producers (N * 1)
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个生产者（N * 1）
- en: 'Having multiple producers or consumers can be easily handled using wait groups. In
    the case of multiple producers, all the goroutines will share the same channel:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等待组可以轻松处理多个生产者或消费者的情况。在多个生产者的情况下，所有的goroutine都将共享同一个通道：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The full example is available here: [https://play.golang.org/p/4DqWKntl6sS](https://play.golang.org/p/4DqWKntl6sS).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/4DqWKntl6sS](https://play.golang.org/p/4DqWKntl6sS)。
- en: They will use `sync.WaitGroup` to wait for each producer to finish before closing
    the channel.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将使用`sync.WaitGroup`等待每个生产者完成后关闭通道。
- en: Multiple consumers (1 * M)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个消费者（1 * M）
- en: 'The same reasoning applies with multiple consumers – they all receive from
    the same channel in different goroutines:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的推理适用于多个消费者-它们都在不同的goroutine中从同一个通道接收：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full example is available here: [https://play.golang.org/p/_SWtw54ITFn](https://play.golang.org/p/_SWtw54ITFn).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例在这里：[https://play.golang.org/p/_SWtw54ITFn](https://play.golang.org/p/_SWtw54ITFn)。
- en: In this case, `sync.WaitGroup` is used to wait for the application to end.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`sync.WaitGroup`用于等待应用程序结束。
- en: Multiple consumers and producers (N*M)
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个消费者和生产者（N*M）
- en: The last scenario is where we have an arbitrary number of producers (`N`) and
    another arbitrary number of consumers (`M`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的情况是我们有任意数量的生产者（`N`）和另一个任意数量的消费者（`M`）。
- en: 'In this case, we need two waiting groups: one for the producer and another
    for the consumer:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要两个等待组：一个用于生产者，另一个用于消费者：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will be followed by a series of producers and consumers, each one in their
    own goroutine:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一系列生产者和消费者，每个都在自己的goroutine中：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The final step is to wait for the `WaitGroup` producer to finish its work in
    order to close the channel.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是等待`WaitGroup`生产者完成工作，以关闭通道。
- en: 'Then, we can wait for the consumer channel to let all the messages be processed
    by the consumers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以等待消费者通道，让所有消息都被消费者处理：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Other patterns
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模式
- en: So far, we've looked at the most common concurrency patterns that can be used.
    Now, we will focus on some that are less common but are worth mentioning.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了可以使用的最常见的并发模式。现在，我们将专注于一些不太常见但值得一提的模式。
- en: Error groups
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误组
- en: 'The power of `sync.WaitGroup` is that it allows us to wait for simultaneous
    goroutines to finish their jobs. We have already looked at how sharing context
    can allow us to give the goroutines an early exit if it''s used correctly. The
    first concurrent operation, such as send or receive from a channel, is in the `select`
    block, together with the context completion channel:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`sync.WaitGroup`的强大之处在于它允许我们等待同时运行的goroutines完成它们的工作。我们已经看过了如何共享上下文可以让我们在正确使用时为goroutines提供早期退出。第一个并发操作，比如从通道发送或接收，位于`select`块中，与上下文完成通道一起：'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An improvement on this scenario is offered by the experimental `golang.org/x/sync/errgroup` package.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实验性的`golang.org/x/sync/errgroup`包提供了对这种情况的改进。
- en: The built-in goroutines are always of the `func()` type, but this package allows
    us to execute `func() error` concurrently and return the first error that's received
    from the various goroutines.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的goroutines始终是`func()`类型，但这个包允许我们并发执行`func() error`并返回从各种goroutines接收到的第一个错误。
- en: This is very useful in scenarios where you launch more goroutines together and
    receive the first error. The `errgroup.Group` type can be used as a zero value,
    and its `Do` method takes `func() error` as an argument and launches the function
    concurrently.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动更多goroutines并接收第一个错误的情况下，这非常有用。`errgroup.Group`类型可以用作零值，其`Do`方法以`func() error`作为参数并并发启动函数。
- en: The `Wait` method either waits for all the functions to finish successfully
    and returns `nil`, or it returns the first error that comes from any of the functions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wait`方法要么等待所有函数成功完成并返回`nil`，要么返回来自任何函数的第一个错误。'
- en: 'Let''s create an example that defines a URL visitor, that is, a function that
    gets a URL string and returns `func() error`, which makes the call:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个定义URL访问者的示例，即一个获取URL字符串并返回`func() error`的函数，用于发起调用：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use it directly with the `Go` method and wait. This will return the
    error that was caused by the invalid URL:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用`Go`方法并等待。这将返回由无效URL引起的错误：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The error group also allows us to create a group, along with a context, with
    the `WithContext` function. This context gets cancelled when the first error is
    received. The context's cancellation enables the `Wait` method to return right
    away, but it also allows an early exit in the goroutines in your functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 错误组还允许我们使用`WithContext`函数创建一个组以及上下文。当收到第一个错误时，此上下文将被取消。上下文的取消使`Wait`方法能够立即返回，但也允许在函数的goroutines中进行早期退出。
- en: 'We can create a similar `func() error` creator that will send values into a
    channel until the context is closed. We will introduce a small chance (1%) of
    raising an error:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个类似的`func() error`创建者，它会将值发送到通道直到上下文关闭。我们将引入一个小概率（1%）引发错误：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will generate an error group and a context with the dedicated function and
    use it to launch several instances of the function. We will receive this in a
    separate goroutine while we wait for the group. After the wait is over, we will
    make sure that there are no more values being sent to the channel (this would
    cause a panic) by waiting an extra second:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用专用函数生成一个错误组和一个上下文，并使用它来启动函数的多个实例。在等待组时，我们将在一个单独的goroutine中接收到它。等待结束后，我们将确保没有更多的值被发送到通道（这将导致恐慌），通过额外等待一秒钟：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As expected, thanks to the `select` statement within the context, the application
    runs seamlessly and does not panic.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，由于上下文中的`select`语句，应用程序运行顺利，不会发生恐慌。
- en: Leaky bucket
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泄漏桶
- en: 'We saw how to build a rate limiter using ticker in the previous chapters: by
    using `time.Ticker` to force a client to await its turn in order to get served.
    There is another take on rate limiting of services and libraries that''s known
    as the **leaky bucket**. The name evokes an image of a bucket with a few holes
    in it. If you are filling it, you have to be careful to not put too much water
    into the bucket, otherwise it''s going to overflow. Before adding more water,
    you need to wait for the level to drop – the speed at which this happens will
    depend on the size of the bucket and the number of the holes it has. We can easily
    understand what this concurrency pattern does by taking a look at the following
    analogy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中看到了如何使用ticker构建速率限制器：通过使用`time.Ticker`强制客户端等待轮到自己被服务。还有另一种对服务和库进行速率限制的方法，称为**泄漏桶**。这个名字让人联想到一个有几个孔的桶。如果你在往里面加水，就要小心不要把太多水放进去，否则它会溢出。在添加更多水之前，你需要等待水位下降
    - 这种速度取决于桶的大小和孔的数量。通过以下类比，我们可以很容易地理解这种并发模式的作用：
- en: The water going through the holes represents requests that have been completed.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过孔洞流出的水代表已完成的请求。
- en: The water that's overflowing from the bucket represents the requests that have
    been discarded.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从桶中溢出的水代表被丢弃的请求。
- en: 'The bucket will be defined by two attributes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 桶将由两个属性定义：
- en: '**Rate**: The ideal amount of requests per time if the frequency of requests
    is lower.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速率**：如果请求频率较低，则每个时间段的理想请求量。'
- en: '**Capacity**: The number of requests that can be done at the same time before
    the resource turns unresponsive temporarily.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容量**：在资源暂时变得无响应之前，可以同时完成的请求数量。'
- en: The bucket has a maximum capacity, so when requests are made with a frequency
    higher than the rate specified, this capacity starts dropping, just like when
    you're putting too much water in and the bucket starts to overflow. If the frequency
    is zero or lower than the rate, the bucket will slowly gain its capacity, and
    so the water will be slowly drained.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 桶具有最大容量，因此当请求的频率高于指定的速率时，该容量开始下降，就像当您放入太多水时，桶开始溢出一样。如果频率为零或低于速率，则桶将缓慢恢复其容量，因此水将被缓慢排出。
- en: 'The data structure of the leaky bucket will have a capacity and a counter for
    the requests that are available. This counter will be the same as the capacity
    on creation, and will drop each time requests are executed. The rate specifies
    how often the status needs to be reset to the capacity:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 漏桶的数据结构将具有容量和可用请求的计数器。该计数器在创建时将与容量相同，并且每次执行请求时都会减少。速率指定了状态需要多久重置到容量的频率：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When creating a new bucket, we should also take care of the status reset. We
    can use a goroutine for this and use a context to terminate it correctly. We can
    create a ticker using the rate and then use these ticks to reset the status. We
    need to use the atomic package to ensure it is thread-safe:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的桶时，我们还应该注意状态重置。我们可以使用goroutine和上下文来正确终止它。我们可以使用速率创建一个ticker，然后使用这些ticks来重置状态。我们需要使用atomic包来确保它是线程安全的：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we''re adding to the bucket, we can check the status and act accordingly:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向桶中添加内容时，我们可以检查状态并相应地采取行动：
- en: If the status is `0`, we cannot add anything.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态为`0`，我们无法添加任何内容。
- en: If the amount to add is higher than the availability, we add what we can.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要添加的数量高于可用性，我们将添加我们可以的内容。
- en: 'We add the full amount otherwise:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们将添加完整的数量：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We are using a loop to try atomic swap operations until they succeed to ensure
    that what we get with the `Load` operation doesn't change when we are doing a **compare
    and swap** (**CAS**).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用循环尝试原子交换操作，直到成功为止，以确保我们在进行**比较和交换**（**CAS**）时得到的内容不会在进行**加载**操作时发生变化。
- en: 'The bucket can be used in a client that will try to add a random amount to
    the bucket and will log its result:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 桶可以用于尝试向桶中添加随机数量并记录其结果的客户端：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use more clients concurrently so that having concurrent access to resources
    will have the following result:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同时使用更多客户端，以便并发访问资源将产生以下结果：
- en: Some goroutines will be adding what they expect to the bucket.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些goroutine将向桶中添加他们期望的内容。
- en: One goroutine will finally fill the bucket by adding a quantity that is equal
    to the remaining capacity, even if the amount that they are trying to add is higher.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个goroutine最终将通过添加与剩余容量相等的数量来填充桶，即使他们试图添加的数量更高。
- en: 'The other goroutines will not be able to add to the bucket until the capacity
    is reset:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他goroutine在容量重置之前将无法向桶中添加内容：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Sequencing
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: In concurrent scenarios with multiple goroutines, we may need to have a synchronization
    between goroutines, such as in a scenario where each goroutine needs to wait for
    its turn after sending.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有多个goroutine的并发场景中，我们可能需要在goroutine之间进行同步，例如在每个goroutine发送后需要等待轮次的情况下。
- en: A use case for this scenario could be a turn-based application wherein different
    goroutines are sending messages to the same channel, and each one of them has
    to wait until all the others have finished before they can send it again.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个用例可能是一个基于轮次的应用程序，其中不同的goroutine正在向同一个通道发送消息，并且每个goroutine都必须等到所有其他goroutine完成后才能再次发送消息。
- en: 'A very simple implementation of this scenario can be obtained using private
    channels between the main goroutine and the senders. We can define a very simple
    structure that carries both messages and a `Wait` channel. It will have two methods –
    one for marking the transaction as done and another one that waits for such a
    signal – when it uses a channel underneath. The following method shows this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用主goroutine和发送者之间的私有通道来获得此场景的非常简单的实现。我们可以定义一个非常简单的结构，其中包含消息和`Wait`通道。它将有两种方法-一种用于标记交易已完成，另一种等待这样的信号-当它在下面使用通道时。以下方法显示了这一点：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can create a source of messages with a generator. We can use a random delay
    with the `send` operation. After each send, we wait for the signal that is obtained
    by calling the `Done` method. We always use context to keep everything free from
    leaks:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器创建消息源。我们可以使用`send`操作进行随机延迟。每次发送后，我们等待通过调用`Done`方法获得的信号。我们始终使用上下文来确保一切都不会泄漏：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can use a fan-in to put all of the channels into one, singular channel:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用fan-in将所有通道放入一个单一的通道中：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The main application will be receiving from the merged channel until it's closed.
    When it receives one message from each channel, the channel will be blocked, waiting
    for the `Done` method signal to be called by the main goroutine.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序将从合并的通道接收，直到它关闭。当它从每个通道接收到一个消息时，通道将被阻塞，等待主goroutine调用`Done`方法信号。
- en: 'This specific configuration will allow the main goroutine to receive just one
    message from each channel. When the message count reaches the number of goroutines,
    we can call `Done` from the main goroutine and reset the list so that the other
    goroutines will be unlocked and be able to send messages again:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的配置将允许主goroutine仅从每个通道接收一个消息。当消息计数达到goroutine数量时，我们可以从主goroutine调用`Done`并重置列表，以便其他goroutine将被解锁并能够再次发送消息：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Running the application will result in all the goroutines sending a message
    to the main one once. Each of them will be waiting for everyone to send their
    message. Then, they will start sending messages again. This results in messages
    being sent in rounds, as expected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序将导致所有goroutine向主goroutine发送一条消息。每个goroutine都将等待其他人发送消息。然后，他们将开始再次发送消息。这导致消息按轮次发送，正如预期的那样。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at some specific concurrency patterns for our applications.
    We learned that generators are functions that return channels, and also feed such
    channels with data and close them when there is no more data. We also saw that
    we can use a context to allow the generator to exit early.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了一些特定的并发模式，用于我们的应用程序。我们了解到生成器是返回通道的函数，并且还向这些通道提供数据，并在没有更多数据时关闭它们。我们还看到我们可以使用上下文来允许生成器提前退出。
- en: Next, we focused on pipelines, which are stages of execution that use channels
    for communication. They can either be source, which doesn't require any input;
    destination, which doesn't return a channel; or intermediate, which receives a
    channel as input and returns one as output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们专注于管道，这是使用通道进行通信的执行阶段。它们可以是源，不需要任何输入；目的地，不返回通道；或者中间的，接收通道作为输入并返回一个作为输出。
- en: Another pattern is the multiplexing and demultiplexing one, which consists of
    spreading a channel to different goroutines and combining several channels into
    one. It is often referred to as *fan-out fan-in*, and it allows us to execute
    different operations concurrently on a set of data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个模式是多路复用和分解复用，它包括将一个通道传播到不同的goroutine，并将多个通道合并成一个。它通常被称为*扇出扇入*，它允许我们在一组数据上并发执行不同的操作。
- en: Finally, we learned how to implement a better version of the rate limiter called
    **leaky bucket**, which limits the number of requests in a specific amount of
    time. We also looked at the sequencing pattern, which uses a private channel to
    signal to all of the sending goroutines when they are allowed to send data again.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何实现一个更好的速率限制器称为**漏桶**，它限制了在特定时间内的请求数。我们还看了顺序模式，它使用私有通道向所有发送goroutine发出信号，告诉它们何时可以再次发送数据。
- en: In this next chapter, we are going to introduce the first of two extra topics
    that were presented in the *Sequencing* section. It is here that we will demonstrate
    how to use reflection to build generic code that adapts to any user-provided type.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍在*顺序*部分中提出的两个额外主题中的第一个。在这里，我们将演示如何使用反射来构建适应任何用户提供的类型的通用代码。
- en: Questions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a generator? What are its responsibilities?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器是什么？它的责任是什么？
- en: How could you describe a pipeline?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何描述一个管道？
- en: What type of stage gets a channel and returns one?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么类型的阶段获得一个通道并返回一个通道？
- en: What is the difference between fan-in and fan-out?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扇入和扇出之间有什么区别？
