- en: Using CGO
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CGO
- en: This chapter will introduce you to CGO, a Go runtime for the C language. It
    makes it possible to call C code from Go applications, and since C has a plethora
    of libraries available, this means that they can be leveraged in Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 CGO，这是一个用于 C 语言的 Go 运行时。它使得可以从 Go 应用程序中调用 C 代码，而由于 C 有大量可用的库，这意味着它们可以在
    Go 中被利用。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using CGO from C and Go
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C 和 Go 中使用 CGO
- en: Understanding type differences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类型差异
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml),
    *An Overview of Go*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装 Go 并设置您喜欢的编辑器。有关更多信息，请参阅[第 3 章](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml)，*Go
    概述*。
- en: 'In addition, it requires the GCC compiler to be installed in your machine.
    This can easily be done on your Unix machine using the package manager. For Ubuntu,
    the command is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它需要安装 GCC 编译器在你的机器上。在你的 Unix 机器上可以很容易地使用包管理器来完成这个任务。对于 Ubuntu，命令如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Introduction to CGO
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CGO 简介
- en: CGO is the tool that makes it possible to run C code in a Go application. This
    feature has been around since Go reached version 1.0 in 2009 and allowed us to
    use existing C libraries when there were fewer packages available outside the
    standard library than today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CGO 是一种工具，可以让我们在 Go 应用程序中运行 C 代码。这个功能自从 Go 在 2009 年达到 1.0 版本以来就一直存在，当时标准库之外可用的包比现在少，所以我们可以使用现有的
    C 库。
- en: The C code is accessed through the `C` pseudo package, and it is accessed and
    called using the package name followed by the identifier, for instance, `C.print`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C 代码通过 `C` 伪包访问，通过包名和标识符访问和调用，例如 `C.print`。
- en: 'The `import` declaration is preceded by a series of special comments, which
    specify what C source file the application should import:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 声明前面有一系列特殊的注释，指定应用程序应该导入哪个 C 源文件：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This statement can also be a multiline comment, which can contain more `include`
    directives, like the one from the example earlier, and even actual C code directly:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句也可以是一个多行注释，可以包含更多的 `include` 指令，就像之前的例子中的那个，甚至可以直接包含实际的 C 代码：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is important to avoid blank lines between the C comment and the `import`
    statement, otherwise the libraries and the code will be imported by CGO in the
    application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是在 C 注释和 `import` 语句之间避免空行，否则库和代码将被 CGO 导入应用程序。
- en: Calling C code from Go
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 Go 调用 C 代码
- en: 'To use existing C code, made by us or by someone else, we need to call C from
    Go. Let''s perform a quick, complete example, where we are printing a string to
    the standard output using just C functionalities:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们自己或他人制作的现有 C 代码，我们需要从 Go 中调用 C。让我们进行一个快速的完整示例，使用只有 C 功能打印一个字符串到标准输出：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are importing two C core libraries here, which are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里导入了两个 C 核心库，它们分别是：
- en: '`stdio.h `: This contains the input and output methods. We are using `printf`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdio.h`：这包含了输入和输出方法。我们正在使用 `printf`。'
- en: '`stdlib.h`: This contains general functions, including memory management.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdlib.h`：这包含了一般函数，包括内存管理。'
- en: 'Looking at the preceding code, we notice that the variable that we are printing
    is not a normal Go `string`, but rather, it is obtained by the `C.CString` function that
    takes a string and returns a slice of `char`, because that''s how strings are
    treated in C. The function is defined as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，我们注意到我们要打印的变量不是普通的 Go `string`，而是通过 `C.CString` 函数获得的，它接受一个字符串并返回一个
    `char` 切片，因为这就是 C 中字符串的处理方式。该函数定义如下：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second thing we can observe is that we are deferring a call to `C.free`, passing
    the `s` variable that we defined, but converted to a different type. This function
    call is essential since the language is not garbage collected and, in order to
    free the memory used, the application needs to specifically call the C `free`
    function. This function receives a generic pointer, which is represented by the `unsafe.Pointer` type in
    Go. According to the Go documentation, the following applies:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到的第二件事是，我们在延迟调用 `C.free`，传递了我们定义的 `s` 变量，但转换成了不同的类型。这个函数调用是必要的，因为语言没有垃圾回收，为了释放内存，应用程序需要明确调用
    C 的 `free` 函数。这个函数接收一个通用指针，它在 Go 中被表示为 `unsafe.Pointer` 类型。根据 Go 文档，以下内容适用：
- en: '"A pointer value of any type can be converted into a Pointer."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"任何类型的指针值都可以转换为指针。"'
- en: This is exactly what we are doing, because the type of the string variable is
    the `*C.char` pointer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们正在做的，因为字符串变量的类型是 `*C.char` 指针。
- en: Calling Go code from C
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C 中调用 Go 代码
- en: 'We just saw how to call C code from a Go application using the C package and
    the `import` statement. Now, we will see how to call Go code from C, which requires
    the use of another special statement called `export`. This is a comment that needs
    to be placed in the line above the function we want to export, followed by the
    name of that function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用 C 包和 `import` 语句从 Go 应用程序中调用 C 代码。现在，我们将看到如何从 C 中调用 Go 代码，这需要使用另一个特殊的语句叫做
    `export`。这是一个需要放在我们想要导出的函数上面的注释，后面跟着那个函数的名称：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Go function needs to be declared as external in the C code. This will allow
    the C code to use it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Go 函数需要在 C 代码中声明为外部函数。这将允许 C 代码使用它：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can test this functionality by creating a Go app that exports a function,
    which is used by a C function. This gets called inside the Go `main` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个导出函数的 Go 应用程序来测试这个功能，这个函数被一个 C 函数使用。这个函数在 Go 的 `main` 函数中被调用：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can see in the preceding example that we have the `goAdd` function, which
    is exported to C with the `export` statement . The export name matches the name
    of the function, and there are no blank lines between the comment and the function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个 `goAdd` 函数，它使用 `export` 语句导出到 C。导出的名称与函数的名称匹配，注释和函数之间没有空行。
- en: We can notice that the types used in the signature of the exported function are
    not regular Go integers, but `C.int` variables. We will see how the C and Go systems
    differ in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到在导出函数的签名中使用的类型不是常规的Go整数，而是`C.int`变量。我们将在下一节中看到C和Go系统的不同之处。
- en: The C and Go type systems
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和Go类型系统
- en: In order to pass data around between C and Go, we need to pass the correct types
    by executing the right conversion.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在C和Go之间传递数据，我们需要通过执行正确的转换来传递正确的类型。
- en: Strings and byte slices
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和字节切片
- en: The `string` type, which is a basic type in Go, does not exist in C. It has
    the `char` type, which represents a character, similar to Go's `rune` type, and
    strings are represented by an array of the `char` type, which is terminated with
    a `\0`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的基本类型`string`在C中不存在。它有`char`类型，表示一个字符，类似于Go的`rune`类型，并且字符串由以`\0`结尾的`char`类型的数组表示。
- en: 'The language makes it possible to declare character arrays directly as an array
    or as a string. The second declaration does not end the `0` value in order to
    end the string:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言允许直接声明字符数组作为数组或字符串。第二个声明不以`0`值结束以结束字符串：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We already saw how to convert a Go string to a C character array using the
    following function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用以下函数将Go字符串转换为C字符数组：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function will allocate the string in the heap so that it will be the application's
    responsibility to free such memory using the `C.free` function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将在堆中分配字符串，因此应用程序有责任使用`C.free`函数释放此内存。
- en: 'In order to convert a slice of bytes to a C character pointer named `*char`,
    we can use the following function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将字节片转换为名为`*char`的C字符指针，我们可以使用以下函数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As it happens, for `C.CString`, the application allocates the data in the heap
    and leaves the responsibilities of freeing it to the Go application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`C.CString`，应用程序在堆中分配数据，并将释放的责任留给Go应用程序。
- en: The main difference between these two functions is that the first produces `char[]` ,
    while the other creates `*char`. These two types are the equivalent of the Go
    `string` and `[]byte`, since the bytes of the first type cannot be changed, while
    the one from the second type can.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数之间的主要区别在于第一个生成`char[]`，而另一个创建`*char`。这两种类型相当于Go的`string`和`[]byte`，因为第一种类型的字节不能更改，而第二种类型的字节可以更改。
- en: 'There are a series of functions that are used to convert the C types back to
    Go ones. As far as strings are concerned, there are two functions: `C.GoString`
    creates a string from the entire array, and `C.GoStringN` enables the creation
    of a string using an explicit length:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有一系列函数用于将C类型转换回Go类型。就字符串而言，有两个函数：`C.GoString`从整个数组创建字符串，`C.GoStringN`允许使用显式长度创建字符串：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To transform the C `*char` back to Go `[]byte`, there is a single function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要将C的`*char`转换回Go的`[]byte`，有一个单独的函数：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can use the `C.CBytes` function to modify a slice of bytes using C and convert
    it back to a Go slice:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`C.CBytes`函数使用C修改字节片并将其转换回Go片：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Executing this application will show that when converting the byte slice, `b1`,
    to the C type as the `c1` variable, it will change address. The C slice returned
    by the C function, `c2`, will have the same address as `c1` because it is the
    same slice. When converted back to Go again and assigned to `b2`, it will have
    another address that is different from the initial Go byte slice, `b1`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此应用程序将显示，将字节片`b1`转换为C类型作为`c1`变量时，地址将更改。由C函数返回的C片段`c2`将具有与`c1`相同的地址，因为它是相同的片段。再次转换回Go并分配给`b2`时，它将具有与初始Go字节片`b1`不同的另一个地址。
- en: 'We can achieve the same result using the C string function. Let''s use the
    same C code from the previous example and change the rest:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用C字符串函数来实现相同的结果。让我们使用上一个示例中的相同C代码并更改其余部分：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is important to note that when transferring the Go string and bytes values
    to C, the values are copied. As a consequence, the C code is not capable of editing
    them directly, but will edit the copy, leaving the original Go value intact.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，将Go字符串和字节值传输到C时，这些值会被复制。因此，C代码无法直接编辑它们，而是将编辑副本，保持原始Go值不变。
- en: Integers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数
- en: In C, the types of integers available have a number of similarities with Go,
    since there are signed and unsigned versions of each integer type in both languages,
    but they differ in terms of name and byte size. The C `sizeof` function makes
    it possible to check the size for each of these types.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，可用的整数类型与Go有许多相似之处，因为两种语言中每种整数类型都有带符号和无符号版本，但它们在名称和字节大小方面有所不同。 C的`sizeof`函数可以检查每种类型的大小。
- en: 'Here is a list of integer types that are available in C:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C中可用的整数类型列表：
- en: '**Signed types**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**有符号类型**'
- en: '| **Type** | **Size** | **Range** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **范围** |'
- en: '| `char` | 1 byte | [-128, +127] |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 1字节 | [-128, +127] |'
- en: '| `int` | 2 or 4 bytes | see `short` and `long` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 2或4字节 | 参见`short`和`long` |'
- en: '| `short` | 2 bytes | [-32 768, +32 767] |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 2字节 | [-32 768, +32 767] |'
- en: '| `long` | 4 bytes | [-2 147 483 648, +2 147 483 647] |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 4字节 | [-2 147 483 648, +2 147 483 647] |'
- en: '| `long long` | 8 bytes | [-9 223 372 036 854 775 808, +9 223 372 036 854 775
    807] |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | 8字节 | [-9 223 372 036 854 775 808, +9 223 372 036 854 775 807]
    |'
- en: '**Unsigned types**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**无符号类型**'
- en: '| **Type** | **Size** | **Range** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **范围** |'
- en: '| unsigned `char` | 1 byte | [0, +255] |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 无符号`char` | 1字节 | [0, +255] |'
- en: '| unsigned `int` | 2 or 4 bytes | see unsigned `short` or unsigned `long` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 无符号`int` | 2或4字节 | 参见无符号`short`或无符号`long` |'
- en: '| unsigned `short` | 2 bytes | [0, +65 535] |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 无符号`short` | 2字节 | [0, +65 535] |'
- en: '| unsigned `long` | 4 bytes | [0, +4 294 967 295] |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 无符号`long` | 4字节 | [0, +4 294 967 295] |'
- en: '| unsigned `long long` | 8 bytes | [0, +18 446 744 073 709 551 615 ] |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 无符号`long long` | 8字节 | [0, +18 446 744 073 709 551 615 ] |'
- en: The size of `int` in `C` depends on the architecture—it used to be 2 bytes with
    16-bit processors, but with modern processors (32- and 64-bit), it's 4 bytes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`C`中，`int`的大小取决于架构-在16位处理器上曾经是2字节，但在现代处理器（32位和64位）上是4字节。
- en: 'When we move from the realm of Go to the realm of C, and vice versa, we lose
    all variable overflow information. The compiler will not warn us when we try to
    fit an integer variable into another one that does not have an adequate size.
    We can see this with a brief example, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Go的领域移动到C的领域，反之亦然，我们失去了所有变量溢出的信息。当我们尝试将一个整数变量适应另一个没有足够大小的整数变量时，编译器不会警告我们。我们可以通过一个简短的例子来看到这一点，如下所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see that the value of `a` is a certain number, but the `short` and `long`
    variables do not have sufficient bytes, so they will have different values. The
    conversion shows that only the last bytes are taken from the variable when converting,
    and the other bytes are discarded.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`a`的值是一个确定的数字，但`short`和`long`变量没有足够的字节，所以它们将有不同的值。转换显示了在转换时只有最后的字节被取自变量，其他字节被丢弃。
- en: 'Here is a useful list of C types and comparable Go types, as well as how to
    use them in Go code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的C类型和可比较的Go类型的列表，以及如何在Go代码中使用它们：
- en: '| **C type** | **Go Type** | **CGO type** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '**C类型** | **Go类型** | **CGO类型**'
- en: '| `char` | `int8` | `C.char` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '`char` | `int8` | `C.char`'
- en: '| `short` | `int16` | `C.short` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '`short` | `int16` | `C.short`'
- en: '| `long` | `int32, rune` | `C.long` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '`long` | `int32, rune` | `C.long`'
- en: '| `long long` | `int64` | `C.longlong` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '`long long` | `int64` | `C.longlong`'
- en: '| `int` | `int` | `C.int` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`int` | `int` | `C.int`'
- en: '| unsigned `char` | `uint8, byte` | `C.uchar` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: 无符号的`char` | `uint8, byte` | `C.uchar`
- en: '| unsigned `short` | `uint16` | `C.ushort` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: 无符号的`short` | `uint16` | `C.ushort`
- en: '| unsigned `long` | `uint32` | `C.ulong` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: 无符号的`long` | `uint32` | `C.ulong`
- en: '| unsigned `long long` | `uint64` | `C.ulonglong` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: 无符号的`long long` | `uint64` | `C.ulonglong`
- en: '| unsigned `int` | `uint` | `C.uint` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: 无符号的`int` | `uint` | `C.uint`
- en: You can use this table as a reference when performing conversions and avoid
    errors derived from using the wrong type, since there are no overflow warnings
    when using CGO.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行转换时，您可以使用此表作为参考，并避免使用错误类型导致的错误，因为在使用CGO时没有溢出警告。
- en: Float types
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'In C, the `float` types are very similar to the Go ones:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，`float`类型与Go中的类型非常相似：
- en: C offers `float`, which is 32 bit, and `double`, which is 64 bit.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C提供了32位的`float`和64位的`double`。
- en: Go has `float32` and `float64`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go有`float32`和`float64`。
- en: 'This can cause rounding errors when converting from a 64-bit value to a 32-bit
    one, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当从64位值转换为32位值时，可能会导致四舍五入误差，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding example shows how the `math.Pi` value goes from `3.141592653589793`
    to `3.1415927`, causing an error of about `1/10⁷`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子显示了`math.Pi`的值从`3.141592653589793`变为`3.1415927`，导致了约`1/10⁷`的错误。
- en: Unsafe conversions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全的转换
- en: We will now see how it is possible to edit a Go variable from C using the `unsafe`
    package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何使用`unsafe`包从C中直接编辑Go变量。
- en: Editing a byte slice directly
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接编辑字节切片
- en: 'It also possible to edit a Go byte slice directly using a dirty trick. From
    Go''s perspective, a slice is a trio of values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用一个不正当的技巧直接编辑Go字节切片。从Go的角度来看，切片是一组值：
- en: A pointer to the first element
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素的指针
- en: The size of slice
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片的大小
- en: The capacity of the slice
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片的容量
- en: In C, a byte slice is just a series of bytes, and a string is a character slice
    that ends with a `\0`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，字节切片只是一系列字节，字符串是以`\0`结尾的字符切片。
- en: 'If we use the `unsafe` package to pass the pointer to the first element of
    the slice, we will be able to edit the existing byte slice directly without executing
    copies and transformations. We can see how to execute this conversion in the following
    application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`unsafe`包将指针传递给切片的第一个元素，我们将能够直接编辑现有的字节切片，而无需执行复制和转换。我们可以看到如何在以下应用程序中执行此转换：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The conversion is executed using the expression `(*C.char)(unsafe.Pointer(&b1[0]))`,
    which does the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 转换是使用表达式`(*C.char)(unsafe.Pointer(&b1[0]))`执行的，它执行以下操作：
- en: Takes the pointer to element zero for the slice
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取切片的第一个元素的指针
- en: Converts it into an unsafe pointer
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其转换为不安全的指针
- en: Converts the `byte` pointer into a `C.char` pointer, which shares the memory
    representation
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`byte`指针转换为`C.char`指针，共享内存表示
- en: Numbers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Using the `unsafe` package, we can also convert a numeric variable pointer to
    its C counterpart. This allows us to edit it directly in the C code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unsafe`包，我们还可以将数字变量的指针转换为其C对应项。这使我们能够直接在C代码中编辑它：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example does exactly that; it halves the value of `a` in a C function,
    without copying and assigning the new value in Go.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例确实做到了这一点；它在C函数中将`a`的值减半，而不是在Go中复制并分配新值。
- en: Working with slices
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用切片
- en: Go slices and C slices differ in one fundamental aspect—the Go version embeds
    both length and capacity, while in C, all we have is a pointer to the first element.
    This means that in C, length and capacity must be stored somewhere else, such
    as in another variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Go切片和C切片在一个基本方面有所不同——Go版本嵌入了长度和容量，而在C中，我们只有指向第一个元素的指针。这意味着在C中，长度和容量必须存储在其他地方，比如另一个变量中。
- en: 'Let''s take the following Go function, which calculates the mean of a series
    of `float64` numbers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下的Go函数，它计算一系列`float64`数字的平均值：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we want to have a similar function in C, we need to pass a pointer together
    with its length. This will avoid errors such as segmentation fault, which happens
    when an application tries to gain access to memory that has not been assigned
    to it. If the memory is still assigned to the application, the result is that
    it provides access to a memory area with an unknown value, causing unpredictable
    results:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在C中有一个类似的函数，我们需要传递一个指针以及它的长度。这将避免诸如分段错误之类的错误，当应用程序尝试访问未分配给它的内存时会发生这种错误。如果内存仍然分配给应用程序，结果是它提供对具有未知值的内存区域的访问，导致不可预测的结果：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can try this function using a Go wrapper that takes a slice and also passes
    the length to the C function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用一个Go包装器来使用这个函数，该包装器接受一个切片，并将长度传递给C函数：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To verify what happens, we can also create a similar function that passes a
    length that is not correct:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证发生了什么，我们还可以创建一个传递了不正确长度的类似函数：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When using this function, we will see that the application should not raise
    any segmentation fault error, but the result obtained will be different. This
    is because the second one will add a series of extra values to the mean calculation,
    as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数时，我们会看到应用程序不会引发任何分段错误，但得到的结果会有所不同。这是因为第二个将在平均计算中添加一系列额外的值，如下所示：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Working with structs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构
- en: After seeing how slices work, we will know how to handle complex data in C and
    Go using structures. For this, let's see the following sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了切片的工作原理之后，我们将知道如何在C和Go中使用结构处理复杂的数据。接下来让我们看看以下几节。
- en: Structures in Go
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的结构
- en: 'Go structures use a technique called alignment, which consists of adding one
    or more bytes to data structures to make it fit into memory addresses better. Consider
    the following data structure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Go结构使用一种称为对齐的技术，它包括向数据结构添加一个或多个字节，以使其更好地适应内存地址。考虑以下数据结构：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With 64-bit architecture calling `unsafe.Sizeof` on this structure, this will
    give us an unexpected result. What we are expecting is the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用64位架构在这个结构上调用`unsafe.Sizeof`，这将给我们一个意外的结果。我们期望的是以下结果：
- en: 16 bytes from the string; 8 for the pointer to the first element, and 8 for
    the length
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16字节来自字符串；8字节用于指向第一个元素，8字节用于长度
- en: 1 byte for the Boolean
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值占1字节
- en: 24 for the slice; 8 for the address, 8 for the length, and 8 for capacity
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 24用于切片；8用于地址，8用于长度，8用于容量
- en: 'The total should be 41, but the function returns 48\. This happens because
    the compiler inserts extra bytes after the Boolean, to reach 8 bytes (64 bits)
    and optimize the operation for the CPU. The structure could be represented in
    memory as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 总数应该是41，但函数返回48。这是因为编译器在布尔值之后插入了额外的字节，以达到8字节（64位），并优化CPU的操作。该结构可以在内存中表示如下：
- en: '![](img/5a7ca5c0-ffa9-472b-b28e-a18b81ac3a39.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a7ca5c0-ffa9-472b-b28e-a18b81ac3a39.png)'
- en: We can see that the Boolean variable takes 1 bit, and that there are 7 extra
    bits added by the compiler. This is very helpful because it avoids the other variables
    that are store, half in one memory slot and half in another. This would require
    two reads and two writes per operation, with a significant drop in performance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到布尔变量占用1位，并且编译器添加了7位额外的位。这非常有帮助，因为它避免了其他变量存储在一个内存槽中的一半，另一半存储在另一个内存槽中。这将导致每次操作需要两次读取和两次写入，性能显著下降。
- en: 'If two or more fields are small enough to fit in one slot of 64 bits, they
    will be stored sequentially. We can see this with the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多字段足够小，可以适应64位的一个槽，它们将被顺序存储。我们可以通过以下示例看到这一点：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This structure translates into the following memory representation on a 64-bit
    architecture:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构在64位架构上的内存表示如下：
- en: '![](img/9aae8af8-9a10-4da7-99a2-37ef32281030.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aae8af8-9a10-4da7-99a2-37ef32281030.png)'
- en: We can clearly see that both the Boolean variables, the `rune` and the `byte`,
    are in the same memory address, and a byte of padding is added to align the last
    field.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到布尔变量，`rune`和`byte`都在同一个内存地址上，并且在最后一个字段上添加了一个字节的填充以对齐。
- en: Manual padding
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动填充
- en: 'Go makes it possible to specify padding in structs manually using the blank
    identifier for fields. Take the following data structure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Go使得可以使用空白标识符手动指定结构中的填充。考虑以下数据结构：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will have the following representation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有以下表示：
- en: '![](img/32a0f046-89da-45ac-9778-843da54b6b14.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32a0f046-89da-45ac-9778-843da54b6b14.png)'
- en: 'We can use the blank identifier to specify padding manually and to optimize
    the data structure for a 64-bit architecture:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用空白标识符手动指定填充，并为64位架构优化数据结构：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will allow the application to store each `int32` in its own memory location
    because the blank fields will be acting as padding:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许应用程序将每个`int32`存储在自己的内存位置，因为空白字段将充当填充：
- en: '![](img/9e7bfe3d-cac4-411a-b7d5-a2ba6a158b94.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e7bfe3d-cac4-411a-b7d5-a2ba6a158b94.png)'
- en: Structures in C
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C中的结构
- en: Structures in C share the same concept of alignment that Go uses, but they are
    always aligned using 4-byte padding. Unlike Go, it is possible to avoid padding
    entirely, which helps to save space by reducing memory usage. Let's find out more
    about this in the following sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: C中的结构共享与Go相同的对齐概念，但它们总是使用4字节填充对齐。与Go不同的是，可以完全避免填充，这有助于通过减少内存使用量来节省空间。让我们在以下几节中了解更多。
- en: Unpacked structures
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未打包的结构
- en: 'Each struct we define will be unpacked unless otherwise specified. We can define
    a structure in C as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，否则我们定义的每个结构都将是未打包的。我们可以在C中定义一个结构如下：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use it and populate it with values directly from our Go code without
    any issues arising:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从我们的Go代码中使用它并填充它的值，而不会出现任何问题：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This small test will give us the following output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小测试将给我们以下输出：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This tells us that there is an extra blank field that is used for padding because
    the last field is 10 bytes, which is 2 bytes short of being a multiple of 4 (that
    is, 12 bytes).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们有一个额外的空白字段用于填充，因为最后一个字段是10字节，比4的倍数（即12字节）短2字节。
- en: Packed structures
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧凑结构
- en: 'We can define a packed struct in C using the `pragma pack` directive. We can
    pack the structure from before as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pragma pack`指令在C中定义一个紧凑的结构。我们可以将之前的结构打包如下：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we try to use the C structure in our Go code, we will obtain a compile error,
    if using fields `c` and `d`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在我们的Go代码中使用C结构，如果使用字段`c`和`d`，我们将获得编译错误：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we try to print the structure as we did for the unpacked version, we will
    see the reason why:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试像我们对未打包版本所做的那样打印结构，我们将看到原因：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can see from the output that the `c` and `d` fields, both of 4 bytes, are
    replaced by one empty field of 8 bytes that Go cannot access. Consequently, we
    cannot populate the structure from Go, but we can access this field in the C part
    of the application:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，4字节的`c`和`d`字段被一个8字节的空字段替换，Go无法访问。因此，我们无法从Go中填充结构，但可以在应用程序的C部分访问这个字段：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will allow us to return a structure with the correct values. We can print
    it and see that the `_` field contains both the values of `c` and `d`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们返回一个带有正确值的结构。我们可以打印它并看到“_”字段包含“c”和“d”的值：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have the data, we need to create a Go structure that can host it:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据，我们需要创建一个能够承载它的Go结构：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we need to read the raw bytes from the C structure and unpack it manually:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从C结构中读取原始字节并手动解包它：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can use the `C.GoBytes` function, which works for any pointer (not just bytes)
    and specifies the size of the struct we defined, which is stored in the constant, `C.sizeof_myStruct`.
    We can then proceed to read each field in order using the `binary.Read` function
    with **Little-Endian** (**LE**) encoding.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“C.GoBytes”函数，它适用于任何指针（不仅仅是字节），并指定我们定义的结构的大小，该大小存储在常量“C.sizeof_myStruct”中。然后，我们可以使用“binary.Read”函数按顺序读取每个字段，使用**小端**（**LE**）编码。
- en: 'We can see that the resulting structure contains all the data in the correct
    fields:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到生成的结构包含所有正确字段中的数据：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: CGO recommendations
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CGO建议
- en: We have now seen how to use CGO with integers, floating pointers, slices, and
    structures. This is a very powerful tool that facilitates the use of a lot of
    the existing C code in our Go applications. As we did for reflection in the previous
    chapter, we are now going to talk about the less obvious downsides of CGO.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何在整数、浮点数、切片和结构体中使用CGO。这是一个非常强大的工具，可以方便我们在Go应用程序中使用大量现有的C代码。就像我们在上一章中对反射所做的那样，我们现在要谈谈CGO的不太明显的缺点。
- en: Compilation and speed
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和速度
- en: 'One of Go''s trademarks is blazingly fast compilation times. When using CGO,
    the amount of work involved in the compilation is much higher, and involves more
    than just passing all the `.go` files to the Go compiler. The compilation process
    goes more or less as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Go的一个特点是编译速度非常快。使用CGO时，编译所涉及的工作量要大得多，不仅仅是将所有“.go”文件传递给Go编译器。编译过程大致如下：
- en: CGO needs to create C to Go and Go to C stubs.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CGO需要创建C到Go和Go到C的存根。
- en: The `make` command needs to be called to compile all the C source files.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要调用“make”命令来编译所有C源文件。
- en: All the files are combined in a `.o` file.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有文件都合并在一个“.o”文件中。
- en: The system's linker needs to verify that all the references between Go and C
    are valid.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的链接器需要验证Go和C之间的所有引用是否有效。
- en: If this process goes smoothly, you can launch your application, but if you encounter
    any issues, you will need to check the errors between C and Go, which is not as
    easy as debugging a pure Go application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个过程顺利进行，您可以启动您的应用程序，但如果遇到任何问题，您需要检查C和Go之间的错误，这并不像调试纯Go应用程序那样容易。
- en: Another drawback is that not every operating system comes with a `make` command
    out of the box. The C part may require some extra flags to compile correctly,
    and that cannot be handled by `go install` or `go build`. You will need to create
    a compilation script for your application, such as a `makefile` script.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是，并非每个操作系统都自带“make”命令。C部分可能需要一些额外的标志才能正确编译，这不能由“go install”或“go build”处理。您需要为您的应用程序创建一个编译脚本，比如一个“makefile”脚本。
- en: Performance
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: While discussing how to let C and Go talk to one another, we saw that for each
    type, there is a conversion operation that needs to be executed. This can be straightforward,
    as it happens, for numbers, but a little bit more complex for strings, bytes,
    or slices, and even more when we talk about structures. These operations are not
    cost-free, both in terms of memory usage and performance. This will not be a problem
    for many applications, but if you're trying to achieve high performance, it could
    be your bottleneck.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何让C和Go相互通信时，我们看到对于每种类型，都需要执行一个转换操作。这对于数字来说可能很简单，但对于字符串、字节或切片来说可能会更复杂，当涉及到结构时甚至更复杂。这些操作不是免费的，无论是在内存使用还是性能方面。这对许多应用程序来说不是问题，但如果您试图实现高性能，这可能成为瓶颈。
- en: The C code is not aware of what's happening in its Go counterpart. When it needs
    to be invoked, Go needs to pass the information about its stack to C in a format
    that is suitable for it. When the C code finishes its execution, the information
    about the stack state and the variables used needs to be transferred back from
    C to Go.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: C代码并不知道其Go对应部分发生了什么。当需要调用它时，Go需要以适合它的格式将有关其堆栈的信息传递给C。当C代码完成执行时，需要将有关堆栈状态和使用的变量的信息从C传递回Go。
- en: Dependency from C
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自C的依赖
- en: When using CGO, you face the same problem that other languages face when creating
    bindings or wrappers to C code. You are completely dependent on it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CGO时，您面临着其他语言在创建与C代码绑定或包装时面临的相同问题。您完全依赖于它。
- en: The Go application has to handle the way C uses memory and other resources,
    while the C application is not aware of what Go is doing and is not using any
    kind of concurrency, neither goroutines nor threads.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Go应用程序必须处理C如何使用内存和其他资源，而C应用程序不知道Go在做什么，也不使用任何并发，既不是goroutine也不是线程。
- en: In addition to that, C code is hard to debug, maintain, and replace if you're
    not a C developer. This way, sometimes it is better to write a library from the
    ground up, instead of relying on the existing C implementation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，C代码很难调试、维护和替换，如果您不是C开发人员。因此，有时最好从头开始编写一个库，而不是依赖现有的C实现。
- en: A very good example of this is `go-git` ([https://github.com/src-d/go-git](https://github.com/src-d/go-git)),
    which implements the Git protocol functionality in pure Go by imitating the existing
    C library, [libgit2](https://libgit2.org/).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是“go-git”（[https://github.com/src-d/go-git](https://github.com/src-d/go-git)），它通过模仿现有的C库[libgit2](https://libgit2.org/)，在纯Go中实现了Git协议功能。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we saw a very powerful tool in the Go arsenal: CGO. This allows
    a Go application to run C code, which, in turn, can invoke Go functions. We saw
    that it requires a special `import` statement, `import "C"`, which is a pseudo
    package that contains all the C code available to Go. To export Go code and make
    it available to C, there is a special comment, `//export`, which makes the Go
    function available in the C namespace.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Go工具中非常强大的一个工具：CGO。这允许Go应用程序运行C代码，反过来又可以调用Go函数。我们看到它需要一个特殊的`import`语句，`import
    "C"`，这是一个伪包，其中包含所有可供Go使用的C代码。要导出Go代码并使其可供C使用，有一个特殊的注释`//export`，它使Go函数在C命名空间中可用。
- en: We saw that the C and Go type systems are very similar for some things, but
    very different for others. We saw that strings and byte arrays can be converted
    to C types, and vice versa. Integers in C and Go are also pretty similar, the
    main difference being the `int` type. In C, this is 4 bytes, while in Go, it is
    4 or 8 bytes, depending on the architecture. Floats are also pretty similar, with
    a 4- and 8-bit version in both C and Go, which just have different names.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到C和Go类型系统在某些方面非常相似，但在其他方面非常不同。我们看到字符串和字节数组可以转换为C类型，反之亦然。C和Go中的整数也非常相似，主要区别在于`int`类型。在C中，这是4个字节，而在Go中，它是4或8个字节，取决于架构。浮点数也非常相似，在C和Go中都有4位和8位版本，只是名称不同。
- en: It is also possible to edit a numeric Go variable or a byte slice directly, without
    creating a copy. This is possible using the `unsafe.Pointer` function to force
    a casting that wouldn't otherwise be allowed. Slices in C are just pointers to
    the first element, and the length of the slice needs to be stored in another variable.
    That's why we created Go functions that take the slice and pass both parameters
    to their C counterparts.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以直接编辑数字Go变量或字节切片，而不创建副本。这是通过使用`unsafe.Pointer`函数来强制进行转换，否则是不允许的。C中的切片只是指向第一个元素的指针，切片的长度需要存储在另一个变量中。这就是为什么我们创建了接受切片并将两个参数传递给它们的C对应函数的Go函数。
- en: Before talking about data structures, we must mention what alignment is, how
    Go achieves it, and how C alignment differs from that of Go. Data structures in
    CGO use alignment, and are pretty straightforward to use. If they are not packed,
    we can pass them around and extract values very easily. If the structure is packed
    instead, we cannot access some of its fields and we need a workaround to manually execute
    a conversion to Go.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论数据结构之前，我们必须提到对齐是什么，Go是如何实现对齐的，以及C对齐与Go的不同之处。CGO中的数据结构使用对齐，并且非常容易使用。如果它们没有打包，我们可以轻松地传递它们并提取值。如果结构被打包，我们就无法访问其中的一些字段，需要一种解决方法来手动执行转换到Go。
- en: The final topic focused on the downsides of CGO, from its slower building time
    to its drop in performance because of the conversion that is required, and how
    the application is going to end up being more difficult to maintain because of
    the C code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个主题集中讨论了CGO的缺点，从构建时间较慢到性能下降，因为需要转换，以及由于C代码的存在，应用程序将变得更难维护。
- en: I hope you enjoyed this Go journey so far, and that it will help you to write
    modern, concurrent, and efficient applications.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你迄今为止享受了这段Go之旅，并且它将帮助你编写现代、并发和高效的应用程序。
- en: Questions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is CGO?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CGO是什么？
- en: How can you call C code from Go?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从Go调用C代码？
- en: How can you use Go code in C?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在C中使用Go代码？
- en: What difference in data types is there between Go and C?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go和C之间的数据类型有什么区别？
- en: How can you edit Go values inside C code?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在C代码中编辑Go值？
- en: What is the main problem with packed data structures?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包数据结构的主要问题是什么？
- en: What are the main downfalls of CGO?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CGO的主要缺点是什么？
