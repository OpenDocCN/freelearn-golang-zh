- en: End-to-End Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端路由
- en: '**End-to-end application routing** is the magic that allows us to leverage
    the benefits of the classic web application architecture along with the benefits
    of the single page application architecture. When implementing modern web applications,
    we have to strike a balance between satisfying the needs of two distinct audiences—humans
    and machines.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端应用程序路由**是使我们能够利用经典Web应用程序架构和单页面应用程序架构的优势的魔力。在实现现代Web应用程序时，我们必须在满足两个不同受众（人类和机器）的需求之间取得平衡。'
- en: Let's first consider the experience from the human user's perspective. When
    a human user directly accesses the About page that we demonstrated in the previous
    chapter, template rendering is initially performed on the server side. This provides
    an initial page load that is perceived to be fast by the human user, since the
    web page content is readily available. This is the hallmark of the classic web
    application architecture. A different approach was taken for subsequent user interactions
    with the website. When the user clicked on the link to the About page from the
    navigation menu, template rendering was performed on the client side without the
    need of a full page reload, allowing for a more smooth and fluid user experience.
    This is the hallmark of the single page application architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们从人类用户的角度考虑体验。当人类用户直接访问我们在上一章演示的“关于”页面时，模板渲染首先在服务器端执行。这为人类用户提供了一个初始页面加载，因为网页内容是立即可用的，所以被认为是快速的。这是经典的Web应用程序架构的特点。对于用户与网站的后续交互采取了不同的方法。当用户从导航菜单点击“关于”页面的链接时，模板渲染在客户端执行，无需进行完整的页面重新加载，从而提供更流畅和流畅的用户体验。这是单页面应用程序架构的特点。
- en: Machine users consist of the the various search engine bot crawlers that periodically
    visit the website. As you learned in the [Chapter 1](c90ed736-d3cf-4c9b-bae7-c8b894e25259.xhtml),
    *Isomorphic Web Applications with Go*, single page applications, are primarily
    not search-engine friendly since the vast majority of search engine bots don't
    have the intelligence to traverse them. Traditional search engine bots are accustomed
    to parsing well-formed HTML markup that has already been rendered. It's much more
    difficult for the bots to be trained to parse through the JavaScript that is used
    to implement the single page application architecture. If we want greater search
    engine discoverability, we must satisfy the needs of our machine audience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 机器用户包括定期访问网站的各种搜索引擎爬虫。正如您在[第1章](c90ed736-d3cf-4c9b-bae7-c8b894e25259.xhtml)中学到的，*使用Go构建同构Web应用程序*，单页面应用程序主要不利于搜索引擎，因为绝大多数搜索引擎爬虫没有智能来遍历它们。传统的搜索引擎爬虫习惯于解析已经呈现的格式良好的HTML标记。训练这些爬虫解析用于实现单页面应用程序架构的JavaScript要困难得多。如果我们希望获得更大的搜索引擎可发现性，我们必须满足我们的机器受众的需求。
- en: The goal of striking the balance between fulfilling the needs of these two distinct
    audiences is the essence of isomorphic web applications. We will learn how to
    accomplish this goal, in this chapter, while we implement the product-related
    pages of IGWEB.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现IGWEB的产品相关页面时，我们将学习如何在本章中实现这一目标，即在满足这两个不同受众的需求之间取得平衡。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Routing perspectives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由视角
- en: The design of the product-related pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品相关页面的设计
- en: Implementing product-related templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现与产品相关的模板
- en: Modeling product data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建模产品数据
- en: Accessing product data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问产品数据
- en: Registering server-side routes with Gorilla Mux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux注册服务器端路由
- en: Server-side handler functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端处理程序函数
- en: Registering client-side routes with the isokit router
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用isokit路由器注册客户端路由
- en: Client-side handler functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端处理程序函数
- en: Rest API endpoints
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rest API端点
- en: Routing perspectives
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由视角
- en: Let's consider how routing works in an Isomorphic Go web application from the
    perspective of the server side and from that of the client side. Remember, our
    goal is to utilize end to end routing to provide web page content access to machine
    users, and to deliver an enhanced user experience to human users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器端和客户端的角度考虑Isomorphic Go Web应用程序中的路由工作原理。请记住，我们的目标是利用端到端路由为机器用户提供网页内容访问，并为人类用户提供增强的用户体验。
- en: Routing on the server side
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端路由
- en: '*Figure 5.1* depicts an initial page load in an Isomorphic Go application,
    implementing the classic web application architecture. The client can either be
    a web browser or a bot (machine) that accesses the website by providing a URL.
    The URL contains the route that the client is accessing. For example, the `/products`
    route, will serve the products listing page. The `/product-detail/swiss-army-knife`
    route, will serve the product detail page for the swiss army knife product that
    is being sold on the website. The request router is responsible for mapping the
    route to its designated route handler function. The request router we will be
    using on the server side is the Gorilla Mux router, and it is available in the
    `mux` package:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1*描述了Isomorphic Go应用程序中的初始页面加载，实现了经典的Web应用程序架构。客户端可以是通过提供URL访问网站的Web浏览器或机器（机器）。URL包含客户端正在访问的路由。例如，`/products`路由将提供产品列表页面。`/product-detail/swiss-army-knife`路由将提供网站上销售的瑞士军刀产品的产品详细页面。请求路由器负责将路由映射到其指定的路由处理程序函数。我们将在服务器端使用的请求路由器是Gorilla
    Mux路由器，它在`mux`包中可用：'
- en: '![](img/bd37be68-f694-4e99-8e5a-dffc6f412520.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd37be68-f694-4e99-8e5a-dffc6f412520.png)'
- en: 'Figure 5.1: Initial page load in an Isomorphic Go application'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：Isomorphic Go应用程序中的初始页面加载
- en: The route handler is responsible for servicing a particular route. It contains
    a set of logic that is executed to perform a given task for a route. For example,
    the route handler for the `/products` route is responsible for fetching the products
    to display, rendering the products listing web page from the associated template,
    and sending the response back to the client. The response from the web server
    is an HTML document, which contains links to associated CSS and JavaScript source
    files. It may also be possible that the returned web page contains inline CSS
    or JavaScript sections as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序负责服务特定路由。它包含一组逻辑，用于执行给定路由的任务。例如，`/products`路由的路由处理程序负责获取要显示的产品，从相关模板中呈现产品列表网页，并将响应发送回客户端。来自Web服务器的响应是一个HTML文档，其中包含与关联的CSS和JavaScript源文件的链接。返回的Web页面也可能包含内联的CSS或JavaScript部分。
- en: Take note that although the diagram depicts Golang running inside the web browser,
    in reality, it is the JavaScript representation (which was transpiled using GopherJS)
    of the Go program that is running inside the web browser. When the client receives
    the server response, the web page is rendered in the user interface inside the
    web browser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管图表描绘了Golang在Web浏览器内运行，但实际上在Web浏览器内运行的是Go程序的JavaScript表示（使用GopherJS转译）。当客户端接收到服务器响应时，Web页面将在Web浏览器内的用户界面中呈现。
- en: Routing on the client side
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端路由
- en: '*Figure 5.2* depicts routing from the perspective of the client side in an
    Isomorphic Go application, implementing the single page application architecture.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.2*描述了从Isomorphic Go应用程序的客户端角度实现单页面应用程序架构的路由。'
- en: In *Figure 5.1*, the client side played a trivial role in simply rendering the
    web page server response. Now, in addition to displaying the rendered web page,
    the client contains a request router, route handlers, and the application business
    logic inside of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图5.1*中，客户端只是简单地呈现Web页面服务器响应的角色。现在，除了显示呈现的Web页面外，客户端还包含请求路由器、路由处理程序和应用程序业务逻辑。
- en: 'We will use the isokit router from the `isokit` package to perform client-side
    routing. The client-side router works much in the same manner as the server-side
    router, except instead of evaluating an HTTP request, the router intercepts the
    click of a hyperlink defined on the web page and routes it to a particular route
    handler defined on the client side itself. The client-side route handler that
    services a particular route, interacts with the server through a Rest API endpoint
    that is accessed by making XHR requests. The response from the web server is data
    that can take on a variety of formats, such as JSON, XML, Plain Text, and HTML
    Fragment, or even Gob-encoded data. We will use JSON as our means of data exchange
    in this chapter. The business logic of the application will determine how the
    data is handled, and it may be displayed to the user in the user interface. At
    this point, all rendering operations can take place on the client side, allowing
    us to prevent a full page reload:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`isokit`包中的isokit路由器执行客户端路由。客户端路由器的工作方式与服务器端路由器类似，只是不是评估HTTP请求，而是拦截在网页上定义的超链接的点击，并将其路由到客户端自身定义的特定路由处理程序。服务特定路由的客户端路由处理程序通过Rest
    API端点与服务器交互，通过发出XHR请求访问。来自Web服务器的响应是可以采用各种格式的数据，如JSON、XML、纯文本和HTML片段，甚至是Gob编码的数据。在本章中，我们将使用JSON作为数据交换的手段。应用程序的业务逻辑将决定数据的处理方式，并且可以在用户界面中显示。此时，所有渲染操作都可以在客户端上进行，从而可以防止整个页面重新加载：
- en: '![](img/563dbef7-1158-4954-a3a3-6146c5f0d36e.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/563dbef7-1158-4954-a3a3-6146c5f0d36e.png)'
- en: 'Figure 5.2: End to End Routing consists of a router on both ends'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：端到端路由包括两端的路由器
- en: Design of the product-related pages
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品相关页面的设计
- en: 'The product-related pages of IGWEB consist of the products listing page and
    the product detail page. The Products page, which may also be referred to as the
    products listing page, will display a list of items that a user may purchase from
    the website. As depicted by the wireframe in *Figure 5.3*, each product will contain
    a thumbnail-sized image of the product, the product price, the product name, a
    brief description of the product, and a button to add the product to the shopping
    cart. Clicking on a product image will take the user to the product detail page
    for the given product. The route to access the products listing page is `/products`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: IGWEB的产品相关页面包括产品列表页面和产品详细页面。产品页面，也可以称为产品列表页面，将显示用户可以从网站购买的商品列表。如*图5.3*所示的线框图，每个产品都包含产品的缩略图，产品价格，产品名称，产品的简要描述，以及将产品添加到购物车的按钮。点击产品图片将带用户进入给定产品的产品详细页面。访问产品列表页面的路由是`/products`：
- en: '![](img/6d8d4c86-627c-409f-9dda-730870fbfc1b.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d8d4c86-627c-409f-9dda-730870fbfc1b.png)'
- en: 'Figure 5.3: Wireframe design of the Products page'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：产品页面的线框设计
- en: 'The product detail page contains information on an individual product. As depicted
    by the wireframe in *Figure 5.4*, the product detail page consists of a full size
    image of the product, the product name, the price of the product, a long description
    of the product, and a button to add the product to the shopping cart. The route
    to access the product detail page is `/product-detail/{productTitle}`. The `{productTitle}`
    is the **SEO** (short for, **search engine optimization**) friendly name of the
    product, for example, the swiss army knife product will have a `{productTitle}`
    value of `"swiss-army-knife"`. By defining SEO friendly product names inside our
    `/product-detail` route, we make it easier for search engine bots to index a website
    and derive semantic meaning from the collection of product detail URLs. In fact,
    a URL that is search engine friendly is known as a **semantic URL**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 产品详细页面包含有关单个产品的信息。如*图5.4*所示的线框设计，产品详细页面包括产品的全尺寸图像、产品名称、产品价格、产品的长描述以及将产品添加到购物车的按钮。访问产品详细页面的路由是`/product-detail/{productTitle}`。`{productTitle}`是产品的**SEO**（搜索引擎优化）友好名称，例如，瑞士军刀产品的`{productTitle}`值将是`"swiss-army-knife"`。通过在`/product-detail`路由中定义SEO友好的产品名称，我们使搜索引擎机器人更容易索引网站，并从产品详细URL集合中推导出语义含义。事实上，搜索引擎友好的URL被称为**语义URL**。
- en: '![](img/5a11f748-d1e1-466f-99ad-906801884842.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a11f748-d1e1-466f-99ad-906801884842.png)'
- en: 'Figure 5.4: Wireframe design of the Product detail page'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：产品详细页面的线框设计
- en: Implementing product-related templates
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现与产品相关的模板
- en: Implementing the product-related templates consists of implementing the templates
    for the products listing page and the templates for the product detail page. The
    products listing page is depicted in *Figure 5.3*, and the product detail page
    is depicted in *Figure 5.4*. We will implement templates to realize these wireframe
    designs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与产品相关的模板包括实现产品列表页面的模板和产品详细页面的模板。产品列表页面如*图5.3*所示，产品详细页面如*图5.4*所示。我们将实现模板来实现这些线框设计。
- en: Implementing the templates for the products listing page
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现产品列表页面的模板
- en: 'Let''s examine the `products_page.tmpl` source file found in the `shared/templates` directory:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`shared/templates`目录中找到的`products_page.tmpl`源文件：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the page template for the products listing page. The primary purpose
    of this template is to render the contents of the `products_content` template
    and place it inside of the web page layout.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是产品列表页面的页面模板。这个模板的主要目的是呈现`products_content`模板的内容，并将其放置在网页布局中。
- en: 'Let''s examine the `products_content.tmpl` source file found in the `shared/templates` directory:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`shared/templates`目录中找到的`products_content.tmpl`源文件：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the content template for the products listing page. The purpose of this
    template is to display all the available products for sale. Inside the `productsContainer` `div` element,
    we have specified an `{{if}}` conditional that checks whether there are products
    available to be displayed. If there are products available, we use the `{{range}}` template
    action to iterate over all the available `Product` objects and generate the HTML
    markup required for each product card. We have defined an anchor (`<a>`) tag to
    make the image clickable, so that the user can navigate directly to the product
    detail page upon clicking on the product image. We have also defined a button
    to add the product to the shopping cart.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是产品列表页面的内容模板。这个模板的目的是显示所有可供销售的产品。在`productsContainer` `div`元素内，我们指定了一个`{{if}}`条件，检查是否有产品可供显示。如果有产品可用，我们使用`{{range}}`模板动作来遍历所有可用的`Product`对象，并生成每个产品卡所需的HTML标记。我们定义了一个锚（`<a>`）标签，使图像可点击，这样用户可以直接点击产品图像进入产品详细页面。我们还定义了一个按钮，将产品添加到购物车中。
- en: If there are no products to be displayed, we reach the `{{else}}` conditional
    and we place a helpful message to indicate that the products need to be loaded
    into the Redis database instance from the sample data set. For the reader's convenience,
    we have provided a hyperlink that can be clicked, which will populate the sample
    data into the Redis instance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有产品可供显示，我们会到达`{{else}}`条件，并放置一个有用的消息，指示需要将产品从样本数据集加载到Redis数据库实例中。为了方便读者，我们提供了一个可以点击的超链接，点击后将样本数据填充到Redis实例中。
- en: Implementing the templates for the product detail page
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现产品详细页面的模板
- en: 'Let''s examine the `product_detail_page.tmpl` source file found in the `shared/templates` directory:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`shared/templates`目录中找到的`product_detail_page.tmpl`源文件：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the page template for the product detail page. Its primary purpose is
    to render the contents of the `product_detail_content` template and place it inside
    of the web page layout.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是产品详细页面的页面模板。其主要目的是呈现`product_detail_content`模板的内容，并将其放置在网页布局中。
- en: 'Let''s examine the `product_detail_content.tmpl` source file found in the `shared/templates` directory:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`shared/templates`目录中找到的`product_detail_content.tmpl`源文件：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside this template, we defined the HTML markup required to render the product
    detail container for the product detail page. We render the product image along
    with the product name, product price, and a detailed summary of the product. Finally,
    we declared a button to add the product to the shopping cart.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们定义了呈现产品详细页面的产品详细容器所需的HTML标记。我们呈现产品图像以及产品名称、产品价格和产品的详细摘要。最后，我们声明了一个按钮，将产品添加到购物车中。
- en: Modeling product data
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对产品数据进行建模
- en: 'We have defined the `Product` struct in the `shared/models/product.go` source
    file to model product data:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`shared/models/product.go`源文件中定义了`Product`结构来对产品数据进行建模。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `SKU` field represents the product's stock keeping unit (`SKU`), a unique
    id that represents the product. In the sample data set provided, we use incrementing
    integer values, however, this field is of the `string` type to accommodate alphanumeric
    SKUs in the future for extensibility. The `Name` field represents the name of
    the product. The `Description` field represents the short description that will
    be included in the products listing page. The `ThumbnailPreviewURI` field provides
    the path to the thumbnail image of the product. The `Price` field represents the
    price of the product and is of the `float64` type. The `Route` field is the server
    relative path to the product detail page for the given product. The `SummaryDetail`
    field represents the long description for the product that will be displayed in
    the product detail page. Finally, the `Quantity` field, which is of the `int` type,
    is the quantity of the particular product item that is presently in the shopping
    cart. We will be making use of this field in the next chapter, when we implement
    the shopping cart functionality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKU`字段代表产品的库存单位（`SKU`），这是代表产品的唯一标识。在提供的样本数据集中，我们使用递增的整数值，但是这个字段是`string`类型的，以便将来可以容纳包含字母数字的SKU，以实现可扩展性。`Name`字段代表产品的名称。`Description`字段代表将包含在产品列表页面中的简短描述。`ThumbnailPreviewURI`字段提供产品缩略图的路径。`Price`字段代表产品的价格，类型为`float64`。`Route`字段是给定产品的服务器相对路径到产品详细页面。`SummaryDetail`字段代表产品的长描述，将显示在产品详细页面中。最后，`Quantity`字段是`int`类型，代表目前在购物车中的特定产品数量。在下一章中，当我们实现购物车功能时，我们将使用这个字段。'
- en: Accessing product data
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问产品数据
- en: For our product data access needs, we have defined two methods in our Redis
    datastore. The `GetProducts` method will return a slice of products and will drive
    the data needs for the products listing page. The `GetProductDetail` method will
    return the profile information for a given product that will drive the data needs
    of the product detail page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的产品数据访问需求，我们在Redis数据存储中定义了两种方法。`GetProducts`方法将返回一个产品切片，并满足产品列表页面的数据需求。`GetProductDetail`方法将返回给定产品的配置信息，满足产品详细页面的数据需求。
- en: Retrieving products from the datastore
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据存储中检索产品
- en: 'Let''s examine the `GetProducts` method defined in the `common/datastore/redis.go` source
    file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在`common/datastore/redis.go`源文件中定义的`GetProducts`方法：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we start by checking whether the product registry key, `"product-registry"`,
    exists in the Redis datastore. If it does exist, we declare a string slice called
    `productKeys`, which is a slice containing all the keys of the available products
    to display on the products listing page. We use the `Cmd` method on the Redis
    datastore object, `r`, to issue a Redis `"GET"` command, which is used to retrieve
    a record, for a given key. We supply the `registryKey` as the second argument
    to the method. Finally, we chain the method call to the `.Str()` method, which
    will convert the output to a string type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查Redis数据存储中是否存在产品注册键“product-registry”。如果存在，我们声明一个名为`productKeys`的字符串切片，其中包含要显示在产品列表页面上的所有产品的键。我们在Redis数据存储对象`r`上使用`Cmd`方法来发出Redis的`"GET"`命令，用于检索给定键的记录。我们将`registryKey`作为方法的第二个参数。最后，我们将方法调用链接到`.Str()`方法，将输出转换为字符串类型。
- en: Retrieving the product detail from the datastore
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据存储中检索产品详细信息
- en: The product registry data store in the Redis datastore is JSON data representing
    a slice of strings. We use the `Unmarshal` function found in the `json` package
    to `unmarshal` the JSON encoded data into the `productKeys` variable. Now, that
    we have all the product keys that should be displayed on the products listing
    page, it's time to create a product instance for each key. We do so, by first
    declaring the products variable that will be a slice of products. We iterate through
    the product keys and derive the `productTitle` value, which is the SEO friendly
    name of the product. We supply the `productTitle` variable to the `GetProductDetail`
    method of the Redis datastore to fetch a product for the given product title.
    We assign the fetched product to the `product` variable and append it to the `products`
    slice. Once the `for` loop ends, we will have collected all the products that
    should be displayed on the product listing page. Finally, we return the `products`
    slice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Redis数据存储中的产品注册数据是表示字符串切片的JSON数据。我们使用`json`包中的`Unmarshal`函数将JSON编码的数据解码为`productKeys`变量。现在，我们已经获得了应该显示在产品列表页面上的所有产品键，是时候为每个键创建一个产品实例了。我们首先声明将成为产品切片的`products`变量。我们遍历产品键并得出`productTitle`值，这是产品的SEO友好名称。我们将`productTitle`变量提供给Redis数据存储的`GetProductDetail`方法，以获取给定产品标题的产品。我们将获取的产品赋给`product`变量，并将其追加到`products`切片中。一旦`for`循环结束，我们将收集到应该显示在产品列表页面上的所有产品。最后，我们返回`products`切片。
- en: 'Let''s examine the `GetProductDetail` method defined in the `common/datastore/redis.go` source
    file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在`common/datastore/redis.go`源文件中定义的`GetProductDetail`方法：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We assign the `productKey` variable of the `string` type with the value of the
    route to the product detail page. This involves concatenating the `"/product-detail"` string with
    the `productTitle` variable for the given product. We check to see whether the
    product key exists in the Redis datastore. If it doesn't exist, we return from
    the method, and if it does exist, we continue on and declare the `p` variable of
    the `Product` type. This will be the variable that the function will return. The
    product data stored in the Redis datastore is the JSON representation of a `Product`
    object. We `unmarshal` the JSON encoded data into the `p` variable. If we didn't
    encounter any errors, we return `p`, which represents the `Product` object for
    the requested `productTitle` variable that was specified as the input argument
    to the `GetProductDetail` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`productKey`变量声明为`string`类型，并赋予产品详细页面的路由值。这涉及将`"/product-detail"`字符串与给定产品的`productTitle`变量连接起来。我们检查产品键是否存在于Redis数据存储中。如果不存在，我们从方法中返回；如果存在，我们继续声明`p`变量为`Product`类型。这将是函数将返回的变量。Redis数据存储中存储的产品数据是`Product`对象的JSON表示。我们将JSON编码的数据解码为`p`变量。如果我们没有遇到任何错误，我们将返回`p`，它代表了请求的`productTitle`变量的`Product`对象，该变量被指定为`GetProductDetail`方法的输入参数。
- en: At this point, we have satisfied the data needs to display a list of products
    for the `/products` route and to display a product's profile page for the `/product-detail/{productTitle}`
    route. Now it's time to register the server-side routes for the product-related
    pages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经满足了在`/products`路由上显示产品列表和在`/product-detail/{productTitle}`路由上显示产品概要页面的数据需求。现在是时候注册与产品相关页面的服务器端路由了。
- en: Registering server-side routes with Gorilla Mux
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gorilla Mux注册服务器端路由
- en: We will use the Gorilla Mux router to handle the server-side application routing
    needs. This router is very flexible since it can not only handle simple routes
    such as `/products` but it can also handle routes with embedded variables. Recall
    that the `/product-detail` route contains the embedded `{productTitle}` variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gorilla Mux路由器来处理服务器端应用程序的路由需求。这个路由器非常灵活，因为它不仅可以处理简单的路由，比如`/products`，还可以处理带有嵌入变量的路由。回想一下，`/product-detail`路由包含嵌入的`{productTitle}`变量。
- en: 'We will start by creating a new instance of the Gorilla Mux router and assigning
    it to the `r` variable as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个Gorilla Mux路由器的新实例，并将其分配给`r`变量，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the section of code from the `registerRoutes` function, defined in
    the `igweb.go` source file, where we register routes along with their associated
    handler functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`igweb.go`源文件中定义的`registerRoutes`函数中的代码部分，我们在这里注册路由以及它们关联的处理函数：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We use the `Handle` method to associate a route to a given handler function
    that is responsible for servicing the given route. For example, when the `/products`
    route is encountered, it will be handled by the `ProductsHandler` function defined
    in the `handlers` package. The `ProductsHandler` function will be responsible
    for fetching the products from the datastore, using the product records to render
    the products listing page from a template and sending the web page response back
    to the web client. Similarly, the `/product-detail/{productTitle}` route will
    be handled by the `ProductDetailHandler` function. This handler function will
    be responsible for fetching the product record for an individual product, using
    the product record to render the product detail page from a template and sending
    the web page response back to the web client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Handle`方法将路由与负责处理该路由的处理函数关联起来。例如，当遇到`/products`路由时，它将由`handlers`包中定义的`ProductsHandler`函数处理。`ProductsHandler`函数将负责从数据存储中获取产品，使用产品记录从模板中呈现产品列表页面，并将网页响应发送回网页客户端。类似地，`/product-detail/{productTitle}`路由将由`ProductDetailHandler`函数处理。这个处理函数将负责获取单个产品的产品记录，使用产品记录从模板中呈现产品详细页面，并将网页响应发送回网页客户端。
- en: Server-side handler functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端处理函数
- en: Now that we have registered the server-side routes for the product-related pages,
    it's time to examine the server-side handler functions that are responsible for
    servicing these routes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为与产品相关的页面注册了服务器端路由，是时候来检查负责处理这些路由的服务器端处理函数了。
- en: The handler function for the products listing page
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表页面的处理函数
- en: 'Let''s examine the `products.go` source file found in the `handlers` directory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`handlers`目录中找到的`products.go`源文件：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we fetch the slice of products, featured on the Products page, by calling
    the `GetProducts` method on the Redis datastore object, `env.DB`. We declared
    the `templateData` variable of the `templatedata.Products` type, and it represents
    the data object that will be passed to the template engine, alongside the `products_page`
    template, to render the Products page. The `PageTitle` field represents the web
    page title, and the `Products` field is the slice of the products that are to
    be displayed on the Products page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过在Redis数据存储对象`env.DB`上调用`GetProducts`方法来获取产品切片，该产品切片在产品页面上展示。我们声明了`templatedata.Products`类型的`templateData`变量，它代表将传递给模板引擎的数据对象，以及`products_page`模板，以渲染产品页面。`PageTitle`字段代表网页标题，`Products`字段是要在产品页面上显示的产品切片。
- en: Inside the `ProductsHandler` function, we call the `GetProducts` method on the
    datastore object to fetch the available products for displaying from the datastore.
    We then create a template data instance having a `PageTitle` field value of `"Products"`,
    and we assign the products that were fetched from the datastore to the `Products`
    field. Finally, we render the `products_page` template from the template set.
    With regard to the `RenderParams` object that we pass to the `env.TemplateSet`
    object's `Render` method, we set the `Writer` property to the `w` variable, which
    is `http.ResponseWriter`, and we set the `Data` property to the `templateData`
    variable, which is the data object that will be supplied to the template. At this
    point, the rendered web page will be sent back to the web client in the server
    response.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductsHandler`函数内部，我们调用数据存储对象的`GetProducts`方法，从数据存储中获取可供显示的产品。然后，我们创建一个模板数据实例，其`PageTitle`字段值为`"Products"`，并将从数据存储中获取的产品分配给`Products`字段。最后，我们从模板集中渲染`products_page`模板。关于我们传递给`env.TemplateSet`对象的`Render`方法的`RenderParams`对象，我们将`Writer`属性设置为`w`变量，即`http.ResponseWriter`，并将`Data`属性设置为`templateData`变量，即将提供给模板的数据对象。此时，渲染的网页将作为服务器响应发送回Web客户端。
- en: '*Figure 5.5* shows the rendered Products page that has been generated after
    accessing the `/products` route by visiting the following link: `http://localhost:8080/products`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5显示了在访问`/products`路由后生成的产品页面，方法是访问以下链接：`http://localhost:8080/products`：
- en: '![](img/d0b0b6da-70a7-4a86-9e6d-f66e37778726.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0b0b6da-70a7-4a86-9e6d-f66e37778726.png)'
- en: 'Figure 5.5: The Products Page'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：产品页面
- en: Now that we are able to display the Products page, let's take a look at the
    handler function for the product detail page.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够显示产品页面，让我们来看一下产品详细页面的处理函数。
- en: The handler function for the product detail page
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品详细页面的处理函数
- en: 'Let''s examine the `productdetail.go` source file found in the `handlers` directory:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`handlers`目录中找到的`productdetail.go`源文件：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the handler function that handles the `/product/{productTitle}` route.
    Remember, this is the route with the embedded variable inside of it. Inside the
    `ProductDetailHandler` function, we first gather the variables defined in the
    route, by calling the `Vars` function of the `mux` package. We supply `r`, the
    pointer to `http.Request`, as the input parameter to the `Vars` function. The
    result of this function is a map of the `map[string]string` type, where the key
    is the name of the variable in the route and the value is the value for that particular
    variable. For example, if we were accessing the `/product-detail/swiss-army-knife`
    route, the key would be `"productTitle"` and the value would be `"swiss-army-knife"`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理`/product/{productTitle}`路由的处理函数。请记住，这是嵌入变量的路由。在`ProductDetailHandler`函数内部，我们首先通过调用`mux`包的`Vars`函数来收集路由中定义的变量。我们将`r`，即`http.Request`的指针，作为`Vars`函数的输入参数。该函数的结果是`map[string]string`类型的映射，其中键是路由中变量的名称，值是该特定变量的值。例如，如果我们访问`/product-detail/swiss-army-knife`路由，键将是`"productTitle"`，值将是`"swiss-army-knife"`。
- en: We get the value supplied for the `productTitle` variable in the route, and
    assign it to the `productTitle` variable. We then get the product object from
    the datastore by supplying the `GetProductDetail` method of the datastore object
    with the `productTitle` variable. We then set up our template data object, setting
    the fields for the page title and the product record. Finally, we call the render
    method on the template set indicating that we want to render the `product_detail_page`
    template. We assign the `http` response writer object and the template data object
    to the respective fields of the render `params` object, which is passed in as
    the second argument to the template set's Render method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取路由中提供的`productTitle`变量的值，并将其赋给`productTitle`变量。然后，我们通过向数据存储对象的`GetProductDetail`方法提供`productTitle`变量来获取产品对象。然后，我们设置我们的模板数据对象，设置页面标题和产品记录的字段。最后，我们在模板集上调用渲染方法，指示我们要渲染`product_detail_page`模板。我们将`http`响应写入对象和模板数据对象分配给渲染`params`对象的相应字段，该对象作为模板集的渲染方法的第二个参数传入。
- en: 'At this point, we have everything that we need in place to render the product
    detail page. Let''s visit the product detail page for the swiss army knife from `http://localhost:8080/products/swiss-army-knife`.
    Here is the rendered product detail page in the web browser:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经准备好渲染产品详细页面所需的一切。让我们访问`http://localhost:8080/products/swiss-army-knife`上的瑞士军刀产品详细页面。以下是在Web浏览器中呈现的产品详细页面：
- en: '![](img/246bdb8e-387d-49a4-ba26-10f3bddf3e98.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/246bdb8e-387d-49a4-ba26-10f3bddf3e98.png)'
- en: 'Figure 5.6: The Product detail page for the Swiss Army Knife'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：瑞士军刀的产品详细页面
- en: Now we have made the `/products` and `/product-title/{productTitle}` routes
    available to humans and machines alike, and we have implemented the classic web
    application architecture. Our machine users (the search engine bots) will be satisfied,
    since they can easily index the links of all the products available in the products
    listing page, and they can readily parse the HTML markup on each product detail
    page.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使`/products`和`/product-title/{productTitle}`路由对人类和机器都可用，并且我们已经实现了经典的Web应用程序架构。我们的机器用户（搜索引擎机器人）将会满意，因为他们可以轻松地索引产品列表页面上所有产品的链接，并且可以轻松解析每个产品详细页面上的HTML标记。
- en: However, we haven't completely satisfied our human audience yet. You may have
    noticed that clicking on an individual product from the product listing page results
    in a full page reload. In a brief instance, the screen may go white in the transition
    of leaving one page and rendering the next page within the web browser. The same
    full page reload happens when we click on the Products link in the navigation
    menu to return to the products listing page from the product detail page. We can
    enhance the user experience of transitioning through web pages by implementing
    the single page architecture for subsequent interactions with the website, after
    the initial page load. In order to do so, we need to define client-side routes
    along with their associated client-side route handler functions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完全满足我们的人类观众。您可能已经注意到，从产品列表页面点击单个产品会导致整个页面重新加载。在短暂的瞬间，屏幕可能会在离开一个页面并在Web浏览器中呈现下一个页面的过渡中变白。当我们从产品详细页面点击导航菜单中的产品链接返回到产品列表页面时，同样会发生完整的页面重新加载。我们可以通过在初始页面加载后实现单页面架构来增强用户在网页之间的过渡体验。为了做到这一点，我们需要定义客户端路由以及它们相关的客户端路由处理程序函数。
- en: Registering client-side routes with the isokit router
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用isokit路由器注册客户端路由
- en: On the client side, we use the isokit router to handle routes. The isokit router
    works by intercepting the click events to hyperlinks and checking if the hyperlink
    contains a route defined in its routing table.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，我们使用isokit路由器来处理路由。isokit路由器通过拦截超链接的单击事件并检查超链接是否包含在其路由表中定义的路由来工作。
- en: We can register a route in the router's routing table using the `Handle` method
    of the isokit router object. The `Handle` method takes two parameters—the first
    parameter is the route and the second parameter is the handler function that should
    service the route. Notice that the code to declare and register routes is very
    similar to the Gorilla Mux router on the server side. Because of this similarity,
    registering routes on the client side, with the isokit router, is straightforward
    and feels like second nature.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用isokit路由器对象的`Handle`方法在路由表中注册路由。`Handle`方法接受两个参数——第一个参数是路由，第二个参数是应该服务该路由的处理程序函数。请注意，声明和注册路由的代码与服务器端的Gorilla
    Mux路由器非常相似。由于这种相似性，使用isokit路由器在客户端注册路由是直接的，感觉像是第二天性。
- en: 'Here''s the section of code from the `registerRoutes` function defined in the `client.go`
    source file found in the `client` folder, which is responsible for registering
    routes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`client`文件夹中找到的`client.go`源文件中定义的`registerRoutes`函数的代码部分，该函数负责注册路由：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we start by creating a new isokit router by calling the `NewRouter` function
    from the `isokit` package and assigning it to the `r` variable. We have defined
    the `/products` route for the product listing page, and the `/product-data/{productTitle}`
    route for the product detail page. After defining all the routes, we make a call
    to the `Listen` method of the router object, `r`. The `Listen` method is responsible
    for adding an event listener to all hyperlinks, to listen for click events. Links
    that are defined in the router's routing table will be intercepted upon a click
    event and their associated client-side route handler function will service them.
    Finally, we assign the `r` router to the `Router` field of the `env` object, so
    that we can access the router throughout the client-side web application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先通过从`isokit`包中调用`NewRouter`函数创建一个新的isokit路由器，并将其分配给`r`变量。我们已经为产品列表页面定义了`/products`路由，以及为产品详细页面定义了`/product-data/{productTitle}`路由。在定义所有路由之后，我们调用路由器对象`r`的`Listen`方法。`Listen`方法负责为所有超链接添加事件侦听器，以侦听单击事件。在路由器的路由表中定义的链接将在单击事件发生时被拦截，并且它们相关的客户端路由处理程序函数将为它们提供服务。最后，我们将`r`路由器分配给`env`对象的`Router`字段，以便我们可以在客户端Web应用程序中访问路由器。
- en: Client-side handler functions
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端处理程序函数
- en: Now that we've registered the routes for the product-related pages on the client
    side, let's take a look at the client-side route handlers functions that are responsible
    for servicing these routes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在客户端注册了与产品相关的页面的路由，让我们来看看负责服务这些路由的客户端路由处理程序函数。
- en: The handler function for the products listing page
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品列表页面的处理程序函数
- en: 'Let''s examine the `ProductsHandler` function in the `products.go` source file
    found in the `client/handlers` directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`client/handlers`目录中`products.go`源文件中的`ProductsHandler`函数：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Recall that from the diagram depicted in *Figure 5.2*, that the client-side
    web application accesses the server-side functionality through the use of XHR
    calls to Rest API endpoints. Here, we create the `productsChannel` channel to
    retrieve a slice of the `Product` objects. We call the `FetchProducts` function,
    which will make the XHR call to the Rest API endpoint on the server that is responsible
    for retrieving the list of available products to display on the Products page.
    Notice that we call the `FetchProducts` function as a goroutine. We must do this
    to ensure that the XHR call does not block. We supply the `productsChannel` channel
    as the sole input argument to the `FetchProducts` function. We then retrieve the
    list of products over the `productsChannel` channel and assign it to the `products`
    variable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在*图5.2*中描述的图表中，客户端Web应用通过对Rest API端点的XHR调用访问服务器端功能。在这里，我们创建`productsChannel`通道来检索`Product`对象的切片。我们调用`FetchProducts`函数，该函数将对服务器上负责检索要在产品页面上显示的可用产品列表的Rest
    API端点进行XHR调用。请注意，我们将`FetchProducts`函数作为goroutine调用。我们必须这样做以确保XHR调用不会阻塞。我们将`productsChannel`通道作为`FetchProducts`函数的唯一输入参数。然后，我们通过`productsChannel`通道检索产品列表并将其分配给`products`变量。
- en: We create a new template data object instance, `templateData`, and set the respective
    fields for the `PageTitle` and the `Products` field. After this, we call the `Render`
    method on the `env.TemplateSet` object, specifying that we want to render the
    `products_content` template. In the `RenderParams` object that we supply to the
    `Render` function, we set the `Data` field with the template data object, `templateData`.
    We set the `Disposition` field to `isokit.PlacementReplaceInnerContents` to specify
    that the disposition of the render should replace the inner HTML contents of the
    associated element. We set the `Element` field to be the primary content `div` container,
    where the main page content is rendered. We call the `InitializeProductsEventHandlers`
    function to set up the event handlers found in the products page. For the Products
    page, the only DOM element needing an event handler is the Add To Cart button,
    which we will cover in [Chapter 6](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml), *Isomorphic
    Handoff*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的模板数据对象实例`templateData`，并设置`PageTitle`和`Products`字段的相应字段。之后，我们在`env.TemplateSet`对象上调用`Render`方法，指定我们要渲染`products_content`模板。在我们提供给`Render`函数的`RenderParams`对象中，我们使用模板数据对象`templateData`设置`Data`字段。我们将`Disposition`字段设置为`isokit.PlacementReplaceInnerContents`，以指定渲染的位置应替换相关元素的内部HTML内容。我们将`Element`字段设置为主要内容`div`容器，其中主页面内容被渲染。我们调用`InitializeProductsEventHandlers`函数来设置产品页面中找到的事件处理程序。对于产品页面，唯一需要事件处理程序的DOM元素是“添加到购物车”按钮，我们将在[第6章](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml)
    *同构交接*中介绍。
- en: As far as client-side routing is concerned, the last line of code in the `ProductsHandler`
    function is the most important line. When each product card is rendered by the
    template renderer, we need to intercept the links of each product item. We can
    tell the isokit router to intercept these links by providing a query selector
    that will target the links found in the primary content `div` container. We do
    this by calling the `RegisterLinks` method of the isokit router object and specifying
    that the query selector should be `"#primaryContent a"`. This will ensure that
    all the links for the product items are intercepted, and that when we click on
    a product item, instead of performing a full page reload to get to the `/product-detail/{productTitle}`
    route, the client-side route handler for the product-detail route will kick in
    and service the request.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就客户端路由而言，`ProductsHandler`函数中的最后一行代码是最重要的一行代码。当模板渲染器渲染每个产品卡时，我们需要拦截每个产品项的链接。我们可以通过提供一个查询选择器来告诉isokit路由器拦截这些链接，该查询选择器将定位主要内容`div`容器中的链接。我们通过调用isokit路由器对象的`RegisterLinks`方法并指定查询选择器应为`"#primaryContent
    a"`来实现这一点。这将确保拦截所有产品项的链接，并且当我们单击产品项时，客户端路由处理程序将启动并服务请求，而不是执行完整的页面重新加载以到达`/product-detail/{productTitle}`路由。
- en: Fetching the list of products
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取产品列表
- en: 'Now that we''ve seen how the client-side route handler function works, let''s
    take a look at the `FetchProducts` function that is used to make the XHR call
    to the server and gather the list of products to display on the page:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了客户端路由处理程序函数的工作原理，让我们来看看`FetchProducts`函数，该函数用于对服务器进行XHR调用并收集要在页面上显示的产品列表：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we use the `xhr` package to make XHR calls to the server. We call the
    `Send` function from the `xhr` package and specify that our request will be using
    the `GET` method, and we will be making the request to the `/restapi/get-products`
    endpoint. For the third argument to the function, we pass a value of `nil` to
    indicate that we are not sending data in our XHR call. If the XHR call is successful,
    we will receive JSON data from the server, which will represent a slice of the `Product`
    objects. We create a new JSON Decoder to decode the data and store it in the `products`
    variable, which we send over the `productsChannel`. We will be examining the Rest
    API endpoint that services this XHR call, in the section, *The endpoint to get
    the list of products*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`xhr`包来对服务器进行XHR调用。我们从`xhr`包中调用`Send`函数，并指定我们的请求将使用`GET`方法，并且我们将对`/restapi/get-products`端点进行请求。对于函数的第三个参数，我们传递了一个值`nil`，以指示我们在XHR调用中不发送数据。如果XHR调用成功，我们将从服务器接收JSON数据，该数据将表示`Product`对象的切片。我们创建一个新的JSON解码器来解码数据并将其存储在`products`变量中，然后将其发送到`productsChannel`。我们将在*用于服务此XHR调用的Rest
    API端点*部分中检查服务此XHR调用的Rest API端点。
- en: At this point, our web application has attained the goal of being able to render
    the Products page without causing a full page reload on subsequent interactions
    with the website. For example, if we were to access the About page at `http://localhost:8080/about`,
    the initial page load will be serviced on the server side. If we initiated a subsequent
    interaction by clicking on the Products link in the navigation menu, the client-side
    routing will kick in, and the Products page will load, without a full page reload
    taking place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的Web应用程序已经实现了能够在与网站的后续交互中渲染产品页面而不引起完整页面重新加载的目标。例如，如果我们访问`http://localhost:8080/about`上的关于页面，初始页面加载将在服务器端进行。如果我们通过单击导航菜单中的产品链接来启动后续交互，客户端路由将启动，并且产品页面将加载，而不会发生完整的页面重新加载。
- en: In the *Verifying client-side routing functionality* section, we will show you
    how you can verify that client-side routing is functioning properly, using the
    web browser's inspector. Now it's time to implement the client-side route handler
    for the product detail page.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*验证客户端路由功能*部分，我们将向您展示如何使用Web浏览器的检查器验证客户端路由是否正常运行。现在是时候实现产品详细页面的客户端路由处理程序了。
- en: The handler function for the product detail page
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品详细页面的处理程序函数
- en: 'Let''s examine the `ProductDetailHandler` function defined in the `productdetail.go`
    source file found in the `client/handlers` directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`client/handlers`目录中的`productdetail.go`源文件中定义的`ProductDetailHandler`函数：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ProductDetailHandler` function returns an `isokit.Handler` value. Notice
    that we specify `isokit.HandlerFunc` as a closure, so that we can perform a dependency
    injection of the `env` object to our client-side handler function. Notice that
    the input argument to `isokit.HandlerFunc` is of the `context.Context` type. This
    context object is important because it contains the variable information embedded
    within a route. By calling the `Value` method on the `ctx` context object, we
    can obtain the route variables by specifying the key of `"Vars"` to the context
    object. Notice that we perform a type assertion to specify that the value obtained
    from the context object is of the `map[string]string` type. We can extract the
    value for the `productTitle` from the route by providing the ``product-detail/{productTitle}`` key.
    The value for the `productTitle` is important since we will be sending it as a
    route variable in the XHR call we make to the server to obtain a product object.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailHandler`函数返回一个`isokit.Handler`值。请注意，我们将`isokit.HandlerFunc`指定为闭包，以便我们可以对我们的客户端处理程序函数执行依赖注入`env`对象。请注意，`isokit.HandlerFunc`的输入参数是`context.Context`类型。这个上下文对象很重要，因为它包含嵌入在路由中的变量信息。通过在`ctx`上下文对象上调用`Value`方法，我们可以通过将`"Vars"`键指定给上下文对象来获取路由变量。请注意，我们执行类型断言以指定从上下文对象获取的值是`map[string]string`类型。我们可以通过提供`product-detail/{productTitle}`键从路由中提取`productTitle`的值。`productTitle`的值很重要，因为我们将在向服务器发出XHR调用以获取产品对象时将其作为路由变量发送。'
- en: We create a product channel, `productChannel`, that will be used to send and
    receive a `Product` object. We call the `FetchProductDetail` function, providing `productChannel`
    and `productTitle` as input arguments to the function. Notice that we call the
    function as a goroutine, and upon successfully running the function, we will have
    a product object sent over `productChannel`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个产品渠道`productChannel`，用于发送和接收`Product`对象。我们调用`FetchProductDetail`函数，提供`productChannel`和`productTitle`作为函数的输入参数。请注意，我们将函数作为goroutine调用，成功运行函数后，我们将通过`productChannel`发送一个产品对象。
- en: We set up our template data object, specifying values for the `PageTitle` and
    `Product` fields. We then set the title of the page to the product name. Once
    this is done, we call the `Render` method of the template set object, and we specify
    that we want to render the `product_detail_content` template. We set the fields
    of the render parameters object, populating the fields for the template data object,
    the disposition, and the associated element where the template will be rendered
    to, which is the primary content `<div>` container. Finally, we make a call to
    the `InitializeProductDetailEventHanders` function, which is responsible for setting
    up the event handlers for the product detail page. The only element in need of
    handlers for this page is the Add To Cart button, which we will cover in the next
    chapter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置模板数据对象，为`PageTitle`和`Product`字段指定值。然后我们将页面标题设置为产品名称。完成后，我们调用模板集对象的`Render`方法，并指定要渲染`product_detail_content`模板。我们设置渲染参数对象的字段，填充模板数据对象、位置和模板将被渲染到的相关元素的字段，这是主要内容`<div>`容器。最后，我们调用`InitializeProductDetailEventHanders`函数，该函数负责设置产品详情页面的事件处理程序。这个页面唯一需要处理程序的元素是“添加到购物车”按钮，我们将在下一章中介绍。
- en: Fetching the product detail
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取产品详情
- en: 'Let''s examine the `FetchProductDetail` function defined in the `productdetail.go`
    source file in the `client/handlers` folder:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`client/handlers`文件夹中`productdetail.go`源文件中定义的`FetchProductDetail`函数：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function is responsible for making the XHR call to the Rest API endpoint
    on the server that provides the product data. The function takes in a product
    channel and a product title as input arguments. We make the XHR call by calling
    the `Send` function of the `xhr` package. Take note that in the second input argument
    to the function (the destination that we are making the request to), we concatenate
    the `prouductTitle` variable to the `/restapi/get-product-detail` route. So, for
    example, if we wanted to request the product object for the swiss army knife,
    we would specify a route of `/restapi/get-product-detail/swiss-army-knife`, and
    in this scenario, the `productTitle` variable would be equal to `"swiss-army-knife"`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责向服务器端的Rest API端点发出XHR调用，以提供产品数据。该函数接受产品渠道和产品标题作为输入参数。我们通过调用`xhr`包的`Send`函数来进行XHR调用。请注意，在函数的第二个输入参数（我们发出请求的目的地）中，我们将`productTitle`变量连接到`/restapi/get-product-detail`路由。因此，例如，如果我们想请求瑞士军刀的产品对象，我们将指定路由为`/restapi/get-product-detail/swiss-army-knife`，在这种情况下，`productTitle`变量将等于`"swiss-army-knife"`。
- en: If the XHR call was successful, the server will return the JSON encoded product
    object. We use a JSON decoder to decode the JSON data returned from the server,
    and we set the `product` variable to the decoded `Product` object. Finally, we
    pass `product` over `productChannel`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果XHR调用成功，服务器将返回JSON编码的产品对象。我们使用JSON解码器解码从服务器返回的JSON数据，并将`product`变量设置为解码的`Product`对象。最后，我们通过`productChannel`传递`product`。
- en: Rest API endpoints
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rest API端点
- en: The Rest API endpoints on the server side are pretty handy. They are the means
    to provide the client-side web application with data, behind the scenes, and we
    apply this data to the respective template to display the page content without
    having the need to do a full page reload.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端的Rest API端点非常方便。它们是在幕后向客户端Web应用程序提供数据的手段，我们将这些数据应用到相应的模板上，以显示页面内容，而无需进行完整的页面重新加载。
- en: Now, we'll consider what goes in to creating these Rest API endpoints. We will
    first have to register routes for them on the server side. We will follow the
    same procedure that we did at the beginning of this chapter for the product listing
    page and the product detail page. The only difference is that our handler functions
    will be found in the `endpoints` package as opposed to being in the `handlers`
    package. The fundamental difference here is that the `handlers` package contains
    handler functions that return a full web page response back to the web client.
    The `endpoints` package, on the other hand, contains handler functions that will
    return data, most likely in the JSON format, back to the web client.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将考虑创建这些Rest API端点所需的内容。我们首先必须在服务器端为它们注册路由。我们将遵循本章开头为产品列表页面和产品详细页面所做的相同过程。唯一的区别是我们的处理程序函数将在`endpoints`包中而不是在`handlers`包中。这里的根本区别在于`handlers`包包含将完整网页响应返回给Web客户端的处理程序函数。另一方面，`endpoints`包包含将数据返回给Web客户端的处理程序函数，很可能是以JSON格式返回。
- en: 'Here''s the section of code from the `igweb.go` source file, where we register
    our Rest API endpoints:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`igweb.go`源文件中的代码部分，我们在其中注册了我们的Rest API端点：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the `/restapi/get-products` route that drives the data needs for
    the client-side products page is serviced by the `GetProductsEndpoint` function
    found in the `endpoints` package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，驱动客户端产品页面的数据需求的`/restapi/get-products`路由由`endpoints`包中的`GetProductsEndpoint`函数提供服务。
- en: Similarly, the `/restapi/get-product-detail/{productTitle}` route that drives
    the data needs for the client-side product detail page, is serviced by the `GetProductDetailEndpoint`
    function found in the `endpoints` package.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，驱动客户端产品详细页面的`/restapi/get-product-detail/{productTitle}`路由由`endpoints`包中的`GetProductDetailEndpoint`函数提供服务。
- en: The endpoint to get the list of products
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取产品列表的端点
- en: 'Let''s examine the `products.go` source file in the `endpoints` folder:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下端点文件夹中的`products.go`源文件：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside the `GetProductsEndpoint` function, we first fetch the slice of products
    that will be displayed on the client-side products page by calling the `GetProducts`
    method of the datastore object, `env.DB`. We then set a header to indicate that
    the server response will be in JSON format. Finally, we use a JSON encoder to
    encode the slice of products as JSON data and write it out using the the `http.ResponseWriter`,
    `w`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetProductsEndpoint`函数内部，我们首先通过调用数据存储对象`env.DB`的`GetProducts`方法来获取将在客户端产品页面上显示的产品切片。然后，我们设置一个标头来指示服务器响应将以JSON格式返回。最后，我们使用JSON编码器将产品切片编码为JSON数据，并使用`http.ResponseWriter`
    `w`将其写出。
- en: The endpoint to get the product detail
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取产品详细信息的端点
- en: 'Let''s examine the `productdetail.go` source file in the endpoints folder:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下端点文件夹中的`productdetail.go`源文件：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside the `GetProductDetailEndpoint` function, we fetch embedded route variables,
    by calling the `Vars` function from the `mux` package and supplying the router
    object, `r`, as the sole input argument to the function. We then obtain the value
    for the `{productTitle}` embedded route variable and assign it to the variable
    `productTitle`. We supply the `productTitle` to the `GetProductDetail` method
    of the datastore object, `env.DB`, to retrieve the corresponding `Product` object
    from the datastore. We set a header to indicate that the server response will
    be in the JSON format, and we use the JSON encoder to encode the `Product` object
    as JSON data, which will be sent out to the web client using `http.ResponseWriter`,
    `w`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetProductDetailEndpoint`函数内部，我们通过调用`mux`包中的`Vars`函数并将路由对象`r`作为唯一输入参数来获取嵌入的路由变量。然后，我们获取`{productTitle}`嵌入式路由变量的值并将其分配给变量`productTitle`。我们将`productTitle`提供给数据存储对象`env.DB`的`GetProductDetail`方法，以从数据存储中检索相应的`Product`对象。我们设置一个标头来指示服务器响应将以JSON格式返回，并使用JSON编码器将`Product`对象编码为JSON数据，然后使用`http.ResponseWriter`
    `w`将其发送到Web客户端。
- en: We have now reached a major milestone. We have implemented the product-related
    pages in a manner that is friendly to both humans and machines alike. When a user
    initially access the products listing page, by entering the URL (`http://localhost:8080/products`)
    in the web browser, the page is rendered on the server side, and the web page
    response is sent back to the client. The user is able to see the web page instantly
    since the web page response is pre-rendered. This behavior exhibits the desired
    trait from the classic web application architecture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经达到了一个重要的里程碑。我们以一种对人类和机器都友好的方式实现了与产品相关的页面。当用户最初访问产品列表页面时，通过在Web浏览器中输入URL（`http://localhost:8080/products`），页面在服务器端呈现，并将Web页面响应发送回客户端。用户能够立即看到网页，因为网页响应是预先呈现的。这种行为展现了经典Web应用程序架构的期望特征。
- en: When the human user initiates subsequent interactions, by clicking on a product
    item, the product detail page is rendered from the client side, and the user is
    saved from having to experience a full page reload. This behavior exhibits the
    desired trait from the SPA architecture.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类用户发起后续交互时，通过单击产品项目，产品详细页面将从客户端呈现，并且用户无需经历完整页面重新加载。这种行为展现了SPA架构的期望特征。
- en: The machine users (the search engine bot crawlers) are also satisfied since
    they can traverse each link to a product item on the products page and readily
    index the website, since we have semantic URLs in place along with well-formed
    HTML markup that the search engine bots can understand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 机器用户（搜索引擎爬虫）也满意，因为他们可以遍历产品页面上的每个产品项目的链接并轻松索引网站，因为我们使用了语义化的URL以及搜索引擎爬虫可以理解的良好形式的HTML标记。
- en: Verifying the client-side routing functionality
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证客户端路由功能
- en: 'To ensure that the client-side routing is functioning properly, you can exercise
    the following procedure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保客户端路由正常运行，您可以执行以下过程：
- en: Access the Products page in your web browser and open up the web browser's inspector.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的Web浏览器中访问产品页面并打开Web浏览器的检查器。
- en: Click on the network tab to watch network traffic, and make sure to filter on
    XHR calls. Now, click on a product item to get to the product's detail page.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击网络选项卡以查看网络流量，并确保过滤XHR调用。现在，点击产品项目以进入产品的详细页面。
- en: Return to the Products page by clicking the Products link on the navigation
    menu.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击导航菜单上的“产品”链接返回产品页面。
- en: 'Repeat this process several times, and you should be able to see all the XHR
    calls being made in the background. *Figure 5.7* includes a screenshot of this
    procedure to verify that the client-side routing is functioning properly:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此过程多次，您应该能够看到后台进行的所有XHR调用。*图5.7*包括此过程的屏幕截图，以验证客户端路由是否正常运行：
- en: '![](img/5d31a4c4-b979-476b-8daf-fb608ee1a690.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d31a4c4-b979-476b-8daf-fb608ee1a690.png)'
- en: 'Figure 5.7: The XHR calls in the web console confirms that the client-side
    routing is functioning properly'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：Web控制台中的XHR调用确认客户端路由正常运行
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we implemented end to end application routing for IGWEB as
    we built the products-related pages. We started by registering server-side routes
    using the Gorilla Mux router. We associated each route with a corresponding, server-side
    route handler function that would service the server-side route. We then examined
    the implementation of the server-side route handler functions for the product-related
    pages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在构建与产品相关的页面时为IGWEB实现了端到端的应用程序路由。我们首先使用Gorilla Mux路由器注册了服务器端路由。我们将每个路由与相应的服务器端路由处理程序函数关联起来，该函数将为服务器端路由提供服务。然后，我们检查了产品相关页面的服务器端路由处理程序函数的实现。
- en: Having satisfied the needs of implementing the classic web application architecture
    for the initial page load, we moved on to the client side by first registering
    routes for the product-related pages, using the isokit router. Just as we had
    done on the server side, we associated each client-side route with a corresponding
    client side route handler function that would service the client-side route. You
    learned how to implement client-side route handlers and how to make XHR calls
    from them to server-side Rest API endpoints. Finally, you learned how to create
    server-side Rest API endpoints that handled XHR requests and returned JSON data
    to the client.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在满足了实现初始页面加载的经典Web应用程序架构的需求后，我们通过首先在客户端注册与产品相关的页面的路由，使用isokit路由器，转向了客户端。就像我们在服务器端所做的那样，我们将每个客户端路由与相应的客户端路由处理程序函数关联起来，该函数将为客户端路由提供服务。您学会了如何实现客户端路由处理程序以及如何从中对服务器端Rest
    API端点进行XHR调用。最后，您学会了如何创建处理XHR请求并向客户端返回JSON数据的服务器端Rest API端点。
- en: The product-related pages had a persistent state since the list of available
    products where driven by the contents of the datastore. How do we maintain state
    in a situation where the user interaction with the website changes the given state?
    For example, if the user added items to the shopping cart, how can we go about
    maintaining the state of the shopping cart and syncing it up between the server
    side and the client side? You are going to learn about *isomorphic handoff*, the
    process of handing off state between the server and the client in [Chapter 6](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml), *Isomorphic
    Handoff*. We will implement the shopping cart functionality for the website in
    the process of doing this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据存储的内容驱动的可用产品列表一样，与产品相关的页面具有持久状态。在用户与网站的交互改变了给定状态的情况下，我们如何维护状态？例如，如果用户向购物车中添加商品，我们如何维护购物车的状态并在服务器端和客户端之间进行同步？您将在[第6章](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml)中了解*同构交接*，即在服务器端和客户端之间交接状态的过程。在此过程中，我们将为网站实现购物车功能。
