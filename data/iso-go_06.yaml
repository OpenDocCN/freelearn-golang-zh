- en: Isomorphic Handoff
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构交接
- en: In the development of Isomorphic Go web applications, two critical techniques
    were introduced in the previous two chapters. First, you learned how to utilize
    an in-memory template set to render templates across environments. Second, you
    learned how to perform end-to-end routing on both the client and the server. Client-side
    routing is the magic that allows the client-side web application to operate in
    the single page mode.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在同构Go web应用的开发中，前两章介绍了两个关键技术。首先，您学习了如何利用内存模板集在各种环境中呈现模板。其次，您学习了如何在客户端和服务器端执行端到端路由。客户端路由是使客户端Web应用程序以单页面模式运行的魔法。
- en: The aforementioned techniques now provide us with the ability to navigate to
    different sections of the website, on the client itself, and render any given
    template across environments. As the implementors of an Isomorphic Go web application
    our responsibility is to ensure that state is maintained between the client and
    the server. For example, when rendering the Products page, it wouldn't make sense
    if the list of products was rendered differently on the client side than it was
    on the server side. The client needs to work in lockstep with the server to ensure
    that the state, in this case, the list of products is maintained—and that's where
    *isomorphic handoff* comes into the picture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上述技术现在为我们提供了在客户端本身导航到网站的不同部分并在各种环境中呈现任何给定模板的能力。作为同构Go web应用的实施者，我们的责任是确保在客户端和服务器之间维护状态。例如，在呈现产品页面时，如果产品列表在客户端和服务器端呈现方式不同，那就没有意义。客户端需要与服务器紧密合作，以确保状态（在这种情况下是产品列表）得到维护，这就是*同构交接*发挥作用的地方。
- en: '**Isomorphic handoff** is the process by which the server hands off state to
    the client and the client uses the passed state to render the web page on the
    client side. Keep in mind that the state the server passes off to the client must
    include the exact same state that was used to render the server-side web page
    response. Isomorphic handoff essentially allows the client to seamlessly pick
    up things where they were left off on the server. In this chapter, we''ll revisit
    the product-related pages, to see exactly how the state is maintained from the
    server side to the client side. In addition to that, we will also complete the
    implementation of the product-related pages, by implementing the user interactivity
    portions, which involve adding event handlers to the Add To Cart buttons found
    in these pages.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**同构交接**是指服务器将状态交接给客户端，客户端使用传递的状态在客户端呈现网页的过程。请记住，服务器传递给客户端的状态必须包括用于呈现服务器端网页响应的完全相同的状态。同构交接本质上允许客户端无缝地在服务器端中断的地方继续进行。在本章中，我们将重新访问与产品相关的页面，以了解状态如何从服务器端维护到客户端。此外，我们还将通过为这些页面中的“添加到购物车”按钮添加事件处理程序来完成产品相关页面的实施。'
- en: The shopping cart feature for the IGWEB website will be implemented in this
    chapter, and it will allow us to consider the scenario where the user can change
    the state of the shopping cart by adding and removing items to and from the shopping
    cart. We will use isomorphic handoff to ensure that the current state of the shopping
    cart is seamlessly maintained across the server and the client. By properly maintaining
    the state of the shopping cart we can guarantee that the shopping cart page rendered
    from the server side always matches the shopping cart page rendered from the client
    side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: IGWEB网站的购物车功能将在本章中实施，它将允许我们考虑用户可以通过向购物车中添加和删除商品来改变购物车状态的情景。我们将使用同构交接来确保购物车的当前状态在服务器和客户端之间无缝地维护。通过正确维护购物车的状态，我们可以保证从服务器端呈现的购物车页面始终与从客户端呈现的购物车页面匹配。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The isomorphic handoff procedure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同构交接程序
- en: Implementing isomorphic handoff for the product-related pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为产品相关页面实现同构交接程序
- en: Implementing isomorphic handoff for the shopping cart
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为购物车实现同构交接
- en: The isomorphic handoff procedure
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同构交接程序
- en: A recurring theme in the development of isomorphic web applications centers
    around the ability to share between the server and the client. In an isomorphic
    web application, the server and client must work in unison to seamlessly maintain
    the state of a particular workflow in the application. In order to do so, the
    server must share the current state, which was used to render the web page output
    on the server side with the client.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 同构Web应用程序开发中的一个重要主题是在服务器和客户端之间共享的能力。在同构Web应用程序中，服务器和客户端必须协同工作，以无缝地维护应用程序中特定工作流程的状态。为了做到这一点，服务器必须与客户端共享用于在服务器端呈现Web页面输出的当前状态。
- en: The ERDA strategy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ERDA策略
- en: 'The isomorphic handoff procedure consists of the following four steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同构交接程序包括以下四个步骤：
- en: Encode
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编码
- en: Register
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册
- en: Decode
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码
- en: Attach
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加
- en: We can use the acronym **ERDA** (**Encode-Register-Decode-Attach**) to easily
    recall each individual step of the procedure. In fact, we can collectively refer
    to the steps to implement the isomorphic handoff procedure as the **ERDA strategy**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用缩写**ERDA**（**编码-注册-解码-附加**）来轻松回忆每个步骤。事实上，我们可以将实施同构交接程序的步骤统称为**ERDA策略**。
- en: 'By implementing the four steps of the isomorphic handoff procedure, as depicted
    in *Figure 6.1*, we can guarantee that state is successfully persisted between
    the server and the client:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施同构交接程序的四个步骤，如*图6.1*所示，我们可以确保状态在服务器和客户端之间成功持久化：
- en: '![](img/b775dd1b-10c7-4646-88b4-5fae1ef16669.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b775dd1b-10c7-4646-88b4-5fae1ef16669.png)'
- en: 'Figure 6.1: The ERDA strategy to implement isomorphic handoff'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：实现同构交接的ERDA策略
- en: The first step, **Encode**, involves encoding a data object that represents
    the state we wish to retain to the client into a data exchange format (JSON, Gob,
    XML, and so on). The subsequent steps are all performed on the client side. The
    second step, **Register**, involves registering a client-side route and its respective
    handler function. The third step, **Decode**, involves decoding the encoded data
    retrieved from the server, through a Rest API endpoint, and utilizing it to render
    the template for the web page on the client side. The fourth and last step, **Attach**,
    involves attaching any needed event handlers to the rendered web page to enable
    user interactivity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，编码，涉及将代表我们希望保留到客户端的状态的数据对象编码为数据交换格式（JSON、Gob、XML等）。随后的步骤都在客户端上执行。第二步，注册，涉及注册客户端路由及其相应的处理程序函数。第三步，解码，涉及解码从服务器检索到的编码数据，通过Rest
    API端点，并利用它在客户端呈现网页的模板。第四步，附加，涉及将任何需要的事件处理程序附加到呈现的网页上，以实现用户交互。
- en: '*Figure 6.2* depicts the key modules involved, on both the server and the client,
    in implementing the isomorphic handoff procedure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2*描述了在服务器端和客户端上涉及的关键模块，用于实现等同手off过程：'
- en: '![](img/2acedc0f-703d-4bc2-bcf3-8a6b05c716b0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2acedc0f-703d-4bc2-bcf3-8a6b05c716b0.png)'
- en: 'Figure 6.2: The key modules involved in isomorphic handoff'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：实现等同手off过程的关键模块
- en: The **Encode** step, is performed inside the **Rest API Endpoint** that exists
    in the server-side web application. The **Register** step is performed inside
    the **Route Handler** that exists in the client-side web application. The **Decode**
    step is performed prior to calling the client-side **Template Renderer**. The
    **Attach** Step is performed by implementing the **DOM Event Handlers** on the
    client side.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编码步骤是在服务器端Web应用程序中存在的Rest API端点内执行的。注册步骤是在客户端Web应用程序中存在的路由处理程序内执行的。解码步骤是在调用客户端模板渲染器之前执行的。附加步骤是通过在客户端实现DOM事件处理程序来执行的。
- en: Now that we have introduced each step in the ERDA strategy, let's explore each
    step in detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了ERDA策略中的每个步骤，让我们详细探讨每个步骤。
- en: The Encode step
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码步骤
- en: Our goal to regenerate the state on the client side begins by identifying the
    data object that represents the state we wish to retain in order to maintain state
    in a particular web page. To identify the object, we simply need to take a look
    at the server-side handler function that produced the rendered web page output.
    For example, in the products listing page, the slice of `Product` objects would
    be the data object that we would want to retain to the client side, so that the
    web page rendered on the client-side would render the same list of products.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在客户端重新生成状态，首先要识别代表我们希望保留的状态的数据对象，以便在特定网页中保持状态。要识别对象，我们只需要查看生成渲染的网页输出的服务器端处理程序函数。例如，在产品列表页面中，`Product`对象的片段将是我们希望保留到客户端的数据对象，以便客户端呈现的网页呈现相同的产品列表。
- en: We can expose the slice of the `Product` objects to the client side by implementing
    a Rest API Endpoint (depicted in *Figure 6.2*). The **Encode** step (depicted
    in *Figure 6.1*), consists of encoding the slice of the `Product` objects to a
    common data exchange format. For this chapter, we will encode objects using the
    **JSON** (short for, **JavaScript Object Notation**) format. The client-side web
    application can access the encoded object by making an XHR call to the Rest API
    endpoint.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现Rest API端点（在*图6.2*中描述）将`Product`对象的片段暴露给客户端。编码步骤（在*图6.1*中描述）包括将`Product`对象的片段编码为通用数据交换格式。对于本章，我们将使用JSON（JavaScript对象表示）格式对对象进行编码。客户端Web应用程序可以通过向Rest
    API端点发出XHR调用来访问编码对象。
- en: Now that the encoded state object is available, the rest of the steps to implement
    the isomorphic handoff procedure happen on the client side.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编码状态对象可用，实现等同手off过程的其余步骤发生在客户端。
- en: The Register step
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册步骤
- en: To fulfill the register step (depicted in *Figure 6.1*), we must first register
    a client-side route and its respective handler function (depicted in the Route
    Handler box in *Figure 6.2*). For example, for the Products page, we would register
    the `/products` route and its associated handler function, `ProductsHandler`.
    When a user clicks on the Products link from the navigation bar, the click event
    will be intercepted by the isokit router and the handler function, `ProductsHandler`,
    which is associated with handling the `/products` route, will be called. The route
    handler function plays the role of executing the last two steps of the isomorphic
    handoff process—decode and attach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成注册步骤（在*图6.1*中描述），我们必须首先注册客户端路由及其相应的处理程序函数（在*图6.2*中的路由处理程序框中描述）。例如，对于产品页面，我们将注册`/products`路由及其关联的处理程序函数`ProductsHandler`。当用户从导航栏点击产品链接时，点击事件将被isokit路由拦截，并且与处理`/products`路由的处理程序函数`ProductsHandler`相关联的处理程序函数将被调用。路由处理程序函数扮演着执行等同手off过程的最后两个步骤——解码和附加的角色。
- en: Keep in mind that if the user were to land first on the `/products` route by
    directly accessing the web page by entering the URL in the web browser, the server-side
    handler function will kick-in and the Products page will be rendered on the server
    side. This provides us the capability to render the web page instantly, providing
    a page load that is perceived to be fast to the user.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果用户首先通过在Web浏览器中输入URL直接访问网页而着陆在`/products`路由上，服务器端处理程序函数将启动，并且产品页面将在服务器端呈现。这使我们能够立即呈现网页，为用户提供被认为是快速的页面加载。
- en: The Decode step
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码步骤
- en: Within the route handler function, we initiate an XHR call to the Rest API endpoint,
    that will return the encoded data that represents the state we wish to maintain
    on the client side. Once the encoded data is obtained, we will perform the third
    step, **Decode** (depicted in *Figure 6.1*), of the isomorphic handoff procedure.
    In this step, we decode the encoded data back into an object instance. The object
    instance is then utilized to populate the corresponding field of the template
    data object that is passed to the Template Renderer (depicted in *Figure 6.2*),
    so that the web page can be successfully rendered on the client side, in the same
    manner as it was rendered on the server side.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由处理程序函数中，我们发起一个XHR调用到Rest API端点，该端点将返回编码数据，表示我们希望在客户端保持的状态。一旦获取到编码数据，我们将执行等同交接过程的第三步**解码**（在*图6.1*中描述）。在这一步中，我们将编码数据解码回对象实例。然后利用对象实例填充模板数据对象的相应字段，传递给模板渲染器（在*图6.2*中描述），以便网页可以在客户端成功渲染，与在服务器端渲染的方式相同。
- en: The Attach step
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加步骤
- en: The fourth and last step, Attach (depicted in *Figure 6.1*), is responsible
    for attaching event handlers (depicted in *Figure 6.2*) to DOM elements that exist
    in the rendered web page. For example, in the Products page, we would need to
    attach event handlers to all the Add To Cart buttons found on the web page. When
    an Add To Cart button is pressed, the respective product item will be added to
    the user's shopping cart.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步也是最后一步，附加（在*图6.1*中描述），负责将事件处理程序（在*图6.2*中描述）附加到渲染的网页中存在的DOM元素上。例如，在产品页面中，我们需要将事件处理程序附加到网页上找到的所有“添加到购物车”按钮上。当按下“添加到购物车”按钮时，相应的产品将被添加到用户的购物车中。
- en: Up to this point, we have laid out the groundwork needed to implement the isomorphic
    handoff procedure for a given web page. To solidify our understanding of isomorphic
    handoff, let's consider two specific examples where we implement all four steps
    of the procedure. First, we will implement the isomorphic handoff procedure in
    the product-related pages, which include the products listing page (`/products`)
    and the product detail page (`/product-detail/{productTitle}`). Second, we will
    implement the isomorphic handoff procedure for the shopping cart page. The second
    example will be more dynamic, since the user will have the capability to alter
    the state, because the user can add and remove items to the shopping cart as they
    wish. This capability allows the user to exert control on the current state of
    the shopping cart.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经铺设了实现给定网页的等同交接过程所需的基础工作。为了巩固我们对等同交接的理解，让我们考虑两个具体的例子，在这两个例子中我们实现了该过程的所有四个步骤。首先，我们将在产品相关页面实现等同交接过程，包括产品列表页面(`/products`)和产品详情页面(`/product-detail/{productTitle}`)。其次，我们将为购物车页面实现等同交接过程。第二个例子将更加动态，因为用户可以改变状态，用户可以随意添加和删除购物车中的商品。这种能力允许用户对购物车的当前状态施加控制。
- en: Implementing isomorphic handoff for the product-related pages
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品相关页面实现等同交接
- en: As noted earlier, the product-related pages consist of the products listing
    page and the product detail page. We will follow the ERDA strategy to implement
    the isomorphic handoff procedure for these pages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，与产品相关的页面包括产品列表页面和产品详情页面。我们将遵循ERDA策略，为这些页面实现等同交接过程。
- en: Implementing the sort interface for the product model
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品模型实现排序接口
- en: 'Before we get started, we will define a new type called `Products` (in the
    `shared/models/product.go` source file), which will be a slice of `Product` objects:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们将在`shared/models/product.go`源文件中定义一个名为`Products`的新类型，它将是`Product`对象的切片：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will have the `Products` type implement the `sort` interface by defining
    the following methods:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Products`类型实现`sort`接口，定义以下方法：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By examining the `Less` method, you will be able to see that we will sort the
    products displayed on the product listing page by the product's price in ascending
    order (lowest to highest).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`Less`方法，您将能够看到我们将按照产品价格升序（从低到高）对产品列表页面上显示的产品进行排序。
- en: At the first glance we may presume that the products obtained from the Redis
    database are already sorted in some predetermined order. However, if we want isomorphic
    handoff to succeed, we cannot operate in the realm of assumption; we must operate
    in the realm of fact. In order to do so, we need a predictable criteria for the
    sorting of products.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们可能会认为从Redis数据库获取的产品已经按照某种预定顺序排序。然而，如果我们希望等同交接成功，我们不能凭假设操作；我们必须凭事实操作。为了做到这一点，我们需要一个可预测的产品排序标准。
- en: This is why we perform the additional work of implementing the `sort` interface
    for the `Products` type, so that we have a predictable criteria by which the products
    are listed on the products listing page. It provides us a benchmark when verifying
    the success of isomorphic handoff, since we simply need to confirm that the products
    listing page rendered on the client side is identical to the products listing
    page rendered on the server side. It is indeed helpful, that we have a common,
    predictable criteria that the products are sorted by price in the ascending order.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们要为`Products`类型实现`sort`接口的额外工作，以便我们有一个可预测的标准，按照这个标准在产品列表页面上列出产品。这为我们提供了一个基准，用于验证等同交接的成功，因为我们只需要确认客户端渲染的产品列表页面与服务器端渲染的产品列表页面相同即可。确实很有帮助，我们有一个共同的、可预测的标准，产品按价格升序排序。
- en: 'We add the following line (shown in bold) in the `GetProducts` method in the
    `redis.go` source file to sort the products:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`redis.go`源文件的`GetProducts`方法中添加以下行（以粗体显示）以对产品进行排序：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implementing isomorphic handoff for the products listing page
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品列表页面实现等同交接
- en: 'First, we must implement the **Encode** step. To do this, we need to decide
    the data that must be persisted to the client side. We can easily identify the
    data that must be persisted to the client, by examining the server side handler
    function, `ProductsHandler`, responsible for rendering the products listing web
    page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须实现**编码**步骤。为此，我们需要决定必须持久化到客户端的数据。通过检查负责渲染产品列表网页的服务器端处理函数`ProductsHandler`，我们可以轻松识别必须持久化到客户端的数据：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The products listing page is responsible for displaying the list of products,
    therefore, the `products` variable (shown in bold), a slice of `Product` objects,
    must be persisted to the client side.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 产品列表页面负责显示产品列表，因此，必须将`products`变量（加粗显示）持久化到客户端，这是`Product`对象的切片。
- en: 'Now that we have identified the data that needs to be persisted to the client,
    to maintain state, we can create a Rest API Endpoint, `GetProductsEndpoint`, that
    is responsible for delivering the slice of products to the client, in the JSON-encoded
    form:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了需要持久化到客户端以维护状态的数据，我们可以创建一个Rest API端点`GetProductsEndpoint`，负责以JSON编码形式将产品切片传递给客户端：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our work to implement isomorphic handoff is complete on the server side, and
    now it's time to turn our attention to the client side.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端完成了实现同构交接的工作，现在是时候转向客户端了。
- en: 'To implement the **Register** step, we add the following line to register the
    `/products` route and its associated handler function, `ProductsHandler`, in the
    `registerRoutes` function found in the `client.go` source file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现**注册**步骤，我们在`client.go`源文件中的`registerRoutes`函数中添加以下行，以注册`/products`路由及其关联的处理函数`ProductsHandler`：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The **Decode** and **Attach** steps are performed within the `ProductsHandler`
    function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码**和**附加**步骤在`ProductsHandler`函数内执行：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we call the `FetchProducts` function a goroutine to fetch the list of
    products from the endpoint on the server side. The **Decode** step (shown in bold),
    is performed inside the `FetchProducts` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`FetchProducts`函数的goroutine来从服务器端的端点获取产品列表。**解码**步骤（加粗显示）在`FetchProducts`函数内执行：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After fetching the encoded data from the Rest API endpoint, we use a JSON decoder
    to decode the encoded data back into a slice of `Product` objects. We then send
    the result over the `productsChannel`, where it is received inside the `ProductsHandler` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从Rest API端点获取编码数据后，我们使用JSON解码器将编码数据解码回`Product`对象的切片。然后我们将结果发送到`productsChannel`，在`ProductsHandler`函数内接收。
- en: 'Now that we have the data object to populate the list of products on the products
    listing page, we can populate the `Products` field of the `templatedata.Products`
    struct. Recall that `templateData` is the data object that will be passed into
    the `Render` method of the `env.TemplateSet` object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于填充产品列表页面上产品列表的数据对象，我们可以填充`templatedata.Products`结构的`Products`字段。回想一下，`templateData`是将传递到`env.TemplateSet`对象的`Render`方法中的数据对象：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Up to this point, we have fulfilled the third step of the isomorphic handoff
    procedure, which means that we can effectively render the products listing page
    on the client side. However, we aren't done just yet, since we have to fulfill
    the last step of attaching DOM event handlers to the rendered web page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了同构交接过程的第三步，这意味着我们可以有效地在客户端上渲染产品列表页面。但是，我们还没有完成，因为我们必须完成最后一步，即将DOM事件处理程序附加到渲染的网页上。
- en: 'Inside the `ProductsHandler` function, there are two calls that are instrumental
    to performing the **Attach** step:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductsHandler`函数内，有两个调用对执行**附加**步骤至关重要：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we call the `InitializeProductsPage` function to add the event handlers
    necessary to enable user interactivity for the products listing page:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`InitializeProductsPage`函数添加必要的事件处理程序，以启用产品列表页面的用户交互：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We retrieve all the Add To Cart buttons that exist on the product listing page,
    by calling the `GetElementsByClassName` method on the `env.Document` object, and
    specifying the `"addToCartButton"` class name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`env.Document`对象上调用`GetElementsByClassName`方法，并指定`"addToCartButton"`类名，来检索产品列表页面上存在的所有加入购物车按钮。
- en: When an Add To Cart button is clicked, the `handleAddToCartButtonClickEvent`
    function will be called. We will cover this function when we implement the shopping
    cart feature.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击“加入购物车”按钮时，将调用`handleAddToCartButtonClickEvent`函数。在实现购物车功能时，我们将介绍这个函数。
- en: 'Let''s return to the `ProductsHandler` function. We will call the `RegisterLinks`
    method on the Isokit router object and specify the CSS query selector of `"#primaryContent
    a"`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`ProductsHandler`函数。我们将在Isokit路由器对象上调用`RegisterLinks`方法，并指定CSS查询选择器`"#primaryContent
    a"`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This ensures that when the web page is rendered on the client side, all click
    events for the product item links will be intercepted by the client-side router.
    This will allow us to render the product detail page on the client side itself,
    without having to perform a full page reload.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保在客户端渲染网页时，所有产品项链接的点击事件都将被客户端路由拦截。这将允许我们在客户端自身渲染产品详细页面，而无需执行完整的页面重新加载。
- en: 'Up to this point, we have  implemented the isomorphic handoff procedure for
    the products listing page. To render the products listing page on the client side,
    click on the Products link in the navigation bar. To render the products listing
    page on the server side, enter the following URL directly in the web browser:
    `http://localhost:8080/products`. *Figure 6.3* depicts the products listing page
    rendered on the client side:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为产品列表页面实现了同构交接过程。要在客户端渲染产品列表页面，请在导航栏中单击产品链接。要在服务器端渲染产品列表页面，请直接在Web浏览器中输入以下URL：`http://localhost:8080/products`。*图6.3*显示了在客户端上渲染的产品列表页面：
- en: '![](img/c7a8d2c3-eaeb-4b87-8b59-f24345b695ba.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7a8d2c3-eaeb-4b87-8b59-f24345b695ba.png)'
- en: 'Figure 6.3: The products listing page rendered on the client side'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：在客户端上渲染的产品列表页面
- en: You may also refresh the web page to force the page to be rendered on the server
    side. We can verify that the isomorphic handoff procedure was implemented properly
    by comparing the web page loaded on the client side with the web page that was
    loaded on the server side. Since both web pages are identical, we can determine
    that the isomorphic handoff procedure has been successfully implemented.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以刷新网页以强制在服务器端呈现页面。我们可以通过比较在客户端加载的网页和在服务器端加载的网页来验证等同手交接程序是否正确实现。由于两个网页都是相同的，我们可以确定等同手交接程序已成功实现。
- en: Implementing isomorphic handoff for the product detail page
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品详细页面实现等同手交接
- en: Having successfully implemented the isomorphic handoff procedure on the products
    listing page using the ERDA strategy, let's focus on implementing isomorphic handoff
    for the product detail page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 成功在产品列表页面上使用ERDA策略实现了等同手交接程序后，让我们专注于为产品详细页面实现等同手交接。
- en: 'To implement the **Encode** step, we first need to identify the data object
    that will represent the state we wish to persist to the client. We identify the
    data object by examining the `ProductDetailHandler` function found in the `handlers/productdetail.go`
    source file. This is the server-side handler function responsible for servicing
    the `/product-detail` route:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现**编码**步骤，我们首先需要确定表示我们希望保存到客户端的状态的数据对象。我们通过检查`handlers/productdetail.go`源文件中找到的`ProductDetailHandler`函数来识别数据对象。这是负责服务`/product-detail`路由的服务器端处理程序函数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The product object, a pointer to a `models.Product` struct, is obtained from
    the Redis datastore (shown in bold). This object contains the product data that
    will be displayed on the Product page; therefore, it is the object that we need
    to persist to the client side.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从Redis数据存储中获取产品对象（以粗体显示）。该对象包含将显示在产品页面上的产品数据；因此，这是我们需要保存到客户端的对象。
- en: 'The `GetProductDetailEndpoint` function, found in the `endpoints/productdetail.go`
    source file, is the Rest API endpoint responsible for providing the JSON encoded
    `Product` data to the client:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`endpoints/productdetail.go`源文件中的`GetProductDetailEndpoint`函数是负责向客户端提供JSON编码的“Product”数据的Rest
    API端点：'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inside the `GetProductDetailEndpoint` function, we obtain the product object
    from the Redis datastore and encode it as JSON formatted data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetProductDetailEndpoint`函数内部，我们从Redis数据存储中获取产品对象，并将其编码为JSON格式数据。
- en: Now that we have taken care of the **Encode** step, we can implement the next
    three steps on the client side.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了**编码**步骤，我们可以在客户端上实现接下来的三个步骤。
- en: 'To implement the **Register** step, we add the following line to register the
    `/product-detail` route and its associated handler function in the `client.go`
    source file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现**注册**步骤，我们在`client.go`源文件中添加以下行，以注册`/product-detail`路由及其关联的处理程序函数：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The **Decode** and **Attach** steps are carried out by the `ProductDetailHandler`
    function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码**和**附加**步骤由`ProductDetailHandler`函数执行：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `ProductDetailHandler` function, we call the `FetchProductDetail`
    function as a goroutine to obtain the product object. The **Decode** step (shown
    in bold) is implemented inside the `FetchProductDetail` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductDetailHandler`函数内部，我们调用`FetchProductDetail`函数作为一个goroutine来获取产品对象。**解码**步骤（以粗体显示）是在`FetchProductDetail`函数内部实现的：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We make an XHR call to the Rest API endpoint to obtain the encoded `Product`
    data. We use a JSON decoder to decode the encoded data back into a `Product` object.
    We send the `Product` object over the `productChannel`, where it is received back
    in the `ProductDetailHandler` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出XHR调用到Rest API端点，以获取编码的“Product”数据。我们使用JSON解码器将编码数据解码回“Product”对象。我们将“Product”对象发送到“productChannel”，在那里它会在“ProductDetailHandler”函数中接收到。
- en: 'Returning to the `ProductDetailHandler` function, we use the product data object
    to populate the product information on the product detail page. We do so by populating
    the Product field of the `templatedata.ProductDetail` object. Again, recall that
    the `templateData` variable is the data object that will be passed into the `Render`
    method of the `env.TemplateSet` object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ProductDetailHandler`函数，我们使用产品数据对象来填充产品详细页面上的产品信息。我们通过填充`templatedata.ProductDetail`对象的Product字段来实现这一点。再次回想一下，`templateData`变量是将传递到`env.TemplateSet`对象的`Render`方法中的数据对象：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Up to this point, we have fulfilled the third step of the isomorphic handoff
    procedure, which means that we can now render the product detail page on the client
    side. Now, it's time to complete the last step of the procedure, **Attach**, by
    attaching DOM event handlers to their respective UI elements on the rendered web
    page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了等同手交接程序的第三步，这意味着我们现在可以在客户端上呈现产品详细页面。现在，是时候完成程序的最后一步**附加**，通过将DOM事件处理程序附加到呈现的网页上的各自UI元素上。
- en: 'We call the `InitializeProductDetailPage` function to add the event handler
    necessary to enable user interactivity for the products listing page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`InitializeProductDetailPage`函数来添加必要的事件处理程序，以启用产品列表页面的用户交互：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to the `InitializeProductsPage` function, we retrieve all the Add To
    Cart buttons on the web page and specify the event handler function, `handleAddToCartButtonClickEvent`,
    that will be called when an Add To Cart button is clicked.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与“InitializeProductsPage”函数类似，我们检索网页上的所有“Add To Cart”按钮，并指定事件处理程序函数“handleAddToCartButtonClickEvent”，当单击“Add
    To Cart”按钮时将调用该函数。
- en: 'Up to this point, we have implemented the isomorphic handoff procedure for
    the product detail page. To render the product detail page on the client side,
    click on a product image found in the the products listing page. To render the
    product detail page on the server-side, enter the URL of a product in the web
    browser. For example, the URL to the product detail page for the swiss army knife
    is `http://localhost:8080/product-detail/swiss-army-knife`. *Figure 6.4* depicts
    the product detail page for the swiss army knife, which was rendered on the client
    side:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为产品详细页面实现了等同手递手的过程。要在客户端渲染产品详细页面，请点击产品列表页面中的产品图片。要在服务器端渲染产品详细页面，请在网页浏览器中输入产品的URL。例如，瑞士军刀的产品详细页面的URL是`http://localhost:8080/product-detail/swiss-army-knife`。*图6.4*描述了在客户端渲染的瑞士军刀产品详细页面：
- en: '![](img/64e2d5c3-b3f8-40bf-8b83-0e87a03a3e66.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64e2d5c3-b3f8-40bf-8b83-0e87a03a3e66.png)'
- en: 'Figure 6.4: The product detail page rendered on the client side'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：在客户端渲染的产品详细页面
- en: Again, we can verify that the isomorphic handoff procedure is functioning properly
    by confirming that the web page rendered on the client side is identical to the
    web page rendered on the server side. Since both web pages are identical, we can
    conclude that we have successfully implemented the isomorphic handoff procedure
    for the product detail page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过确认在客户端渲染的网页与在服务器端渲染的网页相同来验证等同手递手过程是否正常运行。由于两个网页是相同的，我们可以得出结论，我们已经成功实现了产品详细页面的等同手递手过程。
- en: Implementing isomorphic handoff for the shopping cart
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现购物车的等同手递手
- en: Now that we have implemented isomorphic handoff for the product-related web
    pages, it's time to start implementing IGWEB's shopping cart feature. We'll start
    by designing the Shopping Cart web page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为与产品相关的网页实现了等同手递手，是时候开始实现IGWEB的购物车功能了。我们将从设计购物车网页开始。
- en: Designing the shopping cart page
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计购物车页面
- en: 'The design of the Shopping Cart page, as depicted in the wireframe design in
    *Figure 6.5*, is very similar to the product listings page. Each product item
    will contain a thumbnail sized image of the product, the product price, the product
    name, and a brief description of the product, just like the product listings page.
    In addition to these fields, the shopping cart page will have a field to display
    the quantity, that is, the amount of items of a particular product that are in
    the shopping cart, and a Remove From Cart button, that when clicked on, will remove
    the product from the shopping cart:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车页面的设计，如*图6.5*中的线框设计所示，与产品列表页面非常相似。每个产品项目将包含产品的缩略图大小的图片，产品价格，产品名称和产品的简要描述，就像产品列表页面一样。除了这些字段，购物车页面还将有一个字段来显示数量，即购物车中特定产品的数量，以及一个“从购物车中移除”按钮，点击该按钮将从购物车中移除产品：
- en: '![](img/8142b3e2-4b7b-4c15-95b0-907ace76b234.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8142b3e2-4b7b-4c15-95b0-907ace76b234.png)'
- en: 'Figure 6.5: The wireframe design depicting the shopping cart page with products
    in the shopping cart'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：显示购物车中有产品的购物车页面的线框设计
- en: 'Keep in mind that the first wireframe design covers the scenario, when the
    shopping cart has been populated with items. We must also consider the design
    of the page when the shopping cart is empty. The shopping cart could either be
    empty on the user''s initial visit to the IGWEB website or when the user empties
    the shopping cart entirely. *Figure 6.6* is a wireframe design of the shopping
    cart page, depicting the scenario where the shopping cart is empty:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，第一个线框设计涵盖了购物车已经填充了物品的情况。我们还必须考虑当购物车为空时页面的设计。购物车可能在用户首次访问IGWEB网站时为空，或者当用户完全清空购物车时。*图6.6*是购物车页面的线框设计，描述了购物车为空的情况：
- en: '![](img/1e37fbad-adbc-4c02-99b5-dfb451524763.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e37fbad-adbc-4c02-99b5-dfb451524763.png)'
- en: 'Figure 6.6: The wireframe design depicting the shopping cart page when the
    shopping cart is empty'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：当购物车为空时，购物车页面的线框设计
- en: Now that we have the design of the shopping cart page locked down, it's time
    to implement the templates to realize the design.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了购物车页面的设计，是时候实现模板来实现设计了。
- en: Implementing the shopping cart templates
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现购物车模板
- en: 'We will use the shopping cart page template in order to render the shopping
    cart on the server side. Here are the contents of the shopping cart page template,
    as defined in the `shared/templates/shopping_cart_page.tmpl` source file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用购物车页面模板来在服务器端渲染购物车。以下是购物车页面模板的内容，定义在`shared/templates/shopping_cart_page.tmpl`源文件中：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you may have noticed, the shopping cart page template calls a `shopping_cart_content` subtemplate, which
    is responsible for rendering the shopping cart itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，购物车页面模板调用了一个`shopping_cart_content`子模板，负责渲染购物车本身。
- en: 'Here are the contents of the shopping cart content template, as defined in
    the `shared/templates/shopping_cart_content.tmpl` source file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是购物车内容模板的内容，定义在`shared/templates/shopping_cart_content.tmpl`源文件中：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `if` action, we check to see whether there are any products to display
    in the shopping cart. If there are, we render each shopping cart item, using the
    `range` action. We render the name of the template, its thumbnail preview, and
    its description, along with its quantity. Finally, we render a button to remove
    the product from the shopping cart. Notice that we have embedded a data attribute
    called `data-sku` to include the product's unique `SKU` code along with the button
    element. This value come in handy later, when we make the XHR call to the Rest
    API endpoint responsible for removing a shopping cart item by clicking on this
    button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if` 操作，我们检查是否有任何商品要在购物车中显示。如果有，我们使用 `range` 操作来渲染每个购物车商品。我们渲染模板的名称、缩略图预览和描述，以及数量。最后，我们渲染一个按钮，以从购物车中移除产品。请注意，我们嵌入了一个名为
    `data-sku` 的数据属性，将产品的唯一 `SKU` 代码与按钮元素一起包含在内。稍后，当我们通过单击此按钮调用 Rest API 端点来移除购物车商品时，这个值会派上用场。
- en: If there are no items to display in the shopping cart, the flow of control reaches
    the `else` action. In this scenario, we will display the message that the shopping
    cart is empty.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购物车中没有要显示的商品，控制流将到达 `else` 操作。在这种情况下，我们将显示购物车为空的消息。
- en: Finally, we will use the end template action to signal the end of the `if-else`
    conditional blocks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用结束模板操作来表示 `if-else` 条件块的结束。
- en: The template data object
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板数据对象
- en: 'The template data object that will be passed to the template renderer will
    be a `templatedata.ShoppingCart` struct (defined in the `shared/templatedata/shoppingcart.go`
    source file):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给模板渲染器的模板数据对象将是一个 `templatedata.ShoppingCart` 结构体（在 `shared/templatedata/shoppingcart.go`
    源文件中定义）：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `PageTitle` field will be used to display the web page title and the `Products`
    field, a slice of `Product` objects, will be used to display the products that
    are currently in the shopping cart.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTitle` 字段将用于显示网页标题，`Products` 字段是 `Product` 对象的切片，将用于显示当前在购物车中的产品。'
- en: Now that we have the templates in place, let's take a look at modeling the shopping
    cart.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模板，让我们来看看如何对购物车进行建模。
- en: Modeling the shopping cart
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对购物车进行建模
- en: 'The `ShoppingCartItem` struct, defined in the `shared/models/shoppingcart.go`
    source file, represents an item in the shopping cart:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCartItem` 结构体在 `shared/models/shoppingcart.go` 源文件中定义，表示购物车中的商品：'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ProductSKU` field holds the `SKU` code of the product (the unique code
    used to distinguish a product) and the `Quantity` field holds the quantity of
    that particular product the user wishes to purchase. Each time the user hits the
    Add To Cart button on the products listing or product detail page, the quantity
    value for that particular product will be incremented in the shopping cart.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductSKU` 字段保存产品的 `SKU` 代码（用于区分产品的唯一代码），`Quantity` 字段保存用户希望购买的特定产品的数量。每当用户在产品列表或产品详细页面上点击“添加到购物车”按钮时，该特定产品的数量值将在购物车中递增。'
- en: 'The `ShoppingCart` struct, also defined in the `shoppingcart.go` source file,
    represents the shopping cart:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 结构体，也在 `shoppingcart.go` 源文件中定义，表示购物车：'
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Items` field is a map of items having a key of the `string` type (which
    will be the product `SKU` code), and the value will be a pointer to a `ShoppingCartItem`
    struct.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Items` 字段是一个项目的映射，其键为 `string` 类型（将是产品 `SKU` 代码），值将是指向 `ShoppingCartItem`
    结构体的指针。'
- en: 'The `NewShoppingCart` function is a constructor function to create a new instance
    of `ShoppingCart`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewShoppingCart` 函数是一个构造函数，用于创建 `ShoppingCart` 的新实例：'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ItemTotal` method of the `ShoppingCart` type is responsible for returning
    the number of items that are currently in the shopping cart:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `ItemTotal` 方法负责返回当前购物车中的商品数量：'
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `IsEmpty` method of the `ShoppingCart` type is responsible for telling
    us if the shopping cart is empty or not:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `IsEmpty` 方法负责告诉我们购物车是否为空：'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `AddItem` method of the `ShoppingCart` type is responsible for adding an
    item to the shopping cart:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `AddItem` 方法负责向购物车中添加商品：'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a particular product item already exists in the shopping cart, the `Quantity`
    field will be incremented by one, upon each new request to add the product item.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定产品商品已经存在于购物车中，每次新请求添加产品商品时，`Quantity` 字段将递增一次。
- en: 'Similarly, the `RemoveItem` method of the `ShoppingCart` type is responsible
    for removing all items of a specific product type from the shopping cart:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`ShoppingCart` 类型的 `RemoveItem` 方法负责从购物车中删除特定产品类型的所有商品：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `UpdateItemQuantity` method of the `ShoppingCart` type is responsible for
    updating the quantity of a specific product in the shopping cart:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `UpdateItemQuantity` 方法负责更新购物车中特定产品的数量：'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Shopping cart routes
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车路由
- en: By implementing the `ShoppingCart` type, we now have the business logic in place,
    to drive the shopping cart functionality. Now it's time to register the server-side
    routes that are needed to implement the shopping cart.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `ShoppingCart` 类型，我们现在已经有了业务逻辑，可以驱动购物车功能。现在是时候注册服务器端路由，以实现购物车。
- en: 'We register the `/shopping-cart` route along with its associated handler function,
    `ShoppingCartHandler`, inside the `registerRoutes` function, which is found in
    the `igweb.go` source file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `igweb.go` 源文件中的 `registerRoutes` 函数中注册了 `/shopping-cart` 路由及其关联的处理程序函数
    `ShoppingCartHandler`：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The route handler function, `ShoppingCartHandler`, is responsible for generating
    the web page for the shopping cart page on the server side.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序函数 `ShoppingCartHandler` 负责在服务器端生成购物车页面的网页。
- en: 'We also register the following Rest API endpoints:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注册了以下 Rest API 端点：
- en: Fetching a list of items (`/restapi/get-cart-items`)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取商品列表（`/restapi/get-cart-items`）
- en: Adding an item (`/restapi/add-item-to-cart`)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加商品（`/restapi/add-item-to-cart`）
- en: Removing an item (`/restapi/remove-item-from-cart`)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除商品（`/restapi/remove-item-from-cart`）
- en: Fetching a list of items
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取商品列表
- en: 'For fetching a list of items in the shopping cart, we will register the `/restapi/get-cart-items`
    endpoint:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取购物车中物品列表的，我们将注册`/restapi/get-cart-items`端点：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This endpoint will be handled by the `GetShoppingCartItemsEndpoint` handler
    function. This endpoint is responsible for encoding the shopping cart as JSON
    encoded data and providing it to the client-side application. Note that we use
    the HTTP `GET` method to call this endpoint.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点将由`GetShoppingCartItemsEndpoint`处理函数处理。这个端点负责将购物车编码为JSON编码数据，并提供给客户端应用程序。请注意，我们使用HTTP的`GET`方法来调用这个端点。
- en: Adding an item
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加物品
- en: 'For adding an item to the shopping cart, we will register the `/restapi/add-item-to-cart`
    endpoint:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将物品添加到购物车的，我们将注册`/restapi/add-item-to-cart`端点：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This route will be handled by the `AddItemToShoppingCartEndpoint` handler function.
    Note that since we are performing a mutating operation on the web server (adding
    a shopping cart item), we use the HTTP `PUT` method when calling this endpoint.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由将由`AddItemToShoppingCartEndpoint`处理函数处理。请注意，由于我们在web服务器上执行了一个改变操作（添加购物车物品），所以在调用这个端点时，我们使用HTTP的`PUT`方法。
- en: Removing an item
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除物品
- en: 'For removing an item of a specific product type, and all quantities of it,
    from the shopping cart, we will register the `/restapi/remove-item-from-cart`
    endpoint:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从购物车中移除特定产品类型的物品及其所有数量的，我们将注册`/restapi/remove-item-from-cart`端点：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This endpoint will be handled by the `RemoveItemFromShoppingCartEndpoint` handler
    function. Again, note that we use the HTTP `DELETE` method when calling this endpoint since
    we are performing a mutating operation on the web server (removing a shopping
    cart item).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点将由`RemoveItemFromShoppingCartEndpoint`处理函数处理。再次请注意，由于我们在web服务器上执行了一个改变操作（移除购物车物品），所以在调用这个端点时，我们使用HTTP的`DELETE`方法。
- en: The session store
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话存储
- en: Unlike the product records, which are stored in the Redis database, the items
    a user chooses to place in their shopping cart is transitory, and it's customized
    for individual use. This being the case, it makes much more sense to store the
    state of the shopping cart in a session, rather than in the database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与产品记录存储在Redis数据库中不同，用户选择放入购物车的物品是瞬时的，并且是针对个人定制的。在这种情况下，将购物车的状态存储在会话中比存储在数据库中更有意义。
- en: We will use the Gorilla `sessions` package to create sessions and store data
    to the sessions. We will utilize the `session.NewFileSystemStore` type to save
    the session data to the server's file system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gorilla的`sessions`包来创建会话并将数据存储到会话中。我们将利用`session.NewFileSystemStore`类型将会话数据保存到服务器的文件系统中。
- en: 'First, we will add a new field (shown in bold) to the `common.Env` struct (defined
    in the `common/common.go` source file), which will hold the `FileSystemStore`
    instance so that it is accessible throughout the server-side web application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`common/common.go`源文件中的`common.Env`结构体中添加一个新字段（以粗体显示），该字段将保存`FileSystemStore`实例，以便在整个服务器端web应用程序中访问：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside the `main` function defined in the `igweb.go` source file, we will make
    a call to the `initializeSessionstore` function and pass in the `env` object:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`igweb.go`源文件中定义的`main`函数内，我们将调用`initializeSessionstore`函数并传入`env`对象：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `initializeSessionstore` function is responsible for creating the session
    store on the server side:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeSessionstore`函数负责在服务器端创建会话存储：'
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `if` conditional, we first check to see whether the designated path where
    the session data will be stored, `/tmp/igweb-sessions`, exists. If the path does
    not exist, we create the folder by calling the `Mkdir` function from the `os`
    package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`条件中，我们首先检查会话数据将被存储的指定路径`/tmp/igweb-sessions`是否存在。如果路径不存在，我们将调用`os`包中的`Mkdir`函数来创建文件夹。
- en: We will initialize a new file system session store by calling the `NewFileSystemStore`
    function in the `sessions` package, passing in the path where sessions will be
    saved and the authentication key for the session. We will populate the `Store`
    property of the `env` object with the newly created `FileSystemStore` instance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`sessions`包中的`NewFileSystemStore`函数来初始化一个新的文件系统会话存储，传入会话将被保存的路径和会话的身份验证密钥。我们将用新创建的`FileSystemStore`实例填充`env`对象的`Store`属性。
- en: Now that we have the session store in place, let's implement the server-side
    `ShoppingCartHandler` function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了会话存储，让我们实现服务器端的`ShoppingCartHandler`函数。
- en: The server-side shopping cart handler function
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端购物车处理函数
- en: 'The `ShoppingCartHandler` function, defined in `handlers/shoppingcart.go`,
    is responsible for servicing the `/shopping-cart` route:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handlers/shoppingcart.go`中定义的`ShoppingCartHandler`函数负责为`/shopping-cart`路由提供服务。
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main purpose of the server-side shopping cart handler function is to produce
    the output for the shopping cart web page.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端购物车处理函数的主要目的是为购物车网页生成输出。
- en: Recall that the handler functions for the product-related pages, tapped into
    the Redis datastore to retrieve the list of products. The shopping cart handler,
    on the other hand, taps into the server-side session to get the list of items
    that are in the shopping cart.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，与产品相关页面的处理函数是从Redis数据存储中检索产品列表的。另一方面，购物车处理函数是从服务器端会话中获取购物车中物品列表的。
- en: 'We will declare the variables for the `templateData` object and the shopping
    cart:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明`templateData`对象和购物车的变量：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve define and initialize the `igwSession` variable of the `gorilla.SessionStore` type,
    which will hold our server-side session:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义并初始化了`gorilla.SessionStore`类型的`igwSession`变量，它将保存我们的服务器端会话：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Recall that we can access the `FileSystemStore` object by accessing the `Store`
    property of the `env` object. We call the `Get` method of the session store object
    passing in the pointer to `http.Request`, `r`, and the name of the session, `"igweb-session"`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们可以通过访问`env`对象的`Store`属性来访问`FileSystemStore`对象。我们调用会话存储对象的`Get`方法，传入`http.Request`的指针`r`和会话的名称`"igweb-session"`。
- en: If the session does not exist, a new session named `"igweb-session"` will automatically
    be created for us.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果会话不存在，将自动为我们创建一个名为`"igweb-session"`的新会话。
- en: To access values in the session, we use the `Values` property of the `igwSession`
    object, which is a map of keys to values. The keys are strings, and the values
    are of type empty interface, `interface{}`, so that they can hold any type (since
    all types in Go implement the empty interface).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问会话中的值，我们使用`igwSession`对象的`Values`属性，它是一个键值对的映射。键是字符串，值是空接口`interface{}`类型，因此它们可以保存任何类型（因为Go中的所有类型都实现了空接口）。
- en: 'In the `if` conditional block, we check to see whether a value for the `"shoppingCart"` session
    key exists in the `Values` map:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`条件块中，我们检查`Values`映射中是否存在`"shoppingCart"`会话键的值：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The JSON-encoded value for the shopping cart object is accessed using the `"shoppingCart"`
    key. If the shopping cart exists in the session, we decode the JSON object using
    the `Decode` method of the JSON decoder object. If the JSON object is successfully
    decoded, the decoded object is stored in the `cart` variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"shoppingCart"`键访问购物车对象的JSON编码值。如果会话中存在购物车，我们使用JSON解码器对象的`Decode`方法解码JSON对象。如果成功解码JSON对象，则将解码后的对象存储在`cart`变量中。
- en: 'Now that we have the shopping cart object from the session, we need to get
    the product information for each item in the shopping cart. We do so by calling
    the `GetProductsInShoppingCart` method of the the datastore object and supplying
    the `cart` variable as an input argument to the method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从会话中有了购物车对象，我们需要获取购物车中每个商品的产品信息。我们通过调用数据存储对象的`GetProductsInShoppingCart`方法，并将`cart`变量作为输入参数提供给该方法来实现。
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This function will return the slice of products that are to be displayed on
    the shopping cart page. Notice that we populate the `Products` field of the `templatedata.ShoppingCart`
    object with the slice of products obtained from the datastore:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将返回要在购物车页面上显示的产品切片。请注意，我们使用从数据存储获取的产品切片来填充`templatedata.ShoppingCart`对象的`Products`字段：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since we will utilize this slice of products to render the server-side shopping
    cart template page, the slice of products returned from the `GetProductsInShoppingCart`
    method is the state data that we need to persist to the client-side when implementing
    isomorphic handoff.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将利用这个产品切片来呈现服务器端的购物车模板页面，从`GetProductsInShoppingCart`方法返回的产品切片是我们在实现同构交接时需要持久保存到客户端的状态数据。
- en: 'If the `"shoppingCart"` key did not exist in the session, the flow of control
    reaches the `else` block:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果会话中不存在`"shoppingCart"`键，则控制流会进入`else`块：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this situation, we set the `Products` field of the `templatedata.ShoppingCart`
    struct to `nil`, to indicate that there are no products in the shopping cart since
    the shopping cart does not exist in the session.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`templatedata.ShoppingCart`结构体的`Products`字段设置为`nil`，以表示购物车中没有产品，因为购物车在会话中不存在。
- en: 'Finally, we render the shopping cart page by calling the `Render` method on
    the template set object, passing in the name of the template we wish to render
    (the `shopping_cart_page` template) along with the render parameters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在模板集对象上调用`Render`方法，传入我们希望呈现的模板的名称（`shopping_cart_page`模板）以及呈现参数来呈现购物车页面：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that we have set the `RenderParams` object's `Writer` property to `http.ResponseWriter`,
    `w`, and we have set the `Data` property to the `templateData` variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已将`RenderParams`对象的`Writer`属性设置为`http.ResponseWriter`，`w`，并将`Data`属性设置为`templateData`变量。
- en: 'Let''s take a look at the `GetProductsInShoppingCart` method defined in the
    Redis datastore (found in the `common/datastore/redis.go` source file):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在Redis数据存储中定义的`GetProductsInShoppingCart`方法（在`common/datastore/redis.go`源文件中找到）：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The job of this method is to return a slice of `Product` objects for all the
    products that exist within a shopping cart. The `ShoppingCart` struct simply keeps
    track of a product's type (through its `SKU` code) and the `Quantity` of that
    product in the shopping cart.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的作用是返回购物车中所有产品的`Product`对象切片。`ShoppingCart`结构体简单地跟踪产品的类型（通过其`SKU`代码）以及购物车中该产品的`Quantity`。
- en: We declare a `result` variable, which is a slice of the `Product` objects. We
    loop through each shopping cart item, and we retrieve the `Product` object from
    the `productsMap`, providing the product's `SKU` code as the key. We populate
    the `Quantity` field of the `Product` object and append the `Product` object to
    the `result` slice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个`result`变量，它是`Product`对象的切片。我们循环遍历每个购物车项目，并从`productsMap`中检索`Product`对象，提供产品的`SKU`代码作为键。我们填充`Product`对象的`Quantity`字段，并将`Product`对象追加到`result`切片中。
- en: We call the `Sort` method from the sort package passing in the `result` slice.
    Since we have implemented the sort interface for the `Products` type, the `Product`
    objects in the `result` slice will be sorted by price in the ascending order.
    Finally, we return the `result` slice.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用sort包中的`Sort`方法，传入`result`切片。由于我们已经为`Products`类型实现了排序接口，`result`切片中的`Product`对象将按价格升序排序。最后，我们返回`result`切片。
- en: Shopping cart endpoints
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车端点
- en: At this point, while we are finishing up the server-side functionality to implement
    the shopping cart feature, we are also ready to start implementing the isomorphic
    handoff procedure, following the ERDA strategy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，当我们完成服务器端功能以实现购物车功能时，我们也准备开始实现同构交接程序，遵循ERDA策略。
- en: The endpoint to get items in the shopping cart
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取购物车中商品的端点
- en: Let's examine the shopping cart's Rest API endpoints, which help service actions
    that the client-side web application is dependent on. Let's start with the endpoint
    function, `GetShoppingCartItemsEndpoint`, which is responsible for getting the
    items in the shopping cart. The **Encode** step, of the isomorphic handoff procedure
    is performed in this endpoint function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看购物车的Rest API端点，这些端点帮助服务于客户端Web应用程序所依赖的操作。让我们从负责获取购物车中商品的端点函数`GetShoppingCartItemsEndpoint`开始，这个端点函数执行了等同交接过程中的**编码**步骤。
- en: 'Here''s the source listing of the `GetShoppingCartItemsEndpoint` function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`GetShoppingCartItemsEndpoint`函数的源代码列表：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this function, we fetch the shopping cart from the session. If we are able
    to successfully fetch the shopping cart from the session, we use a JSON encoder
    to encode the `ShoppingCart` object and write it using `http.ResponseWriter`,
    `w`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们从会话中获取购物车。如果我们能够成功地从会话中获取购物车，我们就使用JSON编码器对`ShoppingCart`对象进行编码，并使用`http.ResponseWriter`
    `w`进行写入。
- en: If the shopping cart does not exist in the session, then we simply JSON encode
    the value of `nil` (which is equivalent to a JavaScript `null` on the client side)
    and write it out in the response, using `http.ResponseWriter`, `w`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果会话中不存在购物车，我们就简单地对`nil`的值进行JSON编码（在客户端等同于JavaScript的`null`），并使用`http.ResponseWriter`
    `w`在响应中写出。
- en: With this code in place, we have fulfilled the Encode step in the isomorphic
    handoff procedure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们已经完成了等同交接过程中的编码步骤。
- en: The endpoint to add items to the shopping cart
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加商品到购物车的端点
- en: 'We declared a `m` variable (shown in bold), of the `map[string]string` type,
    in `AddItemToShoppingCartEndpoint`, which is the endpoint function that is responsible
    for adding a new item to the shopping cart:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AddItemToShoppingCartEndpoint`中声明了一个`m`变量（加粗显示），类型为`map[string]string`，这是负责向购物车添加新商品的端点函数：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We use a JSON decoder to decode the request body, which will contain a JSON
    encoded map sent from the client. The map will contain the `SKU` value of the
    product to add to the shopping cart, given the `"productSKU"` key.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用JSON解码器来解码请求体，其中包含从客户端发送的JSON编码的映射。该映射将包含要添加到购物车的产品的`SKU`值，给定`"productSKU"`键。
- en: 'We will check to see whether the shopping cart exists in the session. If it
    does, we will decode the shopping cart JSON data back into a `ShoppingCart` object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查会话中是否存在购物车。如果存在，我们将把购物车的JSON数据解码回`ShoppingCart`对象：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the shopping cart doesn''t exist, flow of control reaches the `else` block,
    and we will create a new shopping cart:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购物车不存在，控制流将到达`else`块，我们将创建一个新的购物车：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will then make a call to the `AddItem` method of the `ShoppingCart` object
    to add the product item:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将调用`ShoppingCart`对象的`AddItem`方法来添加产品项：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To add an item to our shopping cart, we simply have to provide the product's
    `SKU` value, which we can obtain from the `m` map variable by accessing the value
    that exists in the map for the `productSKU` key.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要向购物车添加商品，我们只需提供产品的`SKU`值，这个值可以从`m`映射变量中获取，通过访问`productSKU`键的映射值。
- en: 'We will encode the cart object into its JSON representation and save it into
    the session, with the session key `"shoppingCart"`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把购物车对象编码为其JSON表示形式，并保存到会话中，会话键为“shoppingCart”：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We then write back the response, `"OK"`, to the client, to indicate that the
    operation to add a new item to the cart was performed successfully.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将响应“OK”写回客户端，以表明成功执行了向购物车添加新商品的操作。
- en: The endpoint to remove items from the shopping cart
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从购物车中移除商品的端点
- en: 'Here''s the source listing of `RemoveItemFromShoppingCartEndpoint`, the endpoint
    that is responsible for removing all items of a specific product from the shopping
    cart:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`RemoveItemFromShoppingCartEndpoint`的源代码列表，这个端点负责从购物车中移除特定产品的所有商品：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember that we can have multiple quantities for a given product. In the current
    shopping cart implementation, if the user clicks on the Remove From Cart button,
    the given product (and all quantities of it) are removed from the shopping cart.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于给定的产品，我们可以有多个数量。在当前的购物车实现中，如果用户点击“从购物车中移除”按钮，那么该产品（以及所有数量）将从购物车中移除。
- en: We start out by fetching the JSON encoded shopping cart data from the session.
    If it exists, we decode the JSON object into a new `ShoppingCart` object. If the
    shopping cart does not exist in the session, we simply create a new shopping cart.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从会话中获取JSON编码的购物车数据。如果存在，我们将JSON对象解码为一个新的`ShoppingCart`对象。如果会话中不存在购物车，我们就简单地创建一个新的购物车。
- en: We range through the items found in the shopping cart, and if we are able to
    find a product in the cart containing the same product `SKU` code supplied in
    the `m` map variable that was obtained from the client-side web application, we
    will remove the element from the shopping cart object's `Items` map by calling
    the built-in `delete` function (shown in bold). Finally, we will write out a JSON
    encoded response to the client that the operation was successfully completed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历购物车中的商品，如果我们能够在购物车中找到包含与从客户端Web应用程序获取的`m`映射变量中提供的相同产品`SKU`代码的产品，我们将通过调用内置的`delete`函数（加粗显示）从购物车对象的`Items`映射中删除该元素。最后，我们将向客户端写出一个JSON编码的响应，表示操作已成功完成。
- en: Now that we have our server-side endpoints in place, it's time to take a look
    at the functionality needed on the client side to implement the final pieces of
    the shopping cart feature.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在服务器端设置了端点，是时候看看客户端需要实现购物车功能的最后部分了。
- en: Implementing the shopping cart functionality on the client side
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在客户端实现购物车功能
- en: 'To fulfill the **Register** step of the ERDA strategy, we will register the
    `/shopping-cart`  route and its associated handler function, `ShoppingCartHandler`,
    inside the `registerRoutes` function found in the `client/client.go` source file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成ERDA策略的**注册**步骤，我们将在`client/client.go`源文件中的`registerRoutes`函数中注册`/shopping-cart`路由及其关联的处理函数`ShoppingCartHandler`：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Remember that this route will kick-in when a user access the shopping cart by
    clicking on the shopping cart icon in the navigation bar. Upon clicking the shopping
    cart icon, the `ShoppingCartHandler` function will be called.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当用户点击导航栏中的购物车图标访问购物车时，将会触发此路由。点击购物车图标后，将调用`ShoppingCartHandler`函数。
- en: 'Let''s take a look at the `ShoppingCartHandler` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`ShoppingCartHandler`函数：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The main purpose of this function is to call the `renderShoppingCartItems` function
    to render the shopping cart on the client side. We have consolidated the logic
    to render the shopping cart and its contents in the `renderShoppingCartItems`
    function so that the shopping cart page can be re-rendered as the user removes
    items from the shopping cart.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的主要目的是调用`renderShoppingCartItems`函数在客户端上渲染购物车。我们已经将渲染购物车及其内容的逻辑整合到`renderShoppingCartItems`函数中，以便在用户从购物车中移除商品时重新渲染购物车页面。
- en: Rendering the shopping cart
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染购物车
- en: 'The `renderShoppingCartItems` function is responsible for conducting the last
    two steps of the ERDA strategy, the **Decode** and **Attach** steps. Here''s the
    source listing of the `renderShoppingCartItems` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderShoppingCartItems`函数负责执行ERDA策略的最后两个步骤，即**解码**和**附加**步骤。以下是`renderShoppingCartItems`函数的源代码清单：'
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this function, we create a new channel called `productsChannel`, which is
    a channel that we'll use to send and receive a slice of products over. We call
    the `fetchProductsInShoppingCart` function as a goroutine and provide `productsChannel`
    as an input argument to the function. This function is responsible for fetching
    the product items in the shopping cart from the server by performing an XHR call.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们创建了一个名为`productsChannel`的新通道，这是一个我们将用来发送和接收产品切片的通道。我们调用`fetchProductsInShoppingCart`函数作为一个goroutine，并将`productsChannel`作为函数的输入参数。该函数负责通过执行XHR调用从服务器获取购物车中的产品项目。
- en: 'Here''s the source listing for the `fetchProductsInShoppingCart` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`fetchProductsInShoppingCart`函数的源代码清单：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this function, we simply make an XHR call to the Rest API endpoint, `/restapi/get-cart-items`,
    which is responsible for returning the JSON-encoded data that represents the slice
    of products. We use a JSON decoder to decode the encoded slice of products into
    the `products` variable.  Finally, we send the `products` variable over `productsChannel`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们只是对Rest API端点`/restapi/get-cart-items`进行XHR调用，该端点负责返回表示产品切片的JSON编码数据。我们使用JSON解码器将编码的产品切片解码到`products`变量中。最后，我们通过`productsChannel`发送`products`变量。
- en: 'Let''s return to the `renderShoppingCartItems` function and receive the slice
    of products from the `productsChannel`, and then, we will set the `Products` property
    of the `templateData` object with the received products:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`renderShoppingCartItems`函数，并从`productsChannel`接收产品切片，然后我们将使用接收到的产品设置`templateData`对象的`Products`属性：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will then render the shopping cart template on the client side:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将在客户端上渲染购物车模板：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this point, we have fulfilled the **Decode** step of the ERDA strategy.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了ERDA策略的**解码**步骤。
- en: To fulfill the **Attach** step of the ERDA strategy, we will make a call to
    the `InitializeShoppingCartEventHandlers` function to attach any needed event
    listeners to the shopping cart web page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成ERDA策略的**附加**步骤，我们将调用`InitializeShoppingCartEventHandlers`函数，以便将任何所需的事件监听器附加到购物车网页上。
- en: 'Here''s the source listing of the `InitializeShoppingCartEventHandlers` function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`InitializeShoppingCartEventHandlers`函数的源代码清单：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This function is responsible for attaching a click event on all the Remove From
    Cart buttons that are found in each product container listed on the shopping cart
    web page. The event handler function that is called when the Remove From Cart
    button is clicked, is the `handleRemoveFromCartButtonClickEvent` function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责在购物车网页上的每个产品容器中找到的所有“从购物车中移除”按钮上附加点击事件。当点击“从购物车中移除”按钮时，调用的事件处理函数是`handleRemoveFromCartButtonClickEvent`函数。
- en: We have now fulfilled, the fourth and last step of the ERDA strategy, by attaching
    event listeners to the Remove From Cart buttons on the shopping cart web page.
    The implementation of isomorphic handoff for the shopping cart feature is complete.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在购物车网页上的“从购物车中移除”按钮上附加事件监听器，我们已经完成了ERDA策略的第四步，也是最后一步。购物车功能的同构交接实现已经完成。
- en: Removing an item from the shopping cart
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从购物车中移除商品
- en: 'Let''s take a look at the `handleRemoveFromCartButtonClickEvent` function,
    which gets called when the Remove From Cart button is clicked:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`handleRemoveFromCartButtonClickEvent`函数，当点击“从购物车中移除”按钮时会调用该函数：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this function, we obtain the product `SKU` code from the event target element's
    `data-sku` attribute. We then call the `removeFromCart` function as a goroutine,
    passing in the `env` object and `productSKU`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们从事件目标元素的`data-sku`属性中获取产品的`SKU`代码。然后我们调用`removeFromCart`函数作为一个goroutine，传入`env`对象和`productSKU`。
- en: 'Here is the source listing of the `removeFromCart` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`removeFromCart`函数的源代码清单：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We create a new map, `m`, in the `removeFromCart` function, which is used to
    house `productSKU`. We can access the product's `SKU` value from the  `m` map by
    providing the `"productSKU"` key. We have intended to send this map to the web
    server through the request body. The reason that we have chosen the `map` type,
    as opposed to simply sending the product's `SKU` string value, is that we want
    to make our solution extensible. In the future, if there is any additional information
    that should be sent to the server, we can include that value as part of an additional
    key-value pair in the map.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`removeFromCart`函数中，我们创建一个新地图`m`，用于存储`productSKU`。我们可以通过提供`"productSKU"`键从`m`地图中访问产品的`SKU`值。我们打算通过请求主体将此地图发送到Web服务器。我们选择`map`类型的原因是，我们希望使我们的解决方案具有可扩展性。将来，如果有任何其他信息应发送到服务器，我们可以将该值作为地图中的附加键值对的一部分包含进来。
- en: We encode the map into its JSON representation and make an XHR call to the web
    server, sending the map JSON data. Finally, we make a call to the `renderShoppingCartItems`
    function to render the shopping cart items. Remember that by calling this function,
    we will be performing an XHR call to get the latest products in the shopping cart
    (which represents the current state of the shopping cart). This ensures that we
    will have the most up-to-date state of the shopping cart, since again, we are
    using the server-side session (where the shopping cart state is stored) as our
    single source of truth.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将地图编码为其JSON表示，并对Web服务器进行XHR调用，发送地图JSON数据。最后，我们调用`renderShoppingCartItems`函数来渲染购物车商品。请记住，通过调用此函数，我们将执行XHR调用以获取购物车中最新的产品（代表购物车的当前状态）。这确保了我们将拥有购物车的最新状态，因为我们再次使用服务器端会话（购物车状态存储在其中）作为我们的唯一真相来源。
- en: Adding an item to the shopping cart
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将商品添加到购物车
- en: 'The functionality for the Add To Cart button is implemented in a similar manner.
    Recall that on the product-related pages, if any Add To Cart button is clicked,
    the `handleAddToCarButton` function is called. Here is the source listing of the
    function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: “添加到购物车”按钮的功能以类似的方式实现。请记住，在与产品相关的页面上，如果单击任何“添加到购物车”按钮，将调用`handleAddToCarButton`函数。以下是该函数的源代码列表：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In a manner similar to the `handleRemoveFromCartButtonClickEvent` function,
    inside the `handleAddToCart` function, we obtain the product's `SKU` code from
    the event target element by getting the data attribute with the `“data-sku”` key.
    We then call the `addToCart` function as a goroutine and supply `productSKU` as
    an input argument to the function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与`handleRemoveFromCartButtonClickEvent`函数类似，在`handleAddToCart`函数内，我们通过获取带有`“data-sku”`键的数据属性，从事件目标元素中获取产品的`SKU`代码。然后我们调用`addToCart`函数作为一个goroutine，并将`productSKU`作为输入参数提供给函数。
- en: 'Here''s the source listing of the `addToCart` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`addToCart`函数的源代码列表：
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Inside the `addToCart` function, we make an XHR call to the Rest API endpoint
    on the web server that is responsible for adding an item to the cart. Prior to
    making the XHR call, we create a map containing `productSKU`, and then we encode
    the map into its JSON representation. We send the JSON data using an XHR call
    to the server endpoint.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addToCart`函数中，我们对Web服务器上负责向购物车添加项目的Rest API端点进行XHR调用。在进行XHR调用之前，我们创建一个包含`productSKU`的地图，然后将地图编码为其JSON表示。我们使用XHR调用将JSON数据发送到服务器端点。
- en: We can now display the shopping cart on the client side, and we can also accommodate
    the user interactions with the shopping cart, notably adding a product to the
    shopping cart and removing a product from the shopping cart.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在客户端显示购物车，还可以适应用户与购物车的交互，特别是将产品添加到购物车和从购物车中删除产品。
- en: The shopping cart implementation that was covered in this chapter is meant for
    illustration purposes only. It is up to the reader to implement further functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的购物车实现仅用于说明目的。读者可以自行实现进一步的功能。
- en: Verifying the shopping cart functionality
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证购物车功能
- en: Now it's time to verify that the state of the shopping cart is maintained from
    the server to the client, as the user adds and removes items from the shopping
    cart.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候验证购物车的状态是否从服务器到客户端保持不变，因为用户向购物车中添加和删除项目。
- en: Verifying that isomorphic handoff was successfully implemented is straightforward.
    We simply need to verify that the server-side generated shopping cart page is
    identical to the client-side generated shopping cart page. By clicking on the
    shopping cart icon, we can see the client-side generated web page. By clicking
    on the refresh button while on the shopping cart page, we can see the server-side
    generated web page.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 验证等价交接是否成功实施非常简单。我们只需要验证服务器端生成的购物车页面是否与客户端生成的购物车页面相同。通过单击购物车图标，我们可以看到客户端生成的网页。在购物车页面上单击刷新按钮，我们可以看到服务器端生成的网页。
- en: 'Starting out, there are no items placed in the shopping cart. *Figure 6.7*
    is a screenshot depicting the shopping cart in its empty state:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，购物车中没有放置任何物品。*图6.7*是一个截图，描述了购物车处于空状态时的情况：
- en: '![](img/ed44a1f1-4a86-4597-9bc5-0d161404ba33.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed44a1f1-4a86-4597-9bc5-0d161404ba33.png)'
- en: 'Figure 6.7: The shopping cart page when the shopping cart is empty'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：购物车为空时的购物车页面
- en: The shopping cart page rendered on the client side matches the page rendered
    on the server side, indicating that the empty state of the shopping cart is maintained
    properly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端渲染的购物车页面与服务器端渲染的页面匹配，表明购物车的空状态得到了正确维护。
- en: 'Now, let''s visit the product listings page by clicking on the Products link
    on the navigation bar. Let''s add a few items to the shopping cart by clicking
    on the Add To Cart button. Let''s click on the shopping cart icon in the top bar
    of the website to return to the shopping cart page. *Figure 6.8* is a screenshot
    depicting the shopping cart with some products added:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过点击导航栏上的产品链接来访问产品列表页面。通过点击“添加到购物车”按钮，向购物车中添加一些商品。然后点击网站顶部栏中的购物车图标返回到购物车页面。*图6.8*是一个截图，显示了购物车中添加了一些商品：
- en: '![](img/23dbfb75-e299-4ca5-8a6f-83f747859260.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23dbfb75-e299-4ca5-8a6f-83f747859260.png)'
- en: 'Figure 6.8: The shopping cart page with some products in the shopping cart'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：购物车页面中有一些商品在购物车中
- en: After checking that the shopping cart page rendered on the client side matches
    the page rendered on the server side, we can determine that the state of the shopping
    cart has been maintained successfully.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查客户端渲染的购物车页面与服务器端渲染的页面是否匹配后，我们可以确定购物车的状态已成功维护。
- en: Now remove all the items from the shopping cart by clicking on the Remove From
    Cart button on each product. Once the shopping cart is empty, we can perform the
    same verification step of checking the page rendered on the client side with the
    page rendered on the server side to determine that the shopping cart state is
    successfully maintained.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过点击每个产品上的“从购物车中移除”按钮，从购物车中移除所有商品。一旦购物车为空，我们可以执行相同的验证步骤，检查客户端渲染的页面与服务器端渲染的页面是否相同，以确定购物车状态是否成功维护。
- en: At this point, we can acknowledge that the isomorphic handoff procedure has
    been implemented successfully for the shopping cart feature.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以确认等同手交程序已成功实现了购物车功能。
- en: 'You may have noticed that as we add items to the shopping cart, a notification
    is displayed on the lower right-hand side of the screen, as displayed in *Figure
    6.9*. Notice that the notification is displayed at the lower right-hand side of
    the web page, and it indicates that the product has been successfully added to
    the shopping cart:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，当我们向购物车添加商品时，屏幕右下角会显示通知，如*图6.9*所示。请注意，通知显示在网页的右下角，并指示产品已成功添加到购物车中。
- en: '![](img/2636829e-fbcb-4a38-b257-db6f8a6da20b.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2636829e-fbcb-4a38-b257-db6f8a6da20b.png)'
- en: 'Figure 6.9: A notification appears on the page''s lower right-hand side when
    an item has been added to the shopping cart'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：当商品被添加到购物车时，通知出现在页面的右下角
- en: Note that similar notifications also appear when items are removed from the
    shopping cart. We utilized a cog, a reusable component, to generate this notification.
    We will cover the implementation of the cog responsible for generating these notifications
    in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当从购物车中移除商品时，也会出现类似的通知。我们利用了一个可重用的组件“齿轮”来生成这个通知。我们将在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)中介绍负责生成这些通知的齿轮的实现，*齿轮-可重用组件*。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to *isomorphic handoff*, the means by which
    the server passes off state to the client. This is a significant procedure, that
    allows the client to pick up where the server left off in an isomorphic web application.
    We demonstrated the ERDA strategy to implement isomorphic handoff for the product-related
    web pages as well as the shopping cart web page. While implementing the shopping
    cart feature, we created a server-side session store, which acted as the source
    of truth for the current state of the user's shopping cart. We implemented server-side
    endpoints to implement the functionality to get items from the shopping cart,
    add items to the shopping cart, and remove items from the shopping cart. Finally,
    we verified that isomorphic handoff was successfully implemented by confirming
    that the web page rendered on the client side was identical to the the web page
    rendered on the server side.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了*等同手交*，即服务器将状态传递给客户端的方式。这是一个重要的过程，允许客户端在等同的网络应用程序中继续服务器中断的工作。我们演示了ERDA策略，以实现产品相关网页和购物车网页的等同手交。在实现购物车功能时，我们创建了一个服务器端会话存储，它充当了用户购物车当前状态的真相来源。我们实现了服务器端端点来实现从购物车获取商品、向购物车添加商品和从购物车删除商品的功能。最后，我们通过确认客户端渲染的网页与服务器端渲染的网页完全相同来验证等同手交是否成功实现。
- en: We also relied on sources of truth on the server side to maintain state with
    the client. For the product-related pages, the source of truth was the Redis datastore,
    and for the shopping cart page, the single source of truth was the server-side
    session store. In [Chapter 7](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml), *The
    Isomorphic Web Form*, we'll consider how to handle situations that go beyond basic
    user interactions. You'll learn how to accept user generated data from the client
    side, submitted through an isomorphic web form. You will learn how to validate
    and process the data submitted by the user, by implementing the contact form on
    IGWEB's Contact web page.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还依赖服务器端的真相来源来维护与客户端的状态。对于与产品相关的页面，真相来源是Redis数据存储，对于购物车页面，唯一的真相来源是服务器端的会话存储。在[第7章](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml)中，*等同网络表单*，我们将考虑如何处理超出基本用户交互的情况。您将学习如何接受客户端生成的数据，通过等同网络表单提交。您将学习如何验证和处理用户提交的数据，通过在IGWEB的联系网页上实现联系表单。
