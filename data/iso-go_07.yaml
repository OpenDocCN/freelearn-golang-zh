- en: The Isomorphic Web Form
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等同态网络表单
- en: In the previous chapter, we focused on how we could have the server-side application
    handoff data to the client-side application to seamlessly maintain state while
    implementing the shopping cart feature. In [Chapter 6](5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml),
    *Isomorphic Handoff*, we treated the server, as the single source of truth. The
    server dictated, to the client, what the current state of the shopping cart was.
    In this chapter, we are going to go beyond the simple user interactions that we
    have considered thus far and step into the realm of accepting user-generated data
    submitted through an isomorphic web form.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专注于如何使服务器端应用程序将数据移交给客户端应用程序，以无缝地维护状态，同时实现购物车功能。在[第6章]（5759cf7a-e435-431d-b7ca-24a846d6165a.xhtml）*等同态移交*中，我们将服务器视为唯一的真相来源。服务器向客户端指示当前购物车状态。在本章中，我们将超越迄今为止考虑的简单用户交互，并步入接受通过等同态网络表单提交的用户生成数据的领域。
- en: This signifies that now, the client has a voice, to dictate the user-generated
    data that should be stored on the server, within good reason of course (validation
    of user-submitted data). Using an isomorphic web form, validation logic can be
    shared across environments. The client-side application can chip in and inform
    the user that they've made a mistake prior to the form data being submitted to
    the server. The server-side application has the ultimate veto power because it
    will rerun the validation logic on the server side (where, ostensibly, the validation
    logic can't be tampered with) and process the user-generated data only upon a
    successful validation result.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在客户端有了发言权，可以决定应该存储在服务器上的用户生成数据，当然前提是有充分的理由（验证用户提交的数据）。使用等同态网络表单，验证逻辑可以在各个环境中共享。客户端应用程序可以参与并通知用户在提交表单数据到服务器之前已经犯了一个错误。服务器端应用程序拥有最终否决权，因为它将在服务器端重新运行验证逻辑（在那里，验证逻辑显然无法被篡改），并仅在成功验证结果时处理用户生成的数据。
- en: Besides providing the ability to share validation logic and form structure,
    isomorphic web forms also provide a means to make forms more accessible. We must
    address accessibility concerns for web clients that may not have a JavaScript
    runtime or may have the JavaScript runtime disabled. To accomplish this goal,
    we will build an isomorphic web form for the contact section of IGWEB, with progressive
    enhancement in mind. This means that only after implementing form functionality
    to satisfy the bare-minimum, JavaScript-disabled web client scenario, we will
    proceed to implement the client-side form validation that runs directly within
    a JavaScript equipped web browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供共享验证逻辑和表单结构的能力外，等同态网络表单还提供了一种使表单更易访问的方法。我们必须解决网页客户端的可访问性问题，这些客户端可能没有JavaScript运行时，或者可能已禁用JavaScript运行时。为了实现这一目标，我们将为IGWEB的联系部分构建一个等同态网络表单，并考虑渐进增强。这意味着只有在实现了满足最低要求的表单功能，以满足禁用JavaScript的网页客户端场景后，我们才会继续实现在JavaScript配备的网页浏览器中直接运行的客户端表单验证。
- en: By the end of this chapter, we'll have a robust, isomorphic web form, implemented
    in a single language (Go), which will reuse common code across environments. Most
    importantly, the isomorphic web form will be accessible to the most stripped down
    web client running in a terminal window, and at the same time, accessible to the
    GUI-based web client with the latest JavaScript runtime.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个强大的等同态网络表单，使用单一语言（Go）实现，它将在各种环境中重用通用代码。最重要的是，等同态网络表单将对终端窗口中运行的最简化的网页客户端和具有最新JavaScript运行时的基于GUI的网页客户端都是可访问的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the form flow
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解表单流程
- en: Designing the contact form
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计联系表单
- en: Validating email address syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证电子邮件地址语法
- en: The form interface
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单界面
- en: Implementing the contact form
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现联系表单
- en: The accessible contact form
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问的联系表单
- en: Client-side considerations
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端考虑
- en: Contact form Rest API Endpoint
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系表单Rest API端点
- en: Checking the client-side validation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查客户端验证
- en: Understanding the form flow
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解表单流程
- en: '*Figure 7.1* depicts an image showing the web form with only server-side validation
    in place. The form is submitted to the web server through an HTTP Post request.
    The server provides a fully rendered web page response. If the user did not fill
    out the form properly, errors will be populated and displayed in the web page
    response. If the user did fill out the form properly, a HTTP redirect will be
    made to the confirmation web page:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.1*显示了一个图像，显示了仅具有服务器端验证的网页表单。表单通过HTTP Post请求提交到Web服务器。服务器提供完全呈现的网页响应。如果用户没有正确填写表单，错误将在网页响应中显示。如果用户正确填写了表单，将进行HTTP重定向到确认网页：'
- en: '![](img/10bb8e33-a740-4d65-a97b-553d9d223faf.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10bb8e33-a740-4d65-a97b-553d9d223faf.png)'
- en: 'Figure 7.1: The web form with server-side validation only'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：仅具有服务器端验证的网页表单
- en: '*Figure 7.2* depicts an image showing the web form with both client-side and
    server-side validation in place. When the user submits the web form, the data
    in the form is validated using client-side validation. The form data will be submitted
    to the web server using an XHR call to a Rest API endpoint, only upon a successful
    client-side validation result. Once the form data has been submitted to the server,
    it will undergo a second round of server-side validation. This ensures the quality
    of the form data even in a scenario where the client-side validation may have
    been tampered with. The client-side application will inspect the form validation
    result returned from the server and will either display the confirmation page
    upon a successful form submission or will display the contact form errors, upon
    an unsuccessful form submission:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.2*显示了一个图像，显示了具有客户端和服务器端验证的Web表单。当用户提交Web表单时，表单中的数据将使用客户端验证进行验证。仅在成功的客户端验证结果时，表单数据将通过XHR调用提交到Web服务器的Rest
    API端点。一旦表单数据提交到服务器，它将经历第二轮服务器端验证。这确保了即使在客户端验证可能被篡改的情况下，表单数据的质量。客户端应用程序将检查从服务器返回的表单验证结果，并在成功提交表单时显示确认页面，或在提交表单不成功时显示联系表单错误：'
- en: '![](img/4decea16-9af6-4ee1-ac9d-937cceaca898.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4decea16-9af6-4ee1-ac9d-937cceaca898.png)'
- en: 'Figure 7.2: The web form validated on both the client-side and the server-side'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：在客户端和服务器端验证的Web表单
- en: Designing the contact form
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计联系表单
- en: 'The contact form will allow website users to get in touch with the IGWEB team.
    Successfully completing the contact form will result in a contact form submission
    containing the user-generated form data that will be persisted in the Redis database.
    *Figure 7.3* is the wireframe image depicting the contact form:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 联系表单将允许网站用户与IGWEB团队取得联系。成功完成联系表单将导致包含用户生成的表单数据的联系表单提交被持久化在Redis数据库中。*图7.3*是描述联系表单的线框图：
- en: '![](img/f6496bb6-b9b3-45f6-b271-c3464d1e1269.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6496bb6-b9b3-45f6-b271-c3464d1e1269.png)'
- en: 'Figure 7.3: Wireframe design of the contact form'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：联系表单的线框设计
- en: '*Figure 7.4* is the wireframe image depicting the contact form with form errors
    displayed when the user has not filled out the form properly:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.4*是线框图，描述了当用户未正确填写表单时显示表单错误的联系表单：'
- en: '![](img/b1bdc574-a9e3-4078-a195-bb5eff1ff568.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1bdc574-a9e3-4078-a195-bb5eff1ff568.png)'
- en: 'Figure 7.4: Wireframe design of the contact form, with error messages displayed'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：联系表单的线框设计，显示了错误消息
- en: '*Figure 7.5* is the wireframe image depicting the confirmation page that will
    be displayed to the user upon a successful contact form submission:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.5*是线框图，描述了成功提交联系表单后将显示给用户的确认页面：'
- en: '![](img/365ab4bf-f5c3-4ec6-88c3-a0416dad30fa.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/365ab4bf-f5c3-4ec6-88c3-a0416dad30fa.png)'
- en: 'Figure 7.5: Wireframe design of the confirmation page'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：确认页面的线框设计
- en: 'The contact form will solicit the following required information from the user:
    their first name, their last name, their email address, and their message to the
    team. If the user has not filled out any of these fields, upon hitting the Contact button
    on the form, the user will receive field-specific error messages, indicating the
    fields that have not been filled out.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 联系表单将从用户那里征求以下必要信息：他们的名字，姓氏，电子邮件地址和给团队的消息。如果用户没有填写这些字段中的任何一个，点击表单上的联系按钮后，用户将收到特定于字段的错误消息，指示未填写的字段。
- en: Implementing the templates
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施模板
- en: 'When rendering the Contact page from the server-side, we will use the `contact_page` template
    (found in the `shared/templates/contact_page.tmpl` file):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端呈现联系页面时，我们将使用`contact_page`模板（在`shared/templates/contact_page.tmpl`文件中找到）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Recall that because we include the `layouts/webpage_layout` template, and this
    will print the markup that generates the `doctype`, `html`, and `body` tags of
    the page. This template will be used exclusively on the server-side.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，因为我们包含了`layouts/webpage_layout`模板，这将打印生成页面的`doctype`，`html`和`body`标记的标记。这个模板将专门在服务器端使用。
- en: 'Using the `define` template action, we demarcate the `"pagecontent"` block,
    where the content of the contact page will be rendered. The content of the contact
    page is defined inside the `contact_content` template (found in the `shared/template/contact_content.tmpl` file):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`define`模板操作，我们划定了“pagecontent”块，其中将呈现联系页面的内容。联系页面的内容在`contact_content`模板内定义（在`shared/template/contact_content.tmpl`文件中找到）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Recall that in addition to the server-side application, the client-side application
    will be using the `contact_content` template to render the contact form in the
    primary content area.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除了服务器端应用程序之外，客户端应用程序将使用`contact_content`模板在主要内容区域呈现联系表单。
- en: 'Inside the `contact_content` template, we include the contact form partial
    template (`partials/contactform_partial`) that contains the markup for the contact
    form:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`contact_content`模板内，我们包含了包含联系表单标记的联系表单部分模板（`partials/contactform_partial`）：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This partial template contains the HTML markup necessary to implement the wireframe
    design depicted in *Figure 7.3*. The template actions that access the form field
    values and their corresponding errors are shown in bold. The reason that we populate
    the `value` attribute for a given `input` field is in case the user makes a mistake
    filling out the form, these values will be prepopulated with the values the user
    entered in the previous form submission attempt. There is a `<span>` tag directly
    after each `input` field, which will house the corresponding error message for
    that particular field.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分模板包含了实现*图7.3*所示线框设计所需的HTML标记。访问表单字段值及其对应错误的模板操作以粗体显示。我们为给定的`input`字段填充`value`属性的原因是，如果用户在填写表单时出错，这些值将被预先填充为用户在上一次表单提交尝试中输入的值。每个`input`字段后面直接跟着一个`<span>`标记，其中将包含该特定字段的相应错误消息。
- en: The very last `<input>` tag is a `submit` button. By clicking this button, the
    user will be able to submit the form contents to the web server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`<input>`标签是一个`submit`按钮。点击此按钮，用户将能够将表单内容提交到Web服务器。
- en: Validating email address syntax
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证电子邮件地址语法
- en: In addition to the basic requirement that all fields must be filled out, the
    email address field must be a properly formatted email address. If the user fails
    to provide a properly formatted email address, a field-specific error message
    will inform the user that the email address syntax is incorrect.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有字段必须填写的基本要求之外，电子邮件地址字段必须是格式正确的电子邮件地址。如果用户未能提供格式正确的电子邮件地址，字段特定的错误消息将通知用户电子邮件地址语法不正确。
- en: 'We''ll be using the `EmailSyntax` function from the `validate` package found
    within the `shared` folder:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`shared`文件夹中的`validate`包中的`EmailSyntax`函数。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Recall that because the `validate` package is strategically placed in the `shared`
    folder, the package is meant to be isomorphic (used across environments). The
    job of the `EmailSyntax` function is to determine if an input string is a valid
    email address or not. If the email address is valid, the function will return
    `true` or the function will return `false` if the input string isn't a valid email
    address.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，因为`validate`包被策略性地放置在`shared`文件夹中，该包旨在是等距的（跨环境使用）。`EmailSyntax`函数的工作是确定输入字符串是否是有效的电子邮件地址。如果电子邮件地址有效，函数将返回`true`，如果输入字符串不是有效的电子邮件地址，则函数将返回`false`。
- en: The form interface
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单接口
- en: 'An isomorphic web form implements the `Form` interface found in the `isokit`
    package:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 等距网络表单实现了`isokit`包中找到的`Form`接口：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Validate` method determines if the form has been filled out properly or
    not, returning a Boolean value of `true` if the form has been filled out properly,
    and it returns a Boolean value of `false` if the form hasn't been filled out properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validate`方法确定表单是否已正确填写，如果表单已正确填写，则返回`true`的布尔值，如果表单未正确填写，则返回`false`的布尔值。'
- en: The `Fields` method returns `map` of all the form fields where the key is the
    name of the form field, and the value is the string value of the form field.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fields`方法返回了所有表单字段的`map`，其中键是表单字段的名称，值是表单字段的字符串值。'
- en: The `Errors` method contains `map` of all the errors that were populated upon
    validation of the form. The key is the name of the form field, and the value is
    a descriptive error message.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Errors`方法包含了在表单验证时填充的所有错误的`map`。键是表单字段的名称，值是描述性错误消息。'
- en: The `FormParams` method returns the form's isomorphic form parameters object.
    The form parameters object is important because it determines the source from
    where user entered values for the form fields can be obtained. On the server side,
    form field values are obtained from `*http.Request` and on the client-side, form
    fields are obtained from the `FormElement` object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormParams`方法返回表单的等距表单参数对象。表单参数对象很重要，因为它确定了可以获取表单字段的用户输入值的来源。在服务器端，表单字段值是从`*http.Request`获取的，在客户端，表单字段是从`FormElement`对象获取的。'
- en: 'Here''s what the `FormParams` struct looks like:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`FormParams`结构的样子：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `PrefillFields` method returns a string slice of all the names of the form
    fields, whose values should be retained in case the user makes a mistake while
    submitting the form.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrefillFields`方法返回一个字符串切片，其中包含表单字段的所有名称，如果用户在提交表单时出错，应保留其值。'
- en: The last four getter methods considered, `Fields`, `Errors`, `FormParams`, and `PrefillFields`,
    have corresponding settter methods, `SetFields`, `SetErrors`, `SetFormParams`,
    and `SetPrefillFields`, respectively.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到最后四个getter方法，`Fields`、`Errors`、`FormParams`和`PrefillFields`，都有相应的setter方法，`SetFields`、`SetErrors`、`SetFormParams`和`SetPrefillFields`。
- en: Implementing the contact form
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现联系表单
- en: 'Now that we know what the form interface looks like, let''s start implementing
    the contact form. In our import grouping, note that we include the validate package
    and the `isokit` package:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道表单接口的样子，让我们开始实现联系表单。在我们的导入分组中，请注意我们包括了验证包和`isokit`包：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Recall that we need to import the validate package for the email address validation
    functionality using the `EmailSyntax` function defined in the package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们需要导入验证包，以便使用包中定义的`EmailSyntax`函数进行电子邮件地址验证功能。
- en: 'Most of the functionality needed to implement the `Form` interface that we
    covered earlier is provided by the `BasicForm` type, also found in the `isokit`
    package. We will type embed the type `BasicForm` into the type definition of our
    `ContactForm struct`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前介绍的实现`Form`接口所需的大部分功能都由`isokit`包中的`BasicForm`类型提供。我们将类型`BasicForm`嵌入到我们的`ContactForm`结构的类型定义中：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By doing so, most of the functionality to implement the `Form` interface is
    provided to us for free. It is imperative on us though to implement the `Validate`
    method because the default `Validate` method implementation, found in the `BasicForm`
    type, will always return `false`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们大部分实现`Form`接口的功能都是免费提供给我们的。但是，我们必须实现`Validate`方法，因为`BasicForm`类型中找到的默认`Validate`方法实现将始终返回`false`。
- en: 'The constructor function for the contact form accepts a `FormParams` struct
    and will return a pointer to a newly created `ContactForm` struct:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 联系表单的构造函数接受一个`FormParams`结构，并返回一个新创建的`ContactForm`结构的指针：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We create a string slice, containing the names of the fields that should have
    their values retained, in the `prefillFields` variable. We create instances of
    type `map[string]string` for both the `fields` variable and the `errors` variable.
    We create a reference to a new `ContactForm` instance and assign it to the variable
    `c`. We call the `SetFields` method of the `ContactForm` instance, `c`, and pass
    the fields variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个字符串切片，其中包含应保留其值的字段的名称，在`prefillFields`变量中。我们为`fields`变量和`errors`变量分别创建了`map[string]string`类型的实例。我们创建了一个新的`ContactForm`实例的引用，并将其分配给变量`c`。我们调用`ContactForm`实例`c`的`SetFields`方法，并传递`fields`变量。
- en: We call the `SetFields` and `SetErrors` methods and pass in `fields` and `errors`
    variables, respectively. We call the `SetFormParams` method of `c` to set the
    form parameters, which were passed into the constructor function. Finally, we
    return the new `ContactForm` instance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`SetFields`和`SetErrors`方法，并分别传入`fields`和`errors`变量。我们调用`c`的`SetFormParams`方法来设置传入构造函数的表单参数。最后，我们返回新的`ContactForm`实例。
- en: 'As noted earlier, the default `Validate` method implementation, found in the
    `BasicForm` type, will always return `false`. Because we are implementing our
    own custom form, the contact form, it is our responsibility to define what a successful
    validation is, and we do so by implementing the `Validate` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，`BasicForm`类型中的默认`Validate`方法实现总是返回`false`。因为我们正在实现自己的自定义表单，联系表单，我们有责任定义成功验证是什么，并通过实现`Validate`方法来实现。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first call the `RegenerateErrors` method to clear the current errors that
    are displayed to the user. The functionality for this method is only applicable
    to the client-side application. We will cover this method in more detail when
    we implement the contact form functionality on the client side.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`RegenerateErrors`方法来清除当前显示给用户的错误。这个方法的功能只适用于客户端应用程序。当我们在客户端实现联系表单功能时，我们将更详细地介绍这个方法。
- en: We call the `PopulateFields` method to populate the fields `map` of the `ContactForm`
    instance. In case the user had made mistakes filling out the form, this method
    is responsible for prefilling the values that the user had already entered, to
    save them the trouble of having to enter those values again to resubmit the form.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`PopulateFields`方法来填充`ContactForm`实例的字段`map`。如果用户在填写表单时出现错误，这个方法负责预先填充用户已经输入的值，以免他们不得不再次输入这些值来重新提交表单。
- en: At this point, we can commence with the form validation. We first check to see
    whether the first name field has been filled out by the user. We use the `FormValue`
    function, found in the `isokit` package, to obtain the user entered value for
    the form field having the name `firstName`. The first argument we pass to the
    `FormValue` function is the contact form's form parameters object, and the second
    value is the name of the form field whose value we wish to obtain, in this case,
    that is the form field with the name `"firstName"`. By checking to see whether
    the user-entered value is an empty string, we can determine whether or not the
    user has entered a value into the field. If they haven't, we call the `SetError`
    method, passing the name of the form field, along with a descriptive error message.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以开始进行表单验证。我们首先检查用户是否已经填写了名字字段。我们使用`isokit`包中的`FormValue`函数来获取表单字段`firstName`的用户输入值。我们传递给`FormValue`函数的第一个参数是联系表单的表单参数对象，第二个值是我们希望获取的表单字段的名称，即`"firstName"`。通过检查用户输入的值是否为空字符串，我们可以确定用户是否已经在字段中输入了值。如果没有，我们调用`SetError`方法，传递表单字段的名称，以及一个描述性错误消息。
- en: We perform the exact same check, to see if the user has filled out the necessary
    values, for the last name field, the message body, and the email address. If they
    haven't filled out any of these fields, we make calls to the `SetError` method,
    providing the name of the field and a descriptive error message.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行完全相同的检查，以查看用户是否已经填写了必要的值，包括姓氏字段、消息正文和电子邮件地址。如果他们没有填写这些字段中的任何一个，我们将调用`SetError`方法，提供字段的名称和一个描述性错误消息。
- en: In the case of the email address, if the user has entered a value for the email
    form field, we perform an additional check on the syntax of the email address
    supplied by the user. We pass the email value entered by the user to the `EmailSyntax`
    function in the validate package. If the email is not a valid syntax, we call
    the `SetError` method, passing in the form field name `"email"`, along with a
    descriptive error message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电子邮件地址，如果用户已经输入了电子邮件表单字段的值，我们将对用户提供的电子邮件地址的语法进行额外检查。我们将用户输入的电子邮件值传递给验证包中的`EmailSyntax`函数。如果电子邮件不是有效的语法，我们调用`SetError`方法，传入表单字段名称`"email"`，以及一个描述性错误消息。
- en: As we stated earlier, the `Validate` function returns a Boolean value based
    off of whether the form contains errors or not. We use the if conditional to determine
    If the count of errors is greater than zero, and if it is, that indicates that
    the form has errors, and we return a Boolean value of `false`. If count of errors
    is zero, the flow of control will reach the else block where we return a Boolean
    value of `true`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，`Validate`函数基于表单是否包含错误返回一个布尔值。我们使用if条件来确定错误的数量是否大于零，如果是，表示表单有错误，我们返回一个布尔值`false`。如果错误的数量为零，控制流将到达else块，我们返回一个布尔值`true`。
- en: Now that we've added the contact form, it's time to implement the server-side
    route handlers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了联系表单，是时候实现服务器端的路由处理程序了。
- en: Registering the contact route
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册联系路由
- en: 'We start out by adding the routes for the contact form page and the contact
    confirmation page:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加联系表单页面和联系确认页面的路由：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `/contact` route that we have registered, which will be handled
    by the `ContactHandler` function, will accept HTTP requests using both the `GET`
    and the `POST` method. When the contact form is first accessed, it will be through
    a `GET` request to the `/contact` route. When the user submits the contact form,
    they will initiate a `POST` request to the `/contact` route. This explains why
    this route accepts both of these HTTP methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们注册的`/contact`路由将由`ContactHandler`函数处理，将接受使用`GET`和`POST`方法的HTTP请求。当首次访问联系表单时，将通过`GET`请求到`/contact`路由。当用户提交联系表单时，他们将发起一个`POST`请求到`/contact`路由。这解释了为什么这个路由接受这两种HTTP方法。
- en: Upon successfully filling out the contact form, the user will be redirected
    to the `/contact-confirmation` route. This is done intentionally to avoid resubmission
    form errors that can occur, when the user attempts to refresh the web page, if
    we had simply printed out a form confirmation message using the `/contact` route
    itself.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 成功填写联系表单后，用户将被重定向到`/contact-confirmation`路由。这是有意为之，以避免重新提交表单错误，当用户尝试刷新网页时，如果我们仅仅使用`/contact`路由本身打印出表单确认消息。
- en: The contact route handler
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系路由处理程序
- en: 'The `ContactHandler` is responsible for rendering the contact page on IGWEB,
    where the contact form will reside:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactHandler`负责在IGWEB上呈现联系页面，联系表单将驻留在此处：'
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We declare and initialize the `formParams` variable to a newly initialized
    `FormParams` instance, providing the values for the `ResponseWriter` and `Request`
    fields:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化`formParams`变量为新初始化的`FormParams`实例，提供`ResponseWriter`和`Request`字段的值：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then declare and initialize the `contactForm` variable, with a newly created
    `ContactForm` instance, by calling the `NewContactForm` function and passing in
    the reference to the `formParams` struct:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明并初始化`contactForm`变量，通过调用`NewContactForm`函数并传入对`formParams`结构的引用，使用新创建的`ContactForm`实例。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We `switch` on the type of HTTP request method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据HTTP请求方法的类型进行`switch`：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the case that the HTTP request method is `GET`, we call the `DisplayContactForm`
    function, passing in the `env` object and the `contactForm` object. The `DisplayContactForm`
    function will render the contact form on the contact page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP请求方法是`GET`，我们调用`DisplayContactForm`函数，传入`env`对象和`contactForm`对象。`DisplayContactForm`函数将在联系页面上呈现联系表单。
- en: In the case that the HTTP request method is a `POST`, we validate the contact
    form. Remember that if the `/contact` route is accessed using the `POST` method,
    it is indicative of the user having submitted the contact form to the route. We
    declare and initialize the `validationResult` variable, setting it to the value
    of the result from calling the `Validate` method of the `ContactForm` object,
    `contactForm`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP请求方法是`POST`，我们验证联系表单。请记住，如果使用`POST`方法访问`/contact`路由，这表明用户已经向路由提交了联系表单。我们声明并初始化`validationResult`变量，将其设置为调用`ContactForm`对象`contactForm`的`Validate`方法的结果的值。
- en: If the value of the `validationResult` is true, the form validated successfully.
    We call the `ProcessContactForm` function in the submissions package, passing
    in the `env` object and the `ContactForm` object. The `ProcessContactForm` function
    is responsible for handling a successful contact form submission. We then call
    the `DisplayConfirmation` function, passing in the `env` object, `http.ResponseWriter`,
    `w`, and `*http.Request`, `r`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`validationResult`的值为true，表单验证成功。我们调用`submissions`包中的`ProcessContactForm`函数，传入`env`对象和`ContactForm`对象。`ProcessContactForm`函数负责处理成功的联系表单提交。然后我们调用`DisplayConfirmation`函数，传入`env`对象，`http.ResponseWriter`，`w`和`*http.Request`，`r`。
- en: If the value of the `validationResult` is `false`, flow of control goes inside
    the `else` block, and we call the `DisplayContactForm` function passing in the
    `env` object and the `ContactForm` object, `contactForm`. This will render the
    contact form again, and this time, the user will see error messages pertaining
    to the fields that were either not filled out or that were not filled out properly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`validationResult`的值为`false`，控制流进入`else`块，我们调用`DisplayContactForm`函数，传入`env`对象和`ContactForm`对象`contactForm`。这将再次呈现联系表单，这次用户将看到与未填写或未正确填写的字段相关的错误消息。
- en: In the case that the HTTP request method is neither a `GET` or a `POST`, we
    reach the default condition and simply call the `DisplayContactForm` function
    to display the contact form.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP请求方法既不是`GET`也不是`POST`，我们达到默认条件，简单地调用`DisplayContactForm`函数来显示联系表单。
- en: 'Here''s the `DisplayContactForm` function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DisplayContactForm`函数：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function takes in an `env` object and a `ContactForm` object as input arguments.
    We start out by declaring and initializing the variable `templateData`, which
    will serve as the data object that we will be feeding to the `contact_page` template.
    We create a new instance of a `templatedata.Contact` struct and populate its `PageTitle`
    field to `"Contact"`, and its `Form` field to the `ContactForm` object that was
    passed into the function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受`env`对象和`ContactForm`对象作为输入参数。我们首先声明并初始化`templateData`变量，它将作为我们将要提供给`contact_page`模板的数据对象。我们创建一个新的`templatedata.Contact`结构的实例，并将其`PageTitle`字段填充为`"Contact"`，将其`Form`字段填充为传入函数的`ContactForm`对象。
- en: 'Here''s what the `Contact` struct from the `templatedata` package looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`templatedata`包中的`Contact`结构的样子：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `PageTitle` field represents the page title for the web page, and the `Form`
    field represents the `ContactForm` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTitle`字段代表网页的页面标题，`Form`字段代表`ContactForm`对象。'
- en: We then call the `Render` method on the `env.TemplateSet` object, and we pass
    in the name of the template we wish to render, `contact_page`, along with the
    isomorphic template render parameters (`RenderParams`) object. We have assigned
    the `Writer` field, of the `RenderParams` object, with the `ResponseWriter` associated
    with the `ContactForm` object, and we have assigned the `Data` field with the
    `templateData` variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`env.TemplateSet`对象上调用`Render`方法，并传入我们希望呈现的模板名称`contact_page`，以及等同模板呈现参数（`RenderParams`）对象。我们已经将`RenderParams`对象的`Writer`字段分配为与`ContactForm`对象相关联的`ResponseWriter`，并将`Data`字段分配为`templateData`变量。
- en: 'Here''s the `DisplayConfirmation` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DisplayConfirmation`函数：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function is responsible for performing the redirect to the confirmation
    page. In this function, we simply call the `Redirect` function available in the
    `http` package and perform a `302` status redirect to the `/contact-confirmation`
    route.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责执行重定向到确认页面。在这个函数中，我们简单地调用`http`包中可用的`Redirect`函数，并执行`302`状态重定向到`/contact-confirmation`路由。
- en: Now that we've covered the route handler for the Contact page, it's time to
    take a look at the route handler for the contact form confirmation web page.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了联系页面的路由处理程序，是时候看看联系表单确认网页的路由处理程序了。
- en: The contact confirmation route handler
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系确认路由处理程序
- en: 'The sole purpose of the `ContactConfirmationHandler` function is to render
    the contact confirmation page:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactConfirmationHandler`函数的唯一目的是呈现联系确认页面：'
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We call the `Render` method of the `TemplateSet` object and specify that want
    to render the `contact_confirmation_page` template, along with the passed in `RenderParams`
    struct. We have populated the `Writer` field of the struct with the `http.ResponseWriter`,
    and we have assigned a value of `nil` to the `Data` object, to indicate that there
    is no data object that is to be passed to the template.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`TemplateSet`对象的`Render`方法，并指定要呈现`contact_confirmation_page`模板，以及传入的`RenderParams`结构。我们已经将结构的`Writer`字段填充为`http.ResponseWriter`，并将`Data`对象的值分配为`nil`，以指示没有要传递给模板的数据对象。
- en: Processing the contact form submission
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理联系表单提交
- en: 'Upon successful completion of the contact form, we call the `ProcessContactForm`
    function in the `submission` package. If the workflow to fill out the contact
    form were like playing baseball, the call to the `ProcessContactForm` function
    can be considered reaching home plate and scoring a run. As we shall see later
    in the section, *Contact form Rest API endpoint*, this function will also be called
    by the contact form''s Rest API endpoint. Now that we have established the significance
    of this function, let''s go ahead and examine it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在联系表单成功完成后，我们在`submission`包中调用`ProcessContactForm`函数。如果填写联系表单的工作流程就像打棒球一样，那么对`ProcessContactForm`函数的调用可以被认为是到达本垒并得分。正如我们将在*联系表单Rest
    API端点*部分中看到的那样，这个函数也将被联系表单的Rest API端点调用。既然我们已经确定了这个函数的重要性，让我们继续并检查它：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We first print out a log message to indicate that we have successfully reached
    the function, indicating that the user has properly filled out the contact form,
    and the user-entered data is worthy to be processed. We then declare and initialize
    the `contactRequest` variable with a newly created `ContactRequest` instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先打印出一个日志消息，指示我们已成功到达该函数，表明用户已正确填写了联系表单，并且用户输入的数据值得被处理。然后我们声明并初始化`contactRequest`变量，使用新创建的`ContactRequest`实例。
- en: 'The purpose of the `ContactRequest` struct is to model the data that is collected
    from the contact form. Here''s what the `ContactRequest` struct looks like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactRequest`结构的目的是对从联系表单收集的数据进行建模。以下是`ContactRequest`结构的外观：'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, each field in the `ContactRequest` struct corresponds to the
    form field that exists in the contact form. We populate each field in the `ContactRequest`
    struct with its corresponding user-entered value from the contact form by calling
    the `GetFieldValue` method on the contact form object and providing the name of
    the form field.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`ContactRequest`结构中的每个字段对应于联系表单中存在的表单字段。我们通过在联系表单对象上调用`GetFieldValue`方法并提供表单字段的名称，将`ContactRequest`结构中的每个字段填充为其对应的用户输入值。
- en: 'As stated earlier, a successful contact form submission consists of storing
    the contact request information in the Redis database:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，成功的联系表单提交包括将联系请求信息存储在Redis数据库中：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We call the `CreateContactRequest` method of our custom Redis datastore object,
    `env.DB`, and pass in the `ContactRequest` object, `contactRequest` to the method.
    This method will save the contact request information into the Redis database:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用我们自定义Redis数据存储对象`env.DB`的`CreateContactRequest`方法，并将`ContactRequest`对象`contactRequest`传递给该方法。这个方法将联系请求信息保存到Redis数据库中：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `CreateContactRequest` method accepts a `ContactRequest` object as a sole
    input argument. We JSON marshal the `ContactRequest` value and store it into the
    Redis database. An error object is returned if either the JSON marshaling process
    failed or if saving to the database failed. If there were no errors encountered,
    we return `nil`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateContactRequest`方法接受`ContactRequest`对象作为唯一输入参数。我们对`ContactRequest`值进行JSON编组，并将其存储到Redis数据库中。如果JSON编组过程失败或保存到数据库失败，则返回错误对象。如果没有遇到错误，我们返回`nil`。'
- en: The accessible contact form
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可访问的联系表单
- en: At this point, we have everything in place to take the contact form for a test
    drive. However, instead of opening up the contact form in a GUI-based web browser,
    we're first going to see how accessible the contact form is for visually impaired
    users using the Lynx web browser.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经准备好测试联系表单了。但是，我们不是首先在基于GUI的网页浏览器中打开联系表单，而是首先看看使用Lynx网页浏览器对视障用户来说联系表单的可访问性如何。
- en: On first impression, it may seem strange that we are test driving the contact
    form using a 25-year-old, text-only web browser. However, Lynx has the capability
    to provide a refreshable braille display, along with text-to-speech functionality,
    which has made it a commendable web browsing technology for the visually impaired.
    Because Lynx does not support displaying images and running JavaScript, we can
    get a good idea of how the contact form will hold up for users that need greater
    accessibility.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们使用一个25年历史的纯文本网页浏览器来测试联系表单可能看起来有些奇怪。然而，Lynx具有提供可刷新的盲文显示以及文本到语音功能的能力，这使得它成为了一个值得称赞的供视障人士使用的网页浏览技术。因为Lynx不支持显示图像和运行JavaScript，我们可以很好地了解联系表单对于需要更大可访问性的用户来说的表现。
- en: 'If you are using Homebrew on your Mac, you can easily install Lynx like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Mac上使用Homebrew，可以轻松安装Lynx，方法如下：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you are using Ubuntu, you can install Lynx by issuing the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Ubuntu，可以通过发出以下命令安装Lynx：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you are using Windows, you can download Lynx from this web page: [http://lynx.invisible-island.net/lynx2.8.8/index.html](http://lynx.invisible-island.net/lynx2.8.8/index.html).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows，可以从这个网页下载Lynx：[http://lynx.invisible-island.net/lynx2.8.8/index.html](http://lynx.invisible-island.net/lynx2.8.8/index.html)。
- en: You can read more about the Lynx web browser on Wikipedia at [https://en.wikipedia.org/wiki/Lynx_(web_browser)](https://en.wikipedia.org/wiki/Lynx_(web_browser)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在维基百科上阅读有关Lynx Web浏览器的更多信息[https://en.wikipedia.org/wiki/Lynx_(web_browser)](https://en.wikipedia.org/wiki/Lynx_(web_browser))。
- en: 'With the `igweb` web server instance running, we start up lynx using the `--nocolor`
    option like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--nocolor`选项启动lynx时，我们启动`igweb` Web服务器实例：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Figure 7.6* shows what the contact form looks like in the Lynx web browser:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.6*显示了Lynx Web浏览器中联系表格的外观：'
- en: '![](img/aca3054b-b49a-4d85-8e0b-8615390a58de.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aca3054b-b49a-4d85-8e0b-8615390a58de.png)'
- en: 'Figure 7.6: The contact form in the Lynx web browser'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：Lynx Web浏览器中的联系表格
- en: 'Now, we are going to partially fill out the contact form, on purpose to test
    if the form validation logic is working. In the case of the email field, we will
    provide an improperly formatted email address, as shown in *Figure 7.7*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将部分填写联系表格，目的是测试表单验证逻辑是否有效。在电子邮件字段的情况下，我们将提供一个格式不正确的电子邮件地址，如*图7.7*所示：
- en: '![](img/77416de7-79e3-418c-b45b-cbb788fb5479.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77416de7-79e3-418c-b45b-cbb788fb5479.png)'
- en: 'Figure 7.7: The contact form filled out improperly'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：联系表格填写不正确
- en: 'Upon hitting the Contact button, note that we get error messages that pertain
    to the fields that have not been filled out properly, as shown in *Figure 7.8*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“联系”按钮后，请注意我们收到有关未正确填写的字段的错误消息，如*图7.8*所示：
- en: '![](img/33ca6e78-e8e4-45a4-b797-75997ac4d45f.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33ca6e78-e8e4-45a4-b797-75997ac4d45f.png)'
- en: 'Figure 7.8: Error messages are displayed for the email address field and the
    message text area'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：电子邮件地址字段和消息文本区域显示的错误消息
- en: Also note that we received the error message telling us that the email address
    format is not correct.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们收到了错误消息，告诉我们电子邮件地址格式不正确。
- en: '*Figure 7.9* shows what the contact form looks like after we have corrected
    all the errors:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.9*显示了我们纠正所有错误后联系表格的外观：'
- en: '![](img/e251ed95-8f60-4bce-a765-e70fdac4e943.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e251ed95-8f60-4bce-a765-e70fdac4e943.png)'
- en: 'Figure 7.9: The contact form filled out properly'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：联系表格填写正确
- en: 'Upon submitting the corrected contact form, we see the confirmation message,
    informing us that we have successfully filled out the contact form, as shown in
    *Figure 7.10*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更正的联系表格后，我们看到确认消息，通知我们已成功填写联系表格，如*图7.10*所示：
- en: '![](img/e061a763-d5c7-4fa5-871a-8026e37e2c1e.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e061a763-d5c7-4fa5-871a-8026e37e2c1e.png)'
- en: 'Figure 7.10: The confirmation page'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：确认页面
- en: 'Inspecting the Redis database, using the redis-cli command, we can verify that
    we received the form submission, as shown in *Figure 7.11*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用redis-cli命令检查Redis数据库，我们可以验证我们收到了表单提交，如*图7.11*所示：
- en: '![](img/1ffb7e74-e596-4036-bb0b-0880aeca7ae1.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ffb7e74-e596-4036-bb0b-0880aeca7ae1.png)'
- en: 'Figure 7.11: Verification of a newly stored contact request entry in the Redis
    database'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：在Redis数据库中验证新存储的联系请求条目
- en: At this point, we can be satisfied knowing that we've made our contact form
    accessible for visually impaired users and it didn't take much effort on our part.
    Let's take a look at how the contact form looks in a GUI-based web browser with
    JavaScript disabled.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以满意地知道我们已经使我们的联系表格对视力受损用户可访问，并且我们的努力并不多。让我们看看在禁用JavaScript的GUI型Web浏览器中联系表格的外观。
- en: The contact form can function without JavaScript
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系表格可以在没有JavaScript的情况下运行
- en: 'In the Safari web browser, we may disable JavaScript, by choosing the Disable
    JavaScript option in Safari''s Develop menu:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Safari Web浏览器中，我们可以通过在Safari的开发菜单中选择禁用JavaScript选项来禁用JavaScript：
- en: '![](img/aa350d78-e4b2-4a08-8635-92a42f3d45e6.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa350d78-e4b2-4a08-8635-92a42f3d45e6.png)'
- en: 'Figure 7.12: Disabling JavaScript using Safari''s develop menu'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：使用Safari的开发菜单禁用JavaScript
- en: '*Figure 7.13* shows what the contact form looks like in the **Graphical User
    Interface** (**GUI**)-based web browser:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.13*显示了**图形用户界面**（**GUI**）-基于Web浏览器的联系表格的外观：'
- en: '![](img/442aef8b-1adc-467b-944c-d6c77989cba5.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/442aef8b-1adc-467b-944c-d6c77989cba5.png)'
- en: 'Figure 7.13: The contact form in a GUI-based web browser'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：GUI型Web浏览器中的联系表格
- en: 'We follow the same testing strategy that we performed on the Lynx web browser.
    We partially fill out the form and supply an invalid email address, as shown in
    *Figure 7.14*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循与Lynx Web浏览器上执行的相同的测试策略。我们部分填写表格并提供一个无效的电子邮件地址，如*图7.14*所示：
- en: '![](img/cf094d58-b72a-4c86-89d3-a817729357c3.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf094d58-b72a-4c86-89d3-a817729357c3.png)'
- en: 'Figure 7.14: The contact form filled out improperly'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：联系表格填写不正确
- en: 'Upon hitting the Contact button, the error messages are displayed next to the
    fields with issues, as shown in *Figure 7.15*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“联系”按钮后，错误消息显示在有问题的字段旁边，如*图7.15*所示：
- en: '![](img/0a5811f1-53f5-4575-a008-d21b9623dbbe.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a5811f1-53f5-4575-a008-d21b9623dbbe.png)'
- en: 'Figure 7.15: Error messages are displayed next to fields with issues'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：错误消息显示在有问题的字段旁边
- en: 'Upon submitting the contact form, note that we get errors pertaining to the
    improperly filled out fields. After correcting the errors, we are now ready to
    hit the Contact button to submit the form again, as shown in *Figure 7.16*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 提交联系表格后，请注意我们收到有关填写不正确的字段的错误。纠正错误后，我们现在准备再次点击“联系”按钮提交表格，如*图7.16*所示：
- en: '![](img/2e7c59e6-71c5-4980-a186-89aa445d881b.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e7c59e6-71c5-4980-a186-89aa445d881b.png)'
- en: 'Figure 7.16: The properly filled out contact form ready for resubmission'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：准备重新提交的正确填写的联系表格
- en: 'Upon submitting the contact form, we get forwarded to the `/contact-confirmation`
    route, and we receive the confirmation message that the contact form has been
    filled out properly, as shown in *Figure 7.17*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 提交联系表格后，我们被转发到`/contact-confirmation`路由，并收到确认消息，联系表格已正确填写，如*图7.17*所示：
- en: '![](img/a27ce314-b179-4a48-86d3-6480020ac679.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a27ce314-b179-4a48-86d3-6480020ac679.png)'
- en: 'Figure 7.17: The confirmation page'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：确认页面
- en: The server-side-based contact form that we have implemented will continue to
    function even with JavaScript enabled. You might be wondering why do we need to
    implement the contact form on the client-side? Couldn't we just solely use the
    server-side-based contact form and call it a day?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现的基于服务器端的联系表单即使在启用JavaScript的情况下也将继续运行。您可能会想为什么我们需要在客户端实现联系表单？我们不能只使用基于服务器端的联系表单并结束吗？
- en: The answer boils down to providing the user with an enhanced user experience.
    By solely using the server-side contact form, we break the single page application
    architecture that the user is experiencing. The astute reader will recognize that
    it takes a full page reload to submit the form and resubmit the form if there
    were errors. The HTTP redirect to the `/contact-confirmation` route will also
    break the user experience because it will also cause a full page reload.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 答案归结为为用户提供增强的用户体验。仅使用基于服务器端的联系表单，我们会破坏用户正在体验的单页应用架构。敏锐的读者会意识到，提交表单和重新提交表单都需要完整的页面重新加载。HTTP重定向到`/contact-confirmation`路由也会破坏用户体验，因为它也会导致完整的页面重新加载。
- en: 'The following two objectives need to be fulfilled, in order to implement the
    contact form on the client-side:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端实现联系表单，需要实现以下两个目标：
- en: Provide a consistent, seamless single-page application experience
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一致、无缝的单页应用体验
- en: Provide the ability to validate the contact form on the client-side
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端提供验证联系表单的能力
- en: The first objective, providing a consistent, seamless single-page application
    experience, is easily done using the isomorphic template set to render content
    to the primary content area `div` container as we had shown in previous chapters.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目标，提供一致、无缝的单页应用体验，可以通过使用同构模板集来轻松实现，以将内容呈现到主要内容区域的`div`容器中，就像我们在之前的章节中展示的那样。
- en: The second objective, the ability to validate the contact form on the client
    side, is possible, since the web browser has JavaScript enabled. With this capability,
    we can validate the contact form on the client side itself. Consider the scenario,
    where we have a user, that keeps making mistakes while filling out the contact
    form. We can lessen the amount of unnecessary network calls that are made to the
    web server. Only after the user has gotten past the first round of validation
    (on the client-side), will the form be submitted over the network, to the web
    server, where it undergoes the final round of validation (on the server side).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个目标是在客户端验证联系表单的能力，由于Web浏览器启用了JavaScript，这是可能的。有了这个能力，我们可以在客户端验证联系表单本身。考虑这样一种情况，我们有一个用户，在填写联系表单时不断犯错。我们可以减少向Web服务器发出的不必要的网络调用。只有在用户通过第一轮验证（在客户端）之后，表单才会通过网络提交到Web服务器，在那里进行最终的验证（在服务器端）。
- en: Client-side considerations
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端考虑
- en: 'Amazingly enough, there isn''t much work that we need to perform to get the
    contact form going on the client side. Let''s examine the `contact.go` source
    file found in the `client/handlers` folder, section by section:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，在客户端上启用联系表单并不需要我们做太多工作。让我们逐节检查`client/handlers`文件夹中找到的`contact.go`源文件：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is our `ContactHandler` function, which will service the needs of the `/contact`
    route on the client side. We start off by declaring and initializing the `contactForm`
    variable, assigning it to the `ContactForm` instance that is returned by calling
    the `NewContactForm` constructor function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`ContactHandler`函数，它将为客户端上的`/contact`路由提供服务。我们首先声明并初始化`contactForm`变量，将其分配给通过调用`NewContactForm`构造函数返回的`ContactForm`实例。
- en: Note that we pass `nil` to the constructor function, when we should normally
    be passing a `FormParams` struct. On the client side, we would populate the `FormElement`
    field of the `FormParams` struct to associate the form element on the web page
    to the `contactForm` object. However, prior to rendering the web page, we run
    into a *did the chicken come before the egg* scenario. We can't populate the `FormElement`
    field of the `FormParams` struct because a form element doesn't exist on the web
    page yet. So, our first order of business is to render the contact form, and for
    the time being, we will set the contact form's `FormParams` struct to `nil` in
    order to do so. Later on, we will set the `contactForm` object's `FormParams`
    struct using the `contactForm` object's `SetFormParams` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们通常应该传递一个`FormParams`结构时，我们将`nil`传递给构造函数。在客户端，我们将填充`FormParams`结构的`FormElement`字段，以将网页上的表单元素与`contactForm`对象关联起来。然而，在呈现网页之前，我们遇到了一个“先有鸡还是先有蛋”的情况。我们无法填充`FormParams`结构的`FormElement`字段，因为网页上还不存在表单元素。因此，我们的首要任务是呈现联系表单，目前，我们将联系表单的`FormParams`结构设置为`nil`以实现这一点。稍后，我们将使用`contactForm`对象的`SetFormParams`方法设置`contactForm`对象的`FormParams`结构。
- en: 'To display the contact form on the web page, we call the `DisplayContactForm`
    function passing in the `env` object and the `contactForm` object, `contactForm`.
    This function is instrumental in our first objective to preserve the seamless
    single-page application user experience. Here''s what the `DisplayContactForm`
    function looks like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在网页上显示联系表单，我们调用`DisplayContactForm`函数，传入`env`对象和`contactForm`对象。这个函数对于我们保持无缝的单页应用用户体验是至关重要的。`DisplayContactForm`函数如下所示：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We declare and initialize the `templateData` variable, which will be the data
    object that we pass to the template. The `templateData` variable is assigned with
    a newly created `Contact` instance from the `templatedata` package, having a `PageTitle`
    property set to `"Contact"` and the `Form` property set to the `contactForm` object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化`templateData`变量，这将是我们传递给模板的数据对象。`templateData`变量被分配一个新创建的`templatedata`包中的`Contact`实例，其`PageTitle`属性设置为“联系”，`Form`属性设置为`contactForm`对象。
- en: We call the `Render` method of the `env.TemplateSet` object and specify that
    we wish to render the `"contact_content"` template. We also supply the isomorphic
    render parameters (`RenderParams`) to the `Render` method, setting the `Data`
    field equal to the `templateData` variable, and we set the `Disposition` field
    to `isokit.PlacementReplaceInnerContents,` which declares how we will render the
    template content relative to an associated element. By setting the `Element` field
    to `env.PrimaryContent`, we specify that the primary content `div` container will
    be the associated element that the template will be rendering to. Finally, we
    set the `PageTitle` property to dynamically change the web page's title as the
    user lands on the `/contact` route from the client side.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`env.TemplateSet`对象的`Render`方法，并指定我们希望渲染`"contact_content"`模板。我们还向`Render`方法提供了等同渲染参数（`RenderParams`），将`Data`字段设置为`templateData`变量，并将`Disposition`字段设置为`isokit.PlacementReplaceInnerContents`，声明了我们将如何相对于关联元素渲染模板内容。通过将`Element`字段设置为`env.PrimaryContent`，我们指定主要内容`div`容器将是模板将要渲染到的关联元素。最后，我们将`PageTitle`属性设置为动态更改网页标题，当用户从客户端着陆在`/contact`路由时。
- en: 'We call the `InitializeContactPage` function, supplying the `env` object and
    the `contactForm` object. Recall that the `InitializeContactPage` function is
    responsible for setting up the user interactivity-related code (event handlers)
    for the Contact page. Let''s examine the `InitializeContactPage` function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`InitializeContactPage`函数，提供`env`对象和`contactForm`对象。回想一下，`InitializeContactPage`函数负责为联系页面设置用户交互相关的代码（事件处理程序）。让我们检查`InitializeContactPage`函数：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We call the `GetElementByID` method on the `env.Document` object to fetch the
    contact form element and assign it to the variable `formElement`. We call the
    `SetFormParams` method, supplying a `FormParams` struct and populating its `FormElement`
    field with the `formElement` variable. At this point, we have set the form parameters
    for the `contactForm` object. We obtain the contact form's `button` element by
    calling the `GetElementByID` method on the `env.Document` object and supplying
    an `id` of `"contactButton"`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`env.Document`对象的`GetElementByID`方法来获取联系表单元素，并将其赋值给变量`formElement`。我们调用`SetFormParams`方法，提供一个`FormParams`结构，并用`formElement`变量填充其`FormElement`字段。此时，我们已经为`contactForm`对象设置了表单参数。我们通过调用`env.Document`对象的`GetElementByID`方法并提供`id`为`"contactButton"`来获取联系表单的`button`元素。
- en: 'We add an event listener, on the click event of the contact `button`, which
    will call the `handleContactButtonClickEvent` function and pass the `env` object,
    the `event` object, and the `contactForm` object. The `handleContactButtonClickEvent`
    function is significant because it will run the form validation on the client-side,
    and if the validation is successful, it will initiate an XHR call to a Rest API
    endpoint on the server-side. Here''s the code for the `handleContactButtonClickEvent`
    function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在联系`button`的点击事件上添加了一个事件监听器，它将调用`handleContactButtonClickEvent`函数，并传递`env`对象、`event`对象和`contactForm`对象。`handleContactButtonClickEvent`函数非常重要，因为它将在客户端运行表单验证，如果验证成功，它将在服务器端发起XHR调用到Rest
    API端点。以下是`handleContactButtonClickEvent`函数的代码：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first thing that we do is suppress the default behavior of clicking the
    Contact button, which will submit the entire web form. This default behavior stems
    from the fact that the contact `button` element is an `input` element of type
    `submit`, whose default behavior when clicked is to submit the web form.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先抑制点击联系按钮的默认行为，这将提交整个网页表单。这种默认行为源于联系`button`元素是一个`input`类型为`submit`的元素，当点击时默认行为是提交网页表单。
- en: We then declare and initialize `clientSideValidationResult`, a Boolean variable,
    assigned to the result of calling the `Validate` method on the `contactForm` object.
    If the value of `clientSideValidationResult` is `false`, we reach the `else` block
    where we call the `DisplayErrors` method on the `contactForm` object. The `DisplayErrors`
    method is provided to us from the `BasicForm` type in the `isokit` package.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明并初始化`clientSideValidationResult`，一个布尔变量，赋值为调用`contactForm`对象的`Validate`方法的结果。如果`clientSideValidationResult`的值为`false`，我们进入`else`块，在那里调用`contactForm`对象的`DisplayErrors`方法。`DisplayErrors`方法是从`isokit`包中的`BasicForm`类型提供给我们的。
- en: If the value of the `clientSideValidationResult` is true, that means the form
    validated properly on the client side. At this point, the contact form submission
    has cleared the first round of validation on the client-side.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clientSideValidationResult`的值为true，这意味着表单在客户端成功验证。此时，联系表单提交已经通过了客户端的第一轮验证。
- en: To commence the second (and final) round of validation, we need to call the
    Rest API endpoint on the server-side, which is responsible for validating the
    contents of the form and rerun the same set of validations. We create a channel
    named `contactFormErrorsChannel`, which is channel that we'll send `map[string]string`
    values over. We call the `ContactFormSubmissionRequest` function as a goroutine,
    passing in the channel `contactFormErrorsChannel` and the `contactForm` object.
    The `ContactFormSubmissionRequest` function will initiate an XHR call to the server-side
    Rest API endpoint, to validate the contact form on the server-side. A `map` of
    errors will be sent over `contactFormErrorsChannel`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始第二（也是最后）一轮验证，我们需要调用服务器端的Rest API端点，负责验证表单内容并重新运行相同的验证。我们创建了一个名为`contactFormErrorsChannel`的通道，这是一个我们将通过其发送`map[string]string`值的通道。我们将`ContactFormSubmissionRequest`函数作为一个goroutine调用，传入通道`contactFormErrorsChannel`和`contactForm`对象。`ContactFormSubmissionRequest`函数将在服务器端发起XHR调用，验证服务器端的联系表单。一组错误将通过`contactFormErrorsChannel`发送。
- en: 'Let''s take a quick look at the `ContactFormSubmissionRequest` function before
    we return to the `handleContactButtonClickEvent` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在返回`handleContactButtonClickEvent`函数之前快速查看`ContactFormSubmissionRequest`函数：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `ContactFormSubmissionRequest` function, we JSON marshal the fields of
    the `contactForm` object and fire an XHR call to the web server by calling the
    `Send` function from the `xhr` package. We specify that the XHR call will be using
    the `POST` HTTP Method and will be posting to the `/restapi/contact-form` endpoint.
    We pass in the JSON-encoded data of the contact form fields as the final argument
    to the `Send` function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContactFormSubmissionRequest`函数中，我们对`contactForm`对象的字段进行JSON编组，并通过调用`xhr`包中的`Send`函数向Web服务器发出XHR调用。我们指定XHR调用将使用`POST`
    HTTP方法，并将发布到`/restapi/contact-form`端点。我们将联系表单字段的JSON编码数据作为`Send`函数的最后一个参数传入。
- en: If there were no errors in either the JSON marshaling process, or while making
    the XHR call, we obtain the data retrieved from the server and attempt to decode
    it from JSON format into the `contactFormErrors` variable. We then send the `contactFormErrors`
    variable over the channel, `contactFormErrorsChannel`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在JSON编组过程中或在进行XHR调用时没有错误，我们获取从服务器检索到的数据，并尝试将其从JSON格式解码为`contactFormErrors`变量。然后我们通过通道`contactFormErrorsChannel`发送`contactFormErrors`变量。
- en: 'Now, let''s return back to the `handleContactButtonClickEvent` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`handleContactButtonClickEvent`函数：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To prevent blocking within the event handler, we create and run an anonymous
    goroutine function. We receive the `map` of errors into the `serverContactFormErrors`
    variable, from `contactFormErrorsChannel`. The `serverSideValidationResult` Boolean
    variable is responsible for determining if there were errors in the contact form
    by examining the length of the errors `map`. If the length of the errors is zero
    that indicates there were no errors in the contact form submission. If the length
    is greater than zero that indicates that errors are present in the contact form
    submission.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在事件处理程序中发生阻塞，我们创建并运行一个匿名的goroutine函数。我们将错误的`map`接收到`serverContactFormErrors`变量中，从`contactFormErrorsChannel`中。`serverSideValidationResult`布尔变量负责通过检查错误`map`的长度来确定联系表单中是否存在错误。如果错误的长度为零，表示联系表单提交中没有错误。如果长度大于零，表示联系表单提交中存在错误。
- en: If the `severSideValidationResult` Boolean variable has a value of `true`, we
    call the `Render` method on the isomorphic template set to render the `contact_confirmation_content`
    template and we pass in the isomorphic template render parameters. In the `RenderParams`
    object, we set the `Data` field to `nil` because we won't be passing in any data
    object to the template. We specify the value `isokit.PlacementReplaceInnerContents`
    for the `Disposition` field to indicate that we will be performing a replace inner
    HTML operation on the associated element. We set the `Element` field to the associated
    element, the primary content `div` container, since this is where the template
    will render to.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`severSideValidationResult`布尔变量的值为`true`，我们在等同模板集上调用`Render`方法，渲染`contact_confirmation_content`模板，并传入等同模板渲染参数。在`RenderParams`对象中，我们将`Data`字段设置为`nil`，因为我们不会向模板传递任何数据对象。我们为`Disposition`字段指定值`isokit.PlacementReplaceInnerContents`，表示我们将对关联元素执行替换内部HTML操作。我们将`Element`字段设置为关联元素，即主要内容`div`容器，因为这是模板将要渲染到的位置。
- en: If the `serverSideValidationResult` Boolean variable has a value of `false`,
    that means the form still contains errors that need to be corrected. We call the
    `SetErrors` method on the `contactForm` object passing in the `serverContactFormErrors`
    variable. We then call the `DisplayErrors` method on the `contactForm` object
    to display the errors to the user.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`serverSideValidationResult`布尔变量的值为`false`，这意味着表单仍然包含需要纠正的错误。我们在`contactForm`对象上调用`SetErrors`方法，传入`serverContactFormErrors`变量。然后我们在`contactForm`对象上调用`DisplayErrors`方法，将错误显示给用户。
- en: We're just about done, the only item we have left to realizing the contact form
    on the client-side is implementing the server-side, Rest API endpoint that performs
    the second round of validation on the contact form submission.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了，我们在客户端实现联系表单的唯一剩下的事项是实现服务器端的Rest API端点，对联系表单提交进行第二轮验证。
- en: Contact form Rest API endpoint
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系表单Rest API端点
- en: 'Inside the `igweb.go` source file, we have registered the `/restapi/contact-form`
    endpoint and it''s associated handler function, `ContactFormEndpoint`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`igweb.go`源文件中，我们已经注册了`/restapi/contact-form`端点及其关联的处理函数`ContactFormEndpoint`：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `ContactFormEndpoint` function is responsible for servicing the `/restapi/contact-form`
    endpoint:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactFormEndpoint`函数负责为`/restapi/contact-form`端点提供服务：'
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The purpose of this function is to provide server-side validation of the contact-form
    and return a JSON-encoded `map` of errors. We create a variable `fields` of type
    `map[string]string` that represents the fields in the contact form. We read the
    request body, which will contain the JSON-encoded fields `map`. We then unmarshal
    the JSON-encoded fields `map` into the the `fields` variable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的目的是提供联系表单的服务器端验证，并返回JSON编码的错误`map`。我们创建一个`fields`变量，类型为`map[string]string`，表示联系表单中的字段。我们读取请求体，其中包含JSON编码的字段`map`。然后我们将JSON编码的字段`map`解封到`fields`变量中。
- en: We create a new `FormParams` instance and assign it to the variable `formParams`.
    In the `FormParams` struct, we specify the value of the `http.ResponseWriter`,
    `w`, for the `ResponseWriter` field, and the `*http.Request`, `r`, for the `Request`
    field. We set the `UseFormFieldsForValidation` field to `true`. Doing so will
    change the default behavior of fetching the form value for a particular field
    from the request, and instead the values for form fields will be obtained from
    the contact form's `formFields` `map`. Finally, we set the `FormFields` field
    to the `fields` variable, the `map` of fields that we JSON unmarshalled from the
    request body.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`FormParams`实例，并将其分配给变量`formParams`。在`FormParams`结构中，我们为`ResponseWriter`字段指定了`http.ResponseWriter`
    `w`的值，为`Request`字段指定了`*http.Request` `r`的值。我们将`UseFormFieldsForValidation`字段设置为`true`。这样做将改变默认行为，从请求中获取特定字段的表单值，而是从联系表单的`formFields`
    `map`中获取表单字段的值。最后，我们将`FormFields`字段设置为`fields`变量，即我们从请求体中JSON解组得到的字段`map`。
- en: We create a new `contactForm` object by calling the `NewContactForm` function
    and passing in a reference to the `formParams` object. To perform the server-side
    validation, we simply call the `Validate` method on the `contactForm` object and
    assign the result of the method call to the `validationResult` variable. Keep
    in mind that the same validation code present on the client-side is also present
    on the server-side, and there's really nothing special we're doing here, except
    invoking the validation logic from the server-side where presumably it cannot
    be tampered with.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`NewContactForm`函数并传入`formParams`对象的引用来创建一个新的`contactForm`对象。为了进行服务器端验证，我们只需在`contactForm`对象上调用`Validate`方法，并将方法调用的结果分配给`validationResult`变量。请记住，客户端上存在的相同验证代码也存在于服务器端，并且我们在这里并没有做什么特别的，只是从服务器端调用验证逻辑，假设它不会被篡改。
- en: If the value of `validationResult` is `true`, that means the contact form has
    cleared the second round of form validation on the server-side, and we can call
    the `ProcessContactForm` function in the `submissions` package, passing in the
    `env` object and the `contactForm` object. Remember when it comes to successfully
    validating the contact form, calling the `ProcessContactForm` function means we've
    reached the home plate and scored a run.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`validationResult`的值为`true`，这意味着联系表单已经通过了服务器端的第二轮表单验证，我们可以调用`submissions`包中的`ProcessContactForm`函数，传入`env`对象和`contactForm`对象。请记住，当成功验证联系表单时，调用`ProcessContactForm`函数意味着我们已经到达了本垒并得分。
- en: If the value of the `validationResult` is `false`, there is nothing special
    that we have to do. The `Errors` field of the `contactForm` object would have
    been populated after making a call to the object's `Validate` method. If there
    were no errors, the `Errors` field would just be an empty `map`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`validationResult`的值为`false`，我们无需做任何特别的事情。在调用对象的`Validate`方法后，`contactForm`对象的`Errors`字段将被填充。如果没有错误，`Errors`字段将只是一个空的`map`。
- en: We send a header to the client to indicate that the server will be sending a
    JSON object response. We then encode the errors `map` of the `contactForm` object
    into its JSON representation and write it out to the client using `http.ResponseWriter`,
    `w`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向客户端发送一个头部，指示服务器将发送JSON对象响应。然后，我们将`contactForm`对象的`map`错误编码为其JSON表示，并使用`http.ResponseWriter`
    `w`将其写入客户端。
- en: Checking the client-side validation
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查客户端验证
- en: 'We have everything in place now for the contact form''s client-side validation.
    Let''s open up the web browser with JavaScript enabled. Let''s also have the web
    inspector open to check for network calls, as shown in *Figure 7.18*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好联系表单的客户端验证。让我们打开启用了JavaScript的网络浏览器。同时打开网络检查器以检查网络调用，如*图7.18*所示：
- en: '![](img/04e8698f-932b-4309-b907-865893dce865.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04e8698f-932b-4309-b907-865893dce865.png)'
- en: 'Figure 7.18: The contact form with the web inspector open'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：打开网络检查器的联系表单
- en: 'First, we will partially fill out the contact form, as shown in *Figure 7.19*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将部分填写联系表单，如*图7.19*所示：
- en: '![](img/f3669cae-46e7-40b5-9798-c6bdc4871dd7.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3669cae-46e7-40b5-9798-c6bdc4871dd7.png)'
- en: 'Figure 7.19: The contact form filled out improperly'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：填写不正确的联系表单
- en: 'Upon clicking on the Contact button, we will trigger the form validation errors
    on the client side, as shown in *Figure 7.20*. Note that as we do so, no network
    calls are made to the server, no matter how many times we click on the Contact
    button:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 点击联系按钮后，我们将在客户端触发表单验证错误，如*图7.20*所示。请注意，当我们这样做时，无论我们点击联系按钮多少次，都不会向服务器发出网络调用：
- en: '![](img/46be4e96-7be7-489e-a45e-c3c341c622e4.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46be4e96-7be7-489e-a45e-c3c341c622e4.png)'
- en: 'Figure 7.20: Error messages are displayed after performing client-side validation.
    Note that there are no network calls made to the server'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：执行客户端验证后显示错误消息。请注意，没有向服务器发出网络调用
- en: 'Now, let''s correct the errors present in the contact form (as shown in *Figure
    7.21*) and get ready to resubmit:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们纠正联系表单中的错误（如*图7.21*所示）并准备重新提交：
- en: '![](img/e9b46ccf-8c67-429b-9be5-f65af141f8d3.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9b46ccf-8c67-429b-9be5-f65af141f8d3.png)'
- en: 'Figure 7.21: The contact form filled out properly and ready for resubmission'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21：填写完整的联系表单，准备重新提交
- en: 'Upon resubmission of the form, we receive the confirmation message, as shown
    *Figure 7.22*:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重新提交表单后，我们收到确认消息，如*图7.22*所示：
- en: '![](img/4cc80308-7acd-4d2f-a7ad-a8a6668cddb0.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cc80308-7acd-4d2f-a7ad-a8a6668cddb0.png)'
- en: 'Figure 7.22: An XHR call is made containing the form data, and the confirmation
    message is rendered upon successful server-side form validation'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22：进行XHR调用，包含表单数据，并在成功的服务器端表单验证后呈现确认消息
- en: 'Note that an XHR call was initiated to the web server, as shown in *Figure
    7.23*. Examining the response of the call, we can see that the empty object (`{}`)
    returned from the endpoint''s response, indicates that the `errors` `map` is empty,
    signifying a successful form submission:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如*图7.23*所示，发起了一个XHR调用到Web服务器。检查调用的响应，我们可以看到从端点响应返回的空对象（`{}`）表示`errors` `map`为空，表明表单提交成功：
- en: '![](img/e687cd4e-0305-4735-aba2-9ba6cdec6b17.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e687cd4e-0305-4735-aba2-9ba6cdec6b17.png)'
- en: 'Figure 7.23: The XHR call responded with an empty errors map, indicating that
    the form successfully cleared the server-side form validation'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23：XHR调用返回了一个空的错误映射，表明表单成功通过了服务器端的表单验证
- en: Now that we have verified that the client-side validation logic is working on
    the contact form, we must emphasize a significant point that is important when
    accepting data from the  client-side. The server must always hold the veto power,
    when it comes to validating user-entered data. The round two validation performed
    on the server-side should be a mandatory step. Let's take a look at why we always
    need server-side validation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了客户端验证逻辑在联系表单上的工作，我们必须强调一个重要的观点，即在接受来自客户端的数据时非常重要的一点。服务器必须始终拥有否决权，当涉及到验证用户输入的数据时。在服务器端执行的第二轮验证应该是一个强制性的步骤。让我们看看为什么我们总是需要服务器端验证。
- en: Tampering with the client-side validation result
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 篡改客户端验证结果
- en: 'Let''s consider the scenario, where we have a nefarious (and clever) user who
    knows how to short circuit our client-side validation logic. It''s JavaScript
    after all, and it''s running in the web browser. There''s really nothing to stop
    a malicious user from throwing our client-side validation logic to the wind. To
    simulate such a tampering event, we simply need to assign the Boolean value of
    `true` to the `clientSideValidationResult` variable in the `contact.go` source
    file like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这样一种情况，即我们有一个邪恶（而且聪明）的用户，他知道如何绕过我们的客户端验证逻辑。毕竟，这是JavaScript，在Web浏览器中运行。没有什么能阻止一个恶意用户将我们的客户端验证逻辑抛到脑后。为了模拟这样的篡改事件，我们只需要在`contact.go`源文件中将`clientSideValidationResult`变量的布尔值赋值为`true`。
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: At this point, we have bypassed the real result of the client-side validation,
    and we are forcing the client-side web application to always green light the contact
    form validation performed on the client-side. If we were solely performing form
    validation on the client-side, this would put us in a very bad situation. This
    is exactly the reason why, we need the second round of validation on the server-side.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经绕过了客户端验证的真正结果，强制客户端网络应用程序始终通过客户端进行的联系表单验证。如果我们仅在客户端执行表单验证，这将使我们陷入非常糟糕的境地。这正是为什么我们需要在服务器端进行第二轮验证的原因。
- en: 'Let''s open up the web browser and partially fill out the form again, as shown
    in *Figure 7.24*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开Web浏览器，部分填写表单，如*图7.24*所示：
- en: '![](img/b39c09da-a4a1-4b4b-85a2-c134c6b018b0.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b39c09da-a4a1-4b4b-85a2-c134c6b018b0.png)'
- en: 'Figure 7.24: Even after disabling the client-side form validation, the server-side
    form validation prevents the improperly filled out contact form from being submitted'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24：即使禁用了客户端表单验证，服务器端表单验证也阻止了填写不正确的联系表单被提交
- en: 'Note that this time, when the Contact button is clicked, the XHR call is initiated
    to the Rest API endpoint on the server-side, which returns `map` of errors in
    the contact form, as shown in *Figure 7.25*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次，当单击联系按钮时，将发起XHR调用到服务器端的Rest API端点，返回联系表单中的错误`map`，如*图7.25*所示：
- en: '![](img/c04dd7ed-d608-4d0a-8f1a-08631d008d15.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c04dd7ed-d608-4d0a-8f1a-08631d008d15.png)'
- en: 'Figure 7.25: The errors map from the server response is populated with an error
    indicating that the value entered in the email address field has an improper syntax'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25：服务器响应中的错误映射填充了一个错误，指示电子邮件地址字段中输入的值具有不正确的语法
- en: The second round of validation, performed on the server-side, has kicked in,
    and it prevented the malicious user from being able to reach home plate and score
    a run. If the client-side validation is unable to properly function, that incomplete
    or incorrectly formatted form field will be caught by the server-side validation.
    This is a major reason, why you should always implement server-side form validation
    for your web forms.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端执行的第二轮验证已经启动，并阻止了恶意用户能够到达本垒并得分。如果客户端验证无法正常工作，服务器端验证将捕获到不完整或格式不正确的表单字段。这是为什么您应该始终为您的网络表单实现服务器端表单验证的一个重要原因。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we demonstrated the process of building an accessible, isomorphic
    web form. First, we demonstrated the flow of the isomorphic web form in both the
    scenario where JavaScript was disabled and in the scenario where JavaScript was
    enabled.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们演示了构建一个可访问的、同构的网络表单的过程。首先，我们演示了同构网络表单在禁用JavaScript和启用JavaScript的情况下的流程。
- en: We showed you how to create an isomorphic web form, which had the ability to
    share both form code as well as validation logic across environments. In the scenario
    where the form contained errors, we showed you how to display the errors to the
    user in a meaningful manner. The isomorphic web form created was quite robust
    and being able to function, both, in the scenario where JavaScript was either
    disabled in the web browser, or a JavaScript runtime didn't exist (such as the
    Lynx web browser), and in the scenario where JavaScript was enabled in the web
    browser.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您展示了如何创建一个同构的网络表单，它具有在各种环境中共享表单代码和验证逻辑的能力。在表单包含错误的情况下，我们向您展示了如何以有意义的方式向用户显示错误。创建的同构网络表单非常健壮，并能够在Web浏览器中禁用JavaScript或JavaScript运行时不存在的情况下（例如Lynx
    Web浏览器），以及在启用JavaScript的Web浏览器中运行。
- en: We demonstrated testing the accessible, isomorphic web form using the Lynx web
    browser, to verify that the form would be available to users in need of greater
    accessibility. We also verified that the form functioned properly, even with JavaScript
    disabled, in a web browser that was equipped with a JavaScript runtime.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了使用Lynx网络浏览器测试可访问的同构网络表单，以验证该表单对需要更大可访问性的用户是否可用。我们还验证了即使在一个配备了JavaScript运行时的网络浏览器中，该表单也能正常运行，即使JavaScript被禁用。
- en: In the scenario that JavaScript was enabled in the web browser, we showed you
    how to validate the form on the client-side and submit the data to a Rest API
    endpoint after performing client-side validation. Even with the convenience and
    heightened capability of validating the form on the client-side, we emphasized
    the importance of always validating the form on the server-side, by demonstrating
    a scenario where the server-side form validation kicked in, even in the potential
    scenario that the client-side validation result was tampered with.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript启用的情况下，我们向您展示了如何在客户端验证表单并在执行客户端验证后将数据提交到Rest API端点。即使在方便且具有更高能力的客户端验证表单的情况下，我们强调了始终在服务器端验证表单的重要性，通过演示服务器端表单验证启动的情景，即使在潜在的情况下，客户端验证结果被篡改。
- en: The interaction between the user and the contact form was fairly simple. The
    user had to fill out the form correctly in order to submit the data to the server,
    where ultimately the form data was processed. In the next chapter, we are going
    to go beyond this simple interaction and consider a scenario where the user and
    the web application engage in communication, in an almost conversation-like manner.
    In [Chapter 8](38c071ef-d44c-452c-80dd-0b76837cc5e8.xhtml), *Real-time Web Application
    Functionality*, we will implement IGWEB's live chat feature, which allows the
    website user to engage in a simple question and answer conversation with a chatbot.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与联系表单之间的交互非常简单。用户必须正确填写表单才能将数据提交到服务器，最终表单数据将被处理。在下一章中，我们将超越这种简单的交互，考虑用户和网络应用程序以一种几乎类似对话的方式进行交流的情景。在[第8章](38c071ef-d44c-452c-80dd-0b76837cc5e8.xhtml)中，《实时网络应用功能》，我们将实现IGWEB的实时聊天功能，允许网站用户与聊天机器人进行简单的问答对话。
