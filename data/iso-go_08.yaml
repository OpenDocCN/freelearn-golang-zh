- en: Real-Time Web Application Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时Web应用功能
- en: In the previous chapter, we considered how we could validate and process user-generated
    data through a web form. When the user properly filled out the contact form, it
    successfully cleared two rounds of validation, and the user was presented with
    a confirmation message. Once the form had been submitted, the workflow was complete.
    What if we wanted to consider a more engaging workflow, one where the user could
    engage with the server-side application, perhaps, in a conversation-like manner?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们考虑了如何通过Web表单验证和处理用户生成的数据。当用户正确填写联系表单时，它成功通过了两轮验证，并且用户会收到确认消息。一旦表单被提交，工作流程就完成了。如果我们想考虑一个更有吸引力的工作流程，一个用户可以以对话的方式与服务器端应用程序进行交互的工作流程呢？
- en: The web of today is far different from the nascent web that Tim Berners-Lee
    devised in the early 1990s. Back then, the emphasis on the Web was to hyperlink
    connected documents. The HTTP transaction between the client and the server had
    always meant to be short-lived.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的Web与蒂姆·伯纳斯-李（Tim Berners-Lee）在1990年代初设计的起步阶段的Web大不相同。当时，Web的重点是超链接连接的文档。客户端和服务器之间的HTTP事务一直意味着短暂存在。
- en: In the early 2000s, this started to change. Researchers demonstrated the means
    by which the server could maintain a persistent connection with the client. Early
    prototypes on the client side were created using Adobe Flash, one of the only
    technologies available at the time, to make a persistent connection between the
    web server and the web client.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在21世纪初，这种情况开始发生变化。研究人员展示了服务器如何能够与客户端保持持久连接的手段。客户端的早期原型是使用Adobe Flash创建的，这是当时唯一可用的技术之一，用于在Web服务器和Web客户端之间建立持久连接。
- en: In parallel to these early attempts, an era of inefficiency was born in the
    form of AJAX (XHR) long polling. The client would keep making calls to the server
    (similar to a heartbeat check), and check whether the state of something the client
    was interested in had changed. The server would return the same, tired response
    until the state that the client was interested in changed, which could be reported
    back to the client. The major inefficiency of this approach is the sheer amount
    of network calls that have to be made between the web client and the web server.
    Unfortunately, the inefficient practice of AJAX long polling became so popular,
    that it is still widely used by many websites today.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些早期尝试并行的是，一种效率低下的时代诞生了，即AJAX（XHR）长轮询。客户端将继续向服务器发出调用（类似于心跳检查），并检查客户端感兴趣的某些状态是否发生了变化。服务器将返回相同的、疲惫的响应，直到客户端感兴趣的状态发生变化，然后可以将其报告给客户端。这种方法的主要低效性在于Web客户端和Web服务器之间必须进行的网络调用数量。不幸的是，AJAX长轮询的低效做法变得如此流行，以至于今天仍被许多网站广泛使用。
- en: The idea behind real-time web application functionality is to provide a far
    greater user experience by providing information in near real-time. Keep in mind
    that with network latency and the limitations on signals imposed by the laws of
    physics, no communication is ever conducted in *real time* but ,rather, in *near
    real time*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实时Web应用功能的理念是通过几乎实时地提供信息来提供更好的用户体验。请记住，由于网络延迟和物理定律对信号的限制，没有任何通信是真正的“实时”，而是“几乎实时”。
- en: The primary ingredient to implement real-time web application functionality
    is the WebSocket, a protocol allowing for bidirectional communication between
    the web server and the web client. Go makes for an ideal programming language
    to implement real-time web applications due to the built-in capabilities it possesses
    for both networking and web programming.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实现实时Web应用功能的主要组成部分是WebSocket，这是一种允许Web服务器和Web客户端之间进行双向通信的协议。由于Go具有用于网络和Web编程的内置功能，因此Go是实现实时Web应用程序的理想编程语言。
- en: In this chapter, we will build a live chat application that demonstrates real-time
    web application functionality, which will allow the website user to converse with
    a rudimentary chatbot. As the user asks questions to the bot, the bot will respond
    in real time, and all communication between the user and the bot will be performed
    over a  WebSocket connection between the web browser and the web server.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个实时Web应用程序功能的实时聊天应用程序，这将允许网站用户与一个基本的聊天机器人进行对话。当用户向机器人提问时，机器人将实时回复，并且用户与机器人之间的所有通信都将通过Web浏览器和Web服务器之间的WebSocket连接进行。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The live chat feature
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时聊天功能
- en: Implementing the live chat's server-side functionality
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现实时聊天的服务器端功能
- en: Implementing the live chat's client-side functionality
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现实时聊天的客户端功能
- en: Conversing with the agent
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与代理进行对话
- en: The live chat feature
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时聊天功能
- en: It's common nowadays to see chatbots (also known as agents) service the needs
    of website users for a wide variety of purposes, from deciding what shoes to purchase
    to providing tips on what stocks would look good on a client's portfolio, for
    example. We will build a rudimentary chatbot, that will provide some friendly
    tips on Isomorphic Go to IGWEB users.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当今，很常见看到聊天机器人（也称为代理）为网站用户提供各种目的的服务，从决定购买什么鞋子到提供有关哪些股票适合客户投资组合的建议。我们将构建一个基本的聊天机器人，为IGWEB用户提供有关同构Go的友好提示。
- en: Once the live chat feature is activated, the user can continue to access different
    sections of the website without having their conversation with the bot interrupted,
    provided that the user utilizes the navigation menu on the website or links found
    on the website that are routed on the client side. In a real-world scenario, this
    functionality would be an attractive proposition for both product sales and technical
    support usage scenarios. For instance, if a user has a particular question on
    a product listed on the website, the user can freely browse through the website,
    without worrying about losing their current chat conversation with the agent.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活了实时聊天功能，用户可以继续访问网站的不同部分，而不会因为使用网站上的导航菜单或链接而中断与机器人的对话。在现实世界的场景中，这种功能对于产品销售和技术支持的使用场景都是一个有吸引力的选择。例如，如果用户对网站上列出的某个产品有疑问，用户可以自由浏览网站，而不必担心失去与代理人的当前聊天对话。
- en: Keep in mind that the agent that we will build has a low intelligence level.
    The agent is presented here for illustration purposes only, and a far more robust
    **Artificial Intelligence** (**AI**) solution should be utilized for production
    needs. With the knowledge you will gain from this chapter, it should be fairly
    straightforward to replace the current agent's brain with a more robust one that
    will meet your specific needs in the live chat feature.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们将构建的代理具有较低的智能水平。这里仅用于说明目的，并且在生产需求中应该使用更健壮的**人工智能**（**AI**）解决方案。通过本章您将获得的知识，应该可以相当轻松地用更健壮的代理的大脑替换当前的代理，以满足实时聊天功能中的特定需求。
- en: Designing the live chatbox
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计实时聊天框
- en: 'The following diagram is a wireframe design depicting the top bar of IGWEB.
    The icon at the far right, will active the live chat feature when it is clicked
    on:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是IGWEB顶部栏的线框设计。最右边的图标在点击时将激活实时聊天功能：
- en: '![](img/8e3c6a10-56a1-4066-919b-6f8bd0060092.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e3c6a10-56a1-4066-919b-6f8bd0060092.jpg)'
- en: 'Figure 8.1: Wireframe design depicting IGWEB''s top bar'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：IGWEB顶部栏的线框设计
- en: 'The following diagram is a wireframe design depicting the live chat box. The
    chat box consists of an avatar image of the agent named "Case" along with its
    name and title. A close button is included in the top-right corner of the chat
    box. Users may enter their message to the agent in the bottom text area that has
    the placeholder text Type your message here. The conversation with the human and
    the bot will be presented in the middle area of the chat box:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是实时聊天框的线框设计。聊天框包括代理人“Case”的头像图像以及其姓名和职称。关闭按钮包括在聊天框的右上角。用户可以在底部文本区域输入他们的消息，该区域具有占位文本“在此输入您的消息”。与人类和机器人的对话将显示在聊天框的中间区域：
- en: '![](img/882b8a7c-655f-4dd8-9e42-da1d856c53d8.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/882b8a7c-655f-4dd8-9e42-da1d856c53d8.png)'
- en: 'Figure 8.2: Wireframe design of the live chat box'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：实时聊天框的线框设计
- en: Implementing the live chat box templates
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实时聊天框模板
- en: 'In order to have the chat box present in all sections of the website, we will
    need to place the chat box `div` container right below the primary content `div` container
    in the web page layout template (`layouts/webpage_layout.tmpl`):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在网站的所有部分中都有聊天框，我们需要将聊天框`div`容器放置在网页布局模板（`layouts/webpage_layout.tmpl`）中主要内容`div`容器的正下方：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The chat box will be implemented as a partial template in the `chatbox_partial.tmpl`
    source file in the `shared/templates/partials` folder:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天框将作为`shared/templates/partials`文件夹中的`chatbox_partial.tmpl`源文件中的部分模板来实现：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the HTML markup required to implement the wireframe design depicted
    in *Figure 8.2* of the live chat box. Note that the `input` textfield having the
    id `"chatboxInputField"`. This is the `input` field where the user will be able
    to type their message. Each message created, both the one that the user writes,
    as well as the one that the bot writes, will use the `livechatmsg_partial.tmpl`
    template:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现实时聊天框*图8.2*中所示线框设计所需的HTML标记。请注意，`input`文本字段具有id`"chatboxInputField"`。这是用户将能够输入其消息的`input`字段。创建的每条消息，无论是用户编写的消息还是机器人编写的消息，都将使用`livechatmsg_partial.tmpl`模板：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each message is inside its own `div` container that has two `div` containers
    (shown in bold) housing the name of the sender of the message and the message
    itself.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息都在自己的`div`容器中，其中有两个`div`容器（以粗体显示），分别包含消息发送者的姓名和消息本身。
- en: There are no buttons necessary in the live chat feature, since we will be adding
    an event listener to listen for the press of the Enter key to submit the user's
    message to the server over the WebSocket connection.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时聊天功能中不需要按钮，因为我们将添加一个事件侦听器来监听按下Enter键以通过WebSocket连接将用户的消息提交到服务器。
- en: Now that we've implemented the HTML markup that will be used to render the chat
    box, let's examine the functionality required to implement the live chat feature
    on the server side.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了用于呈现聊天框的HTML标记，让我们来检查在服务器端实现实时聊天功能所需的功能。
- en: Implementing the live chat's server-side functionality
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实时聊天的服务器端功能
- en: 'When the live chat feature is activated, we will create a persistent, WebSocket
    connection, between the web client and the web server.  The Gorilla Web Toolkit
    provides an excellent implementation of the WebSocket protocol in their `websocket`
    package, which can be found at [http://github.com/gorilla/websocket](http://github.com/gorilla/websocket).
    To fetch the `websocket` package, you may issue the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当实时聊天功能激活时，我们将在Web客户端和Web服务器之间创建一个持久的WebSocket连接。Gorilla Web Toolkit在其`websocket`包中提供了对WebSocket协议的出色实现，该包可以在[http://github.com/gorilla/websocket](http://github.com/gorilla/websocket)找到。要获取`websocket`包，可以发出以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Gorilla web toolkit also provides a useful example web chat application:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla Web Toolkit还提供了一个有用的示例Web聊天应用程序：
- en: '[https://github.com/gorilla/websocket/tree/master/examples/chat](https://github.com/gorilla/websocket/tree/master/examples/chat).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/gorilla/websocket/tree/master/examples/chat](https://github.com/gorilla/websocket/tree/master/examples/chat)。'
- en: Rather than reinventing the wheel, we will repurpose Gorilla's example web chat
    application to fulfill the live chat feature. The source files needed from the
    web chat example have been copied over to the `chat` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新利用大猩猩的示例网络聊天应用程序，而不是重新发明轮子，以实现实时聊天功能。从网络聊天示例中需要的源文件已经复制到`chat`文件夹中。
- en: 'There are three major changes we need to make to realize the live chat feature
    using the example chat application provided by Gorilla:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行三个重大改变，以利用大猩猩提供的示例聊天应用程序实现实时聊天功能：
- en: Replies from the chatbot (the agent) should be targeted to a specific user,
    and not be sent out to every connected user
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天机器人（代理）的回复应该针对特定用户，而不是发送给所有连接的用户
- en: We need to create the functionality to allow the chatbot to send a message back
    to the user
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要创建功能，允许聊天机器人向用户发送消息
- en: We need to implement the front-end portion of the chat application in Go
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在Go中实现聊天应用程序的前端部分
- en: Let's consider each of these three points in more detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地考虑这三点。
- en: First, Gorilla's web chat example is a free-for-all chat room. Any user can
    come in, type a message, and all other users connected to the chat server will
    be able to see the message. A major requirement for the live chat feature is that
    each conversation between the chatbot and the human should be exclusive. Replies
    from the agent must be targeted to a specific user, and not to all connected users.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，大猩猩的网络聊天示例是一个自由聊天室。任何用户都可以进来，输入消息，所有连接到聊天服务器的其他用户都能看到消息。实时聊天功能的一个主要要求是，聊天机器人和人之间的每次对话都应该是独占的。代理的回复必须针对特定用户，而不是所有连接的用户。
- en: Second, the example web chat application from the Gorilla web toolkit doesn't
    send any messages back to the user. This is where the custom chatbot comes into
    the picture. The agent will communicate directly with the user over the established
    WebSocket connection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，大猩猩网络工具包中的示例网络聊天应用程序不会向用户发送任何消息。这就是自定义聊天机器人出现的地方。代理将直接通过已建立的WebSocket连接与用户通信。
- en: Third, the front-end portion of the example web chat application is implemented
    as a HTML document containing inline CSS and JavaScript. As you may have guessed
    already, we will implement the front-end portion for the live chat feature in
    Go, and the code will reside in the `client/chat` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，示例网络聊天应用程序的前端部分是作为包含内联CSS和JavaScript的HTML文档实现的。正如你可能已经猜到的那样，我们将在Go中实现实时聊天功能的前端部分，代码将驻留在`client/chat`文件夹中。
- en: Now that we have established our plan of action to implement the live chat feature
    using the Gorilla web chat example as a foundation to start from, let's begin
    the implementation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经制定了使用大猩猩网络聊天示例作为起点来实现实时聊天功能的行动计划，让我们开始实施吧。
- en: 'The modified web chat application that we will create contains two main types:
    `Hub` and `Client`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的修改后的网络聊天应用程序包含两种主要类型：`Hub`和`Client`。
- en: The hub type
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中心类型
- en: The chat hub is responsible for maintaining a list of client connections and
    directing the chatbot to broadcast a message to the relevant client. For example,
    if Alice asked the question "What is Isomorphic Go?*"*, the answer from the chatbot
    should go to Alice and not to Bob (who may not have even asked a question yet).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天中心负责维护客户端连接列表，并指示聊天机器人向相关客户端广播消息。例如，如果Alice问了“什么是同构Go?*”，聊天机器人的答案应该发给Alice，而不是Bob（他可能还没有问问题）。
- en: 'Here''s what the `Hub` struct looks like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hub`结构如下：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `chatbot` is a chat bot (agent) that implements the `Bot` interface. This
    is the brain that will answer the questions received from clients.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`chatbot`是一个实现`Bot`接口的聊天机器人（代理）。这是将回答从客户端收到的问题的大脑。'
- en: 'The `clients` map is used to register clients. The key-value pair stored in
    the `map` consists of the key, a pointer to a `Client` instance, and the value
    consists of a Boolean value set to `true` to indicate that the client is connected.
    Clients communicate with the hub over the `broadcastmsg`, `register`, and `unregister`
    channels. The `register` channel registers a client with the hub. The `unregister`
    channel, unregisters a client with the hub. The client sends the message entered
    by the user over the `broadcastmsg` channel, a channel of type `ClientMessage`.
    Here''s the `ClientMessage` struct that we have introduced:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`clients`映射用于注册客户端。存储在`map`中的键值对包括键，指向`Client`实例的指针，值包括一个布尔值，设置为`true`，表示客户端已连接。客户端通过`broadcastmsg`、`register`和`unregister`通道与中心通信。`register`通道向中心注册客户端。`unregister`通道向中心注销客户端。客户端通过`broadcastmsg`通道发送用户输入的消息，这是一个`ClientMessage`类型的通道。这是我们引入的`ClientMessage`结构：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To fulfill the first major change we laid out previously, that is, the exclusivity
    of the conversation between the agent and the user, we use the `ClientMessage`
    struct to store, both the pointer to the `Client` instance that sent the user's
    message along with the user's message itself (a `byte` slice).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们之前提出的第一个重大变化，即代理和用户之间的对话的独占性，我们使用`ClientMessage`结构来存储`Client`实例的指针，以及用户的消息本身（一个`byte`切片）。
- en: 'The constructor function, `NewHub`, takes in `chatbot` that implements the
    `Bot` interface and returns a new `Hub` instance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数`NewHub`接受实现`Bot`接口的`chatbot`，并返回一个新的`Hub`实例：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We implement an exported getter method, `ChatBot`, so that the `chatbot` can
    be accessed from the `Hub` object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个导出的获取方法`ChatBot`，以便从`Hub`对象中访问`chatbot`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This action will be significant when we implement a Rest API endpoint to send
    the bot's details (its name, title, and avatar image) to the client.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现一个Rest API端点来将机器人的详细信息（名称、标题和头像图像）发送给客户端时，这个行动将是重要的。
- en: 'The `SendMessage` method is responsible for broadcasting a message to a particular
    client:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendMessage`方法负责向特定客户端广播消息：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method takes in a pointer to `Client`, and the `message`, which is a `byte`
    slice, that should be sent to that particular client. The message will be sent
    over the client's `send` channel.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个指向`Client`的指针和`message`，这是应该发送给特定客户端的`byte`切片。消息将通过客户端的`send`通道发送。
- en: 'The `Run` method is called to start the chat hub:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Run`方法启动聊天hub：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We use the `select` statement inside the `for` loop to wait on multiple client
    operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`for`循环内使用`select`语句等待多个客户端操作。
- en: In the case that a pointer to a `Client` comes in over the hub's `register`
    channel, the hub will register the new client by adding the `client` pointer (as
    the key) to the clients `map` and set a value of `true` for it. We will fetch
    a `greeting` message to return to the client by calling the `Greeting` method
    on `chatbot`. Once we get the greeting (a string value), we call the `SendMessage`
    method passing in the `client` and the `greeting` converted to a `byte` slice.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过hub的`register`通道传入了一个`Client`的指针，hub将通过将`client`指针（作为键）添加到客户端`map`中并为其设置一个值为`true`来注册新客户端。我们将调用`chatbot`的`Greeting`方法获取要返回给客户端的`greeting`消息。一旦我们得到了问候语（字符串值），我们调用`SendMessage`方法，传入`client`和转换为`byte`切片的`greeting`。
- en: In the case that a pointer to a `Client` comes in over the hub's `unregister`
    channel, the hub will remove the entry in `map` for the given `client` and close
    the client's `send` channel, which signifies that the `client` won't be sending
    any more messages to the server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过hub的`unregister`通道传入了一个`Client`的指针，hub将删除给定`client`的`map`中的条目，并关闭客户端的`send`通道，这表示该`client`不会再向服务器发送任何消息。
- en: In the case that a pointer to a `ClientMessage` comes in over the hub's `broadcastmsg`
    channel, the hub will pass the client's `message` (as a string value) to the `Reply`
    method of the `chatbot` object. Once we get `reply` (a  string value) from the
    agent, we call the `SendMessage` method passing in the `client` and the `reply`
    converted to a `byte` slice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过hub的`broadcastmsg`通道传入了一个`ClientMessage`的指针，hub将把客户端的`message`（作为字符串值）传递给`chatbot`对象的`Reply`方法。一旦我们得到了来自代理的`reply`（字符串值），我们调用`SendMessage`方法，传入`client`和转换为`byte`切片的`reply`。
- en: The client type
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端类型
- en: The `Client` type acts as a broker between  `Hub` and the `websocket` connection.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client`类型充当`Hub`和`websocket`连接之间的代理。'
- en: 'Here''s what the `Client` struct looks like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Client`结构的样子：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each `Client` value contains a pointer to `Hub`, a pointer to a `websocket`
    connection, and a buffered channel, `send`, meant for outbound messages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Client`值都包含指向`Hub`的指针，指向`websocket`连接的指针以及用于出站消息的缓冲通道`send`。
- en: 'The `readPump` method is responsible for relaying inbound messages coming in
    over the `websocket` connection to the hub:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`readPump`方法负责将通过`websocket`连接传入的入站消息中继到hub：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We had to make a slight change to this function to fulfill the requirements
    of the live chat feature. In the Gorilla web chat example, the message alone was
    relayed over to `Hub`. Since we are directing chat bot responses, back to the
    client that sent them, not only do we need to send the message to the hub, but
    also the client that happened to send the message (shown in bold). We do so by
    creating a `ClientMessage` struct:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不对这个函数进行轻微的更改，以满足实时聊天功能的要求。在Gorilla Web聊天示例中，仅仅是将消息中继到`Hub`。由于我们正在将聊天机器人的响应发送回发送它们的客户端，我们不仅需要将消息发送到hub，还需要将发送消息的客户端也发送到hub。我们通过创建一个`ClientMessage`结构来实现这一点：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `ClientMessage` struct contains fields to hold both the pointer to the client
    as well as the `message`, a `byte` slice.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientMessage`结构包含字段，用于保存客户端的指针以及`message`，一个`byte`切片。'
- en: 'Going back to the `readPump` function in the `client.go` source file, the following
    two lines are instrumental in allowing the `Hub` to know which client sent the
    message:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`client.go`源文件中的`readPump`函数，以下两行对于`Hub`知道哪个客户端发送了消息至关重要。
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `writePump` method is responsible for relaying outbound messages from the
    client''s `send` channel over the `websocket` connection:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`writePump`方法负责从客户端的`send`通道中中继出站消息到`websocket`连接：'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ServeWS` method is meant to be registered as an HTTP handler by the web
    application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServeWS`方法旨在由Web应用程序注册为HTTP处理程序：'
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method performs two important tasks. The method upgrades the normal HTTP
    connection to a `websocket` connection and registers the client to the hub.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法执行两个重要任务。该方法将普通的HTTP连接升级为`websocket`连接，并将客户端注册到hub。
- en: Now that we've set up the code for our web chat server, it's time to activate
    it in our web application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的Web聊天服务器设置了代码，是时候在我们的Web应用程序中激活它了。
- en: Activating the chat server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活聊天服务器
- en: 'In the `igweb.go` source file, we have included a function called `startChatHub`,
    which is responsible for starting the `Hub`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`igweb.go`源文件中，我们包含了一个名为`startChatHub`的函数，它负责启动`Hub`：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We add the following code in the `main` function to create a new chatbot, associate
    it with the `Hub`, and start the `Hub`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main`函数中添加以下代码来创建一个新的chatbot，将其与`Hub`关联并启动`Hub`：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we call the `registerRoutes` function to register all the routes for the
    server-side web application, note that we also pass in the `hub` value to the
    function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`registerRoutes`函数为服务器端Web应用程序注册所有路由时，请注意我们还向函数传递了`hub`值：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `registerRoutes` function, we need the `hub` to register the route handler
    for the Rest API endpoint that returns the agent''s information:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`registerRoutes`函数中，我们需要`hub`来为返回代理信息的Rest API端点注册路由处理程序：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will go over this endpoint in the section, *Exposing the agent's information
    to the client*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*向客户端公开代理信息*部分介绍这个端点。
- en: 'The `hub` is also used to register the route handler for the WebSocket route,
    `/ws`. We register the `ServeWS` handler function, passing in the `hub`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`hub`还用于注册WebSocket路由`/ws`的路由处理程序。我们注册`ServeWS`处理程序函数，传入`hub`：'
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have everything in place to activate the chat server, it's time
    to focus on the star of the live chat feature—the chat agent.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好激活聊天服务器，是时候专注于实时聊天功能的明星——聊天代理了。
- en: The agent's brain
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理的大脑
- en: 'The chat bot type that we will use for the live chat feature, `AgentCase`,
    will implement the following `Bot interface`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于实现实时聊天功能的聊天机器人类型`AgentCase`将实现以下`Bot接口`：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Greeting` method will be used to send an initial greeting to the user,
    enticing them to interact with the chat bot.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeting`方法将用于向用户发送初始问候，诱使他们与聊天机器人互动。'
- en: The `Reply` method accepts a question (a string) and returns a reply (also a
    string) for the given question.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reply`方法接受一个问题（字符串），并返回给定问题的回复（也是一个字符串）。'
- en: The rest of the methods implemented are for purely psychological reasons to
    give humans the illusion that they are communicating with someone, rather than
    something.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其余实现的方法纯粹是出于心理原因，让人类产生与某人交流而不是某物的错觉。
- en: The `Name` method is a getter method that returns the chat bot's name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name`方法是一个getter方法，返回聊天机器人的名称。'
- en: The `Title` method is a getter method that returns the chat bot's title.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Title`方法是一个getter方法，返回聊天机器人的标题。'
- en: The `ThumbnailPath` method is a getter method that returns the path to the chat
    bot's avatar image.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThumbnailPath`方法是一个getter方法，返回聊天机器人的头像图像的路径。'
- en: 'Each of the getter methods has a corresponding setter method: `SetName`, `SetTitle`,
    and `SetThumbnailPath`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个getter方法都有一个对应的setter方法：`SetName`、`SetTitle`和`SetThumbnailPath`。
- en: By defining the `Bot` interface, we are clearly stating the expectations of
    a chat bot. This allows us to make the chat bot solution extensible in the future.
    For example, the intelligence that `Case` exhibits may be too rudimentary and
    limiting. In the near future, we may want to implement a bot named Molly, whose
    intelligence may be implemented using a more powerful algorithm. As long as the
    Molly chat bot implements the `Bot` interface, the new chat bot can be easily
    plugged into our web application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`Bot`接口，我们清楚地说明了聊天机器人的期望。这使我们能够在将来使聊天机器人解决方案具有可扩展性。例如，`Case`展示的智能可能过于基础和限制。在不久的将来，我们可能希望实现一个名为Molly的机器人，其智能可能使用更强大的算法实现。只要Molly聊天机器人实现了`Bot`接口，新的聊天机器人就可以轻松地插入到我们的Web应用程序中。
- en: In fact, from the perspective of the server-side web application, it would just
    be a one-line code change. Instead of instantiating an `AgentCase` instance, we
    would instantiate an `AgentMolly` instance instead. Besides the difference in
    intelligence, the new chat bot, Molly, would come with its own name, title, and
    avatar image, so humans would be able to differentiate it from `Case`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从服务器端Web应用程序的角度来看，这只是一行代码的更改。我们将实例化一个`AgentMolly`实例，而不是实例化一个`AgentCase`实例。除了智能上的差异，新的聊天机器人Molly将具有自己的名称、标题和头像图像，因此人类可以将其与`Case`区分开来。
- en: 'Here''s the `AgentCase` struct:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AgentCase`结构：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have embedded the `Bot` interface to the `struct` definition, indicating
    that the `AgentCase` type will implement the `Bot` interface. The field `name`
    is for the name of the agent. The field `title` is for the title of the agent.
    The field `thumbnailPath` is used to specify the path to the chat bot's avatar
    image.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`Bot`接口嵌入到`struct`定义中，表明`AgentCase`类型将实现`Bot`接口。`name`字段是代理的名称。`title`字段是代理的标题。`thumbnailPath`字段用于指定聊天机器人头像图像的路径。
- en: The `knowledgeBase` field is  `map` of type `map[string]string`. This is essentially
    the agent's brain. Keys in the `map` are the common terms found in a particular
    question. Values in the `map` are the answers to the question.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`knowledgeBase`字段是`map`类型的`map[string]string`。这本质上是代理的大脑。`map`中的键是特定问题中发现的常见术语。`map`中的值是问题的答案。'
- en: The `knowledgeCorpus` field, a string `byte` slice, is a knowledge corpus of
    the terms that may exist in questions that the bot will be asked. We use the keys
    of the `knowledgeBase` map to construct the `knowledgeCorpus`. A corpus is a collection
    of text that is used to conduct linguistic analysis. In our case, we will conduct
    the linguistic analysis based on the question (the query) that the human user
    provided to the bot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`knowledgeCorpus`字段是一个字符串`byte`切片，是机器人可能被问到的问题中存在的术语的知识语料库。我们使用`knowledgeBase`映射的键来构建`knowledgeCorpus`。语料库是用于进行语言分析的文本集合。在我们的情况下，我们将根据人类用户提供给机器人的问题（查询）进行语言分析。'
- en: The `sampleQuestions` field, a string `byte` slice, will contain a list of sample
    questions that the user may ask the chat bot. The chat bot will provide the user
    with a sample question when it greets them to entice the human user into a conversation.
    It is understood that the human user is free to paraphrase the sample question
    or ask an entirely different question depending on their preference.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleQuestions`字段是一个字符串`byte`切片，其中包含用户可能向聊天机器人提出的示例问题列表。聊天机器人在问候用户时将向用户提供一个示例问题，以诱使人类用户进行对话。人类用户可以根据自己的喜好自由地改写示例问题或提出完全不同的问题。'
- en: 'The `initializeIntelligence` method is used to initialize Case''s brain:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeIntelligence`方法用于初始化Case的大脑：'
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are three important tasks that occur within this method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中有三个重要的任务：
- en: First, we set Case's knowledge base.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们设置Case的知识库。
- en: Second, we set Case's knowledge corpus.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们设置Case的知识语料库。
- en: Third, we set the sample questions, which Case will utilize when greeting the
    human user.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们设置Case将在问候人类用户时使用的示例问题。
- en: 'The first task we must take care of is to set Case''s knowledge base. This
    consists of setting the `knowledgeBase` property of the `AgentCase` instance.
    As mentioned earlier, the keys in the `map` refer to terms found in the question,
    and the values in the `map` are the answers to the question. For example, the
    `"isomorphic go isomorphic go web applications"` key could service the following
    questions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理的第一个任务是设置Case的知识库。这包括设置`AgentCase`实例的`knowledgeBase`属性。如前所述，`map`中的键指的是问题中的术语，`map`中的值是问题的答案。例如，`"同构go同构go
    web应用程序"`键可以处理以下问题：
- en: What is Isomorphic Go?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是同构Go？
- en: What can you tell me about Isomorphic Go?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能告诉我关于同构Go的情况吗？
- en: 'It can also service statements that aren''t questions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以处理不是问题的陈述：
- en: Tell me about Isomorphic Go
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一下同构Go
- en: Give me the rundown on Isomorphic Go
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给我一个关于同构Go的概述
- en: Due to the the large amount of text contained within the map literal declaration
    for the `knowledgeBase` map, I encourage you to view the source file, `agentcase.go`,
    on a computer.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`knowledgeBase`映射的地图文字声明中包含大量文本，我建议您在计算机上查看源文件`agentcase.go`。
- en: The second task we must take care of is to set Case's corpus, the collection
    of text used for linguistic analysis used against the user's question. The corpus
    is constructed from the keys of the `knowledgeBase` map. We set the `knowledgeCorpus`
    field property of the `AgentCase` instance to a newly created string `byte` slice
    using the built-in `make` function. Using a `for` loop, we iterate through all
    the entries in the `knowledgeBase map` and append each key to the `knowledgeCorpus`
    field slice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理的第二个任务是设置Case的语料库，这是用于针对用户问题进行语言分析的文本集合。语料库是从`knowledgeBase`映射的键构造的。我们将`AgentCase`实例的`knowledgeCorpus`字段属性设置为使用内置的`make`函数创建的新的字符串`byte`切片。使用`for`循环，我们遍历`knowledgeBase
    map`中的所有条目，并将每个键附加到`knowledgeCorpus`字段切片中。
- en: The third and last task we must take care of is to set the sample questions
    that `Case` will present to the human user. We simply populate the `sampleQuestions`
    property of the `AgentCase` instance. We use the string literal declaration to
    populate all the sample questions that are contained in the string `byte` slice.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理的第三个也是最后一个任务是设置`Case`将呈现给人类用户的示例问题。我们简单地填充`AgentCase`实例的`sampleQuestions`属性。我们使用字符串文字声明来填充包含在字符串`byte`切片中的所有示例问题。
- en: 'Here are the getter and setter methods of the `AgentCase` type:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`AgentCase`类型的getter和setter方法：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These methods are used to get and set the name, title, and `thumbnailPath` fields
    of the `AgentCase` object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于获取和设置`AgentCase`对象的`name`，`title`和`thumbnailPath`字段。
- en: 'Here''s the constructor function used to create a new `AgentCase` instance:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于创建新的`AgentCase`实例的构造函数：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We declare and initialize the `agentCase` variable with a new `AgentCase` instance,
    setting the fields for `name`, `title`, and `thumbnailPath`. We then call the
    `initializeIntelligence` method to initialize Case's brain. Finally, we return
    the newly created and initialized `AgentCase` instance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化`agentCase`变量为一个新的`AgentCase`实例，设置`name`，`title`和`thumbnailPath`字段。然后我们调用`initializeIntelligence`方法来初始化Case的大脑。最后，我们返回新创建和初始化的`AgentCase`实例。
- en: Greeting the human
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问候人类
- en: 'The `Greeting` method is used to provide a first-time greeting to the user
    when the live chat feature is activated:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeting`方法用于在激活实时聊天功能时向用户提供首次问候：'
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since the greeting will include a randomly selected sample question that can
    be asked to Case, the `randomNumber` function is called to obtain the index number
    of the sample question. We pass the minimum value and the maximum value to the
    `randomNumber` function to specify the range that the produced random number should
    be in.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于问候将包括一个可以问Case的随机选择的示例问题，因此调用`randomNumber`函数来获取示例问题的索引号。我们将最小值和最大值传递给`randomNumber`函数，以指定生成的随机数应该在的范围内。
- en: 'Here''s the `randomNumber` function used to generate a random number within
    a given range:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`randomNumber`函数用于生成给定范围内的随机数：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Returning to the `Greeting` method, we get the sample question retrieved from
    the `sampleQuestions` string slice using the random index. We then assign the
    sample question to the `greeting` variable and return `greeting`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Greeting`方法，我们使用随机索引从`sampleQuestions`字符串切片中检索示例问题。然后我们将示例问题分配给`greeting`变量并返回`greeting`。
- en: Replying to a human's question
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答人类的问题
- en: Now that we've initialized the intelligence of the chat bot and prepared it
    to greet the human user, it's time to guide the chat bot on how to think about
    a user's question so that the chat bot may offer a sensible reply.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了聊天机器人的智能，并准备好迎接人类用户，是时候指导聊天机器人如何思考用户的问题，以便聊天机器人可以提供明智的回答了。
- en: The replies that the chat bot will send to the human user are limited to those
    found as the values in the `knowledgeBase` map of the `AgentCase` struct. If the
    human user asks a question outside the scope of what the chat bot knows (the knowledge
    corpus), it will simply reply with the message `"I don't know the answer to that
    one."`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人将发送给人类用户的回复仅限于`AgentCase`结构的`knowledgeBase`映射中的值。如果人类用户问的问题超出了聊天机器人所知道的范围（知识语料库），它将简单地回复消息“我不知道答案。”
- en: To analyze the user's question and provide the best reply for it, we will be
    using the `nlp` package, which contains a collection of machine learning algorithms
    that can be used for basic natural language processing.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分析用户的问题并为其提供最佳回复，我们将使用`nlp`包，其中包含一系列可用于基本自然语言处理的机器学习算法。
- en: 'You can install the `nlp` package by issuing the following `go get` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过发出以下`go get`命令来安装`nlp`包：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s go over the `Reply` method piece by piece, starting with the method
    declaration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解`Reply`方法，从方法声明开始：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The function takes in a question string and returns an answer string for the
    given question.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接收一个问题字符串，并返回给定问题的答案字符串。
- en: 'We declare the `result` variable that represents the answer to the user''s
    question:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明`result`变量，表示用户问题的答案：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `result` variable will be returned by the `Reply` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`变量将由`Reply`方法返回。'
- en: 'Using the `nlp` package, we create a new `vectoriser` and a new `transformer`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nlp`包，我们创建一个新的`vectoriser`和一个新的`transformer`：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The **`vectoriser`** will be used to encode the query terms from the knowledge
    corpus into a term document matrix, where each column will represent a document
    within the corpus, and each row represents a term. It is used to keep track of
    the frequency of terms found within a particular document. For our usage scenario,
    you may consider the document as the unique entry found in the `knowledgeCorpus`
    string slice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**`vectoriser`**将用于将知识语料库中的查询术语编码为术语文档矩阵，其中每列代表语料库中的一个文档，每行代表一个术语。它用于跟踪在特定文档中找到的术语的频率。对于我们的使用场景，您可以将文档视为在`knowledgeCorpus`字符串切片中找到的唯一条目。'
- en: The `transformer` will be used to remove bias of frequently appearing terms
    in `knowledgeCorpus` . For example, words that are repeated across `knowledgeCorpus`
    such as *the*, *and*, and *web* will have a lesser weight. The transformer is
    a **TFIDF (term frequency inverse document frequency)** transformer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`transformer`将用于消除`knowledgeCorpus`中频繁出现术语的偏差。例如，`knowledgeCorpus`中重复出现的单词，如*the*、*and*和*web*，将具有较小的权重。转换器是**TFIDF（词频逆文档频率）**转换器。'
- en: 'We then proceed to create `reducer`, which is a new `TruncatedSVD` instance:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续创建`reducer`，这是一个新的`TruncatedSVD`实例：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `reducer` that we just declared is significant, since we will be performing
    **Latent Semantic Analysis** (**LSA**), also known as **Latent Semantic Indexing**
    (**LSI**), for the search and retrieval of the proper document to the users's
    query term. LSA helps us find semantic attributes that exist within a corpus based
    on the co-occurrence of terms. It assumes that words that frequently appear together
    must have some semantic relation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚声明的`reducer`很重要，因为我们将执行**潜在语义分析**（**LSA**），也称为**潜在语义索引**（**LSI**），以搜索和检索与用户查询术语相匹配的正确文档。LSA帮助我们根据术语的共现来找到语料库中存在的语义属性。它假设频繁一起出现的单词必须具有一定的语义关系。
- en: The `reducer` is used to find semantic meaning that may be hidden beneath the
    term frequencies within the document feature vectors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducer`用于查找可能隐藏在文档特征向量中的术语频率下的语义含义。'
- en: 'The following code is a pipeline that transforms the corpus into a Latent Semantic
    Index, which fits the models to the documents:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个将语料库转换为潜在语义索引的管道，该索引适合于文档的模型：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have to run the user''s query through the same pipeline so that it is projected
    in the same dimensional space:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须通过相同的管道运行用户的查询，以便它在相同的维度空间中被投影：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have `lsi` and the `queryVector` in place, it is time to find the
    document that best matches the query term. We do so by calculating the cosine
    similarity of each document in our corpus against the query:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`lsi`和`queryVector`，是时候找到最匹配查询术语的文档了。我们通过计算我们语料库中每个文档与查询的余弦相似度来实现这一点：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The **cosine similarity** calculates the difference between the angles of two
    numerical vectors.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**余弦相似度**计算两个数值向量之间的角度差异。'
- en: The document in the corpus having the highest similarity with the user's query
    will be matched as the best document that reflects the user's question. The possible
    values for the cosine similarity can fall between the range of 0 to 1\. A 0 value
    indicates complete orthogonality and a 1 value indicates a perfect match. The
    cosine similarity value can also be a **NaN (not a number)** value. The NaN value
    is indicative that there is no match at all.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户查询具有最高相似度的语料库中的文档将被匹配为最能反映用户问题的最佳文档。余弦相似度的可能值可以在0到1的范围内。0值表示完全正交，1值表示完全匹配。余弦相似度值也可以是**NaN（不是数字）**值。NaN值表明根本没有匹配。
- en: 'The `highestSimilarity` value will be `-1` if no match was found; otherwise,
    it will be a value between 0 and 1:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配，`highestSimilarity`值将为`-1`；否则，它将是0到1之间的值：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `if` conditional block, we check whether the `highestSimilarity` value
    is `-1`; if it is, the answer to the user will be `"I don't know the answer to
    that one."`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`条件块中，我们检查`highestSimilarity`值是否为`-1`；如果是，用户的答案将是`"I don't know the answer
    to that one."`。
- en: If we reach the `else` block, it indicates that the `highestSimilarity` is a
    value between 0 and 1, indicating that a match was found. Recall that the document
    in our `knowledgeCorpus` has a corresponding key in the `knowledgeBase` `map`.
    The answer to the user's question is the value in the `knowledgeBase` `map` with
    the provided key, and we set the `result` string to this value. In the last line
    of code in the method, we return the `result` variable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达`else`块，表示`highestSimilarity`是0到1之间的值，表示找到了匹配。回想一下，我们`knowledgeCorpus`中的文档在`knowledgeBase`
    `map`中有对应的键。用户问题的答案是`knowledgeBase` `map`中提供的键的值，我们将`result`字符串设置为这个值。在方法的最后一行代码中，我们返回`result`变量。
- en: The logic to implement the chatbot's intelligence was inspired from James Bowman's
    article, *Semantic analysis of webpages with machine learning in Go* ([http://www.jamesbowman.me/post/semantic-analysis-of-webpages-with-machine-learning-in-go/](http://www.jamesbowman.me/post/semantic-analysis-of-webpages-with-machine-learning-in-go/)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实现聊天机器人智能的逻辑是受到James Bowman的文章《在Go中使用机器学习进行网页的语义分析》的启发（[http://www.jamesbowman.me/post/semantic-analysis-of-webpages-with-machine-learning-in-go/](http://www.jamesbowman.me/post/semantic-analysis-of-webpages-with-machine-learning-in-go/)）。
- en: Exposing the agent's information to the client
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向客户端公开代理的信息
- en: Now that we've implemented the chat agent, `AgentCase`, we need a way to expose
    Case's information to the client, notably, its name, title, and the path to its
    avatar image.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了聊天代理`AgentCase`，我们需要一种方法将Case的信息暴露给客户端，特别是其名称、标题和头像图像的路径。
- en: 'We create a new Rest API endpoint, `GetAgentInfoEndpoint`, to expose the chat
    agent''s information to the client-side web application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的Rest API端点`GetAgentInfoEndpoint`，以向客户端Web应用程序公开聊天代理的信息：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that in the signature of the `GetAgentInfoEndpoint` function, we accept
    the `env` object and the `chatbot` object. Note that the `chatbot` is of type
    `bot.Bot`, an interface type, rather than the `AgentCase` type. This provides
    us with the flexibility to easily swap in another bot, such as `AgentMolly`, instead
    of `AgentCase`, in the future.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`GetAgentInfoEndpoint`函数的签名中，我们接受`env`对象和`chatbot`对象。请注意，`chatbot`是`bot.Bot`类型的接口类型，而不是`AgentCase`类型。这使我们能够轻松地在将来将另一个机器人（例如`AgentMolly`）替换为`AgentCase`。
- en: We simply create a map, `m`, of type `map[string]string`, containing the bot's
    name, title, and avatar image path. We set a header to indicate that the server
    response will be in the JSON format. Finally, we write out the JSON encoded `map`
    using `http.ResponseWriter`, `w`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地创建一个`map[string]string`类型的映射`m`，其中包含机器人的姓名、职称和头像路径。我们设置一个标头以指示服务器响应将以JSON格式返回。最后，我们使用`http.ResponseWriter`
    `w`编写JSON编码的`map`。
- en: Implementing the live chat's client-side functionality
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现实时聊天的客户端功能
- en: Now that we've covered the server-side functionality needed to implement the
    chat bot, it's time focus on the live chat feature from the perspective of the
    client-side web application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了实现聊天机器人所需的服务器端功能，是时候从客户端Web应用程序的角度关注实时聊天功能了。
- en: 'Inside the `InitialPageLayoutControls` function, we add an `event` listener
    on the `click` event to the live chat icon found on the top bar:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InitialPageLayoutControls`函数内，我们在顶部栏中的实时聊天图标上添加了一个`click`事件的`event`监听器：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the live chat feature has already been activated, the `chatbox` div element
    will already exist, that is, it will be a non-nil value. In this scenario, we
    return from the function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实时聊天功能已经激活，则`chatbox` div元素将已经存在，即它将是一个非nil值。在这种情况下，我们从函数中返回。
- en: However, in the case that the live chat feature has not been activated yet,
    we call the `StartLiveChat` function located in the `chat` package as a goroutine,
    passing in the `env` object. Calling this function, will activate the live chat
    feature.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实时聊天功能尚未激活的情况下，我们将调用位于`chat`包中的`StartLiveChat`函数作为goroutine，传入`env`对象。调用此函数将激活实时聊天功能。
- en: Creating the live chat client
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建实时聊天客户端
- en: We will use the `gopherjs/websocket/websocketjs` package to create a WebSocket
    connection that will be used to connect to the web server instance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`gopherjs/websocket/websocketjs`包来创建一个WebSocket连接，该连接将用于连接到Web服务器实例。
- en: 'You can install this package using the following `go get` command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下`go get`命令安装此包：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The client-side implementation of the live chat feature can be found in the
    `client/chat/chat.go` source file. We define the `ws` variable of the type `websocketjs.WebSocket` and
    the `agentInfo` variable of type `map[string]string`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实时聊天功能的客户端实现可以在`client/chat/chat.go`源文件中找到。我们定义了类型为`websocketjs.WebSocket`的`ws`变量和类型为`map[string]string`的`agentInfo`变量：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We also declare a constant that represents the key code for the Enter key:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了一个代表Enter键的键码的常量：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `GetAgentInfoRequest` function is used to obtain the agent information
    from the `/restapi/get-agent-info` endpoint:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetAgentInfoRequest`函数用于从`/restapi/get-agent-info`端点获取代理信息：'
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once we retrieve the JSON encoded data from the server, we decode it to `map`
    of type `map[string]string`. We then send the `agentInfo map` over the channel,
    `agentInfoChannel`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从服务器检索到JSON编码的数据，我们将其解码为`map[string]string`类型的`map`。然后我们通过通道`agentInfoChannel`发送`agentInfo
    map`。
- en: 'The `getServerPort` function is a helper function to obtain the port the server
    is running on:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`getServerPort`函数是一个辅助函数，用于获取服务器运行的端口：'
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This function is used when constructing the `serverEndpoint` string variable
    inside the `StartLiveChat` function, which represents the server endpoint that
    we'll be making the WebSocket connection to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于在`StartLiveChat`函数内构造`serverEndpoint`字符串变量，该变量表示我们将要建立WebSocket连接的服务器端点。
- en: 'When the user clicks on the live chat icon in the top bar, the `StartLiveChat`
    function will be called as a goroutine:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击顶部栏中的实时聊天图标时，`StartLiveChat`函数将作为goroutine被调用：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We first start out by fetching the agent's info by calling the `GetAgentInfoRequest` function
    as a goroutine. The agent's  information will be sent as a map of the type `map[string]string` over
    the `agentInfoChannel` channel. The `agentInfo` `map` will be used as the data
    object that is passed to the `partials/chatbox_partial` template to display the
    agent's details (name, title, and avatar image).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`GetAgentInfoRequest`函数作为一个goroutine来获取代理的信息。代理的信息将作为`map[string]string`类型的映射通过`agentInfoChannel`通道发送。`agentInfo`
    `map`将被用作传递给`partials/chatbox_partial`模板以显示代理的详细信息（姓名、职称和头像）的数据对象。
- en: 'We then proceed to create a new WebSocket connection and connect to the server
    endpoint:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续创建一个新的WebSocket连接并连接到服务器端点：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We use the helper `getServerPort` function to get the port that the server is
    running on. The server port value is used when constructing the `serverEndpoint`
    string variable, which represents the WebSocket address of the server endpoint
    we will be connecting to.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用辅助函数`getServerPort`来获取服务器运行的端口。服务器端口值用于构造`serverEndpoint`字符串变量，该变量表示我们将连接到的服务器端点的WebSocket地址。
- en: 'We use the `env.Document` object''s `GetElementByID` method to get the chat
    container `div` element by suppling the ID of `"chatboxContainer"`. We also add
    a CSS animated style to make the chat box container pulsate for a dramatic effect
    when the chatbot is available to answer questions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`env.Document`对象的`GetElementByID`方法来获取聊天容器`div`元素，通过提供ID为`"chatboxContainer"`。我们还添加了CSS动画样式，使聊天框容器在聊天机器人可以回答问题时产生戏剧性的脉动效果：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We call the `Render` method of the template set object, rendering the `"partials/chatbox_partial"`
    template and supplying the template render parameters. We specify that the data
    object that is to be fed to the template will be the `agentInfo` map. We specify
    that the disposition of the rendering should be to replace the inner HTML contents
    of the associated element with the rendered template output. Finally, we specify
    that the associated element to render to is the `chatContainer` element.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用模板集对象的`Render`方法，渲染`"partials/chatbox_partial"`模板并提供模板渲染参数。我们指定要提供给模板的数据对象将是`agentInfo`映射。我们指定渲染的方式应该是用渲染模板输出替换相关元素的内部HTML内容。最后，我们指定要渲染到的相关元素是`chatContainer`元素。
- en: 'When the live chat feature is functional and the WebSocket connection to the
    server is connected, then the chat box header bar, the strip containing the chat
    box title, the `chatboxHeaderBar`, will be colored green. If the WebSocket connection
    has been disconnected or there is an error, the strip will be colored red. By
    default, the strip will be colored green when we set the default CSS class of
    the `chatboxHeaderBar` to `"chatboxHeader"`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当实时聊天功能可用且与服务器的WebSocket连接已连接时，聊天框标题栏，包含聊天框标题的条纹，`chatboxHeaderBar`，将被着绿色。如果WebSocket连接已断开或出现错误，则条纹将被着红色。默认情况下，当我们将`chatboxHeaderBar`的默认CSS类设置为`"chatboxHeader"`时，条纹将被着绿色：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Initializing the event listeners
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化事件监听器
- en: 'Finally, we call the `InitializeChatEventHandlers` function, passing in the
    `env` object, to initialize the event handlers for the live chat feature:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`InitializeChatEventHandlers`函数，传入`env`对象，初始化实时聊天功能的事件处理程序：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `InitializeChatEventHandlers` function is responsible for setting up all
    the event listeners required by the live chat feature. There are two controls
    that require user interaction. The first is the message `input` field, where the
    user types and sends their questions by hitting the Enter key. The second is the
    close button, the X, that's found on the upper right hand corner of the chat box,
    used to close the live chat feature.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitializeChatEventHandlers`函数负责设置实时聊天功能所需的所有事件监听器。有两个需要用户交互的控件。第一个是消息`input`字段，用户通过按下Enter键输入并发送问题。第二个是关闭按钮，即X，位于聊天框右上角，用于关闭实时聊天功能。'
- en: 'To handle the user interaction with the message `input` field, we set up the
    `keypress` event listener, which will detect a `keypress` event inside the message
    `input` textfield element:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理用户与消息`input`字段的交互，我们设置了`keypress`事件监听器，它将检测消息`input`文本字段内的`keypress`事件：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We fetch the `input` message textfield element by calling the `GetElementByID`
    method on the `env.Document` object. We then attach a `keypress` event listener
    function to the element. If the key that the user presses is the Enter key, then
    we will prevent the default behavior of the `keypress` event and call the `ChatSendMessage`
    function, as a goroutine, passing in the `env` object and the `Value` property
    of the `msgInput` element. Finally, we clear the text in the message input field
    by setting its `Value` property to the empty string value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`env.Document`对象上调用`GetElementByID`方法获取`input`消息文本字段元素。然后我们为该元素附加了一个`keypress`事件监听器函数。如果用户按下的键是Enter键，我们将阻止`keypress`事件的默认行为，并调用`ChatSendMessage`函数，作为一个goroutine，传入`env`对象和`msgInput`元素的`Value`属性。最后，我们通过将消息输入字段的`Value`属性设置为空字符串值来清除文本。
- en: The close chat control
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭聊天控件
- en: 'To handle the user interaction when clicking on the X control to close the
    live chat feature, we set up an event listener to handle the click event of the
    close control:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理用户点击X控件关闭实时聊天功能时的交互，我们设置了一个事件监听器来处理关闭控件的点击事件：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We get the `div` element that represents the close control by calling the `GetElementByID`
    method on the `env.Document` object, specifying the ID `"chatboxCloseControl"`.
    We attach an event listener, to the close control, on the `click` event, which
    will call the `CloseChat` function.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`env.Document`对象上调用`GetElementByID`方法，指定ID为`"chatboxCloseControl"`，获取代表关闭控件的`div`元素。我们在`click`事件上为关闭控件附加一个事件监听器，该事件监听器将调用`CloseChat`函数。
- en: Setting up event listeners for the WebSocket object
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为WebSocket对象设置事件监听器
- en: 'Now that we''ve set up the event listeners for the user interactions, we must
    set up event listeners on the WebSocket object, `ws`. We first add an event listener
    on the `message` event:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为用户交互设置了事件监听器，我们必须在WebSocket对象`ws`上设置事件监听器。我们首先在`message`事件上添加一个事件监听器：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `message` event listener will be triggered when a new message comes across
    the WebSocket connection. This is indicative of the agent sending a message back
    to the user. In this situation we call the `HandleOnMessage`, function, passing
    in the `env` object and the event object, `ev`, to the function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当WebSocket连接上有新消息时，将触发`message`事件监听器。这表明代理向用户发送消息。在这种情况下，我们调用`HandleOnMessage`函数，将`env`对象和事件对象`ev`传递给函数。
- en: 'The other event we have to listen for from the WebSocket object is the `close` event.
    This event can be triggered from a normal operating scenario, such as the user
    closing the live chat feature using the close control. The event can also be triggered
    from an abnormal operating scenario, such as the web server instance suddenly
    going down, breaking off the WebSocket connection. Our code must be intelligent
    enough to fire only in the abnormal connection closing scenario:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket对象中我们需要监听的另一个事件是`close`事件。这个事件可能会在正常操作场景下触发，比如用户使用关闭控件关闭实时聊天功能。这个事件也可能在异常操作场景下触发，比如Web服务器实例突然宕机，中断WebSocket连接。我们的代码必须足够智能，只在异常连接关闭的情况下触发：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We do so by first fetching the chatbox container `div` element. If the number
    of child nodes within the chatbox container is greater than zero, it means that
    the connection has abnormally closed while the user is using the live chat feature,
    and we must call the `HandleDisconnection` function, as a goroutine, passing in
    the `env` object to the function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取聊天框容器`div`元素。如果聊天框容器中的子节点数量大于零，则意味着在用户使用实时聊天功能时连接异常关闭，我们必须调用`HandleDisconnection`函数，作为一个goroutine，将`env`对象传递给该函数。
- en: 'There may be certain scenarios, where the close event will not fire, such as
    when we lose internet connectivity. The TCP connection that the WebSocket connection
    is communicating over, may still be considered to be live even though the internet
    connection has been disconnected. In order for our live chat feature to be resilient
    to handle this scenario, we need to listen for the `env.Window` object''s `offline` event,
    which will fire when the network connection is lost:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些情况，关闭事件不会触发，比如当我们失去互联网连接时。WebSocket连接正在通信的TCP连接可能仍然被视为活动的，即使互联网连接已经断开。为了使我们的实时聊天功能能够处理这种情况，我们需要监听`env.Window`对象的`offline`事件，当网络连接丢失时会触发该事件：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We perform the same action as we did previously to handle this event. We call
    the `HandleDisconnection` function, as a goroutine, passing in the `env` object
    to the function. Take note that the last closing brace, `}`, indicates the end
    of the `InitializeChatEventHandlers` function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行与之前处理此事件相同的操作。我们调用`HandleDisconnection`函数，作为一个goroutine，将`env`对象传递给该函数。请注意，最后的闭括号`}`表示`InitializeChatEventHandlers`函数的结束。
- en: Now that we have set up all the necessary event listeners for the live chat
    feature, it's time to examine each function that was called by the event listeners
    we just set up.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为实时聊天功能设置了所有必要的事件监听器，是时候检查刚刚设置的事件监听器调用的每个函数了。
- en: 'The `ChatSendMessage` function is called after the user hits the Enter key
    inside the message `input` textfield:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户在消息`input`文本字段中按下Enter键后，将调用`ChatSendMessage`函数：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We call the `Send` method of the WebSocket object, `ws`, to send the user's
    question over to the web server. We then call the `UpdateChatBox` function to
    render the user's message to the chat box's conversation container. We pass in
    the `env` object, `message` the user wrote, and the `sender` string as input values
    to the `UpdateChatBox` function. The `sender` string is the person who sent the
    message; in this case, since the user sent it, the `sender` string will be `"Me"`.
    The `sender` string helps the user differentiate between messages the user sent
    versus messages the chatbot replied with.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用WebSocket对象`ws`的`Send`方法，将用户的问题发送到Web服务器。然后调用`UpdateChatBox`函数将用户的消息呈现到聊天框的对话容器中。我们将`env`对象、用户编写的`message`和`sender`字符串作为输入值传递给`UpdateChatBox`函数。`sender`字符串是发送消息的人；在这种情况下，由于用户发送了消息，`sender`字符串将是`"Me"`。`sender`字符串帮助用户区分用户发送的消息和聊天机器人回复的消息。
- en: 'The `UpdateChatBox` function is used to update the chat box conversation container
    area:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateChatBox`函数用于更新聊天框对话容器区域：'
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We create a new map of the `map[string]string` type, which will be used as the
    data object that will be fed to the `partials/livechatmsg_partial` template. The
    map consists of an entry with the key `"Name"` to represent `sender` and an entry
    with the key `"Message"` for the `message`. The values for both the `"Name"` and
    the `"Message"` will be displayed in the chat box's conversation container area.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的`map[string]string`类型的映射，它将被用作传递给`partials/livechatmsg_partial`模板的数据对象。该映射包括一个带有键`"Name"`的条目，表示`sender`，以及一个带有键`"Message"`的条目，表示`message`。`"Name"`和`"Message"`的值都将显示在聊天框的对话容器区域中。
- en: We obtain the element for `conversationContainer` by calling the `env.Document`
    object's `GetElementByID` method and specifying the `id` value of `"chatboxConversationContainer"`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`env.Document`对象的`GetElementByID`方法并指定`id`值为`"chatboxConversationContainer"`来获取`conversationContainer`元素。
- en: We call the `Render` method of the `env.TemplateSet` object and specify that
    we want to render the `partials/livechatmsg_partial` template. In the render parameters
    (`RenderParams`) object, we set the `Data` field to the `map`, `m`. We set the
    `Disposition` field to `isokit.PlacementAppendTo` to specify that the disposition
    operation will be an *append to* operation relative to the associated element.
    We set the `Element` field to the `conversationContainer`, since this is the element
    where the chat messages will be appended to.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`env.TemplateSet`对象的`Render`方法，并指定要渲染`partials/livechatmsg_partial`模板。在渲染参数（`RenderParams`）对象中，我们将`Data`字段设置为`map`
    `m`。我们将`Disposition`字段设置为`isokit.PlacementAppendTo`，以指定该操作将是一个*append to*操作，相对于关联元素。我们将`Element`字段设置为`conversationContainer`，因为这是将聊天消息追加到的元素。
- en: The final two lines in the function will auto-scroll the `conversationContainer`
    all the way to the bottom upon rendering a new message so that the most recent
    message will always be displayed to the user.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后两行将在渲染新消息时自动将`conversationContainer`滚动到底部，以便始终显示最近的消息给用户。
- en: 'Besides the `ChatSendMessage` function, the other utilizer of the `UpdateChatBox`
    function is the `HandleOnMessage` function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ChatSendMessage`函数之外，`UpdateChatBox`函数的另一个使用者是`HandleOnMessage`函数：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Recall that this function will be called upon the `"message"` event being fired
    from the WebSocket connection. We fetch the response from the chatbot, communicated
    over the WebSocket connection, by getting the string value of the `data` property
    of the `event` object. We then call the `UpdateChatBox` function passing in the
    `env` object, the `response` string, and the `sender` string, `agentInfo["AgentName"]`.
    Note that we have passed the name of the agent, the value in the `agentInfo` `map`
    obtained using the `"AgentName"` key, as the `sender` string.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此功能将在从WebSocket连接触发`"message"`事件时调用。我们通过获取`event`对象的`data`属性的字符串值，从通过WebSocket连接传递的聊天机器人获取响应。然后我们调用`UpdateChatBox`函数，传入`env`对象、`response`字符串和`sender`字符串`agentInfo["AgentName"]`。请注意，我们已经传递了代理的名称，即使用`"AgentName"`键获取的`agentInfo`
    `map`中的值，作为`sender`字符串。
- en: 'The `CloseChat` function is used to close the web socket connection and dismiss
    the chat box from the user interface:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`CloseChat`函数用于关闭网络套接字连接并从用户界面中解除聊天框：'
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We first call the `Close` method on the WebSocket object. We get the `chatboxContainer`
    element and remove its first child node, which will subsequently remove all the
    children of the first child node.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在WebSocket对象上调用`Close`方法。我们获取`chatboxContainer`元素并移除其第一个子节点，这将随后移除第一个子节点的所有子节点。
- en: Keep in mind that this function will be called either when the user hits the
    X control in the chat box, or in the scenario of an abnormal WebSocket connection
    termination encountered while the live chat feature is open.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此功能将在用户点击聊天框中的X控件时调用，或者在打开实时聊天功能时遇到异常的WebSocket连接终止的情况下调用。
- en: Handling a disconnection event
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理断开连接事件
- en: 'This leads us to the last function, `HandleDisconnection`, which is called
    either on an abnormal WebSocket connection close event or when the internet connection
    has been disconnected, that is, when the `wenv.Window` object fires an `offline`
    event:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导我们到最后一个函数`HandleDisconnection`，它在异常的WebSocket连接关闭事件或互联网连接断开时被调用，即当`wenv.Window`对象触发`offline`事件时：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We first set the CSS `classname` value of the `chatContainer` to empty string,
    using the `SetClass` method, to disable the `chatContainer`  element's pulsate
    effect to indicate that the connection has been broken.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`SetClass`方法将`chatContainer`的CSS`classname`值设置为空字符串，以禁用`chatContainer`元素的脉动效果，以指示连接已中断。
- en: We we then change the background color of `chatboxHeaderBar` to red by setting
    the `chatboxHeaderBar` element's CSS `classname` value to `"chatboxHeader disconnected"` using
    the `SetClass` method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用`SetClass`方法将`chatboxHeaderBar`元素的CSS`classname`值设置为`"chatboxHeader
    disconnected"`，将`chatboxHeaderBar`的背景颜色更改为红色。
- en: The remaining code will present the user with a message indicating that the
    connection has been disconnected, and the live chat feature will automatically
    initiate a countdown. The `chatboxHeaderBar` will display the countdown, 5-4-3-2-1,
    by the second, as the live chat feature shuts itself down. We use two goroutines,
    one for the countdown ticker and the other for the countdown timer. When the countdown
    timer has expired, it signifies that the countdown is over, and we call the `CloseChat`
    function passing in the `env` object to close the live chat feature.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的代码将向用户显示一条消息，指示连接已断开，并且实时聊天功能将自动启动倒计时。`chatboxHeaderBar`将按秒显示倒计时5-4-3-2-1，当实时聊天功能关闭时。我们使用两个goroutine，一个用于倒计时计时器，另一个用于倒计时计时器。当倒计时计时器到期时，表示倒计时结束，我们调用`CloseChat`函数，传入`env`对象来关闭实时聊天功能。
- en: Conversing with the agent
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与代理人交谈
- en: At this point, we have implemented the server-side and client-side functionality
    to realize the live chat feature, showcasing real-time web application functionality.
    Now it's time to to start up a conversation (question and answer session) with
    the chat agent.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经实现了服务器端和客户端功能，实现了实时聊天功能，展示了实时Web应用程序功能。现在是时候开始与聊天代理进行对话（问题和答案会话）了。
- en: 'After clicking on the live chat icon found on the website''s top bar, we are
    presented with the chat box in the lower right-hand side portion of the web page.
    The following screenshot depicts the chat box with the chat agent''s greeting:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在网站顶部栏找到实时聊天图标后，我们会在网页的右下角看到聊天框。以下截图显示了带有聊天代理问候语的聊天框：
- en: '![](img/156fc180-8401-4377-a6a2-e2e39b2bf9fe.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/156fc180-8401-4377-a6a2-e2e39b2bf9fe.png)'
- en: 'Figure 8.3: The chat box opens up with a greeting from the chat agent'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：聊天框打开并显示聊天代理的问候
- en: 'We can close the live chat box window using the X control in the top-right
    corner of the chat box. We can reactivate the live chat feature by clicking on
    the live chat icon again in the top bar. Instead of asking the chat agent a question
    such as What is Isomorphic Go?, we can actually provide a statement such as Tell
    me more about Isomorphic Go as we have shown in the following screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用聊天框右上角的X控件关闭实时聊天框。我们可以通过再次点击顶部栏中的实时聊天图标来重新激活实时聊天功能。我们可以提供一个陈述，例如告诉我更多关于同构Go，而不是向聊天代理提问，就像我们在以下截图中所示的那样：
- en: '![](img/c3eafb6a-f985-4e2e-8f24-58389c7c9db6.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3eafb6a-f985-4e2e-8f24-58389c7c9db6.png)'
- en: 'Figure 8.4: The chat agent understands an information request even if it isn''t
    a question'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：即使不是问题，聊天代理也能理解信息请求
- en: The question and answer session between the human user and the chat agent can
    continue for as long as the human user wishes, as shown in the next screenshot.
    This is perhaps the greatest strength of a chat agent—it has unlimited patience
    when dealing with humans.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 人类用户和聊天代理之间的问答会话可以持续多长时间，如下一张截图所示。这也许是聊天代理的最大优势——在与人类打交道时具有无限的耐心。
- en: '![](img/bd3b7d18-d40e-4fb8-990c-53fe05c5a7dc.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd3b7d18-d40e-4fb8-990c-53fe05c5a7dc.png)'
- en: 'Figure 8.5: The question and answer session can continue as long as the human
    wants it to'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：问题和答案会话可以持续多长时间取决于人类的意愿。
- en: 'The chat agent we have implemented has an extremely narrow and limited set
    of intelligence. The chat agent will admit that it doesn''t know the answer, when
    the human user asks a question outside of the scope of its intelligence, as shown
    here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的聊天代理具有极其狭窄和有限的智能范围。当人类用户提出超出其智能范围的问题时，聊天代理将承认自己不知道答案，如下所示：
- en: '![](img/0ca621a3-a61d-4ba4-8d13-14f02f9e92f4.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ca621a3-a61d-4ba4-8d13-14f02f9e92f4.png)'
- en: 'Figure 8.6: The chat agent doesn''t have an answer for a question outside the
    scope of its intelligence'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：聊天代理对超出其智能范围的问题没有答案
- en: Some human users can be rude to the chat agent. This comes along with the public-facing
    role that the chat agent serves. If we tune the corpus just right, we can have
    our chat agent exhibit a witty reply.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人类用户可能对聊天代理粗鲁。这是聊天代理所服务的公共角色所带来的。如果我们调整语料库得当，我们的聊天代理可以展示一个风趣的回复。
- en: '![](img/daf82631-447d-4a5b-acc9-8dbc20cb0fe1.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/daf82631-447d-4a5b-acc9-8dbc20cb0fe1.png)'
- en: 'Figure 8.7: The chat agent exhibiting a witty reply'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：聊天代理展示一个风趣的回复
- en: 'As noted earlier, we have strategically placed the chat box container outside
    of the primary content area in the web page layout. Having done so, the chat box
    and the conversation with the chat agent, can be continued, as we freely navigate
    through the links of IGWEB, as shown here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，我们已经有策略地将聊天框容器放在网页布局的主要内容区域之外。这样做后，聊天框和与聊天代理的对话可以在我们自由导航IGWEB的链接时继续，如下所示：
- en: '![](img/08c6306f-7edc-45b9-8f53-b000a8cb82d0.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08c6306f-7edc-45b9-8f53-b000a8cb82d0.png)'
- en: 'Figure 8.8: The chat conversation will be retained as the user navigates through
    IGWEB'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：用户在IGWEB中导航时，聊天对话将被保留
- en: 'For example, the chat conversation is continued even after clicking on the
    Coffee Mug product image to get to the product detail page, as shown here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如下所示，即使在单击咖啡杯产品图像以进入产品详细页面后，聊天对话仍在继续：
- en: '![](img/f18de492-5396-4668-855d-b0735549ab42.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f18de492-5396-4668-855d-b0735549ab42.png)'
- en: 'Figure 8.9: The chat conversation has been retained as the user visits the
    product detail page for the coffee mug'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：用户访问咖啡杯产品详细页面时，聊天对话已保留
- en: 'A real-time web application depends on a persistent connection to the Internet.
    Let''s see how the live chat feature gracefully handles the scenario where we
    disconnect the Internet connection, as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实时网络应用取决于对互联网的持续连接。让我们看看实时聊天功能如何优雅地处理断开互联网连接的情况，如下所示：
- en: '![](img/073b2350-2bbb-4a2e-a245-c88950a9018a.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/073b2350-2bbb-4a2e-a245-c88950a9018a.png)'
- en: 'Figure 8.10: Switching off the internet connection'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：关闭互联网连接
- en: 'Once the internet connection has been turned off, we immediately are notified
    of the disconnection in the chat box''s header bar as shown in *Figure 8.11*.
    The background color of the chat box header bar turns red and a countdown to close
    the live chat feature is initiated. After the countdown is complete, the live
    chat feature closes itself automatically:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦网络连接被关闭，我们立即在聊天框的标题栏中得到断开连接的通知，如*图8.11*所示。聊天框标题栏的背景颜色变为红色，并启动关闭实时聊天功能的倒计时。倒计时完成后，实时聊天功能将自动关闭：
- en: '![](img/5caf4ba7-a60e-44bb-9380-3e142e10bc86.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5caf4ba7-a60e-44bb-9380-3e142e10bc86.png)'
- en: 'Figure 8.11: The countdown to shutdown the live chat feature appears in the
    chat box''s header bar'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：关闭实时聊天功能的倒计时出现在聊天框的标题栏中
- en: When implementing real-time web application functionality, it's always important
    to consider the scenario of the persistent WebSocket connection being interrupted. By
    having the live chat close down gracefully, when the persistent connection between
    the web client and the web server is interrupted, we have a means to provide a
    *heads up* to the user to disengage with the chat agent.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现实时网络应用功能时，始终重要考虑持久WebSocket连接中断的情况。当Web客户端和Web服务器之间的持久连接中断时，通过优雅地关闭实时聊天，我们有一种方式向用户提供*提示*，让用户与聊天代理解除联系。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we implemented real-time web application functionality in the
    form of IGWEB's live chat feature. You learned how to establish a persistent connection
    between the web server and the web client using a WebSocket. On the server-side,
    we introduced you to the `websocket` package from the Gorilla toolkit project.
    On the client-side, we introduced you to the `gopherjs/websocket/websocketjs`
    package from the GopherJS project.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以IGWEB的实时网络应用功能的形式实现了实时聊天功能。您学会了如何使用WebSocket在Web服务器和Web客户端之间建立持久连接。在服务器端，我们向您介绍了Gorilla工具包项目中的`websocket`包。在客户端，我们向您介绍了GopherJS项目中的`gopherjs/websocket/websocketjs`包。
- en: We created a simple, rudimentary chatbot that answers questions posed by users
    in real-time, with the conversation between the human and the bot being relayed
    through the established WebSocket connection. Since the real-time web application
    functionality depends on the persistent connection, we also added code to automatically
    shut down the live chat feature in case of an interrupted internet connection.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的初级聊天机器人，实时回答用户提出的问题，人类和机器人之间的对话通过建立的WebSocket连接进行中继。由于实时网络应用功能取决于持续连接，我们还添加了代码，以便在互联网连接中断的情况下自动关闭实时聊天功能。
- en: We used the `nlp` package to implement the brain of the rudimentary chat agent
    so that it could answer a few questions related to Isomorphic Go. We made our
    chat agent solution extensible, where new bots of varying intelligence could be
    added in the future by defining the `Bot` interface.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`nlp`包来实现初级聊天代理的大脑，以便它可以回答一些与同构Go相关的问题。我们使我们的聊天代理解决方案可扩展，未来可以通过定义`Bot`接口来添加具有不同智能的新机器人。
- en: In [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs– Reusable
    Components*, we will explore how to implement reusable interface widgets all across
    IGWEB. Reusable components provide a means to promote greater reusability, and
    they can be used in a plug and play manner. As you will learn, cogs are also efficient,
    making use of a virtual DOM to rerender their content as needed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml)中，*Cogs– 可重复使用的组件*，我们将探讨如何在整个IGWEB中实现可重复使用的接口小部件。可重复使用的组件提供了促进更大重用性的手段，它们可以以即插即用的方式使用。正如您将了解的那样，齿轮也是高效的，利用虚拟DOM根据需要重新渲染其内容。
