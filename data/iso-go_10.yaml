- en: Testing an Isomorphic Go Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试同构Go Web应用
- en: With the sprinkling of reusable components (cogs) throughout the website, that
    was performed in the previous chapter, we had reached a project milestone – we
    completed the IGWEB feature set that was laid out in [Chapter 2](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml), *The
    Isomorphic Go Toolchain*. However, we can't launch IGWEB just yet. Prior to launch,
    we must ensure the quality of the isomorphic web application by verifying that
    it meets a certain baseline set of functional requirements. To do this, we must
    implement end-to-end tests that exercise the isomorphic web application's functionality
    across environments (server-side and client-side).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在上一章中对网站进行可重用组件（齿轮）的点缀，我们已经达到了一个项目里程碑——我们完成了[第2章](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml)《同构Go工具链》中规划的IGWEB功能集。然而，我们还不能立即启动IGWEB。在启动之前，我们必须通过验证它是否满足一定的基本功能要求来确保同构Web应用的质量。为此，我们必须实施端到端测试，跨环境（服务器端和客户端）测试同构Web应用的功能。
- en: In this chapter, you will learn how to provide end-to-end test coverage for
    IGWEB. We will use Go's built-in test framework, for testing the server-side functionality,
    and we will use CasperJS for testing the client-side functionality. By implementing
    a suite of end-to-end tests, not only will we have a means for automated testing,
    but we also have a valuable project artifact in each test that we write, since
    each test communicates the intent of the expected functionality found in the isomorphic
    web application. By the end of this chapter, we will have created an end-to-end
    test suite that forms the foundation of a solid test strategy, which the reader
    can further build upon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何为IGWEB提供端到端的测试覆盖。我们将使用Go的内置测试框架测试服务器端功能，并使用CasperJS测试客户端功能。通过实施一套端到端测试，我们不仅可以进行自动化测试，而且在编写的每个测试中还有一个有价值的项目工件，因为每个测试都传达了同构Web应用中预期功能的意图。到本章结束时，我们将创建一个端到端测试套件，为稳固的测试策略奠定基础，读者可以进一步构建。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Testing the server-side functionality with Go's testing framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Go的测试框架测试服务器端功能
- en: Testing the client-side functionality with CasperJS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CasperJS测试客户端功能
- en: Testing the server-side functionality
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务器端功能
- en: As we learned in [Chapter 1](c90ed736-d3cf-4c9b-bae7-c8b894e25259.xhtml), *Isomorphic
    Web Applications with Go*, the isomorphic web application architecture utilizes
    the classic web application architecture, meaning that the web page response will
    be rendered on the server-side. This means that the web client need not be JavaScript-enabled
    in order to consume the content received from the server response. This fact is
    especially important for machine users, such as search engine bots, who need to
    crawl through the various links found on the website and index them. Often times,
    search engine spiders are not JavaScript-enabled. This means that we have to ensure
    that server-side routing is functioning properly, and that the web page response
    is rendered properly also.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](c90ed736-d3cf-4c9b-bae7-c8b894e25259.xhtml)《使用Go构建同构Web应用》中所学到的，同构Web应用架构利用了经典的Web应用架构，这意味着Web页面响应将在服务器端呈现。这意味着Web客户端无需启用JavaScript即可消费从服务器响应接收到的内容。这对于机器用户（如搜索引擎爬虫）尤为重要，他们需要爬行网站上找到的各种链接并对其进行索引。通常情况下，搜索引擎蜘蛛是不启用JavaScript的。这意味着我们必须确保服务器端路由正常运行，并且Web页面响应也正确呈现。
- en: In addition to this, we put in good effort in [Chapter 7](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml),
    *The Isomorphic Web Form*, to create an accessible, isomorphic web form that can
    be accessed by users who have greater accessibility needs. We need to ensure that
    the contact form's validation functionality is working, and that we can successfully
    send a valid contact form submission.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们在[第7章](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml)《同构Web表单》中，付出了很大的努力，创建了一个可访问的、同构的Web表单，可以被有更高辅助功能需求的用户访问。我们需要确保联系表单的验证功能正常运行，并且我们可以成功发送有效的联系表单提交。
- en: 'Therefore, on the server-side, the baseline set of functionality that we''ll
    test for, includes the following items:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在服务器端，我们将测试的基本功能包括以下项目：
- en: Verifying the server-side routing and template rendering
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证服务器端路由和模板呈现
- en: Verifying the contact form's validation functionality
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证联系表单的验证功能
- en: Verifying a successful contact form submission
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证成功的联系表单提交
- en: Go's testing framework
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go的测试框架
- en: We will use Go's built-in testing framework to write a set of tests that exercise
    IGWEB's server-side functionality. All server-side tests are stored in the `tests`
    folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Go的内置测试框架编写一组测试，测试IGWEB的服务器端功能。所有服务器端测试都存储在`tests`文件夹中。
- en: If you are new to Go's built-in testing framework, provided through the `testing`
    package, you can read more about it at this link: [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Go内置的测试框架还不熟悉，可以通过此链接了解更多：[https://golang.org/pkg/testing/](https://golang.org/pkg/testing/)。
- en: Prior to running the `go test` command to execute all the tests, you must start
    up the Redis server instance and IGWEB (each preferably in their own dedicated
    Terminal window or tab).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`go test`命令执行所有测试之前，您必须启动Redis服务器实例和IGWEB（最好分别在它们自己的专用终端窗口或选项卡中）。
- en: 'You can start the Redis server instance with the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令启动Redis服务器实例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can start the IGWEB instance with the following command, inside the `$IGWEB_APP_ROOT`
    folder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令在`$IGWEB_APP_ROOT`文件夹中启动IGWEB实例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run all the tests in the suite, we simply need to run the `go test` command
    within the `tests` folder:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行套件中的所有测试，我们只需在`tests`文件夹中运行`go test`命令：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Verifying server-side routing and template rendering
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证服务器端路由和模板呈现
- en: We created a test to verify all the server-side routes of the IGWEB application.
    Each route that we test will be associated with an expected string token, which
    is rendered in the page response, particularly in the primary content `div` container.
    So, not only will we be able to verify if the server-side route is functioning
    properly or not, but we will also know if the server-side template rendering is
    functioning normally.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个测试来验证IGWEB应用程序的所有服务器端路由。我们测试的每个路由都将与一个预期的字符串令牌相关联，该令牌在页面响应中呈现，特别是在主要内容`div`容器中。因此，我们不仅能够验证服务器端路由是否正常运行，还能知道服务器端模板呈现是否正常运行。
- en: 'Here are the contents of the `routes_test.go` source file, found in the `tests`
    folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`tests`文件夹中找到的`routes_test.go`源文件的内容：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `testHost` variable that we defined, is used to specify the hostname and
    port where the IGWEB instance is running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的`testHost`变量用于指定运行IGWEB实例的主机名和端口。
- en: The `TestServerSideRoutes` function is responsible for testing server-side routes,
    and verifying that the expected token string exists within the response body.
    Inside the function, we declare and initialize the `routesTokenMap` variable of
    type `map[string]string`. The keys in this `map`, represent the server-side route
    that we are testing, and the value for a given key, represents the expected `string`
    token that should exist in the web page response returned from the server. So,
    this test not only will tell us if the server-side route is functioning properly,
    but it will also give us a good idea on the health of template rendering, since
    the expected `string` tokens we supply are all strings that should be found in
    the body of the web page. We then `range` through the `routesTokenMap`, and for
    each iteration, we pass in the `route` and the `expectedString` to the `checkRoute`
    function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestServerSideRoutes`函数负责测试服务器端路由，并验证预期的令牌字符串是否存在于响应正文中。在函数内部，我们声明并初始化了`routesTokenMap`变量，类型为`map[string]string`。此`map`中的键表示我们正在测试的服务器端路由，给定键的值表示应该存在于从服务器返回的网页响应中的预期`string`令牌。因此，这个测试不仅会告诉我们服务器端路由是否正常运行，还会让我们对模板呈现的健康状况有一个很好的了解，因为我们提供的预期`string`令牌都是应该在网页正文中找到的字符串。然后，我们通过`routesTokenMap`进行`range`，对于每次迭代，我们将`route`和`expectedString`传递给`checkRoute`函数。'
- en: 'The `checkRoute` function is responsible for accessing a given route, reading
    its response body and verifying that the `expectedString` exists within the response
    body. There are three conditions that can cause the test to fail:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkRoute`函数负责访问给定路由，读取其响应正文并验证`expectedString`是否存在于响应正文中。有三种情况可能导致测试失败：'
- en: When a connection to the route URL cannot be made
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当无法连接到路由URL时
- en: If the response body retrieved from the server could not be read
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果无法读取从服务器检索到的响应正文
- en: If the expected string token did not exist in the web page response returned
    from the server
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果从服务器返回的网页响应中不存在预期的字符串令牌
- en: If any of these three errors occur, the test will fail. Otherwise the function
    will return normally.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这三种错误中的任何一种，测试将失败。否则函数将正常返回。
- en: 'We can run this test by issuing the following `go test` command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下`go test`命令来运行此测试：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Examining the output of running the test shows that the test has passed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 检查运行测试的输出显示测试已通过：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have now successfully verified accessing server-side routes and ensuring
    that the expected string in each route was rendered properly in the web page response.
    Now, let's start verifying the contact form functionality, starting with the form
    validation functionality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已成功验证了访问服务器端路由并确保每个路由中的预期字符串在网页响应中正确呈现。现在，让我们开始验证联系表单功能，从表单验证功能开始。
- en: Verifying the contact form's validation functionality
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证联系表单的验证功能
- en: 'The next test that we are going to implement will test the contact form''s
    server-side form validation functionality. There are two types of validations
    that we will be testing:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一个测试将测试联系表单的服务器端表单验证功能。我们将测试两种类型的验证：
- en: An error message that is displayed when the required form field has not been
    filled
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当未填写必填表单字段时显示的错误消息
- en: An error message that is displayed when an improperly formatted email address
    value is provided in the email field
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在电子邮件字段中提供格式不正确的电子邮件地址值时显示的错误消息
- en: 'Here are the contents of the `contactvalidation_test.go` source file, found
    in the `tests` folder:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`tests`文件夹中找到的`contactvalidation_test.go`源文件的内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `TestContactFormValidation` function is responsible for testing the contact
    form's server-side form validation functionality. We declare and initialize the
    `testURL` variable, which is the URL of the contact section of IGWEB.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestContactFormValidation`函数负责测试联系表单的服务器端表单验证功能。我们声明并初始化了`testURL`变量，该变量是IGWEB联系部分的URL。'
- en: We declare and initialize the `expectedTokenMap` variable of the `map[string]string` type,
    where keys in the map are the names of the form fields and the value for each
    key represents the expected error message that should be returned upon submitting
    the form.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化了`expectedTokenMap`变量，类型为`map[string]string`，其中`map`中的键是表单字段的名称，每个键的值表示在提交表单时应返回的预期错误消息。
- en: We create a new form and populate the form field values using the form object's
    `Add` method. Notice that we provided an empty `string` value for the `firstName`,
    `lastName`, and `messageBody` fields. We also provided an improperly formatted
    email address for the `email` field.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新表单，并使用表单对象的`Add`方法填充表单字段值。请注意，我们为`firstName`、`lastName`和`messageBody`字段提供了空的`string`值。我们还为`email`字段提供了格式不正确的电子邮件地址。
- en: We use the `NewRequest` function found in the `http` package to submit the form
    using a HTTP POST request.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`http`包中找到的`NewRequest`函数使用HTTP POST请求提交表单。
- en: We create an `http.Client`, `hc`, and submit the POST request by calling its
    `Do` method. We fetch the contents of the response body using the `ReadAll` function
    found in the `ioutil` package. We `range` through the `expectedTokenMap`, and
    in each iteration, we check whether the expected error message is found in the
    response body.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`http.Client`，`hc`，并通过调用它的`Do`方法提交POST请求。我们使用`ioutil`包中的`ReadAll`函数获取响应正文的内容。我们通过`expectedTokenMap`进行`range`，在每次迭代中，我们检查响应正文中是否包含预期的错误消息。
- en: 'These are the four possible conditions that can cause this test to fail:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可能导致此测试失败的四种可能条件：
- en: If the POST request could not be created
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法创建POST请求
- en: If the POST request failed due to connectivity issues with the web server
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于与Web服务器的连接问题而导致POST请求失败
- en: If the web client failed to read the response body of the web page response
    returned from the web server
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网页客户端无法读取从Web服务器返回的网页响应的响应正文
- en: If the expected error message could not be found in the body of the web page
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在网页正文中找不到预期的错误消息
- en: If any one of these errors are encountered, this test will fail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到任何这些错误中的一个，这个测试将失败。
- en: 'We can run this test by issuing the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行这个测试：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Examining the output of running the test shows that the test has passed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试的输出显示测试已经通过：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Verifying a successful contact form submission
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证成功的联系表单提交
- en: The next test that we will implement will test a successful contact form submission.
    This test, will be closely similar to the last test, with the exception that we
    will fill in all the form fields and provide a properly formatted email address
    in the `email` form field.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的下一个测试将测试成功的联系表单提交。这个测试将与上一个测试非常相似，唯一的区别是我们将填写所有表单字段，并在`email`表单字段中提供一个格式正确的电子邮件地址。
- en: 'Here are the contents of the `contact_test.go` source file, found in the `tests`
    folder:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`tests`文件夹中`contact_test.go`源文件的内容：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the test is very similar to the previous test that we implemented, except
    that we are populating all the form fields and providing a properly formatted
    email address. We declare and initialize the `expectedTokenString` variable to
    the confirmation string that we expect to be printed out in the response body,
    after conducting a successful form submission. The last `if` conditional block
    of the function checks whether the response body contains the `expectedTokenString`.
    If it does not, then the test will fail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个测试与我们之前实现的测试非常相似，只是我们填充了所有表单字段并提供了一个格式正确的电子邮件地址。我们声明并初始化`expectedTokenString`变量，以确认我们期望在成功提交表单后在响应正文中打印出的确认字符串。函数的最后一个`if`条件块检查响应正文是否包含`expectedTokenString`。如果没有，那么测试将失败。
- en: 'These are the four possible conditions that can cause this test to fail:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可能导致此测试失败的四种可能条件：
- en: If the POST request could not be created
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法创建POST请求
- en: If the POST request failed due to connectivity issues with the web server
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果由于与Web服务器的连接问题而导致POST请求失败
- en: If the web client failed to read the response body of the web page response
    returned from the web server
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网页客户端无法读取从Web服务器返回的网页响应的响应正文
- en: If the expected confirmation message could not be found in the body of the web
    page
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在网页正文中找不到预期的确认消息
- en: Again, if any one of these errors are encountered, this test will fail.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果遇到任何这些错误中的一个，这个测试将失败。
- en: 'We can run the test by issuing the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行测试：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From examining the output after running the test, we can see that the test
    has passed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查运行测试后的输出，我们可以看到测试已经通过：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can run all the tests in the test suite by simply issuing the `go test`
    command inside the `tests` directory:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`tests`目录中简单地发出`go test`命令来运行测试套件中的所有测试：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Up to this point, we have written tests to cover the baseline set of functionality
    to test the server-side web application. Now, it's time to focus on testing the
    client-side application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了测试来覆盖测试服务器端Web应用程序的基线功能集。现在，是时候专注于测试客户端应用程序了。
- en: Testing the client-side functionality
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试客户端功能
- en: As covered in [Chapter 1](https://cdp.packtpub.com/isomorphic_go/wp-admin/post.php?post=616&action=edit#post_26), *Isomorphic
    Web Applications with Go*, after the initial page load, subsequent navigations
    on the website are served using single page application architecture. This means
    that an XHR call is initiated to a Rest API endpoint that provides the necessary
    data to render content that will be displayed on the web page. In the case where
    the client-side handler displays the products listing page, for example, a Rest
    API endpoint is utilized to fetch the list of products to display. In some cases,
    a Rest API endpoint is not even necessary since the page content only requires
    rendering a template. One such example of this is when a user accesses the contact
    form by clicking on the Contact link in the navigation bar. In this situation,
    we simply render the contact form template and display the contents in the primary
    content area.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第1章](https://cdp.packtpub.com/isomorphic_go/wp-admin/post.php?post=616&action=edit#post_26)中所述，《使用Go构建同构Web应用程序》，在初始页面加载后，网站上的后续导航使用单页面应用程序架构提供。这意味着会发起XHR调用到Rest
    API端点，以提供渲染内容所需的数据，这些内容将显示在网页上。例如，当客户端处理程序显示产品列表页面时，会利用Rest API端点来获取要显示的产品列表。在某些情况下，甚至不需要Rest
    API端点，因为页面内容只需要渲染模板。一个这样的例子是当用户通过点击导航栏中的联系链接访问联系表单时。在这种情况下，我们只需渲染联系表单模板，并在主要内容区域显示内容。
- en: Let's take a moment and think about all the baseline functionality that we would
    need to test on the client-side. We need to verify that the client-side routes
    are functional and that the proper page is rendered for each route, similar to
    how we verified the server-side routes in the previous section. In addition to
    that, we need to confirm that the client-side form validation is working for the
    contact form as well as testing the scenario of a valid form submission. The functionality
    to add and remove items, to and from the shopping cart, is currently implemented
    on the client-side only. This means that we will have to write tests to verify
    that this functionality is working as expected. Another feature that is currently
    only available on the client-side, is the live chat feature. We must validate
    that the user can communicate with the live chat bot, that the bot replies, and
    that the conversation is maintained as the user navigates to different sections
    of the website.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间思考一下我们需要在客户端测试的所有基本功能。我们需要验证客户端路由是否正常运行，并且对于每个路由都会呈现正确的页面，类似于我们在上一节中验证服务器端路由的方式。除此之外，我们还需要确认客户端表单验证对联系表单是否有效，并测试有效表单提交的情况。目前，添加和移除购物车中物品的功能仅在客户端实现。这意味着我们必须编写测试来验证此功能是否按预期工作。目前仅在客户端可用的另一个功能是实时聊天功能。我们必须验证用户能否与实时聊天机器人进行通信，机器人是否回复，并且在用户导航到网站的不同部分时，对话是否保持。
- en: Finally, we have to test our collection of cogs. We have to make sure that the
    time ago cog, shows a time instance in human understandable format. We have to
    verify that the live clock cog is functioning properly. We have to verify that
    the date picker cog appears when the Time Sensitivity Date field is clicked. We
    have to verify that the carousel cog appears on the home page. Finally, we have
    to verify that the notify cog is displaying notifications properly when adding
    and removing items to and from the shopping cart.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须测试我们的齿轮集合。我们必须确保时间齿轮以人类可理解的格式显示时间实例。我们必须验证实时时钟齿轮是否正常运行。我们必须验证当点击时间敏感日期字段时，日期选择器齿轮是否出现。我们必须验证主页上是否出现了轮播齿轮。最后，我们必须验证当向购物车中添加和移除物品时，通知齿轮是否正确显示通知。
- en: 'Therefore on the client-side, the baseline set of functionality that we''ll
    test for, includes the following items:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在客户端，我们将测试的基线功能包括以下项目：
- en: Verifying client-side routing and template rendering
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证客户端路由和模板呈现
- en: Verifying the contact form
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证联系表单
- en: Verifying the shopping cart functionality
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证购物车功能
- en: Verifying the live chat feature
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证实时聊天功能
- en: Verifying the time ago cog
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证时间齿轮
- en: Verifying the live clock cog
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证实时时钟齿轮
- en: Verifying the date picker cog
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证日期选择器齿轮
- en: Verifying the carousel cog
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证轮播齿轮
- en: Verifying the notify cog
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证通知齿轮
- en: In order to perform automated testing on the client-side, which includes user
    interactions, we need a tool that has a JavaScript runtime built into it. Therefore,
    we cannot use `go test` when testing the client-side functionality.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在客户端执行自动化测试，包括用户交互，我们需要一个内置JavaScript运行时的工具。因此，在测试客户端功能时，我们不能使用`go test`。
- en: We will use CasperJS to perform automated testing on the client-side.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用CasperJS在客户端执行自动化测试。
- en: CasperJS
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CasperJS
- en: CasperJS is an automated testing tool that sits on top of PhantomJS, a headless
    web browser that is used for automating user interactions. CasperJS allows us
    to write tests using assertions, and organize the tests, so that they can all
    be run together sequentially. After the tests are run, we can receive a summary
    of how many tests passed versus how many tests failed. In addition to this, CasperJS
    can tap into the functionality within PhantomJS to take web page screenshots as
    tests are being conducted. This allows human users to visually evaluate a test
    run.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS是一个自动化测试工具，它建立在PhantomJS之上，后者是用于自动化用户交互的无头浏览器。CasperJS允许我们使用断言编写测试，并组织测试，以便它们可以按顺序一起运行。测试运行后，我们可以收到有关通过的测试数量与失败的测试数量的摘要。除此之外，CasperJS可以利用PhantomJS内部的功能，在进行测试时获取网页截图。这使人类用户可以视觉评估测试运行。
- en: In order to install CasperJS, we must first install NodeJS and PhantomJS.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装CasperJS，我们必须先安装NodeJS和PhantomJS。
- en: 'You can install NodeJS by downloading the NodeJS installer for your operating
    system from this link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从此链接下载适用于您操作系统的NodeJS安装程序来安装NodeJS：[https://nodejs.org/en/download/](https://nodejs.org/en/download/)。
- en: 'Once NodeJS is installed, you can install PhantomJS by issuing the following
    command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 安装NodeJS后，您可以通过发出以下命令来安装PhantomJS：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may verify that `phantomjs` has been installed properly, by issuing the
    following command to view the version number of PhantomJS installed on your system:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过发出以下命令来查看系统上安装的PhantomJS版本号，以验证`phantomjs`是否已正确安装：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you have verified that PhantomJS is installed on your system, you may
    issue the following command to install CasperJS:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您验证了系统上安装了PhantomJS，您可以发出以下命令来安装CasperJS：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To verify that `casperjs` has been installed properly, you may issue the following
    command to view the version number of CasperJS installed on your system:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证`casperjs`是否已正确安装，您可以发出以下命令来查看系统上安装的CasperJS版本号：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our client-side CasperJS tests will be housed in the `client/tests` directory.
    Take note of the sub folders inside the `client/tests` folder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端CasperJS测试将存放在`client/tests`目录中。请注意`client/tests`文件夹内的子文件夹：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will be writing all of our CasperJS tests in Go, and we will be placing them
    in the `go` folder. We will use the `build_casper_tests.sh` bash script found
    in the `scripts` directory to transpile the CasperJS tests implemented in Go,
    to their equivalent JavaScript representation. The produced JavaScript source
    files will be placed in the `js` folder. Many of the tests we will create, will
    generate screenshots of the test run in progress, and these screenshot images
    will be stored in the `screenshots` folder.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Go中编写所有的CasperJS测试，并将它们放在`go`文件夹中。我们将使用`scripts`目录中的`build_casper_tests.sh`
    bash脚本来将在Go中实现的CasperJS测试转换为它们相应的JavaScript表示。生成的JavaScript源文件将放在`js`文件夹中。我们将创建许多测试，这些测试将生成正在进行的测试运行的屏幕截图，并且这些屏幕截图图像将存储在`screenshots`文件夹中。
- en: 'You should run the following command, to make the `build_casper_tests.sh` bash
    script executable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该运行以下命令，使`build_casper_tests.sh` bash脚本可执行：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Anytime we write a CasperJS test in Go, or make changes to it, we must execute
    the `build_casper_tests.sh` bash script:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在Go中编写CasperJS测试或对其进行更改时，都必须执行`build_casper_tests.sh` bash脚本。
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before we get started writing CasperJS tests, let''s take a look at the `caspertest.go`
    source file found in the `client/tests/go/caspertest` directory:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写CasperJS测试之前，让我们看一下`client/tests/go/caspertest`目录中的`caspertest.go`源文件：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ViewportParams` struct will be used to define the web browser's viewport
    dimensions. We will use a dimension of 1440 × 960 to simulate a desktop viewing
    experience for all of the client-side tests. The ramifications of setting the
    viewport dimensions can readily be seen by viewing the screenshots generated,
    after running a CasperJS test that generates one or more screenshots.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewportParams`结构将用于定义Web浏览器的视口尺寸。我们将使用1440×960的尺寸来模拟所有客户端测试的桌面浏览体验。设置视口尺寸的影响可以通过运行生成一个或多个屏幕截图的CasperJS测试后立即查看到。'
- en: Now, let's get started with writing client-side tests using CasperJS.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始使用CasperJS编写客户端测试。
- en: Verifying client-side routing and template rendering
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证客户端路由和模板渲染
- en: The CasperJS test that we implemented in Go, to test the client-side routing,
    can be found in the `routes_test.go` source file in the `client/tests/go` directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Go中实现的用于测试客户端路由的CasperJS测试可以在`client/tests/go`目录中的`routes_test.go`源文件中找到。
- en: 'In the import grouping, notice that we include the `caspertestjs` package,
    where we defined the `ViewportParams` `struct`, and we include the `js` package:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入分组中，请注意我们包含了`caspertestjs`包，其中我们定义了`ViewportParams` `struct`，并且我们包含了`js`包：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will use the functionality found in the `js` package, quite extensively,
    to tap into the CasperJS functionality since there are currently no GopherJS bindings
    available for CasperJS.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将广泛使用`js`包中的功能来利用CasperJS功能，因为目前尚无GopherJS绑定可用于CasperJS。
- en: 'We will define a JavaScript function called `wait`, which is responsible for
    waiting until the primary content `div` container gets loaded in the remote DOM:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为`wait`的JavaScript函数，它负责等待，直到远程DOM中的主要内容`div`容器加载完成：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We declare and initialize the `casper` variable to the `casper` instance, a
    JavaScript object, which has been populated in the remote DOM, upon executing
    CasperJS:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化`casper`变量为`casper`实例，这是一个JavaScript对象，在执行CasperJS时已经在远程DOM中填充：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We implement the client-side routing test in the `main` function. We start
    by declaring a `routesTokenMap` (similar to what we did on the server-side route
    test), having a type of `map[string]string`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main`函数中实现了客户端路由测试。我们首先声明了一个`routesTokenMap`（类似于我们在服务器端路由测试中所做的），类型为`map[string]string`：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The key represents a client-side route, and the value for a given key represents
    the expected string token that should be rendered on the web page, when the given
    client-route has been accessed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 键表示客户端路由，给定键的值表示在访问给定客户端路由时应在网页上呈现的预期字符串标记。
- en: 'Using the following code, we set the web browser''s viewport size:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码，我们设置了Web浏览器的视口大小：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that PhantomJS uses a default viewport of 400 × 300\. We have to override
    this value since we will be simulating a desktop viewing experience.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PhantomJS使用默认视口为400×300。由于我们将模拟桌面浏览体验，因此我们必须覆盖此值。
- en: 'We will use the `tester` module of CasperJS when writing our tests. The `Tester`
    class provides an API, for unit and functional testing, and can be accessed by
    the `test` property of the `casper` instance. The full documentation for the `tester`
    module is available at this link: [http://docs.casperjs.org/en/latest/modules/tester.html](http://docs.casperjs.org/en/latest/modules/tester.html).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，我们将使用CasperJS的`tester`模块。`Tester`类提供了一个API，用于单元测试和功能测试，并且可以通过`casper`实例的`test`属性访问。`tester`模块的完整文档可在此链接找到：[http://docs.casperjs.org/en/latest/modules/tester.html](http://docs.casperjs.org/en/latest/modules/tester.html)。
- en: 'We call the `test` object''s `begin` method to start a suite of planned tests:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`test`对象的`begin`方法来启动一系列计划测试：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first parameter supplied to the `begin` method is the description of the
    test suite. We have provided a description of `"Client-Side Routes Test Suite"`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`begin`方法的第一个参数是测试套件的描述。我们提供了一个描述为`"客户端路由测试套件"`。
- en: The second parameter represents the number of tests planned. Here we have specified
    that there will be a total of seven tests since that is how many client-side routes
    we will be testing. If the number of planned tests does not match the number of
    actual tests performed, then CasperJS will consider it to be a *dubious* error,
    so it's always a good practice to make sure that the proper number of tests planned
    is set correctly. We will show you how to count the number of tests performed
    in this example.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数表示计划测试的数量。在这里，我们指定将进行总共七项测试，因为我们将测试七个客户端路由。如果计划测试的数量与实际执行的测试数量不匹配，那么CasperJS将认为这是一个*可疑*错误，因此始终要确保正确设置计划测试的数量是一个良好的做法。我们将向您展示如何在此示例中计算执行的测试数量。
- en: The third parameter is a JavaScript callback function that contains the suite
    of tests that will be performed. Note that the callback function gets the `test`
    instance, a JavaScript object, as an input argument. Inside this function we call
    the `casper` object's `start` method. This starts up Casper and opens up the URL
    specified in the first input argument to the method. The second input argument
    to the `start` method is considered the next step, a JavaScript callback function
    that will run, right after accessing the URL. The next step that we specified
    is the `wait` function, which we had created earlier. This will have the effect
    of accessing the URL to the IGWEB home page, and waiting until the primary content
    `div` container is available in the remote DOM.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个包含将执行的测试套件的JavaScript回调函数。请注意，回调函数将`test`实例作为输入参数。在此函数内部，我们调用`casper`对象的`start`方法。这将启动Casper并打开方法中指定的URL。`start`方法的第二个输入参数被认为是下一步，一个JavaScript回调函数，将在访问URL后立即运行。我们指定的下一步是我们之前创建的`wait`函数。这将导致访问IGWEB主页的URL，并等待直到远程DOM中的主要内容`div`容器可用。
- en: 'At this point, we can start our tests. We `range` through each route and `expectedString`
    pair in the `routesTokenMap`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以开始我们的测试。我们通过`routesTokenMap`中的每个路由和`expectedString`进行`range`：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We call the `then` method of the `casper` object to add a new navigation step
    to the stack:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`casper`对象的`then`方法向堆栈添加一个新的导航步骤：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inside the function that represents the navigation step, we call the `casper`
    object's `click` method. The `click` method will trigger a mouse click event on
    the element that matches the provided CSS selector. We create a CSS selector for
    each route, and it will match a link on the body of the web page. The CSS selector
    allows us to simulate the scenario of the user clicking on the navigation links.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在代表导航步骤的函数内部，我们调用了`casper`对象的`click`方法。`click`方法将在与提供的CSS选择器匹配的元素上触发鼠标点击事件。我们为每个路由创建了一个CSS选择器，它将匹配网页正文中的链接。CSS选择器允许我们模拟用户点击导航链接的情景。
- en: The two routes that are not part of the navigation links are the `/` and `/product-detail/swiss-army-knife`
    routes. The CSS selector for the `/` route will match the link declared for the
    website's logo in the upper left-hand corner of the web page. When this scenario
    is tested, it is equivalent to the user clicking on the logo of the website. In
    this case of the link to the product detail page for the Swiss Army Knife, `/product-detail/swiss-army-knife`,
    will be found in the primary content area div once the content for the products
    page has been rendered. When this scenario is tested, it is equivalent of the
    user clicking on the Swiss Army Knife image on the products listing page.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于导航链接的两个路由是`/`和`/product-detail/swiss-army-knife`路由。`/`路由的CSS选择器将匹配网页左上角标志的链接。当测试这种情况时，相当于用户点击网站标志。在瑞士军刀产品详情页面的链接`/product-detail/swiss-army-knife`的情况下，一旦产品页面的内容被渲染，它将在主要内容区域div中找到。当测试这种情况时，相当于用户点击产品列表页面上的瑞士军刀图片。
- en: 'In the next navigation step, we will generate a screenshot of the tests case,
    and check if `expectedString` is found in the body of the web page:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个导航步骤中，我们将生成测试用例的屏幕截图，并检查网页正文中是否找到了`expectedString`：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we call the `casper` object's `capture` method to supply the path of the
    generated screenshot image. A screenshot will be generated for each route that
    we test, so we will have a total of seven screenshot images generated from this
    test.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`casper`对象的`capture`方法来提供生成的屏幕截图图像的路径。我们将为我们测试的每个路由生成一个屏幕截图，因此我们将从此测试中生成总共七个屏幕截图图像。
- en: Notice that we call casper's `wait` method to introduce a `1800` millisecond
    delay, and we supply a `then` callback function. In conversational English, we
    can interpret this call as, "Wait 1800 milliseconds, and then do this." Inside
    the `then` callback function that we have supplied, we make a call to the `assertTextExists`
    method on casper's `test` object (the `tester` module). In the `assertTextExists`
    method call, we supply the `expectedString` that should exist in the body of the
    web page, and the second parameter is a message describing the test. We have added
    the `1800` millisecond delay, to provide sufficient time for the page content
    to be displayed on the web page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们调用casper的`wait`方法引入了1800毫秒的延迟，并提供了一个`then`回调函数。在对话式英语中，我们可以解释这个调用为“等待1800毫秒，然后执行此操作。”在我们提供的`then`回调函数中，我们调用了casper的`test`对象（`tester`模块）上的`assertTextExists`方法。在`assertTextExists`方法调用中，我们提供了应该存在于网页正文中的`expectedString`，第二个参数是描述测试的消息。我们添加了1800毫秒的延迟，以便页面内容有足够的时间显示在网页上。
- en: Take note that whenever any type of `assert` method call, in the family of `assert`
    methods in the casper `tester` module is called, it counts as a single test. Recall
    that when we called the tester module's `begin` method, we supplied a value of
    `7`, to indicate that there were to be 7 expected tests that would take place
    in this test suite. So the amount of `assert` method calls that you have in your
    test, must match the number of expected tests that will be conducted, otherwise
    you will get a dubious error when performing a run of the test suite.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每当调用`casper`的`tester`模块中`assert`方法系列中的任何一种`assert`方法时，都算作一个单独的测试。回想一下，当我们调用测试模块的`begin`方法时，我们提供了一个值为`7`，表示预计将在此测试套件中进行7个预期测试。因此，您在测试中使用的`assert`方法调用的数量必须与将进行的预期测试数量相匹配，否则在运行测试套件时将会出现可疑的错误。
- en: 'We make a call to the `casper` object''s `run` method to run the test suite:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`casper`对象的`run`方法来运行测试套件：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we supply a callback function to the `run` method. This callback function
    will be called when all steps have completed running. Inside the callback function,
    we call the `tester` module's `done` method to signify the end of the test suite.
    Remember that in a CasperJS test, whenever we call the `begin` method on the `tester`
    module, there must be a corresponding place in the test where we call the tester
    module's `done` method. If we forget to leave the method call to `done`, the program
    will hang and we'll have to break out of the program (using a *Ctrl* + *C* keystroke).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们向run方法提供了一个回调函数。当所有步骤完成运行时，将调用此回调函数。在回调函数内部，我们调用tester模块的done方法来表示测试套件的结束。请记住，在CasperJS测试中，每当我们在tester模块上调用begin方法时，测试中必须有一个相应的地方调用tester模块的done方法。如果我们忘记留下对done方法的调用，程序将挂起，我们将不得不中断程序（使用Ctrl
    + C按键）。
- en: 'We must transpile the test to its JavaScript equivalent, and we can do so by
    running the `build_casper_tests.sh` bash script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将测试转换为其JavaScript等效形式，可以通过运行build_casper_tests.sh bash脚本来实现：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The bash script will transpile all of the CasperJS tests written in Go residing
    in the `client/tests/go` directory, and place the produced JavaScript source files
    in the `client/tests/js` directory. We will omit this step in subsequent test
    runs. Just keep in mind that if you make changes to any of the tests that you
    need to re-run this script so that the changes will take effect, next time you
    run the suite of tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: bash脚本将转换位于client/tests/go目录中的Go中编写的所有CasperJS测试，并将生成的JavaScript源文件放在client/tests/js目录中。我们将在后续的测试运行中省略此步骤。只需记住，如果对任何测试进行更改，需要重新运行此脚本，以便更改生效，下次运行测试套件时。
- en: 'We can run the test to check the client-side routes by issuing the following
    commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行测试以检查客户端路由：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Figure 10.1* shows a screenshot of running the client-side routes test suite:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1*显示了运行客户端路由测试套件的屏幕截图：'
- en: '![](img/41dfb567-3a37-4b6c-8814-5928926b71ef.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/41dfb567-3a37-4b6c-8814-5928926b71ef.png)
- en: 'Figure 10.1: Running the client-side routes test suite'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：运行客户端路由测试套件
- en: The produced screenshot images from the test can be found in the `client/tests/screenshots`
    folder. The screenshots come in handy because they allow a human user to visually
    look over the test results.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生成的屏幕截图可以在client/tests/screenshots文件夹中找到。屏幕截图非常有用，因为它们允许人类用户直观地查看测试结果。
- en: '*Figure 10.2* shows a screenshot image of testing the `/` route:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.2*显示了测试/路由的屏幕截图：'
- en: '![](img/fb2e82c8-a64f-4f2b-9f2b-014b2f11dccf.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/fb2e82c8-a64f-4f2b-9f2b-014b2f11dccf.jpg)
- en: 'Figure 10.2: Testing the / route'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：测试/路由
- en: '*Figure 10.3* shows a screenshot image of testing the `/index` route. Note
    that the page rendering is identical to *Figure 10.2* as it should be:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.3*显示了测试/index路由的屏幕截图。请注意，页面渲染与*图10.2*相同，这是应该的：'
- en: '![](img/1eaa6278-ca2f-4f14-bb58-48db34218b0c.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1eaa6278-ca2f-4f14-bb58-48db34218b0c.jpg)
- en: 'Figure 10.3: Testing the /index route'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：测试/index路由
- en: Notice that by supplying the delay time of `1800` milliseconds, we gave enough
    time for the carousel cog and the live clock cogs to load. Later in this chapter,
    you'll learn how to test these cogs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过提供1800毫秒的延迟时间，我们为轮播齿轮和实时时钟齿轮提供了足够的时间来加载。在本章后面，您将学习如何测试这些齿轮。
- en: '*Figure 10.4* shows a screenshot image of testing the `/products` route:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.4*显示了测试/products路由的屏幕截图：'
- en: '![](img/4bd932f1-20ee-4f35-943b-54e3a4e13f07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/4bd932f1-20ee-4f35-943b-54e3a4e13f07.jpg)
- en: 'Figure 10.4: Testing the /products route'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：测试/products路由
- en: From this test, we can visually confirm that the products listing page has loaded
    fine. The next test step will click on the image of the Swiss Army Knife to navigate
    to its product detail page.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此测试，我们可以直观确认产品列表页面已经成功加载。下一步测试将点击瑞士军刀的图像，以导航到其产品详细信息页面。
- en: '*Figure 10.5* shows a screenshot image of testing the `/product-detail/swiss-army-knife`
    route:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.5*显示了测试/product-detail/swiss-army-knife路由的屏幕截图：'
- en: '![](img/6cc75f81-3bfe-46f3-8191-244984eea02c.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6cc75f81-3bfe-46f3-8191-244984eea02c.jpg)
- en: 'Figure 10.5: Testing the /product-detail route'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：测试/product-detail路由
- en: '*Figure 10.6* shows a screenshot image of testing the `/about` route:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.6*显示了测试/about路由的屏幕截图：'
- en: '![](img/0ea50626-d930-4c4b-a750-adab177c1edd.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/0ea50626-d930-4c4b-a750-adab177c1edd.jpg)
- en: 'Figure 10.6: Testing the /about route'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：测试/about路由
- en: Notice that the time ago cog has rendered properly for all three gophers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，时间已经为所有三只地鼠正确渲染。
- en: '*Figure 10.7* shows a screenshot image of testing the `/contact` route:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.7*显示了测试/contact路由的屏幕截图：'
- en: '![](img/24d218b2-ecb9-4a99-8aab-ad4490824fff.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/24d218b2-ecb9-4a99-8aab-ad4490824fff.jpg)
- en: 'Figure 10.7: Testing the /contact route'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：测试/contact路由
- en: '*Figure 10.8* shows a screenshot image of testing `/shopping-cart` route.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.8*显示了测试/shopping-cart路由的屏幕截图。'
- en: '![](img/7d93df9f-ec48-4fdd-bbde-00e75c0dfce5.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7d93df9f-ec48-4fdd-bbde-00e75c0dfce5.jpg)
- en: 'Figure 10.8: Testing the /shopping-cart route'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：测试/shopping-cart路由
- en: From the visual confirmation provided by the screenshots, we can now be confident
    that the client-side routing is working as expected. In addition to that, the
    generated screenshots help us visually confirm that template rendering is functioning
    properly. Let's take a look at verifying the contact form functionality now.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过屏幕截图提供的视觉确认，我们现在可以确信客户端路由正在按预期工作。除此之外，生成的屏幕截图帮助我们在视觉上确认模板渲染正常运作。现在让我们来验证联系表单功能。
- en: Verifying the contact form
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证联系表单
- en: The test that we implemented to verify the contact form functionality, can be
    found in the `contactform_test.go` source file in the `client/tests/go` directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实施的用于验证联系表单功能的测试可以在client/tests/go目录中的contactform_test.go源文件中找到。
- en: 'In this test, we defined the `FormParams` `struct`, which represents the form
    parameters that the contact form should be filled with, when conducting our test
    steps:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试中，我们定义了`FormParams`结构，该结构表示在进行测试步骤时应填充联系表单的表单参数：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We''ve created a JavaScript `wait` function to ensure that the test runner
    will wait for the primary content `div` container to have loaded, prior to running
    other steps:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个JavaScript的`wait`函数，以确保测试运行程序在运行其他步骤之前等待主要内容`div`容器加载完成：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will introduce the following three JavaScript functions to populate the
    contact form''s fields, depending on the type of test we are conducting:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入以下三个JavaScript函数来填充联系表单的字段，具体取决于我们正在进行的测试类型：
- en: '`fillOutContactFormWithPoorlyFormattedEmailAddress`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillOutContactFormWithPoorlyFormattedEmailAddress`'
- en: '`fillOutContactFormPartially`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillOutContactFormPartially`'
- en: '`filloutContactFormCompletely`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filloutContactFormCompletely`'
- en: 'The `fillOutContactFormWithPoorlyFormattedEmailAddress` function, as the name
    implies, will supply an invalid email address to the `email` field:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillOutContactFormWithPoorlyFormattedEmailAddress`函数将向`email`字段提供一个无效的电子邮件地址，正如其名称所示：'
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that we created a new `FormParams` instance, and populated the `FirstName`,
    `LastName`, `Email`, and `MessageBody` fields. Take particular note that we have
    supplied an invalid email address for the `Email` field.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们创建了一个新的`FormParams`实例，并填充了`FirstName`、`LastName`、`Email`和`MessageBody`字段。特别注意，我们为`Email`字段提供了一个无效的电子邮件地址。
- en: In the context of this function, the `this` variable represents the `tester`
    module. We make a call to the `tester` module's `fill` method, supplying the CSS
    selector to the contact form, the `params` object, and a Boolean value of `true`
    to indicate that the form should be submitted.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数的上下文中，`this`变量代表`tester`模块。我们调用`tester`模块的`fill`方法，提供联系表单的CSS选择器、`params`对象，以及一个布尔值`true`来指示应该提交表单。
- en: After filling in and submitting the form, we expect the client-side form validation
    to present us with an error message indicating that we have provided an invalid
    email address.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写并提交表单后，我们期望客户端表单验证向我们呈现一个错误消息，指示我们提供了一个无效的电子邮件地址。
- en: 'The `fillOutContactFormPartially` function will fill out the contact form partially,
    leaving some required fields unfilled, resulting in an incomplete form:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillOutContactFormPartially`函数将部分填写联系表单，留下一些必填字段未填写，导致表单不完整。'
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we create a new `FormParams` instance, and take note that we have provided
    an empty `string` value for the `LastName` and `MessageBody` fields.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的`FormParams`实例，并注意到我们为`LastName`和`MessageBody`字段提供了空的`string`值。
- en: After filling in and submitting the form, we expect the client-side form validation
    to present us with an error message indicating that we have not filled in these
    two required fields.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写并提交表单后，我们期望客户端表单验证向我们呈现一个错误消息，指示我们没有填写这两个必填字段。
- en: 'The `fillOutContactFormCompletely` function will fill out all fields of the
    contact form and will include a properly formatted email address:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillOutContactFormCompletely`函数将填写联系表单的所有字段，并包括一个格式正确的电子邮件地址：'
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here we create a new `FormParams` instance, and populate all the fields of the
    contact form. In the case of the `Email` field, we ensure to supply a properly
    formatted email address.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的`FormParams`实例，并填充了联系表单的所有字段。在`Email`字段的情况下，我们确保提供了一个格式正确的电子邮件地址。
- en: After filling in and submitting the form, we expect the client-side form validation
    to green-light the form, which behind the scenes, will initiate an XHR call to
    the rest API endpoint to verify that the contact form has been properly filled
    using the server-side form validation. We expect the server-side validation to
    also green-light the form field values, resulting in a confirmation message. Our
    test will pass, if we can successfully verify that we have obtained the confirmation
    message.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写并提交表单后，我们期望客户端表单验证通过，这在后台将启动一个XHR调用到REST API端点，以验证联系表单已经通过服务器端表单验证正确填写。我们期望服务器端验证也通过，结果是一个确认消息。如果我们能成功验证已获得确认消息，我们的测试将通过。
- en: 'As with the previous example, we start by declaring the viewport parameters
    and setting the viewport size of the web browser:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子一样，我们首先声明视口参数，并设置Web浏览器的视口大小：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that we call the `tester` module''s `begin` method to start the tests
    in the Contact Form Test Suite:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们调用`tester`模块的`begin`方法来启动联系表单测试套件中的测试：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We supply the `begin` method with the description of the test, `"Contact Form
    Test Suite"`. We then supply the number of expected tests in this suite, which
    is `4`. Remember that this value corresponds to the number of tests we conduct.
    The number of tests conducted can be ascertained by the number of calls we make
    to a method belonging to the `tester` module's `assert` family of methods. We
    provide the `then` callback function, where we call the `start` method on the
    `casper` object, providing the URL to the Contact page and supplying the `wait`
    function to indicate that we should wait for the primary content `div` container
    to load before conducting any test steps.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`begin`方法提供了测试的描述，“联系表单测试套件”。然后我们提供了这个套件中预期的测试数量，即`4`。请记住，这个值对应于我们进行的测试数量。进行的测试数量可以通过我们对`tester`模块的`assert`系列方法之一进行调用的次数来确定。我们提供了`then`回调函数，在其中我们调用`casper`对象的`start`方法，提供联系页面的URL，并提供`wait`函数以指示我们应该在进行任何测试步骤之前等待主要内容`div`容器加载。
- en: 'The first scenario that we test is to check the client-side validation when
    a poorly formatted email address is provided:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的第一个场景是在提供格式不正确的电子邮件地址时检查客户端验证：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We call the casper object's `then` method, providing the `fillOutContactFormWithPoorlyFormattedEmailAddress`
    JavaScript function as the `then` callback function. We wait for `450` milliseconds
    for a result, capture a screenshot of the test run (shown in *Figure 10.10*),
    and then call the `assertSelectorHasText` method on the `tester` module, providing
    a CSS selector of the element containing the error message, along with the expected
    text the error message should have displayed, followed with a description of the
    test we are conducting.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`casper`对象的`then`方法，提供`fillOutContactFormWithPoorlyFormattedEmailAddress`
    JavaScript函数作为`then`回调函数。我们等待`450`毫秒以获取结果，捕获测试运行的截图（显示在*图10.10*中），然后在`tester`模块上调用`assertSelectorHasText`方法，提供了包含错误消息的元素的CSS选择器，以及错误消息应该显示的预期文本，然后是我们正在进行的测试的描述。
- en: 'The second scenario that we test, is to check the client-side validation when
    an incomplete form has been submitted:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的第二个场景是在提交不完整的表单时检查客户端验证：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We call the `casper` object's `then` method, providing the `fillOutContactFormPartially`
    JavaScript function, as the `then` callback function. We wait for `450` milliseconds
    for a result, capture a screenshot of the test run (shown in *Figure 10.11*),
    and conduct two tests within this scenario.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`casper`对象的`then`方法，提供`fillOutContactFormPartially` JavaScript函数作为`then`回调函数。我们等待`450`毫秒以获取结果，捕获测试运行的截图（显示在*图10.11*中），并在此场景中进行了两个测试。
- en: In the first test, we call the `assertSelectorHasText` method on the `tester`
    module, providing a CSS selector of the element containing the error message for
    the last name field along with the expected text, the error message should have,
    followed with a description of the test. In the second test, we call the `assertSelectorHasText`
    method on the `tester` module, providing a CSS selector of the element containing
    the error message for the message body text area, the expected text the error
    message should have, followed with a description of the test.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试中，我们在`tester`模块上调用`assertSelectorHasText`方法，提供了包含姓氏字段错误消息的元素的CSS选择器，以及预期文本，错误消息应该有的，然后是测试的描述。在第二个测试中，我们在`tester`模块上调用`assertSelectorHasText`方法，提供了包含消息正文文本区域错误消息的元素的CSS选择器，错误消息应该有的预期文本，然后是测试的描述。
- en: 'The third scenario that we test is to check that a confirmation message has
    been displayed upon the submission of a properly filled out contact form:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的第三个场景是检查在正确填写联系表单后是否显示了确认消息：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We call the `casper` object's `then` method, providing the `fillOutContactFormCompletely`
    JavaScript function, as the `then` callback function. We wait for `450` milliseconds
    for a result, capture a screenshot of the test run (shown in *Figure 10.12*),
    and call the `casper` object's `assertSelectorHasText` method. We provide the
    CSS selector `"#primaryContent h1"`, since the confirmation message will be inside
    the `<h1>` tag. We supply the expected text that the confirmation message should
    contain, being `"Confirmation"`. Finally, we provide a description of the test
    for the last parameter of the `assertSelectorHasText` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`casper`对象的`then`方法，提供`fillOutContactFormCompletely` JavaScript函数作为`then`回调函数。我们等待`450`毫秒以获取结果，捕获测试运行的截图（显示在*图10.12*中），并调用`casper`对象的`assertSelectorHasText`方法。我们提供CSS选择器`"#primaryContent
    h1"`，因为确认消息将在`<h1>`标签内。我们提供确认消息应包含的预期文本，即`"Confirmation"`。最后，我们为`assertSelectorHasText`方法的最后一个参数提供了测试的描述。
- en: 'To signify the end of the test suite, we call the casper object''s `run` method,
    and inside the `then` callback function, we call the tester module''s `done` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示测试套件的结束，我们调用`casper`对象的`run`方法，并在`then`回调函数内调用tester模块的`done`方法：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assuming that you are inside the `client/tests` folder, you can issue the following
    command to run the contact form test suite:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在`client/tests`文件夹中，您可以发出以下命令来运行联系表单测试套件：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Figure 10.9* shows a screenshot image of running the contact form test suite:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.9*显示了运行联系表单测试套件的截图图像：'
- en: '![](img/23a64aa1-e615-485d-8963-23c087ae03b9.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23a64aa1-e615-485d-8963-23c087ae03b9.png)'
- en: 'Figure 10.9: Running the contact form test suite'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：运行联系表单测试套件
- en: '*Figure 10.10* shows the generated screenshot image of running the first test
    which checks that the client-side form validation properly detects an improperly
    formatted email address:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.10*显示了运行第一个测试生成的截图图像，该测试检查客户端端表单验证是否正确检测到格式不正确的电子邮件地址：'
- en: '![](img/e460f8a1-c6f5-48d1-b820-b84ae40699ef.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e460f8a1-c6f5-48d1-b820-b84ae40699ef.jpg)'
- en: 'Figure 10.10: Testing the email validation syntax'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：测试电子邮件验证语法
- en: '*Figure 10.11* shows the generated screenshot image of running the second test
    and third test, which checks that the client-side form validation properly detects
    that the last name field and the message body text area has not been filled in:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.11*显示了运行第二个和第三个测试生成的截图图像，该测试检查客户端端表单验证是否正确检测到姓氏字段和消息正文文本区域是否未填写：'
- en: '![](img/38941cab-a572-415b-9fc3-d1af80f33375.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38941cab-a572-415b-9fc3-d1af80f33375.jpg)'
- en: 'Figure 10.11: Test to verify if the form validation detects required fields
    that have not been filled out'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：验证表单验证是否检测到未填写必填字段的测试
- en: '*Figure 10.12* shows the generated screenshot image of running the fourth test,
    which checks that the confirmation message has been displayed upon successfully
    filling out and submitting the contact form:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.12*显示了运行第四个测试生成的截图图像，该测试检查成功填写并提交联系表单后是否显示了确认消息：'
- en: '![](img/6ac84bc0-7438-47bf-a309-700223b90e08.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ac84bc0-7438-47bf-a309-700223b90e08.jpg)'
- en: 'Figure 10.12: Test to verify the confirmation message'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：验证确认消息的测试
- en: Now that we've verified the client-side validation functionality for the contact
    form, let's look into implementing a CasperJS test suite for the shopping cart
    functionality.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了联系表单的客户端验证功能，让我们来研究为购物车功能实施CasperJS测试套件。
- en: Verifying the shopping cart functionality
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证购物车功能
- en: In order to verify the shopping cart functionality, we must be able to add a
    product multiple times to the shopping cart, check that the product exists in
    the shopping cart with the proper quantity of the product displayed, and have
    the ability to remove the product from the shopping cart. Therefore, there are
    3 expected tests that we will need in the shopping cart test suite.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证购物车功能，我们必须能够多次向购物车中添加产品，检查产品是否以正确的数量显示在购物车中，并且能够从购物车中移除产品。因此，我们需要购物车测试套件中的3个预期测试。
- en: 'The `main` function in the `shoppingcart_test.go` source file, located in the
    `client/tests/go` directory, implements the shopping cart test suite:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`client/tests/go`目录中的`shoppingcart_test.go`源文件中的`main`函数实现了购物车测试套件：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Inside the `main` function, we set the web browser's viewport size. We start
    a new test suite by calling the `begin` method on the `casper` object. Note that
    we have indicated that there are 3 expected tests in this test suite. Inside the
    `then` callback function that constitutes the last argument to the `begin` method,
    we call the `start` method of the `casper` object, providing the URL to the products
    listing page, and providing the JavaScript `wait` function, as the `then` callback
    function. This will cause the program to wait until the primary content `div`
    container has loaded in the DOM, before conducting any tests.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内，我们设置了网页浏览器的视口大小。我们通过在`casper`对象上调用`begin`方法来启动一个新的测试套件。请注意，我们已经指示在这个测试套件中有3个预期测试。在`begin`方法的最后一个参数中构成的`then`回调函数内，我们调用`casper`对象的`start`方法，提供产品列表页面的URL，并提供JavaScript的`wait`函数作为`then`回调函数。这将导致程序在进行任何测试之前等待，直到DOM中加载了主要内容`div`容器。
- en: 'With the following code, we add three Swiss Army Knives to the shopping cart:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下代码，我们向购物车中添加了三把瑞士军刀：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Notice that we have passed the `click` method of the `casper` object with the
    CSS selector `".addToCartButton:first-child"`, to ensure that the Swiss Army Knife
    product is clicked on, since it is the first product displayed on the products
    listing page.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经通过`casper`对象的`click`方法传递了CSS选择器`".addToCartButton:first-child"`，以确保点击瑞士军刀产品，因为它是产品列表页面上显示的第一个产品。
- en: 'In order to verify that the Swiss Army Knives were properly placed in the shopping
    cart, we need to navigate to the shopping cart page:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证瑞士军刀是否正确放置在购物车中，我们需要导航到购物车页面：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our first test consists of verifying that the correct product type exists in
    the shopping cart:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试包括验证购物车中存在正确的产品类型：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We do this by checking that the `"Swiss Army Knife"` text exists on the shopping
    cart page by calling the `assertTextExists` method on the `tester` module object
    and providing an expected text value of `"Swiss Army Knife"`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`tester`模块对象上调用`assertTextExists`方法并提供预期文本值`"Swiss Army Knife"`来检查购物车页面上是否存在`"Swiss
    Army Knife"`文本。
- en: 'Our second test consists of verifying that the correct product quantity exists
    on the Shopping Cart page:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个测试包括验证购物车页面上存在正确的产品数量：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Again, we call the `tester` module object''s `assertTextExists` method, passing
    in the expected text, `"Quantity: 3"`.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，我们调用`tester`模块对象的`assertTextExists`方法，传入预期文本`"Quantity: 3"`。'
- en: 'We generate a screenshot of the shopping cart, and this screenshot (shown in
    *Figure 10.14*) should display the Swiss Army Knife with a quantity value of `3`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了一个购物车的截图，这个截图（显示在*图10.14*中）应该显示瑞士军刀的数量值为`3`：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our last test consists of removing an item from the shopping cart. We remove
    the product from the shopping cart with the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个测试包括从购物车中移除一个项目。我们使用以下代码从购物车中移除产品：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In order to verify that the product was successfully removed from the shopping
    cart, we need to check if the message indicating that the shopping cart is empty,
    exists on the Shopping Cart page:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证产品是否成功从购物车中移除，我们需要检查购物车页面上是否存在指示购物车为空的消息：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that in our call to the `tester` module object's `assertTextExists` method,
    we check to see whether the `"Your shopping cart is empty."` text exists on the
    web page. Prior to this, we also generate a screenshot image (shown in *Figure
    10.15*), which will show us the shopping cart in the empty state.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们对`tester`模块对象的`assertTextExists`方法进行调用时，我们检查网页上是否存在`"Your shopping cart
    is empty."`文本。在此之前，我们还生成了一个截图（显示在*图10.15*中），它将显示购物车处于空状态。
- en: 'Finally, we will signify the end of the shopping cart test suite with the following
    code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将用以下代码表示购物车测试套件的结束：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can run the CasperJS tests for the shopping cart test suite by issuing the
    following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行购物车测试套件的CasperJS测试：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Figure 10.13* shows a screenshot of the result of running the shopping cart
    test suite:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.13*显示了运行购物车测试套件的结果的截图：'
- en: '![](img/198e3138-fef7-4a77-aaac-3d297f1761a1.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/198e3138-fef7-4a77-aaac-3d297f1761a1.png)'
- en: Figure 10.13: Running the shopping cart test suite
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：运行购物车测试套件
- en: '*Figure 10.14* shows the generated screenshot showing the test case, where
    `3` Swiss Army Knives have been successfully added to the shopping cart:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.14*显示了生成的截图，显示了测试用例，其中`3`把瑞士军刀已成功添加到购物车中：'
- en: '![](img/bc3bbfd2-e87e-482b-9d5b-0511eb5cffe9.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc3bbfd2-e87e-482b-9d5b-0511eb5cffe9.jpg)'
- en: Figure 10.14: Test case to add a product multiple times to the shopping cart
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：将产品多次添加到购物车的测试用例
- en: '*Figure 10.15* shows the generated screenshot showing the test case, where
    the Swiss Army Knife product has been removed, thus emptying the shopping cart:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.15*显示了生成的截图，显示了测试用例，其中瑞士军刀产品已被移除，因此购物车为空：'
- en: '![](img/f46a1785-f500-4a37-b10c-e58ceb670de9.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f46a1785-f500-4a37-b10c-e58ceb670de9.jpg)'
- en: Figure 10.15: Test to verify emptying the shopping cart
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：验证清空购物车的测试
- en: Now that we've verified the functionality for the shopping cart, let's look
    into testing the live chat feature.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了购物车的功能，让我们来测试一下实时聊天功能。
- en: Verifying the live chat feature
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证实时聊天功能
- en: The live chat test suite consists of three tests. First, we must ensure that
    the chat box opens up when the live chat icon is clicked on the top bar. Second,
    we must ensure that the chat bot responds to us when we ask it a question. Third,
    we must ensure that the conversation is retained when we navigate to another section
    of the website.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实时聊天测试套件包括三个测试。首先，我们必须确保单击顶部栏上的实时聊天图标时，聊天框会打开。其次，我们必须确保当我们向它提问时，聊天机器人会回应我们。第三，我们必须确保在导航到网站的另一部分时，对话会被保留。
- en: The live chat test suite is implemented in the `livechat_test.go` source file
    found in the `client/tests/go` directory.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 实时聊天测试套件实现在`client/tests/go`目录中的`livechat_test.go`源文件中。
- en: 'The `waitChat` JavaScript function will be used to wait for the chat box to
    open:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitChat` JavaScript函数将用于等待聊天框打开：'
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `askQuestion` JavaScript function will be used to send a question to the
    chat bot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`askQuestion` JavaScript函数将用于向聊天机器人发送问题：'
- en: '[PRE56]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that we use the `sendKeys` method of the `tester` module object (the `this`
    variable is bound to the `tester` module object) to type the `"What is Isomorphic
    Go"` question, and we call the `sendKeys` method again to send the `enter` key
    (the equivalent of pressing the `enter` key on the keyboard).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`tester`模块对象的`sendKeys`方法（`this`变量绑定到`tester`模块对象）来输入“什么是同构Go”问题，然后再次调用`sendKeys`方法来发送`enter`键（相当于在键盘上按下`enter`键）。
- en: 'Inside the `main` function, we set the web browser''s viewport size and begin
    the test suite:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们设置了Web浏览器的视口大小并开始测试套件：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following code will activate the live chat feature, by simulating a user
    click on the live chat icon on the top bar:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将通过模拟用户单击顶部栏上的实时聊天图标来激活实时聊天功能：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following code will wait until the chat box has opened up, before proceeding:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将等待聊天框打开后再继续：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Once the chat box has opened up, we can verify that the chat box is visible
    with the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 打开聊天框后，我们可以使用以下代码验证聊天框是否可见：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that we call the `tester` module object's `assertSelectorHasText` method,
    providing a CSS selector of `"#chatboxTitle span"` to target the chat box's title
    `span` element. We then check to see whether the `"Chat with"` text exists inside
    the `span` element to verify that the chat box is visible.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们调用`tester`模块对象的`assertSelectorHasText`方法，提供CSS选择器`"#chatboxTitle span"`来定位聊天框的标题`span`元素。然后我们检查`span`元素内是否存在“Chat
    with”文本，以验证聊天框是否可见。
- en: Notice that we have generated a screenshot image, which should show us the chat
    box opened up, with the chat bot providing its greeting message (shown in *Figure
    10.17*).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已生成了一个屏幕截图图像，应该显示聊天框已打开，并且聊天机器人提供了问候消息（*图10.17*中显示）。
- en: 'The following code is used to verify that the chat bot provides an answer to
    us when we ask it a question:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于验证当我们向聊天机器人提问时，它是否会给出答案：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We call the `askQuestion` function to simulate the user typing in the `"What
    is Isomorphic Go"` question and pressing the `enter` key. We wait for `450` milliseconds,
    then generate a screenshot, which should show the live chat bot answering our
    question (shown in *Figure 10.18*). We verify that the chat bot has provided an
    answer by calling the `tester` module object's `assertSelectorHasText` method
    and providing it the CSS selector to access the `div` container, which contains
    the conversation and a substring of the expected answer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`askQuestion`函数来模拟用户输入“什么是同构Go”问题并按下`enter`键。我们等待450毫秒，然后生成一个屏幕截图，应该显示实时聊天机器人回答我们的问题（*图10.18*中显示）。我们通过调用`tester`模块对象的`assertSelectorHasText`方法并向其提供CSS选择器来验证聊天机器人是否已经给出答案，该选择器用于访问包含对话和预期答案子字符串的`div`容器。
- en: 'Currently, we are on the home page. To test that the conversation is retained
    while navigating to a different section of the website, we use the following code:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在主页上。为了测试在导航到网站的不同部分时对话是否保留，我们使用以下代码：
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we specified to navigate to the About page, and then wait until the primary
    content `div` container has loaded.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定导航到关于页面，然后等待直到主要内容`div`容器加载完成。
- en: 'We wait for `450` milliseconds, take a screenshot image (shown in *Figure 10.19*),
    and then conduct the last test in our test suite:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待450毫秒，拍摄一个屏幕截图（*图10.19*中显示），然后进行我们测试套件中的最后一个测试：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The last test here is a repeat of the previous test we conducted. Since we are
    testing that the conversation has been retained, we expect that the answer the
    chat bot gave us, after the last test, is preserved within the `div` container
    containing the conversation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一个测试是前面进行的测试的重复。由于我们正在测试对话是否已保留，我们期望在上一个测试之后，聊天机器人给出的答案会保留在包含对话的`div`容器中。
- en: 'We will close the chat box by simulating a user click to the close control
    (the Χ found in the upper right hand corner of the chat box), so that the websocket
    connection is closed normally:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过模拟用户点击关闭控件（聊天框右上角的Χ）来关闭聊天框，以便正常关闭websocket连接：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we will signify the end of the live chat test suite with the following
    code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下代码表示实时聊天测试套件的结束：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can run the CasperJS tests for the live chat test suite by issuing the following
    command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行实时聊天测试套件的CasperJS测试：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '*Figure 10.16* shows a screenshot of the result of running the live chat test
    suite:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.16*显示了运行实时聊天测试套件的结果的屏幕截图：'
- en: '![](img/3a3a32ac-e59b-46df-8825-8444727993e5.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a3a32ac-e59b-46df-8825-8444727993e5.png)'
- en: Figure 10.16: Running the live chat test suite
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：运行实时聊天测试套件
- en: '*Figure 10.17* shows the generated screenshot showing the test case, where
    we check to see whether the chat box has opened:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.17*显示了生成的屏幕截图，显示了测试用例，我们检查聊天框是否已打开：'
- en: '![](img/2356f933-0a29-4f85-9cb1-e16773ef5aa0.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2356f933-0a29-4f85-9cb1-e16773ef5aa0.jpg)'
- en: Figure 10.17: Test to verify that the chat box appears
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：验证聊天框是否出现的测试
- en: '*Figure 10.18* shows the generated screenshot showing the test case, where
    we check to see whether the chat bot responds to the given question:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.18*显示了生成的屏幕截图，显示了测试用例，我们在其中检查了聊天机器人是否回答了给定的问题：'
- en: '![](img/287800b7-6d60-4eb6-95b2-ead61e61aa08.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/287800b7-6d60-4eb6-95b2-ead61e61aa08.jpg)'
- en: Figure 10.18: Test to verify that the chat bot responds to a question
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：验证聊天机器人是否回答问题
- en: '*Figure 10.19* shows the generated screenshot showing the test case, where
    we check to see whether the chat conversation is retained after navigating to
    a different page on the website:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.19*显示了生成的屏幕截图，显示了测试用例，我们在其中检查了在网站上导航到不同页面后是否保留了聊天对话：'
- en: '![](img/b035846b-882a-430c-abe3-f4f36f65c4ef.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b035846b-882a-430c-abe3-f4f36f65c4ef.jpg)'
- en: Figure 10.19: Test to see if chat conversation is retained after navigation
    to a different section of the website
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：测试在导航到网站的不同部分后是否保留了聊天对话
- en: Now that we've verified the functionality for the live chat feature, let's look
    into testing the cogs, starting with the time ago cog.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了实时聊天功能，让我们来测试差齿轮，从时间差齿轮开始。
- en: For the sake of brevity, the generated screenshot images shown in Figures 10.17,
    10.18, 10.19, 10.21, 10.23, 10.25, 10.27, and 10.29 have been cropped.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，图10.17、10.18、10.19、10.21、10.23、10.25、10.27和10.29中显示的生成的屏幕截图已被裁剪。
- en: Verifying the time ago cog
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证时间差齿轮
- en: Testing the time ago cog consists of establishing a gopher's known date of joining
    the IGWEB team. We will establish May 24, 2017, as Molly's start date, and use
    this as the basis to test the human understandable time that is displayed under
    Molly's bio data on the About page.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时间差齿轮包括确定地鼠加入IGWEB团队的已知日期。我们将确定2017年5月24日为Molly的开始日期，并将其用作在关于页面上Molly的生物数据下显示的人类可理解时间的测试基础。
- en: 'Here is the test suite for the time ago cog, which is implemented in the `humantimecog_test.go`
    source file found in the `client/tests/go` directory:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是时间差齿轮的测试套件，实现在`client/tests/go`目录中的`humantimecog_test.go`源文件中：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Inside the `main` function, after we set the viewport size, and begin the test
    suite, we create a new `time` instance, called `mollysStartDate`, which represents
    the time when Molly joined the IGWEB team. We then pass `mollyStartDate`, to the
    `Time` function of the `go-humanize` package (note that we have aliased this package
    as `"humanize"`) and store the human understandable value of the start date in
    the `mollysStartDateHumanTime` variable.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内，我们设置了视口大小并开始测试套件后，创建了一个名为`mollysStartDate`的新`time`实例，表示Molly加入IGWEB团队的时间。然后，我们将`mollyStartDate`传递给`go-humanize`包的`Time`函数（请注意，我们已将此包别名为`"humanize"`），并将开始日期的人类可理解值存储在`mollysStartDateHumanTime`变量中。
- en: We generate a screenshot of the test run (shown in *Figure 10.21*). We then
    call the `tester` module object's `assertSelectorHasText` method, passing in the
    CSS selector to the `div` container containing Molly's start date in human readable
    format. We also pass in the `mollysStartDateInHumanTime` variable, since this
    is the expected text that should exist within the selector.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了测试运行的屏幕截图（显示在*图10.21*中）。然后，我们调用`tester`模块对象的`assertSelectorHasText`方法，传入包含Molly开始日期的`div`容器的CSS选择器。我们还传入`mollysStartDateInHumanTime`变量，因为这是应该存在于选择器中的预期文本。
- en: We will signify the end of the time ago cog test suite by calling the `done`
    method on the `tester` module object.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`tester`模块对象上调用`done`方法来表示时间差齿轮测试套件的结束。
- en: 'We can run the CasperJS test for the time ago cog test suite by issuing the
    following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行时间差齿轮测试套件的CasperJS测试：
- en: '[PRE68]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '*Figure 10.20* shows a screenshot of the result of running the time ago cog
    test suite:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.20*显示了运行时间差齿轮测试套件的结果的屏幕截图：'
- en: '![](img/167feaf5-4996-4f62-b9f6-f6ad7d46c6cf.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/167feaf5-4996-4f62-b9f6-f6ad7d46c6cf.png)'
- en: Figure 10.20: Running the time ago cog test suite
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20：运行时间差齿轮测试套件
- en: '*Figure 10.21* shows the generated screenshot showing the About page, with
    Molly''s start date printed out in human readable time format:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.21*显示了生成的屏幕截图，显示了关于页面，其中Molly的开始日期以人类可读的时间格式打印出来：'
- en: '![](img/4939e782-a0bc-42a1-b2a9-0dc531f15f44.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4939e782-a0bc-42a1-b2a9-0dc531f15f44.jpg)'
- en: Figure 10.21: Test to verify the time ago cog
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21：验证时间差齿轮
- en: Now that we've verified the functionality for the time ago cog, let's look into
    testing the functionality of the live clock cog.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了时间差齿轮的功能，让我们来测试实时时钟差齿轮的功能。
- en: Verifying the live clock cog
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证实时时钟差齿轮
- en: Verifying the functionality for the live clock cog for the user's local time,
    consists of creating a new `time` instance, of the current time formatted based
    on the local zone name and the local timezone offset, and comparing it to the
    value that is in the `myLiveClock` `div` container displayed on the home page.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 验证用户本地时间的实时时钟差齿轮的功能包括创建一个新的`time`实例，根据本地区域名称和本地时区偏移量格式化的当前时间，并将其与主页上显示的`myLiveClock`
    `div`容器中的值进行比较。
- en: 'Here is the test suite for the live clock cog, which is implemented in the
    `liveclockcog_test.go` source file found in the `client/tests/go` directory:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实时时钟差齿轮的测试套件，实现在`client/tests/go`目录中的`liveclockcog_test.go`源文件中：
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After setting the web browser's viewport size and starting the test suite by
    accessing the home page, we wait for `900ms`, and then we gather the user's local
    time zone name and the local time zone offset. We will be formatting the time
    according to the RFC1123 layout. This happens to be the same layout that is used
    by the live clock cog for displaying the time.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了Web浏览器的视口大小并通过访问主页启动测试套件后，我们等待`900ms`，然后收集用户的本地时区名称和本地时区偏移量。我们将根据RFC1123布局格式化时间。这恰好是实时时钟差齿轮用于显示时间的相同布局。
- en: We call the `FixedZone` function from the `time` package passing in `localZonename`
    and `localOffset` to get the location. We create a new time zone instance, and
    format it using the `location` and the RFC1123 `layout`. We use the `tester` module
    object's `assertSelectorHasText` method to see whether the current time formatted,
    using the RFC1123 `layout` and using the user's present `location`, exists within
    the selector specified to the `assertSelectorHasText` method.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`time`包中调用`FixedZone`函数，传入`localZonename`和`localOffset`来获取位置。我们创建一个新的时区实例，并使用`location`和RFC1123`layout`对其进行格式化。我们使用`tester`模块对象的`assertSelectorHasText`方法来查看当前时间是否使用RFC1123`layout`和用户当前`location`格式化，是否存在于指定给`assertSelectorHasText`方法的选择器中。
- en: We generate a screenshot of the test run (shown in *Figure 10.23*), and then
    call the `done` method on the `tester` module object to signify the end of the
    test suite.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成测试运行的截图（显示在*图10.23*中），然后在`tester`模块对象上调用`done`方法，表示测试套件的结束。
- en: 'We can run the CasperJS test for the live clock cog test suite by issuing the
    following command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行实时时钟齿轮测试套件的CasperJS测试：
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '*Figure 10.22* shows a screenshot of the result of running the live clock cog
    test suite:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.22*显示了运行实时时钟齿轮测试套件的结果的截图：'
- en: '![](img/2e537569-a9fc-488b-a40b-35643edd978c.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e537569-a9fc-488b-a40b-35643edd978c.png)'
- en: Figure 10.22: Running the live clock cog test suite
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22：运行实时时钟齿轮测试套件
- en: '*Figure 10.23* shows the generated screenshot showing the live clock cog on
    the Home page:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.23*显示了在主页上显示实时时钟齿轮的生成截图：'
- en: '![](img/85e8e540-f8e5-4f98-acf1-ca380e3bb0ba.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85e8e540-f8e5-4f98-acf1-ca380e3bb0ba.jpg)'
- en: Figure 10.23: Testing the live clock cog on the home page
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23：在主页上测试实时时钟齿轮
- en: Now that we've verified the functionality for the live clock cog, let's look
    into testing the functionality of the date picker cog.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了实时时钟齿轮的功能，让我们来测试日期选择器齿轮的功能。
- en: Verifying the date picker cog
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证日期选择器齿轮
- en: Verifying the functionality for the date picker cog consists of navigating to
    the Contact page, and clicking on the Time Sensitivity Date input field. This
    should trigger the display of the calendar widget.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 验证日期选择器齿轮的功能包括导航到联系人页面，并单击时间敏感日期输入字段。这应该触发日历小部件的显示。
- en: 'Here is the test suite for the date picker cog, which is implemented in the
    `datepickercog_test.go` source file, located in the `client/tests/go` directory:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是日期选择器齿轮的测试套件，它是在`datepickercog_test.go`源文件中实现的，位于`client/tests/go`目录中：
- en: '[PRE71]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Inside the `main` function, we set the web browser's viewport size and start
    the test suite by navigating to the Contact page.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们设置了Web浏览器的视口大小，并通过导航到联系人页面来启动测试套件。
- en: We then call the `casper` object's `click` method and provide the CSS selector
    `"#byDateInput"`, which will send a mouse click event to the Time Sensitivity
    Date input field, which should reveal the calendar widget.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`casper`对象的`click`方法，并提供CSS选择器`"#byDateInput"`，这将向时间敏感日期输入字段发送鼠标单击事件，这应该会显示日历小部件。
- en: We take a screenshot of the test run (shown in *Figure 10.25*), and then call
    the `tester` module object's `assertVisible` method, providing the `".pika-single"` selector and
    the name of the test, as input arguments to the method. The `assertVisible` method
    will assert that at least one element matching the provided selector expression
    is visible.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对测试运行进行截图（显示在*图10.25*中），然后调用`tester`模块对象的`assertVisible`方法，将`".pika-single"`选择器和测试名称作为输入参数传递给该方法。`assertVisible`方法将断言至少有一个与提供的选择器表达式匹配的元素是可见的。
- en: Finally, we call the `done` method on the `tester` module object to signify
    the end of the test suite.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`tester`模块对象上调用`done`方法，表示测试套件的结束。
- en: 'We can run the CasperJS test for the date picker cog test suite by issuing
    the following command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行日期选择器齿轮测试套件的CasperJS测试：
- en: '[PRE72]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '*Figure 10.24* shows a screenshot of the result of running the date picker
    cog test suite:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.24*显示了运行日期选择器齿轮测试套件的结果的截图：'
- en: '![](img/b21e8409-5679-499d-b43f-2c07f6351391.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b21e8409-5679-499d-b43f-2c07f6351391.png)'
- en: Figure 10.24: Running the date picker cog test suite
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24：运行日期选择器齿轮测试套件
- en: '*Figure 10.25* shows the generated screenshot showing the calendar widget after
    the Time Sensitivity Date input field has been clicked:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.25*显示了单击时间敏感日期输入字段后显示日历小部件的生成截图：'
- en: '![](img/e736752f-9000-4c4a-8520-62d18ef8be0a.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e736752f-9000-4c4a-8520-62d18ef8be0a.jpg)'
- en: Figure 10.25: Test verifying that the date picker appears
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25：验证日期选择器是否出现
- en: Now that we've verified the functionality for the date picker cog, let's look
    into testing the functionality of the carousel cog.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了日期选择器齿轮的功能，让我们来测试旋转齿轮的功能。
- en: Verifying the carousel cog
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证旋转齿轮
- en: Verifying the functionality for the carousel cog consists of providing sufficient
    time for the images of the carousel to load, and for the first image, the `watch.jpg`
    image file to appear on the web page.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 验证旋转齿轮的功能包括提供足够的时间来加载旋转齿轮的图像，并且第一张图像，即`watch.jpg`图像文件出现在网页上。
- en: 'Here is the test suite for the carousel cog, which is implemented in the `carouselcog_test.go`
    source file, located in the `client/tests/go` directory:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是旋转齿轮的测试套件，它是在`carouselcog_test.go`源文件中实现的，位于`client/tests/go`目录中：
- en: '[PRE73]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: After setting the web browser's viewport size and starting the test suite, by
    navigating to the Home page, we wait `1800` milliseconds and then we call the
    `assetResourceExists` method on the `tester` module object, supplying the name
    of the resource to check, which happens to be the `"watch.jpg"` image file, and
    a description of the test. The `assertResourceExists` function checks to see whether
    the `"watch.jpg"` image file exists in the set of assets that were loaded on the
    web page.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Web浏览器的视口大小并启动测试套件后，通过导航到主页，我们等待`1800`毫秒，然后在`tester`模块对象上调用`assetResourceExists`方法，提供要检查的资源的名称，这恰好是`"watch.jpg"`图像文件，以及测试的描述。`assertResourceExists`函数检查`"watch.jpg"`图像文件是否存在于加载在网页上的资源集中。
- en: We take a screenshot of the test run (shown in *Figure 10.27*), and then call
    the `done` method on the `casper` object to signify the end of the test suite.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拍摄了测试运行的屏幕截图（如图10.27所示），然后在`casper`对象上调用`done`方法，表示测试套件的结束。
- en: 'We can run the CasperJS test for the carousel cog test suite by issuing the
    following command:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行旋转木马齿轮测试套件的CasperJS测试：
- en: '[PRE74]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '*Figure 10.26* shows a screenshot of the result of running the carousel cog
    test suite:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26显示了运行旋转木马齿轮测试套件的结果的屏幕截图：
- en: '![](img/17e19dbb-85e2-46db-b799-0f4e08e90ac5.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17e19dbb-85e2-46db-b799-0f4e08e90ac5.png)'
- en: Figure 10.26: Running the carousel cog test suite
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26：运行旋转木马齿轮测试套件
- en: '*Figure 10.27* shows the generated screenshot showing the carousel cog:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27显示了生成的屏幕截图，显示了旋转木马齿轮：
- en: '![](img/682d8e25-dc8f-45b3-a254-22e383f29bff.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/682d8e25-dc8f-45b3-a254-22e383f29bff.jpg)'
- en: Figure 10.27: Test to veriy that the carousel cog appears
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27：验证旋转木马齿轮是否出现的测试
- en: Now that we've verified the functionality for the carousel cog, let's look into
    testing the functionality of the notify cog.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了旋转木马齿轮的功能，让我们来测试通知齿轮的功能。
- en: Verifying the notify cog
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证通知齿轮
- en: Verifying the functionality for the notify cog consists of navigating to the
    products listing page, adding an item to the shopping cart by clicking the Add
    to Cart button on a listed product, and then verifying that the notification appeared
    on the web page.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 验证通知齿轮的功能包括导航到产品列表页面，通过单击列出产品的“添加到购物车”按钮将商品添加到购物车，然后验证通知是否出现在网页上。
- en: 'Here is the test suite for the notify cog, which is implemented in the `notifycog_test.go`
    source file, located in the `client/test/go` directory:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通知齿轮的测试套件，它是在`client/test/go`目录中的`notifycog_test.go`源文件中实现的：
- en: '[PRE75]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: After setting the web browser's viewport and starting the test suite by navigating
    to the products listing page, we call the `casper` object's `click` method, providing
    the `".addToCartButton:nth-child(1)"` selector. This sends a mouse click event
    to the first Add to Cart button on the web page.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了网页浏览器的视口并通过导航到产品列表页面开始测试套件后，我们调用`casper`对象的`click`方法，提供`".addToCartButton:nth-child(1)"`选择器。这会向网页上的第一个“添加到购物车”按钮发送鼠标单击事件。
- en: We wait for `450` milliseconds and then call the `tester` module's `assertSelectorHasText`
    method providing the CSS selector, the text that should exist within the element
    returned from the selector, and the description of the test as input parameters.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们等待`450`毫秒，然后调用`tester`模块的`assertSelectorHasText`方法，提供CSS选择器、应该存在于从选择器返回的元素中的文本，以及测试描述作为输入参数。
- en: We take a screenshot of the test run (shown in *Figure 10.29*). We then navigate
    to the shopping cart page, and remove the item from the shopping cart.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拍摄了测试运行的屏幕截图（如图10.29所示）。然后我们导航到购物车页面，并从购物车中移除该商品。
- en: Finally, we call the `done` method on the `tester` module object to signify
    the end of the test suite.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`tester`模块对象上调用`done`方法，表示测试套件的结束。
- en: 'We can run the CasperJS test for the notify cog test suite by issuing the following
    command:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过发出以下命令来运行通知齿轮测试套件的CasperJS测试：
- en: '[PRE76]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '*Figure 10.28* shows a screenshot of the result of running the notify cog test
    suite:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28显示了运行通知齿轮测试套件的结果的屏幕截图：
- en: '![](img/7b92c81a-fd43-4a2a-ae48-6dcd8626da95.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b92c81a-fd43-4a2a-ae48-6dcd8626da95.png)'
- en: Figure 10.28: Running the notify cog test suite
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28：运行通知齿轮测试套件
- en: '*Figure 10.29* shows the generated screenshot showing the notification message
    displayed on the lower right hand corner of the web page as expected:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29显示了生成的屏幕截图，显示了通知消息如预期般显示在网页右下角：
- en: '![](img/19ffe05f-950c-4448-9608-7f34d1addbb4.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19ffe05f-950c-4448-9608-7f34d1addbb4.jpg)'
- en: Figure 10.29: Running the test to verify that the notification message was displayed
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29：运行测试以验证是否显示了通知消息
- en: We have now verified that the notify cog is functioning as expected and this
    wraps up our testing of IGWEB's client-side functionality.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经验证了通知齿轮的功能是否符合预期，这结束了我们对IGWEB客户端功能的测试。
- en: '*Figure 10.30* shows a screenshot of running the whole collection of test suites
    by running the following command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30显示了运行整个测试套件的屏幕截图，方法是运行以下命令：
- en: '[PRE77]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](img/2b9a606e-627b-4472-b0a2-af934ca2ff35.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b9a606e-627b-4472-b0a2-af934ca2ff35.png)'
- en: Figure 10.30: Running the whole collection of CasperJS test suites
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30：运行整个CasperJS测试套件
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to perform end-to-end testing to verify the
    functionality of an Isomorphic Go web application. To ensure the quality of IGWEB,
    prior to website launch, we started out by gathering the set of baseline functionality
    to test for.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何执行端到端测试，以验证同构Go Web应用程序的功能。为了确保IGWEB的质量，在网站上线之前，我们首先收集了要测试的基线功能集。
- en: To verify server-side functionality, we implemented tests using Go's `testing`
    package from the standard library. We implemented tests that verified server-side
    routing/template rendering, the contact form's validation functionality, and the
    successful contact form submission scenario.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证服务器端功能，我们使用Go的标准库中的`testing`包实现了测试。我们实现了验证服务器端路由/模板渲染、联系表单的验证功能以及成功的联系表单提交场景的测试。
- en: To verify client-side functionality, we implemented tests using CasperJS that
    verified multiple user interaction scenarios. We were able to perform automated
    user interaction testing using CasperJS, since it sits on top of PhantomJS, a
    headless web browser equipped with a JavaScript runtime. We implemented CasperJS
    tests to verify the client-side routing/template rendering, the contact form's
    client-side validation functionality, the successful contact form submission scenario
    on the client-side, the functionality of the shopping cart, and the functionality
    of the live chat feature. We also implemented CasperJS tests, to verify the functionality
    of the collection of cogs that we implemented in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml),
    *Cogs – Reusable Components*.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证客户端功能，我们使用CasperJS实施了测试，验证了多个用户交互场景。我们能够使用CasperJS执行自动化用户交互测试，因为它建立在PhantomJS之上，后者是一个配备JavaScript运行时的无头浏览器。我们实施了CasperJS测试来验证客户端路由/模板渲染、联系表单的客户端验证功能、客户端成功提交联系表单的场景、购物车功能以及实时聊天功能。我们还实施了CasperJS测试，验证了我们在第9章“齿轮-可重用组件”中实施的齿轮集合的功能。
- en: In [Chapter 11](19922281-fd33-4fab-bac2-75066243176d.xhtml), *Deploying an Isomorphic
    Go Web Application*, you will learn how to deploy IGWEB to the cloud. We will
    first explore the procedure to release the website to a standalone server. After
    that, you'll learn how to utilize Docker, to release the website as a multi-container
    Docker application.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章“部署同构Go Web应用”中，您将学习如何将IGWEB部署到云端。我们将首先探讨将网站发布到独立服务器的过程。之后，您将学习如何利用Docker将网站发布为多容器Docker应用程序。
