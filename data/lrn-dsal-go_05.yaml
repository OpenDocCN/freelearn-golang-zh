- en: Linear Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性数据结构
- en: Various applications, such as Facebook, Twitter, and Google, use lists and linear
    data structures. As we have discussed previously, data structures allow us to
    organize vast swathes of data in a sequential and organized manner, thereby reducing
    time and effort in working with such data. Lists, stacks, sets, and tuples are
    some of the commonly used linear data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Facebook、Twitter和Google等各种应用程序都使用列表和线性数据结构。正如我们之前所讨论的，数据结构允许我们以顺序和组织的方式组织大量数据，从而在处理此类数据时减少时间和精力。列表、栈、集合和元组是一些常用的线性数据结构。
- en: In this chapter, we will discuss these data structures by giving examples of
    various procedures involving them. We will discuss the various operations related
    to these data structures, such as insertion, deletion, updating, traversing (of
    lists), reversing, and merging with various code samples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过给出涉及这些数据结构的各种过程示例来讨论这些数据结构。我们将讨论与这些数据结构相关的各种操作，例如插入、删除、更新、遍历（列表）、反转以及与各种代码示例的合并。
- en: 'We will cover the following linear data structures in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下线性数据结构：
- en: Lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Sets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Tuples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Stacks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Install Go version 1.10 at [https://golang.org/doc/install](https://golang.org/doc/install),
    depending on your operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，在[https://golang.org/doc/install](https://golang.org/doc/install)安装Go版本1.10。
- en: The code files for this chapter can be found at the following GitHub URL: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter03)。
- en: Lists
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: A list is a collection of ordered elements that are used to store list of items. Unlike
    array lists, these can expand and shrink dynamically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一组有序元素集合，用于存储项目列表。与数组列表不同，这些列表可以动态地扩展和收缩。
- en: Lists also be used as a base for other data structures, such as stack and queue. Lists
    can be used to store lists of users, car parts, ingredients, to-do items, and
    various other such elements. Lists are the most commonly used linear data structures. These
    were introduced in the lisp programming language. In this chapter, linked list
    and doubly linked list are the lists we will cover in the Go language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还可以用作其他数据结构的基础，例如栈和队列。列表可以用来存储用户列表、汽车零部件、成分、待办事项以及各种其他元素。列表是最常用的线性数据结构。这些是在lisp编程语言中引入的。在本章中，我们将使用Go语言介绍链表和双链表。
- en: Let's discuss the operations related to add, update, remove, and lookup on linked
    list and doubly linked list in the following section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论与链表和双链表相关的添加、更新、删除和查找操作。
- en: LinkedList
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: '`LinkedList` is a sequence of nodes that have properties and a reference to
    the next node in the sequence. It is a linear data structure that is used to store
    data. The data structure permits the addition and deletion of components from
    any node next to another node. They are not stored contiguously in memory, which
    makes them different arrays**.**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`是一系列具有属性和指向序列中下一个节点的引用的节点。它是一种用于存储数据的线性数据结构。该数据结构允许从任何节点添加和删除与另一个节点相邻的组件。它们不是在内存中连续存储的，这使得它们与数组**不同**。'
- en: The following sections will look at the structures and methods in a linked list.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将查看链表中的结构和方法。
- en: The Node class
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点类
- en: 'The `Node` class has an integer typed variable with the name `property`. The
    class has another variable with the name `nextNode`, which is a node pointer.
    Linked list will have a set of nodes with integer properties, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Node`类有一个名为`property`的整型变量。该类还有一个名为`nextNode`的变量，它是一个指向序列中下一个节点的指针。链表将包含具有整型属性的节点集合，如下所示：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The LinkedList class
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表类
- en: 'The `LinkedList` class has the `headNode` pointer as its property. By traversing
    to `nextNode` from `headNode`, you can iterate through the linked list, as shown
    in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类具有`headNode`指针作为其属性。通过从`headNode`遍历到`nextNode`，您可以遍历链表，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The different methods of the `LinkedList` class, such as `AddtoHead`, `IterateList`,
    `LastNode`, `AddtoEnd`, `NodeWithValue`, `AddAfter`, and the `main` method, are
    discussed in the following sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中讨论了`LinkedList`类的不同方法，例如`AddtoHead`、`IterateList`、`LastNode`、`AddtoEnd`、`NodeWithValue`、`AddAfter`和`main`方法。
- en: The AddToHead method
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到头部的方法
- en: 'The `AddToHead` method adds the node to the start of the linked list. The `AddToHead` method of
    the `LinkedList` class has a parameter integer property. The property is used
    to initialize the node. A new node is instantiated and its property is set to
    the `property` parameter that''s passed. The `nextNode` points to the current
    `headNode` of `linkedList`, and `headNode` is set to the pointer of the new node
    that''s created, as shown in the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToHead`方法将节点添加到链表的开始。`LinkedList`类的`AddToHead`方法有一个整数属性参数。该属性用于初始化节点。实例化一个新节点，并将其属性设置为传递的`property`参数。`nextNode`指向`linkedList`的当前`headNode`，并将`headNode`设置为创建的新节点的指针，如下面的代码所示：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the node with the `1` property is added to the head, adding the `1` property
    to the head of `linkedList` sets `headNode` to `currentNode` with a value of `1`,
    as you can see in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当具有`1`属性的节点添加到头部时，将`1`属性添加到`linkedList`的头部将`headNode`设置为具有值`1`的`currentNode`，如下面的截图所示：
- en: '![](img/ad748616-2e91-4121-a91a-5c3b9ba06066.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad748616-2e91-4121-a91a-5c3b9ba06066.png)'
- en: 'Let''s execute this command using the `main` method. Here, we have created
    an instance of a `LinkedList` class and added the `1` and `3` integer properties
    to the head of this instance. The linked list''s `headNode` property is printed
    after adding the elements, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`main`方法执行此命令。在这里，我们创建了一个`LinkedList`类的实例，并将整数属性`1`和`3`添加到该实例的头部。在添加元素后，打印出链表的`headNode`属性，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the following commands to execute the `linked_list.go` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`linked_list.go`文件：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/7a3f103f-e736-4475-a7ca-56583342dcae.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a3f103f-e736-4475-a7ca-56583342dcae.png)'
- en: Let's take a look at the `IterateList` method in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的`IterateList`方法。
- en: The IterateList method
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代列表方法
- en: 'The `IterateList` method of the `LinkedList` class iterates from the `headNode` property
    and prints the property of the current head node. The iteration happens with the
    head node moves to `nextNode` of the `headNode` property until the current node
    is no longer equal to `nil`. The following code shows the `IterateList` method
    of the `LinkedList` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类的`IterateList`方法从`headNode`属性开始迭代并打印当前头节点的属性。迭代发生在头节点移动到`headNode`属性的`nextNode`，直到当前节点不再等于`nil`。以下代码显示了`LinkedList`类的`IterateList`方法：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The LastNode method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后一个节点方法
- en: 'The `LastNode` method of `LinkedList` returns the node at the end of the list.
    The list is traversed to check whether `nextNode` is `nil` from `nextNode` of `headNode`,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类的`LastNode`方法返回列表末尾的节点。遍历列表以检查从`headNode`的`nextNode`开始的`nextNode`是否为`nil`，如下所示：'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The AddToEnd method
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到末尾方法
- en: 'The `AddToEnd` method adds the node at the end of the list. In the following
    code, the current `lastNode` is found and its `nextNode` property is set as the
    added node:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToEnd`方法将节点添加到列表的末尾。在以下代码中，找到了当前的`lastNode`，并将其`nextNode`属性设置为添加的节点：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following screenshot, the `AddToEnd` method is invoked when the node
    with a property value of 5 is added to the end. Adding the property through this
    method creates a node with a value of 5\. The last node of the list has a property
    value of 5\. The `nextNode` property of `lastNode` is `nil`. The `nextNode` of `lastNode`
    is set to the node with a value of 5:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，当具有属性值`5`的节点添加到末尾时调用了`AddToEnd`方法。通过此方法添加属性创建了一个值为`5`的节点。列表的最后一个节点具有属性值`5`。`lastNode`的`nextNode`属性为`nil`。`lastNode`的`nextNode`被设置为具有值`5`的节点：
- en: '![](img/d8bf773f-ae86-4ec4-8079-eab1b05c1ed2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8bf773f-ae86-4ec4-8079-eab1b05c1ed2.png)'
- en: Let's take a look at the `NodeWithValue` method in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的`NodeWithValue`方法。
- en: The NodeWithValue method
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点值方法
- en: 'In the following code snippet, the `NodeWithValue` method of `LinkedList` returns
    the node with the `property` value. The list is traversed and checked to see whether
    the `property` value is equal to the parameter property:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`LinkedList`类的`NodeWithValue`方法返回具有`property`值的节点。遍历列表并检查`property`值是否等于参数`property`：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The AddAfter method
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到后面方法
- en: 'The `AddAfter` method adds the node after a specific node. The `AddAfter` method
    of `LinkedList` has `nodeProperty` and `property` parameters. A node with the `nodeProperty` value
    is retrieved using the `NodeWithValue` method. A node with `property` is created
    and added after the `NodeWith` node, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAfter`方法在特定节点之后添加节点。`LinkedList`的`AddAfter`方法有`nodeProperty`和`property`参数。使用`NodeWithValue`方法检索具有`nodeProperty`值的节点。创建一个具有`property`的节点并将其添加到`NodeWith`节点之后，如下所示：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You then get the following output when the `AddAfter` method is invoked when
    the node with a property value of 7 is added after the node with a value of 1. The
    `nextNode` property of the node with a property value of 1 is nil. The `nextNode` property
    of the node with a property value of 1 is set to the node with a value of 5:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`AddAfter`方法并在具有属性值`7`的节点之后添加具有值`1`的节点时，你将得到以下输出。具有属性值`1`的节点的`nextNode`属性为nil。具有属性值`1`的节点的`nextNode`属性被设置为具有值`5`的节点：
- en: '![](img/4702e546-c068-42ff-9d31-9b1814410e73.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4702e546-c068-42ff-9d31-9b1814410e73.png)'
- en: Let's take a look at the `main` method in the next section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看`main`方法。
- en: The main method
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法'
- en: 'The `main` method adds the nodes with integer properties of `1`, `3`, and `5`,
    as shown in the following code. A node with an integer property of `7` is added
    after the node with an integer property of `1`. The `IterateList` method is invoked
    on the `linkedList` instance, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法添加了具有整数属性`1`、`3`和`5`的节点，如下面的代码所示。在具有整数属性`1`的节点之后添加了一个具有整数属性`7`的节点。在`linkedList`实例上调用`IterateList`方法，如下所示：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main method adds `1` and `3` to the head of the linked list. `5` is added
    to the end. `7` is added after `1`. The linked list will be `3`, `1`, `7`, and `5`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法将`1`和`3`添加到链表的头部。`5`被添加到末尾。`7`被添加到`1`之后。链表将是`3`、`1`、`7`和`5`。'
- en: 'Run the following commands to execute the `linked_list.go` file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`linked_list.go`文件：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/81213159-77ca-4f5d-bcda-3822916087df.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81213159-77ca-4f5d-bcda-3822916087df.png)'
- en: Let's take a look at doubly linked list in the next section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看双向链表。
- en: Doubly linked list
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'In a doubly linked list, all nodes have a pointer to the node they are connected
    to, on either side of them, in the list. This means that each node is connected
    to two nodes, and we can traverse forward through to the next node or backward
    through to the previous node. Doubly linked lists allow insertion, deletion and,
    obviously, traversing operations. The node class definition is presented in the
    following code example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，所有节点都有一个指向它们在列表中连接的节点的指针，位于它们的两侧。这意味着每个节点连接到两个节点，我们可以通过前向遍历到下一个节点或通过后向遍历到前一个节点。双向链表允许插入、删除以及显然的遍历操作。节点类定义在以下代码示例中：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following sections explain doubly linked list methods, such as the `NodeBetweenValues`,
    `AddToHead`, `AddAfter`, `AddToEnd`, and `main` methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节解释了双向链表方法，例如`NodeBetweenValues`、`AddToHead`、`AddAfter`、`AddToEnd`和`main`方法。
- en: The NodeBetweenValues method
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`NodeBetweenValues`方法'
- en: 'The `NodeBetweenValues` method of the `LinkedList` class returns the node that
    has a property lying between the `firstProperty` and `secondProperty` values.
    The method traverses the list to find out whether the `firstProperty` and `secondProperty`
    integer properties match on consecutive nodes, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinkedList`类的`NodeBetweenValues`方法返回具有位于`firstProperty`和`secondProperty`值之间的属性的节点。该方法遍历列表以确定`firstProperty`和`secondProperty`整数属性是否在连续的节点上匹配，如下所示：'
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The example output after the node between the values method was invoked with
    1 and 5 is shown in the following screenshot. The `nextNode` of the `lastNode`
    is set to the node with a value of 5\. The node with a property value of 7 is
    between the nodes with property values of 1 and 5:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`NodeBetweenValues`方法并使用`1`和`5`作为参数后，以下截图显示了示例输出。`lastNode`的`nextNode`被设置为具有值`5`的节点。具有属性值`7`的节点位于具有属性值`1`和`5`的节点之间：
- en: '![](img/c0578a2b-1158-44d6-b779-2b695aaf820c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0578a2b-1158-44d6-b779-2b695aaf820c.png)'
- en: Let's take a look at the `AddToHead` method in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看`AddToHead`方法。
- en: The AddToHead method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AddToHead`方法'
- en: 'The `AddToHead` method of the doubly `LinkedList` class sets the `previousNode` property
    of the current `headNode` of the linked list to the node that''s added with property.
    The node with property will be set as the `headNode` of the `LinkedList` method
    in the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 双 `LinkedList` 类的 `AddToHead` 方法将当前链表 `headNode` 的 `previousNode` 属性设置为具有属性值的添加的节点。具有属性值的节点将被设置为以下代码中
    `LinkedList` 方法的 `headNode`：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The example output after the  `AddToHead` method was invoked with property
    3 is as follows. A node with property 3 is created. The `headNode` property of
    the list has a property value of 1\. The current node with property 3 has a `nextNode` property
    of nil. The `nextNode` property of the current node is set to `headNode` with
    a property value of 1\. The previous node of the `headNode` property is set to
    the current node:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `AddToHead` 方法并使用属性 3 后的示例输出如下。创建了一个属性值为 3 的节点。列表的 `headNode` 属性的属性值为 1。当前属性值为
    3 的节点有一个 `nextNode` 属性为 `nil`。当前节点的 `nextNode` 属性被设置为属性值为 1 的 `headNode`。`headNode`
    的 `previousNode` 属性被设置为当前节点：
- en: '![](img/a4ca7f7f-d7b2-4cc0-9592-f8a6efca6f9b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4ca7f7f-d7b2-4cc0-9592-f8a6efca6f9b.png)'
- en: Let's take a look at the `AddAfter` method in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的 `AddAfter` 方法。
- en: AddAfter method
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AddAfter` 方法'
- en: 'The `AddAfter` method adds a node after a specific node to a double linked
    list. The `AddAfter` method of the double `LinkedList` class searches the node
    whose value is equal to `nodeProperty`. The found node is set as the `previousNode`
    of the node that was added with property. The `nextNode` of the added node will
    be the `nodeWith` property''s `nextNode`. The `previousNode` of the added node
    will be the node that was found with value equal to `nodeProperty`. The `nodeWith` node
    will be updated to the current node. In the following code, the `AddAfter` method
    is shown:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddAfter` 方法将节点添加到双链表中特定节点之后。双 `LinkedList` 类的 `AddAfter` 方法搜索值等于 `nodeProperty`
    的节点。找到的节点被设置为具有属性值的节点的 `previousNode`。添加的节点的 `nextNode` 将是 `nodeWith` 属性的 `nextNode`。添加的节点的
    `previousNode` 将是值等于 `nodeProperty` 的找到的节点。`nodeWith` 节点将被更新为当前节点。以下代码显示了 `AddAfter`
    方法：'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The example output after the `AddAfter` method is invoked with property 7 is
    as follows. A node with property value 7 is created. The `nextNode` property of
    the created node is `nil`. The `nextNode` property of the created node is set
    to `headNode` with property value 1\. The `previousNode` property of `headNode`
    is set to the current node:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `AddAfter` 方法并使用属性 7 后的示例输出如下。创建了一个属性值为 7 的节点。创建的节点的 `nextNode` 属性为 `nil`。创建的节点的
    `nextNode` 属性被设置为属性值为 1 的 `headNode`。`headNode` 的 `previousNode` 属性被设置为当前节点：
- en: '![](img/1a2834b3-fbf4-4858-acf6-5446b5d16e41.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a2834b3-fbf4-4858-acf6-5446b5d16e41.png)'
- en: Let's take a look at the `AddToEnd` method in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的 `AddToEnd` 方法。
- en: The AddToEnd method
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`AddToEnd` 方法'
- en: 'The `AddToEnd` method adds the node to the end of the double linked list. The
    `AddToEnd` method of the `LinkedList` class creates a node whose property is set
    as the integer parameter property. The method sets the `previousNode` property
    of the node that was added with the current `lastNode` property as follows. The
    `nextNode` of the current `lastNode` property is set to a node added with property
    at the end as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddToEnd` 方法将节点添加到双链表的末尾。`LinkedList` 类的 `AddToEnd` 方法创建一个属性设置为整型参数 `property`
    的节点。该方法将添加的节点的 `previousNode` 属性设置为当前 `lastNode` 属性，如下所示。当前 `lastNode` 属性的 `nextNode`
    设置为在末尾添加具有属性值的节点，如下所示：'
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The example output after the `AddToEnd` method was invoked with property 5
    is as follows. A node with property value 5 is created. The `lastNode` of the
    list has property value 1\. The `nextNode` property of the `lastNode` is `nil`.
    The `nextNode` of the `lastNode` is set to the node with property value 5\. The
    `previousNode` of the created node is set to the node with property value 1:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `AddToEnd` 方法并使用属性 5 后的示例输出如下。创建了一个属性值为 5 的节点。列表的 `lastNode` 的属性值为 1。`lastNode`
    的 `nextNode` 属性为 `nil`。`lastNode` 的 `nextNode` 被设置为属性值为 5 的节点。创建的节点的 `previousNode`
    被设置为属性值为 1 的节点：
- en: '![](img/597173b4-caf3-48f3-b369-c29569362ae9.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/597173b4-caf3-48f3-b369-c29569362ae9.png)'
- en: Let's take a look at the `main` method in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下一节中的 `main` 方法。
- en: The main method
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'In the following code snippet, the `main` method calls the `NodeBetweenValues` property
    with `firstProperty` and `secondProperty`. The node property between values `1`
    and `5` is printed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`main` 方法调用 `NodeBetweenValues` 属性，使用 `firstProperty` 和 `secondProperty`。打印值
    `1` 和 `5` 之间的节点属性：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `main` method creates a linked list. The nodes are added to the head and
    end. The node between values `1` and `5` is searched and its property is printed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法创建了一个链表。节点被添加到头部和尾部。在值 `1` 和 `5` 之间的节点被搜索，并打印其属性。'
- en: 'Run the following command to execute the `doubly_linked_list.go` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `doubly_linked_list.go` 文件：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/617c65dd-924b-4aa7-b9d1-9d51d4688881.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/617c65dd-924b-4aa7-b9d1-9d51d4688881.png)'
- en: The next section talks about sets, which are linear data structures.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论集合，它们是线性数据结构。
- en: Sets
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A Set is a linear data structure that has a collection of values that are not
    repeated. A set can store unique values without any particular order. In the real
    world, sets can be used to collect all tags for blog posts and conversation participants
    in a chat. The data can be of Boolean, integer, float, characters, and other types.
    Static sets allow only query operations, which means operations related to querying
    the elements. Dynamic and mutable sets allow for the insertion and deletion of
    elements. Algebraic operations such as union, intersection, difference, and subset
    can be defined on the sets. The following example shows the `Set` integer with
    a `map` integer key and `bool` as a value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一个线性数据结构，它包含一组不重复的值。集合可以存储无特定顺序的唯一值。在现实世界中，集合可以用来收集博客文章和聊天参与者的所有标签。数据可以是布尔型、整数、浮点数、字符和其他类型。静态集合只允许查询操作，这意味着与查询元素相关的操作。动态可变集合允许插入和删除元素。可以在集合上定义代数运算，如并集、交集、差集和子集。以下示例显示了具有
    `map` 整数键和 `bool` 值的 `Set` 整数：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `AddElement`, `DeleteElement`, `ContainsElement`, `Intersect`, `Union`,
    and `main` methods are discussed in the following sections.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中讨论了 `AddElement`、`DeleteElement`、`ContainsElement`、`Intersect`、`Union`
    和 `main` 方法。
- en: The AddElement method
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddElement 方法
- en: 'The `AddElement` method adds the element to a set. In the following code snippet,
    the `AddElement` method of the `Set` class adds the element to `integerMap` if
    the element is not in the `Set`. The `integerMap` element has the key integer
    and value as `bool`, as shown in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddElement` 方法将元素添加到集合中。在以下代码片段中，如果元素不在 `Set` 中，`Set` 类的 `AddElement` 方法将元素添加到
    `integerMap` 中。`integerMap` 元素具有整数键和 `bool` 值，如下所示：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The example output after invoking the `AddElement` method with parameter 2
    is as follows. The check is done if there is an element with value 2\. If there
    is no element, the map is set to true with the key as 2:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数 2 调用 `AddElement` 方法后的示例输出如下。检查是否存在值为 2 的元素。如果没有元素，则将映射设置为 true，键为 2：
- en: '![](img/5bcb8123-4485-46d5-ae6d-19d96a269670.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5bcb8123-4485-46d5-ae6d-19d96a269670.png)'
- en: Let's take a look at the `DeleteElement` method in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的 `DeleteElement` 方法。
- en: The DeleteElement method
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DeleteElement 方法
- en: 'The `DeleteElement` method deletes the element from `integerMap` using the
    `delete` method. This method removes the element from the `integerMap` of the
    set, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteElement` 方法使用 `delete` 方法从 `integerMap` 中删除元素。此方法从集合的 `integerMap` 中删除元素，如下所示：'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The ContainsElement method
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ContainsElement 方法
- en: 'The `ContainsElement` method of the `Set` class checks whether or not the element
    exists in `integerMap`. The `integerMap` element is looked up with a key integer
    element, as shown in the following code example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 类的 `ContainsElement` 方法检查元素是否存在于 `integerMap` 中。使用以下代码示例中的键整数元素查找 `integerMap`
    元素：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The main method – contains element
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main` 方法 – 包含元素'
- en: 'In the following code snippet, the `main` method creates `Set`, invokes the
    `New` method, and adds elements `1` and `2`. The check is done if element `1`
    exists in the set:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`main` 方法创建 `Set`，调用 `New` 方法，并添加元素 `1` 和 `2`。检查元素 `1` 是否存在于集合中：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the following command to execute the `set.go` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `set.go` 文件：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/18bc1ab4-a4a8-4ad1-9f49-cd5ac47960af.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18bc1ab4-a4a8-4ad1-9f49-cd5ac47960af.png)'
- en: Let's take a look at the `InterSect` method in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的 `InterSect` 方法。
- en: The InterSect method
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InterSect 方法
- en: 'In the following code, the `InterSect` method on the `Set` class returns an
    `intersectionSet` that consists of the intersection of `set` and `anotherSet`.
    The `set` class is traversed through `integerMap` and checked against another
    `Set` to see if any elements exist:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`Set`类上的`InterSect`方法返回一个由`set`和`anotherSet`的交集组成的`intersectionSet`。通过`integerMap`遍历`set`类，并与另一个`Set`进行比较，以查看是否存在任何元素：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The example output after invoking the intersect with the parameter of another
    `Set` is as follows. A new `intersectSet` is created. The current `set` is iterated
    and every value is checked to see if it is in another `set`. If the value is in
    another `set`, it is added to the `set` intersect:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 调用带有另一个`Set`参数的`intersect`方法后的示例输出如下。创建一个新的`intersectSet`。遍历当前`set`，检查每个值是否在另一个`set`中。如果值在另一个`set`中，则将其添加到`set`的交集：
- en: '![](img/38334219-8c06-41f4-925d-4eee31e865fc.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38334219-8c06-41f4-925d-4eee31e865fc.png)'
- en: Let's take a look at the `Union` method in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节看看`Union`方法。
- en: The Union method
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Union`方法'
- en: 'The `Union` method on the `Set` class returns a `unionSet` that consists of
    a union of `set` and `anotherSet`. Both sets are traversed through `integerMap`
    keys, and union set is updated with elements from the sets, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`类上的`Union`方法返回一个由`set`和`anotherSet`的并集组成的`unionSet`。通过`integerMap`键遍历两个集合，并将来自集合的元素更新到并集，如下所示：'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The example output after invoking the union method with the `anotherSet` parameter
    is as follows. A new `unionSet` is created. The current set and another set values
    are iterated. Every value is added to the union set:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 调用带有`anotherSet`参数的`union`方法后的示例输出如下。创建一个新的`unionSet`。遍历当前集合和另一个集合的值。将每个值添加到并集：
- en: '![](img/3c1db8a4-701e-41c8-b595-8dc16d738359.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c1db8a4-701e-41c8-b595-8dc16d738359.png)'
- en: Let's take a look at the `main` method in the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节看看`main`方法。
- en: The main method – intersection and union
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`main`方法 - 交集和并集'
- en: 'In the following code snippet, the `main` method calls intersect and union
    on the set class, passing the `anotherSet` parameter. The intersection and union
    sets are printed as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`main`方法在集合类上调用`intersect`和`union`，并传递`anotherSet`参数。交集和并集集合按以下方式打印：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The main method takes two sets and finds the intersection and union of the sets.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法接受两个集合，并找到这两个集合的交集和并集。'
- en: 'Run the following command to execute the `set.go` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以执行`set.go`文件：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/67d39427-fa0f-4e9c-9384-6085685b886e.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67d39427-fa0f-4e9c-9384-6085685b886e.png)'
- en: The next section talks about tuples, which are finite ordered sequences of objects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论元组，它们是有序对象的有限序列。
- en: Tuples
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples are finite ordered sequences of objects. They can contain a mixture
    of other data types and are used to group related data into a data structure.
    In a relational database, a tuple is a row of a table. Tuples have a fixed size
    compared to lists, and are also faster. A finite set of tuples in the relational
    database is referred to as a relation instance. A tuple can be assigned in a single
    statement, which is useful for swapping values. Lists usually contain values of
    the same data type, while tuples contain different data. For example, we can store
    a name, age, and favorite color of a user in a tuple. Tuples were covered in [Chapter
    1](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml), *Data Structures and Algorithms*.
    The following sample shows a multi-valued expression from a function''s call (`tuples.go`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是有序对象的有限序列。它们可以包含其他数据类型的混合，并用于将相关数据分组到数据结构中。在关系型数据库中，元组是表中的一行。与列表相比，元组具有固定的大小，并且运行速度更快。关系型数据库中有限个元组的集合被称为关系实例。元组可以在单个语句中赋值，这对于交换值很有用。列表通常包含相同数据类型的值，而元组包含不同的数据。例如，我们可以在元组中存储用户的姓名、年龄和最喜欢的颜色。元组在[第1章](fe625525-d4f0-460e-aac5-cb32b02a6565.xhtml)，《数据结构和算法》中有所介绍。以下示例展示了函数调用中的多值表达式（`tuples.go`）：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `main` function calls the `h` function with the `g` function as its parameter.
    The `g` function returns the  tuple `x` and `y` integers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数以`g`函数作为参数调用`h`函数。`g`函数返回`x`和`y`整数组成的元组。'
- en: 'Run the following command to execute the `tuples.go` file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以执行`tuples.go`文件：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/72656d18-fa9a-403d-b244-8e1e12df1e35.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72656d18-fa9a-403d-b244-8e1e12df1e35.png)'
- en: The next section talks about queues, which are linear data structures.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论队列，它们是线性数据结构。
- en: Queues
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: A queue consists of elements to be processed in a particular order or based
    on priority. A priority-based queue of orders is shown in the following code,
    structured as a heap. Operations such as enqueue, dequeue, and peek can be performed
    on queue. A queue is a linear data structure and a sequential collection. Elements
    are added to the end and are removed from the start of the collection. Queues
    are commonly used for storing tasks that need to be done, or incoming HTTP requests
    that need to be processed by a server. In real life, handling interruptions in
    real-time systems, call handling, and CPU task scheduling are good examples for
    using queues.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 队列由按特定顺序或基于优先级处理的元素组成。以下代码显示了基于优先级的订单队列，其结构为堆。可以在队列上执行入队、出队和查看等操作。队列是一种线性数据结构，是一种顺序集合。元素添加到集合的末尾，从集合的开始处移除。队列通常用于存储需要执行的任务，或需要由服务器处理的传入HTTP请求。在现实生活中，处理实时系统中的中断、呼叫处理和CPU任务调度是使用队列的好例子。
- en: 'The following code shows the queue of Orders and how the `Queue` type is defined:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了订单队列以及如何定义`Queue`类型：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The following sections in the chapter discuss the `New`, `Add`, and `main` methods
    of queue.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的以下部分讨论队列的`New`、`Add`和`main`方法。
- en: The New method
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新建方法
- en: 'The `New` method on the `Order` class assigns the properties from the `priority`,
    `quantity`, and `product` parameters for name and `customerName`. The method initializes
    the properties of the order as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order`类上的`New`方法将`priority`、`quantity`和`product`参数的属性分配给`name`和`customerName`。该方法初始化订单的属性如下：'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Add method
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加方法
- en: 'In the following code snippet, the `Add` method on the `Queue` class takes
    the `order` parameter and adds it to `Queue` based on the priority. Based on this,
    the location of the `order` parameter is found by comparing it with the `priority` parameter:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`Queue`类上的`Add`方法接受`order`参数并根据优先级将其添加到`Queue`中。基于此，通过比较`order`参数与`priority`参数找到`order`参数的位置：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The example output after the `add` method is invoked with the order parameter
    is as follows. The order is checked to see whether or not it exists in the queue.
    The order is then appended to the queue:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`order`参数调用`add`方法后的示例输出如下。检查订单是否存在于队列中。然后将订单追加到队列中：
- en: '![](img/72844ffd-21b2-4ccf-a3de-bd20028220dd.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72844ffd-21b2-4ccf-a3de-bd20028220dd.png)'
- en: Let's take a look at the Main method in the next section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的`Main`方法。
- en: The main method – queues
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法 – 队列
- en: 'The `main` method creates two orders, and the priority of the orders is set
    to `2` and `1`. In the following code, the queue will first process the order
    with the higher number on the priority value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法创建了两个订单，并将订单的优先级设置为`2`和`1`。在以下代码中，队列将首先处理优先级值较高的订单：'
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the following commands to execute the `queue.go` file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`queue.go`文件：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/af04ddad-2f0f-4ae8-9923-47f53957c4ff.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af04ddad-2f0f-4ae8-9923-47f53957c4ff.png)'
- en: Let's take a look at *Synchronized queue* in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的*同步队列*。
- en: Synchronized queue
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步队列
- en: 'A synchronized queue consists of elements that need to be processed in a particular
    sequence. Passenger queue and ticket processing queues are types of synchronized queues,
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同步队列由需要按特定顺序处理的元素组成。乘客队列和票务处理队列是同步队列的类型，如下所示：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will discuss the different methods of synchronized queue in the following
    sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分讨论同步队列的不同方法。
- en: The New method
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新建方法
- en: 'The `New` method on `Queue` initializes `message`, `queuePass`, and `queueTicket`
    with `nil` values. The `make` method creates a `Queue` with a `chan` integer parameter, as
    follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`上的`New`方法使用`nil`值初始化`message`、`queuePass`和`queueTicket`。`make`方法创建一个带有`chan`整数参数的`Queue`，如下所示：'
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the following code example, the `Go` routine handles selecting the message
    based on the type of message and the respective queue to process it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，`Go`例程根据消息类型和相应的队列来选择消息：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The StartTicketIssue method
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始发票方法
- en: 'The `StartTicketIssue` method starts the issuing of a ticket for passengers
    standing in a queue. The `StartTicketIssue` method on `Queue` sends `messageTicketStart`
    to the message queue and `queueTicket` receives the message. The ticket issue
    is started by sending messages to the queue, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartTicketIssue` 方法启动对排队乘客的票务发放。`Queue` 上的 `StartTicketIssue` 方法向消息队列发送 `messageTicketStart`
    消息，`queueTicket` 接收该消息。通过向队列发送消息开始票务发放，如下所示：'
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The EndTicketIssue method
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The EndTicketIssue method
- en: 'The `EndTicketIssue` method finishes the issuing of a ticket to a passenger
    standing in the queue. In the following code, the `EndTicketIssue` method on `Queue`
    sends `messageTicketEnd` to the message queue. The ticket issue is ended by sending
    the message:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`EndTicketIssue` 方法完成对排队乘客的票务发放。在以下代码中，`Queue` 上的 `EndTicketIssue` 方法向消息队列发送
    `messageTicketEnd` 消息。通过发送以下消息结束票务发放：'
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The ticketIssue method
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The ticketIssue method
- en: 'The `ticketIssue` method starts and finishes the issuing of a ticket to the
    passenger. The `ticketIssue` method invokes the `StartTicketIssue` and `EndTicketIssue` methods
    after `Sleep` calls for 10 seconds and two seconds. The ticket is issued after
    the ticket is processed, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ticketIssue` 方法开始并结束对乘客的票务发放。`ticketIssue` 方法在调用 `Sleep` 10秒和2秒后调用 `StartTicketIssue`
    和 `EndTicketIssue` 方法。票务在票务处理完毕后发放，如下所示代码：'
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The StartPass method
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The StartPass method
- en: 'The `StartPass` method starts the passenger queue moving toward the ticket
    counter. The `StartPass` method on `Queue` sends `messagePassStart` to the message
    queue and `queuePass` receives the message. Passengers are moved into the queue
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartPass` 方法启动乘客队列向售票柜台移动。`Queue` 上的 `StartPass` 方法向消息队列发送 `messagePassStart`
    消息，`queuePass` 接收该消息。乘客按照以下方式被移动到队列中：'
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The EndPass method
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The EndPass method
- en: 'The `EndPass` method stops the passenger queue moving toward the ticket counter.
    The `EndPass` method on `Queue` sends `messagePassEnd` to the message queue in
    the following code. The passenger is moved to the counter for ticket processing,
    and the passenger is then out of the queue:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`EndPass` 方法停止乘客队列向售票柜台移动。在以下代码中，`Queue` 上的 `EndPass` 方法向消息队列发送 `messagePassEnd`
    消息。乘客被移动到柜台进行票务处理，然后乘客离开队列：'
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The passenger method
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The passenger method
- en: 'The `passenger` methods starts and ends passenger movement to the queue. The
    `passenger` method invokes the `StartPass` method, and the `EndPass` method ends
    after sleep calls for 10 seconds and two seconds. The passenger moves into the
    queue and reaches the ticket counter, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`passenger` 方法启动并结束乘客向队列的移动。`passenger` 方法调用 `StartPass` 方法，并在调用 `sleep` 10秒和2秒后结束
    `EndPass` 方法。乘客进入队列并到达售票柜台，如下所示代码：'
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The main method
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The main method
- en: 'The `main` method calls the `passenger` and `ticketIssue` methods after creating
    a queue. The passenger enters into the queue and a ticket is issued at the counter
    in the processing queue, as explained in the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法在创建队列后调用 `passenger` 和 `ticketIssue` 方法。乘客进入队列，在处理队列的柜台发放票务，如下所示代码：'
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the following command to execute the `sync_queue.go` file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `sync_queue.go` 文件：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令后，我们得到以下输出：
- en: '![](img/31ab2f30-3205-462c-acb7-d7ec21c7b32d.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31ab2f30-3205-462c-acb7-d7ec21c7b32d.png)'
- en: The next section talks about `Stacks`, which are linear data structures.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论 `Stacks`，它们是线性数据结构。
- en: Stacks
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stacks
- en: 'A stack is a last in, first out structure in which items are added from the
    top. Stacks are used in parsers for solving maze algorithms. `Push`, `pop`, `top`,
    and `get size` are the typical operations that are allowed on stack data structures.
    Syntax parsing, backtracking, and compiling time memory management are some real-life
    scenarios where stacks can be used. An example of stack implementation is as follows
    (`stack.go`):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种后进先出结构，其中项目从顶部添加。栈用于解析器中解决迷宫算法。`Push`、`pop`、`top` 和 `get size` 是允许在栈数据结构上执行的典型操作。语法解析、回溯和编译时内存管理是一些可以使用栈的真实场景。以下是一个栈实现的示例（`stack.go`）：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `Element` class has `elementValue` as an attribute. The `String` method
    returns the element's `elementValue`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Element` 类有一个 `elementValue` 属性。`String` 方法返回元素的 `elementValue`。'
- en: Stacks methods, such as `New`, `Push`, `Pop`, and `main` are presented in the
    following sections.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中介绍了栈方法，如 `New`、`Push`、`Pop` 和 `main`。
- en: The New method
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The New method
- en: 'The `New` method on the `Stack` class creates a dynamic array of elements.
    The `Stack` class has the count and array pointer of elements. The code snippet
    with the `Stack` class definition and the `New` method is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`类的`New`方法创建了一个动态元素数组。`Stack`类具有元素的计数和数组指针。以下是与`Stack`类定义和`New`方法相关的代码片段：'
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The Push method
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推入方法
- en: 'The `Push` method adds the node to the top of the `stack` class. In the following
    code sample, the `Push` method on the `Stack` class adds the element to the elements
    array and increases the `Count` element, while the `append` method adds the element
    to the elements of the `stack` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Push`方法将节点添加到`stack`类的顶部。在下面的代码示例中，`Stack`类的`Push`方法将元素添加到元素数组中，并增加`Count`元素，而`append`方法将元素添加到`stack`类的元素中：'
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The example output after the push method is invoked with parameter elements
    as follows. The element with the value 7 is pushed to the stack. The count of
    the elements before pushing to the stack is 2, and, after pushing to the stack,
    this figure is 3:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 调用带有参数元素的`push`方法后的示例输出如下。将值7的元素推入栈中。推入栈之前的元素计数为2，推入栈后这个数字变为3：
- en: '![](img/f214116d-8e1b-485b-9ef1-8b9ab6164ea4.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f214116d-8e1b-485b-9ef1-8b9ab6164ea4.png)'
- en: Let's take a look at the `Pop` method in the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节的`Pop`方法。
- en: The Pop method
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出方法
- en: 'The `Pop` method on the `Stack` implementation removes the last element from
    the element array and returns the element, as shown in the following code. The
    `len` method returns the length of the elements array:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`实现的`Pop`方法从元素数组中移除最后一个元素并返回该元素，如下面的代码所示。`len`方法返回元素数组的长度：'
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The example output after the `Pop` method is invoked is as follows. The element
    value 5 is passed and added to the `Pop` method. The count of elements before
    invoking the `Pop` method is 2\. The count of the elements after calling the `Pop`
    method is 1:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Pop`方法后的示例输出如下。将元素值5传递并添加到`Pop`方法中。调用`Pop`方法之前的元素计数为2。调用`Pop`方法后的元素计数为1：
- en: '![](img/01c29a22-a9a8-4956-9d24-50c44436658a.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01c29a22-a9a8-4956-9d24-50c44436658a.png)'
- en: Let's take a look at the `main` method in the next section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节的`main`方法。
- en: The main method
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'In the following code section, the `main` method creates a `stack`, calls the
    `New` method, and pushes the elements after initializing them. The popped-out
    element value and the order is printed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码部分，`main`方法创建了一个`stack`，调用`New`方法，并在初始化后推入元素。打印出弹出的元素值和顺序：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the following commands to execute the `stack.go` file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行`stack.go`文件：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After executing the preceding command, we get the following output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的命令后，我们得到以下输出：
- en: '![](img/cd05e596-7e16-405a-a158-95dc1fde40d5.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd05e596-7e16-405a-a158-95dc1fde40d5.png)'
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the definition of `LinkedList`, double `LinkedList`, `Tuples`,
    `Sets`, `Queues`, and `Stacks`. The `LinkedList` methods – `AddToHead`, `AddToEnd`,
    `LastNode`, and `iterateList`—were also covered in this chapter. In addition,
    a priority queue was modeled as a heap of orders to be processed, sync queue was
    presented as passenger and ticket processing queues, and tuples were explained
    in a context in which a function returns a multivalued expression. The `new`,
    `push`, `pop`, and `string` methods for `Stack` were explained with code samples.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了`LinkedList`、双`LinkedList`、`Tuples`、`Sets`、`Queues`和`Stacks`的定义。本章还介绍了`LinkedList`方法——`AddToHead`、`AddToEnd`、`LastNode`和`iterateList`。此外，优先队列被建模为待处理订单的堆，同步队列被展示为乘客和票务处理队列，元组在函数返回多值表达式的上下文中进行了解释。`Stack`的`new`、`push`、`pop`和`string`方法通过代码示例进行了说明。
- en: In the next chapter, we will cover areas such as the `Trees`, `Tables`, `Containers`,
    and `Hash` functions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖`Trees`、`Tables`、`Containers`和`Hash`函数等领域。
- en: Questions
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Where can you use double linked list? Please provide an example.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在哪里使用双链表？请提供一个示例。
- en: Which method on linked list can be used for printing out node values?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个链表方法可以用来打印节点值？
- en: Which queue was shown with channels from the Go language?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个队列是用Go语言中的通道展示的？
- en: Write a method that returns multiple values. What data structure can be used
    for returning multiple values?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个返回多个值的方法。可以使用什么数据结构来返回多个值？
- en: Can set have duplicate elements?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能设置有重复元素的吗？
- en: Write a code sample showing the union and intersection of two sets.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个代码示例，展示两个集合的并集和交集。
- en: In a linked list, which method is used to find the node between two values?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链表中，使用哪种方法来查找两个值之间的节点？
- en: We have elements that are not repeated and unique. What is the correct data
    structure that represents the collection?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一些不重复且唯一的元素。表示这些集合的正确数据结构是什么？
- en: In Go, how do you generate a random integer between the values 3 and 5?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Go 语言中，如何生成介于 3 和 5 之间的随机整数？
- en: Which method is called to check if an element of value 5 exists in the Set?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 Set 中检查是否存在值为 5 的元素？
- en: Further reading
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To read more about `LinkedLists`, `Sets`, `Tuples`, and `Stacks`, consult the
    following sources:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `LinkedLists`、`Sets`、`Tuples` 和 `Stacks` 的信息，请参考以下资料：
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式*》，作者 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*算法导论 第3版*》，作者 Thomas H. Cormen、Charles E. Leiserson、Ronald L. Rivest 和 Clifford
    Stein
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*数据结构与算法：简单入门*》，作者 Rudolph Russell
