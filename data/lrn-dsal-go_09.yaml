- en: Dynamic Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态数据结构
- en: A **dynamic data structure** is a set of elements in memory that has the adaptability
    to expand or shrink. This ability empowers a software engineer to control precisely
    how much memory is used. Dynamic data structures are used for handling generic
    data in a key-value store. They can be used in distributed caching and storage
    management. Dynamic data structures are valuable in many circumstances in which
    dynamic addition or deletion of elements occur. They are comparable in capacity
    to a smaller relational database or an in-memory database. These data structures
    are used in marketing and customer relationship management applications. Dictionaries,
    TreeSets, and sequences are examples of dynamic data structures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态数据结构**是内存中一组元素，它具有扩展或收缩的适应性。这种能力使软件工程师能够精确控制使用的内存量。动态数据结构用于在键值存储中处理通用数据。它们可用于分布式缓存和存储管理。在需要动态添加或删除元素的情况下，动态数据结构非常有价值。它们的容量与较小的关系数据库或内存数据库相当。这些数据结构用于市场营销和客户关系管理应用程序。字典、TreeSet
    和序列是动态数据结构的例子。'
- en: In this chapter, we will explain what dictionaries, TreeSets, and sequences
    are and show you how they are implemented with the help of code examples.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释字典、TreeSet 和序列是什么，并通过代码示例向您展示它们的实现方式。
- en: 'This chapter covers the following dynamic data structures:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下动态数据结构：
- en: Dictionaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: 'TreeSets:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TreeSet：
- en: Synchronized TreeSets
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步 TreeSet
- en: Mutable TreeSets
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变 TreeSet
- en: 'Sequences:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列：
- en: Farey
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Farey
- en: Fibonacci
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fibonacci
- en: Look-and-say
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Look-and-say
- en: Thue–Morse
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thue–Morse
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Install Go Version 1.10 from [https://golang.org/doc/install](https://golang.org/doc/install) for
    your OS.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://golang.org/doc/install](https://golang.org/doc/install) 为您的操作系统安装
    Go 版本 1.10。
- en: The GitHub URL for the code in this chapter is as follows: [https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码的 GitHub URL 如下所示：[https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Data-Structures-and-Algorithms-with-Golang/tree/master/Chapter07)。
- en: Dictionaries
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: 'A **dictionary** is a collection of unique key and value pairs. A dictionary
    is a broadly useful data structure for storing a set of data items. It has a key,
    and each key has a solitary item associated with it. When given a key, the dictionary
    will restore the item associated with that key. These keys can be of any type:
    strings, integers, or objects. Where we need to sort a list, an element value
    can be retrieved utilizing its key. Add, remove, modify, and lookup operations
    are allowed in this collection. A dictionary is similar to other data structures,
    such as hash, map, and HashMap. The key/value store is used in distributed caching
    and in memory databases. Arrays differ from dictionaries in how the data is accessed.
    A set has unique items, whereas a dictionary can have duplicate values.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**是一组唯一的键值对集合。字典是一种广泛有用的数据结构，用于存储一组数据项。它有一个键，每个键都与一个单独的项相关联。当给定一个键时，字典将恢复与该键关联的项。这些键可以是任何类型：字符串、整数或对象。当我们需要排序一个列表时，可以通过其键检索元素值。在这个集合中允许添加、删除、修改和查找操作。字典类似于其他数据结构，如哈希、映射和HashMap。键/值存储用于分布式缓存和内存数据库。数组与字典在数据访问方式上有所不同。集合具有唯一项，而字典可以有重复值。'
- en: 'Dictionary data structures are used in the following streams:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 字典数据结构在以下流中使用：
- en: Phone directories
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话簿
- en: Router tables in networking
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中的路由表
- en: Page tables in operating systems
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统中的页面表
- en: Symbol tables in compilers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器中的符号表
- en: Genome maps in biology
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生物学中的基因组图谱
- en: 'The following code shows how to initialize and modify a dictionary. In this
    snippet, the dictionary has the key `DictKey` and is a string:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何初始化和修改一个字典。在这个片段中，字典的键是 `DictKey`，并且是一个字符串：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following sections talk about the type and methods in dictionaries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将讨论字典中的类型和方法。
- en: DictVal type
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DictVal 类型
- en: 'The dictionary has the value `DictVal` of type `string` mapped to `DictKey`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 字典将 `DictKey` 类型的 `DictVal` 值映射到：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Dictionary class
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典类
- en: 'The dictionary in the following code is a class with dictionary elements, with
    `DictKey` as the key and `DictVal` as the value. It has a `sync.RWMutex` property, `lock`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码中的字典是一个具有字典元素的类，其中 `DictKey` 是键，`DictVal` 是值。它有一个 `sync.RWMutex` 属性，`lock`： '
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Put`, `Remove`, `Contain`, `Find`, `Rest`, `NumberofElements`, `GetKeys`,
    `GetValues`, and `Main` methods are discussed in the following sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分中讨论了 `Put`、`Remove`、`Contain`、`Find`、`Rest`、`NumberofElements`、`GetKeys`、`GetValues`
    和 `Main` 方法。
- en: Put method
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Put 方法
- en: 'A has a `Put` method, as shown in the following example, that takes the `key`
    and `value` parameters of the `DictKey` and `DictVal` types respectively. The
    `Lock` method of the dictionary''s `lock` instance is invoked, and the `Unlock`
    method is deferred. If there are empty `map` elements in the dictionary, elements
    are initialized using `make`. The `map` elements are set with a `key` and a `value`
    if they are not empty:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `Put` 方法，如下面的示例所示，它分别接受 `DictKey` 和 `DictVal` 类型的 `key` 和 `value` 参数。调用字典
    `lock` 实例的 `Lock` 方法，并延迟 `Unlock` 方法。如果字典中有空的 `map` 元素，则使用 `make` 初始化元素。如果 `map`
    元素不为空，则设置 `key` 和 `value`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The example output of the `put` method is as follows. The `put` method takes
    the key 1 and value 1\. The `map` is updated with `key` and `value`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`put` 方法的示例输出如下。`put` 方法接受键 1 和值 1。`map` 使用 `key` 和 `value` 更新：'
- en: '![](img/1530c681-3097-46cc-862a-9762725f2f80.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1530c681-3097-46cc-862a-9762725f2f80.png)'
- en: Remove method
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Remove 方法
- en: 'A dictionary has a `remove` method, as shown in the following code, which has
    a `key` parameter of the `DictKey` type. This method returns a `bool` value if
    the value associated with `Dictkey` is removed from the map:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 字典有一个 `remove` 方法，如下面的代码所示，它有一个 `DictKey` 类型的 `key` 参数。如果从映射中移除了与 `Dictkey`
    关联的值，则此方法返回 `bool` 值：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Contains method
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Contains 方法
- en: 'In the following code, the `Contains` method has an input parameter, `key`,
    of the `DictKey` type, and returns `bool` if `key` exists in the dictionary:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`Contains` 方法有一个输入参数 `key`，类型为 `DictKey`，如果 `key` 存在于字典中，则返回 `bool`：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Find method
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Find 方法
- en: 'The `Find` method takes the `key` parameter of the `DictKey` type and returns
    the `DictVal` type associated with the key. The following code snippet explains
    the `Find` method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find` 方法接受 `DictKey` 类型的 `key` 参数，并返回与键关联的 `DictVal` 类型。以下代码片段解释了 `Find` 方法：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reset method
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reset 方法
- en: 'The `Reset` method of the `Dictionary` class is presented in the following
    snippet. The `Lock` method of the dictionary''s `lock` instance is invoked and
    `Unlock` is deferred. The `elements` map is initialized with a `map` of the `DictKey` key
    and the `DictVal` value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary` 类的 `Reset` 方法在以下代码片段中展示。调用字典 `lock` 实例的 `Lock` 方法，并延迟 `Unlock`。`elements`
    映射使用 `DictKey` 键和 `DictVal` 值的映射初始化：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: NumberOfElements method
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumberOfElements 方法
- en: 'The `NumberOfElements` method of the `Dictionary` class returns the length
    of the `elements` map. The `RLock` method of the `lock` instance is invoked. The
    `RUnlock` method of the `lock` instance is deferred before returning the length;
    this is shown in the following code snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary` 类的 `NumberOfElements` 方法返回 `elements` 映射的长度。`lock` 实例的 `RLock`
    方法被调用。在返回长度之前，将 `lock` 实例的 `RUnlock` 方法延迟；这在上面的代码片段中显示：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: GetKeys method
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetKeys 方法
- en: 'The `GetKeys` method of the `Dictionary` class is shown in the following code
    snippet. The method returns the array of the `DictKey` elements. The `RLock` method
    of the lock instance is invoked, and the `RUnlock` method is deferred. The dictionary
    keys are returned by traversing the element''s map:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary` 类的 `GetKeys` 方法在以下代码片段中展示。该方法返回 `DictKey` 元素的数组。调用锁实例的 `RLock`
    方法，并延迟 `RUnlock` 方法。通过遍历元素的映射返回字典键：'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: GetValues method
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetValues 方法
- en: 'The `GetValues` method of the `Dictionary` class returns the array of the `DictVal`
    elements. In the following code snippet, the `RLock` method of the `lock` instance
    is invoked and the `RUnlock` method is deferred. The array of dictionary values
    is returned after traversing the element''s map:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary` 类的 `GetValues` 方法返回 `DictVal` 元素的数组。在以下代码片段中，调用 `lock` 实例的 `RLock`
    方法，并延迟 `RUnlock` 方法。在遍历元素的映射后，返回字典值的数组：'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main method
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'The following code shows the main method, where the dictionary is initialized
    and printed:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了主方法，其中初始化并打印了字典：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the following commands to execute the `dictionary.go` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行 `dictionary.go` 文件：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c54f4a35-f573-4d58-b8fd-16b6e1319ae1.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c54f4a35-f573-4d58-b8fd-16b6e1319ae1.png)'
- en: Let's take a look at the `TreeSet` data structure in the following section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下部分中的 `TreeSet` 数据结构。
- en: TreeSets
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TreeSet
- en: '**TreeSets** are used in marketing and customer relationship management applications.
    `TreeSet` is a set that has a binary tree with unique elements. The elements are
    sorted in a natural order. In the following code snippet, `TreeSet` creation,
    insertion, search, and `stringify` operations are presented. `TreeSet` allows
    only one null value if the set is empty. The elements are sorted and stored as
    elements. The `add`, `remove`, and `contains` functions cost *log*(*n*) on `TreeSets`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**TreeSets** 在市场营销和客户关系管理应用中使用。`TreeSet` 是一个具有唯一元素的二叉树集合。元素按自然顺序排序。在下面的代码片段中，展示了
    `TreeSet` 的创建、插入、搜索和 `stringify` 操作。如果集合为空，`TreeSet` 只允许一个 `null` 值。元素按顺序存储。`add`、`remove`
    和 `contains` 函数在 `TreeSets` 上的成本为 *log*(*n*)：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will discuss the different `TreeSet` methods in the following sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中讨论不同的 `TreeSet` 方法。
- en: InsertTreeNode method
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入树节点方法
- en: 'The `InsertTreeNode` method of the `TreeSet` class takes `treeNodes` variable
    arguments of the `TreeNode` type. In the following code, the elements with the
    `key` and `value` are inserted in the binary search tree of `TreeSet`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet` 类的 `InsertTreeNode` 方法接受 `treeNodes` 变量参数，参数类型为 `TreeNode`。在下面的代码中，具有
    `key` 和 `value` 的元素被插入到 `TreeSet` 的二叉搜索树中：'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The example output of the `InsertTreeNode` method is as follows. The `InsertTreeNode`
    method takes `treeNodes` as the parameter. `treeNodes` are inserted with `rootNode`,
    which has a value of `8`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`InsertTreeNode` 方法的示例输出如下。`InsertTreeNode` 方法接受 `treeNodes` 作为参数。`treeNodes`
    被插入到具有值为 `8` 的 `rootNode` 中：'
- en: '![](img/9dedad06-c40b-4e8b-8e6a-7e8626550c6f.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dedad06-c40b-4e8b-8e6a-7e8626550c6f.png)'
- en: Delete method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除方法
- en: 'The `Delete` method of the `TreeSet` class is shown in the following code snippet.
    In this method, `treeNodes` with the provided key are removed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet` 类的 `Delete` 方法在下面的代码片段中展示。在此方法中，具有提供键的 `treeNodes` 被移除：'
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: InOrderTraverseTree method
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中序遍历树方法
- en: 'The `InOrderTraverseTree` method of the `BinarySearchTree` class takes `function`
    as a parameter. The `RLock` method of the `lock` instance is invoked. The `RUnlock`
    method of the tree''s `lock` instance is deferred. `InOrderTraverseTree` is invoked
    with the `rootNode` of the tree and function as parameters:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearchTree` 类的 `InOrderTraverseTree` 方法接受 `function` 作为参数。`lock` 实例的
    `RLock` 方法被调用。`lock` 实例的 `RUnlock` 方法被延迟。`InOrderTraverseTree` 使用树的 `rootNode`
    和函数作为参数被调用：'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The inOrderTraverseTree method
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中序遍历树方法
- en: 'The `inOrderTraverseTree` method traverses from the left of the tree to root
    of the node and then to the right of the tree. The `inOrderTraverseTree` method
    takes `treeNode` and `function` as parameters. The method recursively calls the
    `inOrderTraverseTree` method with `function` and then `leftNode` and `rightNode`
    in separate calls. The `function` method is invoked with the `value` of `treeNode`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`inOrderTraverseTree` 方法从树的左侧遍历到节点根，然后到树的右侧。`inOrderTraverseTree` 方法接受 `treeNode`
    和 `function` 作为参数。该方法递归地调用 `inOrderTraverseTree` 方法，并分别使用 `function` 和 `leftNode`、`rightNode`
    进行单独调用。`function` 方法使用 `treeNode` 的 `value` 被调用：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: PreOrderTraverseTree method
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预序遍历树方法
- en: 'The `PreOrderTraverseTree` method of the `BinarySearchTree` class takes the
    function as its parameter. The `Lock` method on the tree''s `lock` instance is
    invoked first, and the `Unlock` method is deferred. The `PreOrderTraverseTree`
    method is called with the `rootNode` of the tree and function as parameters:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearchTree` 类的 `PreOrderTraverseTree` 方法接受函数作为其参数。首先在树的 `lock` 实例上调用
    `Lock` 方法，然后延迟调用 `Unlock` 方法。使用树的 `rootNode` 和函数作为参数调用 `PreOrderTraverseTree`
    方法：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preOrderTraverseTree method
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预序遍历树方法
- en: 'The `preOrderTraverseTree` method traverses the tree from the root, to the
    left and right of the tree. The `preOrderTraverseTree` method takes `treeNode`
    and `function` as parameters. If `treeNode` is not `nil`, `function` is invoked
    with the `value` of `treeNode`, and the `preOrderTraverseTree` method is invoked
    with `function` and `leftNode` and `rightNode` as parameters:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`preOrderTraverseTree` 方法从根开始遍历树，到树的左侧和右侧。`preOrderTraverseTree` 方法接受 `treeNode`
    和 `function` 作为参数。如果 `treeNode` 不是 `nil`，则使用 `treeNode` 的 `value` 调用 `function`，然后使用
    `function` 和 `leftNode`、`rightNode` 作为参数调用 `preOrderTraverseTree` 方法：'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Search method
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索方法
- en: 'The `Search` method of the `TreeSet` class takes a variable argument named
    `treeNodes` of the `TreeNode` type and returns true if one of those `treeNodes`
    exists; otherwise, it returns `false`. The code following snippet outlines the
    `Search` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet` 类的 `Search` 方法接受一个名为 `treeNodes` 的变量参数，参数类型为 `TreeNode`。如果这些 `treeNodes`
    中的任何一个存在，则返回 `true`；否则，返回 `false`。以下代码片段概述了 `Search` 方法：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The String method
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String 方法
- en: 'In the following code snippet, the `String` method of the `TreeSet` class returns
    the string version of `bst`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`TreeSet` 类的 `String` 方法返回 `bst` 的字符串版本：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main method
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'The `main` method in the `TreeSet` class creates a `TreeSet` with `TreeNodes`.
    The following snippet creates a `TreeSet` and invokes the `String` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeSet` 类中的 `main` 方法使用 `TreeNodes` 创建一个 `TreeSet`。以下代码片段创建了一个 `TreeSet`
    并调用了 `String` 方法：'
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the following commands to execute the `treeset.go` and `binarysearchtree.go`
    files:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以运行 `treeset.go` 和 `binarysearchtree.go` 文件：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/76ae2280-d1ba-46d3-811a-71e9be2026d9.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76ae2280-d1ba-46d3-811a-71e9be2026d9.png)'
- en: The next section talks about the synchronized `TreeSet` data structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论同步的 `TreeSet` 数据结构。
- en: Synchronized TreeSets
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步 TreeSet
- en: 'Operations that are performed on synchronized TreeSets are synchronized across
    multiple calls that access the elements of TreeSets. Synchronization in TreeSets
    is achieved using a `sync.RWMutex` lock. The `lock` method on the tree''s `lock`
    instance is invoked, and the unlock method is deferred before the `tree` nodes
    are inserted, deleted, or updated:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步 TreeSet 上执行的操作在多个调用之间同步，这些调用访问 TreeSet 的元素。TreeSet 中的同步是通过使用 `sync.RWMutex`
    锁来实现的。在树的 `lock` 实例上调用 `lock` 方法，并在插入、删除或更新 `tree` 节点之前延迟调用解锁方法：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Mutable TreeSets
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变 TreeSet
- en: '**Mutable TreeSets** can use `add`, `update`, and `delete` operations on the
    tree and its nodes. `insertTreeNode` updates the tree by taking the `rootNode`
    and `treeNode` parameters to be updated. The following code snippet shows how
    to insert a `TreeNode` with a given `rootNode` and `TreeNode`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**可变 TreeSet** 可以在树及其节点上使用 `add`、`update` 和 `delete` 操作。`insertTreeNode` 通过传递要更新的
    `rootNode` 和 `treeNode` 参数来更新树。以下代码片段展示了如何使用给定的 `rootNode` 和 `TreeNode` 插入一个 `TreeNode`：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's discuss the different mutable TreeSets in the following sections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的几节中讨论不同的可变 TreeSet。
- en: RemoveNode method
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RemoveNode 方法
- en: 'The `RemoveNode` method of a `BinarySearchTree` is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinarySearchTree` 的 `RemoveNode` 方法如下：'
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Treeset.bst
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Treeset.bst
- en: 'The TreeNode''s can be updated by accessing `treeset.bst` and traversing the
    binary search tree from the `rootNode` and the left and right nodes of `rootNode`,
    as shown here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过访问 `treeset.bst` 并从 `rootNode` 及其左右节点遍历二叉搜索树来更新 TreeNode，如下所示：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, we will take a look at sequences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看序列。
- en: Sequences
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: A **sequence** is a set of numbers that are grouped in a particular order. The
    number of elements in the stream can be infinite, and these sequences are called
    **streams**. A **subsequence** is a sequence that's created from another sequence.
    The relative positions of the elements in a subsequence will remain the same after
    deleting some of the elements in a sequence.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列** 是一组按特定顺序排列的数字。流中元素的数量可以是无限的，这些序列被称为 **流**。**子序列** 是从另一个序列创建的序列。在删除序列中的一些元素后，子序列中元素的相对位置将保持不变。'
- en: In the following sections, we will take a look at different sequences such as
    the Farey sequence, Fibonacci sequence, look-and-say, and Thue–Morse.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将查看不同的序列，如 Farey 序列、Fibonacci 序列、look-and-say 和 Thue–Morse。
- en: Farey sequence
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Farey 序列
- en: 'A **Farey sequence** consists of reduced fractions with values between zero
    and one. The denominators of the fractions are less than or equal to *m*, and
    organized in ascending order. This sequence is called a **Farey series**. In the
    following code, reduced fractions are displayed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Farey 序列** 由介于零和一之间的简化分数组成。分数的分母小于或等于 *m*，并按升序排列。这个序列被称为 **Farey 系列**。在以下代码中，显示了简化分数：'
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's take a look at the different methods in a Farey sequence.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Farey 序列中的不同方法。
- en: String method
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String 方法
- en: 'The `fraction` class has the numerator and denominator integer properties.
    The `String` method of the `fraction` class, as shown in the following snippet,
    returns a `string` version of `fraction`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`fraction` 类具有分子和分母的整数属性。`fraction` 类的 `String` 方法，如以下代码片段所示，返回 `fraction`
    的字符串版本：'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The g method
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: g 方法
- en: 'The `g` method takes two fractions and prints the series of reduced fractions.
    The `g` function takes an `l` or an `r` fraction, and `num` int as arguments to
    print the reduced fraction as a series. The following code snippet shows the `g`
    method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`g` 方法接受两个分数并打印出一系列简化的分数。`g` 函数接受 `l` 或 `r` 分数以及 `num` 整数作为参数，以打印简化的分数作为一系列。以下代码片段展示了
    `g` 方法：'
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main method
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'The following snippet shows the `main` method. In the `main` method, reduced
    fraction series are printed using recursion:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 `main` 方法。在 `main` 方法中，使用递归打印简化的分数序列：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the following command to execute the `farey_sequence.go` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `farey_sequence.go` 文件：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c72f8003-7a5f-45f4-9e18-c45224a1cfa0.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c72f8003-7a5f-45f4-9e18-c45224a1cfa0.png)'
- en: The next section talks about the Fibonacci sequence data structure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论斐波那契数列数据结构。
- en: Fibonacci sequence
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斐波那契数列
- en: 'The **Fibonacci sequence** consists of a list of numbers in which every number
    is the sum of the two preceding numbers. Pingala, in 200 BC, was the first to
    come up with Fibonacci numbers. The Fibonacci sequence is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**斐波那契数列**由一系列数字组成，其中每个数字都是前两个数字的和。Pingala 在公元前200年首次提出了斐波那契数。斐波那契数列如下：'
- en: '![](img/244bad99-448a-4695-948d-357f09cd675c.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/244bad99-448a-4695-948d-357f09cd675c.png)'
- en: 'The recurrence relation for the Fibonacci sequence is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列的递推关系如下：
- en: '![](img/3f724d68-7f38-468d-b3e7-36c2381890de.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f724d68-7f38-468d-b3e7-36c2381890de.png)'
- en: 'The seed values are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 种子值如下：
- en: '![](img/e6795ba4-2732-44a7-9f12-9c97322bd705.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6795ba4-2732-44a7-9f12-9c97322bd705.png)'
- en: 'A Fibonacci prime is a Fibonacci number that is a prime number. The Fibonacci
    prime series is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个斐波那契素数是一个素数的斐波那契数。斐波那契素数序列如下：
- en: '![](img/78c47dff-13da-4d31-8cdb-8bd652511823.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78c47dff-13da-4d31-8cdb-8bd652511823.png)'
- en: Computer algorithms such as the Fibonacci search technique, heap, and cubes
    are popular applications of Fibonacci numbers. Pseudorandom number generators
    use Fibonacci numbers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机算法，如斐波那契搜索技术、堆和立方体，是斐波那契数的流行应用。伪随机数生成器使用斐波那契数。
- en: 'The following code snippet shows the Fibonacci sequence and recursive Fibonacci
    number calculation. The `Series` function is presented as well. The `Series` function
    calculates the Fibonacci numbers in the sequence:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了斐波那契数列及其递归斐波那契数计算。同时展示了 `Series` 函数。`Series` 函数用于计算数列中的斐波那契数：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The different methods of the Fibonacci sequence are discussed in the following
    sections.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论斐波那契数列的不同方法。
- en: FibonacciNumber method
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FibonacciNumber 方法
- en: 'The `FibonacciNumber` method takes the integer *n* and, by recursion, calculates
    the Fibonacci numbers. The following code snippet shows this recursion:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`FibonacciNumber` 方法接受一个整数 *n*，并通过递归计算斐波那契数。以下代码片段展示了这种递归：'
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Main method
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主方法
- en: 'The `main` method in the following code snippet shows how the Fibonacci sequence
    is calculated:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中的 `main` 方法展示了斐波那契数列的计算方法：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the following command to execute the `fibonacci_sequence.go` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `fibonacci_sequence.go` 文件：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f49528c1-7e69-4f7b-b10f-48f275b0c28b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f49528c1-7e69-4f7b-b10f-48f275b0c28b.png)'
- en: The next section talks about the look-and-say data structure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论观察法数据结构。
- en: Look-and-say
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察法
- en: 'The **look-and-say** sequence is a sequence of integers:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察法**序列是一个整数序列：'
- en: '![](img/c17bb938-f6e8-40e9-91dc-13a0c6e0bc43.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c17bb938-f6e8-40e9-91dc-13a0c6e0bc43.png)'
- en: The sequence is generated by counting the digits of the previous number in the
    group. John Conway initially coined the term *look-and-say sequence*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列是通过计算组中前一个数的数字生成的。John Conway 最初提出了 *观察法序列* 这个术语。
- en: 'The look-and-say sequence is shown in the following code. The `look_say` method
    takes a string as a parameter and returns a look-and-say sequence of integers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 观察法序列在以下代码中展示。`look_say` 方法接受一个字符串作为参数，并返回一个观察法整数序列：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `main` method initializes the string and invokes the `look_say` method.
    The look-and-say sequence that is returned from the method is printed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法初始化字符串并调用 `look_say` 方法。该方法返回的观察法序列被打印出来：'
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run the following command to execute the `look_say.go` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行 `look_say.go` 文件：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d41da3c7-166d-4737-815f-65f0ccc42675.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d41da3c7-166d-4737-815f-65f0ccc42675.png)'
- en: The next section talks about the Thue–Morse data structure.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将讨论 Thue–Morse 数据结构。
- en: Thue–Morse
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thue–Morse
- en: The **Thue–Morse** sequence is a binary sequence starting at zero that appends
    the Boolean complement of the current sequence.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**Thue–Morse** 序列是一个从零开始的二进制序列，它附加了当前序列的布尔补码。'
- en: 'The Thue–Morse sequence is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Thue–Morse 序列如下：
- en: '![](img/7ed548d8-0e9f-4d5f-bd8e-3fd071d603a4.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ed548d8-0e9f-4d5f-bd8e-3fd071d603a4.png)'
- en: The Thue–Morse sequence was applied by Eugene Prophet and used by Axel Thue
    in the study of combinatorics on words. The Thue–Morse sequence is used in the
    area of fractal curves, such as Koch snowflakes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Thue–Morse序列被Eugene Prophet应用，并被Axel Thue用于研究词的组合数学。Thue–Morse序列在分形曲线领域得到应用，例如Koch雪花。
- en: 'The following code snippet creates the Thue–Morse sequence. The `ThueMorseSequence`
    function takes a `bytes.Buffer` instance buffer and modifies the buffer to the
    Thue–Morse sequence by applying the `complement` operation on the `bytes`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建Thue–Morse序列。`ThueMorseSequence`函数接收一个`bytes.Buffer`实例buffer，并通过在`bytes`上应用`complement`操作来修改buffer为Thue–Morse序列：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `main` method initializes the sequence number as `0`. The `ThueMorseSequence`
    method takes the pointer to the `bytes.Buffer` and modifies it by invoking the
    `ThueMorseSequence` method. The resulting sequence is printed on the Terminal:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法初始化序列号为`0`。`ThueMorseSequence`方法接收`bytes.Buffer`的指针，并通过调用`ThueMorseSequence`方法来修改它。结果序列在终端上打印：'
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Run the following command to execute the `thue_morse.go` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以执行`thue_morse.go`文件：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/8e0cc4d8-63cc-42bc-b78b-a230d2ca9400.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e0cc4d8-63cc-42bc-b78b-a230d2ca9400.png)'
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the `contains`, `put`, `remove`, `find`, `reset`, `NumberOfElements`,
    `getKeys`, and `getValues` methods of the dictionary data structure. The `InsertTreeNode`,
    `Delete`, `Search`, and `stringify` TreeSet operations have been explained in
    detail, and code examples were provided. The `BinarySearchTree` structure has
    been presented in code, along with the `InsertElement`, `InOrderTraversal`, `PreOrderTraverseTree`,
    `SearchNode`, and `RemoveNode` functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了字典数据结构的`contains`、`put`、`remove`、`find`、`reset`、`NumberOfElements`、`getKeys`和`getValues`方法。`InsertTreeNode`、`Delete`、`Search`和`stringify`
    TreeSet操作已详细解释，并提供了代码示例。代码中展示了`BinarySearchTree`结构，以及`InsertElement`、`InOrderTraversal`、`PreOrderTraverseTree`、`SearchNode`和`RemoveNode`函数。
- en: The next chapter covers algorithms such as sorting, searching, recursion, and
    hashing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涵盖了排序、搜索、递归和散列等算法。
- en: Questions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you ensure a `BinarySearchTree` is synchronized?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确保`BinarySearchTree`同步？
- en: Which method is called to postpone the invocation of a function?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个方法被调用以推迟函数的调用？
- en: How do you define dictionary keys and values with custom types?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用自定义类型定义字典的键和值？
- en: How do you find the length of a map?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何找到映射的长度？
- en: What keyword is used to traverse a list of `treeNodes` in a tree?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在树中遍历`treeNodes`列表时使用什么关键字？
- en: In a Farey sequence, what are the real numbers in the series called?
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在费雷序列中，序列中的实数被称为什么？
- en: What is a Fibonacci number?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 斐波那契数是什么？
- en: How do you convert an integer into a string?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将整数转换为字符串？
- en: What method is used to convert a byte into a string?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于将字节转换为字符串的方法是什么？
- en: What method is called to add elements to a dictionary?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向字典中添加元素时调用什么方法？
- en: Further reading
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following books are recommended if you want to learn more about dynamic
    data structures:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于动态数据结构的信息，以下书籍推荐：
- en: '*Design Patterns*, by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式*》，作者Erich Gamma, Richard Helm, Ralph Johnson, 和 John Vlissides
- en: '*Introduction to Algorithms – Third Edition*, by Thomas H. Cormen, Charles
    E. Leiserson, Ronald L. Rivest, and Clifford Stein'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*算法导论（第三版）*》，作者Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, 和
    Clifford Stein
- en: '*Data structures and Algorithms: An Easy Introduction*, by Rudolph Russell'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*数据结构与算法：简易入门*》，作者Rudolph Russell
