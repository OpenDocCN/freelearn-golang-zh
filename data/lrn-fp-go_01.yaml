- en: Pure Functional Programming in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中进行纯函数式编程
- en: '"Go is an attempt to combine the safety and performance of statically typed
    languages with the convenience and fun of dynamically typed interpretative languages."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种尝试将静态类型语言的安全性和性能与动态类型解释语言的便利性和乐趣相结合的语言。
- en: '- Rob Pike'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- Rob Pike'
- en: Do you love Go? If so, why? Could it be better? Can you write your code better
    today?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您喜欢Go吗？如果是，为什么？它可以更好吗？您今天能写出更好的代码吗？
- en: 'Yes! Because Go is simple yet powerful; Go does not make me wait; its compiler
    is fast and cross-platform; Go makes concurrent programming easy; Go also provides
    useful tooling, and it has a great development community. Perhaps. Yes, that''s
    what this book is about: using the **functional programming** (**FP**) style of
    coding.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！因为Go简单而强大；Go不让我等待；它的编译器快速且跨平台；Go使并发编程变得容易；Go还提供了有用的工具，并且拥有一个伟大的开发社区。也许。是的，这本书就是关于这个的：使用**函数式编程**（**FP**）编码风格。
- en: In this chapter, I will share the benefits of pure FP as well as its performance
    implications in Go by working through Fibonacci sequence code samples. Starting
    with a simple imperative implementation, you will explore functional implementations
    and learn some test-driven development and benchmark techniques along the way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将通过处理斐波那契数列代码示例，分享纯FP的好处以及在Go中的性能影响。从简单的命令式实现开始，您将探索函数式实现，并学习一些测试驱动开发和基准测试技术。
- en: 'The goal of this chapter is to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是：
- en: Become grounded in the theory of FP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扎根于FP的理论
- en: Learn how to implement functional solutions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何实现函数式解决方案
- en: Determine what type of FP will best fit your business requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定哪种FP最适合您的业务需求
- en: Motivation for using FP
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用FP的动机
- en: The FP style of programming can help you write less code in a more concise and
    expressive way, with fewer errors. How is that possible? Well, FP treats computation
    as an evaluation of mathematical functions. FP leverages this computational model
    (and the work of some brilliant mathematicians and logicians) to enable optimizations
    and performance gains that are simply not possible using traditional imperative
    coding techniques.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程风格可以帮助您以更简洁和表达力更强的方式编写更少的代码，减少错误。这是怎么可能的呢？嗯，函数式编程将计算视为数学函数的评估。函数式编程利用这种计算模型（以及一些杰出的数学家和逻辑学家的工作）来实现优化和性能增益，这是使用传统的命令式编码技术根本不可能的。
- en: 'Developing software is not easy. You must handle numerous **non-functional
    requirements** (**NFRs**) first, such as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 开发软件并不容易。您必须首先处理众多的**非功能性需求**（**NFRs**），例如：
- en: Complexity
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性
- en: Extensibility
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Maintainability
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Reliability
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Concurrency
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Scalability
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Software is becoming more and more complex. What is the average number of third-party
    dependencies in your typical application? What did that look like 5 years ago?
    Our applications often must integrate with other services within our own company
    and with our partners as well as external customers. How can we manage this growing
    complexity?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件变得越来越复杂。您的典型应用程序中平均有多少第三方依赖项？5年前是什么样子？我们的应用程序通常必须与我们自己公司内部的其他服务以及与我们的合作伙伴以及外部客户集成。我们如何管理这种不断增长的复杂性？
- en: Applications used to run on-site on servers that were given pet names, such
    as Apollo, Gemini, and so on. It seems like every client would have a different
    naming scheme. Nowadays, most applications are deploying into a cloud environment,
    for example, AWS or the Google Cloud Platform. Do you have a lot of software applications
    that run on a lot of servers? If so, you should treat your servers more like cattle;
    there's just so many of them. Also, since you've got auto scaling, what's important
    is not a single server but the herd. As long as you always have at least one server
    in your cluster running for the accounting department, that's all that really
    matters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序过去通常在被赋予宠物名字的服务器上运行，例如Apollo、Gemini等。似乎每个客户都有不同的命名方案。如今，大多数应用程序都部署在云环境中，例如AWS或Google
    Cloud Platform。您是否有很多软件应用程序在许多服务器上运行？如果是的话，您应该更多地像对待牲畜一样对待您的服务器；它们太多了。此外，由于您已经实现了自动扩展，重要的不是单个服务器，而是整个群体。只要您的集群中始终至少有一台服务器为会计部门运行，那就是真正重要的。
- en: With numbers comes complexity. Can you compose your applications to fit together
    like Lego blocks, and do you find it easy to write useful tests that run really
    fast. Alternatively, do you ever feel like there's too much scaffolding/`for`
    loops in your code? Do you like handling the `err != nil` condition so frequently?
    Would you like to see a simpler, cleaner way to do the same thing? Do your applications
    have any global variables? Do you have code in place to always properly manage
    its state and prevent all the possible side effects? Have race conditions ever
    been a problem?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字的增加，复杂性也随之增加。您能否将应用程序组合在一起，像乐高积木一样，编写运行速度非常快的有用测试？或者，您是否经常觉得自己的代码中有太多的脚手架/`for`循环？您是否喜欢频繁处理`err
    != nil`的条件？您是否希望看到更简单、更清晰的方法来做同样的事情？您的应用程序有全局变量吗？您是否有代码来始终正确管理其状态并防止所有可能的副作用？曾经出现过竞争条件问题吗？
- en: Are you aware of all the possible error conditions in your applications, and
    do you have code in place to handle them? Can you look at the function signature
    of any function in your code and immediately have an intuition as to what it does?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否了解应用程序中所有可能的错误条件，并且是否有代码来处理它们？您是否可以查看代码中任何函数的函数签名，并立即对其功能有直观的理解？
- en: Are you interested in learning about a better way to achieve your NFRs and enjoy
    developing Go software even more than you do right now? Looking for the silver
    bullet? If so, please continue reading. (Note that the rest of this book will
    be written in first person plural since we will be learning together.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否有兴趣了解更好的方法来实现您的NFR，并且比现在更享受开发Go软件？在寻找银弹吗？如果是的话，请继续阅读。（请注意，本书的其余部分将以第一人称复数形式撰写，因为我们将一起学习。）
- en: Getting the source code
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源代码
- en: The GitHub repository for this book's source code is [https://github.com/l3x/fp-go](https://github.com/l3x/fp-go).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的源代码的GitHub存储库是[https://github.com/l3x/fp-go](https://github.com/l3x/fp-go)。
- en: If you store your Go projects in the `~/myprojects` directory, then run `cd
    ~/myprojects; git clone https://github.com/l3x/fp-go.git`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将Go项目存储在`~/myprojects`目录中，那么运行`cd ~/myprojects; git clone https://github.com/l3x/fp-go.git`。
- en: 'Next, run the `cd` command into the first project directory: `cd ~/myprojects/fp-go/1-functional-fundamentals/ch01-pure-fp/01_oop`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行`cd`命令进入第一个项目目录：`cd ~/myprojects/fp-go/1-functional-fundamentals/ch01-pure-fp/01_oop`。
- en: The directory structure of the source files
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源文件的目录结构
- en: 'Directories correspond to the book''s units and chapters:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目录对应于书的单元和章节：
- en: '![](img/40477779-288a-46bb-81b0-e384bd08f0aa.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40477779-288a-46bb-81b0-e384bd08f0aa.png)'
- en: Each chapter is divided into sequentially numbered directories that are in the
    order of their appearance in the book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每一章都分成按顺序编号的目录，按照它们在书中出现的顺序。
- en: How to run our first Go application
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何运行我们的第一个Go应用程序
- en: First, let's make sure we have Go installed, our `GOPATH` is properly set, and
    that we can run a Go application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们已经安装了Go，我们的`GOPATH`已经正确设置，并且我们可以运行一个Go应用程序。
- en: If you are using a macOS, then check out the instructions on how to use the `brew` command
    to install Go in the appendix; otherwise, to install Go, visit: [http://golang.org/doc/install](http://golang.org/doc/install). To
    set your `GOPATH`, visit: [https://github.com/golang/go/wiki/Setting-GOPATH](https://github.com/golang/go/wiki/Setting-GOPATH).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是macOS，那么请查看附录中如何使用`brew`命令安装Go的说明；否则，要安装Go，请访问：[http://golang.org/doc/install](http://golang.org/doc/install)。要设置您的`GOPATH`，请访问：[https://github.com/golang/go/wiki/Setting-GOPATH](https://github.com/golang/go/wiki/Setting-GOPATH)。
- en: Many people use a global `GOPATH` to store the source code for all their Go
    applications or, frequently, manually reset their `GOPATH`. I found this practice
    to be troublesome when working with multiple Go projects for multiple clients,
    each of which had differing Go versions and third-party dependencies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用全局`GOPATH`来存储所有Go应用程序的源代码，或者经常手动重置他们的`GOPATH`。我发现这种做法在处理多个客户的多个Go项目时很麻烦，每个项目都有不同的Go版本和第三方依赖关系。
- en: 'The example Go applications that we''ll use in this chapter do not have dependencies;
    that is, we don''t have to import any third-party packages. So, all we have to
    do to run our first `app--cars.go--is` verify that Go is installed, set our `GOPATH`,
    and type `go run cars.go`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将使用的示例Go应用程序没有依赖关系；也就是说，我们不需要导入任何第三方包。因此，我们要做的就是运行我们的第一个`app--cars.go--`，验证Go是否已安装，设置我们的`GOPATH`，然后输入`go
    run cars.go`：
- en: '![](img/8ff6f041-0caa-4dbd-8aa7-1cb35e033a80.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ff6f041-0caa-4dbd-8aa7-1cb35e033a80.png)'
- en: Using a global `GOPATH` is easy for projects that are super simple, like the
    examples in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的示例这样非常简单的项目来说，使用全局`GOPATH`是很容易的。
- en: In [Chapter 2](../Text/Ch02.xhtml), *Manipulating Collections*, our Go applications
    will start getting more complex, and we'll get introduced to a simple, more consistent
    way to manage our Go development environments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](../Text/Ch02.xhtml) *操作集合*中，我们的Go应用程序将变得更加复杂，我们将介绍一种简单、更一致的方式来管理我们的Go开发环境。
- en: Imperative versus declarative programming
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式与声明式编程
- en: Let's look at why the functional style of programming helps us be more productive
    than the imperative alternative.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么函数式编程风格比命令式编程风格更有助于我们提高生产力。
- en: '"We are not makers of history. We are made by history."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: “我们不是历史的创造者。我们是历史的产物。”
- en: '- Martin Luther King, Jr.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '- 马丁·路德·金'
- en: Nearly all computer hardware is designed to execute machine code, which is native
    to the computer, written in the imperative style. The program state is defined
    by the contents of memory, and the statements are instructions in the machine
    language where each statement advances the state of computation forward, toward
    a final outcome. Imperative programs change their state over time, step by step.
    High-level imperative languages, such as C and Go, use variables and more complex
    statements, but they still follow the same paradigm. Since the basic ideas in
    imperative programming are both conceptually similar to low-level code that operates
    directly on computer hardware, most computer languages--such as Go, also known
    as *C of the 21st century*--are largely imperative.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的计算机硬件都是设计用来执行机器代码的，这是计算机本地的，以命令式风格编写的。程序状态由内存内容定义，语句是机器语言中的指令，其中每个语句都推进计算状态向前，朝着最终结果。命令式程序随着时间逐步改变它们的状态。高级命令式语言，如C和Go，使用变量和更复杂的语句，但它们仍然遵循相同的范式。由于命令式编程中的基本思想在概念上与直接在计算机硬件上操作的低级代码非常相似，大多数计算机语言--如Go，也被称为21世纪的C--在很大程度上是命令式的。
- en: '**Imperative programming** is a programming paradigm that uses statements that
    change a program''s state. It focuses on the step-by-step mechanics of how a program
    operates.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式编程**是一种使用改变程序状态的语句的编程范式。它侧重于程序操作的逐步机制。'
- en: The term is often used in contrast to **declarative programming**. In declarative
    programming, we declare what we want the results to be. We describe what we want,
    not detailed instructions of how to get it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个术语通常与**声明式编程**相对使用。在声明式编程中，我们声明我们想要的结果。我们描述我们想要的，而不是如何得到它的详细说明。
- en: 'Here''s a typical, imperative way to find `Blazer` in a slice of cars:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的命令式查找`Blazer`在汽车切片中的方法：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s a functional way of accomplishing the same task:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成相同任务的函数式方法：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That's nine lines of imperative code, compared to two lines in the **functional
    programming** (**FP**) style.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是九行命令式代码，而在**函数式编程**（**FP**）风格中只有两行。
- en: Functional constructs often express our intent more clearly than for loops in
    such cases and are especially useful when we want to filter, transform, or aggregate
    the elements in a dataset.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，函数式构造通常比for循环更清晰地表达我们的意图，并且在我们想要过滤、转换或聚合数据集中的元素时特别有用。
- en: 'In the imperative example, we must code the *how.* We must:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式示例中，我们必须编写*如何*。我们必须：
- en: Declare a Boolean flag
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个布尔标志
- en: Declare and set a variable value
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明并设置变量值
- en: Create a looping structure
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个循环结构
- en: Compare each iterated value
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较每个迭代值
- en: Set the flag
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置标志
- en: In the functional example, we declare *what* we want to do. We are able to focus
    on what we want to accomplish, rather than bloating our code with the mechanics
    of looping structures, setting variable values, and so on.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式示例中，我们声明了我们想要做什么。我们能够专注于我们想要实现的目标，而不是用循环结构、设置变量值等来膨胀我们的代码。
- en: In FP, iteration is implemented by the library function `contains()`. Leveraging
    library functions means that we code less and allow library developers to focus
    on highly efficient implementations, which have been typically vetted and performance
    enhanced by seasoned professionals. We don't have to write, debug, or test such
    high-quality code for repetitive logic.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，迭代是通过库函数`contains()`来实现的。利用库函数意味着我们编写的代码更少，并且允许库开发人员专注于高效的实现，这些实现通常经过经验丰富的专业人员的审查和性能增强。我们不必为重复的逻辑编写、调试或测试这样高质量的代码。
- en: 'Now, let''s look at how we could look for `Blazer` using the object-oriented
    programming paradigm:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用面向对象编程范式查找`Blazer`：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, we declare our object types:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的对象类型：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we add our methods:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加我们的方法：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we declare a global variable, namely `myCars`, where we will persist
    the state, that is, the list of cars that we will build:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个全局变量，即`myCars`，我们将在其中保持状态，即我们将构建的汽车列表：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add three cars to the list. The `Car` object encapsulates the data for each
    object, and the `cars` object encapsulates our list of cars:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表中添加三辆车。`Car`对象封装了每个对象的数据，而`cars`对象封装了我们的汽车列表：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Look for `Highlander` and print the results:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查找`Highlander`并打印结果：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are using `car` objects, but we are essentially doing the same operations
    as we were in the simple imperative code example. We do have objects that have
    state and to which we could add methods, but the underlying mechanisms are the
    same. We assign a state to object properties, modify the internal state by making
    method calls, and advance the state of execution until we arrive at the desired
    outcome. That's imperative programming.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`car`对象，但实质上我们正在执行与简单的命令式代码示例中相同的操作。我们有状态的对象，可以向其添加方法，但底层机制是相同的。我们给对象属性分配状态，通过进行方法调用修改内部状态，并推进执行状态直到达到期望的结果。这就是命令式编程。
- en: Pure functions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: '"Insanity is doing the same thing over and over again and expecting different
    results."'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: “疯狂就是一遍又一遍地做同样的事情，却期待不同的结果。”
- en: '- Albert Einstein'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '- 阿尔伯特·爱因斯坦'
- en: We can use this insanity principle to our advantage with pure functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这种纯函数的原则来获益。
- en: Assigning values to variables during an imperative function's execution may
    result in the modification of a variable in the environment in which it has run.
    If we run the same imperative function again, using the same input, the result
    may differ.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式函数的执行过程中给变量赋值可能会导致在其运行的环境中修改变量。如果我们再次运行相同的命令式函数，使用相同的输入，结果可能会有所不同。
- en: Given the results of an imperative function and given the same input, different
    results may be returned each time it is run. Is that not insanity?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命令式函数的结果，给定相同的输入，每次运行时可能返回不同的结果。这不是疯狂吗？
- en: '**Pure functions**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数**：'
- en: Treat functions as first-class citizens
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数视为一等公民
- en: Always return the same result given the same input(s)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定相同的输入时，始终返回相同的结果
- en: Have no side effects in the environment in which they run
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其运行的环境中没有副作用
- en: Do not allow an external state to affect their results
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许外部状态影响它们的结果
- en: Do not allow variable values to change over time
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许变量值随时间改变
- en: 'Two characteristics of a pure function include referential transparency and
    idempotence:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的两个特征包括引用透明性和幂等性：
- en: '**Referential transparency**: This is where a function call can be replaced with
    its corresponding value without changing the program''s behavior'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用透明性**：这是指函数调用可以替换为其相应的值，而不会改变程序的行为'
- en: '**Idempotence**: This is where a function call can be called repeatedly and
    produce the same result each time'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：这是指函数调用可以重复调用并每次产生相同的结果'
- en: Referentially transparent programs are more easily optimized. Let's see whether
    we can perform optimizations using a caching technique and Go's concurrency features.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 引用透明的程序更容易优化。让我们看看是否可以使用缓存技术和Go的并发特性进行优化。
- en: Fibonacci sequence - a simple recursion and two performance improvements
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 斐波那契数列 - 一个简单的递归和两个性能改进
- en: 'The Fibonacci sequence is a sequence of numbers where each number is equal
    to the previous two numbers added together. Here''s an example of this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列是一个数列，其中每个数字等于前两个数字相加。这是一个例子：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, 1 plus 1 is 2, 2 plus 3 is 5, 5 plus 8 is 13, and so on.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，1加1等于2，2加3等于5，5加8等于13，依此类推。
- en: Let's use the Fibonacci sequence to help illustrate a number of concepts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用斐波那契数列来帮助说明一些概念。
- en: A **recursive function** is a function that calls itself in order to break down
    complex input into simpler ones. With each recursive call, the input problem must
    be simplified in such a way that eventually the base case must be reached.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归函数**是指调用自身以将复杂输入分解为更简单的输入的函数。每次递归调用时，输入问题必须以一种简化的方式简化，以便最终达到基本情况。'
- en: 'The Fibonacci sequence can be easily implemented as a recursive function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列可以很容易地实现为一个递归函数：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding recursive function (`Fibonacci`), if the input is the simple
    case of `0` then it returns **0. **Similarly, if the input is `1` or `2` then
    return **1**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的递归函数（`Fibonacci`）中，如果输入是简单情况的`0`，则返回**0**。同样，如果输入是`1`或`2`，则返回**1**。
- en: 'An input of 0, 1 or 2 is called the **base case** or **stopping condition**;
    else, `fib` will call itself twice, adding the previous value in the sequence
    to the one preceding it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 0、1或2的输入被称为**基本情况**或**停止条件**；否则，`fib`将调用自身两次，将序列中的前一个值加到前一个值上：
- en: '![](img/0e2ebf78-c7d6-4b9c-98cf-f30eb82b76c0.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e2ebf78-c7d6-4b9c-98cf-f30eb82b76c0.png)'
- en: Fibonacci(5) calculation graph
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Fibonacci(5)计算图
- en: 'In the preceding figure *Fibonacci(5) calculation graph*, we can visually see
    how the fifth element in the Fibonacci sequence is calculated. We see **f(3)**
    is calculated twice and **f(2)** is calculated thrice. Only the final leaf nodes
    of **1** are added together to calculate the sum total of **8**:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图*Fibonacci(5)计算图*中，我们可以直观地看到如何计算斐波那契数列中的第五个元素。我们看到**f(3)**被计算了两次，**f(2)**被计算了三次。只有**1**的最终叶节点被加在一起来计算**8**的总和：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run that code and you'll get `8`. Recursive functions perform identical calculations
    over and over again; **f(3)** is calculated twice and **f(2)** is calculated thrice.
    The deeper the graph, the more redundant calculations get executed. That is terribly
    inefficient. Try it yourself. Pass a value greater than 50 to `fib` and see how
    long you have to wait for the final result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码，你会得到`8`。递归函数一遍又一遍地执行相同的计算；**f(3)**被计算了两次，**f(2)**被计算了三次。图形越深，冗余计算就越多。这是非常低效的。你自己试试吧。将一个大于50的值传递给`fib`，看看你要等多久才能得到最终结果。
- en: 'Go provides many ways to improve this performance. We''ll look at two options:
    memoization and concurrency.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了许多提高性能的方法。我们将看两个选项：备忘录和并发。
- en: Memoization is an optimization technique used to increase performance by storing
    the results of expensive function calls and returning the cached result when the
    same input occurs again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录是一种优化技术，通过存储昂贵的函数调用的结果并在再次出现相同输入时返回缓存的结果来提高性能。
- en: 'Memoization works well because of the following two properties of pure functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录的工作效果很好，因为纯函数具有以下两个属性：
- en: They always return the same result given the same input(s)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在给定相同的输入时总是返回相同的结果
- en: They have no side effects in the environment in which they run
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在其运行的环境中没有副作用
- en: Memoization
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备忘录
- en: Let's utilize a memoization technique to speed up our Fibonacci calculation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用备忘录技术来加速我们的斐波那契计算。
- en: 'First, let''s create a function type named `Memoized()` and define our Fibonacci
    variable to be of that type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`Memoized()`的函数类型，并将我们的斐波那契变量定义为该类型：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, let's implement the `Memoize()` function. The key thing to realize here
    is that as soon as our application starts, even before our `main()` function is
    executed, our `fibMem` variable get *wired up*. If we were to step through our
    code we'd see that our `Memoize` function is called. The cache variable is assigned
    and our anonymous function is returned and assigned to our `fibMem` function literal
    variable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现`Memoize()`函数。在这里要意识到的关键是，当我们的应用程序启动时，甚至在我们的`main()`函数执行之前，我们的`fibMem`变量就已经被*连接*起来了。如果我们逐步执行我们的代码，我们会看到我们的`Memoize`函数被调用。缓存变量被赋值，并且我们的匿名函数被返回并赋值给我们的`fibMem`函数文字变量。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Memoize takes a `Memoized()` function type as its input and returns a `Memoized()`
    function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录接受一个`Memoized()`函数类型作为输入，并返回一个`Memoized()`函数。
- en: In the first line of Memoize, we create a variable of the type `map` to act
    as our cache in order to hold computed Fibonacci computations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Memoize的第一行，我们创建了一个`map`类型的变量，作为我们的缓存，以保存计算的斐波那契数。
- en: Next, we create a closure that is of the type `Memoized()`, which is *return*ed
    by the `Memoize()` function. Note that a **closure** is an inner function that
    closes over or that has access to variables in its outer scope.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个闭包，它是由`Memoized()`类型*返回*的`Memoize()`函数。请注意，**闭包**是一个内部函数，它关闭或者访问其外部作用域中的变量。
- en: Inside the closure, if we find the computation for the passed integer, we return
    its value from the cache; else we call the recursive Fibonacci function *(*`mf`)
    with the integer parameter (`key`), whose return value will be stored in `cache[key]`.
    Next time, when the same key is requested its value will be returned directly
    from the cache.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包内，如果我们找到了传递整数的计算，我们就从缓存中返回它的值；否则，我们调用递归的斐波那契函数`mf`，参数为整数（`key`），其返回值将存储在`cache[key]`中。下次请求相同的键时，它的值将直接从缓存中返回。
- en: An anonymous function is a function defined with no name. When an anonymous
    function includes logic that can access variables defined in its scope, for example,
    `cache`, and if that anonymous function  can be passed as an argument or returned
    as the value of function calls, which is true in this case, then  we can refer
    to this anonymous function as a lambda expression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是没有名称定义的函数。当匿名函数包含可以访问其作用域中定义的变量的逻辑，例如`cache`，并且如果该匿名函数可以作为参数传递或作为函数调用的返回值返回，这在这种情况下是正确的，那么我们可以将这个匿名函数称为lambda表达式。
- en: 'We''ll implement the logic of the Fibonacci Sequence in a function named `fib`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在名为`fib`的函数中实现斐波那契数列的逻辑：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last thing we do in our `memoize.go` file is to create the following function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`memoize.go`文件中，我们要做的最后一件事是创建以下函数：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, it's time to see if our wiring works properly. In our `main()` function
    when we execute our `println` statement, we get the correct output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看我们的连线是否正常工作了。在我们的`main()`函数中，当我们执行`println`语句时，我们得到了正确的输出。
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can verify that 5 is the correct answer by glancing back at our `Fibonacci(5)`
    *calculation graph* shown earlier in this chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过回顾本章前面显示的`Fibonacci(5)`*计算图*来验证5是否是正确答案。
- en: If we were to step through our code using a debugger, we'd see that `fibonacci.FibMemoized(5)`
    calls the following
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用调试器逐步执行我们的代码，我们会看到`fibonacci.FibMemoized(5)`调用了以下内容
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And the value of `n` variable is 5\. Since `fibMem` is pre-wired, we start
    executing at the return statement (and we have access to the `cache` variable
    that has already been initialized) . So, we begin executing at the `return` statement
    shown in the following code (from the `Memoize` function):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`变量的值为5。由于`fibMem`已经预先连接，我们从`return`语句开始执行（并且我们可以访问已经初始化的`cache`变量）。因此，我们从以下代码中的`return`语句开始执行（从`Memoize`函数）：'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since this is the first time through, there are no entries in the cache and
    we skip past the body of the if block and run `temp := mf(key)`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是第一次执行，缓存中没有条目，我们跳过if块的主体并运行`temp := mf(key)`
- en: 'That calls the `fib` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`fib`函数：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And since `x` is greater than 2 we run the last else statement that recursively
    calls `fib` twice. Recursive calls to `fib` continues until the base conditions
    are reached and the final result is calculated and returned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`x`大于2，我们运行最后的else语句，递归调用`fib`两次。对`fib`的递归调用会一直持续，直到达到基本条件，然后计算并返回最终结果。
- en: The difference between an anonymous function and a closure
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数和闭包之间的区别
- en: Let's look at a few simple code examples to understand the difference between
    an anonymous function and a closure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些简单的代码示例，以了解匿名函数和闭包之间的区别。
- en: 'Here''s a typical named function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的命名函数：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is an example of the anonymous function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是匿名函数的示例：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s call them both and call an anonymous inline function to say `Hey`
    to Cindy:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们同时调用它们，并调用一个匿名内联函数对Cindy说“嘿”：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output will be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let's look at a closure named `greeting` and see the difference between
    it and the `anonymousGreeting()` function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个名为`greeting`的闭包，并看看它与`anonymousGreeting()`函数的区别。
- en: 'Since the closure function is declared in the same scope as the `msg` variable,
    the closure has access to it. The `msg` variable is said to be in the same environment
    as the closure; later, we''ll see that a closure''s environment variables and
    data can be passed around and referenced at a later time during a program''s execution:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包函数在与`msg`变量相同的作用域中声明，所以闭包可以访问它。`msg`变量被称为与闭包在同一环境中；稍后，我们将看到闭包的环境变量和数据可以在程序执行期间传递和引用：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will be as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the next example, instead of executing the closure in the `greeting()` function,
    we will return it and assign its return value to the `hey` variable in the `main`
    function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将闭包返回而不是在`greeting()`函数中执行它，并将其返回值分配给`main`函数中的`hey`变量：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the timestamp is calculated when the `msg` variable is initialized,
    at the time the `greeting("bob")` value is assigned to the `hey` variable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，时间戳是在初始化`msg`变量时计算的，在将`greeting("bob")`的值分配给`hey`变量时。
- en: So, 10 seconds later, when `greeting` is called and the closure is executed,
    it will reference the message that was created 10 seconds ago.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，10秒后，当调用`greeting`并执行闭包时，它将引用10秒前创建的消息。
- en: This example shows how closures preserve state. Instead of manipulating the
    state in the outside environment, closures allow states to be created, passed
    around, and subsequently referenced.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了闭包如何保留状态。闭包允许创建、传递和随后引用状态，而不是在外部环境中操作状态。
- en: With functional programming, you still have a state, but it's just passed through
    each function and is accessible even when the outer scopes, from where they originated,
    have already exited.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数式编程，你仍然有一个状态，但它只是通过每个函数传递，并且即使外部作用域已经退出，它仍然是可访问的。
- en: Later in this book, we'll see a more realistic example of how closures can be
    leveraged to maintain a context of application resources required by an API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面，我们将看到一个更现实的例子，说明闭包如何被利用来维护API所需的应用程序资源的上下文。
- en: Another way to speed up our recursive Fibonacci function is to use Go's concurrency
    constructs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 加速我们的递归斐波那契函数的另一种方法是使用Go的并发构造。
- en: FP using Go's concurrency constructs
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go的并发构造的FP
- en: 'Given the expression `result := function1() + function2()`, parallelization
    means that we can run each function on a different CPU core and the total time
    will be approximately the time it takes for the most expensive function to return
    its result. Consider the following explanation for parallelization and concurrency:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 给定表达式`result := function1() + function2()`，并行化意味着我们可以在不同的CPU核心上运行每个函数，并且总时间将大约等于最昂贵函数返回其结果所需的时间。考虑以下关于并行化和并发性的解释：
- en: '**Parallelization**: Executing multiple functions at the same time (in different
    CPU cores)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行化**：同时执行多个函数（在不同的CPU核心上）'
- en: '**Concurrency**: Breaking a program into pieces that can be executed independently'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：将程序分解成可以独立执行的部分'
- en: I recommend that you check out the video* Concurrency is Not Parallelism*, by
    Rob Pike at [https://player.vimeo.com/video/49718712](https://player.vimeo.com/video/49718712).
    This is where he explains concurrency as a decomposition of a complex problem
    into smaller components, where individual components can be run simultaneously
    resulting in improved performance, assuming communication between them is managed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你观看Rob Pike的视频*并发不等于并行*，网址为[https://player.vimeo.com/video/49718712](https://player.vimeo.com/video/49718712)。在视频中，他解释了并发是将复杂问题分解为更小的组件，这些组件可以同时运行，从而提高性能，前提是它们之间的通信得到管理。
- en: Go enhances the concurrent execution of Goroutines with synchronization and
    messaging using channels and provides multiway concurrent control with the `Select`
    statement.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Go通过使用通道增强了Goroutines的并发执行，使用`Select`语句提供了多路并发控制。
- en: 'The following language constructs provide a model in Go for concurrent software
    construction that is easy to understand, use, and reason about:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语言构造为Go提供了一个易于理解、使用和推理的并发软件构建模型：
- en: '**Goroutine**: A lightweight thread managed by the Go runtime.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Goroutine**：由Go运行时管理的轻量级线程。'
- en: '**Go statement**s: The `go` instruction that starts the execution of a function
    call as an independent concurrent thread of control, or Goroutine, in the same
    address space as the calling code.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go语句**：`go`指令启动函数调用的执行，作为独立的并发控制线程，或Goroutine，在与调用代码相同的地址空间中。'
- en: '**Channel**: A typed conduit through which you can send and receive values
    with the channel operator, namely `<-`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：一种类型的导管，通过它可以使用通道操作符`<-`发送和接收值。'
- en: 'In the following code, `data` is sent to `channel` in the first line. In the
    second line, `data` is assigned the value received from `channel`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`data`在第一行发送到`channel`。在第二行，`data`被赋予从`channel`接收到的值：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since Go channels behave as FIFO queues, where the first items in are the first
    items out, and since the calculation for the next number in a Fibonacci sequence
    is a small component, it seems that our Fibonacci sequence function calculation
    is a great candidate for a concurrency implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go通道的行为类似于FIFO队列，先进先出，而斐波那契序列中下一个数的计算是一个小组件，因此我们的斐波那契序列函数计算似乎是并发实现的一个很好的候选。
- en: 'Let''s give it a go. First, let''s define a `Channel` function that uses a
    channel to perform Fibonacci calculations:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。首先，让我们定义一个使用通道执行斐波那契计算的`Channel`函数：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, we declare the variables `n1` and `n2` to hold our initial sequence values
    of `0` and `1`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明变量`n1`和`n2`来保存我们的初始序列值`0`和`1`。
- en: Then, we create a loop for the total number of times given. In each loop, we
    send the next sequential number to the channel and calculate the next number in
    the sequence, until we reach our counter value, which is the last sequential number
    in our sequence.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个循环，循环次数为给定的总次数。在每个循环中，我们将下一个顺序数发送到通道，并计算序列中的下一个数，直到达到我们的计数器值，即序列中的最后一个顺序数。
- en: 'The following `FibChanneled` function creates a channel, namely `ch`, using
    the `make()` function and defines it as a channel that contains integers:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`FibChanneled`函数创建一个通道，即`ch`，使用`make()`函数并将其定义为包含整数的通道：'
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We run our `Channel` (Fibonacci) function as a Goroutine and pass it the `ch`
    channel and the `8` number, which tells `Channel` to produce the first eight numbers
    from the Fibonacci sequence.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`Channel`（斐波那契）函数作为Goroutine运行，并传递给它`ch`通道和`8`数字，告诉`Channel`生成斐波那契序列的前八个数字。
- en: Next, we range over the channel and print any values that the channel produces
    for as long as the channel has not been closed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历通道并打印通道产生的任何值，只要通道尚未关闭。
- en: Now, let's take a breather and examine what we've accomplished with our Fibonacci
    sequence examples.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们休息一下，检查一下我们在斐波那契序列示例中取得的成就。
- en: Testing FP using test-driven development
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试驱动开发测试FP
- en: Let's write some tests to verify each technique (simple recursive, memoized,
    and channeled) works properly. We'll use TDD to help us design and write better
    code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些测试来验证每种技术（简单递归，记忆化和通道）是否正常工作。我们将使用TDD来帮助我们设计和编写更好的代码。
- en: TDD, a software development method where the developer starts with requirements
    and first writes a simple test that will fail. Then, it writes just enough code
    to make it pass. It continues this unit testing pattern repeatedly until there
    are no more reasonable tests that validate the code satisfies the requirements.
    The concept is to *get something working now and perfect it later*. After each
    test, refactoring is performed to implement a little more of the feature requirement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种软件开发方法，开发人员从需求开始，首先编写一个简单的测试，然后编写足够的代码使其通过。它重复这种单元测试模式，直到没有更多合理的测试来验证代码是否满足要求。这个概念是*立即让它工作，然后稍后完善*。每次测试后，都会执行重构以实现更多的功能需求。
- en: 'The same or similar test(s) are performed again as well as introducing new
    test code to test the next piece of the feature. The process is iterated as many
    times as necessary until each unit is functioning according to the desired specifications:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 相同或类似的测试将再次执行，同时引入新的测试代码来测试功能的下一部分。该过程将根据需要重复多次，直到每个单元根据所需的规格进行操作。
- en: '![](img/79c13566-2ba5-4090-8d9e-dd1619702ed7.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79c13566-2ba5-4090-8d9e-dd1619702ed7.png)'
- en: TDD workflow diagram
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: TDD工作流程图
- en: 'We can start using a table of input values and their corresponding result values
    to verify that the function under test is working properly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始使用输入值和相应结果值的表格来验证被测试的函数是否正常工作：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Recall that the Fibonacci sequence looks like this: `1  1  2  3  5  8  13  21
     34`. Here, the first element is `1 {1, 1}`, the second element is `2 {2, 2}`,
    and so on.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，斐波那契序列看起来是这样的：`1  1  2  3  5  8  13  21  34`。这里，第一个元素是`1 {1, 1}`，第二个元素是`2
    {2, 2}`，依此类推。
- en: We use the range statement to iterate through the table, row by row, and check
    each calculated result (`v := FibSimple(ft.a)`) against the expected value (`ft.expected`)
    from that row.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用range语句逐行遍历表格，并检查每个计算结果（`v := FibSimple(ft.a)`）与该行的预期值（`ft.expected`）是否一致。
- en: Only if there is a mismatch do we report the error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在出现不匹配时，我们才报告错误。
- en: 'Later in the `ex1_test.go` file, we find the benchmark testing facility in
    action, which allows us to examine the performance of our Go code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在`ex1_test.go`文件中，我们发现基准测试设施正在运行，这使我们能够检查我们的Go代码的性能：
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let's open a terminal window and write the `cd` command to the first set of
    Go code, our book's source code repository. For me, that directory is `~/clients/packt/dev/fp-go/1-functional-fundamentals/ch01-pure-fp/01_fib`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个终端窗口，并写入`cd`命令到第一组Go代码，即我们书籍的源代码存储库。对我来说，该目录是`~/clients/packt/dev/fp-go/1-functional-fundamentals/ch01-pure-fp/01_fib`。
- en: A note about paths
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于路径的说明
- en: In the first example, I used the `~/myprojects/fp-go` path. The path that I
    actually used to create the code in this book is `~/clients/packt/dev/fp-go`.
    So, please don't be confused by those paths. They are the same thing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我使用了`~/myprojects/fp-go`路径。我实际用于创建本书中代码的路径是`~/clients/packt/dev/fp-go`。所以，请不要被这些路径所困扰。它们是同一个东西。
- en: Also, later in the book, when we start using KISS-Glide, the screenshots may
    reference the `~/dev` directory. That comes from the init script, that is, `MY_DEV_DIR=~/dev`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本书的后面，当我们开始使用KISS-Glide时，屏幕截图可能会引用`~/dev`目录。这来自初始化脚本，即`MY_DEV_DIR=~/dev`。
- en: 'Here are a few links in that directory:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录中有一些链接：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For more information about KISS-Glide, see the appendix.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有关KISS-Glide的更多信息，请参阅附录。
- en: How to run our tests
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何运行我们的测试
- en: 'In the first benchmark test, we examine the performance of computing the eighth
    number in the Fibonacci sequence. Note that we pass the `-bench=.` argument, which
    means run all benchmark tests. The `./...` argument means to run all the tests
    in this directory and all the child directories as well:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个基准测试中，我们检查了计算斐波那契数列中第八个数字的性能。请注意，我们传入了`-bench=.`参数，这意味着运行所有基准测试。`./...`参数表示运行此目录及所有子目录中的所有测试：
- en: '![](img/33f7376d-15ce-4343-87fb-d5118f43194d.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33f7376d-15ce-4343-87fb-d5118f43194d.png)'
- en: When we request the eighth number in the sequence, the simple recursive implementation
    runs faster than the memoized and channeled (optimized) versions, `213 ns/op` compared
    to `1302 ns/op` and `2224 ns/op`, respectively.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求数列中的第八个数字时，简单的递归实现比记忆化和通道化（优化）版本运行得更快，分别为`213 ns/op`，`1302 ns/op`和`2224
    ns/op`。
- en: In fact, when the simple version is executed once, it only takes `3.94 ns/op`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当简单版本执行一次时，只需要`3.94 ns/op`。
- en: One very cool feature of Go's benchmark testing facility is that it is smart
    enough to figure out how many times to execute the function under test. The value
    of `b.N` will increase each time until the benchmark runner is satisfied with
    the stability of the benchmark. The faster the function runs under a test, the
    more times the benchmark facility will run it. The more times the benchmark facility
    runs a function, the more accurate the performance metric, for example, `3.94
    ns/op`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Go基准测试设施的一个非常酷的特性是，它足够聪明，可以找出要执行被测试函数的次数。`b.N`的值将每次增加，直到基准测试运行器对基准测试的稳定性感到满意。函数在测试下运行得越快，基准测试设施就会运行得越多。基准测试设施运行函数的次数越多，性能指标就越准确，例如`3.94
    ns/op`。
- en: Take the `FibSimple` test for example. When it is passed with `1`, it means
    it only needs to execute once. Since it only takes `3.94 ns/op`, we see it is
    executed 10,000,000 times. However, when `FibSimple` is passed with `40`, we see
    that it takes 2,509,110,502 ns to complete one operation, and the benchmark facility
    is smart enough to only run it once. That way, we can be assured that running
    benchmark tests is as accurate as possible and they run within a reasonable time.
    How nice is that?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以`FibSimple`测试为例。当传入`1`时，意味着只需要执行一次。由于每次执行只需要`3.94 ns/op`，我们看到它被执行了10,000,000次。然而，当`FibSimple`传入`40`时，我们发现完成一次操作需要2,509,110,502
    ns，并且基准测试设施足够智能，只运行一次。这样，我们可以确保运行基准测试尽可能准确，并且在合理的时间内运行。多好啊？
- en: 'Since the `FibSimple` implementation is recursive and has not been optimized,
    we can test our assumption that the time it takes to calculate each successive
    number in the sequence will increase exponentially. We can do this using a common
    testing technique by calling the private function `benchmarkFibSimple`, which
    avoids directly invoking the test driver:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FibSimple`实现是递归的，并且没有被优化，我们可以测试我们的假设，即计算数列中每个后续数字所需的时间将呈指数增长。我们可以通过调用私有函数`benchmarkFibSimple`来使用一种常见的测试技术来做到这一点，该函数避免直接调用测试驱动程序：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We test the first four numbers in the sequence, `20` and then `42`. Since it
    takes about 3 seconds for my computer to calculate the 42nd number in the sequence,
    I decided not to go any higher. No need to wait longer than that when we can easily
    see the exponential growth pattern, without having to wait for more than a minute
    to get our results.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了数列中的前四个数字，`20`和`42`。由于我的计算机计算数列中的第42个数字大约需要3秒，我决定不再继续。当我们可以轻松看到指数增长模式时，就没有必要等待更长的时间来获取结果了。
- en: Our benchmark testing has proven that our simple, recursive implementation of
    the Fibonacci sequence behaves as expected. This behavior equates to poor performance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基准测试已经证明，我们对斐波那契数列的简单递归实现表现如预期。这种行为等同于性能不佳。
- en: Let's look at a few ways to increase performance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些提高性能的方法。
- en: We have observed that our `FibSimple` implementation always returns the same
    result, given the same input(s), and that there are no side effects in the environment
    in which it runs. For example, if we pass `FibSimple` an `8` value, we know that
    every time the result will be `13`. We used this fact to leverage a caching technique
    called memoization to create the `FibMemoized` function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到我们的`FibSimple`实现总是返回相同的结果，给定相同的输入，并且在其运行环境中没有副作用。例如，如果我们传入`FibSimple`一个`8`值，我们知道每次结果都将是`13`。我们利用了这一事实来利用一种称为记忆化的缓存技术来创建`FibMemoized`函数。
- en: Now, let's write some tests to see how effective `MemoizeFcn` is.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些测试，看看`MemoizeFcn`有多有效。
- en: Since our `fibTests` structure has been defined in another test in our package,
    in `chapter1/_01_fib/ex1_test.go`, we don't need to define it again. This way,
    we only define the test table once, and we're able to reuse it in subsequent Fibonacci
    function implementations to get a reasonable apples-to-apples comparison of each
    solution.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`fibTests`结构已在包中的另一个测试中定义，即`chapter1/_01_fib/ex1_test.go`，我们不需要重新定义它。这样，我们只需定义一次测试表，就能够在后续的斐波那契函数实现中重复使用它，以获得合理的苹果对苹果的比较。
- en: 'Here''s the basic unit test for the `FibMemoized` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`FibMemoized`函数的基本单元测试：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It won't return an error unless there is a bug in our code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们的代码中有错误，否则它不会返回错误。
- en: That's one of the great things about running unit tests. You don't hear about
    them unless something breaks.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是运行单元测试的好处之一。除非出现问题，否则您不会听到它们。
- en: 'We should write unit tests in order to:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该编写单元测试以便：
- en: Ensure that what you implement meets your feature requirements
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您实现的内容符合您的功能要求
- en: Leverage testing to help you think about how best to implement your solution
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用测试来帮助您考虑如何最好地实施您的解决方案
- en: Produce quality tests that can be used in your constant integration process
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成可以在您的持续集成过程中使用的高质量测试
- en: Verify that your implementation meets interface requirements with other parts
    of your application
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证您的实现是否符合应用程序其他部分的接口要求
- en: Make developing integration tests easier
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使开发集成测试更容易
- en: Safeguard your work against other developers, who might implement a component
    that could break your code in production
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护您的工作免受其他开发人员的影响，他们可能会实现一个可能在生产中破坏您代码的组件
- en: 'Here are the benchmark tests:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基准测试的结果：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As before, in the `FibSimple` example, we examine the performance of computing
    the eighth number in the Fibonacci sequence:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，在`FibSimple`示例中，我们检查了计算斐波那契数列中第八个数字的性能：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As before, we carry out a test calling `FibMemoized`, using `1`, `2`, `3`, `4`,
    `20`, and `42` as input.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们进行了一项测试，使用`1`、`2`、`3`、`4`、`20`和`42`作为输入调用`FibMemoized`。
- en: 'Here''s the complete listing for the `FibChanelled` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`FibChanelled`函数的完整列表：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We performed two optimizations on our original Fibonacci sequence logic using
    a caching technique and Go's concurrency features. We wrote both the optimization
    implementations. More optimizations are possible. In some cases, optimization
    techniques can be combined to produce even faster code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对原始斐波那契数列逻辑进行了两次优化，使用了缓存技术和Go的并发特性。我们编写了这两种优化实现。还有更多的优化可能。在某些情况下，可以将优化技术结合起来产生更快的代码。
- en: What if all we had to do was write a simple recursive version and then when
    we compiled our Go code, the Go compiler would automatically generate object code
    with performance optimizations?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要编写一个简单的递归版本，然后在编译Go代码时，Go编译器会自动生成带有性能优化的目标代码，那该有多好？
- en: '**Lazy evaluation**: An evaluation strategy that delays the evaluation of an
    expression until its value is needed, which improves performance by avoiding needless
    calculations.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**惰性求值**：一种延迟对表达式进行求值直到需要其值的求值策略，通过避免不必要的计算来提高性能。'
- en: A journey from imperative programming to pure FP and enlightenment
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令式编程到纯FP和启示的旅程
- en: 'Let''s take a journey from imperative to a pure functional way of programming
    a `sum` function. First, let''s look at the imperative `sum` function:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命令式编程`sum`函数转向纯函数式编程的旅程。首先，让我们看看命令式的`sum`函数：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The integer variable `sum` changes or mutates over time; `sum` is not immutable.
    There are no for loops or mutating variables in pure FP.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 整数变量`sum`会随时间改变或变异；`sum`是不可变的。在纯FP中没有for循环或变异变量。
- en: So, how can we iterate through a series of elements using pure FP? We can do
    this using recursion.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用纯FP来迭代一系列元素呢？我们可以使用递归来实现这一点。
- en: '**Immutable variable**: A variable whose value is assigned during runtime and
    cannot be modified.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变变量**：在运行时分配值并且不能被修改的变量。'
- en: 'Note that Go does have constants, but they differ from immutable variables
    in that values are assigned to constants at compile time, rather than at runtime:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Go确实有常量，但它们与不可变变量不同，常量的值是在编译时分配的，而不是在运行时分配的：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice that the last line of the preceding `SumRecursive` function calls itself:
    `SumRecursive(nums[1:])` . That''s recursion.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面的`SumRecursive`函数的最后一行调用了自身：`SumRecursive(nums[1:])`。这就是递归。
- en: Benchmark test for the imperative SumLoop function
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SumLoop函数的基准测试
- en: 'We have heard that recursion in Go can be slow. So, let''s write some benchmark
    tests to check it out. First, let''s test the performance of the basic imperative
    function `SumLoop`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们听说Go中的递归可能很慢。因此，让我们编写一些基准测试来检查一下。首先，让我们测试基本命令式函数`SumLoop`的性能：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Results**: It took `46.1 ns/op`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：每次操作耗时`46.1 ns`。'
- en: Benchmark test for the SumRecursive function
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SumRecursive函数的基准测试
- en: 'Now that we know how long the imperative function `SumLoop` takes, let''s write
    a benchmark test to see how long our recursive version, namely `SumRecursive`,
    would take:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了命令式函数`SumLoop`需要多长时间，让我们编写一个基准测试来看看我们的递归版本，即`SumRecursive`需要多长时间：
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Results**: It took `178 ns/op`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**结果**：每次操作耗时`178 ns`。'
- en: 'Tail call recursion is faster in languages such as Prolog, Scheme, Lua, and
    Elixir, and the ECMAScript 6.0-compliant JavaScript engines embrace the pure functional
    style of programming. So, let''s give it a shot:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prolog、Scheme、Lua和Elixir等语言中，尾调用递归速度更快，而符合ECMAScript 6.0标准的JavaScript引擎采用了纯函数式编程风格。因此，让我们试一试：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Results of the benchmark test**: It took `192 ns/op`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**基准测试结果**：每次操作耗时`192 ns`。'
- en: '**TCO**: A tail call is where the last statement of a function is a function
    call. An optimized tail call has been effectively replaced with a `GoTo` statement,
    which eliminates the work required to set up the call stack before the function
    call and restore it afterward.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCO**：尾调用是指函数的最后一条语句是一个函数调用。优化的尾调用已经被有效地替换为`GoTo`语句，它消除了在函数调用之前设置调用堆栈和在函数调用之后恢复调用堆栈所需的工作。'
- en: We could even use `GoTo` statements to further speed up the tail call recursion,
    but it would still be three times slower than the imperative version.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`GoTo`语句来进一步加速尾递归，但它仍然比命令式版本慢三倍。
- en: Why? This is because Go does not provide pure FP support. For example, Go does
    not perform TCOs, nor does it provide immutable variables.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？这是因为Go不支持纯FP。例如，Go不执行TCO，也不提供不可变变量。
- en: A time of reckoning
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次清算
- en: Why would we want to use pure FP in Go? If writing expressive, easy-to-maintain,
    and insightful code is more important than performance, then perhaps.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们想在Go中使用纯FP？如果编写表达力强、易于维护和富有洞察力的代码比性能更重要，那或许可以考虑。
- en: What are our alternatives? Later, we'll look at some pure FP libraries that
    have done the heavy lifting for us and have made strides toward being more performant.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有哪些替代方案？稍后，我们将看一些纯FP库，它们已经为我们做了大量工作，并且在更高性能方面取得了进展。
- en: Is that all there is to functional programming in Go? No. Not by a long shot.
    What we can do with FP in Go is currently partially limited by the fact that the
    Go compiler currently does not support TCO; However, that may change soon. For
    details see the *How to Propose Changes To Go* section in the Appendix.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中的函数式编程就是这些吗？不，远远不止这些。我们在Go中可以做的FP目前受到Go编译器目前不支持TCO的限制；然而，这可能很快会改变。有关详细信息，请参阅附录中的*如何提出Go更改*部分。
- en: 'There is another aspect to functional programming that Go fully supports: function
    literals. And as it turns out, that is the single most important characteristic
    that a language must have to support FP.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的另一个方面是Go完全支持的：函数文字。事实证明，这是支持FP所必须具有的最重要特征。
- en: '**Function literals**: These are functions that are treated as first-class
    citizens of a language, for example, any variable type, such as int and string.
    In Go, functions can be declared as a type, assigned to variables and fields of
    a struct, passed as arguments to other functions, and returned as values from
    other functions. Function literals are closures, giving them access to the scope
    in which they are declared. When function literals are assigned to a variable
    at runtime, for example, `val := func(x int) int { return x + 2}(5)`, we can call
    that **anonymous function** a **function expression**. Function literals are used
    in lambda expressions along with currying. (For details about lambda expressions,
    see [Chapter 10](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*.)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数文字**：这些函数被视为语言的一等公民，例如，任何变量类型，如int和string。在Go中，函数可以声明为一种类型，分配给变量和结构的字段，作为参数传递给其他函数，并从其他函数中作为值返回。函数文字是闭包，使它们可以访问其声明的范围。当函数文字在运行时分配给变量时，例如，`val
    := func(x int) int { return x + 2}(5)`，我们可以称该**匿名函数**为**函数表达式**。函数文字用于lambda表达式以及柯里化。
    （有关lambda表达式的详细信息，请参见[第10章](../Text/Ch09.xhtml)，*函子、幺半群和泛型*。）'
- en: A quick example of a function literal
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数文字的一个快速示例
- en: See that `{ret = n + 2}` is our anonymous function/function literal/closure/lambda
    expression.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`{ret = n + 2}`是我们的匿名函数/函数文字/闭包/lambda表达式。
- en: 'Our function literal:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数文字：
- en: Is written like a function declaration, but without a function name following
    the `func` keyword
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像函数声明一样编写，但在`func`关键字后没有函数名称
- en: Is an expression
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一个表达式
- en: Has access to all the variables available in its lexical scope (`n` in our case)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以访问其词法范围中的所有变量（在我们的例子中为`n`）
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we used the `defer` statement to delay the execution of our function
    literal until after its surrounding function (`curryAddTwo`) is returned. Since
    our anonymous function has access to all the variables in its scope (`n`), it
    can modify `n`. The modified value is what gets printed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`defer`语句延迟执行我们的函数文字，直到其周围的函数（`curryAddTwo`）返回。由于我们的匿名函数可以访问其范围内的所有变量（`n`），它可以修改`n`。修改后的值就是打印出来的值。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: When testing pure functions, we simply pass input arguments and verify the results.
    There is no environment or context to set up. There is no need for stubs or mocks.
    There are no side effects. Testing could not be easier.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试纯函数时，我们只需传递输入参数并验证结果。无需设置环境或上下文。不需要存根或模拟。没有副作用。测试再也不容易了。
- en: Pure functions can be parallelized for performance gains in a horizontally scaled,
    multi-CPU environment. However, given that Go has not yet been optimized to support
    pure functional programming, a pure FP implementation in Go might not meet our
    performance requirements. We won't let that hinder us from leveraging Go's many
    effective non-pure functional programming techniques. We've already seen how we
    can gain performance by adding caching logic and leveraging Go's concurrency features.
    There are many functional patterns that we can use, and we'll soon see how. We'll
    also see how we can leverage them to meet stringent performance requirements.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数可以在水平扩展的多CPU环境中并行化以获得性能增益。然而，鉴于Go尚未经过优化以支持纯函数式编程，Go中的纯FP实现可能无法满足我们的性能要求。我们不会让这妨碍我们利用Go的许多有效的非纯函数式编程技术。我们已经看到了通过添加缓存逻辑和利用Go的并发功能来提高性能。有许多我们可以使用的功能模式，我们很快就会看到。我们还将看到我们如何利用它们来满足严格的性能要求。
- en: In the next chapter, you'll learn about high-order functions as we explore different
    ways to manipulate collections using FP programming techniques.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习高阶函数，因为我们探索使用FP编程技术来操作集合的不同方式。
