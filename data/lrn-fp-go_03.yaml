- en: Using High-Order Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高阶函数
- en: We frequently encounter questions such as, "Just curious, what are the benefits
    of applying pure functional programming concepts to imperative languages (other
    than making the code hard to read for others)?"
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到诸如“只是好奇，将纯函数式编程概念应用于命令式语言的好处是什么（除了使代码难以阅读）？”这样的问题。
- en: In this chapter, we will address this common misconception using high-order
    functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用高阶函数来解决这个常见的误解。
- en: 'Our goal in this chapter is to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的目标是：
- en: Understand the characteristics of **functional programming** (**FP**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**函数式编程**（**FP**）的特点
- en: Understand the purpose of generics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解泛型的目的
- en: Understand how FP improves performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解FP如何提高性能
- en: Understand currying
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解柯里化
- en: Implement `Map`, `Filter`, and `Reduce` functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`Map`，`Filter`和`Reduce`函数
- en: Implement lazy evaluation using Goroutines and a Go channel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Goroutines和Go通道实现惰性评估
- en: Characteristics of FP
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP的特点
- en: 'Let''s start by looking at the requirements for a pure FP language. A pure
    FP language must include support for things like:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看纯FP语言的要求。纯FP语言必须支持诸如：
- en: First-class functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头等函数
- en: '**Tail-call optimization** (**TCO**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尾递归优化**（**TCO**）'
- en: High-order functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Pure functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Immutable Data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变数据
- en: In order to accomplish pure FP, a language must treat functions as it does any
    other variable type. How can an immutable language have variables that vary? The
    way we accomplish this in an FP way is by creating new variables, rather than
    modifying existing ones. We will see how to accomplish this later in the chapter,
    when we look at the `Map` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现纯FP，语言必须像对待任何其他变量类型一样对待函数。在不可变的语言中如何有变化的变量？我们以FP的方式实现这一点的方法是创建新变量，而不是修改现有变量。我们将在本章后面看到如何实现这一点，当我们看`Map`函数时。
- en: Go is a multidimensional language that supports imperative, object-oriented,
    and FP styles. We could write a purely imperative or functional program in Go.
    It is our choice of programming style that dictates this. This is one of the great
    things about Go and FP. It's not an all or nothing issue. We can migrate our code
    toward FP when and where it makes sense to do so.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种支持命令式、面向对象和FP风格的多维语言。我们可以在Go中编写纯粹的命令式或函数式程序。这取决于我们选择的编程风格。这是Go和FP的伟大之处之一。这不是一个全是或全不是的问题。我们可以在合适的时候和地方将我们的代码迁移到FP。
- en: Go requires **tail-call optimization** (**TCO**) to handle production performance
    requirements. Each time a recursive function calls itself, a new block is added
    to the stack frame; we soon feel the sluggish effects of this Go compiler omission.
    We will see how to mitigate this issue when we implement the `Reduce` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go需要**尾递归优化**（**TCO**）来处理生产性能要求。每次递归函数调用自身时，都会向堆栈帧添加一个新块；我们很快就会感受到这种Go编译器遗漏的迟缓效果。当我们实现`Reduce`函数时，我们将看到如何缓解这个问题。
- en: The last requirement is support for **high-order functions** (**HOF**). High-order
    functions take functions as arguments and/or return functions as their result.
    HOFs allow us to chain our functions together in a readable manner with less code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要求是支持**高阶函数**（**HOF**）。高阶函数将函数作为参数并/或返回函数作为它们的结果。HOF允许我们以更少的代码以可读的方式链接我们的函数。
- en: 'HOFs are arguably the focal point of any FP language, and after a quick look
    at FP characteristics, we''ll study how we can exploit them in Go:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HOFs可以说是任何FP语言的焦点，经过对FP特性的快速了解后，我们将研究如何在Go中利用它们：
- en: '| **Characteristic** | **Supported in Go?** | **Description** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **特点** | **Go中支持？** | **描述** |'
- en: '| **Anonymous Function** | Yes | A function without a name. For example, this
    function call an anonymous function that prints a message.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| **匿名函数** | 是 | 一个没有名称的函数。例如，这个函数调用一个打印消息的匿名函数。'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Closures** | Yes | A closure is an inner function that closes over, that
    is, has access to, variables in its outer scope. In other words, a closure is
    a function''s scope that is kept alive by a reference to that function.  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **闭包** | 是 | 闭包是一个内部函数，它关闭（即访问）其外部范围的变量。换句话说，闭包是一个由对该函数的引用保持活动的函数范围。 |'
- en: '| **Composition** | Yes | Composition is what allows us to combine simple functions
    to build more complicated ones. Currying and pipelining are example implementations
    of the concept of composition. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **组合** | 是 | 组合是允许我们将简单函数组合成更复杂函数的方法。柯里化和管道是组合概念的示例实现。 |'
- en: '| **Continuations** | Yes | Continuations are like a GOTO statements with arguments. A
    continuation is a function parameter (`next`) we pass to a function (`factorial`)
    that specifies where the function should return.The factorial function does not
    define a return value. It''s a function that accepts an int and another function
    that passes along its current state.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '| **延续** | 是 | 延续类似于带参数的GOTO语句。延续是我们传递给函数（`factorial`）的函数参数（`next`），它指定函数应该返回的位置。阶乘函数不定义返回值。它是一个接受int和另一个传递其当前状态的函数。'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Calls continue until a base condition is met (`x == 0`) and then all the partially
    executed next functions on the stack are popped off and evaluated .We can call
    `factorial` like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 调用继续直到满足基本条件（`x == 0`），然后堆栈上的所有部分执行的下一个函数都被弹出并评估。我们可以这样调用`factorial`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It will print: **result: 24**Programming with Monads is a form of **continuation
    passing style** (**CPS**) that gives us more control; Using the Lexical Workflow
    Solution, upon encountering an error we can direct execution to the error path
    (bypassing subsequent chained function calls) to our workflow''s single idiomatic
    Go error handler.CPS can also be programmed using Goroutines and channels. |'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '它将打印：**result: 24**使用单子进行编程是**延续传递风格**（**CPS**）的一种形式，它给了我们更多的控制；使用词法工作流解决方案，当遇到错误时，我们可以将执行定向到错误路径（绕过后续的链式函数调用）到我们工作流的单一惯用Go错误处理程序。CPS也可以使用Goroutines和通道进行编程。|'
- en: '| **Currying** | Yes | Currying is where we get a function that accepts x parameters
    and return a composition of x functions each of which take 1 parameter. In FP,
    every function is a function of one argument. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **柯里化** | 是 | 柯里化是指我们得到一个接受x个参数的函数，并返回x个函数的组合，每个函数接受1个参数。在FP中，每个函数都是一个参数的函数。
    |'
- en: '| **Declarative** | Yes | Declarative style, as opposed to an imperative style,
    means that we write expressions as opposed to step by step instructions.The imperative
    function is not used as data; Instead, it''s used for its side effect, i.e., printing
    "Hello".'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '| **声明式** | 是 | 声明式风格，与命令式风格相对，意味着我们写表达式而不是逐步说明。命令式函数不用作数据；相反，它用于其副作用，即打印“Hello”。'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Either Data Type** | Yes | Either is a type constructor that takes two
    arguments. It allows us to say a value is either one of two types. For example,
    `Either Car Truck`. We can use Either to create an error handling system if we
    make our result of type   `Either Success Failure`. Slightly more complicated
    that the Maybe data type.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Either数据类型** | 是 | Either是一个接受两个参数的类型构造函数。它允许我们说一个值是两种类型中的一种。例如，`Either
    Car Truck`。我们可以使用Either来创建一个错误处理系统，如果我们将我们的结果类型定义为`Either Success Failure`。比Maybe数据类型稍微复杂一些。'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **First Class Functions** | Yes! | First-class functions can be passed around
    as parameters and returned as values. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **一级函数** | 是！ | 一级函数可以作为参数传递并作为值返回。 |'
- en: '| **Functional Composition** | Yes | Functional composition means that we decompose
    monolithic applications into our smallest units of computation. We can then re-combine
    our functions in new ways to create new functionality by chaining our function
    calls. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **函数组合** | 是 | 函数组合意味着我们将单片应用程序分解为最小的计算单元。然后，我们可以以新的方式重新组合我们的函数，通过链接我们的函数调用来创建新的功能。
    |'
- en: '| **Hindley-Milner type system** | No | HM infers types without requiring any
    type definitions. HM type systems support polymorphic types, where lists can contain
    items of different types. If Go used HM, then the type of b would be inferred
    as `float64` below (rather than throwing the runtime error, *constant 1.8 truncated
    to integer*)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Hindley-Milner类型系统** | 否 | HM推断类型而不需要任何类型定义。HM类型系统支持多态类型，其中列表可以包含不同类型的项目。如果Go使用了HM，那么b的类型将被推断为`float64`（而不是抛出运行时错误，*常量1.8被截断为整数*）'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Idempotence** | Yes | Idempotence  means that we can call our function
    repeatedly and it will produce the same result each time. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **幂等性** | 是 | 幂等性意味着我们可以重复调用我们的函数，每次都会产生相同的结果。 |'
- en: '| **Immutable data** | Yes | Immutable immutable data structures, once created,
    do not change. Data cannot be added, removed, or reordered. In order to make an
    *update* we need to create a copy with our changes. Immutability is a core tenant
    of FP because without it, the data flow in our applications become lossy and inconsistent.
    The true constant in FP (as in life) is change. Mutation hides change. For more
    reasons see the *Immutable Data* section below. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **不可变数据** | 是 | 不可变的数据结构一旦创建就不会改变。数据不能被添加、移除或重新排序。为了进行*更新*，我们需要创建一个带有我们的更改的副本。不可变性是FP的核心原则，因为没有它，我们应用程序中的数据流会变得不稳定和不一致。FP中真正的常数（如生活中）是变化。变异隐藏了变化。更多原因请参见下面的*不可变数据*部分。
    |'
- en: '| **Immutable variables** | Yes | Go has the const keyword, but that only works
    for ints and strings. In order to have a immutable object, we could to write it
    like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| **不可变变量** | 是 | Go有const关键字，但只适用于int和字符串。为了拥有不可变对象，我们可以这样写：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Or only allow access to fields via method calls that could be coded to prevent
    mutation. |
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者只允许通过方法调用访问字段，这可以编码以防止变异。 |
- en: '| **Lambda expressions** | Yes | A Lambda expression is an anonymous function,
    often used as data, passed as a parameter, and returned as data and used to invoke
    another function. Note that a lambda expression executes in the context of their
    appearance, that is, they only have access to the variables in their lexical scope
    and they take only one parameter.For an example of what is and what is not a lambda
    expression check: `2-design-patterns/ch04-solid/01_lambda/main.go`**Tip 1**: If
    we can call a function without using its return value then it’s impure.**Tip 2**:
    If we need to pass more than one parameter, use a partially applied function.**Tip
    3**: When we see some code like that like the following, we''re likely looking
    at a Lambda Expression:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Lambda表达式** | 是 | Lambda表达式是匿名函数，通常用作数据，作为参数传递，并作为数据返回，并用于调用另一个函数。请注意，lambda表达式在它们出现的上下文中执行，也就是说，它们只能访问它们的词法范围内的变量，并且只接受一个参数。要查看lambda表达式的示例和非lambda表达式的示例，请查看：`2-design-patterns/ch04-solid/01_lambda/main.go`**提示1**：如果我们可以调用一个函数而不使用它的返回值，那么它是不纯的。**提示2**：如果我们需要传递多个参数，请使用部分应用的函数。**提示3**：当我们看到像下面这样的代码时，我们可能正在看一个Lambda表达式：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **List Monad** | Yes | List monads are used to model nondeterministic computations
    that can return an arbitrary number of results. A list monad can return zero or
    more results.The return function inserts a value into a list like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '| **列表单子** | 是 | 列表单子用于模拟可以返回任意数量结果的非确定性计算。列表单子可以返回零个或多个结果。return函数将一个值插入到列表中，如下所示：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The bind function pulls values from the list, applies a function to them and
    produces a new list like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: bind函数从列表中提取值，对它们应用函数，并生成一个新的列表，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given the following function definitions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下函数定义：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The list monad allows us to compose **f** and **g** as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表单子允许我们将**f**和**g**组合如下：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'f looks like this:`f "X" --> ["W", "X", "Y"]`g looks like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: f看起来像这样：`f "X" --> ["W", "X", "Y"]`g看起来像这样：
- en: '`map g (f "X") --> [["w", "W"], ["x", "X"], ["y", "Y"]]`When we compose f and
    g we get`["w", "W","x", "X","y", "Y"]`Using the composition operator "." we can
    write the List monad composition as follows:`f >=> g = concat . map g . f` |'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`map g (f "X") --> [["w", "W"], ["x", "X"], ["y", "Y"]]`当我们组合f和g时，我们得到`["w",
    "W","x", "X","y", "Y"]`使用组合运算符"."，我们可以将List monad组合写成如下形式：`f >=> g = concat .
    map g . f` |'
- en: '| **Maybe data type** | Yes | Maybe represents a computation that might not
    return a result, i.e., an optional value. Maybe a is a value that either contains
    a value of type a (represented as Just a), or it is empty (represented as Nothing) The
    following definition of Maybe:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Maybe数据类型** | 是 | Maybe表示可能不返回结果的计算，即可选值。`Maybe a`是一个值，它要么包含类型为a的值（表示为Just
    a），要么为空（表示为Nothing）。以下是Maybe的定义：'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Says, `Maybe` a is either not there or it is there. If it's not there, its `Nothing`;
    If it is there is is Just a, where a is a value.Maybe is a polymorphic type that
    can be used to define a function that can produce a value of another type or nothing
    at all.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 说，`Maybe` a要么不存在，要么存在。如果不存在，它是`Nothing`；如果存在，它是Just a，其中a是一个值。Maybe是一种多态类型，可以用来定义一个可以产生另一种类型的值或根本没有值的函数。
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Maybe Monad** | Yes | The Maybe Monad is a type of error monad, where all
    errors are represented by `Nothing`. (The Either type provides more functionality.)Given
    the polymorphic nature of `Maybe` and associativity, we can say.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Maybe Monad** | 是 | Maybe Monad是一种错误单子，其中所有错误都由`Nothing`表示。（Either类型提供了更多功能。）鉴于`Maybe`的多态性和结合性，我们可以说。'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**h** is the Monadic composition of **f** and **g**.The definition of the `Maybe`
    monad is a follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**h**是**f**和**g**的单子组合。`Maybe`单子的定义如下：'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Monadic error handling** | Yes | `Maybe` helps us handle errors. It represents
    something expected rather than an unexpected error. Either is like a `Maybe` that
    also lets us return an arbitrary value instead of `Nothing.` Instead of worrying
    about receiving a null from a function call, which could cause a null pointer
    exception, our type system will force to handle error conditions a type-safe way.Using
    Either as our return type, e can run a task, get a result, check for the value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '| **单子错误处理** | 是 | `Maybe`帮助我们处理错误。它表示一些预期的东西，而不是意外的错误。Either就像一个`Maybe`，它还允许我们返回一个任意值而不是`Nothing`。与担心从函数调用中接收到null并可能导致空指针异常不同，我们的类型系统将强制以类型安全的方式处理错误条件。使用Either作为我们的返回类型，我们可以运行一个任务，获取一个结果，检查该值：'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And even if the task failed, we'll get a non-nil result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使任务失败，我们也会得到一个非空的结果。
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For details, see `2-design-patterns/ch04-solid/02_maybe` |
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详情，请参阅`2-design-patterns/ch04-solid/02_maybe` |
- en: '| **No side-effects** | Yes | *No side effects* means that the only thing that
    occurs when we call a pure function is:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '| **无副作用** | 是 | *无副作用*意味着当我们调用纯函数时，唯一发生的事情是：'
- en: We pass in parameters
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们传入参数
- en: We get a result; `Nothing` else happens.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们得到一个结果；没有其他事情发生。
- en: '**Tip 1:** If our function prints output it is impure. **Tip 2:** If any state/data
    changes anywhere else in our system as a result of calling our function then our
    function is impure. **Tip 3:** If our function has no return value then it is
    either impure or completely useless. |'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示1：**如果我们的函数打印输出，那么它是不纯的。**提示2：**如果在我们系统的任何其他地方调用我们的函数导致任何状态/数据的更改，那么我们的函数是不纯的。**提示3：**如果我们的函数没有返回值，那么它要么是不纯的，要么是完全无用的。
    |'
- en: '| **Operator overloading** | No | Operator overloading, also known as *ad hoc
    polymorphism*, is a specific case of polymorphism, where different operators like
    +, = or == are treated as polymorphic functions and as such have different behaviors
    depending on the types of its arguments. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **运算符重载** | 否 | 运算符重载，也称为*特定多态性*，是多态性的一个特例，其中不同的运算符如+、=或==被视为多态函数，并且根据其参数的类型具有不同的行为。
    |'
- en: '| **Option type** | Yes | We can create an Option typeclass in Go:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Option类型** | 是 | 我们可以在Go中创建一个Option类型类：'
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following is the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Parametric polymorphism** | No | Parametric Polymorphism means **Generics**.
    This is a style of datatype generic programming where we code our functions using
    non-specific data types. For example, we can implement generic algorithms that
    work on collections of non-specific types. Generics provides code reuse, type
    safety and easy-to-read code. See the following Generics section for a simple
    example. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **参数多态性** | 否 | 参数多态性意味着**泛型**。这是一种使用非特定数据类型编写函数的数据类型通用编程风格。例如，我们可以实现适用于非特定类型集合的通用算法。泛型提供了代码重用、类型安全和易于阅读的代码。请参阅以下泛型部分以获取一个简单的示例。
    |'
- en: '| **Partial function application** | Yes | Giving a function fewer arguments
    than it expects is called Partial function application. Here, our function accepts
    a function with multiple parameters and returns a function with fewer parameters.
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **部分函数应用** | 是 | 给予一个函数比它所期望的更少的参数被称为部分函数应用。在这里，我们的函数接受一个具有多个参数的函数，并返回一个参数较少的函数。
    |'
- en: '| **Pure functions** | Yes | Pure functions map inputs to outputs. When given
    the same input a pure function will always return the same output  (also known
    as *determinism*) and will not have any observable side effects.The  determinism
    of pure functions means that our FP programs'' correctness can be proven formally,
    which is a great benefit for mission critical applications.Just like a mathematical
    function, the output of our function depends entirely on its input and nothing
    else. For example, the output of the function below will always return two more
    than the value (x) passed to it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '| **纯函数** | 是 | 纯函数将输入映射到输出。给定相同的输入，纯函数将始终返回相同的输出（也称为*确定性*），并且不会有任何可观察的副作用。纯函数的确定性意味着我们的函数式编程程序的正确性可以得到正式证明，这对于关键任务应用程序是一个巨大的好处。就像数学函数一样，我们函数的输出完全取决于其输入，而与其他因素无关。例如，下面的函数的输出将始终比传递给它的值（x）多两个：'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Pattern matching** | No | Pattern matching enables the compiler to match
    a value  against some patterns to select a branch of the code.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| **模式匹配** | 否 | 模式匹配使编译器能够根据一些模式匹配一个值，以选择代码的一个分支。'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The value of our `ErrorMessage` in the preceding code will be one of five different
    error choices (`YourNameInvalid`, `YourPhoneInvalid`, and so on)In Go, we can
    accomplish this at runtime using a union type. |
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们的`ErrorMessage`的值将是五种不同的错误选择之一（`YourNameInvalid`、`YourPhoneInvalid`等）在Go中，我们可以在运行时使用联合类型来实现这一点。
    |
- en: '| **Pipelining** | Yes | Pipelining allows us to pass the output of one function
    as input to another. Function calls can be chained in a sequence to implement
    a workflow. Pipelining encourages code reuse and parallel execution. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **管道** | 是 | 管道允许我们将一个函数的输出作为另一个函数的输入。函数调用可以链接在一起以实现工作流程。管道鼓励代码重用和并行执行。'
- en: '| **Recursion** | Yes | Recursion is used by FP languages in place of loops
    where a function calls itself until an end condition is reached. In Go, every
    recursive call creates a call stack. TCO avoids creating a new stack by making
    last call in a recursion the function itself. Even though we can code recursively
    in Go without TCO, it''s just not practical because of poor performance. Note
    that recursion in pure FP languages are abstracted from sight by HOFs. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **递归** | 是 | 递归在FP语言中用于代替循环，其中一个函数调用自身直到达到结束条件。在Go中，每次递归调用都会创建一个调用堆栈。TCO通过使递归中的最后一次调用成为函数本身来避免创建新的堆栈。尽管我们可以在Go中使用递归编码而不使用TCO，但由于性能差，这并不实用。请注意，纯FP语言中的递归是通过HOFs从视线中抽象出来的。'
- en: '| **Referential rransparency** | Yes | Referential transparency is a property
    of pure functions where our function that always return the same output for the
    same inputs. Our function expression f(x) and the results of evaluating our function
    are interchangeable. For example, 1 + 1 is always equals 2\. As we saw in [Chapter
    2](../Text/Ch02.xhtml), *Manipulating Collections*, this means that we can cache
    the results of the first function invocation and improve performance.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '| **引用透明性** | 是 | 引用透明性是纯函数的属性，其中我们的函数总是为相同的输入返回相同的输出。我们的函数表达式f(x)和评估我们的函数的结果是可以互换的。例如，1
    + 1总是等于2。正如我们在[第2章](../Text/Ch02.xhtml)中看到的，*操作集合*，这意味着我们可以缓存第一次函数调用的结果并提高性能。'
- en: '**Tip:** If we can cache results from previous function calls then we have
    referential integrity. |'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示：**如果我们可以缓存先前函数调用的结果，那么我们就具有引用完整性。'
- en: '| **Sum or Union types** | Yes | We can implement a union type using an interface
    with `Success()` and `Failure()` methods that will return either Success or Failure.For
    details see `2-design-patterns/ch04-solid/02_maybe`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '| **和类型或联合类型** | 是 | 我们可以使用具有`Success()`和`Failure()`方法的接口来实现联合类型，该方法将返回Success或Failure。有关详细信息，请参见`2-design-patterns/ch04-solid/02_maybe`'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Tail Call Optimization** | No | Tail Call Optimization makes recursive
    function calls performant. A tail call happens when a function calls another as
    its last action. TCO acts like a GOTO statement. For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| **尾调用优化** | 否 | 尾调用优化使递归函数调用更高效。尾调用发生在一个函数调用另一个函数作为最后一个动作时。TCO的作用类似于GOTO语句。例如：'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The program does not need to return to the calling function when the called
    function g(x) ends b/c there is no executable code after that last line. After
    the tail call, the program does not need any call stack information about g. Without
    TCO the program will create a needless call stack for g; A lot of recursive calls
    will cause a stack overflow. With TCO, the recursive  program will be faster and
    consume far fewer resources. |
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用的函数g(x)结束时，程序不需要返回到调用函数，因为在最后一行之后没有可执行代码。在尾调用之后，程序不需要关于g的任何调用堆栈信息。没有TCO，程序将为g创建一个不必要的调用堆栈；大量递归调用将导致堆栈溢出。有了TCO，递归程序将更快，消耗的资源也会少得多。
- en: '| **Typeclasses** | Yes | Type classes allow us to define functions that can
    be used on different types with a potentially different implementation for each
    type. Each class represents a set of types and is associated with a particular
    set of member functions. For example, the type class Eq represents the set of
    all equality types, which is precisely the set of types on which the (==) operator
    can be used. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **类型类** | 是 | 类型类允许我们定义可以在不同类型上使用的函数，每种类型可能有不同的实现。每个类代表一组类型，并与特定的成员函数集相关联。例如，类型类Eq表示所有相等类型的集合，这正是可以使用(==)运算符的类型集合。'
- en: '| **Unit type** | Yes | A Unit type has exactly a one value. It is also known
    as the identity. The unit for multiplication is 1, for addition is 0, for string
    concatenation is the empty string. How many values can a type defined as a tuple
    of of type int contain? Infinite. (-∞, …, 0, 1, 2... ∞)  How many values can a
    type defined as the empty tuple contain?The value of a Unit type is that you can
    use it in places where we might otherwise return nil (or null). We return a Unit
    when we don’t care what the value is. We don’t return nil, we return a value;
    the Unit value. All functions return values; No more null pointer exceptions!The
    Unit type is also useful in places that need an empty value. For example, in F#
    an Async action which may create  side effects but does not return a value is
    an instance of type Async<unit> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **单元类型** | 是 | 单元类型恰好有一个值。它也被称为身份。乘法的单位是1，加法的单位是0，字符串连接的单位是空字符串。定义为int类型的元组类型可以包含多少个值？无限。(-∞,
    …, 0, 1, 2... ∞)定义为空元组的类型可以包含多少个值？单元类型的值在于可以在我们可能返回nil（或null）的地方使用它。当我们不关心值是什么时，我们返回一个单元。我们不返回nil，我们返回一个值；单元值。所有函数都返回值；不再有空指针异常！单元类型在需要空值的地方也很有用。例如，在F#中，可能会创建副作用但不返回值的异步操作是类型Async<unit>的实例。'
- en: These are not all characteristics of a pure FP, just some of the more significant
    ones. Probably the most important one is support for first class functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并非纯FP的所有特征，只是其中一些更重要的特征。可能最重要的是对一级函数的支持。
- en: The preceding table introduces a lot of concepts that we'll cover in greater
    detail later in our book. Feel free to skip ahead if your curiosity is too great;
    Otherwise, just go with the flow and we'll eventually get to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上表介绍了我们将在本书后面更详细地介绍的许多概念。如果你太好奇，可以随意跳过；否则，跟着流程走，我们最终会涉及到它。
- en: 'In the *Supported in Go?* column in the preceding table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中的*Go支持？*列中：
- en: '**Yes!**: Indicates that the FP characteristic exists in Go.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是！**：表示FP特性存在于Go中。'
- en: '**Yes**: Indicates that the characteristic or requirement can be achieved with
    some effort in Go.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是**：表示Go中可以通过一些努力实现该特性或要求。'
- en: '**No**: Indicates that this FP characteristic or requirement is missing and
    is difficult or not possible to achieve without a major upgrade to the Go compiler,
    or without using another technology in tandem with Go.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**否**：表示缺少此FP特性或要求，并且在不进行Go编译器的重大升级或在与Go并用其他技术的情况下，难以实现或不可能实现。'
- en: Function composition
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数组合
- en: Function composition is what happens when we combine functions. The output of
    one function is the the input of the next function. We can use objects and morphisms
    of category theory to help us get the order right. Take the following diagram
    for example...
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是当我们组合函数时发生的情况。一个函数的输出是下一个函数的输入。我们可以使用范畴论的对象和态射来帮助我们得到正确的顺序。例如，看下面的图表...
- en: '![](img/df1c8e59-30fe-4a52-89bc-fe93e0cf3599.png)>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/df1c8e59-30fe-4a52-89bc-fe93e0cf3599.png)>'
- en: We see that we can combine our functions f and g to get from A to B to C. Note
    that the order matters. We must first go from A to B via f and then from B to
    C via g.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以组合我们的函数f和g从A到B到C。请注意顺序很重要。我们必须先通过f从A到B，然后通过g从B到C。
- en: We express this with the following notation (f.g)(x). That reads, *f-compose-g
    with input x*. This expression equals g(f(x)), which reads *f of x of g*. So *(f.g)(x)
    == g(f(x))*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下符号表示（f.g)(x)。这读作*f-compose-g with input x*。这个表达式等于g(f(x))，读作*f of x of
    g*。所以*(f.g)(x) == g(f(x))*。
- en: 'This is what the compose function looks like in Go:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go中`compose`函数的样子：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Where `StrFunc` is defined as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`StrFunc`的定义如下：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our `main.go`, we define our `f` and `g` functions, recognize and emphasize,
    respectively:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.go`中，我们定义了我们的`f`和`g`函数，分别识别和强调：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We compose `f` and `g` as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`f`和`g`组合如下：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that order matters. What happens if we flip the order of `f` and `g` and
    then compose?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意顺序很重要。如果我们交换`f`和`g`的顺序，然后组合会发生什么？
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Monads allow us to chain continuations
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单子允许我们链接连续
- en: 'Chaining continuations means that we can execute a series of functions, where
    the output of one function is the input of the next. Check out the following example
    of chaining high-order functions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 链接连续意味着我们可以执行一系列函数，其中一个函数的输出是下一个函数的输入。查看以下链接高阶函数的示例：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You will see the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How much more code would be required if we were to implement the for loops,
    error checking, and other scaffolding that is typically required when coding Go
    in the typical imperative style of programming?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实现`for`循环、错误检查和其他通常在Go中编写典型命令式编程时所需的支撑，需要多少代码？
- en: Instead of telling Go how to filter, map, and reduce our collection, we declare
    what we want to accomplish. Later in this chapter, we do implement the `Filter`,
    `Map`, and `Reduce` functions, but what if the Go standard library already provides
    these for us?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是告诉Go如何过滤、映射和减少我们的集合，而是声明我们想要实现的目标。在本章后面，我们确实实现了`Filter`、`Map`和`Reduce`函数，但如果Go标准库已经为我们提供了这些函数呢？
- en: How can we expect Go to provide HOF implementations for cars? That would not
    be reasonable, right? What's missing? The answer is *generics*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何期望Go为汽车提供HOF实现？那是不合理的，对吧？缺少什么？答案是*泛型*。
- en: The ChainLink implementation in this chapter is sort of a poor man's monad.
    We'll explore a real monad in the last chapter of this book and discover that
    there are more operations involved (Bind, Return, monadic error handling). Real
    monads also do not rely on global variables. What is similar is that they both
    allow us to execute operations in order, where the output of one function is the
    input to the next. That is a key concept to remember.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的ChainLink实现有点像穷人的单子。我们将在本书的最后一章中探讨一个真正的单子，并发现涉及更多操作（Bind，Return，单子错误处理）。真正的单子也不依赖全局变量。相似的是它们都允许我们按顺序执行操作，其中一个函数的输出是下一个函数的输入。这是一个要记住的关键概念。
- en: Generics
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型
- en: Parametric polymorphism means generics. A generic function or a data type can
    be written to handle any data value using the same logic, without having to cast
    the value to a specific data type. This greatly improves code reuse.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 参数多态意味着泛型。泛型函数或数据类型可以编写为使用相同逻辑处理任何数据值，而无需将该值转换为特定数据类型。这大大提高了代码的重用性。
- en: 'The following is a C# code example of a generic `IsEqual` implementation. The
    generic `IsEqual` function will accept any type (that implements `Equals`). We
    pass `IsEqual` integers and strings by simply indicating the type `T` during runtime,
    at the moment `IsEqual` is executed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个泛型`IsEqual`实现的C#代码示例。泛型`IsEqual`函数将接受任何类型（实现`Equals`）。我们通过在运行时简单地指定类型`T`来传递`IsEqual`整数和字符串，在`IsEqual`执行时：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Currently, to do this in Go, we will have to use an empty interface and perform
    a type conversion. It's type conversion that will cause the performance hit that
    usually makes this sort of generics handling in Go impractical.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Go中，我们将不得不使用空接口并执行类型转换来执行此操作。正是类型转换导致了通常使Go中的泛型处理变得不切实际的性能损失。
- en: First-class functions
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头等函数
- en: 'First-class functions allow us to make new functions by providing our base
    functions with function parameters. In the following code, our base function is
    `Filter`. By passing `ByMake("Toyota")` to `Filter`, we remove most of the car
    items from our collection, leaving only Toyota:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 头等函数允许我们通过为基本函数提供函数参数来创建新函数。在下面的代码中，我们的基本函数是`Filter`。通过将`ByMake("Toyota")`传递给`Filter`，我们从集合中删除了大多数汽车项目，只留下了丰田汽车：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also have the ability to transform any function that works on single elements
    into a function that works on lists, by wrapping it with the `Map` function. Without
    our new functional style of programming, we might be tempted to implement a `for`
    loop and apply the `fmt.Sprintf` transformation on each individual car, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有能力将作用于单个元素的任何函数转换为作用于列表的函数，方法是用`Map`函数包装它。如果没有我们新的函数式编程风格，我们可能会尝试实现一个`for`循环，并对每辆汽车应用`fmt.Sprintf`转换，如下所示：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead, we can simply pass the `Upgrade` function to `Map` as we compose our
    data transformation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以将`Upgrade`函数简单地传递给`Map`，因为我们组合我们的数据转换：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We no longer need to write `for` loops that manipulate arrays because we can
    call `Map` inline.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要编写操纵数组的`for`循环，因为我们可以直接调用`Map`。
- en: HOFs can greatly reduce the time that it takes to develop complex logic. We
    can quickly compose smaller, task-specific functions into solutions for complex
    business logic much faster, with less scaffolding code, which means we'll have
    fewer bugs to fix. Our functions are in essence reusable building blocks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: HOFs可以大大减少开发复杂逻辑所需的时间。我们可以快速将较小的、特定任务的函数组合成更快的复杂业务逻辑解决方案，减少了更少的脚手架代码，这意味着我们将有更少的错误需要修复。我们的函数本质上是可重用的构建模块。
- en: HOFs are independent, making them easy to reuse, refactor, and reorganize in
    our code base. This makes our programs more flexible and resilient to future code
    changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: HOFs是独立的，这使它们易于在我们的代码库中重用、重构和重新组织。这使我们的程序更加灵活，更能抵御未来的代码更改。
- en: More readable code, faster implementation, fewer bugs. The benefits of FP are
    adding up!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 更易读的代码，更快的实现，更少的错误。函数式编程的好处正在累积！
- en: Closure
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: 'A closure is a function that closes over variables in its outer scope. We really
    need an example to understand that statement! Here''s a good one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一个在其外部范围内关闭变量的函数。我们真的需要一个例子来理解这个说法！这是一个很好的例子：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will see the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding closure is formed by the `addTwo` function. Inside `addTwo`, both
    `sum` and the anonymous function are declared in the same lexical scope. Since
    `addTwo` closes over both `sum` and the anonymous function, and because sum was
    declared before the anonymous function, the anonymous function always has access
    to, and can modify, the `sum` variable. As soon as `addTwo` is assigned to `twoMore`,
    the `addTwo` functions's anonymous function gets access to the `sum` variable
    and holds on to it as long as the application continues to run.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的闭包是由`addTwo`函数形成的。在`addTwo`内部，`sum`和匿名函数都在同一个词法范围内声明。由于`addTwo`闭合了`sum`和匿名函数，并且因为sum是在匿名函数之前声明的，匿名函数总是可以访问并修改`sum`变量。一旦`addTwo`被赋值给`twoMore`，`addTwo`函数的匿名函数就可以访问`sum`变量，并在应用程序继续运行时保持对其的控制。
- en: Dynamically scoped
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态作用域
- en: 'What if we accidentally initialized `sum` in an outer scope from where we defined
    our  function? Notice that there is no sum variable initialization in the same
    scope as our anonymous function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在外部范围意外地初始化了`sum`，而我们定义了我们的函数呢？请注意，在与我们的匿名函数相同的范围内没有sum变量初始化：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we run this in our `main()` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`main()`函数中运行这个时：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our Go runtime looks in the environment in which the anonymous function was
    called, rather than where it was defined (as is the case in lexical scoping).
    If `addTwoDynamic` had been nested several stack frames deep, our Go runtime would
    look where `addTwoDynamic` was defined for sum. If it was not found there, it
    would continue up the stack until sum is found. So, we see that dynamic scoping
    adds complexity and might cause the value of sum to change in unpredictable ways,
    or at least in ways that  are more difficult to debug.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Go运行时查找匿名函数被调用的环境，而不是它被定义的地方（这是词法作用域的情况）。如果`addTwoDynamic`嵌套了几个堆栈帧，我们的Go运行时会在`addTwoDynamic`被定义的地方查找sum。如果在那里找不到，它将继续向上查找堆栈，直到找到sum。因此，我们看到动态作用域增加了复杂性，并可能导致sum的值以不可预测的方式改变，或者至少以更难以调试的方式改变。
- en: 'The following is the output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What happened? Since sum was not defined in the scope in which our anonymous
    function was defined, Go found it in the global scope. It's value was 5. `addTwoDynamic`
    added 2 to 5 and got 7. `addTwoDynamic` did it again and got 9\. Probably not
    what we wanted.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？由于sum没有在我们定义匿名函数的范围内定义，Go在全局范围内找到了它。它的值是5。`addTwoDynamic`将2加到5得到7。`addTwoDynamic`再次这样做，得到9。可能不是我们想要的。
- en: Being able to pass around lexical context is powerful and guarantees that we
    won't have side effects that might occur with dynamic scoping. We'll look at a
    practical example where we create an application context, for example, database
    connection, logger, and so on, at application startup and pass that context around
    where needed throughout our application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 能够传递词法上下文是强大的，并且保证我们不会出现动态作用域可能发生的副作用。我们将看一个实际的例子，我们在应用程序启动时创建一个应用程序上下文，例如数据库连接、记录器等，并在整个应用程序中需要时传递该上下文。
- en: Pure function
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯函数
- en: A pure function is a function that when given the same input will always return
    the same output and will not have any observable side effects. How is that a benefit?
    Let's see. We can run any pure function in parallel since our functions do not
    need access to shared memory. Race condition due to side effects are not possible
    with pure functions. The performance gains of running our code concurrently on
    multiple cores is another awesome benefit of FP.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是指当给定相同的输入时，将始终返回相同的输出，并且不会有任何可观察的副作用。这有什么好处？让我们看看。我们可以并行运行任何纯函数，因为我们的函数不需要访问共享内存。由于纯函数不可能出现由于副作用而导致的竞争条件。在多核上并发运行我们的代码的性能收益是函数式编程的另一个令人惊叹的好处。
- en: Immuable Data
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变数据
- en: 'Immutable data structures:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构：
- en: Have one state and never change
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个状态并且永远不改变
- en: Are simpler to construct, debug, test, and reason about
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易构建、调试、测试和推理
- en: Are side-effect free
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有副作用
- en: Improve performance and are more scalable because they are easier to cache
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高性能并且更具可扩展性，因为它们更容易缓存
- en: Are safer in that they prevent null pointer references
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更安全，因为它们防止空指针引用
- en: Are thread safe
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全
- en: Are always in a stable state
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是处于稳定状态
- en: Since immutable data structures are never changed, that means that failures
    never occur during a data modification operation. When an immutable data structure
    is initialized it will either fail or succeed, returning a valid data structure
    that never changes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变数据结构永远不会更改，这意味着在数据修改操作期间永远不会发生故障。当初始化不可变数据结构时，它将失败或成功，返回一个永远不会更改的有效数据结构。
- en: In order to make changes to an immutable data structure, we must create a new
    tree. Suppose we want to update the value of g in the existing tree data structure
    (*previous root)*. First, we would create the g' node and build the new tree by
    traversing the nodes connected to g and copying only those values necessary to
    rebuild the tree. References to other nodes can be created without creating new
    nodes (these are the nodes in white). With the new root in place, new leaf nodes
    are added to the new tree structure.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对不可变数据结构进行更改，我们必须创建一个新的树。假设我们想要更新现有树数据结构（*先前的根*）中g的值。首先，我们将创建g'节点，并通过遍历与g连接的节点并仅复制重建树所需的那些值来构建新树。可以创建对其他节点的引用而不创建新节点（这些是白色节点）。有了新的根，新的叶节点被添加到新的树结构中。
- en: Once the new root has been created the previous/old root can be preserved or
    it can be marked for deletion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的根，先前/旧的根可以被保留，也可以被标记为删除。
- en: '![](img/f1d89ea7-d7eb-4169-8cde-e3bad95d668c.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1d89ea7-d7eb-4169-8cde-e3bad95d668c.png)'
- en: This may seem like a lot of work, but one of the greatest benefits is that we
    no longer need to worry about our data unexpectedly changing. For example, what
    if one Goroutine is looping through our data structure while another one is removing
    elements from it? We no longer need to concern ourselves with dealing with race
    conditions and verifying that our preconditions are still valid. When we use immutable
    data structures, our code becomes more robust and easier to reason about.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很费力，但最大的好处之一是我们不再需要担心我们的数据意外更改。例如，如果一个Goroutine正在循环遍历我们的数据结构，而另一个Goroutine正在从中删除元素，我们不再需要担心处理竞争条件并验证我们的前提条件是否仍然有效。当我们使用不可变数据结构时，我们的代码变得更加健壮，更容易理解。
- en: Can you think of any solutions today that make use of immutable data structures?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否能想到今天使用不可变数据结构的任何解决方案？
- en: Ever wondered how git works?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经想知道git是如何工作的吗？
- en: Interested in full stack development? How does ReactJS update its models?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对全栈开发感兴趣吗？ReactJS如何更新其模型？
- en: In the game of soccer, we may loose to a team because they have a player with
    specific skills. When we face the team again we may forget the past, but that
    does not change history; It is not possible to change the past. When the past
    is not preserved, we cannot learn from it and history will repeat itself. Mutability
    hides changes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在足球比赛中，我们可能输给一个具有特定技能的球员的球队。当我们再次面对这支球队时，我们可能会忘记过去，但这并不会改变历史；改变过去是不可能的。当过去没有被保留时，我们无法从中学习，历史将重演。可变性隐藏了变化。
- en: Persistent data structures for Go
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Go的持久数据结构
- en: Check out [https://godoc.org/github.com/mndrix/ps](https://github.com/mndrix/ps)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://godoc.org/github.com/mndrix/ps](https://github.com/mndrix/ps)
- en: 'From it''s documentation:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 来自它的文档：
- en: Fully persistent data structures. A persistent data structure is a data structure
    that always preserves the previous version of itself when it is modified. Such
    data structures are effectively immutable, as their operations do not update the
    structure in-place, but instead always yield a new structure.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 完全持久的数据结构。持久数据结构是一种数据结构，当修改时总是保留其先前版本。这样的数据结构实际上是不可变的，因为它们的操作不会在原地更新结构，而是总是产生一个新的结构。
- en: Persistent data structures typically share structure among themselves. This
    allows operations to avoid copying the entire data structure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 持久数据结构通常彼此共享结构。这使得操作可以避免复制整个数据结构。
- en: 'ps has small but effective API for manipulating lists and maps of data:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ps具有用于操作数据列表和映射的小而有效的API：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For more details see [https://godoc.org/github.com/mndrix/ps](https://godoc.org/github.com/mndrix/ps)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参见[https://godoc.org/github.com/mndrix/ps](https://godoc.org/github.com/mndrix/ps)
- en: Use of expressions
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用表达式
- en: Use of expressions (rather than statements) means that in FP, we pass a value
    to a function that typically transforms it in some way and then returns a new
    value. Since FP functions have no side effects, an FP function that does not return
    a value is useless and a sign of code smell. In [Chapter 1](../Text/Ch01.xhtml),
    *Pure Functional Programming in Go*, we saw that imperative programming focuses
    on the step-by-step mechanics of how a program operates, whereas in declarative
    programming, we declare what we want the results to be.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式（而不是语句）意味着在FP中，我们将一个值传递给一个函数，通常以某种方式对其进行转换，然后返回一个新值。由于FP函数没有副作用，一个不返回值的FP函数是无用的，也是代码异味的标志。在[第1章](../Text/Ch01.xhtml)中，*Go中的纯函数式编程*，我们看到命令式编程关注程序操作的逐步机制，而在声明式编程中，我们声明了我们希望结果是什么。
- en: 'Here''s an example of imperative programming:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令式编程的一个例子：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s an example of declarative programming:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是声明式编程的一个例子：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have less, declarative FP code that is easier to read.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有更少、更易于阅读的声明性FP代码。
- en: Sample HOF application
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本HOF应用程序
- en: Let’s build a sample app that will demonstrate the benefits of applying functional
    programming concepts to Go.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个示例应用程序，演示将函数式编程概念应用于Go的好处。
- en: 'Our app will read from the following `cars.csv` file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将从以下`cars.csv`文件中读取：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We will apply high-order functions and various functional programming constructs
    to the list of cars to filter, map, reduce, and transform it to our heart's content.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用高阶函数和各种函数式编程构造到汽车列表中，以过滤、映射、减少和转换它。
- en: 'Our project is structured as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目结构如下：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At the root of the `chapter4` directory is our `main.go` file. Since we plan
    to build a Go executable from `main.go` and run it, we use the package name of
    `main` and include a `main()` function.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter4`目录的根目录是我们的`main.go`文件。由于我们计划从`main.go`构建一个Go可执行文件并运行它，我们使用`main`包名并包括一个`main()`函数。
- en: The other files will be in a subdirectory named `01_hof`, where `hof` stands
    for high-order functions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文件将位于名为`01_hof`的子目录中，其中`hof`代表高阶函数。
- en: The chapter4 application code
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4章应用程序代码
- en: 'Let''s examine our `chapter4` implementation, starting with `main.go`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main.go`开始检查我们的`chapter4`实现：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The dot (`.`) in the ` . "github.com/l3x/learn-fp-in-go/chapter4/01_hof"` import
    keeps us from having to preface the functions in that directory with `hof`, which
    is the package name used by all the Go files in that directory:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在` . "github.com/l3x/learn-fp-in-go/chapter4/01_hof"`导入中的点(`.`)使我们不必在该目录中的函数前加上`hof`，这是该目录中所有Go文件使用的包名称：
- en: '[PRE49]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We'll use the `log` package to log output to stdout. Passing a 0 value to `log.SetFlags`
    tells the logger to print without prepending timestamps. We also tell the logger
    to print to `stdout`, rather than the default `stderr` because we want all of
    the output to be consistently displayed for ease of reading. We'd likely not output
    any information to `stdout` for a production application because there isn't anything
    useful for the program to send on `stdout` other than command help and usage information.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用`log`包将输出记录到`stdout`。将0值传递给`log.SetFlags`告诉记录器在不添加时间戳的情况下打印。我们还告诉记录器打印到`stdout`，而不是默认的`stderr`，因为我们希望所有输出都能一致地显示，以便阅读。对于生产应用程序，我们可能不会将任何信息输出到`stdout`，因为除了命令帮助和使用信息之外，程序没有任何有用的信息要发送到`stdout`。 '
- en: 'The `log` function can easily be configured to prepend timestamps and line
    numbers. The `log.SetFlags(log.Lshortfile | log.Ldate)` setting will print the
    output to `stdout`: ` 2017/04/07 utils.go:17: car: Honda Accord`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`函数可以很容易地配置为在时间戳和行号之前添加。`log.SetFlags(log.Lshortfile | log.Ldate)`设置将输出打印到`stdout`：`2017/04/07
    utils.go:17: car: Honda Accord`。'
- en: Build and runtime instructions
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建和运行时指令
- en: 'After verifying that our Go environment is properly configured, we can change
    the directory to a project directory and start a RESTful web server with the following
    command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证我们的Go环境是否正确配置之后，我们可以切换到项目目录并使用以下命令启动RESTful web服务器：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See the *My Go build and runtime process* section in the Appendix, *Miscellaneous
    Information and How-Tos*, for details regarding how I manage my Go environment.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有关我如何管理我的Go环境的详细信息，请参阅附录中的*My Go build and runtime process*部分，*Miscellaneous
    Information and How-Tos*。
- en: 'We''ll need to open another Terminal window to run our `chapter4` executable.
    Let''s build and run our `chapter4` app to exercise our HOFs with the following
    command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要打开另一个终端窗口来运行我们的`chapter4`可执行文件。让我们构建和运行我们的`chapter4`应用程序，以使用以下命令来运行我们的HOFs：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The top few lines of output should look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的前几行应该如下所示：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: More application code
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多应用程序代码
- en: 'The first thing we do in the `main()` function is check the `RUN_HTTP_SERVER`
    environment variable. If it''s set to `true`, then the program will set up two
    routes. The first route `/cars` returns the index page that displays all the cars
    that have been loaded from the `.csv` files. The second route `/cars/:id` retrieves
    an individual car object and returns its JSON representation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们首先检查`RUN_HTTP_SERVER`环境变量。如果它被设置为`true`，那么程序将设置两个路由。第一个路由`/cars`返回显示从`.csv`文件中加载的所有汽车的索引页面。第二个路由`/cars/:id`检索单个汽车对象并返回其JSON表示：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `IndexedCars` variable is defined in `types.go` as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexedCars`变量在`types.go`中定义如下：'
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before we look at the else logic, let''s take a peek at the following `cars.go` file.
    We declare an exported package level variable `CarsDB` that is assigned a slice
    of `IndexedCars`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看else逻辑之前，让我们来看一下以下`cars.go`文件。我们声明了一个导出的包级变量`CarsDB`，它被赋予了一个`IndexedCars`的切片：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that every Go source file in our `01_hof` directory uses the package name
    `hof`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们`01_hof`目录中的每个Go源文件都使用包名称`hof`。
- en: We preface the `strings` package with `s` so that we can easily reference string
    utility functions with `s` like this: `s.Contains(car, make)` rather than `strings.Contains(car,
    make)`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`s`来引用`strings`包，这样我们就可以很容易地使用`s`来引用字符串实用函数，比如`s.Contains(car, make)`，而不是`strings.Contains(car,
    make)`。
- en: Since `var CarsDB = initCarsDB()` is defined at the package level, it will be
    evaluated when we start our `chapter4` executable. The `initCarsDB()`  function
    only needs to be referenced in this `cars.go` file, so we do not need to capitalize
    its first character.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`var CarsDB = initCarsDB()`是在包级别定义的，所以当我们启动`chapter4`可执行文件时，它将被评估。`initCarsDB()`函数只需要在这个`cars.go`文件中引用，所以我们不需要将其首字母大写。
- en: The  `LoadCars()` function, on the other hand, is referenced by the main package,
    so we need to capitalize its first character in order to make it accessible.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`LoadCars()`函数被主包引用，因此我们需要将其首字母大写以使其可访问。
- en: Now, let's turn our attention to the FP goodies in the else block.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把注意力转向else块中的FP好东西。
- en: The Filter function
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Filter函数
- en: 'The first HOF that we exploit is the `Filter` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用的第一个HOF是`Filter`函数：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You will see the following output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Filter` function is in the `cars.go` file. Observe the `fn` argument.
    It is passed into the `Filter` function and later called with a `car` parameter.
    If `fn(car)`--that is, `ByMake("Honda")`--returns `true`, then the car is added
    to the collection:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter`函数在`cars.go`文件中。观察`fn`参数。它被传递到`Filter`函数中，稍后会用`car`参数调用。如果`fn(car)`——也就是`ByMake("Honda")`——返回`true`，那么这辆车就会被添加到集合中：'
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When we define the `Filter` function on the `cars collection` type, it's called
    a method. A Go method is a function with a special receiver argument. In our `Filter`
    function, the `cars` collection is the receiver. Notice that `cars` is in the
    first set of arguments, between the `func` keyword and the `Filter` name. Note
    that `cars` is a data structure that has a `Filter` behavior. The `Filter` method
    accepts `FilterFun` as its argument and returns a filtered collection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`cars collection`类型上定义`Filter`函数时，它被称为方法。Go方法是带有特殊接收器参数的函数。在我们的`Filter`函数中，`cars`集合是接收器。请注意，`cars`在第一组参数中，位于`func`关键字和`Filter`名称之间。注意`cars`是具有`Filter`行为的数据结构。`Filter`方法接受`FilterFun`作为其参数，并返回一个过滤后的集合。
- en: Reality check
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 现实检查
- en: What? A `for` loop? A mutating `car` variable? What gives? We must face the
    facts. The Go compiler does not provide TCO, so a recursive implementation is
    simply not practical. Perhaps Go 2.0 will provide a pure functional library with
    all our favorite HOFs as well as generics. Until then, we will make do with using
    the functional programming style as much as possible with a bit of imperative
    programming where necessary. Another option that we'll explore later is an execution
    system named **Gleam**, which provides pure Go mappers and reducers that provide
    high performance and concurrency.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？一个`for`循环？一个可变的`car`变量？怎么回事？我们必须面对现实。Go编译器不提供TCO，因此递归实现根本不现实。也许Go 2.0将提供一个纯函数库，其中包括我们所有喜爱的高阶函数以及泛型。在那之前，我们将尽可能地使用函数式编程风格，必要时使用一些命令式编程。我们稍后将探讨的另一个选项是一个名为**Gleam**的执行系统，它提供了纯Go映射器和减速器，提供了高性能和并发性。
- en: Data transformations are so common that it's nice to have a shorthand for it.
    HOF's ability to simplify both writing and reading code that performs data transformations
    is one of FP's greatest benefits.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换是如此常见，以至于有一个简写方式是很好的。高阶函数简化了执行数据转换的代码的编写和阅读，这是FP最大的好处之一。
- en: FilterFunc
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FilterFunc
- en: 'In the `types.go` file, we see its definition:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`types.go`文件中，我们看到了它的定义：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Looking back at the line in `main.go`, we see that we use the `ByMake` filter
    function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下`main.go`中的那一行，我们看到我们使用了`ByMake`过滤函数：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `ByMake` function is defined in the `cars.go` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByMake`函数在`cars.go`文件中定义：'
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `ByMake` function is a HOF because it returns a function. Recall that `Filter` is
    a HOF because it accepts a function. In this case, `ByMake` is that function,
    `fn`, as we will see in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByMake`函数是一个高阶函数，因为它返回一个函数。回想一下，`Filter`是一个高阶函数，因为它接受一个函数。在这种情况下，`ByMake`就是那个函数`fn`，我们将在下一节中看到。'
- en: Filter function
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 过滤函数
- en: The `Filter` function is a HOF that takes another HOF, namely `ByMake`, and performs a
    data transformation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter`函数是一个高阶函数，它接受另一个高阶函数，即`ByMake`，并执行数据转换。'
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: RESTful resources
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RESTful资源
- en: 'Let''s open `http://localhost:8000/cars` to see the full list of cars from
    both `cars.csv` and `more_cars.csv`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`http://localhost:8000/cars`，看看来自`cars.csv`和`more_cars.csv`的所有汽车的完整列表：
- en: '![](img/fa24237d-e100-487d-9d2c-0edce3dea662.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa24237d-e100-487d-9d2c-0edce3dea662.png)'
- en: 'Let''s take a look at the next `Filter` function in action in `main.go`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`main.go`中下一个`Filter`函数的运行情况：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You will see the following output:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `FilterFunc` method used in this case is `ByHasNumber()`. It operates like
    `ByMake FilterFunc` and uses Go''s regexp `MatchString` function to return `true`
    if the car has a number in it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用的`FilterFunc`方法是`ByHasNumber()`。它的操作方式类似于`ByMake FilterFunc`，并使用Go的regexp
    `MatchString`函数来返回`true`，如果汽车中有数字的话：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Chaining functions
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链接函数
- en: 'Now that we have the hang of it, let''s chain a few filters together:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经掌握了，让我们将几个过滤器链接在一起：
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You will see the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: More cars
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多的汽车
- en: 'It''s time to add more cars:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加更多的汽车了：
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output of this is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Wait, what? `AddCars`? How is that an HOF? `AddCars` neither takes a function
    nor returns a function. Even worse, it mutates the `cars` collection.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么？ `AddCars`？那怎么成为高阶函数了？ `AddCars`既不接受函数，也不返回函数。更糟糕的是，它改变了`cars`集合。
- en: Reality check
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 现实检验
- en: It's not important that the cars collection remain *pure*; frankly, that's not
    feasible, given that the Go compiler currently does not provide TCO. What's important
    is that our code improves with the use of functional programming techniques. Granted,
    this one, `AddCars`, is the furthest function we have from pure, but it is useful
    and it does improve our programs' readability. We do need to be careful when we
    use non-pure functions, especially ones that mutate their state, but this usage
    is perfectly fine for our purposes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车集合保持*纯粹*并不重要；坦率地说，这是不可行的，因为Go编译器目前不提供TCO。重要的是，我们的代码通过使用函数式编程技术得到改进。诚然，这个`AddCars`距离纯粹的函数最远，但它是有用的，它确实提高了我们程序的可读性。当我们使用非纯函数时，尤其是那些改变其状态的函数时，我们需要小心，但对于我们的目的来说，这种用法是完全可以的。
- en: 'We find `AddCars` in `cars.go`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`cars.go`中找到了`AddCars`：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The Map function
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Map函数
- en: 'Back to `main.go`. This time, you''ll be introduced to the `Map` HOF. Whereas
    `Filter` acts to reduce the number of items in the resulting collection, `Map`
    will return the same number of items that it receives. The `Map` function transforms
    the collection into a new collection, where each item is changed in some way:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main.go`。这一次，您将介绍`Map`高阶函数。而`Filter`的作用是减少结果集合中的项目数量，`Map`将返回与接收到的项目数量相同的项目。`Map`函数将集合转换为一个新的集合，其中每个项目都以某种方式改变：
- en: '[PRE71]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here''s the output of this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We pass a `MapFunc` function named `Upgrade` to `Map`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个名为`Upgrade`的`MapFunc`函数传递给`Map`：
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`Upgrade` calls the `UpgradeLabel` function in order to append the appropriate
    upgrade label to the end of the cars'' model name:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Upgrade`调用`UpgradeLabel`函数，以便在汽车的型号名称末尾添加适当的升级标签：'
- en: '[PRE74]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Improved performance from the Map function
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Map函数的性能提高
- en: One of the greatest benefits of FP is performance.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: FP的最大好处之一是性能。
- en: Programs today achieve better performance largely by performing more than one
    operation at a time using multiple CPU cores.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的程序主要通过使用多个CPU核心同时执行多个操作来实现更好的性能。
- en: This means running code in parallel, and to do that, our code must be thread-safe.
    Programs that have a shared mutable state are not thread-safe. These programs
    will be bottlenecked in one core.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着并行运行代码，为了做到这一点，我们的代码必须是线程安全的。具有共享可变状态的程序是不安全的。这些程序将在一个核心中成为瓶颈。
- en: FP solves this bottleneck/thread safety issue by returning new instances of
    variables rather than changing the original instance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: FP通过返回变量的新实例而不是改变原始实例来解决了这个瓶颈/线程安全问题。
- en: '![](img/24149bd7-d77b-4308-a2f5-d78e76d0d712.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24149bd7-d77b-4308-a2f5-d78e76d0d712.png)'
- en: 'Let''s look at the `Map` function to see how we can pull this off using FP:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Map`函数，看看我们如何使用FP实现这一点：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Instead of appending to the cars collection, that `Map` receives a new variable
    `mappedCars`. The `mappedCars` collection is mutated, not the original cars collection.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`不是将内容附加到汽车集合，而是接收一个新变量`mappedCars`。`mappedCars`集合被改变，而不是原始汽车集合。'
- en: What we are doing, tactically, when we call `Map(Upgrade())` is pushing the
    moment that our data changes out to the last moment--in this example, after `mappedCars`
    has been populated.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Map(Upgrade())`时，我们在战术上所做的是将我们的数据更改的时刻推迟到最后一刻--在这个例子中，是在`mappedCars`被填充之后。
- en: We have been programming our way around FP concepts our entire career. Part
    of what we do in this chapter is to identify these FP patterns and see how and
    why we should exploit them.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在我们的整个职业生涯中编写FP概念。本章的部分内容是识别这些FP模式，以及我们应该如何以及为什么要利用它们。
- en: The Reduce function
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Reduce函数
- en: Next, let's look at the `Reduce` function. `Reduce` is the Swiss army knife
    of HOFs. With a `Reduce` function, we can do anything that can be done with `Filter`
    or `Map`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`Reduce`函数。`Reduce`是HOF的瑞士军刀。有了`Reduce`函数，我们可以做任何可以用`Filter`或`Map`完成的事情。
- en: A `Reduce` function, also known as a `fold`, `accumulate`, `aggregate`, `compress`,
    or `inject` takes a seed value and applies the logic of the reducer function to
    the seed, and potentially multiple calls to itself to arrive at a result. Often,
    the reduce function will combine the data elements to return a single aggregated
    value, hence the term `fold`. So, we fold all of the data into a single result.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reduce`函数，也称为`fold`、`accumulate`、`aggregate`、`compress`或`inject`，接受一个种子值，并将reducer函数的逻辑应用于种子，并可能多次调用自身以得到结果。通常，reduce函数将组合数据元素以返回单个聚合值，因此称为`fold`。因此，我们将所有数据折叠成一个结果。'
- en: 'Back in `main.go`, we apply the `ByMake` filter to filter out all the cars
    that are not a Honda product. Then, we call the `Reduce` function to transform
    the collection of Honda vehicles into a collection of JSON strings:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main.go`，我们应用`ByMake`过滤器来过滤掉所有不是本田产品的汽车。然后，我们调用`Reduce`函数将本田车辆的集合转换为JSON字符串的集合：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output of this will be as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `Reduce` function is a method of the cars collection that accepts a `Reducer`
    function. Again, we see a `for` loop and recall, *No TCO, No recursion*. That''s
    okay. So, the guts of our `Reduce` function is not *pure*. That''s OK. It''s still
    readable, performant, and safe; in the spirit of Go programming, it gets the job
    done:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reduce`函数是汽车集合的一个方法，接受一个`Reducer`函数。再次看到一个`for`循环，并回想起，“没有尾调用优化，没有递归”。没关系。所以，我们的`Reduce`函数的核心部分不是*纯*的。没关系。它仍然是可读的，高效的，安全的；符合Go编程的精神，它完成了工作：'
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The second parameter `Collection{}` is the accumulator, which is the initial
    value assigned to the result. The `Reducer` function starts with the accumulator
    value, performs transformations on each item in the collection, and returns the
    result. This `Reduce` function provides the framework in which to perform a reduction,
    but it's the reducer function (`fn`) that does the heavy lifting. Note that we
    can pass any valid reducer function (`fn`) into the `Reduce` framework to get
    vastly different results.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数`Collection{}`是累加器，是分配给结果的初始值。`Reducer`函数从累加器值开始，在集合中的每个项目上执行转换，并返回结果。这个`Reduce`函数提供了执行减少的框架，但是真正的工作是由reducer函数（`fn`）完成的。请注意，我们可以将任何有效的reducer函数（`fn`）传递到`Reduce`框架中，以获得截然不同的结果。
- en: 'Our `JsonReducer` function does the real work of transforming each item in
    the cars collection into a JSON string:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`JsonReducer`函数真正地将汽车集合中的每个项目转换为JSON字符串：
- en: '[PRE79]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Reduce is an HOF function that takes a function. `JsonReducer` is an HOF function
    that returns a function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Reduce是一个接受函数的HOF函数。`JsonReducer`是一个返回函数的HOF函数。
- en: More high-order functions
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多高阶函数
- en: Now, let's return to `main.go` to look at a few more HOFs in action.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们返回`main.go`，看看更多HOF的实际应用。
- en: 'We apply our `ByMake` filter and a new type of reducer. This reducer, `Reducer2`,
    will return a slice of `CarTypes` rather than JSON:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用我们的`ByMake`过滤器和一种新类型的reducer。这个reducer，`Reducer2`，将返回一个`CarTypes`的切片，而不是JSON：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the output of this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个的输出：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following is another example that shows how easy chaining, also known as
    function composition, is:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个示例，展示了链式调用（也称为函数组合）有多么容易：
- en: '[PRE82]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here''s the output of this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个的输出：
- en: '[PRE83]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We saw how the `Upgrade` map function adds the appropriate label to the end
    of the car model. By applying `Downgrade` after `Upgrade`, we effectively undo
    `Upgrade`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`Upgrade`映射函数如何在汽车型号末尾添加适当的标签。通过在`Upgrade`之后应用`Downgrade`，我们有效地撤消了`Upgrade`。
- en: Generators
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Time to check out generators. Generators are useful because they allow us to
    delay an expression evaluation. We only compute the expression(s) we need when
    we need them. Generators also conserve memory because with generators, we only
    create and use what we need, no more:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候检查生成器了。生成器很有用，因为它们允许我们延迟表达式的评估。我们只在需要时计算我们需要的表达式。生成器还节省内存，因为使用生成器，我们只创建和使用我们需要的，不多不少：
- en: '[PRE84]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We will find the implementation of `GenerateCars` in the `generate.go` file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`generate.go`文件中找到`GenerateCars`的实现：
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We define our imports. The `sync` import is a clue that we have a need to synchronize
    our Goroutines. The `iterator` function will be passed to the `carGenerator` function
    and will track how many cars we've generated. We'll be creating cars as per need
    basis.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义我们的导入。`sync`导入是一个线索，表明我们需要同步我们的Goroutines。`iterator`函数将被传递给`carGenerator`函数，并将跟踪我们生成了多少辆汽车。我们将根据需要创建汽车。
- en: RESTful server
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RESTful服务器
- en: 'If we have our RESTful server running on port `8000`, we can open our web browser
    to `http://localhost:8000/cars/1` and see the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的RESTful服务器在端口`8000`上运行，我们可以在网页浏览器中打开`http://localhost:8000/cars/1`，看到以下内容：
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is a representation of an `IndexedCar` struct. It has an index and a car
    make and model string.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`IndexedCar`结构的表示。它有一个索引和一个汽车制造商和型号字符串。
- en: 'Here''s the actual `IndexedCar` struct in `types.go`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`types.go`中实际的`IndexedCar`结构：
- en: '[PRE87]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The GenerateCars function
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成汽车函数
- en: 'Here''s the actual generator function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实际的生成器函数：
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `GenerateCars` is another method in the `cars` collection that makes it
    easy to compose data transformations with other HOFs. `GenerateCars` takes a start
    index and limit, which is the number of cars that we want to be returned. We create
    `carChannel` of pointers to `IndexedCars`:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateCars`是`cars`集合中的另一个方法，它使得与其他HOFs组合数据变换变得容易。`GenerateCars`接受一个起始索引和限制，即我们想要返回的汽车数量。我们创建指向`IndexedCars`的`carChannel`：'
- en: '[PRE89]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We use `sync.WaitGroup` as a counting semaphore to wait for our collection
    of Goroutines to finish:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sync.WaitGroup`作为计数信号量来等待我们的一系列Goroutines完成：
- en: '[PRE90]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We calculate the number of cars we want to generate and pass that number to
    the `waitGroup.Add` function:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算要生成的汽车数量，并将该数字传递给`waitGroup.Add`函数：
- en: '[PRE91]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Our `carGenerator` function returns a function that we assign to a variable
    named `next`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`carGenerator`函数返回一个我们分配给变量`next`的函数：
- en: '[PRE92]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `next` variable returns two variables: `carIndex` and `done`. As long as
    there are more cars to generate, `done` will be `false`. So, we can use `done`
    to control a `for` loop that launches a Goroutine, one for each car to generate:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`变量返回两个变量：`carIndex`和`done`。只要还有更多的汽车要生成，`done`就会是`false`。因此，我们可以使用`done`来控制一个`for`循环，为要生成的每辆汽车启动一个Goroutine：'
- en: '[PRE93]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `next` variable returns two variables `GetThisCar(carIndex)` in the code
    block; immediately after this, the preceding code calls the RESTful car service
    that returns the requested car.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`变量在代码块中返回两个变量`GetThisCar(carIndex)`；在此之后，前面的代码调用RESTful汽车服务，返回所请求的汽车。'
- en: If an error is encountered, we use the built-in function `panic` to stop the execution
    of the current Goroutine. Since we used a deferred function, namely `csvfile.Close()`,
    in the call stack, it will be executed if a panic occurs. Note that we could have
    had more control over the termination sequence using the built-in recover function.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到错误，我们使用内置函数`panic`来停止当前Goroutine的执行。由于我们使用了延迟函数，即`csvfile.Close()`，在调用堆栈中，如果发生panic，它将被执行。请注意，我们本可以使用内置的recover函数更好地控制终止序列。
- en: The `thisCar` variable is sent to `carChannel`, and the `Car` field is appended
    to the `generatedCars` collection.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`thisCar`变量被发送到`carChannel`，并且`Car`字段被附加到`generatedCars`集合中。'
- en: Currying Goroutine
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 柯里化Goroutine
- en: 'Notice anything special about the `generatedCars` collection? (Hint: Our Goroutine
    is an anonymous function).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`generatedCars`集合有什么特别之处吗？（提示：我们的Goroutine是一个匿名函数）。
- en: That's right. We are currying the `generatedCars` collection. Our Goroutine
    covers over the `generatedCars` collection. That's what enables us to reference
    and append to it from the Goroutine, regardless of which core it happens to be
    running in.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。我们正在对`generatedCars`集合进行柯里化。我们的Goroutine覆盖了`generatedCars`集合。这使我们能够从Goroutine中引用并附加到它，而不管它运行在哪个核心上。
- en: We are standing on the shoulders of giants. We're using a Go channel and Goroutines
    to emulate an FP generator and other HOFs. Our code is readable, and it doesn't
    take much code to make it all work.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们站在巨人的肩膀上。我们使用Go通道和Goroutines来模拟FP生成器和其他HOFs。我们的代码可读性强，而且不需要太多的代码就能使其全部工作。
- en: A closer look at currying
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对柯里化的更近距离观察
- en: 'Before we move on, let''s look at the following curried versus non-curried
    code example to improve our understanding of currying:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看一下以下柯里化与非柯里化代码示例，以提高我们对柯里化的理解：
- en: '[PRE94]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: You would immediately see that the curried example takes only one parameter,
    whereas the non-curried example requires two. The idea behind currying is to create
    new, more specific functions from smaller, more general, functions by partially
    applying them. We'll see more of this in [Chapter 8](../Text/Ch07.xhtml), *Functional
    Parameters*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您会立即看到，柯里化示例只需要一个参数，而非柯里化示例需要两个参数。柯里化的想法是通过部分应用来从更小、更一般的函数中创建新的、更具体的函数。我们将在[第8章](../Text/Ch07.xhtml)
    *函数参数*中看到更多内容。
- en: Another take away is the use of a function type. The `numberIs` is a data type
    that is a function that takes an int and returns a bool. That's right. In FP,
    we are not scared of functions. We treat them as a regular old data type. In FP
    everything is data, and data never changes. It only gets passed around, created
    and returned.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个收获是函数类型的使用。`numberIs`是一个数据类型，是一个接受int并返回bool的函数。没错，在FP中，我们不害怕函数。我们将它们视为常规的数据类型。在FP中，一切都是数据，数据永远不会改变。它只是被传递、创建和返回。
- en: 'The value of angle *x* is equal to the length of the (*A*)djacent side divided
    by the length of the (*H*)ypotenuse ([http://www.mathopenref.com/cosine.html](http://www.mathopenref.com/cosine.html)):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 角度*x*的值等于(*A*)邻边的长度除以(*H*)斜边的长度([http://www.mathopenref.com/cosine.html](http://www.mathopenref.com/cosine.html))：
- en: '*cos x = A / H*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*cos x = A / H*'
- en: '![](img/842223a2-7e83-48c9-82da-cbe9f193f131.png)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](img/842223a2-7e83-48c9-82da-cbe9f193f131.png)'
- en: In imperative programming, we are led to believe that functions and data are
    different things. In FP, we see that functions have no side effects. A good FP
    example is the geometric cosine function. For a right-angle triangle, if we pass
    15 for the (*A*)djacent side and 30 for the (*H*)ypotenuse, then we get 0.5 as
    the cosine of angle A. Since we can rely on that fact--pass 15 and 30 and get
    0.5 every time--even with our imperative programming hats on, we know we can put
    those values in a lookup table. Imagine a spreadsheet where row numbers represent
    the A's and the columns represent the H's. The cell at row 15, column 30, would
    have the value 0.5\.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们被引导相信函数和数据是不同的东西。在FP中，我们看到函数没有副作用。一个很好的FP示例是几何余弦函数。对于直角三角形，如果我们将15作为(*A*)邻边和30作为(*H*)斜边传递，那么我们得到角A的余弦值为0.5。由于我们可以依赖这个事实——每次传递15和30都会得到0.5——即使我们戴着命令式编程的帽子，我们也知道我们可以将这些值放入查找表中。想象一下一个电子表格，其中行号代表A，列代表H。在第15行，第30列的单元格将具有值0.5。
- en: See, functions are data! However, we don't always want to store every computed
    value for every possible parameter combination in every use case, just where it
    makes sense to do so.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 看，函数就是数据！然而，我们并不总是想要在每种情况下存储每个可能参数组合的每个计算值，只有在有意义的情况下才这样做。
- en: Imagine the performance of a system where every function call is a table lookup.
    Now imagine our reuse potential, where the evaluation parts of the applications
    are generic. If your mind is still intact, wait until [Chapter 9](../Text/Ch11.xhtml),
    *Category Theory That Applies*, where we will discuss the application of category
    theory and type classes.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，每个函数调用都是一个表查找。现在想象一下我们的重用潜力，应用程序的评估部分是通用的。如果你的头脑还完整，等到[第9章](../Text/Ch11.xhtml)，*适用的范畴论*，我们将讨论范畴论和类型类的应用。
- en: Extending our currying example
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展我们的柯里化示例
- en: 'But wait, there''s more! Let''s add the following, just above `func main()`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！让我们在`func main()`上面添加以下内容：
- en: '[PRE95]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `apply` function is a method bound to a function type, namely `numberIs`.
    Our apply function applies the `numberIs` function to each argument. Each calculated
    value is appended to the newly created array of bools that is then returned to
    the caller.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`函数是绑定到函数类型的方法，即`numberIs`。我们的apply函数将`numberIs`函数应用于每个参数。每个计算出的值都附加到新创建的布尔数组中，然后返回给调用者。'
- en: 'Next, we update `main()` as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`main()`更新如下：
- en: '[PRE96]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Here''s the output of this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的输出：
- en: '[PRE97]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In pure FP, every function is a function of one argument. We can use currying
    in Go to achieve this.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯FP中，每个函数都是一个参数的函数。我们可以使用Go中的柯里化来实现这一点。
- en: Now, back to cars.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到汽车。
- en: Using a WaitGroup variable to manage concurrency
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用WaitGroup变量来管理并发
- en: 'After appending `thisCar` to the `generatedCars` collection, we execute `waitGroup.Done()`.
    This decrements the count of the `WaitGroup` variable. This count corresponds
    to the iterator value we assign to the lower variable, and applies to the `lower
    > upper` expression that is assigned to the done `return` variable:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`thisCar`附加到`generatedCars`集合后，我们执行`waitGroup.Done()`。这会减少`WaitGroup`变量的计数。这个计数对应于我们分配给lower变量的迭代器值，并应用于分配给done
    `return`变量的`lower > upper`表达式：
- en: '[PRE98]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We use the iterator to know how many Goroutines to launch:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用迭代器来知道要启动多少个Goroutines：
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Finishing up the GenerateCars function
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完成GenerateCars函数
- en: 'At the end of our `GenerateCars` function, we execute another anonymous Goroutine.
    The purpose of this Goroutine is to wait for all the previously launched Goroutine
    generators to complete. We use `waitGroup.Wait` to know when the last generator
    was completed. Then, it''s safe to close `carChannel`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`GenerateCars`函数的末尾，我们执行另一个匿名Goroutine。这个Goroutine的目的是等待所有先前启动的Goroutine生成器完成。我们使用`waitGroup.Wait`来知道最后一个生成器何时完成。然后，安全地关闭`carChannel`：
- en: '[PRE100]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `carChannel` will block until it receives a new car; this is a result of
    calling `GetThisCar(carIndex)`. Recall that `WaitGroup.Add(numCarsToGenerate)`
    told `WaitGroup` how many cars we'd process. The `waitGroup.Done()` function counts
    that number down to 0, at which time `waitGroup.Wait()` is executed and `carChannel`
    is closed.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`carChannel`将阻塞，直到接收到新的汽车；这是调用`GetThisCar(carIndex)`的结果。回想一下，`WaitGroup.Add(numCarsToGenerate)`告诉`WaitGroup`我们要处理多少辆汽车。`waitGroup.Done()`函数将该数字减少到0，此时执行`waitGroup.Wait()`，并关闭`carChannel`。'
- en: 'We wait until all our Goroutines have fetched data from the RESTful HTTP server
    before returning the `generatedCars` collection. This is a common pattern in FP:
    we eliminate as much state change in our data transformation operation as possible.
    We wait until all of our data collection processing has completed and then we
    finally return the final result.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回`generatedCars`集合之前，我们等待所有的Goroutines从RESTful HTTP服务器中获取数据。这是FP中的一种常见模式：我们尽可能地消除数据转换操作中的状态更改。我们等到所有的数据收集处理都完成，然后最终返回最终结果。
- en: Our FP work is much like that of an electrician. Electricians turn off the power, hook
    up all the wires in the building, and when everything is in place, they flip the
    power switch and all the lights come on. Data is power. Don't let your data fly
    until the last possible moment.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的FP工作很像电工的工作。电工关闭电源，连接建筑物中的所有电线，当一切就绪时，他们打开电源开关，所有灯都亮了起来。数据就是力量。不要让你的数据飞出去，直到最后一刻。
- en: 'In the `main.go` file, add the following code:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，添加以下代码：
- en: '[PRE101]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The following is its output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的输出：
- en: '[PRE102]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Handling concurrency
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理并发
- en: 'We are managing our `GetThisCar` Goroutines by counting how many we''ve launched,
    and we leverage a `WaitGroup` variable to decrement that count when they complete.
    While it is true that many of our `GetThisCar` Goroutines execute in parallel,
    what''s important is the way we handle their concurrency. Using the next iterator
    and the `waitGroup` variable, we are able to simply and effectively deal with
    their life cycle: starting with each Goroutine, receiving their results and closing
    `carChannel` when our counter indicates all the Goroutines are completed. Ever
    tried managing multiple threads of operation using Java or C++? Notice how we
    don''t have to deal with managing mutexes and hard-to-debug race conditions? The
    ease of concurrency implementation is one of Go''s many strengths.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过计算我们启动了多少个`GetThisCar` Goroutines来管理它们，并利用`WaitGroup`变量在它们完成时递减该计数。虽然我们的许多`GetThisCar`
    Goroutines确实并行执行，但重要的是我们处理它们的并发的方式。使用下一个迭代器和`waitGroup`变量，我们能够简单有效地处理它们的生命周期：从每个Goroutine开始，接收它们的结果，并在我们的计数表明所有Goroutines都完成时关闭`carChannel`。曾经尝试使用Java或C++管理多个操作线程吗？注意我们不必处理管理互斥锁和难以调试的竞争条件？并发实现的便利是Go的许多优势之一。
- en: '**Concurrency**: A property of systems in which several processes are executing
    at the same time and potentially interacting with each other. Concurrency is about
    dealing with lots of things at once.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**：系统的属性，其中多个进程同时执行并可能相互交互。并发是处理许多事情的能力。'
- en: '**Parallelism**: This is a type of computation in which many calculations are
    carried out simultaneously, operating on the principle that large problems can
    often be divided into smaller ones, which are then solved in parallel. Parallelism
    is about doing lots of things at once.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行性**：这是一种计算类型，许多计算同时进行，其原则是大问题通常可以分解为较小的问题，然后并行解决。并行性是同时做很多事情的能力。'
- en: See Rob Pike's epic video, *Concurrency Is Not Parallelism*, at [https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看Rob Pike的史诗级视频，“并发不等于并行”，网址为[https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso)。
- en: The final HOF example
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最终的HOF示例
- en: 'Our final HOF example is a doozy. We generate 14 cars, filter `ByDomestic`,
    map them with an `Upgrade` function, filter them by `ByHasNumber`, and reduce
    them to a collection of JSON strings:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的HOF示例非常棘手。我们生成了14辆汽车，用`ByDomestic`进行筛选，用`Upgrade`函数进行映射，用`ByHasNumber`进行筛选，然后将它们减少为一组JSON字符串：
- en: '[PRE103]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output of this is as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 其输出如下：
- en: '[PRE104]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That's six lines of code. How many lines of code do you think it would take
    to do this using an imperative coding style?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是六行代码。你认为使用命令式编程风格需要多少行代码来完成这个任务？
- en: '"This program is already so bloated a little more bloat won''t hurt." No. Eventually,
    it will. And then it will be too late to fix."'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: “这个程序已经太臃肿了，再多一点臃肿也没关系。” 不，最终会有问题的。然后就来不及修复了。”
- en: '- Rob Pike'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '- Rob Pike'
- en: '"The problem is that adding more bloat is often much easier than integrating
    properly, which requires thought, time, and hard decisions."'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: “问题在于，添加更多的臃肿通常比正确集成要容易得多，后者需要思考、时间和艰难的决定。”
- en: - Roger Peppe
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '- Roger Peppe'
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: FP is a programming style that is declarative. It is more readable and usually requires
    much less code than our imperative or object-oriented implementation options.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: FP是一种声明式的编程风格。它更易读，通常需要比我们的命令式或面向对象的实现选项少得多的代码。
- en: In this chapter, we implemented the `Map`, `Filter`, and `Reduce` high-order
    functions. We studied closures and looked at how currying enables function composition.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了`Map`，`Filter`和`Reduce`高阶函数。我们研究了闭包，并看了看柯里化如何实现函数组合。
- en: Our `Reduce` implementation demonstrated how to use Goroutines and a Go channel
    to perform lazy evaluation. We managed its concurrency using a `WaitGroup` variable
    and some common sense.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Reduce`实现演示了如何使用Goroutines和Go通道执行惰性评估。我们使用`WaitGroup`变量和一些常识来管理其并发性。
- en: In the next chapter, we'll consider the API software design. We'll look at how
    to build composable systems using interfaces and closures to enforce the single
    responsibility principle and the open/close principle.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑API软件设计。我们将看看如何使用接口和闭包构建可组合的系统，以强制执行单一责任原则和开闭原则。
