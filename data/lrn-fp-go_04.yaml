- en: SOLID Design in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的SOLID设计
- en: Ever seen comments such as *If you like design patterns, use Java, not Go*?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经看到过这样的评论吗：*如果你喜欢设计模式，就用Java，不要用Go*？
- en: In this chapter, we will address this common sentiment regarding software design
    patterns and how they fit with developing high-quality Go applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决关于软件设计模式的常见看法，以及它们如何与开发高质量的Go应用程序相适应。
- en: 'Our goal in this chapter is to understand the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解以下主题：
- en: Why many Gophers loath Java
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么许多Gophers讨厌Java
- en: Why Go does not support inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么Go不支持继承
- en: The principles of good software design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好软件设计原则
- en: How to apply the single responsibility principle in Go
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Go中应用单一职责原则
- en: The open/closed principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Duck typing in Go
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的鸭子类型
- en: How to model behavior in Go using interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用接口在Go中建模行为
- en: How to compose software using the interface segregation principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用接口隔离原则来组合软件
- en: Inner type promotion and how to embed interfaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部类型提升以及如何嵌入接口
- en: Why many Gophers loath Java
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么许多Gophers讨厌Java
- en: '*If you like design patterns, use Java, not Go.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你喜欢设计模式，就用Java，不要用Go。*'
- en: Let's think about where this thinking comes from. Java (as well as C++) tends
    to focus on type hierarchies and type taxonomies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考这种思维是从哪里来的。Java（以及C++）倾向于关注类型层次和类型分类。
- en: 'Take the `ObjectRetrievalFailureException` class from the Spring Framework
    for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以Spring Framework中的`ObjectRetrievalFailureException`类为例：
- en: '![](img/44e29e9c-4a08-41d8-813e-d062e604367b.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44e29e9c-4a08-41d8-813e-d062e604367b.png)'
- en: This looks far too complicated and over-abstracted, right?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来太复杂和过于抽象了，对吧？
- en: Unlike Java, Go is designed to be a pragmatic language where we won't get lost
    in infinite levels of inheritance and type hierarchies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，Go被设计为一种务实的语言，我们不会迷失在无限的继承层次和类型层次中。
- en: When we implement a solution in a language that places so much emphasis on a
    type hierarchy, levels of abstractions, and class inheritance, our code refactorings
    tend to be much more time-consuming. It's best to get the design right before
    we begin coding. Leveraging design patterns can save a lot of time when implementing
    Java solutions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一种非常强调类型层次、抽象层次和类继承的语言中实现解决方案时，我们的代码重构往往需要花费更多的时间。最好在开始编码之前就设计好。在实现Java解决方案时，利用设计模式可以节省大量时间。
- en: Inheritance creates a high level of coupling in object-oriented programming.
    In the preceding example, a change in the `DataAccessException` class could cause
    unwanted side effects in every class above it in the hierarchy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在面向对象编程中创建了高耦合。在前面的例子中，`DataAccessException`类的更改可能会导致其上层的每个类中产生意想不到的副作用。
- en: It's easy to see why anyone might think there is no place for design patterns
    in Go.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解为什么有人会认为在Go中没有设计模式的位置。
- en: '"If C++ and Java are about type hierarchies and the taxonomy of types, Go is
    about composition."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果C++和Java关注类型层次和类型分类，那么Go关注组合。"'
- en: '- Rob Pike'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '- Rob Pike'
- en: However, with careful use of abstraction, software design patterns can be entirely
    compatible with Go's composable simple design philosophy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过谨慎使用抽象，软件设计模式可以完全与Go的可组合简单设计理念兼容。
- en: More reasons for loathing Java
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨厌Java的更多原因
- en: 'Consider the following table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表格：
- en: '|  | **Java** | **Golang** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  | **Java** | **Golang** |'
- en: '| **Language specification** (PDF) | 788 pages ([https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf](https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf))
    | 89 pages ([https://golang.org/ref/spec](https://golang.org/ref/spec)) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **语言规范** (PDF) | 788页 ([https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf](https://docs.oracle.com/javase/specs/jls/se8/jls8.pdf))
    | 89页 ([https://golang.org/ref/spec](https://golang.org/ref/spec)) |'
- en: '| **Java JDK versus Go SDK** (compressed) | 279.59 MB ([http://jdk.java.net/9/](http://jdk.java.net/9/))
    | 13 MB |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **Java JDK与Go SDK** (压缩) | 279.59 MB ([http://jdk.java.net/9/](http://jdk.java.net/9/))
    | 13 MB |'
- en: '| **Concurrency implementation complexity** | Difficult | Easy |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **并发实现复杂性** | 困难 | 简单 |'
- en: 'The following is a diagram that compares the Java and Go technology stacks
    from a high level:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个比较Java和Go技术栈的高层次图表：
- en: '![](img/fe227eef-7ff6-4f60-8840-4d1ac45ce65e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe227eef-7ff6-4f60-8840-4d1ac45ce65e.png)'
- en: The Java/JVM alternative has a much bigger footprint; The JVM does more (some
    of which your application will use) and requires more RAM. Furthermore, since
    there is more raw source code to the Java/JVM solution than Go, that means that
    there is a larger attack surface for hackers to attack. Performance? It takes
    time for the JIT compiler to convert your application's source code to executable
    binary code than Go, which is natively compiled.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java/JVM的替代方案占用的空间更大；JVM做了更多的事情（其中一些是你的应用程序会使用的），并且需要更多的RAM。此外，由于Java/JVM解决方案的原始源代码比Go更多，这意味着对黑客进行攻击的攻击面更大。性能？JIT编译器将应用程序的源代码转换为可执行二进制代码比Go需要更多的时间，因为Go是本地编译的。
- en: Go is smaller and simpler. Java was created for profit and has been aggressively
    marketed. Go is not marketed. There is a streamlined process for proposing changes
    to the Go language. See "How to Propose Changes To Go" in the Appendix. (I have
    found no such process for proposing changes to Java or the JVM, but I can only
    image that there would be much more time and effort involved).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go更小更简单。Java是为了盈利而创建的，并且一直在积极营销。Go没有市场营销。对于提出对Go语言的更改有一个简化的流程。请参见附录中的"How to
    Propose Changes To Go"。（我没有找到提出对Java或JVM的更改的流程，但我只能想象这需要更多的时间和精力）。
- en: Given the preceding comparisons of Go v. Java it seems to boil down to Simplicity
    v. Complexity. Gophers tend to prefer simplicity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前面对Go和Java的比较，似乎可以归结为简单与复杂。Gophers倾向于更喜欢简单。
- en: '"Less is exponentially more."'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"少即是多。"'
- en: - Rob Pike
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: - Rob Pike
- en: Digging deeper into error handling
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入挖掘错误处理
- en: In Java, when an exception occurs in a method, the process of creating the exception
    object and handing it over to the runtime environment is called throwing an exception.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，当方法中发生异常时，创建异常对象并将其交给运行时环境的过程称为抛出异常。
- en: The normal flow of the program halts when this happens, and JRE tries to find
    a handler in the call stack that can process the raised exception.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，程序的正常流程会停止，JRE会尝试在调用堆栈中找到一个可以处理引发异常的处理程序。
- en: The exception object contains a lot of debugging information, such as the line
    number where the exception occurred, type of exception, the method hierarchy,
    call stack, and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 异常对象包含了大量的调试信息，比如异常发生的行号、异常类型、方法层次结构、调用堆栈等等。
- en: Dozens of common exception handling antipatterns exist in Java largely due to
    the design and misunderstanding of proper use of Java's type hierarchy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对Java类型层次结构的设计和误解，Java中存在着许多常见的异常处理反模式。
- en: '"Don’t just check errors, handle them gracefully."'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '"不要只是检查错误，要优雅地处理它们。"'
- en: - Dave Cheney
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '- Dave Cheney'
- en: 'Rather than asserting the error is a specific type or value and passing up
    the line, we can assert that the error implements a particular behavior:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与其断言错误是特定类型或值并传递到上一行，我们可以断言错误实现了特定的行为：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the `IsRetryable` error occurs, then the caller would know they can retry
    the operation that generated the error. The caller does not need to import the
    library that implements the thrown error and attempt to understand the intricacies
    of its type hierarchy to handle the error properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生`IsRetryable`错误，那么调用者会知道他们可以重试生成错误的操作。调用者不需要导入实现抛出错误的库，并尝试理解其类型层次结构的复杂性来正确处理错误。
- en: 'The `github.com/pkg/errors` package allows you to wrap errors with context so
    that later you can recover the cause like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/pkg/errors`包允许您使用上下文包装错误，以便以后可以像这样恢复原因：'
- en: '`    func IsRetryable(err error) bool {`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`func IsRetryable(err error) bool {`'
- en: '`        eb, ok := errors.Cause(err).(errorBehavior)`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`eb, ok := errors.Cause(err).(errorBehavior)`'
- en: '`        return ok && eb.Retryable()`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`return ok && eb.Retryable()`'
- en: '`    }`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '} '
- en: Once the error value has been inspected, it should be handled once. Repackaging
    the error and throwing it up for another handler to deal with is not considered
    a best practice in Go.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检查了错误值，就应该处理一次。在Go中，重新打包错误并将其抛出以供另一个处理程序处理并不被认为是最佳实践。
- en: A conversation - Java developer, idiomatic Go developer, FP developer
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一段对话- Java开发者，惯用Go开发者，FP开发者
- en: 'Java developer: I hate having to write `if err != nil` everywhere.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发者：我讨厌到处写`if err != nil`。
- en: 'Go developer: Get used to it.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go开发者：习惯就好了。
- en: 'Java developer: Why not just throw an exception and let a handler up the call
    chain deal with it?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发者：为什么不直接抛出异常，让调用链上的处理程序处理呢？
- en: 'Go developer: All good programmers are lazy and that''s extra typing.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Go开发者：所有优秀的程序员都是懒惰的，那是额外的打字。
- en: '| **Developer** | **Conversation** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **开发者** | **对话** |'
- en: '| Java | I hate having to write `if err != nil` everywhere |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Java | 我讨厌到处写`if err != nil`。|'
- en: '| Go | Get used to it. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Go | 习惯就好了。|'
- en: '| Java | Why not just throw an exception and let a handler up the call chain
    deal with it? That''s less typing and all good programmers are lazy, right? |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| Java | 为什么不直接抛出异常，让调用链上的处理程序处理呢？这样打字更少，所有优秀的程序员都是懒惰的，对吧？|'
- en: '| Go | Errors should always be handled immediately.What if our `buggyCode`
    function returns an error yet we continue processing? Can you see how fragile
    and wrong that is?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| Go | 错误应该立即处理。如果我们的`buggyCode`函数返回错误，但我们继续处理会怎样？你能看出这是多么脆弱和错误吗？'
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| FP | What bothers me the most about throwing a Java exception is that when
    we throw an error up for another function to deal with we have just created a
    side effect. Our function is not pure. We have introduce indeterminism into our
    application. Since any caller in the call stack can handle an exception, how do
    we know which handler handles it? Since we wrote the code closest to the error,
    we should know better than any other developer what happened and how best to deal
    with it. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| FP | 关于抛出Java异常，最让我困扰的是，当我们将错误抛出给另一个函数处理时，我们刚刚创建了一个副作用。我们的函数不是纯的。我们在应用程序中引入了不确定性。由于调用堆栈中的任何调用者都可以处理异常，我们怎么知道哪个处理程序处理它？由于我们编写了最接近错误的代码，我们应该比任何其他开发人员更了解发生了什么以及如何最好地处理它。|'
- en: '| Java | Okay. I get it, but I am not only lazy but I all that extra if `err
    != nil`  code looks like scaffolding that litters my code and makes me want to
    barf. Let me clarify my feelings with a couple of photos. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Java | 好的。我明白了，但我不仅懒惰，而且所有额外的`if err != nil`代码看起来像是我代码中的脚手架，让我想要呕吐。让我用几张照片澄清我的感受。|'
- en: 'Our code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码：
- en: '![](img/4df41f98-3e74-491e-9dc9-156c5f869ff5.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4df41f98-3e74-491e-9dc9-156c5f869ff5.png)'
- en: '| Java | You can see the difference, right? |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Java | 你能看出区别吗？|'
- en: '| Go | Touche! But you need to realize I am mainly interested in programming
    backend systems where correctness trumps pretty. You can take your pretty J2EE
    enterprise business applications and wrap them with as many exception handlers
    as you like. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Go | 理解了！但你需要意识到，我主要对编写后端系统感兴趣，正确性胜过美观。你可以拿你漂亮的J2EE企业业务应用程序，然后用尽可能多的异常处理程序包装它们。|'
- en: '| Java | Seriously? You say you like simplicity, but more code looks more complex
    to me. That''s more code to maintain. That means that instead of having the option
    to handle all of my error handling in one place I have to insert little snippets
    of error handling code all throughout my application? Shit! I absolutely love
    Go''s fast compiles times, Go''s tiny footprint, the ease of programming concurrent
    applications, and so on. I am so frustrated. Is there no better error handling
    solution in Go? |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Java | 真的吗？你说你喜欢简单，但对我来说，更多的代码看起来更复杂。这意味着更多的代码需要维护。这意味着，我不能在一个地方处理所有的错误处理，而是必须在整个应用程序中插入一小段错误处理代码？该死！我非常喜欢Go的快速编译时间，Go的小占用空间，编写并发应用程序的简易性等等。我非常沮丧。Go中没有更好的错误处理解决方案吗？|'
- en: '| FP | Glad you asked. Depending on what you want to accomplish, there is a
    better way. This way will not only allow you to handle all your errors in one
    place, but will also do so with the determinism of pure FP. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| FP | 很高兴你问。根据你想要实现什么，有更好的方法。这种方式不仅可以让您在一个地方处理所有错误，而且还可以以纯FP的确定性处理。|'
- en: '| Go | B.S. I will stop reading this book now because there is no way this
    will work. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Go | 胡说八道。我现在会停止阅读这本书，因为这根本行不通。 |'
- en: '| Java | Yeah! What''s the catch? |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Java | 是的！有什么陷阱吗？ |'
- en: '| FP | The solution requires thought, time, and hard decisions, but just like
    learning to ride a bike. Once you get up and running you''ll keep doing it. It''s
    fun and gets you where you want to go more efficiently and it''s good for you.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| FP | 该解决方案需要思考、时间和艰难的决定，但就像学骑自行车一样。一旦你上手了，你就会继续做。这很有趣，可以更有效地带你到达目的地，对你有好处。
    |'
- en: '| Java | What''s it called? |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Java | 它叫什么？ |'
- en: '| FP | The Lexical Workflow solution |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| FP | 词法工作流解决方案 |'
- en: '| Go | You caught me. I''m still reading. Just long enough to say, That''s
    a ridiculous claim and the name is even more so. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Go | 你抓住我了。我还在阅读。只是足够长的时间来说，这是一个荒谬的说法，名字更是如此。 |'
- en: '| FP | I know it sounds like magic and it sort of is. It''s built on a things
    will even more ridiculous names: the Y-Combinator and  Monads. But we have a way
    to go before we discuss the details. It will take thought and time and decision
    making skills.  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| FP | 我知道这听起来像魔术，而且确实是。它建立在更荒谬的名字上：Y-Combinator和Monad。但在讨论细节之前，我们还有很长的路要走。这需要思考、时间和决策能力。
    |'
- en: '| Java | What''s there to decide? If it works, I''ll use it. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Java | 有什么需要决定的吗？如果它有效，我会使用它。 |'
- en: '| FP | The best use case for Lexical Workflow Solution is where you have data
    you want to transform. Do you have any workflows where you input data, transform
    it in some way and then produce an output? This covers a lot of business use case
    scenarios and some system level ones, too. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| FP | 词法工作流解决方案的最佳用例是您有要转换的数据。您是否有任何工作流程，其中您输入数据，以某种方式进行转换，然后产生输出？这涵盖了许多业务用例场景，也包括一些系统级别的用例。
    |'
- en: '| Java | Sounds good. What does it do and what does it not do? |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Java | 听起来不错。它是做什么的，又不是做什么的？ |'
- en: '| FP | It handles your typical workflow use case where when you encounter an
    error, that error is handled and no further processing occurs in that workflow.
    If you want to keep processing even with errors, then we''d be better off using
    applicative functors. If Go supported TCO, then that would open up the door to
    many more FP possibilities. For now, we need to keep it real (and not worry about
    stack overflows or performance implications of using recursion). If/when Go does
    support TCO then us FP coders will be able to unleash a plethora of robust, expressive
    and performant FP solutions.  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| FP | 它处理您遇到错误时的典型工作流用例，该错误被处理并且在该工作流程中不会发生进一步处理。如果您希望即使出现错误也要继续处理，那么最好使用applicative
    functors。如果Go支持TCO，那将为许多FP可能性打开大门。目前，我们需要保持现实（不用担心递归的堆栈溢出或性能影响）。如果/当Go支持TCO时，我们FP编码人员将能够释放大量强大、富有表现力和高性能的FP解决方案。'
- en: Software design methodology
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件设计方法论
- en: 'Software design is where we:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计是我们：
- en: Gather requirements
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集需求
- en: Create specifications from requirements
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从需求创建规格说明
- en: Implement a solution based on the specifications
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据规格说明实施解决方案
- en: Review results and iterate to improve the solution
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查结果并迭代改进解决方案
- en: Traditional waterfall development depends on a perfect understanding of the
    product requirements at the outset and minimal errors being executed in each phase. Source: [http://scrumreferencecard.com/scrum-reference-card/](http://scrumreferencecard.com/scrum-reference-card/)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的瀑布式开发依赖于对产品需求的完美理解以及在每个阶段执行最小的错误。来源：[http://scrumreferencecard.com/scrum-reference-card/](http://scrumreferencecard.com/scrum-reference-card/)
- en: '![](img/97dc5d5b-3f70-4b52-9fe5-bd9ca4693237.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97dc5d5b-3f70-4b52-9fe5-bd9ca4693237.png)'
- en: 'Scrum blends all the development activities into each iteration, adapting to
    discovered realities at fixed intervals:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum将所有开发活动融合到每个迭代中，以适应在固定间隔内发现的现实情况：
- en: '![](img/caaf5d0e-29c2-4da5-a658-b3f33f3fd88c.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/caaf5d0e-29c2-4da5-a658-b3f33f3fd88c.png)'
- en: Source: [http://scrumreferencecard.com/scrum-reference-card/](http://scrumreferencecard.com/scrum-reference-card/)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://scrumreferencecard.com/scrum-reference-card/](http://scrumreferencecard.com/scrum-reference-card/)
- en: In the process of creating specifications, artifacts such as **Unified Markup
    Language** (**UML**) diagrams are often created to help us think about the problem
    and craft a viable solution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建规格说明的过程中，通常会创建诸如**统一标记语言**（**UML**）图表之类的工件，以帮助我们思考问题并制定可行的解决方案。
- en: Analysis is where we model real-world operations, breaking apart pieces into
    components. Design is where we craft a software solution based on the analysis
    work, our IT environment, and the frameworks/technology stacks at our disposal.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 分析是我们对现实世界操作进行建模，将部分分解为组件。设计是我们根据分析工作、我们的IT环境以及我们可以使用的框架/技术堆栈来制定软件解决方案的地方。
- en: We abstract away all the concerns that are not pertinent. So, during analysis
    and design, we take away and break apart our problem into components that do simple
    things.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们抽象出所有与问题无关的问题。因此，在分析和设计过程中，我们将问题分解成简单的组件。
- en: Implementation is when we put those simple things back together again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实施是当我们将这些简单的事情重新组合在一起时。
- en: Good design
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 良好的设计
- en: Good design is about saving money in the long run.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的设计在长期节省资金。
- en: If our project is small and the value of our time to market is high, then we
    can skip the design process. Otherwise, we should put effort into having a proper
    software design. This is a universal truth, regardless of the technology (Java,
    Go, and so on).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的项目很小，上市时间的价值很高，那么我们可以跳过设计过程。否则，我们应该努力进行适当的软件设计。这是一个普遍的真理，无论技术如何（Java、Go等）。
- en: Bad design
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 糟糕的设计
- en: 'If our application architecture diagram looks something like the following
    one, we have failed to properly design our application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用架构图看起来像下面的图表，那么我们设计应用程序失败了：
- en: '![](img/a6e832c2-95c7-4d49-a93f-c7296b14ca4e.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6e832c2-95c7-4d49-a93f-c7296b14ca4e.png)'
- en: Simplicity is not easy, but it is worth striving for.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 简单并不容易，但值得努力。
- en: The more we add features to our already complex system, the more complex it
    becomes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给已经复杂的系统添加功能，它就会变得更加复杂。
- en: In a system like this, we cannot consider one thing at a time; we must think
    of everything together and all the possible weird interactions that may break
    our system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，我们不能一次只考虑一件事；我们必须一起考虑所有可能破坏我们系统的奇怪交互。
- en: Good versus bad design over time
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随着时间的推移，好的设计与坏的设计
- en: The following diagram depicts the value of good design over time. As with most
    graphs, the *x* axis depicts the progression of time. The higher we go on the
    *y* axis, the more functionality and feature rich our application becomes. Below
    the **design payoff line**, applications with no design or poor design can quickly
    produce results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了随着时间的推移，良好设计的价值。与大多数图表一样，*x*轴表示时间的推移。我们在*y*轴上走得越高，我们的应用程序的功能和特性就越丰富。在**设计回报线**以下，没有设计或设计不良的应用程序可以迅速产生结果。
- en: 'However, there comes a point at which lack of design makes the application
    brittle, non-extensible, and difficult to understand:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缺乏设计会使应用程序变得脆弱、不可扩展且难以理解：
- en: '![](img/0fbf42cb-2919-46c8-afbe-022bf32f944c.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fbf42cb-2919-46c8-afbe-022bf32f944c.png)'
- en: The application that has been properly designed can be extended easily and becomes
    much more maintainable in the long run.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 经过适当设计的应用程序可以轻松扩展，并且从长远来看更易于维护。
- en: '"Over 90% of software cost happens during maintenance phase."'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “超过90%的软件成本发生在维护阶段。”
- en: - Fred Brooks, Mythical Man Month
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '- 弗雷德·布鲁克斯，《神话般的程序员月度》'
- en: SOLID design principles
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: The SOLID design principles of **Object-Oriented Programming** (**OOP**) apply
    to designing Go software solutions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）的SOLID设计原则适用于设计Go软件解决方案。'
- en: Single responsibility principle
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'Single responsibility principle says, *Do One Thing and Do It Well*. We see
    the SRP at play in the Go standard libraries. Here''re a few examples:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则说，*只做一件事，并且做得很好*。我们在Go标准库中看到了SRP的运作。以下是一些例子：
- en: '![](img/9de5a3cb-267f-4651-854b-ec515262c8d6.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9de5a3cb-267f-4651-854b-ec515262c8d6.png)'
- en: If a pull request enhances the `aes/crypto` package, would you expect that code
    merge to affect the functionality of the `database/sql/driver` package (or any
    package)? No. Of course not. Each package is clearly name spaced and highly cohesive;
    they perform specific tasks and do not cross over into other concerns.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个拉取请求增强了`aes/crypto`包，你会期望那段代码合并会影响`database/sql/driver`包（或任何包）的功能吗？不会。当然不会。每个包都有明确定义的名称空间和高度内聚；它们执行特定的任务，不会涉及其他问题。
- en: '"A class should have one, and only one, reason to change."'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该只有一个原因来进行更改。”
- en: – Robert C Martin
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '- 罗伯特C·马丁'
- en: When Mr. Martin said that a class should have only one reason to change, it's
    obvious that he was talking about OOP design, but the same principle applies to
    our Go application. Should the tax calculation update affect the user interface
    or layout of any reports, other than showing a different amount? No. Why? Because
    one is cosmetic in nature and the other is not. Those are two separate responsibilities
    that should be handled by different, loosely coupled classes/modules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当马丁先生说一个类只应该有一个更改原因时，显然他是在谈论OOP设计，但同样的原则也适用于我们的Go应用程序。税收计算更新是否会影响用户界面或任何报告的布局，而不仅仅是显示不同的金额？不会。为什么？因为一个是化妆品的性质，另一个不是。这是两个应该由不同的、松散耦合的类/模块处理的不同责任。
- en: Our classes/modules should be highly cohesive, performing as specific a role
    as possible. Code that has a single responsibility can handle the changing requirements
    better without adversely affecting other parts of our application. If we have
    a request to change our class/module and since it does only one thing then the
    reason for the change can only be related to its one responsibility.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类/模块应该高度内聚，尽可能扮演特定的角色。具有单一职责的代码可以更好地处理变化的需求，而不会对应用程序的其他部分产生不利影响。如果我们有一个更改类/模块的请求，由于它只做一件事情，那么更改的原因只能与它的一个责任有关。
- en: 'Application of the SRP will drive our design towards smaller and smaller interfaces.
    Eventually, we will arrive at the ultimate interface. The interface with one method.
    For example, in [Chapter 5](../Text/Ch05.xhtml), *Adding Functionality with Decoration*, we''ll
    look at Go’s complimentary Reader and Writer interfaces:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: SRP的应用将使我们的设计朝着越来越小的接口发展。最终，我们将到达最终接口。只有一个方法的接口。例如，在[第5章](../Text/Ch05.xhtml)中，*使用装饰添加功能*，我们将看到Go的互补Reader和Writer接口：
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What the SRP means to FP is aligned with the Unix philosophy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: SRP对FP的意义与Unix哲学一致。
- en: '"Although that philosophy can''t be written down in a single sentence, at its
    heart is the idea that the power of a system comes more from the relationships
    among programs than from the programs themselves. Many UNIX programs do quite
    trivial things in isolation, but, combined with other programs, become general
    and useful tools."'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “尽管这种哲学无法用一句话写出来，但它的核心思想是系统的力量更多来自程序之间的关系，而不是程序本身。许多UNIX程序在孤立状态下做的事情相当琐碎，但与其他程序结合起来，成为通用且有用的工具。”
- en: '- Rob Pike'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '- 罗布·派克'
- en: In lambda calculus, each function has exactly one parameter. It may look like
    our pure function accepts multiple parameters, but it's actually just currying
    the parameters. Our function takes the first argument in the list and returns
    a function which takes the rest of the arguments; It continues to process each
    argument until they are all consumed. Function composition works when every function
    accepts only one parameter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在λ演算中，每个函数都只有一个参数。它可能看起来像我们的纯函数接受多个参数，但实际上它只是对参数进行柯里化。我们的函数接受列表中的第一个参数，并返回一个接受其余参数的函数；它继续处理每个参数，直到它们全部被消耗。函数组合仅在每个函数只接受一个参数时有效。
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That was pseudo code for what happens when we curry. It converts a two parameter
    call into a one parameter call. Currying stores data (the number 1) and an operation
    (the addition operator) for use later. How is that like an object in OOP?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们进行柯里化时发生的伪代码。它将一个两个参数的调用转换为一个参数的调用。柯里化存储数据（数字1）和操作（加法运算符）以供以后使用。这与OOP中的对象有什么相似之处？
- en: Function composition
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数组合
- en: 'Function composition is where we combine two smaller functions to create a
    new function that accomplishes the same goal as the two smaller ones. Both ways
    get us from an `a` to `c`. Below, `f[1]` accepts an `a` and returns a `b`. `f[2]`
    accepts a `b` and returns a `c`. We can compose/combine those two functions and
    get a single function that accepts an `a` and returns a `c`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是将两个较小的函数组合成一个新函数的过程，以实现与两个较小函数相同目标的新函数。两种方式都可以将我们从`a`到`c`。下面，`f[1]`接受`a`并返回`b`。`f[2]`接受`b`并返回`c`。我们可以组合/合并这两个函数，并得到一个接受`a`并返回`c`的单个函数：
- en: '![](img/bc4b36c4-3ccb-48de-9ded-e28cabbe4bea.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc4b36c4-3ccb-48de-9ded-e28cabbe4bea.png)'
- en: Function composition is the cornerstone to pure FP; It's what allows us to build
    larger abstractions out of smaller ones.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是纯FP的基石；它允许我们从较小的抽象中构建更大的抽象。
- en: Open/closed principle
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: 'Software should be open for extension but closed for modification. Embedding
    fields in a struct allows us to extend one type with another. The object (`CarWithSpare`)
    that embedded the other (`Car`) has access to its fields and methods. The `CarWithSpare`
    object can call `Car` methods, but cannot modify the `Car` object''s methods.
    Therefore, Go''s types, while being *open for extension*, are *closed for modification*.
    Let''s look at an example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应该对扩展开放，但对修改关闭。在结构体中嵌入字段允许我们用另一个类型扩展一个类型。嵌入其他类型（`Car`）的对象（`CarWithSpare`）可以访问其字段和方法。`CarWithSpare`对象可以调用`Car`方法，但不能修改`Car`对象的方法。因此，Go的类型虽然是*对扩展开放*，但是*对修改关闭*。让我们看一个例子：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We defined our `Car` type and two methods, `Tires` and `PrintInfo`. Next, we''ll
    define our `CarWithSpare` type and embed the `Car` type as an unnamed field:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的`Car`类型和两种方法，`Tires`和`PrintInfo`。接下来，我们将定义我们的`CarWithSpare`类型，并将`Car`类型作为未命名字段嵌入其中：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our `main.go` file, we create a Honda Accord and call its `PrintInfo` method.
    As expected it returns `4` tires.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main.go`文件中，我们创建了一辆本田雅阁，并调用了它的`PrintInfo`方法。预期返回`4`个轮胎。
- en: Next, we create a Toyota Highlander, but when we print its info, it prints `4`
    tires instead of `5`. Why?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一辆丰田高地人，但当我们打印它的信息时，它打印出`4`个轮胎，而不是`5`。为什么？
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's because `PrintInfo` is a method of `Car`, but since `CarWithSpare` is
    missing that method, when we call `highlander.PrintInfo` we're actually executing
    `Car`'s method (not `CarWithSpare`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`PrintInfo`是`Car`的一个方法，但由于`CarWithSpare`缺少该方法，当我们调用`highlander.PrintInfo`时，实际上执行的是`Car`的方法（而不是`CarWithSpare`）。
- en: In order to print the actual number of tires our highlander has, we must manually
    delegate the call by executing `highlander.Tires` directly from within our `fmt.Printf`
    statement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印出我们的高地人实际的轮胎数量，我们必须通过在`fmt.Printf`语句中直接执行`highlander.Tires`来手动委托调用。
- en: 'Do we have other options? Yes. We can override the `PrintInfo` method. In other
    words, we can define a `PrintInfo` method for our `CarWithSpare` as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有其他选择吗？有。我们可以覆盖`PrintInfo`方法。换句话说，我们可以为我们的`CarWithSpare`定义一个`PrintInfo`方法，如下所示：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What if we call `accord.PrintInfo()` again? We get the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次调用`accord.PrintInfo()`会发生什么？我们会得到以下输出：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, Go allows us to:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Go允许我们：
- en: implicitly call an embedded object's method (if not defined)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式调用嵌入对象的方法（如果未定义）
- en: manually delegate to call our object's method
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动委托调用我们对象的方法
- en: override an embedded object's method
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖嵌入对象的方法
- en: What about method overloading?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载呢？
- en: 'Not allowed. If we were to attempt to create another `PrintInfo` method with
    a different argument signature, Go would throw a compiler error:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许。如果我们尝试创建另一个具有不同参数签名的`PrintInfo`方法，Go将抛出编译器错误：
- en: '![](img/c69cfca1-25fd-4055-91dd-7b326f92724b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c69cfca1-25fd-4055-91dd-7b326f92724b.png)'
- en: Using the decorator pattern in the next chapter, we'll see how we can extend
    functionality without modifying the existing code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中使用装饰器模式，我们将看到如何在不修改现有代码的情况下扩展功能。
- en: Open / close principle in functional programming
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数式编程中的开放/封闭原则
- en: Similar to our preceding Go example where we added a new method (`PrintInfo`)
    to our base type (`Car`), pure functional programming languages also add new functions
    over existing data types without having to recompile existing code and while retaining
    static type safety.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的Go示例类似，在基本类型（`Car`）中添加了一个新方法（`PrintInfo`），纯函数式编程语言也可以在不重新编译现有代码的情况下向现有数据类型添加新函数，并保持静态类型安全性。
- en: The *expression problem* also known as the *extensibility problem* addresses
    a software language's ability to add new methods and types to a program in a type
    safe manner. For details, see **Feature Oriented Software Development** (**FOSD**)
    Program Cubes where a base program (in a family of related programs called a **software
    product line**) ([http://softwareproductlines.com/](http://softwareproductlines.com/)) 
    is incrementally augmented with features to produce a complex program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式问题*，也称为*可扩展性问题*，解决了软件语言能够以类型安全的方式向程序添加新方法和类型的能力。有关详细信息，请参见**特征导向软件开发**（**FOSD**）程序立方体，其中基本程序（在称为**软件产品线**的相关程序系列中）（[http://softwareproductlines.com/](http://softwareproductlines.com/)）逐步增加功能，以生成复杂程序。'
- en: 'The following diagram shows how programs can be built by composing models from
    features and then transforming those models into executables:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了如何通过组合特性中的模型，然后将这些模型转换为可执行文件来构建程序：
- en: '![](img/bce0ef89-a861-4daf-b06f-d0e8e97fe10d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bce0ef89-a861-4daf-b06f-d0e8e97fe10d.png)'
- en: The FOSD methodology advocates that complex systems can be built by adding features
    incrementally where the domain models are functions and constants and the programs,
    which are represented as expressions, can be generated to perform specific tasks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: FOSD方法论主张，复杂系统可以通过逐步添加特性来构建，其中领域模型是函数和常量，程序则表示为表达式，可以生成执行特定任务的程序。
- en: FantasyLand JavaScript specification
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FantasyLand JavaScript规范
- en: 'The `FantasyLand` project specifies interoperability of common algebraic structures:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`FantasyLand`项目规定了常见代数结构的互操作性：'
- en: '![](img/cbf62a17-f972-4807-9f34-e4d2be56fee9.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbf62a17-f972-4807-9f34-e4d2be56fee9.png)'
- en: Each data type in the hierarchical diagram is called an algebraic data type
    because each consists of algebra, that is, a set of values, a set of operators
    that it is closed under, and the rules it must obey.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 层次图中的每个数据类型都称为代数数据类型，因为每个都由代数组成，即一组值、一组它所闭合的运算符以及它必须遵守的规则。
- en: Let's take a simple example, the Setoid.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子，Setoid。
- en: Setoid algebra
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Setoid代数
- en: 'The following are the Setoid rules:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Setoid的规则：
- en: '| **Name of rule** | **Description** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **规则名称** | **描述** |'
- en: '| Reflexivity | `a.equals(a) === true ` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 自反性 | `a.equals(a) === true` |'
- en: '| Symmetry | `a.equals(b) === b.equals(a) ` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 对称性 | `a.equals(b) === b.equals(a)` |'
- en: '| Transitivity | if `a.equals(b)` and `b.equals(c)`, then `a.equals(c)` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 传递性 | 如果`a.equals(b)`和`b.equals(c)`，那么`a.equals(c)` |'
- en: '|  | If `b` is not the same `Ord`, behavior of `lte` is unspecified (returning
    false is recommended).`lte` must return a Boolean (`true` or `false`). |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  | 如果`b`不是相同的`Ord`，`lte`的行为是未指定的（建议返回false）。`lte`必须返回一个布尔值（`true`或`false`）。'
- en: The values used in the rules are `a`, `b`, and `c`. A value which has an `Ord`
    must provide an `lte` method. The equals method is this algebra's operator and
    it takes one argument.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 规则中使用的值是`a`、`b`和`c`。具有`Ord`的值必须提供一个`lte`方法。equals方法是这个代数的运算符，它接受一个参数。
- en: That's it. That's all there is to it!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。就是这么简单！
- en: Ord algebra
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Ord代数
- en: 'Here''re the `Ord` rules:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Ord`的规则：
- en: '| **Name of rule** | **Description** |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **规则名称** | **描述** |'
- en: '| Totality | `a.lte(b)` or `b.lte(a)` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 全面性 | `a.lte(b)`或`b.lte(a)` |'
- en: '| Anti-symmetry | If `a.lte(b)` and `b.lte(a)`, then `a.equals(b)` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 反对称性 | 如果`a.lte(b)`和`b.lte(a)`，那么`a.equals(b)` |'
- en: '| Transitivity | If `a.lte(b)` and `b.lte(c)`, then `a.lte(c)` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 传递性 | 如果`a.lte(b)`和`b.lte(c)`，那么`a.lte(c)` |'
- en: '|  | `b` must be a value of the same `Ord` as `a`. If `b` is not the same Setoid,
    then the behavior of equals is unspecified (returning false is recommended). The
    `equals` variable must return a Boolean (`true` or `false`). |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  | `b`必须是与`a`相同的`Ord`的值。如果`b`不是相同的Setoid，则equals的行为是未指定的（建议返回false）。`equals`变量必须返回一个布尔值（`true`或`false`）。'
- en: The values used in the rules are `a`, `b` and `c`. A value which has a Setoid
    must provide an `lte` method. The `lte` method is this algebra's operator and
    it takes one argument.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 规则中使用的值是`a`、`b`和`c`。具有Setoid的值必须提供一个`lte`方法。`lte`方法是这个代数的运算符，它接受一个参数。
- en: From the preceding diagram, we see that an `Ord` is a Setoid, so the `Ord` has
    an `Equals` operator and the `Ord` must obey the same rules that a Setoid does,
    as well as its own rules.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以看到`Ord`是一个Setoid，所以`Ord`有一个`Equals`运算符，`Ord`必须遵守Setoid的规则，以及它自己的规则。
- en: Later in our book, we'll explore Haskell's type class hierarchy and look at
    the Functor, Monoid, and Monad algebras.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的书中，我们将探讨Haskell的类型类层次结构，并研究Functor、Monoid和Monad代数。
- en: The expression problem
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表达式问题
- en: 'Different languages solve the expression problem in various ways:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言以不同的方式解决表达式问题：
- en: Open classes
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放类
- en: Multimethods
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多方法
- en: Coproducts of functors
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子的余积
- en: Type classes
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类
- en: Object algebras
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象代数
- en: The problem they solve is the same as what we looked at with our `CarWithSpare`
    example; It's all about how to add new functions over existing data types without
    having to recompile existing code and while retaining static type safety.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它们解决的问题与我们在`CarWithSpare`示例中看到的问题相同；它关于如何在不必重新编译现有代码的情况下对现有数据类型添加新函数，并保持静态类型安全。
- en: Go has rudimentary support for the expression problem. Type classes, object
    algebras, and so on. are not part of Go's standard library, but there's nothing
    stopping us from building any of the aforementioned solutions. Here's a great
    start: [https://github.com/SimonRichardson/wishful](https://github.com/SimonRichardson/wishful).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Go对表达式问题有基本的支持。类型类、对象代数等不是Go标准库的一部分，但我们可以构建任何上述解决方案。这是一个很好的开始：[https://github.com/SimonRichardson/wishful](https://github.com/SimonRichardson/wishful)。
- en: Liskov substitution principle
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: In OOP terms, the *Liskov Substitution Principle* says that objects of the same
    type or subtype should be substituted and can be replaced by the other, without
    affecting the caller. In other words, when we implement an interface, our class
    should implement all the methods defined in the interface and satisfy all interface
    requirements. And in even fewer words, *satisfy** interface contracts*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 用面向对象的术语来说，*Liskov替换原则*表示相同类型或子类型的对象应该可以被替换，而不影响调用者。换句话说，当我们实现一个接口时，我们的类应该实现接口中定义的所有方法，并满足所有接口要求。简而言之，*满足接口契约*。
- en: The compiler will enforce that our methods have the correct signatures. The
    LSP goes a bit further and demands that our implementation should also have the
    same invariant, postconditions, and other properties stated or implied by the
    documentation of the superclass or interface.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将强制执行我们的方法具有正确的签名。LSP更进一步要求我们的实现也应该具有与超类或接口的文档中陈述或暗示的相同的不变量、后置条件和其他属性。
- en: This OOP method stinks
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 这个面向对象的方法很糟糕
- en: 'This is what a method contract looks like in the OOP world:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向对象编程世界中方法契约的样子：
- en: '![](img/c5b55bae-d5da-4f4f-9c28-704136cc2e91.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b55bae-d5da-4f4f-9c28-704136cc2e91.png)'
- en: Our method `m` is passed an `a`, does some processing and returns `b`. An exception
    can occur, which may or may not be caught and handled and errors can be returned.
    Additionally, in order for the method to properly satisfy its contract, it's up
    to us to read the documentation (which of course will always be completely accurate
    and up-to-date.... not!) in hopes that we cover all the preconditions, invariant,
    and postconditions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法`m`接收一个`a`，进行一些处理并返回`b`。可能会发生异常，可能会被捕获和处理，也可能会返回错误。此外，为了使方法正确满足其契约，我们需要阅读文档（当然，文档总是完全准确和最新的……不是！）希望我们涵盖所有的前置条件、不变量和后置条件。
- en: An **invariant** is something that must be always be true for the life of the
    method. For example, if our class has a duration member variable, that value must
    always be a positive float. Another example could be that our internal latitude
    and longitude values must always be in the northern hemisphere. We could go so
    far as to write invariance validator private methods to ensure our invariant are
    in compliance with their range of acceptable values.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**不变量** 是方法的整个生命周期中必须始终为真的东西。例如，如果我们的类有一个持续时间成员变量，那个值必须始终是一个正浮点数。另一个例子可能是，我们的内部纬度和经度值必须始终在北半球。我们可以进一步编写不变量验证器私有方法，以确保我们的不变量符合其可接受值范围。'
- en: A **precondition** is something that must be true at the time our method is
    called. For example, before we execute our `consummateMarriage` method we should
    ensure that our chosen `wouldBeSpouse` is not already married to another; Otherwise,
    we'd likely be in violation of our state's anti-polygamy laws. We would likely
    do our checking by executing another `verifyPersonIsSingle` method.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**前置条件** 是我们的方法在调用时必须为真的东西。例如，在执行我们的 `consummateMarriage` 方法之前，我们应该确保我们选择的
    `wouldBeSpouse` 没有已经与他人结婚；否则，我们很可能会违反我们州的反多配偶制度。我们可能会通过执行另一个 `verifyPersonIsSingle`
    方法来进行检查。'
- en: 'Let''s not forget the **postconditions**. An example might be: After executing
    our `consummateMarriage` method we should ensure that the person with whom we
    consummate is actually the same person on our marriage certificate. Marrying the
    wrong person could cause all sorts of problems.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了 **后置条件**。一个例子可能是：在执行我们的 `consummateMarriage` 方法之后，我们应该确保我们与之完婚的人实际上是我们结婚证书上的同一个人。与错误的人结婚可能会引发各种问题。
- en: The last issue to deal with is *side effects*. A side effect is what happens
    when our method changes something other than the **b** (or the error) that it
    outputs. For example, if our postcondition check caused a credit card charge from
    a private investigation firm, that charge would be a side effect.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要处理的问题是 *副作用*。副作用是指当我们的方法改变除了它输出的 **b**（或错误）之外的东西时发生的情况。例如，如果我们的后置条件检查导致了私人调查公司的信用卡扣款，那么这个扣款就是一个副作用。
- en: Our FP function smells like roses
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们的函数式编程函数闻起来像玫瑰
- en: 'This is what our function contract looks like in the FP world:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在函数式编程世界中的函数契约是什么样子的：
- en: '![](img/f8c89004-3ce4-4874-a7d3-1c6f8bf1a063.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8c89004-3ce4-4874-a7d3-1c6f8bf1a063.png)'
- en: See the difference? We can almost smell the difference! Hey, wait a minute!
    (An OOP programmer might be thinking...)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 看到区别了吗？我们几乎能闻到区别！嘿，等一下！（面向对象的程序员可能会想...）
- en: This pure function is missing some stuff! This is an unfair comparison!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个纯函数缺少一些东西！这是一个不公平的比较！
- en: That's right. It's not fair, but it's real.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 没错。这不公平，但这是现实。
- en: And what makes it real is our inputs type.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 而使它变得真实的是我们的输入类型。
- en: In FP, contracts don't lie
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在函数式编程中，契约不会说谎
- en: 'Let''s look an example of some imperative code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个命令式代码的例子：
- en: '[PRE11]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What is our contract in the preceding code?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们的契约是什么？
- en: The contract is our method's signature: `func (n Dividend) Divide(divisor int)
    int`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 契约就是我们方法的签名：`func (n Dividend) Divide(divisor int) int`
- en: What three questions must our contract answer?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的契约必须回答哪三个问题？
- en: What does our contract expect?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的契约期望什么？
- en: 'Answer: It expects the following:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案：它期望以下内容：
- en: The `Dividend.Val` to be populated with an `int`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dividend.Val` 要填充一个 `int`'
- en: The divisor to be an `int`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被除数是一个 `int`
- en: What does our contract guarantee?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的契约保证了什么？
- en: 'Answer: It promises to return an integer'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案：它承诺返回一个整数
- en: What does the contract maintain?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 契约维护什么？
- en: 'Answer: Not applicable in this simple case'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案：在这种简单情况下不适用
- en: What happens when we run the preceding code?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时会发生什么？
- en: '![](img/5038ec59-b333-44ea-b460-d7b21aad6d94.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5038ec59-b333-44ea-b460-d7b21aad6d94.jpg)'
- en: We get a runtime panic! Did our contract hold true, or did it lie to us?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个运行时恐慌！我们的契约是否成立，还是对我们说谎了？
- en: '![](img/cbe891bd-f5ad-4179-bf03-b790f2864753.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbe891bd-f5ad-4179-bf03-b790f2864753.jpg)'
- en: In pure FP, we don't rely on lowly types like int, char, or even string. We
    leverage the full power of an amazing type class system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式编程中，我们不依赖于像 int、char 或者 string 这样低级的类型。我们利用了一个令人惊叹的类型类系统的全部威力。
- en: 'In a pure FP language like Haskell, we can define a `PostiveInt` type. So,
    instead of writing a method to validated that an input parameter is positive,
    we define a type named `PostiveInt` that guarantees that only positive integers
    will be input:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Haskell 这样的纯函数式语言中，我们可以定义一个 `PostiveInt` 类型。因此，我们不需要编写一个验证输入参数是否为正数的方法，而是定义一个名为
    `PostiveInt` 的类型，它保证只有正整数会被输入：
- en: '[PRE12]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In FP terms, LSP says, *Contracts don't lie*;
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程术语中，LSP 表示，*契约不会说谎*；
- en: '![](img/1918b05d-8512-4ff6-8a1e-24409f2f2c1d.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1918b05d-8512-4ff6-8a1e-24409f2f2c1d.png)'
- en: In FP, we don't have to rely on our test suite to verify that our application
    properly enforces it requirements. In FP, assuming we have designed our software
    properly, if it compiles then it is correct. We let our type system enforce our
    requirements.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，我们不必依赖于我们的测试套件来验证我们的应用程序是否正确地执行了它的要求。在函数式编程中，假设我们已经正确地设计了我们的软件，如果它编译通过，那么它就是正确的。我们让我们的类型系统来执行我们的要求。
- en: In an OOP courting relationship, the input (candidate spouse) is only verified
    to be Female. When we later discover that she is not the right type of woman,
    that is, she's already married, that would render the marriage contract invalid.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的追求关系中，输入（候选配偶）只被验证为女性。当我们后来发现她不是合适的类型的女人时，也就是说，她已经结婚了，那将使婚姻契约无效。
- en: 'This is what happens when we don''t properly type check our input:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是当我们没有正确地对输入进行类型检查时会发生的情况：
- en: '![](img/3faef2ce-0e74-4a8d-ac69-6bbd2f383021.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3faef2ce-0e74-4a8d-ac69-6bbd2f383021.png)'
- en: 'This is the picture when we use pure FP:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用纯函数式编程时的情况：
- en: '![](img/7221c37a-6cd4-4cdc-9b63-b1783c0334d4.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7221c37a-6cd4-4cdc-9b63-b1783c0334d4.png)'
- en: Looks simple, but where are the external interactions like in-laws that can
    lead to divorce? What about children? Aren't they what we might call side-effects
    of a marriage?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，但是外部交互在哪里，比如可能导致离婚的姻亲？孩子呢？他们不就是我们可能称之为婚姻的副作用吗？
- en: 'Monads provide a way for our couple to interact with the external world; To
    handle possibly harmful influences and generate beautiful side effects. It looks
    something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 单子提供了一种让我们的夫妇与外部世界互动的方式；处理可能有害的影响并产生美丽的副作用。它看起来像这样：
- en: '![](img/388f97d1-8e42-4bc1-800d-eaab913cdd74.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/388f97d1-8e42-4bc1-800d-eaab913cdd74.png)
- en: The trick to Monads is that all external interactions are contained (in the
    box). We'll cover Monads in depth in our last chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 单子的诀窍在于所有外部交互都被包含在内（在盒子里）。我们将在最后一章深入讨论单子。
- en: This book is about learning *functional* programming in Go. Hence, we will embrace
    the full meaning of the term *functional.* Functional does not only mean *pure.* If
    we're using functions, we're doing functional programming. Go is a multi-paradigm
    language that does not force us to be completely pure or completely imperative.
    The vast majority of Go code these days is imperative... take the standard libraries
    as an example. There is a time and a place for implementing pure functional programming
    techniques. The more we learn about all aspects of Go's functional capabilities,
    and pure functional programming concepts, the better equipped we will be to prudently
    apply the proper style of coding to meet our application development requirements.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于在Go中学习*函数*编程的。因此，我们将全面理解术语*函数*的含义。函数不仅意味着*纯*。如果我们使用函数，我们就是在进行函数式编程。Go是一种多范式语言，不强迫我们完全纯粹或完全命令式。如今绝大多数Go代码都是命令式的...以标准库为例。实现纯函数式编程技术有其时机和场合。我们越了解Go的所有函数能力和纯函数式编程概念，我们就越能够谨慎地应用适当的编码风格来满足我们的应用开发需求。
- en: Let's see the LSP at work with a duck typing example.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看鸭子类型示例中的LSP的工作。
- en: Duck typing
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: Go does not have inheritance or subtypes, but we have interfaces. Functions
    that implement the methods of an interface satisfy the interface contract implicitly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有继承或子类型，但我们有接口。实现接口方法的函数隐式满足接口合同。
- en: Go supports what's called **duck typing**. If it walks like a duck and quacks
    like a duck, then it's a duck. In other words, if we have a Go struct with methods
    that implement the Duck interface, that is, if it has the `Walk()` and `Quack()`
    methods, then for all intents and purposes, our struct is a duck.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持所谓的**鸭子类型**。如果它走起来像鸭子，叫起来像鸭子，那么它就是鸭子。换句话说，如果我们有一个具有实现Duck接口的方法的Go结构体，也就是说，如果它有`Walk()`和`Quack()`方法，那么在所有意图和目的上，我们的结构体就是一只鸭子。
- en: In object-oriented languages, such as Java, we'd be tempted to design our ducks
    as follows.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中，比如Java，我们会被诱惑设计我们的鸭子如下。
- en: What can go wrong with inheritance?
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承可能出现什么问题？
- en: 'We are told that ducks can walk and quack. So we implement those behaviors
    in our parent class, namely `Duck`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被告知鸭子可以走路和呱呱叫。因此，我们在我们的父类中实现了这些行为，即`Duck`：
- en: '![](img/d8043e18-a4e1-416a-99e9-0f5f89fae01a.png)![](img/77ddb2f7-0c9e-41a0-841c-725d1269d4b5.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/d8043e18-a4e1-416a-99e9-0f5f89fae01a.png)！[](img/77ddb2f7-0c9e-41a0-841c-725d1269d4b5.png)
- en: We start out with `Mallard` and `BlueBilled` ducks. We are able to reuse the
    `walk()` and `quack()` methods via inheritance.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Mallard`和`BlueBilled`鸭子开始。我们能够通过继承重用`walk()`和`quack()`方法。
- en: 'Next, we hear that ducks can fly. So we implement the fly behavior in our `Duck`
    class and all the child classes inherit this new behavior:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们听说鸭子可以飞。因此，我们在我们的`Duck`类中实现飞行行为，所有子类都继承了这种新行为：
- en: '![](img/66326981-6c3b-4519-8e8a-bf44d140669b.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/66326981-6c3b-4519-8e8a-bf44d140669b.png)
- en: All is well until we add `Pekins` ducks to our flock.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好，直到我们将`Pekins`鸭子加入我们的群体。
- en: 'The problem that we did not account for in our original design is that most
    domestically bred ducks cannot fly:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在原始设计中没有考虑到的问题是，大多数国内饲养的鸭子不能飞行：
- en: '![](img/1035156e-db0e-485e-b1a2-cd2fc956fd05.png)![](img/28bc566a-6b96-490f-8641-8b909a4c9c82.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/1035156e-db0e-485e-b1a2-cd2fc956fd05.png)！[](img/28bc566a-6b96-490f-8641-8b909a4c9c82.png)
- en: The good news for us is that this sort of a design flaw is not even a possibility
    in Go!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这种设计缺陷甚至在Go中都不可能发生！
- en: The way we model behavior in Go is by using interfaces (Go does not support
    inheritance).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用接口来模拟Go中的行为（Go不支持继承）。
- en: Interface segregation principle
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: It is better to have a lot of single purpose-specific interfaces than one general
    purpose interface. Our APIs should not accept references to structures that it
    does not need, and conversely, our client implementations should not depend on
    code that it does not use.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最好有很多单一用途的接口，而不是一个通用接口。我们的API不应该接受它不需要的结构的引用，反之亦然，我们的客户端实现不应该依赖于它不使用的代码。
- en: We'll see this soon in our Viva La Duck code example in the form of separate
    `EatBehavior` and `StrokeBehavior` interfaces.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会在我们的Viva La Duck代码示例中看到这一点，以独立的`EatBehavior`和`StrokeBehavior`接口的形式。
- en: When we strictly apply  the integration segregation principle we end up with
    interfaces with a single method. Such objects represent data with behavior, but
    it can also be modeled as behavior with data, which is what closures are in FP.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们严格应用集成隔离原则时，我们最终得到了只有一个方法的接口。这样的对象代表了具有行为的数据，但它也可以被建模为具有数据的行为，这就是FP中闭包的作用。
- en: This is another area where it would be nice if Go supported Generics. Why create
    boiler plate code to handle slices of `Int` types, `Customers`, or `AvailableWomen`
    when a single enumeration of `T` would work (with less code)?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个地方，如果Go支持泛型将会很好。为什么要创建处理`Int`类型、`Customers`或`AvailableWomen`切片的样板代码，当一个`T`的枚举就可以工作（代码更少）？
- en: Dependency inversion principle
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: The **dependency inversion principle** (**DIP**) states that we should depend
    upon abstractions, not concretions. DIP is about removing hardwired dependencies
    from our code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖反转原则**（**DIP**）指出我们应该依赖于抽象，而不是具体实现。DIP是关于从我们的代码中移除硬编码的依赖关系。'
- en: 'For example, the following code violates DIP:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码违反了DIP：
- en: '[PRE13]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `MyOtherFunction` function is not quite as bad as the `MyFunction` function,
    but both implementations couple our implementation with a type and an interface
    of another package.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyOtherFunction`函数并不像`MyFunction`函数那样糟糕，但两种实现都将我们的实现与另一个包的类型和接口耦合在一起。'
- en: In general, good software design relies on high cohesion, where we write functions
    that do one thing and do it well and are loosely coupled.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，良好的软件设计依赖于高内聚性，我们编写的函数只做一件事，并且做得很好，并且松散耦合。
- en: In pure functional programming, dependency injection is accomplished by passing
    partially applied functions around. Some call it the *hollywood principle*, as
    in, *Don't call us, we'll call you*. In JavaScript, this is frequently accomplished
    using callbacks.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式编程中，通过传递部分应用的函数来实现依赖注入。有些人称之为*好莱坞原则*，就像是，“不要打电话给我们，我们会打电话给你”。在JavaScript中，这通常是使用回调来实现的。
- en: Note that there is a subtle difference between callbacks and continuations.
    Callback functions may be called multiple times in the flow of an application
    and each time they return a result and processing continues. When a function calls
    another function as the last thing it does then the second function is called
    a continuation of the first.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，回调和继续之间存在微妙的区别。回调函数可能在应用程序的流程中被多次调用，每次它们都会返回一个结果，处理会继续进行。当一个函数调用另一个函数作为其最后一件事时，第二个函数被称为第一个函数的继续。
- en: The big reveal
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大揭示
- en: A monad chains continuations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 单子链继续。
- en: Recall the monad from the hierarchy diagram of *Fantasy Land* algebras earlier
    in this chapter?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得本章前面*Fantasy Land*代数的层次图中的单子吗？
- en: We'll talk a lot more about Monads in the last unit of our book, but for now
    let's take a sneak peak at the big picture.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的最后一个单元中更多地讨论单子，但现在让我们来看一下整体情况。
- en: 'Earlier we saw composition of functions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到了函数的组合：
- en: '![](img/ef811db8-5f67-4b7b-a928-1dc30db9cbfe.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef811db8-5f67-4b7b-a928-1dc30db9cbfe.png)'
- en: 'That''s actually a problem because that''s not a Monoid. A Monoid looks like
    this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个问题，因为这不是一个单子。单子看起来像这样：
- en: '![](img/407d6776-83f1-4461-b0c3-3a57e09c632b.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/407d6776-83f1-4461-b0c3-3a57e09c632b.png)'
- en: And that's the big reveal. Monads are purple!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大揭示。单子是紫色的！
- en: Ha. Gotcha!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 哈。抓住你了！
- en: Besides the color, what can you see that's different between the monadic function
    and the ones above it?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颜色，你还能看到单子函数和上面的函数之间的不同之处吗？
- en: What about the **a** going in and the **a** coming out? That means that if a
    Monoid accepts a parameter of type **A** (by convention, a lower case **a** variable
    is a value of type A), then it will spit out another **a** value.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 那么**a**进入和**a**出来怎么办？这意味着如果单子接受类型为**A**的参数（按照惯例，小写**a**变量是类型A的值），那么它将产生另一个**a**值。
- en: Guess what that's called? When our function returns the same type that it's
    fed? We call that an *endomorphism* where *en* means *same* and *morphism* means
    *function*; So, it changes from an **a** to an **a**. Simple.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜那叫什么？当我们的函数返回与其输入相同的类型时？我们称之为*端态*，其中*en*表示*相同*，*morphism*表示*函数*；因此，它从**a**变为**a**。简单。
- en: What about the *chain* word used in the *a monad chains continuations* statement?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在*单子链继续*语句中使用的*链*一词是什么意思？
- en: How about a nice monoidal purple chain of functions?
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一个漂亮的单子紫色链函数呢？
- en: '![](img/1b5e9082-3668-4085-b455-ccc7c63013fe.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b5e9082-3668-4085-b455-ccc7c63013fe.png)'
- en: What else do we know about this purple monoid chain?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个紫色单子链还有什么其他信息？
- en: '![](img/d74237cb-add8-4d04-b161-a28429f5e04a.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d74237cb-add8-4d04-b161-a28429f5e04a.png)'
- en: If all functions are monids then we can combine them in any order (associativity
    rule).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有函数都是单子，那么我们可以以任何顺序组合它们（结合律规则）。
- en: Great, but what can we do with a Monoid chain? Can we run the processes in parallel?
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，但是我们可以用单子链做些什么？我们可以并行运行这些进程吗？
- en: Run in parallel? Well, that depends on what we're dealing with. Many things
    can run in parallel.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 并行运行？嗯，这取决于我们正在处理什么。许多事情可以并行运行。
- en: In theory, yes but in practice we'll need to deal with the same considerations
    other Map/Reduce solutions such as Hadoop must deal with.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上是可以的，但在实践中，我们需要处理与其他Map/Reduce解决方案（如Hadoop）相同的考虑。
- en: MapReduce
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MapReduce
- en: '**MapReduce** is a technique that splits big datasets into many smaller ones.
    Each small dataset is separately, but simultaneously processed on different servers.
    The results are then gathered and aggregated to produce a final result.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapReduce**是一种将大型数据集拆分为许多较小数据集的技术。每个小数据集都在不同的服务器上分别进行处理，然后将结果收集和聚合以产生最终结果。'
- en: How does it work?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: Suppose we have a lot of web servers and we want to determine the top requested
    pages across all of them. We can analyze web server access logs to find all the
    requested URLs, count them, and sort the results.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有很多网络服务器，我们想要确定它们所有的顶部请求页面。我们可以分析网络服务器访问日志，找到所有请求的URL，对其进行计数，并对结果进行排序。
- en: 'The following are the good use cases for MapReduce:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是MapReduce的良好用例：
- en: Gathering statistics from servers, for example, top 10 users, top 10 requested
    URL
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器收集统计信息，例如前10个用户，前10个请求的URL
- en: Compute the frequencies of all keywords found in your data
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数据中所有关键字的频率
- en: 'The following are the use cases not good for MapReduce:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不适合MapReduce的用例：
- en: Jobs that require shared state
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要共享状态的作业
- en: Finding individual records
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找单个记录
- en: Small data
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小数据
- en: MapReduce example
  id: totrans-318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MapReduce示例
- en: 'Suppose we have an Apache web server access log files with entries that look
    like this one:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个Apache网络服务器访问日志文件，其中的条目看起来像这样：
- en: '[PRE14]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What if we are interested in knowing the top 5 most accessed JSON files?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道前5个最常访问的JSON文件呢？
- en: 'We could perform a MapReduce directly from the terminal using standard Unix
    string processing commands:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从终端使用标准的Unix字符串处理命令执行MapReduce：
- en: '[PRE15]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That works great for a few thousand lines. If we type `time` in front of that
    last command we get something like the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这对几千行来说效果很好。如果我们在最后一个命令前面输入`time`，我们会得到以下类似的结果：
- en: '[PRE16]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But what if each server has millions of lines of code and we have a lot of servers?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果每个服务器有数百万行代码，而我们有很多服务器呢？
- en: Time for MapReduce!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行MapReduce了！
- en: 'On each server we can perform our mapping; Starting log file entries as input
    and resulting in a set of key value pairs:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个服务器上，我们可以执行我们的映射；将日志文件条目作为输入，产生一组键值对：
- en: '![](img/ae767c19-be83-409f-883e-8490b2595472.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae767c19-be83-409f-883e-8490b2595472.png)'
- en: 'Next, we take each intermediate result from each server and feed them into
    our `reduce` function which then spits out the results:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从每个服务器的每个中间结果中提取数据，并将它们馈送到我们的`reduce`函数中，然后输出结果：
- en: '![](img/0d6ed4e7-cfdc-45d2-88b8-b811c23bac9c.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d6ed4e7-cfdc-45d2-88b8-b811c23bac9c.png)'
- en: 'Our top 5 most requested JSON files might look like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前5个最常请求的JSON文件可能是这样的：
- en: '[PRE17]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'What can we glean from this example? It looks like good candidates for MapReduce
    include use cases where:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这个例子中得到什么？看起来MapReduce的好候选包括以下用例：
- en: We have so much data that running it all sequentially on one server would take
    too long
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有如此多的数据，如果在一个服务器上顺序运行所有数据将花费太长时间
- en: Our output, from the `map` phase, consists of a list of key, value pairs
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的输出，来自`map`阶段，包括一系列键值对
- en: We can run each `map` or `reduce` function in isolation, knowing that the output
    of our function relies only on its input
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以独立运行每个`map`或`reduce`函数，知道我们函数的输出仅依赖于其输入
- en: But what else is going on here that might not be readily apparent?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里还有什么其他可能不太明显的事情？
- en: What else makes this process of Map/Reduce work?
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 还有什么使Map/Reduce工作的过程？
- en: 'What FP patterns are lurking in the shadows? (Hint: We''ve already seen it
    and it has to do with data types.)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: FP模式在阴影中潜伏着什么？（提示：我们已经看到了它，它与数据类型有关。）
- en: What else can Monads do?
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Monad还能做什么？
- en: Monads can be used to clearly convey our business logic and manage our applications
    processing flows and more.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Monad可以用来清晰地传达我们的业务逻辑，并管理我们应用程序的处理流程等。
- en: '![](img/68aa7767-20aa-4a2f-8f40-89b44386c2af.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68aa7767-20aa-4a2f-8f40-89b44386c2af.jpg)'
- en: 'You know what I''m talking about. Consider the following piece of code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道我在说什么。考虑以下代码片段：
- en: '[PRE18]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Those `if err != nil`  blocks litter our code and obscure our code''s original
    intent. If this is our happy path code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 那些`if err != nil`块遍布我们的代码，并且遮蔽了我们代码的原始意图。如果这是我们的正常路径代码：
- en: '[PRE19]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is what it looks like after we add error checking:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加错误检查之后，它看起来是这样的：
- en: '[PRE20]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Guess what our FP code would look like after including error handling?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜我们的FP代码在包含错误处理后会是什么样子？
- en: '[PRE21]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How can this be? No inline error checking? We'll cover this topic in [Chapter
    9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能？没有内联错误检查？我们将在[第9章](../Text/Ch09.xhtml)中涵盖这个主题，*函子、单子和泛型*。
- en: Viva La Duck
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Viva La Duck
- en: Our next code example will illustrate several of the SOLID design principles
    applied to our Go implementation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个代码示例将说明我们的Go实现应用了几个SOLID设计原则。
- en: In our Viva La Duck application, our duck must visit a number of ponds looking
    for bugs to eat. To keep things simple, we'll assume that each stroke will require
    the duck to eat one bug. Each time the duck paddles its feet (one stroke), the
    duck's supply of strokes is decreased by one.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Viva La Duck应用程序中，我们的鸭子必须访问许多池塘寻找要吃的虫子。为了保持简单，我们假设每一次划水都需要鸭子吃一只虫子。每次鸭子划动脚（一次划水），鸭子的划水次数就会减少一次。
- en: We're not concerned with how the duck moves from pond to pond, but rather the
    number of strokes the duck must make to traverse the length of the pond. If a
    pond has bugs to eat, they will be found on the other side of the pond. If the
    duck runs out of energy, it dies.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不关心鸭子如何从一个池塘到另一个池塘，而是鸭子必须划多少次才能穿过池塘的长度。如果池塘有虫子吃，它们将在池塘的另一边找到。如果鸭子耗尽了能量，它就会死去。
- en: Our program is a self-contained runnable Go source file. Its package name is
    `main` and it has a `main()` function. We'll use the `DASHES` constant later when
    we print the statistics indicating what the duck encountered at each pond.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序是一个独立的可运行的Go源文件。它的包名是`main`，并且有一个`main()`函数。我们将在以后使用`DASHES`常量，用于打印每个池塘中鸭子遇到的统计信息。
- en: 'The `Pond` struct contains the state of each pond, that is, the number of bugs
    it supplies for the duck to eat and how many strokes are required to cross the
    pond:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pond`结构包含了每个池塘的状态，即鸭子要吃的虫子数量以及穿过池塘所需的划水次数：'
- en: '[PRE22]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: One of the first things we should do is define our system's behaviors in the
    form of simple interfaces. We should think about how we can embed our interfaces
    into a larger set of interfaces as we compose our system's behavior patterns. It
    makes sense to categorize a thing by its abilities because a thing is defined
    by its actions.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的第一件事之一是以简单接口的形式定义我们系统的行为。我们应该考虑如何将我们的接口嵌入到更大的一组接口中，因为我们组合我们系统的行为模式。按照能力对事物进行分类是有意义的，因为事物是由其行为定义的。
- en: 'Since this is a book about functional programming, now would be a good time
    to mention that a major benefit of using interfaces is that they allow us to group
    our application''s functions in order to model real-life behaviors:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于函数式编程的书，现在是时候提到使用接口的一个主要好处了，那就是它们允许我们将应用程序的函数分组，以模拟现实生活中的行为：
- en: '[PRE23]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each interface (`StrokeBehavior` and `EatBehavior`) represents a fine-grained,
    well-defined behavior. Breaking apart our system into small parts will make our
    application more flexible and more easily composable:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接口（`StrokeBehavior`和`EatBehavior`）代表了一个细粒度、明确定义的行为。将系统分解成小部分将使我们的应用程序更加灵活和更容易组合：
- en: '[PRE24]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By declaring small, single purpose interfaces, we are now free to embed them
    in new, more feature-rich interfaces.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通过声明小而单一目的的接口，我们现在可以自由地将它们嵌入到新的、更丰富功能的接口中。
- en: 'Grouping interfaces is a common pattern we can find in the Go standard library.
    For example, in the `httputil` package, we find the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 将接口分组是我们可以在Go标准库中找到的常见模式。例如，在`httputil`包中，我们找到以下内容：
- en: '`type writeFlusher interface {`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`type writeFlusher interface {`'
- en: '`    io.Writer`'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Writer`'
- en: '`    http.Flusher`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Flusher`'
- en: '`}`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'Next, we define our duck. Our duck is stateless and has no fields:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的鸭子。我们的鸭子是无状态的，没有字段：
- en: '[PRE25]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We define two methods for our duck. The receiver, `Duck`, must be defined in
    the same package as our method, `Stroke`. Since we are only using a main package,
    that's not a problem.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的鸭子定义了两种方法。接收器“Duck”必须在与我们的方法“Stroke”相同的包中定义。由于我们只使用了一个主包，这不是问题。
- en: 'Modeling our system after the real world, we define a `Foot` struct and a `PaddleFoot`
    method for that foot. Each time our duck paddles its foot, we''ll decrement our
    duck''s `strokeSupply` type:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟现实世界之后，我们定义了一个“Foot”结构和一个“PaddleFoot”方法。每当我们的鸭子划动它的脚时，我们都会减少我们鸭子的“划水次数”类型：
- en: '[PRE26]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Similarly, we define a `Bill` type and its `EatBug` method that increments
    our duck''s `strokeSupply` type:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们定义了一个“Bill”类型及其“EatBug”方法，它增加了我们鸭子的“划水次数”类型。
- en: '[PRE27]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For every stroke, our duck will paddle its foot.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一次划水，我们的鸭子都会划动它的脚。
- en: 'Our `Stroke` method will return an error if the duck runs out of energy and
    gets stuck in the middle of a pond:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鸭子耗尽能量并被困在池塘中，我们的“Stroke”方法将返回一个错误：
- en: '[PRE28]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we define our duck''s eating behavior. When our duck reaches the end of
    the pond, it gets to eat all the pond''s bugs:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义我们鸭子的吃东西行为。当我们的鸭子到达池塘的尽头时，它可以吃掉池塘里的所有虫子：
- en: '[PRE29]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `SwimAndEat` method's signature is slightly different than that of `Eat`
    and `Stroke` methods. Notice the differences?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: “SwimAndEat”方法的签名与“Eat”和“Stroke”方法略有不同。注意到了吗？
- en: All three methods have a `Duck` as their receiver, but the `SwimAndEat` method
    defines the variable `d`. That's because we need to reference the `Stroke` and
    `Eat` methods within the `SwimAndEat` method.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方法都有一个“Duck”作为它们的接收器，但是“SwimAndEat”方法定义了变量“d”。这是因为我们需要在“SwimAndEat”方法中引用“Stroke”和“Eat”方法。
- en: 'Also, they all take an interface as their first parameter, but `SwimAndEat`
    takes a composed set of interfaces, namely `StrokeAndEatBehaviors`, which it uses
    polymorphically for both `Stroke` and `Eat`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们都将一个接口作为它们的第一个参数，但是“SwimAndEat”将一个组合的接口集合，即“StrokeAndEatBehaviors”，作为它的第一个参数，它在“Stroke”和“Eat”中使用多态：
- en: '[PRE30]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Pass by value or reference?
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过值传递还是引用传递？
- en: Here's the rule of thumb--if you want to share a state, then pass by reference,
    that is, use a pointer type; otherwise, pass by value. Since we need to update
    our duck's `strokeSupply` type in this `Stroke` method, we pass it as an `int`
    pointer (`*int`). So, pass a pointer parameter only when absolutely necessary.
    We should begin to code defensively, assuming that someone may try to run our
    code concurrently. When we pass our parameters by value, it's safe for concurrent
    use. When we pass by reference, we may need to add `sync.mutex` or some channels
    to coordinate concurrency.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经验法则——如果你想共享一个状态，那么通过引用传递，也就是使用指针类型；否则，通过值传递。由于我们需要在这个“划水”方法中更新我们鸭子的“划水次数”类型，我们将其作为“int”指针（*int）传递。因此，只有在绝对必要时才传递指针参数。我们应该开始进行防御性编码，假设有人可能尝试同时运行我们的代码。当我们通过值传递参数时，可以安全地进行并发使用。当我们通过引用传递时，可能需要添加“sync.mutex”或一些通道来协调并发。
- en: 'Our duck builds its energy back by eating more bugs that it gets from the pond:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的鸭子通过吃更多从池塘中获得的虫子来恢复能量：
- en: '[PRE31]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since we are designing our software application to model the real world, things
    such as duck feet and duck bills are natural candidates for struct names to represent
    real-life objects. Feet are used to paddle and duck bills are used to eat bugs.
    Each paddle, that is, `stroke`, reduces our duck's supply of possible strokes.
    Each bug is worth one stroke.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在设计我们的软件应用程序来模拟现实世界，鸭脚和鸭嘴等事物是代表真实物体的结构名称的自然候选者。脚用于划水，鸭嘴用于吃虫子。每一次划水，也就是“划”，都会减少我们鸭子的可能划水次数。每只虫子值一次划水。
- en: 'We tell our duck''s foot to paddle. As long as the duck has energy, that is,
    it''s `strokeSupply` type is greater than zero, the duck will obey. However, if `strokeSupply`
    is zero, then our duck will be stranded in the middle of the pond before it gets
    to its next supply of bugs to eat:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉我们鸭子的脚划水。只要鸭子有能量，也就是说，它的“划水次数”类型大于零，鸭子就会服从。但是，如果“划水次数”为零，那么我们的鸭子在到达下一批要吃的虫子之前将被困在池塘中：
- en: '[PRE32]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that we are passing a pointer to our supply of strokes. This means that
    our application is maintaining a state. We know that pure functional programming
    does not permit variable mutations. That''s okay because this chapter is about
    good software design using Go. Pure functional programming in Go is covered in
    [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在传递一个指向我们划水次数的指针。这意味着我们的应用程序正在维护一个状态。我们知道纯函数式编程不允许变量突变。这没关系，因为本章是关于使用Go进行良好软件设计的。Go中的纯函数式编程在[第1章](../Text/Ch01.xhtml)中有介绍，“Go中的纯函数式编程”：
- en: '[PRE33]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For every pond that our duck encounters, it must swim and eat bugs to survive.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的鸭子遇到的每一个池塘，它都必须游泳并吃虫子才能生存。
- en: 'Since our duck''s `SwimAndEat` method requires both `StrokeBehavior` and `EatBehavior`,
    we pass the `SurvivalEatBehaviors` interface set as its first parameter:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的鸭子的“SwimAndEat”方法需要“StrokeBehavior”和“EatBehavior”，我们将“SurvivalEatBehaviors”接口集合作为它的第一个参数传递：
- en: '[PRE34]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Recall that the duck's `Stroke` method takes `StrokeBehavior`, not `StrokeEatBehavior`!
    How is this possible? This is part of the magic of type embedding.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，鸭子的“Stroke”方法接受的是“StrokeBehavior”，而不是“StrokeEatBehavior”！这怎么可能？这是类型嵌入的魔力的一部分。
- en: Type embedding with Go interfaces
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Go接口进行类型嵌入
- en: 'Go allows us to declare a type inside another type. In our `SurvivalBehaviors`
    interface, we have declared two fields of type interface. Through inner type promotion,
    the Go compiler performs interface conversions and the inner interface becomes
    part of the outer interface:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Go允许我们在另一个类型内部声明一个类型。在我们的“SurvivalBehaviors”接口中，我们声明了两个类型接口的字段。通过内部类型提升，Go编译器执行接口转换，内部接口成为外部接口的一部分。
- en: '[PRE35]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `d.Stroke` function takes a `SurvivalBehaviors` type as though it received
    `StrokeBehavior`, and the `d.Eat` function takes a `SurvivalBehaviors` type as
    if it received `EatBehavior`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: “d.Stroke”函数接受“SurvivalBehaviors”类型，就好像它接收了“StrokeBehavior”，“d.Eat”函数接受“SurvivalBehaviors”类型，就好像它接收了“EatBehavior”。
- en: This means that the outer type, `SurvivalBehaviors`, now implements the interface
    of both `StrokeBehavior` and `EatBehavior`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着外部类型`SurvivalBehaviors`现在实现了`StrokeBehavior`和`EatBehavior`的接口。
- en: Interface embedding to add minor features
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入接口以添加次要功能
- en: 'Here''s another example of using interface embedding:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个使用接口嵌入的例子：
- en: '[PRE36]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By embedding  `net.Conn` in our `BytesReadConn` we are able to override its
    `Read` method not only perform the `Conn.Read` operation, but also to count the
    number of bytes read.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的`BytesReadConn`中嵌入`net.Conn`，我们能够重写它的`Read`方法，不仅执行`Conn.Read`操作，还能计算读取的字节数。
- en: There's an ELO song that's ringing in my head now.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我脑中响起了一首ELO的歌。
- en: '![](img/2d409a5b-5a74-46ce-89fa-cdd3259201bf.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d409a5b-5a74-46ce-89fa-cdd3259201bf.png)'
- en: A Go error handling idiom
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go错误处理习惯
- en: 'There''s yet another common Go pattern at play in our code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码中还有另一个常见的Go模式：
- en: '[PRE37]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Errors should be handled once and as soon as possible.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 错误应该尽快处理一次。
- en: Some consider this as an antipattern that litters code with `if err != nil`
    blocks. We'll overlook that sentiment, for now, in favor of its simplicity and
    pragmatism.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为这是一种在代码中充斥着`if err != nil`块的反模式。我们暂时忽略这种情绪，而更看重它的简单和实用性。
- en: 'Next, we''ll define a `Capabilities` struct that embeds both behavior interfaces
    and all the important strokes fields. The `Capabilities` type defines what the
    duck can do. It has a number of strokes that it can use to cross each pond and
    two behaviors--one that increases its stroke count and the other that reduces
    the count but helps it to get close to its next source of food:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个`Capabilities`结构，其中嵌入了行为接口和所有重要的力量字段。`Capabilities`类型定义了鸭子能做什么。它有一些力量，可以用来穿过每个池塘，还有两种行为——一种增加它的力量计数，另一种减少计数但帮助它接近下一个食物来源：
- en: '[PRE38]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In Go, any method or field of an embedded/inner interface is accessible to the
    outer interface. Note that we're not saying parent or child, as that might imply
    inheritances. What we have is called inner type promotion, not inheritance. As
    long as an inner field or method name begins with a capital letter, it will be
    accessible to the outer object.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，嵌入/内部接口的任何方法或字段都可以被外部接口访问。请注意，我们并不是说父类或子类，因为那可能会暗示继承。我们所拥有的是内部类型提升，而不是继承。只要内部字段或方法的名称以大写字母开头，它就可以被外部对象访问。
- en: It's time to run our program
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在是运行我们的程序的时候了
- en: Now, it's time to provide the duck with its starting resources and a list of
    ponds to swim in and see whether our duck survives to live another day.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候为鸭子提供它的起始资源和一系列要游过的池塘，看看我们的鸭子是否能活下来了。
- en: 'Let''s assume our duck has five bugs in its belly, which is worth five strokes
    (we made our ponds and bugs very small to simplify our model):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的鸭子肚子里有五只虫子，价值五个力量（我们让我们的池塘和虫子非常小，以简化我们的模型）：
- en: '[PRE39]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our duck''s first set of ponds will consist of two ponds. Each supplies only
    one bug. The first pond requires three strokes to reach the other side. The second
    pond requires two strokes:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鸭子的第一组池塘将包括两个池塘。每个池塘只提供一种虫子。第一个池塘需要三个力量才能到达另一边。第二个池塘需要两个力量：
- en: '[PRE40]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The call to the duck's `SwimAndEat` method uses the address of its capabilities
    because we want to share the duck's `Capabilities` object as our duck moves from
    one set of ponds to another.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 对鸭子的`SwimAndEat`方法的调用使用了其能力的地址，因为我们希望在鸭子从一个池塘到另一个池塘时共享鸭子的`Capabilities`对象。
- en: 'At the end of each day, after the duck has crossed each pond and eaten the
    bugs it finds, we display the duck''s statistics:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在每天结束时，鸭子穿过每个池塘并吃到它找到的虫子后，我们会显示鸭子的统计数据：
- en: '[PRE41]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s the output of this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE42]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the end of the first day, the duck crossed two ponds and has two strokes
    in reserve to start a new day.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 第一天结束时，鸭子穿过了两个池塘，并有两个力量储备来开始新的一天。
- en: 'The next day, our duck has only one pond to swim. Our duck has two bugs in
    its belly. There''re two bugs in this pond. Let''s see whether our duck makes
    it to the other side:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，我们的鸭子只有一个池塘要游过。我们的鸭子肚子里有两只虫子。这个池塘里有两只虫子。让我们看看我们的鸭子是否能到达另一边：
- en: '[PRE43]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here''s the output of this:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE44]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Unfortunately, our duck did not have enough strokes to cross the pond. Bummer!
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的鸭子没有足够的力量穿过池塘。真遗憾！
- en: '![](img/e5d3a692-3c9e-4e87-b266-f0e6098cf409.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5d3a692-3c9e-4e87-b266-f0e6098cf409.png)'
- en: 'The moral of our story is as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故事的寓意如下：
- en: Model applications in meaningful (like real world) ways
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以有意义的方式（如真实世界）对应用进行建模
- en: Start by creating a set of behaviors as single responsibility interface types
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，创建一组行为，作为单一职责接口类型
- en: Compose simple interface types into larger, coherent sets of behaviors
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将简单的接口类型组合成更大、更一致的行为集
- en: Ensure each function accepts only the types of behaviors it requires
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个函数只接受它所需的行为类型
- en: Don't be a duck
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要成为一只鸭子
- en: Summary
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to use bad design using inheritance in Java and
    contrasted that solution to using composition in Go.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Java中使用继承的不良设计，并将该解决方案与在Go中使用组合进行了对比。
- en: 'The **Gang of Four**''s (**GoF**) epic book, *Design Patterns: Elements of
    Reusable Object-Oriented Software*, discussed design patterns that addressed design
    flaws in the object oriented languages like Java. For example, in the *Putting
    Reuse Mechanisms to Work* section, the GoF book states, *Favor object composition
    over class inheritance*.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**四人帮**（GoF）的史诗之作，*设计模式：可复用面向对象软件的基本元素*，讨论了解决像Java这样的面向对象语言中的设计缺陷的设计模式。例如，在*将重用机制投入实际*一节中，GoF书中指出，*更偏爱对象组合而不是类继承*。'
- en: This design principle is not even applicable to Go. Go does not support inheritance.
    No extra thought or work is required for Go developers. Go promotes composition
    out-of-the-box.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计原则甚至不适用于Go。Go不支持继承。Go开发人员不需要额外的思考或工作。Go默认支持组合。
- en: '"These compositional techniques are what give Go its flavor, which is profoundly
    different from the flavor of C++ or Java programs."'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: “这些组合技术赋予了Go其特色，这与C++或Java程序的特色截然不同。”
- en: '- Rob Pike'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '- Rob Pike'
- en: Composition is a software design pattern we should use to build better APIs.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种软件设计模式，我们应该用它来构建更好的API。
- en: 'We start by breaking our system into small parts: single responsibility interfaces.
    We can then put the pieces back together again. When we architect our APIs using
    composition, our applications have a better chance to grow and adapt to the requirements
    that may change over time. Our applications become easier to reason about and
    maintain.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将系统分解为小部分：单一职责接口。然后我们可以将这些部分重新组合在一起。当我们使用组合来设计我们的API时，我们的应用程序有更好的机会适应随时间可能发生变化的需求。我们的应用程序变得更容易理解和维护。
- en: In the next chapter, we'll persist in our pursuit of good design and will focus
    on the decorator pattern. We'll study Go's `Reader` and `Writer` interfaces and
    see why *less is more*. We'll implement channels in order to control the life
    cycle of a concurrent program and much more.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将坚持追求良好的设计，并将专注于装饰器模式。我们将研究Go语言的`Reader`和`Writer`接口，并看到为什么“少即是多”。我们将实现通道以控制并发程序的生命周期等等。
