- en: Adding Functionality with Decoration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装饰添加功能
- en: 'In this chapter, we''ll continue to address this remark: *If you like design
    patterns, use Java, not Go*. We''ll do so with the help of the decorator and strategy
    patterns.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续解决这一说法：*如果你喜欢设计模式，使用Java，而不是Go*。我们将借助装饰器和策略模式来做到这一点。
- en: 'Our goal in this chapter is to understand:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解：
- en: Go's Reader and Writer interfaces
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go的Reader和Writer接口
- en: Why designing using the interface composition is better than type hierarchy
    design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用接口组合进行设计比类型层次结构设计更好
- en: How to design with and implement the Decorator Pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用和实现装饰器模式
- en: Inversion of Control (IoC) by implementing an IoC framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现IoC框架实现控制反转（IoC）
- en: How to set up a request timeout using a proxy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用代理设置请求超时
- en: How to apply the Strategy Pattern when load balancing requests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在负载均衡请求时应用策略模式
- en: How to understand easy-metrics graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何理解easy-metrics图表
- en: How to implement a simple yet effective logger using standard library interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用标准库接口实现一个简单而有效的日志记录器
- en: How to enrich HTTP requests with logging using dependency injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用依赖注入为HTTP请求添加日志记录
- en: How to use channels to control the flow of events in a concurrent program
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用通道来控制并发程序中事件的流动
- en: A better way to extend our application's functionality
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展我们应用功能的更好方法
- en: Interface composition
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口组合
- en: Much like a writer composes a book from a set of chapters or a chapter from
    a set of sections, as Go programmers, we can compose our software applications
    using functional composition.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像作家从一组章节中组成一本书或从一组部分中组成一章一样，作为Go程序员，我们可以使用功能组合来组成我们的软件应用程序。
- en: '![](img/b40bf8c2-82ef-433b-aedf-b3a69ddee63d.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b40bf8c2-82ef-433b-aedf-b3a69ddee63d.png)'
- en: We can take the functional composition approach to design a software solution
    that enables us to design complex APIs from a set of smaller ones.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用功能组合方法来设计一个软件解决方案，使我们能够从一组较小的解决方案设计复杂的API。
- en: 'For example, in the Viva La Duck example from the previous chapter, we composed
    the `SurvivalBehaviors` interface from two smaller ones:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在上一章的Viva La Duck示例中，我们从两个较小的接口组成了`SurvivalBehaviors`接口：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nothing is difficult. Complex things are simply built upon smaller, simpler
    things! When we approach all our software design problems from this perspective,
    we are able to more easily model the real world--our applications become much
    easier to read and reason about.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么是困难的。复杂的东西只是建立在更小、更简单的东西之上！当我们从这个角度来解决所有软件设计问题时，我们能够更容易地对现实世界进行建模——我们的应用程序变得更容易阅读和推理。
- en: Go's complimentary Reader and Writer interfaces
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go的互补Reader和Writer接口
- en: 'To help us appreciate how Go encourages composition, let''s look at Go''s complimentary
    `Reader` and `Writer` interfaces:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们欣赏Go如何鼓励组合，让我们看看Go的互补`Reader`和`Writer`接口：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What can we observe from these interface declarations? Simplicity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这些接口声明中可以观察到什么？简单。
- en: They both have a single method that takes a single parameter and returns a single
    result (along with the requisite error value).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有一个接受单个参数并返回单个结果（以及必需的错误值）的单个方法。
- en: What does that buy us? For starters, we can compose broad interfaces by simply
    adding simpler interfaces.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了什么？首先，我们可以通过简单地添加更简单的接口来组合广泛的接口。
- en: Example usages of the Reader and Writer interfaces
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读者和作者接口的示例用法
- en: 'The `Hash` interface from Go''s standard library is composed of the `io.Writer`
    interface and four others. Therefore, `Hash` can be used anywhere the `io.Writer`
    interface is required:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Go标准库的`Hash`接口由`io.Writer`接口和其他四个接口组成。因此，`Hash`可以在需要`io.Writer`接口的任何地方使用：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Design with Duck Typing
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用鸭子类型进行设计
- en: As mentioned in the previous chapter, this is known as Duck Typing. It's a powerful
    design pattern. A thing is defined not by its type hierarchy but by its behaviors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，这被称为鸭子类型。这是一个强大的设计模式。一件事不是由其类型层次结构定义的，而是由其行为定义的。
- en: 'Here''s an example of a `File` interface from the `github.com/couchbase/moss`
    package:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`github.com/couchbase/moss`包的`File`接口的一个例子：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s another example of it from Go''s `mime/multipart` project:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个来自Go的`mime/multipart`项目的例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When composing with interfaces, keep things as simple as possible. Similarly,
    function signatures should be designed to only accept the smallest possible interface
    required to get the job done.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用接口进行组合时，保持事情尽可能简单。同样，函数签名应设计为仅接受完成工作所需的最小可能接口。
- en: 'Note the application of the single responsibility principle and open/close
    principle in action: our software should be open for extension but closed for
    modifications.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意单一职责原则和开闭原则的应用：我们的软件应该对扩展开放，但对修改关闭。
- en: More reasons to design using interfaces
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用接口进行设计的更多理由
- en: As if that's not enough reason to design using interfaces.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好像这还不足以使用接口进行设计的理由。
- en: 'We also get access to a plethora of functionality. For example, when working
    with readers and writers, we get the following for free:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获得大量功能。例如，当使用读者和写者时，我们可以免费获得以下内容：
- en: '| **Free functionality** | **Description** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **免费功能** | **描述** |'
- en: '| `io.Copy` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `io.Copy` |'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.LimitReader` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `io.LimitReader` |'
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.MultiReader` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `io.MultiReader` |'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.RuneReader` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `io.RuneReader` |'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.ReadSeeker` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `io.ReadSeeker` |'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `io.MultiWriter` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `io.MultiWriter` |'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `bufio.ScanBytes` | `ScanBytes` is a split function for a Scanner that returns
    each byte as a token. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `bufio.ScanBytes` | `ScanBytes`是Scanner的一个分割函数，它将每个字节作为一个标记返回。 |'
- en: '| `bufio.ScanLines` | `ScanLines` is a split function for a Scanner that returns
    each line of text, stripped of any trailing end-of-line marker. The returned line
    may be empty. The end-of-line marker is one optional carriage return, followed by
    one mandatory newline. In regular expression notation, it is `\r?\n`. The last
    non-empty line of input will be returned even if it has no newline. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `bufio.ScanLines` | `ScanLines`是一个Scanner的分割函数，它返回文本的每一行，去除任何尾随的行尾标记。返回的行可能为空。行尾标记是一个可选的回车符，后面跟着一个必需的换行符。在正则表达式表示中，它是`\r?\n`。即使没有换行符，输入的最后一个非空行也将被返回。'
- en: '| `bufio.ScanRunes` | `ScanRunes` is a split function for a Scanner that returns
    each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent
    to that of a range loop over the input as a string, which means that erroneous
    UTF-8 encodings translate to `U+FFFD = "\xef\xbf\xbd"`. Because of the `Scan`
    interface, this makes it impossible for the client to distinguish correctly encoded
    replacement runes from encoding errors. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `bufio.ScanRunes` | `ScanRunes`是一个Scanner的分割函数，它将每个UTF-8编码的符文作为一个标记返回。返回的符文序列等同于对输入的字符串进行范围循环，这意味着错误的UTF-8编码会转换为`U+FFFD
    = "\xef\xbf\xbd"`。由于`Scan`接口，这使得客户端无法区分正确编码的替换符文和编码错误。'
- en: '| `ioutil.ReadDir` | `ReadDir` reads the directory named by `dirname` and returns a
    list of directory entries sorted by filename. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `ioutil.ReadDir` | `ReadDir`读取名为`dirname`的目录，并返回按文件名排序的目录条目列表。'
- en: '| `ioutil.ReadFile` | The`addKeyFromFileToConfigMap` adds a key with the given
    name to a `ConfigMap`, populating the value with the content of the given file
    path; alternatively, it returns an error. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `ioutil.ReadFile` | `addKeyFromFileToConfigMap`将具有给定名称的键添加到`ConfigMap`，并使用给定文件路径的内容填充值；或者，它会返回一个错误。'
- en: That's a lot of out-of-the-box functionality that we didn't have to test and
    code. Reusing Go standard library interfaces and functions is nearly always a
    win!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多开箱即用的功能，我们不需要测试和编码。重用Go标准库的接口和函数几乎总是一个胜利！
- en: Using the Reader and Writer interfaces
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`Reader`和`Writer`接口
- en: 'Let''s exercise what we''ve learned about the `io.Reader` and `io.Writer` interfaces:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习一下关于`io.Reader`和`io.Writer`接口的知识：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Recall that the `Reader` interface looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`Reader`接口看起来是这样的：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When we implement the `Read` method, our `titlizeReader` struct now satisfies
    the `Reader` interface:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现`Read`方法时，我们的`titlizeReader`结构现在满足了`Reader`接口：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `titlizeReader` type will capitalize the first word in the sentence and
    change all the subsequent letters to lowercase. As we iterate through each byte,
    we check its ASCII value. The ASCII value of `A` is `97`. The decimal value of `a` is
    `65`. So, 97 minus 65 equals 32\.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`titlizeReader`类型将大写第一个单词，并将所有后续字母改为小写。当我们迭代每个字节时，我们检查它的ASCII值。`A`的ASCII值是`97`。`a`的十进制值是`65`。所以97减去65等于32。
- en: 'Here we use the string''s `NewReader` method to create an `io.Reader` interface
    from the string, which is `"this IS a tEsT"`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字符串的`NewReader`方法从字符串创建了一个`io.Reader`接口，即`"this IS a tEsT"`：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We individually assigned the reader value on each line. We could have performed
    this in one line:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一行上分别分配了读取器的值。我们本可以在一行中执行这个操作：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use three Readers: one from the strings package, another free one used to
    truncate our string to 12 characters, and the one we wrote ourselves.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了三个读取器：一个来自字符串包，另一个是免费的，用于将我们的字符串截断为12个字符，还有一个是我们自己编写的。
- en: 'Given that we have separated our logic into individual function calls, Go''s
    concurrency constructs enable us to process them independently to improve performance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们已将逻辑分离为单独的函数调用，Go的并发构造使我们能够独立处理它们以提高性能：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use the `os.Stdout` writer to output our results to standard output (our
    terminal console).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`os.Stdout`写入器将结果输出到标准输出（我们的终端控制台）。
- en: Since we are using the Reader and Writer interfaces, we get to use the `io.Copy` interface
    for free.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`Reader`和`Writer`接口，我们可以免费使用`io.Copy`接口。
- en: With `Readers` and `Writers` interfaces, we are able to process streams piece
    by piece. Granted, our example only used a 14-character string, but we could have
    handled more data than could fit in RAM at the same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Reader`和`Writer`接口，我们能够逐块处理流。尽管我们的示例只使用了一个14个字符的字符串，但我们可以处理比RAM中能够同时容纳的更多数据。
- en: '**Gang of Four** (**GOF**) refers to four authors who wrote the *Design Patterns:
    Elements of Reusable Object-Oriented Software* ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns))
    book. Though the examples in the book are in SmallTalk and C++, the book is frequently referenced
    by many resourceful developers as they build object-oriented software. Languages
    such as Java, which supports inheritance, can greatly benefit from all the patterns in
    the GOF book. Not all patterns are equally important for Go. Though, as we saw
    in the previous chapter, we can definitely benefit from the structural Decorator
    pattern and the behavioral Strategy pattern.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**四人帮**（**GOF**）指的是写了*设计模式：可复用的面向对象软件元素*（[https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)）一书的四位作者。尽管书中的例子是用SmallTalk和C++编写的，但这本书经常被许多富有资源的开发人员引用，因为他们构建面向对象的软件。像支持继承的Java这样的语言可以从GOF书中的所有模式中受益良多。并非所有模式对Go都同样重要。尽管如此，正如我们在前一章中看到的，我们绝对可以从结构装饰者模式和行为策略模式中受益。'
- en: Decorator pattern
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: Though it is easier to write quality Go code--than quality Java code--without
    an understanding of the GOF design patterns, it doesn't mean that we, as Go developers,
    cannot benefit from GOF's insight.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不理解GOF设计模式，编写高质量的Go代码比编写高质量的Java代码更容易，但这并不意味着我们作为Go开发人员不能从GOF的见解中受益。
- en: We'll soon see how we can put the Decorator pattern to good use in Go.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何在Go中充分利用装饰者模式。
- en: Type hierarchy UML
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型层次结构UML
- en: 'This is the type hierarchy UML that we might have created while designing the
    Decorator pattern back in the day that we used object-oriented languages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在设计装饰者模式时可能创建的类型层次结构UML，当时我们使用面向对象的语言：
- en: '![](img/43befe07-31c7-4d0e-aa19-3204ab6f8e03.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43befe07-31c7-4d0e-aa19-3204ab6f8e03.png)'
- en: 'This is the design work needed to represent the same Decorator pattern using
    Go:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Go表示相同装饰器模式所需的设计工作：
- en: '![](img/4e1cc3d4-ee2b-4571-8661-7dd8255c3d7a.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e1cc3d4-ee2b-4571-8661-7dd8255c3d7a.png)'
- en: '"Less is exponentially more"'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"少即是多"'
- en: '- Rob Pike'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '- Rob Pike'
- en: How Procedural design compares to functional Inversion of Control (IoC)
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过程式设计与功能IoC的比较
- en: 'The client request is wrapped by the `Authorization`, `LoadBalancing`, `Logging`,
    and `FaultTolerance` decorators. When a client request is executed, the functionality
    in those decorators will be injected into the flow by our Decorator framework,
    as shown in the following diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求由`Authorization`、`LoadBalancing`、`Logging`和`FaultTolerance`装饰器包装。当客户端请求执行时，这些装饰器中的功能将通过我们的装饰器框架注入到流程中，如下图所示：
- en: '![](img/fa33d7d5-376b-43dd-ada6-49a48f85f800.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa33d7d5-376b-43dd-ada6-49a48f85f800.png)'
- en: 'In procedural programming, the `main()` function would be in control of the
    flow of logic. The code would be monolithic and tightly coupled. For example,
    to implement `Authorization`, the programmer would insert the following line somewhere
    before the request is performed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式编程中，`main()`函数将控制逻辑流。代码将是单片的并且紧密耦合的。例如，要实现`Authorization`，程序员会在请求执行之前的某个地方插入以下行：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The logic of `FaultTolerance` and `LoadBalancing` would likely look like spaghetti
    code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`FaultTolerance`和`LoadBalancing`的逻辑可能看起来像意大利面代码。'
- en: 'By programming the Decorator functions, we adhere to the client interface as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编程装饰器函数，我们遵循客户端接口如下：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each decorator will be a separate function-specific component.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个装饰器将是一个单独的函数特定组件。
- en: Procedural design example
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过程式设计示例
- en: 'Procedural programming is like interacting with a Bash script in the terminal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 过程式编程就像在终端中与Bash脚本交互：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In procedural design, user interaction is predefined and sequential in nature.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式设计中，用户交互是预定义的并且是顺序性的。
- en: Functional IoC example
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IoC功能示例
- en: 'Contrast the text-based Bash script example to a web application where the
    user is in control:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于文本的Bash脚本示例与用户控制的Web应用程序进行对比：
- en: '![](img/f265452e-0db3-431c-8c40-79f2f1e195f7.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f265452e-0db3-431c-8c40-79f2f1e195f7.png)'
- en: In a GUI application, control is inverted. Instead of the program forcing the
    next user interaction, the user is mostly in control of what happens next. The
    IoC container is a web application framework that runs an event loop and handles
    the callback when the user clicks on controls, such as an item in the drop-down
    list or a submit button.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI应用程序中，控制被倒置了。程序不再强制下一个用户交互，用户大多控制接下来发生的事情。IoC容器是一个运行事件循环并在用户点击控件时处理回调的Web应用程序框架，例如下拉列表中的项目或提交按钮。
- en: For some J2EE applications, IoC can also come in the form of XML configuration
    files that are injected into a Spring framework.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些J2EE应用程序，IoC也可以以注入到Spring框架中的XML配置文件的形式出现。
- en: In a product shopping example, dependencies would be things such as Select Product
    or Enter Shipping Address. In our decorator implementation, dependencies include `Authorization`,
    `LoadBalancing`, etc., each of which decorate the request.  Our IoC container
    is the decorator framework where functions like `Authorization` and `LoadBalancing` implement
    the Client interface.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品购物示例中，依赖关系将是诸如选择产品或输入送货地址之类的事物。在我们的装饰器实现中，依赖关系包括`Authorization`、`LoadBalancing`等，每个都装饰了请求。我们的IoC容器是装饰器框架，其中像`Authorization`和`LoadBalancing`这样的函数实现了客户端接口。
- en: A decorator implementation
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器实现
- en: Our decorator pattern example will be runnable, so we'll put it in the `main`
    package and define a `main()` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的装饰器模式示例将是可运行的，因此我们将其放在`main`包中并定义一个`main()`函数。
- en: We use the easy-metrics package for recording and displaying our metrics. It
    comes out of the box with a nice GUI for displaying statistics.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用easy-metrics包来记录和显示我们的指标。它自带一个漂亮的GUI用于显示统计信息。
- en: We also import the decorator package and preface that import with a dot (.)
    in order to access the identifiers in the decorator package, in the local file
    block without a qualifier.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入装饰器包，并在本地文件块中使用点（.）作为前缀，以便在不使用限定符的情况下访问装饰器包中的标识符。
- en: The main.go file
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: main.go文件
- en: 'Let''s have a look at the contents of `main.go`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`main.go`的内容：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is what the imports looked like before using the init script and its aliases
    (and glide):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用init脚本及其别名（和glide）之前导入的样子：
- en: '`import (`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`import (`'
- en: '`. . .`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`. . .`'
- en: '`    "time"`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`"time"`'
- en: '`    "github.com/l3x/fp-in-go/chapter5/02_decorator/easy_metrics"`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`"github.com/l3x/fp-in-go/chapter5/02_decorator/easy_metrics"`'
- en: '`    . "github.com/l3x/fp-in-go/chapter5/02_decorator"`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`. "github.com/l3x/fp-in-go/chapter5/02_decorator"`'
- en: '`)`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`)`'
- en: I never liked long repository paths in my imports. I suppose it's time to give
    this technique a name. Let's call it **Keep It Simple Stupid-Glide** (**KISS-Glide**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我从来不喜欢在我的导入中使用长的存储库路径。我想现在是给这个技术起个名字的时候了。让我们称之为**保持简单愚蠢-滑翔**（**KISS-Glide**）。
- en: We define a host as a constant because we will always run this example code
    on our local workstation. We'll keep things simple and use the HTTP protocol (no
    SSL).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主机定义为常量，因为我们将始终在本地工作站上运行此示例代码。我们将保持简单，并使用HTTP协议（不使用SSL）。
- en: 'Our example uses a proxy server and also uses Go''s standard library HTTP server
    implementation to listen to handle requests:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用代理服务器，并且还使用Go的标准库HTTP服务器实现来监听处理请求：
- en: '![](img/1510e263-6b38-43eb-aab8-4c0b08598798.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1510e263-6b38-43eb-aab8-4c0b08598798.png)'
- en: 'Any function named `init()` will be executed before the `main()` function.
    We define default port numbers for our two servers and permit the user to specify
    different ports at runtime using the `flag` package, which implements command-line
    flag parsing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任何名为`init()`的函数都将在`main()`函数之前执行。我们为两个服务器定义默认端口号，并允许用户使用`flag`包在运行时指定不同的端口，该包实现了命令行标志解析：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll implement a simple logger that will:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个简单的记录器，它将：
- en: Provide log file tracing
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供日志文件跟踪
- en: Provide `Debug`, `Info`, and `Error` log levels
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供`Debug`、`Info`和`Error`日志级别
- en: Permit us to specify which log level(s) we want
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们指定我们想要的日志级别
- en: Enable us to more easily swap out our underlying logging framework
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们更容易地替换底层的日志框架
- en: The decorator/simple_log.go file
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器/simple_log.go文件
- en: 'Our logger leverages Go''s `Logger` package, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日志记录器利用了Go的`Logger`包，如下所示：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A simple logger exports one function, namely `InitLog`, which the calling package
    uses to enable the logging features:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的日志记录器导出一个函数，即`InitLog`，调用包使用它来启用日志记录功能：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example InitLog calls
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例InitLog调用
- en: 'Here we pass the name of our trace file, called `trace-log.txt`, which will
    receive all of the logging output. We don''t want `Debug` information, but we
    do want Info and Error output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递了我们的跟踪文件的名称，称为`trace-log.txt`，它将接收所有的日志输出。我们不需要`Debug`信息，但我们需要Info和Error输出：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This time we pass nil for the name of our trace log file, which tells our logger
    not to create a trace log file. We do want `Debug`, `Info`, and `Error` data displayed
    to standard out in our terminal console.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将跟踪日志文件的名称传递为nil，这告诉我们的日志记录器不要创建跟踪日志文件。我们确实希望在终端控制台上显示`Debug`、`Info`和`Error`数据。
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we specify `traceFileName`, we''ll need to create an `io.MultiWriter`
    interface to send the output to two places at the same time:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们指定`traceFileName`时，我们需要创建一个`io.MultiWriter`接口，同时将输出发送到两个位置：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We'll preface each log line with `DEBUG`, `INFO`, or `ERROR` to indicate its
    log level.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个日志行之前加上`DEBUG`、`INFO`或`ERROR`，以指示其日志级别。
- en: Back to our main package
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回到我们的主包
- en: 'The first line of our `main` block calls our `InitLog` function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`块的第一行调用了我们的`InitLog`函数：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use the `INFO` level to indicate which our server is listening.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`INFO`级别来指示我们的服务器正在侦听。
- en: 'We launch our server using a Goroutine, and since this is the `main()` function,
    we use the `log.Fatal` method, which is equivalent to `println` with a panic.
    This is because if we fail to start our server at this point, there are no buffers
    to flush, no outstanding defer statements, and no temporary files to process.
    We also wait for a second in order to give our server time to start:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Goroutine启动我们的服务器，由于这是`main()`函数，我们使用`log.Fatal`方法，它相当于带有panic的`println`。这是因为如果我们在这一点上未能启动我们的服务器，就没有缓冲区要刷新，没有未完成的延迟语句，也没有临时文件要处理。我们还等待1秒，以便给我们的服务器时间启动：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we declare our request using `req`, which we''ll later execute `NumRequests`
    times:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`req`声明了我们的请求，稍后将执行`NumRequests`次：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In our example, we use a proxy server to pass all our requests through. This
    gives us the flexibility to handle proxy-level processing on a per-call basis.
    Our simple example does no such processing, but we do specify a proxy timeout
    of 1 second:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用代理服务器来传递所有请求。这使我们能够处理每个调用的代理级处理。我们的简单示例不进行此类处理，但我们确实指定了1秒的代理超时：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our client uses the decorator pattern to wrap our `proxyTimeoutClient` client
    with the `Authorization`, `LoadBalancing`, `Logging`, and `FaultTolerance` functionality:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户端使用装饰器模式将我们的`proxyTimeoutClient`客户端与`Authorization`、`LoadBalancing`、`Logging`和`FaultTolerance`功能包装起来：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We do not modify our client implementation, rather extend its functionality
    (remember the open/close principle?):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不修改我们的客户端实现，而是扩展其功能（记得开闭原则吗？）：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a declarative form of programming. There is no code ceremony. We chain
    our function calls, passing only the minimally required information to configure
    its behavior.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种声明式的编程形式。没有代码仪式。我们链接我们的函数调用，只传递最少量的信息来配置其行为。
- en: 'To get the load balancing working locally, you can add the following line to
    your `/etc/hosts` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地使负载均衡工作，您可以将以下行添加到您的`/etc/hosts`文件中：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we define our job. We pass our client, request, the number of requests
    to process, and the time to wait before processing each request:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的作业。我们传递我们的客户端、请求、要处理的请求数以及在处理每个请求之前等待的时间：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In order to better comprehend the statistics, later in the easy-metrics web
    app, we'll set the `IntervalSecs` value to 10\. There will 10 seconds between
    each of our 10 request-processing attempts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解统计数据，在easy-metrics web应用程序中，我们将`IntervalSecs`值设置为10。每个10个请求处理尝试之间将间隔10秒。
- en: 'We set our start time and kick off our job processing with `job.Run()`. The
    `Run` function uses the `sync` package to wait until all the running jobs have
    completed before returning the control, at which time we print out how long the
    request-processing bit took:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了开始时间，并使用`job.Run()`启动了作业处理。`Run`函数使用`sync`包等待所有运行的作业完成后才返回控制权，此时我们打印出请求处理所花费的时间：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once our processing is complete, we call `DisplayResults` from the `easy_metrics`
    package, which displays a message like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的处理完成，我们就从`easy_metrics`包中调用`DisplayResults`，它会显示如下消息：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our server needs to keep running so that we can visit the easy-metrics URL to
    view our statistics with the user-friendly easy-metrics web app.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器需要保持运行，以便我们可以访问easy-metrics URL，使用用户友好的easy-metrics web应用程序查看我们的统计数据。
- en: 'We create a channel to capture the *Ctrl* + *C* key sequence, which will signal
    our program to stop:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个通道来捕获*Ctrl* + *C*键序列，这将信号我们的程序停止：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Understanding our statistics using the easy-metrics GUI
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用easy-metrics GUI理解我们的统计数据
- en: 'The next few screenshots will display our terminal console and our web browser
    at `http://127.0.0.1:3000/easy-metrics?show=Stats` immediately after executing
    Go''s `main.go` command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个屏幕截图将显示我们的终端控制台和我们的Web浏览器在执行Go的`main.go`命令后立即访问`http://127.0.0.1:3000/easy-metrics?show=Stats`：
- en: '![](img/82ea0d7d-2b0b-428a-adda-c83953238d38.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82ea0d7d-2b0b-428a-adda-c83953238d38.png)'
- en: In the following sections, we'll split this image into three parts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将把这个图像分成三个部分。
- en: Quick look at the Dot Init update
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速查看Dot Init更新
- en: 'This is what our terminal looks like using the KISS-Glide toolset:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用KISS-Glide工具集的终端外观：
- en: '![](img/f545f78a-c8e3-4a99-aeb1-03d9ba7f9f12.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f545f78a-c8e3-4a99-aeb1-03d9ba7f9f12.png)'
- en: KISS-Glide makes it simpler and requires less typing to achieve the same result.
    That's a win-win situation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: KISS-Glide使得实现相同结果更简单，打字更少。这是双赢的局面。
- en: When I originally wrote this chapter, I used the standard `go get`, `go build`, and `go
    run main.go` commands. As the projects became more complicated (requiring more
    third-party dependencies), I found it helpful to create the KISS-Glide tool. Later,
    I returned to all the projects and simplified them using the KISS-Glide tool.
    Feel free to use any dependency management tool and build and run your Go applications
    as you prefer. That's one of the great things about Go. As long as tool makers
    adhere to standard Go conventions, such as using the `GOPATH`, and not break other
    Go tools, such as `go test`, `go doc`, and `go vet`, it's all good. I prefer simple,
    yet powerful (KISS-Glide).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初写这一章时，我使用了标准的`go get`、`go build`和`go run main.go`命令。随着项目变得更加复杂（需要更多的第三方依赖），我发现创建KISS-Glide工具很有帮助。后来，我回到所有的项目中，使用KISS-Glide工具简化了它们。随意使用任何依赖管理工具，并按照自己的喜好构建和运行Go应用程序。这就是Go的伟大之处。只要工具制作者遵守标准的Go约定，比如使用`GOPATH`，并且不破坏其他Go工具，比如`go
    test`、`go doc`和`go vet`，就都没问题。我更喜欢简单而强大的（KISS-Glide）。
- en: Easy-metrics - 1 of 3
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Easy-metrics - 1 of 3
- en: 'This first screenshot is more about what we see in our terminal console than
    the easy-metrics GUI:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一张截图更多地展示了我们终端控制台中的内容，而不是easy-metrics GUI中的内容：
- en: '![](img/dc50e34b-e581-4b4b-aea3-76c947724d25.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc50e34b-e581-4b4b-aea3-76c947724d25.png)'
- en: 'The first two lines of output come from our `main.go` file. The next three
    lines come from this decorator: `Logging(log.New(InfoHandler, "client: ", log.Ltime)),`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '输出的前两行来自我们的`main.go`文件。接下来的三行来自这个装饰器：`Logging(log.New(InfoHandler, "client:
    ", log.Ltime)),`。'
- en: Each line is prefaced with either `INFO` or client. The `client` lines indicate
    an individual request attempt. The `INFO`lines indicate whether the initial request,
    which could have been tried twice, succeeded or failed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每行都以`INFO`或`client`开头。`client`行表示单个请求尝试。`INFO`行表示初始请求是否成功或失败（可能尝试了两次）。
- en: The decorator/decorator.go file
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器/decorator.go文件
- en: 'Let''s look at our `decorator.go` implementation. It''s in the `02_decorator`
    directory, and the package name is `decorator`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的`decorator.go`实现。它位于`02_decorator`目录中，包名为`decorator`：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `ClientFunc` function is a function type that implements the `Client` interface.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientFunc`函数是一个实现`Client`接口的函数类型。'
- en: 'We also define two additional methods that act as the getter and setter for
    the `ratelimitDuration` value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了两个额外的方法，作为`ratelimitDuration`值的getter和setter：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we define the `Decorator` function type to wrap our  `Client` with additional
    behavior:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`Decorator`函数类型来包装我们的`Client`以添加额外的行为：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A framework to inject dependencies
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个注入依赖的框架
- en: Next, we'll look closer at the implementation of our IoC container framework.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更仔细地看一下我们的IoC容器框架的实现。
- en: We'll see that by wrapping decorators, which implement the `Client` interface,
    around our core client call and using the decorator pattern, our framework is
    able to extend our application functionality in a modular and easy-to-understand
    manner.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，通过在核心客户端调用周围包装实现`Client`接口的装饰器，并使用装饰器模式，我们的框架能够以一种模块化和易于理解的方式扩展我们的应用功能。
- en: The `Decorator` notation indicates that this is a variadic parameter that can
    take any number of values. Remember our call in `main` where we passed in our
    decorators?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decorator`表示这是一个可变参数，可以接受任意数量的值。还记得我们在`main`中传入装饰器的调用吗？'
- en: Wrapping a client request with decorators (in main)
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用装饰器包装客户端请求（在主函数中）
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our `Decorate` function extends our client's functionality by iterating over
    each decorator in order.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Decorate`函数通过迭代每个装饰器来扩展我们客户端的功能。
- en: 'Note that there are several ways to implement this wrapping functionality.
    We could have used recursion, line-by-line wrapping, or inline wrapping like we
    did earlier in this chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有几种方法可以实现这种包装功能。我们可以使用递归、逐行包装或者像本章前面所做的那样使用内联包装：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using a variadic parameter in conjunction with a range construct, when we are
    unsure of the number of decorators we need to wrap, is probably the best choice:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在不确定需要包装的装饰器数量时，使用可变参数结合range结构可能是最好的选择：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Authorization decorator
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 授权装饰器
- en: 'Our first decorator is `Authorization`. We call the `Header` helper function
    that adds the `Authorization` header with the given token to each request at runtime:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个装饰器是`Authorization`。我们调用`Header`辅助函数，在运行时为每个请求添加带有给定令牌的`Authorization`标头：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Logging decorator
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志装饰器
- en: 'The `Logging` decorator takes a pointer to the log from the `Logger` package,
    from Go''s standard library. Note that we are able to pass our custom `InfoHandler`
    since we chose to implement it using the `io.Writer` interface:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logging`装饰器接受来自Go标准库中的`Logger`包的日志指针。请注意，我们能够传递我们自定义的`InfoHandler`，因为我们选择使用`io.Writer`接口来实现它：'
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We execute the `Printf` command just before running the client's `Do` method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在运行客户端的`Do`方法之前执行`Printf`命令。
- en: LoadBalancing decorator
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 负载均衡装饰器
- en: We leverage the strategy pattern to implement our load balancing decorator.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用策略模式来实现我们的负载均衡装饰器。
- en: The `LoadBalancing` decorator applies the strategy pattern to apply the logic
    that determines which backend server will receive the next incoming client request.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancing`装饰器应用了策略模式来应用决定哪个后端服务器将接收下一个传入的客户端请求的逻辑。'
- en: Strategy pattern
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 策略模式
- en: 'The strategy pattern uses composition rather than inheritance to choose which
    behavior is executed. The behavior in our example implements a load balancing
    algorithm. Production implementations of the strategy pattern often have an administrative
    application that is used to choose which strategy it selected during runtime:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式使用组合而不是继承来选择执行哪种行为。我们示例中的行为实现了一个负载均衡算法。策略模式的生产实现通常有一个管理应用程序，在运行时用于选择选择了哪种策略。
- en: '![](img/c57721b9-cc68-4e21-aad5-c27ef7b2e134.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c57721b9-cc68-4e21-aad5-c27ef7b2e134.png)'
- en: Rather than using the context of the request or configuration instructions from
    an administrative application to selecting our load balancing strategy, we hardcode
    our example to use the `RoundRobin` behavior.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用请求或来自管理应用程序的配置指令的上下文来选择我们的负载均衡策略不同，我们将我们的示例硬编码为使用`RoundRobin`行为。
- en: 'Here''s the call:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first parameter, `RoundRobin`, is the selected strategy. We pass the `RoundRobin`
    function We pass the iterating `RoundRobin` function in order over the backend
    server's host addresses. They are passed over the variadic parameter, namely backends.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`RoundRobin`是所选的策略。我们传递`RoundRobin`函数，以便按顺序传递给后端服务器的主机地址。它们通过可变参数backends传递。
- en: 'Instead of using a request to gather context to determine the strategy to employ,
    we define a `Director` function type that takes the request. We select the `RoundRobin`
    strategy and modify the request''s embedded URL member to specify the server to
    connect to:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用请求来收集上下文以确定要使用的策略，而是定义了一个接受请求的`Director`函数类型。我们选择了`RoundRobin`策略，并修改了请求的嵌入式URL成员以指定要连接的服务器：
- en: '![](img/336ad8ee-8536-4859-88dc-19feef128350.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/336ad8ee-8536-4859-88dc-19feef128350.png)'
- en: 'The following is the `RoundRobin` function where we make the `r.URL.Host` assignment:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`RoundRobin`函数，我们在其中进行`r.URL.Host`的赋值：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Alternatively, if we had defined other load balancing strategies, such as **Least
    Loaded** or **Random**, we'd only need to implement that function and pass it
    to our `LoadBalancing` function as its director.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们定义了其他负载均衡策略，比如**最小负载**或**随机**，我们只需要实现该函数并将其传递给我们的`LoadBalancing`函数作为其指导者。
- en: 'The `LoadBalancing` function returns a decorator that spreads client requests
    across multiple backend servers, based on the given director, that is, `RoundRobin`
    in our example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadBalancing`函数返回一个装饰器，根据给定的指导者（例如我们的例子中的`RoundRobin`）将客户端请求分布到多个后端服务器上：'
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `Director` modifies each HTTP request to follow the chosen load balancing
    strategy:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Director`修改每个HTTP请求以遵循所选的负载均衡策略：'
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we have our `FaultTolerance` decorator that extends a client with
    fault tolerance, based on the given attempts and backoff time duration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`FaultTolerance`装饰器，根据给定的尝试次数和退避时间持续时间，扩展了客户端的容错能力：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We only want the `backing off` information output to our trace file, so we use
    our `Debug.Println` function.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只希望将`backing off`信息输出到我们的跟踪文件中，因此我们使用我们的`Debug.Println`函数。
- en: Notice what each decorator has in common? They provide additional functionality
    and eventually call `c.Do(r)`. Some provide the additional functionality before
    calling `c.Do(r)`; some could do it before and after the call.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个装饰器有什么共同之处？它们提供额外的功能，并最终调用`c.Do(r)`。有些在调用`c.Do(r)`之前提供额外的功能；有些可能在调用之前和之后都这样做。
- en: Inversion of control and dependency injection
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制反转和依赖注入
- en: This is a form **Dependency Injection** (**DI**). DI is where a service; for
    example, `FaultTolerance`, is passed to a dependent object--for instance, the
    client--where it is used.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种**依赖注入**（**DI**）的形式。DI是指将一个服务（例如`FaultTolerance`）传递给一个依赖对象，例如客户端，在那里使用它。
- en: This can also be considered **Inversion of Control** (**IoC**)  (DI is a subset
    of IoC). It's the director function that we pass into the `LoadBalancing` function
    that provides the flow of control. This determines which backend server to direct
    the request to.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以被认为是**控制反转**（**IoC**）（DI是IoC的一个子集）。我们传递给`LoadBalancing`函数的指导函数提供了控制流。这决定了将请求定向到哪个后端服务器。
- en: IoC is a design principle where a framework determines the flow of control.
    Contrast that to procedural programming, where the custom code determines the
    application's flow of control in a predetermined manner.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: IoC是一个设计原则，其中框架确定控制流。与过程式编程相对，过程式编程中自定义代码以预定的方式确定应用程序的控制流。
- en: Our first failure
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 我们的第一次失败
- en: 'Our first failure consisted of three requests:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一次失败包括三个请求：
- en: '![](img/751abca4-5784-4272-bac2-69184f0733c7.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/751abca4-5784-4272-bac2-69184f0733c7.png)'
- en: Easy metrics - 2 of 3
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Easy metrics - 2 of 3
- en: 'Our easy-metrics graph shows when the requests occurred and their average response
    time:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的easy-metrics图显示了请求发生的时间以及它们的平均响应时间：
- en: '![](img/c9af36f3-1262-457e-b1e1-bcceb669e0f2.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9af36f3-1262-457e-b1e1-bcceb669e0f2.png)'
- en: When you open the easy-metrics web application, move your mouse pointer over
    the lines for more context information. For example, when you move your mouse
    where the red arrow is pointing in the preceding screenshot, you'll see that another
    request occurred at that point.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开easy-metrics web应用程序时，将鼠标指针移动到行上以获取更多上下文信息。例如，当您将鼠标移动到前面截图中红色箭头指向的位置时，您会看到在那个点发生了另一个请求。
- en: Groking our trace log file
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groking我们的跟踪日志文件
- en: In order to get a deeper understanding of why our attempts failed, we can look
    in our trace file.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解我们的尝试失败的原因，我们可以查看我们的跟踪文件。
- en: 'Groking is an old Scots term meaning to look at somebody while they''re eating
    in the hope that they''ll give you some of their food. In our case, we''ll be
    looking intently at a trace log file in hope of getting some morsel of understanding:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Groking是一个古老的苏格兰术语，意思是看着别人吃饭，希望他们会给你一些食物。在我们的情况下，我们将专注地查看跟踪日志文件，希望能够获得一些理解的线索：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here''s the call to our call to the `FaultTolerance` function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对`FaultTolerance`函数的调用：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The key lines from our `FaultTolerance` decorator are as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FaultTolerance`装饰器的关键行如下：
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This indicates that if we don't succeed at first, we'll try again twice and
    wait for a second between each attempt.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，如果我们第一次失败，我们将再尝试两次，并在每次尝试之间等待一秒钟。
- en: 'The work is performed in the `metrics.go` file. Note that work can take anywhere
    from 0 to 5,000 milliseconds:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 工作是在`metrics.go`文件中执行的。请注意，工作可能需要0到5000毫秒不等：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Lastly, recall that we set our per request timeout to 1 second when we defined
    `proxyTimeoutClient`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，回想一下，当我们定义`proxyTimeoutClient`时，我们将每个请求的超时时间设置为1秒：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We tried thrice and none of our attempts took less than a second, so our first
    set of requests resulted in a failure.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了三次，没有一次尝试少于一秒，所以我们的第一组请求失败了。
- en: The rest of the graph
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 图的其余部分
- en: 'The rest of the graph shows multiple requests. We''ll focus on the following
    two:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图的其余部分显示了多个请求。我们将关注以下两个：
- en: '![](img/b51e53c3-9447-4543-96e8-67ed2f58dd6b.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b51e53c3-9447-4543-96e8-67ed2f58dd6b.png)'
- en: Notice that in the first set of requests, in green, we made three attempts.
    Note also, in red, the requests were load-balanced, in a round-robin manner, among `web03`,
    `web01`, and `web02`. `INFO` indicates a `FAILURE!`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一组请求中，以绿色显示，我们进行了三次尝试。还要注意，在红色显示的请求中，请求是在`web03`、`web01`和`web02`之间以循环方式进行负载平衡的。`INFO`表示`FAILURE!`。
- en: The first request of the next set of requests began 10 seconds later and was
    sent to the `web03` backend server. `INFO` indicates `SUCCESS!`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组请求的第一个请求在10秒后开始，并发送到`web03`后端服务器。`INFO`表示`SUCCESS!`
- en: Easy metrics - 3 of 3
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简单的指标-3/3
- en: 'We can see the `FAILURE!` and `SUCCESS!` requests in the following easy-metrics
    graph:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下easy-metrics图中看到`FAILURE!`和`SUCCESS!`请求：
- en: '![](img/4fa3b422-3f1d-47a5-9110-25cbbdf54183.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fa3b422-3f1d-47a5-9110-25cbbdf54183.png)'
- en: Examining the trace log
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查跟踪日志
- en: Similar to the failed attempts we saw earlier, none of the three requests were
    performed in under a second. Thus, they failed.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的失败尝试类似，三个请求都没有在一秒内完成。因此，它们失败了。
- en: 'However, the next request will take only 0.495 seconds and it will immediately
    succeed:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一个请求将只花费0.495秒，并且将立即成功：
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The last thing to observe in this trace output are the two lines that indicate
    how many requests have been performed:`> 8 requests done`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在此跟踪输出中要观察的最后一件事是指示已执行多少请求的两行：`> 8 requests done`。
- en: Since this is `DEBUG` output, we don't need to guess which file and line this
    output came from.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是`DEBUG`输出，我们不需要猜测这个输出来自哪个文件和行。
- en: The decorator/requestor.go file
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰器/requestor.go文件
- en: 'The `DEBUG` output leads us to our last go source file, namely `requestor.go`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEBUG`输出将我们带到最后一个go源文件，即`requestor.go`：'
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The response struct is used to record the duration and any error from running
    our request. When we capitalize names of symbols, for example, the "J" in our
    struct named `Job` in the following code, we are telling Go to export it. When
    we import a package we will only be able to access exported symbols.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 响应结构用于记录运行我们的请求的持续时间和任何错误。当我们大写符号的名称时，例如以下代码中名为`Job`的结构中的“J”，我们告诉Go导出它。当我们导入一个包时，我们只能访问导出的符号。
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The private field, `responses`, is a channel of response pointers with a buffer
    that has a size equal to `NumRequests`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段`responses`是一个响应指针的通道，其缓冲区大小等于`NumRequests`。
- en: The job variable declared  in main()
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在main()中声明的job变量
- en: 'It begins with a capital `J` to export it. We use it in our main function to
    declare the total number of requests we want to run as well as how long to wait
    between making each request:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它以大写的`J`开头以进行导出。我们在主函数中使用它来声明我们要运行的总请求数，以及每个请求之间的等待时间：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Back to the requestor.go file
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回到requestor.go文件
- en: 'After the Job struct definition comes the `displayProgress` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Job`结构定义之后是`displayProgress`方法：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Every 500 milliseconds, `displayProgress` checks to see whether a new response
    has been processed. It does this by checking the size of the job''s response channel.
    If it finds a new response, it prints out a line like the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每500毫秒，`displayProgress`检查是否已处理新的响应。它通过检查作业的响应通道的大小来实现。如果找到新的响应，它会打印出类似以下的一行：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It will continue to loop until a value is received on the `stopChan` channel.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续循环，直到在`stopChan`通道上收到一个值。
- en: Using channels to manage the life cycle
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用通道管理生命周期
- en: 'We use three channels to manage the life cycle of our requestor component:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用三个通道来管理我们请求器组件的生命周期：
- en: '`responseChan chan *response`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`responseChan chan *response`'
- en: '`stopChan chan struct{}`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stopChan chan struct{}`'
- en: '`interruptChan := make(chan os.Signal, 1)`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interruptChan := make(chan os.Signal, 1)`'
- en: Every 5,000 milliseconds, we check `responseChan` to see whether we've received
    a new response. If so, we print a message indicating that the request is completed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每5000毫秒，我们检查`responseChan`，看看是否收到了新的响应。如果是，我们打印一条消息，指示请求已完成。
- en: First, `stopChan` is used to stop the running of the `displayProgress` function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`stopChan`用于停止运行`displayProgress`函数。
- en: Then, `interruptChan` is used to signal everything to shut down when the user
    presses *Ctrl* + *C*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当用户按下*Ctrl* + *C*时，使用`interruptChan`来发出关闭一切的信号。
- en: 'The `Run` method of `Job` makes all the requests, displays summary results,
    and blocks until all responses are received:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`Job`的`Run`方法执行所有请求，显示摘要结果，并阻塞直到收到所有响应：'
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We start by creating `responseChan` as a buffered channel with a size equal
    to the number of requests to process. Next, we create `stopChan` as a channel
    of empty structs. We use the empty struct because it takes up no space. We've
    seen in `displayProgress` that we are not concerned with the value in the channel.
    As long as anything, even the empty struct, is received on `stopChan`, that's
    enough to signal that it's time to stop processing. We launch`j.displayProgress(stopChan)`
    as a Goroutine.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`responseChan`创建为一个带有与要处理的请求数相等的大小的缓冲通道。接下来，我们将`stopChan`创建为一个空结构体的通道。我们使用空结构体是因为它不占用空间。我们在`displayProgress`中看到，我们不关心通道中的值。只要接收到`stopChan`上的任何东西，即使是空结构体，都足以表示是时候停止处理了。我们启动`j.displayProgress(stopChan)`作为一个Goroutine。
- en: 'We create `interruptChan` in a way it is unbuffered (with a size of 1). Since
    we want to catch `SIGTERM`, which is the default signal sent by the kill command
    (*Ctrl* + *C*), and since we wish this to work for both Unix and Windows systems,
    we use `syscall.SIGTERM` as the third parameter to `signal.Notify`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以无缓冲的方式创建`interruptChan`（大小为1）。因为我们想要捕获`SIGTERM`，这是`kill`命令发送的默认信号（*Ctrl*
    + *C*），并且我们希望它适用于Unix和Windows系统，所以我们使用`syscall.SIGTERM`作为`signal.Notify`的第三个参数：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Our Goroutine blocks wait for a signal from `interruptChan`. If one is received,
    it will send an empty struct instance to `stopChan` and then close `j.responseChan`
    and finally run `os.Exit(130)`, indicating a fatal error caused by *Ctrl* + *C*.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Goroutine阻塞等待来自`interruptChan`的信号。如果收到信号，它将向`stopChan`发送一个空的结构实例，然后关闭`j.responseChan`，最后运行`os.Exit(130)`，表示由*Ctrl*
    + *C*引起的致命错误。
- en: 'For every `intervalSecs`, we add 1 to `WaitGroup` and launch the next request.
    Once we''ve iterated `j.NumRequests` times, we break out of our loop and run `wg.Wait()`.
    This blocks until all the requests have completed processing. Note that the last
    line of each request-processing Goroutine is the `wg.Done()` function, which is
    used to decrements the `WaitGroup` counter:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔`intervalSecs`，我们向`WaitGroup`添加1并启动下一个请求。一旦我们迭代了`j.NumRequests`次，我们就跳出循环并运行`wg.Wait()`。这会阻塞，直到所有请求都完成处理。请注意，每个请求处理的Goroutine的最后一行是`wg.Done()`函数，用于减少`WaitGroup`计数器：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All requests done
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 所有请求完成
- en: 'When the `WaitGroup` counter reaches zero, `wg.Wait()` is unblocked and the
    processing continues to the next line, where we pass an instance of the empty
    struct to `stopChan`. As we''ve seen previously, `stopChan` signals to the `displayProgress`
    method of `Job` to stop processing:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当`WaitGroup`计数器达到零时，`wg.Wait()`解除阻塞，处理继续到下一行，在那里我们将空结构的实例传递给`stopChan`。正如我们之前看到的那样，`stopChan`向`Job`的`displayProgress`方法发出信号停止处理：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Lastly, we use our `Debug` logger to print `All requests done.` and close `responseChan` of `Job`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用我们的`Debug`记录器打印`All requests done.`并关闭`Job`的`responseChan`。
- en: Launching our makeRequest goroutine
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动我们的makeRequest协程
- en: 'Our `Run` method launches a Goroutine `j.NumRequests` times. Each Goroutine
    runs this code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Run`方法启动了`j.NumRequests`次Goroutine。每个Goroutine运行以下代码：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `makeRequest` function is called in a goroutine and passed to the client.
    We use our `Debug` logger to indicate that we are about to make a request and
    record the start time:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRequest`函数在一个goroutine中被调用并传递给客户端。我们使用我们的`Debug`记录器指示我们即将发出请求并记录开始时间：'
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The key line is `resp, err := c.Do(j.Request)`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关键行是`resp, err := c.Do(j.Request)`。
- en: Our DI framework in action
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们的DI框架在运行中
- en: 'This is when we actually perform the request. This is when all the decorators
    are executed:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们实际执行请求的时候。这是所有装饰器被执行的时候：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The decorators are executed in order. `Authorization` goes first, followed by
    `LoadBalancing`, `Logging`, and `FaultTolerance`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器按顺序执行。`Authorization`首先执行，然后是`LoadBalancing`，`Logging`和`FaultTolerance`。
- en: 'We create our IoC framework by defining the client interface with a single
    `Do` method:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义具有单个`Do`方法的客户端接口来创建我们的IoC框架：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Wrap each decorator around a return `c.Do(r)` statement that fires once the
    following line is executed in the `makeRequest` method of `Job`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个装饰器包装在一个返回`c.Do(r)`语句周围，该语句在`Job`的`makeRequest`方法中执行以下行后触发：
- en: '[PRE70]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We created a simple framework for controlling the execution and enriching each
    HTTP request with our decorators wrapped around the client interface. This is
    IoC, and as we see, it's not too complicated.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的框架来控制执行并使用装饰器包装客户端接口的每个HTTP请求。这就是IoC，正如我们所看到的，它并不太复杂。
- en: '![](img/3b327730-dfb9-41d6-b2e5-617baead5fd6.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b327730-dfb9-41d6-b2e5-617baead5fd6.png)'
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how no design or bad design using type hierarchies can
    lead to technical debt. We studied the decorator pattern and learned a great way
    to extend the functionality of our application using IoC.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了没有设计或糟糕的设计使用类型层次结构可能导致技术债务。我们学习了装饰器模式，并学会了使用IoC来扩展应用程序功能的好方法。
- en: We saw multiple examples of single method interfaces and learned to appreciate
    the fact that less is more and that good design is worthwhile.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了多个单方法接口的示例，并学会了欣赏少即是多以及良好设计是值得的这一事实。
- en: Hopefully, by the end of this chapter, we can all agree that we can leverage
    design patterns to write better Go code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在本章结束时，我们都能同意我们可以利用设计模式来编写更好的Go代码。
- en: In our next chapter, we'll use the adapter design pattern and other functional
    programming techniques to design and build better APIs.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用适配器设计模式和其他函数式编程技术来设计和构建更好的API。
