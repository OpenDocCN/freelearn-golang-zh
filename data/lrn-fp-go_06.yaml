- en: Applying FP at the Architectural Level
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在架构级别应用FP
- en: Most Functional programming (FP) books only talk about the code level benefits
    but FP principles provide better returns when applied at the architecture level.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数式编程（FP）书籍只谈论代码级别的好处，但是在架构级别应用FP原则会带来更好的回报。
- en: In this chapter, we will discuss some architectural styles that are based on
    the same ideas and philosophies of FP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些基于FP相同思想和理念的架构风格。
- en: We'll also build a layered application that solves the problem of circular dependencies
    with the aid of Inversion of Control (IoC) to control the flow of logic. The application we
    build allows an admin to move files between two cloud storage service provider
    accounts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将构建一个分层应用程序，通过控制反转（IoC）来解决循环依赖的问题，以控制逻辑流程。我们构建的应用程序允许管理员在两个云存储服务提供商帐户之间移动文件。
- en: 'Our goals in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: Understand the basics of systems engineering and application architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解系统工程和应用架构的基础知识
- en: Discuss architecture styles that carry the same ideas of FP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论承载FP相同思想的架构风格
- en: Prevent cyclic dependency errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止循环依赖错误
- en: Understand how to apply the Hollywood Principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何应用好莱坞原则
- en: Learn the difference between the observer pattern and dependency injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解观察者模式和依赖注入之间的区别
- en: Use IoC to control the flow of logic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IoC来控制逻辑流程
- en: Build a layered application  architecture
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建分层应用程序架构
- en: Create an effective table-driven framework to test our API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个有效的表驱动框架来测试我们的API
- en: Discuss where FP and Go fit into microservice architectures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论FP和Go如何适用于微服务架构
- en: Application architectures
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序架构
- en: Four years ago, I posted an article entitled *Application Architecture Considerations*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 四年前，我发表了一篇名为*应用架构考虑*的文章。
- en: 'Consider the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表：
- en: '![](img/5df67aaa-0d02-420a-bdfd-7501dc11430a.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5df67aaa-0d02-420a-bdfd-7501dc11430a.png)'
- en: I had talked about things to consider when evaluating an application's architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾谈到评估应用程序架构时要考虑的事项。
- en: For a list of things to consider when designing an application architecture,
    see [http://lexsheehan.blogspot.com/2013/05/application-architecture-considerations.html](http://lexsheehan.blogspot.com/2013/05/application-architecture-considerations.html).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设计应用程序架构时要考虑的事项清单，请参阅[http://lexsheehan.blogspot.com/2013/05/application-architecture-considerations.html](http://lexsheehan.blogspot.com/2013/05/application-architecture-considerations.html)。
- en: 'Some of these things are listed as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些列出的事项：
- en: '**Functionality**: Does the application satisfy its business requirements?'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性**：应用程序是否满足其业务需求？'
- en: '**Performance**: Does the application run fast enough? For example, if there
    are any views that take longer than 7 seconds to display, then you need to re-engineer
    something.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：应用程序运行速度是否足够快？例如，如果有任何视图显示时间超过7秒，那么您需要重新设计某些东西。'
- en: '**Scalability**: How well does your application scale? Can you easily add and
    remove components without affecting your application''s performance or reliability?
    How loosely (or tightly) coupled is your application code?'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：您的应用程序的扩展性如何？您能否轻松添加和删除组件而不影响应用程序的性能或可靠性？您的应用程序代码有多松散（或紧密）耦合？'
- en: It was all high level, mainly discussing nonfunctional requirements and cross-cutting
    concerns, for example, security, error handling, and logging.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是高层次的讨论，主要涉及非功能性需求和横切关注点，例如安全性、错误处理和日志记录。
- en: If you are only interested in pure functional programming techniques, you can
    safely skip this chapter. However, if you want to build an application framework
    in which you can place pure function programming components, this will be a good
    chapter for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对纯函数式编程技术感兴趣，可以放心跳过本章。但是，如果您想构建一个应用程序框架，其中可以放置纯函数式编程组件，那么这将是一个很好的章节。
- en: What is software architecture?
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是软件架构？
- en: Designing software architecture is the process of defining a structured solution
    to address our application's user, business, and system requirements. In each
    case, we must ask, "*What do you need?*" that is, the requirements, and "*Why
    do you need it?*" and document our understanding in a way that the business stakeholders
    understand. Finally, we must implement the "*How?*"*:*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设计软件架构是定义一个结构化解决方案来满足我们应用程序的用户、业务和系统需求的过程。在每种情况下，我们必须问，“*你需要什么？*”即需求，“*你为什么需要它？*”并以业务利益相关者理解的方式记录我们的理解。最后，我们必须实施“*如何？*”：
- en: '![](img/29ed662c-f1e7-4ba5-89ee-cb545092e2bc.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29ed662c-f1e7-4ba5-89ee-cb545092e2bc.png)'
- en: The art of software architecture lies in the ability to understand what is important,
    to make the key decisions in structuring application components and their interfaces,
    and to make the right decisions regarding things that are hard to change.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构的艺术在于理解什么是重要的，做出关于构建应用程序组件及其接口的关键决策，并对难以更改的事物做出正确的决策。
- en: Whereas the *Application Architecture Considerations *article focused mainly
    on the "*What?*", this chapter focuses on the "*How?*" using Go.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 而*应用架构考虑*文章主要关注“*什么？*”，本章则着重于使用Go语言的“*如何？*”。
- en: Client-server architecture
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端-服务器架构
- en: 'The client-server model could be implemented as shown in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器模型可以按照以下图表实现：
- en: '![](img/2ba1004c-b858-4403-a165-bb79ef3c1b4d.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ba1004c-b858-4403-a165-bb79ef3c1b4d.png)'
- en: In our example, the client goes through a load balancer to talk to an application
    server's API. Each application server uses a database API client to interact with
    the database. The small, unlabeled boxes represent an API client. Some clients
    communicate directly to their server, for example, our database client. Others,
    like our application server client, go through intermediaries that provide services,
    for example, load balancing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，客户通过负载均衡器与应用程序服务器的API通信。每个应用程序服务器使用数据库API客户端与数据库进行交互。小的、未标记的方框代表API客户端。有些客户端直接与其服务器通信，例如我们的数据库客户端。其他客户端，如我们的应用程序服务器客户端，通过提供服务的中介进行通信，例如负载均衡。
- en: Cloud architecture
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云架构
- en: APIs expose the functions that are available and define the requirements that
    govern how applications or services can talk to each other.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: API公开了可用的功能，并定义了应用程序或服务之间如何通信的要求。
- en: 'As we move into cloud-based architectures, our systems begin to look more like
    this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进入基于云的架构，我们的系统开始看起来更像这样：
- en: '![](img/0951a5ea-bd78-4cb4-9898-06ed4ba89f67.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0951a5ea-bd78-4cb4-9898-06ed4ba89f67.png)'
- en: What do both the client/server and cloud architectures have most in common?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端/服务器和云架构最常见的共同点是什么？
- en: See all the APIs that expose the functionality of the underlying resources?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 看看所有公开底层资源功能的API？
- en: Go is well suited for server-side applications, that is, everything in the virtual
    network (the big gray box). That's pretty much the entire cloud infrastructure
    and everything running within it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Go非常适合服务器端应用程序，也就是虚拟网络中的一切（大灰色框）。这几乎涵盖了整个云基础架构和其中运行的所有内容。
- en: That's great for the big picture, but what about building applications? How
    much do APIs come into play when building an individual Go application?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于整体来说很好，但是构建应用程序呢？在构建单个Go应用程序时，API有多大作用？
- en: It depends. Are we talking about a small utility application or an enterprise
    CRM application?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于。我们是在谈论小型实用程序还是企业CRM应用程序？
- en: The interface to a small utility application can simply be defined by the command-line
    parameters that it accepts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 小型实用程序的界面可以简单地通过它接受的命令行参数来定义。
- en: Large **customer relationship management** (**CRM**) applications will be composed
    of layers of functionality, not unlike the virtual network diagram we saw earlier.
    For example, the opportunity management system will need an API to the quote generation
    and electronic signatures components. The service and provisioning system will
    need API access to the billing and invoicing system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 大型客户关系管理（CRM）应用程序将由多层功能组成，与之前看到的虚拟网络图类似。例如，机会管理系统将需要与报价生成和电子签名组件的API进行交互。服务和供应系统将需要API访问计费和发票系统。
- en: If we intend to build large, complex applications, we must put effort into architecting
    our solutions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打算构建大型、复杂的应用程序，我们必须努力设计我们的解决方案。
- en: Why does architecture matter?
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构为什么重要？
- en: Much like large buildings, complex software applications must be built on a
    solid foundation. In software, we sometimes call this our application framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大型建筑物一样，复杂的软件应用程序必须建立在坚实的基础上。在软件中，我们有时称之为应用程序框架。
- en: If we do not consider the things mentioned in my article; things like functionality,
    security, extensibility, testability, and performance, then we will likely be
    unprepared for the consequences of our lack of forethought.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不考虑我文章中提到的功能、安全性、可扩展性、可测试性和性能等因素，那么我们可能会对我们缺乏预见的后果毫无准备。
- en: Our exposure to risk will increase as we find our application becomes more costly
    to test, deploy, and maintain over time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们的应用程序变得更加昂贵，测试、部署和维护的成本也会增加，我们面临的风险也会增加。
- en: Design takes some time and effort, but it does not take long before that effort
    pays off.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设计需要一些时间和精力，但不久之后这些努力就会得到回报。
- en: The role of systems engineering
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统工程的角色
- en: Systems engineering is a discipline that focuses on the design and application
    of the whole  system, which may be comprised of many parts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 系统工程是一门专注于整个系统的设计和应用的学科，该系统可能由许多部分组成。
- en: Real systems
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实系统
- en: 'A real system includes things like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 真实系统包括诸如：
- en: Products
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Processes
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程
- en: People
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人员
- en: Information
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息
- en: Techniques
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术
- en: Resources
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源
- en: Services
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: IT system specialty groups
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IT系统专业组
- en: 'Systems engineering focuses on identifying requirements early in the development
     life cycle. It considers the entire problem space. Taking all aspects and variables
    into account and relating the social to the technical aspects. Then it  proceeds
    with design synthesis, integrating  all the specialty groups such as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 系统工程专注于在开发生命周期的早期识别需求。它考虑整个问题空间。考虑所有方面和变量，并将社会与技术方面联系起来。然后进行设计综合，整合所有专业组，如：
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Cost
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本
- en: Development
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发
- en: Disposal
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处置
- en: Manufacturing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制造
- en: Operations
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运营
- en: Performance
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: Process Improvement
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程改进
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Risk Assessment
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险评估
- en: Schedule
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间表
- en: Support
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持
- en: Test
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Training
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 培训
- en: Verification
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: '|'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Into a team effort in a structured development process that proceeds from concept,
    design synthesis, validation, deployment to production and operation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个团队努力的结构化开发过程，从概念、设计综合、验证、部署到生产和运营。
- en: Systems engineering is lean
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统工程是精益的
- en: Systems engineering is all about creating more value for our customer with fewer
    resources.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 系统工程的目标是用更少的资源为我们的客户创造更多的价值。
- en: A lean IT department understands its customer’s business and what  customer
    value means and focuses its efforts to continuously increase it. The goal is to
    provide maximum value to the customer through a perfect value creation process
    that has zero waste.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 精简的IT部门了解其客户的业务以及客户价值意味着什么，并专注于不断增加价值。目标是通过完美的价值创造过程为客户提供最大价值，而且没有浪费。
- en: 'For example, if your customer sells chicken to consumers, then every new project
    must start with this question: Will this project help our customer sell more chicken?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的客户向消费者销售鸡肉，那么每个新项目都必须从这个问题开始：这个项目是否能帮助我们的客户销售更多的鸡肉？
- en: To accomplish this, lean thinking changes the focus of management from optimizing
    separate technologies, and vertical departments to optimizing the flow of products
    and services through entire value streams that flow horizontally across technologies
    and departments to customers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，精益思维将管理的重点从优化单独的技术和垂直部门转变为优化产品和服务通过整个价值流水线的流动，这些价值流水线横跨技术和部门，流向客户。
- en: Eliminating waste along entire value streams, instead of at isolated points,
    creates processes that requires less human effort, less capital, and less time
    to make products and services at far less costs and with much fewer defects, compared
    with traditional business systems. Lean companies are able to respond to changing
    customer desires with high variety, high quality, low cost, and with fast throughput
    times. Information management becomes simpler and more accurate.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 消除整个价值流水线上的浪费，而不是在孤立的点上，创造出需要更少的人力、更少的资本和更少的时间来制造产品和服务的流程，成本要远低于传统的商业系统，并且缺陷要少得多。精益公司能够以高品种、高质量、低成本和快速的吞吐时间来响应不断变化的客户需求。信息管理变得更简单和更准确。
- en: Requirements, scope and terms
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要求、范围和术语
- en: Everytime we develop software, we address both the business and technical needs
    of our customer with the goal of providing a quality product that meets our users’
    needs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们开发软件时，我们都要满足客户的业务和技术需求，目标是提供满足用户需求的高质量产品。
- en: Some requirements are task-specific. For example, if we are required to write
    a script to move a specific log file from one server to another. Other times,
    we need may be required to write a command line input tool to parse the text a
    user types in their console input and count the characters, words, or lines they
    entered. This chapter is not about those types of applications. We'll consider
    system-level requirements only in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一些要求是特定于任务的。例如，如果我们需要编写一个脚本将特定的日志文件从一个服务器移动到另一个服务器。其他时候，我们可能需要编写一个命令行输入工具，解析用户在控制台输入的文本并计算他们输入的字符、单词或行数。本章不涉及这些类型的应用程序。本章只考虑系统级要求。
- en: Defining terms
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义术语
- en: Let’s start by defining a few terms.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一些术语开始。
- en: Software requirements
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 软件要求
- en: Conditions or capabilities needed by our customer to achieve an objective/solve
    problem(s).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户需要实现目标/解决问题的条件或能力。
- en: System
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 系统
- en: An integrated set of subsystems and/or elements that accomplish a defined objective.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 实现定义目标的一组集成子系统和/或元素。
- en: System architecture
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 系统架构
- en: The fundamental properties of a system in its environment embodied in its subsystems,
    elements, relationships along with the principles of its design and evolution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在其环境中体现的基本属性，包括其子系统、元素、关系以及其设计和演变的原则。
- en: System elements
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 系统元素
- en: '**Atomic**: elements that cannot to be broken down further'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原子：不能进一步分解的元素
- en: '**Decomposable**: elements that can to be broken into smaller elements'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可分解的：可以分解为更小的元素
- en: System Boundaries
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 系统边界
- en: Defines the scope of a system, creating a distinction between the system and
    the environment in which a system exists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了系统的范围，创造了系统与系统存在的环境之间的区别。
- en: Managing Complexity
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理复杂性
- en: 'As systems engineers, we must build and integrate elements and subsystems to
    achieve a desired objective. There can be a lot of moving parts: various APIs
    and communication protocols, various data schemas, various security interfaces
    to traverse. Our biggest challenge is, How do we manage all this complexity?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统工程师，我们必须构建和集成元素和子系统以实现预期的目标。可能会有很多移动的部分：各种API和通信协议，各种数据模式，各种安全接口需要穿越。我们面临的最大挑战是，我们如何管理所有这些复杂性？
- en: The best tool for the job
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最适合工作的工具
- en: The best tool we have  to help manage complexity is composition. Functional
    programming to the rescue!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来管理复杂性的最好工具就是组合。函数式编程来拯救！
- en: '![](img/88c7e88d-a180-4369-9677-04f62ba0d016.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88c7e88d-a180-4369-9677-04f62ba0d016.png)'
- en: Our job is to decompose the elements of our system into atomic parts, fit them
    back together into subsystems and wire them together in a distributed, microservice
    based environment.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作是将系统的元素分解为原子部分，将它们重新组合成子系统，并在分布式、微服务的环境中将它们连接在一起。
- en: How do we know when have we sufficiently decomposed an element?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道我们已经充分分解了一个元素？
- en: 'A: When we can treat the element as a black box, i.e., when we do not need
    visibility into the function to understand what it does.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: A：当我们可以将元素视为黑匣子时，即当我们不需要了解其功能就能理解它的作用时。
- en: Divide and conquer
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分而治之
- en: FP gives us the tools and techniques we need to divide our monolithic applications
    into microservices.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: FP为我们提供了将我们的单片应用程序分解为微服务所需的工具和技术。
- en: '![](img/24bc395c-1782-4053-bcab-56fdabd93f7b.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24bc395c-1782-4053-bcab-56fdabd93f7b.png)'
- en: In [Chapter 4](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=220&action=edit), *SOLID
    Design in Go*, we learned that our applications should be built from components
    that follow the Unix philosophy of doing one thing well. We follow the same precepts
    when building microservices. Furthermore, following the **Single Responsibility
    Principle** (**SRP**) we treat each microservice as a separate entity that, whose
    entire life cycle is kept separate within its predefined boundaries. This decoupling
    of our microservices is what allows us to create, move and restart our microservice,
    isolated from its surroundings.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=220&action=edit)中，*Go中的SOLID设计*，我们学到我们的应用程序应该由遵循Unix哲学的组件构建，即做一件事情很好。我们在构建微服务时遵循相同的原则。此外，遵循**单一责任原则**（**SRP**），我们将每个微服务视为一个单独的实体，其整个生命周期都在其预定义的边界内保持分离。我们微服务的解耦是允许我们创建、移动和重新启动我们的微服务，使其与周围环境隔离的关键。
- en: '"This is the Unix philosophy: Write programs that do one thing and do it well.
    Write programs to work together." - Doug McIlroy'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: “这就是Unix哲学：编写只做一件事并且做得很好的程序。编写可以一起工作的程序。”- Doug McIlroy
- en: Designing for state management
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为状态管理设计
- en: Often, we find that application APIs are designed properly, giving the illusion
    that the application services are stateless. However, upon closer examination
    we find problems with their architecture.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们发现应用程序API被正确设计，给人一种应用服务是无状态的错觉。然而，仔细检查后，我们发现他们的架构存在问题。
- en: Add a microservice
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个微服务
- en: 'When they add one microservice it looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们添加一个微服务时，看起来是这样的：
- en: '![](img/5e78e4af-cf17-4557-8161-284b5c440471.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e78e4af-cf17-4557-8161-284b5c440471.png)'
- en: 'When they add two more it looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们再添加两个时，看起来是这样的：
- en: '![](img/23cb1b16-c084-4904-8d00-b1f007595ff3.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23cb1b16-c084-4904-8d00-b1f007595ff3.png)'
- en: They are feeling good about their architecture until they launch their application
    and onboard users.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 他们对他们的架构感到满意，直到他们推出应用程序并吸引用户。
- en: 'Problems begin to appear:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 问题开始出现：
- en: Scalability
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Availability
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: State management
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理
- en: Data integrity issues
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性问题
- en: Rather than creating a stateless architecture, what really happened was that
    they pushed their application state down to a single database, which only complicated
    their issues.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 他们并没有创建无状态的架构，实际上他们是将应用程序状态推送到单个数据库中，这只会使问题更加复杂。
- en: All of their so supposedly stateless microservices are now coupled to the single,
    shared monolithic database.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 他们所有所谓无状态的微服务现在都与单个共享的单体数据库耦合在一起。
- en: '![](img/a224d3ec-6fdb-4b15-8313-5cd736de0213.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a224d3ec-6fdb-4b15-8313-5cd736de0213.png)'
- en: This is what they should have designed...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是他们应该设计的东西...
- en: '![](img/d4e5e9a3-5bac-4504-a254-d050e3896eb5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4e5e9a3-5bac-4504-a254-d050e3896eb5.png)'
- en: … where each microservice owns their own data. Lookup tables can be shared and
    managed with database replication, but the data in their domain remains isolated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '...其中每个微服务都拥有自己的数据。查找表可以共享并通过数据库复制进行管理，但其领域中的数据保持隔离。'
- en: FP influenced architectures
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受FP影响的架构
- en: Let’s discuss a few popular architectures that borrow ideas from FP.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些从FP借鉴思想的流行架构。
- en: Domain driven design (DDD)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）
- en: Event based architectures
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于事件的架构
- en: CQRS
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS
- en: Functional reactive architecture
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能反应式架构
- en: Let’s start with DDD.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从DDD开始。
- en: Other names for DDD include Hexagonal Architecture, Clean Architecture, Ports
    and Adapters, Onion Architecture and Applicative-Style-Architecture. We'll call
    it DDD or layered architecture.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: DDD的其他名称包括六边形架构、清洁架构、端口和适配器、洋葱架构和应用风格架构。我们将其称为DDD或分层架构。
- en: Domain Driven Design
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: In order to create good software, we must understand our customer's business.
    We  cannot create a prospect management software application unless we have a
    good understanding of how a sales pipeline works; We must understand the domain
    of sales. This is what **Domain-Driven Design** (**DDD**) is about. Look for layered
    application architecture diagram later in this chapter. What's in the center?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建优秀的软件，我们必须了解客户的业务。除非我们对销售管道的工作原理有很好的理解，否则我们无法创建潜在客户管理软件应用程序；我们必须了解销售领域。这就是**领域驱动设计**（**DDD**）的意义。稍后在本章中查找分层应用程序架构图。中心是什么？
- en: A firm understanding of our business domain and our requirements is the key
    to successfully engineering a system solution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的业务领域和需求有深刻理解是成功工程系统解决方案的关键。
- en: In this model we consider two main layers. The inside, with applicative use
    case handlers, and business domain logic and the outside, with all our infrastructure
    code, with database connections, and messaging.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，我们考虑两个主要层。内部是应用用例处理程序和业务领域逻辑，外部是所有基础设施代码，包括数据库连接和消息传递。
- en: Combining this model with the dependency inversion principle which states that
    high level modules should not depend on low level modules. We see that our dependencies
    should always point inwards towards the domain layer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个模型与依赖反转原则相结合，该原则规定高级模块不应依赖于低级模块。我们看到我们的依赖关系应始终指向领域层内部。
- en: Interactions between those two areas are achieved by ports and adapters. Clients
    requests or events arrive from the outside world at an API port and the technology
    specific adapter converts it into a function call or message that can be passed
    into the application layer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个领域之间的交互是通过端口和适配器实现的。客户端的请求或事件从外部世界到达API端口，技术特定的适配器将其转换为可以传递到应用层的函数调用或消息。
- en: Dependency rule
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖规则
- en: One issue that we soon face when building large Go applications is how to manage
    our dependencies. The larger your Go application gets, the more likely we are
    to encounter cyclic dependency errors unless our design accounts for the dependency
    rule.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大型Go应用程序时，我们很快面临的一个问题是如何管理我们的依赖关系。随着Go应用程序的规模越来越大，除非我们的设计考虑到依赖规则，否则我们很可能会遇到循环依赖错误。
- en: What is the dependency rule and why does the Go compiler deem it so important?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是依赖规则，为什么Go编译器认为它如此重要？
- en: The dependency rule says that source code in a lower-level layer can make use
    of code in higher-level layers yet higher-level layers may not make use of code
    in lower-level layers. Dependencies may only point in one direction.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖规则表示，低级层中的源代码可以使用高级层中的代码，但高级层不能使用低级层中的代码。依赖关系只能指向一个方向。
- en: What's the difference between a lower-level and a higher-level layer?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 低级和高级层之间有什么区别？
- en: 'Consider the following diagram:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表：
- en: '![](img/8292b65d-715d-46eb-98f2-073248ba93de.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8292b65d-715d-46eb-98f2-073248ba93de.png)'
- en: We'll see the code above in action later in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到上面的代码运行。
- en: In functional terms, the dependency rule says that if function `A` (from package
    `A`) calls function `B` (from package `B`), then function `B` cannot call any
    function from package `A`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能术语中，依赖规则表示，如果函数`A`（来自包`A`）调用函数`B`（来自包`B`），那么函数`B`不能调用来自包`A`的任何函数。
- en: However, the flow of application control could go in nearly any direction (between
    packages).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序控制的流程可以几乎朝任何方向（在包之间）进行。
- en: In practical terms, when writing a CRM application, we might find that our marketing
    campaign component may need to reference a function in our opportunity component.
    If our opportunity component needs to reference a function in our campaign component,
    then we could experience a circular dependency error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，当编写CRM应用程序时，我们可能会发现我们的营销活动组件可能需要引用我们的机会组件中的一个函数。如果我们的机会组件需要引用我们的营销活动组件中的一个函数，那么我们可能会遇到循环依赖错误。
- en: Cyclic dependency
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环依赖
- en: A cyclic dependency is a compilation error in Go. It indicates that our code
    has broken the dependency rule. It occurs when a package imports another package
    that in turn imports the original package. This can occur from package `A` to
    `B` to `A` or any combination that results in package `A` getting imported anywhere
    down the call chain.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 循环依赖是Go中的一个编译错误。它表明我们的代码违反了依赖规则。当一个包导入另一个包，而另一个包又导入原始包时，就会发生这种情况。这可以从包`A`到`B`到`A`或任何导致包`A`在调用链中的任何地方被导入的组合中发生。
- en: Working code
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 工作代码
- en: 'Let''s look at some example code to illustrate this concept. First, let''s
    look at the working code. The `packageb` package has one, simple public function
    and no imports:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些示例代码来说明这个概念。首先，让我们看一下工作代码。`packageb`包有一个简单的公共函数，没有导入：
- en: '`dependency-rule-good/src/packagea/featurea.go`'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependency-rule-good/src/packagea/featurea.go`'
- en: '[PRE0]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `packagea` package has one, simple public function and imports `packageb`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`packagea`包有一个简单的公共函数，并导入了`packageb`：'
- en: '[PRE1]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s our main function where we run `Atask` from `packagea`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主要函数，我们从`packagea`运行`Atask`：
- en: '[PRE2]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE3]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Code with cyclic dependency error
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 具有循环依赖错误的代码
- en: 'This time, we will import `packagea` into `featureb.go`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将在`featureb.go`中导入`packagea`：
- en: '[PRE4]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `featurea.go` file remains unchanged:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`featurea.go`文件保持不变：'
- en: '[PRE5]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `main.go` file also remains unchanged:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`文件也保持不变：'
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE7]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We violated the dependency rule when we imported `packagea` into `featureb.go`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`packagea`导入到`featureb.go`中时，我们违反了依赖规则。
- en: The Golang difference
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Golang的区别
- en: If you have spent most of your time up to now programming in other languages
    such as Ruby, you may be surprised when you get cyclic dependency errors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你大部分时间都在其他语言（如Ruby）中编程，当你遇到循环依赖错误时，你可能会感到惊讶。
- en: Why are there no cyclic dependency errors in a language like Ruby?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在像Ruby这样的语言中没有循环依赖错误？
- en: First, Ruby is an interpreted language, so we will never get a compile error.
    Furthermore, Ruby determines the scope by namespaces. As long as Ruby has a unique
    reference to a block of code and that code has been loaded into memory, there
    should be no dependency reference errors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Ruby是一种解释性语言，所以我们永远不会得到编译错误。此外，Ruby通过命名空间确定作用域。只要Ruby对代码块有唯一的引用，并且该代码已加载到内存中，就不应该有依赖引用错误。
- en: Does that mean Ruby is better than Go in this respect?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着Ruby在这方面比Go更好？
- en: It depends. Do we want to develop as quickly as possible without concerning
    ourselves with the dependency rule? Do we expect our application to grow complex
    over time? Do we want to put more time into design at the beginning of our project?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于我们是否想尽快开发，而不用担心依赖规则？我们是否期望我们的应用程序随着时间的推移变得复杂？我们是否想在项目开始时花更多时间进行设计？
- en: Go not only encourages us to write better code, like this instance, Go makes
    us write better code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Go不仅鼓励我们编写更好的代码，就像这个例子一样，Go让我们编写更好的代码。
- en: Solution for cyclic dependencies
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环依赖的解决方案
- en: How can we write Go code that adheres to the dependency rule and still reflect
    multi-directional flow of control that we frequently encounter in a business application
    logic?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写符合依赖规则的Go代码，同时反映我们在业务应用逻辑中经常遇到的多方向控制流？
- en: We can accomplish this using a layered architecture, an interface-driven development
    and a form of the Hollywood Principle called dependency injection.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用分层架构、面向接口的开发和一种称为依赖注入的好莱坞原则来实现这一点。
- en: Let’s take it one step at a time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来。
- en: Domain Driven Design
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计
- en: We can use a layered domain driven architecture as a tool for structuring our
    large-scale functional programs in a modular and composable manner. This architecture
    helps us visualize the separate application concerns and enables us to write Go
    code whose source code dependencies only point inwards.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分层领域驱动架构作为工具，以模块化和可组合的方式构建我们的大规模功能程序。这种架构帮助我们可视化独立的应用程序关注点，并使我们能够编写Go代码，其源代码依赖只指向内部。
- en: 'All references, that is, import statements must point inwards. An import **domain**
    statement can be found in all other packages. Import **use cases** can be found
    in the **interfaces** and **infrastructure** packages. Import **interfaces** can
    be found in the **infrastructure** package and no package (except the `import_test`
    package that we''ll cover later) is permitted to import the **infrastructure**
    package:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引用，即导入语句必须指向内部。在所有其他包中都可以找到导入**领域**语句。在**接口**和**基础设施**包中可以找到导入**用例**。在**基础设施**包中可以找到导入**接口**，而且除了`import_test`包（我们稍后会介绍）之外，不允许任何包导入**基础设施**包：
- en: '![](img/b31599a9-1361-4d6b-9199-f8698d12f332.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b31599a9-1361-4d6b-9199-f8698d12f332.png)'
- en: The preceding diagram is somewhat of a paradox. The more we move inwards, the
    higher level our software becomes. The **domain** entities are high-level concepts.
    Whereas, the more we move outwards, the more low-level our software is. The **infrastructure**
    is where we interact with the filesystem, cloud provider, or other data repositories,
    for example, databases or cloud storage.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表有点矛盾。我们越往内部移动，我们的软件就变得越高级。**领域**实体是高级概念。而我们越往外移动，我们的软件就变得越低级。**基础设施**是我们与文件系统、云提供商或其他数据存储库（例如数据库或云存储）进行交互的地方。
- en: When we adhere to the dependency rule, our source code dependencies only point
    inwards. Our system becomes highly cohesive, that is, components with closely
    related responsibilities are separated into the appropriate layer, thereby increasing
    cohesion. By programming to interfaces and leveraging dependency injection, we
    create a loose coupling that enables us to swap out pieces of the system without
    affecting other components.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遵循依赖规则时，我们的源代码依赖只指向内部。我们的系统变得高度内聚，即具有密切相关责任的组件被分离到适当的层中，从而增加了内聚性。通过编程到接口和利用依赖注入，我们创建了一种松耦合，使我们能够在不影响其他组件的情况下替换系统的部分。
- en: Interface-driven development
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于接口的开发
- en: Recall the following quote from [Chapter 4](../Text/Ch04.xhtml), *SOLID Design
    in Go*?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得[第4章](../Text/Ch04.xhtml)中的这句话吗？*Go中的SOLID设计*？
- en: '"It makes sense to categorize a thing by its abilities, because everything
    is defined by its actions."'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: “按照其能力对事物进行分类是有道理的，因为一切都是由其行为来定义的。”
- en: Since this is a book about functional programming, now would be a good time
    to mention that a major benefit of using interfaces is that they allow us to group
    our application's functions in order to model real-life behaviors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本关于函数式编程的书，现在是一个好时机提到使用接口的一个主要好处，即它们允许我们将应用程序的函数分组以建模真实生活中的行为。
- en: 'In the previous chapter, we modeled the behavior of a duck:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对鸭子的行为进行了建模：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this chapter, we will look at manipulating files in the **Google Cloud Platform**
    (**GCP**). Our interface defines the four behaviors of interest:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究如何在**Google Cloud Platform**（**GCP**）中操作文件。我们的接口定义了四个感兴趣的行为：
- en: '[PRE9]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's not get confused with the `interface` terminology. We just spoke about
    a Go interface, whereas when we talk about the interface layer in a layered architecture
    that is a way of layering our application into separate, cohesive concerns.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要混淆“接口”术语。我们刚刚谈到了Go接口，而当我们谈论分层架构中的接口层时，这是一种将应用程序分成单独的、内聚的关注点的方式。
- en: This chapter will focus on the mechanics of how we accomplish this task using
    Go.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍我们如何使用Go来完成这项任务的机制。
- en: What are our best options for decoupling dependencies between high-level and
    low-level layers?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之间高级和低级层之间解耦依赖的最佳选择是什么？
- en: We'll look at two-candidate solutions, the observer pattern and dependency injection
    in the upcoming sections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中看两种候选解决方案，观察者模式和依赖注入。
- en: Hollywood principle
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 好莱坞原则
- en: Actors suffer through crushing blows of humiliation in their quest to climb
    one step higher in the Hollywood hierarchy. Who determines whether an actor winds
    up as a stage hand or Brad Pitt? The casting director.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 演员们在努力攀登好莱坞的阶层时，经历了屈辱的打击。是谁决定演员最终成为舞台助手还是布拉德·皮特？是选角导演。
- en: Actors audition for a part in a movie and are advised not to ask whether they
    got the part. The fact is that if the director wants you, he'll find you. That's
    the Hollywood principle of "*Don't call us. We'll call you"*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 演员试镜参加电影角色的试镜，并被告知不要问自己是否得到了角色。事实是，如果导演想要你，他会找到你。这就是好莱坞的原则：“*别打电话给我们，我们会打电话给你*”。
- en: In traditional programming, the actor would audition and then ask the director
    if they got the part. That's not how the Hollywood Principle works.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程中，演员会试镜，然后问导演是否得到了角色。这不是好莱坞原则的工作方式。
- en: What is required for this inversion of control?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要什么样的控制反转？
- en: We require an API that exposes public functions and a framework where dependent
    components are bound to a subject during runtime.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个公开函数的API和一个在运行时将依赖组件绑定到主题的框架。
- en: What are our framework options?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的框架选项是什么？
- en: Observer pattern
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The observer pattern is one option. It works by injecting a callback object
    (observer) into the subject to be observed. The subject simply raises an event
    in all observers when its state changes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一个选择。它通过将一个回调对象（观察者）注入到要观察的主题中来工作。当主题的状态发生变化时，主题只是在所有观察者中引发一个事件。
- en: How the observer reacts to the event is outside the scope or care of the subject.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者对事件的反应超出了主题的范围或关心。
- en: '![](img/91a989bf-e1a9-41c1-95c5-e74222c2c803.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91a989bf-e1a9-41c1-95c5-e74222c2c803.png)'
- en: 'Here’s an implementation of that pattern:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该模式的实现：
- en: '[PRE10]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The observer implements the `Callback` interface. We implement a `Notify` method
    for the observer receiver. `Notify` is the observer''s callback function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者实现了`Callback`接口。我们为观察者接收器实现了一个`Notify`方法。`Notify`是观察者的回调函数：
- en: '[PRE11]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The subject implements three methods: `AddObserver`, `DeleteObserver`, and
    `NotifyObservers`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 主题实现了三个方法：`AddObserver`、`DeleteObserver`和`NotifyObservers`：
- en: '[PRE12]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `AddObserver` method is where the subscription, that is, the relationship
    between the observer and the subject occurs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddObserver`方法是订阅的地方，即观察者和主题之间的关系发生的地方。'
- en: The `NotifyObservers` method acts as a simple service locator. It iterates through
    its list of subscribed observers and executes its callbacks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyObservers`方法充当简单的服务定位器。它遍历其订阅的观察者列表并执行其回调。'
- en: 'The following is the output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we remove the observer from our service locator by executing  `subject.DeleteObserver(&Observer{})`,
    all subsequent notifications have no effect since there are no observers subscribed
    to respond to the published events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过执行`subject.DeleteObserver(&Observer{})`从我们的服务定位器中移除观察者时，所有后续通知都不起作用，因为没有观察者订阅以响应发布的事件。
- en: Dependency injection
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency injection** (**DI**) is a form of Inversion of Control and also
    impacts the flow of control in an application. Although the observer pattern''s
    callback mechanism can modify the flow at many times and in many places in an
    application, DI typically performs the flow of control configuration during application
    initialization.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种控制反转的形式，也影响应用程序中的控制流。虽然观察者模式的回调机制可以在应用程序中的许多时间和许多地方修改流程，但DI通常在应用程序初始化期间执行控制流配置。'
- en: Since this chapter is mainly about a layered architecture and the management
    of dependencies to prevent circular dependency errors, we will not explore pub/sub
    architectures and the observer pattern. Instead, we will choose DI to reconcile
    our dependencies in our main function.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章主要讨论分层架构和管理依赖关系以防止循环依赖错误，我们不会探讨发布/订阅架构和观察者模式。相反，我们将选择DI来在我们的主函数中协调我们的依赖关系。
- en: A cloud bucket application
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云存储桶应用程序
- en: Pictures are worth a thousand words, right? Let's use some diagrams to help
    describe our basic application architecture.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图片说话，对吧？让我们使用一些图表来帮助描述我们基本的应用程序架构。
- en: Next, we will see the high-level architecture of our application that we'll
    call `onion`. (An onion has layers, so we'll use that metaphor to remind us of
    the layers.)   It moves files from the **SOURCE Cloud Bucket** to the local filesystem
    and then to the **SINK Cloud Bucket**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到我们的应用程序的高层架构，我们将称之为`onion`。（洋葱有层，所以我们将使用这个比喻来提醒我们层。）它将文件从**SOURCE Cloud
    Bucket**移动到本地文件系统，然后移动到**SINK Cloud Bucket**。
- en: 'The purple API box in the following diagram represents the web services API
    that our `onion.go` application exposes for the administrative user. The red API
    represents the Google Cloud Platform storage API:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表中的紫色API框代表我们的`onion.go`应用程序为管理用户公开的Web服务API。红色API代表Google Cloud平台存储API：
- en: '![](img/2cef5c64-f499-4839-8e76-b5866b134ea9.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2cef5c64-f499-4839-8e76-b5866b134ea9.png)'
- en: The admin will direct the `onion.go` application to download a log file from
    the **SOURCE Cloud Bucket** to the local filesystem. The admin can subsequently
    tell `onion.go` to upload the file to the **SINK Cloud Bucket**.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员将指示`onion.go`应用程序从**SOURCE Cloud Bucket**下载日志文件到本地文件系统。管理员随后可以告诉`onion.go`将文件上传到**SINK
    Cloud Bucket**。
- en: The purple paths, for example, `/health`, `/list-source-buckets`, and `/list-sink-buckets` are
    the web service APIs that our onion application exposes to the administrative
    user.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，紫色路径`/health`、`/list-source-buckets`和`/list-sink-buckets`是我们洋葱应用程序向管理用户公开的Web服务API。
- en: Directory structure
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录结构
- en: 'The directory structure of our application looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的目录结构如下：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The source code for our project is `main.go`, which lives in the project root.
    The rest of our application is separated into directories corresponding to our
    application's architectural layers (domain, use cases, interfaces, and infrastructure).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的源代码是`main.go`，位于项目根目录。我们的应用程序的其余部分分为与应用程序架构层（领域、用例、接口和基础设施）对应的目录。
- en: Before looking into the details of the other layers, let's see how we tie them
    together. That work is done in our `main.go` file. We start by initializing our
    configuration options with `GetOptions()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解其他层的细节之前，让我们看看如何将它们联系在一起。这项工作在我们的`main.go`文件中完成。我们首先通过`GetOptions()`初始化我们的配置选项。
- en: main.go
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主要.go
- en: 'Let''s have a look at the contents of `main.go`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`main.go`的内容：
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We direct `Debug` statements to standard out if our  `log_debug_info` setting
    is true; otherwise, we discard them. We hardcode the name of the log file for
    simplicity, but we could have used a config value or a function call to dynamically
    generate the filename.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`log_debug_info`设置为true，我们将`Debug`语句定向到标准输出；否则，我们将丢弃它们。为简单起见，我们硬编码了日志文件的名称，但我们可以使用配置值或函数调用来动态生成文件名。
- en: The last thing we do in our `init` function is to change our application's working
    directory to our project root directory. If there is an error doing so, the `HandlePanic()`
    function from our `utils` package will display a stack trace for debugging purposes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的`init`函数中做的最后一件事是将我们的应用程序的工作目录更改为我们的项目根目录。如果这样做时出现错误，我们的`utils`包中的`HandlePanic()`函数将为调试目的显示堆栈跟踪。
- en: We find the `HandlePanic()` function in our utils package. Unlike most functions,
    we do not return an error from `HandlePanic()`. We handle it by adding the filename
    and line number of the source code file where the error originated and alert.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的utils包中找到`HandlePanic()`函数。与大多数函数不同，我们不会从`HandlePanic()`返回错误。我们通过添加错误来源的源代码文件的文件名和行号来处理它并发出警报。
- en: func HandlePanic
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: func HandlePanic
- en: 'Here is our `HandlePanic()` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`HandlePanic()`函数：
- en: '[PRE16]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is worth noting that we import our utils package by prefacing it with a
    period like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们通过在前面加上一个句点来导入我们的utils包，就像这样：
- en: '[PRE17]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This allows us to reference public functions (starting with capital letters)
    without including the `utils` package name.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够引用公共函数（以大写字母开头）而不包括`utils`包名称。
- en: Dependency injection
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In the decorator chapter, we looked at inversion of control. We saw how a decorator,
    for example, the **FaultTolerance**, can be injected into the flow (of main) by
    our decorator framework using dependency injection.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器章节中，我们看到了控制反转。我们看到了如何通过依赖注入，装饰器（例如**FaultTolerance**）可以被注入到（主函数的）流中。
- en: '![](img/47b40c88-4039-48cb-91c5-69952c4b9869.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47b40c88-4039-48cb-91c5-69952c4b9869.png)'
- en: We will use the same concept of dependency injection to wire up our application
    and to provide control over function calls and the data that flows between our
    interfaces.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的依赖注入概念来连接我们的应用程序，并控制函数调用和数据在接口之间的流动。
- en: 'Remember our electrician analogy? This is a great time to revisit the concept.
    Our work is much like the electrician who first turns off the power to the house:
    who lays the wires and subsequently turns the power on. After the power is turned
    on, our electrician can test the switches to verify that the home''s electrical
    system has been wired properly.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们的电工类比吗？现在是重新审视这个概念的好时机。我们的工作很像电工首先关闭房子的电源：铺设电线，然后打开电源。电源打开后，我们的电工可以测试开关，以验证家庭的电气系统是否已正确接线。
- en: We create the interfaces that connect the layers of our application. In the
    main function we instantiate our interactors. Our interactors use the interfaces
    through which we call functions and thereby control the flow of data between the
    parts of our loosely coupled system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建连接应用程序各层的接口。在主函数中，我们实例化我们的交互器。我们的交互器使用接口，通过这些接口我们调用函数，从而控制我们松散耦合系统各部分之间的数据流。
- en: We have two interactors--one for interacting with the Google Cloud Platform,
    the `GcpInteractor`, and the other, `LocalInteractor`, for reading and writing
    files to the local filesystem.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个交互器--一个用于与谷歌云平台交互，`GcpInteractor`，另一个`LocalInteractor`，用于读写本地文件系统中的文件。
- en: func main()
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: func main()
- en: 'Now, let''s go through the `main()` function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`main()`函数：
- en: '[PRE18]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We inject both our interactors into our web service handler, which allows our
    admin user to manipulate our repositories via our public web service APIs, for
    example, `/list-source-buckets`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个交互器注入到我们的Web服务处理程序中，这允许我们的管理员用户通过我们的公共Web服务API来操作我们的存储库，例如`/list-source-buckets`。
- en: Note that DI occurs at object creation time. Contrast DI with parameterized
    functions or the use of a context--that contains all pertinent information for
    a single function invocation—that can be passed through a chain of function calls.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，依赖注入发生在对象创建时。将依赖注入与参数化函数或使用上下文进行对比--上下文包含了单个函数调用所需的所有相关信息，可以通过一系列函数调用传递。
- en: DI typically occurs once during the lifetime of an application. Parameterized
    functions and the passing of context, occurs many times.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入通常在应用程序的生命周期中只发生一次。参数化函数和传递上下文，会发生多次。
- en: Layers in the architecture
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 架构中的层
- en: We are building an application framework based on a layered achitecture that
    will allow us to grow our application with less difficulty.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个基于分层架构的应用程序框架，这将使我们能够更轻松地扩展我们的应用程序。
- en: After building a solid application framework based on a layered architecture,
    we'll return to pure functional programming topics and techniques in subsequent
    chapters.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了基于分层架构的坚实应用程序框架之后，我们将在后续章节中回到纯函数式编程主题和技术。
- en: 'We will separate our Onion application into four layers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的洋葱应用程序分成四层：
- en: Domain
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域
- en: Use cases
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例
- en: Interfaces
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Infrastructure
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施
- en: We will discuss them in detail in the upcoming sections.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中详细讨论它们。
- en: Domain layer
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 领域层
- en: 'The following diagram illustrates the layers in our layered architecture. The
    arrow indicates that we only import packages in one direction. Domain will never
    import from use cases, interfaces, or infrastructure. The red background in the
    **domain** layer indicates that we''re looking into that layer in this section:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了我们分层架构中的各层。箭头表示我们只在一个方向上导入包。领域永远不会从用例、接口或基础设施中导入。**领域**层中的红色背景表示我们在本节中正在研究该层：
- en: '![](img/aa399ec9-f454-4fe4-aa0a-52276702dca1.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa399ec9-f454-4fe4-aa0a-52276702dca1.png)'
- en: The **domain** layer is where we define our business entities. These are the
    core business objects that we would initially think of when defining the essence
    of what our application does.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域**层是我们定义业务实体的地方。这些是我们在定义应用程序的本质时最初会考虑的核心业务对象。'
- en: 'From our following type definitions, we quickly glean that our application
    moves files to and from buckets of a cloud storage provider:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下类型定义中，我们很快就可以得出结论，我们的应用程序将文件移动到云存储提供商的存储桶中：
- en: '[PRE19]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `LocalRepository` and `BucketRepository` do not refer to specific implementations.
    The **domain** layer does not care whether the bucket is Google bucket or an AWS
    bucket. The term repository is used. To the **domain** layer a repository is just
    a place in which files are persisted and retrieved.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalRepository`和`BucketRepository`并不指代特定的实现。**领域**层不关心存储桶是谷歌存储桶还是AWS存储桶。术语存储库被使用。对于**领域**层来说，存储库只是一个文件被持久化和检索的地方。'
- en: 'Before moving on, let’s look at the contents of the log files we’re moving
    around:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们看一下我们正在移动的日志文件的内容：
- en: '[PRE20]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This `.jsonl` file comprises three JSON objects.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`.jsonl`文件包含三个JSON对象。
- en: 'The format of each line is defined in our `domain/log_file.go` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 每行的格式在我们的`domain/log_file.go`文件中定义：
- en: '[PRE21]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We define one function to convert our JSON text into a Go struct:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个函数来将我们的JSON文本转换为Go结构：
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We define a method to operate on a `LogFile` object, transforming it into a
    JSON text representation:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个方法来操作`LogFile`对象，将其转换为JSON文本表示：
- en: '[PRE23]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's worth noting that in both cases we wrap the underlying error with our own
    more specific error message before returning the error to our function’s caller.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在这两种情况下，我们在将错误返回给函数的调用者之前，用我们自己更具体的错误消息包装了底层错误。
- en: The fewer packages our application references the easier the job will be to
    maintain our application. Third-party packages can be frequently updated, which
    is usually a good thing, for example, if they fix a security issue, but can be
    a bad thing for our application if they change their public interfaces in such
    a way as to break our application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序引用的包越少，维护应用程序的工作就越容易。第三方包可能会经常更新，这通常是一件好事，例如，如果它们修复了安全问题，但如果它们以某种方式更改其公共接口以破坏我们的应用程序，那就可能是一件坏事。
- en: The `github.com/pkg/errors` package is one of the few packages that is worththe
    trouble. It allows us to add context to the error message without changing or
    hiding the original error message.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/pkg/errors`包是少数值得麻烦的包之一。它允许我们在不更改或隐藏原始错误消息的情况下为错误消息添加上下文。'
- en: 'Package errors ([https://github.com/pkg/errors](https://github.com/pkg/errors))
    provide simple error handling primitives. You can also refer to: [https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Package errors ([https://github.com/pkg/errors](https://github.com/pkg/errors))提供了简单的错误处理原语。您也可以参考：[https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully)。
- en: 'The `Write` method allows us to write the content of a `LogFile` object to
    disk:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Write`方法允许我们将`LogFile`对象的内容写入磁盘：'
- en: '[PRE24]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In `file.go`, we define our `File` struct, which comprises file attributes.
    For example, filename and bytes. It also has the `LogFile` defined as an embedded
    field.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`file.go`中，我们定义了我们的`File`结构，其中包括文件属性。例如，文件名和字节。它还将`LogFile`定义为嵌入字段。
- en: '[PRE25]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also define structs for manipulating the `.jsonl` files that we receive
    from (and send to) GCP buckets:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为操作从（和发送到）GCP存储桶的`.jsonl`文件定义了结构：
- en: '[PRE26]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `file.go` file also contains the following functions for manipulating a
    file:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`file.go`文件还包含以下用于操作文件的函数：'
- en: '`NewFile`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewFile`'
- en: '`NameOnly`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NameOnly`'
- en: '`Exists`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exists`'
- en: '`Path`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path`'
- en: '`Read`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`'
- en: '`Write`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`'
- en: '`Parse`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Parse`'
- en: 'Our `api.go` file defines the structs we use to communicate whether a file
    exists or whether operations performed on our files were successful:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`api.go`文件定义了我们用于通信文件是否存在或我们对文件执行的操作是否成功的结构：
- en: '[PRE27]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use cases layer
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用例层
- en: 'Let''s look at the use cases layer now:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看用例层：
- en: '![](img/2708c46e-6efc-467b-84e8-a2b795e7bc3f.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2708c46e-6efc-467b-84e8-a2b795e7bc3f.png)'
- en: The use cases layer has to do with what the user wants to do, that is, their
    use cases for using this application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 用例层与用户想要做什么有关，也就是说，他们使用此应用程序的用例。
- en: It references the repositories, local filesystem, and the source and sink buckets
    in the cloud.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 它引用了存储库、本地文件系统以及云中的源和接收桶。
- en: We can directly reference domain entities and we can reference interface entities
    via the local and GCP interactors.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接引用领域实体，也可以通过本地和GCP交互器引用接口实体。
- en: If we can reference an infrastructure entity in any way, then our design is
    broken. For example, we should be able to swap out the Google Cloud Platform storage
    APIs with AWS S3 bucket APIs and without our use case layer changing in any way.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以任何方式引用基础设施实体，那么我们的设计就是有问题的。例如，我们应该能够在不改变用例层的情况下，用AWS S3存储桶API替换Google Cloud
    Platform存储API。
- en: In our application, a user may want to check whether a local file exists or
    get the file, in order to upload it to a bucket in GCP.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，用户可能希望检查本地文件是否存在或获取文件，以便将其上传到GCP的存储桶中。
- en: 'The `LocalInteractor` struct controls the flow to and from the local filesystem:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalInteractor`结构控制着与本地文件系统的流动：'
- en: '[PRE28]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `GcpInteractor` struct controls the flow of files and information regarding
    files in a cloud bucket. *Doing things* with buckets includes things such as listing
    the files in a bucket, checking whether a file exists, uploading, and downloading
    a file:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`GcpInteractor`结构控制云存储桶中文件和文件信息的流动。与存储桶一起*做事*包括列出存储桶中的文件，检查文件是否存在，上传和下载文件：'
- en: '[PRE29]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are two types of buckets. One acts as a source of files and the other
    acts as the sink (or destination) for files.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的存储桶。一个充当文件的来源，另一个充当文件的接收（或目的地）。
- en: 'Note that we can reference the `BucketRepository` struct from the `usecases`
    package, but there will be no reference to `usecases` in any file in the `domain`
    package:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以从`usecases`包中引用`BucketRepository`结构，但在`domain`包中的任何文件中都不会引用`usecases`。
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `GcpInteractor` methods in `usecases.go` define the use cases for manipulating
    files in our Google Cloud account:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`usecases.go`中的`GcpInteractor`方法定义了在我们的Google Cloud帐户中操作文件的用例：'
- en: '[PRE31]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `DownloadFile` and `UploadFile` methods are arguably our most important
    ones:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadFile`和`UploadFile`方法可以说是我们最重要的方法：'
- en: '[PRE32]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The logic in this layer is very lean. When we develop more complex applications
    that have business rules to enforce, these use cases would likely be the best
    place to put them.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层的逻辑非常简洁。当我们开发更复杂的应用程序并需要执行业务规则时，这些用例可能是最好的放置位置。
- en: 'For example, if we had implemented security in our application, we could define
    the following rules as:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在应用程序中实现了安全性，我们可以定义以下规则：
- en: Only users in the sink group or above can list the files in a sink bucket
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有接收组或以上的用户才能列出接收存储桶中的文件
- en: Only users in the `source-downloads` group can download files
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有“源下载”组中的用户可以下载文件
- en: Only users in the `super-admins` group can upload files
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有“超级管理员”组中的用户可以上传文件
- en: Then we'd likely put our authorization logic here in the use cases layer.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可能会在这里放置我们的授权逻辑在用例层。
- en: Compatible interfaces
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 兼容的接口
- en: In order for the dependency injection to work, our application must have compatible
    interfaces, for example, `FileExists(fileName string) (fileExists bool, err error)` 
    in `domain.go` and `gcphandler.go`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使依赖注入起作用，我们的应用程序必须具有兼容的接口，例如，在`domain.go`和`gcphandler.go`中的`FileExists(fileName
    string) (fileExists bool, err error)`。
- en: 'The line `return interactor.SourceBucketRepository.FileExists(fileName)` is
    delegating the `FileExists` behavior to the interface, which is implemented by
    `gcphandler.go` and then injected into the interactor. Below, we define our interface
    for our BucketRepository:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 行`return interactor.SourceBucketRepository.FileExists(fileName)`将`FileExists`行为委托给接口，该接口由`gcphandler.go`实现，然后注入到interactor中。下面，我们为BucketRepository定义接口：
- en: '[PRE33]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `BucketRepository` interface is compatible with the `GcpHandler` interface:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`BucketRepository`接口与`GcpHandler`接口兼容：'
- en: '[PRE34]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s not forget the wiring up that occurred in main, that associated the
    `/source-file-extsts` URL end point with the `GcpInteractor`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记在主函数中进行的连接，将`/source-file-extsts` URL端点与`GcpInteractor`关联起来：
- en: '`main.go`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`'
- en: '[PRE35]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is the crux of the framework that performs the dependency injection and
    allows us to write code that spans the layers of our application without violating
    the dependency rule.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行依赖注入并允许我们编写跨应用程序层的代码的框架的关键。
- en: Interfaces layer
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口层
- en: 'In this section, we will be looking at the interfaces layer:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看接口层：
- en: '![](img/1d2a4bfd-ac95-4061-944f-cccb6fc0f977.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d2a4bfd-ac95-4061-944f-cccb6fc0f977.png)'
- en: The interfaces layer provides a means to communicate with external repositories,
    for example, cloud bucket or local files storage. If our external repositories
    need to communicate events back to our application, for example, out of disk space,
    these events would flow through this interfaces layer.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接口层提供了一种与外部存储库通信的方式，例如云存储桶或本地文件存储。如果我们的外部存储库需要向我们的应用程序通信事件，例如磁盘空间不足，这些事件将通过这个接口层流动。
- en: We begin by defining our interface, that is, the functions that our interfaces
    layer supports.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的接口，也就是我们的接口层支持的功能。
- en: 'This file contains handlers for interfacing with the **Google Cloud Platform’s**
    (**GCP**) storage API:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含了与**Google Cloud Platform**（**GCP**）存储API进行接口的处理程序：
- en: '[PRE36]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To simplify our implementation, we’ll only define one `GcpHandler` interface
    for both source and sink buckets. The consequence is that `DownloadFile` will
    be available, but not useful for the sink bucket and `UploadFile` will not be
    useful for the source bucket.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的实现，我们将只为源存储桶和接收存储桶定义一个`GcpHandler`接口。其结果是`DownloadFile`将可用，但对于接收存储桶来说并不有用，而`UploadFile`对于源存储桶来说也不有用。
- en: 'Next, we define a structure in which we can register our interface handlers:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个结构，可以在其中注册我们的接口处理程序：
- en: '[PRE37]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have two types of GCP repositories. A source bucket and a sink bucket.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种类型的GCP存储库。源存储桶和接收存储桶。
- en: 'Earlier, we provided the interface that satisfies the needs of the use cases.
    In the following code, we implement the code that injects that actual implementation
    (at run time):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们提供了满足用例需求的接口。在下面的代码中，我们实现了在运行时注入实际实现的代码：
- en: '[PRE38]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How can the code above be improved?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以上的代码如何改进？
- en: 'Our NewSinkBucketRepo function could be rewritten as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的NewSinkBucketRepo函数可以重写如下：
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See the difference? Note that, unlike in C, it's perfectly OK to return the
    address of our local variable `SourceBucketRepo`.  When we return our `SourceBucketRepo`
    composite literal, the expression is evaluated  and Go will allocate a fresh instance
    of `SourceBucketRepo`. So, the storage associated with our `SourceBucketRepo`
    variable will survive after our `NewSourceBucketRepo` function returns.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 看到区别了吗？请注意，与C语言不同，返回我们的局部变量`SourceBucketRepo`的地址是完全可以的。当我们返回我们的`SourceBucketRepo`组合文本时，表达式会被评估，Go将分配一个新的`SourceBucketRepo`实例。因此，我们的`SourceBucketRepo`变量关联的存储将在`NewSourceBucketRepo`函数返回后继续存在。
- en: 'The code for wiring up the injection to handle the sink bucket dependencies
    is very similar to the source bucket code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 处理接收存储桶依赖的注入连接代码与源存储桶代码非常相似：
- en: '[PRE40]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The local storage interface is similar to the GCP bucket interface. Both have
    a means to check whether a file exists and to retrieve a file. We have added some
    logic that shows that this would be a good place to implement a caching mechanism
    in order to increase performance (at the expense of additional RAM requirements):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储接口类似于GCP存储桶接口。两者都有一种方法来检查文件是否存在并检索文件。我们添加了一些逻辑，表明这将是实现缓存机制以提高性能的好地方（以额外的RAM要求为代价）：
- en: '[PRE41]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We see the same dependency injection logic in the `NewLocalRepo()` function:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`NewLocalRepo()`函数中看到了相同的依赖注入逻辑：
- en: '[PRE42]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we implement the `FileExists()` function:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现`FileExists()`函数：
- en: '[PRE43]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we want to implement file caching, we could create a `FileCache` global
    variable in the interfaces layer like this:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实现文件缓存，我们可以在接口层创建一个`FileCache`全局变量，如下所示：
- en: '[PRE44]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We could initialize it in the `init()` function:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`init()`函数中初始化它：
- en: '[PRE45]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: But if we did, what else should we do?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们这样做了，我们还应该做什么呢？
- en: What if two requests occur at the same time to upload a file? What could happen?
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个请求同时发生上传文件会发生什么？
- en: What if we implemented a `DeleteFile` function?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现了`DeleteFile`函数会怎样？
- en: Some form of resource locking and race condition mitigation would be needed.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 需要某种资源锁定和竞争条件的缓解。
- en: The big win for us is that now we have a place to put this caching logic. The
    layering helps when the time comes to extend our application's functionality.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说最大的收获是现在我们有一个放置缓存逻辑的地方。当扩展我们应用程序功能的时候，分层有所帮助。
- en: Now we'll have a look at the `interfaces/webservice.go` file.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下`interfaces/webservice.go`文件。
- en: 'First, let''s define an `Api` struct:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个`Api`结构：
- en: '[PRE46]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've seen how we used the `Api` struct to associate our application endpoints
    with their corresponding web service implementations.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用`Api`结构将我们的应用程序端点与其相应的网络服务实现关联起来。
- en: 'The `main.go` file defines an `enpoint` struct that embeds this `Api` struct:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.go`文件定义了一个嵌入了`Api`结构的`enpoint`结构：'
- en: '[PRE47]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In main, we initialize the `endpoints` slice with our web service endpoint
    (handler and URL):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们使用我们的网络服务端点（处理程序和URL）初始化`endpoints`切片：
- en: '[PRE48]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Later in main, we iterate through our endpoints and associate our URLs with
    their respective handlers:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在主函数中，我们遍历我们的端点，并将我们的URL与它们各自的处理程序关联起来：
- en: '[PRE49]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We created a `printApiExample()` helper function to print the following in
    our console:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`printApiExample()`辅助函数，在控制台中打印以下内容：
- en: '[PRE50]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we define our interactor interfaces. There is only one for our local
    filesystem:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的交互接口。我们的本地文件系统只有一个接口：
- en: '[PRE51]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We define five interfaces for our GCP buckets:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的GCP存储桶定义了五个接口：
- en: '[PRE52]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We create a `WebserviceHandler` struct to provide access to both local files
    and cloud bucket files:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`WebserviceHandler`结构，以便访问本地文件和云存储桶文件：
- en: '[PRE53]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Health API**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 健康API
- en: 'Health is a useful, simple utility web service, which is defined as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Health是一个有用的、简单的实用网络服务，定义如下：
- en: '[PRE54]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we want the JSON results, it is defined as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要JSON结果，它的定义如下：
- en: '[PRE55]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we only need the HTTP header status code, it is defined as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要HTTP头状态码，它的定义如下：
- en: '[PRE56]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**File exists APIs**'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 文件存在的API
- en: 'Here''s a web service method for checking whether a local file exists:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于检查本地文件是否存在的网络服务方法：
- en: '[PRE57]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s one for checking whether a file exists in our source cloud bucket:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于检查源云存储桶中文件是否存在的方法：
- en: '[PRE58]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**Extending functionality**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展功能
- en: We could easily extend our application by adding `WebserviceHandler` methods
    that could access both source and sink buckets as well as the local filesystem,
    all in the same function invocation.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加`WebserviceHandler`方法来轻松扩展我们的应用，这些方法可以访问源和接收存储桶以及本地文件系统，都在同一个函数调用中。
- en: Our design using interfaces is flexible in other ways, too. For example, using
    a testing configuration setting when starting our application we could instruct
    our application’s main function to use a test mock implementation when wiring
    up the interactors. This could enable our tests to interact with a speedy test
    stub bucket interface that provides canned responses to test the control flow
    within our application rather than taking time to initialize connections and deal
    with the latency of the network.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用接口的设计在其他方面也很灵活。例如，在启动我们的应用时使用测试配置设置，我们可以指示我们应用的主函数在连接交互器时使用测试模拟实现。这可以使我们的测试与一个快速的测试存根存储桶接口进行交互，该接口提供了预定义的响应，以测试应用程序内的控制流，而不是花时间初始化连接和处理网络的延迟。
- en: Now we'll look at the `interfaces/webservice_helpers.go` file.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看`interfaces/webservice_helpers.go`文件。
- en: 'First, we define the `sf` variable to be the `fmt.Sprintf` function. This allows
    us to abbreviate our code, replacing `sf` with `fmt.Sprintf`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义`sf`变量为`fmt.Sprintf`函数。这使我们能够缩写我们的代码，用`fmt.Sprintf`替换`sf`：
- en: '[PRE59]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, we define one of the few global variables in our application. This is
    the standard response we return to the web clients when an error is encountered.
    This value never changes. So, it is for all intents and purposes a constant:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了我们应用中为数不多的全局变量之一。这是我们在遇到错误时向Web客户端返回的标准响应。这个值永远不会改变。因此，它实际上是一个常量：
- en: '[PRE60]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the following code, we implement a function to determine the format of the
    data to return to the user:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们实现了一个函数来确定要返回给用户的数据格式：
- en: '[PRE61]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Granted, we’ve hardcoded the value to `json`, but we could have just as easily
    pulled the value from a query parameter. The idea to remember is that we use a
    function to return this value. The value returned from the function can change
    from one request to the next. We do not need to write code to synchronize results
    to ensure that each format returned corresponds properly with each request. Neither
    do we need data modification locking logic nor do we need to write code to prevent
    race conditions.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，我们已经将值硬编码为`json`，但我们也可以轻松地从查询参数中获取该值。要记住的是，我们使用一个函数来返回这个值。从函数返回的值可以在下一个请求中改变。我们不需要编写代码来同步结果，以确保每个返回的格式与每个请求正确对应。我们也不需要数据修改锁定逻辑，也不需要编写代码来防止竞争条件。
- en: What if we had defined format to be a global string? What errors might that
    cause? Could we use it to scale this application horizontally?
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将格式定义为全局字符串会怎样？那可能会引起什么错误？我们能用它来横向扩展这个应用吗？
- en: The general rule is, only if a value is constant, use a global reference. Otherwise,
    we should return all results via a function call. Why? Because using global variables
    that change makes our application state unpredictable.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，只有数值是常量时，才使用全局引用。否则，我们应该通过函数调用返回所有结果。为什么？因为使用会改变的全局变量会使我们的应用状态变得不可预测。
- en: Why global variables are bad
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么全局变量是不好的
- en: In [Chapter 1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*, we
    briefly discussed immutable variables, but did not dive much into why they are
    so bad. Let's do that now that we have a concrete example in mind.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](../Text/Ch01.xhtml)中，*在Go中进行纯函数式编程*，我们简要讨论了不可变变量，但并没有深入探讨它们为何如此糟糕。现在我们有了一个具体的例子，让我们来做一下。
- en: '**Functional impurity**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 功能不纯
- en: Also covered in [Chapter 1](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=362&action=edit#post_47), *Pure
    Functional Programming in Go*, pure functions always return the same result, given
    the same inputs and never have side effects. Global variables cause any function
    that references it to be impure.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在[第1章](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=362&action=edit#post_47)中也有，*在Go中进行纯函数式编程*，纯函数总是在给定相同的输入时返回相同的结果，从不产生副作用。全局变量会导致引用它的任何函数都变得不纯。
- en: '**Code complexity and bugs**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 代码复杂性和错误
- en: Global variables by definition are available to a number of functions. It quickly
    becomes difficult to understand the cause and effect aspects of program flow when
    a function behaves differently based on its value and other functions are changing
    that global value.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量根据定义可供多个函数使用。当一个函数根据其值以及其他函数正在改变的全局值而表现不同的时候，很快就会变得难以理解程序流的因果关系方面。
- en: '**Performance and race conditions**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 性能和竞争条件
- en: Mutable global variables require a locking mechanism to allow only one function
    at a time to update its value. This is often difficult to program and frequently
    results in race conditions, where a number of functions, that want to update the
    global variable, must wait in line.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 可变的全局变量需要一个锁定机制，以允许一次只有一个函数更新其值。这通常很难编程，并经常导致竞争条件，即一些想要更新全局变量的函数必须排队等待。
- en: '**Testing difficulties**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试困难**'
- en: Testing must take into account the value of global variables. This typically
    means that each tester must be aware of the global variable's existence, it's
    permissible values, and do the work of initializing the global variable's value
    prior to running each test.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 测试必须考虑全局变量的值。这通常意味着每个测试人员必须知道全局变量的存在、允许的值，并在运行每个测试之前初始化全局变量的值。
- en: Format the response
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 格式化响应
- en: In each web service request handler, we use the `setFormat` function in conjunction
    with the `getFormat` function to format the response data. We are simply using
    JSON in our example code, it is easy to see how we could extend our implementation
    to include formats such as XML and CSV.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个网络服务请求处理程序中，我们使用`setFormat`函数与`getFormat`函数结合使用来格式化响应数据。在我们的示例代码中，我们只是使用JSON，很容易看出我们如何扩展我们的实现以包括XML和CSV等格式。
- en: '(We''re still in `interfaces/webservice_helpers.go`.):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: （我们仍然在`interfaces/webservice_helpers.go`中。）：
- en: '[PRE62]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The handler helpers are similar in format. Let’s first look at how we handle
    a success or failure.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序助手的格式相似。首先让我们看看如何处理成功或失败。
- en: Our function signature contains seven arguments. That’s a lot, which makes it
    a likely candidate for a refactoring. In the next chapter, we’ll study how we
    can simplify complex APIs by passing functions instead of simple values.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数签名包含七个参数。这很多，这使得它成为重构的一个可能候选。在下一章中，我们将学习如何通过传递函数而不是简单值来简化复杂的API。
- en: Since `debugMsg` and `msg` are both strings, they share a single `string` declaration.
    Similarly, `err`, `error`, and `success` are all of the type `bool`; `bool` only
    needs to be typed once after the list of bool arguments. This is idiomatic Go.
    It is a style of programming, unique to Go, that helps us write simpler, more
    easily understood code.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`debugMsg`和`msg`都是字符串，它们共享一个`string`声明。同样，`err`、`error`和`success`都是`bool`类型；在bool参数列表之后，`bool`只需要被输入一次。这是Go的成语。这是一种独特于Go的编程风格，它帮助我们编写更简单、更易于理解的代码。
- en: 'Let''s examine the `handleSuccess()` function:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`handleSuccess()`函数：
- en: '[PRE63]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `handleSuccess()` function is called by the `SourceFileExists()` function
    in `webservices.go`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleSuccess()`函数由`webservices.go`中的`SourceFileExists()`函数调用：'
- en: '[PRE64]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We start with a `Debug.Printf` statement. It takes the first parameter from
    a web service handler method such as `SourceFileExists`:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Debug.Printf`语句开始。它从网络服务处理程序方法（如`SourceFileExists`）中获取第一个参数：
- en: '[PRE65]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It’s worth noting that the `sf` function is defined as a function variable
    at the top of our `webservice_helpers.go` file:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`sf`函数被定义为`webservice_helpers.go`文件顶部的函数变量：
- en: '[PRE66]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Prior to calling our `handleExists` helper function, we pull the `fileName`
    value from a query parameter.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用我们的`handleExists`助手函数之前，我们从查询参数中提取`fileName`值。
- en: What happens when we call `exists, err := handler.GcpInteractor.SourceFileExists(fileName)`
    ?
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`exists, err := handler.GcpInteractor.SourceFileExists(fileName)`时会发生什么？
- en: Let’s look at the series of function calls that will eventually return our results.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最终将返回我们结果的一系列函数调用。
- en: 'First, we visit `usecases.go` in the `usecases` layer. The `SourceFileExists`
    is a `GcpInteractor` method linked to `SourceBucketRepository`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们访问`usecases`层中的`usecases.go`。`SourceFileExists`是一个`GcpInteractor`方法，链接到`SourceBucketRepository`：
- en: '[PRE67]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'That call to `FileExists` brings us back the interfaces layer and calls the
    `FileExists` method in the infrastructure layer:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 对`FileExists`的调用将我们带回接口层，并在基础设施层中调用`FileExists`方法：
- en: '[PRE68]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**The /source-file-exists API flow of control**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**/source-file-exists API控制流**'
- en: 'The following chart and the upcoming diagram show the call stack starting from
    main where the `SourceExists` API is called:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表和即将出现的图表显示了从main开始的调用堆栈，其中调用了`SourceExists` API：
- en: '| **The flow of control goes from main.go to** |  | **Layer** |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| **控制流从main.go到** |  | **层** |'
- en: '| `webservices.go` (`SourceFileExists`) | to | interfaces (to user) |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `webservices.go` (`SourceFileExists`) | 到 | 接口（到用户）|'
- en: '| `usecases.go` (`SourceFileExists`) | to **1** | use cases |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `usecases.go` (`SourceFileExists`) | 到 **1** | 用例 |'
- en: '| `gcpstorage.go` (`FileExists`) | to **2** | interfaces (to GCP) |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `gcpstorage.go` (`FileExists`) | 到 **2** | 接口（到GCP）|'
- en: '| `gcphandler.go` (`FileExists`) | to **3** | infrastructure |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `gcphandler.go` (`FileExists`) | 到 **3** | 基础设施 |'
- en: '| `file.go` (`NewFile`) | to **4** | domain |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `file.go` (`NewFile`) | 到 **4** | 领域 |'
- en: '![](img/23e06acf-12b0-452f-b5a8-ecb34a8c400b.png)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e06acf-12b0-452f-b5a8-ecb34a8c400b.png)'
- en: Notice that the interfaces layer is traversed twice during this API call. The
    function call to `SourceFileExists` in `webservices.go` provides the programmatic
    interface between the user that requested the `/source-file-exists` end point
    and the use cases layer’s analogous `SourceFileExists` function, which defines
    what the user wants to do. The next interface in this call stack interacts with
    the Google Cloud Platform.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此API调用过程中，接口层被遍历两次。在`webservices.go`中对`SourceFileExists`的函数调用提供了用户请求`/source-file-exists`端点和用例层中类似的`SourceFileExists`函数之间的编程接口，该函数定义了用户想要做什么。此调用堆栈中的下一个接口与Google
    Cloud Platform进行交互。
- en: '**The /source-file-exists API call stack**'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**/source-file-exists API调用堆栈**'
- en: The following screenshot shows a single API call to the `/source-file-exists`
    web service. The call originates in main, where the web service endpoint is associated
    with the `SourceFileExists` function in `webservices.go`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了对`/source-file-exists`网络服务的单个API调用。调用起始于main，在那里网络服务端点与`webservices.go`中的`SourceFileExists`函数相关联。
- en: See how the flow of control moves from a user requesting a web service endpoint
    (in main) and flows upwards, from layer to layer?--`interfaces` | `use cases`
    | `interfaces` | `interfaces` | `infrastructure` | `domain`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 看到控制流是如何从用户请求网络服务端点（在主程序中）向上流动，从层到层的吗？--`interfaces` | `use cases` | `interfaces`
    | `interfaces` | `infrastructure` | `domain`。
- en: 'This is a powerful form of flow control that allows us to build complex applications,
    with many multidirectional logic flows and still adheres to the dependency rule,
    that is, we only import packages in one direction:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种强大的流程控制形式，它允许我们构建复杂的应用程序，具有许多多向逻辑流，并且仍然遵守依赖规则，即我们只在一个方向上导入包：
- en: '![](img/d5af7d15-91b8-432b-886b-ccb50af3b818.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5af7d15-91b8-432b-886b-ccb50af3b818.png)'
- en: Testing our interfaces
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试我们的接口
- en: In order to test our application, we'll create an `interfaces_test` directory
    inside our `interfaces` directory.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序，我们将在我们的`interfaces`目录内创建一个`interfaces_test`目录。
- en: Since `interfaces_test` is a different package than `interfaces`, we are unable
    to access the private functions and other symbols within the `interfaces` package.
    We are able to change our web service internals without breaking any tests. This
    also helps us focus on the API. We see just what any other client of our API will
    see when it's deployed and it simplifies our task of creating tests.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`interfaces_test`是一个不同于`interfaces`的包，我们无法访问`interfaces`包内的私有函数和其他符号。我们能够更改我们的网络服务内部而不破坏任何测试。这也帮助我们专注于API。当部署时，我们只看到我们的API的任何其他客户端将看到的内容，这简化了我们创建测试的任务。
- en: 'We use the `testing` package from the Go standard library:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Go标准库中的`testing`包：
- en: '[PRE69]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We declare `fileName` and `WebserviceHandler` that we populate in our following `init()`
    function:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了`fileName`和`WebserviceHandler`，我们在接下来的`init()`函数中填充：
- en: '[PRE70]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We reuse the `Api` struct that we used in our main. Instead of associating
    our APIs with a sample URL, we associate our `Api` with `expectedBody`:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了我们在主程序中使用的`Api`结构。我们将我们的API与`expectedBody`关联起来，而不是与示例URL关联：
- en: '[PRE71]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We only need one function to test our end points. We use an anonymous struct
    and a set of composite literals to create a group to test our data together in
    a simple, readable format:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个函数来测试我们的端点。我们使用匿名结构和一组复合文字来创建一个组，以简单、可读的格式一起测试我们的数据：
- en: '[PRE72]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As we iterate over our slice of endpoints, we call each `Api.Url`:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们迭代我们的端点切片时，我们调用每个`Api.Url`：
- en: '[PRE73]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We create a `ResponseRecorder` type that satisfies the `http.ResponseWriter`
    interface to record the response:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`ResponseRecorder`类型，满足`http.ResponseWriter`接口以记录响应：
- en: '[PRE74]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Since our handlers implement `http.Handler`, we can call their `ServeHTTP`
    method directly and fail the test if the status code is not okay:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的处理程序实现了`http.Handler`，我们可以直接调用它们的`ServeHTTP`方法，并在状态码不正确时失败测试：
- en: '[PRE75]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Lastly, we compare the returned response with the value we stored in the `expectedBody`
    field of endpoint (`ep`):'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将返回的响应与端点（`ep`）的`expectedBody`字段中存储的值进行比较：
- en: '[PRE76]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output should look like this:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是这样的：
- en: '[PRE77]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If you have any errors, the output will look something like this:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何错误，输出将看起来像这样：
- en: '[PRE78]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Infrastructure layer
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基础架构层
- en: 'This section will now talk about the infrastructure layer:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分现在将讨论基础架构层：
- en: '![](img/b4abc0fc-146a-4b1c-9bf0-75268165894a.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4abc0fc-146a-4b1c-9bf0-75268165894a.png)'
- en: The infrastructure layer is where the code that communicates with the external
    services exists, such as databases, cloud storage, or even a local filesystem.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 基础架构层是与外部服务通信的代码所在的地方，例如数据库、云存储，甚至本地文件系统。
- en: Since our code is separated into layers, we should be able to take all the functions
    from a layer and use them in a different application. The functions in our infrastructure
    layer have the least to do with our current problem domain, making them more applicable
    to other applications that need to interact with the Google Cloud Platform.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码分为不同的层，我们应该能够将一个层中的所有函数并在不同的应用程序中使用它们。我们基础架构层中的函数与我们当前的问题域关系最小，使它们更适用于需要与Google
    Cloud Platform交互的其他应用程序。
- en: While our `source` and `sink` functions in our interfaces layer may only make
    sense to our business and what we want to accomplish, the functions in the infrastructure
    layer such as `FileExists` and `ListBuckets` are less specific and hence more
    reusable.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们接口层中的`source`和`sink`函数可能只对我们的业务和我们想要实现的内容有意义，但基础架构层中的函数，如`FileExists`和`ListBuckets`，则不太具体，因此更具有重用性。
- en: 'Much of what we find in Go’s standard library, as shown in the following list,
    would belong in the infrastructure layer:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go标准库中找到的许多内容，如下列表所示，都属于基础架构层：
- en: '`database/sql`'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`database/sql`'
- en: '`log/syslog`'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log/syslog`'
- en: '`net/http`'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/http`'
- en: '`net/rpc`'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/rpc`'
- en: '`net/snmp`'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/snmp`'
- en: '`net/textproto`'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/textproto`'
- en: If a package potentially handles interactions with external systems, then it
    likely belongs in the infrastructure layer.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个包可能处理与外部系统的交互，那么它很可能属于基础架构层。
- en: 'This function signature is also Go idiomatic. It takes a single parameter and
    returns two values. The first is the results, while the second is an error:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数签名也是Go的惯用法。它接受一个参数并返回两个值。第一个是结果，第二个是错误：
- en: '[PRE79]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `FileExists()` function returns `true` if the files exist in the specified
    Google Cloud provider bucket. We build a function call chain to retrieve the bucket
    reader. In Go idiomatic fashion, it returns two values--one for the bucket reader
    and the other for a potential error.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileExists()`函数如果文件存在于指定的Google Cloud提供商存储桶中，则返回`true`。我们构建一个函数调用链来检索存储桶读取器。按照Go的惯例，它返回两个值--一个用于存储桶读取器，另一个用于潜在的错误。'
- en: Context object
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 上下文对象
- en: 'We must pass a context object that is passed to a `withContext` function that
    creates a new request object, based on the context. However, since the context
    is empty, this is what we might refer to as **code ceremony**. Note that in the
    next chapter on functional APIs we’ll cover passing request contexts in more depth.
    In this case, `ctx` is something we must pass so that our code compiles:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须传递一个上下文对象，该对象传递给一个`withContext`函数，该函数基于上下文创建一个新的请求对象。然而，由于上下文为空，这就是我们可能称之为**代码仪式**。请注意，在下一章关于功能API的章节中，我们将更深入地讨论传递请求上下文的问题。在这种情况下，`ctx`是我们必须传递的内容，以便我们的代码能够编译：
- en: '[PRE80]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Our `errors` package allows us to wrap our error with a specific error message
    and not lose the error message from GCP:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`errors`包允许我们用特定的错误消息包装我们的错误，并且不会丢失来自GCP的错误消息：
- en: '[PRE81]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Again, we see the idiomatic return of two values—the result and the error.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们看到了两个值的成语返回——结果和错误。
- en: 'We use another idomatic Go construct using a `defer` call to close our bucket
    reader. This is yet another example of how Go helps us write better code by making
    it easy to do the right thing. In languages that do not have a `defer` statement,
    we must remember to close our connection after performing our work. With Go, we
    can grab a handle to a data reader and immediately tell the application to close
    the connection when the function exits:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个典型的Go构造，使用`defer`调用来关闭我们的存储桶读取器。这是Go如何帮助我们编写更好的代码的又一个例子，因为它使得做正确的事情变得容易。在没有`defer`语句的语言中，我们必须记住在完成工作后关闭连接。而在Go中，我们可以立即获取数据读取器的句柄，并在函数退出时立即告诉应用程序关闭连接：
- en: '[PRE82]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Typically, when we encounter an error, it is best practice to wrap the error
    with a message that makes sense in context and to immediately return the error
    and whatever makes sense for the result value. In this case, since this is a call
    to `FileExists`, we return `false` if any error is encountered.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们遇到错误时，最佳做法是用上下文有意义的消息包装错误，并立即返回错误和对结果值有意义的内容。在这种情况下，由于这是对`FileExists`的调用，如果遇到任何错误，我们将返回`false`。
- en: If we make it to the last return statement, then the file in question exists
    and is of nonzero length. If the GCP API had a public `FileExists` function, we
    could call it, but this method will suffice for our purposes.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达最后的返回语句，那么所讨论的文件存在且长度非零。如果GCP API有一个公共的`FileExists`函数，我们可以调用它，但是这个方法对我们的目的已经足够了。
- en: We design each layer to be as simple and concise as possible. The interfaces
    layer's job is to move and possibly transform data as it flows between use cases
    and the underlying infrastructure.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计每一层尽可能简单和简洁。接口层的工作是在用例和基础设施之间流动和可能转换数据。
- en: 'Now, we''ll look at the `infrastructure/localhandler.go` file. Since there
    is only one local filesystem in our example, we do not need to provide a key to
    register `NewLocalHandler`:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下`infrastructure/localhandler.go`文件。由于我们的示例中只有一个本地文件系统，我们不需要提供一个键来注册`NewLocalHandler`：
- en: '[PRE83]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `FileExists()` function calls the standard library `os.Stat` function. All
    files in our example application will be stored in the `download` directory. Since
    the names of two return values have been defined in the `FileExists()` function
    signature, we only need to set their values where appropriate and execute a bare
    return statement.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileExists()`函数调用标准库`os.Stat`函数。我们示例应用程序中的所有文件都将存储在`download`目录中。由于在`FileExists()`函数签名中已定义了两个返回值的名称，因此我们只需要在适当的位置设置它们的值并执行一个简单的返回语句。'
- en: '[PRE84]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `GetLocalInteractor` function ties its repository (the local filesystem)
    to its interfaces. Our small example has only one method, `FileExists`:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLocalInteractor`函数将其存储库（本地文件系统）与其接口绑定。我们的小例子只有一个方法，`FileExists`：'
- en: '[PRE85]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Granted, this is a lot of code for wiring up just one method, but a typical
    enterprise application has external persistence dependencies each with a potentially
    large number of methods. Our layered architecture provides the structure required
    to extend a large application with minimal effort.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这是为了连接一个方法而编写的大量代码，但是典型的企业应用程序具有外部持久性依赖关系，每个依赖关系可能有大量的方法。我们的分层架构提供了扩展大型应用程序所需的结构，而只需付出最少的努力。
- en: 'In a nutshell, a layered architecture:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，分层架构：
- en: Provides the structure required to extend a large application with minimal effort
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了扩展大型应用程序所需的结构，而只需付出最少的努力
- en: Enforces high cohesion, based on a layered approach
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于分层方法，强制高内聚
- en: Keeps components loosely coupled by managing function references
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过管理函数引用来保持组件松散耦合
- en: Adheres to the dependency rule
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循依赖规则
- en: Uses the Hollywood Principle by injecting dependencies during application initialization
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用好莱坞原则，在应用程序初始化期间注入依赖项
- en: If your application is growing large and you are having issues with cyclic dependencies,
    the layered architecture is worth your consideration.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序正在不断增长，并且出现循环依赖的问题，分层架构值得您考虑。
- en: Benefits of DDD
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DDD的好处
- en: 'The following are the benefits of DDD technique:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: DDD技术的好处如下：
- en: Adaptability
  id: totrans-545
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 适应性
- en: 'DDD makes adding a new ways to interact with our application easy. We simply
    add a new interactor, that is, our port/adapter, to our `WebServiceHandler`. In
    our onion.go application, we have two different ways to communicate with our application:
    the local file system and the Google Cloud Platform.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: DDD使得添加新的与应用程序交互的方式变得容易。我们只需向我们的`WebServiceHandler`添加一个新的交互器，也就是我们的端口/适配器。在我们的onion.go应用程序中，我们有两种不同的方式与我们的应用程序进行通信：本地文件系统和Google
    Cloud Platform。
- en: Sustainability
  id: totrans-547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可持续性
- en: By decoupling our application business logic from the tools we are using, for
    example, Google Cloud Platform, we make it less vulnerable vendor lock-in and
    issues and dependency on services that become defunct or out dated.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将应用程序业务逻辑与我们正在使用的工具（例如Google Cloud Platform）解耦，我们使其不太容易受到供应商锁定和服务变得过时或失效的影响。
- en: Testability
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可测试性
- en: The use of interactors eases the usage of mocks in order to test our applicative
    services and domain code. Tests can be written for our application service layer
    before we decide which technology (REST, Messaging, etc.) to be plugged with its
    corresponding port/adapter.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 使用交互器可以简化我们应用服务和领域代码的测试，以便在决定使用哪种技术（REST、消息传递等）与其相应的端口/适配器连接之前，可以为我们的应用服务层编写测试。
- en: Comprehensibility
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可理解性
- en: The applicative use case layer clearly indicates our application's functional
    intentions.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 应用用例层清楚地表明了我们应用的功能意图。
- en: A solid architectural foundation
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坚实的架构基础
- en: This layered architecture can form the basis for supporting additional architectural
    patterns including REST, CQRS, event driven architectures and event sourcing.
    That's why we focused on DDD.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层架构可以成为支持其他架构模式的基础，包括REST、CQRS、事件驱动架构和事件溯源。这就是为什么我们专注于DDD。
- en: FP and Micyoservices
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP和微服务
- en: Let's look hints of FP philosophies in microservices and related architecturesof 
    event driven architectures, CQRS, Lambda Architecture and  functional reactive
    programming.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在微服务和相关架构中寻找FP哲学的线索，如事件驱动架构、CQRS、Lambda架构和函数式响应式编程。
- en: 'The architectures we will consider leverage FP philosophies in different ways
    to achieve their goals of being:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的架构以不同的方式利用FP哲学来实现其可扩展性和响应性的目标：
- en: Event driven
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动
- en: Scalable
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展
- en: Responsive
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应
- en: Resilient
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性
- en: Message passing
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息传递
- en: 'These architectures frequently employ fanout strategies to improve performance.
    For example, an application might have a series of requests that block while performing
    each request as follows:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这些架构经常采用扇出策略来提高性能。例如，一个应用程序可能有一系列请求，在执行每个请求时会阻塞，如下所示：
- en: '![](img/d83ac674-1eb8-4779-ac18-4da55628db0f.png)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d83ac674-1eb8-4779-ac18-4da55628db0f.png)'
- en: If each request takes 1 second the total time required to send, receive and
    compose all responses will be 3 seconds.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个请求需要1秒，发送、接收和组合所有响应所需的总时间将为3秒。
- en: 'When possible, we should opt to perform each request asynchronously by fanning
    out our requests as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我们应该选择通过扇出请求来异步执行每个请求，如下所示：
- en: '![](img/459d9aa2-b05d-4362-b00f-8b2b3e50cf62.png)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![](img/459d9aa2-b05d-4362-b00f-8b2b3e50cf62.png)'
- en: This would reduce the time required to process all requests from 3 seconds to
    1 second.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把处理所有请求所需的时间从3秒减少到1秒。
- en: Asynchronous processing takes less time which frees up our resources faster.
    This minimizes latency and reduces contention for our shared resources. We have
    just solved one of the biggest hurdles to scalability and improved overall throughput
    and performance.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 异步处理所需的时间较短，可以更快地释放资源。这最小化了延迟，并减少了对共享资源的争用。我们刚刚解决了可扩展性的最大障碍之一，并提高了整体吞吐量和性能。
- en: All parties must participate
  id: totrans-570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 所有参与方必须参与
- en: In order to reap the full benefits of non-blocking execution all parts in a
    request/response chain needs to participate in the non-blocking asynchronous call.
    If any resource, whether inside or outside the service boundary blocks, then we’ve
    got a problem.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用非阻塞执行的所有优势，请求/响应链中的所有部分都需要参与非阻塞异步调用。如果服务边界内外的任何资源都阻塞，那么我们就有问题。
- en: What’s the problem with blocking?
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞有什么问题？
- en: Usually resources provide access via a processing thread. Threads are limited.
    If all the threads are busy, subsequent requests must wait until one becomes available.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 通常资源通过处理线程提供访问。线程是有限的。如果所有线程都忙碌，后续请求必须等待直到有一个可用。
- en: Asynchronous message passing helps us focus on workflows and interaction patterns
    between our services.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 异步消息传递帮助我们专注于服务之间的工作流程和交互模式。
- en: Communication across boundaries
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨界通信
- en: When communicating between our independent, isolated services we can only request
    its state. Each service responds to requests with immutable data that reflects
    its current state.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们独立、隔离的服务之间通信时，我们只能请求其状态。每个服务都以不可变数据响应请求，反映其当前状态。
- en: Polyglot Persistence
  id: totrans-577
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多语言持久性
- en: 'Each service may use different storage repository technologies such as:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务可能使用不同的存储库技术，例如：
- en: Eventlog
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件日志
- en: Graph DB
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据库
- en: NoSQL
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL
- en: RDBMS
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库管理系统
- en: Timeseries DB
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列数据库
- en: The storage technology does not matter. What's important is that each service
    is responsible for its state, providing access to immutable data only via its
    API.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 存储技术并不重要。重要的是每个服务对其状态负责，只通过其API提供对不可变数据的访问。
- en: Lambda architecture
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda架构
- en: 'The Lambda architecture is a generic, scalable and fault-tolerant data processing
    architecture that handles data at-rest as well as data in-motion. It’s comprised
    of three layers:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda架构是一种通用的、可扩展的、容错的数据处理架构，处理静态数据和动态数据。它由三层组成：
- en: Speed
  id: totrans-587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 速度
- en: This layer for real time processing. The Realtime views may not be as accurate
    or complete as the ones eventually produced by the batch layer, but they are available
    as soon as data is received and can be replaced when the batch layer's views for
    the same data becomes available.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层用于实时处理。实时视图可能不如批处理层最终产生的视图准确或完整，但它们在接收数据后立即可用，并且可以在批处理层的相同数据的视图可用时进行替换。
- en: Batch
  id: totrans-589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 批处理
- en: This layer can store a large amount of data. Output is typically stored in a
    read-only database. Any errors can be fixed by recomputing based on a complete
    data set at which time views can be updated. Apache Hadoop is the de facto standard
    batch-processing system used in most high-throughput architectures. Response times
    can be measured in minutes or even hours.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层可以存储大量数据。输出通常存储在只读数据库中。任何错误都可以通过基于完整数据集的重新计算来修复，此时视图可以更新。Apache Hadoop是大多数高吞吐架构中使用的事实标准批处理系统。响应时间可以用分钟甚至小时来衡量。
- en: Servicing
  id: totrans-591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务化
- en: Output from the batch and speed layers are stored in the serving layer, which
    responds to ad-hoc queries by returning precomputed views or building views from
    processed data.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理层和速度层的输出存储在服务层中，通过返回预先计算的视图或从处理过的数据构建视图来响应临时查询。
- en: '![](img/bc46f13d-2264-4643-b254-9d38e92254c1.png)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc46f13d-2264-4643-b254-9d38e92254c1.png)'
- en: Some Lambda implementations have various storage and technology decisions, but
    they all have a batch and a real time components that both consume the same data
    and a real time view that can be updated by corrected data from batch processing.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Lambda实现有各种存储和技术决策，但它们都有批处理和实时组件，两者都使用相同的数据，并且实时视图可以通过批处理的纠正数据进行更新。
- en: The problem with this architecture is that the same data is ingested by both
    the Speed and by the Batch layer and typically stored in two separate databases,
    Cassandra and HBASE in the example above. Plus, extra processing occurs when the
    batch jobs return fixed up batch view data that needs to be merged into the related
    real time views.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的问题在于相同的数据同时被Speed层和Batch层摄取，并且通常存储在两个单独的数据库中，例如上面的Cassandra和HBASE。此外，当批处理作业返回需要合并到相关实时视图中的修复批处理视图数据时，会发生额外的处理。
- en: Next generation big data architecture
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下一代大数据架构
- en: The next generation big data architecture has dropped the batch layer completely.
    The purely real time system brings stream processing directly into the services
    architecture where the data is stored via event logging. The most current data
    is stored in the database and the history of events is stored in the event logs.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 下一代大数据架构已完全放弃了批处理层。纯实时系统直接将流处理带入了服务架构，数据通过事件日志存储。最新的数据存储在数据库中，事件的历史存储在事件日志中。
- en: CQRS
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CQRS
- en: '**Command and Query Responsibility Segregation** (**CQRS**) is an architecture
    style that separates read operations from write operations.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令和查询责任分离**（CQRS）是一种将读操作与写操作分离的架构风格。'
- en: Traditionally, the same data model is used to query and update a database. However,
    more complex applications, problems with this shared data model appear. For example,
    To satisfy the write requirements our data model need to contain complex validation
    and business logic. Our read requirements will have no need for that extra logic.
    Instead, it may need to perform many different queries, using data structures
    that are needed by our write component. Complexity is increased on both sides.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，相同的数据模型用于查询和更新数据库。然而，对于更复杂的应用程序，共享数据模型会出现问题。例如，为了满足写入要求，我们的数据模型需要包含复杂的验证和业务逻辑。我们的读取要求不需要额外的逻辑。相反，它可能需要执行许多不同的查询，使用写入组件所需的数据结构。复杂性在两方面都增加了。
- en: CQRS addresses these problems by separating reads and writes into separate models,
    using commands to update data, and queries to read data.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS通过将读取和写入分离到单独的模型中，使用命令更新数据，使用查询读取数据来解决这些问题。
- en: Commands are based on tasks, rather than specific create or update commands.
    For example, *Upgrade Car*, rather than *append LX* to `model_name` field. Commands
    are placed on a queue for asynchronous processing.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 基于任务的命令，而不是特定的创建或更新命令。例如，*升级汽车*，而不是将*append LX*添加到`model_name`字段。命令被放置在队列中进行异步处理。
- en: Queries return plain data objects that have no behavior or domain knowledge.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回没有行为或领域知识的纯数据对象。
- en: '![](img/be42284f-92d4-46a7-85c7-33e8bcbfaf61.png)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be42284f-92d4-46a7-85c7-33e8bcbfaf61.png)'
- en: Benefits of CQRS
  id: totrans-605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CQRS的好处
- en: CQRS **optimizes performance**. The command service/event store side can be
    optimized for updates while the query service/materialized view side can be optimized
    for queries.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS **优化性能**。命令服务/事件存储端可以针对更新进行优化，而查询服务/物化视图端可以针对查询进行优化。
- en: CQRS **simplifies queries** by storing a materialized view in the read database.
    Complex joins can be avoided and performance improved.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS通过在读取数据库中存储物化视图来**简化查询**。可以避免复杂的连接并提高性能。
- en: CQRS **separates** of writing and reading which greatly simplifies the business
    logic in the query model and puts the complex validation and business logic in
    the command model where it belongs.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS **分离**了写入和读取，大大简化了查询模型中的业务逻辑，并将复杂的验证和业务逻辑放在命令模型中。
- en: CQRS allows the reads and writes to **scale****independently.**
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS允许读取和写入**独立扩展**。
- en: CQRS relies on messaging which is a good fit for message-based microservices.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS依赖于消息传递，这非常适合基于消息的微服务。
- en: '![](img/4c7791c2-e632-46e8-9bd1-5c3c655992ec.png)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c7791c2-e632-46e8-9bd1-5c3c655992ec.png)'
- en: Above, microservice1 writes to its database which publishes a write event. Microservice2
    and microservice3 subscribe to microservice1's write event and get updated every
    time that event occurs.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，微服务1写入其数据库，然后发布写入事件。微服务2和微服务3订阅微服务1的写入事件，并在每次发生该事件时得到更新。
- en: Infrastructure architecture
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础架构架构
- en: 'Developing an isolated microservice is very easy in comparison to designing,
    developing and configuring its infrastructure. Infrastructure includes things
    like:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计、开发和配置基础架构相比，开发独立的微服务非常容易。基础架构包括诸如：
- en: Accessing and ingesting logs
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问和摄取日志
- en: Balancing loads
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡负载
- en: Checking application health
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查应用程序健康状况
- en: Database replication
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库复制
- en: Debugging applications
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试应用程序
- en: Distributing secrets
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发秘钥
- en: Integrating other services
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成其他服务
- en: Monitoring resources
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控资源
- en: Mounting storage systems
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载存储系统
- en: Naming and discovering
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名和发现
- en: Orchestrating/Coordination
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排/协调
- en: Providing authentication and authorization
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供身份验证和授权
- en: Replicating application instances
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制应用程序实例
- en: Rolling updates
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动更新
- en: Using Horizontal Autoscaling
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用水平自动缩放
- en: Share nothing architecture
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享无架构
- en: A share nothing architecture (SN) is a distributed computing architecture where
    each node is independent and self-sufficient. Nodes do not share data storage
    and there is no single point of contention across the system. Sounds a lot like
    a microservice, right?
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 共享无架构（SN）是一种分布式计算架构，其中每个节点都是独立和自给自足的。节点不共享数据存储，系统中没有单一的争用点。听起来很像微服务，对吧？
- en: The problem with SN architectures is that join operation between the nodes can
    be time consuming.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: SN架构的问题在于节点之间的连接操作可能耗时。
- en: SN eliminates shared mutable state, minimizes resource contention and increases
    scalability.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: SN消除了共享的可变状态，最小化了资源争用，并增加了可扩展性。
- en: Integrating services
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成服务
- en: Microservices have no control over other microservices externally or internally.
    It is important that our digital fabric of microservices agree on acceptable communication
    protocols.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务在外部或内部对其他微服务没有控制。我们的微服务数字化结构就必须就可接受的通信协议达成一致。
- en: Agreed upon protocol
  id: totrans-636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 协商一致的协议
- en: The protocol should enforce policies regarding security, the direction and velocity
    of the flow of data as well as flow control.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 协议应该强制执行有关安全性、数据流的方向和速度以及流量控制的政策。
- en: Circuit breakers
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断路器
- en: 'In order to prevent cascading failures there should be mechanisms in place
    such as  fail fast circuit breakers. Management of retries for failed requests
    should consider things like:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止级联故障，应该有一些机制，比如快速失败断路器。对于失败的请求的重试管理应该考虑以下事项：
- en: How long should we wait to retry?
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该等多久才能重试？
- en: Should we monitor the endpoint and wait for it to get back online and then try
    again?
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该监视端点并等待它恢复在线，然后再尝试吗？
- en: When do we notify devops about the failure?
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们什么时候通知运维部门有关故障？
- en: Functional reactive architecture
  id: totrans-643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式响应式架构
- en: Functional reactive architecture (FRP) is similar to other architectures in
    that it embraces many of the FP concepts such as immutable data structures, event
    streaming and data transformation, but different in that it is a front-end architecture.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式响应式架构（FRP）与其他架构类似，它包含了许多FP概念，如不可变数据结构、事件流和数据转换，但不同之处在于它是一个前端架构。
- en: Reactive Functional Programming (RFP) incorporates aspects from both Reactive
    Programming (RP) and Functional Programming (FP).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式函数式编程（RFP）结合了响应式编程（RP）和函数式编程（FP）的方面。
- en: '![](img/1b97bc3a-fbfb-40e9-b756-826dcc2a45ff.png)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b97bc3a-fbfb-40e9-b756-826dcc2a45ff.png)'
- en: Let’s look at an example to get a better appreciation for the connection between
    FRP and FP.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，更好地理解FRP和FP之间的联系。
- en: 'Suppose we have a User Interface (UI) application that sums two numbers:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个用户界面（UI）应用程序，可以对两个数字求和：
- en: '![](img/91fce353-6b82-4274-a0e2-7f0540c523d9.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91fce353-6b82-4274-a0e2-7f0540c523d9.png)'
- en: There is a lot more to RFP (immutable data structures, memoization, state and
    event management, and so on). Since this is a front end technology the logic will
    not be Go, but rather JavaScript (which is one of my specialties).
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: RFP还有很多内容（不可变数据结构、记忆化、状态和事件管理等）。由于这是一个前端技术，逻辑不会是Go，而是JavaScript（这是我的专长之一）。
- en: 'So, if you like my style of writing and would like me to write a book combining
    Go, ReactJS and some distributed data store technology let me hear from you. Please
    post your feedback here: [https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW](https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW)'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你喜欢我的写作风格，并希望我写一本结合Go、ReactJS和一些分布式数据存储技术的书，请让我知道。请在这里发表你的反馈意见：[https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW](https://www.amazon.com/Learning-Functional-Programming-Lex-Sheehan-ebook/dp/B0725B8MYW)
- en: Go is ideal for building microservices
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go非常适合构建微服务
- en: 'Distributed computing involves the horizontal scaling our our microservices.
    We have seen that when we can dramatically improve performance by running our
    tasks in parallel.  In order to manage, order and orchestrate our workloads we
    need a simple mechanism.   What simpler solution exists for creating and running
    applications concurrently? (Answer: None.)'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算涉及水平扩展我们的微服务。我们已经看到，通过并行运行任务，我们可以显著提高性能。为了管理、排序和编排我们的工作负载，我们需要一个简单的机制。还有什么更简单的解决方案可以用于并发创建和运行应用程序？（答案：没有。）
- en: 'Here''re some of Go''s features that make it ideal for microservice environments:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使Go成为微服务环境理想选择的功能：
- en: Simplicity
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Concurrency
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Speed at compile time
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译速度
- en: Speed at runtime
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时速度
- en: Security
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Networking/gRPC/Protocol buffers
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络/gRPC/协议缓冲区
- en: Systems programming
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统编程
- en: Small footprint
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小的占用空间
- en: Go is built upon the philosophy of simplicity. To write go code is to write
    practical code.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Go建立在简单的哲学之上。编写go代码就是编写实用的代码。
- en: Concurrency is baked into the Go language in the form of goroutines and channels.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 并发已经内置到Go语言中，以goroutines和通道的形式。
- en: For a coding example using goroutines and channels see [Chapter 5](../Text/Ch05.xhtml), *Adding
    Functionality with Decoration*.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用goroutines和通道的编码示例，请参见[第5章](../Text/Ch05.xhtml)，*使用装饰添加功能*。
- en: Go's compile times are extremely fast. Once compiled, Go binaries are native
    executables.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: Go的编译时间非常快。一旦编译完成，Go二进制文件就是本机可执行文件。
- en: There are no virtual environments to install, configure, import dependencies
    from, deploy and manage. The only footprint is a small native executable. That's
    less surface area for attackers to exploit.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 没有虚拟环境需要安装、配置、导入依赖项、部署和管理。唯一的占用空间是一个小的本机可执行文件。这对攻击者来说是更小的攻击面。
- en: Size matters
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小很重要
- en: 'Let''s face it. Size matters. If you are paying for the resources (CPU, storage,
    networking, and so on) which would you prefer to pay for:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实吧。大小很重要。如果你正在为资源（CPU、存储、网络等）付费，你更愿意为哪种资源付费：
- en: 1,000 of these?
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 1000个这样的？
- en: '![](img/18b3dc63-c403-465f-9d82-fb3c95356e23.png)'
  id: totrans-671
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18b3dc63-c403-465f-9d82-fb3c95356e23.png)'
- en: Or 1,000 of these?
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 还是1000个这样的？
- en: '![](img/0deec193-8365-46e0-839f-34bb874a5377.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0deec193-8365-46e0-839f-34bb874a5377.png)'
- en: Benefits of gRPC
  id: totrans-674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: gRPC的好处
- en: If you need to employ a request/response architecture, using gRPC with protocol
    buffers is the way to go. gRPC allow us to easily release SDKs. Now integration
    is a matter of and asking the other developers to copy-paste example code written
    in their language. This represents a big win for companies what want to integrate
    with our products, while not requiring us to implement entire SDKs in all the
    various languages that our vendors and partners use.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用请求/响应架构，使用gRPC和协议缓冲区是一个好方法。gRPC使我们能够轻松发布SDK。现在集成只是要求其他开发人员复制粘贴用他们的语言编写的示例代码。这对于希望与我们的产品集成的公司来说是一个巨大的胜利，而不需要我们在所有各种语言中实现整个SDK。
- en: gRPC is built on HTTP/2 HTTP/2's client-side and/or server-side streaming allow
    for faster response times and support for bulk ingestion and bi-directional streaming.
    We can asynchronously stream requests/responses; The server would stream back
    status messages, allowing for easy checkpoint operations. This allows us to process
    uploads as fast as possible without blocking for confirmations.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC建立在HTTP/2之上，HTTP/2的客户端端和/或服务器端流允许更快的响应时间，并支持批量摄入和双向流。我们可以异步地流式传输请求/响应；服务器会流回状态消息，从而实现简单的检查点操作。这使我们能够尽可能快地处理上传，而不会因为确认而阻塞。
- en: By using protocol buffers with gRPC, we'll improve serialization and deserialization
    performance. Clients receive typed objects rather than free form JSON. This allows
    our clients can reap the benefits of type-safety, auto-completion in their IDEs,
    and improved version management.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用gRPC和协议缓冲区，我们将提高序列化和反序列化性能。客户端接收的是类型化的对象，而不是自由形式的JSON。这使得我们的客户端可以享受类型安全、IDE中的自动完成和改进的版本管理的好处。
- en: gRPC enables us to write one interface definition, in the proto format, for
    both the client and server side of our APIs. Interface driven development enables
    both development teams to work in parallel. That makes us leaner, providing more
    value faster.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC使我们能够为API的客户端和服务器端编写一个接口定义，格式为proto。接口驱动的开发使得两个开发团队可以并行工作。这使我们更加精简，更快地提供更多价值。
- en: Who is using Go?
  id: totrans-679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 谁在使用Go？
- en: 'A short list of  systems and infrastructure tools being built in Go includes:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 一些正在使用Go构建的系统和基础设施工具的简短列表包括：
- en: Docker
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Kubernetes
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Packer
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packer
- en: CoreOS
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreOS
- en: InfluxDB
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InfluxDB
- en: Etcd
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Etcd
- en: NSQ,
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSQ，
- en: Summary
  id: totrans-688
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the importance of the dependency rule. We learned
    that we can only import packages in one direction. We learned how to separate
    a complex application into layers.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了依赖规则的重要性。我们了解到我们只能单向导入包。我们学会了如何将复杂的应用程序分成层。
- en: We learned how to use dependency injection to interact between our application
    layers and implemented an application using a layered architecture.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用依赖注入来在应用程序层之间进行交互，并实现了一个使用分层架构的应用程序。
- en: The key to selecting the right architecture is a deep understanding our system's
    requirements, existing components and the capabilities of available technologies
    choices.  At the end of the day it’s the system engineer’s job to ensure the entire
    system works properly.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的架构的关键是深入了解我们系统的要求、现有组件和可用技术选择的能力。最终，系统工程师的工作是确保整个系统正常运行。
- en: In the next chapter, we'll learn about functors, monoids, type classes, and
    other functional programming concerns.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习有关函子、单子、类型类和其他函数式编程问题的内容。
