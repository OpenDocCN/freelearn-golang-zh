- en: Increasing Performance Using Pipelining
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道提高性能
- en: Often, we feel the need to work on some data and pass it along a series of steps,
    transforming it along the way before it arrives at its destination. We come across
    these sort of processes occurring in real-life scenarios, especially in factory
    assembly line environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们感到需要处理一些数据并将其传递到一系列步骤中，在到达目的地之前沿途对其进行转换。我们经常在现实生活场景中遇到这种过程，特别是在工厂装配线环境中。
- en: In this chapter, we will see how the pipeline patterns can be used to build
    component-based applications. We'll see how we can use function composition data
    flow programming techniques to create flexible solutions that are not only robust,
    but also performant in today's distributed processing environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用管道模式来构建基于组件的应用程序。我们将看到如何使用函数组合数据流编程技术来创建灵活的解决方案，这些解决方案不仅健壮，而且在当今的分布式处理环境中也具有高性能。
- en: 'Our goal in this chapter is to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的目标是：
- en: Be able to identify when to use the pipeline pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够确定何时使用管道模式
- en: Learn how to build a pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何构建管道
- en: Understand how we can leverage buffering to increase throughput
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何利用缓冲来增加吞吐量
- en: Use Goroutines and channels to process data faster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Goroutines和通道更快地处理数据
- en: Improve API readability using interfaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口提高API可读性
- en: Implement useful filters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现有用的过滤器
- en: Build a flexible pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建灵活的管道
- en: See what happens when you change the order of filters and submit invalid data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看更改过滤器顺序并提交无效数据时会发生什么
- en: Introducing the pipeline pattern
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍管道模式
- en: The pipeline software design pattern is used in cases where data flows through
    a sequence of stages where the output of the previous stage is the input of the
    next. Each step can be thought of as a filter operation that transforms the data
    in some way. Buffering is frequently implemented between filters to prevent deadlock
    or data loss when one filter runs faster than another filter connected to it.
    Connecting the filters into a pipeline is analogous to function composition.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 管道软件设计模式用于数据流经过一系列阶段的情况，其中前一阶段的输出是下一阶段的输入。每个步骤都可以被视为一种过滤操作，以某种方式转换数据。在过滤器之间经常实现缓冲，以防止死锁或当一个过滤器比连接到它的另一个过滤器运行得更快时发生数据丢失。将过滤器连接到管道中类似于函数组合。
- en: 'The following diagram depicts the flow of data from a data source, for example,
    a file. The data is transformed as it passes from one filter to the next, until
    the result is finally displayed on standard out in the console:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了数据从数据源（例如文件）流过滤器直到最终在控制台上的标准输出中显示的流程：
- en: '![](img/a8ba339a-0300-4012-8a27-280779c6fc81.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8ba339a-0300-4012-8a27-280779c6fc81.png)'
- en: Grep sort example
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Grep排序示例
- en: 'The `/etc/group` file is the data source. Grep is the first filter whose input
    is all the lines from the `/etc/group` file. The `grep` command removes all lines
    that do not begin with `"com"`, and then sends its output to the Unix pipe, which
    sends that data to the `sort` command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/group`文件是数据源。Grep是第一个过滤器，其输入是来自`/etc/group`文件的所有行。`grep`命令删除所有不以“com”开头的行，然后将其输出发送到Unix管道，该管道将数据发送到`sort`命令：'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's be clear. What we're covering in this chapter behaves like Unix pipes,
    but what we'll study are pipelines that are implemented in Go, mainly using Go
    channels and Goroutines. Similarly, we will not discuss Go Pipes ([https://golang.org/pkg/os/#Pipe](https://golang.org/pkg/os/#Pipe))
    other than to say that they are unbuffered, unstructured streams of bytes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们明确一点。我们在本章中涵盖的行为类似于Unix管道，但我们将研究的是使用Go实现的管道，主要使用Go通道和Goroutines。同样，我们不会讨论Go
    Pipes（[https://golang.org/pkg/os/#Pipe](https://golang.org/pkg/os/#Pipe)），除了它们是无缓冲的、无结构的字节流。
- en: Pipeline characteristics
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道特性
- en: 'The pipeline pattern affords a number of valuable benefits that are desirable
    in properly engineered applications; these benefits are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 管道模式提供了许多有价值的优点，这些优点在正确设计的应用程序中是可取的；这些优点如下：
- en: Provides the structure for a system that processes data
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一个处理数据的系统结构
- en: Divides tasks into sequential steps
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务分解为顺序步骤
- en: Encapsulates each step in a filter
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装每个步骤的过滤器
- en: Independent filters (run in isolation) with a set of inputs and outputs
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的过滤器（独立运行）具有一组输入和输出
- en: Data passes through a pipeline in one direction
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据通过管道单向传递
- en: Configurable modularity (read, write, split, and merge operations)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置的模块化（读取、写入、拆分和合并操作）
- en: High cohesion, where filter logic is self-contained
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高内聚，过滤器逻辑是自包含的
- en: Low coupling, where filters communicate through connecting pipes
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低耦合，过滤器通过连接管道进行通信
- en: Distinction between batch and online processing disappears
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批处理和在线处理之间的区别消失
- en: The pipeline pattern has many characteristics that make it appealing for a variety
    of use cases. We see it in use in technologies ranging from constant integration
    and deployment pipelines, to batch and stream data processing. If there is a need
    to handle the flow of data in an assembly line fashion, then we should consider
    using this pipeline pattern.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 管道模式具有许多特点，使其在各种用例中都很有吸引力。我们看到它在技术中的应用范围从持续集成和部署管道到批处理和流数据处理。如果需要以装配线方式处理数据流，那么我们应该考虑使用这种管道模式。
- en: 'Let''s take a look at the advantages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看优势：
- en: '**Extensibility**: Add another filter to the pipeline'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：向管道添加另一个过滤器'
- en: '**Flexibility**: Function composition by connecting filters'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：通过连接过滤器进行函数组合'
- en: '**Performance**: Utilizes multi-processor systems'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：利用多处理器系统'
- en: '**Testability**: Easy to analyze, evaluate, and test pipe filter systems'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：易于分析、评估和测试管道过滤器系统'
- en: As with any pattern, we must consider its potential issues.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何模式一样，我们必须考虑其潜在问题。
- en: 'Here are some of the disadvantages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些缺点：
- en: Potential data transformation overhead
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的数据转换开销
- en: Potential deadlock and buffer overflow
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的死锁和缓冲区溢出
- en: Potential reliability issues if infrastructure loses the data flowing between
    filters
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果基础设施丢失了过滤器之间流动的数据，可能会出现潜在的可靠性问题
- en: Potential reprocessing of data if a filter fails after sending results downstream,
    but before indicating that processing was successfully completed (design filters
    in a pipeline to be idempotent)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果过滤器在向下游发送结果后失败，但在成功完成处理之前指示失败，则可能需要重新处理数据（在管道中设计过滤器为幂等）
- en: Potentially large context, since each filter must be provided with sufficient
    context to perform its work
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 潜在的大上下文，因为每个过滤器必须提供足够的上下文来执行其工作
- en: 'Here are some high-level use cases, which if applicable, make this pipeline
    pattern an attractive design solution candidate:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些高级用例，如果适用，使得这种管道模式成为一个有吸引力的设计解决方案候选：
- en: Processing requirements can be decomposed into a set of independent steps
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理要求可以分解为一组独立的步骤
- en: Filter operations can take advantage of multi-core processors or distributed
    computing
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器操作可以利用多核处理器或分布式计算
- en: Each filter has different scalability requirements
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个过滤器都有不同的可扩展性要求
- en: A system that must accommodate reordering of processing steps
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须容纳处理步骤的重新排序的系统
- en: Examples
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例
- en: Now, let's look at some examples to help appreciate the value and applicability
    of this pipeline pattern.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些示例，以帮助理解这种管道模式的价值和适用性。
- en: Website order processing
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 网站订单处理
- en: 'The following diagram depicts the flow of an order from the website that displays
    the order form to the user. The filters along the way perform various tasks, such
    as decrypting the request payload, authenticating the user credentials, charging
    the customer''s credit card, sending the customer a confirmation email, and finally,
    displaying the thank you page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了订单从网站显示订单表单到用户的流程。沿途的过滤器执行各种任务，如解密请求有效载荷，验证用户凭据，向客户信用卡收费，发送确认电子邮件给客户，最后显示感谢页面。
- en: '![](img/3164bd3c-f56b-47f9-a36d-43f5ca76cd34.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3164bd3c-f56b-47f9-a36d-43f5ca76cd34.png)'
- en: Boss worker pattern
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 老板工人模式
- en: 'In the boss worker pattern, the **Boss** filter pushes data down to the workers
    that process the data and merge the results into the **Product**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在老板工人模式中，**老板**过滤器将数据推送到处理数据并将结果合并到**产品**中的工作人员：
- en: '![](img/4e2256fb-62d4-484e-a677-2699938dbd25.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e2256fb-62d4-484e-a677-2699938dbd25.png)'
- en: Load balancer
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: 'The following example shows a **Load Balancer** that takes requests from clients
    and sends them to the server that has the smallest backlog and is most available
    to handle the request information packet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个**负载均衡器**，它接收来自客户端的请求并将其发送到具有最小积压和最可用于处理请求信息包的服务器：
- en: '![](img/641536af-3cf2-4026-8356-fffa971bad36.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/641536af-3cf2-4026-8356-fffa971bad36.png)'
- en: Data flow types
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据流类型
- en: 'The data flow types can be viewed as **Read**, **Split**, **Merge**, and **Write**
    operations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流类型可以被视为**读取**、**分割**、**合并**和**写入**操作：
- en: '| **Filter type** | **Image** | **Receive** | **Send** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **过滤器类型** | **图像** | **接收** | **发送** | **描述** |'
- en: '| **Read** | ![](img/581df9d3-ea69-4bba-b5fd-98816201ed16.png) |  | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | A **Read** filter reads data from the data source and sends the information
    packet downstream. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **读取** | ![](img/581df9d3-ea69-4bba-b5fd-98816201ed16.png) |  | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | **读取**过滤器从数据源读取数据并将信息包发送到下游。'
- en: '| **Split** | ![](img/beb61560-0dff-4ba2-9537-2ed634a6c356.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | Multiple functions read from the same channel until that channel is closed.
    It improves the performance by distributing work among a group of workers to parallelize
    CPU usage. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **分割** | ![](img/beb61560-0dff-4ba2-9537-2ed634a6c356.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | 多个函数从同一通道读取，直到该通道关闭。通过将工作分配给一组工作人员以并行化CPU使用，可以提高性能。'
- en: '| **Transform** | ![](img/906ea89c-b1e8-400a-9abf-f37907bf6d16.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png) | This filter receives data
    from upstream, transforms it, and sends it downstream. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **转换** | ![](img/906ea89c-b1e8-400a-9abf-f37907bf6d16.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png) | 这个过滤器从上游接收数据，对其进行转换，然后发送到下游。'
- en: '| **Merge** | ![](img/b3515be9-b909-4b4a-a4bd-f256d0697213.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png) | This function reads from
    multiple input channels onto a single channel that''s closed when all the inputs
    are closed. Work can be distributed to multiple Goroutines that all read from
    the same input channel. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **合并** | ![](img/b3515be9-b909-4b4a-a4bd-f256d0697213.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png) | 这个函数从多个输入通道读取数据，然后将其发送到一个通道，当所有输入都关闭时，该通道也关闭。工作可以分配给多个Goroutines，它们都从同一个输入通道读取。'
- en: '| **Write** | ![](img/9f22ce75-8545-450e-a029-0f3e09e1cb25.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    |  | This filter receives data from upstream and writes it to the sink.  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **写入** | ![](img/9f22ce75-8545-450e-a029-0f3e09e1cb25.png) | ![](img/e065c36e-7b8c-472b-b2df-22c69774644d.png)
    |  | 这个过滤器从上游接收数据并将其写入到汇聚处。'
- en: Building blocks
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本构建块
- en: 'These are the basic building blocks of a flow-based programming system. With
    these basic operations, we can build any component-based system:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基于流的编程系统的基本构建块。有了这些基本操作，我们可以构建任何基于组件的系统：
- en: '![](img/8b2a5616-80dd-4653-b1e9-cc4658fbf4c1.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b2a5616-80dd-4653-b1e9-cc4658fbf4c1.png)'
- en: Flow-based programming is a component-based programming model that defines applications
    as a network of asynchronous processing operations (aka filters) that exchange
    streams ([https://en.wikipedia.org/wiki/Stream_(computing)](https://en.wikipedia.org/wiki/Stream_(computing))) of
    structured information packets with defined lifetimes, named ports, and separate
    definitions of connections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于流的编程是一种组件化的编程模型，它将应用程序定义为一组异步处理操作（又名过滤器）的网络，这些操作交换具有定义的生命周期、命名端口和连接的结构化信息包流（[https://en.wikipedia.org/wiki/Stream_(computing)](https://en.wikipedia.org/wiki/Stream_(computing))）。
- en: Generalized business application design
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通用业务应用程序设计
- en: 'The following diagram depicts the component composition diagram for a generalized
    business application that processes input requests and routes the requests to
    backend servers. Responses from the servers are subsequently handled, processed,
    and returned. A few alternate data flows exist for responses that need to be re-routed
    or re-processed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了一个通用业务应用程序的组件组成图，该应用程序处理输入请求并将请求路由到后端服务器。随后处理、处理和返回服务器的响应。存在一些需要重新路由或重新处理的响应的备用数据流：
- en: '![](img/74baa648-b3ea-4ec7-9eb3-ac89c57c0342.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74baa648-b3ea-4ec7-9eb3-ac89c57c0342.png)'
- en: Note that each operation can be swapped, as long as its input and output sets
    are identical, without impacting the flow of data or overall operation of the
    application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只要其输入和输出集相同，每个操作都可以被交换，而不会影响数据流或应用程序的整体操作。
- en: Example implementations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例实现
- en: Now that we see the value in the pipeline pattern, let's start planning a Go
    implementation of one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们看到了管道模式的价值，让我们开始规划一个Go实现。
- en: In Go, pipelines are implemented using a series of stages connected by Go channels.
    A Go pipeline begins with a data source (aka producer), has stages that are connected
    via channels, and ends with a data sink (aka consumer).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，管道是使用一系列通过Go通道连接的阶段实现的。Go管道以数据源（又名生产者）开始，具有通过通道连接的阶段，并以数据接收端（又名消费者）结束。
- en: The data source can be a generator function that sends data to the first stage
    and then closes the initial outbound channel.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据源可以是一个生成器函数，它将数据发送到第一个阶段，然后关闭初始出站通道。
- en: 'Each filter (step or stage) in the pipeline:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中的每个过滤器（步骤或阶段）：
- en: Consists of one or more Goroutines that run the same function (aka filter)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由一个或多个Goroutines组成，运行相同的函数（又名过滤器）
- en: Receives upstream data via one or more inbound channels
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个或多个入站通道接收上游数据
- en: Transforms the data in some way
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以某种方式转换数据
- en: Sends data downstream via one or more outbound channels
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一个或多个出站通道向下游发送数据
- en: Closes its outbound channels when all the send operations are completed
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有发送操作完成时，关闭其出站通道
- en: Keeps receiving values from inbound channels until those channels are closed
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持从入站通道接收值，直到这些通道关闭
- en: 'Example transformer functions include the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例转换函数包括以下内容：
- en: Accumulator
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累加器
- en: Aggregator
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合器
- en: Delta (to calculate the change between two sample data points of a resource)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Delta（用于计算资源的两个样本数据点之间的变化）
- en: Arithmetic
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术
- en: 'Example data sinks include the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例数据接收端包括以下内容：
- en: File storage (for example, NFS and CIFS/SMB protocol access to NAS or DAS)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件存储（例如，NFS和CIFS/SMB协议访问NAS或DAS）
- en: Message broker (for example, Kafka, NATS, and RabbitMQ)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理（例如，Kafka、NATS和RabbitMQ）
- en: Database (for example, PostgreSQL, MongoDB, and DynamoDB)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库（例如，PostgreSQL、MongoDB和DynamoDB）
- en: Cloud storage (for example, S3, OpenStack Swift and Ceph)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云存储（例如，S3、OpenStack Swift和Ceph）
- en: Imperative implementation
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式实现
- en: Let's start our coding examples with the simplest form of a pipeline, which
    of course is implemented using the imperative style of programming.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从管道的最简单形式开始我们的编码示例，当然，这是使用命令式编程风格实现的。
- en: Decrypt, authenticate, charge flow diagram
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解密、认证、收费流程图
- en: 'We''ll base our coding examples on the following flow diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于以下流程图进行编码示例：
- en: '![](img/ae1c9d2f-d295-494b-8b17-ad4d5d8c8567.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae1c9d2f-d295-494b-8b17-ad4d5d8c8567.png)'
- en: 'We''ll be passing order data from stage to stage until the entire process has
    been completed. The order data can be transformed along the way, for example,
    when the **Decrypt** step converts the credit card number into plain text. We''ll
    refer to each stage or step as a filter. In our example, each filter will receive
    one order from the upstream and send one order downstream. The flow is unidirectional.
    It starts at the data source and moves to the **Decrypt** filter, then to the
    **Authenticate** filter, and ends in the **Charge Credit Card** filter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从阶段到阶段传递订单数据，直到整个过程完成。订单数据可以在途中进行转换，例如，当**解密**步骤将信用卡号转换为明文时。我们将把每个阶段或步骤称为过滤器。在我们的示例中，每个过滤器将从上游接收一个订单并将一个订单发送到下游。流是单向的。它从数据源开始，经过**解密**过滤器，然后到**认证**过滤器，最后到**收费信用卡**过滤器：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ll import the `go_currency` package, which will help us handle the prices
    in the order line items:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入`go_currency`包，它将帮助我们处理订单行项目中的价格：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `GetOrders()` function will be our order generating data source. Note that
    the credit card numbers are stored in an encrypted format. We''ll need to decrypt
    them later in order to charge the credit card:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetOrders()`函数将是我们的订单生成数据源。请注意，信用卡号以加密格式存储。我们需要稍后解密它们以便收取信用卡费用：'
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that our credit card number is encrypted and the last field is a slice
    of `LineItem` structs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的信用卡号已加密，最后一个字段是`LineItem`结构的切片：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our example, we'll only process two orders. We return them from the `GetOrders()`
    function as a slice of the `Order` structs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们只处理两个订单。我们将它们作为`Order`结构的切片从`GetOrders()`函数返回。
- en: 'We call the `GetOrder()` function to generate our orders. Next, we range over
    our orders, running each one in turn through our order processing pipeline:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`GetOrder()`函数来生成我们的订单。接下来，我们遍历我们的订单，依次通过我们的订单处理管道运行每个订单：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our pipeline has three steps. Each step is a function that we''ll refer to
    as a filter. There are three sequential filters that our order runs through as
    it is processed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道有三个步骤。每个步骤都是一个我们将称之为过滤器的函数。我们的订单通过三个顺序过滤器进行处理：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we''re starting with the simplest example possible, in each filter is
    output which filter action is occurring and we pass the order along, in this simple
    example without transforming it in any way:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从最简单的示例开始，在每个过滤器中都输出了正在发生的过滤器动作，并且我们在这个简单的示例中将订单传递了下去，而没有以任何方式对其进行转换：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the basic idea of a pipeline. We take a data packet, for example, an
    order, and pass it from step to step, where each step is a filter function with
    a specific speciality. The data can be transformed along the way and travels in
    one direction from the data source to the sink, which ends the process.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管道的基本思想。我们接收一个数据包，例如一个订单，并将其从一步传递到另一步，其中每一步都是具有特定专业性的过滤器函数。数据可以在途中进行转换，并且沿着一条方向从数据源到终点，即结束处理的地方。
- en: Concurrent implementation
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发实现
- en: 'In order to increase performance, we should consider running things concurrently.
    Go has a few concurrency constructs that we can use: Goroutines and channels.
    Let''s give that a try:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，我们应该考虑并发运行。Go语言有一些并发构造，我们可以使用：Goroutines和channels。让我们试试：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We created an input channel and an output channel for our pipeline.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的管道创建了一个输入通道和一个输出通道。
- en: 'Next, we created an immediately executable Goroutine function. Note the open/close
    parenthesis at the end of the Goroutine block: `}()` . This Goroutine won''t exit
    until we close the input channel in the last line of our main function.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个立即可执行的Goroutine函数。请注意Goroutine块末尾的括号：`}()`。直到我们在主函数的最后一行关闭输入通道之前，这个Goroutine不会退出。
- en: We generate an order, just as in our imperative example. Then, we process each
    order by passing the next order to the pipeline.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一个订单，就像在我们的命令式示例中一样。然后，我们通过将下一个订单传递给管道来处理每个订单。
- en: The output is identical to the imperative example and it runs slower. So, we
    have reduced performance and increased code complexity. We can do better.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与命令式示例相同，但运行速度较慢。因此，我们降低了性能并增加了代码复杂性。我们可以做得更好。
- en: Buffered implementation
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲实现
- en: Let's try using input/output buffers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用输入/输出缓冲区。
- en: 'In the following diagram, each stage of the pipeline reads from its input buffer
    and writes to its output buffer. For example, the **Decrypt** filter reads from
    its instream buffer, coming from the data source and writes its output buffer:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，管道的每个阶段都从其输入缓冲区读取并写入其输出缓冲区。例如，**解密**过滤器从其输入缓冲区读取，来自数据源，并写入其输出缓冲区：
- en: '![](img/9ddbc0de-b007-4794-ab6b-88901d9a9605.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ddbc0de-b007-4794-ab6b-88901d9a9605.png)'
- en: Since there are two orders, the buffer size is two. Since concurrent queues'
    buffer shared inputs and outputs, if we had four orders, then all filters in the
    pipeline could execute at the same time. If we had four CPU cores available, then
    all filters could run concurrently.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有两个订单，缓冲区大小为两。由于并发队列的缓冲区共享输入和输出，如果有四个订单，那么管道中的所有过滤器都可以同时执行。如果有四个CPU核心可用，那么所有过滤器都可以并发运行。
- en: As long as there is room in its output buffer, a stage of the pipeline can add
    the value it produces to its output queue. If the output buffer is full, the producer
    of the new value waits until space becomes available.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只要其输出缓冲区有空间，管道的一个阶段就可以将其产生的值添加到其输出队列中。如果输出缓冲区已满，新值的生产者将等待直到空间可用。
- en: Filters can block, waiting for orders to arrive in its instream buffer or until
    its input channel has been closed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器可以阻塞，等待订单到达其输入缓冲区，或者直到其输入通道被关闭。
- en: Buffers can be effectively used that hold more than one order at a time and
    this can compensate for variability in the time it takes each filter to process
    each order.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可以有效地用于一次容纳多个订单，这可以弥补每个过滤器处理每个订单所需时间的变化。
- en: In the best case scenario, each filter along the pipeline would process its
    input order in about the same time as the other filters. However, if the **Decrypt**
    filter takes substantially longer to process an order than the **Authenticate**
    filter, the **Authenticate** filter will block, waiting on **Decrypt** to send
    the decrypted order into its input buffer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在最理想的情况下，管道沿线的每个过滤器将以大致相同的时间处理其输入订单。然而，如果**解密**过滤器处理订单的时间远远长于**认证**过滤器，**认证**过滤器将被阻塞，等待**解密**将解密后的订单发送到其输入缓冲区。
- en: 'Here''s how we would modify our program to include buffered channels:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何修改我们的程序以包含缓冲通道：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is great, right? We increased performance by adding buffered channels.
    Our solution runs filters concurrently on multiple cores at the same time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，对吧？通过添加缓冲通道，我们提高了性能。我们的解决方案可以同时在多个核心上并发运行过滤器。
- en: That's great, but what if we process a large number of orders?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但如果我们处理大量订单怎么办？
- en: Leverage all CPU cores
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 利用所有CPU核心
- en: 'We could increase the number of buffers by the number of CPU cores available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过可用的CPU核心数量增加缓冲区的数量：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The use of I/O buffers is an improvement on our design, but there is actually
    a better solution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用I/O缓冲区是对我们设计的改进，但实际上有更好的解决方案。
- en: Improved implementation
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进的实现
- en: 'Let''s take another look at our order processing pipeline:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的订单处理管道：
- en: '![](img/050180d4-ba4a-40a3-bc59-4d2f2f328d4e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/050180d4-ba4a-40a3-bc59-4d2f2f328d4e.png)'
- en: Now, let's implement the **Decrypt, Authenticate**, and **Charge Credit Card** filters
    with a closer to real life example.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用更接近实际生活的例子来实现**解密，认证**和**信用卡扣款**过滤器。
- en: The `Order` and `LineItem` structs will remain the same and so will the `GetOrders()`
    generator.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order`和`LineItem`结构将保持不变，`GetOrders()`生成器也将保持不变。'
- en: Imports
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入
- en: 'We have more imports. We''ll use `go_utils` for its `Dashes` function to anonymize
    the credit card number. Also, we''ll import a number of `crypto` packages for
    decrypting the credit card number:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有更多的导入。我们将使用`go_utils`的`Dashes`函数来对信用卡号进行匿名化。此外，我们将导入许多`crypto`包来解密信用卡号：
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: BuildPipeline
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BuildPipeline
- en: 'We have a new function, `BuildPipeline()`, which takes a list of filters and
    connects them using each filter''s input and output channels. The `BuildPipeline()`
    function lays the pipe, starting with the data source and ending with the sink,
    that is, the `Charge` filter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个新的函数`BuildPipeline()`，它接受一系列过滤器，并使用每个过滤器的输入和输出通道将它们连接起来。`BuildPipeline()`函数铺设了管道，从数据源开始，到终点，也就是`Charge`过滤器：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Immediately executable Goroutine
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 立即可执行的Goroutine
- en: 'Next, is the immediately executable Goroutine that iterates over the orders
    that it generates and sends each order to the input of that filter:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是立即可执行的Goroutine，它迭代生成的订单，并将每个订单发送到该过滤器的输入：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When all of the orders have been sent into the pipeline, it's time to close
    the pipeline's input channel.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有订单都被发送到管道中时，是时候关闭管道的输入通道了。
- en: Receive order
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接收订单
- en: 'Next, we execute the pipeline''s `Receive()` function to wait for the orders
    to arrive on the output channel, and then we print out the order:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行管道的`Receive()`函数，等待订单到达输出通道，然后打印订单：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Filterer interface
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Filterer接口
- en: 'Our pipeline API is constructed around the `Filterer` interface:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道API是围绕`Filterer`接口构建的：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A Filterer object
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Filterer对象
- en: 'A Filterer object has one method, `Filter`, which has an input channel of type
    `Order` and returns an output channel of type `Order`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Filterer对象有一个方法`Filter`，它具有类型为`Order`的输入通道，并返回类型为`Order`的输出通道：
- en: '![](img/524bf1d3-8f54-4431-acd1-da49e4472a9b.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/524bf1d3-8f54-4431-acd1-da49e4472a9b.png)
- en: We define types to act as receivers of `Filter` executions. The first filter
    encountered in the pipeline is the Authenticate filter. The following Authenticate
    filter has a single input parameter of type `Order` channel and it returns a single
    value of type `Order` channel.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义类型来充当`Filter`执行的接收器。在管道中遇到的第一个过滤器是Authenticate过滤器。以下Authenticate过滤器有一个输入参数，类型为`Order`通道，并返回一个类型为`Order`通道的单个值。
- en: Authenticate filter
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 认证过滤器
- en: 'Our authentication logic is hardcoded and simple, that is, not what I''d call
    production ready. The password `secret` will work for any username. If `Authenticate`
    encounters `secret` in the `Credentials` field, the order will flow unchanged
    to the next step in the pipeline. However, if the password is not `secret`, then
    the order''s `isValid` field will be set to `false`. The behavior or subsequent
    filters in the pipeline can be affected by this value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的认证逻辑是硬编码的和简单的，即不是我所说的生产就绪。密码`secret`对于任何用户名都有效。如果`Authenticate`在`Credentials`字段中遇到`secret`，订单将不变地流向管道中的下一步。但是，如果密码不是`secret`，那么订单的`isValid`字段将被设置为`false`。管道中后续过滤器的行为可能会受到这个值的影响：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Decrypt filter
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解密过滤器
- en: 'The following `Decrypt` filter has a single input parameter of type `Order`
    channel and it returns a single value of type `Order` channel:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`Decrypt`过滤器有一个输入参数，类型为`Order`通道，并返回一个类型为`Order`通道的单个值：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we handle errors by logging the error. Even though we are told that
    the `IsDecrypted` field value is always false when it arrives from the source,
    we play it safe and set `order.IsDecrypted = false` if we encounter an error.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过记录错误来处理错误。即使我们被告知当它从源头到达时，`IsDecrypted`字段值总是false，如果我们遇到错误，我们也会安全地设置`order.IsDecrypted
    = false`。
- en: We only process this order if the order is valid. The order can be invalid if
    the decrypt function fails, refer to the the preceding code. The order can also
    be invalidated in a previous step in the flow, for example, if the order's `Authenticate`
    filter failed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在订单有效时我们才处理此订单。如果解密函数失败，订单可能无效，请参考前面的代码。订单也可能在流程的前一步中无效，例如，如果订单的`Authenticate`过滤器失败。
- en: Complete processing
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 完整处理
- en: 'When this filter''s processing is complete, we close its output channel:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当此过滤器的处理完成时，我们关闭其输出通道：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The ChargeCard helper function
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ChargeCard辅助函数
- en: 'The `ChargeCard` function is a helper function used by the `Charge` filter
    to charge the credit card number found in the order. This implementation simply
    prints that the credit card was charged. It''s a good placeholder for a real charge
    credit card logic:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChargeCard`函数是`Charge`过滤器使用的辅助函数，用于收取订单中的信用卡号。这个实现只是简单地打印信用卡已经被收取。这是一个真实的信用卡收费逻辑的良好占位符：'
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Charge filter
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 收费过滤器
- en: Like all the other filters in the API, `Charge` accepts an input channel of
    type `Order` and returns an output channel of type `Order`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与API中的所有其他过滤器一样，`Charge`接受类型为`Order`的输入通道，并返回类型为`Order`的输出通道。
- en: 'If the order is valid, then we initialize the total to $0.00 using the  `total
    := gc.USD{0, 0}`  statement and iterate over the order''s line items, executing
    the `Add` function to arrive at the order''s total amount. We then pass that amount
    to the `ChargeCard` helper function to collect our money:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订单有效，我们使用`total := gc.USD{0, 0}`语句将总额初始化为$0.00，并迭代订单的行项目，执行`Add`函数以得到订单的总金额。然后我们将该金额传递给`ChargeCard`辅助函数来收取我们的钱：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The encrypt and decrypt helper functions
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加密和解密辅助函数
- en: The `decrypt` helper function in the following code is used by the `Decrypt`
    filter. We also have the `encrypt` helper function, though not in our pipeline,
    can be nice to have, to encrypt plain text and for testing purposes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的`decrypt`辅助函数被`Decrypt`过滤器使用。我们还有`encrypt`辅助函数，虽然不在我们的管道中，但可以很好地加密纯文本和用于测试目的。
- en: 'The `decrypt` function accepts the encrypted string value. The `aes.NewCipher`
    accepts our 32-byte long AES encryption key and returns an AES-256 cipher block,
    which is passed to `NewCBCDecrypter`. The `NewCBCDecrypter` function also accepts
    an initialization vector (`iv`), which it uses to decrypt the block in cipher
    block chaining mode. Its `CryptBlocks` function is used to decrypt the value,
    and `RightTrim` is used to slice off the trailing `\x00`. Voila! we''ve got our
    decrypted string value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`decrypt`函数接受加密的字符串值。`aes.NewCipher`接受我们的32字节长AES加密密钥并返回一个AES-256密码块，该密码块传递给`NewCBCDecrypter`。`NewCBCDecrypter`函数还接受一个初始化向量（`iv`），它用于在密码块链接模式下解密块。它的`CryptBlocks`函数用于解密值，`RightTrim`用于切掉尾随的`\x00`。哇！我们得到了我们的解密字符串值：'
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Testing how the application handles invalid data
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试应用程序如何处理无效数据
- en: Let's see how our application handles bad data.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的应用程序如何处理坏数据。
- en: Invalid credit card cipher text
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无效信用卡密文
- en: 'Note the XXX that has been appended to the encrypted credit card number value:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意已附加到加密信用卡号值的XXX：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The order that had the invalid credit card number was not fully processed. Note
    the error message in the log.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 具有无效信用卡号的订单未完全处理。请注意日志中的错误消息。
- en: Invalid password
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无效密码
- en: 'Note the XXX that has been appended to the credentials field value:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意已附加到凭据字段值的XXX：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The order that had the invalid password was not fully processed. Note the error
    message in the log.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 具有无效密码的订单未完全处理。请注意日志中的错误消息。
- en: Changing the order of authenticate and decrypt filters
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改身份验证和解密过滤器的顺序
- en: 'Previously, the order was `Decrypt{},Authenticate{}, Charge{}`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，订单是`Decrypt{}，Authenticate{}，Charge{}`：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There was difference. In both cases, both invoices were fully processed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有所不同。在这两种情况下，两张发票都已完全处理。
- en: Attempting to charge before decrypting credit card number and authentication
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在解密信用卡号和身份验证之前尝试收费
- en: 'We start by building our pipeline of functions: Charge,Decrypt and Authenticate.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建了我们的函数管道：Charge，Decrypt和Authenticate。
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is the output:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Attempting to charge before authentication
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在身份验证之前尝试收费
- en: 'No surprise here either. If we attempt to charge the credit card before we
    authenticate the request, the charge will not be processed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里也没有什么意外。如果我们在身份验证请求之前尝试收费信用卡，收费将不会被处理：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: An entire book could be written on the topic of the pipeline pattern.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书都可以写关于管道模式的主题。
- en: 'Some of the topics not covered in this chapter, but you should research on
    your own, include the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章未涵盖的一些主题，但您应该自行研究的包括以下内容：
- en: Designing and implementing the `Split` and `Merge` filters
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现`Split`和`Merge`过滤器
- en: Understanding how the `sync.WaitGroup` type helps you manage synchronization
    of channel communication
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`sync.WaitGroup`类型如何帮助您管理通道通信的同步
- en: Add branching and conditional workflow patterns to the pipeline
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分支和条件工作流模式添加到管道中
- en: 'Good reads: *Go Concurrency Patterns: Pipelines and cancellation* ([https://blog.golang.org/pipelines](https://blog.golang.org/pipelines)) and *Go
    by Example: Channels* ([https://gobyexample.com/channels](https://gobyexample.com/channels))'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好的阅读：*Go并发模式：管道和取消*（[https://blog.golang.org/pipelines](https://blog.golang.org/pipelines)）和*Go示例：通道*（[https://gobyexample.com/channels](https://gobyexample.com/channels)）
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Building applications that have high cohesion and low coupling is a major goal
    in software engineering. In this chapter, we explored the pipeline pattern and
    you learned how to build component-based systems using **flow-based programming**
    (**FPB**) techniques. We studied FPB patterns and use cases that would benefit
    from applying the pipeline pattern.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 构建具有高内聚性和低耦合性的应用程序是软件工程的主要目标。在本章中，我们探讨了管道模式，并学习了如何使用**基于流的编程**（**FPB**）技术构建基于组件的系统。我们研究了适用于应用管道模式的FPB模式和用例。
- en: We studied an example order processing flow. We progressed from an imperative
    implementation to a concurrent one using Goroutines and channels. We learned how
    I/O buffers can effectively be used to hold more than one order at a time and
    how this can compensate for variability in the time it takes each filter to process
    each order.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了一个订单处理流程的示例。我们从命令式实现逐步过渡到使用Goroutines和通道的并发实现。我们学习了如何有效地使用I/O缓冲区来同时保存多个订单，以及如何弥补每个过滤器处理每个订单所需时间的变化。
- en: 'Our last implementation was an improvement upon the prior attempts. We created
    an elegant API based on the `Filterer` interface. We were able to define and control
    our entire order processing flow with this one command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个实现是对之前尝试的改进。我们基于`Filterer`接口创建了一个优雅的API。我们能够使用这个命令定义和控制整个订单处理流程：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Lastly, we implemented various FPB error handling techniques and tested their
    effectiveness.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实施了各种FPB错误处理技术并测试了它们的有效性。
- en: 'In the next chapter, we''ll look at another technique used to improve performance:
    being lazy.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到另一种用于提高性能的技术：懒惰。
