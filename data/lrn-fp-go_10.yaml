- en: Monads, Type Classes, and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子、类型类和泛型
- en: 'Functional programming in Go:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的函数式编程：
- en: “Not sure if it’s a good idea, but let’s try it anyway.”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “不确定这是否是一个好主意，但无论如何让我们试试。”
- en: '"Fun to think about;  Not sure how to use it."'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: “思考很有趣；不确定如何使用它。”
- en: '"The Y-Combinator is a theoretical concept with no practical value."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “Y-组合器是一个没有实际价值的理论概念。”
- en: '"Who can understand the code in this Monad package. Lambda what? Generics?"'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “谁能理解这个单子包中的代码。Lambda是什么？泛型？”
- en: Please put your prejudices aside, work through this chapter, and then ask yourself,
    How relevant is functional programming in Go?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请把你的偏见放在一边，通过本章，然后问问自己，函数式编程在Go中有多相关？
- en: 'Our goals in this chapter are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: Understand how a Monad works
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解单子的工作原理
- en: Learn how to compose functions using the `bind` operation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会使用`bind`操作组合函数
- en: Understand how the `Success` and `Failure` paths work
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`Success`和`Failure`路径的工作原理
- en: Understand how a Monad deals with impure operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解单子如何处理不纯操作
- en: Work through a Monadic workflow implementation in Go
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Go中的单子工作流程实现
- en: Learn what Lambda Calculus is and what it has to do with Monads
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Lambda演算是什么，以及它与单子有什么关系
- en: See how Lambda Calculus implements recursion
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看Lambda演算如何实现递归
- en: Learn how the Y-Combinator works
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会Y-组合器的工作原理
- en: Use the Y-Combinator to control workflow
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Y-组合器来控制工作流程
- en: Learn to write concise workflow code and handle all errors at the end
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会编写简洁的工作流程代码，并在最后处理所有错误
- en: Understand how `Type` classes work and implement a few in Go
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`Type`类如何工作，并在Go中实现一些
- en: Review the pros and cons of generics
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查泛型的优缺点
- en: Mother Teresa Monad
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特蕾莎修女单子
- en: Who are you? Are you a good person or a bad person? What would other people
    say? How did you become the person you are now?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你是谁？你是一个好人还是一个坏人？其他人会怎么说？你是如何成为现在的这个人的？
- en: Ponder those questions for a few minutes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 思考这些问题几分钟。
- en: What is a Monad?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是单子？
- en: 'The explanation is like answering the question: How were you raised as a child
    and what have you become?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 解释就像回答这个问题：你是如何被养育成为一个孩子的，你现在变成了什么样子？
- en: 'In the following diagram, we explore a Monad:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们探讨了一个单子：
- en: '![](img/85062f95-936f-4bd1-9029-605db3113f17.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/85062f95-936f-4bd1-9029-605db3113f17.png)
- en: The chain of blue boxes represents moments in the flow of Mother Teresa’s life.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色框的链条代表了特蕾莎修女生活中的时刻。
- en: The closed blue boxes represent her private time from birth to death. The open
    boxes represent events in which she opened herself up to interactions with the
    world around her.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭的蓝色框代表她从出生到死亡的私人时间。开放的框代表她向周围世界开放互动的事件。
- en: Let's suppose she was nurtured as a baby and received positive input (the blue
    incoming arrow). Also suppose that along the way, she was exposed to some negative
    input (the dark incoming arrows) as well as positive input. Her life (the data)
    was transformed in some way during every interaction. As she grew, her actions
    were her side effects (the outgoing arrows from the open box).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设她在婴儿时期得到了良好的培养和积极的输入（蓝色的传入箭头）。还假设在她成长过程中，她接触到了一些负面的输入（黑色的传入箭头）以及积极的输入。她的生活（数据）在每次互动中以某种方式被转化。随着她的成长，她的行为就成了她的副作用（从开放框中发出的出箭头）。
- en: Success might be defined as entering the gates of Heaven after death (or Hell,
    for failure).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 成功可能被定义为在死后进入天堂（或者失败的话是地狱）。
- en: So, what is a Monad? It’s a mechanism into which data flows, interacts with
    an impure environment, is transformed, and eventually comes out the other end;
    it's a way to structure and control the workflow in a real application that interfaces
    with external endpoints, such as log files, external APIs, notifications, and
    so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是单子？它是一个机制，数据流进入其中，与不纯净的环境进行交互，被转化，最终从另一端出来；它是一种在与外部端点（如日志文件、外部API、通知等）进行接口的真实应用程序中结构化和控制工作流程的方式。
- en: The previous diagram should prompt a few questions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表应该引发一些问题。
- en: '![](img/aaa61d9a-9347-43d8-a1b3-6a28798f1dca.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/aaa61d9a-9347-43d8-a1b3-6a28798f1dca.png)
- en: 'In [Chapter 4](../Text/Ch04.xhtml)*, SOLID Design in Go*, we saw how a function
    **f** receives **a** and returns **b**, but we also recognized that in the real
    world, where connections fail and RAM and disk space might fill up, errors may
    occur:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](../Text/Ch04.xhtml)*，Go中的SOLID设计*中，我们看到函数**f**接收**a**并返回**b**，但我们也意识到在现实世界中，连接可能失败，RAM和磁盘空间可能会填满，错误可能会发生：
- en: '![](img/f240bdf3-e10c-4774-8809-4ab6fd3db71b.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f240bdf3-e10c-4774-8809-4ab6fd3db71b.png)
- en: 'To keep our diagram clean-looking, we’ll just move the errors arrow up and
    shoot it out the right side, rather than underneath. We’ll also color the input
    and output arrows blue. That’s our pure, happy path. See? No side effects:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的图表看起来整洁，我们将把错误箭头向上移动，并将其射出右侧，而不是在下面。我们还将把输入和输出箭头涂成蓝色。这是我们的纯净、快乐的路径。看到了吗？没有副作用：
- en: '![](img/6861edad-2f1c-4bc4-a1ab-51bf44b9e134.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6861edad-2f1c-4bc4-a1ab-51bf44b9e134.png)
- en: But real programs can have side-effects, right? Real programs interface with
    external APIs, accept input from users, print invoices, and send emails, right?
    Where’s the real stuff?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是真实的程序可能会有副作用，对吧？真实的程序与外部API进行接口，接受用户输入，打印发票，发送电子邮件，对吧？真实的东西在哪里？
- en: '![](img/626d32fa-3ca4-4221-a3fc-d1e29374fd4a.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/626d32fa-3ca4-4221-a3fc-d1e29374fd4a.png)
- en: We have two inputs matching our two outputs so that we can easily link our blue
    boxes into a chain. Remember when we discussed the decomposition of finite state
    machines? We pulled apart the pieces (**C1**, **C2**, and **C5**) of our application.
    These are our *reusable components*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个与我们的两个输出匹配的输入，这样我们就可以轻松地将我们的蓝色框链接成一个链条。还记得我们讨论有限状态机的分解吗？我们拆开了我们应用程序的部分（**C1**、**C2**和**C5**）。这些是我们的*可重用组件*。
- en: '![](img/b9da2dd7-73a6-4bad-8b2d-109d381446cb.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/b9da2dd7-73a6-4bad-8b2d-109d381446cb.png)
- en: 'That was done in order to fill our toolbox with individual components, which
    we can subsequently use to re-compose our application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了用个别组件填充我们的工具箱，随后我们可以重新组合我们的应用程序：
- en: '![](img/7a11dbf4-f3ea-454d-8777-b7d90703bc0e.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7a11dbf4-f3ea-454d-8777-b7d90703bc0e.png)
- en: Ever wonder how our pieces will fit back together?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道我们的部分将如何重新拼合在一起？
- en: 'It’s not going to work if all our pieces look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们所有的部分都是这样，它是行不通的：
- en: '![](img/144f9738-0d14-4f05-9f81-d15a3d65554a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/144f9738-0d14-4f05-9f81-d15a3d65554a.png)'
- en: 'However, consider if the pieces looked like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑如果这些部分看起来像这样：
- en: '![](img/ca9657ab-fc8e-4f21-bcc7-15d1f1dcc93d.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca9657ab-fc8e-4f21-bcc7-15d1f1dcc93d.png)'
- en: Then they will all fit together like legos! See how they fit together?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它们将像乐高积木一样拼合在一起！看它们如何拼合在一起？
- en: '![](img/fd0c509c-eb4f-458b-a9b0-80699dcca0b7.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0c509c-eb4f-458b-a9b0-80699dcca0b7.png)'
- en: How can we go from a one-input to a two-input thing?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从一个输入转换为两个输入？
- en: The bind operation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定操作
- en: 'We accomplish this feat using the Monad''s bind operation:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单子的绑定操作来实现这一壮举：
- en: '![](img/07c89347-d1df-40ec-a06f-6777445ed542.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07c89347-d1df-40ec-a06f-6777445ed542.png)'
- en: In Haskell, it’s called the `bind` operation. Other names for bind include `flatMap`,
    `flatten`, `andThen`, `collect`, and `SelectMany`. (That's part of what makes
    functional programming confusing--different languages use different names for
    the same thing.) The Lexical Workflow calls it `Next`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，它被称为`bind`操作。`bind`的其他名称包括`flatMap`、`flatten`、`andThen`、`collect`和`SelectMany`。（这就是函数式编程令人困惑的地方之一--不同的语言对同一件事使用不同的名称。）词法工作流称其为`Next`。
- en: More descriptive names might be adapt, link, or even hard shove. (In our code
    example, we'll use the name `Next`, because it makes the most sense in the context
    of moving to the `Next` step.) Bind is a pattern that adapts the one-input, two-output
    block to a two-input, two-output block.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 更具描述性的名称可能是adapt、link，甚至是hard shove。（在我们的代码示例中，我们将使用名称`Next`，因为在移动到`Next`步骤的上下文中，这是最有意义的名称。）绑定是一种模式，它将一个输入、两个输出的块适应为一个输入、两个输出的块。
- en: Now, let’s talk about the two paths--the top blue path is the `Success` path.
    That’s our *Happy Path*, through which our data flows, as long as all goes well.
    The bottom red path is where errors go.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈两条路径--顶部蓝色路径是`Success`路径。只要一切顺利，这就是我们的*Happy Path*，我们的数据就会流过这条路径。底部红色路径是错误发生的地方。
- en: '![](img/455761cf-fe6f-40a8-9b0b-d04bc5679c21.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/455761cf-fe6f-40a8-9b0b-d04bc5679c21.png)'
- en: The lift operation
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升操作
- en: 'Let’s examine what happens when an error occurs in the lift operation of our
    second component in the chain:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看当在链中的第二个组件的提升操作发生错误时会发生什么：
- en: '![](img/507a1ede-9f0c-404e-93de-cdc5e8b79831.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/507a1ede-9f0c-404e-93de-cdc5e8b79831.png)'
- en: Lifting lifts a function into a *wrapped* type. Lift connects our functions
    from one world and another.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数提升到*包装*类型中。提升将我们的函数从一个世界连接到另一个世界。
- en: A functor lifts single parameter functions. An applicative functor lifts second
    multi parameter functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函子提升单参数函数。一个应用函子提升第二个多参数函数。
- en: 'This is the type definition of the the lift operation in Haskell:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Haskell中提升操作的类型定义：
- en: '`liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c`'
- en: See the following terminal console for an example of using the lift operation
    (`liftA2`) to transform the the `replicate` function into a wrapped type. We're
    using the *applicative style* since we are lifting with an arbitrary number of
    arguments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下面的终端控制台，这是使用提升操作（`liftA2`）将`replicate`函数转换为包装类型的示例。我们使用*applicative style*，因为我们正在使用任意数量的参数进行提升。
- en: '![](img/8d6315e9-fa8f-429f-8c45-f6eeec9c1312.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d6315e9-fa8f-429f-8c45-f6eeec9c1312.png)'
- en: Notice that we do not throw an exception (or panic); instead, we move our application
    flow from the `Success` path to the `Failure` path. Practically, what this means
    is that we no longer need to check for errors after executing each command that
    could possibly fail in our code. Using the monad pattern, we are able to redirect
    program flow to the `Failure` path and handle all of our errors for this execution
    chain at the tail end.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不会抛出异常（或恐慌）；相反，我们将我们的应用程序流从`Success`路径移动到`Failure`路径。实际上，这意味着在执行可能在我们的代码中失败的每个命令后，我们不再需要检查错误。使用单子模式，我们能够将程序流重定向到`Failure`路径，并在尾端处理这个执行链中的所有错误。
- en: 'Now that we understand why and how we got two inputs and two outputs, let’s
    look at what’s going on under our chain of blue boxes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了为什么以及如何得到了两个输入和两个输出，让我们来看看在我们的一系列蓝色框下发生了什么：
- en: '![](img/831dcc03-20ab-4f75-ba23-76abb2a8d543.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831dcc03-20ab-4f75-ba23-76abb2a8d543.png)'
- en: See the open box with the arrows coming in and going out? Those are impure arrows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看到那个打开的盒子，箭头进来和出去？那些是不纯的箭头。
- en: Remember our discussion about the action of lowering elements into the gutter
    of mutation in [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics,*
    in the section about functors?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第9章](../Text/Ch09.xhtml) *函子、单子和泛型*中关于将元素降低到突变的行为的讨论吗？
- en: This is where our monad allows us to open our box outside the pure world of
    FP. Our monad is a functor, and here, we're using the functor operation of lifting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的单子允许我们在纯函数式编程之外打开我们的盒子的地方。我们的单子是一个函子，在这里，我们使用了提升的函子操作。
- en: For details about lifting, see the previous chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关提升的详细信息，请参阅上一章。
- en: 'The in arrow represents interactions with the external world. Things like:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输入箭头表示与外部世界的交互。诸如：
- en: Managing state
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理状态
- en: Reading log files
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取日志文件
- en: Accepting input from external APIs
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部API接收输入
- en: Concurrent processing
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理
- en: 'The out arrow represents interactions with the external world. Things like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出箭头表示与外部世界的交互。诸如：
- en: Managing state
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理状态
- en: Writing log files
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入日志文件
- en: Sending output to external APIs
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出发送到外部API
- en: Concurrent processing
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理
- en: Remember, in pure functional programming, if a program receives a certain input
    value, then it will always return the same output. However, when a program writes
    to a log file, how could it possibly have the same timestamp each time? Monads
    allow pure FP programs to remain pure and still interact with an impure world.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在纯函数式编程中，如果程序接收到某个输入值，那么它将始终返回相同的输出。然而，当程序写入日志文件时，它怎么可能每次都有相同的时间戳？单子允许纯FP程序保持纯净，同时与不纯净的世界进行交互。
- en: '![](img/ae6b607b-efb1-48d0-89d7-1110c55d35ef.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae6b607b-efb1-48d0-89d7-1110c55d35ef.png)'
- en: This is where the mapping/data transformation function is applied to the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将映射/数据转换函数应用于数据的地方。
- en: In our Mother Teresa life monad example, this (in the box) is where the positive
    interactions, perhaps with her loving mother, occurred, which helped to point
    her in a positive direction. What other interactions might have occurred to transform
    her life?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特蕾莎修女生活的monad示例中，这（在盒子里）是积极互动发生的地方，也许是与她充满爱心的母亲，这些互动帮助她朝着积极的方向发展。还可能发生了哪些其他互动来改变她的生活？
- en: How can any useful application not manage state? How can an FP application manage
    state and remain pure? Monads. (See the state monad in the upcoming table.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有用的应用程序怎么可能不管理状态？一个FP应用程序如何管理状态并保持纯净？Monad。（请参见即将出现的表中的状态monad。）
- en: Why use Monads to manage state? Monads allow the manipulation of state in an
    elegant, type-safe, constrained, deferred, and controlled manner.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用Monad来管理状态？Monad允许以一种优雅、类型安全、受限、推迟和受控的方式操纵状态。
- en: 'Elegant? What’s elegant about a Monad? Elegance is in the eye of the beholder.
    Elegance gets out of the way. It is simple, obvious, straightforward, and allows
    us to very little intellectual effort to immediately understand our code''s purpose:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅？Monad有什么优雅之处？优雅在于观察者的眼中。优雅不会妨碍。它简单、明显、直接，并且使我们几乎不费什么智力就能立即理解我们代码的目的：
- en: '[PRE0]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's a Monad. It's clutter-free and it's easy to see what the workflow does.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个Monad。它没有杂乱，很容易看出工作流程是什么。
- en: Deferred? What are we talking about? Why not just bake in all the control flow
    logic up front? We know what should happen in all our use cases. Why not write
    all our if/then/else logic and for loops and bake them all into a single executable?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 推迟？我们在谈论什么？为什么不直接将所有控制流逻辑一开始就写入？我们知道在所有用例中应该发生什么。为什么不将所有的if/then/else逻辑和for循环都写入并将它们全部编译成一个可执行文件呢？
- en: With Monads, we attempt to write our applications using as many pure, side effect
    free functions as possible. This style of programming mostly defers the decisions
    about how and when to mutate states until the moment they are required. That’s
    what happens when we open the box.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Monad，我们尽量使用尽可能多的纯净、无副作用的函数来编写我们的应用程序。这种编程风格大多将有关何时以及如何改变状态的决策推迟到需要它们的时刻。这就是当我们打开盒子时会发生的事情。
- en: Constrained? What’s constrained? Well, that’s an overloaded term. From a framework
    perspective, we are constraining/quarantining our side effect causing and real-world
    interfacing code to this little, purposeful box. Its job is to perform the specific
    data mapping transformation functions that have been provided to it. If any errors
    occur, the framework will capture them and package the errors for us, and will
    ensure that they quickly travel down the `Failure` path until they get spit out
    the end of the execution pipe, where all errors for this execution chain are handled.
    From a data perspective, we use our type system to constrain the input to only
    valid data types. (If we have a division operation, we can constrain our input
    type to be `PositiveNumbers` to ensure that a divide by zero exception will never
    occur.) From a type class perspective, our operations are constrained by the laws
    of Monads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 受限？什么受限？嗯，这是一个多义词。从框架的角度来看，我们正在将引起副作用和真实世界接口的代码限制/隔离到这个小而有目的的盒子中。它的工作是执行特定的数据映射转换功能。如果发生任何错误，框架将捕获它们并为我们打包错误，并确保它们迅速通过“失败”路径传递，直到它们被排出执行管道的末端，在那里处理此执行链的所有错误。从数据的角度来看，我们使用我们的类型系统来限制输入为有效的数据类型。（如果我们有一个除法操作，我们可以将输入类型限制为`PositiveNumbers`，以确保永远不会发生除以零的异常。）从类型类的角度来看，我们的操作受Monad的法则约束。
- en: 'What operations? What laws? The operations are the sequences of tasks that
    we chain together to perform various operations on our data. If we start with
    a list of cars, we might want to transform our list by applying the following
    transformations:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 什么操作？什么法律？操作是我们将任务链在一起以对数据执行各种操作的序列。如果我们从一辆车的列表开始，我们可能想通过应用以下转换来转换我们的列表：
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And finally, what do we mean by controlled? This is where the Monad shines.
    The Monad provides the structure for chaining the transformation operations. It
    provides the `Success` and `Failure` paths. Now, rather than littering our code
    with `if err != nil` error checking blocks, we can put all of our error handling
    logic at the end of all of the steps we need to perform for our particular use
    case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们所说的控制是什么意思？这就是Monad的优势所在。Monad提供了链接转换操作的结构。它提供了“成功”和“失败”的路径。现在，我们不再需要在代码中到处散布“if
    err != nil”错误检查块，我们可以将所有错误处理逻辑放在我们需要为特定用例执行的所有步骤的末尾。
- en: 'One more time: What is a Monad? A Monad is a design pattern that provides a
    way of chaining operations together. The `bind` function is what links the operations
    together in a chain; it takes the output from one step and feeds it into the next
    one.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再说一遍：Monad是什么？Monad是一种设计模式，提供了一种将操作链接在一起的方法。`bind`函数是将操作链接在一起的链条；它接收一个步骤的输出并将其传递到下一个步骤。
- en: We can write the calls that directly use the `bind` operator, or we can use
    a sugar syntax, in a language like Haskell, which makes the compiler insert those
    function calls for use. But either way, each step is separated by a call to the `bind`
    function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写直接使用`bind`运算符的调用，或者我们可以使用一种语法糖，比如Haskell语言，让编译器为我们插入这些函数调用。但无论哪种方式，每个步骤都是通过对`bind`函数的调用来分隔的。
- en: Since Haskell is a fully baked pure functional programming language, we'll often
    refer to its FP in order to think about how we can best incorporate that method
    of thinking/design into our Go solutions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Haskell是一个完全成熟的纯函数式编程语言，我们经常会提到它的FP，以便思考如何最好地将这种思维/设计方法融入我们的Go解决方案中。
- en: 'In Haskell, there are many kinds of monads. What makes each monad unique and
    especially useful is what it does in addition to the `bind` operation. We can
    use the following table of monads found in Haskell as a starting point for building
    a package of monads in Go:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中有许多种monad。每种monad的独特之处和特别有用之处在于它在`bind`操作之外所做的事情。我们可以使用在Haskell中找到的monad表格作为在Go中构建monad包的起点：
- en: '| **Monad** | **Description** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **Monad** | **描述** |'
- en: '| **Either** | The `Either` type is similar to the `Maybe` type, with one key
    difference--it can carry attached data of both `Success` and `Failure`. The `Left`
    return value to indicates failure, and `Right` indicates success. Here''s a useful
    pun: use *Either* to get the *Right* answer. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **Either** | `Either`类型类似于`Maybe`类型，但有一个关键区别——它可以携带`Success`和`Failure`的附加数据。`Left`返回值表示失败，`Right`表示成功。这里有一个有用的双关语：使用*Either*来得到*Right*的答案。
    |'
- en: '| **Error** | Allows us to define exactly how exception handling works for
    our application. For example, we can choose to ignore a specific exception if
    a similar one has been handled in the past 60 seconds. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **Error** | 允许我们精确定义异常处理在我们的应用程序中的工作方式。例如，如果过去60秒内已处理了类似的异常，我们可以选择忽略特定的异常。
    |'
- en: '| **Eval** | Used for modularizing parallel code by separating the algorithm
    from the parallelism, allowing us to change the way we parallelize our code by
    replacing the `Strategy` function. `Eval` and the swappable `Strategies` leverage
    lazy evaluation to express parallelism. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **Eval** | 用于通过将算法与并行性分离来模块化并行代码，允许我们通过替换`Strategy`函数来改变并行化代码的方式。`Eval`和可交换的`Strategies`利用惰性评估来表达并行性。
    |'
- en: '| **Failure** | Aborts the chain of execution steps automatically without requiring
    an `if err != nil` conditional error check after every function call. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **Failure** | 在不需要在每个函数调用后都进行`if err != nil`条件错误检查的情况下，自动中止执行步骤链。 |'
- en: '| **Free** | Allows us to construct a monad from an arbitrary type. The free
    monad allows us to abstractly specify control flow between pure functions and
    separately define an implementation. We use monads to glue together pure functions
    with special purpose control-flow, such as fail fast error handling (`Maybe/Either`)
    or asynchronous computation. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **Free** | 允许我们从任意类型构造一个monad。自由monad允许我们抽象地指定纯函数之间的控制流，并分别定义一个实现。我们使用monad将纯函数与特定目的的控制流（如快速失败错误处理（`Maybe/Either`）或异步计算）粘合在一起。
    |'
- en: '| **Identity** | The `Identity` monad is a monad that does not embody any computational
    strategy. It simply applies the bound function to its input without any modification.
    Computationally, there is no reason to use the `Identity` monad instead of the
    much simpler act of applying functions to their arguments. The purpose of the
    `Identity` monad is its fundamental role in the theory of monad transformers.
    Any Monad transformer applied to the `Identity` monad yields a non-transformer
    version of that Monad. The `Identity` monad is like the number zero in addition.
    You cannot increase another number with zero, but zero comes in handy when you
    need to write a `Reduce` function. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **Identity** | `Identity` monad是一个不具备任何计算策略的monad。它只是将绑定函数应用于其输入，而不进行任何修改。从计算上讲，没有理由使用`Identity`
    monad而不是更简单的将函数应用于其参数。`Identity` monad的目的在于它在monad变换器理论中的基本作用。对`Identity` monad应用的任何Monad变换器都会产生该Monad的非变换器版本。`Identity`
    monad就像加法中的零一样。你不能用零增加另一个数字，但是当你需要编写`Reduce`函数时，零就派上用场了。 |'
- en: '| **If** | Provides simple control flow to evaluate the results of a clause
    if the logic condition is true, or else it will evaluate the false block (if one
    is provided). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **If** | 提供简单的控制流，以评估逻辑条件是否为真的子句的结果，否则将评估假的块（如果提供了）。 |'
- en: '| **IO** | Separates I/O from the rest of the (pure) language. In Haskell,
    it''s the return statement that takes the impure I/O and puts it into the `IO`
    Monad. It allows access to impure I/O sources, such as memory, global variables,
    network, native operating system calls, standard input, and so on. The following
    example Haskell code illustrates the IO monad:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| **IO** | 将I/O与（纯）语言的其余部分分离。在Haskell中，是`return`语句将不纯的I/O放入`IO`Monad中。它允许访问不纯的I/O源，如内存、全局变量、网络、本地操作系统调用、标准输入等。以下是一个Haskell代码示例，说明了IO
    monad：'
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Lazy** | It''s the same as the `StateThread` (ST) monad, except that this
    monad delays the evaluation of state operations until a value depending on them
    is required. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **懒惰** | 它与`StateThread`（ST）monad相同，只是这个monad延迟了对状态操作的评估，直到需要依赖它们的值。 |'
- en: '| **List** | We can make each step return a list of results. Our bind function
    can iterate over the list, feeding each one into the next step. This eliminates
    the need to write looping constructs to iterate over lists of elements. Write
    it once and reuse it. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **List** | 我们可以使每一步返回一系列结果。我们的绑定函数可以迭代列表，将每个结果传递到下一步。这消除了编写循环结构来迭代元素列表的需要。只需编写一次，然后重复使用。
    |'
- en: '| **Maybe** | Used to deal with nil values, as it deals with computations that
    might not return results. Instead of returning nil (or throwing an exception/panic),
    monadic operations return a `Just` value or `Nothing`. Errors are propagated down
    the monad structure until they reach the exit point at which all errors are handled.Here’s
    how it’s defined in Haskell:`data Maybe a = Nothing &#124; Just a` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **Maybe** | 用于处理nil值，因为它处理可能不返回结果的计算。monadic操作返回`Just`值或`Nothing`，而不是返回nil（或抛出异常/panic）。错误会沿着monad结构传播，直到它们到达所有错误被处理的出口点。在Haskell中它是这样定义的：`data
    Maybe a = Nothing &#124; Just a` |'
- en: '| **Option** | Used as the return type for data that might otherwise return
    a nil/null value. If the data is invalid, `None` is returned inside the `Option`
    monad, or else `Some` is returned with the valid data inside of it. The monadic
    functions will then chain fail states, so if a function requires the data is valid
    but receives an `Option` with `None` in it, it will simply return `Option None`
    to the `Next` function. This pattern is similar to returning `Null` in an imperative
    language and it solves the [Billion Dollar Mistake](https://en.wikipedia.org/wiki/Null_pointer).
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | 用作可能返回nil/null值的数据的返回类型。如果数据无效，在`Option`单子内返回`None`，否则返回带有有效数据的`Some`。单子函数将链式失败状态，因此如果函数要求数据有效但接收到一个带有`None`的`Option`，它将简单地返回`Option
    None`给`Next`函数。这种模式类似于在命令式语言中返回`Null`，并解决了[十亿美元的错误](https://en.wikipedia.org/wiki/Null_pointer)。|'
- en: '| **Par** | Used for modularizing parallel code by requiring the programmer
    to provide more details about the data dependencies. Par provides more control
    and does not rely on lazy evaluation to manage parallel tasks. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **Par** | 用于通过要求程序员提供有关数据依赖关系的更多细节来模块化并行代码。Par提供更多控制，并且不依赖于惰性评估来管理并行任务。|'
- en: '| **Parser** | Used to create a parser. For example, our grammar might look
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '| **Parser** | 用于创建解析器。例如，我们的语法可能如下所示：'
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We could use our Parser monad to perform math operations such as:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的解析器单子执行数学运算，例如：
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Pause** | Used when computations need to be interrupted and resumed. Could
    provide a step function, which runs the computation until it calls the yield function
    where the computation is paused, returning to the caller enough information to
    resume the computation later. For an example of about a dozen possible implementations,
    see [stackoverflow.com/questions/10236953/the-pause-monad](https://stackoverflow.com/questions/10236953/the-pause-monad)[.](https://stackoverflow.com/questions/10236953/the-pause-monad)
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **Pause** | 用于需要中断和恢复计算的情况。可以提供一个步骤函数，该函数运行计算，直到调用yield函数将计算暂停，返回足够的信息给调用者以便稍后恢复计算。有关大约十几种可能的实现示例，请参见[stackoverflow.com/questions/10236953/the-pause-monad](https://stackoverflow.com/questions/10236953/the-pause-monad)[.](https://stackoverflow.com/questions/10236953/the-pause-monad)。'
- en: '| **Reader** | Provides access to the global state. During initialization,
    an application can read configuration into a single context that can be passed
    along to subsequent steps. Also known as **Environment**. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **Reader** | 提供对全局状态的访问。在初始化期间，应用程序可以将配置读入单个上下文，然后将其传递给后续步骤。也被称为**环境**。'
- en: '| **State** | Provides access to state values. A run function that performs
    some computation will update the state and return the final state. For example,
    in an online first person shooter video game, the player needs to know the state
    of the player during every phase of the game: their health, amount of ammo, types
    of weapons on hand, location, or an overlay a map of the surrounding area. State
    is not global, but rather, a new state created in each step of the game. Since
    the state is not actually performing destructive updates, reverting to an older
    version or performing undo operations is easier. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **State** | 提供对状态值的访问。执行一些计算的运行函数将更新状态并返回最终状态。例如，在在线第一人称射击视频游戏中，玩家需要在游戏的每个阶段了解玩家的状态：他们的健康状况，弹药量，手头的武器类型，位置，或者周围地区的地图叠加。状态不是全局的，而是在游戏的每一步中创建一个新的状态。由于状态实际上并不执行破坏性的更新，因此回滚到旧版本或执行撤消操作更容易。'
- en: '| **ST** | Allows us to safely work with a mutable states. For example, we
    can thaw an immutable/frozen array and modify it in place and freeze a new immutable
    array. ST also allows us to create data structures that we can then modify, as
    we can do in imperative languages. Also known as a **State Thread monad**. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **ST** | 允许我们安全地使用可变状态。例如，我们可以解冻一个不可变/冻结的数组并在原地修改它，然后冻结一个新的不可变数组。ST还允许我们创建数据结构，然后修改它，就像我们在命令式语言中所做的那样。也被称为**状态线程单子**。'
- en: '| **STM** | The **Software Transactional Memory** (**STM**) monad helps us
    with the problem of synchronizing multiple tasks by preventing us from accidentally
    performing non-transactional I/O operations that may cause deadlocks. In order
    to perform concurrent programming in imperative programming, we use threads that
    must share data. We must be careful that the different threads don''t improperly
    update the shared data. We often lock data blocks using a a technique called a
    **semaphore lock**. With STM, we don''t need to worry about semaphores since our
    code contains no locks. Note that in Go, the language constructs we use to perform
    concurrent programming include Goroutines, channels, and `sync.WaitGroup`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **STM** | **软件事务内存**（**STM**）单子通过防止我们意外执行可能导致死锁的非事务I/O操作来帮助我们解决同步多个任务的问题。为了在命令式编程中执行并发编程，我们使用必须共享数据的线程。我们必须小心，以确保不同的线程不会不正确地更新共享数据。我们经常使用一种称为**信号量锁**的技术来锁定数据块。使用STM，我们不需要担心信号量，因为我们的代码不包含锁。请注意，在Go中，我们用于执行并发编程的语言构造包括Goroutines，通道和`sync.WaitGroup`。'
- en: '| **Writer** | Used to signal some side effect. Often used for logging or debug
    printing. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **Writer** | 用于表示某些副作用。通常用于日志记录或调试打印。'
- en: 'In addition to learning from Haskell''s implementation of Monads, other features
    we can learn from include:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从Haskell的单子实现中学习之外，我们还可以学习的其他功能包括：
- en: Lazy evaluation
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性评估
- en: Type classes
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型类
- en: Syntax based on layout
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于布局的语法
- en: Pattern matching on data structures
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构上的模式匹配
- en: Bounded and Parametric polymorphism
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有界和参数多态性
- en: 'Check out more about Haskell at the following resources:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下资源中了解更多关于Haskell的信息：
- en: '[https://en.wikipedia.org/wiki/Haskell_(programming_language)](https://en.wikipedia.org/wiki/Haskell_(programming_language))'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Haskell_(programming_language)](https://en.wikipedia.org/wiki/Haskell_(programming_language))'
- en: '[https://www.haskell.org/](https://www.haskell.org/)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.haskell.org/](https://www.haskell.org/)'
- en: '[http://learnyouahaskell.com/](http://learnyouahaskell.com/)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://learnyouahaskell.com/](http://learnyouahaskell.com/)'
- en: '[https://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html](https://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html](https://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html)'
- en: Monadic functions
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单子函数
- en: 'Monads are implemented as a type class with two methods, `return` and bind
    (`>>=`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 单子被实现为一个类型类，有两个方法，`return`和bind(`>>=`)：
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that `m` refers to a type constructor, such as `Either` or `Maybe,` that
    implements the `Monad` type class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`m`指的是一个类型构造器，比如`Either`或`Maybe`，它实现了`Monad`类型类。
- en: 'We''ll include a few more monadic functions from the Standard Library in the
    following table:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的表格中包含了标准库中的一些单子函数：
- en: '| **Function** | **Description** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| **fail** | The fail function supports a monad''s implementation of failure.
    We get the `fail` function from the `Monad` type class, and it enables a failed
    pattern matching to result in a failure in the context of the current monad instead
    of a program crash. For example, the `fail` function is called when pattern matching
    fails in a do expression. `fail :: Monad m => String -> m a` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **fail** | fail函数支持单子的失败实现。我们从`Monad`类型类中获得`fail`函数，它使得失败的模式匹配会导致当前单子环境中的失败，而不是程序崩溃。例如，当模式匹配在do表达式中失败时，就会调用`fail`函数。`fail
    :: Monad m => String -> m a` |'
- en: '| **fmap** | `fmap` comes from the Functor type class. `fmap` applies a function
    over ordinary values `a -> b`, and lifts them to become a function over containers
    `f a -> f b`, where `f` is the container type:`fmap :: Functor f => (a -> b) ->
    f a -> f b` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **fmap** | `fmap`来自于Functor类型类。`fmap`将一个函数应用于普通值`a -> b`，并将它们提升为容器类型`f a
    -> f b`的函数，其中`f`是容器类型：`fmap :: Functor f => (a -> b) -> f a -> f b` |'
- en: '| **mplus****mzero** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **mplus****mzero** |'
- en: '`MonadPlus` is a type class which extends a `Monad` class and provides `mzero`
    and `mplus`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonadPlus`是一个类型类，它扩展了`Monad`类并提供了`mzero`和`mplus`：'
- en: '`class Monad m => MonadPlus m where`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Monad m => MonadPlus m where`'
- en: '`mzero :: m a`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`mzero :: m a`'
- en: '`mplus :: m a -> m a -> m a``mplus` combines two results into one.`mzero` represents
    an empty result. |'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`mplus :: m a -> m a -> m a``mplus`将两个结果合并为一个。`mzero`表示一个空结果。|'
- en: '| **return** | Return is our lift function. Don''t confuse `return` with what
    return means in Go. Think of it like this: **Return** a pure value **a** (of type
    **A**) into a monad **m a** (of type **Monad A**). The Lexical Workflow Solution
    calls this function `Get`. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **return** | Return是我们的提升函数。不要把`return`和Go语言中的return搞混了。可以这样理解：**Return**一个纯值**a**（类型为**A**）到一个单子**m
    a**（类型为**Monad A**）。词法工作流解决方案将这个函数称为`Get`。'
- en: '| **(>>=)** | (`>>=`) runs an action and then passes its result to a function
    that also returns an action. Both actions are run and the final result is the
    result of the second action. We can think of (`>>=`) as our chaining function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '| **(>>=)** | (`>>=`)运行一个动作，然后将其结果传递给一个也返回一个动作的函数。两个动作都会运行，最终结果是第二个动作的结果。我们可以把(`>>=`)看作是我们的链接函数：'
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following to your Haskell ghci console:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到你的Haskell ghci控制台：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '(`>>=`) is also known as **bind**. The Lexical Workflow Solution calls this
    function `Get`.Here''s its type definition:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (`>>=`)也被称为**bind**。词法工作流解决方案将这个函数称为`Get`。下面是它的类型定义：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **(>>)** | (`>>`)  performs two actions in sequence. The result of the first
    action is discard. What we keep is the result of the second operation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '| **(>>)** | (`>>`)按顺序执行两个动作。第一个动作的结果被丢弃。我们保留的是第二个操作的结果：'
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '(`>>`) is defined in terms of the `bind` operation that discarded its argument.
    The following says that (`>>`) has a left and right argument that are monadic
    with types `m a` and `m b`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (`>>`)是根据丢弃其参数的`bind`操作定义的。以下说明了(`>>`)有左右两个单子类型为`m a`和`m b`的参数：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Basic monadic functions
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本单子函数
- en: 'The following table consists of some of the more frequently used Monads (for
    composition, looping, and mapping):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了一些更常用的单子（用于组合、循环和映射）：
- en: '| **Function** | **Description** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| **forM** | `forM` acts like an iterator that maps an action over a list and
    returns the transformed list. `forM` serves the same purpose as `mapM` and exists
    for readability. The rule of thumb is that if there are multiple lines of code
    in the for loop, then use `forM`. For example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '| **forM** | `forM`像一个迭代器，它在列表上映射一个动作并返回转换后的列表。`forM`的作用与`mapM`相同，但是为了可读性而存在。经验法则是，如果在for循环中有多行代码，则使用`forM`。例如：'
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **forever** |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| **forever** |'
- en: '`forever` is a combinator used to repeat an action `forever`, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`forever`是一个组合子，用于重复一个动作`forever`，如下所示：'
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **mapM** | The `map` operation performs mutations when it transforms elements
    in a list, right? But how can that be? Pure functions cannot mutate variables.
    We''re able to execute actions indirectly by using `mapM`. `mapM` can change the
    element''s values in the list because it runs in the IO monad, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '| **mapM** | `map`操作在转换列表中的元素时执行了变异，对吧？但是这怎么可能呢？纯函数不能改变变量。我们可以通过使用`mapM`间接执行动作。`mapM`可以改变列表中元素的值，因为它在IO单子中运行，如下所示：'
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **sequence** | Used to evaluate each action in the sequence from left to
    right and collect the results, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '| **sequence** | 用于从左到右评估序列中的每个动作并收集结果，如下所示：'
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **void** | Used to discard the return value of an IO action, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '| **void** | 用于丢弃IO动作的返回值，如下所示：'
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **(=<<)** | This is the same as `>>=` but with the arguments interchanged,
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '| **(=<<)** | 这与`>>=`相同，但参数位置互换，如下所示：'
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **(>=>)** | Used to compose monads via left-to-right Kleisli composition,
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '| **(>=>)** | 用于通过左到右的Kleisli组合组合单子，如下所示：'
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **(<=<)** | This is the same as `>=>` but with the arguments interchanged
    (using right-to-left Kleisli composition), as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '| **(<=<)** | 这与`>=>`相同，但参数位置互换（使用右到左的Kleisli组合），如下所示：'
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Note that `functionName_` functions not listed here are used for side-effects.
    For example, when we want to evaluate such a list for effects, we use `sequence_`
    and `mapM_`, which discard the results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里未列出的`functionName_`函数用于副作用。例如，当我们想要评估这样一个列表以产生效果时，我们使用`sequence_`和`mapM_`，它们会丢弃结果。
- en: Monadic list functions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单子列表函数
- en: The thing to remember with lists is that they model non-determinism. A list
    of values `a` represents a number of different possibilities for the value of
    `a`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件事是，列表模拟了非确定性。值`a`的列表代表了`a`值的许多不同可能性。
- en: '| **Function** | **Description** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **Function** | **Description** |'
- en: '| **filterM** | Used in place of `filter` inside a monad, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '| **filterM** | 用于在单子内部替代`filter`，如下所示：'
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **foldM** | Used in place of foldl where monadic computations built from
    a list are bound left-to-right, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '| **foldM** | 用于在列表构建的单子计算中从左到右绑定foldl的位置，如下所示：'
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **join** | Used to flatten the nesting of groups, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '| **join** | 用于展平组的嵌套，如下所示：'
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **msum** | A list based concat function that is best described by the following
    example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '| **msum** | 一个基于列表的连接函数，最好通过以下示例来描述：'
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **replicateM** | Used to perform an action `n` times and gather the results,
    as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '| **replicateM** | 用于执行一个动作`n`次并收集结果，如下所示：'
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **zipWithM** | Used to merge two lists together, applying a special rule
    in the process. `zipWithM` is a monadic version of the `zipWith` function on lists.
    It is useful when only the side-effects of the monadic computation matter, as
    follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '| **zipWithM** | 用于合并两个列表，同时应用特殊规则。`zipWithM`是列表上`zipWith`函数的单子版本。当只有单子计算的副作用很重要时，它是有用的，如下所示：'
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Monadic workflow implementation
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子工作流实现
- en: 'Let''s start by reading our car data in from a file with base64 encoded text
    strings that represent cars, found in `cars.base64`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从一个包含汽车的base64编码文本字符串的文件`cars.base64`中读取我们的汽车数据：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our car processing monad will take that base64 text, timestamp it, and output
    JSON, as shown in the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的汽车处理单子将获取base64文本，对其进行时间戳处理，并输出JSON，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s start by looking at `main.go`. We import two project packages, `workflow`
    and `utils`. We also import `bufio` and `os` from the Go Standard Library for
    processing our `base64` text file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`main.go`开始。我们导入两个项目包，`workflow`和`utils`。我们还从Go标准库中导入`bufio`和`os`来处理我们的`base64`文本文件。
- en: We put our project packages at the top of our list of imported packages. We
    import *workflow* and *utils*. In this book, we use the logging and configuration
    features from the utils package a lot. In order to be lazy, we'll just remember
    that we can use the `Config` object anywhere we want and refer to a value from
    our `config.toml` file. Similarly, to use our info logger, we can simply type
    `Info.Println`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的项目包放在导入包列表的顶部。我们导入*workflow*和*utils*。在本书中，我们经常使用utils包中的日志记录和配置功能。为了懒惰起见，我们只需记住我们可以在任何地方使用`Config`对象，并引用我们的`config.toml`文件中的值。类似地，要使用我们的信息记录器，我们只需输入`Info.Println`。
- en: In Go, it is considered best practice to write tests first. That's called **test
    driven development**. We discussed that in the first chapter. You should code
    your applications that way. However, after [Chapter 2](../Text/Ch02.xhtml), M*anipulating
    Collections,* example code is more frequently found in the `main.go` file (with
    no test files). I did that because I am a lazy programmer and don't like to type
    more than is absolutely necessary, and I think it conveys the lesson quicker/better.
    I used similar reasoning when I chose to eliminate the package reference requirement
    when calling Config and the Info, Debug, and Error loggers. Should you use a global
    logger and config object at your job? Probably not. Why? Because they are dependencies
    that should be explicitly passed into each function that uses them. [Chapter 7](../Text/Ch07.xhtml)*,
    Functional Parameters*, illustrates how this can can accomplished. For more information,
    see [http://peter.bourgon.org/go-best-practices-2016/](http://peter.bourgon.org/go-best-practices-2016/).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，先写测试被认为是最佳实践。这被称为**测试驱动开发**。我们在第一章讨论过这个问题。你应该以这种方式编写你的应用程序。然而，在[第2章](../Text/Ch02.xhtml)之后，*操作集合*，示例代码更频繁地出现在`main.go`文件中（没有测试文件）。我这样做是因为我是一个懒惰的程序员，不喜欢打字超出必要的范围，而且我认为这样能更快/更好地传达教训。当我选择在调用Config和Info、Debug和Error记录器时消除包引用要求时，我也使用了类似的推理。你应该在工作中使用全局记录器和配置对象吗？可能不应该。为什么？因为它们是应该明确传递给使用它们的每个函数的依赖项。[第7章](../Text/Ch07.xhtml)*，功能参数*，说明了如何实现这一点。更多信息，请参见[http://peter.bourgon.org/go-best-practices-2016/](http://peter.bourgon.org/go-best-practices-2016/)。
- en: In the following `main.go` we import packages and run our initializer.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的`main.go`中，我们导入包并运行我们的初始化程序。
- en: '[PRE27]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `init` function will be executed before our `main` function. We call `GetOptions`
    to read the values in our `config.toml` file into a global `Config` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`函数将在我们的`main`函数之前执行。我们调用`GetOptions`来将`config.toml`文件中的值读取到全局的`Config`变量中。'
- en: Yes. It’s a global variable. And there’re more. For example, Debug, Info, and
    Error are our global loggers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这是一个全局变量。还有更多。例如，Debug、Info和Error是我们的全局记录器。
- en: Are you wondering why I would dare put global variables in an example application
    using a pure FP concept like Monads?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道为什么我会在一个纯FP概念的示例应用程序中放置全局变量，比如单子？
- en: This book is about improving the way you approach application development. Go
    is a multi paradigm language and allows us to mix pure FP with our existing code.
    The `01_car_steps` application consists of an imperative framework with a global
    logger object, as well as some pure FP code to handle workflow.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于改进你处理应用程序开发的方式。Go是一种多范式语言，允许我们将纯FP与我们现有的代码混合在一起。`01_car_steps`应用程序包括一个带有全局记录器对象的命令式框架，以及一些纯FP代码来处理工作流程。
- en: This is a small application, so having one global logger is convenient. If this
    were a larger project, it would be better to have one logger for each instance
    of your service.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小应用程序，所以拥有一个全局记录器很方便。如果这是一个更大的项目，最好为每个服务实例拥有一个记录器。
- en: While this book does cover theory as well as some of the history of pure FP,
    this book’s main goal is to be practical. I hope you will be able to use some
    of the code in this book in your own projects (or at least some of the concepts)
    to build better applications yourself.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书涵盖了纯FP的理论以及一些历史，但这本书的主要目标是实用性。我希望你能够在自己的项目中使用这本书中的一些代码（或者至少是一些概念）来构建更好的应用程序。
- en: Debug, Info, and Error are each assigned a `log.New` object ([https://golang.org/pkg/log/#New](https://golang.org/pkg/log/#New))
    that returns a `*Logger` . If you want to use it concurrently from various goroutines,
    you should pass those logger objects around as pointers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 调试，信息和错误分别分配了一个`log.New`对象（[https://golang.org/pkg/log/#New](https://golang.org/pkg/log/#New)），返回一个`*Logger`。如果你想要并发地从各种goroutines使用它，你应该将这些记录器对象作为指针传递。
- en: 'We can adjust our application settings in the `config.toml` file as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`config.toml`文件中调整我们的应用程序设置如下：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The last setting can tell our application which translation file to use. Later
    in this chapter, we'll see how we can use `go-i18n` to use message IDs to reference
    the appropriate message, and how to change the translation text based on the appropriate
    language/locale. We won't add the internationalization (I18N) of error messages
    in this first example to keep things simple, and so that we can focus on understanding
    how monads work.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个设置可以告诉我们的应用程序使用哪个翻译文件。在本章后面，我们将看到如何使用`go-i18n`来使用消息ID引用适当的消息，以及如何根据适当的语言/区域设置更改翻译文本。在这个第一个例子中，我们不会添加错误消息的国际化（I18N），以保持简单，并且可以专注于理解单子是如何工作的。
- en: The `log_ settings` can affect what gets logged as our application runs. We’ll
    see a few examples of how to use them later in this chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`log_ settings`可以影响我们应用程序运行时记录的内容。我们将在本章后面看到如何使用它们的几个示例。'
- en: Our `main` function initializes a `carCntr` to count how many cars we’ve processed.
    Next, we open our data file using the `Config.DataFilepath` value set in our config
    file.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main`函数初始化了一个`carCntr`来计算我们处理了多少辆汽车。接下来，我们使用在我们的配置文件中设置的`Config.DataFilepath`值打开我们的数据文件。
- en: An idiom is a manner of speaking that is natural to the native speakers of a
    language. In English, idioms often have figurative meanings, utilizing pictures
    to help us visualize that meaning. For example, *Hit the nail on the head*, *A
    hot potato*, *It takes two to tango*, and so on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 成语是一种对本族语言的说话方式。在英语中，成语通常具有比喻意义，利用图片来帮助我们可视化其含义。例如，*Hit the nail on the head*，*A
    hot potato*，*It takes two to tango*等等。
- en: The following `if` statement that opens a file in idomatic style Go.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`if`语句以Go的成语风格打开文件。
- en: 'The `Config.DataFilepath` value, `./data/cars.base64`, comes from our `config.toml`
    file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Config.DataFilepath`的值，`./data/cars.base64`，来自我们的`config.toml`文件：'
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s look closely at that line of code to see what we can learn:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看那行代码，看看我们能学到什么：
- en: '![](img/eb80947b-9568-433a-a564-234239c7d76d.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb80947b-9568-433a-a564-234239c7d76d.png)'
- en: We start with the if statement, like in a typical `if...then` else statement,
    but rather than immediately checking for a Boolean (true/false), after the `if`,
    we execute a statement that opens our data file. That statement assigns err a
    value. If `err == nil`, then we know the file opened successfully. This particular
    idiom is used about 100 times in the Go standard library. The coding styles we
    find in the Go Standard Library should be emulated, especially ones that appear
    that many times.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从if语句开始，就像典型的`if...then` else语句一样，但是不是立即检查布尔值（真/假），在`if`之后，我们执行一个打开我们数据文件的语句。该语句为err赋值。如果`err
    == nil`，那么我们知道文件成功打开。这种特定的成语在Go标准库中使用了大约100次。我们应该模仿在Go标准库中找到的编码风格，特别是那些出现了这么多次的风格。
- en: The goal of this book is not to remove idiomatic Go from your toolbox, but rather
    to add simple yet powerful FP tools to it. *If your only hammer is imperative
    in programming, then every iterative nail looks like a for loop*. That's just
    not the case. Some iterative tasks are better solved with maps, filters, reductions,
    functors, monoids, and/or monads.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目标不是从你的工具箱中删除Go的成语，而是向其中添加简单而强大的FP工具。*如果你的唯一工具是命令式编程，那么每个迭代的钉子看起来都像一个for循环*。这并不是事实。一些迭代任务最好用映射、过滤器、减少、函子、幺半群和/或单子来解决。
- en: In the following `main` function we initialize our car counter and open our
    configuration file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的`main`函数中，我们初始化了我们的汽车计数器并打开了我们的配置文件。
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: After opening a file, it’s best practice to immediately defer the closing of
    the file. (The Go standard library uses defer over 100 times.) This way, we won’t
    forget to close our file, which is a frequent mistake that causes memory leaks
    and can be difficult to troubleshoot. defer is another delightful tool Go gives
    us to help us write better code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件后，最佳实践是立即推迟关闭文件。（Go标准库使用defer超过100次。）这样，我们就不会忘记关闭文件，这是一个经常导致内存泄漏并且难以排除故障的错误。defer是Go给我们的另一个令人愉快的工具，可以帮助我们编写更好的代码。
- en: We execute bufio's `NewScanner` command to open the file and load its contents
    into the scanner variable in order to read the file line by line.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行bufio的`NewScanner`命令来打开文件并将其内容加载到scanner变量中，以便逐行读取文件。
- en: 'For simplicity, we chose to read cars from a file, but we could read our data
    from a stream of input coming from another I/O source such as:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们选择从文件中读取汽车，但我们也可以从另一个I/O源的输入流中读取我们的数据，比如：
- en: ActiveMQ
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveMQ
- en: NATS
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NATS
- en: Kafka
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kafka
- en: Kestrel
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kestrel
- en: NSQ
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NSQ
- en: RabbitMQ
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: Redis
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: Ruby-NATS
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby-NATS
- en: ZeroMQ
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZeroMQ
- en: What’s important is that the interface to the source you read from needs to
    implement the `Reader` interface. If we look at the `NewScanner` implementation
    in the Go standard library, we can see it takes an `io.Reader:`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你从中读取的源的接口需要实现`Reader`接口。如果我们查看Go标准库中`NewScanner`的实现，我们可以看到它需要一个`io.Reader`：
- en: '[PRE31]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `io.Reader` is an interface with one method, `Read`. So, in other words,
    the API that we get our data from needs to have a `Read` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Reader`是一个具有一个方法`Read`的接口。换句话说，我们从中获取数据的API需要有一个`Read`方法：'
- en: '[PRE32]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is another pattern that we should learn to emulate from the Go Standard
    Library: *Program to the interface*. Here, the interface of interest is an object
    with a `Read` method.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个模式，我们应该学会从Go标准库中模仿：*按接口编程*。在这里，感兴趣的接口是一个带有`Read`方法的对象。
- en: 'We can use the scanner''s `Scan` method in a for loop. We will continue to
    iterate until there are no more lines to be read:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在for循环中使用扫描器的`Scan`方法。我们将继续迭代，直到没有更多的行可读取为止：
- en: '[PRE33]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we’re in the loop and have printed out the first line read (the first
    car):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在循环中，并打印出了第一行读取的内容（第一辆车）：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we call our monad to execute the workflow required to process our input
    line (our first car):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用我们的monad来执行处理我们输入行所需的工作流程（我们的第一辆车）：
- en: '[PRE35]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After we process our input, we check for errors and output the result:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完我们的输入后，我们检查错误并输出结果：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The remainder of `main` prints a few dashes, checks for scanner errors and closes
    another if else block.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`的其余部分打印了几条破折号，检查扫描器错误并关闭另一个if else块。'
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码的输出如下：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see what happens when we run this line:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行这行时会发生什么：
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We import `utils` so that we can log errors:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`utils`以便记录错误：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our `ProcessCar` function clearly expresses our business intent. It accepts
    a base64 encoded string and, in idiomatic Go style, returns an error and result
    (`carJson`). If all goes well, our error will be nil and `carJson` will be populated.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ProcessCar`函数清楚地表达了我们的业务意图。它接受一个base64编码的字符串，并以惯用的Go风格返回一个错误和结果（`carJson`）。如果一切顺利，我们的错误将是nil，`carJson`将被填充。
- en: The workflow embodies our business logic. The rest of our code is framework.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流体现了我们的业务逻辑。我们的其余代码是框架。
- en: Notice that `ProcessCar` is not cluttered with error checking code, but rather,
    each step in the workflow is self-explanatory.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ProcessCar`没有被错误检查代码淹没，而是，工作流程中的每个步骤都是不言自明的。
- en: 'This diagram illustrates each step in our workflow:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表说明了我们工作流程中的每个步骤：
- en: '![](img/465e5ef6-1e15-4644-ba5c-e6a0183b6546.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/465e5ef6-1e15-4644-ba5c-e6a0183b6546.png)'
- en: 'We initialize our step variable by calling the `Get` function with our input
    `lineBase64`. This starts our workflow:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用我们的输入`lineBase64`调用`Get`函数来初始化我们的步骤变量。这启动了我们的工作流程：
- en: '[PRE41]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s look in `monad.go` for the `Get` function''s implementation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`monad.go`中查找`Get`函数的实现：
- en: '`src/workflow/monad.go`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/workflow/monad.go`'
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That’s the empty interface! Look out for pirates!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是空接口！小心海盗！
- en: '![](img/d393554d-c2db-4385-9802-566f98cf005f.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d393554d-c2db-4385-9802-566f98cf005f.png)'
- en: This pirate is right. In our example, we do use reflection in our toolbox of
    functions. For example, in order to get the filename to pass to the `ioutil.Readfile`
    function, we must downcast our filename argument from the empty `interace{}` data
    to a string.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个海盗是对的。在我们的示例中，我们确实在我们的函数工具箱中使用了反射。例如，为了获取传递给`ioutil.Readfile`函数的文件名，我们必须将我们的文件名参数从空的`interace{}`数据向下转换为字符串。
- en: 'Here is a snippet from `src/workflow/toolbox.go`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自`src/workflow/toolbox.go`的片段：
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If Go supported generics, we would not need to do this. We''d just need to
    modify our code slightly to accept generic data types. So, the above `ReadFile`
    function would look something like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go支持泛型，我们就不需要这样做了。我们只需要稍微修改我们的代码以接受通用数据类型。因此，上述的`ReadFile`函数将看起来像这样：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That’s about 30% less code, and it will run faster because typecasting is a
    relatively expensive operation. In this case, if Go supported generics, the compiler
    would create a string shaped hole in the compiled `ReadFile` function, into which
    we could pass our string.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约少了30%的代码，并且它将运行得更快，因为类型转换是一个相对昂贵的操作。在这种情况下，如果Go支持泛型，编译器将在编译后的`ReadFile`函数中创建一个字符串形状的空间，我们可以将我们的字符串传递进去。
- en: In this case, if Go supported generics, we’d have about 30% less code to write
    and our code would be type-safe and very fast.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果Go支持泛型，我们将需要写大约30%的代码，并且我们的代码将是类型安全且非常快速的。
- en: It’s easy to see why so many programmers are making such a big deal about this
    topic.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解为什么这么多程序员对这个话题大惊小怪。
- en: If the runtime cost of reflection is too much to bear, then we can leverage
    meta-programming tools like `clipperhouse/gen` to generate the repetitive, boilerplate
    code necessary to handle all the data types that reflection would otherwise handle
    for us. (If we went down this type-safe route, and we compared the code necessary
    to support type-safe, reflection free code to what we'd need to write if Go supported
    generics, we’d likely find that we’d have around 80% less code to maintain than
    if we had generics.)
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果反射的运行时成本太高，那么我们可以利用元编程工具，比如`clipperhouse/gen`来生成处理反射所需的重复样板代码。 （如果我们走这条类型安全的路线，并且比较支持类型安全、无反射代码所需的代码与如果Go支持泛型我们需要编写的代码，我们可能会发现我们需要维护的代码量大约少80%。）
- en: 'Before you start thinking about jumping onto the Haskell or Java bandwagon
    for generics, consider what is good about Go: simplicity, performance, concurrency
    support, and so on. It''s easy enough to use tools to generate type-safe code,
    and when Go does one day (fingers crossed) support generics, we should be able
    to fairly easily remove our generated boilerplate code and simply use generics.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始考虑跳上Haskell或Java的泛型车队之前，考虑一下Go的优点：简单、性能、并发支持等等。使用工具生成类型安全的代码非常容易，当Go有一天（手指交叉）支持泛型时，我们应该能够相当容易地删除我们生成的样板代码，并简单地使用泛型。
- en: 'Here is our `Monad` type. It is a function that accepts an `error` and returns
    transformed `Data` and an `error`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Monad`类型。它是一个接受`error`并返回转换后的`Data`和`error`的函数：
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What can we guess about the way a `Monad` works? Maybe if it gets an error,
    it will fail fast and pass the error along, or otherwise, it will continue processing
    and pass the data along with nil for the error?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能猜到`Monad`的工作方式吗？也许如果它遇到错误，它会快速失败并传递错误，否则它将继续处理并传递数据以及nil的错误？
- en: Sounds a bit like `Continuation Passing Style` (`CPS`) programming, but how
    does it work? Remember in [Chapter 4](../Text/Ch04.xhtml)*, SOLID Design in Go,* when
    we learned that Monads are purple?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点像`Continuation Passing Style`（`CPS`）编程，但它是如何工作的呢？还记得在[第4章](../Text/Ch04.xhtml)*，Go中的SOLID设计*中，我们学到了Monad是紫色的吗？
- en: 'We saw a composition of functions like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了这样的函数组合：
- en: '![](img/2dc0ccef-5432-4615-930c-3a708bb716e0.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dc0ccef-5432-4615-930c-3a708bb716e0.png)'
- en: 'We learned that in order to be a Monad, we need our functions to accept **a**
    and return a like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了为了成为一个Monad，我们需要我们的函数接受**a**并返回一个这样的函数：
- en: '![](img/4d9ffdfa-2d10-4599-ad86-b591d650307a.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d9ffdfa-2d10-4599-ad86-b591d650307a.png)'
- en: 'That would give us associativity:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们关联性：
- en: '![](img/dd30e598-7cd2-4e2e-91dc-5b594d12b128.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd30e598-7cd2-4e2e-91dc-5b594d12b128.png)'
- en: 'We’ll call the `Get` method that lifts our data into the world of pure FP.
    It accepts data and returns a `Monad`. Note that our `Data`, `d`, is curried:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`Get`方法，将我们的数据提升到纯FP的世界中。它接受数据并返回一个`Monad`。请注意，我们的`Data`，`d`是柯里化的：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is where we put our data in the first blue box in our monad chain:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将数据放入monad链中的第一个蓝色框的地方：
- en: '![](img/a8fbd316-efd6-426c-a369-ab5d4cc4c4d7.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8fbd316-efd6-426c-a369-ab5d4cc4c4d7.png)'
- en: 'After initializing our step, we call our first data transformation function,
    `Base64ToBytes` (in `workflow/process_car_steps.go`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化我们的步骤之后，我们调用我们的第一个数据转换函数`Base64ToBytes`（在`workflow/process_car_steps.go`中）：
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s jump back to `monad.go` and look at `Next` function''s implementation:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳回到`monad.go`并查看`Next`函数的实现：
- en: '[PRE48]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `Next` function accepts a monad and a function that returns a monad and
    itself returns a monad.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Next`函数接受一个monad和一个返回monad的函数，并返回一个monad。'
- en: That's it. This is how we get purple Monads that take a and return a.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这就是我们如何得到接受a并返回a的紫色Monad。
- en: '![](img/9a10fa0f-8f49-48c8-a416-6f4ffd7a96ea.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a10fa0f-8f49-48c8-a416-6f4ffd7a96ea.png)'
- en: 'The first line in our `Next` function looks familiar:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`Next`函数中的第一行看起来很熟悉：
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That’s because that line is exactly the same as the first line in our Get method.
    In the line that follows, we call our monad, passing our error as its parameter,
    and get transformed data, `newData`, as well as the `newError` value in return:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这一行与我们的Get方法中的第一行完全相同。在接下来的一行中，我们调用我们的monad，将我们的错误作为其参数传递，并获得转换后的数据`newData`，以及返回的`newError`值：
- en: '[PRE50]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It is here that our stack fills up with `workflow.Next` monad functions. Our
    call stack will look like this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的堆栈填满了`workflow.Next` monad函数。我们的调用堆栈看起来像这样：
- en: '[PRE51]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is where we wire up our steps and jump back to `Get` to grab our data
    (in the return statement):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们连接步骤并跳回到`Get`以获取我们的数据（在返回语句中）的地方：
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we were electricians, we’d turn off the power, wire up the lights in the
    house, and turn the power back on to see if our wiring was correct.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是电工，我们会关闭电源，连接房子里的灯，然后打开电源，看看我们的接线是否正确。
- en: 'As soon as execution returns from the `return d, e` statement, we hit the `if
    newError != nil`  error check block:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行从`return d, e`语句返回，我们就会进入`if newError != nil`错误检查块：
- en: '[PRE53]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If an error occurs, then we return nil for the data and the `newError`; all
    subsequent error checks will pass the same `newError` along until our execution
    spits out the error at the end of the monad chain.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，那么我们为数据和`newError`返回nil；直到我们的执行在monad链的末尾输出错误之前，所有后续的错误检查都将传递相同的`newError`。
- en: 'If an error does not occur, the last return is executed: `return f(newData)(newError)`. What
    is this? Ever seen a function call like this before?'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，则执行最后的返回：`return f(newData)(newError)`。这是什么？以前见过这样的函数调用吗？
- en: '[PRE54]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This language construct is known as the Y-Combinator. Before diving into the
    details of the Y-Combinator implementation in Go, let's think about what it is
    and its origin, the Lambda Calculus.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言结构被称为Y-组合子。在深入讨论Go中Y-组合子实现的细节之前，让我们思考一下它是什么以及它的起源，即λ演算。
- en: Lambda calculus
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: λ演算
- en: 'The Lambda calculus defines what a function is from a computational perspective.
    It''s comprised of three things:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: λ演算从计算的角度定义了函数是什么。它由三个东西组成：
- en: Variables (x, y, z, and so on)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（x、y、z等）
- en: A way of creating functions (with the "\" notation)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数的一种方式（使用“\”符号）
- en: A way to apply functions (substitution)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用函数的一种方式（替换）
- en: Everything else is defined in terms of encoding those three things.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有内容都是根据编码这三个东西来定义的。
- en: 'In [Chapter 7](../Text/Ch07.xhtml), Fu*nctional Parameters,* we defined a function
    where **f** is the function name, **x** is the input value, and the result is
    the whole expression **f(x)**:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](../Text/Ch07.xhtml)中，我们定义了一个函数，其中**f**是函数名，**x**是输入值，结果是整个表达式**f(x)**：
- en: '![](img/0672ab83-0174-4330-8dc7-c871712ae272.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0672ab83-0174-4330-8dc7-c871712ae272.png)'
- en: If *f(x) = x + 2*, then we know that every time we input the value three, five
    will always be the output value. So, functions are like black boxes where we put
    values in and get different values out. There’s neither internal hidden data nor
    side-effects.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f(x) = x + 2*，那么我们知道每次输入值三时，输出值总是五。因此，函数就像黑匣子，我们输入值，得到不同的值。既没有内部隐藏的数据，也没有副作用。
- en: However, in lambda calculus, we use anonymous, unnamed functions. How would
    we express *f(x) = x + 2* in lambda calculus?
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在λ演算中，我们使用匿名的未命名函数。我们如何在λ演算中表示*f(x) = x + 2*？
- en: 'The way we build functions in lambda calculus is with expressions, as shown
    in the following diagram:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在λ演算中构建函数的方式是使用表达式，如下图所示：
- en: '![](img/b5940174-48d8-43a2-8f35-396358e65d76.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5940174-48d8-43a2-8f35-396358e65d76.png)'
- en: The period after `\x` is just a notation that separates our function signature
    (its arguments, x) from its body (`x+2` in our example ).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`\x`后面的句点只是一个将我们的函数签名（其参数x）与其主体（在我们的例子中为`x+2`）分开的标记。'
- en: 'In the following example, `3` is the input parameter:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`3`是输入参数：
- en: '[PRE55]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The result is `5`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`5`。
- en: 'In math class, we’re used to writing function applications like this: f(3).
    In lambda calculus, we say (f 3).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学课上，我们习惯于这样写函数应用：f(3)。在λ演算中，我们说（f 3）。
- en: The function application associates to the left, so `(f a b c) = (((f a) b)
    c)`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用是从左边开始的，所以 `(f a b c) = (((f a) b) c)`。
- en: 'When a function is applied, we are simply substituting our parameter for x
    in our body, where the computation, such as `x+2`, is performed. Let’s try another
    one that takes two parameters:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被应用时，我们只是用我们的参数替换x在我们的主体中，计算，比如`x+2`，就会被执行。让我们再试一个接受两个参数的函数：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This returns one parameter function that also returns one parameter function,
    which then returns the result:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个参数函数，也返回一个参数函数，然后返回结果：
- en: '![](img/21b640c5-cff5-49e1-a198-4ca5c72c000b.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21b640c5-cff5-49e1-a198-4ca5c72c000b.png)'
- en: What we just did was called **currying**, where functions of multiple arguments
    are really just higher order functions that take one argument and return function(s).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的叫做**柯里化**，多参数函数实际上只是接受一个参数并返回函数的高阶函数。
- en: The numbers we used earlier (**2**, **3**, **5**) and the operators (+, /) are
    not part of lambda calculus. We just used them to encode computations.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的数字（2、3、5）和运算符（+、/）不是Lambda演算的一部分。我们只是用它们来编码计算。
- en: 'Lambda calculus does not have data types, but we can represent data types by
    using functions. Let''s create the Boolean data type:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda演算没有数据类型，但我们可以通过使用函数来表示数据类型。让我们创建布尔数据类型：
- en: '| **Boolean functions** | **Description** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **布尔函数** | **描述** |'
- en: '| `true := \x.\y.x` | The `true` function is a function of two parameters (x
    and y) and returns the first parameter (x). |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `true := \x.\y.x` | `true` 函数是一个接受两个参数（x和y）并返回第一个参数（x）的函数。 |'
- en: '| `false := \x.\y.y​` | The `false` function is a function of two parameters
    (x and y) and returns the second parameter (y). |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `false := \x.\y.y​` | `false` 函数是一个接受两个参数（x和y）并返回第二个参数（y）的函数。 |'
- en: 'Let''s define the logical negation function, not:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义逻辑非函数，not：
- en: '| **Boolean expressions** | **Description** |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **布尔表达式** | **描述** |'
- en: '| (\b. b false true ) true | lambda b b applied to false and true returns true
    |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| (\b. b false true ) true | lambda b b 应用于false和true返回true |'
- en: '| (\b. b true false ) false | lambda b b applied to true and false returns
    false |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| (\b. b true false ) false | lambda b b 应用于true和false返回false |'
- en: 'We''ve seen that the Fibonacci function is recursive:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到斐波那契函数是递归的：
- en: '![](img/e9e29fdd-7ed4-48ff-b45e-d8692638366b.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9e29fdd-7ed4-48ff-b45e-d8692638366b.png)'
- en: We defined the `fib` function in terms of itself. That makes the fib function
    recursive.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`fib`函数是基于自身的。这使得`fib`函数是递归的。
- en: Let's start by defining a for loop using Lambda Calculus.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用Lambda演算定义一个for循环开始。
- en: Maybe we could form an expression a that would call itself, as in, apply the
    function to itself. That would that look like?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以形成一个表达式a，它会调用自身，也就是将函数应用于自身。那会是什么样子呢？
- en: '[PRE57]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s see how that works:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '![](img/2db74003-ff22-4e84-ab95-9b107250c28a.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2db74003-ff22-4e84-ab95-9b107250c28a.png)'
- en: '`\x.x x` takes input `x` and applies `x` to itself. Our function takes `x`
    as its input and makes two copies of `x`. That''s called self application.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`\x.x x` 接受输入`x`并将`x`应用于自身。我们的函数以`x`作为输入，并生成`x`的两个副本。这就是自我应用。'
- en: Recursion is about defining something in terms of itself.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 递归就是关于用自身来定义某物。
- en: 'Let''s see what it looks like when we perform recursion twice:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们执行两次递归时会是什么样子：
- en: '![](img/b574874e-0187-4506-ab08-9dd58519e9cb.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b574874e-0187-4506-ab08-9dd58519e9cb.png)'
- en: We can see how this process can continue indefinitely. This is how we encode
    for loop behavior using Lambda calculus.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个过程如何无限地继续下去。这就是我们如何使用Lambda演算来编码for循环行为。
- en: Now that we know how to encode a for loop, how can we encode recursion?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何编码一个for循环，那么如何编码递归呢？
- en: 'Let''s define a general recursive function as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个通用的递归函数如下：
- en: '[PRE58]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That reads, recursive `f` equals `f` applied to recursive `f`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这读作，递归的`f`等于`f`应用于递归的`f`。
- en: 'When we run this function, it will repeatedly apply `f` and we''ll get:  `f(f(f(...)))`. The
    following is the Y-Combinator:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个函数时，它将重复应用`f`，我们会得到： `f(f(f(...)))`。以下是Y-组合器：
- en: '[PRE59]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It's not recursive, but it encodes recursion. This is how we can implement recursion
    in a language that does not support recursion.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是递归的，但它编码了递归。这就是我们如何在不支持递归的语言中实现递归的方式。
- en: Ready to see how to implement the Y-Combinator in Go?
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好看如何在Go中实现Y-组合器了吗？
- en: But wait, there's more.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，还有更多。
- en: 'Let''s stop to think about where the Y-Combinator could be used in bioengineering.
    The recursive genome function could be modeled using the Y-Combinator. What proof
    is there that the Lambda Calculus is practical? Look in the mirror:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停下来思考Y-组合器在生物工程中可以用在哪里。递归基因组函数可以使用Y-组合器进行建模。Lambda演算实际上是实用的证据在哪里？看镜子里：
- en: '![](img/b4955fe3-7619-4e03-96c4-0aa419fc089e.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4955fe3-7619-4e03-96c4-0aa419fc089e.png)'
- en: For more information on the *Recursive Genome Function - the Pellionisz Principle*,
    see [http://www.junkdna.com/recursivegenomefunction/](http://www.junkdna.com/recursivegenomefunction/).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*递归基因组函数-佩里奥尼兹原理*的更多信息，请参见[http://www.junkdna.com/recursivegenomefunction/](http://www.junkdna.com/recursivegenomefunction/)。
- en: Did you know that your genes can be sequenced and anomalies detected to indicate
    your predisposition to certain diseases, like Parkinson's Disease? The sooner
    you know, the sooner preventative measures can be taken.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗，你的基因可以被测序，检测出异常，表明你对某些疾病的易感性，比如帕金森病？你越早知道，预防措施就能越早采取。
- en: See [https://en.wikipedia.org/wiki/Disease_gene_identification](https://en.wikipedia.org/wiki/Disease_gene_identification).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[https://en.wikipedia.org/wiki/Disease_gene_identification](https://en.wikipedia.org/wiki/Disease_gene_identification)。
- en: The Lambda Calculus (which provides recursion) and Monads (which control the
    composition of operations) are deeply woven into the fabric of life. What happens
    when we sleep? Have you ever worked long hours to solve a problem without success,
    only to wake the next morning with the solution in mind? Did you know that we
    are about 25% more susceptible to illness when we are sleep deprived? What do
    you think causes DNA mutations that lead to cancerous cell growth? What is it
    about restorative time (sleep) that allows our body to compose properly?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda演算（提供递归）和单子（控制操作的组合）深深地编织在生活的结构中。当我们睡觉时会发生什么？你是否曾经长时间工作来解决问题，但没有成功，只是在第二天早上醒来时想到了解决方案？你知道吗，当我们睡眠不足时，我们更容易患病约25%？你认为是什么导致了导致癌细胞生长的DNA突变？休息时间（睡眠）有什么特别之处，使我们的身体能够正确地组合？
- en: When we follow basic rules, we thrive.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遵循基本规则时，我们会茁壮成长。
- en: '"Early to bed, early to wise makes a man healthy wealthy and wise."'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: “早睡早起使人健康、富有和聪明。”
- en: '- Benjamin Franklin'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '- 本杰明·富兰克林'
- en: Y-Combinator
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Y-Combinator
- en: The Y-combinator is one of most beautiful ideas in all of programming. This
    code demonstrates how amazingly powerful the simple ideas of functional programming
    are. The Y-Combinator is a higher order function. It accepts a single argument,
    which is a function that isn't recursive. It returns a copy of the function which
    is recursive. It requires that our language supports first class functions and
    that functions be named or anonymous. Go supports all of that.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Y-Combinator是编程中最美丽的想法之一。这段代码展示了函数式编程的简单思想是多么强大。Y-Combinator是一个高阶函数。它接受一个参数，这个参数是一个不是递归的函数。它返回一个递归的函数的副本。它要求我们的语言支持一级函数和函数命名或匿名。Go支持所有这些。
- en: The Y in Y-Combinator
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Y-Combinator中的Y
- en: Ever wonder the Y in the Y-Combinator comes from?
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想知道Y-Combinator中的Y来自哪里？
- en: '![](img/8937b02c-0771-4fd0-9e6c-5ae1d63666f0.png)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8937b02c-0771-4fd0-9e6c-5ae1d63666f0.png)'
- en: See how **A** and **B** and **C** connect the dots to form the top part of the
    "y"?
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 看看**A**和**B**和**C**如何连接起来形成“y”的顶部部分？
- en: How the Y-Combinator works
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Y-Combinator的工作原理
- en: 'The diagram below illustrates how the Y-Combinator works:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表说明了Y-Combinator的工作原理：
- en: '![](img/cbc5c483-225c-4d80-96a2-1925fcaa77c5.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbc5c483-225c-4d80-96a2-1925fcaa77c5.png)'
- en: 'The following are the steps to wire up the Y-Combinator:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接Y-Combinator的步骤：
- en: '`f(newData)` calls `Base64ToByes` with the `base64` encoded text. `dString`
    is downcast into a string.'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`f(newData)`调用`Base64ToByes`并使用`base64`编码的文本。`dString`被降级为字符串。'
- en: The `return func(e error) (Data, error) {` statement is executed and returns
    execution back to the return statement in the `Next` function.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`return func(e error) (Data, error) {`语句被执行，并将执行返回到`Next`函数中的返回语句。'
- en: At that time, `f(newData)`, which itself is a function, has its `newError` parameter
    populated and can now be executed.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，`f(newData)`本身是一个函数，它的`newError`参数被填充，现在可以执行。
- en: Runtime execution returns to the `return func(e error) (Data, error)` line in
    `Base64ToBytes` and enters its code block, which is the return statement that
    decodes the `base64` string into a regular string.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时执行返回到`Base64ToBytes`中的`return func(e error) (Data, error)`行，并进入其代码块，这是将`base64`字符串解码为常规字符串的返回语句。
- en: Execution again returns to `Next`, in the last return line. This is where recursion
    happens. It calls itself, passing the error value.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行再次返回到`Next`，在最后的返回行。这是递归发生的地方。它调用自身，传递错误值。
- en: On *line 14* we call our next monad. This is where continuation passing happens.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第14行*，我们调用下一个单子。这是继续传递发生的地方。
- en: We wrote a recursive function of one bound variable using only functions of
    one variable and no assignments. The Y-combinator performs the magic of associating
    the anonymous inner function (`func(e error) (Data, error) {`) with the parameter
    name (`newError`) of the function (`f`) that was originally passed to `Next`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个使用一个绑定变量的递归函数，只使用一个变量的函数和没有赋值。Y-Combinator执行了将匿名内部函数(`func(e error) (Data,
    error) {`)与最初传递给`Next`的函数(`f`)的参数名(`newError`)关联起来的魔术。
- en: Now that we know how one of our reusable functions in `toolbox.go` works, we
    don’t need to go through the rest of them. They all work the same way. We can
    simply move on to the `Next` step through each line of our workflow until we come
    out the other end. If an error is encountered in any of our reusable functions,
    we simply kick the can down the road.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了`toolbox.go`中一个可重用函数的工作原理，我们就不需要再去了解其他函数了。它们都是以相同的方式工作。我们只需通过工作流程的每一行进行`Next`步骤，直到我们走出另一端。如果在任何可重用函数中遇到错误，我们只需将问题推迟到下一步。
- en: This makes it easy and simple to handle errors. Errors only need to be handled
    at the very end of the process, in one place. Simple.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得处理错误变得简单和容易。错误只需要在流程的最后一步处理，只需在一个地方处理。简单。
- en: The Lexical Workflow solution
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 词法工作流解决方案
- en: 'Here''s our entire `ProcessCar` workflow:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们整个`ProcessCar`工作流程：
- en: '[PRE60]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How's that for clarity? Each step one after the next and error handling at the
    very end.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于清晰度来说如何？每一步接着下一步，错误处理在最后。
- en: This Go idiomatic Monadic workflow solution needs a label, and because I thought
    of it first, its name is The Lexical Workflow. It's how we can do Monadic composition
    of impure components in Go. Lex means **law**, and since it controls and rules
    over our workflow, the name fits. (The fact that it has my name in it must be
    purely coincidental!)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这种符合Go惯用法的单子工作流解决方案需要一个标签，因为我首先想到了它，它的名字是词法工作流。这是我们如何在Go中对不纯组件进行单子组合的方式。Lex意味着**法律**，因为它控制和支配我们的工作流，所以这个名字很合适。（它有我的名字纯属巧合！）
- en: Is our ProcessCar method idomatic Go code?
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的ProcessCar方法是否符合Go代码的惯用法？
- en: Let's start with what's not idiomatic.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从不符合惯用法的地方开始。
- en: The non idiomatic parts
  id: totrans-430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不符合惯用法的部分
- en: There are no if `err != nil` error checks until the end of our processing pipeline. That’s
    by design.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的处理管道的末尾之前，没有`err != nil`的错误检查。这是有意设计的。
- en: 'The benefits of using a monadic pipeline are as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单子管道的好处如下：
- en: Enables us to clearly express business logic without the clutter
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们能够清晰地表达业务逻辑，而不受干扰
- en: Eliminates if `err != nil` error checks after every operative line of code
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除每个操作代码行后的`err != nil`错误检查
- en: Provides structure for pipeline processing
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为管道处理提供结构
- en: Orders all of our `Next` steps in our workflow
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对我们工作流中的所有`Next`步骤进行排序
- en: Provides a framework for plugging in reusable components
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为插入可重用组件提供框架
- en: The idiomatic parts
  id: totrans-438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 成语化的部分
- en: 'We have a typical if `err != nil` error check at the end of our pipeline:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在管道的末尾有一个典型的`if err != nil`错误检查：
- en: '[PRE61]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is where we should perform error checking, so having an error check is
    natural.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该执行错误检查的地方，所以进行错误检查是很自然的。
- en: 'We could choose to implement an `Either` monad to wrap our response in a struct
    that might look like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择实现一个`Either`单子来将我们的响应包装在一个可能看起来像这样的结构中：
- en: '[PRE62]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We could include a sum or union type which would return only either `Success()`
    or `Failure()`:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含一个求和或联合类型，它只会返回`Success()`或`Failure()`：
- en: '[PRE63]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then we would have to create another interface to convert our `Either` to a
    `Success` or a `Failure`. It might look something like this:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要创建另一个接口来将我们的`Either`转换为`Success`或`Failure`。它可能看起来像这样：
- en: '[PRE64]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: But we'll no longer pursue these monadic error handling techniques. The Go idiomatic
    error check works great for our purposes (to handle errors for this workflow)
    and it does so without the added complexities of additional layers of interfaces
    or other external dependencies (that we'll discuss at the end of this chapter).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将不再追求这些单子错误处理技术。Go成语化的错误检查非常适合我们的目的（处理此工作流的错误），而且它不会增加额外的接口层或其他外部依赖的复杂性（我们将在本章末讨论）。
- en: An alternative workflow option
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个工作流选项
- en: 'Suppose we have a text file that looks like this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个文本文件，看起来像这样：
- en: '[PRE65]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This code will read three sets of two characters:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将读取三组两个字符：
- en: '[PRE66]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can improve our code by defining a struct with an error field and an `io.Reader`
    field:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个带有错误字段和`io.Reader`字段的结构来改进我们的代码：
- en: '[PRE67]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You might remember from [Chapter 3](../Text/Ch03.xhtml), *Using High-Order
    Functions,* that the `io.Reader` interface only requires one method, read. So,
    we implement that and add the `logInfo` call:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得[第3章](../Text/Ch03.xhtml)中的*使用高阶函数*，`io.Reader`接口只需要一个方法，read。所以，我们实现了它并添加了`logInfo`调用：
- en: '[PRE68]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, our code to print three sets of two bytes looks like this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们打印三组两个字节的代码如下：
- en: '[PRE69]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Much better! But that is more like a utility function than a workflow solution.
    It simplifies our code and reduces the number of ` if err != nil`  blocks.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！但这更像是一个实用函数而不是工作流解决方案。它简化了我们的代码，并减少了`if err != nil`块的数量。
- en: However, for every step in our workflow, if possible, we’d need to create a
    separate utility function, and each would have its own `if err != nil`  blocks.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的工作流的每一步中，如果可能的话，我们需要创建一个单独的实用函数，并且每个函数都有自己的`if err != nil`块。
- en: Compare that to our monad workflow pipeline that only requires one  `if err
    != nil` block.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与我们的单子工作流管道进行比较，只需要一个`if err != nil`块。
- en: Business use case scenarios
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务用例场景
- en: The monad workflow provides a solution for business use case scenarios. If we
    work with a team that implements application features or manages tasks using use
    case scenarios, the steps in the monad workflow pipeline would likely correspond
    directly to our task’s requirements. Using this workflow could simplify testing,
    as well as development.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 单子工作流为业务用例场景提供了解决方案。如果我们与一个团队合作，该团队使用用例场景实现应用程序功能或管理任务，单子工作流管道中的步骤可能直接对应于我们任务的需求。使用这个工作流可能简化测试以及开发。
- en: 'Here’s an example that requires five steps:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要五个步骤的例子：
- en: '![](img/f7829288-5fff-4310-a0dd-62b37dbd0098.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7829288-5fff-4310-a0dd-62b37dbd0098.png)'
- en: Each requirement maps directly to a workflow step (as well as a test).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 每个需求直接映射到工作流步骤（以及测试）。
- en: 'If we make it through the last step with no errors, then we downcast our data
    into a string. It will contain JSON and look something like this:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过最后一步没有错误，那么我们将把我们的数据转换为字符串。它将包含JSON并且看起来像这样：
- en: '[PRE70]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Y-Combinator re-examined
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视Y-组合子
- en: 'Let’s look at another Y-Combinator example in Go to improve our grasp of the
    topic. Remember the `Fibonacci` function in [Chapter 1](../Text/Ch01.xhtml), *Pure
    Functional Programming in Go*? It looked like this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个Go中的Y-组合子示例，以改善我们对该主题的理解。还记得[第1章](../Text/Ch01.xhtml)中的`Fibonacci`函数，*Go中的纯函数式编程*吗？它看起来像这样：
- en: '[PRE71]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If it passes a `0`, `1`, or `2`, it simply returns a value (`0` or `1`). Otherwise,
    it will call itself (recursion) with two functions that look like this--`fib(x-2)
    + fib(x-1)`. Since values are continually being decremented by two or one, processing
    will eventually complete, at which time the accumulated values will be summed
    up.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它传递了`0`，`1`或`2`，它只会返回一个值（`0`或`1`）。否则，它将调用自身（递归）并返回这样的两个函数--`fib(x-2) + fib(x-1)`。由于值不断减少两个或一个，处理最终将完成，届时累积的值将被求和。
- en: 'The following diagram illustrates this recursive processing. The orange and
    red boxes highlight functions that only need to be executed once. Referential
    integrity allows us to store the value of those functions. Subsequent execution
    only needs to look up the stored value, rather than re-execute the function:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这种递归处理。橙色和红色框突出显示只需要执行一次的函数。引用完整性允许我们存储这些函数的值。后续执行只需要查找存储的值，而不是重新执行函数：
- en: '![](img/695320f1-fb9f-49d4-b948-d1658e2aa050.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](img/695320f1-fb9f-49d4-b948-d1658e2aa050.png)'
- en: 'We define three function types in `main.go`, as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main.go`中定义了三种函数类型，如下所示：
- en: '`Func`: A simple function that takes an int and returns an `int`'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func`：一个简单的函数，接受一个整数并返回一个整数'
- en: '`FuncFunc`: A function that takes a function of type `Func` and returns a function
    of type `Func`'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FuncFunc`：一个接受`Func`类型的函数并返回`Func`类型的函数'
- en: '`RecursiveFunc`: A function that takes a `RecursiveFunc` function and returns
    a function of type `Func`'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecursiveFunc`：一个接受`RecursiveFunc`函数并返回`Func`类型的函数'
- en: '[PRE72]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s look at what happens when we initialize the `yCombo` variable:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们初始化`yCombo`变量时会发生什么：
- en: '[PRE73]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `yCombinator` function is called and we initialize our `g` variable with
    a recursive lambda expression.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`yCombinator`函数并使用递归lambda表达式初始化我们的`g`变量。
- en: 'Let''s take a closer look at the wiring that occurs when we initialize the
    `yCombo` variable:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下当我们初始化`yCombo`变量时发生的连接：
- en: '![](img/8fd202ce-337f-4a96-8b36-2ef87d8c4589.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fd202ce-337f-4a96-8b36-2ef87d8c4589.png)'
- en: 'Compare that to the minimal wiring required for the basic recursive variable
    initialization:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与初始化基本递归变量所需的最小连接进行比较：
- en: '![](img/2029b1cb-2c02-466a-90ef-219a56e102a3.png)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2029b1cb-2c02-466a-90ef-219a56e102a3.png)'
- en: 'The execution path looks to be nearly the opposite when we evaluate our Lambda
    expressions on *line 13* and *line 14*. The slightly wider red lines are the two
    steps the `yCombo` function requires to evaluate the expression. The thinner black
    lines are the eight (plus one) steps that it takes to evaluate the regular recursive
    function:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第13行*和*第14行*评估我们的Lambda表达式时，执行路径看起来几乎相反。稍微宽一点的红线是`yCombo`函数评估表达式所需的两个步骤。细一点的黑线是评估常规递归函数所需的八（加一）步：
- en: '![](img/01cf266f-2eb8-4911-aeb5-978c75e91836.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01cf266f-2eb8-4911-aeb5-978c75e91836.png)'
- en: These patterns of execution indicate major differences. The `yCombinator` (lambda
    expression) does hold on to state and only references the argument (`x`). In contrast,
    the regular recursive function holds on to the state of `x` after arriving at
    the `Recurse` function (*step 2*). When `Recurse` gets to *step 6* (*line 43*),
    the value for `x` is supplied from *line 42* (left there from *step 2*).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这些执行模式表明了主要的差异。`yCombinator`（lambda表达式）保留状态并且只引用参数（`x`）。相比之下，常规递归函数在到达`Recurse`函数后保留了`x`的状态（*第2步*）。当`Recurse`到达*第6步*（*第43行*）时，`x`的值是从*第42行*提供的（留在*第2步*）。
- en: Since the `yCombinator` (lambda expression) has been prewired, when it's time
    to evaluate the lambda expression (*line 13*), only two steps are required. Compare
    that to the twelve steps required to evaluate the regular recursive function (`Recurse`).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`yCombinator`（lambda表达式）已经预先连接，当需要评估lambda表达式（*第13行*）时，只需要两个步骤。与评估常规递归函数（`Recurse`）需要的十二个步骤相比。
- en: Since recursion is necessary in our lambda expression implementation, now would
    be a good time to re-emphasize the need for the Go compiler to support **Tail
    Call Optimization** (**TCO**). [Chapter 3](../Text/Ch03.xhtml), *Using High-Order
    Functions,* mentioned that TCO avoids creating a new stack by making the last
    call in a recursion the function itself.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 由于递归在我们的lambda表达式实现中是必要的，现在是强调Go编译器支持**尾调用优化**（**TCO**）的好时机。[第3章](../Text/Ch03.xhtml)，*使用高阶函数*，提到TCO通过使递归中的最后一次调用成为函数本身来避免创建新的堆栈。
- en: What is tail recursion?
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是尾递归？
- en: 'Recursion is where a function calls itself. Tail recursion is where a recursive
    call is the last line of our function. For example, the last line of our `fib`
    function calls itself twice:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是指一个函数调用自身。尾递归是指递归调用是函数的最后一行。例如，我们的`fib`函数的最后一行调用自身两次：
- en: '[PRE74]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this case, there is no reason to preserve the state. There are no other lines
    of code left to execute in the function and we don’t care about any values of
    any variables that may have been assigned prior to reaching our return statement.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有必要保留状态。在函数中没有其他代码需要执行，我们也不关心在到达返回语句之前分配的任何变量的任何值。
- en: If our return statement occurred in the middle of our function, the Go runtime
    would need to remember our function’s address in order to return to it, and it
    would need to store function-local variable values for when our recursive call
    completes and returns to resume execution.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的返回语句出现在函数的中间，Go运行时需要记住我们函数的地址以便返回，并且需要存储函数局部变量的值，以便在递归调用完成并返回以恢复执行时使用。
- en: The problem we currently have is that Go treats all recursive calls the same.
    Even though tail recursion has no need for a return address or to access any other
    function-local variable values, Go does it anyway.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前的问题是，Go对所有递归调用都一视同仁。即使尾递归不需要返回地址或访问任何其他函数局部变量的值，Go也会执行。
- en: If Go were tail call optimized, then it would not allocate additional space
    on the stack but would instead execute a `GOTO` statement from the tail call directly
    to itself. That would improve performance and save stack space.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go进行了尾调用优化，那么它将不会在堆栈上分配额外的空间，而是直接从尾调用执行`GOTO`语句到自身。这将提高性能并节省堆栈空间。
- en: Why not optimize tail calls? One reason is that inserting `GOTO` statements
    could make debugging stack frame information more difficult.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不优化尾调用？一个原因是插入`GOTO`语句可能会使调试堆栈帧信息更加困难。
- en: When was the last time you debugged a stack frame? I’m sure system programmers
    debug stack frames all day, but most of us don’t. It’s probably safe to assume
    that we all care about performance. Perhaps a trade-off would be to allow functional
    programmers to add an annotation above a tail call to indicate to the compiler
    to perform TCO for us?
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你上次调试堆栈帧是什么时候？我相信系统程序员整天都在调试堆栈帧，但我们大多数人不会。可以肯定地假设我们都关心性能。也许一个权衡是允许函数式程序员在尾调用上方添加一个注释，指示编译器为我们执行TCO？
- en: Without TCO, we need to be aware of recursion depth, because in Go each level
    of recursion means another layer of information that Go runtime needs to store
    on the stack.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 没有尾递归优化，我们需要注意递归深度，因为在Go中，每一层递归都意味着Go运行时需要在堆栈上存储另一层信息。
- en: If we are traversing a binary tree, our recursive algorithm will likely be **O(log
    n)**, which means that we will likely not run into runtime performance issues.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遍历二叉树，我们的递归算法可能是**O(log n)**，这意味着我们可能不会遇到运行时性能问题。
- en: However, if our recursion depth is **O(n)**, this could lead to some troubles
    with stack. Anything over that should be avoided.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的递归深度是**O(n)**，这可能会导致堆栈出现问题。应该避免超过这个深度。
- en: Big-Oh notation
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大O符号
- en: Big-Oh notation is frequently used to indicate the relative complexity of algorithms.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号经常用于表示算法的相对复杂性。
- en: 'It’s used to indicate the order of an algorithm. For example, if we have three
    algorithms, one O(n), one O(n log n), and one O(n2), the times for various n are:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于指示算法的顺序。例如，如果我们有三种算法，一个是O(n)，一个是O(n log n)，一个是O(n2)，那么不同n的时间是：
- en: '| **n** | **O(n)** | **O(n log n)** | **O(n2)** |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| **n** | **O(n)** | **O(n log n)** | **O(n2)** |'
- en: '| 10 | 10 | 33 | 100 |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 10 | 33 | 100 |'
- en: '| 100 | 100 | 664 | 10000 |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 100 | 664 | 10000 |'
- en: '| 500 | 500 | 4483 | 250000 |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 500 | 500 | 4483 | 250000 |'
- en: '| 1000 | 1000 | 9966 | 1000000 |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 1000 | 9966 | 1000000 |'
- en: '| 5000 | 5000 | 61438 | 25000000 |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 5000 | 5000 | 61438 | 25000000 |'
- en: Let’s assume our unit of measurement is one second per operation. The first
    line in the table tells us that executing 10 operations takes from 10 seconds
    for an **O(n)** algorithm to about 1.5 minutes for a **O(n2)** algorithm. The
    last line tells us that executing 5,000 operations would take from 1.4 hours for
    the **O(n)** to around three quarters of a year for the **O(n2)** algorithm. Order
    of magnitude matters.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的操作单位是每秒一次。表中的第一行告诉我们，执行10次操作对于**O(n)**算法需要10秒，对于**O(n2)**算法需要大约1.5分钟。最后一行告诉我们，执行5000次操作对于**O(n)**算法需要1.4小时，对于**O(n2)**算法需要大约四分之三年。数量级很重要。
- en: What does this have to do with tail recursion? Recursive function calls make
    our stack grow linearly **O(n)**. So, the lack of TCO probably won't make our
    applications crash, but it will definitely slow them down. Performing computations
    with an order of magnitude greater than **O(n)** would be difficult at best.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这与尾递归有什么关系？递归函数调用使我们的堆栈线性增长**O(n)**。因此，缺乏TCO可能不会使我们的应用程序崩溃，但肯定会减慢它们的速度。执行大于**O(n)**数量级的计算将是非常困难的。
- en: In other words, when we use recursive function calls, we can quickly run out
    of stack space. TCO can reorganize/optimize our code so that our program uses
    constant stack space, which will prevent our stack from growing too large and
    will reduce stack errors.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们使用递归函数调用时，我们可能会很快耗尽堆栈空间。TCO可以重新组织/优化我们的代码，使我们的程序使用恒定的堆栈空间，这将防止我们的堆栈变得过大，并减少堆栈错误。
- en: 'The benefits of TCO are:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: TCO的好处包括：
- en: Improved execution speed, since no stack pushes and pops are required
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进的执行速度，因为不需要堆栈推送和弹出。
- en: Function recursion depth is no longer a constraint
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数深度不再是一个限制
- en: Stack overflow runtime errors will not be an issue
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈溢出运行时错误将不是一个问题
- en: 'The languages that support TCO are:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 支持TCO的语言有：
- en: Common Lisp
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Common Lisp
- en: JavaScript (ECMAScript 6.0)
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript（ECMAScript 6.0）
- en: Lua
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua
- en: Python
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: Scheme
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scheme
- en: Racket
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Racket
- en: Tcl
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tcl
- en: Kotlin
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin
- en: Elixir
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elixir
- en: Perl
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Perl
- en: Scala
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala
- en: Where's Haskell? Haskell performs more optimized optimizations than just the
    tail call elimination. Haskell uses *guarded* recursion. It's a lazy runtime system
    that does not evaluate a thunk unless it has to.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell在哪里？Haskell执行的优化优于尾调用消除。Haskell使用*guarded*递归。这是一个懒惰的运行时系统，除非必须，否则不会评估一个thunk。
- en: There are a few reasons to not include it. With TCO enabled, calls would no
    longer be clearly delineated, making debugging stack frames more difficult. How
    would TCO affect defer statements?
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因不包括它。启用TCO后，调用将不再清晰地划分，使得调试堆栈帧更加困难。TCO会如何影响延迟语句？
- en: What if Go supported an annotation (such as `//@tco`) that would allow us to
    turn on TCO for a particular function call?
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go支持一个注释（比如`//@tco`），允许我们为特定的函数调用打开TCO，会怎么样？
- en: See the  *How to Propose Changes To Go *section of the appendix for more information
    about Go and TCO.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Go和TCO的更多信息，请参见附录中的*如何提出更改Go*部分。
- en: InternationalizatioN (I18N) package
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 国际化（I18N）包
- en: Remember earlier in the chapter when we looked at the monad workflow and saw
    how we could push all errors that occurred in any step into the error pipe and
    wait until the very end to process them?
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得本章开头我们看了单子工作流，并看到我们如何将发生在任何步骤中的所有错误推送到错误管道，并等到最后处理它们吗？
- en: One thing we might need to do when we process errors is to localize the error
    messages for the language of the individuals tasked with reading them.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理错误时，我们可能需要做的一件事是将错误消息本地化为负责阅读它们的个人的语言。
- en: This sample application explores how we might do that using the `go-i18n` library.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应用程序探讨了如何使用`go-i18n`库来实现这一点。
- en: The Go package **go-i18n** ([https://github.com/nicksnyder/go-i18n](https://github.com/nicksnyder/go-i18n)) a
    command ([https://github.com/nicksnyder/go-i18n#goi18n-command](https://github.com/nicksnyder/go-i18n#goi18n-command))
    that helps you translate Go programs into multiple languages. It supports pluralized
    strings ([http://cldr.unicode.org/index/cldr-spec/plural-rules](http://cldr.unicode.org/index/cldr-spec/plural-rules))
    for all 200+ languages in the **Unicode Common Locale Data Repository** (**CLDR**)
    [http://www.unicode.org/cldr/charts/28/supplemental/language_plural_rules.html](http://www.unicode.org/cldr/charts/28/supplemental/language_plural_rules.html).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: Go包**go-i18n**（[https://github.com/nicksnyder/go-i18n](https://github.com/nicksnyder/go-i18n)）提供了一个命令（[https://github.com/nicksnyder/go-i18n#goi18n-command](https://github.com/nicksnyder/go-i18n#goi18n-command)），可以帮助您将Go程序翻译成多种语言。它支持**Unicode通用区域设置数据存储库**（**CLDR**）中的所有200多种语言的复数字符串（[http://cldr.unicode.org/index/cldr-spec/plural-rules](http://cldr.unicode.org/index/cldr-spec/plural-rules)）[http://www.unicode.org/cldr/charts/28/supplemental/language_plural_rules.html](http://www.unicode.org/cldr/charts/28/supplemental/language_plural_rules.html)。
- en: 'In `main.go`, we import the `github.com/nicksnyder/go-i18n/i18n` library as
    well at the text/template library from Go’s Standard Library:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中，我们导入了`github.com/nicksnyder/go-i18n/i18n`库以及Go标准库中的text/template库：
- en: '[PRE75]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Here, we initialize the `funcMap` function with the `"T"` key, and give it
    the value `i18n.TranslateFunc`:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`funcMap`函数初始化了`"T"`键，并给它赋予了`i18n.TranslateFunc`的值：
- en: '[PRE76]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we define our templates:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的模板：
- en: '[PRE77]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We define their corresponding functions:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义它们对应的函数：
- en: '[PRE78]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Notice that if our error message accepts parameters, then we define them in
    the body of the Execute function. For example, `illegalBase64` defines `BytePos`.
    Here’s how it might be output:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们的错误消息接受参数，那么我们在`Execute`函数的主体中定义它们。例如，`illegalBase64`定义了`BytePos`。下面是它可能的输出方式：
- en: '[PRE79]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In our main function, we load our translation files. In this sample application,
    we’ll show the support for English and German:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们加载我们的翻译文件。在这个示例应用程序中，我们将展示对英语和德语的支持：
- en: '[PRE80]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next, we range over a list of our two languages, `en-US`, and `de-DE`, printing
    out three messages for each language:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历我们两种语言的列表，`en-US`和`de-DE`，为每种语言打印出三条消息：
- en: '[PRE81]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is where we tell `i18n` which translation to use:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们告诉`i18n`要使用哪个翻译的地方：
- en: '[PRE82]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Three lines follow, in which we assign our en-US translation function to the
    `"T"` key of our `tmplIllegalBase64Data` variable:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是三行，我们将我们的en-US翻译函数分配给`tmplIllegalBase64Data`变量的`"T"`键：
- en: '[PRE83]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When it is evaluated, the `Funcs` method in `text/template/template.go` is executed
    and is passed to our `funcMap` variable.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被评估时，`text/template/template.go`中的`Funcs`方法被执行并传递给我们的`funcMap`变量。
- en: 'This is what `Funcs` looks like (mine is in `/usr/local/Cellar/go/1.9/libexec/src/text/template/template.go`):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`Funcs`的样子（我的在`/usr/local/Cellar/go/1.9/libexec/src/text/template/template.go`中）：
- en: '[PRE84]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Notice that since `Func` is a method of `*Template` and returns a `*Template`,
    `Func` can be chained.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`Func`是`*Template`的一个方法并返回`*Template`，因此`Func`可以被链接。
- en: 'At the end of the range loop, we call our error message printing functions:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围循环结束时，我们调用我们的错误消息打印函数：
- en: '[PRE85]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output is as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE86]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The English translation file `4-purely-functional/ch10-monads/04_i18n/en-us.all.json`
    has the following content:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 英文翻译文件`4-purely-functional/ch10-monads/04_i18n/en-us.all.json`的内容如下：
- en: '[PRE87]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The German translation file `4-purely-functional/ch10-monads/04_i18n/de-de.all.json`
    has the following content:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 德文翻译文件`4-purely-functional/ch10-monads/04_i18n/de-de.all.json`的内容如下：
- en: '[PRE88]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: I used Google Translate. Just type sentences in your native language in the
    left pane (English) and select the language you want it translated to (German)
    in the right pane's drop-down.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了Google翻译。只需在左窗格（英语）中输入句子，并在右窗格的下拉菜单中选择要翻译的语言（德语）。
- en: 'We can use Google Translate to translate sentences into other languages:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Google翻译将句子翻译成其他语言：
- en: '![](img/a4c7f951-2355-458b-a0a5-73e2bfaf9a5c.png)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4c7f951-2355-458b-a0a5-73e2bfaf9a5c.png)'
- en: Assuming you are using the init script that is included in every Go project
    for this book, you should have the `get-go-binary` Bash function loaded in your
    shell and ready to use.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在为本书的每个Go项目中包含的init脚本，您应该在shell中加载并准备使用`get-go-binary` Bash函数。
- en: 'Here''s the workflow to initialize our project and install i18n:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是初始化项目和安装i18n的工作流程：
- en: '![](img/e3e8b6dc-67ae-4339-a7fd-f093289dd165.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3e8b6dc-67ae-4339-a7fd-f093289dd165.png)'
- en: The i18n site describes a workflow we can use if we are sending our files out
    to a translation service.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: i18n网站描述了我们可以使用的工作流程，如果我们要将我们的文件发送到翻译服务。
- en: Type classes
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型类
- en: Type classes allow us to define behavior on types.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类允许我们在类型上定义行为。
- en: As discussed in [Chapter 3](../Text/Ch03.xhtml), *Using High-Order Functions*,
    type classes add an additional layer to our type system.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](../Text/Ch03.xhtml)中所讨论的*使用高阶函数*，类型类为我们的类型系统增加了一个额外的层次。
- en: 'We accomplish this by:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式实现这一点：
- en: Defining behavior using Go interfaces (parent type class)
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Go接口定义行为（父类型类）
- en: Declaring a new type (base type class) to wrap base types
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新类型（基本类型类）来包装基本类型
- en: Implementing behavior on our new type classes
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新类型类上实现行为
- en: Let’s look at our `Equals` type class implementation.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的`Equals`类型类实现。
- en: 'Parent class definition:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 父类定义：
- en: '[PRE89]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Equals is our parent type class. All base classes must implement the `Equals`
    method.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: Equals是我们的父类型类。所有基类必须实现`Equals`方法。
- en: Base class definitions
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基类定义
- en: We'll define two base types, `Int` and `String`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义两个基本类型，`Int`和`String`。
- en: Int base class
  id: totrans-592
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Int基类
- en: 'The `Equals` method of Int will check whether other types are equal, using
    whatever logic we deem appropriate:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: Int的`Equals`方法将检查其他类型是否相等，使用我们认为合适的逻辑：
- en: '[PRE90]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: String base class
  id: totrans-595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: String基类
- en: 'It''s just like the `Int` class, but for strings:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Int`类一样，但是用于字符串：
- en: '[PRE91]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Our main.go file
  id: totrans-598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们的main.go文件
- en: 'We start by importing our typeclass code (located in the `src` directory, where
    we store all project-local packages):'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入我们的类型类代码（位于`src`目录中，我们在其中存储所有项目本地包）：
- en: '[PRE92]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output is as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE93]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Sum parent type class
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Sum父类型类
- en: 'Let’s create another type class to sum values:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个类型类来对值进行求和：
- en: '[PRE94]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Sum is our parent type class. All base type classes must implement the `Sum`
    method.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Sum是我们的父类型类。所有基本类型类必须实现`Sum`方法。
- en: Sum base classes
  id: totrans-607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Sum基类
- en: 'Here are our base classes:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的基类：
- en: '[PRE95]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We can see from our type definitions that we will be able to sum any two of
    these base types.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从我们的类型定义中看到，我们将能够对这些基本类型中的任意两个进行求和。
- en: 'Here’s the `Int32` implementation of `Sum`:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Int32`的`Sum`实现：
- en: '[PRE96]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Notice that we return zero if the value we are trying to add our `Int32` to
    is not in the accepted list of types.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们要将`Int32`添加到的值不在接受的类型列表中，则返回零。
- en: Another option would be to implement a result type, like Haskell’s Either type.
    This is a recent Golang specification addition which was rejected. For details,
    see [https://github.com/golang/go/issues/19991](https://github.com/golang/go/issues/19991).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是实现一个结果类型，就像Haskell的Either类型。这是一个最近被拒绝的Golang规范添加。详情请参见[https://github.com/golang/go/issues/19991](https://github.com/golang/go/issues/19991)。
- en: 'The Sum implementations for `Int64` and `Float64` are similar:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int64`和`Float64`的Sum实现类似：'
- en: '[PRE97]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In our implementation for int slices, we implement a range iteration for each
    type we wish to add to our slice of ints:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的int切片实现中，我们为我们希望添加到我们的int切片中的每种类型实现了一个范围迭代：
- en: '[PRE98]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Here, we exercise our `Sum` type classes:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们练习我们的`Sum`类型类：
- en: '[PRE99]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output is as follows:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE100]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Generics revisited
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型重访
- en: 'In the last chapter, we discussed some of the benefits of generics:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们讨论了一些通用的好处：
- en: Type safety
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全
- en: Eliminates the need to write repetitive, boilerplate code
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除了编写重复的样板代码的需要
- en: Reuses and shares code for different types
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同类型重用和共享代码
- en: Enforces consistent APIs across different types
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制在不同类型之间保持一致的API
- en: Time spent optimizing generic code has more impact
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化通用代码所花费的时间影响更大
- en: Don’t need to re-implement algorithms that are hard to get right
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要重新实现难以正确的算法
- en: Able to specify domain constraints
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够指定域约束
- en: 'Given the following type definitions:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下类型定义：
- en: '[PRE101]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Instead of writing both of these:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是写这两个：
- en: '[PRE102]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We can print the price sums as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式打印价格总和：
- en: '[PRE103]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If Go supported generics, we could write it once. It would look something like
    this:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go支持通用，我们可以只写一次。它会看起来像这样：
- en: '[PRE104]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can print the price sums as follows:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式打印价格总和：
- en: '[PRE105]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Covariance and contravariance ([https://www.ibm.com/developerworks/library/j-jtp01255/index.html](https://www.ibm.com/developerworks/library/j-jtp01255/index.html)) refers
    to the ability to use a less specific or more more specific type than originally
    specified. Covariant and contravariant generic type parameters provide greater
    flexibility when assigning and using generic types.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 协变和逆变（[https://www.ibm.com/developerworks/library/j-jtp01255/index.html](https://www.ibm.com/developerworks/library/j-jtp01255/index.html)）指的是使用比最初指定的更不具体或更具体的类型的能力。协变和逆变的通用类型参数在分配和使用通用类型时提供了更大的灵活性。
- en: Considering that example code, what's not to love about generics?
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到示例代码，通用代码有什么不好的地方？
- en: Go's fast compilation speed is partly due to incremental compilation. Incremental
    compilation is not possible with generics because the concrete type only knows
    where the generic function is used at runtime, not where it is defined.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: Go的快速编译速度部分原因是增量编译。增量编译对于通用代码是不可能的，因为具体类型只知道通用函数在运行时被使用的位置，而不知道它的定义位置。
- en: 'Not counting the fact that the implementation of generics into the Go compiler
    would be incredibly complex, in terms of both semantics and implementation, here
    are some of the disadvantages of adding generics to Go from a developer''s perspective:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 不计入将通用实现到Go编译器中将是非常复杂的，无论是从语义还是实现的角度来看，以下是从开发者角度考虑将通用添加到Go的一些缺点：
- en: Generic algorithms tend to accumulate features (affecting code quality).
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用算法往往会积累特性（影响代码质量）。
- en: It's difficult to optimize generic algorithms.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化通用算法很困难。
- en: It's difficult to debug generic code.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试通用代码很困难。
- en: Error handling complexities.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理的复杂性。
- en: 'Usage complexities: covariance, contravariance, erasure.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂性：协变、逆变、擦除。
- en: Slows down compile time (or runtime).
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减慢编译时间（或运行时间）。
- en: Generic/existing non-generic code incompatibilities.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用/现有非通用代码的不兼容性。
- en: The fourth and the seventh disadvantage and 7 are the most concerning.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 第四和第七个缺点是最令人担忧的。
- en: First, let’s better understand what is meant by error handling complexities.
    What about `Maybe`, `Either`, and `Option` solving the nil pointer errors?
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更好地理解错误处理的复杂性是什么意思。`Maybe`、`Either`和`Option`能解决空指针错误吗？
- en: In order for pure FP monadic error handling to work, all the packages referenced
    in our applications would need to return a monadic error type, like Either. (Either
    it succeeded or not, but nil would never be returned.)
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使纯FP单子错误处理起作用，我们应用中引用的所有包都需要返回一个单子错误类型，比如Either。（要么成功，要么失败，但不会返回nil。）
- en: 'Granted, that would eliminate the need for the the following ubiquitous error
    check:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这将消除对以下普遍错误检查的需要：
- en: '[PRE106]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: However, we would now need to change the way we handle errors, using new language
    extensions like `Maybe` monads, `Either`, `Option`, `Nothing`, `Just`, and so
    on. (For some code examples, see `2-design-patterns/ch04-solid/02_maybe`.) That’s
    another layer of complexity.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在我们需要改变处理错误的方式，使用新的语言扩展，比如`Maybe`单子、`Either`、`Option`、`Nothing`、`Just`等。（有关一些代码示例，请参见`2-design-patterns/ch04-solid/02_maybe`。）这是另一层复杂性。
- en: Furthermore, how would we integrate this new error handling paradigm into existing
    applications? If we were creating a new application, but wanted to use any standard
    library packages or any package that had not been converted to use generics-compatible
    error handling, would we write an adapt layer? That's another layer of complexity.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们如何将这种新的错误处理范式集成到现有应用中？如果我们正在创建一个新应用，但希望使用任何标准库包或任何尚未转换为使用通用兼容错误处理的包，我们会写一个适配层吗？这是另一层复杂性。
- en: The impact of going generic would be signification. What percentage of the Go
    Standard Library would need to change?
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 通用化的影响将是显著的。Go标准库中有多少百分比需要改变？
- en: Do we replace the ubiquitous slice with a collection type? How much existing
    code would be affected by that?
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否用集合类型替换普遍的切片？这会对现有代码产生多大影响？
- en: How would support for generics affect concurrency?
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 通用支持会如何影响并发？
- en: How would performance be impacted if go were to lose type erasure and implement
    reification in order to add explicit type annotations to generic arguments?
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go失去类型擦除并实现具体化以添加对通用参数的显式类型注释，性能会受到什么影响？
- en: Impact of Golang
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Golang的影响
- en: 'A minimal set of language constructs that would need modification includes:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 需要修改的最小语言构造集包括：
- en: Type assertions
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言
- en: Type switches
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型开关
- en: Range statements
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围语句
- en: Function calls
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数调用
- en: They are all deeply impactful, and the last one is deep and broad.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都具有深远的影响，最后一个影响深远而广泛。
- en: The entire type system will likely need an overhaul.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 整个类型系统可能需要彻底改变。
- en: Personal opinion
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 个人观点
- en: Before writing this book, I was of the opinion that the benefits of generics
    far outweighed its disadvantages. Writing this book forced me to really think
    about it.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这本书之前，我认为通用的好处远远超过了它的缺点。写这本书迫使我真正思考这个问题。
- en: I thought about the pros and cons as well as alternatives, such as using metaprogramming
    and code generation tools (see the clipperhouse/gen tool in the last chapter).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 我考虑了利弊以及替代方案，比如使用元编程和代码生成工具（见最后一章中的clipperhouse/gen工具）。
- en: I thought about how monadic error handling works and its similarities to Go’s
    `return successValue, err  error` handling idiom (as well as its similarities
    to the Unix `stdout` / `stderr`). I found a way to get the most significant feature
    from pure FP (Monads) to work in Go while maintaining Go’s error handling idiom.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 我考虑了Monad错误处理的工作原理，以及它与Go的`return successValue, err error`处理习惯（以及它与Unix的`stdout`/`stderr`相似之处）。我找到了一种方法，可以在Go中使用纯FP（Monad）的最重要特性，同时保持Go的错误处理习惯。
- en: 'The benefits of using The Lexical (Monadic) Workflow Solution in Go are:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用词法（Monad）工作流解决方案的好处是：
- en: Type-safe
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全
- en: No empty interfaces/unboxing/downcasting/reflection required
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要空接口/拆箱/向下转型/反射
- en: Expressive, easy-to-understand workflow code
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达力强，易于理解的工作流代码
- en: '`Get(data)` then `Next(step)`, `Next(step)` until done'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get(data)`然后`Next(step)`，直到完成'
- en: Mostly idiomatic error handling in one place (at the end)
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分成语化的错误处理都在一个地方（在最后）
- en: Directly mirrors business requirements
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接反映业务需求
- en: Allows us to compose new workflows easily using reusable components (see `toolbox.go`)
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们使用可重用组件轻松地组合新的工作流程（参见`toolbox.go`）
- en: Designed to be optimized for horizontal scaling
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计为水平扩展进行优化
- en: Does not impose any requirements on external packages
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不对外部包有任何要求
- en: Does not require additional Monadic error handling logic
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要额外的Monad错误处理逻辑
- en: Since this solution uses a lambda expression, there is recursion, and since
    Go currently does not provide TCO, there is a performance hit, but the recursion
    is limited to controlling the workflow.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个解决方案使用了lambda表达式，所以存在递归，而由于Go目前不提供尾递归优化，所以会有性能损失，但递归被限制在控制工作流程上。
- en: The burden is that I must manually create repetitive code or generate the generic
    code (using a tool like clipperhouse/gen) to avoid the performance penalty of
    using the empty `interface{}` and reflection.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 负担在于我必须手动创建重复的代码或生成通用代码（使用类似clipperhouse/gen的工具），以避免使用空的`interface{}`和反射的性能损失。
- en: I concluded that generics are a trade-off between compilation time, runtime,
    and my time. Given the risk and the list of disadvantages of adding generics to
    Go, I’m okay with doing a little more work.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我得出结论，泛型是编译时间、运行时间和我的时间之间的权衡。考虑到向Go添加泛型的风险和劣势，我可以多做一些工作。
- en: '"Simplicity and elegance are unpopular because they require hard work and discipline
    to achieve and education to be appreciated."'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: “简单和优雅不受欢迎，因为它们需要努力和纪律才能实现，并且需要教育才能被欣赏。”
- en: '- Edsger Dijkstra'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '- Edsger Dijkstra'
- en: Summary
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Function programming in Go is a paradigm shift, a fundamentally different approach
    to the way we write software. Just like we can get the results we want with an
    imperative Turing Machine or with Lambda Calculus, we can choose to code imperatively
    with idiomatic Go or declaratively using the FP style of programming.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中进行函数式编程是一种范式转变，是一种根本不同的编写软件的方式。就像我们可以用命令式的图灵机或者Lambda演算来得到我们想要的结果一样，我们可以选择用Go的惯用方式命令式编码，也可以选择使用FP编程风格声明式编码。
- en: We began our journey with a light introduction to FP. We learned how to write
    intermediate functions like `Map`, `Filter`, and `Sort`, as well as terminal functions
    like `Reduce` and `Join`, to transform collections. We saw how to use tools like
    Gleam and Itertool and implemented lazy evaluation using Go routines and a Go
    channel.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从轻松的FP简介开始我们的旅程。我们学会了如何编写像`Map`、`Filter`和`Sort`这样的中间函数，以及像`Reduce`和`Join`这样的终端函数，来转换集合。我们看到了如何使用Gleam和Itertool等工具，并使用Go例程和Go通道实现了惰性评估。
- en: We thought about the characteristics of FP and worked through examples of function
    composition, closures, and high order functions.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们思考了FP的特点，并通过函数组合、闭包和高阶函数的示例进行了实践。
- en: 'We studied both the imperative-functional and pure-functional styles of software
    design (and later mixed both styles). We learned how the Reader/Writer interface
    in Go implements the single responsibility principle. Just one whiff of OOP gave
    us an appreciation for the simplicity (and honesty) of pure FP. (FP contracts
    don''t lie.)  The secret to function composition was revealed to us: Monads chain
    continuations.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了软件设计的命令式功能和纯功能风格（后来混合了这两种风格）。我们学会了Go中的Reader/Writer接口如何实现单一责任原则。面向对象编程让我们对纯FP的简单（和诚实）有了欣赏。（FP合同不会撒谎。）我们揭示了函数组合的秘密：Monad链式延续。
- en: We learned how `Map` and `Reduce` work. As the constant flow of diagrams began
    to heighten our awareness of the value of FP, we were tossed back to the world
    of imperative programming using functions.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了`Map`和`Reduce`的工作原理。随着不断涌现的图表增强了我们对FP价值的认识，我们被抛回到了使用函数的命令式编程世界。
- en: Duck typing, embedding, the decorator, strategy, and pipeline patterns, inversion
    of control, dependency injection, the use of channels to control the flow of events
    in a concurrent program... we even learned how to avoid circular dependencies
    using a layered application architecture. We learned the difference between currying
    and partial application and how to implement functional parameters to improve
    our APIs.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型、嵌入、装饰器、策略和管道模式、控制反转、依赖注入、使用通道控制并发程序中事件流的方法……我们甚至学会了如何使用分层应用架构避免循环依赖。我们学会了柯里化和部分应用之间的区别，以及如何实现函数参数来改进我们的API。
- en: 'Category theory was presented in a way never seen before: using over 100 images,
    17 tables of information, and code samples, along with simple and concise wording.
    We led you through the history of functional programming and learned the deep
    connection between category theory, logic, and type theory. We learned that the
    math we learned in grade school, middle school, and high school is applicable
    to functional programming. (Maybe that even inspired someone to send their old
    math teacher a note of appreciation?)'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论以前所未见的方式呈现：使用了100多张图片，17张信息表和代码示例，以及简洁明了的文字。我们带领你了解了函数式编程的历史，并学习了范畴论、逻辑和类型理论之间的深刻联系。我们了解到我们在小学、初中和高中学到的数学是适用于函数式编程的。（也许这甚至激励了某人给他们的老数学老师写一封感谢信？）
- en: With a solid understanding of category theory, we embarked on a pure FP journey
    where we learned how to map between worlds using functors. We built a few monoids
    and learned how to write a reduce function. We also learned how to use a generics
    code generation tool to solve the boilerplate problem.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在对范畴论有了扎实的理解之后，我们踏上了纯函数式编程的旅程，学习了如何使用函子在不同世界之间进行映射。我们构建了一些幺半群，并学会了如何编写一个 reduce
    函数。我们还学会了如何使用泛型代码生成工具来解决样板问题。
- en: Armed with the knowledge of pure and imperative functional programming, we dove
    into the world of Monads. We learned about Lambda Calculus and how the Y-Combinator
    works, and how to use it to control workflow.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借对纯函数式和命令式函数式编程的知识，我们深入了解了单子的世界。我们学习了关于 Lambda 演算以及 Y-组合子的工作原理，以及如何使用它来控制工作流。
- en: We implemented the Lexical Workflow Solution that leveraged the Y-Combinator
    to control a sequence of impure operations. We witnessed our data as it was transformed
    from one step to the next. We saw how the `Success` and `Failure` pipes work and
    how we could handle all errors at the end of the pipeline using the idiomatic
    Go techniques. We gained a much better understanding of the pros and cons of adding
    generics to Go.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了词法工作流解决方案，利用 Y-组合子来控制一系列不纯操作。我们目睹了我们的数据在一步步转换的过程中。我们看到了`Success`和`Failure`管道的工作原理，以及如何使用惯用的
    Go 技术在管道的末尾处理所有错误。我们对向 Go 添加泛型的利弊有了更好的理解。
- en: Where to go from here
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从这里去哪里
- en: 'Here are some ideas:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些想法：
- en: Look for places to use the Lexical Workflow Solution to control data transformation
    workflows
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找使用词法工作流解决方案来控制数据转换工作流的地方
- en: Build a reusable set of components, to put in your toolbox, that you can use
    in our workflows
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个可重复使用的组件集，放入你的工具箱，可以在我们的工作流中使用
- en: Build your own type classes, monads and pure FP components in Go
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中构建你自己的类型类、单子和纯函数式组件
- en: Support the request to add TCO to Go (see the [Appendix](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=7&action=edit),
    *Miscellaneous Information and How-To's*)
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持添加 TCO 到 Go 的请求（请参阅[附录](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=7&action=edit)，*其他信息和操作指南*）
- en: I hope the information you found in this book is useful for what you're building
    both today and tomorrow and that it inspires you to continue to improve upon these
    ideas so that we can all build even better applications going forward.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在这本书中找到的信息对你今天和明天构建的东西有用，并且它能激励你继续改进这些想法，以便我们都能不断构建更好的应用程序。
- en: '"Talk is cheap. Show me the code."'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: “言而无信，不如实际行动。”
- en: - Linus Torvalds
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '- Linus Torvalds'
