- en: Category Theory That Applies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用的范畴论
- en: In kindergarten, we learned how to read time. In advanced math, we learned how
    to abstract a 12-hour clock and called it a monad.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在幼儿园，我们学会了如何读时间。在高级数学中，我们学会了如何抽象一个12小时的时钟，并称之为单子。
- en: '![](img/86296f8a-78f5-4e16-aabe-f0677b0aa00e.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86296f8a-78f5-4e16-aabe-f0677b0aa00e.png)'
- en: In elementary school, we learned geometry, logical reasoning, and functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在小学，我们学习了几何、逻辑推理和函数。
- en: In high school, we learned algebra, linear, and quadratic equations. We were
    so busy going through the motions deep in the minutiae of our problems that we
    could see no use for any of it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在高中，我们学习了代数、线性和二次方程。我们忙于按部就班地解决问题的细枝末节，以至于看不出任何用处。
- en: Check out the learning material used in K-12 education here: [https://www.ixl.com/math/kindergarten/match-analog-clocks-and-times](https://www.ixl.com/math/kindergarten/match-analog-clocks-and-times).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里查看K-12教育中使用的学习材料：[https://www.ixl.com/math/kindergarten/match-analog-clocks-and-times](https://www.ixl.com/math/kindergarten/match-analog-clocks-and-times)。
- en: Fast forward to our day job. To appear smart, we often ask, *Will it scale?* No
    matter what *it* is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到我们的日常工作。为了显得聪明，我们经常问，“它会扩展吗？”无论*它*是什么。
- en: Wondering how reading time and horizontal scaling are related? They are, deeply.
    We'll find out how in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道阅读时间和水平缩放有什么关系吗？它们之间有深刻的联系。我们将在本章中找出答案。
- en: 'Our goal in this chapter is to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的目标是做到以下几点：
- en: Gain a working understanding of the category theory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握范畴论的工作原理
- en: Appreciate the deep connection between category theory, logic, and type theory
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏范畴论、逻辑和类型理论之间的深刻联系
- en: Understand what binding, currying and application means in the context of a
    lambda expression
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在lambda表达式的上下文中绑定、柯里化和应用的含义
- en: Understand the different categories of homomorphisms and how to use them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解同态的不同类别以及如何使用它们
- en: Learn to use composition techniques from category theory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会从范畴论中使用组合技术
- en: Understand what interface-driven development is about
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解接口驱动开发的含义
- en: See the value of knowledge driven systems
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到知识驱动系统的价值
- en: Apply our understanding of category theory to build better apps
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用我们对范畴论的理解来构建更好的应用程序
- en: Our goal
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的目标
- en: By the end of this chapter, we will see value in those math classes we took
    back in school. We'll understand how the things we learned in our high school
    math classes can be applied when horizontally scaling our software solutions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将看到我们在学校上学的数学课的价值。我们将了解到我们在高中数学课上学到的东西在水平扩展我们的软件解决方案时是如何应用的。
- en: 'The following diagram implies that **Category Theory**, functional programming,
    and logic are equivalent:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表暗示了**范畴论**、函数式编程和逻辑是等价的：
- en: '![](img/af0d7bae-4b90-4710-889d-4c9219795ef4.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af0d7bae-4b90-4710-889d-4c9219795ef4.png)'
- en: Huh?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯？
- en: I thought Category Theory was about a sets of objects and the arrows that connect
    them and that *Proof Theory* was about using logic to prove something. And we
    all know that function programming is about software. How can all three things
    be related?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我以为范畴论是关于一组对象和连接它们的箭头，而*证明论*是关于使用逻辑来证明某事。我们都知道函数式编程是关于软件的。这三件事怎么可能相关？
- en: This seems about as useful as all those math classes we had to take in school,
    right?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎和我们在学校上的所有那些数学课一样有用，对吧？
- en: Your pessimism is understandable. Please proceed with an open mind and remain
    seated. Mathematics, logic, and computation. They are just three different ways
    to approach solving the same problems.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你的悲观是可以理解的。请以开放的心态继续并保持坐姿。数学、逻辑和计算。它们只是解决同样问题的三种不同方式。
- en: How can Category Theory, Proof Theory, and functional programming be the same
    thing? (and why care?)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论、证明论和函数式编程如何是一回事？（以及为什么要关心？）
- en: '"Scientists derive satisfaction from figuring out the puzzle. It''s about the
    quest, not the grail."'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “科学家从解决难题中获得满足感。这是关于探索，而不是圣杯。”
- en: -Isaac Asimov
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: -艾萨克·阿西莫夫
- en: Break it down
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解它
- en: 'Let''s break each part down to get a firm grasp of the breadth of our problem:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解每个部分，以便更好地掌握我们问题的广度：
- en: '![](img/9dada6bb-5c8a-4b7f-b0ef-ef890939c86f.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dada6bb-5c8a-4b7f-b0ef-ef890939c86f.png)'
- en: If the **WHY** is the motivation for building your application, then the **HOW**
    describes how our application is better, and the **WHAT** is our end product/application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**为什么**是构建应用程序的动机，那么**如何**描述了我们的应用程序如何更好，而**什么**是我们的最终产品/应用程序。
- en: The **HOW** relates to how we, as humans, reason. This is the realm of the Category
    Theory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何**与我们作为人类的推理方式有关。这是范畴论的领域。'
- en: The **WHAT** pertains to the specifics of what it is. This is the realm of mathematics
    and computation. We will use algebra to help define the **WHAT**. Later, we'll
    see that our work in algebra is directly transferable to functional programming.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么**涉及到它是什么。这是数学和计算的领域。我们将使用代数来帮助定义**什么**。后来，我们会看到我们在代数中的工作直接可转移到函数式编程。'
- en: Algebra and the unknown
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代数和未知数
- en: 'Algebra is a branch of mathematics that is very similar to arithmetic. It uses
    the four main operations that math uses: addition, subtraction, multiplication,
    and division (+, -, /, *). Algebra also introduces a new element: the unknown.
    In math, the unknown is on the right-hand side of the equation. Remember math
    problems like *2 + 3*. The answer is unknown until we perform the math operation
    on the operands (2 and 3). In algebra, we use symbols in place of the unknown
    placeholder. An algebraic equation would be *2 + 3 = x*. That is an algebraic
    equation that states both sides of the equals sign are equivalent. The operands 2
    and 3 operands are known and the *x* is the unknown.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代数是数学的一个分支，与算术非常相似。它使用数学的四个主要运算：加法、减法、乘法和除法（+，-，/，*）。代数还引入了一个新元素：未知数。在数学中，未知数在等式的右侧。记得数学问题，比如*2
    + 3*。在我们对操作数（2和3）进行数学运算之前，答案是未知的。在代数中，我们使用符号代替未知的占位符。一个代数方程将是*2 + 3 = x*。这是一个代数方程，说明等号两边是等价的。操作数2和3是已知的，而*x*是未知的。
- en: '![](img/832a593d-233b-49aa-8b4b-ee260b887556.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/832a593d-233b-49aa-8b4b-ee260b887556.png)'
- en: 'The goal in algebra is to solve the equation by determining the value(s) of
    the unknown symbol(s):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代数的目标是通过确定未知符号的值来解决方程：
- en: '![](img/7fc1bd2c-f58e-43ab-bd01-cc5dbaa57828.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fc1bd2c-f58e-43ab-bd01-cc5dbaa57828.png)'
- en: Remember what our math teachers would do next?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的数学老师接下来会做什么吗？
- en: '![](img/ab780b7e-3e27-4043-9a82-0c8e985c3bdf.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab780b7e-3e27-4043-9a82-0c8e985c3bdf.png)'
- en: 'They would swap the symbol and a number to make the problem more difficult
    for us to figure out! Then, they would give us more and more complicated equations
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 他们会交换符号和数字，让问题对我们更加困难！然后，他们会给我们更多更复杂的方程，就像这样：
- en: '![](img/9d52b32c-b8c4-428b-9dd9-f5f20cd4b934.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d52b32c-b8c4-428b-9dd9-f5f20cd4b934.png)'
- en: 'They forced us to perform multiple steps to simplify our problem. Since both
    sides must remain equal, we can visualize the problem using a weight balance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 他们强迫我们执行多个步骤来简化我们的问题。由于两边必须保持相等，我们可以使用一个天平来可视化问题：
- en: '![](img/effb217a-e403-47d7-bd83-928d602a7c3c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/effb217a-e403-47d7-bd83-928d602a7c3c.png)'
- en: 'How did we solve the more complicated problem? Answer: By chopping it up into
    smaller pieces that are easier to work with, as shown in the following figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是如何解决更复杂的问题的？答案：通过将其分解成更容易处理的小部分，如下图所示：
- en: '![](img/7d8cd9ab-ed00-46ca-8f9f-7b394b90c310.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d8cd9ab-ed00-46ca-8f9f-7b394b90c310.png)'
- en: 'Algebra, not unlike in the real world, relies on rules for things to work properly.
    Here are the few rules:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代数，不像在现实世界中，依赖于规则才能正常工作。以下是一些规则：
- en: '**Rule 1:** The variable *x* in an algebraic equation cannot represent two
    different values in the same equation at the same time'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1：** 代数方程中的变量*x*不能在同一时间的同一个方程中代表两个不同的值'
- en: 'For example, if we have the equation, *x + x = 6*, the following is true: 1
    + 5 = 6; However, since *x* cannot represent the two different values in the same
    equation, the only value that would work for *x* is 3 (using 1 and 5 for x would
    violate *Rule 1*).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有方程*x + x = 6*，那么以下是正确的：1 + 5 = 6；然而，由于*x*不能在同一个方程中代表两个不同的值，唯一适用于*x*的值是3（使用1和5作为*x*会违反*规则1*）。
- en: '**Rule 2:** If we want two variables to represent two different values, we
    must use two different symbols. For example, *x + y = 6.*'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2：** 如果我们希望两个变量代表两个不同的值，我们必须使用两个不同的符号。例如，*x + y = 6*。'
- en: '**Rule 3:** When the same variable symbol is used multiple times in the same
    equation, it represents the same value.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则3：** 当同一个变量符号在同一个方程中多次使用时，它代表相同的值。'
- en: '**Rule 4:** The default operation is multiplication. 2 * x is the same as 2x.
    So, if there is no operator, we can assume we are dealing with the default operation,
    multiplication.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则4：** 默认操作是乘法。2 * x等同于2x。因此，如果没有运算符，我们可以假设我们正在处理默认操作，即乘法。'
- en: '**Rule 5:** Parenthesis can be used to group terms. If we see 3(2), that is
    the same as 3 * (2) which is the same as 3*2\. All three groupings of terms are
    equal to 6 (not 32).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则5：** 括号可以用来分组项。如果我们看到3(2)，那就等同于3*(2)，也等同于3*2。所有三组项的结果都等于6（而不是32）。'
- en: '![](img/83e4b940-d0b1-4bec-bc59-af5c0c5a5bc4.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83e4b940-d0b1-4bec-bc59-af5c0c5a5bc4.png)'
- en: 'Our job now is to break this problem down into smaller steps and figure out
    what the value of *x* is. (Hint: you''ve seen it before.)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的工作是将这个问题分解成更小的步骤，并找出*x*的值是多少。（提示：你以前见过它。）
- en: '**Rule 6:** Different symbols can represent the same value in the same equation,
    but they don''t have to.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则6：** 不同的符号可以在同一个方程中代表相同的值，但不一定要这样。'
- en: As we saw, *x* and *y* have the same value, but only in the second if statement.
    As the value of *x* varies (from 0 to 1 to 2), the value of y varies (from **2**
    to **1** to **0**). That's the main reason why the symbols *x* and *y* are called
    **variables**. They can vary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，*x*和*y*有相同的值，但只在第二个if语句中。随着*x*的值变化（从0到1到2），*y*的值也会变化（从2到1到0）。这就是为什么符号*x*和*y*被称为**变量**的主要原因。它们可以变化。
- en: The way variables are handled in a Turing-based language as opposed to a Lambda
    calculus (pure functional programming) language is very different.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在图灵语言中处理变量的方式与Lambda演算（纯函数式编程）语言非常不同。
- en: 'In a Turing-based language like C, the value of a variable *x* is stored in
    a specific location in the memory in the computer running the C program. It can
    be a global variable, which means other running procedures can access and change
    (aka *mutate*) its value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在像C这样的图灵语言中，变量*x*的值存储在运行C程序的计算机内存中的特定位置。它可以是全局变量，这意味着其他运行的程序可以访问和改变（也称为*变异*）它的值：
- en: '![](img/03ec9444-a409-4ed5-aeb5-28754a909503.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03ec9444-a409-4ed5-aeb5-28754a909503.png)'
- en: In a pure functional language like Haskell, values are never stored. New ones
    can be created and passed along the execution chain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Haskell这样的纯函数语言中，值永远不会被存储。新值可以被创建并传递到执行链中。
- en: Real-world application of algebra
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代数的现实应用
- en: Ever wondered what good are these equations?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经想过这些方程有什么好处吗？
- en: They can be useful when trying to model things in the real world. Let's take
    some algebraic equations and graph their solutions. Graphing an equation is like
    using the results of equations (output of functions) to draw lines and curves
    that can be used to illustrate and/or predict things in real life.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在试图模拟现实世界中的事物时，它们可能是有用的。让我们来看一些代数方程并绘制它们的解。绘制方程就像使用方程的结果（函数的输出）来绘制可以用于说明和/或预测现实生活中事物的线条和曲线。
- en: Linear equation and the law of demand
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线性方程和需求定律
- en: 'Linear equations can be used to describe things with straight line slopes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程可以用来描述具有直线斜率的事物：
- en: '![](img/5508511d-bf5e-466d-8bd9-415f0cd5db81.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5508511d-bf5e-466d-8bd9-415f0cd5db81.png)'
- en: The law of demand states that as the price of a product increases, the demand
    for that product will decrease. That's because people naturally avoid buying a
    product that will force them to forfeit the purchase of something else that they
    value more. The graph indicates that the demand curve is a downward slope. The
    lower the price, the more products will be sold.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 需求定律规定，产品价格上涨时，对该产品的需求将减少。这是因为人们自然而然地避免购买会迫使他们放弃更重要的东西的产品。图表表明需求曲线是向下倾斜的。价格越低，销售的产品就越多。
- en: Building architects use linear equations to determine slopes of roof lines and
    Google Maps uses linear equations to tell you how long your trip will take.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑师使用线性方程确定屋顶线的斜率，谷歌地图使用线性方程告诉你旅行需要多长时间。
- en: What do we know about linear equation functions like *f(x) = 3x + 2*?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对于像*f(x) = 3x + 2*这样的线性方程函数了解多少？
- en: For every input *x*, we get one and only one result. That's why if we were to
    input every possible number (as the value *x*), we get a line! And that's why
    vertical lines are difficult to achieve in geometry.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输入*x*，我们只得到一个结果。这就是为什么如果我们输入每个可能的数字（作为值*x*），我们得到一条线！这就是为什么在几何中很难实现垂直线的原因。
- en: Quadratic equations all around us
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们周围到处都是二次方程
- en: 'Equations like the following are said to be linear:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 像以下这样的方程被称为线性方程：
- en: '*y = x + 2*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = x + 2*'
- en: This is because all the variables are to the power of one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为所有变量的幂都是1。
- en: 'Given the **x** values of -**4** to **2**, we can easily calculate the **y**
    values, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 给定**x**值为-**4**到**2**，我们可以轻松计算**y**值，如下所示：
- en: '![](img/1fca5de4-c1d2-41c0-9cf3-2e27fa08b086.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fca5de4-c1d2-41c0-9cf3-2e27fa08b086.png)'
- en: If we were to input every possible *x* value (including those with decimals
    like 0.1, 0.11, 0.12, and so on), we'd get a straight line. We can say that the
    *domain* is the set of all possible *x* values and the *range* is the set of all
    possible *y* values. Note that any non-vertical or non-horizontal line is a function
    with its domain and range consisting of all real numbers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入每个可能的*x*值（包括小数，如0.1、0.11、0.12等），我们会得到一条直线。我们可以说*定义域*是所有可能的*x*值的集合，*值域*是所有可能的*y*值的集合。请注意，任何非垂直或非水平线都是一个定义域和值域都包含所有实数的函数。
- en: It's easy to see that our preceding *f(x)* function is just a mapping from one
    set of numbers to another.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出我们之前的*f(x)*函数只是从一组数字到另一组数字的映射。
- en: 'When we use exponents of 2 or greater, then the equation is said to be quadratic.
    Here''s an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用大于2的指数时，方程被称为二次方程。这里有一个例子：
- en: '*y = x² + 1*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = x² + 1*'
- en: Function composition with linear and quadratic functions
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线性和二次函数的函数组合
- en: 'Let''s compose our *f(x) = x² + 1* quadratic equation with our *g(x) = x +
    2* linear equation table. Here''s one way we could compose our two functions:
    *y = f(g(x))*. We''d say *y* equals *f-compose-g of x* or *y = f o g* where o
    is our composition operator. The way it works is that we assign a value for *x*,
    then we plug that value into *g*, compute g(x), and then plug the result into *f*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的 *f(x) = x² + 1* 二次方程与我们的 *g(x) = x + 2* 线性方程表进行组合。我们可以通过以下方式组合我们的两个函数：*y
    = f(g(x))*。我们会说*y*等于*f-compose-g of x*或*y = f o g*，其中o是我们的组合运算符。它的工作原理是我们为*x*分配一个值，然后我们将该值代入*g*，计算g(x)，然后将结果代入*f*。
- en: We input **1** to **g** and to express that as **g(1)**. We input **g(1)** to
    **f** to get **f(g(1))**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将**1**输入到**g**，并将其表示为**g(1)**。我们将**g(1)**输入到**f**，得到**f(g(1))**。
- en: '![](img/00f1ce17-a629-47a5-a085-4bc46f044c95.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00f1ce17-a629-47a5-a085-4bc46f044c95.png)'
- en: 'Let''s make it work by replacing **g(1)** with the value that maps from **1**
    to **g(1)**, which is **3**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过用从**1**到**g(1)**映射的值**3**替换**g(1)**来使其工作：
- en: '![](img/a84f18c7-5685-4f50-8cee-720ba4604019.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a84f18c7-5685-4f50-8cee-720ba4604019.png)'
- en: 'Replacing **g(1)** with **3**, we get the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 用**3**替换**g(1)**，我们得到以下结果：
- en: '![](img/6c096205-a9a5-43b9-afdf-37f1daa1a590.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c096205-a9a5-43b9-afdf-37f1daa1a590.png)'
- en: 'When we input **3** to **g**, we evaluate the **x² + 1** or **3² + 1** expression, which
    equals **10**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将**3**输入到**g**时，我们评估*x² + 1*或*3² + 1*表达式，结果等于**10**：
- en: '![](img/be540442-e169-48c7-b312-7bca9d8d5953.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be540442-e169-48c7-b312-7bca9d8d5953.png)'
- en: So, **f(g(1))** equals **10**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，*f(g(1))* 等于 **10**。
- en: What if we reverse our nesting of functions like **g(f(1))**? Will we get the
    same answer?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们颠倒函数的嵌套，比如**g(f(1))**，我们会得到相同的答案吗？
- en: '*f(1) = x2 + 1 = 1 + 1 = 2*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*f(1) = x2 + 1 = 1 + 1 = 2*'
- en: '*g(2) = 4*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*g(2) = 4*'
- en: We got *f(2)=4* from the preceding linear equation table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面的线性方程表中得到了*f(2)=4*。
- en: Since *g(f(1)) = 10* and *f(g(1)) = 4*, we know that composing the same functions
    in a different order will likely give different results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*g(f(1)) = 10*和*f(g(1)) = 4*，我们知道以不同顺序组合相同的函数可能会得到不同的结果。
- en: We also see that when we compose, we are either replacing a function/value with
    the corresponding/mapped value from a table or we are evaluating a function expression
    and replacing with that value. We've already seen how the referential integrity
    characteristic of our functions allow us to cache its value. So, after a function
    is evaluated the first time, all we're doing is a bunch of value replacements
    when we compose functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，当我们组合时，我们要么用表中对应/映射的值替换函数/值，要么评估函数表达式并用该值替换。我们已经看到我们函数的引用完整性特征允许我们缓存其值。因此，当函数第一次被评估后，当我们组合函数时，我们所做的就是一堆值替换。
- en: '"If A equals success, then the formula is A equals X plus Y and Z, with X being
    work, Y play, and Z keeping your mouth shut."'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"如果A等于成功，那么公式就是A等于X加Y和Z，其中X是工作，Y是玩耍，Z是保持嘴巴闭上。"'
- en: '- Albert Einstein'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '- 阿尔伯特·爱因斯坦'
- en: More examples of quadratic equations
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多二次方程的例子
- en: Are all of the following quadratic?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有都是二次的吗？
- en: '![](img/66fbf895-5ff8-41a3-b18a-1d83b930306f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66fbf895-5ff8-41a3-b18a-1d83b930306f.png)'
- en: Plot your own equations online at: [https://www.desmos.com/calculator](https://www.desmos.com/calculator)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://www.desmos.com/calculator](https://www.desmos.com/calculator)上在线绘制你自己的方程
- en: The golden ratio
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 黄金比例
- en: Let's look at one more fascinating quadratic equation. The Greeks believed that
    the rectangular shape, which had the most aesthetic proportions, was one where
    the large and the small rectangles have the same proportions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个迷人的二次方程。希腊人认为，具有最美的比例的矩形形状是大矩形和小矩形具有相同比例的形状。
- en: This became known as the *golden rectangle*. The solution to *x² + x = 1* is
    *x = 1.61803398875*, which we'll shorten to *x = 1.61.*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*黄金矩形*。方程*x² + x = 1*的解为*x = 1.61803398875*，我们将其缩写为*x = 1.61*。
- en: The Greeks weren't the only ones that thought the golden ratio was perfect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 希腊人并不是唯一认为黄金比例是完美的人。
- en: '![](img/9298c91f-2a10-4957-9b8b-ecf7446368d5.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9298c91f-2a10-4957-9b8b-ecf7446368d5.png)'
- en: 'When we look closely, we''ll see the Golden Ratio in business:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仔细观察时，我们会在商业中看到黄金比例：
- en: '![](img/451ac9b7-560d-4ad7-90c0-5b7e4e9f2a1f.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/451ac9b7-560d-4ad7-90c0-5b7e4e9f2a1f.png)'
- en: Remember the Fibonacci sequence and its relationship to recursion from [Chapter
    1](../Text/Ch01.xhtml), *Pure Functional Programming in Go*? `0, 1, 1, 2, 3, 5,
    8, 13, 21, 34, 55, 89`. In this sequence, each term is the sum of the previous
    two terms. If we look closely, we'll see this sequence in nature. For example,
    lilies have 3 petals, buttercups 5, marigolds 13, asters 21\. Most daisies have
    34, 55 or 89 petals.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得斐波那契数列及其与[第1章](../Text/Ch01.xhtml)中递归的关系吗？`0, 1, 1, 2, 3, 5, 8, 13, 21, 34,
    55, 89`。在这个序列中，每一项都是前两项的和。如果我们仔细观察，我们会在自然界中看到这个序列。例如，百合有3片花瓣，毛茛有5片，万寿菊有13片，紫苑有21片。大多数雏菊有34、55或89片花瓣。
- en: '![](img/391e2289-10cb-4ff3-8f73-fb0f05fdda2f.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/391e2289-10cb-4ff3-8f73-fb0f05fdda2f.png)'
- en: The seeds of a sunflower head radiate from its center in two families of interlaced
    spirals, one winding clockwise and the other counterclockwise. There are usually
    34 spirals twisting clockwise and 55 in the opposite direction.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 向日葵头部的种子从中心向外辐射，分为两组交织的螺旋，一组顺时针旋转，另一组逆时针旋转。通常有34条顺时针螺旋和55条逆时针螺旋。
- en: The more we learn about the relationship between mathematics, programming, the
    arts and sciences and nature, the more evidence we find of the hand of a master
    architect at work around us.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越了解数学、编程、艺术和科学之间的关系，越能找到我们周围工作的大师建筑师的证据。
- en: The more we understand how systems around us work, the more patterns we see.
    Later, when we look closer at the category theory, we'll study the important patterns
    of decomposition (chopping problems up into small, comprehensible pieces) and
    composition (putting those pieces back together again). FP allows us to break
    a monolithic application down into a set of Lego building blocks that can be assembled
    in different configurations for different systems if desired, and we do can do
    so in an easy-to-understand, declarative manner.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越了解我们周围系统的工作方式，我们就会看到越多的模式。稍后，当我们更仔细地研究范畴论时，我们将学习分解（将问题分解成小而可理解的部分）和组合（将这些部分重新组合）的重要模式。FP允许我们将一个整体应用程序分解为一组可以根据需要以不同配置组装的乐高积木，并且我们可以以易于理解的声明方式进行操作。
- en: Given the guarantees of immutability and referential transparency, the time
    at which an operation occurs is much less of a concern. This simplifies the combinatorial
    complexity of coding concurrent solutions. This also allows performance to be
    improved harmlessly by the use of parallelism, and it pays off in distributed
    systems, where time is not even perfectly defined.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到不可变性和引用透明性的保证，操作发生的时间就不那么重要了。这简化了编写并发解决方案的组合复杂性。这也允许通过并行性无害地提高性能，并且在时间甚至没有完全定义的分布式系统中也是如此。
- en: Basic laws of algebra
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代数的基本定律
- en: Study these basic laws of algebra. We'll see them again soon!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这些代数的基本定律。我们很快会再次看到它们！
- en: '![](img/03501ee4-0d7b-44ab-bd08-e79ffdc1527c.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03501ee4-0d7b-44ab-bd08-e79ffdc1527c.png)'
- en: 'Later, you''ll learn that function composition has the following features:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，您将了解到函数组合具有以下特点：
- en: It is associative
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是结合的
- en: It is typically not commutative
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不是可交换的
- en: It is distributive via *(g+h) ∘ f = g ∘ f+h ∘ f (g + h) ∘ f = g ∘ f + h ∘ f*
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过*(g+h) ∘ f = g ∘ f+h ∘ f (g + h) ∘ f = g ∘ f + h ∘ f*进行分配
- en: It is typically not distributive via *f ∘ (g + h) = f ∘ g + f ∘ h*
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不是通过*f ∘ (g + h) = f ∘ g + f ∘ h*进行分配
- en: Correspondence in mathematics
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学中的对应关系
- en: The category theory presents mathematics as abstractly as possible and removes
    all nonessential properties, providing a framework for all mathematics.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论尽可能抽象地呈现数学，并去除所有非必要的属性，为所有数学提供了一个框架。
- en: 'Remember your math classes? Here are a few of the classes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得你的数学课吗？以下是一些课程：
- en: '| Branch of mathematics | Description |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 数学分支 | 描述 |'
- en: '| Algebra | Algebra describes relationships between its elements using laws,
    for example, associative, commutative properties. There are different types of
    algebra, such as, linear, lie, commutative, and abstract. In algebra, we often
    replace numbers with letters in an equation. For example,The *1 + 2 = 3* form
    becomes *x + y = z*. Boolean algebra is another type of algebra in which the variables
    are truth values (true and false) instead of numbers. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 代数 | 代数使用定律描述其元素之间的关系，例如，结合性、交换性质。代数有不同类型，如线性、李、交换和抽象。在代数中，我们经常用字母替换方程中的数字。例如，*1
    + 2 = 3*的形式变成了*x + y = z*。布尔代数是代数的另一种类型，其中变量是真值（真和假），而不是数字。|'
- en: '| Geometry | Geometry studies the properties of shapes and position in space.
    It provides formulas for determining things such as the circumference of a circle
    (*c = 2πr*) and determining the area of various shapes. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 几何 | 几何研究空间中形状和位置的属性。它提供了用于确定诸如圆的周长(*c = 2πr*)和确定各种形状的面积的公式。|'
- en: '| Logic | Logic provides rules of mathematical reasoning. Boolean algebra is
    a form of mathematical logic. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | 逻辑提供数学推理的规则。布尔代数是数学逻辑的一种形式。|'
- en: '| Numerical analysis | Numerical analysis provides algorithms to approximate
    solutions to mathematical problems. It typically uses computing power to quickly
    get close to the true solution that might not be solvable manually. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 数值分析 | 数值分析提供了用于近似解决数学问题的算法。它通常利用计算能力快速接近可能无法手动解决的真实解决方案。 |'
- en: '| Calculus | Calculus is the application of the results proven in analysis.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 微积分 | 微积分是对分析中证明的结果的应用。 |'
- en: 'Mathematics is the study of data structures: shapes, numbers, groups, sets,
    and so on. We study their structure, their behaviors, and how they interact with
    each other.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数学是数据结构的研究：形状、数字、群、集合等等。我们研究它们的结构、行为以及它们如何相互作用。
- en: Curry, Howard, and Lambek discovered that all branches of mathematics are the
    exact same thing! They realized that at a certain level of abstraction, the structure
    of all mathematical theories are the same. We can morph the structure of our logic
    into category classes and we can change that structure into type theory. All morphisms,
    and hence all activities, in the universe can be described by the category theory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Curry、Howard和Lambek发现所有数学分支实际上都是相同的东西！他们意识到在一定抽象层次上，所有数学理论的结构都是相同的。我们可以将我们的逻辑结构变形成范畴类，并且我们可以将该结构变形成类型理论。宇宙中的所有态射，因此所有活动，都可以用范畴论来描述。
- en: For example, when we consider a photon particle in an electromagnetic field,
    a soccer ball in flight, and a bouncy C (musical note), they don't seem to have
    much in common until we provide context. From the point of view of wave theory,
    they are all the same problem. Now, change or context to centripetal force; again,
    they are all the same problem, only in a different context. When we abstract away
    all the non-essential details, what remains is the mathematical structure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们考虑电磁场中的光子粒子，飞行中的足球，以及弹跳的C（音符），它们似乎没有太多共同之处，直到我们提供上下文。从波动理论的角度来看，它们都是同一个问题。现在，改变或者转换到向心力的上下文；同样，它们都是同一个问题，只是在不同的上下文中。当我们抽象掉所有非必要的细节，剩下的就是数学结构。
- en: The advantage of using abstraction in this way is that we begin to see connections
    between things that were previously hidden from view. When can create and use
    tools that allow us to contextualize problem sets in different ways. We have the
    full power of category theory to enlighten our way. Software engineers who understand
    these concepts are better equipped to perform data analytics. Software engineers
    who learn to apply functional programming concepts build more reliable solutions
    that scale horizontally across multiple cores and across multiple compute instances
    in their cloud native clusters. It's not difficult to see what all the fuss regarding
    functional programming is about, right?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用抽象的优势在于，我们开始看到以前隐藏在视野之外的事物之间的联系。我们可以创造和使用工具，使我们能够以不同的方式对问题集进行上下文化。我们拥有范畴论的全部力量来启迪我们的道路。了解这些概念的软件工程师更有能力进行数据分析。学会应用函数式编程概念的软件工程师构建更可靠的解决方案，可以在其云原生集群中横向扩展到多个核心和多个计算实例。很容易看出，函数式编程引起了这么多关注，对吧？
- en: Proof theory
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证明理论
- en: Proof theory is a branch of mathematics where we make assumptions and apply
    logic to prove something. For example, if a and b can be proven to be true, then
    a is true and so is b.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 证明理论是数学的一个分支，我们在其中做出假设并应用逻辑来证明某些事情。例如，如果a和b可以被证明为真，则a为真，b也为真。
- en: Logical connectives
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑连接词
- en: 'The following table depicts logical connectives, in order of precedence:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格按优先顺序描述了逻辑连接词：
- en: '| **Symbol** | **Math name** | **English name** | **Go operator** | **Example**
    | **Meaning** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **数学名称** | **英文名称** | **Go运算符** | **示例** | **含义** |'
- en: '| ¬   | Negation | NOT | ! | ¬a | not a |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ¬   | 否定 | NOT | ! | ¬a | 非a |'
- en: '| ∧ | Conjunction | AND | && | a ∧ b | a and b |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ∧ | 合取 | 与 | && | a ∧ b | a和b |'
- en: '| ⊕ | Exclusive disjunction | exclusive or (XOR) | NA | a ⊕ b | either a or
    b (but not both) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| ⊕ | 排他性析取 | 异或（XOR） | NA | a ⊕ b | 要么a要么b（但不能同时） |'
- en: '| ∨ | Disjunction | OR | &#124;&#124; | a ∨ b | a or b |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ∨ | 析取 | 或 | &#124;&#124; | a ∨ b | a或b |'
- en: '| ∀ | Universal quantification | ∀ x: A(x) means A(x) is true for all x | NA
    | ∀a:A | all values a of type A |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| ∀ | 全称量化 | ∀ x: A(x) 表示对所有x，A(x)为真 | NA | ∀a:A | 类型A的所有值a |'
- en: '| ∃ | Existential quantification | ∃ x: A(x) means there is at least one x
    such that A(x) is true | NA | ∃a:A | there exists some value a of type A |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| ∃ | 存在量化 | ∃ x: A(x) 表示至少存在一个x使得A(x)为真 | NA | ∃a:A | 存在类型A的某个值a |'
- en: '| ⇒ | Material implication | Implies | NA | a ⇒ b | if a then b |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| ⇒ | 材料蕴涵 | 蕴含 | NA | a ⇒ b | 如果a则b |'
- en: '| ⇔ | Material equivalence | a ⇔ b is true only if both a and b are false,
    or both a and b are true | NA | a ⇔ b | a if and only if b |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| ⇔ | 材料等价 | 当且仅当a和b都为假，或者a和b都为真时，a ⇔ b 为真 | NA | a ⇔ b | a当且仅当b |'
- en: '| **≡** | Is defined as | a ≡ b means a is defined to be another name for b
    | NA | a ≡ b | a is logically equivalent to b |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **≡** | 定义为 | a ≡ b 表示a被定义为b的另一个名称 | NA | a ≡ b | a在逻辑上等价于b |'
- en: '| ⊢ | Turnstile | a ⊢ b means a is provable from b | NA | a ⊢ b | a is provable
    from b |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| ⊢ | 推导 | a ⊢ b 表示a可以从b推导出 | NA | a ⊢ b | a可以从b推导出 |'
- en: NA = Not Applicable, that is, there is no symbol for this in Go.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: NA = 不适用，即在Go中没有这个符号。
- en: There are other logic symbols, but these are some of the more important ones.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他逻辑符号，但这些是一些更重要的符号。
- en: In software, we use logic by combining these symbols and other terms like variables
    to prove whether something is true.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，我们通过组合这些符号和其他术语如变量来运用逻辑来证明某些事情是否为真。
- en: 'The following is an example using quantification symbols:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用量化符号的示例：
- en: '`f: A ⇒ B` means `∀a:A∃b:B` such that `b = f(b)`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`f: A ⇒ B` 意味着 `∀a:A∃b:B` 使得 `b = f(b)`'
- en: In other words, there is a function from *A* to *B,* where for all values a
    of type *A,* there exists some value b of type *B* such that *b = f(a)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，存在从*A*到*B*的函数，对于类型*A*的所有值*a*，都存在类型*B*的某个值*b*，使得*b = f(a)*。
- en: Logical inconsistency
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑不一致性
- en: 'The following function signature represents a function with logical inconsistency:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数签名表示具有逻辑不一致性的函数：
- en: '[PRE0]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The problem is that factorial is not defined for negative integers.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于阶乘未定义为负整数。
- en: Partial function
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分函数
- en: If our function is not defined/consistent for all values in our domain, it's
    said to be a partial function (as opposed to a total function). If our function
    is inconsistent, then we run the risk of running into unexpected errors during
    runtime.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的函数在我们的域中的所有值上未定义/一致，那么它被称为部分函数（与全函数相对）。如果我们的函数不一致，那么我们就有可能在运行时遇到意外错误。
- en: 'There are two main ways to solve this problem:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的两种主要方法：
- en: We can solve this inconsistency by reducing the size of our domain to only positive
    integers
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过将我们的域的大小减小到仅为正整数来解决这个不一致
- en: We can use failure monads like either validation or disjunction to capture things
    that go wrong
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用失败单子，如验证或分歧，来捕捉出错的事情
- en: Truth table
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真值表
- en: 'The truth tables contains interpretations of a proposition. An interpretation
    is the calculation of the value of a proposition:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表包含命题的解释。解释是命题值的计算：
- en: '| a | b | ¬a | ¬b | a ∧ b | a ∨ b | a ⊕ b | a → b | a ↔ b |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| a | b | ¬a | ¬b | a ∧ b | a ∨ b | a ⊕ b | a → b | a ↔ b |'
- en: '| T | T | F | F | T | T | F | T | T |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| T | T | F | F | T | T | F | T | T |'
- en: '| T | F | F | T | F | T | T | F | F |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F | T | F | T | T | F | F |'
- en: '| F | T | T | F | F | T | F | T | F |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| F | T | T | F | F | T | F | T | F |'
- en: '| F | F | T | T | F | F | F | T | T |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| F | F | T | T | F | F | F | T | T |'
- en: '"The opposite of a correct statement is a false statement. The opposite of
    a profound truth may well be another profound truth."'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正确陈述的相反是错误陈述。深刻真理的相反可能是另一个深刻真理。
- en: '- Niels Bohr'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '- 尼尔斯·玻尔'
- en: Conditional propositions
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件命题
- en: 'The following propositions say the same thing:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命题表达了相同的意思：
- en: '*If a, then b*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果a，则b*'
- en: '*a implies b*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a蕴含b*'
- en: '*a → b*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a → b*'
- en: '*a ⇒ b*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a ⇒ b*'
- en: 'The variable *a* is the hypothesis and *b* is the conclusion. The conclusion
    is always true, except when *a* is true and *b* is false. One way of thinking
    about this is: "If pigs could fly, then…" anything you conclude is true after
    such an obviously false statement. If *a* and *b* are both true, then obviously
    going from a to b will be true. However, if *a* is true and *b* is false, then
    when going from *a* to *b* we''ll end up with a false value.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 变量*a*是假设，*b*是结论。结论总是真的，除非*a*为真且*b*为假。对此的一种思考方式是：“如果猪会飞，那么……”在这样一个显然错误的陈述之后，你得出的任何结论都是真的。然而，如果*a*和*b*都为真，那么显然从*a*到*b*的过程将是真的。然而，如果*a*为真且*b*为假，那么当从*a*到*b*时，我们将得到一个假值。
- en: Logical equivalence
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑等价
- en: Now, we can use our truth table to determine the outcome of compound propositions.
    Since *¬a ∨ b* and *a → b* have the same truth values, they are said to be logically
    equivalent and we express that with the *¬a ∨ b ≡ a → b* equation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的真值表来确定复合命题的结果。由于*¬a ∨ b*和*a → b*具有相同的真值，它们被认为是逻辑等价的，并且我们用*¬a ∨ b
    ≡ a → b*等式来表示。
- en: '| a | b | ¬a | ¬a ∨ b | a → b |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| a | b | ¬a | ¬a ∨ b | a → b |'
- en: '| T | T | F | T | T |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| T | T | F | T | T |'
- en: '| T | F | F | F | F |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F | F | F |'
- en: '| F | T | T | T | T |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| F | T | T | T | T |'
- en: '| F | F | T | T | T |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| F | F | T | T | T |'
- en: A logically equivalent statement could be, "*If Jenny were sitting at her desk
    then she'd be at home*." That is a logical statement. A logical equivalent statement
    might be, "*If Jenny were not at home, then she would not be sitting at her desk*."
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个逻辑等价的陈述可能是，“*如果珍妮坐在她的办公桌前，那么她会在家*。”这是一个逻辑陈述。一个逻辑等价的陈述可能是，“*如果珍妮不在家，那么她就不会坐在她的办公桌前*。”
- en: 'We create logical equivalences by creating a hypothesis and its conclusion.
    The preceding hypothesis is: "*If Jenny were sitting at her desk*, and the conclusion
    is "*she''d be at home*." We determine the truth of each and compare their truth
    (true or false).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提出假设及其结论来创建逻辑等价。前面的假设是：“*如果珍妮坐在她的办公桌前*”，结论是“*她会在家*。”我们确定每个的真值并比较它们的真值（真或假）。
- en: Converse of a conditional proposition
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件命题的逆
- en: 'Let''s use a truth table to prove the `(a → b)∧(b → a) ≡ a ↔ b` equation:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用真值表来证明`(a → b)∧(b → a) ≡ a ↔ b`等式：
- en: '| a | b | a → b | b → a | (a → b)∧(b → a) | a ↔ b |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| a | b | a → b | b → a | (a → b)∧(b → a) | a ↔ b |'
- en: '| T | T | T | T | T | T |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| T | T | T | T | T | T |'
- en: '| T | F | F | T | F | F |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| T | F | F | T | F | F |'
- en: '| F | T | T | T | F | F |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| F | T | T | T | F | F |'
- en: '| F | F | T | T | T | T |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| F | F | T | T | T | T |'
- en: In other words, a biconditional proposition *(a ↔ b)* is equivalent to the conjunction
    of a conditional proposition *(a → b)* and its converse *(b → a)*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，双条件命题*(a ↔ b)*等价于条件命题*(a → b)*及其逆命题*(b → a)*的合取。
- en: Order matters
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 顺序很重要
- en: 'Remember the statement: "*If Jenny were sitting at her desk, then she''d be
    at home?"*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个陈述：“*如果珍妮坐在她的办公桌前，那么她会在家？*”
- en: Its converse would be, "*If Jenny were at home then she'd be sitting at her
    desk*." The converse is created by swapping the hypothesis and conclusion. How
    does the converse change the logic of the sentence? (*Could "Jenny be at home,
    but not at her desk?"*) The same words in a different order can change the resulting
    truth value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它的逆命题将是，“*如果珍妮在家，那么她会坐在她的办公桌前*。”逆命题是通过交换假设和结论而创建的。逆命题如何改变句子的逻辑？（*珍妮可能在家，但不在她的办公桌前吗？*）同样的词以不同的顺序可以改变结果的真值。
- en: Similarly, the inverse of a conditional can also change the logic. For example,
    consider the negative form of "*If Jenny were sitting at her desk, then she'd
    be at home,*" which is "*If Jenny were not sitting at her desk, then she would
    not be at home*." (Could Jenny be at home, but not at her desk?)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，条件的逆也可以改变逻辑。例如，考虑“*如果珍妮坐在她的办公桌前，那么她会在家*”的否定形式，即“*如果珍妮不坐在她的办公桌前，那么她就不会在家*。”（珍妮可能在家，但不在她的办公桌前吗？）
- en: See how we can use truth tables to combine statements and determine its resulting
    truth value?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用真值表来组合陈述并确定其结果的真值？
- en: The Curry Howard isomorphism
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里-霍华德同构
- en: The Curry Howard Isomorphism said that types are propositions and programs are
    their proofs. A proposition is an assertion (declarative statement), which is
    either true or false (but not both).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里-霍华德同构说类型是命题，程序是它们的证明。命题是一个断言（陈述性语句），它要么是真的，要么是假的（但不能两者都是）。
- en: Examples of propositions
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命题的例子
- en: 'Consider the following examples of propositions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下命题的例子：
- en: The equation 2 * 3 = 5
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程2 * 3 = 5
- en: 'If it is storming outside, then I take an Uber to class; otherwise, I walk,
    and if it is sunny, then I ride my bicycle:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果外面在下暴风雨，那么我会乘Uber去上课；否则，我会步行，如果天晴，那么我会骑自行车：
- en: '| **Variable** | **Clause** |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **变量** | **子句** |'
- en: '| a | *It is storming outside* |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| a | *外面在下暴风雨* |'
- en: '| b | *I take an Uber to class* |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| b | *我乘Uber去上课* |'
- en: '| c | *I walk* |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| c | *我步行* |'
- en: '| d | *It is sunny* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| d | *天晴* |'
- en: '| e | *I ride my bicycle* |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| e | *我骑自行车* |'
- en: 'The following is the **written logic version**:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**书面逻辑版本**：
- en: '*a implies b and ((not a) implies (c and (d implies e)))*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '* a意味着b和((非a)意味着(c和(d意味着e)))*'
- en: 'The following is the **logical symbols version**:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是**逻辑符号版本**：
- en: '*(a ⇒ b) ∧ (¬a ⇒  (c ∧ (d⇒  e)))*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*(a ⇒ b) ∧ (¬a ⇒  (c ∧ (d⇒  e)))*'
- en: Not propositions
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非命题
- en: 'The following are the examples of not propositions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是非命题的例子：
- en: '*x = 5*  (this is not an assertion of truth, it''s an assignment)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x = 5*（这不是真理的断言，而是一个赋值）'
- en: '*x + y = 5* (not enough information to be an assertion, answer depends on missing
    data)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x + y = 5*（不足以成为断言的信息，答案取决于缺少的数据）'
- en: Propositions can combine terms using connectives (and, or not).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 命题可以使用连接词（和，或不）组合术语。
- en: Lambda calculus
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda演算
- en: Alonzo Church brought formal logic, called **untyped Lambda calculus**, to computer
    science that includes substitution, abstraction, and application. Let's remember
    these terms and use them when implementing a lambda expression in Go later in
    this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 阿隆佐·丘奇将形式逻辑，称为**无类型的Lambda演算**，引入了计算机科学，其中包括替换，抽象和应用。让我们记住这些术语，并在本章后面实现Go中的lambda表达式时使用它们。
- en: Why so formal?
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么如此正式？
- en: Why do we care about adhering to the formalism and rules of logical (and algebraic)
    equations?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么关心遵守逻辑（和代数）方程的形式主义和规则？
- en: '"The irony is that the constraints of formalism is what liberates us to be
    our best."'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: “具有形式主义的讽刺是，形式主义的约束是解放我们成为最好的自己。”
- en: The importance of protocol
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 协议的重要性
- en: 'Respecting your elders, saying "Yes, Ma''am" and "Yes Sir" is not just social
    formalism. That''s called *following protocol*. It helps us communicate in a consistent
    way. Following formalisms helps us to act appropriately. Examples of practicing
    the civil virtues include things like these:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬长者，说“是的，夫人”和“是的，先生”不仅仅是社交礼仪。这被称为*遵循协议*。这有助于我们以一致的方式进行交流。遵循礼仪有助于我们适当地行事。练习文明美德的例子包括以下内容：
- en: Being honest
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诚实
- en: Maintaining self-control
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持自我控制
- en: Showing kindness toward fellow human beings
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对待他人的善良
- en: When we lead through an example of serving one another with transparency and
    kindness and to guard against greed and other forms of evil, we can freely engage
    with others in ways that are less likely to offend.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过为彼此服务的例子来领导，以透明和善良的方式来防范贪婪和其他形式的邪恶时，我们可以自由地与他人交往，这样就不太可能冒犯他人。
- en: How does offensive language and inappropriate behavior from our leaders affect
    the strength of our society? What good comes from showing blatant disrespect toward
    officers of the law?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领导人的冒犯性语言和不当行为如何影响我们社会的力量？对执法人员表现出公然的不尊重有什么好处？
- en: When everyone understands the importance of being polite and showing guarded
    generosity, we live in a strong social system in which we all have the opportunity
    to thrive. When we transfer this concept to our software development efforts,
    we end up with better solutions. The way we implement this system is through logic.
    If our systems are logically sound, then they will reliably help us achieve our
    goals.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个人都理解有礼貌和表现谨慎的慷慨的重要性时，我们生活在一个强大的社会体系中，我们都有机会蓬勃发展。当我们将这个概念转移到我们的软件开发工作中时，我们最终会得到更好的解决方案。我们实施这个系统的方式是通过逻辑。如果我们的系统在逻辑上是合理的，那么它们将可靠地帮助我们实现我们的目标。
- en: Historical Events in Functional Programming
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程的历史事件
- en: The history of functional programming is nothing short of fascinating. Functional
    programming languages are based on an elegant yet simple mathematical foundation,
    Lambda calculus.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的历史是非常迷人的。函数式编程语言是基于一个优雅而简单的数学基础，Lambda演算。
- en: '"To understand a science, it is necessary to know its history."'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: “要理解一门科学，有必要了解它的历史。”
- en: '- Auguste Comte'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '- 奥古斯特·孔特'
- en: Let's look at the discoveries that led up to Lambda calculus.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看导致Lambda演算的发现。
- en: George Boole (1815 - 1864)
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乔治·布尔（1815-1864）
- en: '![](img/2333ad17-4599-42b4-98d5-e0a0a31491d3.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2333ad17-4599-42b4-98d5-e0a0a31491d3.png)'
- en: 'Logic came from ancient Greeks such as Aristotle and Euclid. Prior to Boole,
    logic was literally in Greek; it was expressed in the form of language. Boole
    was the first to translate logic into algebraic symbols:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑来自古希腊人，如亚里士多德和欧几里德。在布尔之前，逻辑实际上是用希腊语表达的。布尔是第一个将逻辑翻译成代数符号的人：
- en: '*true = 1*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*真=1*'
- en: '*false = 0*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*假=0*'
- en: '*and = product (AxB)*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*和=乘积（AxB）*'
- en: '*or = sum(A+B)*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*或=和（A+B）*'
- en: Augustus De Morgan (1806 - 1871)
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 奥古斯都·德·摩根（1806-1871）
- en: '![](img/9b96a9e7-638f-4643-85a9-d800899098a9.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b96a9e7-638f-4643-85a9-d800899098a9.png)'
- en: 'De Morgan''s Law stated that all logical operations can be expressed in terms
    of *and*, *or*, and *not.* Furthermore, all logical operations can also be expressed
    in terms of just *and* and *not*, or just *or* and *not*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 德·摩根定律规定，所有逻辑运算都可以用*和*，*或*和*非*来表示。此外，所有逻辑运算也可以用*和*和*非*，或者只用*或*和*非*来表示：
- en: '*a ∧ b = ¬ ( (¬ a) ∨ (¬ b) )*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*a ∧ b = ¬ ( (¬ a) ∨ (¬ b) )*'
- en: '*a ∨ b = ¬ ( (¬ a) ∧ (¬ b) )*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*a ∨ b = ¬ ( (¬ a) ∧ (¬ b) )*'
- en: The first equation says that *a* and *b* are both true if and only if at least
    one of *a* or *b* is false. The second equation says that at least one of *a*
    or *b* is true if and only if both a and b are false.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程说，如果且仅当*a*和*b*中至少有一个为假时，*a*和*b*都为真。第二个方程说，如果且仅当*a*和*b*都为假时，*a*或*b*至少有一个为真。
- en: Friedrich Ludwig Gottlob Frege (1848 – 1925)
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弗里德里希·路德维希·戈特洛布·弗雷格（1848-1925）
- en: '![](img/e1582856-86da-4e72-b140-2ba4569797c8.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1582856-86da-4e72-b140-2ba4569797c8.png)'
- en: Frege was a German mathematician who is considered by many as the father of
    analytic philosophy. He studied the use of functions in logic and was the first
    to use currying. Frege invented axiomatic predicate logic. Axioms are statements/propositions
    that we accept as true; they are so self-evident that no other reasoning could
    make it plainer. They are simple truths.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 弗雷格是一位德国数学家，被许多人认为是分析哲学之父。他研究了逻辑中函数的使用，并且是第一个使用柯里化的人。弗雷格发明了公理谓词逻辑。公理是我们接受为真的陈述/命题；它们是如此不言自明，以至于没有其他推理可以使其更清楚。它们是简单的真理。
- en: Modus Ponens
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 假言推理
- en: 'The following rule of propositional logic is called **Modus Ponens**:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 命题逻辑的以下规则称为**假言推理**：
- en: '![](img/1b284fb3-3e24-4fc5-b0f4-6cc51ee30d97.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b284fb3-3e24-4fc5-b0f4-6cc51ee30d97.png)'
- en: If the tree is still on the power line, then we have no power
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果树还在电线上，那么我们就没有电了
- en: The tree is still on the power line
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树还在电线上
- en: We have no power
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有权力
- en: Charles Lutwidge Dodgson (1832 –1898)
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查尔斯·路德维奇·道奇森（1832-1898）
- en: '![](img/eded66d3-a4a0-4322-a6a9-eb0ff12189ad.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eded66d3-a4a0-4322-a6a9-eb0ff12189ad.png)'
- en: 'Charles Dodson (pen name: Lewis Carroll) authored several books in which he
    stripped away intuition and any preconception by manipulating logic, even if it
    seems like nonsense. Let''s look at the literary nonsense in his fiction book,
    *Alice in Wonderland*. Dodson often defied common sense by creating an entirely
    new world through the manipulation of language. The story maintained a balance
    between sense and nonsense, remaining logical, even though it appeared at times
    to be completely illogical. For example, as Alice moves within the back-to-front
    world of *Looking-Glass Land*, she discovers a book written in a seemingly unintelligible
    language:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·道森（笔名：刘易斯·卡罗尔）创作了几本书，他通过操纵逻辑剥离了直觉和任何先入之见，即使看起来像胡说八道。让我们来看看他的小说《爱丽丝梦游仙境》中的文学胡说。道森经常通过操纵语言创造一个全新的世界，违背常识。故事在理性和胡说之间保持平衡，即使有时看起来完全不合逻辑。例如，当爱丽丝在《镜中世界》中穿行时，她发现了一本用看似难以理解的语言写成的书：
- en: Twas brillig, and the slithy toves
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 那是个炫目的时刻，滑溜的土狸
- en: Did gyre and gimble in the wabe:All mimsy were the borogoves,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Did gyre and gimble in the wabe:All mimsy were the borogoves,
- en: And the mome raths outgrabe.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: And the mome raths outgrabe.
- en: '"Beware the Jabberwock, my son!'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: “当心贾伯沃克，我的孩子！
- en: The jaws that bite, the claws that catch!Beware the Jubjub bird, and shun
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 咬人的下颚，抓人的爪！当心朱布朱布鸟，避开
- en: The frumious Bandersnatch!"
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 那可怕的班德斯纳奇！”
- en: 'In *Through The Looking Glass*, Alice tries to keep up with the Red Queen;
    though constantly running, she remains in the same spot. Alice remarked:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在《镜中世界》中，爱丽丝试图跟上红皇后的脚步；尽管不断奔跑，她仍停留在原地。爱丽丝评论道：
- en: '*Well, in our country*, said Alice, still panting a little, *you''d generally
    get to somewhere else—if you run very fast for a long time, as we''ve been doing.*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们国家，”爱丽丝说，还有点气喘吁吁，“通常情况下，如果你像我们一样一直跑得很快很久，你最终会到达另一个地方。”
- en: 'The Red Queen''s race is often used to illustrate deep concepts such as these:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 红皇后的比赛经常用来说明这些深层概念：
- en: Time travel
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间旅行
- en: The relativistic effect on light from galaxies near the edge of the expanding
    observable universe
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不断膨胀的可观测宇宙边缘附近的星系对光的相对论效应
- en: Our efforts in the IT industry to adopt new technologies in an effort to keep
    up with our competitors (though years later, when looking back, we realize we
    did not actually improve our systems, we merely changed technologies sometimes
    to our detriment)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在IT行业的努力是为了采用新技术，以便跟上我们的竞争对手（尽管多年后回顾时，我们意识到我们实际上并没有改进我们的系统，我们只是有时改变了技术，有时对我们不利）
- en: We'll later look at an FP library named **Fantasy Land**, which likely gets
    its name from the nonsense logic found in works such as Alice in Wonderland.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将看一下名为**Fantasy Land**的FP库，这很可能是从《爱丽丝梦游仙境》等作品中找到的胡说逻辑得名的。
- en: Alfred Whitehead and Bertrand Russell (1903)
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阿尔弗雷德·怀特海德和伯特兰·罗素（1903）
- en: '![](img/6a0ab236-9d97-4826-85bb-1168a5f6c5bb.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a0ab236-9d97-4826-85bb-1168a5f6c5bb.png)'
- en: 'In a letter Russell wrote to Frege, the proposed the *Barbers Paradox* found
    a problem with Frege''s logic:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在罗素写给弗雷格的一封信中，提出了*理发师悖论*，发现了弗雷格逻辑的问题：
- en: 'Given that a town''s only barber shaves everybody, except those who shave themselves.
    We can deduce two things:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个镇上的理发师给每个人都剃须，除了那些给自己剃须的人。我们可以推断出两件事：
- en: If a person does not shave her/himself, the barber will
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个人不给自己剃须，理发师会给他/她剃须
- en: If person shaves her/himself, the barber won't
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个人给自己剃须，理发师就不会给他/她剃须
- en: 'The paradox is: *The barber cannot be shaven*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 悖论是：*理发师不能剃须*。
- en: The first statement says that if the barber does not shave himself, then barber
    will shave himself. However, the second statement directly contradicts that first
    statement.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 第一句话说，如果理发师不给自己剃须，那么理发师会给自己剃须。然而，第二句话直接否认了第一句话。
- en: Russell and Whitehead collaborated to prove/solve the Barber's Paradox and to
    prove that mathematics is a formal, logical framework. In 1912, they arrogantly
    produced a work entitled Principia Mathematica (that's the same name that Isaac
    Newton used to name his works that included the laws of motion, forming the foundation
    of classical mechanics, the law of universal gravitation, and a derivation of
    Kepler's laws of planetary motion).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 罗素和怀特海德合作证明/解决了理发师悖论，并证明了数学是一个形式化的逻辑框架。1912年，他们傲慢地出版了一部名为《数学原理》的作品（这与艾萨克·牛顿用来命名他的包括运动定律、形成古典力学基础、普遍引力定律和开普勒行星运动定律的作品的名字相同）。
- en: Russell and Whitehead's work proved to be impractical (it includes a 450-page
    proof to show that *1 + 1 = 2*). The irony is that logical substitution was not
    formalized in their Principa Mathematica. (We'll look at what logical substitution
    means when we look at Lambda calculus.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 罗素和怀特海德的工作被证明是不切实际的（其中包括一个450页的证明，证明*1+1=2*）。讽刺的是，逻辑替换在他们的《数学原理》中并没有形式化。（我们将在看λ演算时看看逻辑替换是什么意思。）
- en: Moses Schonfinkel (1889–1942)
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 莫西斯·肖恩芬克尔（1889-1942）
- en: '![](img/0988b518-2c41-480b-979a-458cc54021a0.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0988b518-2c41-480b-979a-458cc54021a0.png)'
- en: Schonfinkel was a Russian mathematician who invented combinatory logic around
    1924\. A combinator is a higher order function that uses only function application
    and earlier defined combinators to define a result from its arguments. This replacement
    technique reduced multiple function arguments to a single argument, and was later
    known as currying, after Haskell Curry.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 肖恩芬克尔是一位于1924年左右发明组合逻辑的俄罗斯数学家。组合子是一个高阶函数，它仅使用函数应用和先前定义的组合子来从其参数定义结果。这种替换技术将多个函数参数减少为单个参数，并且后来被称为柯里化，以纪念Haskell
    Curry。
- en: 'The following table explains Schonfinkel combinators:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了肖恩芬克尔组合子：
- en: '| **Definition** | **Acroymn - German** | **Function Type** |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| **定义** | **缩写词-德语** | **函数类型** |'
- en: '| λx. x | I - Identitatsfunktion | Identity |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| λx。x | I- Identitatsfunktion | 身份 |'
- en: '| λx,y. x | K - Konstanzfunktion | Constant |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: 兰布达演算的λx，y。x | K- Konstanzfunktion | 常数
- en: '| λx,y,z. xz(yz) | S - Verschmelzungsfunktion | Amalgamation |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| λx，y，z。xz(yz) | S- Verschmelzungsfunktion | 合并 |'
- en: '| λx,y,z. xzy | T - Vertauschungsfunktion | Exchange |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| λx，y，z。xzy | T- Vertauschungsfunktion | 交换 |'
- en: '| λx,y,z. x(yz) | Z - Zusammensetzungsfunktion | Composition |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| λx，y，z。x(yz) | Z- Zusammensetzungsfunktion | 组合 |'
- en: Haskell Curry - 1927
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈斯克尔·柯里-1927年
- en: '![](img/4d9ef818-a309-47a1-9273-b3b71a36ac30.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d9ef818-a309-47a1-9273-b3b71a36ac30.png)'
- en: Haskell Curry introduced Combinatory Logic in 1927 that eliminated the use of
    variables that change. It is based on combinators. A combinator is a higher order
    function that uses function application and previously defined combinators to
    produce a result from its arguments. Alonzo Church later devised a similar formalism
    called **The** **Lambda Calculus**, where lambda expressions represent functional
    abstractions are replaced by a limited set of combinators. For details, see *The
    Lambda Calculus* section later in this chapter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell Curry于1927年引入了组合逻辑，消除了变量的使用。它基于组合子。组合子是一个高阶函数，它使用函数应用和先前定义的组合子从其参数产生结果。阿隆佐·丘奇后来设计了一个类似的形式主义称为**λ演算**，其中λ表达式代表功能抽象被一组有限的组合子替换。有关详细信息，请参见本章后面的*λ演算*部分。
- en: Gerhard Gentzen (1936)
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格哈德·根岑（1936年）
- en: '![](img/59c2b39d-8398-497c-a4b0-dfdd513b4b1b.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c2b39d-8398-497c-a4b0-dfdd513b4b1b.png)'
- en: In 1936, a German mathematician named Gerhard Gentzen provided proof that first-order
    arithmetic (addition and multiplication) is consistent using primitive recursive
    arithmetic. Gentzen used sequent calculus, which is a conditional tautology (a
    series of true statements) to build arguments according to rules and procedures
    of inference ([https://en.wikipedia.org/wiki/Inference](https://en.wikipedia.org/wiki/Inference))
    with zero or more assertions. Note that sequent calculus is very similar to natural
    deduction, which is composed of one or more assertions.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 1936年，一位名叫格哈德·根岑的德国数学家提供了证明，一阶算术（加法和乘法）是一致的，使用原始递归算术。根岑使用序言演算，这是一个条件性重言式（一系列真实陈述），根据推理的规则和程序（[https://en.wikipedia.org/wiki/Inference](https://en.wikipedia.org/wiki/Inference)）进行论证，其中有零个或多个断言。请注意，序言演算与自然演绎非常相似，后者由一个或多个断言组成。
- en: Alonzo Church (1930, 1940)
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阿隆佐·丘奇（1930年，1940年）
- en: '![](img/4b97339d-31a7-4eee-8bc2-0bb76d083a8d.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b97339d-31a7-4eee-8bc2-0bb76d083a8d.png)'
- en: Church read the Principa Mathematica and decided to improve upon it. Church
    applied formal mathematical logic to computer science using function abstraction
    and application using variable binding and substitution. In 1930, Church's released
    the first version of Lambda calculus, which formed the basis of what he called
    *effectively computable functions*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 丘奇阅读了《数学原理》并决定对其进行改进。丘奇应用了形式化数学逻辑到计算机科学中，使用函数抽象和应用来使用变量绑定和替换。 1930年，丘奇发布了λ演算的第一个版本，这构成了他所谓的*有效可计算函数*的基础。
- en: In 1935, Kleene and Rosser proved that it was logically inconsistent. Church
    quickly responded with an improved version named *simply typed Lambda calculus*
    that fixed the issue of non-terminating programs with a typed system that defined
    the syntax of high order logic, but did not include recursive functions. Later,
    in 1940, Church invented The Lambda Calculus, which is composed only of functions,
    which does not concern itself with concrete values like strings and numbers. It
    works with only functions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 1935年，克利恩和罗瑟证明了它在逻辑上是不一致的。丘奇迅速回应，推出了一个改进版本，名为*简单类型的λ演算*，它通过定义高阶逻辑的语法来解决了非终止程序的问题，但不包括递归函数。后来，在1940年，丘奇发明了λ演算，它仅由函数组成，不涉及像字符串和数字这样的具体值。它只使用函数。
- en: Functions can take functions and return functions. Haskell Curry intended Lambda
    calculus to be a foundation for mathematics. You need some form of recursive type
    to write any interesting kind of program in it. Haskell Curry's work with combinatory
    logic is a foundation of the functional programming language.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受函数并返回函数。 Haskell Curry打算将λ演算作为数学的基础。您需要某种形式的递归类型才能在其中编写任何有趣的程序。 Haskell
    Curry与组合逻辑的工作是函数式编程语言的基础。
- en: Alan Turing (1950)
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 艾伦·图灵（1950年）
- en: '![](img/370f7a7f-06f9-4ae6-bb8f-9e8ee7a27690.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/370f7a7f-06f9-4ae6-bb8f-9e8ee7a27690.png)'
- en: At about the same time as Alonzo Church published his Lambda calculus, Alan
    Turing introduced the Turing machine, which could perform any computational task,
    that is, anything Lambda calculus could calculate. Turing completeness is an abstract
    statement of ability, rather than a prescription of specific language features
    used to implement that ability. The features used to achieve Turing completeness
    can be quite different; Fortran systems would use loop constructs or possibly
    even `goto` statements to achieve repetition. Pure functional languages like Haskell
    and Prolog use recursion.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 阿隆佐·丘奇发表λ演算的同时，艾伦·图灵引入了图灵机，可以执行任何计算任务，也就是说，任何λ演算可以计算的任务。 图灵完备性是一种能力的抽象陈述，而不是用于实现该能力的特定语言特性的规定。实现图灵完备性的特性可能会有很大不同；Fortran系统将使用循环结构或可能甚至使用`goto`语句来实现重复。像Haskell和Prolog这样的纯函数语言使用递归。
- en: MacLane and Eilenberg (1945)
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 麦克莱恩和艾伦伯格（1945年）
- en: '![](img/99d11550-5d85-4c95-b79d-14ca2aaa0c21.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99d11550-5d85-4c95-b79d-14ca2aaa0c21.png)'
- en: Saunders Mac Lane (left) and Samuel Eilenberg (right) introduced the concepts
    of categories, functors, and natural transformations in 1945 with their paper
    titled, *A general theory of natural equivalences*. In their study of algebraic
    topology, they gave explicit definitions for objects, maps, and composition of
    maps, with the goal of understanding the processes that preserve mathematical
    structure.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Saunders Mac Lane（左）和Samuel Eilenberg（右）在1945年发表了题为*A general theory of natural
    equivalences*的论文，介绍了范畴、函子和自然变换的概念。在他们的代数拓扑学研究中，他们给出了对象、映射和映射的组合的明确定义，目的是理解保持数学结构的过程。
- en: John McCarthy (1950)
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约翰·麦卡锡（1950）
- en: '![](img/12a0816c-2e09-42bf-9e0f-6751948d82db.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12a0816c-2e09-42bf-9e0f-6751948d82db.png)'
- en: Next came John McCarthy who published the paper *Recursive functions of symbolic
    expressions and their computation by machine, Part I* ([http://dl.acm.org/citation.cfm?id=367199](http://dl.acm.org/citation.cfm?id=367199)).
    In 1958, one of his students wrote an interpreter based on McCarthy's teachings,
    which became a programming language based on pure mathematics called Lisp. Lisp
    was the first functional language. The first popular computer languages based
    on type systems were Fortran and Cobol, which emerged in the 1950s.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是约翰·麦卡锡，他发表了论文*Recursive functions of symbolic expressions and their computation
    by machine, Part I*（[http://dl.acm.org/citation.cfm?id=367199](http://dl.acm.org/citation.cfm?id=367199)）。1958年，他的一名学生根据麦卡锡的教导编写了一个解释器，这成为了一种基于纯数学的编程语言Lisp。Lisp是第一种函数式语言。基于类型系统的第一批流行的计算机语言是Fortran和Cobol，它们出现在1950年代。
- en: Curry-Howard-Lambek Correspondence (1969)
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Curry-Howard-Lambek Correspondence（1969）
- en: '![](img/27c1437c-4e2a-484b-8124-71cd25d2a12f.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27c1437c-4e2a-484b-8124-71cd25d2a12f.png)'
- en: '**Curry, Howard, and Lambek** (**CHL**) discovered the one-to-one correspondence
    between objects in category theory, propositions in logic, and types in programming
    languages.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**Curry, Howard, and Lambek**（**CHL**）发现了范畴论中的对象、逻辑中的命题和编程语言中的类型之间的一一对应关系。'
- en: CHL looked at the types of rules for natural deduction rules and typed Lambda
    calculus and discovered that they are identical.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: CHL研究了自然推导规则和带类型的Lambda演算的类型，并发现它们是相同的。
- en: '![](img/8cd2fd21-a53f-4208-95b8-40e18110d956.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cd2fd21-a53f-4208-95b8-40e18110d956.png)'
- en: If we remove the red terms in the preceding table, they are identical. Hence,
    Church's lambda types correspond one-to-one with Gentzen's logical formulas. Type
    checking is the same as proof checking.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们去掉上表中的红色术语，它们是相同的。因此，Church的λ类型与Gentzen的逻辑公式一一对应。类型检查与证明检查是相同的。
- en: Logic includes **and**, **or** and **implication** constructs
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑包括**和**、**或**和**蕴涵**结构
- en: Programming has data records and function constructs
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程具有数据记录和函数结构
- en: Category theory has arrows which are functions (that can also be data)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴论具有箭头，这些箭头是函数（也可以是数据）
- en: As an example of how they relate, consider that a proposition in logic can be
    true or false. Similarly, a type can be either inhabited or not. True propositions
    are inhabited. The void type is false. If we can produce an element of a type,
    then we have proven our proposition.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子来说明它们的关系，逻辑中的命题可以是真或假。同样，类型可以是有人居住的或者没有。真命题是有人居住的。空类型是假的。如果我们能产生一个类型的元素，那么我们就证明了我们的命题。
- en: CHL realized that Cartesian closed categories, intuitionistic propositional
    logic, and the simply typed Lambda calculus are all essentially the same thing.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: CHL意识到笛卡尔闭范畴、直觉命题逻辑和简单类型的λ演算本质上是相同的东西。
- en: 'Let''s have a look at the correspondence table:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下对应表：
- en: '| **Category theory** | **Logic theory** | **Type theory/Lambda calculus**
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **范畴论** | **逻辑理论** | **类型理论/λ演算** |'
- en: '| Objects | Propositions | Types |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 命题 | 类型 |'
- en: '| Morphisms | Proofs | Functions |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 源 | 证明 | 函数 |'
- en: '| Equivalences between morphisms  | Equivalences between proofs | Beta-eta
    equivalences between Lambda calculus term |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 源之间的等价  | 证明之间的等价 | Lambda演算术语之间的Beta-eta等价 |'
- en: All three areas of study arrived at the same discoveries independently, from
    different perspectives, but the mathematical structures they describe in each
    case are essentially identical.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个研究领域都是独立地从不同的角度得出了相同的发现，但它们在每种情况下描述的数学结构本质上是相同的。
- en: Roger Godement (1958)
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Roger Godement（1958）
- en: '![](img/52ea5534-e8b2-4367-a8fa-e5231c030e91.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52ea5534-e8b2-4367-a8fa-e5231c030e91.png)'
- en: In 1958, Roger Godement wrote a book on the sheaf theory that first introduced
    the concept of monads. Sheaves are objects that capture local data about a manifold,
    yet in doing so, allows one to see global properties of space as a whole. What's
    a manifold? It's a geometric object, for example, the Earth. From where you stand
    or walk, it looks like it goes on for ever. However, if you walk around the Earth
    enough times, you'll realize that it's a sphere. What Godement called a **standard
    construction** was subsequently called a **monad** by Saunders Mac Lane, and that
    name stuck.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 1958年，Roger Godement写了一本关于层理论的书，首次引入了单子的概念。层是捕捉流形的局部数据的对象，但在这样做的同时，允许人们看到空间的整体性质。什么是流形？它是一个几何对象，例如地球。从你所站立或行走的地方看，它看起来好像永远都在延伸。然而，如果你绕地球走足够多次，你会意识到它是一个球体。Godement所谓的**标准构造**后来被Saunders
    Mac Lane称为**单子**，这个名字一直沿用至今。
- en: '![](img/1ea00651-8b6f-4fd9-94aa-007f70088054.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ea00651-8b6f-4fd9-94aa-007f70088054.png)'
- en: Moggi, Wadler, Jones (1991)
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Moggi, Wadler, Jones（1991）
- en: '![](img/8158a240-e97d-4e71-b61b-9115581c15e2.png) ![](img/950a9232-2aba-4255-b48a-3a3f186370d1.png) ![](img/9a6f4ab3-4e6a-435b-af45-08bdc0a79c95.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8158a240-e97d-4e71-b61b-9115581c15e2.png) ![](img/950a9232-2aba-4255-b48a-3a3f186370d1.png) ![](img/9a6f4ab3-4e6a-435b-af45-08bdc0a79c95.png)'
- en: In 1991, Eugenio Moggi wrote *Notions of computation and monads*, which introduced
    the concept of categorical semantics of computation in order to understand features
    in new programming languages. Languages often add new features to solve particular
    problems, but the features are rarely specified carefully in a formal way. In
    order to understand programs written in these languages, we need a framework to
    help us understand how information flows through our applications.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 1991年，Eugenio Moggi写了《计算概念和单子》，其中介绍了计算的范畴语义概念，以便理解新编程语言中的特性。语言经常添加新特性来解决特定问题，但这些特性很少以正式的方式进行仔细规定。为了理解用这些语言编写的程序，我们需要一个框架来帮助我们理解信息如何在我们的应用程序中流动。
- en: Moggi described a category C and an endomorphic functor *f* with an object *A*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Moggi描述了一个范畴C和一个具有对象*A*的内态函子*f*。
- en: '*A* is a type in *C*, where members are values of type *A*'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*是*C*中的一种类型，其中成员是类型*A*的值'
- en: '*f* applies to *A* and returns another *A*'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f*应用于*A*并返回另一个*A*'
- en: It is amazing how far we have gone with so little. Less really is more!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是我们用如此少的东西走了这么远。少真的就是更多！
- en: 'Philip Wadler and Simon Peyton Jones and others began to use monads and it
    trickled down into the Haskell language. Now, monads are part of its standard
    library. Uses for monads include the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Philip Wadler和Simon Peyton Jones等人开始使用单子，并且它渗透到了Haskell语言中。现在，单子是其标准库的一部分。单子的用途包括以下内容：
- en: Chain/link/connect/compose functions
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接/连接/组合函数
- en: Handling input
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理输入
- en: Handling side effects
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理副作用
- en: Asynchronous/concurrent processing
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步/并发处理
- en: Logging
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录
- en: Error handling
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Gibbons, Oliveira (2006)
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gibbons, Oliveira (2006)
- en: '![](img/b2ca9753-13f3-44f3-b30d-56567aa82ce8.png)![](img/88fe78d2-ee02-4d64-95b9-53d6eabe9ff7.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2ca9753-13f3-44f3-b30d-56567aa82ce8.png)![](img/88fe78d2-ee02-4d64-95b9-53d6eabe9ff7.png)'
- en: Gibbons and Oliveira explored an FP solution to the OOP iterator pattern. They
    used imperative iterations patterns and observed that data is mapped element-by-element
    with accumulation and can return an object of the same shape, that is, a transformed
    list of elements.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Gibbons和Oliveira探索了一种FP解决OOP迭代器模式的方法。他们使用了命令式迭代模式，并观察到数据是逐个元素映射的，并且可以返回相同形状的对象，即转换后的元素列表。
- en: 'They took Kernighan and Ritchie''s imperative wordcount program (in the following C#
    code) and created an alternative implementation using traversal operators and applicative
    functor techniques:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 他们拿了Kernighan和Ritchie的命令式wordcount程序（以下是C#代码）并使用遍历操作符和applicative functor技术创建了另一种实现：
- en: '[PRE1]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s an iteration example in Go:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go中的一个迭代示例：
- en: '![](img/c6aafb3c-b4ca-49fa-b299-73b4dd693ec7.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6aafb3c-b4ca-49fa-b299-73b4dd693ec7.png)'
- en: 'Given that different traversals perform different functions:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于不同的遍历执行不同的功能：
- en: '| **Function** | **Map element** | **Create state** | **Mapped dependent on
    state** | **State dependent on element** |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '**函数** **映射元素** **创建状态** **依赖于状态的映射** **状态依赖于元素**'
- en: '| `collect` | X | X |  | X |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '`collect` X X X '
- en: '| `disperse` | X | X | X |  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '`disperse` X X X '
- en: '| `measure` | X | X |  |  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '`measure` X X '
- en: '| `traverse` | X | X | X | X |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '`traverse` X X X X'
- en: '| `reduce` |  | X |  | X |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '`reduce`  X X '
- en: '| `reduceConst` |  | X |  |  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '`reduceConst`  X '
- en: '| `map` | X |  |  |  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '`map` X '
- en: 'The computation is in this form (K is the type of computation and T is data
    type): `K[T]`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 计算以这种形式进行（K是计算的类型，T是数据类型）：`K[T]`
- en: 'The nature of the following FP computations:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下FP计算的性质：
- en: '| **Computation** | **Description** | **New computations** | **Use computations**
    | **Functor map** |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '**计算** **描述** **新计算** **使用计算** **Functor map**'
- en: '| `Option[T]` | 0 &#124;&#124; 1 element | Some(t) | Some(3) | change value
    |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '`Option[T]` 0 || 1 element Some(t) Some(3) change value'
- en: '| `List[T]` | >= 0 elements | List(t) | List(1, 2, 3) | change values |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '`List[T]` >= 0 elements List(t) List(1, 2, 3) change values'
- en: '| `Future[T]` | perform later | future(t) | future(sum) | change later |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '`Future[T]` perform later future(t) future(sum) change later'
- en: '| `State[S, T]` | dependency on state | state(s => (s,t)) | state(s => (s,
    s+2)) | change t[x] |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '`State[S, T]` 依赖于状态 state(s => (s,t)) state(s => (s, s+2)) change t[x]'
- en: '| `IO[T]` | external effects | IO(t) | IO(putStr("hi")) | modify action |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '`IO[T]` 外部影响 IO(t) IO(putStr("hi")) modify action'
- en: 'Starting with this applicative: `f(a, b) ==> f(K[a], K[b])` with this pointed
    `f(a:A, b:B):C  ==> fk: K[A => B => C]` and with currying:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '从这个applicative开始：`f(a, b) ==> f(K[a], K[b])`，带有这个pointed `f(a:A, b:B):C  ==>
    fk: K[A => B => C]`，并且使用柯里化：'
- en: '[PRE2]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, apply **f** to **a** and **b** **inside** **K**: `K(**f**) <*> K**(a**)
    <*> K(**b)**`
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在K内应用**f**到**a**和**b**：`K(**f**) <*> K**(a**) <*> K(**b)**`
- en: We can use applicative composition to compose functions with Traversables and
    show that transformations on iterators are applicative.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用applicative composition来将函数与Traversables组合，并展示迭代器上的变换是applicative的。
- en: 'That''s the big picture. For the details, read their paper: [https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf).'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大局。有关详细信息，请阅读他们的论文：[https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)。
- en: The history of FP in a nutshell
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FP的历史简介
- en: In the 1930s, two very different approaches to solve computing problems emerged
    . The first school of thought rallied behind Alonzo Church. (Church developed
    Lambda calculus around 1929.) Church said that design should be top-down rather
    than bottom-up. He said we should start by treating all computation as the evaluation
    of mathematical functions and then remove abstractions to move toward the machine-level
    operations. The ability to control complexity via composition was arguably the
    main concern (definitely not performance). Languages that sprang from this line
    of thinking include ML, Lisp, SmallTalk, Erlang, Clojure and Haskell.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在1930年代，出现了两种解决计算问题的非常不同的方法。第一种思想支持者是Alonzo Church。（Church在1929年左右开发了Lambda演算。）Church说设计应该是自顶向下的，而不是自底向上的。他说我们应该从将所有计算视为数学函数的评估开始，然后去除抽象以向机器级操作迈进。通过组合来控制复杂性的能力可以说是主要关注点（绝对不是性能）。从这种思路产生的语言包括ML、Lisp、SmallTalk、Erlang、Clojure和Haskell。
- en: The other computing solution came from Alan Turing (a former student of Church,
    developed the Turing machine around 1937). Turing said that software design should
    first consider the hardware upon which the software would run. Later, abstraction
    could be  as needed to achieve the desired result. Performance was their paramount
    concern. Languages that sprang from this line of thought include Fortran, C, C++,
    C#, Pascal, and Java.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个计算解决方案来自Alan Turing（Church的前学生，约1937年左右开发了图灵机）。图灵说软件设计应首先考虑软件将在其上运行的硬件。稍后，可以根据需要进行抽象以实现所需的结果。性能是他们的首要关注点。从这种思路产生的语言包括Fortran、C、C++、C#、Pascal和Java。
- en: Lambda calculus and Turing Machines are both Turing Complete. A Turing Complete
    machine is basically a general purpose computer (has if, then, else, branching
    logic and looping constructs like for or while loops and a way to read and write
    data) that can help us solve problems. Church proved that a Turing Machine can
    be implemented using Lambda calculus.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda演算和图灵机都是图灵完备的。图灵完备机器基本上是一台通用计算机（具有if、then、else、分支逻辑和循环结构，如for或while循环以及读写数据的方法），可以帮助我们解决问题。Church证明了可以使用Lambda演算实现图灵机。
- en: The Lambdas warned against the fragility of locking down the software design
    based on hardware that may be obsoleted. Until recently, the bottom up approach
    has won out. With the recent advent of multi-core computers and distributed processing
    environments, Lambda calculus is gaining ground.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda警告说，基于可能过时的硬件锁定软件设计的脆弱性。直到最近，自下而上的方法才获胜。随着多核计算机和分布式处理环境的最近出现，Lambda演算正在获得越来越多的支持。
- en: Recently, Turing-based languages have begun to embrace the top down approach.
    For example, we began to see FP characteristics in Java 7\. More and more FP features
    are added to each subsequent version. We're also seeing FP constructs being added
    to Python, C++, C#, PHP, and more.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，基于图灵的语言已经开始采用自上而下的方法。例如，我们开始在Java 7中看到FP特征。越来越多的FP特性被添加到每个后续版本中。我们还看到FP构造被添加到Python、C++、C#、PHP等语言中。
- en: What is the most important concern today? Raw performance, or the ability to
    control complexity? As usual, It Depends, but given the industry shift to cloud
    computing environments, the ever increasing need to integrate with third-party
    libraries and even with other in-house departments, it looks like functional programming
    is not only catching on, it's taking over.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 今天最重要的问题是什么？原始性能，还是控制复杂性的能力？像往常一样，这取决于情况，但考虑到行业转向云计算环境，与第三方库甚至公司内部其他部门集成的需求不断增加，似乎函数式编程不仅仅是流行，而且正在取代其他编程方式。
- en: Where to go from here
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从这里去哪里
- en: As the need to run applications concurrently in distributed cloud environments
    rises, so will the demand to build and maintain those solutions. We know that
    pure FP scales, but how can we use FP to improve overall performance and control
    its complexity?
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 随着在分布式云环境中并发运行应用程序的需求增加，构建和维护这些解决方案的需求也将增加。我们知道纯FP可以扩展，但我们如何使用FP来提高整体性能并控制其复杂性呢？
- en: Knowledge is power. Keep learning. And apply what you know to build a better
    future.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 知识就是力量。不断学习。并应用你所知道的来建设更美好的未来。
- en: 'Functional Programming Resources:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程资源：
- en: '[https://www.cambridge.org/core/journals/journal-of-functional-programming/](https://www.cambridge.org/core/journals/journal-of-functional-programming/)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.cambridge.org/core/journals/journal-of-functional-programming/](https://www.cambridge.org/core/journals/journal-of-functional-programming/)'
- en: 'Check out today''s FP giants here:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 查看今天的FP巨头：
- en: '[https://scholar.google.com/citations?view_op=search_authors&hl=en&mauthors=label:functional_programming](https://scholar.google.com/citations?view_op=search_authors&hl=en&mauthors=label:functional_programming)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://scholar.google.com/citations?view_op=search_authors&hl=en&mauthors=label:functional_programming](https://scholar.google.com/citations?view_op=search_authors&hl=en&mauthors=label:functional_programming)'
- en: '[http://learnyouahaskell.com/](http://learnyouahaskell.com/)'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://learnyouahaskell.com/](http://learnyouahaskell.com/)'
- en: '[http://learnyousomeerlang.com/](http://learnyousomeerlang.com/)'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://learnyousomeerlang.com/](http://learnyousomeerlang.com/)'
- en: Programming language categories
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程语言类别
- en: Here, we can see four categories of programming languages. The two big categories
    are imperative and declarative. When programming in a declarative language, we
    tell the computer what we want. For example, in the following declarative code,
    we tell the computer that we want to find a `Highlander` car.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到四种编程语言的类别。两个主要的类别是命令式和声明式。在声明式语言中编程时，我们告诉计算机我们想要什么。例如，在下面的声明式代码中，我们告诉计算机我们想要找到一辆“Highlander”汽车。
- en: A declarative example
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个声明式的例子
- en: 'The following is an  example of declarative programming language:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个声明式编程语言的例子：
- en: '[PRE3]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Contrast that with an imperative language with all code ceremony where we must
    construct a `for` loop.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式语言相比，其中所有代码都必须进行`for`循环的繁文缛节。
- en: An imperative example
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个命令式的例子
- en: 'The following is an example of an imperative programming language:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个命令式编程语言的例子：
- en: '[PRE4]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: An OOP example
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个面向对象的例子
- en: '**Object-oriented programs** (**OOP**) consists of stateful objects that support
    object-related operations, called **methods**, whose implementation and internal
    structure is hidden. This means you can evolve or replace the internals of an
    object without the clients of that object also having to change. It also means
    that changes can occur to the hidden data without your knowledge, which, as we''ve
    seen, can be a bad thing. OOP also includes the idea of inheritance, where a new
    object could base its state and implementation on another object higher up in
    its hierarchy, which can cause your program to become rigid and more difficult
    to change. Here is a `Car` object and its `Add` method:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象的程序**（**OOP**）由支持与对象相关的操作的有状态对象组成，称为**方法**，其实现和内部结构是隐藏的。这意味着您可以发展或替换对象的内部而不必更改该对象的客户端。这也意味着隐藏数据的更改可能会在您不知情的情况下发生，正如我们所见，这可能是一件坏事。OOP还包括继承的概念，其中新对象可以基于其层次结构中更高的另一个对象的状态和实现，这可能导致您的程序变得僵化且更难更改。这是一个`Car`对象及其`Add`方法：'
- en: '[PRE5]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Venn diagram of four programming paradigms
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四种编程范式的维恩图
- en: Note that Go supports all three of those styles of programming. Originally,
    *idiomatic* Go programming style directed us to code using for loops. That is
    beginning to change. Similarly, Java was originally a mix of object-oriented and
    imperative coding styles. Java supported Generics in 2004 to provide type safety
    for collections and to eliminate the need of typecasting. 8 years later, Java
    added support for lambda expressions. The JDK's `java.util.stream` package leverages
    FP language features to provide aggregate operations on data structures like collections
    and arrays in a declarative and parallel-processing-friendly manner.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Go支持这三种编程风格。最初，*惯用*的Go编程风格指导我们使用for循环进行编码。这开始发生改变。同样，Java最初是面向对象和命令式编码风格的混合体。Java在2004年支持了泛型，以为集合提供类型安全性并消除了类型转换的需要。8年后，Java增加了对lambda表达式的支持。JDK的`java.util.stream`包利用FP语言特性，以声明式和并行处理友好的方式对数据结构（如集合和数组）进行聚合操作。
- en: '![](img/54d92dfb-ff8b-402b-abf7-f1322cbc39f3.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54d92dfb-ff8b-402b-abf7-f1322cbc39f3.png)'
- en: Five generations of languages
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 五代语言
- en: Another way to group programming languages is by their *generation*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种对编程语言进行分组的方法是按照它们的*代数*。
- en: The first generation (1GL) language consists only of 1's and 0's which represent
    the on and off positions of electrical switches. The 1GL machine language is difficult
    for humans to understand.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 第一代（1GL）语言只包含1和0，它们代表电子开关的开和关位置。1GL机器语言对人类来说很难理解。
- en: Assembly language (2GL) allows the programming to user words to represent operations
    and operands, for example, CMP means compare the data in the AX register with
    the number 99\. The result is stored in the the EFLAGS register and used by the
    jump (JL) command. 2GL's are specific to a particular processor family, that is,
    they are machine dependent.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言（2GL）允许编程人员使用单词来表示操作和操作数，例如，CMP表示比较AX寄存器中的数据和数字99。结果存储在EFLAGS寄存器中，并被跳转（JL）命令使用。2GL是特定于特定处理器系列的，也就是说，它们是机器相关的。
- en: A 3GL is a higher level language and most are not machine dependent. For example,
    Go is a 3GL. Go abstracts more details than a 2GL and allows us to program in
    more familiar notations. Go provides curly braces `{ }` to indicate blocks of
    code, control structures like if, switch and range and other abstractions such
    as functions and interfaces.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 3GL是一种更高级的语言，大多数不依赖于特定的机器。例如，Go是一种3GL。Go比2GL抽象更多的细节，并允许我们使用更熟悉的符号进行编程。Go提供了花括号`{
    }`来表示代码块，控制结构如if、switch和range以及其他抽象，比如函数和接口。
- en: A 4GL language are declarative. They allow us to declare what we want to compute,
    rather than telling the computer how to do it. This is yet another higher level
    of abstraction. For example in SQL we may write `SELECT * FROM USERS`  which says,
    give me all the columns and all the rows of data in the `USERS` table. We did
    not have to include and looping, order, parsing or any other details, we just
    said what we wanted.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 4GL语言是声明式的。它们允许我们声明我们想要计算的内容，而不是告诉计算机如何做。这是另一种更高级的抽象。例如，在SQL中，我们可以写`SELECT *
    FROM USERS`，这表示，给我`USERS`表中的所有列和所有数据行。我们不必包括任何循环、顺序、解析或其他细节，我们只是说我们想要什么。
- en: A 5GL languages allow use to program using human languages like English. They
    are typically built on Lisp and emulate human-like qualities such as learning,
    reasoning, seeing and communicating.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 5GL语言允许我们使用英语等人类语言进行编程。它们通常建立在Lisp之上，并模拟学习、推理、视觉和交流等类人的特质。
- en: '![](img/974bf050-7d90-4177-93c1-f64a648e14ff.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![](img/974bf050-7d90-4177-93c1-f64a648e14ff.png)'
- en: The Forth language
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Forth语言
- en: Let's look at the Forth language. It is imperative, but incorporates key FP
    aspects, such as abstraction, replacement and chaining functions. We can open
    a forth console and start typing commands and get results. Rather than hide the
    fact that the runtime will use a stack to push and pop operators and operands
    on and off the stack, it's built into the language. There are no anonymous functions.
    Forth uses *words* which act like named functions. Words can reference other words
    which provides a very elegant form of abstraction. Common stack operations in
    Forth work with the top two or three values on the stack and can change the order
    of things or duplicate things.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Forth语言。它是命令式的，但包含了关键的FP方面，比如抽象、替换和链接函数。我们可以打开一个Forth控制台，开始输入命令并得到结果。与其隐藏运行时将使用堆栈来推送和弹出运算符和操作数的事实，不如将其内置到语言中。没有匿名函数。Forth使用*单词*来充当命名函数。单词可以引用其他单词，这提供了一种非常优雅的抽象形式。Forth中的常见堆栈操作可以处理堆栈上的前两个或三个值，并且可以改变事物的顺序或复制事物。
- en: 'Let''s look at an example:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '![](img/4bdc0e15-4166-49fd-84de-ab045e265255.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bdc0e15-4166-49fd-84de-ab045e265255.png)'
- en: 'We define our a function name/word starting with a colon. Comments are enclosed
    in parentheses. `( x -- x-squared )` says our function/word will take one input
    off the stack (x) and return that value squared. We define a second word that
    takes the top two values from the stack and returns a result. To test, we type
    `3 squared .`, the "." means evaluate this expression. The result is 9 (3 duplicated
    and multiplied). Next, we type `2 3  sumOfSquares negate .` this pushes 2 and
    3 on the stack, executes squared (which returns 9 since 3 is on the top), swaps
    3 with 9 and runs square which takes the next value (2) and then evaluates "+"
    which takes the top two values on the stack (9 and 4). We chain the builtin word
    to get our result: -13.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用冒号开头定义函数名/单词。注释用括号括起来。`( x -- x-squared )`表示我们的函数/单词将从堆栈中取出一个输入（x）并返回该值的平方。我们定义了第二个单词，它从堆栈中取出顶部两个值并返回一个结果。为了测试，我们输入`3
    squared .`，"."表示评估这个表达式。结果是9（3被复制并相乘）。接下来，我们输入`2 3  sumOfSquares negate .`，这将2和3推入堆栈，执行squared（因为3在顶部，所以返回9），交换3和9并运行square，然后取下一个值（2）并评估"+"，它取出堆栈上的两个值（9和4）。我们链接内置单词以获得结果：-13。
- en: 'If you''re using a mac then you can install forth using `brew install forth`.
    For details and more Forth references, visit: [https://github.com/lawrencewoodman/awesome-forth](https://github.com/lawrencewoodman/awesome-forth)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Mac，则可以使用`brew install forth`来安装Forth。有关详细信息和更多Forth参考，请访问：[https://github.com/lawrencewoodman/awesome-forth](https://github.com/lawrencewoodman/awesome-forth)
- en: Unlike the FP languages, Forth is untyped. Also, Forth directly uses values
    on the stack rather than passing parameters. Forth is a compiled language with
    a small footprint and is often used for embedded programming application, for
    example, NASA space crafts. We'd probably not consider Forth for enterprise system
    development since it lacks type safety.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 与FP语言不同，Forth是无类型的。此外，Forth直接使用堆栈上的值而不是传递参数。Forth是一种占用空间小的编译语言，通常用于嵌入式编程应用，例如NASA的航天器。我们可能不会考虑Forth用于企业系统开发，因为它缺乏类型安全性。
- en: The LINQ language
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LINQ语言
- en: 'Most languages are multi-paradigm, meaning that depending on our coding style,
    we can use declarative, object-oriented and imperative features in the same program.
    Knowing when to use which style is more of an art than science. The more we learn,
    the better equipped we will be to make the right design choice, and the sooner
    in our development process we do it, the better. One final not, see the dotted
    line from imperative/declarative FoxPro to object-oriented Visual FoxPro? That''s
    Microsoft killing its competition; FoxPro was once a well designed multi-paradigm
    language. FoxPro''s procedural language was extended using **Language Integrated
    Query** (**LINQ**). LINQ added query expressions similar to SQL to the FoxPro
    language. For example, the scatter and gather commands were used with the prebaked
    context of manipulating a database table:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都是多范式的，这意味着根据我们的编码风格，我们可以在同一个程序中使用声明式、面向对象和命令式特性。知道何时使用哪种风格更多的是一种艺术而不是科学。我们学得越多，我们就越能够做出正确的设计选择，而且我们在开发过程中越早做出选择就越好。最后一点，看看从命令式/声明式FoxPro到面向对象Visual
    FoxPro的虚线？这是微软消灭竞争对手；FoxPro曾经是一种设计良好的多范式语言。FoxPro的过程语言使用了**语言集成查询**（**LINQ**）进行扩展。LINQ添加了类似于SQL的查询表达式到FoxPro语言中。例如，scatter和gather命令与预先制作的上下文一起用于操作数据库表：
- en: '[PRE6]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These **4th generation language** (**4GL**) features increased developer productivity
    and code consistency.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**第四代语言**（**4GL**）的特性提高了开发人员的生产力和代码一致性。
- en: Type systems
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型系统
- en: What comes to mind when we see the word *type?* Data type? Like integer, string,
    date, or a composite type (struct in Go) that can contain multiple fields of various
    data types..
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到*type*这个词时，我们会想到什么？数据类型？比如整数、字符串、日期，或者包含多个不同数据类型字段的复合类型（Go中的struct）。
- en: What are they good for? When we compile our program, strongly typed language
    compilers can catch errors that might cause runtime errors or possibly worse,
    incorrect results that don't crash the program. For example, JavaScript uses type
    coercion to dynamically change data types of variables during runtime. The statement
    *MyBalance + 100.00* will equal *MyBalance100.00,* which might not be what we
    really want and may cause problems that are caught by online bank customers that
    complain that their balances don't add up. Weakly typed languages such as JavaScript
    and Ruby require much more rigorous testing than strongly typed language alternatives.
    Type systems not only detect errors in programs prior to running them, thereby
    increasing code quality, but they also help IDEs provide useful code navigation
    features.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有什么好处？当我们编译程序时，强类型语言编译器可以捕捉可能导致运行时错误或更糟糕的不正确结果的错误，这些错误不会使程序崩溃。例如，JavaScript使用类型强制转换在运行时动态更改变量的数据类型。语句*MyBalance
    + 100.00*将等于*MyBalance100.00*，这可能不是我们真正想要的，可能会导致在线银行客户抱怨他们的余额不平衡。JavaScript和Ruby等弱类型语言需要比强类型语言替代方案更严格的测试。类型系统不仅可以在运行程序之前检测程序中的错误，从而提高代码质量，还可以帮助IDE提供有用的代码导航功能。
- en: The Lambda Calculus
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda演算
- en: Lambda calculus is a logical system of rules for expressing computation using
    variable binding, abstraction, and function application. We can define anonymous
    functions and apply those functions. Lambda calculus would be limited if it weren't
    for recursion. Pure functional programming languages derived from lambda calculus
    include LISP, Haskell, and ML.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda演算是一种用于使用变量绑定、抽象和函数应用来表达计算的逻辑系统。我们可以定义匿名函数并应用这些函数。如果没有递归，Lambda演算将受到限制。源自Lambda演算的纯函数式编程语言包括LISP、Haskell和ML。
- en: Lambda Expressions
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: A lambda expression is an instance of a functional interface consisting of a
    set of terms. These terms can be variables like *x*, *y*, and *z*. These are not
    mutating variables, but rather placeholders for values or other lambda terms.
    The variable inside of x is applied to whatever it is bound to. The variable *x*
    is inside the term *t*. The lambda abstraction is defined as *λ x.t*.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是由一组术语组成的函数接口的实例。这些术语可以是像*x*、*y*和*z*这样的变量。这些不是可变的变量，而是值或其他lambda术语的占位符。x内部的变量应用于它绑定的任何内容。λ抽象定义为*λ
    x.t*。
- en: For example, if we have the equation `f(x) = x2` and replace x with 5, we have
    *f(5) =  52*.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有方程`f(x) = x²`，并用5替换x，我们有*f(5) = 52*。
- en: When the function *f* is applied to *x*, we get x². In our example, the function
    f is applied to the argument 5 and we get 52.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数*f*应用于*x*时，我们得到*x²*。在我们的例子中，函数*f*应用于参数5，我们得到*52*。
- en: We can eliminate the parentheses for brevity and we have the term *f* applied
    to another term 5: `f 5 = 52`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为了简洁起见消除括号，我们有术语*f*应用于另一个术语5：`f 5 = 52`。
- en: 'When we abstract, we remove information that we don''t need: *Lambda of x where
    x² is applied to 5*: `(λx.x2)  5 = 52`.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们抽象时，我们去除我们不需要的信息：*Lambda of x where x² is applied to 5*：`(λx.x²) 5 = 52`。
- en: We could use a term that is not a constant or a variable in place of 5\. *Lambda
    of x where x2 is applied to lambda of y + 1*: `(λx.x2) (λy.y + 1)  =  λy.(y +
    1)2`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在5的位置使用一个不是常量或变量的术语。*Lambda of x where x² is applied to lambda of y + 1*：`(λx.x²)
    (λy.y + 1) = λy.(y + 1)²`。
- en: Now, we have a new function. We passed a function to a function and got a function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新函数。我们将一个函数传递给一个函数，并得到一个函数。
- en: Since the lambda expression is an instance of a functional interface, when we
    write our code as though it were data we are effectively generating code with
    code.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 lambda 表达式是函数接口的一个实例，当我们将我们的代码写成数据时，我们实际上是用代码生成代码。
- en: When we only need to use a function once, it is usually more convenient to not
    give the function a name. In that case, it would be an anonymous function. Another
    name for the anonymous function is a *lambda expression*. Why create a new local
    function and then refer to the named function, when we can simply use a lambda
    expression?
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只需要使用一个函数一次时，通常更方便的是不给函数命名。在这种情况下，它将是一个匿名函数。匿名函数的另一个名称是*lambda 表达式*。为什么要创建一个新的本地函数，然后引用命名函数，当我们可以简单地使用
    lambda 表达式呢？
- en: Anonymous function example and type inference
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匿名函数示例和类型推断
- en: First, let's look at what we mean by the term *anonymous function*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们所说的*匿名函数*是什么意思。
- en: '![](img/7b6af684-3cd4-43dd-923a-6593b17e4dc3.png)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b6af684-3cd4-43dd-923a-6593b17e4dc3.png)'
- en: Function literals in Go require us to declare its type (`int` in our preceding
    example). In pure functional languages like Haskell and even Java 8 and above,
    the compilers of those languages are able to infer the type of the lambda expression
    without requiring use to declare it inline. Those compilers need minimal information
    to infer the types of expressions at runtime. If the compiler sees an expression
    with an argument of 5 and the "+" operator, a language with type inference will
    not require us to specifically indicate that we are dealing with integers.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的函数文字要求我们声明其类型（在我们之前的示例中为`int`）。在像Haskell甚至Java 8及以上这样的纯函数式语言中，这些语言的编译器能够推断
    lambda 表达式的类型，而无需我们内联声明它。这些编译器在运行时需要最少的信息来推断表达式的类型。如果编译器看到一个带有参数5和“+”运算符的表达式，具有类型推断的语言将不需要我们明确指示我们正在处理整数。
- en: 'Check out an example of lambda expression type inference in Java 8 here: [https://www.youtube.com/watch?v=a8jvxBbswp4](https://www.youtube.com/watch?v=a8jvxBbswp4).'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里查看 Java 8 中 lambda 表达式类型推断的示例：[https://www.youtube.com/watch?v=a8jvxBbswp4](https://www.youtube.com/watch?v=a8jvxBbswp4)。
- en: Lambda expression ingredients
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lambda 表达式成分
- en: A lambda expression is an unnamed block of code with parameters.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: λ 表达式是一个带参数的未命名代码块。
- en: 'A lambda expression consists of three things:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: λ 表达式由三部分组成：
- en: A block of code *x + 2*
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码块 *x + 2*
- en: Parameters *x*
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数 *x*
- en: Values for the free variables (not defined inside the code block) *5*
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由变量的值（未在代码块内定义） *5*
- en: 'Lambda calculus uses the following three concepts to describe how to perform
    a unit of computation:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 演算使用以下三个概念来描述如何执行一个计算单元：
- en: Abstraction (defining a *function*)
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象（定义一个*函数*）
- en: Binding (defining a *variable*)
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定（定义一个*变量*）
- en: Application (executing a *function*)
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用（执行一个*函数*）
- en: 'Variables that are unbound are referred to as *free variables*. Computation
    is achieved by performing single steps of reduction:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 未绑定的变量称为*自由变量*。通过执行单步缩减来实现计算：
- en: Alpha reduction
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alpha 缩减
- en: Beta reduction
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Beta 缩减
- en: Eta reduction
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eta 缩减
- en: 'Consider the following untyped Lambda calculus statement:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下未类型化的 Lambda 演算语句：
- en: '`(λx.xx)(λx.xx)`'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`(λx.xx)(λx.xx)`'
- en: The lambda symbol (from whence the name is derived) "λ" binds the name. In the
    example, the first parenthetical captures a statement that binds the name x. The
    second parenthetical serves as an argument. During beta-reduction, when we are
    applying the function, the parameter is bound to the name x. This is just substitution.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 符号（名称来源）“λ”绑定名称。在示例中，第一个括号捕获了绑定名称 x 的语句。第二个括号作为参数。在 beta-缩减期间，当我们应用函数时，参数绑定到名称
    x。这只是替换。
- en: 'Confused? That''s understandable, since we are using a mixture of Greek and
    English to describe what the code does. Let''s look at some Go code that performs
    these steps for clarity:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？这是可以理解的，因为我们在描述代码的功能时使用了希腊语和英语的混合。让我们看一些执行这些步骤以澄清的 Go 代码：
- en: 'Refer to the *Lambda calculus Reduction steps* post for a more detailed description
    of the 3 steps: [https://stackoverflow.com/questions/34140819/lambda-calculus-reduction-steps](https://stackoverflow.com/questions/34140819/lambda-calculus-reduction-steps)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何执行 Lambda 演算缩减步骤的更详细描述，请参阅*Lambda 演算缩减步骤*帖子：[https://stackoverflow.com/questions/34140819/lambda-calculus-reduction-steps](https://stackoverflow.com/questions/34140819/lambda-calculus-reduction-steps)
- en: Now that we've got some formalism out of the way, let's look at what it means
    in practice.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了一些形式化的内容，让我们看看它在实践中意味着什么。
- en: Visualizing a lambda expression
  id: totrans-478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可视化 lambda 表达式
- en: 'This is what happens when we evaluate a lambda expression:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们评估 lambda 表达式时发生的情况：
- en: '![](img/dde71c7b-2c81-40f9-911d-863b0c4f5fee.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dde71c7b-2c81-40f9-911d-863b0c4f5fee.png)'
- en: Let's describe our visualization.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下我们的可视化。
- en: First, we define our function as the *abstract* operation of *a + b*. This operation
    requires two values, a and b. Second, when we execute *add2 := add(2)* , we are
    binding the value 2 to the variable a. (*a* is technically a variable, but we
    treat it like a constant. Remember? Functional programming does not permit mutation.)
    Since our inner, anonymous function closes over a, the a variable's value is stored
    in the context of our closure structure and remains available for use later when
    we apply *b* and finally evaluate our *a + b* expression.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们的函数定义为 *a + b* 的*抽象*操作。此操作需要两个值，a 和 b。其次，当我们执行 *add2 := add(2)* 时，我们将值2绑定到变量
    a。 （*a* 在技术上是一个变量，但我们将其视为常量。记得吗？函数式编程不允许变异。）由于我们的内部匿名函数关闭了 a，a 变量的值存储在我们的闭包结构的上下文中，并在以后使用时仍然可用于应用
    *b* 并最终评估我们的 *a + b* 表达式。
- en: We define our add function to be of type *lambda*, that is, a function that
    accepts an int and returns an int. (Note that unlike our abstract add operation
    that requires two values, all of our functions accept only one argument and return
    only one value.) The output of our closure structure returns an expression representing
    the function definition f(b) = 2 + b.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义我们的add函数为*lambda*类型，即接受int并返回int的函数。（请注意，与我们需要两个值的抽象add操作不同，我们所有的函数都只接受一个参数并返回一个值。）我们的闭包结构的输出返回一个表示函数定义f(b)
    = 2 + b的表达式。
- en: We call our closure when we execute *three := add2(1)*, where *three* is a lambda,
    that is, it is a function that accepts an input function. That input function
    accepts an int, that is, 1 in our example. 1 is bound to the unbound terminal
    *b*. Now that we know that all of our variables are bound, that is, they all have
    values, we can evaluate our expression *2 + 1* and return the result *3:*
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行*three := add2(1)*时，我们调用我们的闭包，其中*three*是一个lambda，也就是一个接受输入函数的函数。该输入函数接受一个int，也就是我们例子中的1。1绑定到未绑定的终端*b*。现在我们知道我们所有的变量都被绑定了，也就是说它们都有值，我们可以计算我们的表达式*2
    + 1*并返回结果*3*：
- en: '![](img/bd6cdb82-a8ca-464a-9411-04388ca837b0.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd6cdb82-a8ca-464a-9411-04388ca837b0.png)'
- en: 'The following is the output:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE7]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In *step 1*, we define our `add` function. The `add` function accepts the argument
    `a` of type `int` and returns an anonymous function of type lambda.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们定义了我们的`add`函数。`add`函数接受类型为`int`的参数`a`，并返回类型为lambda的匿名函数。
- en: In *step 2*, we call our lambda function and pass the integer 2\. 2 is accepted
    as argument a. We can say that add is partially invoked in this step and that
    the value 2 stored in a is curried. What we return is a *closure*, that is, a
    function that *closes over* the a variable.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们调用我们的lambda函数并传递整数2。2被接受为参数a。我们可以说在这一步中部分调用了add，并且存储在a中的值2被柯里化。我们返回的是一个*闭包*，也就是一个*封闭*变量a的函数。
- en: In *step 3*, we pass our free variable 1 to our `add2` lambda function. This
    is where the magic happens. `add2` is a variable that contains a function with
    the curried value 2\. When we pass 1 to that lambda, it assigns 1 to the free
    argument, which next gets assigned to the *b* argument of the inner, anonymous,
    application function where our *a + b* expression is evaluated and returned.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们将自由变量1传递给我们的`add2` lambda函数。这就是魔法发生的地方。`add2`是一个包含柯里化值2的函数变量。当我们将1传递给该lambda时，它将1分配给自由参数，然后将其分配给内部的匿名应用函数的*b*参数，其中我们的*a
    + b*表达式被计算并返回。
- en: Pretty cool, huh? Go allows us to directly implement lambda expressions. Maybe
    this lambda closure application functionality will become part of Go's standard
    library one day. There's not much code here, but understanding it and then implementing
    it was challenging. However, now that we have it, we can reuse our `add2` function
    and pass it around like a variable. A variable that contains contextual data and
    logic. Sweet!
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，对吧？Go允许我们直接实现lambda表达式。也许这种lambda闭包应用功能将来会成为Go标准库的一部分。这里的代码不多，但理解它然后实现它是具有挑战性的。然而，现在我们有了它，我们可以重用我们的`add2`函数并像变量一样传递它。一个包含上下文数据和逻辑的变量。甜！
- en: Granted our example was rudimentary, but consider all the naturally scalable
    reuse and compositional capabilities that we now have in our arsenal!
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的例子很基础，但考虑一下我们现在在我们的工具库中拥有的所有自然可扩展的重用和组合能力！
- en: A Lambda calculus is like chocolate milk
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Lambda演算就像巧克力牛奶
- en: The closure is like the shot glass, chocolate syrup is like our curried variable *a.* Every
    shot glass partially filled with chocolate syrup is like our partially invoked
    lambda expression that we set aside, just waiting for the milk.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包就像小玻璃杯，巧克力糖浆就像我们的柯里化变量*a*。每个部分装满巧克力糖浆的小玻璃杯就像我们放在一边等待牛奶的部分调用lambda表达式。
- en: '![](img/93362ed5-e224-402d-86ca-394635707b45.png)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93362ed5-e224-402d-86ca-394635707b45.png)'
- en: When we add good ole' milk and stir, that's like passing the 1 and executing
    2 + 1\. The result (that is, 3) is a tasty treat called chocolate milk. For our
    lactose intolerant friends, we can take a glass of chocolate syrup (partially
    invoked function with curried chocolate syrup) and add almond milk. For our crazy
    lactose intolerant uncle, we can take another curried glass of chocolate syrup
    and add hemp milk. See, Lambda calculus isn't confusing after all; it's delicious!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加入好的牛奶并搅拌时，就像传递1并执行2 + 1。结果（即3）是一种美味的巧克力牛奶。对于我们的乳糖不耐受的朋友，我们可以拿一杯巧克力糖浆（部分调用的带有柯里化巧克力糖浆的函数）并加入杏仁奶。对于我们疯狂的乳糖不耐受的叔叔，我们可以拿另一杯柯里化的巧克力糖浆并加入大麻奶。看，Lambda演算毕竟不那么令人困惑；它很美味！
- en: Lambda examples in other languages
  id: totrans-497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他语言中的Lambda示例
- en: 'Let''s look at the same `add2` lambda function in a few other languages:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其他几种语言中看看相同的`add2` lambda函数：
- en: JavaScript
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JavaScript
- en: 'Since JavaScript is a weakly typed language, we don''t need to specify that
    the type of our *a* and *b* variables are integers:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是一种弱类型语言，我们不需要指定*a*和*b*变量的类型为整数：
- en: '[PRE8]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: JavaScript (ES6)
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JavaScript（ES6）
- en: 'ES6 provide arrow functions (also known as *fat arrow* functions) that provide
    a more concise syntax for writing function expressions. Fat arrows indicate an
    anonymous function and allow us to not type the keywords `function` and `return`:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ES6提供了箭头函数（也称为*fat arrow*函数），提供了更简洁的语法来编写函数表达式。Fat arrows表示一个匿名函数，并允许我们不输入关键字`function`和`return`：
- en: '[PRE9]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ruby
  id: totrans-505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Ruby
- en: Let's study lambda expressions in Ruby; it's quite insightful.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一下Ruby中的lambda表达式；这是非常有见地的。
- en: 'Ruby lets us define an anonymous lambda function in two ways. One uses the
    `lambda` keyword:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby让我们以两种方式定义匿名的lambda函数。一种使用`lambda`关键字：
- en: '[PRE10]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The other uses the stabby symbol:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用了刺痛符号：
- en: '[PRE11]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the IRB console, we can call the lambda expression like this:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在IRB控制台中，我们可以这样调用lambda表达式：
- en: '[PRE12]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's a lot we can do just with Ruby lambda. A Ruby lambda is a special kind
    of closure. Like Ruby blocks and procs, a Ruby lambda acts like a code snippet
    that can be passed around.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用Ruby lambda做很多事情。Ruby lambda是一种特殊的闭包。像Ruby块和procs一样，Ruby lambda就像可以传递的代码片段。
- en: 'Where do we often see lambdas used with Ruby in real world applications? Ever
    worked with Rails? Ruby on Rails is a web application framework with an **Object
    Relational Mapping** (**ORM**) library named `ActiveRecord`. Ruby classes of type
    `ActiveRecord::Base` map to database tables. We call those Ruby classes models.
    They have a method named `scope` used for retrieving rows from their associated
    tables. We can define a scope using a lambda, as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在现实世界的应用程序中经常在哪里看到Ruby与lambda一起使用？曾经使用过Rails吗？Ruby on Rails是一个Web应用程序框架，具有名为`ActiveRecord`的**对象关系映射**（**ORM**）库。类型为`ActiveRecord::Base`的Ruby类映射到数据库表。我们称这些Ruby类为模型。它们有一个名为`scope`的方法，用于从其关联的表中检索行。我们可以使用lambda定义一个作用域，如下所示：
- en: '[PRE13]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Consider seeding our tables, as follows:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对我们的表进行种子填充，如下所示：
- en: '[PRE14]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can use our `by_make` scope to retrieve only records containing Honda cars,
    as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`by_make`作用域来检索只包含Honda汽车的记录，如下所示：
- en: '[PRE15]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding, we are able to pass the key `id` value for a Honda (2) which
    the scope method passes to the lambda function.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够传递Honda（2）的关键`id`值，这个值被`scope`方法传递给lambda函数。
- en: 'In order to leverage the full power of lambda expressions in Ruby, we''ll need
    to curry our function. For example, to call our `add` function from earlier with
    one parameter like we did in the JavaScript examples, we add the `curry` method
    to create a lexical scope for our anonymous lambda function. Next, we store it
    in a variable named `add2`:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用Ruby中lambda表达式的全部功能，我们需要对我们的函数进行柯里化。例如，要像在JavaScript示例中那样使用一个参数调用我们的`add`函数，我们添加`curry`方法来创建我们匿名lambda函数的词法作用域。然后，我们将其存储在名为`add2`的变量中：
- en: '[PRE16]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The lambda provides a closure, that is, an anonymous, first class literal function
    that we store as a variable `add`. The curry adds a special ability to access
    other variables local to the scope in which that lambda was created.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: lambda提供了一个闭包，即一个匿名的、一等公民的文字函数，我们将其存储为变量`add`。柯里化为访问在创建lambda的作用域中的其他变量添加了特殊能力。
- en: 'We can call the lambda expression in the `add2` variable by executing its call
    method:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行其调用方法来调用`add2`变量中的lambda表达式：
- en: '[PRE17]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Look at the following call to the anonymous function:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 看看对匿名函数的以下调用：
- en: '[PRE18]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What is immediately obviously different between that and the following call
    to the curried function?
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 那么立即显而易见的是，这个调用与柯里化函数的调用有什么不同？
- en: '[PRE19]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Curried functions take one argument.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数接受一个参数。
- en: Why use currying instead of a regular function with multiple arguments?
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用柯里化而不是具有多个参数的常规函数？
- en: 'A: How many arguments can you pass to the *regular* function?'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: A：您可以向*常规*函数传递多少个参数？
- en: In this case it's rigidly set to two. However, if we use currying we can easily
    add more without breaking our interface. This is a powerful tool in our toolbox
    of composition. We can easily replace the pieces in our chain of function calls
    with more easily reusable functions.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它被严格设置为两个。但是，如果我们使用柯里化，我们可以轻松地添加更多而不破坏我们的接口。这是我们组合工具箱中的一个强大工具。我们可以轻松地用更容易重用的函数替换我们的函数调用链中的部分。
- en: Thus, we learned that a lambda expression is a curried, anonymous function.
    We just saw how those two concepts (anonymous and curried function) are defined
    and accessed in Ruby. In other languages, such as Go, while the syntax varies,
    the concepts remain the same.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到lambda表达式是一个柯里化的匿名函数。我们刚刚看到了这两个概念（匿名和柯里化函数）在Ruby中是如何定义和访问的。在其他语言中，例如Go，虽然语法不同，但概念是相同的。
- en: The importance of Type systems to FP
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FP对类型系统的重要性
- en: The purpose of a type system is to reduce bugs by defining the interfaces between
    the different functions in a program and verifying that those functions can be
    reliably connected. Types can be a simple as strings, ints, and booleans or can
    be a complex data structure with embedded fields and interfaces. Types can be
    checked at compile time or runtime.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统的目的是通过定义程序中不同函数之间的接口并验证这些函数可以可靠连接来减少错误。类型可以是简单的字符串、整数和布尔值，也可以是具有嵌入字段和接口的复杂数据结构。类型可以在编译时或运行时进行检查。
- en: The Lambda Calculus was originally untyped, but Alonzo Church found that that
    though it was more expressive, it caused inconsistencies. So, Church introduced
    a typed version to simplify computation. We use type systems for similar reasons,
    that is, to improve determinism and to help prevent bugs.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda演算最初是无类型的，但Alonzo Church发现，尽管它更具表现力，但会导致不一致性。因此，Church引入了一个有类型的版本来简化计算。我们出于类似的原因使用类型系统，即改进确定性并帮助防止错误。
- en: Since in FP a function is a data type, we need to define our functions' type
    for the type system.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在FP中函数是一种数据类型，我们需要为类型系统定义我们的函数类型。
- en: A type system can also increase our programs' runtime performance. Go is a statically
    compiled language, so the data types are known at compile time. This makes type
    erasure possible. So, Go does not have to require our programs to carry around
    explicit type annotations. Contrast this to languages that support Generics. Generics
    employs a process called reification that allows programmers to pass generic data
    types, along with explicit type annotations, so that called functions that need
    to know their type can make the generic data a first class citizen, that is, convert
    it to an actual data type that the program recognizes.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统还可以提高我们程序的运行时性能。Go是一种静态编译语言，因此数据类型在编译时是已知的。这使得类型擦除成为可能。因此，Go不必要求我们的程序携带显式的类型注释。与支持泛型的语言形成对比。泛型采用一种称为实体化的过程，允许程序员传递泛型数据类型，以及显式的类型注释，以便需要知道其类型的调用函数可以使泛型数据成为一等公民，即将其转换为程序识别的实际数据类型。
- en: The added complexity of reification and the performance degradation of using
    generics contradict Go's core principles of simplicity and performance.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 实体化的增加了复杂性，使用泛型会导致性能下降，这与Go的核心原则简单性和性能相矛盾。
- en: Static versus dynamic typing
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态与动态类型
- en: In Go and other statically typed languages, such as C, C++, Java, and Scala,
    the compiler will catch type mismatches at compile time. In contrast, dynamically
    typed languages such as Ruby, SmallTalk, and Python catch these type errors at
    runtime and rely more on error handling to keep our programs from crashing.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go和其他静态类型的语言（如C、C++、Java和Scala）中，编译器将在编译时捕获类型不匹配。相比之下，动态类型的语言（如Ruby、SmallTalk和Python）在运行时捕获这些类型错误，并更多地依赖错误处理来防止程序崩溃。
- en: 'In statical yet dynamic typed languages, we can easily write a function definition
    without mentioning the data types, like this:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态但动态类型的语言中，我们可以很容易地编写一个函数定义，而不提及数据类型，就像这样：
- en: '[PRE20]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works great when we pass it the correct data:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递正确的数据时，这很有效：
- en: '[PRE21]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, runtime exceptions occur when we pass types that are compatible:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们传递兼容的类型时，会发生运行时异常：
- en: '[PRE22]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Type inference
  id: totrans-549
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型推断
- en: Type inference is the process of determining the appropriate types for expressions
    based on how they are used.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是根据表达式的使用方式确定适当类型的过程。
- en: 'Go can determine that the type of the variable a in the following examples
    is `int`:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: Go可以确定以下示例中变量a的类型是`int`：
- en: '[PRE23]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Go properly infers data types in many scenarios, such as the one here:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Go在许多情况下正确推断数据类型，例如这里：
- en: '[PRE24]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the output:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE25]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, since Go does not fully implement the Hindley-Milner type system,
    Go fails to infer the type of `b` in this example:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于Go没有完全实现Hindley-Milner类型系统，Go未能推断出此示例中`b`的类型：
- en: '[PRE26]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Rather than inferring that the type of `b` is float64, Go reports the following
    compile errors:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: Go不是推断`b`的类型是float64，而是报告以下编译错误：
- en: '[PRE27]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While it's unfortunate that Go's type system implementation is not perfect,
    it is understandable why it does not fully implement the HM type system. HM supports
    polymorphic functions. Go supports neither generics or polymorphic functions,
    nor parametric polymorphism. However, polymorphic list manipulation can be achieved
    in Go using the `interface{}` for any unknown types. We can store that in a slice
    of `interface{}`, that is, `[]interface{}` and use normal slice operations (append,
    copy, shift, and so on) on the list. When we later retrieve them from the slice,
    we'll need to cast the items to their appropriate type.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Go的类型系统实现并不完美，但可以理解为什么它没有完全实现HM类型系统。HM支持多态函数。Go既不支持泛型函数，也不支持多态函数，也不支持参数多态。但是，可以使用`interface{}`来实现Go中的多态列表操作。我们可以将其存储在`interface{}`的切片中，即`[]interface{}`，并在列表上使用常规切片操作（追加、复制、移位等）。当我们稍后从切片中检索它们时，我们需要将项目转换为其适当的类型。
- en: Haskell
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Haskell
- en: Functional programming has been popularized largely as a result of Haskell (named
    after Haskell Curry), which is a programming language that was designed by a group
    of academics that are intimately familiar with the category theory. Since Haskell
    syntax is so clear and closely aligned with the original formal logical notations,
    we may see a few example in the following texts to help express category theory
    concepts.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在很大程度上因Haskell（以Haskell Curry命名）而流行，这是一种由一群熟悉范畴论的学者设计的编程语言。由于Haskell语法如此清晰，并且与原始形式逻辑符号紧密对齐，我们可能会在以下文本中看到一些例子，以帮助表达范畴论概念。
- en: Things are a bit different in Haskell than they are in Go. For example, Haskell
    variables are immutable, that is, they are not allowed to change. We use them
    only as bindings to expressions.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell中的情况与Go有些不同。例如，Haskell变量是不可变的，也就是说，它们不允许更改。我们只将它们用作表达式的绑定。
- en: 'I highly recommend learning Haskell. It''s a great, pure, functional programming
    language. Here are some good resources to get you started:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐学习Haskell。这是一种很棒的纯函数式编程语言。以下是一些帮助你入门的好资源：
- en: '[http://www.happylearnhaskelltutorial.com/](http://www.happylearnhaskelltutorial.com/)'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.happylearnhaskelltutorial.com/](http://www.happylearnhaskelltutorial.com/)'
- en: '[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters)'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters)'
- en: '[http://haskellbook.com/](http://haskellbook.com/)'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://haskellbook.com/](http://haskellbook.com/)'
- en: '[https://wiki.haskell.org/Tutorials](https://wiki.haskell.org/Tutorials)'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.haskell.org/Tutorials](https://wiki.haskell.org/Tutorials)'
- en: 'In Haskell, we don''t implement the steps in our algorithms. Instead, we declare
    what our functions do. Consider the following example:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，我们不实现算法中的步骤。相反，我们声明我们的函数做什么。考虑以下例子：
- en: The sum of a list of numbers is zero plus the sum of all the numbers
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列数字的总和是零加上所有数字的总和
- en: The product of a list of numbers is one times the product of all the numbers
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列数字的乘积是一个乘以所有数字的乘积
- en: The factorial of a number is the product of all the numbers from 1 to that number
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字的阶乘是从1到该数字的所有数字的乘积
- en: Our new list is the result of adding two to all the numbers in our original
    list of numbers
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的新列表是在我们原始数字列表中的所有数字上加2的结果
- en: In Haskell, the our functions can only calculate a value and return it. This
    feature enables referential integrity. If a function is called more than once
    with the same parameters, it's guaranteed to return the same result every time.
    This allows the compiler to reason about our program's behavior and to improve
    its performance. This feature also allows us to compose our functions together
    to build more complex functions.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中，我们的函数只能计算一个值并返回它。这个特性实现了引用完整性。如果一个函数以相同的参数被调用多次，它保证每次都返回相同的结果。这使得编译器能够推断我们程序的行为并提高其性能。这个特性还允许我们将函数组合在一起构建更复杂的函数。
- en: Haskell boils away the syntax and code ceremony that is non-essential.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell消除了非必要的语法和代码仪式。
- en: Learning a bit of Haskell will help open our minds up to the new functional
    programming paradigms that we will cover in [Chapter 10](../Text/Ch10.xhtml),
    *Monoids, and Type Classes, and Generics*.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一点Haskell将有助于我们打开心智，接触我们将在[第10章](../Text/Ch10.xhtml)中涵盖的新的函数式编程范式，*Monoids,
    and Type Classes, and Generics*。
- en: Type classes in Haskell
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Haskell中的类型类
- en: Haskell is strongly typed and fully supports the HM type type system. Haskell
    has an additional layer above what we normally think of a type. Recall that a
    type defines the structure of the data stored in a variable of that type (`string`,
    `int`, user defined struct, and so on). A type class allows us to be more specific
    and specify not only what the data is, but also how it behaves.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell是强类型的，并完全支持HM类型系统。Haskell在我们通常认为的类型之上有一个额外的层次。回想一下，类型定义了存储在该类型变量中的数据的结构（`string`，`int`，用户定义的结构等）。类型类允许我们更具体地指定数据的结构以及其行为。
- en: Type classes define the sets of operations. A particular object may be an instance
    of a class and will have a method corresponding to each operation. Type classes
    may be arranged hierarchically, forming notions of superclasses and sub classes
    and permitting inheritance of operations/methods. A default method may also be
    associated with an operation.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类定义了操作的集合。特定对象可能是类的实例，并且将具有与每个操作对应的方法。类型类可以按层次结构排列，形成超类和子类的概念，并允许继承操作/方法。默认方法也可以与操作关联。
- en: Type classes are not objects; there is no internal mutable state. Type classes
    are type-safe; any attempt to apply a method to a value whose type is not in the
    required class will be detected at compile time. In other words, methods are not
    *looked up* at runtime, but are simply passed as higher order functions.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 类型类不是对象；没有内部可变状态。类型类是类型安全的；任何尝试将方法应用于其类型不在所需类中的值的尝试都将在编译时检测到。换句话说，方法不是在运行时*查找*，而只是作为高阶函数传递。
- en: Like an interface declaration, a type class declaration defines a protocol for
    using an object, rather than defining an object itself. For example, a type is
    an instance of the Functor class if it is parameterized by another type where
    its values can be modified using the fmap function.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口声明类似，类型类声明定义了使用对象的协议，而不是定义对象本身。例如，如果类型是由另一种类型参数化的实例，则类型是Functor类的实例，其中其值可以使用fmap函数进行修改。
- en: Looking at Haskell's type class hierarchy here, we can see that a Monad is a
    Monoid, as well as an Applicative. So, we know that a Monad inherits operations
    from both.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里查看Haskell的类型类层次结构，我们可以看到Monad是Monoid，也是Applicative。因此，我们知道Monad继承了两者的操作。
- en: '![](img/d45754a8-9d77-4759-8e74-c075f70ec39b.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d45754a8-9d77-4759-8e74-c075f70ec39b.png)'
- en: 'So, we don''t need to add the int type to the argument signatures and we still
    get the type safety features to catch errors at compile time. The following defines
    a lambda function that adds 2:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要将int类型添加到参数签名中，我们仍然可以获得类型安全功能，以在编译时捕获错误。以下定义了一个将2添加的lambda函数：
- en: '[PRE28]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On the following, we''re in a Haskell REPL console, where we can enter Haskell
    commands interactively:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们在Haskell REPL控制台中，可以交互式输入Haskell命令：
- en: '![](img/6b1d6450-db25-4f5d-8a7e-477955eab5f8.png)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b1d6450-db25-4f5d-8a7e-477955eab5f8.png)'
- en: The lambda character allows us to define an anonymous function that performs
    the curry operation. We pass our lambda function to map, which is a high order
    function. Map transforms each element in our original list to a new list that
    results from adding 2 to each item in the list.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: λ字符允许我们定义一个执行curry操作的匿名函数。我们将我们的lambda函数传递给map，这是一个高阶函数。Map将原始列表中的每个元素转换为一个新列表，该列表是将列表中的每个项加2得到的结果。
- en: Domains, codomains, and morphisms
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域、共域和态射
- en: 'If we look closely, we can find ordered pairs of data all around us. Let''s
    look at some statistics of Lionel Messi. The following table shows how many goals
    Messi scored for 10 consecutive years:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，我们可以在周围找到有序对的数据。让我们看一下莱昂内尔·梅西的一些统计数据。以下表格显示了梅西连续10年进球数：
- en: '![](img/5a08f80c-2899-44e2-945e-3bf6fe3c15ce.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a08f80c-2899-44e2-945e-3bf6fe3c15ce.png)'
- en: We say that the domain is **set A:** `{2007, 2007, 2007, 2010, 2011, 2012, 2013,
    2014, 2015, 2016}` and the range (or codomain) is **set B:** `{5, 6, 7, 8, 10}`
    and that the ordered pairs are `{(2007,10), (2008, 6), (2008, 8), (2010, 5), (2011,
    8), (2012, 5), (2013, 5), (2014, 7), (2015, 6), (2016, 10)}`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说域是**集合A:** `{2007, 2007, 2007, 2010, 2011, 2012, 2013, 2014, 2015, 2016}`，范围（或共域）是**集合B:**
    `{5, 6, 7, 8, 10}`，有序对是`{(2007,10), (2008, 6), (2008, 8), (2010, 5), (2011, 8),
    (2012, 5), (2013, 5), (2014, 7), (2015, 6), (2016, 10)}`。
- en: Each year maps to a number of goals scored.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 每年都映射到进球数。
- en: If the year where x and y was calculated by calling a function named *f*, we
    could get y by calling f(x). For example, *f(2010) = 5* and *f(2016) = 10*.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果年份x和y是通过调用名为*f*的函数计算得出的，我们可以通过调用f(x)来得到y。例如，*f(2010) = 5*和*f(2016) = 10*。
- en: '![](img/e13440e5-aeb8-4706-a959-d7f49fe0cedb.png)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e13440e5-aeb8-4706-a959-d7f49fe0cedb.png)'
- en: Does the following relation make sense?
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 以下关系是否有意义？
- en: How can Messi score exactly 6 goals and exactly 7 goals and exactly 10 goals
    in the same year? That makes no sense, right? (Right!)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 梅西如何能在同一年进球数分别为6、7和10？这是毫无意义的，对吧？（对！）
- en: We can say that the relation of *{(2007, 6), (2007, 7), (2007, 10)}* which is
    defined by our arrows is not a function because it contains ordered pairs with
    the same *x* value.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说*{(2007, 6), (2007, 7), (2007, 10)}*的关系，由我们的箭头定义，不是一个函数，因为它包含具有相同*x*值的有序对。
- en: Set theory symbols
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合论符号
- en: 'Before moving forward with category theory, let''s get familiar with the symbols
    of set theory:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续类别理论之前，让我们熟悉一下集合论的符号：
- en: '| **Symbol** | **Symbol name** | **Meaning/definition** | **Example** |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **符号名称** | **含义/定义** | **示例** |'
- en: '| { } | Set | A collection of objects (also known as elements) | *A = {5,6,7,8},**B
    = {5,8,10}* |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| { } | 集合 | 对象的集合（也称为元素） | *A = {5,6,7,8},**B = {5,8,10}* |'
- en: '| &#124; | Such that | So that | *A = {x &#124; x ∈**ℝ, x<0}* |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 如此 | 以便 | *A = {x &#124; x ∈**ℝ, x<0}* |'
- en: '| A∩B | Intersection | Objects that belong to set A and set B | *A ∩ B = {5,8}*
    |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| A∩B | 交集 | 属于集合A和集合B的对象 | *A ∩ B = {5,8}* |'
- en: '| A∪B | Union | Objects that belong to set A or set B | *A ∪ B = {5,6,7,8,10}*
    |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| A∪B | 并集 | 属于集合A或集合B的对象 | *A ∪ B = {5,6,7,8,10}* |'
- en: '| A⊆B | Subset | A is a subset of B. Set A is included in set B | *{5,8,10}
    ⊆ {5,8,10}* |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| A⊆B | 子集 | A是B的子集。集合A包含在集合B中 | *{5,8,10} ⊆ {5,8,10}* |'
- en: '| A⊂B | Proper subset / Strict subset | A is a subset of B, but A is not equal
    to B | *{5,8} ⊂ {**5,8,10}* |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| A⊂B | 真子集 | A是B的子集，但A不等于B | *{5,8} ⊂ {**5,8,10}* |'
- en: '| A⊄B | Not subset | Set A is not a subset of set B | *{8,15} ⊄ {8,10,25}*
    |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| A⊄B | 非子集 | 集合A不是集合B的子集 | *{8,15} ⊄ {8,10,25}* |'
- en: '| a∈A | Element of | Set membership | *A ={5,10,15}, 5 ∈ A* |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| a∈A | 元素属于 | 集合成员 | *A ={5,10,15}, 5 ∈ A* |'
- en: '| x∉A | Not element of | No set membership | *A ={5,10,15}, 2 ∉ A* |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| x∉A | 不属于 | 不是集合成员 | *A ={5,10,15}, 2 ∉ A* |'
- en: '| (a,b) | Ordered pair | A collection of 2 elements |  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| (a,b) | 有序对 | 2个元素的集合 |  |'
- en: '| A×B | Cartesian product | A set of all ordered pairs from A and B |  |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| A×B | 笛卡尔积 | A和B的所有有序对的集合 |  |'
- en: '| &#124;A&#124; | Cardinality | The number of elements of set A | *A ={5,10,15},
    &#124;A&#124;=3* |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| &#124;A&#124; | 基数 | 集合A的元素数量 | *A ={5,10,15}, &#124;A&#124;=3* |'
- en: '| Ø | Empty set | Ø = {} | *A = Ø* |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| Ø | 空集 | Ø = {} | *A = Ø* |'
- en: '| ↦ | Maps to | f: a ↦ b means the function f maps from the element a to the
    element b | *f: a ↦ f(a)* |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| ↦ | 映射到 | f: a ↦ b表示函数f将元素a映射到元素b | *f: a ↦ f(a)* |'
- en: '| U | Universal set | set of all possible values |  |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| U | 全集 | 所有可能值的集合 |  |'
- en: '| ℕ[o] | Natural numbers / Whole numbers set (with zero) | ℕ[o] = {0, 1, 2,
    3, ...} | *0 ∈ ℕ[o]* |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| ℕ[o] | 自然数/整数集（含零） | ℕ[o] = {0, 1, 2, 3, ...} | *0 ∈ ℕ[o]* |'
- en: '| ℕ[1] | Natural numbers / Whole numbers set (without zero) | ℕ[1] = {1, 2,
    3, 4, ...} | *5 ∈ ℕ[1]* |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| ℕ[1] | 自然数/整数集（不含零） | ℕ[1] = {1, 2, 3, 4, ...} | *5 ∈ ℕ[1]* |'
- en: '| ℤ | Integer numbers set | ℤ = {... -2, -1, 0, 1, 2, ..} | *-5 ∈ ℤ* |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| ℤ | 整数集 | ℤ = {... -2, -1, 0, 1, 2, ..} | *-5 ∈ ℤ* |'
- en: '| ℝ | Real numbers set | ℝ= {x &#124; -∞ < x <∞} | *5.166667 ∈ ℝ* |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| ℝ | 实数集 | ℝ= {x &#124; -∞ < x <∞} | *5.166667 ∈ ℝ* |'
- en: 'In set theory, we look at elements in a set. For example, set **A** may have
    2 elements: `{5, 6}` and set **B** may have 3 elements: `{7, 8, 10}`. A Cartesian
    product has every possible combination of each: `{(5, 7), (5, 8), (5, 10), (6,
    7), (6, 8), (6, 10)}`.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合论中，我们看集合中的元素。例如，集合**A**可能有2个元素：`{5, 6}`，集合**B**可能有3个元素：`{7, 8, 10}`。笛卡尔积包含每个元素的所有可能组合：`{(5,
    7), (5, 8), (5, 10), (6, 7), (6, 8), (6, 10)}`。
- en: In category theory, we no longer look at elements inside sets, we only look
    at the relationships between sets. In other words, we only look at the arrows.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在范畴论中，我们不再看集合中的元素，我们只看集合之间的关系。换句话说，我们只看箭头。
- en: Category theory
  id: totrans-624
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范畴论
- en: Category theory is a branch of mathematics that deals with structure, rather
    than with particulars. It deals with the kinds of structures that make programs
    composable.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是数学的一个分支，处理的是结构，而不是细节。它处理使程序可组合的结构类型。
- en: Category theory is a branch of mathematics that is similar to Set theory. A
    basic example of a category is the category of sets, where the objects are sets
    and the arrows are functions from one set to another. Objects of a category need
    are typically sets, and arrows are typically functions. Any way of formalizing
    a mathematical concept so that it meets the basic conditions on the behavior of
    objects and arrows is a valid category.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是数学的一个分支，类似于集合论。一个基本的范畴的例子是集合的范畴，其中对象是集合，箭头是从一个集合到另一个集合的函数。范畴的对象通常是集合，箭头通常是函数。任何形式化数学概念的方式，使其满足对象和箭头行为的基本条件的方式都是有效的范畴。
- en: I could not find an easy-to-understand resource for learning category theory.
    Most of what's out there is geared toward mathematicians. Though I did take a
    good number of advanced math classes in college, I am not a practicing mathematician.
    While understanding the logical and mathematical formalism is important (and we'll
    cover the enough to be conversant), what I really wanted was something that I
    could wrap my head around. I wanted practical information. I wondered, how can
    I implement this Lambda calculus in Go? How can I build better scalable software
    using these lambdas? How can I tease apart the details and compose a better application
    from smaller, simple pieces? Can I use this new found knowledge to better architect
    my big data/data analytics project? I hope this chapter does that for you.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我找不到一个易于理解的学习范畴论的资源。大多数资源都是针对数学家的。虽然我在大学里上了很多高级数学课程，但我不是一名从业数学家。虽然理解逻辑和数学形式主义很重要（我们将涵盖足够的内容以便交谈），但我真正想要的是一些我能理解的东西。我想要实用的信息。我想知道，我怎样才能在Go中实现这个Lambda演算？我怎样才能使用这些lambda构建更好的可扩展软件？我怎样才能分解细节，并从更小、更简单的部分组合出更好的应用程序？我能否利用这些新的知识更好地设计我的大数据/数据分析项目？我希望这一章对你有所帮助。
- en: Algebra of functions
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数的代数
- en: Category theory is the abstract algebra of functions. In fact, the Lambda calculus
    is a calculus for specifying, manipulating, and calculating functions. There is
    a deep connection between Lambda calculus and category theory. We're looking at
    the same thing from two different perspectives--from the logical, syntactic way
    on the Lambda calculus side and from a more algebraic, geometric perspective from
    category theory.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是函数的抽象代数。事实上，Lambda演算是一种用于指定、操作和计算函数的演算。Lambda演算与范畴论之间有着深刻的联系。我们从Lambda演算的逻辑、语法角度和从范畴论的更代数、几何角度看到了同样的东西。
- en: Abstract functions
  id: totrans-630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抽象函数
- en: Abstract functions are any process, expression or assignment that can be read
    in a functional way. This is an abstract algebra of abstract functions.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象函数是任何可以以函数方式读取的过程、表达式或赋值。这是抽象函数的抽象代数。
- en: We'll look at set theoretical functions on sets in order to arrive at the basic
    principles of category theory.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究集合理论中的函数，以便得出范畴论的基本原理。
- en: 'We''ll look at functions on set. Given sets are **A**, **B**, and **C**. And
    a function *f* going from ***A*** to **B**:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究集合上的函数。给定的集合是**A**、**B**和**C**。以及一个从***A***到**B**的函数*f*：
- en: '*f: A -> B *'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '*f: A -> B *'
- en: Official definition of a function
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数的官方定义
- en: 'A function is a subset of Cartesian product of A and B, which is relation of
    *AxB* (*A cross B*):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是A和B的笛卡尔积的子集，这是*AxB* (*A cross B*)的关系：
- en: '*f is equal to or subset of AxB*'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '*f等于或是AxB的子集*'
- en: Here, f is a subset of pairs.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，f是对的子集。
- en: 'For all of A, there is a unique B (*b:B*) such that the subset *<a,b>* is a
    relation of that relation f:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的A，存在一个唯一的B（*b:B*），使得子集*<a,b>*是该关系f的一个关系：
- en: '*<a,b> ∈  f*'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '*<a,b> ∈  f*'
- en: Intuitive definition of a function
  id: totrans-641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数的直观定义
- en: 'In a more intuitive way, we''ll think of the function f as: *taking an element
    of set A and returning an element of set B*.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 更直观地，我们会把函数f看作：*取集合A的一个元素并返回集合B的一个元素*。
- en: Function composition with sets
  id: totrans-643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合的函数组合
- en: 'Function composition is where we take the output of one function (*f: A → B*)
    and use it as input for another (*g: B → C*). Through the law of associativity,
    we know that if *A → B → C*, then this is true: *A → C*. (We can go from A to
    B to C or we can go from A directly to C.)'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '函数组合是指我们取一个函数的输出（*f: A → B*）并将其用作另一个函数（*g: B → C*）的输入。通过结合律，我们知道如果*A → B →
    C*，那么这是真的：*A → C*。（我们可以从A到B到C，或者我们可以直接从A到C。）'
- en: '![](img/4a47ca09-1a9b-49bc-998c-93ea6ccf9830.png)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a47ca09-1a9b-49bc-998c-93ea6ccf9830.png)'
- en: Composition operation example using travel expenses
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用旅行费用的组合操作示例
- en: 'In the following composition table, we enter our budget for travelling from
    the US to Europe:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的组合表中，我们输入了从美国到欧洲旅行的预算：
- en: '![](img/5f36d0f4-d1cb-4cbc-a5dc-c5a4e96def82.png)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f36d0f4-d1cb-4cbc-a5dc-c5a4e96def82.png)'
- en: If we travel from the US to Europe, we use the **f** arrow (function) to convert
    dollars to euros. If we travel from Europe to Mexico, we use the g arrow to convert
    euros to pesos. Here, the output of function f is the input to function **g**;
    this is called function composition.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从美国去欧洲，我们使用**f**箭头（函数）将美元转换为欧元。如果我们从欧洲去墨西哥，我们使用g箭头将欧元转换为比索。这里，函数f的输出是函数**g**的输入；这称为函数组合。
- en: If we decided to not travel to and from Europe and travel directly to Mexico
    from the US, we use the gof arrow. Either way, `f($) → g(€)  → ₱` or `f(g($))
    → ₱` , we still should get the same amount of pesos for our dollar!
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定不去欧洲往返旅行，而是直接从美国去墨西哥，我们使用gof箭头。无论如何，`f($) → g(€)  → ₱` 或 `f(g($)) → ₱` ，我们仍然应该得到相同数量的比索！
- en: '![](img/ed77bf35-b1ea-4c23-ad3f-7b5abeb4c213.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed77bf35-b1ea-4c23-ad3f-7b5abeb4c213.png)'
- en: A Category
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个范畴
- en: A category is defined by its objects and the arrows that connect the objects
    and all compositions.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 类别由其对象和连接对象的箭头以及所有组合定义。
- en: For every two arrows (f and g), we must define their composition (**g** o **f**).
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每两个箭头（f和g），我们必须定义它们的组合（**g** o **f**）。
- en: 'The elements/data of a category theory include:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴理论的元素/数据包括：
- en: '**Categories**/**sets**: is a grouping of objects'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**范畴**/**集合**：是对象的分组'
- en: '**Objects**: dots/points/a primitive with no properties no structure'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：点/点/没有属性没有结构的原始'
- en: '**Morphisms**: (arrows) something that goes between two objects/elements'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**态射**：（箭头）在两个对象/元素之间的东西'
- en: We write objects with upper case letters (such as A, B, C, and so on). We write
    arrows in lower case letters (such as f, g, h, and so on).
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用大写字母（如A、B、C等）表示对象。我们用小写字母（如f、g、h等）表示箭头。
- en: Arrows have a beginning and an end. Objects in the beginning of the arrow are
    in the domain; arrows at the end arrows are in the range (also known as **codomain**).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头有起点和终点。箭头起点的对象在定义域；箭头终点的对象在值域（也称为**余值域**）。
- en: Category axioms
  id: totrans-661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范畴公理
- en: 'For each f, we have an arrow that goes from the domain of f to the codomain
    of **f**:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个f，我们有一个从f的定义域到**f**的余值域的箭头：
- en: '*f: dom(f) → cod(f)*'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '*f: dom(f) → cod(f)*'
- en: 'For each A, we have an identity arrow that goes from A to A:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个A，我们有一个从A到A的恒等箭头：
- en: '*1A: A → A*'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '*1A: A → A*'
- en: For each composable pair, *A → B → C* we have a composition operation from *A
    → C*.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一对可组合的*A → B → C*，我们有一个从*A → C*的组合操作。
- en: Category laws
  id: totrans-667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范畴定律
- en: 'The following are the category laws:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是范畴定律：
- en: '**Associativity**: *h o (g o f) = (h o g) o f*'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结合律**：*h o (g o f) = (h o g) o f*'
- en: '**Identity**: *f o 1A = f  = f o 1B*'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恒等**：*f o 1A = f  = f o 1B*'
- en: '**Unit**: Every composite is equal to itself'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单位**：每个复合等于它自己'
- en: We'll look more closely at those laws later in this chapter.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将更仔细地研究这些定律。
- en: More rules
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多规则
- en: 'Here are some more rules that apply to categories:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适用于范畴的一些规则：
- en: We can have zero or more arrows between objects.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象之间可以有零个或多个箭头。
- en: There can no more than one arrow from any object in the domain. Remember? x
    values must not be repeated.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对象的定义域中不能有多于一个箭头。记得吗？x值不能重复。
- en: We can put all compositions in a composition table (how we compose morphisms).
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以把所有的组合放在一个组合表中（我们如何组合态射）。
- en: Different compositions will give you different categories.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的组合将给出不同的范畴。
- en: Objects and arrows have no structure and no information; the composition has
    the information.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和箭头没有结构和信息；组合有信息。
- en: Category theory is based on the more general notion.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴理论是基于更一般的概念。
- en: The s value of objects and morphisms. Objects generalize types and morphisms
    generalize functions.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和态射的s值。对象概括类型，态射概括函数。
- en: A category does not take time into account.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范畴不考虑时间。
- en: There is also a spacial relationship between objects.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象之间也有一种特殊关系。
- en: When it comes to programming and computers, time is important. For example,
    if we are studying the motion of a soccer ball in flight, the ball moves in an
    three dimensional (x,y,z) space with respect to time. If we wish to know the exact
    position of the ball with respect to time, we need to take time into account in
    our calculations.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及编程和计算机时，时间很重要。例如，如果我们研究足球在飞行中的运动，球在三维（x，y，z）空间中随时间移动。如果我们希望知道球随时间的确切位置，我们需要在计算中考虑时间。
- en: More examples
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多例子
- en: Here're a few examples to help get a better intuition about what a category
    is, what it means to be a category, what things are required, and what rules must
    be obeyed.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子，以帮助更好地理解什么是一个范畴，成为一个范畴意味着什么，需要什么东西，以及必须遵守什么规则。
- en: Invalid categories
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无效的范畴
- en: Here, we have two valid categories. The first one is of a car. The objects include
    the car itself, the car's model name, and the car's age. We show two identity
    morphisms. One arrow goes from a car to itself (upgrade a car and it's another
    car). The other arrow goes from the integer object to itself (the "++" operator
    means add one to the current value). We left off the arrow from the model name
    to itself, but it exists (a name is a name):=
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个有效的范畴。第一个是汽车的范畴。对象包括汽车本身、汽车的型号名称和汽车的年龄。我们展示了两个恒等态射。一个箭头从汽车指向自身（升级一辆车后它是另一辆车）。另一个箭头从整数对象指向自身（“++”运算符表示将当前值加一）。我们省略了从型号名称指向自身的箭头，但它是存在的（名字就是名字）：=
- en: '![](img/a6ac962d-0694-441e-98c5-1e1bc6df014b.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6ac962d-0694-441e-98c5-1e1bc6df014b.png)'
- en: Why is this invalid? It looks like it composes, but does it really?
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是无效的？看起来像是组合，但真的吗？
- en: The next example should be a bit more obvious. (Funny, but obviously not a category.)
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子应该更明显一些。（有趣，但显然不是一个范畴。）
- en: '![](img/5d5a6493-a646-4f48-8261-17fa621c07d5.png)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d5a6493-a646-4f48-8261-17fa621c07d5.png)'
- en: There's a link from the Favorite's page (A) to the link on the Reddit home page
    (B), and one from there to the image (C), but not one from the Favorite's page
    (A) to the image (C).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个从收藏夹页面（A）到Reddit主页上的链接（B），还有一个从那里到图片（C），但没有从收藏夹页面（A）到图片（C）的链接。
- en: Morphisms
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 态射
- en: A morphism is an arrow from one object (A, B, C in our example) in a category
    (our grouping of A, B, C). There can be more than one arrow from A to B (or from
    B to C, or A to C). Also, arrows can go from any object to itself; this is called
    the identity morphism.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 态射是范畴中一个对象（我们的例子中的A、B、C）到另一个对象的箭头。从A到B（或从B到C，或从A到C）可能有不止一个箭头。箭头也可以从任何对象指向自身；这被称为恒等态射。
- en: '![](img/135cce5f-678e-4afe-970a-ad9a309dcbf2.png)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![](img/135cce5f-678e-4afe-970a-ad9a309dcbf2.png)'
- en: f:A→B statement is a morphism (f) from A to B
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: f:A→B语句是从A到B的态射（f）
- en: Hom(A,B) is the collection of all arrows from A to B
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hom(A,B)是从A到B的所有箭头的集合
- en: Hom(A,B) is also known as the Hom-Set of A to B
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hom(A,B)也被称为A到B的Hom-Set
- en: idA:A→A is a morphism from A to A
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: idA:A→A是从A到A的态射
- en: The behaviors of morphisms
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 态射的行为
- en: Let's look at at a couple things we can do with morphisms. W can compose them
    and run the identity morphism to verify an object's identity.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用态射做些什么。我们可以组合它们并运行恒等态射来验证对象的身份。
- en: Composition operation
  id: totrans-703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 组合操作
- en: Below, is our basic composition operation.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的基本组合操作。
- en: '![](img/c00c08cc-ac82-4fb7-b920-bf841aa54bf8.png)'
  id: totrans-705
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c00c08cc-ac82-4fb7-b920-bf841aa54bf8.png)'
- en: 'The composition operation is *g o f,* *g after f *applies arg x (from **A**)
    to give us g applied to f applied to *x*: *(g o f)(x) = g(f(x)).*'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作是*g o f,* *g after f*将参数x（来自**A**）应用到g应用到f应用到*x*上：*(g o f)(x) = g(f(x))。*
- en: If *f(g(x)) = g(f(x))* for all *x*, then we can say that **f** and **g** commute
    under composition.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于所有*x*，*f(g(x)) = g(f(x))*，那么我们可以说**f**和**g**在组合下是可交换的。
- en: However, that's not typical. Function composition is generally not commutative.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不典型。函数组合通常不是可交换的。
- en: 'Let''s take an example. Remember when we composed *f(x) = x + 2* with *g(x)
    = x2 + 1* earlier in the chapter? We solved *g(f(1)) = 10*, but what about *f(g(1))*?
    Does that also equal 10? Let''s see now:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子。还记得我们在本章前面将*f(x) = x + 2*和*g(x) = x2 + 1*组合在一起吗？我们解出了*g(f(1)) = 10*，但*f(g(1))*呢？那也等于10吗？现在让我们看一下：
- en: '*g(1) = 1² + 1 = 2*  and *f(2) = 4*'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '*g(1) = 1² + 1 = 2*和*f(2) = 4*'
- en: 'So, no, our functions f and g are not associative: *g(f(1)) != f(g(1))*.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不，我们的函数f和g不是可结合的：*g(f(1)) != f(g(1))*。
- en: Identity operation
  id: totrans-712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 恒等操作
- en: Identity law of our category says the identity morphism of A is A.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的范畴的恒等律说A的恒等态射是A。
- en: '![](img/31746fff-0c56-4b8d-86f5-6c20a024716b.png)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31746fff-0c56-4b8d-86f5-6c20a024716b.png)'
- en: Every object has a morphism pointing back to itself.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个指向自身的态射。
- en: When we have more than one object, we denote which ID we're talking about with
    a subscript, for example, **idA**.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个对象时，我们用下标来表示我们正在谈论哪个ID，例如**idA**。
- en: '![](img/cf1de571-5404-4247-892e-05a9839dfecb.png)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf1de571-5404-4247-892e-05a9839dfecb.png)'
- en: This graph says *f o idA  = f*.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图说的是*f o idA  = f*。
- en: 'In other words, the morphism of **f** after **idA** is the same as the morphism
    of **f**. Here''s a concrete example:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，**idA**之后的**f**的态射与**f**的态射相同。这里有一个具体的例子：
- en: '![](img/4e7c29f9-e39a-4762-a3c8-c13a2de591ef.png)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e7c29f9-e39a-4762-a3c8-c13a2de591ef.png)'
- en: The identity morphism for the natural number 3 is a function that multiplies
    any number by
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 自然数3的恒等态射是一个将任何数乘以
- en: '![](img/ce4eb718-cc2a-43fb-b69e-adac25484348.png)'
  id: totrans-722
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce4eb718-cc2a-43fb-b69e-adac25484348.png)'
- en: 'There is a symmetric identity morphism: *idA o g = g  *'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个对称的恒等态射：*idA o g = g  *
- en: Law of associativity
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合律
- en: In the following diagram, we see that we can get from A to C by way of the *g
    o f* composition.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，我们看到我们可以通过*g o f*组合从A到C。
- en: From **C**, we can get to **D** using the **h** arrow, which we can write as *ho(gof)*.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 从**C**，我们可以使用**h**箭头到达**D**，我们可以写成*ho(gof)*。
- en: Note that this is the same as **h(f(g))**. This notation seems more intuitive
    than using the composition operation, but they mean the same thing.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这与**h(f(g))**相同。这种表示法似乎比使用组合操作更直观，但它们的意思是一样的。
- en: '![](img/f4af522e-e395-47c1-b6aa-cf7a5855bca3.png)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4af522e-e395-47c1-b6aa-cf7a5855bca3.png)'
- en: From the following diagram, we see that **ho(gof)** is the same as **(hog)of**.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 从下面的图中，我们看到**ho(gof)**和**(hog)of**是相同的。
- en: 'So, our category obeys the law of associativity. The next diagram is another
    illustration of the associativity of composition:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的范畴遵守结合律。下一个图是组合的结合性的另一个例证：
- en: '![](img/e8ef1f15-6cce-47ca-9a7b-f4f0c68ce59c.png)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8ef1f15-6cce-47ca-9a7b-f4f0c68ce59c.png)'
- en: That diagram says that if the arrows exist from A→B→C→D, then if we start at
    A, we can use composition of functions to shortcut a set either by choosing the
    red path **ho(gof)** or the green path **(hog)of**.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图说的是，如果从A→B→C→D存在箭头，那么如果我们从A开始，我们可以使用函数的组合来通过选择红色路径**ho(gof)**或绿色路径**(hog)of**来捷径到达集合。
- en: Associativity helps us manage complexity. It is the basis for composition.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性有助于我们管理复杂性。它是组合的基础。
- en: Only concerned with morphisms
  id: totrans-734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 只关注态射
- en: In a category theory, we only have objects and arrows between them.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 在范畴论中，我们只有对象和它们之间的箭头。
- en: We can compose functions by applying a function to an argument to get a result.
    Then, we apply another function to the result and so on, until we end up where
    we started.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将函数应用于参数来组合函数以获得结果。然后，我们将另一个函数应用于结果，依此类推，直到我们回到起点。
- en: We put all of our compositions in a table and only concern ourselves with the
    morphisms. It is the morphisms that define the interface for our application.
    What's important is how objects are connected/mapped.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有的组合放在一个表中，并且只关注态射。正是态射为我们的应用程序定义了接口。重要的是对象如何连接/映射。
- en: Interface-driven development
  id: totrans-738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于接口的开发
- en: One concept of the category theory that we can use when we develop software
    is that our design should be concerned only with interfaces, that is, the arrows/morphisms.
    We have seen the theme of composition repeated throughout this book. From Mozart
    compositions to function compositions with linear and quadratic functions, and
    later with finite state machines. We've seen that the way to solve complex problems
    is to break them apart into understandable pieces. We can then reach into our
    toolbox of pieces and compose elegant, reliable solutions. We design our **application
    programming interfaces** (**APIs**) to connect our pieces and can leverage concurrent
    programming constructs and concurrency-aware frameworks to arrange how the pieces
    work together to arrive at our desired result.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论的一个概念是，当我们开发软件时，我们的设计应该只关注接口，即箭头/态射。我们已经在本书中反复看到了组合的主题。从莫扎特的作品到线性和二次函数的函数组合，以及后来的有限状态机。我们已经看到了解决复杂问题的方法是将其分解为可理解的部分。然后，我们可以从我们的部件工具箱中取出部件并组合出优雅、可靠的解决方案。我们设计我们的**应用程序编程接口**（**API**）来连接我们的部件，并且可以利用并发编程构造和并发感知框架来安排这些部件如何一起工作以达到我们想要的结果。
- en: Design the architecture, name the components, document the details. Clear is
    better than clever. Don't communicate by sharing memory; share memory by communicating.
    Channels orchestrate; mutexes serialize. The bigger the interface, the weaker
    the abstraction.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 设计架构，命名组件，记录细节。清晰比聪明更好。不要通过共享内存进行通信；通过通信共享内存。通道编排；互斥串行化。接口越大，抽象越弱。
- en: For more Go proverbs, visit: [https://www.youtube.com/watch?v=PAAkCSZUG1c](https://www.youtube.com/watch?v=PAAkCSZUG1c),
    and for *Concurrency Is Not Parallelism, *visit: [https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多Go格言，请访问：[https://www.youtube.com/watch?v=PAAkCSZUG1c](https://www.youtube.com/watch?v=PAAkCSZUG1c)，以及有关*并发不等于并行*，请访问：[https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso)。
- en: More morphisms
  id: totrans-742
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多态射
- en: The example below shows two identity morphisms and a morphism from A to B.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了两个恒等态射和从A到B的态射。
- en: '![](img/23f024a7-63fc-4025-98a4-01c54136f217.png)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23f024a7-63fc-4025-98a4-01c54136f217.png)'
- en: If we take A and any f to B and the Identity on **A (1A)**, then this composite
    f after the identity on A (**f** o **1A**) is equal to f.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取A和任何f到B和**A (1A)**上的恒等物，则在A上的恒等物之后的复合f (**f** o **1A**)等于f。
- en: 'Here''s another way to look at it:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种看待它的方式：
- en: '![](img/6aff6f48-45d1-4bec-9b47-fa5e771a672b.png)'
  id: totrans-747
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6aff6f48-45d1-4bec-9b47-fa5e771a672b.png)'
- en: If we take **A** and any **f** and we take the identity on **A**, then this
    composite **f** after the identity on **A** is equal to **f**.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取**A**和任何**f**，并且我们取**A**上的恒等物，那么这个复合**f**在**A**上的恒等物之后等于**f**。
- en: 'Here''s the morphism f from A to B:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从A到B的态射f：
- en: '![](img/fb4c84db-0473-47b9-a902-db6132f6dc9d.png)'
  id: totrans-750
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb4c84db-0473-47b9-a902-db6132f6dc9d.png)'
- en: 'And here''s a concrete example:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具体的例子：
- en: '![](img/80334cbc-eb56-427b-a5ef-45d03bc822fc.png)'
  id: totrans-752
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80334cbc-eb56-427b-a5ef-45d03bc822fc.png)'
- en: The identity axiom says that if there is an arrow f from the identity of **A**
    to **B** and there is an arrow f from the identity of **B** to **B**, then the
    arrow from **A** to **B** is the same arrow **f**.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 恒等公理表明，如果有一个从**A**的恒等物到**B**的箭头f，以及一个从**B**的恒等物到**B**的箭头f，那么从**A**到**B**的箭头就是相同的箭头**f**。
- en: '![](img/b4541002-bc1f-4737-8b81-9e5ebdcac7cf.png)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4541002-bc1f-4737-8b81-9e5ebdcac7cf.png)'
- en: The associativity axiom says that the composition of arrows is associative,
    which is another way of saying the diagram is commutative.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性公理表明箭头的组合是可结合的，这又是说图表是可交换的另一种方式。
- en: '![](img/bc412540-f44d-440d-8d2e-2c7edfdc8bf3.png)'
  id: totrans-756
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc412540-f44d-440d-8d2e-2c7edfdc8bf3.png)'
- en: Therefore, for all arrows, 𝑓 ∶ 𝑎 → 𝑏, 𝑔 ∶ 𝑏 → 𝑐, and h ∶ 𝑐 → 𝑑, *h* ∘ 𝑔 ∘ 𝑓
    denotes *h* ∘ (𝑔 ∘ 𝑓).
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于所有的箭头，𝑓 ∶ 𝑎 → 𝑏, 𝑔 ∶ 𝑏 → 𝑐, 和 h ∶ 𝑐 → 𝑑, *h* ∘ 𝑔 ∘ 𝑓 表示 *h* ∘ (𝑔 ∘ 𝑓)。
- en: 'And it follows the this is true: h∘(𝑔∘𝑓) = h∘𝑔∘𝑓 = (h∘𝑔)∘𝑓.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它遵循这个真理：h∘(𝑔∘𝑓) = h∘𝑔∘𝑓 = (h∘𝑔)∘𝑓。
- en: A review of Category theory
  id: totrans-759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范畴论回顾
- en: Category theory is about composing functions.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论是关于组合函数的。
- en: '*A, B, C  = type = algebras/mathematical structure(homomorphisms)*'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '*A, B, C  = 类型 = 代数/数学结构（同态）*'
- en: Note that we no longer concern ourselves with the objects/elements inside the
    sets (only the arrows).
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再关心集合中的对象/元素（只关注箭头）。
- en: '*f = function = arrow that goes between objects (and maintains algebraic structure)*'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '*f = 函数 = 在对象之间移动并保持代数结构的箭头*'
- en: The **f** variable is a function that accepts arguments of type A and can, for
    example, return objects of type B.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '**f**变量是一个接受类型A的参数的函数，例如可以返回类型B的对象。'
- en: '**Identity arrow** (**idA**) goes from A to A and does nothing. **f;g** (*composition*
    of 1 arrow after another) is a function that accepts arguments of type A and B,
    and returns C.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '**恒等箭头** (**idA**) 从A到A并且什么也不做。**f;g**（1箭头之后的*组合*）是一个接受类型A和B的参数并返回C的函数。'
- en: '*idA;f  = f; idB  = f*'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '*idA;f  = f; idB  = f*'
- en: There are three ways to compose two things: *(f;g);h = f;(g;h)*.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种组合两个事物的方式：*(f;g);h = f;(g;h)*。
- en: '*C (category C) = set* of all arrows in Category from A to C is in C.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '*C (范畴C) = 集合* 范畴中从A到C的所有箭头在C中。'
- en: Even more correspondence
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多对应
- en: Remember the filter types (Read, Split, Transform, Merge, and Write) from our
    flow-based programming discussion in [Chapter 6](../Text/Ch06.xhtml), *Building
    on an Onion Architecture* (i*ncrease performance with pipelining*)? Let's see
    how flow-based programming corresponds to category theory, logic, and types.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在[第6章](../Text/Ch06.xhtml)中关于基于流的编程讨论中提到的过滤器类型（读取、拆分、转换、合并和写入）吗？让我们看看基于流的编程如何与范畴理论、逻辑和类型相关联。
- en: Logic has and, or, and implication operations
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑有和、或和蕴涵操作
- en: Programming has data records and function operations
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程中有数据记录和函数操作
- en: Flow-based programming has merge, split, and transform operations
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于流的编程有合并、拆分和转换操作
- en: '![](img/dd10fefd-97eb-44ef-9062-69e8a396270c.png)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/dd10fefd-97eb-44ef-9062-69e8a396270c.png)
- en: Category theory has arrows that are functions (that can also be data).
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴理论中的箭头是函数（也可以是数据）。
- en: Just like a proposition in logic can be true or false, a type can be either
    inhabited or not. True propositions are inhabited. The void type is false. If
    we can produce an element of a type, then we have proven our proposition.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 就像逻辑中的命题可以是真或假一样，类型可以是有人居住的或没有。真命题是有人居住的。空类型是假的。如果我们可以产生一个类型的元素，那么我们已经证明了我们的命题。
- en: Table of morphisms
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 态射表
- en: 'The following table summarizes our basic operations, as well as our initial
    and terminal states:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们的基本操作，以及我们的初始和终端状态：
- en: '![](img/edad6217-bd3b-4f71-8daf-7d1a34def666.png)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/edad6217-bd3b-4f71-8daf-7d1a34def666.png)
- en: Morphism examples
  id: totrans-780
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 态射示例
- en: 'The *a → b* statement says that if we provide an element a to our function,
    then our function will produce an element of b. The same goes for logical implication:
    if a is true then b is true.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '*a → b*语句表示，如果我们向函数提供元素a，那么我们的函数将产生元素b。逻辑蕴涵也是一样的：如果a为真，则b为真。'
- en: If we have a function type *a ⇒ b* and pair it with an element of *a*, we get
    an element of b.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个函数类型*a ⇒ b*并将其与*a*的元素配对，我们得到*b*的元素。
- en: Modens ponens
  id: totrans-783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Modens ponens
- en: In Latin, modens ponens means, "the mode of affirming".
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在拉丁语中，modens ponens的意思是“肯定的方式”。
- en: Type theory version
  id: totrans-785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型理论版本
- en: '*((a ⇒ b), a) → b* says that if we have function (a ⇒ b) and an argument a,
    it will produce b.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*((a ⇒ b), a) → b*表示如果我们有函数（a ⇒ b）和参数a，它将产生b。'
- en: Logic version
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逻辑版本
- en: If we know b follows from a and that a is true, then you can prove b.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道b是由a得出的，并且a为真，那么你可以证明b。
- en: '*a ⇒ b ∧ a → b*'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '*a ⇒ b ∧ a → b*'
- en: This is called Modens ponens also known as an implication.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为Modens ponens，也是一种蕴涵。
- en: Correspondence between logic and type theory
  id: totrans-791
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑和类型理论之间的对应关系
- en: Do you see the one-to-one correspondence between logic and type theory?
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到逻辑和类型理论之间的一一对应了吗？
- en: Add the category theory correspondence and we get the Curry Howard Lambek correspondence.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 加上范畴理论的对应关系，我们得到了Curry Howard Lambek对应。
- en: Cartesian closed category
  id: totrans-794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 笛卡尔闭范畴
- en: A cartesian closed category, where a product exists for any two elements and
    an exponential exists for any two elements, is a model for logic and type theory.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔闭范畴，其中任意两个元素都有积存在，任意两个元素都有指数存在，是逻辑和类型理论的模型。
- en: Though many categories have products and sums, only a few have map objects.
    Such categories are called cartesian closed categories.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多范畴都有积和和，但只有少数有映射对象。这样的范畴被称为笛卡尔闭范畴。
- en: There is a deep connection between λ-calculus, logic, and cartesian closed categories.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: λ演算、逻辑和笛卡尔闭范畴之间有着深刻的联系。
- en: 'A **cartesian closed category** (**CCC**) is an abstraction having a small
    vocabulary with associated laws:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '**笛卡尔闭范畴**（CCC）是一个具有小词汇量和相关法则的抽象：'
- en: The *category* part means we have a notion of *morphisms* each having a domain
    and codomain object. There is an identity morphism for and associative composition
    operator.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '*范畴*部分意味着我们有一个*态射*的概念，每个态射都有一个定义域和值域对象。有一个恒等态射和一个关联的组合运算符。'
- en: The *cartesian* part means that we have products, with projection functions
    and an operator (`fst` or `snd` in Haskell) to combine two functions into a pair-producing
    function
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '*笛卡尔*部分意味着我们有积，带有投影函数和一个操作符（在Haskell中为`fst`或`snd`）将两个函数组合成一个产生对的函数'
- en: The *closed* part means that we have a way to represent morphisms via objects,
    referred to as *exponentials*.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭*部分意味着我们有一种通过对象表示态射的方法，称为*指数*。'
- en: The corresponding operations are curry and apply. These exponential objects
    are first class functions.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的操作是curry和apply。这些指数对象是头等函数。
- en: Lambda expressions can be systematically translated into the CCC vocabulary.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以系统地转换为CCC词汇。
- en: A *CCC* is a category that is closed with respect to both products and exponentials.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '*CCC*是一个对于积和指数都是闭的范畴。'
- en: 'This is what it looks like in terms of products and sums of objects:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于对象的积和和的样子：
- en: '[PRE29]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See the correspondence to the following distributive law?
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下分配律的对应关系？
- en: '*(a ∨ b) ∧ c = (a ∧c) ∨ (b ∧ c)*'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '*(a ∨ b) ∧ c = (a ∧c) ∨ (b ∧ c)*'
- en: The objects in a CCC represent the types of the language, for example, strings,
    integers, and floats. The morphisms represent computable functions, for example,
    length(string). Exponential objects allow us to consider computable functions
    as the input to other functions.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: CCC中的对象代表语言的类型，例如字符串、整数和浮点数。态射代表可计算的函数，例如，length(string)。指数对象允许我们将可计算的函数作为其他函数的输入考虑。
- en: Joachim Lambek discovered that the models of the simply typed λ-calculus (STLC) are
    exactly the cartesian closed categories (CCCs).
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: Joachim Lambek发现，简单类型λ演算（STLC）的模型恰好是笛卡尔闭范畴（CCCs）。
- en: The generic type mechanism in Java is based on the generic type systems that
    originated in Lambda calculus. In fact, Java uses the Hindley-Milner Lambda calculus
    type inference, which is based on CCC.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的通用类型机制是基于Lambda演算起源的通用类型系统。事实上，Java使用基于CCC的Hindley-Milner Lambda演算类型推断。
- en: We will revisit the topic of CCCs when we cover Mondads in a later chapter.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在后面的章节中讨论Mondads时，我们将重新讨论CCCs的主题。
- en: Unit type
  id: totrans-813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元类型
- en: A tuple is a list of items that are ordered and immutable. You can select an
    element based on its position.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个有序且不可变的项目列表。您可以根据其位置选择一个元素。
- en: A unit type has exactly a one value. It is also known as the identity. The unit
    for multiplication is 1, for addition is 0, and for string concatenation, it is
    the empty string.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 单位类型确切地有一个值。它也被称为身份。乘法的单位是1，加法的单位是0，字符串连接的单位是空字符串。
- en: How many values can a type defined as a tuple of type `int` contain? Infinite
    (-∞, …, 0, 1, 2... ∞).
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 作为int类型的元组定义的类型可以包含多少个值？无限（-∞，…，0，1，2... ∞）。
- en: How many values can a type defined as the empty tuple contain? One. The *unit*
    is also represented as `()` in Haskell.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 作为空元组定义的类型可以包含多少个值？一个。在Haskell中，*unit*也表示为`()`。
- en: The value of a unit type is that you can use it in places where we might otherwise
    return nil (or null). We return a unit when we don't care what the value is. We
    don't return nil, we return a value; the unit value. All functions return values;
    no more null pointer exceptions! Now, we can chain functions and never worry that
    one on the middle with throw a null pointer exception and crash our program.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 单位类型的值在于，您可以在我们可能返回nil（或null）的地方使用它。当我们不关心值是什么时，我们返回一个单位。我们不返回nil，我们返回一个值；单位值。所有函数都返回值；不再有空指针异常！现在，我们可以链接函数，而不必担心中间的函数会抛出空指针异常并使我们的程序崩溃。
- en: Homomorphism
  id: totrans-819
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同态
- en: 'Here''s a Venn diagram depicting how the different categories of homomorphisms
    relate to one another:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个描述同态关系不同类别之间关系的文氏图：
- en: '![](img/040b0267-99d7-46a0-89bd-6027ed1141fb.png)'
  id: totrans-821
  prefs: []
  type: TYPE_IMG
  zh: '![](img/040b0267-99d7-46a0-89bd-6027ed1141fb.png)'
- en: '| **Abbreviation** | **Description** |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '| **缩写** | **描述** |'
- en: '| Mono | Set of monomorphisms (injective) |'
  id: totrans-823
  prefs: []
  type: TYPE_TB
  zh: '| Mono | 单态集（单射） |'
- en: '| Epi | Set of epimorphism (surjective) |'
  id: totrans-824
  prefs: []
  type: TYPE_TB
  zh: '| Epi | 满射集（满射） |'
- en: '| Iso | Set of isomorphisms (bijective) |'
  id: totrans-825
  prefs: []
  type: TYPE_TB
  zh: '| Iso | 同构集（双射） |'
- en: '| Auto | Set of automorphisms (bijective and endomorphic) |'
  id: totrans-826
  prefs: []
  type: TYPE_TB
  zh: '| Auto | 自同构集（双射和自同态） |'
- en: A homomorphism is a correspondence between set A (the domain) and set B (the
    codomain or range), so that each object in A determines a unique object in B and
    each object in B has an arrow/function/morphism pointing to it from A.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 同态是集合A（定义域）和集合B（余域或值域）之间的对应关系，以便A中的每个对象确定B中的唯一对象，并且B中的每个对象都有一个从A指向它的箭头/函数/态射。
- en: If operations, for example, addition and multiplication, are defined for A and
    B, it is required that they correspond. That is, *a * b* must correspond to *f(a)
    * f(b)*.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对A和B定义了操作，例如加法和乘法，则它们必须对应。也就是说，*a * b*必须对应于*f(a) * f(b)*。
- en: Homomorphisms preserve correspondence
  id: totrans-829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态保持对应关系
- en: 'Correspondence must be as follows:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 对应关系必须如下：
- en: '**Single-valued**: The morphism must at least be a partial function'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单值**：态射至少是一个偏函数'
- en: '**Surjective**: Each a in A has at least one f(a) in B'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满射：A中的每个a至少有一个B中的f(a)
- en: 'Homomorphism is a way to compare two groups for structural similarities. It''s
    a function between two groups that preserve their structure. Suppose we have two
    groups, G and H. G and H have different group operations. Let''s also suppose
    that **G** has the group operation ☆ and H has the group operation (heart). Given
    any two elements in *G: a, b ∈ G*. And let''s suppose  a ☆ b = c. We also have
    a function f that maps **G** to *H: f: G→ H*. The elements a, b, and c are mapped
    to elements in H. The a variable maps to f(a), b maps to f(b), and c maps to f(c):'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 同态是一种比较两个群的结构相似性的方法。它是两个群之间保持它们的结构的函数。假设我们有两个群，G和H。G和H有不同的群操作。我们也假设G有群操作☆，H有群操作（心）。假设在G中有任意两个元素a，b∈G。我们还有一个将G映射到H的函数f：G→H。元素a，b和c被映射到H中的元素。变量a映射到f(a)，b映射到f(b)，c映射到f(c)：
- en: '*f: a ↦ f(a)*'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f：a ↦ f(a)*'
- en: '*f: b ↦ f(b)*'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f：b ↦ f(b)*'
- en: '*f: c ↦ f(c)*'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f：c ↦ f(c)*'
- en: The purpose of homomorphism is to find the structural similarities between two
    groups.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 同态的目的是找到两个群之间的结构相似性。
- en: So, if in G, a ☆ b = c, then we like f(a) (heart) f(b) = f(c) in the group H.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果在G中，a ☆ b = c，那么我们喜欢f(a)（心）f(b) = f(c)在群H中。
- en: 'a ☆ b = c  ⇒ f(a) (heart) f(b) = f(c) and since a ☆ b = c, we can substitute
    to get the definition of a homomorphism:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: a ☆ b = c ⇒ f(a)（心）f(b) = f(c)并且由于a ☆ b = c，我们可以替换以获得同态的定义：
- en: f(a) (heart) f(b) = f(a ☆ b)
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: f(a)（心）f(b) = f(a ☆ b)
- en: There's a way to compare two groups.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法来比较两个群。
- en: Let's look at an example. G is a group of real numbers (ℝ) with a group operator
    of addition (+) and identity operator 0, and H is a group of real numbers (ℝ)
    with a group operator of multiplication (*) and identity operator 1.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。G是一个实数（ℝ）的群，具有加法（+）和单位运算符0，H是一个实数（ℝ）的群，具有乘法（*）和单位运算符1。
- en: We can define the homomorphism that maps elements of G to H that maps element
    *a* to *ea*.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义将G的元素映射到H的同态，将元素a映射到ea。
- en: 'f: G ↦ H'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: f：G ↦ H
- en: a ↦ ea
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: a ↦ ea
- en: Let’s ensure that this is a homomorphism by verifying that f(a + b) = f(a) *
    f(b).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过验证f(a + b) = f(a) * f(b)来确保这是一个同态。
- en: 'By the definition of f given above, this says that:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上面给出的f的定义，这表示：
- en: '*ea + b = ea * ea*'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: '*ea + b = ea * ea*'
- en: This is true. It is a rule of exponents. So, f is a homomorphism.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的。这是指数的规则。所以，f是一个同态。
- en: Homomorphic encryption
  id: totrans-850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态加密
- en: 'Homomorphic encryption allows operations to be performed on ciphertexts without
    the knowledge of corresponding plaintexts:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 同态加密允许在不知道相应明文的情况下对密文执行操作：
- en: '`EncryptFcn(a) (heart) EncryptFcn(b) = EncryptFcn(a ☆ b)`'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '`EncryptFcn(a) (heart) EncryptFcn(b) = EncryptFcn(a ☆ b)`'
- en: An example of homomorphic encryption
  id: totrans-853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 同态加密的一个例子
- en: Alice downloads a snippet of music she likes from an untrusted source and wants
    to use it to find the name of the song.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: Alice从一个不受信任的来源下载了她喜欢的音乐片段，并希望用它来找到歌曲的名称。
- en: Bob has a song recognition capability and could identify the song for Alice.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: Bob有歌曲识别能力，可以为Alice识别歌曲。
- en: '![](img/7f35c02e-f1fa-47a8-aea2-65a139641f39.png)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f35c02e-f1fa-47a8-aea2-65a139641f39.png)'
- en: The problem is that Alice and Bob do not trust each other.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，Alice和Bob彼此不信任。
- en: Alice fears that if she gives Bob her snippet of music, Bob might turn her into
    the authorities. Bob could give Alice his music catalog but fears that she may
    sell it to his competitors.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: Alice担心如果她把她的音乐片段给Bob，Bob可能会把她交给当局。Bob可以把他的音乐目录给Alice，但担心她可能会把它卖给他的竞争对手。
- en: The solution is for Alice to encrypt her music snippet and send that to Bob.
    Bob could find the encrypted result and send that back to Alice to decrypt.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是Alice加密她的音乐片段并将其发送给Bob。Bob可以找到加密结果并将其发送回Alice进行解密。
- en: Lesson learned
  id: totrans-860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 教训
- en: We can perform complex collaborative operations without revealing private information
    through the use of cryptography and category theory.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用密码学和范畴论，我们可以进行复杂的协作操作，而不会泄露私人信息。
- en: Isomorphism
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同构
- en: Sometimes, groups are more than just similar. If they are identical, they are
    isomorphic. Isomorphism is comprised of two Greek words that mean equal and form.
    In mathematics, isomorphism is a perfect one-to-one, bijective mapping between
    two groups (structures or sets). Every object in group A maps directly to an object
    in group B.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，群不仅仅是相似的。如果它们是相同的，它们就是同构的。同构由两个希腊词组成，意思是相等和形式。在数学中，同构是两个群（结构或集合）之间的完美一对一，双射映射。群A中的每个对象都直接映射到群B中的一个对象。
- en: '![](img/9c7bccfb-c779-49ee-8b74-ef8456d4ad27.png)'
  id: totrans-864
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c7bccfb-c779-49ee-8b74-ef8456d4ad27.png)'
- en: 'In an isomorphism, every object in A is mapped to an object in B. The morphisms
    are also injective because no two objects from A map to the same object in B.
    So, if the objects in A are x, y, and z, then the following are not possible:
    `f(x) = f(y), f(x) = f(z), f(y) = f(z`). The only mappings we find are `x -> f(x),
    y -> f(y)`, and `z -> f(z)` and none of those three values are the same.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 在同构中，A中的每个对象都映射到B中的一个对象。态射也是单射的，因为A中没有两个对象映射到B中的同一个对象。因此，如果A中的对象是x、y和z，则以下情况是不可能的：`f(x)
    = f(y), f(x) = f(z), f(y) = f(z`。我们发现的唯一映射是`x -> f(x), y -> f(y)`和`z -> f(z)`，这三个值都不相同。
- en: '![](img/5ca714ed-2a7f-4b8f-8901-90e60e05d3f6.png)'
  id: totrans-866
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ca714ed-2a7f-4b8f-8901-90e60e05d3f6.png)'
- en: This morphism is also surjective, since every object in codomain B has at least
    one mapping from domain A. Furthermore, since we have a one-to-one correspondence
    between every object in A and B. We can see that we've got both surjection and
    injection; this is also called a bijection.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这个态射也是满射的，因为共域B中的每个对象至少有一个从定义域A的映射。此外，由于我们在A和B中的每个对象之间有一一对应的关系。我们可以看到我们既有满射又有单射；这也被称为双射。
- en: Injective morphism
  id: totrans-868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单射态射
- en: An injective morphism is where every object in A maps to different object in
    B. Mappings to the same object in B are not allowed.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 单射态射是指A中的每个对象都映射到B中的不同对象。不允许映射到B中的相同对象。
- en: '![](img/457eed58-25de-44a0-84e4-e59c467c3c5d.png)'
  id: totrans-870
  prefs: []
  type: TYPE_IMG
  zh: '![](img/457eed58-25de-44a0-84e4-e59c467c3c5d.png)'
- en: Surjective morphism
  id: totrans-871
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 满射态射
- en: Surjective morphism is where every object in the codomain B is connected to
    a morphism from the domain A. In other words, every object in B has the value
    of f(x), where x is in A. This mapping is called *many-to-one,* since there are
    more than one mappings from A to a single object in B.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 满射态射是指共域B中的每个对象都与定义域A中的一个态射相连。换句话说，B中的每个对象都具有f(x)的值，其中x在A中。这种映射被称为“多对一”，因为从A到B中的单个对象有多个映射。
- en: '![](img/11ce691e-4149-4c00-bcb1-02424b3399aa.png)'
  id: totrans-873
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11ce691e-4149-4c00-bcb1-02424b3399aa.png)'
- en: Endomorphism
  id: totrans-874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自同态
- en: If the objects are in the same set, the morphism is known as an endomorphism.
    In other words, the morphism maps back onto itself. An example of this would be
    a domain A of natural numbers (positive integers), morphisms comprised of addition
    and multiplication operations, and a range of B, which will consist of natural
    numbers. Another example would be the set of numbers 1 to 12 on a 12-hour analog
    clock.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象在同一个集合中，则态射被称为自同态。换句话说，态射映射回自身。这种情况的一个例子是自然数（正整数）的定义域A，由加法和乘法运算组成的态射，以及由自然数组成的范围B。另一个例子是12小时模拟时钟上的1到12数字的集合。
- en: SemiGroup homomorphism
  id: totrans-876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 半群同态
- en: A semigroup is a set with an associative operation. Adding any two positive
    integers results in another positive integer; hence, addition is an associative
    property for natural numbers.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 半群是具有可交换操作的集合。任何两个正整数相加的结果仍然是一个正整数；因此，加法对自然数是一个可交换的属性。
- en: Another example is a monoid with a unit morphism that acts as the identity operator.
    For example, the set of natural numbers and multiplication morphisms, whose unit
    morphism is the mutliplyByOne function, or the set of natural numbers and addition
    morphisms, whose unit morphism is the addZero function.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是具有单位态射的幺半群，它充当单位算子。例如，自然数和乘法态射的集合，其单位态射是mutliplyByOne函数，或者自然数和加法态射的集合，其单位态射是addZero函数。
- en: '![](img/b2ebd323-545d-4c5e-bc53-b4ed8e6f2a06.png)'
  id: totrans-879
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2ebd323-545d-4c5e-bc53-b4ed8e6f2a06.png)'
- en: SemiGroup Homomorphism Algebra
  id: totrans-880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 半群同态代数
- en: 'Consider that we''re given semigroups (A, *) and (B, +) and a function f: A
    => B. Then f is a semigroup homomorphism if `f(x) + f(y) = f(x*y)` .'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑到我们有半群(A, *)和(B, +)以及一个函数f: A => B。那么如果`f(x) + f(y) = f(x*y)`，则f是一个半群同态。'
- en: Note that "+" is the operation in range B and "*" is the operation in the domain
    A.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“+”是范围B中的操作，“*”是定义域A中的操作。
- en: So, a semigroup homomorphism is a mapping between two semigroups that preserve
    the semigroup operation.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，半群同态是两个半群之间保持半群运算的映射。
- en: Homomorphism table
  id: totrans-884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同态表
- en: The following table contains the categories of homomorphisms that correspond
    to the Venn diagram of homomorphisms.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含与同态的Venn图相对应的同态的类别。
- en: A → A
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: A → A
- en: '| **Morphism** | **Description** | **Diagram** | **Example** |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '| **态射** | **描述** | **图表** | **例子** |'
- en: '| **Epi**- | Surjective "onto" |  ![](img/e87a0bfa-eb1d-43e5-8dde-ca3ba78923a3.png)A
    → B ⇉ C | ![](img/66fcffdf-715e-4006-ab7f-fe1b58b89f6d.png) |'
  id: totrans-888
  prefs: []
  type: TYPE_TB
  zh: Epi- | 满射“到” |  ![](img/e87a0bfa-eb1d-43e5-8dde-ca3ba78923a3.png)A → B ⇉ C |
    ![](img/66fcffdf-715e-4006-ab7f-fe1b58b89f6d.png) |
- en: '| **Mono**- | Injective "1 to 1" | ![](img/a9f4521c-a16d-4f3a-8cee-8ca21bbad66e.png)
    C ⇉ A → B | ![](img/548b8b4f-6993-45db-9c5f-de9bccad306c.png) |'
  id: totrans-889
  prefs: []
  type: TYPE_TB
  zh: '| **单**- | 单射“1对1” | ![](img/a9f4521c-a16d-4f3a-8cee-8ca21bbad66e.png) C ⇉
    A → B | ![](img/548b8b4f-6993-45db-9c5f-de9bccad306c.png) |'
- en: '| **Iso**- | Bijective "onto" and "1 to 1" Bijective = Injective + Surjective'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: '| **同构**- | 双射“到”和“1对1” 双射 = 单射 + 满射'
- en: Each element in the domain will have a corresponding element in the range (aka
    "codomain"). | ![](img/8a7d96d5-dfb8-411c-9bf2-004f464a61df.png) A ⇄ B | ![](img/a49eeef4-a5b0-451a-a4b5-12db3b88c0aa.png)An
    isomorphism between G and H. Ordered pairs:f(a) = 1, f(b) = 6,... f(j) = 7 |
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 域中的每个元素都将有一个对应的范围中的元素（也称为“余域”）。 | ![](img/8a7d96d5-dfb8-411c-9bf2-004f464a61df.png)
    A ⇄ B | ![](img/a49eeef4-a5b0-451a-a4b5-12db3b88c0aa.png)G和H之间的同构。有序对：f(a) = 1,
    f(b) = 6,... f(j) = 7 |
- en: '| **Endo**- | From a structure to itself. An endomorphism is an homomorphism
    whose domain equals the range. | ![](img/b0798445-c7ef-4428-961a-e611da50b5d2.png)
    A → A | ![](img/e791f956-01c1-4971-abf3-18b9fac98ea5.png)Same pixels, rearranged.
    |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '| **自同**- | 从一个结构到它自身。自同态是一个定义域等于范围的同态。 | ![](img/b0798445-c7ef-4428-961a-e611da50b5d2.png)
    A → A | ![](img/e791f956-01c1-4971-abf3-18b9fac98ea5.png)相同的像素，重新排列。 |'
- en: '| **Auto**- | Bijective endomorphism is an endomorphism that is also an isomorphism;
    an isomorphism with itself. Automorphism = Bijective + Endomorphism | ![](img/e3fd3966-1a4f-40e2-95ee-82a616668e57.png)
    |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '| **自动**- | 双射态射是一个同时也是同构的态射；与自身同构。自同态 = 双射 + 同态 | ![](img/e3fd3966-1a4f-40e2-95ee-82a616668e57.png)
    |'
- en: Car crash analogy
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 车祸类比
- en: We are looking at the same structures/ideas (decomposition, composition, transformation,
    and so on) from different points of view. Whether it's from a mathematical/algebraic/geometric,
    logical/syntactic, Lambda calculus or flow-based perspective, it's all the same
    thing. We just express the same concepts using different notations. It's sort
    of like asking four different individuals what they saw immediately after a car
    crash. They all saw the same thing, but the way it's expressed is differently.
    Considering all points of view can bring more clarity and provide better understanding.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从不同的角度观察相同的结构/思想（分解、组合、转换等）。无论是从数学/代数/几何、逻辑/语法、Lambda演算或基于流的角度来看，它都是相同的东西。我们只是用不同的符号表达相同的概念。这有点像询问四个不同的人在车祸发生后立即看到了什么。他们都看到了同样的事情，但表达方式不同。考虑所有的观点可以带来更多的清晰度和更好的理解。
- en: Composable concurrency
  id: totrans-896
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合的并发性
- en: Functional programming is not only about composing functions and algebraic data
    structures--it makes concurrency composable--something that's virtually impossible
    with other programming paradigms.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程不仅仅是关于组合函数和代数数据结构--它使并发可组合--这在其他编程范式中几乎是不可能的。
- en: How can we take what we've learned about morphisms and apply it to creating
    highly concurrent processing models? Suppose we start with a monolithic application
    with a single binary executable.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将我们对态射的学习应用于创建高度并发的处理模型？假设我们从一个单一的二进制可执行文件开始。
- en: What if we can focus only on the morphisms, that is, the interface of inputs
    and outputs, in our system?
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只关注系统中的态射，也就是输入和输出的接口，会怎样？
- en: 'Consider that we''re given the following:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们已经给出了以下内容：
- en: Inputs and outputs can be mapped through isomorphisms
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出可以通过同构映射
- en: The state exists in the groupings of our objects
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态存在于我们对象的分组中
- en: Morphisms are stateless
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 态射是无状态的
- en: Finite state machines
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限状态机
- en: Can we assume that the finite state machines (FSMs) of our system exist within
    our groupings? (Where the FSM would be like the A and B groupings that we looked
    at previously.)
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设我们系统的有限状态机（FSM）存在于我们的分组中吗？（其中FSM会像我们之前看到的A和B分组一样。）
- en: Let's imagine systematically decomposing our FSMs into the smallest possible
    components.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象将我们的FSM系统系统地分解为最小可能的组件。
- en: Starting with our context component C, by observing behavior/morphisms and applying
    the Schreier Refinement Theorem and what we know about isomorphism, can we systematically
    decompose a large FSM into a grouping of the smallest possible FSMs of equivalent
    behavior?
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的上下文组件C开始，通过观察行为/态射并应用Schreier细化定理以及我们对同构的了解，我们是否可以系统地将一个大的FSM分解成具有等效行为的最小可能的FSM分组？
- en: '![](img/58656498-f5d8-4eaa-a080-27d33efe7f61.png)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58656498-f5d8-4eaa-a080-27d33efe7f61.png)'
- en: 'Here''s the first decomposition:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个分解：
- en: '![](img/afc2b6a2-5122-4a0e-b4fb-944e69f840fd.png)'
  id: totrans-910
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afc2b6a2-5122-4a0e-b4fb-944e69f840fd.png)'
- en: 'Here''s the second decomposition:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个分解：
- en: '![](img/d2a1e98f-1552-4792-8863-295c8d222fa0.png)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2a1e98f-1552-4792-8863-295c8d222fa0.png)'
- en: 'We have been wiring up our components in parallel; we can also (de)compose
    them in serial:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在并行地连接我们的组件；我们也可以（解）组合它们串行地：
- en: '![](img/1eda8918-5be2-4b15-bf96-50b5975b4582.png)'
  id: totrans-914
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1eda8918-5be2-4b15-bf96-50b5975b4582.png)'
- en: Now that we have a complete set of FSMs that comprise our system, we have filled
    our toolbox with the building blocks of our system. Now, we can rebuild our system
    by re-wiring our simple components and fitting them together in a distributed,
    microservice-based environment. Once we've tested our new configurations, we'll
    be in a position to deploy our building blocks and scale them horizontally.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构成我们系统的完整的FSM集合，我们已经用我们系统的构建块填满了我们的工具箱。现在，我们可以通过重新连接我们的简单组件并将它们适配到一个分布式的、基于微服务的环境中来重建我们的系统。一旦我们测试了我们的新配置，我们就可以部署我们的构建块并对它们进行水平扩展。
- en: '![](img/8ed090c6-eef5-447f-aa58-e29d8756aaea.png)'
  id: totrans-916
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ed090c6-eef5-447f-aa58-e29d8756aaea.png)'
- en: 'This power and flexibility comes at some cost. In order to put our components
    to good use, we must build a framework to glue them together and sequence the
    work. We''ll need to think about the following:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 这种力量和灵活性是有代价的。为了充分利用我们的组件，我们必须构建一个框架来将它们粘合在一起并安排工作的顺序。我们需要考虑以下问题：
- en: Compatibility of interfaces
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的兼容性
- en: Determining how to partition our work
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定如何分割我们的工作
- en: Scheduling morphisms
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度态射
- en: Managing resources
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理资源
- en: Graph Database Example
  id: totrans-922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图数据库示例
- en: 'Suppose we just got hired to build a graph database solution for a local college.
    First, we should build the information model. It might look something like this:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们刚被聘用为当地大学构建图数据库解决方案。首先，我们应该构建信息模型。它可能看起来像这样：
- en: '![](img/2948b2f9-5f11-4f90-90ec-4572e5ee5c4e.png)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2948b2f9-5f11-4f90-90ec-4572e5ee5c4e.png)'
- en: Every course has one instructor and many students.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 每门课程都有一个教练和许多学生。
- en: An instructor can teach more than one class.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 一个教练可以教多门课程。
- en: An advisor has more than one student, but a student can have only one advisor.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顾问可以有多个学生，但一个学生只能有一个顾问。
- en: A student may have more than one tutor, and a tutor may help more than one student.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 一个学生可能有多个导师，一个导师可能帮助多个学生。
- en: '![](img/25d16cc6-3d4b-44b0-aa74-f384708ca0a0.png)'
  id: totrans-929
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25d16cc6-3d4b-44b0-aa74-f384708ca0a0.png)'
- en: 'We have five sets of objects:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五组对象：
- en: '| Set | Description |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: 集合 | 描述
- en: '| **A** | Instructors |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: 教练 | 教练
- en: '| **B** | Courses |'
  id: totrans-933
  prefs: []
  type: TYPE_TB
  zh: 课程 | 课程
- en: '| **C** | Students |'
  id: totrans-934
  prefs: []
  type: TYPE_TB
  zh: 关联 | 学生
- en: '| **D** | Tutors |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: 导师 | 导师
- en: '| **E** | Advisor |'
  id: totrans-936
  prefs: []
  type: TYPE_TB
  zh: 顾问 | 顾问
- en: 'Our actual database schema could look something like this:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际的数据库模式可能看起来像这样：
- en: '![](img/5fa7cba4-1290-471a-9419-9f0973412b15.png)'
  id: totrans-938
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fa7cba4-1290-471a-9419-9f0973412b15.png)'
- en: Using mathematics and category theory to gain understanding
  id: totrans-939
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用数学和范畴论来获得理解
- en: Let's work with something we can relate to soccer!
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们能够与足球相关的东西！
- en: How can we know the position of a ball in the air as it moves from Messi's foot
    into the goal?
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道球在空中从梅西的脚到球门的位置？
- en: Note that due to spin on the ball and the imbalance of air pressure, when in
    the air, the ball may curve left to right and up and sharply down.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于球的旋转和空气压力的不平衡，在空中，球可能左右弯曲，上下急剧下降。
- en: 'Check out Messi''s curving goals here:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里看梅西的弯曲进球：
- en: '[https://www.youtube.com/embed/CmSwaK6RsB4?start=11&end=15M](https://www.youtube.com/embed/CmSwaK6RsB4?start=11&end=15M)'
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/embed/CmSwaK6RsB4?start=11&end=15M](https://www.youtube.com/embed/CmSwaK6RsB4?start=11&end=15M)'
- en: '[https://www.youtube.com/watch?v=rNlGmhFSkxw](https://www.youtube.com/watch?v=rNlGmhFSkxw)'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=rNlGmhFSkxw](https://www.youtube.com/watch?v=rNlGmhFSkxw)'
- en: 'Suppose we have a small soccer field with the dimensions of 50 yards X 100
    yards and a net that is 8 feet tall. The height of the goal is the z dimension:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个尺寸为50码X100码的小型足球场和一个高8英尺的球网。球门的高度是z维度：
- en: '![](img/23e24919-e68d-4ce3-8f42-78a4fc883f9f.png)'
  id: totrans-947
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e24919-e68d-4ce3-8f42-78a4fc883f9f.png)'
- en: If the sun is directly overhead and makes a shadow on the field, then we can
    know the x, y coordinates. If we can also measure the height of the ball as it
    moves, then we know the z coordinate. Combining both of those pieces of information,
    we can know the ball's position in the three-dimensional space.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 如果太阳正好在头顶上，并在球场上投下影子，那么我们可以知道x，y坐标。如果我们还可以测量球移动时的高度，那么我们就知道z坐标。结合这两个信息，我们就可以知道球在三维空间中的位置。
- en: '![](img/10f298af-00a0-4c58-a3d5-fab9db32b48c.png)'
  id: totrans-949
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10f298af-00a0-4c58-a3d5-fab9db32b48c.png)'
- en: The following diagram says that if we know A and B, then we also know C.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 下图表示如果我们知道A和B，那么我们也知道C。
- en: In category theory, this is called a product <f,g> of two sets of arrows, f
    and g.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 在范畴论中，这被称为两组箭头f和g的乘积<f,g>。
- en: '![](img/259b6ab1-3465-48a0-b5b9-6f1fcb129def.png)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
  zh: '![](img/259b6ab1-3465-48a0-b5b9-6f1fcb129def.png)'
- en: Given that first extracts A from AxB and second extracts B from AxB and h =
    <f,g>, we can say that `<f,g>; first = f` and `<f,g>; second = g.`
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 假设first从AxB中提取A，second从AxB中提取B，h = <f,g>，我们可以说`<f,g>; first = f`和`<f,g>; second
    = g.`
- en: So, we have a commuting diagram. In other words, we have two paths <f,g> from
    C to AxB and first to A is equal to f, which goes from C to A, and vice versa
    for g.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个交换图。换句话说，我们有两条路径<f,g>从C到AxB和first到A等于f，它从C到A，反之亦然。
- en: The Universality Condition says that the only way to get from C to AxB is to
    apply <f,g> to C.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍性条件表示从C到AxB的唯一方法是对C应用<f,g>。
- en: This diagram says that any arrow <f,g> is in one-to-one correspondence with
    the f and g arrows.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表表示任何箭头<f,g>都与f和g箭头一一对应。
- en: The cartesian product of the sets (C,A) x (C,B) is equal to the set (C, AxB).
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 集合(C,A) x (C,B)的笛卡尔积等于集合(C, AxB)。
- en: In logic, this means if A is true and B is true then we know that A and B is
    true. So, the product is logical conjunction.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑中，这意味着如果A为真且B为真，则我们知道A和B为真。因此，乘积是逻辑连接。
- en: The identify function is depicted in the table. It says that the identity function
    of AxB is AxB. While this seems simple, it is important. The identity function
    is also known as the unit, which we've already discussed as it relates to types
    and will encounter again in the chapter about monads.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 表中描述了恒等函数。它表示AxB的恒等函数是AxB。虽然这看起来很简单，但很重要。恒等函数也被称为单位，我们已经讨论过它与类型的关系，并且在关于单子的章节中会再次遇到。
- en: 'We''ve seen the following laws for multiplication in elementary school:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在小学学过乘法的以下定律：
- en: '| **Law** | **Example** |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: 法律 | 例子
- en: '| **Identity** | A x 1 = A and 1 x A = A |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: 恒等 | A x 1 = A and 1 x A = A
- en: '| **Associative** | A x (B x C) = (AxB) x C |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: 结合律 | A x (B x C) = (AxB) x C
- en: '| **Commutative** | A x B = B x A |'
  id: totrans-964
  prefs: []
  type: TYPE_TB
  zh: 交换律 | A x B = B x A
- en: '| **Distributive** | A x (B + C) = (A x B) + (A x C) |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: 分配律 | A x (B + C) = (A x B) + (A x C)
- en: 'The following diagram depicts the identity law for a product in category theory.
    It says that the identity of AxB is the arrow pair of <first, second>:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了范畴论中乘积的恒等律。它表示AxB的恒等性是<first, second>的箭头对：
- en: '![](img/c7433e75-2208-463a-8fdd-9659fe677c75.png)'
  id: totrans-967
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7433e75-2208-463a-8fdd-9659fe677c75.png)'
- en: 'The following diagram depicts the sum operation:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了求和运算：
- en: '![](img/00fd4d03-b4ee-46ac-93b3-5c24cca35016.png)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00fd4d03-b4ee-46ac-93b3-5c24cca35016.png)'
- en: It says that there are two ways to build a sum, with inLeft or inRight.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 它表示有两种方法来构建和，使用inLeft或inRight。
- en: In code, we'd need a case statement or an if/then statement to get the result.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们需要一个case语句或一个if/then语句来获得结果。
- en: The bracket in [f,g] indicates that the result is either f or g.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的[f,g]表示结果是f或g。
- en: Our morphism must terminate if we are to have either a true sum or a true product.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要有真正的总和或真正的乘积，我们的态射必须终止。
- en: Our diagram also says that an arrow from A+B is isomorphic with an arrow from
    A to C paired with an arrow from B to C; or formally, (A,C) x (B,C) = (A+B, C)
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表还表示，从A+B到C的箭头与从A到C配对的箭头和从B到C的箭头是同构的；或者正式地说，(A,C) x (B,C) = (A+B, C)
- en: So, if we know A or we know B, we have proof of C. (This is also known as disjunction.)
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们知道A或我们知道B，我们就有C的证明。（这也被称为析取。）
- en: '![](img/56e516dd-d44a-4fc2-a8b5-fc2ff0f466a2.png)'
  id: totrans-976
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56e516dd-d44a-4fc2-a8b5-fc2ff0f466a2.png)'
- en: The set theory equation is `A ∪ (B∩C) = (A∪B) ∩ (A∪C)`
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 集合论方程是`A ∪ (B∩C) = (A∪B) ∩ (A∪C)`
- en: For more information on distributive law, visit: [https://ncatlab.org/nlab/show/distributive+law](https://ncatlab.org/nlab/show/distributive+law).
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分配律的更多信息，请访问：[https://ncatlab.org/nlab/show/distributive+law](https://ncatlab.org/nlab/show/distributive+law)。
- en: Laws of exponentials for building a lambda expression
  id: totrans-979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于构建λ表达式的指数定律
- en: 'Laws of exponentials for building a lambda expression are as follows:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建λ表达式的指数定律如下：
- en: '![](img/2eadab28-61e4-4b84-a07b-32df3ae096bd.png)'
  id: totrans-981
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2eadab28-61e4-4b84-a07b-32df3ae096bd.png)'
- en: Table legend
  id: totrans-982
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表格图例
- en: Gamma (Γ) represents the environment, that is, free variables paired with a
    bunch of types. We give names to free variables (for example, x of type A in the
    context, y of type B,...) and their type.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: Gamma (Γ)代表环境，即与一堆类型配对的自由变量。我们为自由变量（例如，在上下文中类型为A的x，类型为B的y等）和它们的类型赋予名称。
- en: Turnstile (⊢) a ⊢ b means a is provable from b.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: Turnstile (⊢) a ⊢ b 意味着a可以从b中证明。
- en: The term (M) represent expressions we write in a programming language.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 术语(M)代表我们在编程语言中编写的表达式。
- en: We show types A and B.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示类型A和B。
- en: For the top right law...
  id: totrans-987
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对于右上角的定律...
- en: Consider f represents the semantics (above) and curry(f) and we pair f and g
    to get A to B with a and apply it, categorically, exponentials give us implication
    A ⇒ B.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑f代表语义（上面）和curry(f)，我们将f和g配对，得到A到B与a的范畴应用，指数给出了蕴含A ⇒ B。
- en: 'For the bottom left law:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 对于左下角的定律：
- en: How do we know A implies B? By assuming A, we can prove B and we know A implies
    B.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道A蕴含B？通过假设A，我们可以证明B，我们知道A蕴含B。
- en: If we know A implies B and we know A, then we can conclude B.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道A蕴含B，并且我们知道A，那么我们可以得出B。
- en: This is also known as modus ponens.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为假言推理。
- en: Sums and products
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 求和和乘积
- en: What can we see when we compare the diagrams for sums and products?
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们比较求和和乘积的图表时，我们能看到什么？
- en: If we were to flip the arrows, then they would be identical!
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们翻转箭头，那么它们将是相同的！
- en: This is called a **Dual**. We say the *co* of a dual is the thing we started
    with.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**对偶**。我们说对偶的*co*是我们开始的东西。
- en: Negation in logic is an example of a dual.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑中的否定是对偶的一个例子。
- en: 'Category theory jokes:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴论笑话：
- en: What are the morphisms in the category of cars? AUTO morphisms
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在汽车类别中的态射是什么？AUTO morphisms
- en: A Priest, a Rabbi, and an Automorphism walk into a bar.... "I think we should
    talk, one-to-one", "We can't... He's onto us."
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 一个牧师、一个拉比和一个自同构走进一家酒吧...“我认为我们应该一对一地交谈”，“我们不能...他发现了我们。”
- en: What does a categorical mathematician call a coconut?
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 范畴数学家如何称呼椰子？
- en: Isomorphic equations
  id: totrans-1002
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 同构方程
- en: 'We have learned the following isomorphic equations:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了以下同构方程：
- en: '*(C,A) x (C,B) = (C, AxB)*'
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(C,A) x (C,B) = (C, AxB)*'
- en: '*(A,C) x (C,B) = (A+B, C)*'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(A,C) x (C,B) = (A+B, C)*'
- en: '*(C x A,B) = (C, [A⇒B])*'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*(C x A,B) = (C, [A⇒B])*'
- en: In first equation, what does it mean to have an arrow from C to AxB?
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方程中，从C到AxB有什么意义？
- en: 'A: We have a pair of arrows, an arrow from C to A and an arrow from C to B.'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: A：我们有一对箭头，一个箭头从C指向A，一个箭头从C指向B。
- en: Similarly for 2 and 3.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的对于2和3。
- en: If C is a finite set with exactly C objects in it, and A is a finite set with
    exactly A things in it, then how many ways are there to get from C to A?
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C是一个有C个对象的有限集，A是一个有A个事物的有限集，那么从C到A有多少种方式？
- en: 'Answer: There are A X C different ways of getting from C to A'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：有A X C种不同的方法可以从C到A
- en: How many functions are there from n variables onto 2?
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 从n个变量到2的函数有多少个？
- en: 'Answer: 2^n'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：2^n
- en: Do you see the direct correspondence between the categorical isomorphic equations
    and the laws of exponents we learned in high school?
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到范畴同构方程和我们在高中学到的指数定律之间的直接对应关系吗？
- en: '![](img/32d600db-94cd-4725-975e-11e08ba2f42e.png)'
  id: totrans-1015
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32d600db-94cd-4725-975e-11e08ba2f42e.png)'
- en: Fun with Sums, Products, Exponents and Types
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求和、乘积、指数和类型的乐趣
- en: 'Here''s the sum of cows with tigers and elephants:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有牛、老虎和大象的总和：
- en: '![](img/d09d84fa-bc0e-442f-9d00-d446a92579ae.png)'
  id: totrans-1018
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d09d84fa-bc0e-442f-9d00-d446a92579ae.png)'
- en: 'Here''s a product of cows with tigers and elephants:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有牛、老虎和大象的乘积：
- en: '![](img/2e47f7a3-ffd2-4eef-911c-c46aa6995979.png)'
  id: totrans-1020
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e47f7a3-ffd2-4eef-911c-c46aa6995979.png)'
- en: 'Here''s the exponents of cows with tigers and elephants:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有牛、老虎和大象的指数：
- en: '![](img/e0c100bd-258b-4e0a-85d0-e1b29eccf934.png)'
  id: totrans-1022
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0c100bd-258b-4e0a-85d0-e1b29eccf934.png)'
- en: If we have a getCow method that will return DressedCows and if we have 3 types
    of DressedCows then if we call getCow then there are 3¹ possible DressedCows that
    it can return.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个getCow方法，它将返回DressedCows，如果我们有3种类型的DressedCows，那么如果我们调用getCow，它可以返回3¹个可能的DressedCows。
- en: Note that functions with no arguments are Units. A Unit is a singleton type
    that carries no information. In [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids,
    and Generics*,we'll see how Units are useful when we build a 12-hour clock functor
    and when writing a reduce function. A Unit is our identity morphism.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有参数的函数是Units。Unit是一个携带没有信息的单例类型。在[第9章](../Text/Ch09.xhtml)中，*Functors,
    Monoids, and Generics*，我们将看到在构建12小时时钟函子和编写reduce函数时，Units是如何有用的。Unit是我们的恒等态射。
- en: '![](img/59258b9f-d2d3-4c07-9057-a4e290c32dd8.png)'
  id: totrans-1025
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59258b9f-d2d3-4c07-9057-a4e290c32dd8.png)'
- en: Looking at structures algebraically lets us find matching structure.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 代数结构的代数观察让我们找到匹配的结构。
- en: Once we've identified an isomorphism we have proven ways to optimize for memory
    usage, performance or data augmentation.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了同构，我们就有了优化内存使用、性能或数据增强的方法。
- en: Proving what our code allows us to us it.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 证明我们的代码允许我们使用它。
- en: Proving what our code isn't prevents errors.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 证明我们的代码不允许错误。
- en: In this way, types are a fundamental part of functional programming.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，类型是函数式编程的一个基本部分。
- en: '![](img/c98c2d34-9ad8-46ae-9eef-ac63311b2d70.png)'
  id: totrans-1031
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c98c2d34-9ad8-46ae-9eef-ac63311b2d70.png)'
- en: Our sums are isomorphic to products. The tiger on the left and the tiger on
    the right are *dual* to each other. Same for the elephant and the football. A
    tiger's dual is called a cotiger. Similarly sums are called coproducts.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的总和与乘积同构。左边的老虎和右边的老虎彼此*对偶*。大象和足球也是如此。老虎的对偶被称为余老虎。同样，总和被称为余积。
- en: '![](img/49b65af9-69c6-44f9-a54e-587422dd6d83.png)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49b65af9-69c6-44f9-a54e-587422dd6d83.png)'
- en: 'A monomorphism is shown below. **f** is *monic*:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了一个单态射。**f**是*单调*：
- en: '![](img/c4d072d2-8e0a-48eb-afda-ac35b581e0fb.png)'
  id: totrans-1035
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4d072d2-8e0a-48eb-afda-ac35b581e0fb.png)'
- en: 'An epimorphism is shown below. **f** is *epic*:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了一个满态射。**f**是*史诗*的：
- en: '![](img/683a70a8-e237-437d-80da-329f9ae5366b.png)'
  id: totrans-1037
  prefs: []
  type: TYPE_IMG
  zh: '![](img/683a70a8-e237-437d-80da-329f9ae5366b.png)'
- en: The following diagrams shows that monomorphisms are dual to epimorphisms.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示单态射与满态射是对偶的。
- en: '![](img/1ea69afd-5d9c-4a33-ac71-924445c34667.png)'
  id: totrans-1039
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ea69afd-5d9c-4a33-ac71-924445c34667.png)'
- en: 'If we don''t lose data going from tigers to elephants to tigers:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从老虎到大象再到老虎不丢失数据：
- en: '![](img/b1329f40-4346-491d-a223-6e3dcfdce68e.png)'
  id: totrans-1041
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1329f40-4346-491d-a223-6e3dcfdce68e.png)'
- en: 'Also, we don''t lose data going from elephants to tigers to elephants:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们从大象到老虎再到大象也不会丢失数据：
- en: '![](img/a07790de-b31a-4a54-a638-354eba7e1b18.png)'
  id: totrans-1043
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a07790de-b31a-4a54-a638-354eba7e1b18.png)'
- en: Then, our morphism are isomorphic.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的态射是同构的。
- en: Algebraic data structures give us certainty when move, map and transform data
    that we won't lose data.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 代数数据结构在我们移动、映射和转换数据时给了我们确定性，我们不会丢失数据。
- en: It is essential to understand how our data structures are preserved during our
    workflows.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的数据结构在工作流程中是如何保留的至关重要。
- en: Functional programming brings us the certainty we need for data integrity as
    well as the composition we need to help manage complexity.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程为我们带来了我们需要的数据完整性以及我们需要帮助管理复杂性的组合。
- en: When Aubie goes to buy his tickets to the Iron Bowl he enters is order data...
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 当奥比去买铁碗的票时，他输入了订单数据...
- en: '![](img/bf534933-2b3f-4405-a547-dfe8e803e9a6.png)'
  id: totrans-1049
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf534933-2b3f-4405-a547-dfe8e803e9a6.png)'
- en: 'When he clicks the Submit button the data flows from one endpoint to another.
    As the data flows, it may be transformed in some way but the structure of the
    data is kept intact:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 当他点击提交按钮时，数据从一个端点流向另一个端点。随着数据的流动，它可能以某种方式进行转换，但数据的结构保持不变：
- en: '![](img/3371fc32-d0fd-4af0-a450-dd4bf550c046.png)'
  id: totrans-1051
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3371fc32-d0fd-4af0-a450-dd4bf550c046.png)'
- en: Isomorphisms guarantee data integrity (no data loss). Computation uses data
    types to map morphisms. Interface definitions (using data types) allow us to connect
    functions. Immutable data structures can leverage memoization, improve concurrency,
    and reduce memory usage. Using FP in Go helps us to simplify our development process.
    We no longer need to worry about a whole classification of data/interface incompatibility
    issues.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 同构保证数据完整性（没有数据丢失）。计算使用数据类型来映射态射。接口定义（使用数据类型）允许我们连接函数。不可变数据结构可以利用记忆化，改进并发性，并减少内存使用。在Go中使用FP可以帮助我们简化开发过程。我们不再需要担心整个数据/接口不兼容问题的分类。
- en: 'Benefits of using FP an Go include better:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FP和Go的好处包括更好的：
- en: performance
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能
- en: data reliability
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可靠性
- en: component reuse
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件重用
- en: management of complexity
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂性管理
- en: resource utilization
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源利用
- en: Big data, knowledge-driven development, and data visualization
  id: totrans-1059
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大数据、知识驱动的开发和数据可视化
- en: Big data implies there's a lot of data. When there is a lot of data, it becomes
    difficult to find meaning. The category theory helps us to remove the unimportant
    details and see the meaningful information that is there waiting to be discovered.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 大数据意味着有大量的数据。当有大量的数据时，很难找到含义。范畴论帮助我们去除不重要的细节，并看到那些等待被发现的有意义的信息。
- en: Data visualization
  id: totrans-1061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据可视化
- en: How can we apply what we've learned in the real world?
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将我们学到的应用到现实世界中？
- en: 'Composition sounds great but how can we go from this:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 组合听起来很棒，但我们如何从这里开始：
- en: '![](img/e98700e3-ee70-46e4-80a7-14397eab3157.png)'
  id: totrans-1064
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e98700e3-ee70-46e4-80a7-14397eab3157.png)'
- en: 'And an I/O Monad:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个I/O Monad：
- en: '![](img/4b578bfa-0468-4566-aacb-7195ff39ed43.png)'
  id: totrans-1066
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b578bfa-0468-4566-aacb-7195ff39ed43.png)'
- en: To something useful.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 变得有用。
- en: We can read data from server logs and integrate a graphical user interface (GUI)
    that renders a presentation that our users can view and derive an understanding
    from the data that is presented in a meaningful way.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从服务器日志中读取数据，并集成一个图形用户界面（GUI），以呈现用户可以查看并从中获得理解的方式呈现的演示。
- en: '![](img/f8cd539c-5028-41c5-beba-08768c3f8845.png)'
  id: totrans-1069
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8cd539c-5028-41c5-beba-08768c3f8845.png)'
- en: What if our data had a corresponding schema?
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据有对应的模式呢？
- en: 'Can we generalize the presentation of the data to different layouts? For example,
    spreadsheet programs allow their users to display different types of graphs based
    on the same set of rows and columns (pie charts, bar charts, and so on). If we
    can do that, then the following is feasible:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将数据的呈现推广到不同的布局吗？例如，电子表格程序允许用户基于相同的行和列显示不同类型的图表（饼图、条形图等）。如果我们可以做到这一点，那么以下是可行的：
- en: '![](img/e31d8175-e4e2-47f5-916f-913f396bfe97.png)'
  id: totrans-1072
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e31d8175-e4e2-47f5-916f-913f396bfe97.png)'
- en: 'From the practical side of things, the data from our log files might feed into
    tables with rows and columns, much like a spreadsheet. From the category side,
    we could say that our schema is a Cartesian product of object instances and their
    attributes: Schema = Instances x Attributes.'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，我们日志文件中的数据可能会进入具有行和列的表格，就像电子表格一样。从类别的角度来看，我们可以说我们的模式是对象实例和它们的属性的笛卡尔积：模式=实例x属性。
- en: 'We can then combine our diagrams to get this:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以合并我们的图表得到这个：
- en: '![](img/58bbf8fc-cd35-476b-9c12-b81ddf5c6ea0.png)'
  id: totrans-1075
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58bbf8fc-cd35-476b-9c12-b81ddf5c6ea0.png)'
- en: 'Now, if we want to allow our users to input queries to gain a working knowledge
    of their domain, we could arrive at the following diagram:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要允许用户输入查询以获得对其领域的工作知识，我们可以得到以下的图表：
- en: '![](img/2f47ccad-f0b3-459c-bb7b-29424570d637.png)'
  id: totrans-1077
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f47ccad-f0b3-459c-bb7b-29424570d637.png)'
- en: The category shown here defines a well-formed vizualisation process; if the
    arrows, objects, and data are accurate, then the diagram will commute. We can
    be confident that the knowledge we gain is reliable.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的类别定义了一个良好的可视化过程；如果箭头、对象和数据准确无误，那么图表就会通行无阻。我们可以确信我们获得的知识是可靠的。
- en: '![](img/4e8c54bb-9e39-431f-92c3-247822fe86cc.png)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e8c54bb-9e39-431f-92c3-247822fe86cc.png)'
- en: Knowledge-driven systems can make the difference between success and failure.
    Our proverbial hay stack could be every interaction, every gesture of body language/facial
    expression, words spoken, commitments kept/broken, and so on. If our key performance
    indicator is the health of our relationship, a knowledge-based system could sift
    through the minutia and highlight the one remark that mattered, "*I wish you would
    stop work and greet me when I arrive.*"
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 知识驱动的系统可以决定成功与失败之间的差异。我们所谓的干草堆可能是每一次互动，每一个身体语言/面部表情的姿态，所说的话，信守/违背的承诺等等。如果我们的关键绩效指标是我们关系的健康，一个基于知识的系统可以筛选出细枝末节，并突出那个重要的一句话，“*我希望你停下工作，迎接我的到来*”。
- en: Sometimes, we need to start with the correct data set. If our goal is to find
    the next great location to build a shopping mall, we could gather two data sets,
    one for all cell phone records and another of population demographics. Though
    both sets of data have copious amounts of data that don't provide guidance, if
    we build our system with rules designed to find the actionable needles of truth,
    the given geolocation information of both cell phone records and demographics
    combined with income statistics, our system could bring to light the most ideal
    locations for our investors.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要从正确的数据集开始。如果我们的目标是找到下一个建造购物中心的绝佳位置，我们可以收集两个数据集，一个是所有手机通话记录，另一个是人口统计数据。虽然这两组数据都有大量的数据，但如果我们构建我们的系统以设计规则来找到可行的真相，结合手机通话记录和人口统计数据以及收入统计数据的地理位置信息，我们的系统可以揭示出最理想的投资地点。
- en: You might be thinking, "*I can do that with my imperative language.*" Perhaps,
    but will it scale?
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，“*我可以用我的命令式语言做到这一点*”。也许，但它是否可扩展呢？
- en: Summary
  id: totrans-1083
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what we need to know about category theory to be
    dangerous. We walked through history together, learning how functional programming
    came to be what it is today. We looked at logical propositions and proofs, sets,
    objects, and arrows as well as Lambda calculus. We shared in the amazement of
    the correspondence between category theory, logic, and Lambda calculus. And you
    saw how to apply what you learned in real-world scenarios (such as the flight
    of a soccer ball and doing business with untrusted partners). Lastly, we gained
    insight into how to design knowledge-based systems to derive value from big data.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了我们需要了解的范畴论知识，以便危险。我们一起走过历史，了解了函数式编程如何成为今天的样子。我们看了逻辑命题和证明，集合、对象和箭头以及Lambda演算。我们分享了范畴论、逻辑和Lambda演算之间的对应之处的惊奇。您还看到了如何将所学应用于现实场景（如足球的飞行和与不信任的合作伙伴做生意）。最后，我们深入了解了如何设计基于知识的系统，从大数据中获取价值。
- en: In the next chapter, we'll dig deeper into pure functional programming. We'll
    see how to leverage category theory and class types to abstract away details in
    order to glean new insights. We'll look at functors, along with slightly stronger
    and more useful versions of functors called applicative functors. We'll also learn
    how to bring the world of side-effects under control using monads and monoids.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地了解纯函数式编程。我们将看到如何利用范畴论和类类型来抽象细节，以获得新的见解。我们将研究函子，以及稍微更强大和更有用的函子称为应用函子。我们还将学习如何使用单子和幺半群控制副作用的世界。
