- en: Chapter 3. Go Control Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Go控制流
- en: 'Go borrows several of its control flow syntax from the C-family of languages.
    It supports all of the expected control structures, including `if...else`, `switch`,
    `for` loop, and even `goto`. Conspicuously absent, though, are `while` or `do...while`
    statements. The following topics in this chapter examine Go''s control flow elements,
    some of which you may already be familiar with, and others that bring a new set
    of functionalities not found in other languages:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go从C语言家族中借用了几种控制流语法。它支持所有预期的控制结构，包括if...else、switch、for循环，甚至goto。然而，明显缺少的是while或do...while语句。本章中的以下主题将讨论Go的控制流元素，其中一些您可能已经熟悉，而其他一些则带来了其他语言中没有的一组新功能：
- en: The `if` statement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if语句
- en: The `switch` statement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: switch语句
- en: The type `Switch`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型Switch
- en: The `for` statement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for语句
- en: The if statement
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if语句
- en: 'The `if` statement, in Go, borrows its basic structural form from other C-like
    languages. The statement conditionally executes a code block when the Boolean
    expression that follows the `if` keyword evaluates to `true`, as illustrated in
    the following abbreviated program, which displays information about world currencies:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，if语句从其他类似C的语言中借用了其基本结构形式。当跟随if关键字的布尔表达式求值为true时，该语句有条件地执行代码块，如下面简化的程序所示，该程序显示有关世界货币的信息：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch03/ifstmt.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/ifstmt.go
- en: 'The `if` statement in Go looks similar to other languages. However, it sheds
    a few syntactic rules, while enforcing new ones:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的if语句看起来与其他语言相似。但是，它摒弃了一些语法规则，同时强制执行了一些新规则：
- en: 'The parentheses around the test expression are not necessary. While the following
    `if` statement will compile, it is not idiomatic:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试表达式周围的括号是不必要的。虽然以下if语句将编译，但这不是惯用法：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the following instead:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代替：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The curly braces for the code block are always required. The following snippet
    will not compile:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块的大括号始终是必需的。以下代码片段将无法编译：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, this will compile:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，这将编译通过：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is idiomatic, however, to write the `if` statement on multiple lines (no
    matter how simple the statement block may be). This encourages good style and
    clarity. The following snippet will compile with no issues:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，惯用的、更清晰的编写if语句的方式是使用多行（无论语句块有多简单）。以下代码片段将无问题地编译通过：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the preferred idiomatic layout for the statement is to use multiple
    lines, as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，语句的首选惯用布局是使用多行，如下所示：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `if` statement may include an optional `else` block, which is executed
    when the expression in the `if` block evaluates to `false`. The code in the `else`
    block must be wrapped in curly braces using multiple lines, as shown in the following
    snippet:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if语句可以包括一个可选的else块，当if块中的表达式求值为false时执行。else块中的代码必须使用多行用大括号括起来，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `else` keyword may be immediately followed by another `if` statement forming
    an `if...else...if` chain, as used in the function `printCurr()` from the source
    code listed earlier:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: else关键字后面可以紧接着另一个if语句，形成if...else...if链，就像前面列出的源代码中的printCurr()函数中使用的那样：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `if...else...if` statement chain can grow as long as needed and may be
    terminated by an optional `else` statement to express all other untested conditions.
    Again, this is done in the `printCurr()` function, which tests four conditions
    using the `if...else...if` blocks. Lastly, it includes an `else` statement block
    to catch any other untested conditions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: if...else...if语句链可以根据需要增加，并且可以通过可选的else语句来终止，以表达所有其他未经测试的条件。同样，这是在printCurr()函数中完成的，该函数使用if...else...if块测试四个条件。最后，它包括一个else语句块来捕获任何其他未经测试的条件：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Go, however, the idiomatic, and cleaner, way to write such a deep `if...else...if`
    code block is to use an expressionless `switch` statement. This is covered later,
    in the *Switch statement* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Go中，编写这样深层if...else...if代码块的惯用且更清晰的方式是使用无表达式的switch语句。这将在*Switch语句*部分中介绍。
- en: The if statement initialization
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句初始化
- en: 'The `if` statement supports a composite syntax where the tested expression
    is preceded by an initialization statement. At runtime, the initialization is
    executed before the test expression is evaluated, as illustrated in this code
    snippet (from the program listed earlier):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: if语句支持复合语法，其中被测试的表达式前面有一个初始化语句。在运行时，初始化在评估测试表达式之前执行，如前面列出的程序中所示：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The initialization statement follows normal variable declaration and initialization
    rules. The scope of the initialized variables is bound to the `if` statement block,
    beyond which they become unreachable. This is a commonly used idiom in Go and
    is supported in other flow control constructs covered in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句遵循正常的变量声明和初始化规则。初始化变量的作用域绑定到if语句块，超出该范围后就无法访问。这是Go中常用的习惯用法，并且在本章中涵盖的其他流程控制结构中也得到支持。
- en: Switch statements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch语句
- en: 'Go also supports a `switch` statement similar to that found in other languages
    such as, C or Java. The `switch` statement in Go achieves multi-way branching
    by evaluating values or expressions from `case` clauses, as shown in the following,
    abbreviated, source code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持类似于C或Java等其他语言中的switch语句。Go中的switch语句通过评估case子句中的值或表达式来实现多路分支，如下面简化的源代码所示：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch03/switchstmt.go
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt.go
- en: 'The `switch` statement in Go has some interesting properties and rules that
    make it easy to use and reason about:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的switch语句具有一些有趣的属性和规则，使其易于使用和理解：
- en: 'Semantically, Go''s `switch` statement can be used in two contexts:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从语义上讲，Go的switch语句可以在两个上下文中使用：
- en: An expression`switch` statement
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式switch语句
- en: A type`switch` statement
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型switch语句
- en: The `break` statement can be used to escape out of a switch code block early.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: break语句可以用于提前跳出switch代码块。
- en: The `switch` statement can include a default case when no other case expressions
    evaluate to a match. There can only be one default case and it may be placed anywhere
    within the switch block.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有其他case表达式评估为匹配时，`switch`语句可以包括一个默认case。只能有一个默认case，并且可以放置在switch块的任何位置。
- en: Using expression switches
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式开关
- en: 'Expression switches are flexible and can be used in many contexts where control
    flow of a program needs to follow multiple path. An expression switch supports
    many attributes, as outlined in the following bullets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式开关是灵活的，可以在程序控制流需要遵循多个路径的许多上下文中使用。表达式开关支持许多属性，如下面的要点所述：
- en: 'Expression switches can test values of any types. For instance, the following
    code snippet (from the previous program listing) tests variable `Curr` of type
    `struct`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式开关可以测试任何类型的值。例如，以下代码片段（来自前面的程序清单）测试了类型为`struct`的变量`Curr`：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The expressions in `case` clauses are evaluated from left to right, top to bottom,
    until a value (or expression) is found that is equal to that of the `switch` expression.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`case`子句中的表达式从左到右、从上到下进行评估，直到找到与`switch`表达式相等的值（或表达式）为止。'
- en: Upon encountering the first case that matches the `switch` expression, the program
    will execute the statements for the `case` block and then immediately exit the
    `switch` block. Unlike other languages, the Go `case` statement does not need
    to use a break to avoid falling through the next case (see the *Fallthrough cases*
    section). For instance, calling `isDollar(Curr{"HKD", "Hong Kong Dollar", "Hong
    Kong", 344})` will match the second `case` statement in the preceding function.
    The code will set the result to `true` and exit the `switch` code block immediately.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到与`switch`表达式匹配的第一个case时，程序将执行`case`块的语句，然后立即退出`switch`块。与其他语言不同，Go的`case`语句不需要使用`break`来避免下一个case的穿透（参见*Fallthrough
    cases*部分）。例如，调用`isDollar(Curr{"HKD", "Hong Kong Dollar", "Hong Kong", 344})`将匹配前面函数中的第二个`case`语句。代码将将结果设置为`true`并立即退出`switch`代码块。
- en: '`Case` clauses can have multiple values (or expressions) separated by commas
    with a logical `OR` operator implied between them. For instance, in the following
    snippet, the `switch` expression `curr` is tested against values `currencies[2]`,
    `currencies[4]`, or `currencies[10]`, using one case clause until a match is found:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Case`子句可以有多个值（或表达式），用逗号分隔，它们之间隐含着逻辑`OR`运算符。例如，在以下片段中，`switch`表达式`curr`被测试与值`currencies[2]`、`currencies[4]`或`currencies[10]`，使用一个case子句，直到找到匹配：'
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `switch` statement is the cleaner and preferred idiomatic approach to writing
    complex conditional statements in Go. This is evident when the preceding snippet
    is compared to the following, which does the same comparison using `if` statements:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句是在Go中编写复杂条件语句的更清晰和首选的惯用方法。当前面的片段与使用`if`语句进行相同比较时，这一点是明显的：'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fallthrough cases
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 穿透案例
- en: 'There is no automatic *fall through* in Go''s `case` clause as there is in
    the C or Java `switch` statements. Recall that a `switch` block will exit after
    executing its first matching case. The code must explicitly place the `fallthrough`
    keyword, as the last statement in a `case` block, to force the execution flow
    to fall through the successive `case` block. The following code snippet shows
    a `switch` statement with a `fallthrough` in each case block:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go的`case`子句中没有自动的*穿透*，就像C或Java的`switch`语句中一样。回想一下，一个`switch`块在执行完第一个匹配的case后会退出。代码必须明确地将`fallthrough`关键字放在`case`块的最后一个语句，以强制执行流程穿透到连续的`case`块。以下代码片段显示了一个`switch`语句，其中每个case块都有一个`fallthrough`：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch03/switchstmt.go
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt.go
- en: 'When a case is matched, the `fallthrough` statements cascade down to the first
    statement of the successive `case` block. So, if `curr = Curr{"AUD", "Australian
    Dollar", "Australia", 36}`, the first case will be matched. Then the flow cascades
    down to the first statement of the second case block, which is also a `fallthrough`
    statement. This causes the first statement, to return `true`, of the third case
    block to execute. This is functionally equivalent to the following snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当匹配到一个case时，`fallthrough`语句会级联到连续`case`块的第一个语句。因此，如果`curr = Curr{"AUD", "Australian
    Dollar", "Australia", 36}`，第一个case将被匹配。然后流程级联到第二个case块的第一个语句，这也是一个`fallthrough`语句。这导致第三个case块的第一个语句执行返回`true`。这在功能上等同于以下片段：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Expressionless switches
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无表达式的开关
- en: 'Go supports a form of the `switch` statement that does not specify an expression.
    In this format, each `case` expression must evaluate to a Boolean value `true`.
    The following abbreviated source code illustrates the uses of an expressionless
    `switch` statement, as listed in function `find()`. The function loops through
    the slice of `Curr` values to search for a match based on field values in the
    `struct` function that''s passed in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持一种不指定表达式的`switch`语句形式。在这种格式中，每个`case`表达式必须评估为布尔值`true`。以下简化的源代码示例说明了无表达式`switch`语句的用法，如`find()`函数中所列。该函数循环遍历`Curr`值的切片，以根据传入的`struct`函数中的字段值搜索匹配项：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt2.go
- en: 'Notice in the previous example, the `switch` statement in function `find()`
    does not include an expression. Each `case` expression is separated by a comma
    and must be evaluated to a Boolean value with an implied `OR` operator between
    each. The previous `switch` statement is equivalent to the following use of an
    `if` statement to achieve the same logic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的示例中，函数`find()`中的`switch`语句不包括表达式。每个`case`表达式用逗号分隔，并且必须被评估为布尔值，每个之间隐含着`OR`运算符。前面的`switch`语句等同于以下使用`if`语句实现相同逻辑：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Switch initializer
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开关初始化器
- en: 'The `switch` keyword may be immediately followed by a simple initialization
    statement where variables, local to the `switch` code block, may be declared and
    initialized. This convenient syntax uses a semi-colon between the initializer
    statement and the `switch` expression to declare variables, which may appear anywhere
    in the `switch` code block. The following code sample shows how this is done by
    initializing two variables, `name` and `curr`, as part of the `switch` declaration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`关键字后面可以紧跟一个简单的初始化语句，在其中可以声明和初始化`switch`代码块中的局部变量。这种方便的语法使用分号在初始化语句和`switch`表达式之间声明变量，这些变量可以出现在`switch`代码块的任何位置。以下代码示例显示了如何通过初始化两个变量`name`和`curr`来完成这个操作：'
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt2.go
- en: The previous code snippet uses an expressionless `switch` statement with an
    initializer. Notice the trailing semi-colon to indicate the separation between
    the initialization statement and the expression area for the switch. In the example,
    however, the `switch` expression is empty.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用了一个没有表达式的`switch`语句和一个初始化程序。注意分号表示初始化语句和`switch`表达式区域之间的分隔。然而，在这个例子中，`switch`表达式是空的。
- en: Type switches
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型开关
- en: Given Go's strong type support, it should be of little surprise that the language
    supports the ability to query type information. The type `switch` is a statement
    that uses the Go interface type to compare the underlying type information of
    values (or expressions). A full discussion on interface types and type assertion
    is beyond the scope of this section. You can find more details on the subject
    in [Chapter 8](ch08.html "Chapter 8. Methods, Interfaces, and Objects"), *Methods,
    Interfaces, and Objects*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Go对强类型的支持，也许不足为奇的是，该语言支持查询类型信息的能力。类型`switch`是一种语句，它使用Go接口类型来比较值（或表达式）的底层类型信息。关于接口类型和类型断言的详细讨论超出了本节的范围。你可以在[第8章](ch08.html
    "第8章。方法、接口和对象")*方法、接口和对象*中找到更多关于这个主题的细节。
- en: 'Nevertheless, for the sake of completeness, a short discussion on type switches
    is provided here. For now, all you need to know is that Go offers the type `interface{}`,
    or empty interface, as a super type that is implemented by all other types in
    the type system. When a value is assigned type `interface{}`, it can be queried
    using the type `switch`, as shown in function `findAny()` in the following code
    snippet, to query information about its underlying type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，为了完整起见，这里提供了关于类型开关的简短讨论。目前，你只需要知道的是，Go提供了类型`interface{}`或空接口作为一个超类型，它由类型系统中的所有其他类型实现。当一个值被赋予类型`interface{}`时，可以使用类型`switch`来查询关于其底层类型的信息，如下面的代码片段中的函数`findAny()`所示：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/switchstmt2.go
- en: 'The function `findAny()` takes an `interface{}` as its parameter. The type
    `switch` is used to determine the underlying type and value of the variable `val`
    using the type assertion expression:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`findAny()`以`interface{}`作为其参数。类型`switch`用于使用类型断言表达式确定变量`val`的底层类型和值：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice the use of the keyword `type` in the preceding type assertion expression.
    Each case clause will be tested against the type information queried from `val.(type)`.
    Variable `i` will be assigned the actual value of the underlying type and is used
    to invoke a function with the respective value. The default block is invoked to
    guard against any unexpected type assigned to the parameter `val` parameter. Function
    `findAny` may then be invoked with values of diverse types, as shown in the following
    code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的类型断言表达式中使用了关键字`type`。每个case子句将根据从`val.(type)`查询到的类型信息进行测试。变量`i`将被赋予底层类型的实际值，并用于调用具有相应值的函数。默认块被调用来防范对参数`val`分配的任何意外类型。然后，函数`findAny`可以使用不同类型的值进行调用，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The for statements
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for语句
- en: 'As a language related to the C-family, Go also supports `for` loop style control
    structures. However, as you may have come to expect by now, Go''s `for` statements
    work interestingly differently and simply. The `for` statement in Go supports
    four distinct idioms, as summarized in the following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为与C家族相关的语言，Go也支持`for`循环风格的控制结构。然而，正如你现在可能已经预料到的那样，Go的`for`语句工作方式有趣地不同而简单。Go中的`for`语句支持四种不同的习语，如下表所总结的：
- en: '| **For Statement** | **Usage** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **For语句** | **用法** |'
- en: '| For condition | Used to semantically replace `while` and `do...while` loops:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 条件为|用于语义上替代`while`和`do...while`循环：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Infinite loop | The conditional expression may be omitted to create an infinite
    loop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| 无限循环 | 可以省略条件表达式创建无限循环：'
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Traditional | This is the traditional form of the C-family `for` loop with
    the initializer, test, and update clauses:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '| 传统的 | 这是C家族`for`循环的传统形式，包括初始化、测试和更新子句：'
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| For range | Used to iterate over an expression representing a collection
    of items stored in an array, string (array of rune), slice, map, and channel:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '| For范围 | 用于遍历表示存储在数组、字符串（rune数组）、切片、映射和通道中的项目集合的表达式：'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Notice, as with all other control statements in Go, the `for` statements do
    not use parentheses around their expressions. All statements for the loop code
    block must be enclosed within curly brackets or the compiler will produce an error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与Go中的所有其他控制语句一样，`for`语句不使用括号括住它们的表达式。循环代码块的所有语句必须用大括号括起来，否则编译器会产生错误。
- en: For condition
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于条件
- en: 'The `for` condition uses a construct that is semantically equivalent to the
    `while` loop found in other languages. It uses the keyword `for`, followed by
    a Boolean expression that allows the loop to proceed as long as it is evaluated
    to true. The following abbreviated source listing shows an example of this form
    of the `for` loop:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`条件使用了一个在其他语言中等价于`while`循环的构造。它使用关键字`for`，后面跟着一个布尔表达式，允许循环在评估为true时继续进行。以下是这种形式的`for`循环的缩写源代码清单示例：'
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch03/forstmt.go
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/forstmt.go
- en: The `for` statement, in function `listCurrs()`, iterates as long as the conditional
    expression `i < len(currencencies)` returns `true`. Care must be taken to ensure
    the value of `i` is updated with each iteration to avoid creating an accidental
    infinite loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`listCurrs()`中，`for`语句循环迭代，只要条件表达式`i < len(currencencies)`返回`true`。必须小心确保`i`的值在每次迭代中都得到更新，以避免创建意外的无限循环。
- en: Infinite loop
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无限循环
- en: 'When the Boolean expression is omitted in the `for` statement, the loop runs
    indefinitely, as shown the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当`for`语句中省略布尔表达式时，循环将无限运行，如下例所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is equivalent to the `for(;;)` or the `while (true)` found in other languages,
    such as C or Java.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在其他语言（如C或Java）中找到的`for(;;)`或`while(true)`。
- en: The traditional for statement
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的for语句
- en: 'Go also supports the traditional form of the `for` statement, which includes
    an initialization statement, a conditional expression, and an update statement,
    all separated by a semi-colon. This is the form of the statement that is traditionally
    found in other C-like languages. The following source snippet illustrates the
    use of a traditional for statement in the function `sortByNumber`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持传统形式的`for`语句，其中包括初始化语句、条件表达式和更新语句，所有这些都由分号分隔。这是传统上在其他类C语言中找到的语句形式。以下源代码片段说明了在函数`sortByNumber`中使用传统的for语句：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch03/forstmt.go
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/forstmt.go
- en: 'The previous example implements a selection sort that sorts the `slice` currencies
    by comparing the `Number` field of each `struct` value. The different sections
    of the `for` statement are highlighted using the following snippet of code (from
    the preceding function):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子实现了一个选择排序，它通过比较每个`struct`值的`Number`字段来对`slice` currencies进行排序。`for`语句的不同部分使用以下代码片段进行了突出显示（来自前面的函数）：
- en: '![The traditional for statement](img/B03676_For-Loop.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![传统的for语句](img/B03676_For-Loop.jpg)'
- en: 'It turns out that the traditional `for` statement is a superset of the other
    forms of the loop discussed so far, as summarized in the following table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，传统的`for`语句是迄今为止讨论的循环形式的超集，如下表所总结的那样：
- en: '| **For statement** | **Description** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **For语句** | **描述** |'
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| The initialization statement is omitted. Variable `k` is initialized outside
    of the `for` statement. The idiomatic way, however, is to initialize your variables
    with the `for` statement. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 初始化语句被省略。变量`k`在`for`语句之外被初始化。然而，惯用的方式是用`for`语句初始化你的变量。|'
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| The `update` statement (after the last semi-colon) is omitted here. The developer
    must provide update logic elsewhere or you risk creating an infinite loop. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 这里省略了`update`语句（在最后的分号之后）。开发人员必须在其他地方提供更新逻辑，否则会产生无限循环。|'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| This is equivalent to the `for` condition form (discussed earlier) `for k
    < 10 { ... }`. Again, the variable `k` is expected to be declared prior to the
    loop. Care must be taken to update `k` or you risk creating an infinite loop.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 这相当于`for`条件形式（前面讨论过的）`for k < 10 { ... }`。再次强调，变量`k`预期在循环之前声明。必须小心更新`k`，否则会产生无限循环。|'
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Here, the conditional expression is omitted. As before, this evaluates the
    conditional to `true`, which will produce an infinite loop if proper termination
    logic is not introduced in the loop. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 这里省略了条件表达式。与之前一样，如果在循环中没有引入适当的终止逻辑，这将评估为`true`，将产生无限循环。|'
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This is equivalent to the form `for{ ... }` and produces an infinite loop.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 这相当于形式`for{ ... }`，会产生无限循环。|'
- en: 'The initialization and the `update` statements, in the `for` loop, are regular
    Go statements. As such, they can be used to initialize and update multiple variables,
    as is supported by Go. To illustrate this point, the next example initializes
    and updates two variables, `w1` and `w2`, at the same time in the statement clauses:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中的初始化和`update`语句是常规的Go语句。因此，它们可以用于初始化和更新多个变量，这是Go支持的。为了说明这一点，下一个例子在语句子句中同时初始化和更新两个变量`w1`和`w2`：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: golang.fyi/ch03/forstmt2.go
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/forstmt2.go
- en: The initialization statements initialize variables `w1` and `w2` by calling
    the function `nextPair()`. The condition uses a compound logical expression that
    will keep the loop running as long as it is evaluated to true. Lastly, variables
    `w1` and `w2` are both updated with each iteration of the loop by calling `nextPair()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句通过调用函数`nextPair()`初始化变量`w1`和`w2`。条件使用一个复合逻辑表达式，只要它被评估为true，循环就会继续运行。最后，变量`w1`和`w2`通过调用`nextPair()`在每次循环迭代中都会被更新。
- en: The for range
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for range
- en: 'Lastly, the `for` statement supports one additional form that uses the keyword
    `range` to iterate over an expression that evaluates to an array, slice, map,
    string, or channel. The for-range loop has this generic form:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`for`语句支持使用关键字`range`的另一种形式，用于迭代求值为数组、切片、映射、字符串或通道的表达式。for-range循环具有以下通用形式：
- en: '*for [<identifier-list> :=] range <expression> { ... }*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*for [<identifier-list> :=] range <expression> { ... }*'
- en: 'Depending on the type produced by the `range` expression, there can be up to
    two variables emitted by each iteration, as summarized in the following table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`range`表达式产生的类型，每次迭代可能会产生多达两个变量，如下表所总结的那样：
- en: '| **Range Expression** | **Range Variables** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **Range表达式** | **Range变量** |'
- en: '| Loop over array or slice:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| 循环遍历数组或切片：'
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| The range produces two values, where `i` is the loop index and `v` is the
    value `v[i]` from the collection. Further discussions on array and slice are covered
    in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite Types*. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| range产生两个值，其中`i`是循环索引，`v`是集合中的值`v[i]`。有关数组和切片的进一步讨论在[第7章](ch07.html "第7章. 复合类型")中有所涵盖，*复合类型*。|'
- en: '| Loop over string value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| 循环遍历字符串值：'
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| The range produces two values, where `i` is the index of byte in the string
    and `v` is the value of the UTF-8 encoded byte at `v[i]` returned as a rune. Further
    discussion on the string type is covered in in [Chapter 4](ch04.html "Chapter 4. Data
    Types"), *Data Types*. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `range`产生两个值，其中`i`是字符串中字节的索引，`v`是在`v[i]`处返回的UTF-8编码字节的值作为rune。有关字符串类型的进一步讨论在[第4章](ch04.html
    "第4章。数据类型")中有所涵盖，*数据类型*。|'
- en: '| Loop over map:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| 循环地图：'
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| The `range` produces two values, where `k` is assigned the value of the map
    key of type `K` and `v` gets stored at `map[k]` of type `V`. Further discussion
    on map is covered in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite
    Types*. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `range`产生两个值，其中`k`被赋予类型为`K`的地图键的值，`v`被存储在类型为`V`的`map[k]`中。有关地图的进一步讨论在[第7章](ch07.html
    "第7章。复合类型")中有所涵盖，*复合类型*。|'
- en: '| Loop on channel values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '| 循环通道值：'
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| An adequate discussion of channels is covered in [Chapter 9](ch09.html "Chapter 9. Concurrency"),
    *Concurrency*. A channel is a two-way conduit able to receive and emit values.
    The `for...range` statement assigns each value received from the channel to variable
    `c` with each iteration. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 有关通道的充分讨论在[第9章](ch09.html "第9章。并发")中有所涵盖，*并发*。通道是一个能够接收和发出值的双向导管。`for...range`语句将从通道接收到的每个值分配给变量`c`，每次迭代。|'
- en: 'You should be aware that the value emitted with each iteration is a copy of
    the original item stored in the source. For instance, in the following program,
    the values in the slice do not get updated after the loop completes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，每次迭代发出的值都是源中存储的原始项目的副本。例如，在以下程序中，循环完成后，切片中的值不会被更新：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To update the original value using the `for...range` loop, use the index expression
    to access the original value, as illustrated in the following.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`for...range`循环更新原始值，使用索引表达式访问原始值，如下所示。
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the previous example, value `i` is used in a slice index expression  `vals[i]`
    to update the original value stored in the slice. It is possible to omit the iteration
    value (the second variable in the assignment) if you only need access to the index
    value of an array, slice, or string (or key for a map). For instance, in the following
    example, the `for...range` statement only emits the current index value with each
    iteration:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，值`i`用于切片索引表达式`vals[i]`来更新存储在切片中的原始值。如果您只需要访问数组、切片或字符串（或地图的键）的索引值，则可以省略迭代值（赋值中的第二个变量）。例如，在以下示例中，`for...range`语句只在每次迭代中发出当前索引值：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: golang.fyi/ch03/for-range-stmt.go
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/for-range-stmt.go
- en: 'Finally, there are some situations where you may not be interested in any of
    the values generated by the iteration, but rather the iteration mechanic itself.
    The next form of the for statement was introduced (as of Version 1.4 of Go) to
    express a for range without any variable declaration as shown in the following
    code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些情况下，您可能对迭代生成的任何值都不感兴趣，而是对迭代机制本身感兴趣。引入了for语句的下一形式（截至Go的1.4版本）来表达不带任何变量声明的for范围，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The previous code will print `"Looping"` four times on the standard output.
    This form of the `for...range` loop is used sometimes when the range expression
    is over a channel. It is used to simply notify of the presence of a value in the
    channel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在标准输出上打印四次`"Looping"`。当范围表达式在通道上时，这种形式的`for...range`循环有时会被使用。它用于简单地通知通道中存在值。
- en: The break, continue, and goto statements
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`break`，`continue`和`goto`语句'
- en: Go supports a group of statements designed specifically to exit abruptly out
    of a running code block, such as switch and for statement, and transfer control
    to a different section of the code. All three statements can accept a label identifier
    that specifies a targeted location in the code where control is to be transferred.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持一组专门设计用于突然退出运行中的代码块的语句，例如`switch`和`for`语句，并将控制转移到代码的不同部分。所有三个语句都可以接受一个标签标识符，该标识符指定了代码中要转移控制的目标位置。
- en: The label identifier
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签标识符
- en: 'Before diving into the core of this section, it is worthwhile to look at the
    label used by these statements. Declaring a label in Go requires an identifier
    followed by a colon, as shown in the following snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本节的核心之前，值得看一下这些语句使用的标签。在Go中声明标签需要一个标识符，后面跟着一个冒号，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Naming your label is a matter of style. However, one should follow the identifier
    naming guidelines covered in the previous chapter. A label must be enclosed within
    a function. The Go compiler will not allow unused labels to dangle in the code.
    Similar to variables, if a label is declared, it must be referenced in the code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 给标签命名是一种风格问题。但是，应该遵循前一章中介绍的标识符命名指南。标签必须包含在函数内。与变量类似，如果声明了标签，则必须在代码中引用它，否则Go编译器将不允许未使用的标签在代码中悬挂。
- en: The break statement
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`break`语句'
- en: 'As in other C-like languages, the Go `break` statement terminates and exits
    the innermost enclosing `switch` or `for` statement code block and transfers control
    to another part of the running program. The `break` statement can accept an optional
    label identifier specifying a labeled location, in the enclosing function, where
    the flow of the program will resume. Here are some attributes of the label for
    the `break` statement to remember:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类似C的语言一样，Go的`break`语句终止并退出最内层的包围`switch`或`for`语句代码块，并将控制转移到运行程序的其他部分。`break`语句可以接受一个可选的标签标识符，指定在包围函数中程序流将恢复的标记位置。以下是要记住`break`语句标签的一些属性：
- en: The label must be declared within the same running function where the `break`
    statement is located
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签必须在与`break`语句所在的运行函数内声明
- en: A declared label must be followed immediately by the enclosing control statement
    (a `for` loop or `switch` statement) where the break is nested
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的标签必须紧随着包围控制语句（`for`循环或`switch`语句）的位置，其中`break`被嵌套
- en: If a `break` statement is followed by a label, control is transferred, not to
    the location where the label is, but rather to the statement immediately following
    the labeled block. If a label is not provided, the `break` statement abruptly
    exits and transfers control to the next statement following its enclosing `for`
    statement (or `switch` statement) block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`break`语句后面跟着一个标签，控制将被转移到标签所在的位置，而不是紧接着标记块后面的语句。如果没有提供标签，`break`语句会突然退出并将控制转移到其封闭的`for`语句（或`switch`语句）块后面的下一个语句。
- en: 'The following code is an overly exaggerated linear search that illustrates
    the working of the `break` statement. It does a word search and exits once the
    first instance of the word is found in the slice:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个过度夸张的线性搜索，用于说明`break`语句的工作原理。它进行单词搜索，并在找到单词的第一个实例后退出切片：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: golang.fyi/ch03/breakstmt.go
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/breakstmt.go
- en: In the previous code snippet, the `break DoSearch` statement will essentially
    exit out of the innermost `for` loop and cause the execution flow to continue
    after the outermost labeled `for` statement, which in this example, will simply
    end the program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`break DoSearch`语句实质上将退出最内层的`for`循环，并导致执行流在最外层的带标签的`for`语句之后继续，这个例子中，将简单地结束程序。
- en: The continue statement
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续语句
- en: 'The `continue` statement causes the control flow to immediately terminate the
    current iteration of the enclosing `for` loop and jump to the next iteration.
    The `continue` statement can take an optional label as well. The label has similar
    properties to that of the `break` statement:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句导致控制流立即终止封闭的`for`循环的当前迭代，并跳转到下一次迭代。`continue`语句也可以带有可选的标签。标签具有与`break`语句类似的属性：'
- en: The label must be declared within the same running function where the `continue`
    statement is located
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签必须在`continue`语句所在的运行函数内声明
- en: The declared label must be followed immediately by an enclosing `for` loop statement
    where the continue statement is nested
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的标签必须紧随着一个封闭的`for`循环语句，在其中`continue`语句被嵌套
- en: When present, the `continue` statement is reached within a `for` statement block,
    the `for` loop will be abruptly terminated and control will be transferred to
    the outermost labeled `for` loop block for continuation. If a label is not specified,
    the `continue` statement will simply transfer control to the start of its enclosing
    `for` loop block for continuation of the next iteration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当`continue`语句在`for`语句块内部到达时，`for`循环将被突然终止，并且控制将被转移到最外层的带标签的`for`循环块以进行继续。如果未指定标签，`continue`语句将简单地将控制转移到其封闭的`for`循环块的开始，以进行下一次迭代的继续。
- en: 'To illustrate, let us revisit the previous example of word search. This version
    uses a `continue` statement, which causes the search to find multiple occurrences
    of the searched word in the slice:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们重新访问单词搜索的先前示例。这个版本使用了`continue`语句，导致搜索在切片中找到搜索词的多个实例：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: golang.fyi/ch03/breakstmt2.go
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/breakstmt2.go
- en: The `continue DoSearch` statement causes the current iteration of the innermost
    loop to stop and transfer control to the labeled outer loop, causing it to continue
    with the next iteration.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue DoSearch`语句导致最内层循环的当前迭代停止，并将控制转移到带标签的外部循环，导致它继续下一次迭代。'
- en: The goto statement
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: goto语句
- en: 'The `goto` statement is more flexible, in that it allows flow control to be
    transferred to an arbitrary location, inside a function, where a target label
    is defined. The `goto` statement causes an abrupt transfer of control to the label
    referenced by the `goto` statement. The following shows Go''s `goto` statement
    in action in a simple, but functional example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`语句更灵活，因为它允许将流控制转移到函数内定义目标标签的任意位置。`goto`语句会突然转移控制到`goto`语句引用的标签。以下是Go中`goto`语句在一个简单但功能性示例中的示例：'
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: golang.fyi/ch03/gotostmt.go
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch03/gotostmt.go
- en: 'The code uses the `goto` statement to jump to different sections of the `main()`
    function. Notice that the `goto` statement can target labels defined anywhere
    in the code. The superfluous usage of the `Start:` label is left in the code for
    completeness and is not necessary in this context (since continue, without the
    label, would have the same effect). The following provides some guidance when
    using the `goto` statement:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用`goto`语句跳转到`main()`函数的不同部分。请注意，`goto`语句可以定位到代码中任何地方定义的标签。在这种情况下，代码中留下了多余使用`Start:`标签的部分，这在这种情况下是不必要的（因为没有标签的`continue`会产生相同的效果）。以下是在使用`goto`语句时提供一些指导的内容：
- en: Avoid using the `goto` statement unless the logic being implemented can only
    be achieved using `goto` branching. This is because overuse of the `goto` statement
    can make code harder to reason about and debug.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非实现的逻辑只能使用`goto`分支，否则应避免使用`goto`语句。这是因为过度使用`goto`语句会使代码更难以理解和调试。
- en: Place `goto` statements and their targeted label within the same enclosing code
    block when possible.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能将`goto`语句及其目标标签放在同一个封闭的代码块中。
- en: Avoid placing labels where a `goto` statement will cause the flow to skip new
    variable declarations or cause them to be re-declared.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在`goto`语句将流程跳过新变量声明或导致它们被重新声明的地方放置标签。
- en: Go will let you jump from inner to outer enclosing code blocks.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go允许您从内部跳转到外部封闭的代码块。
- en: It is a compilation error if you try to jump to a peer or to an enclosing code
    block.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尝试跳转到对等或封闭的代码块，这将是一个编译错误。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a walkthrough of the mechanism of control flow in Go,
    including `if`, `switch`, and `for` statements. While Go's flow control constructs
    appear simple and easy to use, they are powerful and implement all branching primitives
    expected of a modern language. Readers are introduced to each concept with ample
    detail and examples to ensure clarity of the topics. The next chapter continues
    our look into Go fundamentals by introducing the reader to the Go type systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Go语言中控制流的机制，包括`if`、`switch`和`for`语句。虽然Go的流程控制结构看起来简单易用，但它们功能强大，实现了现代语言所期望的所有分支原语。读者通过丰富的细节和示例介绍了每个概念，以确保主题的清晰度。下一章将继续介绍Go基础知识，向读者介绍Go类型系统。
