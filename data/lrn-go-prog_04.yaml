- en: Chapter 4. Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 第四章。数据类型'
- en: 'Go is a strongly-typed language, which means any language element that stores
    (or expression that produces) a value has a type associated with it. In this chapter,
    readers will learn about the features of the type system as they explore the common
    data types supported by the language as outlined in the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '- Go是一种强类型语言，这意味着存储（或产生）值的任何语言元素都与其关联一个类型。在本章中，读者将了解类型系统的特性，因为他们将探索语言支持的常见数据类型，如下所述：'
- en: Go types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- Go类型'
- en: Numeric types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 数值类型'
- en: Boolean type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 布尔类型'
- en: Pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 指针'
- en: Type declaration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 类型声明'
- en: Type conversion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 类型转换'
- en: Go types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- Go类型'
- en: 'To help launch the conversation about types, let us take a peek at the types
    available. Go implements a simple type system that provides programmers direct
    control over how memory is allocated and laid out. When a program declares a variable,
    two things must take place:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '- 为了帮助启动关于类型的讨论，让我们来看看可用的类型。Go实现了一个简单的类型系统，为程序员提供了直接控制内存分配和布局的能力。当程序声明一个变量时，必须发生两件事：'
- en: The variable must receive a type
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 变量必须接收一个类型'
- en: The variable will also be bound to a value (even when none is assigned)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 变量也将绑定到一个值（即使没有分配任何值）'
- en: This allows the type system to allocate the number of bytes necessary to store
    the declared value. The memory layout for declared variables maps directly to
    their declared types. There is no type boxing or automatic type conversion that
    takes place. The space you expect to be allocated is actually what gets reserved
    in memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '- 这使得类型系统能够分配存储已声明值所需的字节数。已声明变量的内存布局直接映射到它们声明的类型。没有类型装箱或自动类型转换发生。分配的空间实际上就是在内存中保留的空间。'
- en: To demonstrate this fact, the following program uses a special package called
    `unsafe` to circumvent the type system and extract memory size information for
    declared variables. It is important to note that this is purely illustrative as
    most programs do not commonly make use of the `unsafe` package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '- 为了证明这一事实，以下程序使用一个名为 `unsafe` 的特殊包来规避类型系统，并提取已声明变量的内存大小信息。重要的是要注意，这纯粹是为了说明，因为大多数程序通常不常使用
    `unsafe` 包。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch04/alloc.go
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '- golang.fyi/ch04/alloc.go'
- en: 'When the program is executed, it prints out the amount of memory (in bits)
    consumed by each declared variable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '- 当程序执行时，它会打印出每个已声明变量消耗的内存量（以位为单位）：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding output, we can see that variable `a` (of type `uint8`) will
    be stored using eight bits (or one byte), variable `b` using 32 bits (or four
    bytes), and so on. With the ability to influence memory consumption coupled with
    Go's support for pointer types, programmers are able to strongly control how memory
    is allocated and consumed in their programs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '- 从前面的输出中，我们可以看到变量 `a`（类型为 `uint8`）将使用8位（或1字节）存储，变量 `b` 将使用32位（或4字节）存储，依此类推。通过影响内存消耗的能力以及Go对指针类型的支持，程序员能够强力控制内存在其程序中的分配和消耗。'
- en: 'This chapter will cover the types listed in the following table. They include
    basic types such as numeric, Boolean, and strings:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '- 本章将介绍下表中列出的类型。它们包括基本类型，如数值、布尔和字符串：'
- en: '| **Type** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '- **类型** | **描述**'
- en: '| `string` | Type for storing text values |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '- `string` | 用于存储文本值的类型。'
- en: '| `rune` | An integer type (int32) used to represent characters. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '- `rune` | 用于表示字符的整数类型（int32）。'
- en: '| `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | Types for storing integral values. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '- `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | 用于存储整数值的类型。'
- en: '| `float32`, `float64` | Types for storing floating point decimal values. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '- `float32`, `float64` | 用于存储浮点十进制值的类型。'
- en: '| `complex64`, `complex128` | Types that can represent complex numbers with
    both real and imaginary parts. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '- `complex64`, `complex128` | 可以表示具有实部和虚部的复数的类型。'
- en: '| `bool` | Type for Boolean values. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '- `bool` | 用于布尔值的类型。'
- en: '| `*T`, pointer to type T | A type that represents a memory address where a
    value of type T is stored. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '- `*T`，指向类型 T 的指针 | 代表存储类型为 T 的值的内存地址的类型。'
- en: The remaining types supported by Go, such as those listed in the following table,
    include composite, interface, function, and channels. They are covered later in
    chapters dedicated to their respective topics.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '- Go支持的其余类型，如下表中列出的类型，包括复合类型、接口、函数和通道。它们将在专门讨论它们的章节中进行介绍。'
- en: '| **Type** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '- **类型** | **描述**'
- en: '| Array `[n]T` | An ordered collection of fixed size `n` of numerically indexed
    sequence of elements of a type `T`. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '- 数组 `[n]T` | 由类型 `T` 的元素组成的具有固定大小 `n` 的有序集合。'
- en: '| Slice`[]T` | A collection of unspecified size of numerically indexed sequence
    of elements of type `T`. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '- 切片`[]T` | 由类型 `T` 的元素组成的未指定大小的有序集合。'
- en: '| `struct{}` | A structure is a composite type composed of elements known as
    fields (think of an object). |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '- `struct{}` | 结构是由称为字段的元素组成的复合类型（类似于对象）。'
- en: '| `map[K]T` | An unordered sequence of elements of type `T` indexed by a key
    of arbitrary type `K`. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '- `map[K]T` | 由任意类型 `K` 的键索引的类型为 `T` 的元素的无序序列。'
- en: '| `interface{}` | A named set of function declarations that define a set of
    operations that can be implemented by other types. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '- `interface{}` | 一组命名的函数声明，定义了其他类型可以实现的一组操作。'
- en: '| `func (T) R` | A type that represents all functions with a given parameter
    type `T` and return type `R`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '- `func (T) R` | 代表具有给定参数类型 `T` 和返回类型 `R` 的所有函数的类型。'
- en: '| `chan T` | A type for an internal communication channel to send or receive
    values of type `T`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '- `chan T` | 用于内部通信通道的类型，用于发送或接收类型为 `T` 的值。'
- en: Numeric types
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 数值类型'
- en: Go's numeric types include support for integral and decimal values with a variety
    of sizes ranging from 8 to 64 bits. Each numeric type has its own layout in memory
    and is considered unique by the type system. As a way of enforcing this, and to
    avoid any sort of confusion when porting Go on different platforms, the name of
    a numeric type reflects its size requirement. For instance, type `*int16*` indicates
    an integer type that uses 16 bits for internal storage*.* This means that numberic
    values must be explicitly be converted when crossing type boundaries in assignments,
    expressions, and operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go的数字类型包括对从8位到64位的各种大小的整数和小数值的支持。 每种数字类型在内存中都有自己的布局，并且被类型系统视为独特的。 为了强制执行这一点，并且避免在不同平台上移植Go时出现任何混淆，数字类型的名称反映了其大小要求。
    例如，类型`*int16*`表示使用16位进行内部存储的整数类型。 这意味着在赋值、表达式和操作中跨类型边界时，必须明确地转换数值。
- en: The following program is not all that functional, since all values are assigned
    to the blank identifier. However, it illustrates all of the numeric data types
    supported in Go.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序并不是非常实用，因为所有值都被分配给了空白标识符。 但是，它展示了Go中支持的所有数字数据类型。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch04/nums.go
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/nums.go
- en: Unsigned integer types
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无符号整数类型
- en: 'The following table lists all available types that can represent unsigned integers
    and their storage requirements in Go:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了Go中可以表示无符号整数及其存储要求的所有可用类型：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `uint8` | Unsigned 8-bit | Range 0 - 255 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `uint8` | 无符号8位 | 范围0-255 |'
- en: '| `uint16` | Unsigned 16-bit | Range 0 - 65535 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `uint16` | 无符号16位 | 范围0-65535 |'
- en: '| `uint32` | Unsigned 32-bit | Range 0 - 4294967295 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | 无符号32位 | 范围0-4294967295 |'
- en: '| `uint64` | Unsigned 64-bit | Range 0 - 18446744073709551615 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | 无符号64位 | 范围0-18446744073709551615 |'
- en: '| `uint` | Implementation specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `uint` represents a
    32-bit unsigned integer. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | 实现特定 | 预先声明的类型，旨在表示32位或64位整数。 截至Go的1.x版本，`uint`表示32位无符号整数。 |'
- en: '| `byte` | Unsigned 8-bit | Alias for the `unit8` type. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 无符号8位 | `unit8`类型的别名。 |'
- en: '| `uintptr` | Unsigned | An unsigned integer type designed to store pointers
    (memory addresses) for the underlying machine architecture. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `uintptr` | 无符号 | 一种设计用于存储底层机器体系结构的指针（内存地址）的无符号整数类型。 |'
- en: Signed integer types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有符号整数类型
- en: 'The following table lists all available types that can represent signed integers
    and their storage requirements in Go:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了Go中可以表示有符号整数及其存储要求的所有可用类型：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `int8` | Signed 8-bit | Range -128 - 127 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `int8` | 有符号8位 | 范围-128 - 127 |'
- en: '| `int16` | Signed 16-bit | Range -32768 - 32767 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `int16` | 有符号16位 | 范围-32768 - 32767 |'
- en: '| `int32` | Signed 32-bit | Range -2147483648 - 2147483647 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | 有符号32位 | 范围-2147483648 - 2147483647 |'
- en: '| `int64` | Signed 64-bit | Range -9223372036854775808 - 9223372036854775807
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | 有符号64位 | 范围-9223372036854775808 - 9223372036854775807 |'
- en: '| `int` | Implementati specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `int` represents a
    32-bit signed integer. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 实现特定 | 预先声明的类型，旨在表示32位或64位整数。 截至Go的1.x版本，`int`表示32位有符号整数。 |'
- en: Floating point types
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'Go supports the following types for representation of decimal values using
    IEEE standards:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持以下类型来表示使用IEEE标准的十进制值：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `float32` | Signed 32-bit | IEEE-754 standard representation of single precision
    floating point values. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | 有符号32位 | 单精度浮点值的IEEE-754标准表示。 |'
- en: '| `float64` | Signed 64-bit | IEEE-754 standard representation of double-precision
    floating point values. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | 有符号64位 | 双精度浮点值的IEEE-754标准表示。 |'
- en: Complex number types
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数类型
- en: 'Go also supports representation of complex numbers with both imaginary and
    real parts as shown by the following table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Go还支持表示具有虚部和实部的复数，如下表所示：
- en: '| **Type** | **Size** | **Description** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **大小** | **描述** |'
- en: '| `complex64` | float32 | Represents complex numbers with real and imaginary
    parts stored as `float32` values. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | float32 | 以`float32`值存储的实部和虚部表示复数。 |'
- en: '| `complex128` | float64 | Represents complex numbers with real and imaginary
    parts stored as `float64` values. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` | float64 | 以`float64`值存储的实部和虚部表示复数。 |'
- en: Numeric literals
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字文字
- en: 'Go supports the natural representation of integer values using a sequence of
    digits with a combination of a sign and decimal point (as seen in the previous
    example). Optionally, Go integer literals can also represent hexadecimal and octal
    numbers as illustrated in the following program:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持使用数字序列和符号以及小数点的组合来自然表示整数值（如前面的例子所示）。 可选地，Go整数文字也可以表示十六进制和八进制数字，如下面的程序所示：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch04/intslit.go
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/intslit.go
- en: 'Hexadecimal values are prepended with the `0x` or (`0X`) prefix while octal
    values start with the number 0 as shown in the previous example. Floating point
    values can be represented using both decimal and exponential notations as shown
    in the following examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制值以`0x`或（`0X`）前缀开头，而八进制值以前面示例中显示的数字0开头。 浮点值可以使用十进制和指数表示法表示，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: golang.fyi/ch04/floats.go
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/floats.go
- en: 'The previous program shows several representations of floating point literals
    in Go. Numbers can include an optional exponent portion indicated by `e` (or `E`)
    at the end of the number. For instance, `1.616199e-35` in the code represents
    numerical value 1.616199 x 10^(-35). Lastly, Go supports literals for expressing
    complex numbers as shown in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序展示了Go中浮点文字的几种表示。 数字可以包括一个可选的指数部分，该部分由数字末尾的`e`（或`E`）表示。 例如，代码中的`1.616199e-35`表示数值1.616199
    x 10^(-35)。 最后，Go支持用于表示复数的文字，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch04/complex.go
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/complex.go
- en: In the previous example, variable `a` is assigned a complex number with both
    a real and an imaginary part. The imaginary literal is a floating point number
    followed by the letter `i`. Notice that Go also offers two built-in functions,
    `real()` and `imag(),` to deconstruct complex numbers into their real and imaginary
    parts respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，变量`a`被分配了一个具有实部和虚部的复数。虚部文字是一个浮点数，后面跟着字母`i`。请注意，Go还提供了两个内置函数，`real()`和`imag()`，分别用于将复数分解为其实部和虚部。
- en: Boolean type
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'In Go, Boolean binary values are stored using the `bool` type. Although a variable
    of type `bool` is stored as a 1-byte value, it is not, however, an alias for a
    numeric value. Go provides two pre-declared literals, `true` and `false`, to represent
    Boolean values as shown in the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，布尔二进制值使用`bool`类型存储。虽然`bool`类型的变量存储为1字节值，但它并不是数值的别名。Go提供了两个预声明的文字，`true`和`false`，用于表示布尔值，如下例所示：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch04/bool.go
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/bool.go
- en: Rune and string types
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符文和字符串类型
- en: In order to start our discussion about the `rune` and `string` types, some background
    context is in order. Go can treat character and string literal constants in its
    source code as Unicode. It is a global standard whose goal is to catalog symbols
    for known writing systems by assigning a numerical value (known as code point)
    to each character.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们关于`rune`和`string`类型的讨论，需要一些背景知识。Go可以将其源代码中的字符和字符串文字常量视为Unicode。这是一个全球标准，其目标是通过为每个字符分配一个数值（称为代码点）来记录已知书写系统的符号。
- en: By default, Go inherently supports UTF-8 which is an efficient way of encoding
    and storing Unicode numerical values. That is all the background needed to continue
    with this subject. No further detail will be discussed as it is beyond the scope
    of this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，Go本身支持UTF-8，这是一种有效的编码和存储Unicode数值的方式。这就是继续这个主题所需的所有背景。不会讨论更多细节，因为这超出了本书的范围。 '
- en: The rune
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符文
- en: 'So, what exactly does the `rune` type have to do with Unicode? The rune is
    an alias for the *int32* type. It is specifically intended to store Unicode integer
    values encoded as UTF-8\. Let us take a look at some rune literals in the following
    program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`rune`类型与Unicode有什么关系呢？`rune`是`int32`类型的别名。它专门用于存储以UTF-8编码的Unicode整数值。让我们在下面的程序中看一些`rune`文字：
- en: '![The rune](img/B03676_04_runes.go-snippet.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: ！[符文](img/B03676_04_runes.go-snippet.jpg)
- en: golang.fyi/ch04/rune.go
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/rune.go
- en: 'Each variable in the previous program stores a Unicode character as a `rune`
    value. In Go, the `rune` may be specified as a string literal constant surrounded
    by single quotes. The literal may be one of the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个程序中的每个变量都存储一个Unicode字符作为`rune`值。在Go中，`rune`可以被指定为由单引号括起来的字符串文字常量。文字可以是以下之一：
- en: A printable character (as shown with variables `char1`, `char2`, and `char3`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可打印字符（如变量`char1`、`char2`和`char3`所示）
- en: A single character escaped with backslash for non-printable control values as
    tab, linefeed, newline, and so on
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用反斜杠转义的单个字符，用于不可打印的控制值，如制表符、换行符、换行符等
- en: '`\u` followed by Unicode values directly (`\u0369`)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u`后直接跟Unicode值（`\u0369`）'
- en: '`\x` followed by two hex digits'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\x`后跟两个十六进制数字'
- en: A backslash followed by three octal digits (`\045`)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠后跟三个八进制数字（`\045`）
- en: 'Regardless of the `rune` literal value within the single quotes, the compiler
    compiles and assigns an integer value as shown by the printout of the previous
    variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论单引号内的`rune`文字值如何，编译器都会编译并分配一个整数值，如上一个变量的打印输出所示：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The string
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'In Go, a string is implemented as a slice of immutable byte values. Once a
    string value is assigned to a variable, the value of that string is never changed.
    Typically, string values are represented as constant literals enclosed within
    double quotes as shown in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，字符串被实现为不可变字节值的切片。一旦将字符串值分配给变量，该字符串的值就不会改变。通常，字符串值被表示为双引号括起来的常量文字，如下例所示：
- en: '![The string](img/B03676_04_strings.go-snippet.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: ！[字符串](img/B03676_04_strings.go-snippet.jpg)
- en: golang.fyi/ch04/string.go
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/string.go
- en: The previous snippet shows variable `txt` being assigned a string literal containing
    seven characters including two embedded Chinese characters. As referenced earlier,
    the Go compiler will automatically interpret string literal values as Unicode
    characters and encode them using UTF-8\. This means that under the cover, each
    literal character is stored as a `rune` and may end up taking more than one byte
    for storage per visible character. In fact, when the program is executed, it prints
    the length of `txt` as `11`, instead of the expected seven characters for the
    string, accounting for the additional bytes used for the Chinese symbols.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个片段显示了变量`txt`被分配了一个包含七个字符的字符串文字，其中包括两个嵌入的中文字符。正如前面提到的，Go编译器会自动将字符串文字值解释为Unicode字符，并使用UTF-8对其进行编码。这意味着在底层，每个文字字符都被存储为`rune`，并且可能需要多于一个字节的存储空间来存储每个可见字符。事实上，当程序执行时，它打印出`txt`的长度为`11`，而不是预期的字符串的七个字符，这考虑到了用于中文符号的额外字节。
- en: Interpreted and raw string literals
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释和原始字符串文字
- en: 'The following snippet (from the previous example) includes two string literals
    assigned to variable `txt2` and `txt3` respectively. As you can see, these two
    literals have the exact same content, however, the compiler will treat them differently:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段（来自上一个示例）包括分配给变量`txt2`和`txt3`的两个字符串文字。正如你所看到的，这两个文字具有完全相同的内容，然而，编译器会对它们进行不同的处理：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: golang.fyi/ch04/string.go
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch04/string.go
- en: 'The literal value assigned to variable `txt2` is enclosed in double quotes.
    This is known as an interpreted string. An interpreted string may contain normal
    printable characters as well as backslash-escaped values which are parsed and
    interpreted as `rune` literals. So, when `txt2` is printed, the escape values
    are translated as the following string:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`txt2`分配的文字值用双引号括起来。这被称为解释字符串。解释字符串可以包含普通的可打印字符，也可以包含反斜杠转义值，这些值被解析并解释为`rune`文字。因此，当打印`txt2`时，转义值被翻译为以下字符串：
- en: '![Interpreted and raw string literals](img/B03676-04-bingslife-snippet.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![解释和原始字符串文字](img/B03676-04-bingslife-snippet.jpg)'
- en: 'Each symbol, in the interpreted string, corresponds to an escape value or a
    printable symbol as summarized in the following table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释字符串中，每个符号对应一个转义值或可打印符号，如下表所总结的：
- en: '| ![Interpreted and raw string literals](img/B03676-water-chinese.jpg) | **<space>**
    | **brings** | **<space>** | **life** | . |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| ![解释和原始字符串文字](img/B03676-water-chinese.jpg) | **<space>** | **带来** | **<space>**
    | **生命** | . |'
- en: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| \u6C34 | \x20 | 带来 | \x20 | \x6c\x69\x66\x65 | . |'
- en: On the other hand, the literal value assigned to variable `txt3` is surrounded
    by the grave accent characters [PRE9]
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，变量`txt3`分配的文字值被反引号字符[PRE9]包围
- en: \u6C34\x20brings\x20\x6c\x69\x66\x65.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: \u6C34\x20带来\x20\x6c\x69\x66\x65。
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: package main
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import "fmt"
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: import "fmt"
- en: var valPtr *float32
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: var valPtr *float32
- en: var countPtr *int
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: var countPtr *int
- en: var person *struct {
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: var person *struct {
- en: name string
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: name string
- en: age  int
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 年龄  int
- en: '}'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: var matrix *[1024]int
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: var matrix *[1024]int
- en: var row []*int64
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: var row []*int64
- en: func main() {
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: fmt.Println(valPtr, countPtr, person, matrix, row)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Println(valPtr, countPtr, person, matrix, row)
- en: '}'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: package main
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import "fmt"
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: import "fmt"
- en: func main() {
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: var a int = 1024
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: var a int = 1024
- en: var aptr *int = &a
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: var aptr *int = &a
- en: fmt.Printf("a=%v\n", a)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("a=%v\n", a)
- en: fmt.Printf("aptr=%v\n", aptr)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("aptr=%v\n", aptr)
- en: '}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: var a int = 1024
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: var a int = 1024
- en: var aptr *int = &a
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: var aptr *int = &a
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: a=1024
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: a=1024
- en: aptr=0xc208000150
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: aptr=0xc208000150
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: var aptr *int = &1024
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: var aptr *int = &1024
- en: fmt.Printf("a ptr1 = %v\n", aptr)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("a ptr1 = %v\n", aptr)
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: package main
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import "fmt"
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: import "fmt"
- en: func main() {
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: structPtr := &struct{ x, y int }{44, 55}
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: structPtr := &struct{ x, y int }{44, 55}
- en: pairPtr := &[2]string{"A", "B"}
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: pairPtr := &[2]string{"A", "B"}
- en: fmt.Printf("struct=%#v, type=%T\n", structPtr, structPtr)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("struct=%#v, type=%T\n", structPtr, structPtr)
- en: fmt.Printf("pairPtr=%#v, type=%T\n", pairPtr, pairPtr)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("pairPtr=%#v, type=%T\n", pairPtr, pairPtr)
- en: '}'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: package main
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import "fmt"
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: import "fmt"
- en: func main() {
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: intptr := new(int)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: intptr := new(int)
- en: '*intptr = 44'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*intptr = 44'
- en: p := new(struct{ first, last string })
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: p := new(struct{ first, last string })
- en: p.first = "Samuel"
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: p.first = "Samuel"
- en: p.last = "Pierre"
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: p.last = "Pierre"
- en: fmt.Printf("Value %d, type %T\n", *intptr, intptr)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("Value %d, type %T\n", *intptr, intptr)
- en: fmt.Printf("Person %+v\n", p)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("Person %+v\n", p)
- en: '}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: package main
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import (
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: import (
- en: '"fmt"'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '"fmt"'
- en: '"strings"'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '"strings"'
- en: )
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: func main() {
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: a := 3
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: a := 3
- en: double(&a)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: double(&a)
- en: fmt.Println(a)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Println(a)
- en: p := &struct{ first, last string }{"Max", "Planck"}
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: p := &struct{ first, last string }{"Max", "Planck"}
- en: cap(p)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: cap(p)
- en: fmt.Println(p)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Println(p)
- en: '}'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func double(x *int) {
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: func double(x *int) {
- en: '*x = *x * 2'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*x = *x * 2'
- en: '}'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func cap(p *struct{ first, last string }) {
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: func cap(p *struct{ first, last string }) {
- en: p.first = strings.ToUpper(p.first)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: p.first = strings.ToUpper(p.first)
- en: p.last = strings.ToUpper(p.last)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: p.last = strings.ToUpper(p.last)
- en: '}'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*x * 2'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*x * 2'
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*(*x) * 2'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*(*x) * 2'
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 3 * 2 = 6
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 3 * 2 = 6
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*(*x) = 6'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*(*x) = 6'
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: type truth bool
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 truth bool
- en: type quart float64
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 quart float64
- en: type gallon float64
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 gallon float64
- en: type node string
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 node string
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: package main
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import "fmt"
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: import "fmt"
- en: type fahrenheit float64
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 fahrenheit float64
- en: type celsius float64
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 celsius float64
- en: type kelvin float64
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 kelvin float64
- en: func fharToCel(f fahrenheit) celsius {
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: func fharToCel(f fahrenheit) celsius {
- en: return celsius((f - 32) * 5 / 9)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: return celsius((f - 32) * 5 / 9)
- en: '}'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func fharToKel(f fahrenheit) celsius {
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: func fharToKel(f fahrenheit) celsius {
- en: return celsius((f-32)*5/9 + 273.15)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: return celsius((f-32)*5/9 + 273.15)
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func celToFahr(c celsius) fahrenheit {
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: func celToFahr(c celsius) fahrenheit {
- en: return fahrenheit(c*5/9 + 32)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: return fahrenheit(c*5/9 + 32)
- en: '}'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func celToKel(c celsius) kelvin {
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: func celToKel(c celsius) kelvin {
- en: return kelvin(c + 273.15)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: return kelvin(c + 273.15)
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: func main() {
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: var c celsius = 32.0
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: var c celsius = 32.0
- en: f := fahrenheit(122)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: f := fahrenheit(122)
- en: fmt.Printf("%.2f \u00b0C = %.2f \u00b0K\n", c, celToKel(c))
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("%.2f \u00b0C = %.2f \u00b0K\n", c, celToKel(c))
- en: fmt.Printf("%.2f \u00b0F = %.2f \u00b0C\n", f, fharToCel(f))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Printf("%.2f \u00b0F = %.2f \u00b0C\n", f, fharToCel(f))
- en: '}'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: package main
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: package main
- en: import "fmt"
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: import "fmt"
- en: type signal int
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类型信号 int
- en: func main() {
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: var count int32
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: var count int32
- en: var actual int
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: var actual int
- en: var test int64 = actual + count
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: var test int64 = actual + count
- en: var sig signal
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: var sig signal
- en: var event int = sig
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: var event int = sig
- en: fmt.Println(test)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Println(test)
- en: fmt.Println(event)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: fmt.Println(event)
- en: '}'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: type signal int
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类型信号 int
- en: func main() {
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: func main() {
- en: var count int32
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: var count int32
- en: var actual int
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: var actual int
- en: var test int32 = int32(actual) + count
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: var test int32 = int32(actual) + count
- en: var sig signal
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: var sig signal
- en: var event int = int(sig)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: var event int = int(sig)
- en: '}'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: var i int
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: var i int
- en: var i2 int32 = int32(i)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: var i2 int32 = int32(i)
- en: var re float64 = float64(i +   int(i2))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: var re float64 = float64(i +   int(i2))
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: var cn64 complex64
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: var cn64 complex64
- en: var cn128 complex128 =   complex128(cn64)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: var cn128 complex128 =   complex128(cn64)
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: type signal int
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类型信号 int
- en: var sig signal
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: var sig signal
- en: var event int = int(sig)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: var event int = int(sig)
- en: '[PRE29]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: a := string(72)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: a := string(72)
- en: b := string(int32(101))
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: b := string(int32(101))
- en: c := string(rune(108))
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: c := string(rune(108))
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: msg0 := string([]byte{'H','i'})
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: msg0 := string([]byte{'H','i'})
- en: msg1 := string([]rune{'Y','o','u','!'})
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: msg1 := string([]rune{'Y','o','u','!'})
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: data0 := []byte("Hello")
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: data0 := []byte("Hello")
- en: data0 := []int32("World!")
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: data0 := []int32("World!")
- en: '```'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: '|'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Additionally, the conversion rules also work when the target type and converted
    value are pointers that reference the same types. Besides these scenarios in the
    previous table, Go types cannot be explicitly converted. Any attempt to do so
    will result in a compilation error.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当目标类型和转换值是引用相同类型的指针时，转换规则也适用。除了上表中的这些情况外，Go类型不能被显式转换。任何尝试这样做都将导致编译错误。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: This chapter presented its readers with an introduction the Go type system.
    The chapter opened with an overview of types and dove into a comprehensive exploration
    of the basic built-in types such as numeric, Boolean, string, and pointer types.
    The discussion continued by exposing the reader to other important topics such
    as named type definition. The chapter closed with coverage of the mechanics of
    type conversion. In coming chapters, you will get a chance to learn more about
    other types such as composite, function, and interface.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向读者介绍了Go类型系统。本章以类型概述开篇，深入全面地探讨了基本内置类型，如数字、布尔、字符串和指针类型。讨论继续暴露读者对其他重要主题，如命名类型定义。本章以类型转换的机制结束。在接下来的章节中，您将有机会了解其他类型，如复合类型、函数类型和接口类型。
