- en: Chapter 5. Functions in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Go中的函数
- en: 'One of Go''s syntactical *tour de force* is via its support for higher-order
    functions as is found in dynamic languages such as Python or Ruby. As we will
    see in this chapter, a function is also a typed entity with a value that can be
    assigned to a variable. In this chapter, we are going to explore functions in
    Go covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go的语法*绝活*之一是通过支持高阶函数，就像在Python或Ruby等动态语言中一样。正如我们将在本章中看到的，函数也是一个具有值的类型实体，可以赋值给变量。在本章中，我们将探讨Go中的函数，涵盖以下主题：
- en: Go functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go函数
- en: Passing parameter values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递参数值
- en: Anonymous functions and closures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数和闭包
- en: Higher-order functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Error signaling handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信号处理
- en: Deferring function calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟函数调用
- en: Function panic and recovery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数恐慌和恢复
- en: Go functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go函数
- en: In Go, functions are first-class, typed programming elements. A declared function
    literal always has a type and a value (the defined function itself) and can optionally
    be bound to a named identifier. Because functions can be used as data, they can
    be assigned to variables or passed around as parameters of other functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，函数是第一类的、有类型的编程元素。声明的函数文字始终具有类型和值（定义的函数本身），并且可以选择地绑定到命名标识符。因为函数可以被用作数据，它们可以被分配给变量或作为其他函数的参数传递。
- en: Function declaration
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数声明
- en: Declaring a function in Go takes the general form illustrated in the following
    figure. This canonical form is used to declare named and anonymous functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中声明函数的一般形式如下图所示。这种规范形式用于声明命名和匿名函数。
- en: '![Function declaration](img/B03676_05_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![函数声明](img/B03676_05_01.jpg)'
- en: The most common form of function definition in Go includes the function's assigned
    identifier in the function literal. To illustrate this, the following table shows
    the source code of several programs with definitions of named functions with different
    combinations of parameters and return types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，最常见的函数定义形式包括函数文字中的函数分配标识符。为了说明这一点，下表显示了几个程序的源代码，其中定义了具有不同参数和返回类型组合的命名函数。
- en: '| **Code** | **Description** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** |'
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch05/func0.go | A function with the name identifier `printPi`. It
    takes no parameter and returns no values. Notice when there is nothing to return,
    the `return` statement is optional. |
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func0.go | 一个名为`printPi`的函数。它不接受参数，也不返回任何值。请注意，当没有要返回的内容时，`return`语句是可选的。|
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: golang.fyi/ch05/func1.go | A function named `avogadro.` It takes no parameter
    but returns a value of type `float64`. Notice the `return` statement is required
    when a return value is declared as part of the function's signature. |
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func1.go | 一个名为`avogadro`的函数。它不接受参数，但返回一个`float64`类型的值。请注意，当返回值在函数签名中声明时，`return`语句是必需的。|
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: golang.fyi/ch05/func2.go | This defines the function `fib`. It takes parameter
    `n` of type `int` and prints the Fibonacci sequence for up to `n`. Again, nothing
    to return, therefore the `return` statement is omitted. |
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func2.go | 这定义了`fib`函数。它接受类型为`int`的参数`n`，并打印出最多`n`的斐波那契数列。同样，没有要返回的内容，因此省略了`return`语句。|
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: golang.fyi/ch05/func3.go | The last example defines the `isPrime` function.
    It takes a parameter of type `int` and returns a value of type `bool`. Since the
    function is declared to return a value of type `bool`, the last logical statement
    in the execution flow must be a `return` statement that returns a value of the
    declared type. |
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/func3.go | 最后一个示例定义了`isPrime`函数。它接受一个`int`类型的参数，并返回一个`bool`类型的值。由于函数声明要返回一个`bool`类型的值，因此执行流程中的最后一个逻辑语句必须是一个`return`语句，返回声明类型的值。|
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Function signature**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数签名**'
- en: The set of specified parameter types, result types, and the order in which those
    types are declared is known as the signature of the function. It is another unique
    characteristic that help identify a function. Two functions may have the same
    number of parameters and result values; however, if the order of those elements
    are different, then the functions have different signatures.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的参数类型、结果类型和这些类型声明的顺序被称为函数的签名。这是另一个帮助识别函数的独特特征。两个函数可能具有相同数量的参数和结果值；然而，如果这些元素的顺序不同，那么这些函数就具有不同的签名。
- en: The function type
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'Normally, the name identifier, declared in a function literal, is used to invoke
    the function using an invocation expression whereby the function identifier is
    followed by a parameter list. This is what we have seen throughout the book so
    far and it is illustrated in the following example calling the `fib` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数文字中声明的名称标识符用于使用调用表达式调用函数，其中函数标识符后面跟着参数列表。这是我们迄今为止在整本书中看到的，并且在下面的示例中调用`fib`函数中有所说明：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When, however, a function''s identifier appears without parentheses, it is
    treated as a regular variable with a type and a value as shown in the following
    program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当函数的标识符出现时，没有括号，它被视为一个具有类型和值的常规变量，如下面的程序所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: golang.fyi/ch05/functype.go
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/functype.go
- en: The type of a function is determined by its signature. Functions are considered
    to be of the same type when they have the same number of arguments with the same
    types in the same order. In the previous example the `opAdd` variable is declared
    having the type `func (int, int) int` . This is the same signature as the declared
    functions `add` and `sub`. Therefore, the `opAdd` variable is assigned the `add`
    function variable. This allows `opAdd` to be invoked as you would invoke the `add`
    function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的类型由其签名确定。当具有相同数量的参数、相同类型和相同顺序的参数时，函数被认为是相同类型的。在前面的示例中，`opAdd`变量被声明为`func
    (int, int) int`类型。这与声明的`add`和`sub`函数相同。因此，`opAdd`变量被赋予`add`函数变量。这允许像调用`add`函数一样调用`opAdd`。
- en: The same is done for the  `opSub` variable. It is assigned the value represented
    by the function identifier `sub` and type `func (int, int)`. Therefore, `opSub(99,13)`
    invokes the second function, which returns the result of a subtraction.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`opAdd`变量也是同样的操作。它被赋予了由函数标识符`add`和类型`func(int, int)`表示的值。因此，`opAdd(3,5)`调用了第一个函数，返回了加法的结果。
- en: Variadic parameters
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数
- en: The last parameter of a function can be declared as **variadic** (**variable
    length arguments**) by affixing ellipses (`…`) before the parameter's type. This
    indicates that zero or more values of that type may be passed to the function
    when it is called.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一个参数可以通过在参数类型之前添加省略号(`…`)来声明为**可变参数**（**可变长度参数**）。这表示在调用函数时可以传递零个或多个该类型的值。
- en: 'The following example implements two functions that accept variadic parameters.
    The first function calculates the average of the passed values and the second
    function sums up the numbers passed in as arguments:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例实现了两个接受可变参数的函数。第一个函数计算传入值的平均值，第二个函数对传入的数字进行求和：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: golang.fyi/ch05/funcvariadic.go
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcvariadic.go
- en: 'The compiler resolves the variadic parameter as a slice of type `[]float64`
    in both the preceding functions. The parameter values can then be accessed using
    a slice expression as shown in the previous example. To invoke functions with
    variadic arguments, simply provide a comma-separated list of values that matches
    the specified type as shown in the following snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在前述两个函数中将可变参数解析为`[]float64`类型的切片。然后可以使用切片表达式来访问参数值，就像前面的例子中所示。要调用具有可变参数的函数，只需提供一个逗号分隔的值列表，与指定类型匹配，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When no parameters are provided, the function receives an empty slice. The
    astute reader may be wondering, "Is it possible to pass in an existing slice of
    values as variadic arguments?" Thankfully, Go provides an easy idiom to handle
    such a case. Let''s examine the call to the  `sum` function in the following code
    snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有提供参数时，函数接收到一个空切片。敏锐的读者可能会想，“是否可以将现有值的切片作为可变参数传递进去？”幸运的是，Go提供了一个简单的习语来处理这种情况。让我们来看下面代码片段中对`sum`函数的调用：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A slice of floating-point values is declared and stored in variable `points`.
    The slice can be passed as a variadic parameter by adding ellipses to the parameter
    in the `sum(points...)` function call.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个浮点数值的切片，并将其存储在变量`points`中。通过在`sum(points...)`函数调用中的参数中添加省略号，可以将切片作为可变参数传递。
- en: Function result parameters
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数结果参数
- en: Go functions can be defined to return one or more result values. So far in the
    book, most of the functions we have encountered have been defined to return a
    single result value. In general, a function is able to return a list of result
    values, with diverse types, separated by a comma (see the previous section, *Function
    declaration*).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go函数可以定义返回一个或多个结果值。到目前为止，在本书中，我们遇到的大多数函数都被定义为返回单个结果值。一般来说，一个函数能够返回一个由逗号分隔的不同类型的结果值列表（参见前一节，*函数声明*）。
- en: 'To illustrate this concept, let us examine the following simple program which
    defines a function that implements an Euclidian division algorithm (see [http://en.wikipedia.org/wiki/Division_algorithm](http://en.wikipedia.org/wiki/Division_algorithm)).
    The `div` function returns both the quotient and the remainder values as its result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，让我们来看下面的简单程序，它定义了一个实现欧几里得除法算法的函数（参见[http://en.wikipedia.org/wiki/Division_algorithm](http://en.wikipedia.org/wiki/Division_algorithm)）。`div`函数返回商和余数作为其结果：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: golang.fyi/ch05/funcret0.go
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcret0.go
- en: The `**return**` keyword is followed by the number of result values matching
    (respectively) the declared results in the function's signature. In the previous
    example, the signature of the `div` function specifies two `int` values to be
    returned as result values. Internally, the function defines `int` variables `p`
    and `r` that are returned as result values upon completion of the function. Those
    returned values must match the types defined in the function's signature or risk
    compilation errors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`**return**`关键字后面跟着与函数签名中声明的结果匹配的结果值的数量。在前面的例子中，`div`函数的签名指定了两个`int`值作为结果值返回。在内部，函数定义了`int`变量`p`和`r`，它们在函数完成时作为结果值返回。这些返回的值必须与函数签名中定义的类型匹配，否则会出现编译错误。'
- en: 'Functions with multiple result values must be invoked in the proper context:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个结果值的函数必须在适当的上下文中调用：
- en: They must be assigned to a list of identifiers of the same types respectively
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须分别分配给相同类型的标识符列表
- en: They can only be included in expressions that expect the same number of returned
    values
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能包含在期望相同数量的返回值的表达式中
- en: 'This is illustrated in the following source snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的源代码片段中有所说明：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Named result parameters
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名结果参数
- en: 'In general, the result list of a function''s signature can be specified using
    variable identifiers along with their types. When using named identifiers, they
    are passed to the function as regular declared variables and can be accessed and
    modified as needed. Upon encountering a `return` statement, the last assigned
    result values are returned. This is illustrated in the following source snippet,
    which is a rewrite of the previous program:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，函数签名的结果列表可以使用变量标识符及其类型来指定。使用命名标识符时，它们被传递给函数作为常规声明的变量，并且可以根据需要访问和修改。在遇到`return`语句时，将返回最后分配的结果值。这在下面的源代码片段中有所说明，它是对前一个程序的重写：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch05/funcret1.go
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcret1.go
- en: Notice the `return` statement is naked; it omits all identifiers. As stated
    earlier, the values assigned in `q` and `r` will be returned to the caller. For
    readability, consistency, or style, you may elect not to use a naked `return`
    statement. It is perfectly legal to attach the identifier's name with the `return`
    statement (such as `return q, r`) as before.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`return`语句是裸的；它省略了所有标识符。如前所述，`q`和`r`中分配的值将返回给调用者。为了可读性、一致性或风格，您可以选择不使用裸`return`语句。可以像以前一样将标识符的名称与`return`语句（例如`return
    q, r`）结合使用是完全合法的。
- en: Passing parameter values
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递参数值
- en: 'In Go, all parameters passed to a function are done so by value. This means
    a local copy of the passed values is created inside the called function. There
    is no inherent concept of passing parameter values by reference. The following
    code illustrates this mechanism by modifying the value of the passed parameter,
    `val`, inside the `dbl` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，所有传递给函数的参数都是按值传递的。这意味着在被调用的函数内部创建了传递值的本地副本。没有固有的按引用传递参数值的概念。以下代码通过修改`dbl`函数内的传递参数`val`的值来说明这种机制：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: golang.fyi/ch05/funcpassbyval.go
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcpassbyval.go
- en: 'When the program runs, it produces the following output that chronicles the
    state of the `p` variable before it is passed to the `dbl` function. The update
    is made locally to the passed parameter variable inside the `dbl` function, and
    lastly the value of the `p` variable after the `dbl` function is called:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它产生以下输出，记录了传递给`dbl`函数之前`p`变量的状态。更新是在`dbl`函数内部对传递参数变量进行本地更新的，最后是在调用`dbl`函数之后的`p`变量的值：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding output shows that the original value assigned to variable `p`
    remains variable unchanged, even after it is passed to a function that seems to
    update its value internally. This is because the `val` parameter in the `dbl`
    function receives a local copy of the passed parameter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，分配给变量`p`的原始值保持不变，即使它被传递给一个似乎在内部更新其值的函数。这是因为`dbl`函数中的`val`参数接收传递参数的本地副本。
- en: Achieving pass-by-reference
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现按引用传递
- en: 'While the pass-by-value is appropriate in many cases, it is important to note
    that Go can achieve pass-by-reference semantics using pointer parameter values.
    This allows a called function to reach outside of its lexical scope and change
    the value stored at the location referenced by the pointer parameter as is done
    in the `half` function in the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然按值传递在许多情况下是合适的，但重要的是要注意，Go可以使用指针参数值实现按引用传递的语义。这允许被调用的函数超出其词法范围并更改指针参数引用的位置存储的值，就像在以下示例中的`half`函数中所做的那样：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: golang.fyi/ch05/funcpassbyref.go
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcpassbyref.go
- en: 'In the previous example, the call to the `half(&num)` function in `main()`
    updates, in place, the original value referenced by its `num` parameter. So, when
    the code is executed, it shows the original value of `num` and its value after
    the call to the `half` function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在`main()`中对`half(&num)`函数的调用会直接更新其`num`参数引用的原始值。因此，当代码执行时，它显示了`num`的原始值以及调用`half`函数后的值：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As was stated earlier, Go function parameters are passed by value. This is true
    even when the function takes a pointer value as its parameter. Go still creates
    and passes in a local copy of the pointer value. In the previous example, the
    `half` function receives a copy of the pointer value it receives via the `val`
    parameter. The code uses pointer operator (`*`) to dereference and manipulate,
    in place, the value referenced by `val`. When the `half` function exits and goes
    out of scope, its changes are accessible by calling the `main` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，Go函数参数是按值传递的。即使函数以指针值作为参数，这也是正确的。Go仍然创建并传递指针值的本地副本。在前面的例子中，`half`函数接收通过`val`参数传递的指针值的副本。代码使用指针操作符（`*`）来取消引用和就地操作`val`引用的值。当`half`函数退出并超出范围时，通过调用`main`函数可以访问其更改。
- en: Anonymous Functions and Closures
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数和闭包
- en: 'Functions can be written as literals without a named identifier. These are
    known as anonymous functions and can be assigned to a variable to be invoked later
    as shown in the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以被写成没有命名标识符的文字。这些被称为匿名函数，可以被分配给一个变量，以便稍后调用，就像下面的例子所示：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: golang.fyi/ch05/funcs.go
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcs.go
- en: The previous program shows two anonymous functions declared and bound to the
    `mul` and `sqr` variables. In both cases, the functions take in parameters and
    return a value. Later in `main()`, the variables are used to invoke the function
    code bound to them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序显示了两个匿名函数声明并绑定到`mul`和`sqr`变量。在这两种情况下，函数都接受参数并返回一个值。稍后在`main()`中，变量被用来调用与它们绑定的函数代码。
- en: Invoking anonymous function literals
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用匿名函数文字
- en: 'It is worth noting that an anonymous function does not have to be bound to
    an identifier. The function literal can be evaluated, in place, as an expression
    that returns the function''s result. This is done by ending the function literal
    with a list of argument values, enclosed in parentheses, as shown in the following
    program:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，匿名函数不一定要绑定到标识符。函数文字可以在现场评估为返回函数结果的表达式。通过在括号中结束函数文字的方式，传递参数值的列表，如下面的程序所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch05/funcs.go
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funcs.go
- en: The literal format not only defines the anonymous function, but also invokes
    it. For instance, in the following snippet (from the previous program), the anonymous
    function literal is nested as a parameter to `fmt.Printf()`. The function itself
    is defined to accept a parameter and returns a value of type `float64`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文字格式不仅定义了匿名函数，还调用了它。例如，在以下片段（来自前面的程序）中，匿名函数文字被嵌套为`fmt.Printf()`的参数。函数本身被定义为接受一个参数并返回`float64`类型的值。
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since the function literal ends with a parameter list enclosed within parentheses,
    the function is invoked as an expression.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数文字以括号括起的参数列表结束，因此该函数被调用为表达式。
- en: Closures
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Go function literals are closures. This means they have lexical visibility
    to non-local variables declared outside of their enclosing code block. The following
    example illustrates this fact:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go函数文字是闭包。这意味着它们在封闭的代码块之外声明的非局部变量具有词法可见性。以下示例说明了这一事实：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: github.com/vladimirvivien/learning-go/ch05/funcs.go
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: github.com/vladimirvivien/learning-go/ch05/funcs.go
- en: In the previous program, the function literal code block, `func() float64 {return
    deg * math.Pi / 180}()`, is defined as an expression that converts degrees to
    radians. With each iteration of the loop, a closure is formed between the enclosed
    function literal and the outer non-local variable, `i`. This provides a simpler
    idiom where the function naturally accesses non-local values without resorting
    to other means such as pointers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个程序中，函数文字代码块`func() float64 {return deg * math.Pi / 180}()`被定义为将度数转换为弧度的表达式。在每次循环迭代时，闭包在封闭的函数文字和外部非局部变量`i`之间形成。这提供了一种更简单的习语，其中函数自然地访问非局部值，而不需要诸如指针之类的其他手段。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Go, lexically closed values can remain bounded to their closures long after
    the outer function that created the closure has gone out of scope. The garbage
    collector will handle cleanups as these closed values become unbounded.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，词法闭包的值可以在创建闭包的外部函数已经超出范围之后仍然保持与它们的闭包绑定。垃圾收集器将在这些闭合值变得无限制时处理清理工作。
- en: Higher-order functions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: We have already established that Go functions are values bound to a type. So,
    it should not be a surprise that a Go function can take another function as a
    parameter and also return a function as a result value. This describes the notion
    known as a higher-order function, which is a concept adopted from mathematics.
    While types such as `struct` let programmers abstract data, higher-order functions
    provide a mechanism to encapsulate and abstract behaviors that can be composed
    together to form more complex behaviors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定Go函数是绑定到类型的值。因此，Go函数可以接受另一个函数作为参数，并且还可以返回一个函数作为结果值，这应该不足为奇。这描述了一个被称为高阶函数的概念，这是从数学中采用的概念。虽然诸如`struct`之类的类型让程序员抽象数据，但高阶函数提供了一种机制，用于封装和抽象可以组合在一起形成更复杂行为的行为。
- en: 'To make this concept clearer, let us examine the following program, which uses
    a higher-order function, `apply`, to do three things. It accepts a slice of integers
    and a function as parameters. It applies the specified function to each element
    in the slice. Lastly, the `apply` function also returns a function as its result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个概念更清晰，让我们来看一下下面的程序，它使用了一个高阶函数`apply`来做三件事。它接受一个整数切片和一个函数作为参数。它将指定的函数应用于切片中的每个元素。最后，`apply`函数还返回一个函数作为其结果：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch05/funchighorder.go
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/funchighorder.go
- en: 'In the program, the `apply` function is invoked with an anonymous function
    that halves each element in the slice as highlighted in the following snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，`apply`函数被调用，并使用匿名函数对切片中的每个元素进行减半，如下面的代码段所示：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As a higher-order function, `apply` abstracts the transformation logic which
    can be provided by any function of type `func(i int) int`, as shown next. Since
    the `apply` function returns a function, the variable `result` can be invoked
    as shown in the previous snippet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为高阶函数，`apply`抽象了可以由任何类型为`func(i int) int`的函数提供的转换逻辑，如下所示。由于`apply`函数返回一个函数，因此变量`result`可以像前面的代码段中所示那样被调用。
- en: As you explore this book, and the Go language, you will continue to encounter
    usage of higher-order functions. It is a popular idiom that is used heavily in
    the standard libraries. You will also find higher-order functions used in some
    concurrency patterns to distribute workloads (see [Chapter 9](ch09.html "Chapter 9. Concurrency"),
    *Concurrency*).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您探索本书和Go语言时，您将继续遇到高阶函数的使用。这是一种在标准库中广泛使用的习语。您还将发现高阶函数在一些并发模式中被用于分发工作负载（参见[第9章](ch09.html
    "第9章。并发性")，“并发性”）。
- en: Error signaling and handling
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误信号和处理
- en: At this point, let us address how to idiomatically signal and handle errors
    when you make a function call. If you have worked with languages such as Python,
    Java, or C#, you may be familiar with interrupting the flow of your executing
    code by throwing an exception when an undesirable state arises.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，让我们来看看如何在进行函数调用时惯用地发出和处理错误。如果您曾经使用过Python、Java或C#等语言，您可能熟悉在不良状态出现时通过抛出异常来中断执行代码流的做法。
- en: As we will explore in this section, Go has a simplified approach to error signaling
    and error handling that puts the onus on the programmer to handle possible errors
    immediately after a called function returns. Go discourages the notion of interrupting
    an execution by indiscriminately short-circuiting the executing program with an
    exception in the hope that it will be properly handled further up the call stack.
    In Go, the traditional way of signaling errors is to return a value of type `error`
    when something goes wrong during the execution of your function. So let us take
    a closer look how this is done.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本节中探讨的，Go对错误信号和错误处理采用了简化的方法，这使得程序员需要在调用函数返回后立即处理可能的错误。Go不鼓励通过在执行程序中不加区别地中断执行来短路执行程序，并希望异常能够在调用堆栈的更高位置得到适当处理的概念。在Go中，信号错误的传统方式是在函数执行过程中出现问题时返回`error`类型的值。因此，让我们更仔细地看看这是如何完成的。
- en: Signaling errors
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误信号
- en: To better understand what has been described in the previous paragraph, let
    us start with an example. The following source code implements an anagram program,
    as described in Column 2 from Jon Bentley's popular *Programming Pearls* book
    (second edition). The code reads a dictionary file (`dict.txt`) and groups all
    words with the same anagram. If the code does not quite make sense, please see
    [golang.fyi/ch05/anagram1.go](http://learning.golang.fyi/ch05/anagram1.go) for
    an annotated explanation of how each part of the program works.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解前面段落中所描述的内容，让我们从一个例子开始。以下源代码实现了一个变位词程序，如Jon Bentley的流行书籍《编程珠玑》（第二版）中的第2列所述。该代码读取一个字典文件（`dict.txt`），并将所有具有相同变位词的单词分组。如果代码不太容易理解，请参阅[golang.fyi/ch05/anagram1.go](http://learning.golang.fyi/ch05/anagram1.go)以获取程序各部分如何工作的注释解释。
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: golang.fyiy/ch05/anagram1.go
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyiy/ch05/anagram1.go
- en: 'Again, if you want a more detail explanation of the previous program, take
    a look at the link supplied earlier. The focus here is on error signaling used
    in the previous program. As a convention, Go code uses the built-in type `error`
    to signal when an error occurred during execution of a function. Therefore, a
    function must return a value of type error to indicate to its caller that something
    went wrong. This is illustrated in the following snippet of the `load` function
    (extracted from the previous example):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您想要更详细的解释前面的程序，请查看之前提供的链接。这里的重点是前面程序中使用的错误信号。作为惯例，Go代码使用内置类型`error`来表示在函数执行过程中发生错误。因此，函数必须返回一个`error`类型的值，以指示给其调用者发生了错误。这在前面示例中的`load`函数的以下片段中有所说明：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that the `load` function returns multiple result parameters. One is
    for the expected value, in this case `[]string`, and the other is the error value.
    Idiomatic Go dictates that the programmer returns a non-nil value for result of
    type `error` to indicate that something abnormal occurred during the execution
    of the function. In the previous snippet, the `load` function signals an error
    occurrence to its callers in two possible instances:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`load`函数返回多个结果参数。一个是预期值，本例中为`[]string`，另一个是错误值。惯用的Go规定程序员应该返回一个非nil值作为`error`类型的结果，以指示在函数执行过程中发生了异常情况。在前面的片段中，`load`函数在两种可能的情况下向其调用者发出错误发生的信号：
- en: when the expected filename (`fname`) is empty
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期的文件名（`fname`）为空时
- en: when the call to `os.Open()` fails (for example, permission error, or otherwise)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`os.Open()`失败时（例如，权限错误，或其他情况）
- en: In the first case, when a filename is not provided, the code returns an error
    using `errors.New()` to create a value of type `error` to exit the function. In
    the second case, the `os.Open` function returns a pointer representing the file
    and an error assigned to the `file` and `err` variables respectively. If `err`
    is not `nil` (meaning an error was generated), the execution of the `load` function
    is halted prematurely and the value of `err` is returned to be handled by the
    calling function further up the call stack.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，当未提供文件名时，代码使用`errors.New()`返回一个`error`类型的值来退出函数。在第二种情况下，`os.Open`函数返回一个代表文件的指针，并将错误分配给`file`和`err`变量。如果`err`不是`nil`（表示生成了错误），则`load`函数的执行会过早终止，并将`err`的值返回给调用函数处理调用堆栈中更高的位置。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When returning an error for a function with multiple result parameters, it is
    customary to return the zero-value for the other (non-error type) parameters.
    In the example, a value of `nil` is returned for the result of type `[]string`.
    While not necessary, it simplifies error handling and avoids any confusion for
    function callers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当为具有多个结果参数的函数返回错误时，习惯上会返回其他（非错误类型）参数的零值。在这个例子中，对于类型为`[]string`的结果，返回了`nil`值。虽然这并非必需，但它简化了错误处理，并避免了对函数调用者造成任何困惑。
- en: Error handling
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'As described previously, signaling of an erroneous state is as simple as returning
    a non-nil value, of type `error`, during execution of a function. The caller may
    choose to handle the `error` or `return` it for further evaluation up the call
    stack as was done in the `load` function. This idiom forces errors to propagate
    upwards until they are handled at some point. The next snippet shows how the error
    generated by the `load` function is handled in the `main` function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在函数执行过程中，只需返回一个非nil值，类型为`error`，即可简单地表示错误状态的发生。调用者可以选择处理`error`或将其`return`以供调用堆栈上进一步评估，就像在`load`函数中所做的那样。这种习惯强制错误向上传播，直到某个地方处理它们。下一个片段展示了`load`函数生成的错误在`main`函数中是如何处理的：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the `main` function is the topmost caller in the call stack, it handles
    the error by terminating the entire program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`main`函数是调用堆栈中最顶层的调用者，它通过终止整个程序来处理错误。
- en: This is all there is to the mechanics of error handling in Go. The language
    forces the programmer to always test for an erroneous state on every function
    call that returns a value of the type `error`. The `if…not…nil error` handling
    idiom may seem excessive and verbose to some, especially if you are coming from
    a language with formal exception mechanisms. However, the gain here is that the
    program can construct a robust execution flow where programmers always know where
    errors may come from and handle them appropriately.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Go中错误处理的机制。语言强制程序员始终测试每个返回`error`类型值的函数调用是否处于错误状态。`if…not…nil error`处理习惯可能对一些人来说过于冗长，特别是如果你来自一个具有正式异常机制的语言。然而，这里的好处在于程序可以构建一个健壮的执行流程，程序员总是知道错误可能来自哪里，并适当地处理它们。
- en: The error type
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误类型
- en: 'The `error` type is a built-in interface and, therefore must be implemented
    before it can be used. Fortunately, the Go standard library comes with implementations
    ready to be used. We have already used one of the implementation from the package,
    `errors`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`类型是一个内置接口，因此必须在使用之前实现。幸运的是，Go标准库提供了准备好的实现。我们已经使用了来自`errors`包的一个实现：'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also create parameterized error values using the `fmt.Errorf` function
    as shown in the following snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`fmt.Errorf`函数创建参数化的错误值，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: golang.fyi/ch05/anagram2.go
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram2.go
- en: 'It is also idiomatic to assign error values to high-level variables so they
    can be reused throughout a program as needed. The following snippet pulled from
    [http://golang.org/src/os/error.go](http://golang.org/src/os/error.go) shows the
    declaration of reusable errors associated with OS file operations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误值分配给高级变量，以便根据需要在整个程序中重复使用，也是惯用的做法。以下摘录自[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)显示了与OS文件操作相关的可重用错误的声明：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://golang.org/src/os/error.go](http://golang.org/src/os/error.go)'
- en: You can also create your own implementation of the `error` interface to create
    custom errors. This topic is revisited in [Chapter 7](ch08.html "Chapter 8. Methods,
    Interfaces, and Objects"), *Methods, Interfaces, and Objects* where the book discusses
    the notion of extending types.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的`error`接口实现来创建自定义错误。这个主题在[第7章](ch08.html "第8章。方法，接口和对象")中重新讨论，*方法，接口和对象*，在这本书中讨论了扩展类型的概念。
- en: Deferring function calls
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推迟函数调用
- en: 'Go supports the notion of deferring a function call. Placing the keyword `defer`
    before a function call has the interesting effect of pushing the function unto
    an internal stack, delaying its execution right before the enclosing function
    returns. To better explain this, let us start with the following simple program
    that illustrates the use of `defer`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持推迟函数调用的概念。在函数调用之前放置关键字`defer`会有一个有趣的效果，将函数推入内部堆栈，延迟其执行直到封闭函数返回之前。为了更好地解释这一点，让我们从以下简单的程序开始，它演示了`defer`的用法：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: golang.fyi/ch05/defer1.go
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/defer1.go
- en: 'The previous example defines the `do` function that takes variadic parameter
    `steps`. The function defers the statement with `defer fmt.Println("All done!")`.
    Next, the function loops through slice `steps` and defers the output of each element
    with `defer fmt.Println(s).` The last statement in the function `do` is a non-deferred
    call to `fmt.Println("Starting").` Notice the order of the printed string values
    when the program is executed, as shown in the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例定义了`do`函数，该函数接受可变参数`steps`。该函数使用`defer fmt.Println("All done!")`推迟语句。接下来，函数循环遍历切片`steps`，并推迟每个元素的输出，使用`defer
    fmt.Println(s)`。函数`do`中的最后一个语句是一个非延迟调用`fmt.Println("Starting")`。当程序执行时，请注意打印的字符串值的顺序，如下面的输出所示：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are a couple facts that explain the reverse order of the printout. First,
    recall that deferred functions are executed right before their enclosing function
    returns. Therefore, the first value printed is generated by the last non-deferred
    method call. Next, as stated earlier, deferred statements are pushed into a stack.
    Therefore, deferred calls are executed using a last-in-first-out order. That is
    why `"All done!"` is the last string value printed in the output.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个事实可以解释打印顺序的反向顺序。首先，回想一下，延迟函数在其封闭函数返回之前执行。因此，第一个打印的值是由最后一个非延迟方法调用生成的。接下来，如前所述，延迟语句被推入堆栈。因此，延迟调用使用后进先出的顺序执行。这就是为什么输出中的最后一个字符串值是`"All
    done!"`。
- en: Using defer
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用defer
- en: 'The `defer` keyword modifies the execution flow of a program by delaying function
    calls. One idiomatic usage for this feature is to do a resource cleanup. Since
    defer will always get executed when the surrounding function returns, it is a
    good place to attach cleanup code such as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`关键字通过延迟函数调用修改程序的执行流程。这一特性的惯用用法之一是进行资源清理。由于defer总是在封闭函数返回时执行，因此它是一个很好的地方来附加清理代码，比如：'
- en: Closing open files
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭打开的文件
- en: Releasing network resources
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放网络资源
- en: Closing the Go channel
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭Go通道
- en: Committing database transactions
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交数据库事务
- en: And do on
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等
- en: 'To illustrate, let us return to our anagram example from earlier. The following
    code snippet shows a version of the code where defer is used to close the file
    after it has been loaded. The `load` function calls `file.Close()` right before
    it returns:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们回到之前的变位词示例。下面的代码片段显示了在加载文件后使用defer关闭文件的代码版本。`load`函数在返回之前调用`file.Close()`：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: golang.fyi/ch05/anagram2.go
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram2.go
- en: The pattern of opening-defer-closing resources is widely used in Go. By placing
    the deferred intent immediately after opening or creating a resource allows the
    code to read naturally and reduces the likeliness of creating a resource leakage.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 打开-推迟-关闭资源的模式在Go中被广泛使用。在打开或创建资源后立即放置延迟意图的做法使得代码读起来更自然，并减少了资源泄漏的可能性。
- en: Function panic and recovery
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数panic和恢复
- en: Earlier in the chapter, it was stated that Go does not have the traditional
    exception mechanism offered by other languages. Nevertheless, in Go, there is
    a way to abruptly exit an executing function known as function panic. Conversely,
    when a program is panicking, Go provides a way of recovering and regaining control
    of the execution flow.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面提到，Go没有其他语言提供的传统异常机制。尽管如此，在Go中，有一种称为函数panic的突然退出执行函数的方法。相反，当程序处于panic状态时，Go提供了一种恢复并重新控制执行流程的方法。
- en: Function panic
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数panic
- en: 'During execution, a function may panic because of any one of following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，函数可能因为以下任何一个原因而panic：
- en: Explicitly calling the **panic** built-in function
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式调用**panic**内置函数
- en: Using a source code package that panics due to an abnormal state
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用由于异常状态而引发panic的源代码包
- en: Accessing a nil value or an out-of-bound array element
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问nil值或超出数组范围的元素
- en: Concurrency deadlock
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发死锁
- en: 'When a function panics, it aborts and executes its deferred calls. Then its
    caller panics, causing a chain reaction as illustrated in the following figure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数panic时，它会中止并执行其延迟调用。然后它的调用者panic，导致如下图所示的连锁反应：
- en: '![Function panic](img/B03676_05_02.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![函数panic](img/B03676_05_02.jpg)'
- en: 'The panic sequence continues all the way up the call stack until the `main`
    function is reached and the program exits (crashes). The following source code
    snippet shows a version of the anagram program that will cause an explicit panic
    if an output anagram file already exists when it tries to create one. This is
    done illustratively to cause the `write` function to panic when there is a file
    error:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: panic序列一直沿着调用堆栈一直到达`main`函数并且程序退出（崩溃）。以下源代码片段显示了一个版本的anagram程序，如果尝试创建一个输出anagram文件时已经存在，则会导致显式panic。这是为了导致`write`函数在出现文件错误时引发panic：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: golang.fyi/ch05/anagram2.go
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram2.go
- en: 'In the preceding snippet, the `write` function calls the `panic` function if
    `os.OpenFile()` method errors out. When the program calls the `main` function,
    if there is an output file already in the working directory, the program will
    panic and crash as shown in the following stack trace, indicating the sequence
    of calls that caused the crash:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，如果`os.OpenFile()`方法出错，`write`函数调用`panic`函数。当程序调用`main`函数时，如果工作目录中已经存在输出文件，程序将会引发panic并像下面的堆栈跟踪所示一样崩溃，指示导致崩溃的调用序列：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Function panic recovery
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数panic恢复
- en: When a function panics, as explained earlier, it can crash an entire program.
    That may be the desired outcome depending on your requirements. It is possible,
    however, to regain control after a panic sequence has started. To do this, Go
    offers the built-in function called `recover`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数引发panic时，正如前面所解释的，它可能会导致整个程序崩溃。根据您的需求，这可能是期望的结果。然而，可以在panic序列开始后重新获得控制。为此，Go提供了名为`recover`的内置函数。
- en: 'Recover works in tandem with panic. A call to function recover returns the
    value that was passed as an argument to panic. The following code shows how to
    recover from the panic call that was introduced in the previous example. In this
    version, the write function is moved inside `makeAnagram()` for clarity. When
    the `write` function is invoked from `makeAnagram()` and fails to open a file,
    it will panic. However, additional code is now added to recover:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: recover与panic协同工作。对recover函数的调用会返回作为参数传递给panic的值。以下代码展示了如何从前面的示例中引入的panic调用中恢复。在这个版本中，write函数被移动到`makeAnagram()`中以提高清晰度。当从`makeAnagram()`调用`write`函数并且无法打开文件时，它会引发panic。然而，现在添加了额外的代码来进行恢复：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: golang.fyi/ch05/anagram3.go
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: golang.fyi/ch05/anagram3.go
- en: 'To be able to recover from an unwinding panic sequence, the code must make
    a deferred call to the recover function. In the previous code, this is done in
    the `makeAnagrams` function by wrapping `recover()` inside an anonymous function
    literal, as highlighted in the following snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从一个展开的panic序列中恢复，代码必须对recover函数进行延迟调用。在前面的代码中，这是在`makeAnagrams`函数中通过将`recover()`包装在一个匿名函数文字中完成的，如下面的片段所示：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When the deferred `recover` function is executed, the program has an opportunity
    to regain control and prevent the panic from crashing the running program. If
    `recover()` returns `nil`, it means there is no current panic unwinding up the
    call stack or the panic was already handled downstream.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行延迟的`recover`函数时，程序有机会重新获得控制并阻止panic导致程序崩溃。如果`recover()`返回`nil`，这意味着当前没有panic在调用堆栈上展开，或者panic已经在下游处理过了。
- en: 'So, now when the program is executed, instead of crashing with a stack trace,
    the program recovers and gracefully displays the issue as shown in the following
    output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在当程序执行时，不会崩溃并显示堆栈跟踪，而是会恢复并优雅地显示问题，如下面的输出所示：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why we are using a `nil` to test the value returned by
    the `recover` function when a string was passed inside the call to `panic`. This
    is because both panic and recover take an empty interface type. As you will learn,
    the empty interface type is a generic type with the ability to represent any type
    in Go's type system. We will learn more about the empty interface in [Chapter
    7](ch08.html "Chapter 8. Methods, Interfaces, and Objects"), *Methods, Interfaces
    and Objects* during discussions about interfaces.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们在测试`recover`函数返回的值时使用`nil`，而在调用`panic`时传递了一个字符串。这是因为panic和recover都采用了空接口类型。正如您将了解的那样，空接口类型是一个通用类型，具有表示Go类型系统中的任何类型的能力。在[第7章](ch08.html
    "第8章。方法、接口和对象")*方法、接口和对象*中关于接口的讨论中，我们将更多地了解空接口。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter presented its reader with an exploration of Go functions. It started
    with an overview of named function declarations, followed by a discussion on function
    parameters. The chapter delved into a discussion of function types and function
    values. The last portion of the chapter discussed the semantics of error handling,
    panic, and recovery. The next chapter continues the discussion of functions; however,
    it does so within the context of Go packages. It explains the role of a package
    as a logical grouping of Go functions (and other code elements) to form sharable
    and callable code modules.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向读者介绍了Go函数的探索。它从命名函数声明的概述开始，然后讨论了函数参数。本章深入讨论了函数类型和函数值。本章的最后部分讨论了错误处理、panic和恢复的语义。下一章将继续讨论函数；然而，它是在Go包的上下文中进行的。它解释了包作为Go函数（和其他代码元素）的逻辑分组形成可共享和可调用的代码模块的角色。
