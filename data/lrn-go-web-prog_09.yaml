- en: Chapter 9. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 安全
- en: In the previous chapter we looked at how to store information generated by our
    application as it works as well as adding unit tests to our suite to ensure that
    the application behaves as we expect it to and diagnose errors when it does not.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了如何存储应用程序生成的信息，以及向我们的套件添加单元测试，以确保应用程序的行为符合我们的期望，并在不符合期望时诊断错误。
- en: In that chapter, we did not add a lot of functionality to our blog app; so let's
    get back to that now. We'll also extend some of the logging and testing functionality
    from this chapter into our new features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一章中，我们没有为我们的博客应用程序添加太多功能；所以现在让我们回到那里。我们还将把本章的一些日志记录和测试功能扩展到我们的新功能中。
- en: Till now, we have been working on the skeleton of a web application that implements
    some basic inputs and outputs of blog data and user-submitted comments. Just like
    any public networked server, ours is subject to a variety of attack vectors.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在开发一个Web应用程序的框架，该应用程序实现了博客数据和用户提交的评论的一些基本输入和输出。就像任何公共网络服务器一样，我们的服务器也容易受到各种攻击。
- en: None of these are unique to Go, but we have an arsenal of tools at our disposal
    to implement the best practices and extend our server and application to mitigate
    common issues.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题并不是Go独有的，但我们有一系列工具可以实施最佳实践，并扩展我们的服务器和应用程序以减轻常见问题。
- en: When building a publicly accessible networked application, one quick and easy
    reference guide for common attack vectors is the **Open Web Application Security
    Project** (**OWASP**), which provides a periodically updated list of the most
    critical areas where security issues manifest. OWASP can be found at [https://www.owasp.org/](https://www.owasp.org/).
    Its Top Ten Project compiles the 10 most common and/or critical network security
    issues. While it's not a comprehensive list and has a habit of becoming dated
    between updates, but it still remains a good first start when compiling potential
    vectors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个公开访问的网络应用程序时，一个快速简便的常见攻击向量参考指南是**开放网络应用程序安全项目**（**OWASP**），它提供了一个定期更新的最关键的安全问题清单。OWASP可以在[https://www.owasp.org/](https://www.owasp.org/)找到。其十大项目编制了最常见和/或最关键的网络安全问题。虽然它不是一个全面的清单，并且在更新之间容易过时，但在编制潜在攻击向量时仍然是一个很好的起点。
- en: A few of the most pervasive vectors of the years have unfortunately stuck around;
    despite the fact that security experts have been shouting from the rooftops of
    their severity. Some have seen a rapid decrease in exposure across the Web (like
    injection), but they still tend to stick around longer, for years and years, even
    as legacy applications phase out.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，一些最普遍的攻击向量不幸地一直存在；尽管安全专家一直在大声疾呼其严重性。有些攻击向量在Web上的曝光迅速减少（比如注入），但它们仍然会长期存在，甚至在遗留应用程序逐渐淘汰的情况下。
- en: 'Here is a glimpse of four of the most recent top 10 vulnerabilities, from late
    2013, some of which we''ll look at in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是2013年末最近的十大漏洞中的四个概述，其中一些我们将在本章中讨论：
- en: '**Injections**: Any case where untrusted data has an opportunity to be processed
    without escaping, thus allowing data manipulation or access to data or systems,
    normally its not exposed publicly. Most commonly this is an SQL injection.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入**：任何未经信任的数据有机会在不转义的情况下被处理，从而允许数据操纵或访问数据或系统，通常不会公开暴露。最常见的是SQL注入。'
- en: '**Broken authentication**: This is caused due to poor encryption algorithms,
    weak password requirements, session hijacking is feasible.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**破坏的身份验证**：这是由于加密算法不佳，密码要求不严格，会话劫持是可行的。'
- en: '**XSS**: Cross-site scripting allows an attacker to access sensitive information
    by injecting and executing scripts on another site.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XSS**：跨站点脚本允许攻击者通过在另一个站点上注入和执行脚本来访问敏感信息。'
- en: '**Cross-site request forgery**: Unlike XSS, this allows the attack vector to
    originate from another site, but it fools a user into completing some action on
    another site.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站点请求伪造**：与XSS不同，这允许攻击向量来自另一个站点，但它会欺骗用户在另一个站点上完成某些操作。'
- en: While the other attack vectors range from being relevant to irrelevant for our
    use case, it is worth evaluating the ones that we aren't covering, to see what
    other places might be rife for exploitation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其他攻击向量从相关到不相关都有，但值得评估我们没有涵盖的攻击向量，看看其他可能存在利用的地方。
- en: To get going, we'll look at the best ways to implement and force HTTPS in your
    applications using Go.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下使用Go在应用程序中实现和强制使用HTTPS的最佳方法。
- en: HTTPS everywhere – implementing TLS
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到处使用HTTPS - 实施TLS
- en: In [Chapter 5](ch05.html "Chapter 5. Frontend Integration with RESTful APIs"),
    *Frontend Integration with RESTful APIs*, we looked at creating self-signed certificates
    and utilizing HTTPS/TLS in our app. But let's review quickly why this matters
    so much in terms of overall security for not just our application but the Web
    in general.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章 前端与RESTful API的集成")中，*前端与RESTful API的集成*，我们讨论了创建自签名证书并在我们的应用程序中使用HTTPS/TLS。但让我们快速回顾一下为什么这对于我们的应用程序和Web的整体安全性如此重要。
- en: First, simple HTTP generally produces no encryption for traffic, particularly
    for vital request header values, such as cookies and query parameters. We say
    generally here because RFC 2817 does specify a system use TLS over the HTTP protocol,
    but it's all but unused. Most importantly, it would not give users the type of
    palpable feedback necessary to register that a site is secure.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，简单的HTTP通常不会为流量提供加密，特别是对于重要的请求头值，如cookie和查询参数。我们在这里说通常是因为RFC 2817确实指定了在HTTP协议上使用TLS的系统，但几乎没有使用。最重要的是，它不会给用户提供必要的明显反馈，以注册网站的安全性。
- en: Second and similarly, HTTP traffic is subsequently vulnerable to man-in-the-middle
    attacks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，HTTP流量容易受到中间人攻击。
- en: 'One other side effect: Google (and perhaps other search engines) begun to favor
    HTTPS traffic over less secure counterparts.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个副作用是：Google（也许其他搜索引擎）开始偏爱HTTPS流量而不是不太安全的对应物。
- en: Until relatively recently, HTTPS was relegated primarily to e-commerce applications,
    but the rise in available and prevalent attacks utilizing the deficiencies of
    HTTP—like sidejacking and man-in-the-middle attacks—began to push much of the
    Web toward HTTPS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 直到相对最近，HTTPS主要被限制在电子商务应用程序中，但利用HTTP的不足的攻击的可用性和普遍性的增加——如侧面攻击和中间人攻击——开始将Web的大部分推向HTTPS。
- en: You may have heard of the resulting movement and motto **HTTPS Everywhere**,
    which also bled into the browser plugins that force site usage to implement the
    most secure available protocol for any given site.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经听说过由此产生的运动和座右铭**HTTPS无处不在**，这也渗透到了强制网站使用实施最安全可用协议的浏览器插件中。
- en: One of the easiest things we can do to extend the work in [Chapter 6](ch06.html
    "Chapter 6. Sessions and Cookies"), *Session and Cookies* is to require that all
    traffic goes through HTTPS by rerouting the HTTP traffic. There are other ways
    of doing this, as we'll see at the end of the chapter, but it can be accomplished
    fairly simply.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的最简单的事情之一是扩展[第6章](ch06.html "第6章。会话和Cookie")中的工作，*会话和Cookie*是要求所有流量通过HTTPS重新路由HTTP流量。还有其他方法可以做到这一点，正如我们将在本章末看到的那样，但它可以相当简单地实现。
- en: 'First, we''ll implement a `goroutine` to concurrently serve our HTTPS and HTTP
    traffic using the `tls.ListenAndServe` and `http.ListenAndServe` respectively:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现一个`goroutine`来同时为我们的HTTPS和HTTP流量提供服务，分别使用`tls.ListenAndServe`和`http.ListenAndServe`：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This assumes that we set a `SECUREPORT` constant to, likely, `":443"` just as
    we set `PORT` to `":8080"`, or whatever you chose. There's nothing preventing
    you from using another port for HTTPS; the benefit here is that the browser directs
    `https://` requests to port `443` by default, just as it directs HTTP requests
    to ports `80` and sometimes fallback to port `8080`. Remember that you'll need
    to run as sudo or administrator in many cases to launch with ports below `1000`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设我们将一个`SECUREPORT`常量设置为`":443"`，就像我们将`PORT`设置为`":8080"`一样，或者您选择的任何其他端口。没有什么可以阻止您在HTTPS上使用另一个端口；这里的好处是浏览器默认将`https://`请求重定向到端口`443`，就像它将HTTP请求重定向到端口`80`，有时会回退到端口`8080`一样。请记住，在许多情况下，您需要以sudo或管理员身份运行以使用低于`1000`的端口启动。
- en: 'You''ll note in the preceding example that we''re utilizing a separate handler
    for HTTP traffic called `redirectNonSecure`. This fulfills a very basic purpose,
    as you''ll see here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在前面的示例中，我们使用了一个专门用于HTTP流量的处理程序`redirectNonSecure`。这实现了一个非常基本的目的，正如您在这里所看到的：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `serverName` is set explicitly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`serverName`被明确设置。
- en: There are some potential issues with gleaning the domain or server name from
    the request, so it's best to set this explicitly if you can.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从请求中获取域名或服务器名称可能存在一些潜在问题，因此最好在可能的情况下明确设置这一点。
- en: Another very useful piece to add here is **HTTP Strict Transport Security**
    (**HSTS**), an approach that, when combined with compliant consumers, aspires
    to mitigate protocol downgrade attacks (such as forcing/redirecting to HTTP).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加的另一个非常有用的部分是**HTTP严格传输安全**（**HSTS**），这种方法与兼容的消费者结合使用，旨在减轻协议降级攻击（如强制/重定向到HTTP）。
- en: This is nothing more than an HTTPS header that, when consumed, will automatically
    handle and force the `https://` requests for requests that would otherwise utilize
    less secure protocols.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个HTTPS标头，当被使用时，将自动处理并强制执行`https://`请求，以替代使用较不安全的协议。
- en: 'OWASP recommends the following setting for this header:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP建议为此标头使用以下设置：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this header is ignored over HTTP.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此标头在HTTP上被忽略。
- en: Preventing SQL injection
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止SQL注入
- en: While injection remains one of the biggest attack vectors across the Web today,
    most languages have simple and elegant ways of preventing or largely mitigating
    the odds of leaving vulnerable SQL injections in place with prepared statements
    and sanitized inputs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管注入仍然是当今Web上最大的攻击向量之一，但大多数语言都有简单而优雅的方法来通过准备好的语句和经过消毒的输入来防止或大大减轻留下易受攻击的SQL注入的可能性。
- en: But even with languages that provide these services, there is still an opportunity
    to leave areas open for exploits.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使使用提供这些服务的语言，仍然有机会留下漏洞的空间。
- en: One of the core tenets of any software development whether on the Web or a server
    or a standalone executable is to never trust input data acquired from an external
    (and sometimes internal) source.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在Web上还是在服务器上或独立的可执行文件中，任何软件开发的核心原则都是不要相信从外部（有时是内部）获取的输入数据。
- en: This tenet stands true for any language, though some make interfacing with a
    database safer and/or easier either through prepared queries or abstractions,
    such as **Object-relational mapping** (**ORM**).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则对于任何语言都是正确的，尽管有些语言通过准备好的查询或抽象（如对象关系映射（ORM））使与数据库的交互更安全和/或更容易。
- en: Natively, Go doesn't have any ORM and since there technically isn't even an
    O (Object) (Go not being purely object-oriented), it's hard to replicate a lot
    of what object-oriented languages have in this area.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Go没有任何ORM，因为从技术上讲，甚至没有一个O（对象）（Go不是纯粹的面向对象的），很难在这个领域复制许多面向对象语言所拥有的东西。
- en: There are, however, a number of third-party libraries that attempt to coerce
    ORM through interfaces and structs, but a lot of this could be very easily written
    by hand since you probably know your schemas and data structures better than any
    library, even in the abstract sense.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多第三方库试图通过接口和结构来强制ORM，但是很多这些都可以很容易地手工编写，因为您可能比任何库更了解您的模式和数据结构，即使是在抽象的意义上。
- en: For SQL, however, Go has a robust and consistent interface for almost any database
    that supports SQL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于SQL，Go具有几乎支持SQL的任何数据库的强大和一致的接口。
- en: To show how an SQL injection exploit can simply surface in a Go application,
    we'll compare a raw SQL query to a prepared statement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示SQL注入漏洞如何在Go应用程序中简单地出现，我们将比较原始的SQL查询和准备好的语句。
- en: 'When we select pages from our database, we use the following query:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从数据库中选择页面时，我们使用以下查询：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This shows us how to open up your application to injection vulnerabilities by
    accepting unsanitized user input. In this case, anyone requesting a page like
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了如何通过接受未经处理的用户输入来打开您的应用程序以进行注入漏洞。在这种情况下，任何请求类似于
- en: '`/page/foo;delete from pages` could, in theory, empty your `pages` table in
    a hurry.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`/page/foo;delete from pages`理论上可以迅速清空你的`pages`表。'
- en: 'We have some preliminary sanitization at the router level that does help in
    this regard. As our mux routes only include alphanumeric characters, we can avoid
    some of the characters that would otherwise need to be escaped being routed to
    our `ServePage` or `APIPage` handlers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在路由器级别有一些初步的消毒工作，这在这方面有所帮助。由于我们的mux路由只包括字母数字字符，我们可以避免一些需要被转义的字符被路由到我们的`ServePage`或`APIPage`处理程序中：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is not a foolproof way of addressing this, though. The preceding query
    took raw input and appended it to the SQL query, but we can handle this much better
    with parameterized, prepared queries in Go. The following is what we ended up
    using:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个绝对可靠的方法。前面的查询接受了原始输入并将其附加到SQL查询中，但是我们可以在Go中使用参数化、准备好的查询来更好地处理这个问题。以下是我们最终使用的内容：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This approach is available in any of Go''s query interfaces, which take a query
    using `?` in place of values as a variadic:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在Go的任何查询接口中都可以使用，它使用`?`来代替值作为可变参数的查询：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While all of these fulfill a slightly different purpose within the world of
    SQL, they all implement the prepared query in the same way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些在SQL世界中有着略微不同的目的，但它们都以相同的方式实现了准备好的查询。
- en: Protecting against XSS
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止跨站脚本攻击
- en: We've touched briefly upon cross-site scripting and limiting this as a vector
    makes your application safer for all users, against the actions of a few bad apples.
    The crux of the issue is the ability for one user to add dangerous content that
    will be shown to users without scrubbing out the aspects that make it dangerous.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到了跨站脚本攻击和限制它作为一种向量，这使得您的应用程序对所有用户更安全，而不受少数不良分子的影响。问题的关键在于一个用户能够添加危险内容，并且这些内容将被显示给用户，而不会清除使其危险的方面。
- en: Ultimately you have a choice here—sanitize the data as it comes in or sanitize
    the data as you present it to other users.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你在这里有一个选择——在输入时对数据进行消毒，或者在呈现给其他用户时对数据进行消毒。
- en: In other words, if someone produces a block of comment text that includes a
    `script` tag, you must take care to stop that from ever being rendered by another
    user's browser. You can choose to save the raw HTML and then strip all, or only
    the sensitive tags on the output rendering. Or, you can encode it as it's entered.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果有人产生了一个包含`script`标签的评论文本块，你必须小心阻止其他用户的浏览器渲染它。你可以选择保存原始HTML，然后在输出渲染时剥离所有或只剥离敏感标签。或者，你可以在输入时对其进行编码。
- en: There's no right answer; however, you may discover value in following the former
    approach, where you accept anything and sanitize the output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准答案；然而，您可能会发现遵循前一种方法有价值，即接受任何内容并对输出进行消毒。
- en: 'There is risk with either, but this approach allows you to keep the original
    intent of the message should you choose to change your approach down the road.
    The downside is that of course you can accidentally allow some of this raw data
    to slip through unsanitized:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都存在风险，但这种方法允许您保留消息的原始意图，如果您选择在以后改变您的方法。缺点是当然你可能会意外地允许一些原始数据通过未经处理的：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first function will take the data and remove the formatting of the HTML
    to produce a plaintext version of the message input by a user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数将获取数据并删除HTML的格式，以产生用户输入的消息的纯文本版本。
- en: 'The second function will do something similar but for JavaScript-specific values.
    You can test these very easily with a quick script similar to the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数将做类似的事情，但是针对JavaScript特定的值。您可以使用类似以下示例的快速脚本很容易地测试这些功能：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we request from the unsafe endpoint, we''ll get our data back:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从不安全的端点请求，我们将得到我们的数据返回：
- en: '![Protecting against XSS](img/B04294_09_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![防止跨站脚本攻击](img/B04294_09_01.jpg)'
- en: 'Compare this with `/html_safe`, which automatically escapes the input, where
    you can see the content in its sanitized form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与`/html_safe`进行比较，后者会自动转义输入，您可以在其中看到内容以其经过处理的形式：
- en: '![Protecting against XSS](img/B04294_09_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![防止跨站脚本攻击](img/B04294_09_02.jpg)'
- en: None of this is foolproof, but if you choose to take input data as the user
    submits it, you'll want to look at ways to relay that information on resulting
    display without opening up other users to XSS.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都不是绝对可靠的，但如果您选择按用户提交的方式接受输入数据，您将希望寻找一些方法来在结果显示时传递这些信息，而不会让其他用户受到跨站脚本攻击的威胁。
- en: Preventing cross-site request forgery (CSRF)
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止跨站请求伪造（CSRF）
- en: While we won't go very deeply into CSRF in this book, the general gist is that
    it is a slew of methods that malicious actors can use to fool a user into performing
    an undesired action on another site.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这本书中不会深入讨论CSRF，但总的来说，它是一系列恶意行为者可以使用的方法，以欺骗用户在另一个站点上执行不需要的操作。
- en: As it's at least tangentially related to XSS in approach, it's worth talking
    about now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它至少在方法上与跨站脚本攻击有关，现在谈论它是值得的。
- en: 'The biggest place where this manifests is in forms; think of it as a Twitter
    form that allows you to send tweets. If a third party forced a request on a user''s
    behalf without their consent, think of something similar to this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这最明显的地方是在表单中；把它想象成一个允许你发送推文的Twitter表单。如果第三方强制代表用户在没有他们同意的情况下请求，想象一下类似这样的情况：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Without any protection, anyone who posts to this guestbook would inadvertently
    help spread spam to this attack.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何保护，任何发布到这个留言簿的人都会无意中帮助传播垃圾邮件到这次攻击中。
- en: Obviously, Twitter is a mature application that has long ago handled this, but
    you get the general idea. You might think that restricting referrers will fix
    this problem, but that can also be spoofed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Twitter是一个成熟的应用程序，早就处理了这个问题，但你可以得到一个大致的想法。你可能会认为限制引用者会解决这个问题，但这也可以被欺骗。
- en: The shortest solution is to generate secure tokens for form submissions, which
    prevents other sites from being able to construct a valid request.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是为表单提交生成安全令牌，这可以防止其他网站能够构造有效的请求。
- en: Of course, our old friend Gorilla also provides a few helpful tools in this
    regard. Most relevant is the `csrf` package, which includes tools to produce tokens
    for requests as well as prebaked form fields that will produce `403` if violated
    or ignored.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的老朋友Gorilla在这方面也提供了一些有用的工具。最相关的是`csrf`包，其中包括用于生成请求令牌的工具，以及预先制作的表单字段，如果违反或忽略将产生`403`。
- en: 'The simplest way to produce a token is to include it as part of the interface
    that your handler will be using to produce a template, as so from our `ApplicationAuthenticate()`
    handler:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 生成令牌的最简单方法是将其作为您的处理程序将用于生成模板的接口的一部分，就像我们的`ApplicationAuthenticate()`处理程序一样：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point we''ll need to expose `{{.csrfField}}` in our template. To validate,
    we''ll need to chain it to our `ListenAndServe` call:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们需要在我们的模板中公开`{{.csrfField}}`。要进行验证，我们需要将其链接到我们的`ListenAndServe`调用：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Securing cookies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护cookie
- en: One of the attack vectors we looked at earlier was session hijacking, which
    we discussed in the context of HTTP versus HTTPS and the way others can see the
    types of information that are critical to identity on a website.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前研究过的攻击向量之一是会话劫持，我们在HTTP与HTTPS的背景下讨论了这个问题，以及其他人如何看到网站身份关键信息的方式。
- en: Finding this data is incredibly simple on public networks for a lot of non-HTTPS
    applications that utilize sessions as definitive IDs. In fact, some large applications
    have allowed session IDs to be passed in URLs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多非HTTPS应用程序来说，在公共网络上找到这些数据非常简单，这些应用程序利用会话作为确定性ID。事实上，一些大型应用程序允许会话ID在URL中传递。
- en: In our application, we've used Gorilla's `securecookie` package, which does
    not rely on HTTPS because the cookie values themselves are encoded and validated
    using HMAC hashing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们使用了Gorilla的`securecookie`包，它不依赖于HTTPS，因为cookie值本身是使用HMAC哈希编码和验证的。
- en: 'Producing the key itself can be very simple, as demonstrated in our application
    and the `securecookie` documentation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥本身可以非常简单，就像我们的应用程序和`securecookie`文档中所演示的那样：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more info on Gorilla''s `securecookie` package see: [http://www.gorillatoolkit.org/pkg/securecookie](http://www.gorillatoolkit.org/pkg/securecookie)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Gorilla的`securecookie`包的更多信息，请参见：[http://www.gorillatoolkit.org/pkg/securecookie](http://www.gorillatoolkit.org/pkg/securecookie)
- en: Presently, our app's server has HTTPS first and secure cookies, which means
    that we likely feel a little more confident about storing and identifying data
    in the cookie itself. Most of our create/update/delete operations are happening
    at the API level, which still implements session checking to ensure our users
    are authenticated.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应用程序的服务器首先使用HTTPS和安全cookie，这意味着我们可能对在cookie本身中存储和识别数据感到更有信心。我们大部分的创建/更新/删除操作都是在API级别进行的，这仍然实现了会话检查，以确保我们的用户已经通过身份验证。
- en: Using the secure middleware
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用secure中间件
- en: One of the more helpful packages for quickly implementing some of the security
    fixes (and others) mentioned in this chapter is a package from Cory Jacobsen called,
    helpfully, `secure`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，快速实施一些安全修复（和其他内容）的更有帮助的软件包之一是Cory Jacobsen的一个软件包，贴心地称为`secure`。
- en: Secure offers a host of useful utilities, such as SSLRedirects (as we implemented
    in this chapter), allowed Hosts, HSTS options, and X-Frame-Options shorthand for
    preventing your site from being loaded into frames.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Secure提供了许多有用的实用程序，例如SSL重定向（正如我们在本章中实现的那样），允许的主机，HSTS选项和X-Frame-Options的简写，用于防止您的网站被加载到框架中。
- en: A good amount of this covers some of the topics that we looked at in this chapter
    and is largely the best practice. As a piece of middleware, secure can be an easy
    way to quickly cover some of those best practices in one swoop.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中涵盖了我们在本章中研究的一些主题，并且基本上是最佳实践。作为一个中间件，secure可以是一种快速覆盖这些最佳实践的简单方法。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To grab `secure`, simply go get it at [github.com/unrolled/secure](http://github.com/unrolled/secure).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`secure`，只需在[github.com/unrolled/secure](http://github.com/unrolled/secure)上获取它。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While this chapter is not a comprehensive review of web security issues and
    solutions, we hoped to address some of the biggest and most common vectors as
    surfaced by OWASP and others.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章并不是对Web安全问题和解决方案的全面审查，但我们希望解决一些由OWASP和其他人提出的最大和最常见的向量之一。
- en: Within this chapter we covered or reviewed the best practices to prevent some
    of these issues from creeping into your applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖或审查了防止这些问题渗入您的应用程序的最佳实践。
- en: In [Chapter 10](ch10.html "Chapter 10. Caching, Proxies and Improved Performance"),
    *Caching, Proxies, and Improved Performance*, we'll look at how to make your application
    scale with increased traffic while remaining performant and speedy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。缓存、代理和性能改进")中，*缓存、代理和性能改进*，我们将讨论如何使您的应用程序在流量增加的同时保持可扩展性和速度。
