- en: Chapter 1. An Introduction to Concurrency in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Go中并发的介绍
- en: While Go is both a great general purpose and low-level systems language, one
    of its primary strengths is the built-in concurrency model and tools. Many other
    languages have third-party libraries (or extensions), but inherent concurrency
    is something unique to modern languages, and it is a core feature of Go's design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go既是一个很好的通用语言，也是一个低级系统语言，但它的主要优势之一是内置的并发模型和工具。许多其他语言都有第三方库（或扩展），但固有的并发性是现代语言独有的，也是Go设计的核心特性。
- en: Though there's no doubt that Go excels at concurrency—as we'll see in this book—what
    it has that many other languages lack is a robust set of tools to test and build
    concurrent, parallel, and distributed code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管毫无疑问，Go在并发方面表现出色——正如我们将在本书中看到的那样——但它具有许多其他语言所缺乏的一套强大的工具来测试和构建并发、并行和分布式代码。
- en: Enough talk about Go's marvelous concurrency features and tools, let's jump
    in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 足够谈论Go的奇妙并发特性和工具了，让我们开始吧。
- en: Introducing goroutines
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍goroutines
- en: The primary method of handling concurrency is through a goroutine. Admittedly,
    our first piece of concurrent code (mentioned in the preface) didn't do a whole
    lot, simply spitting out alternating "hello"s and "world"s until the entire task
    was complete.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 处理并发的主要方法是通过goroutine。诚然，我们的第一段并发代码（在前言中提到）并没有做太多事情，只是简单地输出交替的“hello”和“world”，直到整个任务完成。
- en: 'Here is that code once again:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该代码：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www. packtpub.com](http://www.%20packtpub.com). If
    you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www. packtpub.com](http://www.%20packtpub.com)的帐户中购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接发送到您的邮箱。
- en: But, if you think back to our real-world example of planning a surprise party
    for your grandmother, that's exactly how things often have to be managed with
    limited or finite resources. This asynchronous behavior is critical for some applications
    to run smoothly, although our example essentially ran in a vacuum.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你回想一下我们为祖母筹划惊喜派对的现实例子，这正是事情通常必须用有限或有限的资源来管理的方式。这种异步行为对于某些应用程序的平稳运行至关重要，尽管我们的例子基本上是在真空中运行的。
- en: 'You may have noticed one quirk in our early example: despite the fact that
    we called the `outputText()` function on the `hello` struct first, our output
    started with the `world` struct''s text value. Why is that?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们早期例子中的一个怪癖：尽管我们首先在`hello`结构上调用了`outputText()`函数，但我们的输出始于`world`结构的文本值。为什么呢？
- en: 'Being asynchronous, when a goroutine is invoked, it waits for the blocking
    code to complete before concurrency begins. You can test this by replacing the
    `outputText()` function call on the `world` struct with a goroutine, as shown
    in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为异步的，当调用goroutine时，它会等待阻塞代码完成后再开始并发。您可以通过在下面的代码中用goroutine替换`world`结构上的`outputText()`函数调用来测试这一点：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you run this, you will get no output because the main function ends while
    the asynchronous goroutines are running. There are a couple of ways to stop this
    to see the output before the main function finishes execution and the program
    exits. The classic method simply asks for user input before execution, allowing
    you to directly control when the application finishes. You can also put an infinite
    loop at the end of your main function, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你将得不到任何输出，因为主函数结束了，而异步goroutines正在运行。有几种方法可以阻止这种情况，在主函数执行完毕并退出程序之前看到输出。经典的方法只是在执行之前要求用户输入，允许您直接控制应用程序何时结束。您还可以在主函数的末尾放置一个无限循环，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Better yet, Go also has a built-in mechanism for this, which is the `WaitGroup`
    type in the `sync` package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，Go还有一个内置的机制，即`sync`包中的`WaitGroup`类型。
- en: If you add a `WaitGroup` struct to your code, it can delay execution of the
    main function until after all goroutines are complete. In simple terms, it lets
    you set a number of required iterations to get a completed response from the goroutines
    before allowing the application to continue. Let's look at a minor modification
    to our "Hello World" application in the following section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在代码中添加一个`WaitGroup`结构，它可以延迟主函数的执行，直到所有goroutines完成。简单来说，它允许您设置所需的迭代次数，以便在允许应用程序继续之前从goroutines获得完成的响应。让我们在下一节中看一下对我们“Hello
    World”应用程序的微小修改。
- en: A patient goroutine
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个耐心的goroutine
- en: 'From here, we''ll implement a `WaitGroup` struct to ensure our goroutines run
    entirely before moving on with our application. In this case, when we say patient,
    it''s in contrast to the way we''ve seen goroutines run outside of a parent method
    with our previous example. In the following code, we will implement our first
    `Waitgroup` struct:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将实现一个`WaitGroup`结构，以确保我们的goroutines在继续应用程序之前完全运行。在这种情况下，当我们说“patient”时，这与我们在先前的例子中看到的goroutines在父方法之外运行的方式形成对比。在下面的代码中，我们将实现我们的第一个`Waitgroup`结构：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s look at the changes in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下代码的变化：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we declared a `WaitGroup` struct named `goGroup`. This variable will
    receive note that our goroutine function has completed *x* number of times before
    allowing the program to exit. Here''s an example of sending such an expectation
    in `WaitGroup`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个名为`goGroup`的`WaitGroup`结构。这个变量将接收我们的goroutine函数在允许程序退出之前完成*x*次的通知。以下是在`WaitGroup`中发送这种期望的一个例子：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Add()` method specifies how many `Done` messages `goGroup` should receive
    before satisfying its wait. Here, we specified `2` because we have two functions
    running asynchronously. If you had three goroutine members and still called two,
    you may see the output of the third. If you added a value more than two to `goGroup`,
    for example, `goGroup.Add(3)`, then `WaitGroup` would wait forever and deadlock.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add()`方法指定了`goGroup`在满足等待之前应该接收多少个`Done`消息。在这里，我们指定了`2`，因为我们有两个异步运行的函数。如果你有三个goroutine成员，但仍然调用了两个，你可能会看到第三个的输出。如果你向`goGroup`添加了一个大于两的值，例如`goGroup.Add(3)`，那么`WaitGroup`将永远等待并发死锁。'
- en: 'With that in mind, you shouldn''t manually set the number of goroutines that
    need to wait; this is ideally handled computationally or explicitly in a range.
    This is how we tell `WaitGroup` to wait:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你不应该手动设置需要等待的goroutines的数量；最好是在范围内进行计算或明确处理。这就是我们告诉`WaitGroup`等待的方式：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we wait. This code will fail for the same reason `goGroup.Add(3)` failed;
    the `goGroup` struct never receives messages that our goroutines are done. So,
    let''s do this as shown in the following code snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们等待。这段代码会因为和`goGroup.Add(3)`一样的原因而失败；`goGroup`结构体从未接收到我们的goroutines完成的消息。所以，让我们按照下面的代码片段来做：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've only made two changes to our `outputText()` function from the preface.
    First, we added a pointer to our `goGroup` as the second function argument. Then,
    when all our iterations were complete, we told `goGroup` that they are all done.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对前言中的`outputText()`函数进行了两处更改。首先，我们在第二个函数参数中添加了一个指向我们的`goGroup`的指针。然后，在所有迭代完成后，我们告诉`goGroup`它们都完成了。
- en: Implementing the defer control mechanism
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现defer控制机制
- en: While we're here, we should take a moment and talk about defer. Go has an elegant
    implementation of the defer control mechanism. If you've used defer (or something
    functionally similar) in other languages, this will seem familiar—it's a useful
    way of delaying the execution of a statement until the rest of the function is
    complete.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该花点时间来谈谈defer。Go有一个优雅的defer控制机制的实现。如果你在其他语言中使用了defer（或者类似功能），这会看起来很熟悉——这是一种有用的方式，可以延迟执行语句，直到函数的其余部分完成。
- en: 'For the most part, this is syntactical sugar that allows you to see related
    operations together, even though they won''t execute together. If you''ve ever
    written something similar to the following pseudocode, you''ll know what I mean:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这只是一种语法糖，允许你将相关操作放在一起，即使它们不会一起执行。如果你曾经写过类似以下伪代码的东西，你会知道我的意思：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You probably know the kind of pain that can come from large "distances" separating
    related bits of code. In Go, you can actually write the code similar to the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道由于代码之间的大“距离”而导致的痛苦。在Go中，你实际上可以编写类似以下的代码：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There isn't any actual functional advantage to this other than making clearer,
    more readable code, but that's a pretty big plus in itself. Deferred calls are
    executed reverse of the order in which they are defined, or last-in-first-out.
    You should also take note that any data passed by reference may be in an unexpected
    state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有任何实际的功能优势，除了使代码更清晰、更易读，但这本身就是一个很大的优点。延迟调用是按照它们定义的顺序的相反顺序执行的，或者说是后进先出。你还应该注意，任何通过引用传递的数据可能处于意外的状态。
- en: 'For example, refer to the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，参考以下代码片段：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will return `0`, and not `100`, as it is the default value for an integer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回`0`，而不是`100`，因为这是整数的默认值。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Defer* is not the same as *deferred* (or futures/promises) in other languages.
    We''ll talk about Go''s implementations and alternatives to futures and promises
    in [Chapter 2](part0021_split_000.html#page "Chapter 2. Understanding the Concurrency
    Model"), *Understanding the Concurrency Model*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Defer*不同于其他语言中的*deferred*（或者future/promises）。我们将在[第2章](part0021_split_000.html#page
    "第2章。理解并发模型")中讨论Go的实现和future和promise的替代方案，*理解并发模型*。'
- en: Using Go's scheduler
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Go的调度程序
- en: With a lot of concurrent and parallel applications in other languages, the management
    of both soft and hard threads is handled at the operating system level. This is
    known to be inherently inefficient and expensive as the OS is responsible for
    context switching, among multiple processes. When an application or process can
    manage its own threads and scheduling, it results in faster runtime. The threads
    granted to our application and Go's scheduler have fewer OS attributes that need
    to be considered in context to switching, resulting in less overhead.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，许多并发和并行应用程序的软线程和硬线程的管理是在操作系统级别处理的。这被认为是固有的低效和昂贵，因为操作系统负责上下文切换，处理多个进程。当应用程序或进程可以管理自己的线程和调度时，它会导致更快的运行时间。授予我们应用程序和Go调度程序的线程具有较少的操作系统属性，需要考虑上下文切换，从而减少了开销。
- en: If you think about it, this is self-evident—the more you have to juggle, the
    slower it is to manage all of the balls. Go removes the natural inefficiency of
    this mechanism by using its own scheduler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这是不言自明的——你需要处理的东西越多，管理所有的球就越慢。Go通过使用自己的调度程序消除了这种机制的自然低效性。
- en: 'There''s really only one quirk to this, one that you''ll learn very early on:
    if you don''t ever yield to the main thread, your goroutines will perform in unexpected
    ways (or won''t perform at all).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上只有一个怪癖，你会很早就学到：如果你从不让出主线程，你的goroutines会以意想不到的方式执行（或者根本不执行）。
- en: 'Another way to look at this is to think that a goroutine must be blocked before
    concurrency is valid and can begin. Let''s modify our example and include some
    file I/O to log to demonstrate this quirk, as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，goroutine必须在并发有效并开始之前被阻塞。让我们修改我们的示例，并包括一些文件I/O记录来演示这个怪癖，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In theory, all that has changed is that we're now using a file operation to
    log each operation to a distinct file (in this case, `hello.txt` and `world.txt`).
    However, if you run this, no files are created.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，改变的只是我们现在使用文件操作将每个操作记录到不同的文件中（在这种情况下是`hello.txt`和`world.txt`）。然而，如果你运行这个程序，不会创建任何文件。
- en: In our last example, we used a `sync.WaitSync` struct to force the main thread
    to delay execution until asynchronous tasks were complete. While this works (and
    elegantly), it doesn't really explain *why* our asynchronous tasks fail. As mentioned
    before, you can also utilize blocking code to prevent the main thread from completing
    before its asynchronous tasks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一个例子中，我们使用了`sync.WaitSync`结构来强制主线程延迟执行，直到异步任务完成。虽然这样可以工作（而且优雅），但它并没有真正解释*为什么*我们的异步任务失败。如前所述，您还可以利用阻塞代码来防止主线程在其异步任务完成之前完成。
- en: Since the Go scheduler manages context switching, each goroutine must yield
    control back to the main thread to schedule all of these asynchronous tasks. There
    are two ways to do this manually. One method, and probably the ideal one, is the
    `WaitGroup` struct. Another is the `GoSched()` function in the runtime package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go调度器管理上下文切换，每个goroutine必须将控制权让回主线程，以安排所有这些异步任务。有两种方法可以手动完成这个过程。一种方法，也可能是理想的方法，是`WaitGroup`结构。另一种是runtime包中的`GoSched()`函数。
- en: 'The `GoSched()` function temporarily yields the processor and then returns
    to the current goroutine. Consider the following code as an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`GoSched()`函数暂时让出处理器，然后返回到当前的goroutine。考虑以下代码作为一个例子：'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run this with `runtime.Gosched()` commented out and the underscore before `"runtime"`
    removed, and you'll see only `Goodbye!`. This is because there's no guarantee
    as to how many goroutines, if any, will complete before the end of the `main()`
    function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`runtime.Gosched()`被注释掉并且在`"runtime"`之前的下划线被移除的情况下运行这段代码，你将只会看到`Goodbye!`。这是因为在`main()`函数结束之前，没有保证有多少goroutines会完成。
- en: As we learned earlier, you can explicitly wait for a finite set number of goroutines
    before ending the execution of the application. However, `Gosched()` allows (in
    most cases) for the same basic functionality. Remove the comment before `runtime.Gosched()`,
    and you should get 0 through 10 printed before `Goodbye!`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，您可以在结束应用程序的执行之前显式等待有限数量的goroutines。但是，`Gosched()`允许（在大多数情况下）具有相同的基本功能。删除`runtime.Gosched()`之前的注释，您应该在`Goodbye!`之前打印出0到10。
- en: 'Just for fun, try running this code on a multicore server and modify your max
    processors using `runtime.GOMAXPROCS()`, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，尝试在多核服务器上运行此代码，并使用`runtime.GOMAXPROCS()`修改您的最大处理器，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also, push your `runtime.Gosched()` to the absolute end so that all goroutines
    have a chance to run before `main` ends.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将您的`runtime.Gosched()`推到绝对末尾，以便所有goroutines在`main`结束之前有机会运行。
- en: 'Got something unexpected? That''s not unexpected! You may end up with a totally
    jostled execution of your goroutines, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 得到了一些意外的东西？这并不意外！您可能会得到完全混乱的goroutines执行，如下面的截图所示：
- en: '![Using Go''s scheduler](img/00002.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用Go的调度器](img/00002.jpeg)'
- en: Although it's not entirely necessary to demonstrate how juggling your goroutines
    with multiple cores can be vexing, this is one of the simplest ways to show exactly
    why it's important to have communication between them (and the Go scheduler).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有必要完全演示如何在多个核心上处理goroutines可能会很棘手，但这是展示为什么在它们之间进行通信（和Go调度器）很重要的最简单的方法之一。
- en: 'You can debug the parallelism of this using `GOMAXPROCS > 1`, enveloping your
    goroutine call with a timestamp display, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`GOMAXPROCS > 1`来调试这个，并在您的goroutine调用周围加上时间戳显示，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to import the `time` and `strconv` parent packages here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在这里导入`time`和`strconv`父包。
- en: 'This will also be a good place to see concurrency and compare it to parallelism
    in action. First, add a one-second delay to the `showNumber()` function, as shown
    in the following code snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的地方来看并发并将其与并行执行进行比较。首先，在`showNumber()`函数中添加一秒的延迟，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, remove the goroutine call before the `showNumber()` function with `GOMAXPROCS(0)`,
    as shown in the following code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`showNumber()`函数之前删除goroutine调用，并使用`GOMAXPROCS(0)`，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As expected, you get 0-10 with 10-millisecond delays between them followed by
    `Goodbye!` as an output. This is straight, serial computing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，您会得到0-10之间的数字，它们之间有10毫秒的延迟，然后输出`Goodbye!`。这是直接的串行计算。
- en: 'Next, let''s keep `GOMAXPROCS` at zero for a single thread, but restore the
    goroutine as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`GOMAXPROCS`保持为零以使用单个线程，但是恢复goroutine如下：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is the same process as before, except for the fact that everything will
    execute within the same general timeframe, demonstrating the concurrent nature
    of execution. Now, go ahead and change your `GOMAXPROCS` to two and run again.
    As mentioned earlier, there is only one (or possibly two) timestamp, but the order
    has changed because everything is running simultaneously.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的过程相同，只是一切都会在相同的时间范围内执行，展示了执行的并发性质。现在，继续将您的`GOMAXPROCS`更改为两个并再次运行。如前所述，只有一个（或可能两个）时间戳，但顺序已经改变，因为一切都在同时运行。
- en: Goroutines aren't (necessarily) thread-based, but they feel like they are. When
    Go code is compiled, the goroutines are multiplexed across available threads.
    It's this very reason why Go's scheduler needs to know what's running, what needs
    to finish before the application's life ends, and so on. If the code has two threads
    to work with, that's what it will use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines不一定是基于线程的，但它们感觉像是。当Go代码被编译时，goroutines会在可用的线程上进行多路复用。这正是为什么Go的调度器需要知道什么正在运行，什么需要在应用程序生命周期结束之前完成等等的原因。如果代码有两个线程可用，那就会使用两个线程。
- en: Using system variables
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用系统变量
- en: So what if you want to know how many threads your code has made available to
    you?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果您想知道您的代码有多少个线程可用呢？
- en: 'Go has an environment variable returned from the runtime package function `GOMAXPROCS`.
    To find out what''s available, you can write a quick application similar to the
    following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个从runtime包函数`GOMAXPROCS`返回的环境变量。要找出可用的内容，您可以编写一个类似以下代码的快速应用程序：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A simple Go build on this will yield the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上进行简单的Go构建将产生以下输出：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `0` parameter (or no parameter) delivered to `GOMAXPROCS` means no change
    is made. You can put another number in there, but as you might imagine, it will
    only return what is actually available to Go. You cannot exceed the available
    cores, but you can limit your application to use less than what's available.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`GOMAXPROCS`的`0`参数（或没有参数）意味着没有进行更改。你可以在那里放入另一个数字，但正如你所想象的那样，它只会返回Go实际可用的内容。你不能超过可用的核心，但你可以限制你的应用程序使用少于可用的核心。
- en: The `GOMAXPROCS()` call itself returns an integer that represents the *previous*
    number of processors available. In this case, we first set it to two and then
    set it to zero (no change), returning two.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`GOMAXPROCS()`调用本身返回一个整数，表示*之前*可用的处理器数量。在这种情况下，我们首先将其设置为两，然后设置为零（没有更改），返回两。'
- en: It's also worth noting that increasing `GOMAXPROCS` can sometimes *decrease*
    the performance of your application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，增加`GOMAXPROCS`有时可能会*降低*应用程序的性能。
- en: As there are context-switching penalties in larger applications and operating
    systems, increasing the number of threads used means goroutines can be shared
    among more than one, and the lightweight advantage of goroutines might be sacrificed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的应用程序和操作系统中存在上下文切换的惩罚，增加使用的线程数量意味着goroutines可以在多个线程之间共享，并且goroutines的轻量级优势可能会被牺牲。
- en: If you have a multicore system, you can test this pretty easily with Go's internal
    benchmarking functionality. We'll take a closer look at this functionality in
    [Chapter 5](part0048_split_000.html#page "Chapter 5. Locks, Blocks, and Better
    Channels"), *Locks, Blocks, and Better Channels,* and [Chapter 7](part0060_split_000.html#page
    "Chapter 7. Performance and Scalability"), *Performance and Scalability*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个多核系统，你可以很容易地使用Go的内部基准测试功能来测试这一点。我们将在[第5章](part0048_split_000.html#page
    "第5章. 锁、阻塞和更好的通道")*锁、阻塞和更好的通道*和[第7章](part0060_split_000.html#page "第7章. 性能和可伸缩性")*性能和可伸缩性*中更仔细地研究这个功能。
- en: The runtime package has a few other very useful environment variable return
    functions, such as `NumCPU`, `NumGoroutine`, `CPUProfile`, and `BlockProfile`.
    These aren't just handy to debug, they're also good to know how to best utilize
    your resources. This package also plays well with the reflect package, which deals
    with metaprogramming and program self-analysis. We'll touch on that in more detail
    later in [Chapter 9](part0078_split_000.html#page "Chapter 9. Logging and Testing
    Concurrency in Go"), *Logging and Testing Concurrency in Go*, and [Chapter 10](part0082_split_000.html#page
    "Chapter 10. Advanced Concurrency and Best Practices"), *Advanced Concurrency
    and Best Practices*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: runtime包还有一些其他非常有用的环境变量返回函数，比如`NumCPU`、`NumGoroutine`、`CPUProfile`和`BlockProfile`。这些不仅方便调试，也有助于了解如何最好地利用资源。这个包还与reflect包很好地配合，reflect包处理元编程和程序自我分析。我们将在[第9章](part0078_split_000.html#page
    "第9章. Go中的日志记录和测试并发")*Go中的日志记录和测试并发*和[第10章](part0082_split_000.html#page "第10章. 高级并发和最佳实践")*高级并发和最佳实践*中更详细地讨论这一点。
- en: Understanding goroutines versus coroutines
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解goroutines与coroutines
- en: At this point, you may be thinking, "Ah, goroutines, I know these as coroutines."
    Well, yes and no.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会想，“啊，goroutines，我知道这些就是coroutines。”嗯，是和不是。
- en: A coroutine is a cooperative task control mechanism, but in its most simplistic
    sense, a coroutine is not concurrent. While coroutines and goroutines are utilized
    in similar ways, Go's focus on concurrency provides a lot more than just state
    control and yields. In the examples we've seen so far, we have what we can call
    *dumb* goroutines. Although they operate in the same time and address space, there's
    no real communication between the two. If you look at coroutines in other languages,
    you may find that they are often not necessarily concurrent or asynchronous, but
    rather they are step-based. They yield to `main()` and to each other, but two
    coroutines might not necessarily communicate between each other, relying on a
    centralized, explicitly written data management system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: coroutine是一种协作式任务控制机制，但从其最简单的意义上讲，coroutine并不是并发的。虽然coroutines和goroutines的使用方式类似，但Go对并发的关注提供了远不止状态控制和产出。在我们迄今为止看到的例子中，我们有可以称之为*愚蠢*的goroutines。虽然它们在同一时间和地址空间中运行，但两者之间没有真正的通信。如果你看看其他语言中的coroutines，你可能会发现它们通常并不一定是并发的或异步的，而是基于步骤的。它们会向`main()`和彼此产出，但两个coroutine之间可能并不一定会进行通信，而是依赖于一个集中的、明确编写的数据管理系统。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The original coroutine**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始coroutine**'
- en: Coroutines were first described for COBOL by Melvin Conway. In his paper, *Design
    of a Separable Transition-Diagram Compiler*, he suggested that the purpose of
    a coroutine was to take a program broken apart into subtasks and allow them to
    operate independently, sharing only small pieces of data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: coroutines最初是由Melvin Conway为COBOL描述的。在他的论文《可分离转换图编译器的设计》中，他建议coroutine的目的是将程序分解为子任务，并允许它们独立运行，仅共享少量数据。
- en: Goroutines can sometimes violate the basic tenets of Conway's coroutines. For
    example, Conway suggested that there should be only a unidirectional path of execution;
    in other words, A followed by B, then C, and then D, and so on, where each represents
    an application chunk in a coroutine. We know that goroutines can be run in parallel
    and can execute in a seemingly arbitrary order (at least without direction). To
    this point, our goroutines have not shared any information either; they've simply
    executed in a shared pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Goroutines有时可能会违反Conway的coroutines的基本原则。例如，Conway建议只应该有一个单向的执行路径；换句话说，A后面是B，然后是C，然后是D，依此类推，其中每个代表coroutine中的一个应用程序块。我们知道goroutines可以并行运行，并且可以以看似任意的顺序执行（至少没有方向）。到目前为止，我们的goroutines也没有共享任何信息；它们只是以共享的模式执行。
- en: Implementing channels
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现通道
- en: So far, we've dabbled in concurrent processes that are capable of doing a lot
    but not effectively communicating with each other. In other words, if you have
    two processes occupying the same processing time and sharing the same memory and
    data, you must have a way of knowing which process is in which place as part of
    a larger task.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涉足了能够做很多事情但不能有效地相互通信的并发进程。换句话说，如果你有两个进程占用相同的处理时间并共享相同的内存和数据，你必须知道哪个进程在哪个位置作为更大任务的一部分。
- en: 'Take, for example, an application that must loop through one paragraph of Lorem
    Ipsum and capitalize each letter, then write the result to a file. Of course,
    we will not really need a concurrent application to do this (and in fact, it''s
    an endemic function of almost any language that handles strings), but it''s a
    quick way to demonstrate the potential limitations of isolated goroutines. Shortly,
    we''ll turn this primitive example into something more practical, but for now,
    here''s the beginning of our capitalization example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个应用程序必须循环遍历Lorem Ipsum的一个段落，并将每个字母大写，然后将结果写入文件。当然，我们实际上不需要一个并发应用程序来做这个事情（事实上，几乎任何处理字符串的语言都具有这个固有功能），但这是一个快速演示孤立goroutine潜在限制的方法。不久，我们将把这个原始示例转化为更实用的东西，但现在，这是我们大写示例的开始：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we run this with some degree of parallelism here but no communication between
    our goroutines, we''ll end up with a jumbled mess of text, as shown in the following
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里以某种程度的并行性运行，但我们的goroutine之间没有通信，我们最终会得到一团糟的文本，如下面的截图所示：
- en: '![Implementing channels](img/00003.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![实现通道](img/00003.jpeg)'
- en: Due to the demonstrated unpredictability of concurrent scheduling in Go, it
    may take many iterations to get this exact output. In fact, you may never get
    the exact output.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go中并发调度的不可预测性，可能需要多次迭代才能获得这个确切的输出。事实上，你可能永远也得不到确切的输出。
- en: This won't do, obviously. So how do we best structure this application? The
    missing piece here is synchronization, but we could also do with a better design
    pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这样行不通。那么我们应该如何最好地构建这个应用程序呢？这里缺少的是同步，但我们也可以用更好的设计模式。
- en: Here's another way to break this problem down into pieces. Instead of having
    two processes handling the same thing in parallel, which is rife with risk, let's
    have one process that takes a letter from the `loremIpsum` string and capitalizes
    it, and then pass it onto another process to add it to our `finalIpsum` string.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种将这个问题分解成片段的方法。与其让两个进程并行处理相同的事情，这充满了风险，不如让一个进程从`loremIpsum`字符串中取一个字母并将其大写，然后将其传递给另一个进程将其添加到我们的`finalIpsum`字符串中。
- en: You can envision this as two people sitting at two desks, each with a stack
    of letters. Person A is responsible to take a letter and capitalize it. He then
    passes the letter onto person B, who then adds it to the `finalIpsum` stack. To
    do this, we'll implement a channel in our code in an application tasked with taking
    text (in this case, the first line of Abraham Lincoln's Gettysburg address) and
    capitalizing each letter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这想象成两个人坐在两张桌子前，每个人手上都有一叠信件。A负责拿一封信并将其大写。然后他把信传给B，然后B把它添加到`finalIpsum`堆栈中。为了做到这一点，我们将在我们的代码中实现一个通道，这个应用程序的任务是接收文本（在这种情况下是亚伯拉罕·林肯的葛底斯堡演说的第一行）并将每个字母大写。
- en: Channel-based sorting at the letter capitalization factory
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于通道的字母大写工厂排序
- en: 'Let''s take the last example and do something (slightly) more purposeful by
    attempting to capitalize the preamble of Abraham Lincoln''s Gettysburg address
    while mitigating the sometimes unpredictable effect of concurrency in Go, as shown
    in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以最后一个例子为例，通过尝试大写亚伯拉罕·林肯的葛底斯堡演说序言，来做一些（略微）更有意义的事情，同时减轻Go中并发的不可预测影响，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You''ll note that we even bumped this up to a duo-core process and ended up
    with the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们甚至将这提升到了一个双核处理过程，并得到了以下输出：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output is just as we expected. It's worth reiterating that this example
    is overkill of the most extreme kind, but we'll parlay this functionality into
    a usable practical application shortly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出正如我们所预期的那样。值得重申的是，这个例子是极端的过度，但我们很快将把这个功能转化为一个可用的实际应用程序。
- en: 'So what''s happening here? First, we reimplemented the `sync.WaitGroup` struct
    to allow all of our concurrent code to execute while keeping the main thread alive,
    as shown in the following code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里发生了什么？首先，我们重新实现了`sync.WaitGroup`结构，以允许我们所有的并发代码在保持主线程活动的同时执行，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We allow each goroutine to tell the `WaitGroup` struct that we're done with
    the step. As we have two goroutines, we queue two `Add()` methods to the `WaitGroup`
    struct. Each goroutine is responsible to announce that it's done.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许每个goroutine告诉`WaitGroup`结构我们已经完成了这一步。由于我们有两个goroutine，我们将两个`Add()`方法排入`WaitGroup`结构的队列。每个goroutine负责宣布自己已经完成。
- en: 'Next, we created our first channel. We instantiate a channel with the following
    line of code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了我们的第一个通道。我们用以下代码行实例化一个通道：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This tells Go that we have a channel that will send and receive a string to
    various procedures/goroutines. This is essentially the manager of all of the goroutines.
    It is also responsible to send and receive data to goroutines and manage the order
    of execution. As we mentioned earlier, the ability of channels to operate with
    internal context switching and without reliance on multithreading permits them
    to operate very quickly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Go我们有一个通道，将向各种程序/ goroutine发送和接收字符串。这本质上是所有goroutine的管理者。它还负责向goroutine发送和接收数据，并管理执行顺序。正如我们之前提到的，通道具有在内部上下文切换和无需依赖多线程的能力，使它们能够快速运行。
- en: There is a built-in limit to this functionality. If you design non-concurrent
    or blocking code, you will effectively remove concurrency from goroutines. We
    will talk more about this shortly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能有内置的限制。如果你设计非并发或阻塞的代码，你将有效地从goroutine中移除并发。我们很快会更多地讨论这个问题。
- en: 'We run two separate goroutines through `letterChannel`: `capitalize()` and
    `addToFinalStack()`. The first one simply takes a single byte from a byte array
    constructed from our string and capitalizes it. It then returns the byte to the
    channel as shown in the following line of code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`letterChannel`运行两个单独的goroutine：`capitalize()`和`addToFinalStack()`。第一个简单地从构建的字节数组中获取一个字节并将其大写。然后，它将字节返回到通道，如下一行代码所示：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All communication across a channel happens in this fashion. The `<-` symbol
    syntactically tells us that data will be sent back to (or back through) a channel.
    It''s never necessary to do anything with this data, but the most important thing
    to know is that a channel can be blocking, at least per thread, until it receives
    data back. You can test this by creating a channel and then doing absolutely nothing
    of value with it, as shown in the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通过通道的通信都是以这种方式进行的。`<-`符号在语法上告诉我们数据将被发送回通道。从来不需要对这些数据做任何处理，但最重要的是要知道通道可以阻塞，至少在每个线程中，直到它接收到数据。您可以通过创建一个通道，然后对其不做任何有价值的事情来测试这一点，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As nothing is sent along the channel and no goroutine is instantiated, this
    results in a deadlock. You can fix this easily by creating a goroutine and by
    bringing the channel into the global space by creating it outside of `main()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有沿着通道发送任何东西，也没有实例化goroutine，这导致了死锁。您可以通过创建一个goroutine并将通道带入全局空间来轻松解决这个问题，方法是在`main()`之外创建它。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of clarity, our example here uses a local scope channel. Keeping
    these global whenever possible removes a lot of cruft, particularly if you have
    a lot of goroutines, as references to the channel can clutter up your code in
    a hurry.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们的示例在这里使用了局部范围的通道。尽可能保持这些全局范围，可以消除很多不必要的东西，特别是如果您有很多goroutine，因为通道的引用可能会使您的代码变得混乱。
- en: 'For our example as a whole, you can look at it as is shown in the following
    figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的整个示例，您可以将其视为下图所示：
- en: '![Channel-based sorting at the letter capitalization factory](img/00004.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![基于通道的字母大写工厂的排序](img/00004.jpeg)'
- en: Cleaning up our goroutines
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理我们的goroutine
- en: You may be wondering why we need a `WaitGroup` struct when using channels. After
    all, didn't we say that a channel gets blocked until it receives data? This is
    true, but it requires one other piece of syntax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么在使用通道时需要`WaitGroup`结构。毕竟，我们不是说过通道会被阻塞，直到它接收到数据吗？这是真的，但它需要另一段语法。
- en: A nil or uninitialized channel will always get blocked. We will discuss the
    potential uses and pitfalls of this in [Chapter 7](part0060_split_000.html#page
    "Chapter 7. Performance and Scalability"), *Performance and Scalability*, and
    [Chapter 10](part0082_split_000.html#page "Chapter 10. Advanced Concurrency and
    Best Practices"), *Advanced Concurrency and Best Practices*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 空或未初始化的通道将始终被阻塞。我们将在[第7章](part0060_split_000.html#page "第7章。性能和可伸缩性")*性能和可伸缩性*和[第10章](part0082_split_000.html#page
    "第10章。高级并发和最佳实践")*高级并发和最佳实践*中讨论这种情况的潜在用途和陷阱。
- en: You have the ability to dictate how a channel blocks the application based on
    a second option to the `make` command by dictating the channel buffer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`make`命令的第二个选项中指定通道缓冲区来决定通道如何阻塞应用程序。
- en: Buffered or unbuffered channels
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲或非缓冲通道
- en: By default, channels are unbuffered, which means they will accept anything sent
    on them if there is a channel ready to receive. It also means that every channel
    call will block the execution of the application. By providing a buffer, the channel
    will only block the application when many returns have been sent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通道是非缓冲的，这意味着如果有一个准备接收的通道，它们将接受任何发送到它们的东西。这也意味着每个通道调用都会阻塞应用程序的执行。通过提供一个缓冲区，只有在发送了许多返回时，通道才会阻塞应用程序。
- en: A buffered channel is synchronous. To guarantee asynchronous performance, you'll
    want to experiment by providing a buffer length. We'll look at ways to ensure
    our execution falls as we expect in the next chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道是同步的。为了保证异步性能，您需要通过提供缓冲区长度来进行实验。我们将在下一章中探讨确保我们的执行符合预期的方法。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go's channel system is based on **Communicating Sequential Processes** (**CSP**),
    a formal language to design concurrent patterns and multiprocessing. You will
    likely encounter CSP on its own when people describe goroutines and channels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Go的通道系统是基于**通信顺序进程**（**CSP**）的，这是一种设计并发模式和多处理的正式语言。当人们描述goroutine和通道时，您可能会单独遇到CSP。
- en: Using the select statement
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用select语句
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In a `switch` statement, the right-hand expression represents a value; in `select`,
    it represents a receive operation on a channel. A `select` statement will block
    the application until some information is sent along the channel. If nothing is
    sent ever, the application deadlocks and you'll get an error to that effect.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`语句中，右侧表达式表示一个值；在`select`中，它表示对通道的接收操作。`select`语句将阻塞应用程序，直到有一些信息通过通道发送。如果从未发送任何内容，应用程序将死锁，并且您将收到相应的错误。
- en: If two receive operations are sent at the same time (or if two cases are otherwise
    met), Go will evaluate them in an unpredictable fashion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个接收操作同时发送（或者满足两个情况），Go将以不可预测的方式对它们进行评估。
- en: 'So, how might this be useful? Let''s look at a modified version of the letter
    capitalization application''s main function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这有什么用呢？让我们看一下字母大写应用程序的主函数的修改版本：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The primary difference here is we now have a channel that listens for data
    across two functions running concurrently, `getLetters` and `capitalizeLetters`.
    At the bottom, you''ll see a `for{}` loop that keeps the main active until the
    `applicationStatus` variable is set to `false`. In the following code, we pass
    each of these bytes as a string through the Go channel:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别是我们现在有一个通道，它在两个并发运行的函数`getLetters`和`capitalizeLetters`之间监听数据。在底部，您将看到一个`for{}`循环，它会一直保持主动状态，直到`applicationStatus`变量设置为`false`。在下面的代码中，我们将每个字节作为字符串通过Go通道传递：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `getLetters` function is our primary goroutine that fetches individual letters
    from the byte array constructed from Lincoln's line. As the function iterates
    through each byte, it sends the letter through the `getQueue` channel.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLetters`函数是我们的主要goroutine，它从构建自Lincoln''s行的字节数组中获取单个字母。当函数迭代每个字节时，它通过`getQueue`通道发送该字母。'
- en: 'On the receiving end, we have `capitalizeLetters` that takes each letter as
    it''s sent across the channel, capitalizes it, and appends to our `finalString`
    variable. Let''s take a look at this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端，我们有`capitalizeLetters`，它接收每个字母并将其大写，然后附加到我们的`finalString`变量上。让我们来看一下这个：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's critical that all channels are closed at some point or our application
    will hit a deadlock. If we never break the `for` loop here, our channel will be
    left waiting to receive from a concurrent process, and the program will deadlock.
    We manually check to see that we've capitalized all letters and only then break
    the loop.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭所有通道是至关重要的，否则我们的应用程序将陷入死锁。如果我们在这里永远不打破`for`循环，我们的通道将一直等待从并发进程接收，并且程序将陷入死锁。我们手动检查是否已将所有字母大写，然后才打破循环。
- en: Closures and goroutines
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包和goroutines
- en: 'You may have noticed the anonymous goroutine in Lorem Ipsum:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到Lorem Ipsum中的匿名goroutine：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While it isn't always ideal, there are plenty of places where inline functions
    work best in creating a goroutine.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不总是理想的，但有很多地方内联函数最适合创建goroutine。
- en: The easiest way to describe this is to say that a function isn't big or important
    enough to deserve a named function, but the truth is, it's more about readability.
    If you have dealt with lambdas in other languages, this probably doesn't need
    much explanation, but try to reserve these for quick inline functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 描述这个最简单的方法是说一个函数不够大或重要，不值得拥有一个命名函数，但事实上，这更多的是关于可读性。如果您在其他语言中使用过lambda表达式，这可能不需要太多解释，但请尽量将这些保留给快速的内联函数。
- en: In the earlier examples, the closure works largely as a wrapper to invoke a
    `select` statement or to create anonymous goroutines that will feed the `select`
    statement.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的示例中，闭包主要作为调用`select`语句的包装器或创建匿名goroutines来提供`select`语句。
- en: Since functions are first-class citizens in Go, not only can you utilize inline
    or anonymous functions directly in your code, but you can also pass them to and
    from other functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数在Go中是一等公民，因此不仅可以直接在代码中使用内联或匿名函数，还可以将它们传递给其他函数并从其他函数返回。
- en: Here's an example that passes a function's result as a return value, keeping
    the state resolute outside of that returned function. In this, we'll return a
    function as a variable and iterate initial values on the returned function. The
    initial argument will accept a string that will be trimmed by word length with
    each successive call of the returned function.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，它将函数的结果作为返回值传递，使返回的函数之外的状态坚定。在这种情况下，我们将一个函数作为变量返回，并在返回的函数上迭代初始值。初始参数将接受一个字符串，每次调用返回的函数时都会根据单词长度进行修剪。
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once initialized and returned, we set the message variable, and each successive
    run of the returned method iterates on that value. This functionality allows us
    to eschew running a function multiple times on returned values or loop unnecessarily
    when we can very cleanly handle this with a closure as shown.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化并返回，我们设置消息变量，并且返回方法的每次运行都会迭代该值。这种功能允许我们避免在返回值上多次运行函数或不必要地循环，而可以使用闭包来处理这个问题，如上所示。
- en: Building a web spider using goroutines and channels
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用goroutines和通道构建网络爬虫
- en: 'Let''s take the largely useless capitalization application and do something
    practical with it. Here, our goal is to build a rudimentary spider. In doing so,
    we''ll accomplish the following tasks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿这个几乎没什么用的大写应用程序，做一些实际的事情。在这里，我们的目标是构建一个基本的爬虫。这样做，我们将完成以下任务：
- en: Read five URLs
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取五个URL
- en: Read those URLs and save the contents to a string
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取这些URL并将内容保存到字符串中
- en: Write that string to a file when all URLs have been scanned and read
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有URL都被扫描和读取时，将该字符串写入文件
- en: These kinds of applications are written every day, and they're the ones that
    benefit the most from concurrency and non-blocking code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的应用程序每天都在编写，并且它们是最能从并发和非阻塞代码中受益的应用程序之一。
- en: It probably goes without saying, but this is not a particularly elegant web
    scraper. For starters, it only knows a few start points—the five URLs that we
    supply it. Also, it's neither recursive nor is it thread-safe in terms of data
    integrity.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不用说，但这并不是一个特别优雅的网络爬虫。首先，它只知道一些起始点——我们提供的五个URL。此外，它既不是递归的，也不是线程安全的，就数据完整性而言。
- en: 'That said, the following code works and demonstrates how we can use channels
    and the `select` statements:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，以下代码有效，并演示了我们如何使用通道和`select`语句：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, we have our most basic global variables that we''ll use for the application
    state. The `applicationStatus` variable tells us that our spider process has begun
    and `urls` is our slice of simple string URLs. The rest are idiomatic data storage
    variables and/or application flow mechanisms. The following code snippet is our
    function to read the URLs and pass them across the channel:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们最基本的全局变量，我们将用它们来表示应用程序状态。`applicationStatus`变量告诉我们我们的爬虫进程已经开始，`urls`是我们的简单字符串URL的切片。其余的是成语数据存储变量和/或应用程序流程机制。以下代码片段是我们读取URL并将它们传递到通道的函数：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `readURLs` function assumes `statusChannel` and `textChannel` for communication
    and loops through the `urls` variable slice, returning the text on `textChannel`
    and a simple ping on `statusChannel`. Next, let''s look at the function that will
    append scraped text to the full text:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`readURLs`函数假定`statusChannel`和`textChannel`用于通信，并循环遍历`urls`变量切片，在`textChannel`上返回文本，并在`statusChannel`上返回一个简单的ping。接下来，让我们看一下将抓取的文本附加到完整文本的函数：'
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We use the `addToScrapedText` function to accumulate processed text and add
    it to a master text string. We also close our two primary channels when we get
    a kill signal on our `processChannel`. Let''s take a look at the `evaluateStatus()`
    function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`addToScrapedText`函数来累积处理过的文本并将其添加到主文本字符串中。当我们在`processChannel`上收到关闭信号时，我们也关闭了我们的两个主要通道。让我们看一下`evaluateStatus()`函数：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this juncture, all that the `evaluateStatus` function does is determine
    what''s happening in the overall scope of the application. When we send a `0`
    (our aforementioned ping) through this channel, we increment our `urlsProcessed`
    variable. When we send a `1`, it''s a message that we can close the channel. Finally,
    let''s look at the `main` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时刻，`evaluateStatus`函数所做的就是确定应用程序的整体范围内发生了什么。当我们通过这个通道发送一个`0`（我们前面提到的ping）时，我们会增加我们的`urlsProcessed`变量。当我们发送一个`1`时，这是一个消息，我们可以关闭通道。最后，让我们看一下`main`函数：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a basic extrapolation of our last function, the capitalization function.
    However, each piece here is responsible for some aspect of reading URLs or appending
    its respective content to a larger variable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们上一个函数的基本推断，即大写函数。然而，这里的每个部分都负责读取URL或将其相应内容附加到较大的变量中。
- en: 'In the following code, we created a sort of master loop that lets you know
    when a URL has been grabbed on `statusChannel`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们创建了一种主循环，让您知道在`statusChannel`上何时抓取了一个URL：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Often, you'll see this wrapped in `go func()` as part of a `WaitGroup` struct,
    or not wrapped at all (depending on the type of feedback you require).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会看到这被包装在`go func()`中，作为`WaitGroup`结构的一部分，或者根本没有包装（取决于您需要的反馈类型）。
- en: The control flow, in this case, is `evaluateStatus`, which works as a channel
    monitor that lets us know when data crosses each channel and ends execution when
    it's complete. The `readURLs` function immediately begins reading our URLs, extracting
    the underlying data and passing it on to `textChannel`. At this point, our `addToScrapedText`
    function takes each sent HTML file and appends it to the `fullText` variable.
    When `evaluateStatus` determines that all URLs have been read, it sets `applicationStatus`
    to `false`. At this point, the infinite loop at the bottom of `main()` quits.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，控制流是`evaluateStatus`，它作为一个通道监视器，让我们知道数据何时穿过每个通道，并在执行结束时结束。`readURLs`函数立即开始读取我们的URL，提取底层数据并将其传递给`textChannel`。此时，我们的`addToScrapedText`函数接收每个发送的HTML文件并将其附加到`fullText`变量中。当`evaluateStatus`确定所有URL已被读取时，它将`applicationStatus`设置为`false`。此时，`main()`底部的无限循环退出。
- en: As mentioned, a crawler cannot come more rudimentary than this, but seeing a
    real-world example of how goroutines can work in congress will set us up for safer
    and more complex examples in the coming chapters.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，爬虫不能比这更基础，但是看到goroutines如何在一起工作的真实例子将为我们在接下来的章节中更安全和更复杂的例子做好准备。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to go from simple goroutines and instantiating
    channels to extending the basic functionality of goroutines and allowing cross-channel,
    bidirectional communication within concurrent processes. We looked at new ways
    to create blocking code to prevent our main process from ending before our goroutines.
    Finally, we learned about using select statements to develop reactive channels
    that are silent unless data is sent along a channel.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从简单的goroutines和实例化通道扩展到goroutines的基本功能，并允许并发进程内的跨通道、双向通信。我们看了一些创建阻塞代码的新方法，以防止我们的主进程在goroutines之前结束。最后，我们学习了使用select语句来开发反应式通道，除非沿着通道发送数据，否则它们是静默的。
- en: In our rudimentary web spider example, we employed these concepts together to
    create a safe, lightweight process that could extract all links from an array
    of URLs, grab the content via HTTP, and store the resulting response.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们基本的网络蜘蛛示例中，我们将这些概念结合在一起，创建了一个安全、轻量级的过程，可以从一系列URL中提取所有链接，通过HTTP获取内容并存储结果响应。
- en: In the next chapter, we'll go beneath the surface to see how Go's internal scheduling
    manages concurrency and start using channels to really utilize the power, thrift,
    and speed of concurrency in Go.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解Go的内部调度如何管理并发，并开始使用通道来真正利用Go中并发的力量、节俭和速度。
