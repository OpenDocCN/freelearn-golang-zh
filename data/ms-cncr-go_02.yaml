- en: Chapter 2. Understanding the Concurrency Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。理解并发模型
- en: Now that we have a sense of what Go is capable of and how to test drive some
    concurrency models, we need to look deeper into Go's most powerful features to
    understand how to best utilize various concurrent tools and models.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Go的能力以及如何测试一些并发模型，我们需要更深入地了解Go最强大的功能，以了解如何最好地利用各种并发工具和模型。
- en: We played with some general and basic goroutines to see how we can run concurrent
    processes, but we need to see how Go manages scheduling in concurrency before
    we get to communication between channels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们玩了一些一般和基本的goroutines，看看我们如何运行并发进程，但在我们开始通道之间的通信之前，我们需要看看Go是如何管理并发调度的。
- en: Understanding the working of goroutines
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解goroutines的工作方式
- en: By this point, you should be well-versed in what goroutines do, but it's worth
    understanding *how* they work internally in Go. Go handles concurrency with cooperative
    scheduling, which, as we mentioned in the previous chapter, is heavily dependent
    on some form of blocking code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该对goroutines做了很好的了解，但值得理解的是它们在Go中是如何内部工作的。Go使用协作调度处理并发，正如我们在前一章中提到的，这在某种程度上严重依赖于某种形式的阻塞代码。
- en: The most common alternative to cooperative scheduling is preemptive scheduling,
    wherein each subprocess is granted a space of time to complete and then its execution
    is paused for the next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 协作调度的最常见替代方案是抢占式调度，其中每个子进程被授予一段时间来完成，然后它的执行被暂停以进行下一个。
- en: Without some form of yielding back to the main thread, execution runs into issues.
    This is because Go works with a single process, working as a conductor for an
    orchestra of goroutines. Each subprocess is responsible to announce its own completion.
    As compared to other concurrency models, some of which allow for direct, named
    communication, this might pose a sticking point, particularly if you haven't worked
    with channels before.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 没有某种形式的让回到主线程，执行就会遇到问题。这是因为Go使用单个进程，作为goroutines乐队的指挥。每个子进程负责宣布自己的完成。与其他并发模型相比，其中一些允许直接命名通信，这可能构成一个难点，特别是如果你以前没有使用过通道。
- en: You can probably see a potential for deadlocks given these facts. In this chapter,
    we'll discuss both the ways Go's design allows us to manage this and the methods
    to mitigate issues in applications wherein it fails.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到这些事实存在死锁的潜在可能性。在本章中，我们将讨论Go的设计允许我们管理这一点的方式，以及在应用程序中解决问题的方法。
- en: Synchronous versus asynchronous goroutines
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步与异步goroutines
- en: Understanding the concurrency model is sometimes an early pain point for programmers—not
    just for Go, but across languages that use different models as well. Part of this
    is due to operating in a *black box* (depending on your terminal preferences);
    a developer has to rely on logging or errors with data consistency to discern
    asynchronous and/or multiple core timing issues.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并发模型有时是程序员的早期痛点，不仅仅是对于Go，还有其他使用不同模型的语言。部分原因是由于在*黑盒*中操作（取决于你的终端偏好）；开发人员必须依赖于日志记录或数据一致性错误来辨别异步和/或多核定时问题。
- en: As the concepts of synchronous and asynchronous or concurrent and nonconcurrent
    tasks can sometimes be a bit abstract, we will have a bit of fun here in an effort
    to demonstrate all the concepts we've covered so far in a visual way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同步和异步或并发和非并发任务的概念有时可能有点抽象，我们将在这里尝试以一种视觉方式来演示到目前为止我们所涵盖的所有概念。
- en: There are, of course, a myriad of ways to address feedback and logging. You
    can write to files in `console/terminal/stdout…`, most of which are inherently
    linear in nature. There is no concise way to represent concurrency in a logfile.
    Given this and the fact that we deal with an emerging language with a focus on
    servers, let's take a different angle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有许多方法来处理反馈和日志记录。你可以写入文件`console/terminal/stdout…`，其中大部分本质上是线性的。在日志文件中没有简洁的方式来表示并发。鉴于这一点，以及我们处理着一个专注于服务器的新兴语言，让我们采取不同的角度。
- en: Instead of simply outputting to a file, we'll create a visual feedback that
    shows when a process starts and stops on a timeline.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个可视化反馈，显示进程在时间轴上的开始和停止。
- en: Designing the web server plan
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Web服务器计划
- en: To show how approaches differ, we'll create a simple web server that loops through
    three trivial tasks and outputs their execution marks on an X-second timeline.
    We'll do this using a third-party library called `svgo` and the built-in `http`
    package for Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示不同的方法，我们将创建一个简单的Web服务器，循环执行三个微不足道的任务，并在X秒时间轴上输出它们的执行标记。我们将使用一个名为`svgo`的第三方库和Go的内置`http`包来实现这一点。
- en: 'To start, let''s grab the `svgo` library via `go get`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过`go get`获取`svgo`库：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you try to install a package via the `go get` command and get an error about
    `$GOPATH` not being set, you need to set that environment variable. `GOPATH` is
    where Go will look to find installed import packages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过`go get`命令安装一个包，并且收到关于未设置`$GOPATH`的错误，那么你需要设置该环境变量。`GOPATH`是Go将查找已安装的导入包的位置。
- en: 'To set this in Linux (or Mac), type the following in bash (or Terminal):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux（或Mac）中设置这个，输入以下bash（或终端）：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This path is up to you, so pick a place where you're most comfortable storing
    your Go packages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这条路由取决于你，所以选择一个你最舒适的地方来存储你的Go包。
- en: To ensure it's globally accessible, install it where your Go binary is installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它是全局可访问的，请将它安装在你的Go二进制文件安装的位置。
- en: 'On Windows, you can right-click on **My Computer** and navigate to **Properties**
    | **Advanced system settings** | **Environment Variables…**, as shown in the following
    screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你可以右键单击**我的电脑**，然后导航到**属性** | **高级系统设置** | **环境变量...**，如下面的截图所示：
- en: '![Designing the web server plan](img/00005.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![设计Web服务器计划](img/00005.jpeg)'
- en: 'Here, you''ll need to create a new variable called `GOPATH`. As with the Linux
    and Mac instructions, this can either be your Go language root directory or someplace
    else entirely. In this example, we''ve used `C:\Go`, as shown in the following
    screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您需要创建一个名为`GOPATH`的新变量。与Linux和Mac的说明一样，这可以是您的Go语言根目录，也可以是完全不同的地方。在本例中，我们使用了`C:\Go`，如下截图所示：
- en: '![Designing the web server plan](img/00006.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![设计Web服务器计划](img/00006.jpeg)'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that after taking these steps, you may need to reopen the Terminal, Command
    Prompt, or bash sessions before the value is read as valid. On *nix systems, you
    can log in and log out to initiate this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在执行这些步骤后，您可能需要重新打开终端、命令提示符或bash会话，以便值被视为有效。在*nix系统上，您可以登录和注销以启动此操作。
- en: Now that we have installed gosvg, we can visually demonstrate how the asynchronous
    and synchronous processes will look side-by-side as well as with multiple processors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了gosvg，我们可以直观地演示异步和同步进程并排以及多个处理器的外观。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**More libraries**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多库**'
- en: 'Why SVG? We didn''t need to use SVG and a web server, of course, and if you''d
    rather see an image generated and open that separately, there are other alternatives
    to do so. There are some additional graphical libraries available for Go, which
    are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用SVG？当然，我们不需要使用SVG和Web服务器，如果您更愿意看到生成的图像并单独打开它，还有其他替代方法可以做到这一点。Go还有一些其他可用的图形库，如下所示：
- en: '**draw2d**: As the name suggests, this is a two-dimensional drawing library
    for doing vector-style and raster graphics, which can be found at [https://code.google.com/p/draw2d/](https://code.google.com/p/draw2d/).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**draw2d**：顾名思义，这是一个用于进行矢量风格和光栅图形的二维绘图库，可以在[https://code.google.com/p/draw2d/](https://code.google.com/p/draw2d/)找到。'
- en: '**graphics-go**: This project involves some members of the Go team itself.
    It''s fairly limited in scope. You can find more about it at [https://code.google.com/p/graphics-go/](https://code.google.com/p/graphics-go/).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**graphics-go**：这个项目涉及Go团队的一些成员。它的范围相当有限。您可以在[https://code.google.com/p/graphics-go/](https://code.google.com/p/graphics-go/)找到更多信息。'
- en: '**go:ngine**: This is one of the few OpenGL implementations for Go. It can
    be overkill for this project, but if you find yourself in need of a three-dimensional
    graphics library, start at [http://go-ngine.com/](http://go-ngine.com/).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**go:ngine**：这是为Go设计的少数OpenGL实现之一。对于这个项目来说可能有些过度，但如果您发现自己需要一个三维图形库，可以从[http://go-ngine.com/](http://go-ngine.com/)开始。'
- en: '**Go-SDL**: Another possible overkill method, this is an implementation of
    the wonderful multimedia library SDL. You can find more about it at [https://github.com/banthar/Go-SDL](https://github.com/banthar/Go-SDL).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Go-SDL**：另一种可能过度的方法，这是一个实现了出色的多媒体库SDL的项目。您可以在[https://github.com/banthar/Go-SDL](https://github.com/banthar/Go-SDL)找到更多信息。'
- en: Robust GUI toolkits are also available, but as they were designed as systems
    languages, it isn't really Go's forte.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些强大的GUI工具包可用，但由于它们是作为系统语言设计的，这并不是Go的长处。
- en: Visualizing concurrency
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化并发
- en: Our first attempt at visualizing concurrency will have two simple goroutines
    running the `drawPoint` function in a loop with 100 iterations. After running
    this, you can visit `localhost:1900/visualize` and see what concurrent goroutines
    look like.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对可视化并发的第一次尝试将有两个简单的goroutines在循环中运行`drawPoint`函数，循环100次。运行后，您可以访问`localhost:1900/visualize`，看看并发goroutines的样子。
- en: If you run into problems with port 1900 (either with your firewall or through
    a port conflict), feel free to change the value on line 99 in the `main()` function.
    You may also need to access it through `127.0.0.1` if your system doesn't resolve
    localhost.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在端口1900上遇到问题（无论是防火墙还是端口冲突），请随意在`main()`函数的第99行更改该值。如果您的系统无法解析localhost，则可能还需要通过`127.0.0.1`访问它。
- en: 'Note that we''re not using `WaitGroup` or anything to manage the end of the
    goroutines because all we want to see is a visual representation of our code running.
    You can also handle this with a specific blocking code or `runtime.Gosched()`,
    as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有使用`WaitGroup`或任何其他东西来管理goroutines的结束，因为我们只想看到我们的代码运行的可视化表示。您也可以使用特定的阻塞代码或`runtime.Gosched()`来处理这个问题，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you go to `localhost:1900/visualize`, you should see something like the
    following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问`localhost:1900/visualize`时，您应该看到类似以下截图的内容：
- en: '![Visualizing concurrency](img/00007.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发](img/00007.jpeg)'
- en: 'As you can see, everything is definitely running concurrently—our briefly sleeping
    goroutines hit on the timeline at the same moment. By simply forcing the goroutines
    to run in a serial fashion, you''ll see a predictable change in this behavior.
    Remove the goroutine call on line 73, as shown:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一切肯定是同时运行的——我们短暂休眠的goroutines在同一时刻命中时间轴。通过简单地强制goroutines以串行方式运行，您将看到这种行为的可预测变化。如下所示，删除第73行的goroutine调用：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To keep our demonstration clean, change line 77 to indicate that there are
    no goroutines as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的演示清晰，将第77行更改为指示没有goroutines，如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we stop our server and restart with `go run`, we should see something like
    the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们停止服务器并使用`go run`重新启动，我们应该看到类似以下截图的内容：
- en: '![Visualizing concurrency](img/00008.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发](img/00008.jpeg)'
- en: Now, each process waits for the previous process to complete before beginning.
    You can actually add this sort of feedback to any application if you run into
    problems with syncing data, channels, and processes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个进程在开始之前都会等待前一个进程完成。如果您在同步数据、通道和进程的同步方面遇到问题，您实际上可以向任何应用程序添加这种反馈。
- en: If we so desired, we could add some channels and show communication across them
    as represented. Later, we will design a self-diagnosing server that gives real-time
    analytics about the state and status of the server, requests, and channels.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以添加一些通道，并显示它们之间的通信。稍后，我们将设计一个自我诊断服务器，实时提供有关服务器、请求和通道状态的分析。
- en: 'If we turn the goroutine back on and increase our maximum available processors,
    we''ll see something similar to the following screenshot, which is not exactly
    the same as our first screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新启动goroutine并增加最大可用处理器，我们将看到类似于以下截图的内容，这与我们的第一个截图并不完全相同：
- en: '![Visualizing concurrency](img/00009.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![可视化并发](img/00009.jpeg)'
- en: Your mileage will obviously vary depending on server speeds, the number of processors,
    and so on. But in this case, our change here resulted in a faster total execution
    time for our two processes with intermittent sleeps. This should come as no surprise,
    given we have essentially twice the bandwidth available to complete the two tasks.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您的里程数会根据服务器速度、处理器数量等而有所不同。但在这种情况下，我们的更改导致了两个具有间歇性休眠的进程的更快总执行时间。这应该不足为奇，因为我们基本上有两倍的带宽可用来完成这两个任务。
- en: RSS in action
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSS的实际应用
- en: Let's take the concept of **Rich Site Summary** / **Really Simple Syndication**
    (**RSS**) and inject some real potential delays to identify where we can best
    utilize goroutines in an effort to speed up execution and prevent blocking code.
    One common way to bring real-life, potentially blocking application elements into
    your code is to use something involving network transmission.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以**Rich Site Summary** / **Really Simple Syndication** (**RSS**)的概念为基础，并注入一些真正的潜在延迟，以确定我们在哪里可以最好地利用goroutines来加快执行速度并防止阻塞代码。将真实生活中可能阻塞应用程序元素引入您的代码的一种常见方式是使用涉及网络传输的内容。
- en: This is also a great place to look at timeouts and close channels to ensure
    that our program doesn't fall apart if something takes too long.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的地方，可以查看超时和关闭通道，以确保我们的程序不会在某些操作花费太长时间时崩溃。
- en: To accomplish both these requirements, we'll build a very basic RSS reader that
    will simply parse through and grab the contents of five RSS feeds. We'll read
    each of these as well as the provided links on each, and then we'll generate an
    SVG report of the process available via HTTP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这两个要求，我们将构建一个非常基本的RSS阅读器，它将简单地解析并获取五个RSS源的内容。我们将读取每一个源以及每个源上提供的链接，然后我们将通过HTTP生成一个SVG报告。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is obviously an application best suited for a background task—you'll notice
    that each request can take a long time. However, for graphically representing
    a real-life process working with and without concurrency, it will work, especially
    with a single end user. We'll also log our steps to standard output, so be sure
    to take a look at your console as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个最适合作为后台任务的应用程序——您会注意到每个请求可能需要很长时间。但是，为了以图形方式表示与并发和无并发的真实生活过程，它将起作用，特别是对于单个最终用户。我们还将将我们的步骤记录到标准输出中，所以一定要查看您的控制台。
- en: 'For this example, we''ll again use a third-party library, although it''s entirely
    possible to parse RSS using Go''s built-in XML package. Given the open-ended nature
    of XML and the specificity of RSS, we''ll bypass them and use `go-pkg-rss` by
    Jim Teeuwen, available via the following `go get` command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将再次使用第三方库，尽管完全可以使用Go的内置XML包来解析RSS。鉴于XML的开放性和RSS的特定性，我们将绕过它们，使用Jim Teeuwen的`go-pkg-rss`，可以通过以下`go
    get`命令获取：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this package is specifically intended as a replacement for the Google
    Reader product, which means that it does interval-based polling for new content
    within a set collection of sources, it also has a fairly neat and tidy RSS reading
    implementation. There are a few other RSS parsing libraries out there, though,
    so feel free to experiment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个包专门用作Google Reader产品的替代品，这意味着它会在一组来源中对新内容进行基于间隔的轮询，但它也有一个相当整洁的RSS阅读实现。虽然还有一些其他的RSS解析库，但是请随意尝试。
- en: An RSS reader with self diagnostics
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带自我诊断功能的RSS阅读器
- en: 'Let''s take a look at what we''ve learned so far, and use it to fetch and parse
    a set of RSS feeds concurrently while returning some visual feedback about the
    process in an internal web browser, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们迄今为止学到的东西，并利用它来同时获取和解析一组RSS源，同时在内部Web浏览器中返回有关该过程的一些可视化反馈，如下所示的代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is the basis of our feed''s overall structure: we have a `url` variable
    that represents the feed''s location, a `status` variable to indicate whether
    it''s started, and a `complete` Boolean variable to indicate it''s finished. The
    next piece is an individual `FeedItem`; here''s how it can be laid out:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们源的整体结构的基础：我们有一个代表源位置的`url`变量，一个表示它是否已启动的`status`变量，以及一个表示它是否已完成的`complete`布尔变量。下一个部分是一个单独的`FeedItem`；以下是它的布局方式：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Meanwhile, we will not do much with individual items; at this point, we simply
    maintain a URL, whether it's complete or a `FeedItem` struct's index.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们不会对单个项做太多处理；在这一点上，我们只是维护一个URL，无论它是完整的还是`FeedItem`结构体的索引。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `grabFeed()` method directly controls the flow of grabbing any individual
    feed. It also bypasses potential concurrent duplication through the `WaitGroup`
    struct. Next, let''s check out the `itemsHandler` function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`grabFeed()`方法直接控制抓取任何单个源的流程。它还通过`WaitGroup`结构绕过了潜在的并发重复。接下来，让我们看看`itemsHandler`函数：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `itemsHandler` function doesn''t do much at this point, other than instantiating
    a new `FeedItem` struct—in the real world, we''d take this as the next step and
    retrieve the values of the items themselves. Our next step is to look at the process
    that grabs individual feeds and marks the time taken for each one, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemsHandler`函数目前并没有做太多事情，除了实例化一个新的`FeedItem`结构体——在现实世界中，我们会将这作为下一步，并检索这些项本身的值。我们的下一步是查看抓取单个feed并标记每个feed所花费的时间的过程，如下所示：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we retrieve the RSS feed and mark points on our SVG with the status of
    our retrieval and read events. Our `main()` function will primarily handle the
    setup of feeds, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取RSS源并在我们的SVG上标记我们的检索和读取事件的状态。我们的`main()`函数主要处理源的设置，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is our slice of `FeedItem` structs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`FeedItem`结构体的切片：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the print version, these colors may not be particularly useful, but testing
    it on your system will allow you to delineate between events inside the application.
    We''ll need an HTTP route to act as an endpoint; here''s how we''ll set that up:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印版本中，这些颜色可能并不特别有用，但在您的系统上测试它将允许您区分应用程序内部的事件。我们需要一个HTTP路由作为终点；以下是我们将如何设置它：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When run, you should see the start and duration of the RSS feed retrieval and
    parsing, followed by a thin line indicating that the feed has been parsed and
    all items read.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，您应该看到RSS feed检索和解析的开始和持续时间，然后是一条细线，表示该feed已被解析并且所有项已被读取。
- en: 'Each of the three blocks expresses the full time to process each feed, demonstrating
    the nonconcurrent execution of this version, as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 三个块中的每一个都表达了处理每个feed的全部时间，展示了这个版本的非并发执行，如下面的屏幕截图所示：
- en: '![An RSS reader with self diagnostics](img/00010.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![带有自我诊断功能的RSS阅读器](img/00010.jpeg)'
- en: 'Note that we don''t do anything interesting with the feed items, we simply
    read the URL. The next step will be to grab the items via HTTP, as shown in the
    following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对feed项并没有做任何有趣的事情，我们只是读取URL。下一步将是通过HTTP获取这些项，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this example, we stop at every step to provide some sort of feedback to
    the SVG that some event has occurred. Our channel here is buffered and we explicitly
    state that it must receive three Boolean messages before it can finish blocking,
    as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们在每一步都停下来向SVG提供某种反馈，告诉它发生了某种事件。我们的通道在这里是有缓冲的，我们明确声明它必须在完成阻塞之前接收三条布尔消息，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: By giving `3` as the second parameter in our channel invocation, we tell Go
    that this channel must receive three responses before continuing the application.
    You should use caution with this, though, particularly in setting things explicitly
    as we have done here. What if one of the goroutines never sent a Boolean across
    the channel? The application would crash.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的通道调用中给出`3`作为第二个参数，我们告诉Go这个通道必须在继续应用程序之前接收三个响应。不过，您应该谨慎使用这个功能，特别是在明确设置事物时。如果其中一个goroutine从未通过通道发送布尔值会怎么样？应用程序会崩溃。
- en: Note that we also increased our timeline here, from 800ms to 60 seconds, to
    allow for retrieval of all feeds. Keep in mind that if our script exceeds 60 seconds,
    all actions beyond that time will occur outside of this visual timeline representation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里还增加了我们的时间轴，从800毫秒增加到60秒，以便检索所有的feeds。请记住，如果我们的脚本超过60秒，那么超过这个时间的所有操作都将发生在这个可视时间轴表示之外。
- en: 'By implementing the `WaitGroup` struct while reading feeds, we impose some
    serialization and synchronization to the application. The second feed will not
    start until the first feed has completed retrieving all URLs. You can probably
    see where this might introduce some errors going forward:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在读取feeds时实现`WaitGroup`结构，我们对应用程序施加了一些串行化和同步。第二个feed将在第一个feed完成检索所有URL之前不会开始。您可能会看到这可能会引入一些错误：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This tells our application to yield until we set the `Done()` command from the
    `itemsHandler()` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的应用程序要等到我们从`itemsHandler()`函数中设置`Done()`命令为止。
- en: So what happens if we remove `WaitGroups` entirely? Given that the calls to
    grab the feed items are asynchronous, we may not see the status of all of our
    RSS calls; instead, we might see just one or two feeds or no feed at all.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们完全删除`WaitGroups`会发生什么？考虑到抓取feed项的调用是异步的，我们可能看不到所有的RSS调用的状态；相反，我们可能只看到一个或两个feeds，或者根本没有feed。
- en: Imposing a timeout
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强加超时
- en: So what happens if nothing runs within our timeline? As you might expect, we'll
    get three bars with no activity in them. It's important to consider how to kill
    processes that aren't doing what we expect them to. In this case, the best method
    is a timeout. The `Get` method in the `http` package does not natively support
    a timeout, so you'll have to roll your own `rssFeed.Fetch` (and underlying `http.Get()`)
    implementation if you want to prevent these requests from going into perpetuity
    and killing your application. We'll dig into this a bit later; in the mean time,
    take a look at the `Transport` struct, available in the core `http` package at
    [http://golang.org/pkg/net/http/#Transport](http://golang.org/pkg/net/http/#Transport).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果在我们的时间轴内没有运行任何东西会发生什么？正如您所期望的那样，我们将得到三个没有任何活动的条形图。重要的是要考虑如何终止那些没有按我们期望的方式运行的进程。在这种情况下，最好的方法是超时。`http`包中的`Get`方法并不原生支持超时，因此如果您想要防止这些请求永无止境地进行并杀死您的应用程序，您将不得不自己编写`rssFeed.Fetch`（和底层的`http.Get()`）实现。我们稍后会深入探讨这一点；与此同时，看一下核心`http`包中可用的`Transport`结构，网址为[http://golang.org/pkg/net/http/#Transport](http://golang.org/pkg/net/http/#Transport)。
- en: A little bit about CSP
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于CSP的一点说明
- en: We touched on CSP briefly in the previous chapter, but it's worth exploring
    a bit more in the context of how Go's concurrency model operates.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中简要介绍了CSP，但在Go的并发模型操作方式的背景下，值得更深入地探讨一下。
- en: CSP evolved in the late 1970s and early 1980s through the work of Sir Tony Hoare
    and is still in the midst of evolution today. Go's implementation is heavily based
    on CSP, but it neither entirely follows all the rules and conventions set forth
    in its initial description nor does it follow its evolution since.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CSP在20世纪70年代末和80年代初通过Tony Hoare爵士的工作发展起来，至今仍在不断发展中。Go的实现在很大程度上基于CSP，但它既不完全遵循初始描述中设定的所有规则和惯例，也不遵循其自那时以来的发展。
- en: One of the ways in which Go differs from true CSP is that as it is defined,
    a process in Go will only continue so long as there exists a channel ready to
    receive from that process. We've already encountered a couple of deadlocks that
    were the result of a listening channel with nothing to receive. The inverse is
    also true; a deadlock can result from a channel continuing without sending anything,
    leaving its receiving channel hanging indefinitely.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Go与真正的CSP不同的一种方式是，根据其定义，Go中的一个进程只会继续存在，只要存在一个准备好从该进程接收的通道。 我们已经遇到了一些由于监听通道没有接收任何内容而导致的死锁。
    反之亦然；死锁也可能是由于通道继续而没有发送任何内容，使其接收通道无限期挂起。
- en: This behavior is endemic to Go's scheduler, and it should really only pose problems
    when you're working with channels initially.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是Go调度程序的典型特征，当您最初使用通道时，它确实只会在您处理通道时造成问题。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hoare's original work is now available (mostly) free from a number of institutions.
    You can read, cite, copy, and redistribute it free of charge (but not for commercial
    gain). If you want to read the whole thing, you can grab it at [http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 霍尔的原始作品现在可以从许多机构（大部分）免费获得。 您可以免费阅读，引用，复制和重新分发它（但不能用于商业用途）。 如果您想阅读整个内容，可以在[http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf](http://www.cs.ucf.edu/courses/cop4020/sum2009/CSP-hoare.pdf)上获取。
- en: The complete book itself is also available at [http://www.usingcsp.com/cspbook.pdf](http://www.usingcsp.com/cspbook.pdf).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的书本本身也可以在[http://www.usingcsp.com/cspbook.pdf](http://www.usingcsp.com/cspbook.pdf)上获得。
- en: As of this publishing, Hoare is working as a researcher at Microsoft.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本出版之时，霍尔正在微软担任研究员。
- en: As per the designers of the application itself, the goal of Go's implementation
    of CSP concepts was to focus on simplicity—you don't have to worry about threads
    or mutexes unless you really want to or need to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序设计者的说法，Go实现CSP概念的目标是专注于简单性-除非您真的想要或需要，否则您不必担心线程或互斥量。
- en: The dining philosophers problem
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 餐桌哲学家问题
- en: 'You may have heard of the dining philosophers problem, which describes the
    kind of problems concurrent programming was designed to solve. The dining philosophers
    problem was formulated by the great Edsger Dijkstra. The crux of the problem is
    a matter of resources—five philosophers sit at a table with five plates of food
    and five forks, and each can only eat when he has two forks (one to his left and
    another to his right). A visual representation is shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经听说过餐桌哲学家问题，这描述了并发编程旨在解决的问题类型。 餐桌哲学家问题是由伟大的Edsger Dijkstra提出的。 问题的关键在于资源-五位哲学家坐在一张桌子旁，有五盘食物和五把叉子，每个人只有在他有两把叉子（一把在左边，另一把在右边）时才能吃饭。
    可视化表示如下：
- en: '![The dining philosophers problem](img/00011.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![The dining philosophers problem](img/00011.jpeg)'
- en: With a single fork on either side, any given philosopher can only eat when he
    has a fork in both hands and must put both back on the table when complete. The
    idea is to coordinate the meal such that all of the philosophers can eat in perpetuity
    without any starving—two philosophers must be able to eat at any moment and there
    can be no deadlocks. They're philosophers because when they're not eating, they're
    thinking. In a programming analog, you can consider this as either a waiting channel
    or a sleeping process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一侧只有一把叉子时，任何给定的哲学家只有在双手都拿着叉子时才能吃饭，并且在完成后必须将两者都放回桌子上。 思想是协调餐点，以便所有哲学家都可以永远吃饭而不会挨饿-任何时刻都必须有两位哲学家能够吃饭，而且不能有死锁。
    他们是哲学家，因为当他们不吃饭时，他们在思考。 在编程类比中，您可以将其视为等待通道或睡眠进程。
- en: Go handles this problem pretty succinctly with goroutines. Given five philosophers
    (in an individual struct, for example), you can have all five alternate between
    thinking, receiving a notification when the forks are down, grabbing forks, dining
    with forks, and placing the forks down.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用goroutines相当简洁地处理了这个问题。 给定五位哲学家（例如在一个单独的结构中），您可以让这五位哲学家在思考、在叉子放下时接收通知、抓住叉子、用叉子就餐和放下叉子之间交替。
- en: Receiving the notification that the forks are down acts as the listening channel,
    dining and thinking are separate processes, and placing the forks down operates
    as an announcement along the channel.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到叉子放下的通知作为监听通道，就餐和思考是独立的过程，放下叉子则是沿通道的公告。
- en: 'We can visualize this concept in the following pseudo Go code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下伪Go代码中可视化这个概念：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This example has been left very abstract and nonoperational so that you have
    a chance to attempt to solve it. We will build a functional solution for this
    in the next chapter, so make sure to compare your solution later on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子被留得非常抽象和非操作性，以便您有机会尝试解决它。 我们将在下一章中为此构建一个功能性解决方案，因此请确保稍后比较您的解决方案。
- en: There are hundreds of ways to handle this problem, and we'll look at a couple
    of alternatives and how they can or cannot play nicely within Go itself.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百种处理此问题的方法，我们将看看一些替代方案以及它们在Go本身内部如何能够或不能够很好地发挥作用。
- en: Go and the actor model
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go和演员模型
- en: The actor model is something that you'll likely be very familiar with if you're
    an Erlang or Scala user. The difference between CSP and the actor model is negligible
    but important. With CSP, messages from one channel can only be completely sent
    if another channel is listening and ready for them. The actor model does not necessarily
    require a ready channel for another to send. In fact, it stresses direct communication
    rather than relying on the conduit of a channel.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Erlang或Scala用户，那么演员模型可能是您非常熟悉的。 CSP和演员模型之间的区别微不足道但很重要。 使用CSP，如果另一个通道正在监听并准备好接收消息，那么来自一个通道的消息只能完全发送。
    演员模型并不一定需要准备好的通道才能发送。 实际上，它强调直接通信，而不是依赖通道的导管。
- en: 'Both systems can be nondeterministic, which we''ve already seen demonstrated
    in Go/CSP in our earlier examples. CSP and goroutines are anonymous and transmission
    is specified by the channel rather than the source and destination. An easy way
    to visualize this in pseudocode in the actor model is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种系统都可能是不确定的，这在我们之前的Go/CSP示例中已经看到了。CSP和goroutines都是匿名的，传输由通道而不是源和目的地指定。在演员模型的伪代码中可视化这一点的简单方法如下：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In CSP, it is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSP中，它是这样的：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both serve the same fundamental functionality but through slightly different
    ways.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都通过稍微不同的方式提供了相同的基本功能。
- en: Object orientation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象
- en: As you work with Go, you will notice that there is a core characteristic that's
    often espoused, which users may feel is wrong. You'll hear that Go is not an object-oriented
    language, and yet you have structs that can have methods, those methods in turn
    can have methods, and you can have communication to and from any instantiation
    of it. Channels themselves may feel like primitive object interfaces, capable
    of setting and receiving values from a given data element.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Go时，你会注意到一个核心特征经常被提倡，用户可能觉得是错误的。你会听到Go不是一种面向对象的语言，然而你有可以有方法的结构体，这些方法反过来又可以有方法，你可以与任何实例进行通信。通道本身可能感觉像原始的对象接口，能够从给定的数据元素中设置和接收值。
- en: The message passing implementation of Go is, indeed, a core concept of object-oriented
    programming. Structs with interfaces operate essentially as classes, and Go supports
    polymorphism (although not parametric polymorphism). Yet, many who work with the
    language (and who have designed it) stress that it is not object oriented. So
    what gives?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Go的消息传递实现确实是面向对象编程的核心概念。具有接口的结构本质上就像类，Go支持多态性（尽管不支持参数多态性）。然而，许多使用该语言的人（以及设计它的人）强调它并不是面向对象的。那么是什么原因呢？
- en: Much of this definition ultimately depends on who you ask. Some believe that
    Go lacks some of the requisite characteristics of object-oriented programming,
    and others believe it satisfies them. The most important thing to keep in mind
    is that you're not limited by Go's design. Anything that you can do in a *true*
    object-oriented language can be handled without much struggle within Go.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义的很大程度上取决于你问的是谁。有些人认为Go缺乏面向对象编程的必要特征，而其他人认为它满足了这些特征。最重要的是要记住，你并不受Go设计的限制。在*真正*的面向对象语言中可以做的任何事情在Go中都可以轻松处理。
- en: Demonstrating simple polymorphism in Go
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示Go中简单的多态性
- en: 'As mentioned before, if you expect polymorphism to resemble object-oriented
    programming, this may not represent a syntactical analogue. However, the use of
    interfaces as an abstraction of class-bound polymorphic methods is just as clean,
    and in many ways, more explicit and readable. Let''s look at a very simple implementation
    of polymorphism in Go:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你期望多态性类似于面向对象编程，这可能不代表一种语法类比。然而，使用接口作为类绑定多态方法的抽象同样干净，并且在许多方面更加明确和可读。让我们看一个Go中多态性的非常简单的实现：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we use an interface (or its Go analog) to disambiguate methods.
    You cannot have generics the same way you might in Java, for example. This, however,
    boils down to a mere matter of style in the end. You should neither find this
    daunting nor will it impose any cruft or ambiguity into your code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用接口（或其Go模拟）来消除方法的歧义。例如，你不能像在Java中那样使用泛型。然而，这归结为最终只是一种风格问题。你既不应该觉得这令人畏惧，也不会给你的代码带来任何混乱或歧义。
- en: Using concurrency
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并发
- en: It hasn't yet been mentioned, but we should be aware that concurrency is not
    always necessary and beneficial for an application. There exists no real rule
    of thumb, and it's rare that concurrency will introduce problems to an application;
    but if you really think about applications as a whole, not all will require concurrent
    processes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未提到的是，我们应该意识到，并发并不总是对应用程序有益的。并没有真正的经验之谈，而且并发很少会给应用程序带来问题；但是如果你真的考虑整个应用程序，不是所有的应用程序都需要并发进程。
- en: So what works best? As we've seen in the previous example, anything that introduces
    potential latency or I/O blocking, such as network calls, disk reads, third-party
    applications (primarily databases), and distributed systems, can benefit from
    concurrency. If you have the ability to do work while other work is being done
    on an undetermined timeline, concurrency strategies can improve the speed and
    reliability of an application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么效果最好呢？正如我们在之前的例子中看到的，任何引入潜在延迟或I/O阻塞的东西，比如网络调用、磁盘读取、第三方应用程序（主要是数据库）和分布式系统，都可以从并发中受益。如果你有能力在未确定的时间表上进行工作，那么并发策略可以提高应用程序的速度和可靠性。
- en: The lesson here is you should never feel compelled to shoehorn concurrency into
    an application that doesn't really require it. Programs with inter-process dependencies
    (or lack of blocking and external dependencies) may see little or no benefit from
    implementing concurrency structures.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是你不应该感到被迫将并发加入到一个真正不需要它的应用程序中。具有进程间依赖关系（或缺乏阻塞和外部依赖关系）的程序可能很少或根本不会从实现并发结构中获益。
- en: Managing threads
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理线程
- en: So far, you've probably noticed that thread management is not a matter that
    requires the programmer's utmost concern in Go. This is by design. Goroutines
    aren't tied to a specific thread or threads that are handled by Go's internal
    scheduler. However, this doesn't mean that you neither have access to the threads
    nor the ability to control what individual threads do. As you know, you can already
    tell Go how many threads you have (or wish to use) by using `GOMAXPROCS`. We also
    know that using this can introduce asynchronous issues as it pertains to data
    consistency and execution order.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到，在Go中，线程管理并不是程序员最关心的问题。这是有意设计的。Goroutines并不绑定到Go内部调度程序处理的特定线程或线程。然而，这并不意味着你既不能访问线程，也不能控制单个线程的操作。正如你所知，你已经可以告诉Go你有多少线程（或希望使用）通过使用`GOMAXPROCS`。我们也知道，使用这个可能会引入与数据一致性和执行顺序相关的异步问题。
- en: At this point, the main issue with threads is not how they're accessed or utilized,
    but how to properly control execution flow to guarantee that your data is predictable
    and synchronized.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，线程的主要问题不是它们如何被访问或利用，而是如何正确地控制执行流程，以确保你的数据是可预测的和同步的。
- en: Using sync and mutexes to lock data
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sync和互斥锁来锁定数据
- en: One issue that you may have run into with the preceding examples is the notion
    of atomic data. After all, if you deal with variables and structures across multiple
    goroutines, and possibly processors, how do you ensure that your data is safe
    across them? If these processes run in parallel, coordinating data access can
    sometimes be problematic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在前面的例子中遇到的一个问题是原子数据的概念。毕竟，如果你在多个goroutines和可能的处理器之间处理变量和结构，你如何确保你的数据在它们之间是安全的？如果这些进程并行运行，协调数据访问有时可能会有问题。
- en: Go provides a bevy of tools in its `sync` package to handle these types of problems.
    How elegantly you approach them depends heavily on your approach, but you should
    never have to reinvent the wheel in this realm.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Go在其`sync`包中提供了大量工具来处理这些类型的问题。你如何优雅地处理它们在很大程度上取决于你的方法，但在这个领域你不应该不得不重新发明轮子。
- en: We've already looked at the `WaitGroup` struct, which provides a simple method
    to tell the main thread to pause until the next notification that says a waiting
    process has done what it's supposed to do.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过`WaitGroup`结构，它提供了一种简单的方法，告诉主线程暂停，直到下一个通知说等待的进程已经完成了它应该做的事情。
- en: Go also provides a direct abstraction to a mutex. It may seem contradictory
    to call something a direct abstraction, but the truth is you don't have access
    to Go's scheduler, only an approximation of a true mutex.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Go还提供了对互斥锁的直接抽象。称某物为直接抽象可能看起来矛盾，但事实上你并没有访问Go的调度程序，只是一个真正互斥锁的近似。
- en: 'We can use a mutex to lock and unlock data and guarantee atomicity in our data.
    In many cases, this may not be necessary; there are a great many times where the
    order of execution does not impact the consistency of the underlying data. However,
    when we do have concerns about this value, it''s helpful to be able to invoke
    a lock explicitly. Let''s take the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用互斥锁来锁定和解锁数据，并保证数据的原子性。在许多情况下，这可能是不必要的；有很多时候，执行顺序并不影响底层数据的一致性。然而，当我们对这个值有顾虑时，能够显式地调用锁是很有帮助的。让我们看下面的例子：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unsurprisingly, this provides a list of 0 to 99 in your terminal. What happens
    if we change `WaitGroup` to know there will be 100 instances of `Done()` called,
    and put our blocking code at the end of the loop?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，在你的终端中提供了0到99的列表。如果我们将`WaitGroup`更改为知道将调用100个`Done()`实例，并将我们的阻塞代码放在循环的末尾，会发生什么？
- en: 'To demonstrate a simple proposition of why and how to best utilize `waitGroups`
    as a mechanism for concurrency control, let''s do a simple number iterator and
    look at the results. We will also check out how a directly called mutex can augment
    this functionality, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示为什么以及如何最好地利用`waitGroups`作为并发控制机制的一个简单命题，让我们做一个简单的数字迭代器并查看结果。我们还将看看如何直接调用互斥锁可以增强这种功能，如下所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, our order of execution is suddenly off. You may see something like the
    following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的执行顺序突然错了。你可能会看到类似以下的输出：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have the ability to lock and unlock the current command at will; however,
    this won't change the underlying execution order, it will only prevent reading
    and/or writing to and from a variable until an unlock is called.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有能力随时锁定和解锁当前命令；然而，这不会改变底层的执行顺序，它只会阻止对变量的读取和/或写入，直到调用解锁为止。
- en: 'Let''s try to lock down the variable we''re outputting using `mutex`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`mutex`锁定我们输出的变量，如下所示：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can probably see how a mutex control mechanism can be important to enforce
    data integrity in your concurrent application. We'll look more at mutexes and
    locking and unlocking processes in [Chapter 4](part0040_split_000.html#page "Chapter 4. Data
    Integrity in an Application"), *Data Integrity in an Application*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到，在并发应用程序中，互斥控制机制如何重要，以确保数据的完整性。我们将在[第4章](part0040_split_000.html#page
    "Chapter 4. Data Integrity in an Application")*应用程序中的数据完整性*中更多地了解互斥锁和锁定和解锁过程。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've tried to remove some of the ambiguity of Go's concurrency
    patterns and models by giving visual, real-time feedback to a few applications,
    including a rudimentary RSS aggregator and reader. We examined the dining philosophers
    problem and looked at ways you can use the Go concurrency topics to solve the
    problem neatly and succinctly. We compared the way CSP and actor models are similar
    and ways in which they differ.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图通过给出一些可视化的实时反馈，来消除Go并发模式和模型的一些模糊性，包括一个基本的RSS聚合器和阅读器。我们研究了餐桌哲学家问题，并探讨了如何使用Go并发主题来整洁而简洁地解决问题。我们比较了CSP和actor模型的相似之处以及它们的不同之处。
- en: In the next chapter, we will take these concepts and apply them to the process
    of developing a strategy to maintain concurrency in an application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这些概念应用到开发应用程序中维护并发性的过程中。
