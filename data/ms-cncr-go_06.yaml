- en: Chapter 6. C10K – A Non-blocking Web Server in Go
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。在Go中创建一个非阻塞Web服务器
- en: Up to this point, we've built a few usable applications; things we can start
    with and leapfrog into real systems for everyday use. By doing so, we've been
    able to demonstrate the basic and intermediate-level patterns involved in Go's
    concurrent syntax and methodology.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一些可用的应用程序；我们可以从中开始，并跃入到日常使用的真实系统中。通过这样做，我们能够展示Go并发语法和方法中涉及的基本和中级模式。
- en: However, it's about time we take on a real-world problem—one that has vexed
    developers (and their managers and VPs) for a great deal of the early history
    of the Web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在是时候解决一个真实世界的问题了——这个问题困扰了开发人员（以及他们的经理和副总裁）在Web的早期历史中很长一段时间。
- en: In addressing and, hopefully, solving this problem, we'll be able to develop
    a high-performance web server that can handle a very large volume of live, active
    traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解决这个问题，我们将能够开发一个高性能的Web服务器，可以处理大量的实时活跃流量。
- en: For many years, the solution to this problem was solely to throw hardware or
    intrusive caching systems at the problem; so, alternately, solving it with programming
    methodology should excite any programmer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，解决这个问题的唯一方法是向问题投入硬件或侵入式缓存系统；因此，用编程方法解决它应该会激发任何程序员的兴趣。
- en: 'We''ll be using every technique and language construct we''ve learned so far,
    but we''ll do so in a more structured and deliberate way than we have up to now.
    Everything we''ve explored so far will come into play, including the following
    points:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用到目前为止学到的每一种技术和语言构造，但我们将以比以前更有条理和有意识的方式来做。到目前为止，我们所探讨的一切都将发挥作用，包括以下几点：
- en: Creating a visual representation of our concurrent application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们并发应用的可视化表示
- en: Utilizing goroutines to handle requests in a way that will scale
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用goroutine来处理请求，以实现可扩展性
- en: Building robust channels to manage communication between goroutines and the
    loop that will manage them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建健壮的通道来管理goroutine之间的通信和管理它们的循环
- en: Profiling and benchmarking tools (JMeter, ab) to examine the way our event loop
    actually works
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析和基准测试工具（JMeter、ab）来检查我们的事件循环的实际工作方式
- en: Timeouts and concurrency controls—when necessary—to ensure data and request
    consistency
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时设置超时和并发控制，以确保数据和请求的一致性
- en: Attacking the C10K problem
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻克C10K问题
- en: The genesis of the C10K problem is rooted in serial, blocking programming, which
    makes it ideal to demonstrate the strength of concurrent programming, especially
    in Go.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C10K问题的起源根植于串行、阻塞式编程，这使得它成为展示并发编程优势的理想选择，特别是在Go语言中。
- en: 'The proposed problem came from developer Dan Kegel, who famously asked:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的提出者是开发者丹·凯格尔，他曾经问过：
- en: '|   | *It''s time for web servers to handle ten thousand clients simultaneously,
    don''t you think? After all, the web is a big place now.* |   |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| *是时候让Web服务器同时处理一万个客户端了，你不觉得吗？毕竟，现在的网络是一个很大的地方。* | |'
- en: '|   | --*Dan Kegel ([http://www.kegel.com/c10k.html](http://www.kegel.com/c10k.html))*
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --*丹·凯格尔（[http://www.kegel.com/c10k.html](http://www.kegel.com/c10k.html）*
    |'
- en: When he asked this in 1999, for many server admins and engineers, serving 10,000
    concurrent visitors was something that would be solved with hardware. The notion
    that a single server on common hardware could handle this type of CPU and network
    bandwidth without falling over seemed foreign to most.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当他在1999年提出这个问题时，对于许多服务器管理员和工程师来说，为10,000个并发访问者提供服务是需要通过硬件解决的问题。在常见硬件上，单个服务器能够处理这种类型的CPU和网络带宽而不会崩溃的想法对大多数人来说似乎是陌生的。
- en: The crux of his proposed solutions relied on producing non-blocking code. Of
    course, in 1999, concurrency patterns and libraries were not widespread. C++ had
    some polling and queuing options available via some third-party libraries and
    the earliest predecessor to multithreaded syntaxes, later available through Boost
    and then C++11.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 他提出的解决方案的关键在于生成非阻塞代码。当然，在1999年，并发模式和库并不普遍。C++通过一些第三方库和后来通过Boost和C++11提供的最早的多线程语法的前身，有一些轮询和排队选项。
- en: Over the coming years, solutions to the problem began pouring in across various
    flavors of languages, programming design, and general approaches. At the time
    of publishing this book, the C10K problem is not one without solutions, but it
    is still an excellent platform to conduct a very real-world challenge to high-performance
    Go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几年里，针对这个问题的解决方案开始涌现，涵盖了各种语言、编程设计和一般方法。在撰写本书时，C10K问题并非没有解决方案，但它仍然是一个非常适合在高性能Go中进行真实世界挑战的平台。
- en: Any performance and scalability problem will ultimately be bound to the underlying
    hardware, so as always, your mileage may vary. Squeezing 10,000 concurrent connections
    on a 486 processor with 500 MB of RAM will certainly be more challenging than
    doing so on a barebones Linux server stacked with memory and multiple cores.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 任何性能和可伸缩性问题最终都将受限于底层硬件，因此，结果可能因人而异。在486处理器和500MB RAM上实现10,000个并发连接肯定比在堆满内存和多核的Linux服务器上实现更具挑战性。
- en: It's also worth noting that a simple echo server would obviously be able to
    assume more cores than a functional web server that returns larger amounts of
    data and accepts greater complexity in requests, sessions, and so on, as we'll
    be dealing with here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一个简单的回显服务器显然能够承担比返回更多数据并接受更复杂请求、会话等的功能性Web服务器更多的核心，正如我们将在这里处理的那样。
- en: Failing of servers at 10,000 concurrent connections
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器在10,000个并发连接时失败
- en: As you may recall, when we discussed concurrent strategies back in [Chapter
    3](part0032_split_000.html#page "Chapter 3. Developing a Concurrent Strategy"),
    *Developing a Concurrent Strategy*, we talked a bit about Apache and its load-balancing
    tools.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能还记得的，当我们在[第3章](part0032_split_000.html#page "第3章。开发并发策略")中讨论并发策略时，我们谈到了一些关于Apache及其负载均衡工具的内容。
- en: When the Web was born and the Internet commercialized, the level of interactivity
    was pretty minimal. If you're a graybeard, you may recall the transition from
    NNTP/IRC and the like and how extraordinarily rudimentary the Web was.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web诞生并且互联网商业化时，互动水平相当低。如果你是一个老手，你可能还记得从NNTP/IRC等的转变以及Web的极其原始的情况。
- en: To address the basic proposition of [page request] → [HTTP response], the requirements
    on a web server in the early 1990s were pretty lenient. Ignoring all of the error
    responses, header readings and settings, and other essential (but unrelated to
    the in → out mechanism) functions, the essence of the early servers was shockingly
    simple, at least compared to the modern web servers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决[页面请求]→[HTTP响应]的基本命题，20世纪90年代早期对Web服务器的要求相当宽松。忽略所有的错误响应、头部读取和设置以及其他基本功能（但与输入输出机制无关），早期服务器的本质相当简单，至少与现代Web服务器相比是如此。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first web server was developed by the father of the Web, Tim Berners-Lee.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个Web服务器是由Web之父蒂姆·伯纳斯-李开发的。
- en: Developed at CERN (such as WWW/HTTP itself), CERN httpd handled many of the
    things you would expect in a web server today—hunting through the code, you'll
    find a lot of notation that will remind you that the very core of the HTTP protocol
    is largely unchanged. Unlike most technologies, HTTP has had an extraordinarily
    long shelf life.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由CERN（例如WWW/HTTP本身）开发的CERN httpd处理了许多你今天在Web服务器中所期望的事情——在代码中搜索，你会发现很多注释，这些注释会让你想起HTTP协议的核心基本上没有改变。与大多数技术不同，HTTP的寿命非常长。
- en: Written in C in 1990, it was unable to utilize a lot of concurrency strategies
    available in languages such as Erlang. Frankly, doing so was probably unnecessary—the
    majority of web traffic was a matter of basic file retrieval and protocol. The
    meat and potatoes of a web server were not dealing with traffic, but rather dealing
    with the rules surrounding the protocol itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 1990年用C语言编写的服务器无法利用Erlang等语言中可用的许多并发策略。坦率地说，这样做可能是不必要的——大多数的Web流量都是基本的文件检索和协议问题。Web服务器的核心问题不是处理流量，而是处理协议本身的规则。
- en: You can still access the original CERN httpd site and download the source code
    for yourself from [http://www.w3.org/Daemon/](http://www.w3.org/Daemon/). I highly
    recommend that you do so as both a history lesson and a way to look at the way
    the earliest web server addressed some of the earliest problems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以访问原始的CERN httpd网站，并从[http://www.w3.org/Daemon/](http://www.w3.org/Daemon/)下载源代码。我强烈建议你这样做，既可以作为历史课程，也可以看看最早的Web服务器是如何解决最早的问题的。
- en: However, the Web in 1990 and the Web when the C10K question was first posed
    were two very different environments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，1990年的Web和首次提出C10K问题时的Web是两个非常不同的环境。
- en: By 1999, most sites had some level of secondary or tertiary latency provided
    by third-party software, CGI, databases, and so on, all of which further complicated
    the matter. The notion of serving 10,000 flat files concurrently is a challenge
    in itself, but try doing so by running them on top of a Perl script that accesses
    a MySQL database without any caching layer; the challenge is immediately exacerbated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到1999年，大多数网站都有一定程度的由第三方软件、CGI、数据库等提供的次要或第三级延迟，所有这些都进一步复杂化了问题。同时并发地提供10,000个平面文件的概念本身就是一个挑战，但是如果通过在Perl脚本的基础上运行它们来访问MySQL数据库而没有任何缓存层，这个挑战就会立即加剧。
- en: By the mid 1990s, the Apache web server had taken hold and largely controlled
    the market (by 2009, it had become the first server software to serve more than
    100 million websites).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到了20世纪90年代中期，Apache Web服务器已经占据主导地位，并在很大程度上控制了市场（到2009年，它成为第一个为超过1亿个网站提供服务的服务器软件）。
- en: 'Apache''s approach was rooted heavily in the earliest days of the Internet.
    At its launch, connections were initially handled first in, first out. Soon, each
    connection was assigned a thread from the thread pool. There are two problems
    with the Apache server. They are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Apache的方法深深扎根于互联网的早期。在推出时，连接最初是先进先出处理的。很快，每个连接都被分配了一个线程池中的线程。Apache服务器存在两个问题。它们如下：
- en: Blocking connections can lead to a domino effect, wherein one or more slowly
    resolved connections could avalanche into inaccessibility
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞连接可能导致多米诺效应，其中一个或多个慢速解析的连接可能会导致无法访问
- en: Apache had hard limits on the number of threads/workers you could utilize, irrespective
    of hardware constraints
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache对可以利用的线程/工作者数量有严格的限制，与硬件约束无关
- en: It's easy to see the opportunity here, at least in retrospect. A concurrent
    server that utilizes actors (Erlang), agents (Clojure), or goroutines (Go) seems
    to fit the bill perfectly. Concurrency does not *solve* the C10k problem in itself,
    but it absolutely provides a methodology to facilitate it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 至少从回顾的角度来看，这里很容易看到机会。一个利用actors（Erlang）、agents（Clojure）或goroutines（Go）的并发服务器似乎完全符合要求。并发本身并不能解决C10k问题，但它绝对提供了一种促进解决的方法。
- en: 'The most notable and visible example of an approach to the C10K problem today
    is Nginx, which was developed using concurrency patterns, widely available in
    C by 2002 to address—and ultimately solve—the C10k problem. Nginx, today, represents
    either the #2 or #3 web server in the world, depending on the source.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 今天解决C10K问题的最显著和可见的例子是Nginx，它是使用并发模式开发的，到2002年在C语言中广泛可用，用于解决C10K问题。如今，Nginx代表着世界上第二或第三大的Web服务器，这取决于来源。
- en: Using concurrency to attack C10K
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用并发攻击C10K
- en: There are two primary approaches to handle a large volume of concurrent requests.
    The first involves allocating threads per connection. This is what Apache (and
    a few others) do.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大量并发请求的两种主要方法。第一种方法涉及为每个连接分配线程。这就是Apache（和其他一些服务器）所做的。
- en: On the one hand, allocating a thread to a connection makes a lot of sense—it's
    isolated, controllable via the application's and kernel's context switching, and
    can scale with increased hardware.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，为连接分配一个线程是有很多道理的——它是隔离的，可以通过应用程序和内核的上下文切换进行控制，并且可以随着硬件的增加而扩展。
- en: One problem for Linux servers—on which the majority of the Web lives—is that
    each allocated thread reserves 8 MB of memory for its stack by default. This can
    (and should) be redefined, but this imposes a largely unattainable amount of memory
    required for a single server. Even if you set the default stack size to 1 MB,
    we're dealing with a minimum of 10 GB of memory just to handle the overhead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux服务器来说，这是一个问题——大多数Web都是在Linux服务器上运行的，每个分配的线程默认保留8 MB的内存用于其堆栈。这可以（也应该）重新定义，但这会导致需要大量的内存来处理单个服务器的开销，即使将默认堆栈大小设置为1
    MB，我们也需要至少10 GB的内存来处理开销。
- en: 'This is an extreme example that''s unlikely to be a real issue for a couple
    of reasons: first, because you can dictate the maximum amount of resources available
    to each thread, and second, because you can just as easily load balance across
    a few servers and instances rather than add 10 GB to 80 GB of RAM.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极端的例子，由于几个原因，这不太可能成为一个真正的问题：首先，因为您可以规定每个线程可用的最大资源量，其次，因为您可以很容易地在几台服务器和实例之间进行负载平衡，而不是增加10
    GB到80 GB的RAM。
- en: Even in a threaded server environment, we're fundamentally bound to the issue
    that can lead to performance decreases (to the point of a crash).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在一个线程服务器环境中，我们基本上也受到可能导致性能下降（甚至崩溃）的问题的限制。
- en: 'First, let''s look at a server with connections bound to threads (as shown
    in the following diagram), and visualize how this can lead to logjams and, eventually,
    crashes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个连接绑定到线程的服务器（如下图所示），并想象一下这如何导致阻塞，最终导致崩溃：
- en: '![Using concurrency to attack C10K](img/00027.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![使用并发攻击C10K](img/00027.jpeg)'
- en: This is obviously what we want to avoid. Any I/O, network, or external process
    that can impose some slowdown can bring about that avalanche effect we talked
    about, such that our available threads are taken (or backlogged) and incoming
    requests begin to stack up.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是我们要避免的。任何I/O、网络或外部进程都可能导致一些减速，从而引发我们所说的雪崩效应，使我们可用的线程被占用（或积压），而传入的请求开始堆积起来。
- en: We can spawn more threads in this model, but as mentioned earlier, there are
    potential risks there too, and even this will fail to mitigate the underlying
    problem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模型中，我们可以生成更多的线程，但正如前面提到的，这里也存在潜在的风险，甚至这也无法减轻潜在的问题。
- en: Taking another approach
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采取另一种方法
- en: In an attempt to create our web server that can handle 10,000 concurrent connections,
    we'll obviously leverage our goroutine/channel mechanism to put an event loop
    in front of our content delivery to keep new channels recycled or created constantly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可以处理10,000个并发连接的网络服务器，我们显然会利用我们的goroutine/channel机制，将一个事件循环放在我们的内容交付前面，以保持新通道不断回收或创建。
- en: For this example, we'll assume we're building a corporate website and infrastructure
    for a rapidly expanding company. To do this, we'll need to be able to serve both
    static and dynamic content.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设我们正在为一个快速扩张的公司构建企业网站和基础设施。为了做到这一点，我们需要能够提供静态和动态内容。
- en: The reason we want to introduce dynamic content is not just for the purposes
    of demonstration—we want to challenge ourselves to show 10,000 true concurrent
    connections even when a secondary process gets in the way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望引入动态内容的原因不仅仅是为了演示的目的——我们想挑战自己，展示即使在次要进程干扰的情况下，也能展示10,000个真正的并发连接。
- en: As always, we'll attempt to map our concurrency strategy directly to goroutines
    and channels. In a lot of other languages and applications, this is directly analogous
    to an event loop, and we'll approach it as such. Within our loop, we'll manage
    the available goroutines, expire or reuse completed ones, and spawn new ones where
    necessary.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们将尝试将我们的并发策略直接映射到goroutines和通道。在许多其他语言和应用程序中，这与事件循环直接类似，我们将以此方式处理。在我们的循环中，我们将管理可用的goroutines，过期或重用已完成的goroutines，并在必要时生成新的goroutines。
- en: 'In this example visualization, we show how an event loop (and corresponding
    goroutines) can allow us to scale our connections without employing too many *hard*
    resources such as CPU threads or RAM:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例可视化中，我们展示了一个事件循环（和相应的goroutines）如何使我们能够扩展我们的连接，而不需要使用太多*硬*资源，比如CPU线程或RAM：
- en: '![Taking another approach](img/00028.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![采取另一种方法](img/00028.jpeg)'
- en: The most important step for us here is to manage that event loop. We'll want
    to create an open, infinite loop to manage the creation and expiration of our
    goroutines and respective channels.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，这里最重要的一步是管理事件循环。我们希望创建一个开放的、无限循环来管理我们的goroutines和各自的通道的创建和过期。
- en: As part of this, we will also want to do some internal logging of what's happening,
    both for benchmarking and debugging our application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一过程的一部分，我们还希望对所发生的情况进行一些内部记录，既用于基准测试，也用于调试我们的应用程序。
- en: Building our C10K web server
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的C10K网络服务器
- en: Our web server will be responsible for taking requests, routing them, and serving
    either flat files or dynamic files with templates parsed against a few different
    data sources.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络服务器将负责处理请求，路由它们，并提供平面文件或针对几种不同数据源解析模板的动态文件。
- en: As mentioned earlier, if we exclusively serve flat files and remove much of
    the processing and network latency, we'd have a much easier time with handling
    10,000 concurrent connections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，如果我们只提供平面文件并消除大部分处理和网络延迟，那么处理10,000个并发连接将会更容易。
- en: Our goal is to approach as much of a real-world scenario as we can—very little
    of the Web operates on a single server in a static fashion. Most websites and
    applications utilize databases, **CDNs** (**Content Delivery Networks**), dynamic
    and uncached template parsing, and so on. We need to replicate them whenever possible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是尽可能接近真实世界的情景——很少有网站在一个静态的服务器上运行。大多数网站和应用程序都利用数据库、CDN（内容交付网络）、动态和未缓存的模板解析等。我们需要尽可能地复制它们。
- en: 'For the sake of simplicity, we''ll separate our content by type and filter
    them through URL routing, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将按类型分隔我们的内容，并通过URL路由进行过滤，如下所示：
- en: '`/static/[request]`: This will serve `request.html` directly'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/static/[request]`：这将直接提供`request.html`'
- en: '`/template/[request]`: This will serve `request.tpl` after its been parsed
    through Go'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/template/[request]`：这将在通过Go解析后提供`request.tpl`'
- en: '`/dynamic/[request][number]`: This will also serve `request.tpl` and parse
    it against a database source''s record'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dynamic/[request][number]`：这也将提供`request.tpl`并对其进行数据库源记录的解析'
- en: By doing this, we should get a better mixture of possible HTTP request types
    that could impede the ability to serve large numbers of users simultaneously,
    especially in a blocking web server environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们应该能够更好地混合可能阻碍大量用户同时服务能力的HTTP请求类型，特别是在阻塞的Web服务器环境中。
- en: We'll utilize the `html/template` package to do parsing—we've briefly looked
    at the syntax before, and going any deeper is not necessarily part of the goals
    of this book. However, you should look into it if you're going to parlay this
    example into something you use in your environment or have any interest in building
    a framework.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用`html/template`包进行解析——我们之前简要地看过语法，深入了解并不一定是本书的目标。但是，如果您打算将这个示例转化为您在环境中使用的内容，或者对构建框架感兴趣，您应该研究一下。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find Go's exceptional library to generate safe data-driven templating
    at [http://golang.org/pkg/html/template/](http://golang.org/pkg/html/template/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://golang.org/pkg/html/template/](http://golang.org/pkg/html/template/)找到Go出色的库，用于生成安全的数据驱动模板。
- en: By safe, we're largely referring to the ability to accept data and move it directly
    into templates without worrying about the sort of injection issues that are behind
    a large amount of malware and cross-site scripting.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓安全，我们主要是指接受数据并将其直接移入模板，而不必担心大量恶意软件和跨站脚本背后的注入问题。
- en: For the database source, we'll use MySQL here, but feel free to experiment with
    other databases if you're more comfortable with them. Like the `html/template`
    package, we're not going to put a lot of time into outlining MySQL and/or its
    variants.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库源，我们将在这里使用MySQL，但如果您更熟悉其他数据库，可以随意尝试。与`html/template`包一样，我们不打算花费太多时间来概述MySQL和/或其变体。
- en: Benchmarking against a blocking web server
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 针对阻塞Web服务器的基准测试
- en: It's only fair to add some starting benchmarks against a blocking web server
    first so that we can measure the effect of concurrent versus nonconcurrent architecture.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，公平地对阻塞Web服务器进行一些起始基准测试，以便我们可以衡量并发与非并发架构的影响。
- en: For our starting benchmarks, we'll eschew any framework, and we'll go with our
    old stalwart, Apache.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的起始基准测试，我们将放弃任何框架，而选择我们的老朋友Apache。
- en: For the sake of completeness here, we'll be using an Intel i5 3GHz machine with
    8 GB of RAM. While we'll benchmark our final product on Ubuntu, Windows, and OS
    X here, we'll focus on Ubuntu for our example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们将使用一台Intel i5 3GHz的机器，配备8GB的RAM。虽然我们将在Ubuntu、Windows和OS X上对我们的最终产品进行基准测试，但我们将以Ubuntu为例。
- en: Our localhost domain will have three plain HTML files in `/static`, each trimmed
    to 80 KB. As we're not using a framework, we don't need to worry about raw dynamic
    requests, but only about static and dynamic requests in addition to data source
    requests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的本地域将在`/static`中有三个普通的HTML文件，每个文件都被裁剪为80KB。由于我们不使用框架，我们不需要担心原始动态请求，而只需要关注静态和动态请求，以及数据源请求。
- en: 'For all examples, we''ll use a MySQL database (named `master`) with a table
    called `articles` that will contain 10,000 duplicate entries. Our structure is
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有示例，我们将使用一个名为`master`的MySQL数据库，其中包含一个名为`articles`的表，其中将包含10,000个重复条目。我们的结构如下：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With ID indexes ranging sequentially from 0-10,000, we'll be able to generate
    random number requests, but for now, we just want to see what kind of basic response
    we can get out of Apache serving static pages with this machine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过顺序范围从0到10,000的ID索引，我们将能够生成随机数请求，但目前，我们只想看看Apache在这台机器上提供静态页面时能得到什么样的基本响应。
- en: For this test, we'll use Apache's ab tool and then gnuplot to sequentially map
    the request time as the number of concurrent requests and pages; we'll do this
    for our final product as well, but we'll also go through a few other benchmarking
    tools for it to get some better details.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测试，我们将使用Apache的ab工具，然后使用gnuplot来顺序映射请求时间作为并发请求和页面的数量；我们也将为我们的最终产品做同样的测试，但我们还将使用一些其他基准测试工具来获得更好的细节。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apache's AB comes with the Apache web server itself. You can read more about
    it at [http://httpd.apache.org/docs/2.2/programs/ab.html](http://httpd.apache.org/docs/2.2/programs/ab.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Apache的AB随Apache Web服务器本身提供。您可以在[http://httpd.apache.org/docs/2.2/programs/ab.html](http://httpd.apache.org/docs/2.2/programs/ab.html)了解更多信息。
- en: You can download it for Linux, Windows, OS X, and more from [http://httpd.apache.org/download.cgi](http://httpd.apache.org/download.cgi).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://httpd.apache.org/download.cgi](http://httpd.apache.org/download.cgi)下载它的Linux、Windows、OS
    X等版本。
- en: The gnuplot utility is available for the same operating systems at [http://www.gnuplot.info/](http://www.gnuplot.info/).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: gnuplot实用程序也适用于相同的操作系统，网址是[http://www.gnuplot.info/](http://www.gnuplot.info/)。
- en: 'So, let''s see how we did it. Have a look at the following graph:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们看看我们是如何做到的。看一下下面的图表：
- en: '![Benchmarking against a blocking web server](img/00029.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![针对阻塞Web服务器的基准测试](img/00029.jpeg)'
- en: Ouch! Not even close. There are things we can do to tune the connections available
    (and respective threads/workers) within Apache, but this is not really our goal.
    Mostly, we want to know what happens with an out-of-the-box Apache server. In
    these benchmarks, we start to drop or refuse connections at around 800 concurrent
    connections.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！差距太大了。我们可以调整Apache中可用的连接（以及相应的线程/工作者），但这并不是我们的目标。大多数情况下，我们想知道开箱即用的Apache服务器会发生什么。在这些基准测试中，我们开始在大约800个并发连接时丢弃或拒绝连接。
- en: More troubling is that as these requests start stacking up, we see some that
    exceed 20 seconds or more. When this happens in a blocking server, each request
    behind it is queued; requests behind that are similarly queued and the entire
    thing starts to fall apart.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人担忧的是，随着这些请求开始堆积，我们看到一些请求超过20秒甚至更长时间。当这种情况发生在阻塞服务器中时，每个请求都会排队；在其后排队的请求也会类似地排队，整个系统开始崩溃。
- en: Even if we cannot hit 10,000 concurrent connections, there's a lot of room for
    improvement. While a single server of any capacity is no longer the way we expect
    a web server environment to be designed, being able to squeeze as much performance
    as possible out of that server, ostensibly with our concurrent, event-driven approach,
    should be our goal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们无法处理10,000个并发连接，仍然有很大的改进空间。虽然单个服务器的容量不再是我们期望设计为Web服务器环境的方式，但能够尽可能地从该服务器中挤取性能，基本上是我们并发、事件驱动方法的目标。
- en: Handling requests
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理请求
- en: In an earlier chapter, we handled URL routing with Gorilla, a compact but feature-full
    framework. The Gorilla toolkit certainly makes this easier, but we should also
    know how to intercept the functionality to impose our own custom handler.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的章节中，我们使用Gorilla处理URL路由，这是一个紧凑但功能丰富的框架。Gorilla工具包确实使这变得更容易，但我们也应该知道如何拦截功能以强加我们自己的自定义处理程序。
- en: 'Here is a simple web router wherein we handle and direct requests using a custom
    `http.Server` struct, as shown in the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Web路由器，我们在其中使用自定义的`http.Server`结构处理和指导请求，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, instead of using a built-in URL routing muxer and dispatcher, we're creating
    a custom server and custom handler type to accept URLs and route requests. This
    allows us to be a little more robust with our URL handling.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是使用内置的URL路由muxer和分发器，而是创建了一个自定义服务器和自定义处理程序类型来接受URL并路由请求。这使我们在处理URL时更加强大。
- en: In this case, we created a basic, empty struct called `customRouter` and passed
    it to our custom server creation call.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个名为`customRouter`的基本空结构，并将其传递给我们的自定义服务器创建调用。
- en: 'We can add more elements to our `customRouter` type, but we really don''t need
    to for this simple example. All we need to do is to be able to access the URLs
    and pass them along to a handler function. We''ll have three: one for static content,
    one for dynamic content, and one for dynamic content from a database.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的`customRouter`类型添加更多元素，但是对于这个简单的示例，我们实际上不需要这样做。我们所需要做的就是能够访问URL并将它们传递给处理程序函数。我们将有三个：一个用于静态内容，一个用于动态内容，一个用于来自数据库的动态内容。
- en: Before we go so far though, we should probably see what our absolute barebones
    HTTP server written in Go does when presented with the same traffic that we sent
    Apache's way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们走得太远之前，我们应该看看我们用Go编写的绝对基本的HTTP服务器在面对我们向Apache发送的相同流量时会做些什么。
- en: By old school, we mean that the server will simply accept a request and pass
    along a static, flat file. You could do this using a custom router as we did earlier,
    taking requests, opening files, and then serving them, but Go provides a much
    simpler mode to handle this basic task in the `http.FileServer` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 老派的意思是服务器只会接受请求并传递静态的平面文件。您可以使用自定义路由器来做到这一点，就像我们之前做的那样，接受请求，打开文件，然后提供它们，但是Go提供了一种更简单的方式来处理`http.FileServer`方法中的基本任务。
- en: So, to get some benchmarks for the most basic of Go servers against Apache,
    we'll utilize a simple FileServer and test it against a `test.html` page (which
    contains the same 80 KB file that we had with Apache).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了获得Go服务器的最基本性能与Apache的基准，我们将利用一个简单的FileServer，并将其与`test.html`页面进行测试（其中包含与Apache相同的80
    KB文件）。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As our goal with this test is to improve our performance in serving flat and
    dynamic pages, the actual specs for the test suite are somewhat immaterial. We'd
    expect that while the metrics will not match from environment to environment,
    we should see a similar trajectory. That said, it's only fair we supply the environment
    used for these tests; in this case, we used a MacBook Air with a 1.4 GHz i5 processor
    and 4 GB of memory.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是提高提供平面和动态页面的性能，因此测试套件的实际规格有些不重要。我们期望，尽管度量标准在不同环境中不会匹配，但我们应该看到类似的轨迹。也就是说，我们应该提供这些测试所使用的环境；在这种情况下，我们使用了一台配备1.4
    GHz i5处理器和4 GB内存的MacBook Air。
- en: First, we'll do this with our absolute best performance out of the box with
    Apache, which had 850 concurrent connections and 900 total requests.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用Apache的最佳性能，它具有850个并发连接和900个总请求。
- en: '![Handling requests](img/00030.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![处理请求](img/00030.jpeg)'
- en: The results are certainly encouraging as compared to Apache. Neither of our
    test systems were tweaked much (Apache as installed and basic FileServer in Go),
    but Go's FileServer handles 1,000 concurrent connections without so much as a
    blip, with the slowest clocking in at 411 ms.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与Apache相比，结果确实令人鼓舞。我们的两个测试系统都没有进行太多调整（Apache安装和Go中的基本FileServer），但Go的FileServer可以处理1,000个并发连接，而没有任何问题，最慢的时钟速度为411毫秒。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Apache has made a great number of strides pertaining to concurrency and performance
    options in the last five years, but to get there does require a bit of tuning
    and testing. The intent of this experiment is not intended to denigrate Apache,
    which is well tested and established. Instead, it's to compare the out-of-the-box
    performance of the world's number 1 web server against what we can do with Go.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的五年中，Apache在并发性和性能选项方面取得了很大进展，但要达到这一点需要进行一些调整和测试。这个实验的目的并不是贬低经过充分测试和建立的世界第一Web服务器Apache，而是要将其与我们在Go中所能做的进行比较。
- en: 'To really get a baseline of what we can achieve in Go, let''s see if Go''s
    FileServer can hit 10,000 connections on a single, modest machine out of the box:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正了解我们在Go中可以实现的基准，让我们看看Go的FileServer是否可以在单个普通机器上轻松处理10,000个连接：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will get the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Handling requests](img/00031.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![处理请求](img/00031.jpeg)'
- en: Success! Go's FileServer by itself will easily handle 10,000 concurrent connections,
    serving flat, static content.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！Go的FileServer本身将轻松处理10,000个并发连接，提供平面的静态内容。
- en: Of course, this is not the goal of this particular project—we'll be implementing
    real-world obstacles such as template parsing and database access, but this alone
    should show you the kind of starting point that Go provides for anyone who needs
    a responsive server that can handle a large quantity of basic web traffic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是这个特定项目的目标——我们将实现诸如模板解析和数据库访问等真实世界的障碍，但这本身就应该向您展示Go为需要处理大量基本网络流量的响应服务器提供的起点。
- en: Routing requests
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由请求
- en: So, let's take a step back and look again at routing our traffic through a traditional
    web server to include not only our static content, but also the dynamic content.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们退一步，再次看看如何通过传统的Web服务器路由我们的流量，不仅包括静态内容，还包括动态内容。
- en: 'We''ll want to create three functions that will route traffic from our `customRouter:serveStatic()::
    read` function and serve a flat file `serveRendered():`, parse a template to display
    `serveDynamic():`, connect to MySQL, apply data to a struct, and parse a template.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将创建三个函数，用于从我们的`customRouter:serveStatic():: read`函数中路由流量并提供一个平面文件`serveRendered():`，解析模板以显示`serveDynamic():`，连接到MySQL，将数据应用于结构，并解析模板。'
- en: To take our requests and reroute, we'll change the `ServeHTTP` method for our
    `customRouter` struct to handle three regular expressions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接受我们的请求并重新路由，我们将更改`customRouter`结构的`ServeHTTP`方法来处理三个正则表达式。
- en: For the sake of brevity and clarity, we'll only be returning data on our three
    possible requests. Anything else will be ignored.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁和清晰起见，我们只会返回我们三种可能请求的数据。其他任何内容都将被忽略。
- en: In a real-world scenario, we can take this approach to aggressively and proactively
    reject connections for requests we think are invalid. This would include spiders
    and nefarious bots and processes, which offer no real value as nonusers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的场景中，我们可以采取这种方法，积极主动地拒绝我们认为无效的请求连接。这将包括蜘蛛和恶意机器人和进程，它们作为非用户并没有真正价值。
- en: Serving pages
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供页面
- en: 'First up are our static pages. While we handled this the idiomatic way earlier,
    there exists the ability to rewrite our requests, better handle specific 404 error
    pages, and so on by using the `http.ServeFile` function, as shown in the following
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是我们的静态页面。虽然我们之前以成语方式处理了这个问题，但是使用`http.ServeFile`函数可以重写我们的请求，更好地处理特定的404错误页面等，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we simply relegate all requests starting with `/static/(.*)` to match
    the request in addition to the `.html` extension. In our case, we've named our
    test file (the 80 KB example file) `test.html`, so all requests to it will go
    to `/static/test`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需将所有以`/static/(.*)`开头的请求与`.html`扩展名匹配。在我们的情况下，我们已经将我们的测试文件（80 KB示例文件）命名为`test.html`，因此所有对它的请求将转到`/static/test`。
- en: We've prepended this with `staticPath`, a constant defined upcode. In our case,
    it's `/var/www/`, but you'll want to modify it as necessary.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这之前加上了`staticPath`，这是一个在代码中定义的常量。在我们的情况下，它是`/var/www/`，但您可能需要根据需要进行修改。
- en: 'So, let''s see what kind of overhead is imposed by introducing some regular
    expressions, as shown in the following graph:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看引入一些正则表达式所带来的开销，如下图所示：
- en: '![Serving pages](img/00032.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![提供页面](img/00032.jpeg)'
- en: How about that? Not only is there no overhead imposed, it appears that the FileServer
    functionality itself is heavier and slower than a distinct `FileServe()` call.
    Why is that? Among other reasons, not explicitly calling the file to open and
    serve imposes an additional OS call, one which can cascade as requests mount up
    at the expense of concurrency and performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样？不仅没有额外的开销，而且似乎`FileServer`功能本身比单独的`FileServe()`调用更重，更慢。为什么呢？除了其他原因，不显式调用文件以打开和提供会导致额外的操作系统调用，这可能会随着请求的增加而成倍增加，从而损害并发性能。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Sometimes it''s the little things**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**有时候是小事情**'
- en: 'Other than strictly serving flat pages here, we''re actually doing one other
    task per request using the following line of code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了严格地提供平面页面之外，我们实际上还在每个请求中执行另一个任务，使用以下代码行：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While this ultimately may have no impact on your final performance, we should
    take care to avoid unnecessary logging or related activities that may impart seemingly
    minimal performance obstacles that become much larger ones at scale.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这最终可能不会对您的最终性能产生影响，但我们应该注意避免不必要的日志记录或相关活动，这可能会给看似微不足道的性能障碍带来更大的问题。
- en: Parsing our template
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析我们的模板
- en: In our next phase, we'll measure the impact of reading and parsing a template.
    To effectively match the previous tests, we'll take our HTML static file and impose
    some variables on it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个阶段，我们将衡量读取和解析模板的影响。为了有效地匹配以前的测试，我们将采用我们的HTML静态文件，并对其施加一些变量。
- en: If you recall, our goal here is to mimic real-world scenarios as closely as
    possible. A real-world web server will certainly handle a lot of static file serving,
    but today, dynamic calls make up the vast bulk of web traffic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们的目标是尽可能模仿真实世界的场景。真实的Web服务器肯定会处理大量的静态文件服务，但是今天，动态调用构成了绝大部分的网络流量。
- en: 'Our data structure will resemble the simplest of data tables without having
    access to an actual database:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据结构将类似于最简单的数据表，而没有实际数据库的访问权限：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We'll want to take any data of this form and render a template with it. Remember
    that Go creates the notion of public or private variables through the syntactical
    sugar of capitalized (public) or lowercase (private) values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望采用这种形式的任何数据，并使用模板呈现它。请记住，Go通过大写（公共）或小写（私有）值的语法糖来创建公共或私有变量的概念。
- en: If you find that the template fails to render but you're not given explicit
    errors in the console, check your variable naming. A private value that is called
    from an HTML (or text) template will cause rendering to stop at that point.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现模板无法渲染，但控制台没有明确的错误提示，请检查您的变量命名。从HTML（或文本）模板调用的私有值将导致渲染在该点停止。
- en: 'Now, we''ll take that data and apply it to a template for any calls to a URL
    that begins with the `/(.*)` template. We could certainly do something more useful
    with the wildcard portion of that regular expression, so let''s make it part of
    the title using the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将获取这些数据，并将其应用于以`/(.*)`开头的URL的模板。我们可以确实使用正则表达式的通配部分做一些更有用的事情，所以让我们使用以下代码将其作为标题的一部分：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Hitting `localhost:9000/template/hello` should render a template with a primary
    body of the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`localhost:9000/template/hello`应该呈现一个主体为以下代码的模板：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will do this with the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![Parsing our template](img/00033.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![解析我们的模板](img/00033.jpeg)'
- en: One thing to note about templates is that they are not compiled; they remain
    dynamic. That is to say, if you create a renderable template and start your server,
    the template can be modified and the results are reflected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模板的一点需要注意的是，它们不是编译的；它们保持动态。也就是说，如果您创建了一个可渲染的模板并启动了服务器，那么模板可以被修改，结果会反映出来。
- en: 'This is noteworthy as a potential performance factor. Let''s run our benchmarks
    again, with template rendering as the added complexity to our application and
    its architecture:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个潜在的性能因素。让我们再次运行我们的基准测试，将模板渲染作为我们应用程序及其架构的附加复杂性：
- en: '![Parsing our template](img/00034.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![解析我们的模板](img/00034.jpeg)'
- en: Yikes! What happened? We've gone from easily hitting 10,000 concurrent requests
    to barely handling 200.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊！发生了什么？我们从轻松处理10,000个并发请求到几乎无法处理200个。
- en: To be fair, we introduced an intentional stumbling block, one not all that uncommon
    in the design of any given CMS.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，我们引入了一个故意设置的绊脚石，在任何给定CMS的设计中并不罕见。
- en: You'll notice that we're calling the `template.ParseFiles()` method on every
    request. This is the sort of seemingly cheap call that can really add up when
    you start stacking the requests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在每个请求上调用`template.ParseFiles（）`方法。这是一种看似廉价的调用，但当您开始堆叠请求时，它确实会增加起来。
- en: It may then make sense to move the file operations outside of the request handler,
    but we'll need to do more than that—to eliminate overhead and a blocking call,
    we need to set an internal cache for the requests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将文件操作移出请求处理程序可能是有意义的，但我们需要做的不仅仅是这些——为了消除开销和阻塞调用，我们需要为请求设置一个内部缓存。
- en: 'Most importantly, all of our template creation and parsing should happen outside
    the actual request handler if you want to keep your server non-blocking, fast,
    and responsive. Here''s another take:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，如果您希望保持服务器的非阻塞、快速和响应性，所有模板的创建和解析都应该发生在实际请求处理程序之外。这里是另一种方法：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even though we're using the `Parse()` function prior to our request, we can
    still modify our URL-specific variables using the `Execute()` method, which does
    not carry the same overhead as `Parse()`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在请求之前使用了`Parse（）`函数，但我们仍然可以使用`Execute（）`方法修改我们特定于URL的变量，这与`Parse（）`没有相同的开销。
- en: 'When we move this outside of the `customRouter` struct''s `ServeHTTP()` method,
    we''re back in business. This is the kind of response we''ll get with these changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这个移出`customRouter`结构的`ServeHTTP（）`方法时，我们又回到了正常状态。这是我们将会得到的这些更改的响应：
- en: '![Parsing our template](img/00035.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![解析我们的模板](img/00035.jpeg)'
- en: External dependencies
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部依赖
- en: Finally, we need to bring in our biggest potential bottleneck, which is the
    database. As mentioned earlier, we'll simulate random traffic by generating a
    random integer between 1 and 10,000 to specify the article we want.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要解决我们最大的潜在瓶颈，即数据库。正如前面提到的，我们将通过生成1到10,000之间的随机整数来模拟随机流量，以指定我们想要的文章。
- en: Randomization isn't just useful on the frontend—we'll want to work around any
    query caching within MySQL itself to limit nonserver optimizations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随机化不仅在前端有用——我们将要绕过MySQL内部的任何查询缓存，以限制非服务器优化。
- en: Connecting to MySQL
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到MySQL
- en: We can route our way through a custom connection to MySQL using native Go, but
    as is often the case, there are a few third-party packages that make this process
    far less painful. Given that the database here (and associated libraries) is tertiary
    to the primary exercise, we'll not be too concerned about the particulars here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过原生Go路由到自定义连接到MySQL，但通常情况下，有一些第三方包可以使这个过程变得不那么痛苦。鉴于这里的数据库（以及相关库）是主要练习的第三方，我们不会太关心这里的细节。
- en: 'The two mature MySQL driver libraries are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两个成熟的MySQL驱动程序库如下：
- en: '**Go-MySQL-Driver** ([https://github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql))'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go-MySQL-Driver（[https://github.com/go-sql-driver/mysql](https://github.com/go-sql-driver/mysql)）
- en: '**MyMySQL** ([https://github.com/ziutek/mymysql](https://github.com/ziutek/mymysql))'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MyMySQL**（[https://github.com/ziutek/mymysql](https://github.com/ziutek/mymysql)）'
- en: 'For this example, we''ll go with the Go-MySQL-Driver. We''ll quickly install
    it using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Go-MySQL-Driver。我们将使用以下命令快速安装它：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Both of these implement the core SQL database connectivity package in Go, which
    provides a standardized method to connect to a SQL source and iterate over rows.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都实现了Go中核心的SQL数据库连接包，提供了一种标准化的方法来连接到SQL源并遍历行。
- en: One caveat is if you've never used the SQL package in Go but have in other languages—typically,
    in other languages, the notion of an `Open()` method implies an open connection.
    In Go, this simply creates the struct and relevant implemented methods for a database.
    This means that simply calling `Open()` on `sql.database` may not give you relevant
    connection errors such as username/password issues and so on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一个注意事项是，如果你以前从未在Go中使用过SQL包，但在其他语言中使用过——通常在其他语言中，“Open（）”方法的概念意味着打开连接。在Go中，这只是为数据库创建结构和相关实现方法。这意味着仅仅在`sql.database`上调用`Open（）`可能不会给出相关的连接错误，比如用户名/密码问题等。
- en: One advantage of this (or disadvantage depending on your vantage point) is that
    connections to your database may not be left open between requests to your web
    server. The impact of opening and reopening connections is negligible in the grand
    scheme.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优势（或者根据您的观点而定的劣势）是，连接到数据库可能不会在向 Web 服务器发送请求之间保持打开状态。在整体方案中，打开和重新打开连接的影响微乎其微。
- en: 'As we''re utilizing a pseudo-random article request, we''ll build a MySQL piggyback
    function to get an article by ID, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用伪随机文章请求，我们将构建一个MySQL附属函数来通过ID获取文章，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will then call the function directly from our `ServeHTTP()` method, as shown
    in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将直接从我们的`ServeHTTP()`方法中调用该函数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'How did we do here? Take a look at the following graph:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做得怎么样？看一下下面的图表：
- en: '![Connecting to MySQL](img/00036.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![连接到MySQL](img/00036.jpeg)'
- en: Slower, no doubt, but we held up to all 10,000 concurrent requests, entirely
    from uncached MySQL calls.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，速度较慢，但我们成功承受了全部10,000个并发请求，完全来自未缓存的MySQL调用。
- en: Given that we couldn't hit 1,000 concurrent requests with a default installation
    of Apache, this is nothing to sneeze at.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们无法通过默认安装的Apache达到1,000个并发请求，这绝非易事。
- en: Multithreading and leveraging multiple cores
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程和利用多个核心
- en: You may be wondering how performance may vary when invoking additional processor
    cores—as mentioned earlier, this can sometimes have an unexpected effect.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道在调用额外的处理器核心时性能会如何变化——正如前面提到的，这有时会产生意想不到的效果。
- en: 'In this case, we should expect only improved performance in our dynamic requests
    and static requests. Any time the cost of context switching in the OS might outweigh
    the performance advantages of additional cores, we can see paradoxical performance
    degradation. In this case, we do not see this effect and instead see a relatively
    similar line, as shown in the following graph:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该期望我们的动态请求和静态请求的性能都会有所提高。任何时候，操作系统中的上下文切换成本可能会超过额外核心的性能优势，我们都会看到矛盾的性能下降。在这种情况下，我们没有看到这种效果，而是看到了一个相对类似的线，如下图所示：
- en: '![Multithreading and leveraging multiple cores](img/00037.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![多线程和利用多个核心](img/00037.jpeg)'
- en: Exploring our web server
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索我们的 Web 服务器
- en: Our final web server is capable of serving static, template-rendered, and dynamic
    content well within the confines of the goal of 10,000 concurrent connections
    on even the most modest of hardware.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终 Web 服务器能够在即使是最适度的硬件上，很好地处理静态、模板渲染和动态内容，符合10,000个并发连接的目标。
- en: 'The code—much like the code in this book—can be considered a jumping-off point
    and will need refinement if put into production. This server lacks anything in
    the form of error handling but can ably serve valid requests without any issue.
    Let''s take a look at the following server''s code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码——就像本书中的代码一样——可以被视为一个起点，如果投入生产，就需要进行改进。这个服务器缺乏任何形式的错误处理，但可以在没有任何问题的情况下有效地处理有效的请求。让我们看一下以下服务器的代码：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Most of our imports here are fairly standard, but note the MySQL line that
    is called solely for its side effects as a database/SQL driver:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的大部分导入都是相当标准的，但请注意MySQL行，它仅仅因为其副作用而被调用作为数据库/SQL驱动程序：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The relative `static/` path is where we''ll look for any file requests—as mentioned
    earlier, this does no additional error handling, but the `net/http` package itself
    will deliver 404 errors should a request to a nonexistent file hit it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 相对的`static/`路径是我们将查找任何文件请求的地方——正如前面提到的，这并不会进行额外的错误处理，但`net/http`包本身会在请求不存在的文件时返回404错误：
- en: '[PRE14]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our `WebPage` type represents the final output page before template rendering.
    It can be filled with static content or populated by data source, as shown in
    the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`WebPage`类型表示模板渲染之前的最终输出页面。它可以填充静态内容，也可以由数据源填充，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use these if you choose to extend the web app—this makes the code cleaner and
    removes a lot of the cruft in the `ServeHTTP` section, as shown in the following
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择扩展 Web 应用程序，请使用这些方法——这样可以使代码更清晰，并删除`ServeHTTP`部分中的大量不必要的内容，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All of our routing here is based on regular expression pattern matching. There
    are a lot of ways you can do this, but `regexp` gives us a lot of flexibility.
    The only time you may consider simplifying this is if you have so many potential
    patterns that it could cause a performance hit—and this means thousands. The popular
    web servers, Nginx and Apache, handle a lot of their configurable routing through
    regular expressions, so it''s fairly safe territory:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的路由都是基于正则表达式模式匹配的。有很多方法可以做到这一点，但`regexp`给了我们很大的灵活性。唯一需要考虑简化的时候是，如果您有很多潜在的模式，可能会导致性能损失——这意味着成千上万。流行的
    Web 服务器 Nginx 和 Apache 处理他们的可配置路由大部分都是通过正则表达式，所以这是相当安全的领域：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Go is notoriously cranky about unused variables, and while this isn't always
    the best practice, you will end up, at some point, with a function that does nothing
    specific with data but keeps the compiler happy. For production, this is not the
    way you'd want to handle such data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Go 对于未使用的变量非常挑剔，虽然这并不总是最佳实践，但在某些时候，您会得到一个不对数据进行特定处理但能让编译器满意的函数。对于生产环境，这并不是您想要处理此类数据的方式。
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our `getArticle` function demonstrates how you can interact with the `database/sql`
    package at a very basic level. Here, we open a connection and query a single row
    with the `QueryRow()` function. There also exists the `Query` command, which is
    also usually a `SELECT` command but one that could return more than a single row.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getArticle`函数演示了您如何在非常基本的级别上与`database/sql`包进行交互。在这里，我们打开一个连接，并使用`QueryRow()`函数查询一行。还有`Query`命令，通常也是一个`SELECT`命令，但可能返回多行。
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our main function sets up the server, builds a default `WebPage` and `customRouter`,
    and starts listening on port `9000`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主函数设置服务器，构建默认的`WebPage`和`customRouter`，并开始在端口`9000`上监听。
- en: Timing out and moving on
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超时并继续
- en: One thing we did not focus on in our server is the notion of lingering connection
    mitigation. The reason we didn't worry much about it is because we were able to
    hit 10,000 concurrent connections in all three approaches without too much issue,
    strictly by utilizing Go's powerful built-in concurrency features.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的服务器中，我们没有专注于持续连接的缓解概念。我们之所以不太担心它，是因为我们能够通过利用Go语言强大的内置并发特性，在所有三种方法中都能够轻松达到10,000个并发连接。
- en: Particularly when working with third-party or external applications and services,
    it's important to know that we can and should be prepared to call it quits on
    a connection (if our application design permits it).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在使用第三方或外部应用程序和服务时，重要的是要知道我们可以并且应该准备在连接中放弃（如果我们的应用程序设计允许的话）。
- en: 'Note the custom server implementation and two notes-specific properties: `ReadTimeout`
    and `WriteTimeout`. These allow us to handle this use case precisely.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意自定义服务器实现和两个特定属性：`ReadTimeout`和`WriteTimeout`。这使我们能够精确处理这种用例。
- en: 'In our example, this is set to an absurdly high 10 seconds. For a request to
    be received, processed, and sent, up to 20 seconds can transpire. This is an eternity
    in the Web world and has the potential to cripple our application. So, what does
    our C10K look like with 1 second on each end? Let''s take a look at the following
    graph:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，这被设置为一个荒谬地高的10秒。要接收、处理和发送一个请求，最多需要20秒的时间。在Web世界中，这是一个漫长的时间，有可能使我们的应用瘫痪。那么，我们的C10K在每端都设置为1秒会是什么样子呢？让我们看一下下面的图表：
- en: '![Timing out and moving on](img/00038.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![超时并继续前进](img/00038.jpeg)'
- en: Here, we've saved nearly 5 seconds off the tail end of our highest volume of
    concurrent requests, almost certainly at the expense of complete responses to
    each.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们几乎在最高并发请求的尾部节省了将近5秒的时间，几乎可以肯定是以完整响应为代价。
- en: It's up to you to decide how long it's acceptable to keep slow-running connections,
    but it's another tool in the arsenal to keep your server swift and responsive.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 决定保持运行缓慢连接的时间长度是由你来决定的，但这是保持服务器迅速响应的武器库中的另一个工具。
- en: There will always be a tradeoff when you decide to kill a connection—too early
    and you'll have a bevy of complaints about a nonresponsive or error-prone server;
    too late and you'll be unable to cope with the connection volume programmatically.
    This is one of those considerations that will require QA and hard data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定终止连接时，总会有一个权衡——太早会导致大量关于不响应或容易出错的服务器的投诉；太晚则无法以编程方式处理连接量。这是需要质量保证和硬数据的考虑之一。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The C10K problem may seem like a relic today, but the call to action was symptomatic
    of the type of approaches to systems' applications that were primarily employed
    prior to the rapid expansion of concurrent languages and application design.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C10K问题今天看起来可能已经过时了，但是呼吁行动是在并发语言和应用程序设计迅速扩展之前主要采用的系统应用的方法的症状。
- en: Just 15 years ago, this seemed a largely insurmountable problem facing systems
    and server developers worldwide; now, it's handled with only minor tweaking and
    consideration by a server designer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅15年前，这似乎是全球系统和服务器开发人员面临的一个几乎无法克服的问题；现在，通过对服务器设计进行轻微调整和考虑就能够解决。
- en: Go makes it easy to get there (with a little effort), but reaching 10,000 (or
    100,000 or even 1,000,000) concurrent connections is only half the battle. We
    must know what to do when problems arise, how to seek out maximum performance
    and responsiveness out of our servers, and how to structure our external dependencies
    such that they do not create roadblocks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言使得实现这一点变得容易（只需付出一点努力），但是达到10,000（甚至是100,000或1,000,000）并发连接只是一半的战斗。当问题出现时，我们必须知道该怎么做，如何在服务器中寻求最大性能和响应能力，并且如何构建我们的外部依赖，使其不会造成障碍。
- en: In our next chapter, we'll look at squeezing even more performance out of our
    concurrent applications by testing some distributed computing patterns and best
    utilizing memory management.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将通过测试一些分布式计算模式并最大限度地利用内存管理来进一步提高并发应用的性能。
