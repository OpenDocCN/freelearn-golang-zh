- en: Chapter 7. Performance and Scalability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。性能和可扩展性
- en: To build a high-powered web server in Go with just a few hundred lines of code,
    you should be quite aware of how concurrent Go provides us with exceptional tools
    for performance and stability out of the box.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几百行代码就可以在Go中构建一个高性能的Web服务器，您应该非常清楚，并发Go为我们提供了出色的性能和稳定性工具。
- en: Our example in [Chapter 6](part0054_split_000.html#page "Chapter 6. C10K – A
    Non-blocking Web Server in Go"), *C10K – A Non-blocking Web Server in Go*, also
    showed how imposing blocking code arbitrarily or inadvertently into our code can
    introduce some serious bottlenecks and quickly torpedo any plans to extend or
    scale your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第6章](part0054_split_000.html#page "Chapter 6. C10K – A Non-blocking Web
    Server in Go")中的示例，*C10K – A Non-blocking Web Server in Go*，也展示了如何在我们的代码中任意或无意地引入阻塞代码会引入严重的瓶颈，并迅速破坏扩展或扩展应用程序的计划。
- en: What we'll look at in this chapter are a few ways that can better prepare us
    to take our concurrent application and ensure that it's able to continuously scale
    in the future and that it is capable of being expanded in scope, design, and/or
    capacity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一些方法，可以更好地准备我们的并发应用程序，确保它能够持续扩展，并且能够在范围、设计和/或容量上进行扩展。
- en: We'll expand a bit on **pprof**, the CPU profiling tool we looked at briefly
    in previous chapters, as a way to elucidate the way our Go code is compiled and
    to locate possible unintended bottlenecks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地扩展**pprof**，这是我们在之前章节中简要介绍的CPU分析工具，作为阐明我们的Go代码是如何编译的，并找出可能的意外瓶颈的方法。
- en: Then we'll expand into distributed Go and into ways to offer some performance-enhancing
    parallel-computing concepts to our applications. We'll also look at the Google
    App Engine, and at how you can utilize it for your Go-based applications to ensure
    scalability is placed in the hands of one of the most reliable hosting infrastructures
    in the world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将扩展到分布式Go，以及提供一些性能增强的并行计算概念到我们的应用程序中的方法。我们还将看看谷歌应用引擎，以及如何利用它来确保您的基于Go的应用程序能够扩展到世界上最可靠的托管基础设施之一。
- en: Lastly, we'll look at memory utilization, preservation, and how Google's garbage
    collector works (and sometimes doesn't). We'll finally delve a bit deeper into
    using memory caching to keep data consistent as well as less ephemeral, and we
    will also see how that dovetails with distributed computing in general.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将研究内存利用、保留以及谷歌的垃圾收集器的工作方式（有时也会出现问题）。我们将深入研究如何使用内存缓存来保持数据一致性，以及如何与分布式计算结合，最终也会看到这与分布式计算的关系。
- en: High performance in Go
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go的高性能
- en: Up to this point, we've talked about some of the tools we can use to help discover
    slowdowns, leaks, and inefficient looping.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了一些工具，可以帮助我们发现减速、泄漏和低效的循环。
- en: Go's compiler and its built-in deadlock detector keep us from making the kind
    of mistake that's common and difficult to detect in other languages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go的编译器和内置的死锁检测器阻止了我们在其他语言中常见且难以检测的错误。
- en: We've run time-based benchmarks based on specific changes to our concurrency
    patterns, which can help us design our application using different methodologies
    to improve overall execution speed and performance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于特定并发模式的时间基准测试，可以帮助我们使用不同的方法设计我们的应用程序，以提高整体执行速度和性能。
- en: Getting deeper into pprof
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解pprof
- en: The pprof tool was first encountered in [Chapter 5](part0048_split_000.html#page
    "Chapter 5. Locks, Blocks, and Better Channels"), *Locks, Blocks, and Better Channels*,
    and if it still feels a bit cryptic, that's totally understandable. What pprof
    shows you in export is a **call graph**, and we can use this to help identify
    issues with loops or expensive calls on the heap. These include memory leaks and
    processor-intensive methods that can be optimized.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: pprof工具首次出现在[第5章](part0048_split_000.html#page "Chapter 5. Locks, Blocks, and
    Better Channels")中，*Locks, Blocks, and Better Channels*，如果它仍然感觉有点神秘，那是完全可以理解的。pprof向您显示的是一个**调用图**，我们可以使用它来帮助识别循环或堆上的昂贵调用的问题。这些包括内存泄漏和可以进行优化的处理器密集型方法。
- en: One of the best ways to demonstrate how something like this works is to build
    something that doesn't. Or at least something that doesn't work the way it should.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 展示这种工作原理的最好方法之一是构建一些不起作用的东西。或者至少是一些不按照应该的方式工作的东西。
- en: You might be thinking that a language with garbage collection might be immune
    to these kinds of memory issues, but there are always ways to hide mistakes that
    can lead to memory leakage. If the GC can't find it, it can sometimes be a real
    pain to do so yourself, leading to a lot of—often feckless—debugging.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为具有垃圾收集的语言可能对这些类型的内存问题免疫，但总是有方法可以隐藏导致内存泄漏的错误。如果GC找不到它，有时自己找到它可能会非常痛苦，导致大量——通常是无效的——调试。
- en: To be fair, what constitutes a memory leak is sometimes debated among computer
    science members and experts. A program that continuously consumes RAM may not
    be leaking memory by technical definition if the application itself could re-access
    any given pointers. But that's largely irrelevant when you have a program that
    crashes and burns after consuming memory like an elephant at a buffet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，什么构成内存泄漏有时在计算机科学成员和专家之间存在争议。如果程序不断消耗内存，根据技术定义，如果应用程序本身可以重新访问任何给定的指针，则可能不会泄漏内存。但当你有一个程序在消耗内存后崩溃时，这基本上是无关紧要的，就像大象在自助餐厅消耗内存一样。
- en: The basic premise of creating a memory leak in a garbage-collected language
    relies on hiding the allocation from the compiler—indeed, any language in which
    you can access and utilize memory directly provides a mechanism for introducing
    leaks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在垃圾收集的语言中创建内存泄漏的基本前提是隐藏分配的内存，事实上，在任何可以直接访问和利用内存的语言中，都提供了引入泄漏的机制。
- en: We'll review a bit more about garbage collection and Go's implementation later
    in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面再次回顾一些关于垃圾收集和Go实现的内容。
- en: So how does a tool like pprof help? Very simply put, by showing you **where**
    your memory and CPU utilization goes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么像pprof这样的工具如何帮助呢？非常简单地说，它向您展示了**您的内存和CPU利用情况**。
- en: 'Let''s first design a very obvious CPU hog as follows to see how pprof highlights
    this for us:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设计一个非常明显的CPU占用如下，看看pprof如何为我们突出显示这一点：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is shown in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下图所示：
- en: '![Getting deeper into pprof](img/00039.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![深入了解pprof](img/00039.jpeg)'
- en: In this case, we know where our stack resource allocation is going, because
    we willfully introduced the loop (and the loop within that loop).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们知道我们的堆栈资源分配去了哪里，因为我们故意引入了循环（以及其中的循环）。
- en: Imagine that we didn't intentionally do that and had to locate resource hogs.
    In this case, pprof makes this pretty easy, showing us the creation and memory
    allocation of simple strings comprising the majority of our samples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们并没有故意这样做，而是不得不找出资源占用。在这种情况下，pprof使这变得非常容易，向我们展示了创建和内存分配的简单字符串构成了我们大部分样本。
- en: We can modify this slightly to see the changes in the pprof output. In an effort
    to allocate more and more memory to see whether we can vary the pprof output,
    we might consider heavier types and more memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微修改一下，看看pprof输出的变化。为了分配更多的内存，看看我们是否可以改变pprof的输出，我们可能会考虑使用更重的类型和更多的内存。
- en: 'The easiest way to accomplish that is to create a slice of a new type that
    includes a significant amount of these heavier types such as int64\. We''re blessed
    with Go: in that, we aren''t prone to common C issues such as buffer overflows
    and memory protection and management, but this makes debugging a little trickier
    when we cannot intentionally break the memory management system.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个新类型的切片，其中包括大量这些较重的类型，如int64。我们很幸运有Go：在这方面，我们不容易出现常见的C问题，比如缓冲区溢出和内存保护和管理，但是当我们无法故意破坏内存管理系统时，调试就会变得有点棘手。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The unsafe package**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**unsafe包**'
- en: 'Despite the built-in memory protection provided, there is still another interesting
    tool provided by Go: the **unsafe** package. As per Go''s documentation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管提供了内置的内存保护，但Go还提供了另一个有趣的工具：**unsafe**包。根据Go的文档：
- en: '*Package unsafe contains operations that step around the type safety of Go
    programs.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*包unsafe包含绕过Go程序类型安全性的操作。*'
- en: This might seem like a curious library to include—indeed, while many low-level
    languages allow you to shoot your foot off, it's fairly unusual to provide a segregated
    language.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个奇怪的库要包括——确实，虽然许多低级语言允许您自毁，但提供一个分离的语言是相当不寻常的。
- en: Later in this chapter, we'll examine `unsafe.Pointer`, which allows you to read
    and write to arbitrary bits of memory allocation. This is obviously extraordinarily
    dangerous (or useful and nefarious, depending on your goal) functionality that
    you would generally try to avoid in any development language, but it does allow
    us to debug and understand our programs and the Go garbage collector a bit better.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将研究`unsafe.Pointer`，它允许您读写任意内存分配的位。这显然是非常危险的（或者有用和邪恶的，这取决于您的目标）功能，您通常会尽量避免在任何开发语言中使用，但它确实允许我们调试和更好地理解我们的程序和Go垃圾收集器。
- en: 'So to increase our memory usage, let''s switch our string allocation as follows,
    for random type allocation, specifically for our new struct `MemoryHog`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加我们的内存使用量，让我们将我们的字符串分配切换如下，用于随机类型分配，特别是用于我们的新结构`MemoryHog`：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's obviously nothing preventing us from extending this into some ludicrously
    large set of slices, huge arrays of int64s, and so on. But our primary goal is
    solely to change the output of pprof so that we can identify movement in the call
    graph's samples and its effect on our stack/heap profiles.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，没有什么能阻止我们将其扩展为一组荒谬地大的切片，大量的int64数组等等。但我们的主要目标仅仅是改变pprof的输出，以便我们可以识别调用图样本中的移动以及它对我们的堆栈/堆配置文件的影响。
- en: 'Our arbitrarily expensive code looks as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任意昂贵的代码如下：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this in place, our CPU consumption remains about the same (due to the looping
    mechanism remaining largely unchanged), but our memory allocation has increased—unsurprisingly—by
    about 900 percent. It's unlikely that you will precisely duplicate these results,
    but the general trend of a small change leading to a major difference in resource
    allocation is reproducible. Note that memory utilization reporting is possible
    with pprof, but it's not what we're doing here; the memory utilization observations
    here happened outside of pprof.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们的CPU消耗保持大致相同（由于循环机制基本保持不变），但我们的内存分配增加了——毫不奇怪——大约900%。你可能不会精确复制这些结果，但是一个小改变导致资源分配的重大差异的一般趋势是可以重现的。请注意，内存利用报告可以使用pprof进行，但这不是我们在这里所做的；这里的内存利用观察发生在pprof之外。
- en: 'If we took the extreme approach suggested previously—to create absurdly large
    properties for our struct—we could carry that out even further, but let''s see
    what the aggregate impact is on our CPU profile on execution. The impact is shown
    in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们采取之前建议的极端方法——为我们的结构创建荒谬地大的属性——我们可以进一步进行，但让我们看看这对我们的CPU配置文件执行的总体影响。影响如下图所示：
- en: '![Getting deeper into pprof](img/00040.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![深入了解pprof](img/00040.jpeg)'
- en: On the left-hand side, we have our new allocation approach, which invokes our
    larger struct instead of an array of strings. On the right-hand side, we have
    our initial application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有我们的新分配方法，它调用我们更大的结构，而不是一组字符串。在右侧，我们有我们的初始应用程序。
- en: A pretty dramatic flux, don't you think? While neither of these programs is
    wrong in design, we can easily toggle our methodologies to see where resources
    are going and discern how we can reduce their consumption.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 相当戏剧性的波动，你觉得呢？虽然这两个程序在设计上都没有错，但我们可以轻松地切换我们的方法，看看资源去哪里，以及我们如何减少它们的消耗。
- en: Parallelism's and concurrency's impact on I/O pprof
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行性和并发对I/O pprof的影响
- en: One issue you'll likely run into pretty quickly when using pprof is when you've
    written a script or application that is especially bound to efficient runtime
    performance. This happens most frequently when your program executes too quickly
    to properly profile.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用pprof时，您可能会很快遇到一个问题，那就是当您编写的脚本或应用程序特别依赖于高效的运行时性能时。当您的程序执行速度过快以至于无法正确进行性能分析时，这种情况最常见。
- en: A related issue involves network applications that require connections to profile;
    in this case, you can simulate traffic either in-program or externally to allow
    proper profiling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题涉及到需要连接进行性能分析的网络应用程序；在这种情况下，您可以在程序内部或外部模拟流量，以便进行正确的性能分析。
- en: 'We can demonstrate this easily by replicating something like the preceding
    example with goroutines as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用goroutines复制类似于前面示例的方式来轻松演示这一点：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following diagram shows the pprof output of the preceding code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了前面代码的pprof输出：
- en: '![Parallelism''s and concurrency''s impact on I/O pprof](img/00041.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![并行性和并发性对I/O pprof的影响](img/00041.jpeg)'
- en: It's not nearly as informative, is it?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是那么具有信息量，是吗？
- en: If we want to get something more valuable about the stack trace of our goroutines,
    Go—as usual—provides some additional functionality.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获得有关goroutines堆栈跟踪的更有价值的信息，Go——像往常一样——提供了一些额外的功能。
- en: 'In the runtime package, there is a function and a method that allow us to access
    and utilize the stack traces of our goroutines:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时包中，有一个函数和一个方法，允许我们访问和利用goroutines的堆栈跟踪：
- en: '`runtime.Lookup`: This function returns a profile based on name'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime.Lookup`：此函数根据名称返回一个性能分析'
- en: '`runtime.WriteTo`: This method sends the snapshot to the I/O writer'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runtime.WriteTo`：此方法将快照发送到I/O写入器'
- en: If we add the following line to our program, we won't see the output in the
    `pprof` Go tool, but we can get a detailed analysis of our goroutines in the console.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在程序中添加以下行，我们将无法在`pprof` Go工具中看到输出，但我们可以在控制台中获得对我们的goroutines的详细分析。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code line gives us some more of the abstract goroutine memory
    location information and package detail, which will look something like the following
    screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行代码给出了一些抽象goroutine内存位置信息和包细节，看起来会像下面的截图：
- en: '![Parallelism''s and concurrency''s impact on I/O pprof](img/00042.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![并行性和并发性对I/O pprof的影响](img/00042.jpeg)'
- en: 'But an even faster way to get this output is by utilizing the `http`/`pprof`
    tool, which keeps the results of our application active via a separate server.
    We''ve gone with port 6000 here as shown in the following code, though you can
    modify this as necessary:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但更快的获得这个输出的方法是利用`http`/`pprof`工具，它通过一个单独的服务器保持我们应用程序的结果处于活动状态。我们在这里使用了端口6000，如下面的代码所示，但您可以根据需要进行修改：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While you cannot get an SVG output of the goroutine stack call, you can see
    it live in your browser by going to `http://localhost:6060/debug/pprof/goroutine?debug=1`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您无法获得goroutine堆栈调用的SVG输出，但您可以通过访问`http://localhost:6060/debug/pprof/goroutine?debug=1`在浏览器中实时查看。
- en: Using the App Engine
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用App Engine
- en: While not right for every project, Google's App Engine can open up a world of
    scalability when it comes to concurrent applications, without the hassle of VM
    provisioning, reboots, monitoring, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非适用于每个项目，但Google的App Engine可以在并发应用程序方面提供可扩展性，而无需进行VM配置、重启、监控等繁琐操作。
- en: The App Engine is not entirely dissimilar to Amazon Web Services, DigitalOcean,
    and the ilk, except for the fact that you do not need to necessarily involve yourself
    in the minute details of direct server setup and maintenance. All of them provide
    a single spot to acquire and utilize virtual computing resources for your applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine与亚马逊网络服务、DigitalOcean等并没有完全不同，唯一的区别在于您不需要必须参与直接服务器设置和维护的细节。它们都提供了一个单一的地方来获取和利用虚拟计算资源来运行您的应用程序。
- en: Rather, it can be a more abstract environment within Google's architecture with
    which to house and run your code in a number of languages, including—no surprise
    here—the Go language itself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，它可以成为谷歌架构中更抽象的环境，用于在多种语言中托管和运行您的代码，包括——毫不奇怪的——Go语言本身。
- en: While large-scale apps will cost you, Google provides a free tier with reasonable
    quotas for experimentation and small applications.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大型应用程序将会产生费用，但Google提供了一个免费的层次，具有合理的试验和小型应用程序的配额。
- en: 'The benefits as they relate to scalability here are two-fold: you''re not responsible
    for ensuring uptime on the instances as you would be in an AWS or DigitalOcean
    scenario. Who else but Google will have not only the architecture to support anything
    you can throw at it, but also have the fastest updates to the Go core itself?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与可扩展性相关的好处有两个：您无需像在AWS或DigitalOcean场景中那样负责确保实例的正常运行时间。除了谷歌之外，还有谁不仅拥有支持任何你可以投入其中的架构，而且还拥有Go核心本身的最快更新速度？
- en: There are some obvious limitations here that coincide with the advantages, of
    course, including the fact that your core application will be available exclusively
    via `http` (although it will have access to plenty of other services).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里有一些明显的限制与优势相一致，包括您的核心应用程序将仅通过`http`可用（尽管它将可以访问到其他许多服务）。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: To deploy apps to the App Engine, you'll need the SDK for Go, available for
    Mac OS X, Linux, and Windows, at [https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Go](https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Go).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序部署到App Engine，您需要Go的SDK，适用于Mac OS X、Linux和Windows，网址为[https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Go](https://developers.google.com/appengine/downloads#Google_App_Engine_SDK_for_Go)。
- en: Once you've installed the SDK, the changes you'll need to make to your code
    are minor—the most noteworthy point is that for most cases, your Go tool command
    will be supplanted by `goapp`, which handles serving your application locally
    and then deploying it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了SDK后，您需要对代码进行一些微小的更改，最值得注意的一点是，在大多数情况下，您的Go工具命令将被`goapp`替代，它负责在本地提供您的应用程序，然后部署它。
- en: Distributed Go
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式Go
- en: We've certainly covered a lot about concurrent and parallel Go, but one of the
    biggest infrastructure challenges for developers and system architects today has
    to do with cooperative computing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实涵盖了很多关于并发和并行Go的内容，但对于开发人员和系统架构师来说，最大的基础设施挑战之一与协作计算有关。
- en: Some of the applications and designs that we've mentioned previously scale from
    parallelism to distributed computing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到的一些应用程序和设计从并行扩展到分布式计算。
- en: Memcache(d) is a form of in-memory caching, which can be used as a queue among
    several systems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Memcache(d)是一种内存缓存，可以用作多个系统之间的队列。
- en: Our master-slave and producer-consumer models we presented in [Chapter 4](part0040_split_000.html#page
    "Chapter 4. Data Integrity in an Application"), *Data Integrity in an Application*,
    have more to do with distributed computing than single-machine programming in
    Go, which manages concurrency idiomatically. These models are typical concurrency
    models in many languages, but can be scaled to help us design distributed systems
    as well, utilizing not just many cores and vast resources but also redundancy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](part0040_split_000.html#page "第4章。应用程序中的数据完整性")中提出的主从和生产者-消费者模型与Go中的单机编程相比更多地涉及分布式计算，后者在并发方面具有成语特色。这些模型是许多语言中典型的并发模型，但也可以扩展到帮助我们设计分布式系统，利用不仅是许多核心和丰富的资源，还有冗余。
- en: The basic premise of distributed computing is to share, spread, and best absorb
    the various burdens of any given application across many systems. This not only
    improves performance on aggregate, but provides some sense of redundancy for the
    system itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算的基本原则是将任何给定应用程序的各种负担分享、分散和最佳吸收到许多系统中。这不仅可以提高总体性能，还可以为系统本身提供一定程度的冗余。
- en: 'This all comes at some cost though, which are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是有一定成本的，具体如下：
- en: Potential for network latency
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络延迟的潜在可能性
- en: Creating slowdowns in communication and in application execution
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致通信和应用程序执行减速
- en: Overall increase in complexity both in design and in maintenance
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和维护上的复杂性整体增加
- en: Potential for security issues at various nodes along the distributed route(s)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式路线上各个节点存在安全问题的潜在可能性
- en: Possible added cost due to bandwidth considerations
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于带宽考虑可能增加成本
- en: This is all to say, simply, that while building a distributed system can provide
    great benefits to a large-scale application that utilizes concurrency and ensures
    data consistency, it's by no means right for every example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是为了简单地说，虽然构建分布式系统可以为利用并发性和确保数据一致性的大型应用程序提供巨大的好处，但这并不意味着它适用于每个示例。
- en: Types of topologies
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拓扑类型
- en: Distributed computing recognizes a slew of logical topologies for distributed
    design. Topology is an apt metaphor, because the positioning and logic of the
    systems involved can often represent physical topology.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式计算认识到分布式设计的一系列逻辑拓扑结构。拓扑结构是一个恰当的比喻，因为所涉及系统的位置和逻辑通常可以代表物理拓扑。
- en: Out of the box, not all of the accepted topologies apply to Go. When we design
    concurrent, distributed applications using Go, we'll generally rely on a few of
    the simpler designs, which are as follows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有被接受的拓扑结构都适用于Go。当我们使用Go设计并发分布式应用程序时，通常会依赖于一些更简单的设计，具体如下。
- en: Type 1 – star
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型1-星形
- en: The star topology (or at least this particular form of it), resembles our master-slave
    or producer-consumer models as outlined previously.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 星形拓扑结构（或至少是这种特定形式），类似于我们之前概述的主从或生产者-消费者模型。
- en: 'The primary method of data passing involves using the master as a message-passing
    conduit; in other words, all requests and commands are coordinated by a single
    instance, which uses some routing method to pass messages. The following diagram
    shows the star topology:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传递的主要方法涉及使用主服务器作为消息传递通道；换句话说，所有请求和命令都由单个实例协调，该实例使用某种路由方法传递消息。以下图显示了星形拓扑结构：
- en: '![Type 1 – star](img/00043.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![类型1-星形](img/00043.jpeg)'
- en: 'We can actually very quickly design a goroutine-based system for this. The
    following code is solely the master''s (or distributed destination''s) code and
    lacks any sort of security considerations, but shows how we can parlay network
    calls to goroutines:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以非常快速地为此设计一个基于goroutine的系统。以下代码仅为主服务器（或分布式目的地）的代码，缺乏任何安全考虑，但显示了我们如何将网络调用转换为goroutines：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our standard, basic libraries are defined as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的标准基本库定义如下：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These are the two custom types we''ll use here. A `Subscriber` type is any
    distributed helper that comes into the fray, and a `Task` type represents any
    given distributable task. We''ve left that undefined here because it''s not the
    primary goal of demonstration, but you could ostensibly have `Task` do anything
    by communicating standardized commands across the TCP connection. The `Subscriber`
    type is defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在这里使用的两种自定义类型。`Subscriber`类型是任何进入战场的分布式助手，`Task`类型代表任何给定的可分发任务。我们在这里没有定义它，因为这不是演示的主要目标，但你可以通过在TCP连接上通信标准化命令来做任何事情。`Subscriber`类型定义如下：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This essentially treats every connection as a new `Subscriber`, which gets
    its own channel based on its index. This master server then iterates through existing
    `Subscriber` connections using the following very basic round-robin approach:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这实质上将每个连接视为一个新的`Subscriber`，它根据其索引获得自己的通道。然后，主服务器使用以下非常基本的轮询方法迭代现有的`Subscriber`连接：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As mentioned previously, this lacks any sort of security model, which means
    that any connection to port 9000 would become a `Subscriber` and could get network
    messages assigned to it (and ostensibly could invoke new messages too). But you
    may have noticed an even bigger omission: this distributed application doesn''t
    do anything. Indeed, this is just a model for assignment and management of subscribers.
    Right now, it doesn''t have any path of action, but we''ll change that later in
    this chapter.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这缺乏任何安全模型，这意味着对端口9000的任何连接都将成为`Subscriber`，并且可以接收分配给它的网络消息（并且可能还可以调用新消息）。但您可能已经注意到一个更大的遗漏：这个分布式应用程序什么也没做。实际上，这只是一个用于分配和管理订阅者的模型。现在，它没有任何行动路径，但我们将在本章后面更改这一点。
- en: Type 2 – mesh
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型2-网格
- en: 'The mesh is very similar to the star with one major difference: each node is
    able to communicate not just through the master, but also directly with other
    nodes as well. This is also known as a **complete graph**. The following diagram
    shows a mesh topology:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 网格与星型非常相似，但有一个主要区别：每个节点不仅可以通过主节点进行通信，还可以直接与其他节点进行通信。这也被称为**完全图**。以下图显示了网格拓扑结构：
- en: '![Type 2 – mesh](img/00044.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![类型2-网格](img/00044.jpeg)'
- en: For practical purposes, the master must still handle assignments and pass connections
    back to the various nodes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 出于实际目的，主服务器仍然必须处理分配并将连接传递回各个节点。
- en: 'This is actually not particularly difficult to add through the following simple
    modification of our previous server code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，通过对我们之前的服务器代码进行以下简单修改，添加这个并不特别困难：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we add the following corresponding `broadcast` function to share all
    available connections to all other connections:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加以下对应的`broadcast`函数，将所有可用的连接共享给所有其他连接：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Publish and Subscribe model
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布和订阅模型
- en: In both the previous topologies, we've replicated a Publish and Subscribe model
    with a central/master handling delivery. Unlike in a single-system, concurrent
    pattern, we lack the ability to use channels directly across separate machines
    (unless we use something like Go's Circuit as described in [Chapter 4](part0040_split_000.html#page
    "Chapter 4. Data Integrity in an Application"), *Data Integrity in an Application*).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两种拓扑结构中，我们复制了一个由中央/主服务器处理交付的发布和订阅模型。与单系统并发模式不同，我们缺乏直接在不同计算机之间使用通道的能力（除非我们使用像Go的Circuit这样的东西，如[第4章](part0040_split_000.html#page
    "第4章。应用程序中的数据完整性")中所述的那样，*应用程序中的数据完整性*）。
- en: Without direct programmatic access to send and receive actual commands, we rely
    on some form of API. In the previous examples, there is no actual task being sent
    or executed, but how could we do this?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 没有直接的编程访问来发送和接收实际命令，我们依赖某种形式的API。在前面的例子中，没有实际发送或执行的任务，但我们该如何做呢？
- en: 'Obviously, to create tasks that can be formalized into non-code transmission,
    we''ll need a form of API. We can do this one of two ways: serialization of commands,
    ideally via JSONDirect transmission, and execution of code.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，要创建可以形式化为非代码传输的任务，我们需要一种API形式。我们可以通过两种方式之一来实现这一点：命令序列化，理想情况下通过JSON直接传输，以及代码执行。
- en: As we'll always be dealing with compiled code, the serialization of commands
    option might seem like you couldn't include Go code itself. This isn't exactly
    true, but passing full code in any language is fairly high on lists of security
    concerns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将始终处理编译后的代码，因此命令序列化选项可能看起来似乎无法包含Go代码本身。这并不完全正确，但是在任何语言中传递完整代码都是安全问题的重要问题。
- en: 'But let''s look at two ways of sending data via API in a task by removing a
    URL from a slice of URLs for retrieval. We''ll first need to initialize that array
    in our `main` function as shown in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看通过API以任务的方式发送数据的两种方法，即通过从URL切片中删除一个URL以进行检索。我们首先需要在我们的`main`函数中初始化该数组，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Every URL in our array will include the URI, its status, and the subscriber
    address to which it's been assigned. We'll formalize the status points as 0 for
    unassigned, 1 for assigned and waiting, and 2 for assigned and complete.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数组中的每个URL都将包括URI、其状态和分配给它的订阅者地址。我们将状态点规范为0表示未分配，1表示已分配并等待，2表示已分配并完成。
- en: Remember our `CurrentSubscriber` iterator? That represents the next-in-line
    round robin assignment which will fulfill the `SubscriberID` value for our `URL`
    struct.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们的`CurrentSubscriber`迭代器吗？它代表了下一个轮询分配，将为我们的`URL`结构的`SubscriberID`值提供值。
- en: 'Next, we''ll create an arbitrary array of URLs that will represent our overall
    job here. Some suspension of incredulity may be necessary to assume that the retrieval
    of four URLs should require any distributed system; in reality, this would introduce
    significant slowdown by virtue of network transmission. We''ve handled this in
    a purely single-system, concurrent application before:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个任意的URL数组，代表我们在这里的整体工作。可能需要一些怀疑来假设检索四个URL需要任何分布式系统；实际上，这将通过网络传输引入显著的减速。我们之前在纯粹的单系统并发应用程序中处理过这个问题：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Serialized data
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化数据
- en: 'In our first option in the API, we''ll send and receive serialized data in
    JSON. Our master will be responsible for formalizing its command and associated
    data. In this case, we''ll want to transmit a few things: what to do (in this
    case, retrieve) with the relevant data, what the response should be when it is
    complete, and how to address errors.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在API的第一个选项中，我们将以JSON格式发送和接收序列化数据。我们的主服务器将负责规范其命令和相关数据。在这种情况下，我们希望传输一些内容：要做什么（在这种情况下是检索）与相关数据，当完成时响应应该是什么，以及如何处理错误。
- en: 'We can represent this in a custom struct as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用自定义结构表示如下：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remote code execution
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程代码执行
- en: The remote code execution option is not necessarily separate from serialization
    of commands, but instead of structured and interpreted formatted responses, the
    payload could be code that will be run via a system command.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 远程代码执行选项并不一定与命令序列化分开，而是结构化和解释格式化响应的替代方案，有效载荷可以是将通过系统命令运行的代码。
- en: 'As an example, code from any language could be passed through the network and
    executed from a shell or from a syscall library in another language, like the
    following Python example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何语言的代码都可以通过网络传递，并且可以从另一种语言的shell或syscall库中执行，就像以下Python示例一样：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The disadvantages to this approach are many: it introduces serious security
    issues and makes error detection within your client nearly impossible.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点很多：它引入了严重的安全问题，并使您几乎无法在客户端内部进行错误检测。
- en: The advantages are you do not need to come up with a specific format and interpreter
    for responses as well as potential speed improvements. You can also offload the
    response code to another external process in any number of languages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是您不需要为响应制定特定的格式和解释器，以及潜在的速度改进。您还可以将响应代码卸载到任意数量的语言的另一个外部进程中。
- en: In most cases, serialization of commands is far preferable over the remote code
    execution option.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，命令的序列化远比远程代码执行选项更可取。
- en: Other topologies
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他拓扑
- en: There exist quite a few topology types that are more complicated to manage as
    part of a messaging queue.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多更复杂的拓扑类型，作为消息队列的一部分更难管理。
- en: 'The following diagram shows the bus topology:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了总线拓扑：
- en: '![Other topologies](img/00045.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![其他拓扑](img/00045.jpeg)'
- en: The bus topology network is a unidirectional transmission system. For our purposes,
    it's neither particularly useful nor easily managed, as each added node needs
    to announce its availability, accept listener responsibility, and be ready to
    cede that responsibility when a new node joins.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总线拓扑网络是一个单向传输系统。对于我们的目的来说，它既不特别有用，也不容易管理，因为每个添加的节点都需要宣布其可用性，接受监听器责任，并准备在新节点加入时放弃该责任。
- en: 'The advantage of a bus is quick scalability. This comes with serious disadvantages
    though: lack of redundancy and single point of failure.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 总线的优势在于快速扩展性。但是，这也带来了严重的缺点：缺乏冗余和单点故障。
- en: Even with a more complex topology, there will always be some issue with potentially
    losing a valuable cog in the system; at this level of modular redundancy, some
    additional steps will be necessary to have an always-available system, including
    automatic double or triple node replication and failovers. That's a bit more than
    we'll get into here, but it's important to note that the risk will be there in
    any event, although it would be a little more vulnerable with a topology like
    the bus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用更复杂的拓扑，系统中始终会存在一些可能丢失宝贵齿轮的问题；在这种模块化冗余级别上，将需要一些额外的步骤来实现始终可用的系统，包括自动双重或三重节点复制和故障转移。这比我们在这里讨论的要多一些，但重要的是要注意，无论如何都会存在风险，尽管在总线等拓扑中更容易受到影响。
- en: 'The following diagram shows the ring topology:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了环形拓扑：
- en: '![Other topologies](img/00046.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![其他拓扑](img/00046.jpeg)'
- en: 'The ring topology looks similar to our mesh topology, but lacks a master. It
    essentially requires the same communication process (announce and listen) as does
    a bus. Note one significant difference: instead of a single listener, communication
    can happen between any node without the master.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 环形拓扑看起来与我们的网状拓扑类似，但缺少主节点。它基本上需要与总线一样的通信过程（宣布和监听）。请注意一个重要的区别：通信不是在单个监听器之间进行，而是可以在没有主节点的情况下在任何节点之间进行。
- en: This simply means that all nodes must both listen and announce their presence
    to other nodes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有节点都必须同时监听并宣布它们的存在给其他节点。
- en: Message Passing Interface
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息传递接口
- en: There exists a slightly more formalized version of what we built previously,
    called Message Passing Interface. MPI was borne from early 1990s academia as a
    standard for distributed communication.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个稍微更正式的版本，称为消息传递接口，它是我们之前构建的更正式的版本。MPI是从上世纪90年代初的学术界诞生的，作为分布式通信的标准。
- en: Originally written with FORTRAN and C in mind, it is still a protocol, so it's
    largely language agnostic.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最初是为FORTRAN和C而编写的，它仍然是一个协议，因此它基本上与语言无关。
- en: MPI allows the management of topology above and beyond the basic topologies
    we were able to build for a resource management system, including not only the
    line and ring but also the common bus topology.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: MPI允许管理高于我们能够为资源管理系统构建的基本拓扑，包括不仅是线性和环形拓扑，还有常见的总线拓扑。
- en: For the most part, MPI is used by the scientific community; it is a highly concurrent
    and analogous method for building large-scale distributed systems. Point-to-point
    operations are more rigorously defined with error handling, retries, and dynamic
    spawning of processes all built in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，MPI被科学界使用；它是一种高度并发和类似的方法，用于构建大规模分布式系统。点对点操作更严格地定义了错误处理、重试和动态生成进程。
- en: Our previous basic examples lend no prioritization to processors, for example,
    and this is a core effect of MPI.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的基本示例没有为处理器设置优先级，这是MPI的核心效果之一。
- en: There is no official implementation of MPI for Go, but as there exists one for
    both C and C++, it's entirely possible to interface with it through that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Go没有官方的MPI实现，但由于C和C++都有官方实现，因此完全可以通过它们进行接口操作。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is also a simple and incomplete binding written in Go by Marcus Thierfelder
    that you can experiment with. It is available at [https://github.com/marcusthierfelder/mpi](https://github.com/marcusthierfelder/mpi).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个由Marcus Thierfelder用Go编写的简单而不完整的绑定，您可以进行实验。它可以在[https://github.com/marcusthierfelder/mpi](https://github.com/marcusthierfelder/mpi)上找到。
- en: You can read more about and install OpenMPI from [http://www.open-mpi.org/](http://www.open-mpi.org/).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.open-mpi.org/](http://www.open-mpi.org/)了解更多关于OpenMPI的信息并进行安装。
- en: Also you can read more about MPI and MPICH implementations at [http://www.mpich.org/](http://www.mpich.org/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[http://www.mpich.org/](http://www.mpich.org/)上阅读更多关于MPI和MPICH实现的信息。
- en: Some helpful libraries
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些有用的库
- en: There's little doubt that Go provides some of the best ancillary tools available
    to any compiled language out there. Compiling to native code on a myriad of systems,
    deadlock detection, pprof, fmt, and more allow you to not just build high-performance
    applications, but also test them and format them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Go语言提供了一些最好的辅助工具，适用于任何编译语言。在许多系统上编译成本地代码，死锁检测，pprof，fmt等工具不仅可以帮助你构建高性能的应用程序，还可以测试和格式化它们。
- en: This hasn't stopped the community from developing other tools that can be used
    for debugging or aiding your concurrent and/or distributed code. We'll take a
    look at a few great tools that may prove worthy of inclusion in your app, particularly
    if it's highly visible or performance critical.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有阻止社区开发其他工具，用于调试或帮助并发和/或分布式代码。我们将看看一些很棒的工具，可能值得包含在你的应用程序中，特别是如果它非常显眼或性能关键。
- en: Nitro profiler
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nitro性能分析器
- en: As you are probably now well aware, Go's pprof is extremely powerful and useful,
    if not exactly user-friendly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经很清楚，Go的pprof非常强大和有用，尽管不太用户友好。
- en: If you love pprof already, or even if you find it arduous and confusing, you
    may love Nitro profiler twice as much. Coming from Steve Francia of spf13, Nitro
    profiler allows you to produce even cleaner analyses of your application and its
    functions and steps, as well as providing more usable a/b tests of alternate functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经喜欢pprof，甚至如果你觉得它很繁琐和令人困惑，你可能会更喜欢Nitro性能分析器。来自spf13的Steve Francia，Nitro性能分析器可以让你更清晰地分析你的应用程序及其功能和步骤，同时提供更可用的备选功能的A/B测试。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Read more about Nitro profiler at [http://spf13.com/project/nitro](http://spf13.com/project/nitro).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://spf13.com/project/nitro](http://spf13.com/project/nitro)上阅读更多关于Nitro性能分析器的信息。
- en: You can get it via [github.com/spf13/nitro](http://github.com/spf13/nitro).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过[github.com/spf13/nitro](http://github.com/spf13/nitro)获取它。
- en: As with pprof, Nitro automatically injects flags into your application, and
    you'll see them in the results themselves.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与pprof一样，Nitro会自动将标志注入到你的应用程序中，并且你会在结果中看到它们。
- en: Unlike pprof, your application does not need to be compiled to get profile analysis
    from it. Instead, you can simply append `-stepAnalysis` to the `go run` command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与pprof不同，你的应用程序不需要编译就可以从中获取性能分析。相反，你只需在`go run`命令后附加`-stepAnalysis`。
- en: Heka
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Heka
- en: Heka is a data pipeline tool that can be used to gather, analyze, and distribute
    raw data. Available from Mozilla, Heka is more a standalone application rather
    than a library, but when it comes to acquiring, analyzing, and distributing data
    such as server logfiles across multiple servers, Heka can prove itself worthy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Heka是一个数据管道工具，可用于收集、分析和分发原始数据。Heka来自Mozilla，它更像是一个独立的应用程序，而不是一个库，但在获取、分析和分发诸如服务器日志文件之类的数据时，Heka可以证明自己是有价值的。
- en: Heka is also written in Go, so make sure to check out the source to see how
    Mozilla utilizes concurrency and Go in real-time data analysis.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Heka也是用Go语言编写的，所以一定要查看源代码，看看Mozilla如何在实时数据分析中利用并发和Go语言。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can visit the Heka home page at [http://heka-docs.readthedocs.org/en/latest/](http://heka-docs.readthedocs.org/en/latest/)
    and the Heka source page at [https://github.com/mozilla-services/heka](https://github.com/mozilla-services/heka).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问Heka主页[http://heka-docs.readthedocs.org/en/latest/](http://heka-docs.readthedocs.org/en/latest/)和Heka源页[https://github.com/mozilla-services/heka](https://github.com/mozilla-services/heka)。
- en: GoFlow
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GoFlow
- en: Finally, there's GoFlow, a flow-based programming paradigm tool that lets you
    segment your application into distinct components, each capable of being bound
    to ports, channels, the network, or processes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有GoFlow，这是一个基于流的编程范式工具，可以将你的应用程序分成不同的组件，每个组件都可以绑定到端口、通道、网络或进程。
- en: While not itself a performance tool, GoFlow might be an appropriate approach
    to extending concurrency for some applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GoFlow本身不是一个性能工具，但对于一些应用程序来说，GoFlow可能是扩展并发的合适方法。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Visit GoFlow at [https://github.com/trustmaster/goflow](https://github.com/trustmaster/goflow).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 访问GoFlow[https://github.com/trustmaster/goflow](https://github.com/trustmaster/goflow)。
- en: Memory preservation
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存保留
- en: At the time of this writing, Go 1.2.2's compiler utilizes a naive mark/sweep
    garbage collector, which assigns a reference rank to objects and clears them when
    they are no longer in use. This is noteworthy only to point out that it is widely
    considered a relatively poor garbage collection system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Go 1.2.2的编译器使用了一个天真的标记/清除垃圾收集器，它为对象分配引用等级，并在它们不再使用时清除它们。这值得注意的只是为了指出它被广泛认为是一个相对较差的垃圾收集系统。
- en: 'So why does Go use it? As Go has evolved; language features and compiler speed
    have largely taken precedence over garbage collection. While it''s a long-term
    development timeline for Go, for the time being, this is where we are. The tradeoff
    is a good one, though: as you well know by now, compiling Go code is light years
    faster than, say, compiling C or C++ code. Good enough for now is a fair description
    for the GC. But there are some things you can do to augment and experiment within
    the garbage collection system.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么Go要使用它呢？随着Go的发展，语言特性和编译速度在很大程度上优先于垃圾收集。虽然Go的长期发展时间轴，目前来看，这就是我们的现状。然而，这种权衡是很好的：正如你现在所知道的，编译Go代码比编译C或C++代码快得多。目前的垃圾收集系统已经足够好了。但你可以做一些事情来增强和实验垃圾收集系统。
- en: Garbage collection in Go
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go中的垃圾收集
- en: To get an idea of how the garbage collector is managing the stack at any time,
    take a look at the `runtime.MemProfileRecord` object, which keeps track of presently
    living objects in the active stack trace.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解垃圾收集器在任何时候如何管理堆栈，可以查看`runtime.MemProfileRecord`对象，它跟踪当前活动堆栈跟踪中的对象。
- en: 'You can call the profile record when necessary and then utilize it against
    the following methods to get a few interesting pieces of data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在必要时，你可以调用性能记录，然后利用它来获取一些有趣的数据：
- en: '`InUseBytes()`: This method has the bytes used presently as per the memory
    profile'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InUseBytes()`: 这个方法根据内存配置文件当前使用的字节数'
- en: '`InUseObjects()`:This method has the number of live objects in use'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InUseObjects()`:该方法返回正在使用的活动对象的数量'
- en: '`Stack()`: This method has the full stack trace'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stack()`:该方法返回完整的堆栈跟踪'
- en: 'You can place the following code in a heavy loop in your application to get
    a peek at all of these:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将以下代码放入应用程序的重循环中，以查看所有这些内容：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We can now build some pretty high-performance applications and then utilize
    some of Go's built-in tools and third-party packages to seek out the most performance
    in a single instance application as well as across multiple, distributed systems.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一些非常高性能的应用程序，然后利用一些Go内置工具和第三方包，以在单个实例应用程序以及跨多个分布式系统中寻求最佳性能。
- en: In the next chapter, we're going to wrap everything together to design and build
    a concurrent server application that can work quickly and independently, and easily
    scale in performance and scope.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把所有内容整合起来，设计并构建一个并发服务器应用程序，它可以快速独立地工作，并且可以轻松地在性能和范围上进行扩展。
