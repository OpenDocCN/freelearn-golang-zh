- en: Chapter 8. Concurrent Application Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。并发应用程序架构
- en: By now, we've designed small bits of concurrent programs, primarily in a single
    piece keeping concurrency largely isolated. What we haven't done yet is tie everything
    together to build something a little more robust, complex, and more daunting to
    manage from an administrator's perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设计了一些并发程序的小部分，主要是在一个单一的部分中保持并发性。但我们还没有把所有东西联系起来，构建出更强大、更复杂、从管理员的角度来看更具挑战性的东西。
- en: Simple chat applications and web servers are fine and dandy. However, you will
    eventually need more complexity and require external software to meet all of the
    more advanced requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的聊天应用程序和Web服务器都很好。然而，最终您将需要更多的复杂性，并需要外部软件来满足所有更高级的要求。
- en: 'In this case, we''ll build something that''s satisfied by a few dissonant services:
    a file manager with revision control that supplies web and shell access. Services
    such as Dropbox and Google Drive allow users to keep and share files among peers.
    On the other hand, GitHub and its ilk allow for a similar platform but with the
    critical added benefit of revision control.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将构建一些由几个不协调的服务满足的东西：一个带有修订控制的文件管理器，提供Web和Shell访问。像Dropbox和Google Drive这样的服务允许用户在同行之间保留和共享文件。另一方面，GitHub及其类似的服务允许使用类似的平台，但具有关键的修订控制的额外好处。
- en: 'Many organizations face problems with the following sharing and distribution
    options:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多组织面临以下共享和分发选项的问题：
- en: Limitations on repositories, storage, or number of files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对存储库、存储空间或文件数量的限制
- en: Potential inaccessibility if the services are down
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务中断，可能导致无法访问
- en: Security concerns, particularly for sensitive information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全问题，特别是涉及敏感信息
- en: Simple sharing applications such as Dropbox and Google Drive are great at storing
    data without a large amount of revision control options. GitHub is an excellent
    collaborative revision control and distribution system, but comes with many costs
    and the mistakes by developers can lead to large and potentially serious security
    lapses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的共享应用程序，如Dropbox和Google Drive，在没有大量修订控制选项的情况下存储数据。GitHub是一个出色的协作修订控制和分发系统，但伴随着许多成本，开发人员的错误可能导致严重的安全漏洞。
- en: We'll be combining the aims of version control (and the GitHub ideal) with Dropbox's
    / Google Drive's simplicity and openness. This type of application will be perfect
    as an intranet replacement—wholly isolated and accessible with custom authentication
    that doesn't necessarily rely on cloud services. The ability to keep it all in-house
    removes any potential for network security concerns and allows an administrator
    to design permanent backup solutions in a way that fits their organization.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结合版本控制的目标（以及GitHub的理想）与Dropbox/Google Drive的简单性和开放性。这种类型的应用程序将作为内部网络替代品非常完美——完全隔离并且可通过自定义身份验证访问，不一定依赖于云服务。将所有内容保留在内部消除了任何网络安全问题的潜在可能，并允许管理员设计符合其组织需求的永久备份解决方案。
- en: File sharing within the organization will allows forking, backups, file locking,
    and revision control all from the command line but also through a simple web interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 组织内的文件共享将允许从命令行进行分叉、备份、文件锁定和修订控制，同时也可以通过简单的Web界面进行。
- en: Designing our concurrent application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的并发应用程序
- en: 'When designing a concurrent application, we will have three components running
    in separate processes. A file listener will be alerted to make changes to files
    in specified locations. A web-CLI interface will allow users to augment or modify
    files, and a backup process will be bound to the listener to provide automated
    copies of new file changes. With that in mind, these three processes will look
    a bit like what is shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计并发应用程序时，我们将有三个在单独进程中运行的组件。文件监听器将被警报以对指定位置的文件进行更改。Web-CLI界面将允许用户增加或修改文件，并且备份过程将绑定到监听器，以提供新文件更改的自动副本。考虑到这一点，这三个过程将看起来有点像下图所示的样子：
- en: '![Designing our concurrent application](img/00047.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的并发应用程序](img/00047.jpeg)'
- en: 'Our file listener process will do the following three things:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件监听器进程将执行以下三项任务：
- en: Keep an eye on any file changes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密切关注任何文件更改
- en: Broadcast to our web/CLI servers and the backup process
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的Web/CLI服务器和备份过程进行广播
- en: Maintain the state of any given file in our database / data store
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护我们的数据库/数据存储中任何给定文件的状态
- en: The backup process will accept any broadcasts from the file listener (#2) and
    create a backup file in an iterative design.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 备份过程将接受文件监听器(#2)的任何广播，并以迭代设计创建备份文件。
- en: Our general server (web and CLI) will report details on individual files and
    allow versioning forward and backward with a customizable syntax. This part of
    the application will also have to broadcast back to the file listener when new
    files are committed or revisions are requested.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的通用服务器（Web和CLI）将报告有关个别文件的详细信息，并允许使用可定制的语法进行前后版本控制。该应用程序的这一部分还必须在提交新文件或请求修订时向文件监听器进行广播。
- en: Identifying our requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定我们的需求
- en: 'The most critical step in our architectural design process is really zooming
    in on the required features, packages, and technologies that we''ll need to implement.
    For our file management and revision control application, there are a few key
    points that will stand out:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的架构设计过程中最关键的一步是真正关注我们需要实现的功能、包和技术。对于我们的文件管理和修订控制应用程序，有一些关键点将突出显示：
- en: A web interface that allows file uploads, downloads, and revisions.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许文件上传、下载和修订的Web界面。
- en: A command-line interface that allows us to roll back changes and modify files
    directly.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们回滚更改并直接修改文件的命令行界面。
- en: A filesystem listener that finds changes made to a shared location.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文件系统监听器，用于查找对共享位置所做的更改。
- en: A data store system that has strong Go tie-in and allows us to maintain information
    about files and users in a mostly consistent manner. This system will also maintain
    user records.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有强大的Go关联性的数据存储系统，允许我们以基本一致的方式维护有关文件和用户的信息。该系统还将维护用户记录。
- en: A concurrent log system that maintains and cycles logs of changed files.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个维护和循环更改文件日志的并发日志系统。
- en: 'We''re somewhat complicating things by allowing the following three different
    ways to interface with the overall application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许以下三种不同的方式与整个应用程序进行交互，这在某种程度上使事情变得复杂：
- en: Via the Web that requires a user and login. This also allows our users to access
    and modify files even if they happen to be somewhere not connected to the shared
    drive.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过需要用户和登录的Web。这也允许我们的用户访问和修改文件，即使他们可能在某个地方没有连接到共享驱动器。
- en: Via the command line. This is archaic but also extremely valuable anytime a
    user is traversing a filesystem, particularly power users not in a GUI.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过命令行。这是过时的，但对于用户遍历文件系统，特别是不在GUI中的高级用户来说，它也是非常有价值的。
- en: Via the filesystem that changes itself. This is the shared drive mechanism wherein
    we assume that any user with access to this will be making valid modifications
    to any files.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过自身改变的文件系统。这是共享驱动机制，我们假设任何有权访问的用户都将对任何文件进行有效修改。
- en: 'To handle all of this, we can identify a few critical technologies as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理所有这些，我们可以确定一些关键的技术如下：
- en: A database or data store to manage revisions to our filesystem. When choosing
    between transactional, ACID-compliant SQL and fast document stores in NoSQL, the
    tradeoff is often performance versus consistency. However, since most of our locking
    mechanism will exist in the application, duplicating locks (even at the row level)
    will add a level of potential slowness and cruft that we don't need. So, we will
    utilize a NoSQL solution.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于管理文件系统修订的数据库或数据存储。在选择事务性、ACID兼容的SQL和NoSQL中的快速文档存储时，权衡通常是性能与一致性之间的权衡。然而，由于我们的大部分锁定机制将存在于应用程序中，复制锁定（即使在行级别）将增加潜在的缓慢和不需要的混乱。因此，我们将利用NoSQL解决方案。
- en: This solution will need to play well with concurrency.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个解决方案需要很好地处理并发。
- en: We'll be using a web interface, one that brings in powerful and clean routing/muxing
    and plays well with Go's robust built-in templating system.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用一个Web界面，它引入了强大而干净的路由/多路复用，并与Go的强大内置模板系统很好地配合。
- en: A filesystem notification library that allows us to monitor changes to files
    as well as backing up revisions.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文件系统通知库，允许我们监视文件的更改以及备份修订。
- en: Any solutions we uncover or build to satisfy these requirements will need to
    be highly concurrent and non-blocking. We'll want to make sure that we do not
    allow simultaneous changes to files, including changes to our internal revisions
    themselves.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现或构建的任何解决方案都需要高度并发和非阻塞。我们要确保不允许对文件进行同时更改，包括对我们内部修订的更改。
- en: With all of this in mind, let's identify our pieces one-by-one and decide how
    they will play in our application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，让我们逐个识别我们的部分，并决定它们在我们的应用程序中的作用。
- en: We'll also present a few alternatives with options that can be swapped without
    compromising the functionality or core requirements. This will allow some flexibility
    in cases where platform or preference makes our primary option unpalatable. Any
    time we're designing an application, it's a good idea to know what else is out
    there in case the software (or terms of its use) change or it is no longer satisfactory
    to use at a future scale.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提出一些备选方案，这些选项可以在不损害功能或核心要求的情况下进行交换。这将允许在平台或偏好使我们的主要选项不可取的情况下具有一定的灵活性。每当我们设计一个应用程序时，了解其他可能的选择是个好主意，以防软件（或其使用条款）发生变化，或者在未来的规模上不再满意使用。
- en: Let's start with our data store.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的数据存储开始。
- en: Using NoSQL as a data store in Go
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Go中使用NoSQL作为数据存储
- en: One of the biggest concessions with using NoSQL is, obviously, the lack of standardization
    when it comes to CRUD operations (create, read, update, and delete). SQL has been
    standardized since 1986 and is pretty airtight across a number of databases—from
    MySQL to SQL Server and from Microsoft and Oracle all the way down to PostgreSQL.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NoSQL的最大让步之一显然是在进行CRUD操作（创建、读取、更新和删除）时缺乏标准化。SQL自1986年以来一直是标准化的，并且在许多数据库中非常严密——从MySQL到SQL
    Server，从微软和甲骨文一直到PostgreSQL。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about NoSQL and various NoSQL platforms at [http://nosql-database.org/](http://nosql-database.org/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://nosql-database.org/](http://nosql-database.org/)上阅读更多关于NoSQL和各种NoSQL平台的信息。
- en: Martin Fowler has also written a popular introduction to the concept and some
    use cases in his book *NoSQL Distilled* at [http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler在他的书《NoSQL Distilled》中也写了一篇关于这个概念和一些用例的流行介绍，网址为[http://martinfowler.com/books/nosql.html](http://martinfowler.com/books/nosql.html)。
- en: Depending on the NoSQL platform, you can also lose ACID compliance and durability.
    This means that your data is not 100 percent secure—there can be transactional
    loss if a server crashes, if reads happen on outdated or non-existent data, and
    so on. The latter of which is known as a dirty read.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据NoSQL平台的不同，您还可能失去ACID兼容性和耐久性。这意味着您的数据不是100%安全——如果服务器崩溃，如果读取过时或不存在的数据等，可能会有事务丢失。后者被称为脏读。
- en: This is all noteworthy as it applies to our application and with concurrency
    specifically because we've talked about one of those big potential third-party
    bottlenecks in the previous chapters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都值得注意，因为它适用于我们的应用程序，特别是在并发性方面，因为我们在前几章中已经谈到了其中一个潜在的第三方瓶颈。
- en: For our file-sharing application in Go, we will utilize NoSQL to store metadata
    about files as well as the users that modify/interact with those files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在Go中的文件共享应用程序，我们将利用NoSQL来存储有关文件的元数据以及修改/交互这些文件的用户。
- en: We have quite a few options when it comes to a NoSQL data store to use here,
    and almost all of the big ones have a library or interface in Go. While we're
    going to go with Couchbase here, we'll briefly talk about some of the other big
    players in the game as well as the merits of each.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择NoSQL数据存储时，我们有很多选择，几乎所有主要的数据存储都在Go中有库或接口。虽然我们在这里选择了Couchbase，但我们也会简要讨论一些其他主要的竞争对手以及每个的优点。
- en: The code snippets in the following sections should also give you some idea of
    how to switch out Couchbase for any of the others without too much angst. While
    we don't go deeply into any of them, the code for maintaining the file and modifying
    information will be as generic as possible to ensure easy exchange.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节中的代码片段也应该让你对如何在不太焦虑的情况下将Couchbase替换为其他任何一个有一些想法。虽然我们不会深入研究其中任何一个，但为了确保易于交换，用于维护文件和修改信息的代码将尽可能通用。
- en: MongoDB
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: MongoDB is one of the most popular NoSQL platforms available. Written in 2009,
    it's also one of the most mature platforms, but comes with a number of tradeoffs
    that have pushed it somewhat out of favor in the recent years.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是最受欢迎的NoSQL平台之一。它是在2009年编写的，也是最成熟的平台之一，但也带来了一些权衡，这使得它在近年来有些失宠。
- en: Even so, Mongo does what it does in a reliable fashion and with a great deal
    of speed. Utilizing indices, as is the case with most databases and data stores,
    improves query speed on reads greatly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，Mongo以可靠的方式完成了它的任务，并且速度非常快。使用索引，就像大多数数据库和数据存储一样，极大地提高了读取的查询速度。
- en: Mongo also allows for some very granular control of guarantees as they apply
    to reads, writes, and consistency. You can think of this as a very vague analog
    to any language and/or engine that supports syntactical dirty reads.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo还允许对读取、写入和一致性的保证进行非常精细的控制。你可以将其视为对支持语法脏读的任何语言和/或引擎的非常模糊的类比。
- en: Most importantly, Mongo supports concurrency easily within Go and is implicitly
    designed to work in distributed systems.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，Mongo在Go中很容易支持并发，并且隐式地设计用于分布式系统。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The biggest Go interface for Mongo is `mgo`, which is available at: [http://godoc.org/labix.org/v2/mgo](http://godoc.org/labix.org/v2/mgo).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo的最大Go接口是`mgo`，可以在以下网址找到：[http://godoc.org/labix.org/v2/mgo](http://godoc.org/labix.org/v2/mgo)。
- en: 'Should you wish to experiment with Mongo in Go, it''s a relatively straightforward
    process to take your data store record and inject it into a custom struct. The
    following is a quick and dirty example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Go中尝试Mongo，将数据存储记录注入自定义结构是一个相对简单的过程。以下是一个快速而简单的例子：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One downside to Mongo compared to other NoSQL solutions is that it does not
    come with any GUI by default. This means we either need to tie in another application
    or web service, or stick to the command line to manage its data store. For many
    applications, this isn't a big deal, but we want to keep this project as compartmentalized
    and provincial as possible to limit points of failure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他NoSQL解决方案相比，Mongo的一个缺点是它默认没有任何GUI。这意味着我们要么需要绑定另一个应用程序或Web服务，要么坚持使用命令行来管理其数据存储。对于许多应用程序来说，这并不是什么大问题，但我们希望尽可能地将这个项目分隔和局部化，以限制故障点。
- en: Mongo has also gotten a bit of a bad rap as it pertains to fault tolerance and
    data loss, but this is equally true of many NoSQL solutions. In addition, it's
    in many ways a feature of a fast data store—so often catastrophe recovery comes
    at the expense of speed and performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Mongo在容错性和数据丢失方面也有点名声不佳，但这同样适用于许多NoSQL解决方案。此外，这在很多方面是一个快速数据存储的特性——因此，灾难恢复往往是以速度和性能为代价的。
- en: It's also fair to say this is a generally overblown critique of Mongo and its
    peers. Can something bad happen with Mongo? Sure. Can it also happen with a managed
    Oracle-based system? Absolutely. Mitigating massive failures in this realm is
    more the responsibility of a systems administrator than the software itself, which
    can only provide the tools necessary to design such a contingency plan.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说这是对Mongo及其同行的一种普遍夸大的批评。Mongo会出现问题吗？当然会。管理的基于Oracle的系统也会出现问题吗？当然会。在这个领域减轻大规模故障更多地是系统管理员的责任，而不是软件本身，后者只能提供设计这样的应急计划所需的工具。
- en: All that said, we'll want something with a quick and highly-available management
    interface, so Mongo is out for our requirements but could easily be plugged into
    this solution if those are less highly valued.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们希望有一个快速和高可用的管理界面，因此Mongo不符合我们的要求，但如果这些要求不那么受重视，它可以很容易地插入到这个解决方案中。
- en: Redis
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is another key/value data store and, as of recently, took the number one
    spot in terms of total usage and popularity. In an ideal Redis world, an entire
    dataset is held in memory. Given the size of many datasets, this isn't always
    possible; however, coupled with Redis' ability to eschew durability, this can
    result in some very high performance results when used in concurrent applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是另一个键/值数据存储，最近成为了总使用量和受欢迎程度方面的第一名。在理想的Redis世界中，整个数据集都保存在内存中。鉴于许多数据集的大小，这并不总是可能的；然而，结合Redis的能力来摒弃持久性，当在并发应用程序中使用时，这可能会产生一些非常高性能的结果。
- en: Another useful feature of Redis is the fact that it can inherently hold different
    data structures. While you can make abstractions of such data by unmarshalling
    JSON objects/arrays in Mongo (and other data stores), Redis can handle sets, strings,
    arrays, and hashes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的另一个有用的特性是它可以固有地保存不同的数据结构。虽然你可以通过在Mongo（和其他数据存储）中取消编组JSON对象/数组来对这些数据进行抽象，但Redis可以处理集合、字符串、数组和哈希。
- en: 'There are two major accepted libraries for Redis in Go:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，有两个主要被接受的Redis库：
- en: '**Radix**: This is a minimalist client that''s barebones, quick, and dirty.
    To install Radix, run the following command:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Radix**：这是一个极简主义的客户端，简洁、快速而简单。要安装Radix，请运行以下命令：'
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Redigo**: This more robust and a bit more complex, but provides a lot of
    the more intricate functionality that we''ll probably not need for this project.
    To install Redigo, run the following command:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redigo**：这更加强大，稍微复杂一些，但提供了许多更复杂的功能，我们可能在这个项目中不需要。要安装Redigo，请运行以下命令：'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ll now see a quick example of getting a user''s name from the data store
    of `Users` in Redis using Redigo:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一个快速的例子，使用Redigo从Redis的`Users`数据存储中获取用户的名称：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Looking over this, you might note some non programmatic access syntax, such
    as the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查这一点时，您可能会注意到一些非程序访问语法，例如以下内容：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is indeed one of the reasons why Redis in Go will not be our choice for
    this project—both libraries here provide an almost API-level access to certain
    features with some more detailed built-ins for direct interaction. The `Do` command
    passes straight queries directly to Redis, which is fine if you need to use the
    library, but a somewhat inelegant solution across the board.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是为什么Go中的Redis不会成为我们这个项目的选择之一的原因之一——这两个库都提供了对某些功能的几乎API级别的访问，还提供了一些更详细的内置功能，用于直接交互。`Do`命令直接将查询传递给Redis，如果需要使用库，这是可以的，但在整体上是一个不太优雅的解决方案。
- en: Both the libraries play very nicely with the concurrent features of Go, and
    you'll have no problem making non-blocking networked calls to Redis through either
    of them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个库都非常好地与Go的并发特性配合，您在通过它们之一进行非阻塞网络调用到Redis时不会遇到任何问题。
- en: It's worth noting that Redis only supports an experimental build for Windows,
    so this is mostly for use on *nix platforms. The port that does exist comes from
    Microsoft and can be found at [https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Redis仅支持Windows的实验性构建，因此这主要用于*nix平台。现有的端口来自Microsoft，可以在[https://github.com/MSOpenTech/redis](https://github.com/MSOpenTech/redis)找到。
- en: Tiedot
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tiedot
- en: If you've worked a lot with NoSQL, then the preceding engines all likely seemed
    very familiar to you. Redis, Couch, Mongo, and so on are all virtual stalwarts
    in what is a relatively young technology.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经大量使用NoSQL，那么前面提到的引擎对您来说可能都很熟悉。Redis、Couch、Mongo等在这个相对年轻的技术中都是虚拟的支柱。
- en: Tiedot, on the other hand, probably isn't as familiar. We're including it here
    only because the document store itself is written in Go directly. Document manipulation
    is handled primarily through a web interface, and it's a JSON document store like
    several other NoSQL solutions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Tiedot可能不太熟悉。我们在这里包括它，只是因为文档存储本身是直接用Go编写的。文档操作主要通过Web界面处理，它是一个像其他几种NoSQL解决方案一样的JSON文档存储。
- en: 'As document access and handling is governed via HTTP, there''s a somewhat counterintuitive
    workflow, shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文档访问和处理是通过HTTP进行的，所以工作流程有点违反直觉，如下所示：
- en: '![Tiedot](img/00048.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Tiedot](img/00048.jpeg)'
- en: As that introduces a potential spot for latency or failure, this keeps from
    being an ideal solution for our application here. Keep in mind that this is also
    a feature of a few of the other solutions mentioned earlier, but since Tiedot
    is written in Go, it would be significantly easier to connect to it and read/modify
    data using a package. While this book was being written, this did not exist.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这引入了潜在的延迟或故障点，这使得它不是我们这里的理想解决方案。请记住，这也是之前提到的一些其他解决方案的特点，但由于Tiedot是用Go编写的，因此连接到它并使用包读取/修改数据将会更容易。在撰写本书时，这是不存在的。
- en: Unlike other HTTP- or REST-focused alternatives such as CouchDB, Tiedot relies
    on URL endpoints to dictate actions, not HTTP methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与CouchDB等基于HTTP或REST的替代方案不同，Tiedot依赖于URL端点来指示操作，而不是HTTP方法。
- en: 'You can see in the following code how we might handle something like this through
    standard libraries:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码中看到我们如何通过标准库处理类似的事情：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This, simply, is a data structure for any record you wish to bring into your
    Go application via data selects, queries, and so on. You saw this in our previous
    usage of SQL servers themselves, and this is not any different:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，这是您希望通过数据选择、查询等方式引入到Go应用程序中的任何记录的数据结构。您在我们之前使用SQL服务器本身时看到了这一点，这并没有什么不同：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While not as robust, powerful, or scalable as many of its peers, Tiedot is certainly
    worth playing with or, better yet, contributing to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不像许多同行那样健壮、强大或可扩展，Tiedot肯定值得玩耍，或者更好的是，值得贡献。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find Tiedot at [https://github.com/HouzuoGuo/tiedot](https://github.com/HouzuoGuo/tiedot).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/HouzuoGuo/tiedot](https://github.com/HouzuoGuo/tiedot)找到Tiedot。
- en: CouchDB
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CouchDB
- en: CouchDB from Apache Incubator is another one of the big boys in NoSQL big data.
    As a JSON document store, CouchDB offers a great deal of flexibility when it comes
    to your data store approach.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Apache孵化器的CouchDB是NoSQL大数据中的另一个重要角色。作为一个JSON文档存储，CouchDB在数据存储方法方面提供了很大的灵活性。
- en: CouchDB supports ACID semantics and can do so concurrently, which provides a
    great deal of performance benefit if one is bound to those properties. In our
    application, that reliance on ACID consistency is somewhat flexible. By design,
    it will be failure tolerant and recoverable, but for many, even the possibility
    of data loss with recoverability is still considered catastrophic.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB支持ACID语义，并且可以同时执行，这在某种程度上提供了很大的性能优势。在我们的应用程序中，对ACID一致性的依赖性是相对灵活的。从设计上讲，它将是容错和可恢复的，但对于许多人来说，即使是可恢复的数据丢失的可能性仍然被认为是灾难性的。
- en: 'Interfacing with CouchDB happens via HTTP, which means there is no need for
    a direct implementation or Go SQL database hook to use it. Interestingly, CouchDB
    uses HTTP header syntax to manipulate data, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与CouchDB的接口是通过HTTP进行的，这意味着不需要直接实现或Go SQL数据库钩子来使用它。有趣的是，CouchDB使用HTTP头语法来操作数据，如下所示：
- en: '**GET**: This represents read operations'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：这代表读取操作'
- en: '**PUT**: This represents creation operations'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：这代表创建操作'
- en: '**DELETE**: This represents deletion and update operations'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：这代表删除和更新操作'
- en: These are, of course, what the header methods were initially intended in HTTP
    1.1, but so much of the Web has focused on GET/POST that these tend to get lost
    in the fray.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些最初是在HTTP 1.1中的标头方法，但是Web的很多部分都集中在GET/POST上，这些方法往往会在混乱中失去。
- en: 'Couch also comes with a convenient web interface for management. When CouchDB
    is running, you''re able to access this at `http://localhost:5984/_utils/`, as
    shown in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Couch还配备了一个方便的Web界面进行管理。当CouchDB运行时，您可以在`http://localhost:5984/_utils/`访问它，如下面的截图所示：
- en: '![CouchDB](img/00049.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![CouchDB](img/00049.jpeg)'
- en: That said, there are a few wrappers that provide a level of abstraction for
    some of the more complicated and advanced features.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有一些包装器为一些更复杂和高级的功能提供了一定程度的抽象。
- en: Cassandra
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cassandra
- en: Cassandra, another Apache Foundation project, isn't technically a NoSQL solution
    but a clustered (or cluster-able) database management platform.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Cassandra，作为Apache基金会的另一个项目，技术上并不是一个NoSQL解决方案，而是一个集群（或可集群化）的数据库管理平台。
- en: Like many NoSQL applications, there is a limitation in the traditional query
    methods in Cassandra, for example, subqueries and joins are generally not supported.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多NoSQL应用程序一样，Cassandra的传统查询方法存在一些限制，例如，通常不支持子查询和连接。
- en: We're mentioning it here primarily because of its focus on distributed computing
    as well as the ability to programmatically tune whether data consistency or performance
    is more important. Much of that is equally expressed in our solution, Couchbase,
    but Cassandra has a deeper focus on distributed data stores.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提到它主要是因为它专注于分布式计算以及以编程方式调整数据一致性或性能的能力。Couchbase同样也表达了很多这些内容，但Cassandra更加专注于分布式数据存储。
- en: Cassandra does, however, support a subset of SQL that will make it far more
    familiar to developers who have dabbled in MySQL, PostgreSQL, or the ilk. Cassandra's
    built-in handling of highly concurrent integrations makes it in many ways ideal
    for Go, although it is an overkill for this project.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Cassandra支持一部分SQL，这将使它对于那些涉足过MySQL、PostgreSQL或类似数据库的开发人员来说更加熟悉。Cassandra对高并发集成的内置处理在很多方面使其对Go来说是理想的，尽管对于这个项目来说有些过度。
- en: The most noteworthy library to interface with Cassandra is gocql, which focuses
    on speed and a clean connection to the Cassandra connection. Should you choose
    to use Cassandra in lieu of Couchbase (or other NoSQL), you'll find a lot of the
    methods that can be simply replaced.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与Cassandra进行接口的最值得注意的库是gocql，它专注于速度和与Cassandra连接的清晰性。如果您选择使用Cassandra而不是Couchbase（或其他NoSQL），您会发现许多方法可以简单地替换。
- en: 'The following is an example of connecting to a cluster and writing a simple
    query:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是连接到集群并编写简单查询的示例：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Cassandra may be an ideal solution if you plan on rapidly scaling this application,
    distributing it widely, or are far more comfortable with SQL than data store /
    JSON access.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划快速扩展此应用程序、广泛分发它，或者对SQL比数据存储/JSON访问更熟悉，那么Cassandra可能是一个理想的解决方案。
- en: For our purposes here, SQL is not a requirement and we value speed over anything
    else, including durability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，SQL不是必需的，我们更看重速度，包括耐久性在内。
- en: Couchbase
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Couchbase
- en: Couchbase is a relative newcomer in the field, but it was built by people from
    both CouchDB and memcached. Written in Erlang, it shares many of the same focuses
    on concurrency, speed, and non-blocking behavior that we've come to expect from
    a great deal of our Go applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase是该领域的一个相对新手，但它是由CouchDB和memcached的开发人员构建的。它是用Erlang编写的，与我们期望从我们的许多Go应用程序中获得的并发性、速度和非阻塞行为有许多相同的关注点。
- en: Couchbase also supports a lot of the other features we've discussed in the previous
    chapters, including easy distribution-based installations, tuneable ACID compliance,
    and low-resource consumption.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase还支持我们在前几章中讨论的许多其他功能，包括易于分发的安装、可调的ACID兼容性和低资源消耗。
- en: One caveat on Couchbase is it doesn't run well (or at all) on some lower-resourced
    machines or VMs. Indeed, 64-bit installations require an absolute minimum of 4
    GB of memory and four cores, so forget about launching this on tiny, small, or
    even medium-grade instances or older hardware.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase的一个缺点是它在一些资源较低的机器或虚拟机上运行效果不佳（或根本无法运行）。确实，64位安装至少需要4GB内存和四个核心，所以不要指望在小型、中小型实例或旧硬件上启动它。
- en: While most NoSQL solutions presented here (or elsewhere) offer performance benefits
    over their SQL counterparts in general, Couchbase has done very well against its
    peers in the NoSQL realm itself.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里（或其他地方）提出的大多数NoSQL解决方案通常比它们的SQL对应方案具有性能优势，但Couchbase在NoSQL领域中表现得非常出色。
- en: Couchbase, such as CouchDB, comes with a web-based graphical interface that
    simplifies the process of both setup and maintenance. Among the advanced features
    that you'll have available to you in the setup include your base bucket storage
    engine (Couchbase or memcached), your automated backup process (replicas), and
    the level of read-write concurrency.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase，如CouchDB一样，配备了一个基于Web的图形界面，简化了设置和维护的过程。在设置中，您可以使用的高级功能包括基本存储引擎（Couchbase或memcached）、自动备份过程（副本）和读写并发级别。
- en: 'In addition to configuration and management tools, it also presents some real-time
    monitoring in the web dashboard as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置和管理工具，它还在Web仪表板中提供了一些实时监控，如下面的截图所示：
- en: '![Couchbase](img/00050.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Couchbase](img/00050.jpeg)'
- en: While not a replacement for full-scale server management (what happens when
    this server goes down and you have no insight), it's incredibly helpful to know
    exactly where your resources are going without needing a command-line method or
    an external tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不能完全替代完整的服务器管理（当服务器宕机时，你没有洞察力会发生什么），但知道你的资源究竟去了哪里，而不需要命令行方法或外部工具，这非常有帮助。
- en: The vernacular in Couchbase varies slightly, as it tends to in many of these
    solutions. The nascent desire to slightly separate NoSQL from stodgy old SQL solutions
    will pop its head from time to time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Couchbase中的术语略有不同，就像在许多这些解决方案中一样。对稍微将NoSQL与古板的旧SQL解决方案分开的渴望会不时地显现出来。
- en: With Couchbase, a database is a data bucket and records are documents. However,
    views, an old transactional SQL standby, bring a bit of familiarity to the table.
    The big takeaway here is views allow you to create more complex queries using
    simple JavaScript, in some cases, replicating otherwise difficult features such
    as joins, unions, and pagination.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Couchbase中，数据库是一个数据存储桶，记录是文档。然而，视图，作为一个旧的事务性SQL标准，为表格带来了一些熟悉的东西。这里的重点是，视图允许您使用简单的JavaScript创建更复杂的查询，在某些情况下，可以复制否则难以实现的功能，如连接、联合和分页。
- en: Each view created in Couchbase becomes an HTTP access point. So a view that
    you name `select_all_files` will be accessible via a URL such as `http://localhost:8092/file_manager/_design/select_all_files/_view/Select%20All%20Files?connection_timeout=60000&limit=10&skip=0`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Couchbase中创建的每个视图都成为一个HTTP访问点。因此，您命名为`select_all_files`的视图将可以通过URL访问，例如`http://localhost:8092/file_manager/_design/select_all_files/_view/Select%20All%20Files?connection_timeout=60000&limit=10&skip=0`。
- en: The most noteworthy Couchbase interface library is Go Couchbase, which, if nothing
    else, might save you from some of the redundancy of making HTTP calls in your
    code to access CouchDB.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最值得注意的Couchbase接口库是Go Couchbase，如果没有其他选择，它可能会让您免受在代码中进行HTTP调用以访问CouchDB的冗余之苦。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go Couchbase can be found at [https://github.com/couchbaselabs/go-couchbase](https://github.com/couchbaselabs/go-couchbase).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Go Couchbase可以在[https://github.com/couchbaselabs/go-couchbase](https://github.com/couchbaselabs/go-couchbase)找到。
- en: 'Go Couchbase makes interfacing with Couchbase through a Go abstraction simple
    and powerful. The following code connects and grabs information about the various
    data pools in a lean way that feels native:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Go Couchbase通过Go抽象简单而强大地与Couchbase进行接口交互。以下代码以精简的方式连接并获取有关各种数据池的信息，感觉自然而简单：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting up our data store
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的数据存储
- en: After installing Couchbase, you can access its administration panel by default
    at localhost and port 8091.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Couchbase后，默认情况下可以通过localhost和端口8091访问其管理面板。
- en: You'll be given an opportunity to set up an administrator, other IPs to connect
    (if you're joining a cluster), and general data store design.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您将有机会设置管理员、其他IP连接（如果加入集群）和一般数据存储设计。
- en: 'After that, you''ll need to set up a bucket, which is what we''ll use to store
    all information about individual files. Here is what the interface for the bucket
    setup looks like:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要设置一个存储桶，这是我们用来存储有关单个文件的所有信息的地方。以下是存储桶设置的界面：
- en: '![Setting up our data store](img/00051.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的数据存储](img/00051.jpeg)'
- en: In our example, we're working on a single machine, so replicas (also known as
    replication in database vernacular) are not supported. We've named it `file_manager`,
    but this can obviously be called anything that makes sense.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们正在使用单台机器，因此不支持副本（在数据库术语中也称为复制）。我们将其命名为`file_manager`，但这显然可以称为任何有意义的东西。
- en: We're also keeping our data usage pretty low—there's no need for much more than
    256 MB of memory when we're storing file operations and logging older ones. In
    other words, we're not necessarily concerned with keeping the modification history
    of `test.txt` in memory forever.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将保持数据使用量相当低——当我们存储文件操作并记录较旧的操作时，没有必要使用超过256MB的内存。换句话说，我们并不一定关心将`test.txt`的修改历史永远保存在内存中。
- en: We'll also stick with Couchbase for a storage engine equivalent, although you
    can flip back and forth with memcache(d) without much noticeable change.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Couchbase作为存储引擎等效，尽管您可以在memcache(d)之间来回切换而几乎没有注意到的变化。
- en: 'Let''s start by creating a seed document: one we''ll delete later, but that
    will represent the schema of our data store. We can create this document with
    an arbitrary JSON structured object, as shown in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个种子文档：稍后我们将删除的文档，但它将代表我们的数据存储架构。我们可以使用任意的JSON结构化对象创建此文档，如下面的屏幕截图所示：
- en: '![Setting up our data store](img/00052.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的数据存储](img/00052.jpeg)'
- en: 'Since everything stored in this data store should be valid JSON, we can mix
    and match strings, integers, bools, arrays, and objects. This affords us some
    flexibility in what data we''re using. The following is an example document:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储在此数据存储中的所有内容都应为有效的JSON，因此我们可以混合和匹配字符串、整数、布尔值、数组和对象。这为我们提供了一些在使用数据时的灵活性。以下是一个示例文档：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Monitoring filesystem changes
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视文件系统更改
- en: When it came to NoSQL options, we had a vast variety of solutions at our disposal.
    This is not the case when it comes to applications that monitor filesystem changes.
    While Linux flavors have a fairly good built-in solution in inotify, this does
    restrict the portability of the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择NoSQL选项时，我们可以选择各种各样的解决方案。但是当涉及到监视文件系统更改的应用程序时，情况就不一样了。虽然Linux版本在inotify中有一个相当不错的内置解决方案，但这限制了应用程序的可移植性。
- en: So it's incredibly helpful that a cross-platform library for handling this exists
    in Chris Howey's fsnotify.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Chris Howey的fsnotify中存在一个处理这个问题的跨平台库非常有帮助。
- en: Fsnotify works on Linux, OSX, and Windows and allows us to detect when files
    in any given directory are created, deleted, modified, or renamed, which is more
    than enough for our purposes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Fsnotify在Linux、OSX和Windows上运行，并允许我们检测任何给定目录中的文件何时被创建、删除、修改或重命名，这对我们的目的来说已经足够了。
- en: Implementing fsnotify couldn't be easier, either. Best of all it's all non-blocking,
    so if we throw the listener behind a goroutine, we can have this run as part of
    the primary server application code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 实现fsnotify也非常容易。最重要的是，它都是非阻塞的，因此，如果我们将监听器放在goroutine后面，我们可以将其作为主服务器应用程序代码的一部分运行。
- en: 'The following code shows a simple directory listener:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个简单的目录监听器：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Managing logfiles
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理日志文件
- en: Like many basic features in a developer's toolbox, Go provides a fairly complete
    solution built-in for logging. It handles many of the basics, such as creating
    timestamp-marked log items and saving to disk or to console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多开发人员工具箱中的基本功能一样，Go提供了一个相当完整的内置日志记录解决方案。它处理许多基本功能，例如创建时间戳标记的日志项并保存到磁盘或控制台。
- en: One thing the basic package misses out on is built-in formatting and log rotation,
    which are key requirements for our file manager application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本包遗漏的一件事是内置格式化和日志轮换，这是我们的文件管理器应用程序的关键要求。
- en: Remember that key requirements for our application include the ability to work
    seamlessly in our concurrent environment and be ready to scale to a distributed
    network if need be. This is where the fine **log4go** application comes in handy.
    Log4go allows logging to file, console, and memory and handles log rotation inherently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的应用程序的关键要求包括能够在并发环境中无缝工作，并且在需要时能够准备好扩展到分布式网络。这就是fine **log4go**应用程序派上用场的地方。Log4go允许将日志记录到文件、控制台和内存，并且内在地处理日志轮换。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Log4go can be found at [https://code.google.com/p/log4go/](https://code.google.com/p/log4go/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Log4go可以在[https://code.google.com/p/log4go/](https://code.google.com/p/log4go/)找到。
- en: 'To install Log4go, run the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Log4go，请运行以下命令：
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating a logfile that handles warnings, notices, debug information, and critical
    errors is simple and appending log rotation to that is similarly simple, as shown
    in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个处理警告、通知、调试信息和关键错误的日志文件很简单，并且将日志轮换附加到其中同样简单，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Handling configuration files
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理配置文件
- en: When it comes to configuration files and parsing them, you have a lot of options,
    from simple to complicated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理配置文件和解析它们时，您有很多选择，从简单到复杂。
- en: We could, of course, simply store what we want in JSON, but that format is a
    little tricky to work directly for humans—it will require escaping characters
    and so on, which makes it vulnerable to errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以简单地将所需内容存储为JSON，但是该格式对于人类来说有点棘手——它需要转义字符等，这使其容易出现错误。
- en: 'Instead, we''ll keep things simple by using a standard `ini config` file library
    in gcfg, which handles `gitconfig` files and traditional, old school `.ini` format,
    as shown in the following code snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用gcfg中的标准`ini config`文件库来简化事务，该库处理`gitconfig`文件和传统的旧式`.ini`格式，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find gcfg at [https://code.google.com/p/gcfg/](https://code.google.com/p/gcfg/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://code.google.com/p/gcfg/](https://code.google.com/p/gcfg/)找到gcfg。
- en: 'Essentially, this library takes the values of a config file and pushes them
    into a struct in Go. An example of how we''ll do that is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，该库获取配置文件的值并将其推送到Go中的结构体中。我们将如何做到这一点的示例如下：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Detecting file changes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测文件更改
- en: Now we need to focus on our file listener. You may recall this is the part of
    the application that will accept client connections from our web server and our
    backup application and announce any changes to files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要专注于我们的文件监听器。您可能还记得，这是应用程序的一部分，它将接受来自我们的Web服务器和备份应用程序的客户端连接，并通知文件的任何更改。
- en: 'The basic flow of this part is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分的基本流程如下：
- en: Listen for changes to files in a goroutine.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中监听文件的更改。
- en: Accept connections and add to the pool in a goroutine.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine中接受连接并添加到池中。
- en: If any changes are detected, announce them to the entire pool.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果检测到任何更改，则向整个池通知它们。
- en: All three happen concurrently, and the first and the third can happen without
    any connections in the pool, although we assume there will be a connection that
    is always on with both our web server and our backup application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个操作同时发生，第一个和第三个操作可以在池中没有任何连接的情况下发生，尽管我们假设总会有一个连接始终与我们的Web服务器和备份应用程序保持连接。
- en: 'Another critical role the file listener will fulfill is analyzing the directory
    on first load and reconciling it with our data store in Couchbase. Since the Go
    Couchbase library handles the get, update, and add operations, we won''t need
    any custom views. In the following code, we''ll examine the file listener process
    and show how we listen on a folder for changes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监听器将扮演的另一个关键角色是在首次加载时分析目录并将其与我们在Couchbase中的数据存储进行协调。由于Go Couchbase库处理获取、更新和添加操作，我们不需要任何自定义视图。在下面的代码中，我们将检查文件监听器进程，并展示如何监听文件夹的更改：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we''ve declared our shared folder as well as a connecting `Client` struct.
    In this application, `Client` is either a web listener or a backup listener, and
    we''ll pass messages in one direction using the following JSON-encoded structure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了我们的共享文件夹以及一个连接的`Client`结构。在这个应用程序中，`Client`可以是Web监听器或备份监听器，并且我们将使用以下JSON编码结构单向传递消息：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If this looks familiar, it could be because it's also the example document format
    we set up initially.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很熟悉，那可能是因为这也是我们最初设置的示例文档格式。
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not familiar with the syntactical sugar expressed earlier, these are
    known as struct tags. A tag is just a piece of additional metadata that can be
    applied to a struct field for key/value lookups via the `reflect` package. In
    this case, they're used to map our struct fields to JSON fields.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对之前表达的语法糖不熟悉，这些被称为结构标签。标签只是可以应用于结构字段的附加元数据，以便通过`reflect`包进行键/值查找。在这种情况下，它们用于将我们的结构字段映射到JSON字段。
- en: 'Let''s first look at our overall `Message struct`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们的整体`Message struct`：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We compartmentalize our file into a message, which alerts our other two processes
    of changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的文件分成一个消息，用于通知我们的其他两个进程发生了更改：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a somewhat unreliable method to generate a hash reference to a file
    and will fail if a filename changes. However, it allows us to keep track of files
    that are created, deleted, or modified.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相对不可靠的方法，用于生成文件的哈希引用，如果文件名更改，它将失败。但是，它允许我们跟踪创建、删除或修改的文件。
- en: Sending changes to clients
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向客户端发送更改
- en: 'Here is the broadcast message that goes to all existing connections. We pass
    along our JSON-encoded `Message` struct with the current version, the current
    location, and the hash for reference. Our other servers will then react accordingly:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发送到所有现有连接的广播消息。我们传递我们的JSON编码的`Message`结构，其中包含当前版本、当前位置和用于参考的哈希。然后我们的其他服务器将相应地做出反应：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our backup server will create a copy of that file with the `.[VERSION]` extension
    in the backup folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的备份服务器将在备份文件夹中创建带有`.[VERSION]`扩展名的文件副本。
- en: 'Our web server will simply alert the user via our web interface that the file
    has changed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web服务器将通过Web界面简单地通知用户文件已更改：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Does this code look familiar? We''ve taken almost our exact chat server `Client`
    handler and brought it over here nearly intact:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来熟悉吗？我们几乎完全复制了我们的聊天服务器`Client`处理程序并将其几乎完整地带到这里：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `removeFile` function does one thing only and that''s removing the file
    from our Couchbase data store. As it''s reactive, we don''t need to do anything
    on the file-server side because the file is already deleted. Also, there''s no
    need to delete any backups, as this allows us to recover. Next, let''s look at
    our function that updates an existing file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeFile`函数只做一件事，那就是从我们的Couchbase数据存储中删除文件。由于它是反应性的，我们不需要在文件服务器端做任何事情，因为文件已经被删除。此外，没有必要删除任何备份，因为这使我们能够恢复。接下来，让我们看一下我们的更新现有文件的函数：'
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This function essentially overwrites any values in Couchbase with new ones,
    copying an existing `File` struct and changing the `LastModified` date:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数本质上是用新值覆盖Couchbase中的任何值，复制现有的`File`结构并更改`LastModified`日期：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we react to any changes to the filesystem in our watched directory. We
    aren''t reacting to renames, but you can handle those as well. Here''s how we''d
    approach the general `updateFile` function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对我们监视目录中文件系统的任何更改做出反应。我们不会对重命名做出反应，但您也可以处理这些情况。以下是我们处理一般`updateFile`函数的方法：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Checking records against Couchbase
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查与Couchbase的记录
- en: 'When it comes to checking for existing records against Couchbase, we check
    whether a hash exists in our Couchbase bucket. If it doesn''t, we create it. If
    it does, we do nothing. To handle shutdowns more robustly, we should also ingest
    existing records into our application. The code for doing this is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查现有记录与Couchbase相对时，我们检查Couchbase存储桶中是否存在哈希。如果不存在，我们就创建它。如果存在，我们就什么都不做。为了更可靠地处理关闭，我们还应该将现有记录纳入我们的应用程序。执行此操作的代码如下：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, `main()` handles setting up our connections and goroutines, including
    a file watcher, our TCP server, and connecting to Couchbase.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main()`处理设置我们的连接和goroutines，包括文件监视器、TCP服务器和连接到Couchbase。
- en: Now, let's look at another step in the whole process where we will automatically
    create backups of our modified files.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下整个过程中的另一个步骤，我们将自动创建我们修改后的文件的备份。
- en: Backing up our files
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份我们的文件
- en: Since we're sending our commands on the wire, so to speak, our backup process
    needs to listen on that wire and respond with any changes. Given that modifications
    will be sent via localhost, we should have minimal latency on both the network
    and the file side.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以说是在网络上发送我们的命令，因此我们的备份过程需要在该网络上侦听并响应任何更改。鉴于修改将通过本地主机发送，我们在网络和文件方面应该有最小的延迟。
- en: 'We''ll also return some information as to what happened with the file, although
    at this point we''re not doing much with that information. The code for this is
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将返回一些关于文件发生了什么的信息，尽管在这一点上我们对这些信息并没有做太多处理。这段代码如下：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that we have a separate folder for backups, in this case, on a Windows
    machine. If we happen to accidentally use the same directory, we run the risk
    of infinitely duplicating and backing up files. In the following code snippet,
    we''ll look at the `Message` struct itself and the `backup` function, the core
    of this part of the application:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有一个专门用于备份的文件夹，在这种情况下是在Windows机器上。如果我们不小心使用相同的目录，我们就有无限复制和备份文件的风险。在下面的代码片段中，我们将看一下`Message`结构本身和`backup`函数，这是应用程序的这一部分的核心：
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is our basic file operation. Go doesn''t have a one-step copy function;
    instead you need to create a file and then copy the contents of another file into
    it with `io.Copy`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的基本文件操作。Go语言没有一步复制函数；相反，您需要创建一个文件，然后使用`io.Copy`将另一个文件的内容复制到其中：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code is nearly verbatim for our chat client''s `listen()` function, except
    that we take the contents of the streamed JSON data, unmarshal it, and convert
    it to a `Message{}` struct and then a `File{}` struct. Finally, let''s look at
    the `main` function and TCP initialization:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎与我们的聊天客户端的`listen()`函数一字不差，只是我们获取了流式JSON数据的内容，对其进行解组，并将其转换为`Message{}`结构，然后是`File{}`结构。最后，让我们看一下`main`函数和TCP初始化：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Designing our web interface
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的Web界面
- en: To interact with the filesystem, we'll want an interface that displays all of
    the current files with the version, last modified time, and alerts to changes,
    and allows drag-and-drop creation/replacement of files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与文件系统交互，我们需要一个接口，显示所有当前文件的版本、最后修改时间和更改的警报，并允许拖放创建/替换文件。
- en: Getting a list of files will be simple, as we'll grab them directly from our
    `file_manager` Couchbase bucket. Changes will be sent through our file manager
    process via TCP, which will trigger an API call, illuminating changes to the file
    for our web user.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件列表将很简单，因为我们将直接从我们的`file_manager` Couchbase存储桶中获取它们。更改将通过我们的文件管理器进程通过TCP发送，这将触发API调用，为我们的Web用户显示文件的更改。
- en: 'A few of the methods we''ve used here are duplicates of the ones we used in
    the backup process and could certainly benefit from some consolidation; still,
    the following is the code for the web server, which allows uploads and shows notifications
    for changes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的一些方法是备份过程中使用的方法的副本，并且肯定可以从一些整合中受益；但以下是Web服务器的代码，它允许上传并显示更改的通知：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This, for example, is the same `File` struct we use in both the file listener
    and the backup process:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我们在文件监听器和备份过程中使用的相同的`File`结构：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our `Page` struct represents generic web data that gets converted into corresponding
    variables for our web page''s template:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Page`结构表示通用的Web数据，这些数据被转换为我们网页模板的相应变量：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our `md5` hashing method is the same for this application as well. It''s worth
    noting that we derive a `lastChecked` variable that is the Unix-style timestamp
    from each time we get a signal from our file listener. We use this to compare
    with file changes on the client side to know whether to alert the user on the
    Web. Let''s now look at the `updateFile` function for the web interface:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`md5`哈希方法在这个应用程序中也是一样的。 值得注意的是，我们从文件监听器接收到信号时，会派生一个`lastChecked`变量，该变量是Unix风格的时间戳。
    我们使用这个变量来与客户端文件更改进行比较，以便知道是否在Web上提醒用户。 现在让我们来看看Web界面的`updateFile`函数：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the same function as our backup process, except that instead of creating
    a duplicate file, we simply overwrite our internal `File` struct to allow it represent
    its updated `LastModified` value when the `/api` is next called. And as with our
    last example, let''s check out the `listen()` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们备份过程中的函数相同，只是不是创建一个重复的文件，而是简单地覆盖我们的内部`File`结构，以便在下次调用`/api`时表示其更新的`LastModified`值。
    和我们上一个例子一样，让我们来看看`listen()`函数：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is where our message is read, unmarshalled, and set to its hashed map''s
    key. This will create a file if it doesn''t exist or update our current one if
    it does. Next, we''ll look at the `main()` function, which sets up our application
    and the web server:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们读取消息，解组并将其设置为其哈希映射的键。 如果文件不存在，这将创建一个文件，如果存在，则更新我们当前的文件。 接下来，我们将看看`main()`函数，它设置了我们的应用程序和Web服务器：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In our web server component, `main()` takes control of setting up the connection
    to the file listener and Couchbase and creating a web server (with related routing).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Web服务器组件中，`main()`负责设置与文件监听器和Couchbase的连接，并创建一个Web服务器（带有相关路由）。
- en: 'If you upload a file by dragging it to the **Drop files here to upload** box,
    within a few seconds you''ll see that the file is noted as changed in the web
    interface, as shown in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过将文件拖放到**拖放文件到此处上传**框中上传文件，几秒钟后，您将看到文件在Web界面中被标记为已更改，如下面的屏幕截图所示：
- en: '![Designing our web interface](img/00053.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们的Web界面](img/00053.jpeg)'
- en: We haven't included the code for the client side of the web interface; the key
    points, though, are retrieval via an API. We used a JavaScript library called
    `Dropzone.js` that allows a drag-and-drop upload, and jQuery for API access.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有包括Web界面客户端的代码； 但关键点是通过API检索。 我们使用了一个名为`Dropzone.js`的JavaScript库，它允许拖放上传，并使用jQuery进行API访问。
- en: Reverting a file's history – command line
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复文件的历史记录-命令行
- en: 'The final component we''d like to add to this application suite is a command-line
    file revision process. We can keep this one fairly simple, as we know where a
    file is located, where its backups are located, and how to replace the former
    with the latter. As with before, we have some global configuration variables and
    a replication of our `generateHash()` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加到这个应用程序套件中的最后一个组件是一个命令行文件修订过程。 我们可以将这个过程保持相当简单，因为我们知道文件的位置，备份的位置以及如何用后者替换前者。
    与以前一样，我们有一些全局配置变量和我们的`generateHash()`函数的复制：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This application accepts up to two parameters:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序最多接受两个参数：
- en: '`-f`: This denotes the filename'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：这表示文件名'
- en: '`-r`: This denotes the number of versions to revert'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：这表示要恢复的版本数'
- en: Note that this itself creates a new version and thus a backup, so -2 would need
    to become -3, and then -6, and so on in order to continuously back up recursively.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这本身会创建一个新版本，因此需要将-2变为-3，然后为-6，以此类推，以便连续递归备份。
- en: 'As an example, if you wished to revert `example.txt` back three versions, you
    could use the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您希望将`example.txt`还原为三个版本之前，您可以使用以下命令：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using Go in daemons and as a service
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在守护程序和服务中使用Go
- en: A minor note on running something like this part of the application—you'll ideally
    wish to keep these applications as active, restartable services instead of standalone,
    manually executed background processes. Doing so will allow you to keep the application
    active and manage its life from external or server processes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于运行这部分应用程序的一点说明——理想情况下，您希望将这些应用程序保持为活动的、可重启的服务，而不是独立的、手动执行的后台进程。 这样做将允许您保持应用程序的活动状态，并从外部或服务器进程管理其生命周期。
- en: This sort of application suite would be best suited on a Linux box (or boxes)
    and managed with a daemon manager such as daemontools or Ubuntu's built-in Upstart
    service. The reason for this is that any long-term downtime can result in lost
    data and inconsistency. Even storing file data details in the memory (Couchbase
    and memcached) provides a vulnerability for lost data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种应用程序套件最适合在Linux框（或框）上，并使用像daemontools或Ubuntu内置的Upstart服务这样的守护程序管理器进行管理。 这样做的原因是，任何长期的停机时间都可能导致数据丢失和不一致。
    即使在内存中存储文件数据细节（Couchbase和memcached）也会对数据丢失构成漏洞。
- en: Checking the health of our server
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查我们服务器的健康状况
- en: 'Of the many ways to check general server health, we''re in a good position
    here without having to build our own system, thanks in great part to Couchbase
    itself. If you visit the Couchbase web admin, under your cluster, server, and
    bucket views, clicking on any will present some real-time statistics, as shown
    in the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方法可以检查一般服务器的健康状况，我们在这里处于一个良好的位置，而无需构建我们自己的系统，这在很大程度上要归功于Couchbase本身。 如果您访问Couchbase
    Web管理界面，在您的集群、服务器和存储桶视图下，单击任何一个都会显示一些实时统计信息，如下面的屏幕截图所示：
- en: '![Checking the health of our server](img/00054.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![检查我们服务器的健康状况](img/00054.jpeg)'
- en: These areas are also available via REST if you wish to include them in the application
    to make your logging and error handling more comprehensive.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将这些区域包含在应用程序中，以使您的日志记录和错误处理更全面，这些区域也可以通过REST访问。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a top to bottom application suite that is highly concurrent, ropes
    in several third-party libraries, and mitigates potential failures with logging
    and catastrophe recovery.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个从头到尾高度并发的应用程序套件，涉及多个第三方库，并通过记录和灾难恢复来减轻潜在的故障。
- en: At this point, you should have no issue constructing a complex package of software
    with a focus on maintaining concurrency, reliability, and performance in Go. Our
    file monitoring application can be easily modified to do more, use alternative
    services, or scale to a robust, distributed environment.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，你应该没有问题构建一个以Go语言为重点，专注于维护并发性、可靠性和性能的复杂软件包。我们的文件监控应用程序可以很容易地修改以执行更多操作，使用替代服务，或者扩展到一个强大的分布式环境。
- en: In the next chapter, we'll take a closer look at testing our concurrency and
    throughput, explore the value of panic and recover, as well as dealing with logging
    vital information and errors in a safe, concurrent manner in Go.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更仔细地测试我们的并发性和吞吐量，探讨panic和recover的价值，以及在Go语言中以安全并发的方式处理记录重要信息和错误。
